commit 9686a77dcb640ace74f923c1f0f7f7307f79edfe
Author: Thomas Kriechbaumer <thomas@kriechbaumer.name>
Date:   Sun Aug 16 20:02:18 2015 +0200

    http2: implement request target

diff --git a/netlib/http/cookies.py b/netlib/http/cookies.py
index b77e3503..78b03a83 100644
--- a/netlib/http/cookies.py
+++ b/netlib/http/cookies.py
@@ -23,8 +23,7 @@ variants. Serialization follows RFC6265.
     http://tools.ietf.org/html/rfc2965
 """
 
-# TODO
-# - Disallow LHS-only Cookie values
+# TODO: Disallow LHS-only Cookie values
 
 
 def _read_until(s, start, term):
diff --git a/netlib/http/http2/protocol.py b/netlib/http/http2/protocol.py
index c27b4e9e..eacbd2d8 100644
--- a/netlib/http/http2/protocol.py
+++ b/netlib/http/http2/protocol.py
@@ -80,13 +80,39 @@ class HTTP2Protocol(semantics.ProtocolMixin):
 
         timestamp_end = time.time()
 
+        authority = headers.get_first(':authority', '')
+        method = headers.get_first(':method', 'GET')
+        scheme = headers.get_first(':scheme', 'https')
+        path = headers.get_first(':path', '/')
+        host = None
+        port = None
+
+        if path == '*' or path.startswith("/"):
+            form_in = "relative"
+        elif method == 'CONNECT':
+            form_in = "authority"
+            if ":" in authority:
+                host, port = authority.split(":", 1)
+            else:
+                host = authority
+        else:
+            form_in = "absolute"
+            # FIXME: verify if path or :host contains what we need
+            scheme, host, port, _ = utils.parse_url(path)
+
+        if host is None:
+            host = 'localhost'
+        if port is None:
+            port = 80 if scheme == 'http' else 443
+        port = int(port)
+
         request = http.Request(
-            "relative",  # TODO: use the correct value
-            headers.get_first(':method', 'GET'),
-            headers.get_first(':scheme', 'https'),
-            headers.get_first(':host', 'localhost'),
-            443,  # TODO: parse port number from host?
-            headers.get_first(':path', '/'),
+            form_in,
+            method,
+            scheme,
+            host,
+            port,
+            path,
             (2, 0),
             headers,
             body,
@@ -324,6 +350,7 @@ class HTTP2Protocol(semantics.ProtocolMixin):
         return [frm.to_bytes() for frm in frms]
 
     def _receive_transmission(self, include_body=True):
+        # TODO: include_body is not respected
         body_expected = True
 
         stream_id = 0
diff --git a/test/http/http2/test_protocol.py b/test/http/http2/test_protocol.py
index 8c38bebd..fc0fe487 100644
--- a/test/http/http2/test_protocol.py
+++ b/test/http/http2/test_protocol.py
@@ -289,7 +289,6 @@ class TestCreateBody():
 
 class TestReadRequest(tservers.ServerTestBase):
     class handler(tcp.BaseHandler):
-
         def handle(self):
             self.wfile.write(
                 b'000003010400000001828487'.decode('hex'))
@@ -306,11 +305,83 @@ class TestReadRequest(tservers.ServerTestBase):
         protocol = HTTP2Protocol(c, is_server=True)
         protocol.connection_preface_performed = True
 
-        resp = protocol.read_request()
+        req = protocol.read_request()
 
-        assert resp.stream_id
-        assert resp.headers.lst == [[u':method', u'GET'], [u':path', u'/'], [u':scheme', u'https']]
-        assert resp.body == b'foobar'
+        assert req.stream_id
+        assert req.headers.lst == [[u':method', u'GET'], [u':path', u'/'], [u':scheme', u'https']]
+        assert req.body == b'foobar'
+
+
+class TestReadRequestRelative(tservers.ServerTestBase):
+    class handler(tcp.BaseHandler):
+        def handle(self):
+            self.wfile.write(
+                b'00000c0105000000014287d5af7e4d5a777f4481f9'.decode('hex'))
+            self.wfile.flush()
+
+    ssl = True
+
+    def test_asterisk_form_in(self):
+        c = tcp.TCPClient(("127.0.0.1", self.port))
+        c.connect()
+        c.convert_to_ssl()
+        protocol = HTTP2Protocol(c, is_server=True)
+        protocol.connection_preface_performed = True
+
+        "OPTIONS *"
+        req = protocol.read_request()
+
+        assert req.form_in == "relative"
+        assert req.method == "OPTIONS"
+        assert req.path == "*"
+
+
+class TestReadRequestAbsolute(tservers.ServerTestBase):
+    class handler(tcp.BaseHandler):
+        def handle(self):
+            self.wfile.write(
+                b'00001901050000000182448d9d29aee30c0e492c2a1170426366871c92585422e085'.decode('hex'))
+            self.wfile.flush()
+
+    ssl = True
+
+    def test_absolute_form_in(self):
+        c = tcp.TCPClient(("127.0.0.1", self.port))
+        c.connect()
+        c.convert_to_ssl()
+        protocol = HTTP2Protocol(c, is_server=True)
+        protocol.connection_preface_performed = True
+
+        req = protocol.read_request()
+
+        assert req.form_in == "absolute"
+        assert req.scheme == "http"
+        assert req.host == "address"
+        assert req.port == 22
+
+
+class TestReadRequestConnect(tservers.ServerTestBase):
+    class handler(tcp.BaseHandler):
+        def handle(self):
+            self.wfile.write(
+                b'00001b0105000000014287bdab4e9c17b7ff44871c92585422e08541871c92585422e085'.decode('hex'))
+            self.wfile.flush()
+
+    ssl = True
+
+    def test_connect(self):
+        c = tcp.TCPClient(("127.0.0.1", self.port))
+        c.connect()
+        c.convert_to_ssl()
+        protocol = HTTP2Protocol(c, is_server=True)
+        protocol.connection_preface_performed = True
+
+        req = protocol.read_request()
+
+        assert req.form_in == "authority"
+        assert req.method == "CONNECT"
+        assert req.host == "address"
+        assert req.port == 22
 
 
 class TestReadResponse(tservers.ServerTestBase):

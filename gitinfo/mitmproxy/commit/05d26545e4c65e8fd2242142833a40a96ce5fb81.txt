commit 05d26545e4c65e8fd2242142833a40a96ce5fb81
Author: Thomas Kriechbaumer <thomas@kriechbaumer.name>
Date:   Fri Aug 21 10:26:28 2015 +0200

    adapt netlib changes

diff --git a/libmproxy/protocol/http.py b/libmproxy/protocol/http.py
index 4472cb2a..1b168569 100644
--- a/libmproxy/protocol/http.py
+++ b/libmproxy/protocol/http.py
@@ -41,7 +41,7 @@ def send_connect_request(conn, host, port, update_state=True):
     protocol = http1.HTTP1Protocol(conn)
 
     conn.send(protocol.assemble(upstream_request))
-    resp = HTTPResponse.from_protocol(protocol, upstream_request.method)
+    resp = HTTPResponse.from_protocol(protocol, upstream_request)
     if resp.status_code != 200:
         raise proxy.ProxyError(resp.status_code,
                                "Cannot establish SSL " +
@@ -177,7 +177,7 @@ class HTTPHandler(ProtocolHandler):
                 # Only get the headers at first...
                 flow.response = HTTPResponse.from_protocol(
                     self.c.server_conn.protocol,
-                    flow.request.method,
+                    flow.request,
                     body_size_limit=self.c.config.body_size_limit,
                     include_body=False,
                 )
@@ -760,7 +760,7 @@ class RequestReplayThread(threading.Thread):
                 self.flow.server_conn.protocol = http1.HTTP1Protocol(self.flow.server_conn)
                 self.flow.response = HTTPResponse.from_protocol(
                     self.flow.server_conn.protocol,
-                    r.method,
+                    r,
                     body_size_limit=self.config.body_size_limit,
                 )
             if self.channel:
diff --git a/libmproxy/protocol/http_wrappers.py b/libmproxy/protocol/http_wrappers.py
index e41d65d6..f91b936c 100644
--- a/libmproxy/protocol/http_wrappers.py
+++ b/libmproxy/protocol/http_wrappers.py
@@ -352,12 +352,12 @@ class HTTPResponse(MessageMixin, semantics.Response):
     def from_protocol(
             self,
             protocol,
-            request_method,
+            request,
             include_body=True,
             body_size_limit=None
     ):
         resp = protocol.read_response(
-            request_method,
+            request,
             body_size_limit,
             include_body=include_body
         )
diff --git a/libmproxy/protocol2/http.py b/libmproxy/protocol2/http.py
index a2dfc428..f093f7c5 100644
--- a/libmproxy/protocol2/http.py
+++ b/libmproxy/protocol2/http.py
@@ -37,7 +37,7 @@ class Http1Layer(Layer):
     def read_from_server(self, request):
         return HTTPResponse.from_protocol(
             self.server_protocol,
-            request.method,
+            request,
             body_size_limit=self.config.body_size_limit,
             include_body=False,
         )
@@ -80,7 +80,7 @@ class Http2Layer(Layer):
     def read_from_server(self, request):
         response = HTTPResponse.from_protocol(
             self.server_protocol,
-            request.method,
+            request,
             body_size_limit=self.config.body_size_limit,
             include_body=False,
         )
diff --git a/test/test_protocol_http.py b/test/test_protocol_http.py
index c6a9159c..940d6c7a 100644
--- a/test/test_protocol_http.py
+++ b/test/test_protocol_http.py
@@ -4,6 +4,7 @@ from cStringIO import StringIO
 from mock import MagicMock
 
 from libmproxy.protocol.http import *
+import netlib.http
 from netlib import odict
 from netlib.http import http1
 from netlib.http.semantics import CONTENT_MISSING
@@ -27,19 +28,19 @@ class TestHTTPResponse:
              "\r\n"
 
         protocol = mock_protocol(s)
-        r = HTTPResponse.from_protocol(protocol, "GET")
+        r = HTTPResponse.from_protocol(protocol, netlib.http.EmptyRequest(method="GET"))
         assert r.status_code == 200
         assert r.content == "content"
-        assert HTTPResponse.from_protocol(protocol, "GET").status_code == 204
+        assert HTTPResponse.from_protocol(protocol, netlib.http.EmptyRequest(method="GET")).status_code == 204
 
         protocol = mock_protocol(s)
         # HEAD must not have content by spec. We should leave it on the pipe.
-        r = HTTPResponse.from_protocol(protocol, "HEAD")
+        r = HTTPResponse.from_protocol(protocol, netlib.http.EmptyRequest(method="HEAD"))
         assert r.status_code == 200
         assert r.content == ""
         tutils.raises(
             "Invalid server response: 'content",
-            HTTPResponse.from_protocol, protocol, "GET"
+            HTTPResponse.from_protocol, protocol, netlib.http.EmptyRequest(method="GET")
         )
 
 

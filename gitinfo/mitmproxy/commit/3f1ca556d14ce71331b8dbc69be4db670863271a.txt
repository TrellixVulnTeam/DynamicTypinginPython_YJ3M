commit 3f1ca556d14ce71331b8dbc69be4db670863271a
Author: Maximilian Hils <git@maximilianhils.com>
Date:   Sun Sep 20 18:12:55 2015 +0200

    python3++

diff --git a/.travis.yml b/.travis.yml
index 7e18176c..00f8b4db 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -21,6 +21,7 @@ matrix:
         - nosetests --with-cov --cov-report term-missing test/test_utils.py
         - nosetests --with-cov --cov-report term-missing test/test_encoding.py
         - nosetests --with-cov --cov-report term-missing test/test_odict.py
+        - nosetests --with-cov --cov-report term-missing test/test_certutils.py
     - python: pypy
     - python: pypy
       env: OPENSSL=1.0.2
diff --git a/netlib/certutils.py b/netlib/certutils.py
index 9193b757..df793537 100644
--- a/netlib/certutils.py
+++ b/netlib/certutils.py
@@ -5,6 +5,8 @@ import time
 import datetime
 import itertools
 import ipaddress
+
+import sys
 from pyasn1.type import univ, constraint, char, namedtype, tag
 from pyasn1.codec.der.decoder import decode
 from pyasn1.error import PyAsn1Error
@@ -184,7 +186,7 @@ class CertStore(object):
             with open(path, "wb") as f:
                 f.write(DEFAULT_DHPARAM)
 
-        bio = OpenSSL.SSL._lib.BIO_new_file(path, b"r")
+        bio = OpenSSL.SSL._lib.BIO_new_file(path.encode(sys.getfilesystemencoding()), b"r")
         if bio != OpenSSL.SSL._ffi.NULL:
             bio = OpenSSL.SSL._ffi.gc(bio, OpenSSL.SSL._lib.BIO_free)
             dh = OpenSSL.SSL._lib.PEM_read_bio_DHparams(
@@ -318,10 +320,9 @@ class CertStore(object):
         potential_keys.append((commonname, tuple(sans)))
 
         name = next(
-            itertools.ifilter(
-                lambda key: key in self.certs,
-                potential_keys),
-            None)
+            filter(lambda key: key in self.certs, potential_keys),
+            None
+        )
         if name:
             entry = self.certs[name]
         else:
diff --git a/netlib/tcp.py b/netlib/tcp.py
index 707e11e0..6dcc8c72 100644
--- a/netlib/tcp.py
+++ b/netlib/tcp.py
@@ -76,7 +76,7 @@ class SSLKeyLogger(object):
                     d = os.path.dirname(self.filename)
                     if not os.path.isdir(d):
                         os.makedirs(d)
-                    self.f = open(self.filename, "ab")
+                    self.f = open(self.filename, "a")
                     self.f.write("\r\n")
                 client_random = connection.client_random().encode("hex")
                 masterkey = connection.master_key().encode("hex")
@@ -184,7 +184,7 @@ class Reader(_FileLike):
         """
             If length is -1, we read until connection closes.
         """
-        result = ''
+        result = b''
         start = time.time()
         while length == -1 or length > 0:
             if length == -1 or length > self.BLOCKSIZE:
diff --git a/netlib/wsgi.py b/netlib/wsgi.py
index 8a98884a..fba9f388 100644
--- a/netlib/wsgi.py
+++ b/netlib/wsgi.py
@@ -1,8 +1,11 @@
 from __future__ import (absolute_import, print_function, division)
-import cStringIO
+from io import BytesIO
 import urllib
 import time
 import traceback
+
+import six
+
 from . import http, tcp
 
 
@@ -58,7 +61,7 @@ class WSGIAdaptor(object):
         environ = {
             'wsgi.version': (1, 0),
             'wsgi.url_scheme': flow.request.scheme,
-            'wsgi.input': cStringIO.StringIO(flow.request.body or ""),
+            'wsgi.input': BytesIO(flow.request.body or b""),
             'wsgi.errors': errsoc,
             'wsgi.multithread': True,
             'wsgi.multiprocess': False,
@@ -91,17 +94,17 @@ class WSGIAdaptor(object):
             Make a best-effort attempt to write an error page. If headers are
             already sent, we just bung the error into the page.
         """
-        c = """
+        c = b"""
             <html>
                 <h1>Internal Server Error</h1>
                 <pre>%s"</pre>
             </html>
-        """ % s
+        """.strip() % s
         if not headers_sent:
-            soc.write("HTTP/1.1 500 Internal Server Error\r\n")
-            soc.write("Content-Type: text/html\r\n")
-            soc.write("Content-Length: %s\r\n" % len(c))
-            soc.write("\r\n")
+            soc.write(b"HTTP/1.1 500 Internal Server Error\r\n")
+            soc.write(b"Content-Type: text/html\r\n")
+            soc.write(b"Content-Length: %s\r\n" % len(c))
+            soc.write(b"\r\n")
         soc.write(c)
 
     def serve(self, request, soc, **env):
@@ -114,14 +117,14 @@ class WSGIAdaptor(object):
 
         def write(data):
             if not state["headers_sent"]:
-                soc.write("HTTP/1.1 %s\r\n" % state["status"])
+                soc.write(b"HTTP/1.1 %s\r\n" % state["status"])
                 headers = state["headers"]
                 if 'server' not in headers:
                     headers["Server"] = self.sversion
                 if 'date' not in headers:
                     headers["Date"] = date_time_string()
-                soc.write(str(headers))
-                soc.write("\r\n")
+                soc.write(bytes(headers))
+                soc.write(b"\r\n")
                 state["headers_sent"] = True
             if data:
                 soc.write(data)
@@ -131,7 +134,7 @@ class WSGIAdaptor(object):
             if exc_info:
                 try:
                     if state["headers_sent"]:
-                        raise exc_info[0], exc_info[1], exc_info[2]
+                        six.reraise(*exc_info)
                 finally:
                     exc_info = None
             elif state["status"]:
@@ -140,7 +143,7 @@ class WSGIAdaptor(object):
             state["headers"] = http.Headers(headers)
             return write
 
-        errs = cStringIO.StringIO()
+        errs = BytesIO()
         try:
             dataiter = self.app(
                 self.make_environ(request, errs, **env), start_response
@@ -148,7 +151,7 @@ class WSGIAdaptor(object):
             for i in dataiter:
                 write(i)
             if not state["headers_sent"]:
-                write("")
+                write(b"")
         except Exception as e:
             try:
                 s = traceback.format_exc()
diff --git a/test/test_certutils.py b/test/test_certutils.py
index b44879f6..fc91609e 100644
--- a/test/test_certutils.py
+++ b/test/test_certutils.py
@@ -36,10 +36,10 @@ class TestCertStore:
     def test_create_explicit(self):
         with tutils.tmpdir() as d:
             ca = certutils.CertStore.from_store(d, "test")
-            assert ca.get_cert("foo", [])
+            assert ca.get_cert(b"foo", [])
 
             ca2 = certutils.CertStore.from_store(d, "test")
-            assert ca2.get_cert("foo", [])
+            assert ca2.get_cert(b"foo", [])
 
             assert ca.default_ca.get_serial_number(
             ) == ca2.default_ca.get_serial_number()
@@ -47,11 +47,11 @@ class TestCertStore:
     def test_create_tmp(self):
         with tutils.tmpdir() as d:
             ca = certutils.CertStore.from_store(d, "test")
-            assert ca.get_cert("foo.com", [])
-            assert ca.get_cert("foo.com", [])
-            assert ca.get_cert("*.foo.com", [])
+            assert ca.get_cert(b"foo.com", [])
+            assert ca.get_cert(b"foo.com", [])
+            assert ca.get_cert(b"*.foo.com", [])
 
-            r = ca.get_cert("*.foo.com", [])
+            r = ca.get_cert(b"*.foo.com", [])
             assert r[1] == ca.default_privatekey
 
     def test_add_cert(self):
@@ -61,18 +61,18 @@ class TestCertStore:
     def test_sans(self):
         with tutils.tmpdir() as d:
             ca = certutils.CertStore.from_store(d, "test")
-            c1 = ca.get_cert("foo.com", ["*.bar.com"])
-            ca.get_cert("foo.bar.com", [])
+            c1 = ca.get_cert(b"foo.com", [b"*.bar.com"])
+            ca.get_cert(b"foo.bar.com", [])
             # assert c1 == c2
-            c3 = ca.get_cert("bar.com", [])
+            c3 = ca.get_cert(b"bar.com", [])
             assert not c1 == c3
 
     def test_sans_change(self):
         with tutils.tmpdir() as d:
             ca = certutils.CertStore.from_store(d, "test")
-            ca.get_cert("foo.com", ["*.bar.com"])
-            cert, key, chain_file = ca.get_cert("foo.bar.com", ["*.baz.com"])
-            assert "*.baz.com" in cert.altnames
+            ca.get_cert(b"foo.com", [b"*.bar.com"])
+            cert, key, chain_file = ca.get_cert(b"foo.bar.com", [b"*.baz.com"])
+            assert b"*.baz.com" in cert.altnames
 
     def test_overrides(self):
         with tutils.tmpdir() as d:
@@ -81,14 +81,14 @@ class TestCertStore:
             assert not ca1.default_ca.get_serial_number(
             ) == ca2.default_ca.get_serial_number()
 
-            dc = ca2.get_cert("foo.com", ["sans.example.com"])
+            dc = ca2.get_cert(b"foo.com", [b"sans.example.com"])
             dcp = os.path.join(d, "dc")
             f = open(dcp, "wb")
             f.write(dc[0].to_pem())
             f.close()
-            ca1.add_cert_file("foo.com", dcp)
+            ca1.add_cert_file(b"foo.com", dcp)
 
-            ret = ca1.get_cert("foo.com", [])
+            ret = ca1.get_cert(b"foo.com", [])
             assert ret[0].serial == dc[0].serial
 
 
diff --git a/test/test_socks.py b/test/test_socks.py
index 65a0f0eb..f2fb9b98 100644
--- a/test/test_socks.py
+++ b/test/test_socks.py
@@ -23,7 +23,7 @@ def test_client_greeting_assert_socks5():
     msg = socks.ClientGreeting.from_file(raw)
     tutils.raises(socks.SocksError, msg.assert_socks5)
 
-    raw = tutils.treader(b"HTTP/1.1 200 OK" + " " * 100)
+    raw = tutils.treader(b"HTTP/1.1 200 OK" + b" " * 100)
     msg = socks.ClientGreeting.from_file(raw)
     try:
         msg.assert_socks5()
diff --git a/test/test_tcp.py b/test/test_tcp.py
index 615900ce..dc0efeb0 100644
--- a/test/test_tcp.py
+++ b/test/test_tcp.py
@@ -1,5 +1,5 @@
-import cStringIO
-import Queue
+from io import BytesIO
+from six.moves import queue
 import time
 import socket
 import random
@@ -435,7 +435,7 @@ class TestSSLDisconnect(tservers.ServerTestBase):
         c.rfile.read(10)
         c.close()
         tutils.raises(TcpDisconnect, c.wfile.write, "foo")
-        tutils.raises(Queue.Empty, self.q.get_nowait)
+        tutils.raises(queue.Empty, self.q.get_nowait)
 
 
 class TestSSLHardDisconnect(tservers.ServerTestBase):
@@ -578,7 +578,7 @@ class TestTCPClient:
 class TestFileLike:
 
     def test_blocksize(self):
-        s = cStringIO.StringIO("1234567890abcdefghijklmnopqrstuvwxyz")
+        s = BytesIO(b"1234567890abcdefghijklmnopqrstuvwxyz")
         s = tcp.Reader(s)
         s.BLOCKSIZE = 2
         assert s.read(1) == "1"
@@ -589,7 +589,7 @@ class TestFileLike:
         assert d.startswith("abc") and d.endswith("xyz")
 
     def test_wrap(self):
-        s = cStringIO.StringIO("foobar\nfoobar")
+        s = BytesIO(b"foobar\nfoobar")
         s.flush()
         s = tcp.Reader(s)
         assert s.readline() == "foobar\n"
@@ -598,18 +598,18 @@ class TestFileLike:
         assert s.isatty
 
     def test_limit(self):
-        s = cStringIO.StringIO("foobar\nfoobar")
+        s = BytesIO(b"foobar\nfoobar")
         s = tcp.Reader(s)
         assert s.readline(3) == "foo"
 
     def test_limitless(self):
-        s = cStringIO.StringIO("f" * (50 * 1024))
+        s = BytesIO(b"f" * (50 * 1024))
         s = tcp.Reader(s)
         ret = s.read(-1)
         assert len(ret) == 50 * 1024
 
     def test_readlog(self):
-        s = cStringIO.StringIO("foobar\nfoobar")
+        s = BytesIO(b"foobar\nfoobar")
         s = tcp.Reader(s)
         assert not s.is_logging()
         s.start_log()
@@ -626,7 +626,7 @@ class TestFileLike:
         tutils.raises(ValueError, s.get_log)
 
     def test_writelog(self):
-        s = cStringIO.StringIO()
+        s = BytesIO()
         s = tcp.Writer(s)
         s.start_log()
         assert s.is_logging()
@@ -636,7 +636,7 @@ class TestFileLike:
         assert s.get_log() == "xx"
 
     def test_writer_flush_error(self):
-        s = cStringIO.StringIO()
+        s = BytesIO()
         s = tcp.Writer(s)
         o = mock.MagicMock()
         o.flush = mock.MagicMock(side_effect=socket.error)
@@ -644,7 +644,7 @@ class TestFileLike:
         tutils.raises(TcpDisconnect, s.flush)
 
     def test_reader_read_error(self):
-        s = cStringIO.StringIO("foobar\nfoobar")
+        s = BytesIO(b"foobar\nfoobar")
         s = tcp.Reader(s)
         o = mock.MagicMock()
         o.read = mock.MagicMock(side_effect=socket.error)
@@ -652,14 +652,14 @@ class TestFileLike:
         tutils.raises(TcpDisconnect, s.read, 10)
 
     def test_reset_timestamps(self):
-        s = cStringIO.StringIO("foobar\nfoobar")
+        s = BytesIO(b"foobar\nfoobar")
         s = tcp.Reader(s)
         s.first_byte_timestamp = 500
         s.reset_timestamps()
         assert not s.first_byte_timestamp
 
     def test_first_byte_timestamp_updated_on_read(self):
-        s = cStringIO.StringIO("foobar\nfoobar")
+        s = BytesIO(b"foobar\nfoobar")
         s = tcp.Reader(s)
         s.read(1)
         assert s.first_byte_timestamp
@@ -668,7 +668,7 @@ class TestFileLike:
         assert s.first_byte_timestamp == expected
 
     def test_first_byte_timestamp_updated_on_readline(self):
-        s = cStringIO.StringIO("foobar\nfoobar\nfoobar")
+        s = BytesIO(b"foobar\nfoobar\nfoobar")
         s = tcp.Reader(s)
         s.readline()
         assert s.first_byte_timestamp
@@ -695,7 +695,7 @@ class TestFileLike:
         tutils.raises(TcpDisconnect, s.readline, 10)
 
     def test_reader_incomplete_error(self):
-        s = cStringIO.StringIO("foobar")
+        s = BytesIO(b"foobar")
         s = tcp.Reader(s)
         tutils.raises(TcpReadIncomplete, s.safe_read, 10)
 
diff --git a/test/test_wsgi.py b/test/test_wsgi.py
index e26e1413..856967af 100644
--- a/test/test_wsgi.py
+++ b/test/test_wsgi.py
@@ -1,4 +1,4 @@
-import cStringIO
+from io import BytesIO
 import sys
 from netlib import wsgi
 from netlib.http import Headers
@@ -41,7 +41,7 @@ class TestWSGI:
         f.request.host = "foo"
         f.request.port = 80
 
-        wfile = cStringIO.StringIO()
+        wfile = BytesIO()
         err = w.serve(f, wfile)
         assert ta.called
         assert not err
@@ -55,7 +55,7 @@ class TestWSGI:
         f = tflow()
         f.request.host = "foo"
         f.request.port = 80
-        wfile = cStringIO.StringIO()
+        wfile = BytesIO()
         w.serve(f, wfile)
         return wfile.getvalue()
 

commit 64285140f959eaa939c4cf35585cfe21cbf1a449
Author: Aldo Cortesi <aldo@nullcube.com>
Date:   Sun Feb 24 11:34:01 2013 +1300

    Test a difficult-to-trigger IOError, fix cert generation in test suite.

diff --git a/doc-src/howmitmproxy.html b/doc-src/howmitmproxy.html
index 6ea723cd..94c895d7 100644
--- a/doc-src/howmitmproxy.html
+++ b/doc-src/howmitmproxy.html
@@ -71,7 +71,7 @@ flow of requests and responses are completely opaque to the proxy.
 
 ## The MITM in mitmproxy
 
-This is where mitmproxy's fundamental trick comes in to play. The MITM in its
+This is where mitmproxy's fundamental trick comes into play. The MITM in its
 name stands for Man-In-The-Middle - a reference to the process we use to
 intercept and interfere with these theoretially opaque data streams. The basic
 idea is to pretend to be the server to the client, and pretend to be the client
diff --git a/test/test_server.py b/test/test_server.py
index a2c65275..9df88400 100644
--- a/test/test_server.py
+++ b/test/test_server.py
@@ -1,4 +1,5 @@
 import socket, time
+import mock
 from netlib import tcp
 from libpathod import pathoc
 import tutils, tservers
@@ -97,6 +98,14 @@ class TestHTTP(tservers.HTTPProxTest, SanityMixin):
         assert p.request("get:'%s':h'Connection'='close'"%response)
         tutils.raises("disconnect", p.request, "get:'%s'"%response)
 
+    def test_proxy_ioerror(self):
+        # Tests a difficult-to-trigger condition, where an IOError is raised
+        # within our read loop.
+        with mock.patch("libmproxy.proxy.ProxyHandler.read_request") as m:
+            m.side_effect = IOError("error!")
+            tutils.raises("empty reply", self.pathod, "304")
+
+
 
 class TestHTTPS(tservers.HTTPProxTest, SanityMixin):
     ssl = True
diff --git a/test/tservers.py b/test/tservers.py
index ae0bacf5..262536a7 100644
--- a/test/tservers.py
+++ b/test/tservers.py
@@ -63,7 +63,7 @@ class ProxTestBase:
         cls.server = libpathod.test.Daemon(ssl=cls.ssl)
         pconf = cls.get_proxy_config()
         config = proxy.ProxyConfig(
-            certfile=tutils.test_data.path("data/testkey.pem"),
+            cacert = tutils.test_data.path("data/serverkey.pem"),
             **pconf
         )
         tmaster = cls.masterclass(cls.tqueue, config)

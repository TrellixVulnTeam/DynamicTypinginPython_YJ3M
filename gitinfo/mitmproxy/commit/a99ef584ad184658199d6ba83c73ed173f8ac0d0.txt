commit a99ef584ad184658199d6ba83c73ed173f8ac0d0
Author: Thomas Kriechbaumer <thomas@kriechbaumer.name>
Date:   Sun Jan 24 23:16:50 2016 +0100

    reuse frame reading snippet

diff --git a/libmproxy/protocol/http2.py b/libmproxy/protocol/http2.py
index a6d1b73f..ff1726ae 100644
--- a/libmproxy/protocol/http2.py
+++ b/libmproxy/protocol/http2.py
@@ -206,12 +206,8 @@ class Http2Layer(Layer):
                 other_conn = self.server_conn if conn == self.client_conn.connection else self.client_conn
                 is_server = (conn == self.server_conn.connection)
 
-                field = source_conn.rfile.peek(3)
-                length = int(field.encode('hex'), 16)
-                raw_frame = source_conn.rfile.safe_read(9 + length)
-
                 with source_conn.h2.lock:
-                    events = source_conn.h2.receive_data(raw_frame)
+                    events = source_conn.h2.receive_data(utils.http2_read_frame(source_conn.rfile))
                     source_conn.send(source_conn.h2.data_to_send())
 
                     for event in events:
diff --git a/libmproxy/utils.py b/libmproxy/utils.py
index a697a637..94dbbca8 100644
--- a/libmproxy/utils.py
+++ b/libmproxy/utils.py
@@ -173,3 +173,9 @@ def safe_subn(pattern, repl, target, *args, **kwargs):
         need a better solution that is aware of the actual content ecoding.
     """
     return re.subn(str(pattern), str(repl), target, *args, **kwargs)
+
+def http2_read_frame(rfile):
+    field = rfile.peek(3)
+    length = int(field.encode('hex'), 16)
+    raw_frame = rfile.safe_read(9 + length)
+    return raw_frame

commit 735c79a2edb3b31a35ed3e484744807bb626ab77
Author: Thomas Kriechbaumer <thomas@kriechbaumer.name>
Date:   Mon Jan 25 19:41:22 2016 +0100

    increase coverage

diff --git a/.travis.yml b/.travis.yml
index e86a4117..ed6d8e11 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -52,7 +52,7 @@ before_script:
   - "openssl version -a"
 
 script:
-  - "py.test -n 4 --cov libmproxy"
+  - "py.test -n 4 -s --cov libmproxy"
 
 after_success:
   - coveralls
diff --git a/libmproxy/contentviews.py b/libmproxy/contentviews.py
index 80955b0f..c0652c18 100644
--- a/libmproxy/contentviews.py
+++ b/libmproxy/contentviews.py
@@ -35,12 +35,12 @@ from .contrib.wbxml.ASCommandResponse import ASCommandResponse
 try:
     import pyamf
     from pyamf import remoting, flex
-except ImportError:  # pragma nocover
+except ImportError:  # pragma no cover
     pyamf = None
 
 try:
     import cssutils
-except ImportError:  # pragma nocover
+except ImportError:  # pragma no cover
     cssutils = None
 else:
     cssutils.log.setLevel(logging.CRITICAL)
diff --git a/libmproxy/controller.py b/libmproxy/controller.py
index 712ab1d2..9a059856 100644
--- a/libmproxy/controller.py
+++ b/libmproxy/controller.py
@@ -56,7 +56,7 @@ class Channel:
             try:
                 # The timeout is here so we can handle a should_exit event.
                 g = m.reply.q.get(timeout=0.5)
-            except Queue.Empty:  # pragma: nocover
+            except Queue.Empty:  # pragma: no cover
                 continue
             return g
 
diff --git a/libmproxy/main.py b/libmproxy/main.py
index 655d573d..1c3cbf78 100644
--- a/libmproxy/main.py
+++ b/libmproxy/main.py
@@ -37,7 +37,7 @@ def get_server(dummy_server, options):
             sys.exit(1)
 
 
-def mitmproxy(args=None):  # pragma: nocover
+def mitmproxy(args=None):  # pragma: no cover
     from . import console
 
     check_pyopenssl_version()
@@ -68,7 +68,7 @@ def mitmproxy(args=None):  # pragma: nocover
         pass
 
 
-def mitmdump(args=None):  # pragma: nocover
+def mitmdump(args=None):  # pragma: no cover
     from . import dump
 
     check_pyopenssl_version()
@@ -103,7 +103,7 @@ def mitmdump(args=None):  # pragma: nocover
         pass
 
 
-def mitmweb(args=None):  # pragma: nocover
+def mitmweb(args=None):  # pragma: no cover
     from . import web
 
     check_pyopenssl_version()
diff --git a/libmproxy/protocol/base.py b/libmproxy/protocol/base.py
index 4eb034c0..40fcaf65 100644
--- a/libmproxy/protocol/base.py
+++ b/libmproxy/protocol/base.py
@@ -14,7 +14,7 @@ class _LayerCodeCompletion(object):
     Dummy class that provides type hinting in PyCharm, which simplifies development a lot.
     """
 
-    def __init__(self, **mixin_args):  # pragma: nocover
+    def __init__(self, **mixin_args):  # pragma: no cover
         super(_LayerCodeCompletion, self).__init__(**mixin_args)
         if True:
             return
diff --git a/libmproxy/protocol/http2.py b/libmproxy/protocol/http2.py
index 03408142..54e7572e 100644
--- a/libmproxy/protocol/http2.py
+++ b/libmproxy/protocol/http2.py
@@ -249,12 +249,13 @@ class Http2SingleStreamLayer(_HttpTransmissionLayer, threading.Thread):
 
         if path == '*' or path.startswith("/"):
             form_in = "relative"
-        elif method == 'CONNECT':
-            form_in = "authority"
-            if ":" in authority:
-                host, port = authority.split(":", 1)
-            else:
-                host = authority
+        elif method == 'CONNECT':  # pragma: no cover
+            # form_in = "authority"
+            # if ":" in authority:
+            #     host, port = authority.split(":", 1)
+            # else:
+            #     host = authority
+            raise NotImplementedError("CONNECT over HTTP/2 is not implemented.")
         else:
             form_in = "absolute"
             # FIXME: verify if path or :host contains what we need
diff --git a/libmproxy/protocol/tls.py b/libmproxy/protocol/tls.py
index af1a6055..ccae1661 100644
--- a/libmproxy/protocol/tls.py
+++ b/libmproxy/protocol/tls.py
@@ -349,7 +349,7 @@ class TlsLayer(Layer):
         layer = self.ctx.next_layer(self)
         layer()
 
-    def __repr__(self):
+    def __repr__(self):  # pragma: no cover
         if self._client_tls and self._server_tls:
             return "TlsLayer(client and server)"
         elif self._client_tls:
diff --git a/libmproxy/proxy/server.py b/libmproxy/proxy/server.py
index 750cb1a4..d208cff5 100644
--- a/libmproxy/proxy/server.py
+++ b/libmproxy/proxy/server.py
@@ -103,9 +103,9 @@ class ConnectionHandler(object):
             return Socks5Proxy(root_context)
         elif mode == "regular":
             return HttpProxy(root_context)
-        elif callable(mode):  # pragma: nocover
+        elif callable(mode):  # pragma: no cover
             return mode(root_context)
-        else:  # pragma: nocover
+        else:  # pragma: no cover
             raise ValueError("Unknown proxy mode: %s" % mode)
 
     def handle(self):
diff --git a/test/test_protocol_http2.py b/test/test_protocol_http2.py
index a7e8978a..e72113c4 100644
--- a/test/test_protocol_http2.py
+++ b/test/test_protocol_http2.py
@@ -122,6 +122,10 @@ class TestHttp2(tservers.ProxTestBase):
                 if isinstance(event, h2.events.StreamEnded):
                     done = True
 
+        h2_conn.close_connection()
+        client.wfile.write(h2_conn.data_to_send())
+        client.wfile.flush()
+
         self.server.teardown_class()
 
         assert len(self.master.state.flows) == 1

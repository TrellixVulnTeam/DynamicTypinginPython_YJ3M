commit c00ae41486de06192865f8539da0f00985a16a90
Author: Aldo Cortesi <aldo@nullcube.com>
Date:   Sat Oct 25 19:50:48 2014 +1300

    Add a memoize argument to prevent playing the same pattern twice
    
    Also remove addition of Date header, which makes this non-deterministic

diff --git a/libpathod/cmdline.py b/libpathod/cmdline.py
index f80b7aae..fe5eed68 100644
--- a/libpathod/cmdline.py
+++ b/libpathod/cmdline.py
@@ -34,6 +34,14 @@ def go_pathoc():
         metavar = "HOST:PORT",
         help="Issue an HTTP CONNECT to connect to the specified host."
     )
+    parser.add_argument(
+        "-m", dest='memo', action="store_true", default=False,
+        help="""
+            Remember specs, and never play the same one twice. Note that this
+            means requests have to be rendered in memory, which means that large
+            generated data can cause issues.
+        """
+    )
     parser.add_argument(
         "-n", dest='repeat', default=1, type=int, metavar="N",
         help='Repeat N times. If 0 repeat for ever.'
diff --git a/libpathod/language.py b/libpathod/language.py
index d8f201db..56cbc18b 100644
--- a/libpathod/language.py
+++ b/libpathod/language.py
@@ -819,20 +819,6 @@ class _Message(object):
                             ValueLiteral(request_host)
                         )
                     )
-            else:
-                if not utils.get_header("Date", self.headers):
-                    tokens.append(
-                        Header(
-                            ValueLiteral("Date"),
-                            ValueLiteral(
-                                formatdate(
-                                    timeval=None,
-                                    localtime=False,
-                                    usegmt=True
-                                )
-                            )
-                        )
-                    )
         intermediate = self.__class__(tokens)
         return self.__class__([i.resolve(intermediate, settings) for i in tokens])
 
diff --git a/libpathod/pathoc.py b/libpathod/pathoc.py
index 02d0c06d..0ff02b01 100644
--- a/libpathod/pathoc.py
+++ b/libpathod/pathoc.py
@@ -1,5 +1,6 @@
 import sys
 import os
+import hashlib
 import random
 from netlib import tcp, http, certutils
 import netlib.utils
@@ -148,9 +149,6 @@ class Pathoc(tcp.TCPClient):
 
             Returns True if we have a non-ignored response.
         """
-        if explain:
-            r = r.freeze(self.settings, self.address.host)
-
         resp, req = None, None
         if showreq:
             self.wfile.start_log()
@@ -223,10 +221,15 @@ class Pathoc(tcp.TCPClient):
 
 
 def main(args):
+    memo = set([])
     try:
         cnt = 0
         while 1:
             cnt += 1
+            if args.random:
+                playlist = [random.choice(args.requests)]
+            else:
+                playlist = args.requests
             p = Pathoc(
                 (args.host, args.port),
                 ssl=args.ssl,
@@ -235,6 +238,21 @@ def main(args):
                 clientcert=args.clientcert,
                 ciphers=args.ciphers
             )
+            if args.explain or args.memo:
+                playlist = [
+                    i.freeze(p.settings, p.address.host) for i in playlist
+                ]
+            if args.memo:
+                newlist = []
+                for spec in playlist:
+                    h = hashlib.sha256(spec.spec()).digest()
+                    if h not in memo:
+                        memo.add(h)
+                        newlist.append(spec)
+                playlist = newlist
+            if not playlist:
+                continue
+
             try:
                 p.connect(args.connect_to)
             except (tcp.NetLibError, PathocError), v:
@@ -242,10 +260,6 @@ def main(args):
                 sys.exit(1)
             if args.timeout:
                 p.settimeout(args.timeout)
-            if args.random:
-                playlist = [random.choice(args.requests)]
-            else:
-                playlist = args.requests
             for spec in playlist:
                 ret = p.print_request(
                     spec,

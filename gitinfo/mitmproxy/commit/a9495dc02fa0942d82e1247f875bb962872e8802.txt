commit a9495dc02fa0942d82e1247f875bb962872e8802
Author: Aldo Cortesi <aldo@nullcube.com>
Date:   Fri Jun 15 09:20:10 2012 +1200

    Refactor test suite to make room for transparent mode tests.

diff --git a/libmproxy/proxy.py b/libmproxy/proxy.py
index ea38b1e8..fa8d1062 100644
--- a/libmproxy/proxy.py
+++ b/libmproxy/proxy.py
@@ -34,7 +34,8 @@ class ProxyError(Exception):
 
 
 class ProxyConfig:
-    def __init__(self, certfile = None, cacert = None, clientcerts = None, cert_wait_time=0, upstream_cert=False, body_size_limit = None, reverse_proxy=None):
+    def __init__(self, certfile = None, cacert = None, clientcerts = None, cert_wait_time=0, upstream_cert=False, body_size_limit = None, reverse_proxy=None, transparent_mode=None):
+        assert not (reverse_proxy and transparent_mode)
         self.certfile = certfile
         self.cacert = cacert
         self.clientcerts = clientcerts
@@ -43,6 +44,7 @@ class ProxyConfig:
         self.upstream_cert = upstream_cert
         self.body_size_limit = body_size_limit
         self.reverse_proxy = reverse_proxy
+        self.transparent_mode = transparent_mode
 
 
 def read_headers(fp):
@@ -239,7 +241,7 @@ class FileLike:
 
     def flush(self):
         pass
-    
+
     def read(self, length):
         result = ''
         while len(result) < length:
@@ -488,7 +490,9 @@ class ProxyHandler(SocketServer.StreamRequestHandler):
         if line == "":
             return None
 
-        if self.config.reverse_proxy:
+        if self.config.transparent_mode:
+            pass
+        elif self.config.reverse_proxy:
             scheme, host, port = self.config.reverse_proxy
             method, path, httpversion = parse_init_http(line)
             headers = read_headers(self.rfile)
diff --git a/test/test_server.py b/test/test_server.py
index 296333d8..e54d3559 100644
--- a/test/test_server.py
+++ b/test/test_server.py
@@ -11,28 +11,32 @@ import tutils
     for a 200 response.
 """
 
-class Sanity(tutils.ProxTest):
+class SanityMixin:
     def test_http(self):
         assert self.pathod("304").status_code == 304
         assert self.log()
 
     def test_large(self):
-        assert len(self.pathod("200:b@500k").content) == 1024*500
+        assert len(self.pathod("200:b@50k").content) == 1024*50
 
 
-class TestHTTP(Sanity):
+class TestHTTP(tutils.HTTPProxTest, SanityMixin):
     pass
 
 
-class TestHTTPS(Sanity):
+class TestHTTPS(tutils.HTTPProxTest, SanityMixin):
     ssl = True
 
 
-class TestReverse(Sanity):
+class TestReverse(tutils.ReverseProxTest, SanityMixin):
     reverse = True
 
 
-class TestProxy(tutils.ProxTest):
+class _TestTransparent():
+    transparent = True
+
+
+class TestProxy(tutils.HTTPProxTest):
     def test_http(self):
         f = self.pathod("304")
         assert f.status_code == 304
diff --git a/test/tutils.py b/test/tutils.py
index 2fdf51a8..2556a57b 100644
--- a/test/tutils.py
+++ b/test/tutils.py
@@ -83,24 +83,15 @@ class ServerThread(threading.Thread):
         self.server.shutdown()
 
 
-class ProxTest:
-    ssl = None
-    reverse = False
+class ProxTestBase:
     @classmethod
     def setupAll(cls):
         cls.tqueue = Queue.Queue()
         cls.server = libpathod.test.Daemon(ssl=cls.ssl)
-        if cls.reverse:
-            reverse_proxy = (
-                "https" if cls.ssl else "http",
-                "127.0.0.1",
-                cls.server.port
-            )
-        else:
-            reverse_proxy = None
+        pconf = cls.get_proxy_config()
         config = proxy.ProxyConfig(
             certfile=test_data.path("data/testkey.pem"),
-            reverse_proxy = reverse_proxy
+            **pconf
         )
         cls.proxy = ProxyThread(cls.tqueue, config)
         cls.proxy.start()
@@ -113,25 +104,6 @@ class ProxTest:
     def setUp(self):
         self.proxy.tmaster.clear()
 
-    def pathod(self, spec):
-        """
-            Constructs a pathod request, with the appropriate base and proxy.
-        """
-        if self.reverse:
-            r = hurl.get(
-                "http://127.0.0.1:%s"%self.proxy.port + "/p/" + spec,
-                validate_cert=False,
-                #debug=hurl.utils.stdout_debug
-            )
-            return r
-        else:
-            return hurl.get(
-                self.urlbase + "/p/" + spec,
-                proxy=self.proxies,
-                validate_cert=False,
-                #debug=hurl.utils.stdout_debug
-            )
-
     @property
     def scheme(self):
         return "https" if self.ssl else "http"
@@ -157,6 +129,49 @@ class ProxTest:
         return pthread.tmaster.log
 
 
+class HTTPProxTest(ProxTestBase):
+    ssl = None
+    @classmethod
+    def get_proxy_config(cls):
+        return dict()
+
+    def pathod(self, spec):
+        """
+            Constructs a pathod request, with the appropriate base and proxy.
+        """
+        return hurl.get(
+            self.urlbase + "/p/" + spec,
+            proxy=self.proxies,
+            validate_cert=False,
+            #debug=hurl.utils.stdout_debug
+        )
+
+
+class ReverseProxTest(ProxTestBase):
+    ssl = None
+    @classmethod
+    def get_proxy_config(cls):
+        return dict(
+            reverse_proxy = (
+                "https" if cls.ssl else "http",
+                "127.0.0.1",
+                cls.server.port
+            )
+        )
+
+    def pathod(self, spec):
+        """
+            Constructs a pathod request, with the appropriate base and proxy.
+        """
+        r = hurl.get(
+            "http://127.0.0.1:%s"%self.proxy.port + "/p/" + spec,
+            validate_cert=False,
+            #debug=hurl.utils.stdout_debug
+        )
+        return r
+
+
+
 @contextmanager
 def tmpdir(*args, **kwargs):
     orig_workdir = os.getcwd()

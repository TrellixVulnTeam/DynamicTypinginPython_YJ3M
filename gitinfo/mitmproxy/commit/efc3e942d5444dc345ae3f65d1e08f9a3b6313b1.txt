commit efc3e942d5444dc345ae3f65d1e08f9a3b6313b1
Author: ikoz <john@kozyrakis.gr>
Date:   Wed Mar 16 17:43:48 2016 +0000

    Restructuring of the AddServerCertsToClientChain test so that it uses a Mixin - also removed some extra printf statements

diff --git a/test/mitmproxy/test_server.py b/test/mitmproxy/test_server.py
index 3286df89..560c7b34 100644
--- a/test/mitmproxy/test_server.py
+++ b/test/mitmproxy/test_server.py
@@ -1001,61 +1001,48 @@ class TestProxyChainingSSLReconnect(tservers.HTTPUpstreamProxyTest):
         assert self.chain[1].tmaster.state.flow_count() == 2
 
 
-class TestHTTPSAddServerCertsToClientChainTrue(tservers.HTTPProxyTest):
-    ssl = True
-    add_server_certs_to_client_chain = True
-    servercert = tutils.test_data.path("data/trusted-server.crt")
-    ssloptions = pathod.SSLOptions(
-            cn="trusted-cert",
-            certs=[
-                ("trusted-cert", servercert)
-            ]
-    )
+class AddServerCertsToClientChainMixin:
 
-    def test_add_server_certs_to_client_chain_true(self):
-        """
-        If --add-server-certs-to-client-chain is True, then the client should receive the server's certificates
-        """
+    def test_add_server_certs_to_client_chain(self):
         with open(self.servercert, "rb") as f:
             d = f.read()
         c1 = SSLCert.from_pem(d)
         p = self.pathoc()
-        print("digest of p.cert[1]: %s"%p.server_certs[1].digest('sha256'))
-        print("digest of c1.cert[1]: %s"%c1.digest('sha256'))
         server_cert_found_in_client_chain = False
-
         for cert in p.server_certs:
             if cert.digest('sha256') == c1.digest('sha256'):
                 server_cert_found_in_client_chain = True
                 break
+        assert(server_cert_found_in_client_chain == self.add_server_certs_to_client_chain)
 
-        assert(server_cert_found_in_client_chain == True)
 
+class TestHTTPSAddServerCertsToClientChainTrue(tservers.HTTPProxyTest, AddServerCertsToClientChainMixin):
 
-class TestHTTPSAddServerCertsToClientChainFalse(tservers.HTTPProxyTest):
+    """
+    If --add-server-certs-to-client-chain is True, then the client should receive the server's certificates
+    """
+    add_server_certs_to_client_chain = True
     ssl = True
-    add_server_certs_to_client_chain = False
     servercert = tutils.test_data.path("data/trusted-server.crt")
     ssloptions = pathod.SSLOptions(
-            cn="trusted-cert",
-            certs=[
-                ("trusted-cert", servercert)
-            ]
+        cn="trusted-cert",
+        certs=[
+            ("trusted-cert", servercert)
+        ]
     )
 
-    def test_add_server_certs_to_client_chain_false(self):
-        """
-        If --add-server-certs-to-client-chain is False, then the client should not receive the server's certificates
-        """
-        with open(self.servercert, "rb") as f:
-            d = f.read()
-        c1 = SSLCert.from_pem(d)
-        p = self.pathoc()
-        server_cert_found_in_client_chain = False
 
-        for cert in p.server_certs:
-            if cert.digest('sha256') == c1.digest('sha256'):
-                server_cert_found_in_client_chain = True
-                break
+class TestHTTPSAddServerCertsToClientChainFalse(tservers.HTTPProxyTest, AddServerCertsToClientChainMixin):
 
-        assert(server_cert_found_in_client_chain == False)
+    """
+    If --add-server-certs-to-client-chain is False, then the client should not receive the server's certificates
+    """
+    add_server_certs_to_client_chain = False
+    ssl = True
+    servercert = tutils.test_data.path("data/trusted-server.crt")
+    ssloptions = pathod.SSLOptions(
+        cn="trusted-cert",
+        certs=[
+            ("trusted-cert", servercert)
+        ]
+    )

commit a2261e3cf01121fb466bc91cd4117204187ba059
Author: Aldo Cortesi <aldo@nullcube.com>
Date:   Sun Jan 5 10:58:53 2014 +1300

    Introduce file descriptor decorators for Request objects
    
    Which lets us enable the apps again, now running from flow.py

diff --git a/libmproxy/app.py b/libmproxy/app.py
index f19eb03b..8ec8ea03 100644
--- a/libmproxy/app.py
+++ b/libmproxy/app.py
@@ -3,6 +3,8 @@ import flask
 mapp = flask.Flask(__name__)
 mapp.debug = True
 
+def master():
+    return flask.request.environ["mitmproxy.master"]
 
 @mapp.route("/")
 def index():
diff --git a/libmproxy/flow.py b/libmproxy/flow.py
index 59d8bde4..f5985197 100644
--- a/libmproxy/flow.py
+++ b/libmproxy/flow.py
@@ -331,6 +331,15 @@ class Request(HTTPMsg):
         self.stickycookie = False
         self.stickyauth = False
 
+        # Live attributes - not serialized
+        self.wfile, self.rfile = None, None
+
+    def set_live(self, rfile, wfile):
+        self.wfile, self.rfile = wfile, rfile
+
+    def is_live(self):
+        return bool(self.wfile)
+
     def anticache(self):
         """
             Modifies this request to remove headers that might produce a cached
@@ -1397,7 +1406,6 @@ class FlowMaster(controller.Master):
         self.setheaders = SetHeaders()
 
         self.stream = None
-        app.mapp.config["PMASTER"] = self
         self.apps = AppRegistry()
 
     def start_app(self, host, port, external):
@@ -1632,19 +1640,20 @@ class FlowMaster(controller.Master):
         return f
 
     def handle_request(self, r):
-        app = self.apps.get(r)
-        if app:
-            r.reply()
-            #err = app.serve(r, self.wfile)
-            #if err:
-            #    self.add_event("Error in wsgi app. %s"%err, "error")
-        else:
-            f = self.state.add_request(r)
-            self.replacehooks.run(f)
-            self.setheaders.run(f)
-            self.run_script_hook("request", f)
-            self.process_new_request(f)
-            return f
+        if r.is_live():
+            app = self.apps.get(r)
+            if app:
+                err = app.serve(r, r.wfile, **{"mitmproxy.master": self})
+                if err:
+                    self.add_event("Error in wsgi app. %s"%err, "error")
+                r.reply(proxy.KILL)
+                return
+        f = self.state.add_request(r)
+        self.replacehooks.run(f)
+        self.setheaders.run(f)
+        self.run_script_hook("request", f)
+        self.process_new_request(f)
+        return f
 
     def handle_response(self, r):
         f = self.state.add_response(r)
diff --git a/libmproxy/proxy.py b/libmproxy/proxy.py
index 7f39a5c5..69e5f411 100644
--- a/libmproxy/proxy.py
+++ b/libmproxy/proxy.py
@@ -6,6 +6,8 @@ from netlib import odict, tcp, http, certutils, http_status, http_auth
 import utils, flow, version, platform, controller
 
 
+TRANSPARENT_SSL_PORTS = [443, 8443]
+
 KILL = 0
 
 
@@ -425,10 +427,12 @@ class ProxyHandler(tcp.BaseHandler):
         content = http.read_http_body_request(
             self.rfile, self.wfile, headers, httpversion, self.config.body_size_limit
         )
-        return flow.Request(
+        r = flow.Request(
             client_conn, httpversion, host, port, scheme, method, path, headers, content,
             self.rfile.first_byte_timestamp, utils.timestamp()
         )
+        r.set_live(self.rfile, self.wfile)
+        return r
 
     def _read_request_origin_form(self, client_conn, scheme, host, port):
         """
@@ -456,10 +460,12 @@ class ProxyHandler(tcp.BaseHandler):
         content = http.read_http_body_request(
             self.rfile, self.wfile, headers, httpversion, self.config.body_size_limit
         )
-        return flow.Request(
+        r = flow.Request(
             client_conn, httpversion, host, port, scheme, method, path, headers, content,
             self.rfile.first_byte_timestamp, utils.timestamp()
         )
+        r.set_live(self.rfile, self.wfile)
+        return r
 
     def read_headers(self, authenticate=False):
         headers = http.read_headers(self.rfile)
@@ -560,7 +566,6 @@ def certificate_option_group(parser):
     )
 
 
-TRANSPARENT_SSL_PORTS = [443, 8443]
 
 def process_proxy_options(parser, options):
     if options.cert:
@@ -603,7 +608,9 @@ def process_proxy_options(parser, options):
     if options.clientcerts:
         options.clientcerts = os.path.expanduser(options.clientcerts)
         if not os.path.exists(options.clientcerts) or not os.path.isdir(options.clientcerts):
-            return parser.error("Client certificate directory does not exist or is not a directory: %s"%options.clientcerts)
+            return parser.error(
+                    "Client certificate directory does not exist or is not a directory: %s"%options.clientcerts
+                )
 
     if (options.auth_nonanonymous or options.auth_singleuser or options.auth_htpasswd):
         if options.auth_singleuser:

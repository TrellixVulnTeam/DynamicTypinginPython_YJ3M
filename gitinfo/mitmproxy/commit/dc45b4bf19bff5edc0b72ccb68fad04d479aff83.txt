commit dc45b4bf19bff5edc0b72ccb68fad04d479aff83
Author: Maximilian Hils <git@maximilianhils.com>
Date:   Fri Jan 31 01:06:53 2014 +0100

    move StateObject back into libmproxy

diff --git a/netlib/certutils.py b/netlib/certutils.py
index 139203b9..94294f6e 100644
--- a/netlib/certutils.py
+++ b/netlib/certutils.py
@@ -3,7 +3,6 @@ from pyasn1.type import univ, constraint, char, namedtype, tag
 from pyasn1.codec.der.decoder import decode
 from pyasn1.error import PyAsn1Error
 import OpenSSL
-from netlib.stateobject import StateObject
 import tcp
 
 default_exp = 62208000 # =24 * 60 * 60 * 720
@@ -153,22 +152,13 @@ class _GeneralNames(univ.SequenceOf):
     sizeSpec = univ.SequenceOf.sizeSpec + constraint.ValueSizeConstraint(1, 1024)
 
 
-class SSLCert(StateObject):
+class SSLCert:
     def __init__(self, cert):
         """
             Returns a (common name, [subject alternative names]) tuple.
         """
         self.x509 = cert
 
-    def _get_state(self):
-        return self.to_pem()
-
-    def _load_state(self, state):
-        self.x509 = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, state)
-
-    def _from_state(cls, state):
-        return cls.from_pem(state)
-
     @classmethod
     def from_pem(klass, txt):
         x509 = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, txt)
diff --git a/netlib/odict.py b/netlib/odict.py
index 8e195afc..46b74e8e 100644
--- a/netlib/odict.py
+++ b/netlib/odict.py
@@ -1,5 +1,4 @@
 import re, copy
-from netlib.stateobject import StateObject
 
 
 def safe_subn(pattern, repl, target, *args, **kwargs):
@@ -11,7 +10,7 @@ def safe_subn(pattern, repl, target, *args, **kwargs):
     return re.subn(str(pattern), str(repl), target, *args, **kwargs)
 
 
-class ODict(StateObject):
+class ODict:
     """
         A dictionary-like object for managing ordered (key, value) data.
     """
diff --git a/netlib/stateobject.py b/netlib/stateobject.py
deleted file mode 100644
index c2ef2cd4..00000000
--- a/netlib/stateobject.py
+++ /dev/null
@@ -1,80 +0,0 @@
-from types import ClassType
-
-
-class StateObject:
-    def _get_state(self):
-        raise NotImplementedError
-
-    def _load_state(self, state):
-        raise NotImplementedError
-
-    @classmethod
-    def _from_state(cls, state):
-        raise NotImplementedError
-
-    def __eq__(self, other):
-        try:
-            return self._get_state() == other._get_state()
-        except AttributeError:  # we may compare with something that's not a StateObject
-            return False
-
-
-class SimpleStateObject(StateObject):
-    """
-    A StateObject with opionated conventions that tries to keep everything DRY.
-
-    Simply put, you agree on a list of attributes and their type.
-    Attributes can either be primitive types(str, tuple, bool, ...) or StateObject instances themselves.
-    SimpleStateObject uses this information for the default _get_state(), _from_state(s) and _load_state(s) methods.
-    Overriding _get_state or _load_state to add custom adjustments is always possible.
-    """
-
-    _stateobject_attributes = None  # none by default to raise an exception if definition was forgotten
-    """
-    An attribute-name -> class-or-type dict containing all attributes that should be serialized
-    If the attribute is a class, this class must be a subclass of StateObject.
-    """
-
-    def _get_state(self):
-        return {attr: self.__get_state_attr(attr, cls)
-                for attr, cls in self._stateobject_attributes.iteritems()}
-
-    def __get_state_attr(self, attr, cls):
-        """
-        helper for _get_state.
-        returns the value of the given attribute
-        """
-        if getattr(self, attr) is None:
-            return None
-        if isinstance(cls, ClassType):
-            return getattr(self, attr)._get_state()
-        else:
-            return getattr(self, attr)
-
-    def _load_state(self, state):
-        for attr, cls in self._stateobject_attributes.iteritems():
-            self.__load_state_attr(attr, cls, state)
-
-    def __load_state_attr(self, attr, cls, state):
-        """
-        helper for _load_state.
-        loads the given attribute from the state.
-        """
-        if state[attr] is not None:  # First, catch None as value.
-            if isinstance(cls, ClassType):  # Is the attribute a StateObject itself?
-                assert issubclass(cls, StateObject)
-                curr = getattr(self, attr)
-                if curr:  # if the attribute is already present, delegate to the objects ._load_state method.
-                    curr._load_state(state[attr])
-                else: # otherwise, create a new object.
-                    setattr(self, attr, cls._from_state(state[attr]))
-            else:
-                setattr(self, attr, cls(state[attr]))
-        else:
-            setattr(self, attr, None)
-
-    @classmethod
-    def _from_state(cls, state):
-        f = cls()  # the default implementation assumes an empty constructor. Override accordingly.
-        f._load_state(state)
-        return f
\ No newline at end of file
diff --git a/netlib/tcp.py b/netlib/tcp.py
index c26d1191..346bc053 100644
--- a/netlib/tcp.py
+++ b/netlib/tcp.py
@@ -1,7 +1,6 @@
 import select, socket, threading, sys, time, traceback
 from OpenSSL import SSL
 import certutils
-from netlib.stateobject import StateObject
 
 SSLv2_METHOD = SSL.SSLv2_METHOD
 SSLv3_METHOD = SSL.SSLv3_METHOD
@@ -174,13 +173,13 @@ class Reader(_FileLike):
         return result
 
 
-class Address(StateObject):
+class Address(object):
     """
     This class wraps an IPv4/IPv6 tuple to provide named attributes and ipv6 information.
     """
     def __init__(self, address, use_ipv6=False):
         self.address = address
-        self.family = socket.AF_INET6 if use_ipv6 else socket.AF_INET
+        self.use_ipv6 = use_ipv6
 
     @classmethod
     def wrap(cls, t):
@@ -204,19 +203,9 @@ class Address(StateObject):
     def use_ipv6(self):
         return self.family == socket.AF_INET6
 
-    def _load_state(self, state):
-        self.address = state["address"]
-        self.family = socket.AF_INET6 if state["use_ipv6"] else socket.AF_INET
-
-    def _get_state(self):
-        return dict(
-            address=self.address,
-            use_ipv6=self.use_ipv6
-        )
-
-    @classmethod
-    def _from_state(cls, state):
-        return cls(**state)
+    @use_ipv6.setter
+    def use_ipv6(self, b):
+        self.family = socket.AF_INET6 if b else socket.AF_INET
 
 
 class SocketCloseMixin:

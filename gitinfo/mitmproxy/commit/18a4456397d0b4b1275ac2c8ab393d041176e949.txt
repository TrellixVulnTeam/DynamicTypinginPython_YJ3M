commit 18a4456397d0b4b1275ac2c8ab393d041176e949
Author: Thomas Kriechbaumer <thomas@kriechbaumer.name>
Date:   Mon Jun 8 16:03:33 2015 +0200

    refactor cmdline tests

diff --git a/libpathod/pathoc_cmdline.py b/libpathod/pathoc_cmdline.py
new file mode 100644
index 00000000..fa30aa1e
--- /dev/null
+++ b/libpathod/pathoc_cmdline.py
@@ -0,0 +1,218 @@
+#!/usr/bin/env python
+import sys
+import argparse
+import os
+import os.path
+import re
+from netlib import http_uastrings
+from . import pathoc, pathod, version, utils, language
+
+
+def args_pathoc(argv, stdout=sys.stdout, stderr=sys.stderr):
+    preparser = argparse.ArgumentParser(add_help=False)
+    preparser.add_argument(
+        "--show-uas", dest="showua", action="store_true", default=False,
+        help="Print user agent shortcuts and exit."
+    )
+    pa = preparser.parse_known_args(argv)[0]
+    if pa.showua:
+        print >> stdout, "User agent strings:"
+        for i in http_uastrings.UASTRINGS:
+            print >> stdout, "  ", i[1], i[0]
+        sys.exit(0)
+
+    parser = argparse.ArgumentParser(
+        description='A perverse HTTP client.', parents=[preparser]
+    )
+    parser.add_argument(
+        '--version',
+        action='version',
+        version="pathoc " + version.VERSION
+    )
+    parser.add_argument(
+        "-c", dest="connect_to", type=str, default=False,
+        metavar = "HOST:PORT",
+        help="Issue an HTTP CONNECT to connect to the specified host."
+    )
+    parser.add_argument(
+        "--memo-limit", dest='memolimit', default=5000, type=int, metavar="N",
+        help='Stop if we do not find a valid request after N attempts.'
+    )
+    parser.add_argument(
+        "-m", dest='memo', action="store_true", default=False,
+        help="""
+            Remember specs, and never play the same one twice. Note that this
+            means requests have to be rendered in memory, which means that
+            large generated data can cause issues.
+        """
+    )
+    parser.add_argument(
+        "-n", dest='repeat', default=1, type=int, metavar="N",
+        help='Repeat N times. If 0 repeat for ever.'
+    )
+    parser.add_argument(
+        "-w", dest='wait', default=0, type=float, metavar="N",
+        help='Wait N seconds between each request.'
+    )
+    parser.add_argument(
+        "-r", dest="random", action="store_true", default=False,
+        help="""
+        Select a random request from those specified. If this is not specified,
+        requests are all played in sequence.
+        """
+    )
+    parser.add_argument(
+        "-t", dest="timeout", type=int, default=None,
+        help="Connection timeout"
+    )
+    parser.add_argument(
+        "--http2", dest="use_http2", action="store_true", default=False,
+        help='Perform all requests over a single HTTP/2 connection.'
+    )
+    parser.add_argument(
+        "--http2-skip-connection-preface",
+        dest="http2_skip_connection_preface",
+        action="store_true",
+        default=False,
+        help='Skips the HTTP/2 connection preface before sending requests.')
+
+    parser.add_argument(
+        'host', type=str,
+        metavar = "host[:port]",
+        help='Host and port to connect to'
+    )
+    parser.add_argument(
+        'requests', type=str, nargs="+",
+        help="""
+        Request specification, or path to a file containing request
+        specifcations
+        """
+    )
+
+    group = parser.add_argument_group(
+        'SSL',
+    )
+    group.add_argument(
+        "-s", dest="ssl", action="store_true", default=False,
+        help="Connect with SSL"
+    )
+    group.add_argument(
+        "-C", dest="clientcert", type=str, default=False,
+        help="Path to a file containing client certificate and private key"
+    )
+    group.add_argument(
+        "-i", dest="sni", type=str, default=False,
+        help="SSL Server Name Indication"
+    )
+    group.add_argument(
+        "--ciphers", dest="ciphers", type=str, default=False,
+        help="SSL cipher specification"
+    )
+    group.add_argument(
+        "--sslversion", dest="sslversion", type=int, default=4,
+        choices=[1, 2, 3, 4],
+        help="""
+            Use a specified protocol - TLSv1, SSLv2, SSLv3, SSLv23. Default
+            to SSLv23.
+        """
+    )
+
+    group = parser.add_argument_group(
+        'Controlling Output',
+        """
+            Some of these options expand generated values for logging - if
+            you're generating large data, use them with caution.
+        """
+    )
+    group.add_argument(
+        "-I", dest="ignorecodes", type=str, default="",
+        help="Comma-separated list of response codes to ignore"
+    )
+    group.add_argument(
+        "-S", dest="showssl", action="store_true", default=False,
+        help="Show info on SSL connection"
+    )
+    group.add_argument(
+        "-e", dest="explain", action="store_true", default=False,
+        help="Explain requests"
+    )
+    group.add_argument(
+        "-o", dest="oneshot", action="store_true", default=False,
+        help="Oneshot - exit after first non-ignored response"
+    )
+    group.add_argument(
+        "-q", dest="showreq", action="store_true", default=False,
+        help="Print full request"
+    )
+    group.add_argument(
+        "-p", dest="showresp", action="store_true", default=False,
+        help="Print full response"
+    )
+    group.add_argument(
+        "-T", dest="ignoretimeout", action="store_true", default=False,
+        help="Ignore timeouts"
+    )
+    group.add_argument(
+        "-x", dest="hexdump", action="store_true", default=False,
+        help="Output in hexdump format"
+    )
+
+    args = parser.parse_args(argv[1:])
+
+    args.port = None
+    if ":" in args.host:
+        h, p = args.host.rsplit(":", 1)
+        try:
+            p = int(p)
+        except ValueError:
+            return parser.error("Invalid port in host spec: %s" % args.host)
+        args.host = h
+        args.port = p
+
+    if args.port is None:
+        args.port = 443 if args.ssl else 80
+
+    try:
+        args.ignorecodes = [int(i) for i in args.ignorecodes.split(",") if i]
+    except ValueError:
+        return parser.error(
+            "Invalid return code specification: %s" %
+            args.ignorecodes)
+
+    if args.connect_to:
+        parts = args.connect_to.split(":")
+        if len(parts) != 2:
+            return parser.error(
+                "Invalid CONNECT specification: %s" %
+                args.connect_to)
+        try:
+            parts[1] = int(parts[1])
+        except ValueError:
+            return parser.error(
+                "Invalid CONNECT specification: %s" %
+                args.connect_to)
+        args.connect_to = parts
+    else:
+        args.connect_to = None
+
+    if args.http2_skip_connection_preface:
+        args.use_http2 = True
+
+    reqs = []
+    for r in args.requests:
+        if os.path.isfile(r):
+            data = open(r).read()
+            r = data
+        try:
+            reqs.append(language.parse_pathoc(r, args.use_http2))
+        except language.ParseException as v:
+            print >> stderr, "Error parsing request spec: %s" % v.msg
+            print >> stderr, v.marked()
+            sys.exit(1)
+    args.requests = reqs
+    return args
+
+
+def go_pathoc():  # pragma: nocover
+    args = args_pathoc(sys.argv)
+    pathoc.main(args)
diff --git a/libpathod/cmdline.py b/libpathod/pathod_cmdline.py
similarity index 52%
rename from libpathod/cmdline.py
rename to libpathod/pathod_cmdline.py
index 06a6c533..c1f016c2 100644
--- a/libpathod/cmdline.py
+++ b/libpathod/pathod_cmdline.py
@@ -8,213 +8,6 @@ from netlib import http_uastrings
 from . import pathoc, pathod, version, utils, language
 
 
-def args_pathoc(argv, stdout=sys.stdout, stderr=sys.stderr):
-    preparser = argparse.ArgumentParser(add_help=False)
-    preparser.add_argument(
-        "--show-uas", dest="showua", action="store_true", default=False,
-        help="Print user agent shortcuts and exit."
-    )
-    pa = preparser.parse_known_args(argv)[0]
-    if pa.showua:
-        print >> stdout, "User agent strings:"
-        for i in http_uastrings.UASTRINGS:
-            print >> stdout, "  ", i[1], i[0]
-        sys.exit(0)
-
-    parser = argparse.ArgumentParser(
-        description='A perverse HTTP client.', parents=[preparser]
-    )
-    parser.add_argument(
-        '--version',
-        action='version',
-        version="pathoc " + version.VERSION
-    )
-    parser.add_argument(
-        "-c", dest="connect_to", type=str, default=False,
-        metavar = "HOST:PORT",
-        help="Issue an HTTP CONNECT to connect to the specified host."
-    )
-    parser.add_argument(
-        "--memo-limit", dest='memolimit', default=5000, type=int, metavar="N",
-        help='Stop if we do not find a valid request after N attempts.'
-    )
-    parser.add_argument(
-        "-m", dest='memo', action="store_true", default=False,
-        help="""
-            Remember specs, and never play the same one twice. Note that this
-            means requests have to be rendered in memory, which means that
-            large generated data can cause issues.
-        """
-    )
-    parser.add_argument(
-        "-n", dest='repeat', default=1, type=int, metavar="N",
-        help='Repeat N times. If 0 repeat for ever.'
-    )
-    parser.add_argument(
-        "-w", dest='wait', default=0, type=float, metavar="N",
-        help='Wait N seconds between each request.'
-    )
-    parser.add_argument(
-        "-r", dest="random", action="store_true", default=False,
-        help="""
-        Select a random request from those specified. If this is not specified,
-        requests are all played in sequence.
-        """
-    )
-    parser.add_argument(
-        "-t", dest="timeout", type=int, default=None,
-        help="Connection timeout"
-    )
-    parser.add_argument(
-        "--http2", dest="use_http2", action="store_true", default=False,
-        help='Perform all requests over a single HTTP/2 connection.'
-    )
-    parser.add_argument(
-        "--http2-skip-connection-preface",
-        dest="http2_skip_connection_preface",
-        action="store_true",
-        default=False,
-        help='Skips the HTTP/2 connection preface before sending requests.')
-
-    parser.add_argument(
-        'host', type=str,
-        metavar = "host[:port]",
-        help='Host and port to connect to'
-    )
-    parser.add_argument(
-        'requests', type=str, nargs="+",
-        help="""
-        Request specification, or path to a file containing request
-        specifcations
-        """
-    )
-
-    group = parser.add_argument_group(
-        'SSL',
-    )
-    group.add_argument(
-        "-s", dest="ssl", action="store_true", default=False,
-        help="Connect with SSL"
-    )
-    group.add_argument(
-        "-C", dest="clientcert", type=str, default=False,
-        help="Path to a file containing client certificate and private key"
-    )
-    group.add_argument(
-        "-i", dest="sni", type=str, default=False,
-        help="SSL Server Name Indication"
-    )
-    group.add_argument(
-        "--ciphers", dest="ciphers", type=str, default=False,
-        help="SSL cipher specification"
-    )
-    group.add_argument(
-        "--sslversion", dest="sslversion", type=int, default=4,
-        choices=[1, 2, 3, 4],
-        help="""
-            Use a specified protocol - TLSv1, SSLv2, SSLv3, SSLv23. Default
-            to SSLv23.
-        """
-    )
-
-    group = parser.add_argument_group(
-        'Controlling Output',
-        """
-            Some of these options expand generated values for logging - if
-            you're generating large data, use them with caution.
-        """
-    )
-    group.add_argument(
-        "-I", dest="ignorecodes", type=str, default="",
-        help="Comma-separated list of response codes to ignore"
-    )
-    group.add_argument(
-        "-S", dest="showssl", action="store_true", default=False,
-        help="Show info on SSL connection"
-    )
-    group.add_argument(
-        "-e", dest="explain", action="store_true", default=False,
-        help="Explain requests"
-    )
-    group.add_argument(
-        "-o", dest="oneshot", action="store_true", default=False,
-        help="Oneshot - exit after first non-ignored response"
-    )
-    group.add_argument(
-        "-q", dest="showreq", action="store_true", default=False,
-        help="Print full request"
-    )
-    group.add_argument(
-        "-p", dest="showresp", action="store_true", default=False,
-        help="Print full response"
-    )
-    group.add_argument(
-        "-T", dest="ignoretimeout", action="store_true", default=False,
-        help="Ignore timeouts"
-    )
-    group.add_argument(
-        "-x", dest="hexdump", action="store_true", default=False,
-        help="Output in hexdump format"
-    )
-
-    args = parser.parse_args(argv[1:])
-
-    args.port = None
-    if ":" in args.host:
-        h, p = args.host.rsplit(":", 1)
-        try:
-            p = int(p)
-        except ValueError:
-            return parser.error("Invalid port in host spec: %s" % args.host)
-        args.host = h
-        args.port = p
-
-    if args.port is None:
-        args.port = 443 if args.ssl else 80
-
-    try:
-        args.ignorecodes = [int(i) for i in args.ignorecodes.split(",") if i]
-    except ValueError:
-        return parser.error(
-            "Invalid return code specification: %s" %
-            args.ignorecodes)
-
-    if args.connect_to:
-        parts = args.connect_to.split(":")
-        if len(parts) != 2:
-            return parser.error(
-                "Invalid CONNECT specification: %s" %
-                args.connect_to)
-        try:
-            parts[1] = int(parts[1])
-        except ValueError:
-            return parser.error(
-                "Invalid CONNECT specification: %s" %
-                args.connect_to)
-        args.connect_to = parts
-    else:
-        args.connect_to = None
-
-    reqs = []
-    for r in args.requests:
-        if os.path.isfile(r):
-            data = open(r).read()
-            r = data
-        try:
-            reqs.append(language.parse_pathoc(r, args.use_http2))
-        except language.ParseException as v:
-            print >> stderr, "Error parsing request spec: %s" % v.msg
-            print >> stderr, v.marked()
-            sys.exit(1)
-    args.requests = reqs
-    return args
-
-
-def go_pathoc():  # pragma: nocover
-    args = args_pathoc(sys.argv)
-    pathoc.main(args)
-
-
 def args_pathod(argv, stdout=sys.stdout, stderr=sys.stderr):
     parser = argparse.ArgumentParser(
         description='A pathological HTTP/S daemon.'
diff --git a/pathoc b/pathoc
index cbf8f773..b3121611 100755
--- a/pathoc
+++ b/pathoc
@@ -1,5 +1,6 @@
 #!/usr/bin/env python
-from libpathod import cmdline
+
+from libpathod import pathoc_cmdline as cmdline
 
 if __name__ == "__main__":
     cmdline.go_pathoc()
diff --git a/pathod b/pathod
index ca0baa57..a79becf1 100755
--- a/pathod
+++ b/pathod
@@ -1,5 +1,6 @@
 #!/usr/bin/env python
-from libpathod import cmdline
+
+from libpathod import pathod_cmdline as cmdline
 
 if __name__ == "__main__":
     cmdline.go_pathod()
diff --git a/setup.py b/setup.py
index 7340f983..1a6a3e3f 100644
--- a/setup.py
+++ b/setup.py
@@ -37,8 +37,8 @@ setup(
     include_package_data=True,
     entry_points={
         'console_scripts': [
-            "pathod = libpathod.cmdline:go_pathod",
-            "pathoc = libpathod.cmdline:go_pathoc"
+            "pathod = libpathod.pathod_cmdline:go_pathod",
+            "pathoc = libpathod.pathoc_cmdline:go_pathoc"
         ]
     },
     install_requires=[
diff --git a/test/test_pathoc_cmdline.py b/test/test_pathoc_cmdline.py
new file mode 100644
index 00000000..03c83844
--- /dev/null
+++ b/test/test_pathoc_cmdline.py
@@ -0,0 +1,62 @@
+from libpathod import pathoc_cmdline as cmdline
+import tutils
+import cStringIO
+import mock
+
+
+@mock.patch("argparse.ArgumentParser.error")
+def test_pathoc(perror):
+    assert cmdline.args_pathoc(["pathoc", "foo.com", "get:/"])
+    s = cStringIO.StringIO()
+    tutils.raises(
+        SystemExit, cmdline.args_pathoc, [
+            "pathoc", "--show-uas"], s, s)
+
+    a = cmdline.args_pathoc(["pathoc", "foo.com:8888", "get:/"])
+    assert a.port == 8888
+
+    a = cmdline.args_pathoc(["pathoc", "foo.com:xxx", "get:/"])
+    assert perror.called
+    perror.reset_mock()
+
+    a = cmdline.args_pathoc(["pathoc", "-I", "10, 20", "foo.com:8888", "get:/"])
+    assert a.ignorecodes == [10, 20]
+
+    a = cmdline.args_pathoc(["pathoc", "-I", "xx, 20", "foo.com:8888", "get:/"])
+    assert perror.called
+    perror.reset_mock()
+
+    a = cmdline.args_pathoc(["pathoc", "-c", "foo:10", "foo.com:8888", "get:/"])
+    assert a.connect_to == ["foo", 10]
+
+    a = cmdline.args_pathoc(["pathoc", "foo.com", "get:/", "--http2"])
+    assert a.use_http2 == True
+
+    a = cmdline.args_pathoc(["pathoc", "foo.com", "get:/", "--http2-skip-connection-preface"])
+    assert a.use_http2 == True
+    assert a.http2_skip_connection_preface == True
+
+    a = cmdline.args_pathoc(["pathoc", "-c", "foo", "foo.com:8888", "get:/"])
+    assert perror.called
+    perror.reset_mock()
+
+    a = cmdline.args_pathoc(
+        ["pathoc", "-c", "foo:bar", "foo.com:8888", "get:/"])
+    assert perror.called
+    perror.reset_mock()
+
+    a = cmdline.args_pathoc(
+        [
+            "pathoc",
+            "foo.com:8888",
+            tutils.test_data.path("data/request")
+        ]
+    )
+    assert len(list(a.requests)) == 1
+
+    tutils.raises(
+        SystemExit,
+        cmdline.args_pathoc,
+        ["pathoc", "foo.com", "invalid"],
+        s, s
+    )
diff --git a/test/test_cmdline.py b/test/test_pathod_cmdline.py
similarity index 54%
rename from test/test_cmdline.py
rename to test/test_pathod_cmdline.py
index c1b55608..590bb56b 100644
--- a/test/test_cmdline.py
+++ b/test/test_pathod_cmdline.py
@@ -1,4 +1,4 @@
-from libpathod import cmdline
+from libpathod import pathod_cmdline as cmdline
 import tutils
 import cStringIO
 import mock
@@ -93,50 +93,6 @@ def test_pathod(perror):
     assert perror.called
     perror.reset_mock()
 
-
-@mock.patch("argparse.ArgumentParser.error")
-def test_pathoc(perror):
-    assert cmdline.args_pathoc(["pathoc", "foo.com", "get:/"])
-    s = cStringIO.StringIO()
-    tutils.raises(
-        SystemExit, cmdline.args_pathoc, [
-            "pathoc", "--show-uas"], s, s)
-
-    a = cmdline.args_pathoc(["pathoc", "foo.com:8888", "get:/"])
-    assert a.port == 8888
-
-    a = cmdline.args_pathoc(["pathoc", "foo.com:xxx", "get:/"])
-    assert perror.called
-    perror.reset_mock()
-
-    a = cmdline.args_pathoc(["pathoc", "-I", "10, 20", "foo.com:8888", "get:/"])
-    assert a.ignorecodes == [10, 20]
-
-    a = cmdline.args_pathoc(["pathoc", "-I", "xx, 20", "foo.com:8888", "get:/"])
-    assert perror.called
-    perror.reset_mock()
-
-    a = cmdline.args_pathoc(["pathoc", "-c", "foo:10", "foo.com:8888", "get:/"])
-    assert a.connect_to == ["foo", 10]
-
-    a = cmdline.args_pathoc(["pathoc", "-c", "foo", "foo.com:8888", "get:/"])
-    assert perror.called
-    perror.reset_mock()
-
-    a = cmdline.args_pathoc(
-        ["pathoc", "-c", "foo:bar", "foo.com:8888", "get:/"])
-    assert perror.called
-    perror.reset_mock()
-
-    a = cmdline.args_pathoc(
-        [
-            "pathoc",
-            "foo.com:8888",
-            tutils.test_data.path("data/request")
-        ]
-    )
-    assert len(list(a.requests)) == 1
-
     a = cmdline.args_pathod(
         [
             "pathod",
@@ -146,10 +102,3 @@ def test_pathoc(perror):
     )
     assert perror.called
     perror.reset_mock()
-
-    tutils.raises(
-        SystemExit,
-        cmdline.args_pathoc,
-        ["pathoc", "foo.com", "invalid"],
-        s, s
-    )

commit 394bd1d6b00719a12e36b3a6c8dac4b2b20e5ecf
Author: Aldo Cortesi <aldo@nullcube.com>
Date:   Tue Mar 15 17:53:29 2011 +1300

    Interrupt interception when deleting an intercepting flow.
    
    Prompting the user for this is annoying.

diff --git a/libmproxy/console.py b/libmproxy/console.py
index eaaa7b3a..78e81035 100644
--- a/libmproxy/console.py
+++ b/libmproxy/console.py
@@ -139,10 +139,6 @@ class ConnectionItem(WWrap):
         w = self.get_text()
         WWrap.__init__(self, w)
 
-    def intercept(self):
-        self.intercepting = True
-        self.w = self.get_text()
-
     def get_text(self):
         return urwid.Text(format_flow(self.flow, self.focus))
 
@@ -159,8 +155,8 @@ class ConnectionItem(WWrap):
         elif key == "C":
             self.master.clear_connections()
         elif key == "d":
-            if not self.state.delete_flow(self.flow):
-                self.master.statusbar.message("Can't delete connection mid-intercept.")
+            self.flow.kill(self.master)
+            self.state.delete_flow(self.flow)
             self.master.sync_list_view()
         elif key == "r":
             r = self.master.replay_request(self.flow)
@@ -178,7 +174,7 @@ class ConnectionItem(WWrap):
                 self.flow
             )
         elif key == "z":
-            self.master.kill_connection(self.flow)
+            self.flow.kill(self.master)
         elif key == "enter":
             if self.flow.request:
                 self.master.view_flow(self.flow)
@@ -1416,9 +1412,6 @@ class ConsoleMaster(flow.FlowMaster):
         self.state.delete_flow(f)
         self.sync_list_view()
 
-    def kill_connection(self, f):
-        f.kill(self)
-
     def refresh_connection(self, c):
         if hasattr(self.header, "refresh_connection"):
             self.header.refresh_connection(c)
diff --git a/libmproxy/flow.py b/libmproxy/flow.py
index 21d4017a..62fba6ab 100644
--- a/libmproxy/flow.py
+++ b/libmproxy/flow.py
@@ -293,8 +293,8 @@ class Flow:
             self.request.ack(None)
         elif self.response and not self.response.acked:
             self.response.ack(None)
-        self.intercepting = False
         master.handle_error(self.error)
+        self.intercepting = False
 
     def intercept(self):
         self.intercepting = True
@@ -403,12 +403,10 @@ class State:
             return tuple(self.flow_list[:])
 
     def delete_flow(self, f):
-        if not f.intercepting:
-            if f.request in self.flow_map:
-                del self.flow_map[f.request]
-            self.flow_list.remove(f)
-            return True
-        return False
+        if f.request in self.flow_map:
+            del self.flow_map[f.request]
+        self.flow_list.remove(f)
+        return True
 
     def clear(self):
         for i in self.flow_list[:]:
diff --git a/test/test_flow.py b/test/test_flow.py
index a3fa48d7..463375aa 100644
--- a/test/test_flow.py
+++ b/test/test_flow.py
@@ -325,9 +325,6 @@ class uState(libpry.AutoTree):
         f = self._add_request(c)
         f.intercepting = True
 
-        c.clear()
-        assert c.flow_count() == 1
-        f.intercepting = False
         c.clear()
         assert c.flow_count() == 0
 

commit 1c124421e34d310c6e0577f20b595413d639a5c3
Author: Thomas Kriechbaumer <thomas@kriechbaumer.name>
Date:   Mon Jun 15 15:31:58 2015 +0200

    http2: fix header_block_fragments and length

diff --git a/netlib/http2/frame.py b/netlib/http2/frame.py
index 3e285cba..98ced904 100644
--- a/netlib/http2/frame.py
+++ b/netlib/http2/frame.py
@@ -114,6 +114,8 @@ class Frame(object):
         raise NotImplementedError()
 
     def human_readable(self, direction="-"):
+        self.length = len(self.payload_bytes())
+
         return "\n".join([
             "%s: %s | length: %d | flags: %#x | stream_id: %d" % (direction, self.__class__.__name__, self.length, self.flags, self.stream_id),
             self.payload_human_readable(),
@@ -456,7 +458,10 @@ class PushPromiseFrame(Frame):
             s.append("padding: %d" % self.pad_length)
 
         s.append("promised stream: %#x" % self.promised_stream)
-        s.append("header_block_fragment: %s" % str(self.header_block_fragment))
+        s.append(
+            "header_block_fragment: %s" %
+            self.header_block_fragment.encode('hex'))
+
         return "\n".join(s)
 
 
@@ -600,7 +605,11 @@ class ContinuationFrame(Frame):
         return self.header_block_fragment
 
     def payload_human_readable(self):
-        return "header_block_fragment: %s" % str(self.header_block_fragment)
+        s = []
+        s.append(
+            "header_block_fragment: %s" %
+            self.header_block_fragment.encode('hex'))
+        return "\n".join(s)
 
 _FRAME_CLASSES = [
     DataFrame,
diff --git a/netlib/http2/protocol.py b/netlib/http2/protocol.py
index 682b7863..f17f998f 100644
--- a/netlib/http2/protocol.py
+++ b/netlib/http2/protocol.py
@@ -50,14 +50,18 @@ class HTTP2Protocol(object):
         return True
 
     def _receive_settings(self, hide=False):
-        frm = self.read_frame(hide)
-        assert isinstance(frm, frame.SettingsFrame)
+        while True:
+            frm = self.read_frame(hide)
+            if isinstance(frm, frame.SettingsFrame):
+                break
 
     def _read_settings_ack(self, hide=False):
-        settings_ack_frame = self.read_frame(hide)
-        assert isinstance(settings_ack_frame, frame.SettingsFrame)
-        assert settings_ack_frame.flags & frame.Frame.FLAG_ACK
-        assert len(settings_ack_frame.settings) == 0
+        while True:
+            frm = self.read_frame(hide)
+            if isinstance(frm, frame.SettingsFrame):
+                assert settings_ack_frame.flags & frame.Frame.FLAG_ACK
+                assert len(settings_ack_frame.settings) == 0
+                break
 
     def perform_server_connection_preface(self, force=False):
         if force or not self.connection_preface_performed:
@@ -119,7 +123,7 @@ class HTTP2Protocol(object):
                 state=self,
                 flags=frame.Frame.FLAG_ACK),
                 hide)
-        self._read_settings_ack(hide)
+        # self._read_settings_ack(hide)
 
     def _create_headers(self, headers, stream_id, end_stream=True):
         # TODO: implement max frame size checks and sending in chunks
@@ -219,10 +223,13 @@ class HTTP2Protocol(object):
         if headers is None:
             headers = []
 
+        body='foobar'
+
         headers = [(b':status', bytes(str(code)))] + headers
 
         stream_id = self.next_stream_id()
 
         return list(itertools.chain(
             self._create_headers(headers, stream_id, end_stream=(body is None)),
-            self._create_body(body, stream_id)))
+            self._create_body(body, stream_id),
+        ))

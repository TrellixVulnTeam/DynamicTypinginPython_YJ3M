commit 421b241ff010ae979cff8df504b6744e4c291aeb
Author: Maximilian Hils <git@maximilianhils.com>
Date:   Sun Aug 30 13:40:23 2015 +0200

    remove http2http references

diff --git a/doc-src/features/reverseproxy.html b/doc-src/features/reverseproxy.html
index 5ef4efc5..af5a5c53 100644
--- a/doc-src/features/reverseproxy.html
+++ b/doc-src/features/reverseproxy.html
@@ -7,22 +7,17 @@ mitmproxy forwards HTTP proxy requests to an upstream proxy server.
 <table class="table">
     <tbody>
         <tr>
-            <th width="20%">command-line</th> <td>-R <i>schema</i>://hostname[:port]</td>
+            <th width="20%">command-line</th> <td>-R <i>scheme</i>://hostname[:port]</td>
         </tr>
     </tbody>
 </table>
 
-Here, **schema** is one of http, https, http2https or https2http. The latter
-two extended schema specifications control the use of HTTP and HTTPS on
-mitmproxy and the upstream server. You can indicate that mitmproxy should use
-HTTP, and the upstream server uses HTTPS like this:
+Here, **scheme** signifies if the proxy should use TLS to connect to the server.
+mitmproxy accepts both encrypted and unencrypted requests and transforms them to what the server
+expects.
 
-	http2https://hostname:port
-
-And you can indicate that mitmproxy should use HTTPS while the upstream
-service uses HTTP like this:
-
-	https2http://hostname:port
+    mitmdump -R https://httpbin.org -p 80
+    mitmdump -R https://httpbin.org -p 443
 
 
 ### Host Header
diff --git a/doc-src/modes.html b/doc-src/modes.html
index b5a38696..a878fd82 100644
--- a/doc-src/modes.html
+++ b/doc-src/modes.html
@@ -149,7 +149,7 @@ this:
     <h1>Reverse Proxy</h1>
 </div>
 
-Mitmproxy is usually used with a client that uses the proxy to access the
+mitmproxy is usually used with a client that uses the proxy to access the
 Internet. Using reverse proxy mode, you can use mitmproxy to act like a normal
 HTTP server:
 
@@ -174,14 +174,14 @@ requests recorded in mitmproxy.
 
 - Say you have some toy project that should get SSL support. Simply set up
 mitmproxy with SSL termination and you're done (<code>mitmdump -p 443 -R
-https2http://localhost:80/</code>). There are better tools for this specific
+http://localhost:80/</code>). There are better tools for this specific
 task, but mitmproxy is very quick and simple way to set up an SSL-speaking
 server.
 
 - Want to add a non-SSL-capable compression proxy in front of your server? You
-could even spawn a mitmproxy instance that terminates SSL (https2http://...),
+could even spawn a mitmproxy instance that terminates SSL (-R http://...),
 point it to the compression proxy and let the compression proxy point to a
-SSL-initiating mitmproxy (http2https://...), which then points to the real
+SSL-initiating mitmproxy (-R https://...), which then points to the real
 server. As you see, it's a fairly flexible thing.
 
 Note that mitmproxy supports either an HTTP or an HTTPS upstream server, not
diff --git a/libmproxy/protocol2/reverse_proxy.py b/libmproxy/protocol2/reverse_proxy.py
index c4cabccc..3ca998d5 100644
--- a/libmproxy/protocol2/reverse_proxy.py
+++ b/libmproxy/protocol2/reverse_proxy.py
@@ -1,7 +1,6 @@
 from __future__ import (absolute_import, print_function, division)
 
 from .layer import Layer, ServerConnectionMixin
-from .tls import TlsLayer
 
 
 class ReverseProxy(Layer, ServerConnectionMixin):
diff --git a/libmproxy/protocol2/root_context.py b/libmproxy/protocol2/root_context.py
index 210ba6ab..daea54bd 100644
--- a/libmproxy/protocol2/root_context.py
+++ b/libmproxy/protocol2/root_context.py
@@ -10,6 +10,7 @@ from .layer import ServerConnectionMixin
 from .http_proxy import HttpProxy, HttpUpstreamProxy
 from .reverse_proxy import ReverseProxy
 
+
 class RootContext(object):
     """
     The outmost context provided to the root layer.
diff --git a/test/test_cmdline.py b/test/test_cmdline.py
index 1443ee1c..bb54d011 100644
--- a/test/test_cmdline.py
+++ b/test/test_cmdline.py
@@ -51,10 +51,6 @@ def test_parse_server_spec():
         "Invalid server specification",
         cmdline.parse_server_spec,
         "http://")
-    tutils.raises(
-        "Invalid server specification",
-        cmdline.parse_server_spec,
-        "https2http://foo.com")
 
 
 def test_parse_setheaders():
diff --git a/test/test_server.py b/test/test_server.py
index b691804b..66c3a0ae 100644
--- a/test/test_server.py
+++ b/test/test_server.py
@@ -468,7 +468,7 @@ class TestHttps2Http(tservers.ReverseProxTest):
     @classmethod
     def get_proxy_config(cls):
         d = super(TestHttps2Http, cls).get_proxy_config()
-        d["upstream_server"] = ("https2http", d["upstream_server"][1])
+        d["upstream_server"] = ("http", d["upstream_server"][1])
         return d
 
     def pathoc(self, ssl, sni=None):
@@ -476,7 +476,7 @@ class TestHttps2Http(tservers.ReverseProxTest):
             Returns a connected Pathoc instance.
         """
         p = pathoc.Pathoc(
-            ("localhost", self.proxy.port), ssl=ssl, sni=sni, fp=None
+            ("localhost", self.proxy.port), ssl=True, sni=sni, fp=None
         )
         p.connect()
         return p
@@ -490,6 +490,10 @@ class TestHttps2Http(tservers.ReverseProxTest):
         assert p.request("get:'/p/200'").status_code == 200
         assert all("Error in handle_sni" not in msg for msg in self.proxy.log)
 
+    def test_http(self):
+        p = self.pathoc(ssl=False)
+        assert p.request("get:'/p/200'").status_code == 200
+
 
 class TestTransparent(tservers.TransparentProxTest, CommonMixin, TcpMixin):
     ssl = False

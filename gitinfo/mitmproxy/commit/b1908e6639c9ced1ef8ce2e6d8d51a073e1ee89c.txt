commit b1908e6639c9ced1ef8ce2e6d8d51a073e1ee89c
Author: Aldo Cortesi <aldo@nullcube.com>
Date:   Sun Aug 16 17:25:38 2015 +1200

    Updates
    
    build -> rtool to avoid clashing with standard pyinstaller dirs
    checklist updates
    script adaptations

diff --git a/.gitignore b/.gitignore
index 356e5994..dfd65745 100644
--- a/.gitignore
+++ b/.gitignore
@@ -9,3 +9,4 @@ MANIFEST
 
 /venv
 /release
+/build
diff --git a/osx-binaries b/osx-binaries
index 3cfe0913..657dbae9 100755
--- a/osx-binaries
+++ b/osx-binaries
@@ -7,10 +7,11 @@
 #   https://github.com/pyinstaller/pyinstaller/wiki/Recipe-Setuptools-Entry-Point
 # Once this is fixed, we can ditch the redundant command scripts.
 
-VENV=../venv.mitmproxy
+VENV=./venv
 PYINST_CMD="$VENV/bin/pyinstaller -F --clean"
 TMPDIR=./tmp
 CACHE="~/Library/Application Support/pyinstaller"
+MITMPROXY="../mitmproxy"
 
 
 if [ ! -d $VENV ]
@@ -44,23 +45,23 @@ rm -f dist/*
 rm -rf $TMPDIR
 rm -rf $CACHE
 
-$PYINST_CMD ./release/mitmdump.spec
-echo "Running mitmdump..."
-./dist/mitmdump --version || exit 1
+# $PYINST_CMD $MITMPROXY/release/mitmdump.spec
+# echo "Running mitmdump..."
+# ./dist/mitmdump --version || exit 1
 
-$PYINST_CMD ./release/mitmproxy.spec
+$PYINST_CMD $MITMPROXY/release/mitmproxy.spec
 echo "Running mitmproxy..."
 ./dist/mitmproxy --version || exit 1
 
-$PYINST_CMD ./release/mitmweb.spec
-echo "Running mitmweb..."
-./dist/mitmweb --version || exit 1
+# $PYINST_CMD $MITMPROXY/release/mitmweb.spec
+# echo "Running mitmweb..."
+# ./dist/mitmweb --version || exit 1
 
-DST=osx-mitmproxy-`./dist/mitmdump --shortversion 2>&1`
-mkdir -p $TMPDIR/$DST
-cp ./dist/mitmproxy $TMPDIR/$DST
-cp ./dist/mitmdump $TMPDIR/$DST
-cshape ./doc-src $TMPDIR/$DST/doc
-
-cd $TMPDIR
-tar -czvf $DST.tar.gz $DST
+# DST=osx-mitmproxy-`./dist/mitmdump --shortversion 2>&1`
+# mkdir -p $TMPDIR/$DST
+# cp ./dist/mitmproxy $TMPDIR/$DST
+# cp ./dist/mitmdump $TMPDIR/$DST
+# cshape ./doc-src $TMPDIR/$DST/doc
+#
+# cd $TMPDIR
+# tar -czvf $DST.tar.gz $DST
diff --git a/release-checklist.md b/release-checklist.md
index e6d9ae1f..59fa7623 100644
--- a/release-checklist.md
+++ b/release-checklist.md
@@ -1,35 +1,37 @@
 # Release Checklist
 
-## Test
-
-  - Create the source distributions, make sure the output is sensible:  
-    `./release/build.py release`  
-    All source distributions can be found in `./dist`.
+## Check out release versions
 
-  - Test the source distributions:  
-    `./release/build.py test`  
-    This creates a new virtualenv in `../venv.mitmproxy-release` and installs the distributions from `./dist` into it.
-
-## Release
+  - Check out the versions of pathod, netlib and mitmproxy due to be released
 
   - Verify that repositories are in a clean state:
-    `./release/build.py git status`
-
-  - Update the version number in `version.py` for all projects:  
-    `./release/build.py set-version 0.13`
+    `./build git status`
 
   - Ensure that the website style assets have been compiled for production, and synced to the docs.
 
   - Render the docs, update CONTRIBUTORS file:  
-    `./release/build.py docs contributors`
-  
-  - Make version bump commit for all projects, tag and push it:
-    `./release/build.py git commit -am "bump version"`
-    `./release/build.py git tag v0.13`  
-    `./release/build.py git push --tags`
+    `./build docs contributors`
+
+
+## Test
 
-  - Recreate the source distributions with updated version information:  
-    `./release/build.py sdist`
+  - Test the source distributions:  
+
+        `./build test`  
+
+    This does the following:
+        - creates a venv in release/venv
+        - creates source distributions in release/release
+        - installs the source distributions in the venv
+        - and runs all installed tools
+
+
+## Release
+
+  - Make a release commit for all projects, tag and push it:
+    `./build git commit -am "Release v0.13"`
+    `./build git tag v0.13`  
+    `./build git push --tags`
 
   - Build the OSX binaries
     - Follow instructions in osx-binaries
@@ -40,16 +42,19 @@
     `mv ./dist/* ~/mitmproxy/www.mitmproxy.org/src/download`
 
   - Upload distributions in `./dist` to PyPI:  
-    `./release/build.py upload`  
+    `./build upload`  
     You can test with [testpypi.python.org](https://testpypi.python.org/pypi) by passing `--repository test`.
     ([more info](https://tom-christie.github.io/articles/pypi/))
 
   - Now bump the version number to be ready for the next cycle:
 
-    **TODO**: We just shipped 0.12 - do we bump to 0.12.1 or 0.13 now? 
+    **TODO**: We just shipped 0.12 - do we bump to 0.12.1 or 0.13 now?
     We should probably just leave it as-is and only bump once we actually do the next release.
-    
+
+  - Bump the version number in `version.py` for all projects:  
+    `./build set-version 0.13`
+
     Also, we need a release policy. I propose the following:
       - By default, every release is a new minor (`0.x`) release and it will be pushed for all three projects.
       - Only if an emergency bugfix is needed, we push a new `0.x.y` bugfix release for a single project.
-        This matches with what we do in `setup.py`: `"netlib>=%s, <%s" % (version.MINORVERSION, version.NEXT_MINORVERSION)`
\ No newline at end of file
+        This matches with what we do in `setup.py`: `"netlib>=%s, <%s" % (version.MINORVERSION, version.NEXT_MINORVERSION)`
diff --git a/requirements.txt b/requirements.txt
index de1b90b2..0bb2e378 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -1,2 +1,3 @@
 click>=4.1
 twine>=1.5.0
+pyinstaller
diff --git a/build b/rtool
similarity index 91%
rename from build
rename to rtool
index 49e3213f..356ea963 100755
--- a/build
+++ b/rtool
@@ -2,8 +2,9 @@
 from __future__ import (
     absolute_import, print_function, division, unicode_literals
 )
-from contextlib import contextmanager
-from os.path import dirname, realpath, join, exists, normpath
+from os.path import join
+import contextlib
+import os.path
 import os
 import shutil
 import subprocess
@@ -19,10 +20,10 @@ if os.name == "nt":
 else:
     VENV_BIN = "bin"
 
-RELEASE_DIR = join(dirname(realpath(__file__)))
+RELEASE_DIR = join(os.path.dirname(os.path.realpath(__file__)))
+DIST_DIR = join(RELEASE_DIR, "release")
 ROOT_DIR = join(RELEASE_DIR, "..")
 MITMPROXY_DIR = join(ROOT_DIR, "mitmproxy")
-DIST_DIR = join(MITMPROXY_DIR, "dist")
 TEST_VENV_DIR = join(RELEASE_DIR, "venv")
 
 PROJECTS = ("netlib", "pathod", "mitmproxy")
@@ -34,13 +35,13 @@ TOOLS = {
 if os.name == "nt":
     TOOLS["mitmproxy"].remove("mitmproxy")
 VERSION_FILES = {
-    "mitmproxy": normpath(join(ROOT_DIR, "mitmproxy/libmproxy/version.py")),
-    "pathod": normpath(join(ROOT_DIR, "pathod/libpathod/version.py")),
-    "netlib": normpath(join(ROOT_DIR, "netlib/netlib/version.py")),
+    "mitmproxy": join(ROOT_DIR, "mitmproxy/libmproxy/version.py"),
+    "pathod": join(ROOT_DIR, "pathod/libpathod/version.py"),
+    "netlib": join(ROOT_DIR, "netlib/netlib/version.py"),
 }
 
 
-@contextmanager
+@contextlib.contextmanager
 def empty_pythonpath():
     """
     Make sure that the regular python installation is not on the python path,
@@ -52,7 +53,7 @@ def empty_pythonpath():
     os.environ["PYTHONPATH"] = pythonpath
 
 
-@contextmanager
+@contextlib.contextmanager
 def chdir(path):
     old_dir = os.getcwd()
     os.chdir(path)
@@ -158,7 +159,7 @@ def sdist(projects):
     """
     with empty_pythonpath():
         print("Building release...")
-        if exists(DIST_DIR):
+        if os.path.exists(DIST_DIR):
             shutil.rmtree(DIST_DIR)
         for project in projects:
             print("Creating %s source distribution..." % project)
@@ -171,22 +172,20 @@ def sdist(projects):
             )
 
 
-@cli.command("test")
+@cli.command("mkvenv")
 @click.option(
     '--project', '-p', 'projects',
     multiple=True, type=click.Choice(PROJECTS), default=PROJECTS
 )
 @click.pass_context
-def test(ctx, projects):
+def mkvenv(ctx, projects):
     """
-    Test the source distribution
+    make a venv and test the source distribution
     """
-    if not exists(DIST_DIR):
-        ctx.invoke(sdist)
-
+    ctx.invoke(sdist)
     with empty_pythonpath():
         print("Creating virtualenv for test install...")
-        if exists(TEST_VENV_DIR):
+        if os.path.exists(TEST_VENV_DIR):
             shutil.rmtree(TEST_VENV_DIR)
         subprocess.check_call(["virtualenv", "-q", TEST_VENV_DIR])
 
@@ -206,7 +205,7 @@ def test(ctx, projects):
 
             print("Virtualenv available for further testing:")
             print(
-                "source %s" % normpath(
+                "source %s" % os.path.normpath(
                     join(TEST_VENV_DIR, VENV_BIN, "activate")
                 )
             )

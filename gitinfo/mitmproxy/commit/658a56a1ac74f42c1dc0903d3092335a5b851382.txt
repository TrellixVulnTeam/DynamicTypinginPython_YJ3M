commit 658a56a1ac74f42c1dc0903d3092335a5b851382
Author: Maximilian Hils <git@maximilianhils.com>
Date:   Sun Aug 31 02:09:04 2014 +0200

    use setuptools entrypoints rather than scripts

diff --git a/pathod b/libpathod/main.py
old mode 100755
new mode 100644
similarity index 54%
rename from pathod
rename to libpathod/main.py
index 2e9fafc4..6f53832d
--- a/pathod
+++ b/libpathod/main.py
@@ -1,16 +1,181 @@
 #!/usr/bin/env python
-import argparse, sys, logging, logging.handlers
-import os
-from libpathod import pathod, utils, version, language
+import argparse, sys, logging, logging.handlers, os
+from . import pathoc as _pathoc, pathod as _pathod, utils, version, language
+from netlib import tcp, http_uastrings
 
 
-def daemonize (stdin='/dev/null', stdout='/dev/null', stderr='/dev/null'):
+def pathoc():
+    preparser = argparse.ArgumentParser(add_help=False)
+    preparser.add_argument(
+        "--show-uas", dest="showua", action="store_true", default=False,
+        help="Print user agent shortcuts and exit."
+    )
+    pa = preparser.parse_known_args()[0]
+    if pa.showua:
+        print "User agent strings:"
+        for i in http_uastrings.UASTRINGS:
+            print "  ", i[1], i[0]
+        sys.exit(0)
+
+    parser = argparse.ArgumentParser(description='A perverse HTTP client.', parents=[preparser])
+    parser.add_argument('--version', action='version', version="pathoc " + version.VERSION)
+    parser.add_argument(
+        "-c", dest="connect_to", type=str, default=False,
+        metavar = "HOST:PORT",
+        help="Issue an HTTP CONNECT to connect to the specified host."
+    )
+    parser.add_argument(
+        "-n", dest='repeat', default=1, type=int, metavar="N",
+        help='Repeat requests N times'
+    )
+    parser.add_argument(
+        "-p", dest="port", type=int, default=None,
+        help="Port. Defaults to 80, or 443 if SSL is active"
+    )
+    parser.add_argument(
+        "-t", dest="timeout", type=int, default=None,
+        help="Connection timeout"
+    )
+    parser.add_argument(
+        'host', type=str,
+        help='Host to connect to'
+    )
+    parser.add_argument(
+        'request', type=str, nargs="+",
+        help='Request specification'
+    )
+
+    group = parser.add_argument_group(
+        'SSL',
+    )
+    group.add_argument(
+        "-s", dest="ssl", action="store_true", default=False,
+        help="Connect with SSL"
+    )
+    group.add_argument(
+        "-C", dest="clientcert", type=str, default=False,
+        help="Path to a file containing client certificate and private key"
+    )
+    group.add_argument(
+        "-i", dest="sni", type=str, default=False,
+        help="SSL Server Name Indication"
+    )
+    group.add_argument(
+        "--ciphers", dest="ciphers", type=str, default=False,
+        help="SSL cipher specification"
+    )
+    group.add_argument(
+        "--sslversion", dest="sslversion", type=int, default=4,
+        choices=[1, 2, 3, 4],
+        help="Use a specified protocol - TLSv1, SSLv2, SSLv3, SSLv23. Default to SSLv23."
+    )
+
+    group = parser.add_argument_group(
+        'Controlling Output',
+        """
+            Some of these options expand generated values for logging - if
+            you're generating large data, use them with caution.
+        """
+    )
+    group.add_argument(
+        "-I", dest="ignorecodes", type=str, default="",
+        help="Comma-separated list of response codes to ignore"
+    )
+    group.add_argument(
+        "-S", dest="showssl", action="store_true", default=False,
+        help="Show info on SSL connection"
+    )
+    group.add_argument(
+        "-e", dest="explain", action="store_true", default=False,
+        help="Explain requests"
+    )
+    group.add_argument(
+        "-o", dest="oneshot", action="store_true", default=False,
+        help="Oneshot - exit after first non-ignored response"
+    )
+    group.add_argument(
+        "-q", dest="showreq", action="store_true", default=False,
+        help="Print full request"
+    )
+    group.add_argument(
+        "-r", dest="showresp", action="store_true", default=False,
+        help="Print full response"
+    )
+    group.add_argument(
+        "-T", dest="ignoretimeout", action="store_true", default=False,
+        help="Ignore timeouts"
+    )
+    group.add_argument(
+        "-x", dest="hexdump", action="store_true", default=False,
+        help="Output in hexdump format"
+    )
+
+    args = parser.parse_args()
+
+    if args.port is None:
+        port = 443 if args.ssl else 80
+    else:
+        port = args.port
+
+    try:
+        codes = [int(i) for i in args.ignorecodes.split(",") if i]
+    except ValueError:
+        parser.error("Invalid return code specification: %s"%args.ignorecodes)
+
+    if args.connect_to:
+        parts = args.connect_to.split(":")
+        if len(parts) != 2:
+            parser.error("Invalid CONNECT specification: %s"%args.connect_to)
+        try:
+            parts[1] = int(parts[1])
+        except ValueError:
+            parser.error("Invalid CONNECT specification: %s"%args.connect_to)
+        connect_to = parts
+    else:
+        connect_to = None
+
+    try:
+        for i in range(args.repeat):
+            p = _pathoc.Pathoc(
+                (args.host, port),
+                ssl=args.ssl,
+                sni=args.sni,
+                sslversion=args.sslversion,
+                clientcert=args.clientcert,
+                ciphers=args.ciphers
+            )
+            try:
+                p.connect(connect_to)
+            except (tcp.NetLibError, _pathoc.PathocError), v:
+                print >> sys.stderr, str(v)
+                sys.exit(1)
+            if args.timeout:
+                p.settimeout(args.timeout)
+            for spec in args.request:
+                ret = p.print_request(
+                    spec,
+                    showreq=args.showreq,
+                    showresp=args.showresp,
+                    explain=args.explain,
+                    showssl=args.showssl,
+                    hexdump=args.hexdump,
+                    ignorecodes=codes,
+                    ignoretimeout=args.ignoretimeout
+                )
+                sys.stdout.flush()
+                if ret and args.oneshot:
+                    sys.exit(0)
+    except KeyboardInterrupt:
+        pass
+
+
+def daemonize(stdin='/dev/null', stdout='/dev/null', stderr='/dev/null'):
     try:
         pid = os.fork()
         if pid > 0:
             sys.exit(0)
     except OSError, e:
-        sys.stderr.write ("fork #1 failed: (%d) %s\n" % (e.errno, e.strerror) )
+        sys.stderr.write("fork #1 failed: (%d) %s\n" % (e.errno, e.strerror))
         sys.exit(1)
     os.chdir("/")
     os.umask(0)
@@ -20,7 +185,7 @@ def daemonize (stdin='/dev/null', stdout='/dev/null', stderr='/dev/null'):
         if pid > 0:
             sys.exit(0)
     except OSError, e:
-        sys.stderr.write ("fork #2 failed: (%d) %s\n" % (e.errno, e.strerror) )
+        sys.stderr.write("fork #2 failed: (%d) %s\n" % (e.errno, e.strerror))
         sys.exit(1)
     si = open(stdin, 'rb')
     so = open(stdout, 'a+b')
@@ -30,7 +195,7 @@ def daemonize (stdin='/dev/null', stdout='/dev/null', stderr='/dev/null'):
     os.dup2(se.fileno(), sys.stderr.fileno())
 
 
-def main(parser, args):
+def pathod_main(parser, args):
     certs = []
     for i in args.ssl_certs:
         parts = i.split("=", 1)
@@ -41,7 +206,7 @@ def main(parser, args):
             parser.error("Certificate file does not exist: %s"%parts[1])
         certs.append(parts)
 
-    ssloptions = pathod.SSLOptions(
+    ssloptions = _pathod.SSLOptions(
         cn = args.cn,
         confdir = args.confdir,
         not_after_connect = args.ssl_not_after_connect,
@@ -85,7 +250,7 @@ def main(parser, args):
             parser.error(v)
 
     try:
-        pd = pathod.Pathod(
+        pd = _pathod.Pathod(
             (args.address, args.port),
             craftanchor = args.craftanchor,
             ssl = args.ssl,
@@ -103,7 +268,7 @@ def main(parser, args):
             hexdump = args.hexdump,
             explain = args.explain,
         )
-    except pathod.PathodError, v:
+    except _pathod.PathodError, v:
         parser.error(str(v))
     except language.FileAccessDenied, v:
         parser.error("%s You probably want to a -d argument."%str(v))
@@ -115,7 +280,7 @@ def main(parser, args):
         pass
 
 
-if __name__ == "__main__":
+def pathod():
     parser = argparse.ArgumentParser(description='A pathological HTTP/S daemon.')
     parser.add_argument('--version', action='version', version="pathod " + version.VERSION)
     parser.add_argument("-p", dest='port', default=9999, type=int, help='Port. Specify 0 to pick an arbitrary empty port.')
@@ -166,7 +331,6 @@ if __name__ == "__main__":
         help='Disable response crafting. If anchors are specified, they still work.'
     )
 
-
     group = parser.add_argument_group(
         'SSL',
     )
@@ -176,7 +340,7 @@ if __name__ == "__main__":
     )
     group.add_argument(
         "--cn", dest="cn", type=str, default=None,
-        help="CN for generated SSL certs. Default: %s"%pathod.DEFAULT_CERT_DOMAIN
+        help="CN for generated SSL certs. Default: %s"%_pathod.DEFAULT_CERT_DOMAIN
     )
     group.add_argument(
         "-C", dest='ssl_not_after_connect', default=False, action="store_true",
@@ -184,7 +348,7 @@ if __name__ == "__main__":
     )
     group.add_argument(
         "--cert", dest='ssl_certs', default=[], type=str,
-        metavar = "SPEC", action="append", 
+        metavar = "SPEC", action="append",
         help='Add an SSL certificate. SPEC is of the form "[domain=]path". '\
              'The domain may include a wildcard, and is equal to "*" if not specified. '\
              'The file at path is a certificate in PEM format. If a private key is included in the PEM, '\
@@ -230,5 +394,8 @@ if __name__ == "__main__":
     args = parser.parse_args()
     if args.daemonize:
         daemonize()
-    main(parser, args)
+    pathod_main(parser, args)
 
+
+if __name__ == "__main__":
+    pathoc()
\ No newline at end of file
diff --git a/pathoc b/pathoc
deleted file mode 100755
index b1045c80..00000000
--- a/pathoc
+++ /dev/null
@@ -1,170 +0,0 @@
-#!/usr/bin/env python
-import argparse, sys
-from libpathod import pathoc, version, language
-from netlib import tcp, http_uastrings
-
-if __name__ == "__main__":
-    preparser = argparse.ArgumentParser(add_help=False)
-    preparser.add_argument(
-        "--show-uas", dest="showua", action="store_true", default=False,
-        help="Print user agent shortcuts and exit."
-    )
-    pa = preparser.parse_known_args()[0]
-    if pa.showua:
-        print "User agent strings:"
-        for i in http_uastrings.UASTRINGS:
-            print "  ", i[1], i[0]
-        sys.exit(0)
-
-    parser = argparse.ArgumentParser(description='A perverse HTTP client.', parents=[preparser])
-    parser.add_argument('--version', action='version', version="pathoc " + version.VERSION)
-    parser.add_argument(
-        "-c", dest="connect_to", type=str, default=False,
-        metavar = "HOST:PORT",
-        help="Issue an HTTP CONNECT to connect to the specified host."
-    )
-    parser.add_argument(
-        "-n", dest='repeat', default=1, type=int, metavar="N",
-        help='Repeat requests N times'
-    )
-    parser.add_argument(
-        "-p", dest="port", type=int, default=None,
-        help="Port. Defaults to 80, or 443 if SSL is active"
-    )
-    parser.add_argument(
-        "-t", dest="timeout", type=int, default=None,
-        help="Connection timeout"
-    )
-    parser.add_argument(
-        'host', type=str,
-        help='Host to connect to'
-    )
-    parser.add_argument(
-        'request', type=str, nargs="+",
-        help='Request specification'
-    )
-
-
-    group = parser.add_argument_group(
-        'SSL',
-    )
-    group.add_argument(
-        "-s", dest="ssl", action="store_true", default=False,
-        help="Connect with SSL"
-    )
-    group.add_argument(
-        "-C", dest="clientcert", type=str, default=False,
-        help="Path to a file containing client certificate and private key"
-    )
-    group.add_argument(
-        "-i", dest="sni", type=str, default=False,
-        help="SSL Server Name Indication"
-    )
-    group.add_argument(
-        "--ciphers", dest="ciphers", type=str, default=False,
-        help="SSL cipher specification"
-    )
-    group.add_argument(
-        "--sslversion", dest="sslversion", type=int, default=4,
-        choices=[1, 2, 3, 4],
-        help="Use a specified protocol - TLSv1, SSLv2, SSLv3, SSLv23. Default to SSLv23." 
-    )
-
-    group = parser.add_argument_group(
-        'Controlling Output',
-        """
-            Some of these options expand generated values for logging - if
-            you're generating large data, use them with caution.
-        """
-    )
-    group.add_argument(
-        "-I", dest="ignorecodes", type=str, default="",
-        help="Comma-separated list of response codes to ignore"
-    )
-    group.add_argument(
-        "-S", dest="showssl", action="store_true", default=False,
-        help="Show info on SSL connection"
-    )
-    group.add_argument(
-        "-e", dest="explain", action="store_true", default=False,
-        help="Explain requests"
-    )
-    group.add_argument(
-        "-o", dest="oneshot", action="store_true", default=False,
-        help="Oneshot - exit after first non-ignored response"
-    )
-    group.add_argument(
-        "-q", dest="showreq", action="store_true", default=False,
-        help="Print full request"
-    )
-    group.add_argument(
-        "-r", dest="showresp", action="store_true", default=False,
-        help="Print full response"
-    )
-    group.add_argument(
-        "-T", dest="ignoretimeout", action="store_true", default=False,
-        help="Ignore timeouts"
-    )
-    group.add_argument(
-        "-x", dest="hexdump", action="store_true", default=False,
-        help="Output in hexdump format"
-    )
-
-    args = parser.parse_args()
-
-    if args.port is None:
-        port = 443 if args.ssl else 80
-    else:
-        port = args.port
-
-    try:
-        codes = [int(i) for i in args.ignorecodes.split(",") if i]
-    except ValueError:
-        parser.error("Invalid return code specification: %s"%args.ignorecodes)
-
-    if args.connect_to:
-        parts = args.connect_to.split(":")
-        if len(parts) != 2:
-            parser.error("Invalid CONNECT specification: %s"%args.connect_to)
-        try:
-            parts[1] = int(parts[1])
-        except ValueError:
-            parser.error("Invalid CONNECT specification: %s"%args.connect_to)
-        connect_to = parts
-    else:
-        connect_to = None
-
-    try:
-        for i in range(args.repeat):
-            p = pathoc.Pathoc(
-                (args.host, port),
-                ssl=args.ssl,
-                sni=args.sni,
-                sslversion=args.sslversion,
-                clientcert=args.clientcert,
-                ciphers=args.ciphers
-            )
-            try:
-                p.connect(connect_to)
-            except (tcp.NetLibError, pathoc.PathocError), v:
-                print >> sys.stderr, str(v)
-                sys.exit(1)
-            if args.timeout:
-                p.settimeout(args.timeout)
-            for spec in args.request:
-                ret = p.print_request(
-                    spec,
-                    showreq=args.showreq,
-                    showresp=args.showresp,
-                    explain=args.explain,
-                    showssl=args.showssl,
-                    hexdump=args.hexdump,
-                    ignorecodes=codes,
-                    ignoretimeout=args.ignoretimeout
-                )
-                sys.stdout.flush()
-                if ret and args.oneshot:
-                    sys.exit(0)
-    except KeyboardInterrupt:
-        pass
-
diff --git a/setup.py b/setup.py
index 80eb2b06..2ff2d0be 100644
--- a/setup.py
+++ b/setup.py
@@ -79,7 +79,12 @@ setup(
     url="http://pathod.net",
     packages=packages,
     package_data=package_data,
-    scripts=["pathod", "pathoc"],
+    entry_points={
+        'console_scripts': [
+            "pathod = libpathod.main:pathod",
+            "pathoc = libpathod.main:pathoc"
+        ]
+    },
     classifiers=[
         "License :: OSI Approved :: MIT License",
         "Development Status :: 5 - Production/Stable",

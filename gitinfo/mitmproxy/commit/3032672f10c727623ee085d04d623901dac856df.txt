commit 3032672f10c727623ee085d04d623901dac856df
Author: Maximilian Hils <git@maximilianhils.com>
Date:   Sat Mar 8 15:47:09 2014 +0100

    combine asterisk-form and origin-form into relative form

diff --git a/libmproxy/protocol/http.py b/libmproxy/protocol/http.py
index bddd87df..8a2583b1 100644
--- a/libmproxy/protocol/http.py
+++ b/libmproxy/protocol/http.py
@@ -185,10 +185,9 @@ class HTTPRequest(HTTPMessage):
         to False to make checking for the presence of content natural.
 
         form_in: The request form which mitmproxy has received. The following values are possible:
-                 - origin (GET /index.html)
+                 - relative (GET /index.html, OPTIONS *) (covers origin form and asterisk form)
                  - absolute (GET http://example.com:80/index.html)
                  - authority-form (CONNECT example.com:443)
-                 - asterisk-form (OPTIONS *)
                  Details: http://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-25#section-5.3
 
         form_out: The request form which mitmproxy has send out to the destination
@@ -269,10 +268,8 @@ class HTTPRequest(HTTPMessage):
             raise http.HttpError(400, "Bad HTTP request line: %s" % repr(request_line))
         method, path, httpversion = request_line_parts
 
-        if path == '*':
-            form_in = "asterisk"
-        elif path.startswith("/"):
-            form_in = "origin"
+        if path == '*' or path.startswith("/"):
+            form_in = "relative"
             if not netlib.utils.isascii(path):
                 raise http.HttpError(400, "Bad HTTP request line: %s" % repr(request_line))
         elif method.upper() == 'CONNECT':
@@ -303,9 +300,9 @@ class HTTPRequest(HTTPMessage):
     def _assemble_first_line(self, form=None):
         form = form or self.form_out
 
-        if form == "asterisk" or \
-           form == "origin":
-            request_line = '%s %s HTTP/%s.%s' % (self.method, self.path, self.httpversion[0], self.httpversion[1])
+        if form == "relative":
+            path = self.path if self.method != "OPTIONS" else "*"
+            request_line = '%s %s HTTP/%s.%s' % (self.method, path, self.httpversion[0], self.httpversion[1])
         elif form == "authority":
             request_line = '%s %s:%s HTTP/%s.%s' % (self.method, self.host, self.port,
                                                     self.httpversion[0], self.httpversion[1])
@@ -1038,7 +1035,7 @@ class HTTPHandler(ProtocolHandler, TemporaryServerChangeMixin):
                 if request.scheme != "http":
                     raise http.HttpError(400, "Invalid Request")
                 if not self.c.config.forward_proxy:
-                    request.form_out = "origin"
+                    request.form_out = "relative"
                     self.c.set_server_address((request.host, request.port), AddressPriority.FROM_PROTOCOL)
                     flow.server_conn = self.c.server_conn  # Update server_conn attribute on the flow
             else:
diff --git a/test/test_protocol_http.py b/test/test_protocol_http.py
index d2ba24de..1d8872cc 100644
--- a/test/test_protocol_http.py
+++ b/test/test_protocol_http.py
@@ -29,7 +29,7 @@ class TestHTTPRequest:
         s = StringIO("OPTIONS * HTTP/1.1")
         f = tutils.tflow_noreq()
         f.request = HTTPRequest.from_stream(s)
-        assert f.request.form_in == "asterisk"
+        assert f.request.form_in == "relative"
         x = f.request._assemble()
         assert f.request._assemble() == "OPTIONS * HTTP/1.1\r\nHost: address:22\r\n\r\n"
 
@@ -95,7 +95,7 @@ class TestInvalidRequests(tservers.HTTPProxTest):
         assert r.status_code == 502
         assert "Must not CONNECT on already encrypted connection" in r.content
 
-    def test_origin_request(self):
+    def test_relative_request(self):
         p = self.pathoc_raw()
         p.connect()
         r = p.request("get:/p/200")
@@ -181,15 +181,15 @@ class TestProxyChainingSSLReconnect(tservers.HTTPChainProxyTest):
         assert self.proxy.tmaster.state._flow_list[1].response
 
         assert self.chain[1].tmaster.state._flow_list[0].request.form_in == "authority"
-        assert self.chain[1].tmaster.state._flow_list[1].request.form_in == "origin"
+        assert self.chain[1].tmaster.state._flow_list[1].request.form_in == "relative"
 
         assert self.chain[0].tmaster.state._flow_list[0].request.form_in == "authority"
-        assert self.chain[0].tmaster.state._flow_list[1].request.form_in == "origin"
+        assert self.chain[0].tmaster.state._flow_list[1].request.form_in == "relative"
         assert self.chain[0].tmaster.state._flow_list[2].request.form_in == "authority"
-        assert self.chain[0].tmaster.state._flow_list[3].request.form_in == "origin"
+        assert self.chain[0].tmaster.state._flow_list[3].request.form_in == "relative"
 
-        assert self.proxy.tmaster.state._flow_list[0].request.form_in == "origin"
-        assert self.proxy.tmaster.state._flow_list[1].request.form_in == "origin"
+        assert self.proxy.tmaster.state._flow_list[0].request.form_in == "relative"
+        assert self.proxy.tmaster.state._flow_list[1].request.form_in == "relative"
 
         req = p.request("get:'/p/418:b\"content2\"'")
 
diff --git a/test/tutils.py b/test/tutils.py
index 75fb7c0b..b1bfc831 100644
--- a/test/tutils.py
+++ b/test/tutils.py
@@ -55,7 +55,7 @@ def treq(conn=None, content="content"):
     headers["header"] = ["qvalue"]
 
     f = http.HTTPFlow(conn, server_conn)
-    f.request = http.HTTPRequest("origin", "GET", None, None, None, "/path", (1, 1), headers, content,
+    f.request = http.HTTPRequest("relative", "GET", None, None, None, "/path", (1, 1), headers, content,
                                  None, None, None)
     f.request.reply = controller.DummyReply()
     return f.request

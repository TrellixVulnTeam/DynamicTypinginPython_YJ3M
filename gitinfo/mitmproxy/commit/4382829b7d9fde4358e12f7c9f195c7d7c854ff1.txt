commit 4382829b7d9fde4358e12f7c9f195c7d7c854ff1
Author: Maximilian Hils <git@maximilianhils.com>
Date:   Fri Jul 25 18:47:48 2014 +0200

    workaround: always make sure that flow.response.reply exists

diff --git a/libmproxy/console/common.py b/libmproxy/console/common.py
index c59d52a0..a8440f79 100644
--- a/libmproxy/console/common.py
+++ b/libmproxy/console/common.py
@@ -197,7 +197,7 @@ def format_flow(f, focus, extended=False, hostheader=False, padding=2):
         d.update(dict(
             resp_code = f.response.code,
             resp_is_replay = f.response.is_replay,
-            resp_acked = hasattr(f.response, "reply") and f.response.reply.acked,
+            resp_acked = f.response.reply.acked,
             resp_clen = contentdesc,
             resp_rate = "{0}/s".format(rate),
         ))
diff --git a/libmproxy/console/flowview.py b/libmproxy/console/flowview.py
index ac10e809..4aaf8944 100644
--- a/libmproxy/console/flowview.py
+++ b/libmproxy/console/flowview.py
@@ -153,7 +153,7 @@ class FlowView(common.WWrap):
 
     def cont_view_handle_missing(self, conn, viewmode):
             if conn.content == CONTENT_MISSING:
-                msg, body = "", [urwid.Text([("error", "[content missing]")])], 0
+                msg, body = "", [urwid.Text([("error", "[content missing]")])]
             else:
                 msg, body = self.content_view(viewmode, conn)
 
diff --git a/libmproxy/controller.py b/libmproxy/controller.py
index 63e44241..4a72cf80 100644
--- a/libmproxy/controller.py
+++ b/libmproxy/controller.py
@@ -49,7 +49,7 @@ class Channel:
             try:
                 # The timeout is here so we can handle a should_exit event.
                 g = m.reply.q.get(timeout=0.5)
-            except Queue.Empty: # pragma: nocover
+            except Queue.Empty:  # pragma: nocover
                 continue
             return g
 
diff --git a/libmproxy/flow.py b/libmproxy/flow.py
index 6b751bc9..fce4cd91 100644
--- a/libmproxy/flow.py
+++ b/libmproxy/flow.py
@@ -724,13 +724,14 @@ class FlowMaster(controller.Master):
         self.process_new_request(f)
         return f
 
-    def handle_responseheaders(self, f):
+    def handle_responseheaders(self, resp):
+        f = resp.flow
         self.run_script_hook("responseheaders", f)
 
         if self.stream_large_bodies:
             self.stream_large_bodies.run(f, False)
 
-        f.reply()
+        resp.reply()
         return f        
 
     def handle_response(self, r):
diff --git a/libmproxy/protocol/http.py b/libmproxy/protocol/http.py
index 8b9cb448..cc6533b2 100644
--- a/libmproxy/protocol/http.py
+++ b/libmproxy/protocol/http.py
@@ -921,7 +921,7 @@ class HTTPHandler(ProtocolHandler, TemporaryServerChangeMixin):
                 flow.response = self.get_response_from_server(flow.request, include_body=False)
 
                 # call the appropriate script hook - this is an opportunity for an inline script to set flow.stream = True
-                self.c.channel.ask("responseheaders", flow)
+                self.c.channel.ask("responseheaders", flow.response)
 
                 # now get the rest of the request body, if body still needs to be read but not streaming this response
                 if flow.response.stream:
@@ -931,8 +931,9 @@ class HTTPHandler(ProtocolHandler, TemporaryServerChangeMixin):
                                                                 self.c.config.body_size_limit,
                                                                 flow.request.method, flow.response.code, False)
 
-            flow.server_conn = self.c.server_conn  # no further manipulation of self.c.server_conn beyond this point
+            # no further manipulation of self.c.server_conn beyond this point
             # we can safely set it as the final attribute value here.
+            flow.server_conn = self.c.server_conn
 
             self.c.log("response", "debug", [flow.response._assemble_first_line()])
             response_reply = self.c.channel.ask("response", flow.response)

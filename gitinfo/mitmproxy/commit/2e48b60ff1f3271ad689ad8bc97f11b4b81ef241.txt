commit 2e48b60ff1f3271ad689ad8bc97f11b4b81ef241
Author: Aldo Cortesi <aldo@nullcube.com>
Date:   Mon Oct 3 14:37:45 2016 +1100

    Clarify channel interaction pattern
    
    Before this patch, it wasn't clear when the arguments to an event could be
    modified, and when a new object should be returned. After this patch, the right
    thing to do is to modify the arguments in 99% of cases. The only exception to
    this is root_layer, for which we can find a better structure down the track.

diff --git a/mitmproxy/protocol/http.py b/mitmproxy/protocol/http.py
index 744733a8..35b375de 100644
--- a/mitmproxy/protocol/http.py
+++ b/mitmproxy/protocol/http.py
@@ -219,10 +219,10 @@ class HttpLayer(base.Layer):
                 else:
                     # response was set by an inline script.
                     # we now need to emulate the responseheaders hook.
-                    flow = self.channel.ask("responseheaders", flow)
+                    self.channel.ask("responseheaders", flow)
 
                 self.log("response", "debug", [repr(flow.response)])
-                flow = self.channel.ask("response", flow)
+                self.channel.ask("response", flow)
                 self.send_response_to_client(flow)
 
                 if self.check_close_connection(flow):
@@ -253,7 +253,7 @@ class HttpLayer(base.Layer):
     def get_request_from_client(self, flow):
         request = self.read_request()
         flow.request = request
-        flow = self.channel.ask("requestheaders", flow)
+        self.channel.ask("requestheaders", flow)
         if request.headers.get("expect", "").lower() == "100-continue":
             # TODO: We may have to use send_response_headers for HTTP2 here.
             self.send_response(models.expect_continue_response)
@@ -339,7 +339,7 @@ class HttpLayer(base.Layer):
 
         # call the appropriate script hook - this is an opportunity for an
         # inline script to set flow.stream = True
-        flow = self.channel.ask("responseheaders", flow)
+        self.channel.ask("responseheaders", flow)
 
         if flow.response.stream:
             flow.response.data.content = None
@@ -372,11 +372,7 @@ class HttpLayer(base.Layer):
             if host_header:
                 flow.request.headers["host"] = host_header
             flow.request.scheme = "https" if self.__initial_server_tls else "http"
-
-        request_reply = self.channel.ask("request", flow)
-        if isinstance(request_reply, models.HTTPResponse):
-            flow.response = request_reply
-            return
+        self.channel.ask("request", flow)
 
     def establish_server_connection(self, host, port, scheme):
         address = tcp.Address((host, port))
diff --git a/test/mitmproxy/test_server.py b/test/mitmproxy/test_server.py
index 059ea856..ec59fbdf 100644
--- a/test/mitmproxy/test_server.py
+++ b/test/mitmproxy/test_server.py
@@ -807,8 +807,7 @@ class TestStreamRequest(tservers.HTTPProxyTest):
 class MasterFakeResponse(tservers.TestMaster):
     @controller.handler
     def request(self, f):
-        resp = HTTPResponse.wrap(netlib.tutils.tresp())
-        f.reply.send(resp)
+        f.response = HTTPResponse.wrap(netlib.tutils.tresp())
 
 
 class TestFakeResponse(tservers.HTTPProxyTest):
@@ -889,7 +888,7 @@ class MasterIncomplete(tservers.TestMaster):
     def request(self, f):
         resp = HTTPResponse.wrap(netlib.tutils.tresp())
         resp.content = None
-        f.reply.send(resp)
+        f.response = resp
 
 
 class TestIncompleteResponse(tservers.HTTPProxyTest):

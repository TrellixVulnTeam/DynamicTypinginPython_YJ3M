commit 6dda2b2ee544c3890f04b7bf99272998e29992b6
Author: Aldo Cortesi <aldo@nullcube.com>
Date:   Tue May 31 18:46:19 2016 +1200

    Module is part of the name - url.decode, not url.urldecode
    
    A pattern we need to use far more often in the codebase

diff --git a/mitmproxy/cmdline.py b/mitmproxy/cmdline.py
index d8bbe448..ad0427d2 100644
--- a/mitmproxy/cmdline.py
+++ b/mitmproxy/cmdline.py
@@ -105,7 +105,7 @@ def parse_setheader(s):
 
 def parse_server_spec(url):
     try:
-        p = netlib.http.url.parse_url(url)
+        p = netlib.http.url.parse(url)
         if p[0] not in ("http", "https"):
             raise ValueError()
     except ValueError:
diff --git a/mitmproxy/console/flowlist.py b/mitmproxy/console/flowlist.py
index 66d92fe1..1e65e3eb 100644
--- a/mitmproxy/console/flowlist.py
+++ b/mitmproxy/console/flowlist.py
@@ -343,7 +343,7 @@ class FlowListBox(urwid.ListBox):
         )
 
     def new_request(self, url, method):
-        parts = netlib.http.url.parse_url(str(url))
+        parts = netlib.http.url.parse(str(url))
         if not parts:
             signals.status_message.send(message="Invalid Url")
             return
diff --git a/mitmproxy/console/statusbar.py b/mitmproxy/console/statusbar.py
index 4cc63a54..20656cb4 100644
--- a/mitmproxy/console/statusbar.py
+++ b/mitmproxy/console/statusbar.py
@@ -203,7 +203,7 @@ class StatusBar(urwid.WidgetWrap):
 
         if self.master.server.config.mode in ["reverse", "upstream"]:
             dst = self.master.server.config.upstream_server
-            r.append("[dest:%s]" % netlib.utils.unparse_url(
+            r.append("[dest:%s]" % netlib.utils.unparse(
                 dst.scheme,
                 dst.address.host,
                 dst.address.port
diff --git a/mitmproxy/contentviews.py b/mitmproxy/contentviews.py
index 5c562f95..75e4273f 100644
--- a/mitmproxy/contentviews.py
+++ b/mitmproxy/contentviews.py
@@ -258,7 +258,7 @@ class ViewURLEncoded(View):
     content_types = ["application/x-www-form-urlencoded"]
 
     def __call__(self, data, **metadata):
-        d = url.urldecode(data)
+        d = url.decode(data)
         return "URLEncoded form", format_dict(ODict(d))
 
 
diff --git a/mitmproxy/protocol/http2.py b/mitmproxy/protocol/http2.py
index f4a6cf9d..ffea7fae 100644
--- a/mitmproxy/protocol/http2.py
+++ b/mitmproxy/protocol/http2.py
@@ -320,7 +320,7 @@ class Http2SingleStreamLayer(_HttpTransmissionLayer, threading.Thread):
         else:  # pragma: no cover
             first_line_format = "absolute"
             # FIXME: verify if path or :host contains what we need
-            scheme, host, port, _ = netlib.http.url.parse_url(path)
+            scheme, host, port, _ = netlib.http.url.parse(path)
 
         if authority:
             host, _, port = authority.partition(':')
diff --git a/netlib/http/http1/read.py b/netlib/http/http1/read.py
index f776d0b5..93fca04e 100644
--- a/netlib/http/http1/read.py
+++ b/netlib/http/http1/read.py
@@ -241,7 +241,7 @@ def _read_request_line(rfile):
             scheme, path = None, None
         else:
             form = "absolute"
-            scheme, host, port, path = url.parse_url(path)
+            scheme, host, port, path = url.parse(path)
 
         _check_http_version(http_version)
     except ValueError:
diff --git a/netlib/http/http2/connections.py b/netlib/http/http2/connections.py
index 4c15ee07..7c7ad693 100644
--- a/netlib/http/http2/connections.py
+++ b/netlib/http/http2/connections.py
@@ -118,7 +118,7 @@ class HTTP2Protocol(object):
         else:
             first_line_format = "absolute"
             # FIXME: verify if path or :host contains what we need
-            scheme, host, port, _ = url.parse_url(path)
+            scheme, host, port, _ = url.parse(path)
             scheme = scheme.decode('ascii')
             host = host.decode('ascii')
 
diff --git a/netlib/http/request.py b/netlib/http/request.py
index 170066f7..d552bc70 100644
--- a/netlib/http/request.py
+++ b/netlib/http/request.py
@@ -180,11 +180,11 @@ class Request(Message):
         """
         if self.first_line_format == "authority":
             return "%s:%d" % (self.host, self.port)
-        return netlib.http.url.unparse_url(self.scheme, self.host, self.port, self.path)
+        return netlib.http.url.unparse(self.scheme, self.host, self.port, self.path)
 
     @url.setter
     def url(self, url):
-        self.scheme, self.host, self.port, self.path = netlib.http.url.parse_url(url)
+        self.scheme, self.host, self.port, self.path = netlib.http.url.parse(url)
 
     def _parse_host_header(self):
         """Extract the host and port from Host header"""
@@ -220,7 +220,7 @@ class Request(Message):
         """
         if self.first_line_format == "authority":
             return "%s:%d" % (self.pretty_host, self.port)
-        return netlib.http.url.unparse_url(self.scheme, self.pretty_host, self.port, self.path)
+        return netlib.http.url.unparse(self.scheme, self.pretty_host, self.port, self.path)
 
     @property
     def query(self):
@@ -235,12 +235,12 @@ class Request(Message):
 
     def _get_query(self):
         _, _, _, _, query, _ = urllib.parse.urlparse(self.url)
-        return tuple(netlib.http.url.urldecode(query))
+        return tuple(netlib.http.url.decode(query))
 
     def _set_query(self, value):
-        query = netlib.http.url.urlencode(value)
+        query = netlib.http.url.encode(value)
         scheme, netloc, path, params, _, fragment = urllib.parse.urlparse(self.url)
-        _, _, _, self.path = netlib.http.url.parse_url(
+        _, _, _, self.path = netlib.http.url.parse(
             urllib.parse.urlunparse([scheme, netloc, path, params, query, fragment]))
 
     @query.setter
@@ -288,7 +288,7 @@ class Request(Message):
         components = map(lambda x: urllib.parse.quote(x, safe=""), components)
         path = "/" + "/".join(components)
         scheme, netloc, _, params, query, fragment = urllib.parse.urlparse(self.url)
-        _, _, _, self.path = netlib.http.url.parse_url(
+        _, _, _, self.path = netlib.http.url.parse(
             urllib.parse.urlunparse([scheme, netloc, path, params, query, fragment]))
 
     def anticache(self):
@@ -340,7 +340,7 @@ class Request(Message):
     def _get_urlencoded_form(self):
         is_valid_content_type = "application/x-www-form-urlencoded" in self.headers.get("content-type", "").lower()
         if is_valid_content_type:
-            return tuple(netlib.http.url.urldecode(self.content))
+            return tuple(netlib.http.url.decode(self.content))
         return ()
 
     def _set_urlencoded_form(self, value):
@@ -349,7 +349,7 @@ class Request(Message):
         This will overwrite the existing content if there is one.
         """
         self.headers["content-type"] = "application/x-www-form-urlencoded"
-        self.content = netlib.http.url.urlencode(value)
+        self.content = netlib.http.url.encode(value)
 
     @urlencoded_form.setter
     def urlencoded_form(self, value):
diff --git a/netlib/http/url.py b/netlib/http/url.py
index 3961998b..147ed572 100644
--- a/netlib/http/url.py
+++ b/netlib/http/url.py
@@ -19,7 +19,7 @@ def encode_parse_result(result, enc):
         return urllib.parse.ParseResult(*[x.encode(enc) for x in result])
 
 
-def parse_url(url):
+def parse(url):
     """
         URL-parsing function that checks that
             - port is an integer 0-65535
@@ -68,7 +68,7 @@ def parse_url(url):
     return parsed.scheme, host, port, full_path
 
 
-def unparse_url(scheme, host, port, path=""):
+def unparse(scheme, host, port, path=""):
     """
     Returns a URL string, constructed from the specified components.
 
@@ -80,7 +80,7 @@ def unparse_url(scheme, host, port, path=""):
     return "%s://%s%s" % (scheme, utils.hostport(scheme, host, port), path)
 
 
-def urlencode(s):
+def encode(s):
     """
         Takes a list of (key, value) tuples and returns a urlencoded string.
     """
@@ -88,7 +88,7 @@ def urlencode(s):
     return urllib.parse.urlencode(s, False)
 
 
-def urldecode(s):
+def decode(s):
     """
         Takes a urlencoded string and returns a list of (key, value) tuples.
     """
diff --git a/test/mitmproxy/test_contentview.py b/test/mitmproxy/test_contentview.py
index 57e5ae99..9142bdad 100644
--- a/test/mitmproxy/test_contentview.py
+++ b/test/mitmproxy/test_contentview.py
@@ -60,10 +60,10 @@ class TestContentView:
         assert f[0] == "Query"
 
     def test_view_urlencoded(self):
-        d = url.urlencode([("one", "two"), ("three", "four")])
+        d = url.encode([("one", "two"), ("three", "four")])
         v = cv.ViewURLEncoded()
         assert v(d)
-        d = url.urlencode([("adsfa", "")])
+        d = url.encode([("adsfa", "")])
         v = cv.ViewURLEncoded()
         assert v(d)
 
diff --git a/test/netlib/http/test_url.py b/test/netlib/http/test_url.py
index d777a949..697c83a8 100644
--- a/test/netlib/http/test_url.py
+++ b/test/netlib/http/test_url.py
@@ -1,65 +1,65 @@
 from netlib import tutils
 from netlib.http import url
 
-def test_parse_url():
+def test_parse():
     with tutils.raises(ValueError):
-        url.parse_url("")
+        url.parse("")
 
-    s, h, po, pa = url.parse_url(b"http://foo.com:8888/test")
+    s, h, po, pa = url.parse(b"http://foo.com:8888/test")
     assert s == b"http"
     assert h == b"foo.com"
     assert po == 8888
     assert pa == b"/test"
 
-    s, h, po, pa = url.parse_url("http://foo/bar")
+    s, h, po, pa = url.parse("http://foo/bar")
     assert s == b"http"
     assert h == b"foo"
     assert po == 80
     assert pa == b"/bar"
 
-    s, h, po, pa = url.parse_url(b"http://user:pass@foo/bar")
+    s, h, po, pa = url.parse(b"http://user:pass@foo/bar")
     assert s == b"http"
     assert h == b"foo"
     assert po == 80
     assert pa == b"/bar"
 
-    s, h, po, pa = url.parse_url(b"http://foo")
+    s, h, po, pa = url.parse(b"http://foo")
     assert pa == b"/"
 
-    s, h, po, pa = url.parse_url(b"https://foo")
+    s, h, po, pa = url.parse(b"https://foo")
     assert po == 443
 
     with tutils.raises(ValueError):
-        url.parse_url(b"https://foo:bar")
+        url.parse(b"https://foo:bar")
 
     # Invalid IDNA
     with tutils.raises(ValueError):
-        url.parse_url("http://\xfafoo")
+        url.parse("http://\xfafoo")
     # Invalid PATH
     with tutils.raises(ValueError):
-        url.parse_url("http:/\xc6/localhost:56121")
+        url.parse("http:/\xc6/localhost:56121")
     # Null byte in host
     with tutils.raises(ValueError):
-        url.parse_url("http://foo\0")
+        url.parse("http://foo\0")
     # Port out of range
-    _, _, port, _ = url.parse_url("http://foo:999999")
+    _, _, port, _ = url.parse("http://foo:999999")
     assert port == 80
     # Invalid IPv6 URL - see http://www.ietf.org/rfc/rfc2732.txt
     with tutils.raises(ValueError):
-        url.parse_url('http://lo[calhost')
+        url.parse('http://lo[calhost')
 
 
-def test_unparse_url():
-    assert url.unparse_url("http", "foo.com", 99, "") == "http://foo.com:99"
-    assert url.unparse_url("http", "foo.com", 80, "/bar") == "http://foo.com/bar"
-    assert url.unparse_url("https", "foo.com", 80, "") == "https://foo.com:80"
-    assert url.unparse_url("https", "foo.com", 443, "") == "https://foo.com"
+def test_unparse():
+    assert url.unparse("http", "foo.com", 99, "") == "http://foo.com:99"
+    assert url.unparse("http", "foo.com", 80, "/bar") == "http://foo.com/bar"
+    assert url.unparse("https", "foo.com", 80, "") == "https://foo.com:80"
+    assert url.unparse("https", "foo.com", 443, "") == "https://foo.com"
 
 
 def test_urlencode():
-    assert url.urlencode([('foo', 'bar')])
+    assert url.encode([('foo', 'bar')])
 
 
 def test_urldecode():
     s = "one=two&three=four"
-    assert len(url.urldecode(s)) == 2
+    assert len(url.decode(s)) == 2

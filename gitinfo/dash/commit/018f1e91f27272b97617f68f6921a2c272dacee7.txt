commit 018f1e91f27272b97617f68f6921a2c272dacee7
Author: chriddyp <chris@plot.ly>
Date:   Thu Mar 2 21:13:30 2017 -0500

    Handle callbacks returning content with dependencies

diff --git a/src/actions/index.js b/src/actions/index.js
index 22e694a0..382e3d12 100644
--- a/src/actions/index.js
+++ b/src/actions/index.js
@@ -13,10 +13,12 @@ import {
     pick,
     reject,
     sort,
+    type,
     union,
     view
 } from 'ramda';
 import {createAction} from 'redux-actions';
+import {crawlLayout, hasId} from '../reducers/utils';
 // TODO - Use whatwg-fetch instead of window.fetch
 // import fetch from 'whatwg-fetch';
 
@@ -47,7 +49,7 @@ export const initialize = function() {
 
             // TODO - will need to recompute paths when the layout changes
             // from request responses
-            dispatch(computePaths(layout));
+            dispatch(computePaths({subTree: layout, startingPath: []}));
         })).then(function() {
             fetch('/dependencies', {method: 'GET'})
             .then(res => res.json().then(dependencies => {
@@ -211,9 +213,64 @@ export const notifyObservers = function(payload) {
                 };
                 dispatch(updateProps(observerUpdatePayload));
 
+
                 // fire an event that the props have changed
                 // TODO - Need to wait for updateProps to finish?
                 dispatch(notifyObservers({event: 'propChange', id: eventObserverId}));
+
+                /*
+                 * If the response includes content which includes or
+                 * or removes items with IDs, then we need to update our
+                 * paths store.
+                 * TODO - Do we need to wait for updateProps to finish?
+                 */
+                if (type(observerUpdatePayload.props.content) === 'Object' &&
+                    !isEmpty(observerUpdatePayload.props.content)) {
+
+                    dispatch(computePaths({
+                        subTree: observerUpdatePayload.props.content,
+                        startingPath: concat(
+                            getState().paths[eventObserverId],
+                            ['props', 'content']
+                        )
+                    }));
+
+                    /*
+                     * And then we need to dispatch
+                     * an initialization propChange for all
+                     *  of _these_ components!
+                     * TODO: We're just naively crawling
+                     * the _entire_ layout to recompute the
+                     * the dependency graphs.
+                     * We don't need to do this - just need
+                     * to compute the subtree
+                     */
+                    const newIds = [];
+                    crawlLayout(
+                        observerUpdatePayload.props.content,
+                        function appendIds(child) {
+                            if (hasId(child)) {
+                                newIds.push(child.props.id);
+                            }
+                        }
+                    );
+                    // TODO - We might need to reset the
+                    // request queue here.
+                    const depOrder = EventGraph.overallOrder();
+                    const sortedIds = sort(
+                        (a, b) => depOrder.indexOf(a) - depOrder.indexOf(b),
+                        newIds
+                    );
+
+                    sortedIds.forEach(function(newId) {
+                        dispatch(notifyObservers({
+                            event: 'propChange', id: newId
+                        }));
+                    })
+
+                }
+
+
             }));
 
         }
diff --git a/src/reducers/paths.js b/src/reducers/paths.js
index 0ed4b051..eed74b82 100644
--- a/src/reducers/paths.js
+++ b/src/reducers/paths.js
@@ -1,21 +1,19 @@
-import {crawlLayout} from './utils'
+import {crawlLayout, hasId} from './utils'
 import R from 'ramda'
 
 const initialPaths = {};
 
+
 const paths = (state = initialPaths, action) => {
     switch (action.type) {
         case 'COMPUTE_PATHS': {
-            const layout = action.payload;
+            const {subTree, startingPath} = action.payload;
             const newState = Object.assign({}, state);
 
-            crawlLayout(layout, function assignPath(child, itempath) {
-                if(R.type(child) === 'Object' &&
-                   R.has('props', child) &&
-                   R.has('id', child.props)
-                ) {
+            crawlLayout(subTree, function assignPath(child, itempath) {
+                if(hasId(child)) {
 
-                    newState[child.props.id] = itempath;
+                    newState[child.props.id] = R.concat(startingPath, itempath);
 
                 }
             });
diff --git a/src/reducers/utils.js b/src/reducers/utils.js
index fdc8e65c..9feedd61 100644
--- a/src/reducers/utils.js
+++ b/src/reducers/utils.js
@@ -32,3 +32,11 @@ export const crawlLayout = (object, func, path=[]) => {
 
     }
 }
+
+export function hasId(child) {
+    return (
+        R.type(child) === 'Object' &&
+        R.has('props', child) &&
+        R.has('id', child.props)
+    );
+}
diff --git a/tests/test_render.py b/tests/test_render.py
index 10c38bce..e1bc8cef 100644
--- a/tests/test_render.py
+++ b/tests/test_render.py
@@ -443,27 +443,48 @@ class Tests(IntegrationTests):
         # call the callbacks immediately to set
         # the correct initial state
         wait_for(
-            lambda *args: (
+            lambda: (
                 self.driver.find_element_by_id('output')
-                 .get_attribute('innerHTML')) ==
-            '''
-            <div>
-                <input type="text/javascript" id="sub-input-1" value="sub input initial value">
-                <div id="sub-output-1">sub input inital value</div>
-            </div>'''.replace('\n', '').replace('    ', '')
+                    .get_attribute('innerHTML') == '''
+                <div>
+                    <input type="text/javascript" id="sub-input-1" value="sub input initial value">
+                    <div id="sub-output-1">
+                        sub input initial value
+                    </div>
+                </div>'''.replace('\n', '').replace('  ', '')
+        ))
+
+        # the paths should include these new output IDs
+        self.assertEqual(
+            self.driver.execute_script('return window.store.getState().paths'),
+            {
+                u'input': [
+                    u'props', u'content', 0
+                ],
+                u'output': [u'props', u'content', 1],
+                u'sub-input-1': [
+                    u'props', u'content', 1,
+                    u'props', u'content',
+                    u'props', u'content', 0
+                ],
+                u'sub-output-1': [
+                    u'props', u'content', 1,
+                    u'props', u'content',
+                    u'props', u'content', 1
+                ]
+            }
         )
 
         # editing the input should modify the sub output
         sub_input = self.driver.find_element_by_id('sub-input-1')
         sub_input.send_keys('a')
         wait_for(
-            lambda *args: (
-                self.driver.find_element_by_id('sub-output-1')
-                 .get_attribute('innerHTML')
-            ) == 'a'
+            lambda: (
+                self.driver.find_element_by_id('sub-output-1').text
+            ) == 'sub input initial valuea'
         )
 
-        self.assertEqual(call_count.value, 1)
+        self.assertEqual(call_count.value, 2)
 
         assert_clean_console(self)
 

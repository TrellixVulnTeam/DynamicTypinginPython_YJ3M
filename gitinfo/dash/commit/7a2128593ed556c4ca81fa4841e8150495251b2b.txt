commit 7a2128593ed556c4ca81fa4841e8150495251b2b
Author: alexcjohnson <alex@plot.ly>
Date:   Sun Sep 1 11:13:47 2019 -0400

    persistence initial commit

diff --git a/dash-renderer/src/APIController.react.js b/dash-renderer/src/APIController.react.js
index d95b1301..89b38b7d 100644
--- a/dash-renderer/src/APIController.react.js
+++ b/dash-renderer/src/APIController.react.js
@@ -10,6 +10,7 @@ import {
     hydrateInitialOutputs,
     setLayout,
 } from './actions/index';
+import {applyPersistence} from './persistence';
 import apiThunk from './actions/api';
 import {getAppState} from './reducers/constants';
 import {STATUS} from './constants/constants';
@@ -48,7 +49,7 @@ class UnconnectedContainer extends Component {
             dispatch(apiThunk('_dash-layout', 'GET', 'layoutRequest'));
         } else if (layoutRequest.status === STATUS.OK) {
             if (isEmpty(layout)) {
-                dispatch(setLayout(layoutRequest.content));
+                dispatch(setLayout(applyPersistence(layoutRequest.content)));
             } else if (isNil(paths)) {
                 dispatch(computePaths({subTree: layout, startingPath: []}));
             }
diff --git a/dash-renderer/src/TreeContainer.js b/dash-renderer/src/TreeContainer.js
index a2158ffd..247b72ca 100644
--- a/dash-renderer/src/TreeContainer.js
+++ b/dash-renderer/src/TreeContainer.js
@@ -22,6 +22,7 @@ import {
     type,
 } from 'ramda';
 import {notifyObservers, updateProps} from './actions';
+import {recordUiEdit} from './persistence';
 import ComponentErrorBoundary from './components/error/ComponentErrorBoundary.react';
 import checkPropTypes from 'check-prop-types';
 
@@ -164,6 +165,7 @@ class TreeContainer extends Component {
                 _dashprivate_dependencies,
                 _dashprivate_dispatch,
                 _dashprivate_path,
+                _dashprivate_layout,
             } = this.props;
 
             const id = this.getLayoutProps().id;
@@ -185,6 +187,10 @@ class TreeContainer extends Component {
                     )
             )(keysIn(newProps));
 
+            // setProps here is triggered by the UI - record these changes
+            // for persistence
+            recordUiEdit(_dashprivate_layout, newProps);
+
             // Always update this component's props
             _dashprivate_dispatch(
                 updateProps({
diff --git a/dash-renderer/src/actions/index.js b/dash-renderer/src/actions/index.js
index 4674fb0d..61cae7c7 100644
--- a/dash-renderer/src/actions/index.js
+++ b/dash-renderer/src/actions/index.js
@@ -16,6 +16,7 @@ import {
     lensPath,
     mergeLeft,
     mergeDeepRight,
+    path,
     pluck,
     propEq,
     reject,
@@ -31,6 +32,7 @@ import {getAction} from './constants';
 import cookie from 'cookie';
 import {uid, urlBase, isMultiOutputProp, parseMultipleOutputs} from '../utils';
 import {STATUS} from '../constants/constants';
+import {applyPersistence, prunePersistence} from '../persistence';
 
 export const updateProps = createAction(getAction('ON_PROP_CHANGE'));
 export const setRequestQueue = createAction(getAction('SET_REQUEST_QUEUE'));
@@ -530,6 +532,32 @@ function updateOutput(
         });
     }
 
+    function doUpdateProps(id, updatedProps) {
+        const {layout, paths} = getState();
+        const itempath = paths[id];
+        if (!itempath) {
+            return false;
+        }
+
+        // This is a callback-generated update.
+        // Check if this invalidates existing persisted prop values,
+        prunePersistence(path(itempath, layout), updatedProps);
+
+        // In case the update contains whole components, see if any of
+        // those components have props to update to persist user edits.
+        const finalProps = applyPersistence(updatedProps);
+
+        dispatch(
+            updateProps({
+                itempath,
+                props: finalProps,
+                source: 'response',
+            })
+        );
+
+        return finalProps;
+    }
+
     // Clientside hook
     if (clientside_function) {
         let returnValue;
@@ -587,24 +615,20 @@ function updateOutput(
             updateRequestQueue(false, STATUS.OK);
 
             // Update the layout with the new result
-            dispatch(
-                updateProps({
-                    itempath: getState().paths[outputId],
-                    props: updatedProps,
-                    source: 'response',
-                })
-            );
+            const appliedProps = doUpdateProps(outputId, updatedProps);
 
             /*
              * This output could itself be a serverside or clientside input
              * to another function
              */
-            dispatch(
-                notifyObservers({
-                    id: outputId,
-                    props: updatedProps,
-                })
-            );
+            if (appliedProps) {
+                dispatch(
+                    notifyObservers({
+                        id: outputId,
+                        props: appliedProps,
+                    })
+                );
+            }
         }
 
         if (isMultiOutputProp(payload.output)) {
@@ -717,20 +741,16 @@ function updateOutput(
                 const handleResponse = ([outputIdAndProp, props]) => {
                     // Backward compatibility
                     const pathKey = multi ? outputIdAndProp : outputComponentId;
-                    const observerUpdatePayload = {
-                        itempath: getState().paths[pathKey],
-                        props,
-                        source: 'response',
-                    };
-                    if (!observerUpdatePayload.itempath) {
+
+                    const appliedProps = doUpdateProps(pathKey, props);
+                    if (!appliedProps) {
                         return;
                     }
-                    dispatch(updateProps(observerUpdatePayload));
 
                     dispatch(
                         notifyObservers({
                             id: pathKey,
-                            props: props,
+                            props: appliedProps,
                         })
                     );
 
@@ -739,10 +759,11 @@ function updateOutput(
                      * paths store.
                      * TODO - Do we need to wait for updateProps to finish?
                      */
-                    if (has('children', observerUpdatePayload.props)) {
+                    if (has('children', appliedProps)) {
+                        const newChildren = appliedProps.children;
                         dispatch(
                             computePaths({
-                                subTree: observerUpdatePayload.props.children,
+                                subTree: newChildren,
                                 startingPath: concat(
                                     getState().paths[pathKey],
                                     ['props', 'children']
@@ -756,11 +777,8 @@ function updateOutput(
                          * new children components
                          */
                         if (
-                            contains(
-                                type(observerUpdatePayload.props.children),
-                                ['Array', 'Object']
-                            ) &&
-                            !isEmpty(observerUpdatePayload.props.children)
+                            contains(type(newChildren), ['Array', 'Object']) &&
+                            !isEmpty(newChildren)
                         ) {
                             /*
                              * TODO: We're just naively crawling
@@ -770,32 +788,27 @@ function updateOutput(
                              * to compute the subtree
                              */
                             const newProps = {};
-                            crawlLayout(
-                                observerUpdatePayload.props.children,
-                                function appendIds(child) {
-                                    if (hasId(child)) {
-                                        keys(child.props).forEach(childProp => {
-                                            const componentIdAndProp = `${child.props.id}.${childProp}`;
-                                            if (
-                                                has(
-                                                    componentIdAndProp,
-                                                    InputGraph.nodes
-                                                )
-                                            ) {
-                                                newProps[componentIdAndProp] = {
-                                                    id: child.props.id,
-                                                    props: {
-                                                        [childProp]:
-                                                            child.props[
-                                                                childProp
-                                                            ],
-                                                    },
-                                                };
-                                            }
-                                        });
-                                    }
+                            crawlLayout(newChildren, function appendIds(child) {
+                                if (hasId(child)) {
+                                    keys(child.props).forEach(childProp => {
+                                        const componentIdAndProp = `${child.props.id}.${childProp}`;
+                                        if (
+                                            has(
+                                                componentIdAndProp,
+                                                InputGraph.nodes
+                                            )
+                                        ) {
+                                            newProps[componentIdAndProp] = {
+                                                id: child.props.id,
+                                                props: {
+                                                    [childProp]:
+                                                        child.props[childProp],
+                                                },
+                                            };
+                                        }
+                                    });
                                 }
-                            );
+                            });
 
                             /*
                              * Organize props by shared outputs so that we
diff --git a/dash-renderer/src/persistence.js b/dash-renderer/src/persistence.js
new file mode 100644
index 00000000..92e9da77
--- /dev/null
+++ b/dash-renderer/src/persistence.js
@@ -0,0 +1,346 @@
+/**
+ * Generalized persistence for component props
+ *
+ * When users input new prop values, they can be stored and reapplied later,
+ * when the component is recreated (changing `Tab` for example) or when the
+ * page is reloaded (depending on `persistence_type`) Storage is tied to
+ * component ID and will not on with components without an ID.
+ *
+ * Renderer handles the mechanics, but components must define a few props:
+ *
+ * - `persistence`: boolean, string, or number. For simple usage, set to `true`
+ *   to enable persistence, omit or set `false` to disable. For more complex
+ *   scenarios, use any truthy value, and change to a *different* truthy value
+ *   when you want the persisted values cleared. (modeled off `uirevision` in)
+ *   plotly.js
+ *   Typically should have no default, but the other persistence props should
+ *   have defaults, so all a user needs to do to enable persistence is set this
+ *   one prop.
+ *
+ * - `persisted_props`: array of prop names allowed to persist. Normally should
+ *   default to the full list of supported props, so they can all be enabled at
+ *   once. The main exception to this is if there's a prop that *can* be
+ *   persisted but most users wouldn't want this.
+ *
+ * - `persistence_type`: one of "local", "session", or "memory", just like
+ *   `dcc.Store`. But the default here should be "local" because the main use
+ *   case is to maintain settings across reloads.
+ *
+ * In addition, if any props require special behavior - particularly for storing
+ * a piece nested inside a larger prop, a component can define a class property
+ * (not a React prop) `persistenceTransforms`. This should be an object:
+ * {
+ *   [propName]: {
+ *     extract: propValue => valueToStore,
+ *     apply: (storedValue, propValue) => newPropValue
+ *   }
+ * }
+ * - `extract` turns a prop value into a reduced value to store.
+ * - `apply` puts an extracted value back into the prop.
+ * You only need to define these for the props that need them.
+ * It's important that `extract` pulls out *only* the relevant pieces of the
+ * prop, because persistence is only maintained if the extracted value of the
+ * prop before applying persistence is the same as it was before the user's
+ * changes.
+ */
+
+import {
+    difference,
+    equals,
+    filter,
+    forEach,
+    forEachObjIndexed,
+    keys,
+    lensPath,
+    set,
+    type,
+} from 'ramda';
+
+import Registry from './registry';
+
+const storePrefix = '_dash_persistence.';
+const UNDEFINED = 'U';
+
+/*
+ * Does a key fit this prefix? Must either be an exact match
+ * or a scoped match - exact prefix followed by a dot (then anything else)
+ */
+function keyPrefixMatch(prefix) {
+    return key =>
+        key === prefix || key.substr(0, prefix.length + 1) === prefix + '.';
+}
+
+class WebStore {
+    constructor(storage) {
+        this._storage = storage;
+    }
+
+    hasItem(key) {
+        return this._storage.getItem(storePrefix + key) !== null;
+    }
+
+    getItem(key) {
+        // note: _storage.getItem returns null on missing keys
+        // and JSON.parse(null) returns null as well
+        const gotVal = this._storage.getItem(storePrefix + key);
+        return gotVal === UNDEFINED ? void 0 : JSON.parse(gotVal);
+    }
+
+    setItem(key, value) {
+        const setVal = value === void 0 ? UNDEFINED : JSON.stringify(value);
+        this._storage.setItem(storePrefix + key, setVal);
+    }
+
+    removeItem(key) {
+        this._storage.removeItem(storePrefix + key);
+    }
+
+    clear(keyPrefix) {
+        const fullPrefix = storePrefix + keyPrefix;
+        const keyMatch = keyPrefixMatch(fullPrefix);
+        const keysToRemove = [];
+        // 2-step process, so we don't depend on any particular behavior of
+        // key order while removing some
+        for (let i = 0; i < this._storage.length; i++) {
+            const fullKey = this._storage.key(i);
+            if (keyMatch(fullKey)) {
+                keysToRemove.push(fullKey);
+            }
+        }
+        forEach(this._storage.removeItem, keysToRemove);
+    }
+}
+
+class MemStore {
+    constructor() {
+        this._data = {};
+    }
+
+    hasItem(key) {
+        return key in this._data;
+    }
+
+    getItem(key) {
+        // run this storage through JSON too so we know we get a fresh object
+        // each retrieval
+        return JSON.parse(this._data[key] || null);
+    }
+
+    setItem(key, value) {
+        this._data[key] = JSON.stringify(value);
+    }
+
+    removeItem(key) {
+        delete this._data[key];
+    }
+
+    clear(keyPrefix) {
+        forEach(
+            key => delete this._data[key],
+            filter(keyPrefixMatch(keyPrefix), keys(this._data))
+        );
+    }
+}
+
+const stores = {
+    local: new WebStore(window.localStorage),
+    session: new WebStore(window.sessionStorage),
+    memory: new MemStore(),
+};
+
+const noopTransform = {
+    extract: propValue => propValue,
+    apply: (storedValue, _propValue) => storedValue,
+};
+
+const getTransform = (element, propName) =>
+    (element.persistenceTransforms || {})[propName] || noopTransform;
+
+const getNewValKey = (id, propName) => id + '.' + propName;
+const getOriginalValKey = newValKey => newValKey + '.orig';
+const getPersistIdKey = newValKey => newValKey + '.id';
+
+const getProps = layout => {
+    const {props} = layout;
+    const {id, persistence} = props;
+    if (!id || !persistence) {
+        return {props};
+    }
+
+    const element = Registry.resolve(layout);
+    const persisted_props =
+        props.persisted_props || element.defaultProps.persisted_props;
+    const persistence_type =
+        props.persistence_type || element.defaultProps.persistence_type;
+    if (!persisted_props || !persistence_type) {
+        return {};
+    }
+    return {id, props, element, persistence, persisted_props, persistence_type};
+};
+
+export function recordUiEdit(layout, newProps) {
+    const {
+        id,
+        props,
+        element,
+        persistence,
+        persisted_props,
+        persistence_type,
+    } = getProps(layout);
+    if (!persistence) {
+        return;
+    }
+
+    forEachObjIndexed((newPropVal, propName) => {
+        // TODO: this only supports specifying top-level props to persist
+        // DO we need nested specification?
+        // This *does* support custom methods to save/restore these props,
+        // so if we persist `columns` on a table, the component can specify
+        // to only keep & restore the names, associating them with IDs.
+        // It just wouldn't allow us to separately enable/disable persisting
+        // something else inside columns.
+        if (persisted_props.indexOf(propName) !== -1) {
+            const storage = stores[persistence_type];
+            const transform = getTransform(element, propName);
+
+            const newValKey = getNewValKey(id, propName);
+            const persistIdKey = getPersistIdKey(newValKey);
+            const setOriginalAndId = () => {
+                storage.setItem(
+                    getOriginalValKey(newValKey),
+                    transform.extract(props[propName])
+                );
+                storage.setItem(persistIdKey, persistence);
+            };
+            if (
+                !storage.hasItem(newValKey) ||
+                storage.getItem(persistIdKey) !== persistence
+            ) {
+                setOriginalAndId();
+            }
+            storage.setItem(newValKey, transform.extract(newPropVal));
+        }
+    }, newProps);
+}
+
+function clearUIEdit(id, persistence_type, propName) {
+    const storage = stores[persistence_type];
+    const newValKey = getNewValKey(id, propName);
+
+    if (storage.hasItem(newValKey)) {
+        storage.removeItem(newValKey);
+        storage.removeItem(getOriginalValKey(newValKey));
+        storage.removeItem(getPersistIdKey(newValKey));
+    }
+}
+
+/*
+ * Used for entire layouts (on load) or partial layouts (from children
+ * callbacks) to apply previously-stored UI edits to components
+ */
+export function applyPersistence(layout) {
+    if (type(layout) !== 'Object' || !layout.props) {
+        return layout;
+    }
+
+    return persistenceMods(layout, layout, []);
+}
+
+function persistenceMods(layout, component, path) {
+    const {
+        id,
+        props,
+        element,
+        persistence,
+        persisted_props,
+        persistence_type,
+    } = getProps(component);
+
+    let layoutOut = layout;
+    if (persistence) {
+        const storage = stores[persistence_type];
+        forEach(propName => {
+            const newValKey = getNewValKey(id, propName);
+            const storedPersistID = storage.getItem(getPersistIdKey(newValKey));
+            const transform = getTransform(element, propName);
+            if (storedPersistID) {
+                if (
+                    storedPersistID === persistence &&
+                    equals(
+                        storage.getItem(getOriginalValKey(newValKey)),
+                        transform.extract(props[propName])
+                    )
+                ) {
+                    layoutOut = set(
+                        lensPath(path.concat('props', propName)),
+                        transform.apply(
+                            storage.getItem(newValKey),
+                            props[propName]
+                        ),
+                        layoutOut
+                    );
+                } else {
+                    clearUIEdit(id, persistence_type, propName);
+                }
+            }
+        }, persisted_props);
+    }
+
+    // recurse inward
+    const {children} = props;
+    if (Array.isArray(children)) {
+        children.forEach((child, i) => {
+            if (type(child) === 'Object' && child.props) {
+                layoutOut = persistenceMods(
+                    layoutOut,
+                    child,
+                    path.concat('props', 'children', i)
+                );
+            }
+        });
+        forEach(applyPersistence, children);
+    } else if (type(children) === 'Object' && children.props) {
+        layoutOut = persistenceMods(
+            layoutOut,
+            children,
+            path.concat('props', 'children')
+        );
+    }
+    return layoutOut;
+}
+
+/*
+ * When we receive new explicit props from a callback,
+ * these override UI-driven edits of those exact props
+ * but not for props nested inside children
+ */
+export function prunePersistence(layout, newProps) {
+    const {id, persistence, persisted_props, persistence_type} = getProps(
+        layout
+    );
+    if (!persistence) {
+        return;
+    }
+
+    // first look for conditions that clear the persistence store entirely
+    if (
+        ('persistence' in newProps && newProps.persistence !== persistence) ||
+        ('persistence_type' in newProps &&
+            newProps.persistence_type !== persistence_type)
+    ) {
+        stores[persistence_type].clear(id);
+        return;
+    }
+
+    if ('persisted_props' in newProps) {
+        forEach(
+            prevPropName => clearUIEdit(id, persistence_type, prevPropName),
+            difference(persisted_props, newProps.persisted_props)
+        );
+    }
+
+    forEach(
+        propName => clearUIEdit(id, persistence_type, propName),
+        difference(keys(newProps), persisted_props)
+    );
+}

commit 1cd18bd4bd8f67b19217ef6a8934e2c61ac2ea78
Author: alexcjohnson <alex@plot.ly>
Date:   Sat Feb 29 09:14:22 2020 -0500

    fix & test for dcc.Location multi-path case

diff --git a/dash-renderer/src/actions/dependencies.js b/dash-renderer/src/actions/dependencies.js
index 343d9e78..14d1adbc 100644
--- a/dash-renderer/src/actions/dependencies.js
+++ b/dash-renderer/src/actions/dependencies.js
@@ -11,13 +11,16 @@ import {
     evolve,
     flatten,
     forEachObjIndexed,
+    includes,
     isEmpty,
     map,
     mergeDeepRight,
     mergeRight,
-    omit,
+    mergeWith,
     partition,
     path,
+    pickBy,
+    propEq,
     props,
     unnest,
     values,
@@ -69,7 +72,7 @@ function parseMultipleOutputs(outputIdAndProp) {
     return outputIdAndProp.substr(2, outputIdAndProp.length - 4).split('...');
 }
 
-export function splitIdAndProp(idAndProp) {
+function splitIdAndProp(idAndProp) {
     // since wildcard ids can have . in them but props can't,
     // look for the last . in the string and split there
     const dotPos = idAndProp.lastIndexOf('.');
@@ -497,6 +500,9 @@ const makeResolvedCallback = (callback, resolve, anyVals) => ({
     requestedOutputs: {},
 });
 
+const DIRECT = 2;
+const INDIRECT = 1;
+
 let nextRequestId = 0;
 
 /*
@@ -531,7 +537,11 @@ export function isMultiValued({id}) {
  *     getState: same for state
  *     blockedBy: an object of {[resolvedId]: 1} blocking this callback
  *     blocking: an object of {[resolvedId]: 1} this callback is blocking
- *     changedPropIds: an object of {[idAndProp]: 1} triggering this callback
+ *     changedPropIds: an object of {[idAndProp]: v} triggering this callback
+ *         v = DIRECT (2): the prop was changed in the front end, so dependent
+ *             callbacks *MUST* be executed.
+ *         v = INDIRECT (1): the prop is expected to be changed by a callback,
+ *             but if this is prevented, dependent callbacks may be pruned.
  *     initialCall: boolean, if true we don't require any changedPropIds
  *         to keep this callback around, as it's the initial call to populate
  *         this value on page load or changing part of the layout.
@@ -633,7 +643,7 @@ function addResolvedFromOutputs(callback, outPattern, outs, matches) {
  * (with an MATCH corresponding to the input's ALLSMALLER) will only appear
  * in one entry.
  */
-export function getCallbacksByInput(graphs, paths, id, prop) {
+export function getCallbacksByInput(graphs, paths, id, prop, changeType) {
     const matches = [];
     const idAndProp = combineIdAndProp({id, property: prop});
 
@@ -691,7 +701,7 @@ export function getCallbacksByInput(graphs, paths, id, prop) {
         });
     }
     matches.forEach(match => {
-        match.changedPropIds[idAndProp] = 1;
+        match.changedPropIds[idAndProp] = changeType || DIRECT;
     });
     return matches;
 }
@@ -747,7 +757,8 @@ export function getCallbacksInLayout(graphs, paths, layoutChunk, opts) {
         if (callback) {
             const foundIndex = foundCbIds[callback.resolvedId];
             if (foundIndex !== undefined) {
-                callbacks[foundIndex].changedPropIds = mergeRight(
+                callbacks[foundIndex].changedPropIds = mergeWith(
+                    Math.max,
                     callbacks[foundIndex].changedPropIds,
                     callback.changedPropIds
                 );
@@ -855,7 +866,10 @@ export function removePendingCallback(
                 mergeRight(pending, {
                     blockedBy: dissoc(removeResolvedId, blockedBy),
                     blocking: dissoc(removeResolvedId, blocking),
-                    changedPropIds: omit(skippedProps, changedPropIds),
+                    changedPropIds: pickBy(
+                        (v, k) => v === DIRECT || includes(k, skippedProps),
+                        changedPropIds
+                    ),
                 })
             );
         }
@@ -927,7 +941,7 @@ export function followForward(graphs, paths, callbacks_) {
     let callback;
 
     const followOutput = ({id, property}) => {
-        const nextCBs = getCallbacksByInput(graphs, paths, id, property);
+        const nextCBs = getCallbacksByInput(graphs, paths, id, property, INDIRECT);
         nextCBs.forEach(nextCB => {
             let existingIndex = allResolvedIds[nextCB.resolvedId];
             if (existingIndex === undefined) {
@@ -936,7 +950,8 @@ export function followForward(graphs, paths, callbacks_) {
                 allResolvedIds[nextCB.resolvedId] = existingIndex;
             } else {
                 const existingCB = callbacks[existingIndex];
-                existingCB.changedPropIds = mergeRight(
+                existingCB.changedPropIds = mergeWith(
+                    Math.max,
                     existingCB.changedPropIds,
                     nextCB.changedPropIds
                 );
@@ -1003,3 +1018,45 @@ export function mergePendingCallbacks(cb1, cb2) {
 
     return finalCallbacks;
 }
+
+/*
+ * Remove callbacks whose outputs or changed inputs have been removed
+ * from the layout
+ */
+export function pruneRemovedCallbacks(pendingCallbacks, paths) {
+    const removeIds = [];
+    let cleanedCallbacks = pendingCallbacks.map(callback => {
+        const {changedPropIds, getOutputs, resolvedId} = callback;
+        if (!flatten(getOutputs(paths)).length) {
+            removeIds.push(resolvedId);
+            return callback;
+        }
+
+        let omittedProps = false;
+        const newChangedProps = pickBy((_, propId) => {
+            if (getPath(paths, splitIdAndProp(propId).id)) {
+                return true;
+            }
+            omittedProps = true;
+            return false;
+        }, changedPropIds);
+
+        return omittedProps
+            ? assoc('changedPropIds', newChangedProps, callback)
+            : callback;
+    });
+
+    removeIds.forEach(resolvedId => {
+        const cb = cleanedCallbacks.find(propEq('resolvedId', resolvedId));
+        if (cb) {
+            cleanedCallbacks = removePendingCallback(
+                pendingCallbacks,
+                paths,
+                resolvedId,
+                flatten(cb.getOutputs(paths)).map(combineIdAndProp)
+            );
+        }
+    });
+
+    return cleanedCallbacks;
+}
diff --git a/dash-renderer/src/actions/index.js b/dash-renderer/src/actions/index.js
index ad915079..2efd7af3 100644
--- a/dash-renderer/src/actions/index.js
+++ b/dash-renderer/src/actions/index.js
@@ -1,6 +1,5 @@
 /* global fetch:true, Promise:true, document:true */
 import {
-    assoc,
     concat,
     flatten,
     has,
@@ -37,8 +36,8 @@ import {
     mergePendingCallbacks,
     removePendingCallback,
     parseIfWildcard,
+    pruneRemovedCallbacks,
     setNewRequestId,
-    splitIdAndProp,
     stringifyId,
 } from './dependencies';
 import {computePaths, getPath} from './paths';
@@ -539,42 +538,7 @@ function updateChildPaths(
     const paths = computePaths(children, childrenPath, oldPaths);
     dispatch(setPaths(paths));
 
-    // Prune now-nonexistent changedPropIds and mark callbacks with
-    // now-nonexistent outputs
-    const removeIds = [];
-    let cleanedCallbacks = pendingCallbacks.map(callback => {
-        const {changedPropIds, getOutputs, resolvedId} = callback;
-        if (!flatten(getOutputs(paths)).length) {
-            removeIds.push(resolvedId);
-            return callback;
-        }
-
-        let omittedProps = false;
-        const newChangedProps = pickBy((_, propId) => {
-            if (getPath(paths, splitIdAndProp(propId).id)) {
-                return true;
-            }
-            omittedProps = true;
-            return false;
-        }, changedPropIds);
-
-        return omittedProps
-            ? assoc('changedPropIds', newChangedProps, callback)
-            : callback;
-    });
-
-    // Remove the callbacks we marked above
-    removeIds.forEach(resolvedId => {
-        const cb = cleanedCallbacks.find(propEq('resolvedId', resolvedId));
-        if (cb) {
-            cleanedCallbacks = removePendingCallback(
-                pendingCallbacks,
-                paths,
-                resolvedId,
-                flatten(cb.getOutputs(paths)).map(combineIdAndProp)
-            );
-        }
-    });
+    const cleanedCallbacks = pruneRemovedCallbacks(pendingCallbacks, paths);
 
     const newCallbacks = getCallbacksInLayout(graphs, paths, children);
 
diff --git a/tests/integration/callbacks/test_basic_callback.py b/tests/integration/callbacks/test_basic_callback.py
index bc29e9b6..fa1854cb 100644
--- a/tests/integration/callbacks/test_basic_callback.py
+++ b/tests/integration/callbacks/test_basic_callback.py
@@ -1,5 +1,8 @@
+import json
 from multiprocessing import Value
 
+import pytest
+
 import dash_core_components as dcc
 import dash_html_components as html
 import dash_table
@@ -232,3 +235,57 @@ def test_cbsc005_array_of_objects(dash_duo):
         dash_duo.find_element("#btn").click()
         dash_duo.wait_for_text_to_equal("#out", str(i + 1))
         dash_duo.select_dcc_dropdown("#dd", "opt{}".format(i))
+
+
+@pytest.mark.parametrize("refresh", [False, True])
+def test_cbsc006_parallel_updates(refresh, dash_duo):
+    # This is a funny case, that seems to mostly happen with dcc.Location
+    # but in principle could happen in other cases too:
+    # A callback chain (in this case the initial hydration) is set to update a
+    # value, but after that callback is queued and before it returns, that value
+    # is also set explicitly from the front end (in this case Location.pathname,
+    # which gets set in its componentDidMount during the render process, and
+    # callbacks are delayed until after rendering is finished because of the
+    # async table)
+    # At one point in the wildcard PR #1103, changing from requestQueue to
+    # pendingCallbacks, calling PreventUpdate in the callback would also skip
+    # any callbacks that depend on pathname, despite the new front-end-provided
+    # value.
+
+    app = dash.Dash()
+
+    app.layout = html.Div([
+        dcc.Location(id='loc', refresh=refresh),
+        html.Button('Update path', id='btn'),
+        dash_table.DataTable(id='t', columns=[{'name': 'a', 'id': 'a'}]),
+        html.Div(id='out')
+    ])
+
+    @app.callback(Output('t', 'data'), [Input('loc', 'pathname')])
+    def set_data(path):
+        return [{'a': (path or repr(path)) + ':a'}]
+
+    @app.callback(
+        Output('out', 'children'),
+        [Input('loc', 'pathname'), Input('t', 'data')]
+    )
+    def set_out(path, data):
+        return json.dumps(data) + ' - ' + (path or repr(path))
+
+    @app.callback(Output('loc', 'pathname'), [Input('btn', 'n_clicks')])
+    def set_path(n):
+        if not n:
+            raise PreventUpdate
+
+        return '/{0}'.format(n)
+
+    dash_duo.start_server(app)
+
+    dash_duo.wait_for_text_to_equal('#out', '[{"a": "/:a"}] - /')
+    dash_duo.find_element("#btn").click()
+    # the refresh=True case here is testing that we really do get the right
+    # pathname, not the prevented default value from the layout.
+    dash_duo.wait_for_text_to_equal("#out", '[{"a": "/1:a"}] - /1')
+    if not refresh:
+        dash_duo.find_element("#btn").click()
+        dash_duo.wait_for_text_to_equal("#out", '[{"a": "/2:a"}] - /2')

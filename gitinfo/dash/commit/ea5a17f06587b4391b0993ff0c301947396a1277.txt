commit ea5a17f06587b4391b0993ff0c301947396a1277
Author: t4rk1n <t4rk@outlook.com>
Date:   Thu Feb 7 19:01:46 2019 -0500

    :bug: Fix multi-output circular dependencies.

diff --git a/src/actions/index.js b/src/actions/index.js
index 89f26df9..ef76229f 100644
--- a/src/actions/index.js
+++ b/src/actions/index.js
@@ -50,8 +50,10 @@ export function hydrateInitialOutputs() {
 
 function triggerDefaultState(dispatch, getState) {
     const {graphs} = getState();
-    const {InputGraph} = graphs;
+    const {InputGraph, MultiGraph} = graphs;
     const allNodes = InputGraph.overallOrder();
+    // overallOrder will assert circular dependencies for multi output.
+    MultiGraph.overallOrder();
     const inputNodeIds = [];
     allNodes.reverse();
     allNodes.forEach(nodeId => {
diff --git a/src/reducers/dependencyGraph.js b/src/reducers/dependencyGraph.js
index 535b4df2..bde08299 100644
--- a/src/reducers/dependencyGraph.js
+++ b/src/reducers/dependencyGraph.js
@@ -8,23 +8,58 @@ const graphs = (state = initialGraph, action) => {
         case 'COMPUTE_GRAPHS': {
             const dependencies = action.payload;
             const inputGraph = new DepGraph();
+            const multiGraph = new DepGraph();
 
             dependencies.forEach(function registerDependency(dependency) {
                 const {output, inputs} = dependency;
 
                 // Multi output supported will be a string already
                 // Backward compatibility by detecting object.
-                const outputId = type(output) === 'Object' ?
-                    `${output.id}.${output.property}` : output;
+                let outputId;
+                if (type(output) === 'Object') {
+                    outputId= `${output.id}.${output.property}`;
+                } else {
+                    outputId = output;
+                    if (output.startsWith('.')) {
+                        output.slice(2, output.length - 2).split('...').forEach(
+                            out => {
+                                multiGraph.addNode(out);
+                                inputs.forEach(
+                                    i => {
+                                        const inputId = `${i.id}.${i.property}`;
+                                        if (!multiGraph.hasNode(inputId)) {
+                                            multiGraph.addNode(inputId);
+                                        }
+                                        multiGraph.addDependency(inputId, out);
+                                    }
+                                );
+                            }
+                        )
+                    } else {
+                        multiGraph.addNode(output);
+                        inputs.forEach(
+                            i => {
+                                const inputId = `${i.id}.${i.property}`;
+                                if (!multiGraph.hasNode(inputId)) {
+                                    multiGraph.addNode(inputId);
+                                }
+                                multiGraph.addDependency(inputId, output);
+                            }
+                        )
+                    }
+                }
+
                 inputs.forEach(inputObject => {
                     const inputId = `${inputObject.id}.${inputObject.property}`;
                     inputGraph.addNode(outputId);
-                    inputGraph.addNode(inputId);
+                    if (!inputGraph.hasNode(inputId)) {
+                        inputGraph.addNode(inputId);
+                    }
                     inputGraph.addDependency(inputId, outputId);
                 });
             });
 
-            return {InputGraph: inputGraph};
+            return {InputGraph: inputGraph, MultiGraph: multiGraph};
         }
 
         default:

commit db070b31ad5abae34b962a7531d7c26d6ab30b1a
Author: alexcjohnson <alex@plot.ly>
Date:   Sun Feb 9 22:13:34 2020 -0500

    handle callback queue race condition
    new callbacks can't delete existing ones added elsewhere

diff --git a/dash-renderer/src/actions/index.js b/dash-renderer/src/actions/index.js
index 26e84663..6cdf4d9a 100644
--- a/dash-renderer/src/actions/index.js
+++ b/dash-renderer/src/actions/index.js
@@ -229,6 +229,29 @@ async function fireReadyCallbacks(dispatch, getState, callbacks) {
     await isAppReady(layout, paths, ids);
 
     const allCallbacks = concat(requestedCallbacks, blockedCallbacks);
+
+    // because of the async step above, make sure we haven't separately added
+    // more callbacks to the queue - this particular step should only be adding
+    // callbacks, not removing them.
+    const existingCallbacks = getState().pendingCallbacks;
+    if (existingCallbacks.length) {
+        const resolvedIds = {};
+        allCallbacks.forEach((cb, i) => {
+            resolvedIds[cb.resolvedId] = i;
+        });
+        existingCallbacks.forEach(existingCB => {
+            const iAll = resolvedIds[existingCB.resolvedId];
+            if (iAll === undefined) {
+                allCallbacks.push(existingCB);
+            } else if (existingCB.requestId && !allCallbacks[iAll].requestId) {
+                // already requested put the requested one in the queue
+                allCallbacks[iAll] = existingCB;
+            }
+            // otherwise either both are blocked, fine, either one will do...
+            // or both have been requested - either way keep the newer one
+        });
+    }
+
     dispatch(setPendingCallbacks(allCallbacks));
 
     function fireNext() {

commit 9846817c454b8e1a1a44069bb128fe73bbd4ebdb
Author: alexcjohnson <alex@plot.ly>
Date:   Mon May 4 16:24:44 2020 -0400

    app.config.prevent_initiall_callbacks

diff --git a/dash/dash.py b/dash/dash.py
index e5648d63..07f3f3bb 100644
--- a/dash/dash.py
+++ b/dash/dash.py
@@ -211,6 +211,15 @@ class Dash(object):
         env: ``DASH_SUPPRESS_CALLBACK_EXCEPTIONS``
     :type suppress_callback_exceptions: boolean
 
+    :param prevent_initial_callbacks: Default ``False``: Sets the default value
+        of ``prevent_initial_call`` for all callbacks added to the app.
+        Normally all callbacks are fired when the associated outputs are first
+        added to the page. You can disable this for individual callbacks by
+        setting ``prevent_initial_call`` in their definitions, or set it
+        ``True`` here in which case you must explicitly set it ``False`` for
+        those callbacks you wish to have an initial call. This setting has no
+        effect on triggering callbacks when their inputs change later on.
+
     :param show_undo_redo: Default ``False``, set to ``True`` to enable undo
         and redo buttons for stepping through the history of the app state.
     :type show_undo_redo: boolean
@@ -241,6 +250,7 @@ class Dash(object):
         external_scripts=None,
         external_stylesheets=None,
         suppress_callback_exceptions=None,
+        prevent_initial_callbacks=False,
         show_undo_redo=False,
         plugins=None,
         **obsolete
@@ -288,6 +298,7 @@ class Dash(object):
             suppress_callback_exceptions=get_combined_config(
                 "suppress_callback_exceptions", suppress_callback_exceptions, False
             ),
+            prevent_initial_callbacks=prevent_initial_callbacks,
             show_undo_redo=show_undo_redo,
         )
         self.config.set_read_only(
@@ -814,6 +825,9 @@ class Dash(object):
         return flask.jsonify(self._callback_list)
 
     def _insert_callback(self, output, inputs, state, prevent_initial_call):
+        if prevent_initial_call is None:
+            prevent_initial_call = self.config.prevent_initial_callbacks
+
         _validate.validate_callback(output, inputs, state)
         callback_id = create_callback_id(output)
         callback_spec = {
@@ -832,7 +846,7 @@ class Dash(object):
         return callback_id
 
     def clientside_callback(
-        self, clientside_function, output, inputs, state=(), prevent_initial_call=False
+        self, clientside_function, output, inputs, state=(), prevent_initial_call=None
     ):
         """Create a callback that updates the output by calling a clientside
         (JavaScript) function instead of a Python function.
@@ -893,6 +907,10 @@ class Dash(object):
              Input('another-input', 'value')]
         )
         ```
+
+        The last, optional argument `prevent_initial_call` causes the callback
+        not to fire when its outputs are first added to the page. Defaults to
+        `False` unless `prevent_initial_callbacks=True` at the app level.
         """
         self._insert_callback(output, inputs, state, prevent_initial_call)
 
@@ -925,7 +943,18 @@ class Dash(object):
             "function_name": function_name,
         }
 
-    def callback(self, output, inputs, state=(), prevent_initial_call=False):
+    def callback(self, output, inputs, state=(), prevent_initial_call=None):
+        """
+        Normally used as a decorator, `@app.callback` provides a server-side
+        callback relating the values of one or more `output` items to one or
+        more `input` items which will trigger the callback when they change,
+        and optionally `state` items which provide additional information but
+        do not trigger the callback directly.
+
+        The last, optional argument `prevent_initial_call` causes the callback
+        not to fire when its outputs are first added to the page. Defaults to
+        `False` unless `prevent_initial_callbacks=True` at the app level.
+        """
         callback_id = self._insert_callback(output, inputs, state, prevent_initial_call)
         multi = isinstance(output, (list, tuple))
 
diff --git a/tests/integration/callbacks/test_prevent_initial.py b/tests/integration/callbacks/test_prevent_initial.py
index ed9ff191..adcef5b4 100644
--- a/tests/integration/callbacks/test_prevent_initial.py
+++ b/tests/integration/callbacks/test_prevent_initial.py
@@ -6,12 +6,34 @@ import dash
 from dash.dependencies import Input, Output, MATCH
 from dash.exceptions import PreventUpdate
 
+# parametrize all the tests, but no need to do all 8 combinations, 5 is enough!
+flavors = [
+    {"clientside": False, "content": False, "global": False},
+    {"clientside": True, "content": False, "global": False},
+    {"clientside": False, "content": True, "global": False},
+    {"clientside": True, "content": True, "global": True},
+    {"clientside": False, "content": False, "global": True},
+]
 
-def content_callback(app, content, layout):
-    if content:
+
+def make_app(flavor):
+    kwargs = {}
+    if flavor["global"]:
+        kwargs["prevent_initial_callbacks"] = True
+    return dash.Dash(__name__, **kwargs)
+
+
+def content_callback(app, flavor, layout):
+    kwargs = {}
+    if flavor["global"]:
+        kwargs["prevent_initial_call"] = False
+
+    if flavor["content"]:
         app.layout = html.Div(id="content")
 
-        @app.callback(Output("content", "children"), [Input("content", "style")])
+        @app.callback(
+            Output("content", "children"), [Input("content", "style")], **kwargs
+        )
         def set_content(_):
             return layout
 
@@ -19,25 +41,31 @@ def content_callback(app, content, layout):
         app.layout = layout
 
 
-def const_callback(app, clientside, val, outputs, inputs, prevent_initial_call=None):
-    if clientside:
+def const_callback(app, flavor, val, outputs, inputs, prevent_initial_call=False):
+    kwargs = {}
+    if prevent_initial_call != flavor["global"]:
+        kwargs["prevent_initial_call"] = prevent_initial_call
+
+    if flavor["clientside"]:
         vstr = json.dumps(val)
         app.clientside_callback(
-            "function() { return " + vstr + "; }",
-            outputs,
-            inputs,
-            prevent_initial_call=prevent_initial_call,
+            "function() { return " + vstr + "; }", outputs, inputs, **kwargs
         )
     else:
 
-        @app.callback(outputs, inputs, prevent_initial_call=prevent_initial_call)
+        @app.callback(outputs, inputs, **kwargs)
         def f(*args):
             return val
 
 
-def concat_callback(app, clientside, outputs, inputs, prevent_initial_call=None):
+def concat_callback(app, flavor, outputs, inputs, prevent_initial_call=False):
+    kwargs = {}
+    if prevent_initial_call != flavor["global"]:
+        kwargs["prevent_initial_call"] = prevent_initial_call
+
     multi_out = isinstance(outputs, (list, tuple))
-    if clientside:
+
+    if flavor["clientside"]:
         app.clientside_callback(
             """
             function() {
@@ -49,24 +77,24 @@ def concat_callback(app, clientside, outputs, inputs, prevent_initial_call=None)
             }
             """.replace(
                 "X",
-                ("[" + ','.join(["out"] * len(outputs)) + "]") if multi_out else "out"
+                ("[" + ",".join(["out"] * len(outputs)) + "]") if multi_out else "out",
             ),
             outputs,
             inputs,
-            prevent_initial_call=prevent_initial_call,
+            **kwargs
         )
     else:
 
-        @app.callback(outputs, inputs, prevent_initial_call=prevent_initial_call)
+        @app.callback(outputs, inputs, **kwargs)
         def f(*args):
             out = "".join(str(arg) for arg in args)
             return [out] * len(outputs) if multi_out else out
 
 
-@pytest.mark.parametrize("clientside", (False, True))
-@pytest.mark.parametrize("content", (False, True))
-def test_cbpi001_prevent_initial_call(clientside, content, dash_duo):
-    app = dash.Dash(__name__)
+@pytest.mark.parametrize("flavor", flavors)
+def test_cbpi001_prevent_initial_call(flavor, dash_duo):
+    app = make_app(flavor)
+
     layout = html.Div(
         [
             html.Button("click", id="btn"),
@@ -78,12 +106,12 @@ def test_cbpi001_prevent_initial_call(clientside, content, dash_duo):
             html.Div("F", id="f"),
         ]
     )
-    content_callback(app, content, layout)
+    content_callback(app, flavor, layout)
 
     # Prevented, so A will only change after the button is clicked
     const_callback(
         app,
-        clientside,
+        flavor,
         "Click",
         Output("a", "children"),
         [Input("btn", "n_clicks")],
@@ -93,7 +121,17 @@ def test_cbpi001_prevent_initial_call(clientside, content, dash_duo):
     # B depends on A - this *will* run, because prevent_initial_call is
     # not equivalent to PreventUpdate within the callback, it's treated as if
     # that callback was never in the initialization chain.
-    concat_callback(app, clientside, Output("b", "children"), [Input("a", "children")])
+    concat_callback(app, flavor, Output("b", "children"), [Input("a", "children")])
+
+    # C matches B except that it also has prevent_initial_call itself, not just
+    # its input A - so it will not run initially
+    concat_callback(
+        app,
+        flavor,
+        Output("c", "children"),
+        [Input("a", "children")],
+        prevent_initial_call=True,
+    )
 
     @app.callback(Output("d", "children"), [Input("d", "style")])
     def d(_):
@@ -103,7 +141,7 @@ def test_cbpi001_prevent_initial_call(clientside, content, dash_duo):
     # the prevent_initial_call means it *will* run
     concat_callback(
         app,
-        clientside,
+        flavor,
         Output("e", "children"),
         [Input("a", "children"), Input("d", "children")],
     )
@@ -112,16 +150,12 @@ def test_cbpi001_prevent_initial_call(clientside, content, dash_duo):
     # inputs (B) was changed by a callback
     concat_callback(
         app,
-        clientside,
+        flavor,
         Output("f", "children"),
         [Input("a", "children"), Input("b", "children"), Input("d", "children")],
         prevent_initial_call=True,
     )
 
-    # C matches B except that it also has prevent_initial_call itself, not just
-    # its input A - so it will not run initially
-    concat_callback(app, clientside, Output("c", "children"), [Input("a", "children")], prevent_initial_call=True)
-
     dash_duo.start_server(app)
 
     # check from the end, to ensure the callbacks are all done
@@ -142,11 +176,11 @@ def test_cbpi001_prevent_initial_call(clientside, content, dash_duo):
     dash_duo.wait_for_text_to_equal("#a", "Click")
 
 
-@pytest.mark.parametrize("clientside", (False, True))
-@pytest.mark.parametrize("content", (False, True))
-def test_cbpi002_pattern_matching(clientside, content, dash_duo):
+@pytest.mark.parametrize("flavor", flavors)
+def test_cbpi002_pattern_matching(flavor, dash_duo):
     # a clone of cbpi001 just throwing it through the pattern-matching machinery
-    app = dash.Dash(__name__)
+    app = make_app(flavor)
+
     layout = html.Div(
         [
             html.Button("click", id={"i": 0, "j": "btn"}, className="btn"),
@@ -158,50 +192,61 @@ def test_cbpi002_pattern_matching(clientside, content, dash_duo):
             html.Div("F", id={"i": 0, "j": "f"}, className="f"),
         ]
     )
-    content_callback(app, content, layout)
+    content_callback(app, flavor, layout)
 
-    # Prevented, so A will only change after the button is clicked
     const_callback(
         app,
-        clientside,
+        flavor,
         "Click",
         Output({"i": MATCH, "j": "a"}, "children"),
         [Input({"i": MATCH, "j": "btn"}, "n_clicks")],
         prevent_initial_call=True,
     )
 
-    # B depends on A - this *will* run, because prevent_initial_call is
-    # not equivalent to PreventUpdate within the callback, it's treated as if
-    # that callback was never in the initialization chain.
-    concat_callback(app, clientside, Output({"i": MATCH, "j": "b"}, "children"), [Input({"i": MATCH, "j": "a"}, "children")])
+    concat_callback(
+        app,
+        flavor,
+        Output({"i": MATCH, "j": "b"}, "children"),
+        [Input({"i": MATCH, "j": "a"}, "children")],
+    )
+
+    concat_callback(
+        app,
+        flavor,
+        Output({"i": MATCH, "j": "c"}, "children"),
+        [Input({"i": MATCH, "j": "a"}, "children")],
+        prevent_initial_call=True,
+    )
 
-    @app.callback(Output({"i": MATCH, "j": "d"}, "children"), [Input({"i": MATCH, "j": "d"}, "style")])
+    @app.callback(
+        Output({"i": MATCH, "j": "d"}, "children"),
+        [Input({"i": MATCH, "j": "d"}, "style")],
+    )
     def d(_):
         raise PreventUpdate
 
-    # E depends on A and D - one prevent_initial_call and one PreventUpdate
-    # the prevent_initial_call means it *will* run
     concat_callback(
         app,
-        clientside,
+        flavor,
         Output({"i": MATCH, "j": "e"}, "children"),
-        [Input({"i": MATCH, "j": "a"}, "children"), Input({"i": MATCH, "j": "d"}, "children")],
+        [
+            Input({"i": MATCH, "j": "a"}, "children"),
+            Input({"i": MATCH, "j": "d"}, "children"),
+        ],
     )
 
-    # F has prevent_initial_call but DOES fire during init, because one of its
-    # inputs (B) was changed by a callback
     concat_callback(
         app,
-        clientside,
+        flavor,
         Output({"i": MATCH, "j": "f"}, "children"),
-        [Input({"i": MATCH, "j": "a"}, "children"), Input({"i": MATCH, "j": "b"}, "children"), Input({"i": MATCH, "j": "d"}, "children")],
+        [
+            Input({"i": MATCH, "j": "a"}, "children"),
+            Input({"i": MATCH, "j": "b"}, "children"),
+            Input({"i": MATCH, "j": "d"}, "children"),
+        ],
         prevent_initial_call=True,
     )
 
-    # C matches B except that it also has prevent_initial_call itself, not just
-    # its input A - so it will not run initially
-    concat_callback(app, clientside, Output({"i": MATCH, "j": "c"}, "children"), [Input({"i": MATCH, "j": "a"}, "children")], prevent_initial_call=True)
-
     dash_duo.start_server(app)
 
     # check from the end, to ensure the callbacks are all done
@@ -222,32 +267,52 @@ def test_cbpi002_pattern_matching(clientside, content, dash_duo):
     dash_duo.wait_for_text_to_equal(".a", "Click")
 
 
-@pytest.mark.parametrize("clientside", (False, True))
-@pytest.mark.parametrize("content", (False, True))
-def test_cbpi003_multi_outputs(clientside, content, dash_duo):
-    app = dash.Dash(__name__)
+@pytest.mark.parametrize("flavor", flavors)
+def test_cbpi003_multi_outputs(flavor, dash_duo):
+    app = make_app(flavor)
 
-    layout = html.Div([
-        html.Button("click", id="btn"),
-        html.Div("A", id="a"),
-        html.Div("B", id="b"),
-        html.Div("C", id="c"),
-        html.Div("D", id="d"),
-        html.Div("E", id="e"),
-        html.Div("F", id="f"),
-        html.Div("G", id="g"),
-    ])
+    layout = html.Div(
+        [
+            html.Button("click", id="btn"),
+            html.Div("A", id="a"),
+            html.Div("B", id="b"),
+            html.Div("C", id="c"),
+            html.Div("D", id="d"),
+            html.Div("E", id="e"),
+            html.Div("F", id="f"),
+            html.Div("G", id="g"),
+        ]
+    )
 
-    content_callback(app, content, layout)
+    content_callback(app, flavor, layout)
 
-    const_callback(app, clientside, ["Blue", "Cheese"], [Output("a", "children"), Output("b", "children")], [Input("btn", "n_clicks")], prevent_initial_call=True)
+    const_callback(
+        app,
+        flavor,
+        ["Blue", "Cheese"],
+        [Output("a", "children"), Output("b", "children")],
+        [Input("btn", "n_clicks")],
+        prevent_initial_call=True,
+    )
 
-    concat_callback(app, clientside, [Output("c", "children"), Output("d", "children")], [Input("a", "children"), Input("b", "children")], prevent_initial_call=True)
+    concat_callback(
+        app,
+        flavor,
+        [Output("c", "children"), Output("d", "children")],
+        [Input("a", "children"), Input("b", "children")],
+        prevent_initial_call=True,
+    )
 
-    concat_callback(app, clientside, [Output("e", "children"), Output("f", "children")], [Input("a", "children")], prevent_initial_call=True)
+    concat_callback(
+        app,
+        flavor,
+        [Output("e", "children"), Output("f", "children")],
+        [Input("a", "children")],
+        prevent_initial_call=True,
+    )
 
     # this is the only one that should run initially
-    concat_callback(app, clientside, Output("g", "children"), [Input("f", "children")])
+    concat_callback(app, flavor, Output("g", "children"), [Input("f", "children")])
 
     dash_duo.start_server(app)
 

commit c62ce93cd446e4128e1179dd57b6c3546b2dbcfe
Author: chriddyp <chris@plot.ly>
Date:   Wed Mar 1 20:53:52 2017 -0500

    :bug: fix up `content`
    
    - handle strings, numbers, None values
    - allow `content` to just be a single component
    - better nested test cases

diff --git a/dash/development/base_component.py b/dash/development/base_component.py
index 3b1c27ce..fa0f0c53 100644
--- a/dash/development/base_component.py
+++ b/dash/development/base_component.py
@@ -2,6 +2,14 @@ import collections
 import types
 
 
+def is_number(s):
+    try:
+        float(s)
+        return True
+    except ValueError:
+        return False
+
+
 class Component(collections.MutableMapping):
     def __init__(self, **kwargs):
         for k, v in kwargs.iteritems():
@@ -23,14 +31,14 @@ class Component(collections.MutableMapping):
             'type': self._type,
             'namespace': self._namespace
         }
-        if hasattr(self, 'dependencies'):
-            as_json['dependencies'] = self.dependencies
+
         return as_json
 
     def _check_if_has_indexable_content(self, item):
         if (not hasattr(item, 'content') or
-                item.content is None or
-                isinstance(item.content, basestring)):
+                (not isinstance(item.content, Component) and
+                 not isinstance(item.content, collections.MutableSequence))):
+
             raise KeyError
 
     def _get_set_or_delete(self, id, operation, new_item=None):
@@ -38,6 +46,7 @@ class Component(collections.MutableMapping):
 
         if isinstance(self.content, Component):
             if getattr(self.content, 'id', None) is not None:
+                # Woohoo! It's the item that we're looking for
                 if self.content.id == id:
                     if operation == 'get':
                         return self.content
@@ -47,35 +56,51 @@ class Component(collections.MutableMapping):
                     elif operation == 'delete':
                         self.content = None
                         return
-                else:
-                    raise KeyError
-
-        # if content is like a list
-        for (i, item) in enumerate(self.content):
-            # If the item itself is the one we're looking for
-            if getattr(item, 'id', None) == id:
-                if operation == 'get':
-                    return item
-                elif operation == 'set':
-                    self.content[i] = new_item
-                    return
-                elif operation == 'delete':
-                    del self.content[i]
-                    return
 
-            # Otherwise, recursively dig into that items subtree
+            # Recursively dig into its subtree
             try:
                 if operation == 'get':
-                    return item.__getitem__(id)
+                    return self.content.__getitem__(id)
                 elif operation == 'set':
-                    item.__setitem__(id, new_item)
+                    self.content.__setitem__(id, new_item)
                     return
                 elif operation == 'delete':
-                    item.__delitem__(id)
+                    self.content.__delitem__(id)
                     return
             except KeyError:
                 pass
 
+        # if content is like a list
+        if isinstance(self.content, collections.MutableSequence):
+            for (i, item) in enumerate(self.content):
+                # If the item itself is the one we're looking for
+                if getattr(item, 'id', None) == id:
+                    if operation == 'get':
+                        return item
+                    elif operation == 'set':
+                        self.content[i] = new_item
+                        return
+                    elif operation == 'delete':
+                        del self.content[i]
+                        return
+
+                # Otherwise, recursively dig into that item's subtree
+                # Make sure it's not like a string
+                elif isinstance(item, Component):
+                    try:
+                        if operation == 'get':
+                            return item.__getitem__(id)
+                        elif operation == 'set':
+                            item.__setitem__(id, new_item)
+                            return
+                        elif operation == 'delete':
+                            item.__delitem__(id)
+                            return
+                    except KeyError:
+                        pass
+
+        # The end of our branch
+        # If we were in a list, then this exception will get caught
         raise KeyError
 
     # Supply ABC methods for a MutableMapping:
@@ -95,25 +120,30 @@ class Component(collections.MutableMapping):
         return self._get_set_or_delete(id, 'get')
 
     def __setitem__(self, id, item):
+        '''Set an element by its ID
+        '''
         return self._get_set_or_delete(id, 'set', item)
 
     def __delitem__(self, id):
+        '''Delete items by ID in the tree of content
+        '''
         return self._get_set_or_delete(id, 'delete')
 
     def __iter__(self):
+        '''Yield IDs in the tree of content
+        '''
         content = getattr(self, 'content', None)
 
         # content is just a component
-        if (isinstance(content, Component) and
-                getattr(self.content, 'id', None) is not None):
+        if isinstance(content, Component):
+            if getattr(self.content, 'id', None) is not None:
+                yield self.content.id
 
-            yield self.content.id
+            for t in content.__iter__():
+                yield t
 
         # content is a list of components
-        # TODO - Stronger check for list?
-        if (not isinstance(content, basestring) and
-                not isinstance(content, Component) and
-                content is not None):
+        if isinstance(content, collections.MutableSequence):
 
             for i in content:
 
@@ -127,18 +157,25 @@ class Component(collections.MutableMapping):
     def __len__(self):
         '''Return the number of items in the tree
         '''
-        l = 0
+        # TODO - Should we return the number of items that have IDs
+        # or just the number of items?
+        # The number of items is more intuitive but returning the number
+        # of IDs matches __iter__ better.
+        length = 0
         if getattr(self, 'content', None) is None:
-            l = 0
-        elif isinstance(self.content, basestring):
-            l = 1
+            length = 0
         elif isinstance(self.content, Component):
-            l = 1
-        else:
+            length = 1
+            length += len(self.content)
+        elif isinstance(self.content, collections.MutableSequence):
             for c in self.content:
-                l += 1
-                l += len(c)
-        return l
+                length += 1
+                if isinstance(c, Component):
+                    length += len(c)
+        else:
+            # string or number
+            length = 1
+        return length
 
 
 def generate_class(typename, component_arguments, namespace):
diff --git a/tests/development/test_base_component.py b/tests/development/test_base_component.py
index 7b5ebd64..0057e772 100644
--- a/tests/development/test_base_component.py
+++ b/tests/development/test_base_component.py
@@ -7,6 +7,39 @@ import unittest
 
 
 Component._prop_names = ('id', 'a', 'content', 'style', )
+Component._type = 'TestComponent'
+Component._namespace = 'test_namespace'
+
+def nested_tree():
+    '''This tree has a few unique properties:
+    - Content is mixed strings and components (as in c2)
+    - Content is just components (as in c)
+    - Content is just strings (as in c1)
+    - Content is just a single component (as in c3, c4)
+    - Content contains numbers (as in c2)
+    - Content contains "None" items (as in c2)
+    '''
+    c1 = Component(
+        id='0.1.x.x.0',
+        content='string'
+    )
+    c2 = Component(
+        id='0.1.x.x',
+        content=[10, None, 'wrap string', c1, 'another string', 4.51]
+    )
+    c3 = Component(
+        id='0.1.x',
+        # content is just a component
+        content=c2
+    )
+    c4 = Component(
+        id='0.1',
+        content=c3
+    )
+    c5 = Component(id='0.0')
+    c = Component(id='0', content=[c5, c4])
+    return c, c1, c2, c3, c4, c5
+
 
 class TestComponent(unittest.TestCase):
     def test_init(self):
@@ -43,6 +76,132 @@ class TestComponent(unittest.TestCase):
         self.assertEqual(c5['1'], c1)
         self.assertEqual(c5['3'], c3)
 
+    def test_get_item_with_nested_content_with_mixed_strings_and_without_lists(self):
+        c, c1, c2, c3, c4, c5 = nested_tree()
+        self.assertEqual(
+            c.keys(),
+            [
+                '0.0',
+                '0.1',
+                '0.1.x',
+                '0.1.x.x',
+                '0.1.x.x.0'
+            ]
+        )
+
+        # Try to get each item
+        for comp in [c1, c2, c3, c4, c5]:
+            self.assertEqual(c[comp.id], comp)
+
+        # Get an item that doesn't exist
+        with self.assertRaises(KeyError):
+            c['x']
+
+    def test_len_with_nested_content_with_mixed_strings_and_without_lists(self):
+        c = nested_tree()[0]
+        self.assertEqual(
+            len(c),
+            5 + # 5 components
+            5 + # c2 has 2 strings, 2 numbers, and a None
+            1# c1 has 1 string
+        )
+
+    def test_set_item_with_nested_content_with_mixed_strings_and_without_lists(self):
+        keys = [
+            '0.0',
+            '0.1',
+            '0.1.x',
+            '0.1.x.x',
+            '0.1.x.x.0'
+        ]
+        c = nested_tree()[0]
+
+        # Test setting items starting from the innermost item
+        for i, key in enumerate(reversed(keys)):
+            new_id = 'new {}'.format(key)
+            new_component = Component(
+                id=new_id,
+                content='new string'
+            )
+            c[key] = new_component
+            self.assertEqual(c[new_id], new_component)
+
+    def test_del_item_with_nested_content_with_mixed_strings_and_without_lists(self):
+        c = nested_tree()[0]
+        for key in reversed(c.keys()):
+            c[key]
+            del c[key]
+            with self.assertRaises(KeyError):
+                c[key]
+
+    def test_iter_with_nested_content_with_mixed_strings_and_without_lists(self):
+        c = nested_tree()[0]
+        keys = c.keys()
+        # get a list of ids that __iter__ provides
+        iter_keys = [i for i in c]
+        self.assertEqual(keys, iter_keys)
+
+    def test_to_plotly_json_with_nested_content_with_mixed_strings_and_without_lists(self):
+        c = nested_tree()[0]
+        n = Component._namespace
+        t = Component._type
+
+        self.assertEqual(json.loads(json.dumps(
+                c.to_plotly_json(),
+                cls=plotly.utils.PlotlyJSONEncoder
+            )), {
+            'type': 'TestComponent',
+            'namespace': 'test_namespace',
+            'props': {
+                'content': [
+                    {
+                        'type': 'TestComponent',
+                        'namespace': 'test_namespace',
+                        'props': {
+                            'id': '0.0'
+                        }
+                    },
+                    {
+                        'type': 'TestComponent',
+                        'namespace': 'test_namespace',
+                        'props': {
+                            'content': {
+                                'type': 'TestComponent',
+                                'namespace': 'test_namespace',
+                                'props': {
+                                    'content': {
+                                        'type': 'TestComponent',
+                                        'namespace': 'test_namespace',
+                                        'props': {
+                                            'content': [
+                                                10,
+                                                None,
+                                                'wrap string',
+                                                {
+                                                    'type': 'TestComponent',
+                                                    'namespace': 'test_namespace',
+                                                    'props': {
+                                                        'content': 'string',
+                                                        'id': '0.1.x.x.0'
+                                                    }
+                                                },
+                                                'another string',
+                                                4.51
+                                            ],
+                                            'id': '0.1.x.x'
+                                        }
+                                    },
+                                    'id': '0.1.x'
+                                }
+                            },
+                            'id': '0.1'
+                        }
+                    }
+                ],
+                'id': '0'
+            }
+        })
+
     def test_get_item_raises_key_if_id_doesnt_exist(self):
         c = Component()
         with self.assertRaises(KeyError):

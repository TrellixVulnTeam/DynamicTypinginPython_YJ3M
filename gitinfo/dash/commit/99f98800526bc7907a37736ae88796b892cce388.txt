commit 99f98800526bc7907a37736ae88796b892cce388
Author: Philippe Duval <philippe@plot.ly>
Date:   Thu Oct 25 16:19:39 2018 -0400

    Multi-output callback support.

diff --git a/src/actions/index.js b/src/actions/index.js
index f0dc6ea4..a8b7b586 100644
--- a/src/actions/index.js
+++ b/src/actions/index.js
@@ -237,7 +237,15 @@ export function notifyObservers(payload) {
         );
         const queuedObservers = [];
         outputObservers.forEach(function filterObservers(outputIdAndProp) {
-            const outputComponentId = outputIdAndProp.split('.')[0];
+            let outputIds;
+            if (outputIdAndProp.startsWith('[')) {
+                outputIds = outputIdAndProp
+                    .slice(1, outputIdAndProp.length - 1)
+                    .split(':')
+                    .map(e => e.split('.')[0]);
+            } else {
+                outputIds = [outputIdAndProp.split('.')[0]];
+            }
 
             /*
              * before we make the POST to update the output, check
@@ -305,9 +313,12 @@ export function notifyObservers(payload) {
              * of a controller change.
              * for example, perhaps the user has hidden one of the observers
              */
+
+            const {paths} = getState();
+
             if (
                 controllersInFutureQueue.length === 0 &&
-                has(outputComponentId, getState().paths) &&
+                any(e => has(e, paths))(outputIds) &&
                 !controllerIsInExistingQueue
             ) {
                 queuedObservers.push(outputIdAndProp);
@@ -330,14 +341,13 @@ export function notifyObservers(payload) {
         const promises = [];
         for (let i = 0; i < queuedObservers.length; i++) {
             const outputIdAndProp = queuedObservers[i];
-            const [outputComponentId, outputProp] = outputIdAndProp.split('.');
+            // const [outputComponentId, outputProp] = outputIdAndProp.split('.');
 
             const requestUid = newRequestQueue[i].uid;
 
             promises.push(
                 updateOutput(
-                    outputComponentId,
-                    outputProp,
+                    outputIdAndProp,
                     getState,
                     requestUid,
                     dispatch
@@ -352,8 +362,7 @@ export function notifyObservers(payload) {
 }
 
 function updateOutput(
-    outputComponentId,
-    outputProp,
+    outputIdAndProp,
     getState,
     requestUid,
     dispatch
@@ -370,13 +379,11 @@ function updateOutput(
      * }
      */
     const payload = {
-        output: {id: outputComponentId, property: outputProp},
+        output: outputIdAndProp,
     };
 
     const {inputs, state} = dependenciesRequest.content.find(
-        dependency =>
-            dependency.output.id === outputComponentId &&
-            dependency.output.property === outputProp
+        dependency => dependency.output === outputIdAndProp
     );
     const validKeys = keys(paths);
 
@@ -484,7 +491,7 @@ function updateOutput(
         const isRejected = () => {
             const latestRequestIndex = findLastIndex(
                 // newRequestQueue[i].controllerId),
-                propEq('controllerId', `${outputComponentId}.${outputProp}`),
+                propEq('controllerId', outputIdAndProp),
                 getState().requestQueue
             );
             /*
@@ -535,179 +542,178 @@ function updateOutput(
              * if it's not visible, then ignore the rest of the updates
              * to the store
              */
-            if (!has(outputComponentId, getState().paths)) {
-                return;
-            }
 
-            // and update the props of the component
-            const observerUpdatePayload = {
-                itempath: getState().paths[outputComponentId],
-                // new prop from the server
-                props: data.response.props,
-                source: 'response',
-            };
-            dispatch(updateProps(observerUpdatePayload));
+            const {paths} = getState();
 
-            dispatch(
-                notifyObservers({
-                    id: outputComponentId,
-                    props: data.response.props,
-                })
-            );
+            Object.keys(data.response).map(k => [k, data.response[k]]).forEach(([k, props]) => {
+                const observerUpdatePayload = {
+                    itempath: paths[k],
+                    props,
+                    source: 'response'
+                };
+                dispatch(updateProps(observerUpdatePayload));
 
-            /*
-             * If the response includes children, then we need to update our
-             * paths store.
-             * TODO - Do we need to wait for updateProps to finish?
-             */
-            if (has('children', observerUpdatePayload.props)) {
                 dispatch(
-                    computePaths({
-                        subTree: observerUpdatePayload.props.children,
-                        startingPath: concat(
-                            getState().paths[outputComponentId],
-                            ['props', 'children']
-                        ),
+                    notifyObservers({
+                        id: k,
+                        props: props,
                     })
                 );
 
                 /*
-                 * if children contains objects with IDs, then we
-                 * need to dispatch a propChange for all of these
-                 * new children components
+                 * If the response includes children, then we need to update our
+                 * paths store.
+                 * TODO - Do we need to wait for updateProps to finish?
                  */
-                if (
-                    contains(type(observerUpdatePayload.props.children), [
-                        'Array',
-                        'Object',
-                    ]) &&
-                    !isEmpty(observerUpdatePayload.props.children)
-                ) {
-                    /*
-                     * TODO: We're just naively crawling
-                     * the _entire_ layout to recompute the
-                     * the dependency graphs.
-                     * We don't need to do this - just need
-                     * to compute the subtree
-                     */
-                    const newProps = {};
-                    crawlLayout(
-                        observerUpdatePayload.props.children,
-                        function appendIds(child) {
-                            if (hasId(child)) {
-                                keys(child.props).forEach(childProp => {
-                                    const componentIdAndProp = `${
-                                        child.props.id
-                                    }.${childProp}`;
-                                    if (
-                                        has(
-                                            componentIdAndProp,
-                                            InputGraph.nodes
-                                        )
-                                    ) {
-                                        newProps[componentIdAndProp] = {
-                                            id: child.props.id,
-                                            props: {
-                                                [childProp]:
-                                                    child.props[childProp],
-                                            },
-                                        };
-                                    }
-                                });
-                            }
-                        }
+                if (has('children', observerUpdatePayload.props)) {
+                    dispatch(
+                        computePaths({
+                            subTree: observerUpdatePayload.props.children,
+                            startingPath: concat(
+                                paths[k],
+                                ['props', 'children']
+                            ),
+                        })
                     );
 
                     /*
-                     * Organize props by shared outputs so that we
-                     * only make one request per output component
-                     * (even if there are multiple inputs).
-                     *
-                     * For example, we might render 10 inputs that control
-                     * a single output. If that is the case, we only want
-                     * to make a single call, not 10 calls.
-                     */
+                    * if children contains objects with IDs, then we
+                    * need to dispatch a propChange for all of these
+                    * new children components
+                    */
+                    if (
+                        contains(type(observerUpdatePayload.props.children), [
+                            'Array',
+                            'Object',
+                        ]) &&
+                        !isEmpty(observerUpdatePayload.props.children)
+                    ) {
+                        /*
+                         * TODO: We're just naively crawling
+                         * the _entire_ layout to recompute the
+                         * the dependency graphs.
+                         * We don't need to do this - just need
+                         * to compute the subtree
+                         */
+                        const newProps = {};
+                        crawlLayout(
+                            observerUpdatePayload.props.children,
+                            function appendIds(child) {
+                                if (hasId(child)) {
+                                    keys(child.props).forEach(childProp => {
+                                        const componentIdAndProp = `${
+                                            child.props.id
+                                        }.${childProp}`;
+                                        if (
+                                            has(
+                                                componentIdAndProp,
+                                                InputGraph.nodes
+                                            )
+                                        ) {
+                                            newProps[componentIdAndProp] = {
+                                                id: child.props.id,
+                                                props: {
+                                                    [childProp]:
+                                                        child.props[childProp],
+                                                },
+                                            };
+                                        }
+                                    });
+                                }
+                            }
+                        );
 
-                    /*
-                     * In some cases, the new item will be an output
-                     * with its inputs already rendered (not rendered)
-                     * as part of this update.
-                     * For example, a tab with global controls that
-                     * renders different content containers without any
-                     * additional inputs.
-                     *
-                     * In that case, we'll call `updateOutput` with that output
-                     * and just "pretend" that one if its inputs changed.
-                     *
-                     * If we ever add logic that informs the user on
-                     * "which input changed", we'll have to account for this
-                     * special case (no input changed?)
-                     */
-
-                    const outputIds = [];
-                    keys(newProps).forEach(idAndProp => {
-                        if (
-                            // It's an output
-                            InputGraph.dependenciesOf(idAndProp).length === 0 &&
-                            /*
-                             * And none of its inputs are generated in this
-                             * request
-                             */
-                            intersection(
-                                InputGraph.dependantsOf(idAndProp),
-                                keys(newProps)
-                            ).length === 0
-                        ) {
-                            outputIds.push(idAndProp);
-                            delete newProps[idAndProp];
-                        }
-                    });
-
-                    // Dispatch updates to inputs
-                    const reducedNodeIds = reduceInputIds(
-                        keys(newProps),
-                        InputGraph
-                    );
-                    const depOrder = InputGraph.overallOrder();
-                    const sortedNewProps = sort(
-                        (a, b) =>
-                            depOrder.indexOf(a.input) -
-                            depOrder.indexOf(b.input),
-                        reducedNodeIds
-                    );
-                    sortedNewProps.forEach(function(inputOutput) {
-                        const payload = newProps[inputOutput.input];
-                        payload.excludedOutputs = inputOutput.excludedOutputs;
-                        dispatch(notifyObservers(payload));
-                    });
-
-                    // Dispatch updates to lone outputs
-                    outputIds.forEach(idAndProp => {
-                        const requestUid = uid();
-                        dispatch(
-                            setRequestQueue(
-                                append(
-                                    {
-                                        // TODO - Are there any implications of doing this??
-                                        controllerId: null,
-                                        status: 'loading',
-                                        uid: requestUid,
-                                        requestTime: Date.now(),
-                                    },
-                                    getState().requestQueue
-                                )
-                            )
+                        /*
+                         * Organize props by shared outputs so that we
+                         * only make one request per output component
+                         * (even if there are multiple inputs).
+                         *
+                         * For example, we might render 10 inputs that control
+                         * a single output. If that is the case, we only want
+                         * to make a single call, not 10 calls.
+                         */
+
+                        /*
+                         * In some cases, the new item will be an output
+                         * with its inputs already rendered (not rendered)
+                         * as part of this update.
+                         * For example, a tab with global controls that
+                         * renders different content containers without any
+                         * additional inputs.
+                         *
+                         * In that case, we'll call `updateOutput` with that output
+                         * and just "pretend" that one if its inputs changed.
+                         *
+                         * If we ever add logic that informs the user on
+                         * "which input changed", we'll have to account for this
+                         * special case (no input changed?)
+                         */
+
+                        const outputIds = [];
+                        keys(newProps).forEach(idAndProp => {
+                            if (
+                                // It's an output
+                                InputGraph.dependenciesOf(idAndProp).length === 0 &&
+                                /*
+                                 * And none of its inputs are generated in this
+                                 * request
+                                 */
+                                intersection(
+                                    InputGraph.dependantsOf(idAndProp),
+                                    keys(newProps)
+                                ).length === 0
+                            ) {
+                                outputIds.push(idAndProp);
+                                delete newProps[idAndProp];
+                            }
+                        });
+
+                        // Dispatch updates to inputs
+                        const reducedNodeIds = reduceInputIds(
+                            keys(newProps),
+                            InputGraph
                         );
-                        updateOutput(
-                            idAndProp.split('.')[0],
-                            idAndProp.split('.')[1],
-                            getState,
-                            requestUid,
-                            dispatch
+                        const depOrder = InputGraph.overallOrder();
+                        const sortedNewProps = sort(
+                            (a, b) =>
+                                depOrder.indexOf(a.input) -
+                                depOrder.indexOf(b.input),
+                            reducedNodeIds
                         );
-                    });
+                        sortedNewProps.forEach(function(inputOutput) {
+                            const payload = newProps[inputOutput.input];
+                            payload.excludedOutputs = inputOutput.excludedOutputs;
+                            dispatch(notifyObservers(payload));
+                        });
+
+                        // Dispatch updates to lone outputs
+                        outputIds.forEach(idAndProp => {
+                            const requestUid = uid();
+                            dispatch(
+                                setRequestQueue(
+                                    append(
+                                        {
+                                            // TODO - Are there any implications of doing this??
+                                            controllerId: null,
+                                            status: 'loading',
+                                            uid: requestUid,
+                                            requestTime: Date.now(),
+                                        },
+                                        getState().requestQueue
+                                    )
+                                )
+                            );
+                            updateOutput(
+                                idAndProp,
+
+                                getState,
+                                requestUid,
+                                dispatch
+                            );
+                        });
+                    }
                 }
-            }
+            });
         });
     });
 }
diff --git a/src/reducers/dependencyGraph.js b/src/reducers/dependencyGraph.js
index bb63430f..6992fb57 100644
--- a/src/reducers/dependencyGraph.js
+++ b/src/reducers/dependencyGraph.js
@@ -10,12 +10,11 @@ const graphs = (state = initialGraph, action) => {
 
             dependencies.forEach(function registerDependency(dependency) {
                 const {output, inputs} = dependency;
-                const outputId = `${output.id}.${output.property}`;
                 inputs.forEach(inputObject => {
                     const inputId = `${inputObject.id}.${inputObject.property}`;
-                    inputGraph.addNode(outputId);
+                    inputGraph.addNode(output);
                     inputGraph.addNode(inputId);
-                    inputGraph.addDependency(inputId, outputId);
+                    inputGraph.addDependency(inputId, output);
                 });
             });
 

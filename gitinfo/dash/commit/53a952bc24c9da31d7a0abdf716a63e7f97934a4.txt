commit 53a952bc24c9da31d7a0abdf716a63e7f97934a4
Author: alexcjohnson <alex@plot.ly>
Date:   Tue Oct 15 17:45:32 2019 -0400

    wildcards back end

diff --git a/dash/_utils.py b/dash/_utils.py
index f7952af3..79062c6f 100644
--- a/dash/_utils.py
+++ b/dash/_utils.py
@@ -163,7 +163,13 @@ def create_callback_id(output):
     if isinstance(output, (list, tuple)):
         return "..{}..".format(
             "...".join(
-                "{}.{}".format(x.component_id, x.component_property)
+                "{}.{}".format(
+                    # A single dot within a dict id key or value is OK
+                    # but in case of multiple dots together escape each dot
+                    # with `\` so we don't mistake it for multi-outputs
+                    x.component_id_str().replace(".", "\\."),
+                    x.component_property
+                )
                 for x in output
             )
         )
diff --git a/dash/_validate.py b/dash/_validate.py
index f6d35607..12cee117 100644
--- a/dash/_validate.py
+++ b/dash/_validate.py
@@ -1,15 +1,10 @@
 import collections
-from itertools import chain
-import pprint
 import re
 
-from .development.base_component import Component
-from .dependencies import Input, Output, State
+from .development.base_component import Component, _strings
+from .dependencies import Input, Output, State, ANY, ALLSMALLER, PREVIOUS
 from . import exceptions
-from ._utils import create_callback_id, patch_collections_abc
-
-# py2/3 json.dumps-compatible strings - these are equivalent in py3, not in py2
-_strings = (type(u""), type(""))
+from ._utils import patch_collections_abc
 
 
 def validate_callback(app, layout, output, inputs, state):
@@ -52,58 +47,89 @@ def validate_callback(app, layout, output, inputs, state):
         if is_multi:
             for o in output:
                 if o == i:
+                    # Note: different but overlapping wildcards compare as equal
                     bad = o
-        else:
-            if output == i:
-                bad = output
+        elif output == i:
+            bad = output
         if bad:
             raise exceptions.SameInputOutputException(
                 "Same output and input: {}".format(bad)
             )
 
-    if is_multi:
-        if len(set(output)) != len(output):
-            raise exceptions.DuplicateCallbackOutput(
-                "Same output was used more than once in a "
-                "multi output callback!\nDuplicates:\n{}".format(
-                    ",\n".join(str(x) for x in output if output.count(x) > 1)
+    if is_multi and len(set(output)) != len(output):
+        raise exceptions.DuplicateCallbackOutput(
+            """
+            Same output was used more than once in a multi output callback!
+            Duplicates:
+            {}
+            """.format(
+                ",\n".join(str(x) for x in output if output.count(x) > 1)
+            )
+        )
+
+    any_keys = get_wildcard_keys(outputs[0], (ANY,))
+    for out in outputs[1:]:
+        if get_wildcard_keys(out, (ANY,)) != any_keys:
+            raise exceptions.InconsistentCallbackWildcards(
+                """
+                All `Output` items must have matching wildcard `ANY` values.
+                `ALL` wildcards need not match, only `ANY`.
+
+                Output {} does not match the first output {}.
+                """.format(
+                    out, outputs[0]
                 )
             )
 
-    callback_id = create_callback_id(output)
+    matched_wildcards = (ANY, ALLSMALLER, PREVIOUS)
+    for dep in list(inputs) + list(state):
+        wildcard_keys = get_wildcard_keys(dep, matched_wildcards)
+        if wildcard_keys - any_keys:
+            raise exceptions.InconsistentCallbackWildcards(
+                """
+                `Input` and `State` items can only have {}
+                wildcards on keys where the `Output`(s) have `ANY` wildcards.
+                `ALL` wildcards need not match, and you need not match every
+                `ANY` in the `Output`(s).
 
-    callbacks = set(
-        chain(
-            *(
-                x[2:-2].split("...") if x.startswith("..") else [x]
-                for x in app.callback_map
+                This callback has `ANY` on keys {}.
+                {} has these wildcards on keys {}.
+                """.format(
+                    matched_wildcards, any_keys, dep, wildcard_keys
+                )
             )
-        )
-    )
 
-    if is_multi:
-        dups = callbacks.intersection(str(y) for y in output)
-        if dups:
+    dups = set()
+    for out in outputs:
+        for used_out in app.used_outputs:
+            if out == used_out:
+                dups.add(str(used_out))
+    if dups:
+        if is_multi or len(dups) > 1 or str(output) != list(dups)[0]:
             raise exceptions.DuplicateCallbackOutput(
                 """
-                Multi output {} contains an `Output` object
-                that was already assigned.
-                Duplicates:
+                One or more `Output` is already set by a callback.
+                Note that two wildcard outputs can refer to the same component
+                even if they don't match exactly.
+
+                The new callback lists output(s):
+                {}
+                Already used:
                 {}
                 """.format(
-                    callback_id, pprint.pformat(dups)
+                    ", ".join([str(o) for o in outputs]),
+                    ", ".join(dups)
                 )
             )
-    else:
-        if callback_id in callbacks:
+        else:
             raise exceptions.DuplicateCallbackOutput(
                 """
-                You have already assigned a callback to the output
-                with ID "{}" and property "{}". An output can only have
-                a single callback function. Try combining your inputs and
-                callback functions together into one function.
+                {} was already assigned to a callback.
+                Any given output can only have one callback that sets it.
+                Try combining your inputs and callback functions together
+                into one function.
                 """.format(
-                    output.component_id, output.component_property
+                    repr(output)
                 )
             )
 
@@ -130,7 +156,30 @@ def validate_callback_args(args, cls, layout, validate_ids):
                 )
             )
 
-        if not isinstance(arg.component_id, _strings):
+        if not isinstance(getattr(arg, "component_property", None), _strings):
+            raise exceptions.IncorrectTypeException(
+                """
+                component_property must be a string, found {!r}
+                """.format(
+                    arg.component_property
+                )
+            )
+
+        if hasattr(arg, "component_event"):
+            raise exceptions.NonExistentEventException(
+                """
+                Events have been removed.
+                Use the associated property instead.
+                """
+            )
+
+        if isinstance(arg.component_id, dict):
+            validate_id_dict(arg, layout, validate_ids, cls.allowed_wildcards)
+
+        elif isinstance(arg.component_id, _strings):
+            validate_id_string(arg, layout, validate_ids)
+
+        else:
             raise exceptions.IncorrectTypeException(
                 """
                 component_id must be a string or dict, found {!r}
@@ -139,77 +188,112 @@ def validate_callback_args(args, cls, layout, validate_ids):
                 )
             )
 
-        if not isinstance(arg.component_property, _strings):
+
+def validate_id_dict(arg, layout, validate_ids, wildcards):
+    arg_id = arg.component_id
+
+    def id_match(c):
+        c_id = getattr(c, "id", None)
+        return isinstance(c_id, dict) and all(
+            k in c and v in wildcards or v == c_id.get(k)
+        )
+
+    if validate_ids:
+        component = None
+        if id_match(layout):
+            component = layout
+        else:
+            for c in layout._traverse():
+                if id_match(c):
+                    component = c
+                    break
+        if component:
+            # for wildcards it's not unusual to have no matching components
+            # initially; this isn't a problem and we shouldn't force users to
+            # set suppress_callback_exceptions in this case; but if we DO have
+            # a matching component, we can check that the prop is valid
+            validate_prop_for_component(arg, component)
+
+    for k, v in arg_id.items():
+        if not (k and isinstance(k, _strings)):
             raise exceptions.IncorrectTypeException(
                 """
-                component_property must be a string, found {!r}
+                Wildcard ID keys must be non-empty strings,
+                found {!r} in id {!r}
                 """.format(
-                    arg.component_property
+                    k, arg_id
                 )
             )
-
-        invalid_characters = ["."]
-        if any(x in arg.component_id for x in invalid_characters):
-            raise exceptions.InvalidComponentIdError(
+        if not (v in wildcards or isinstance(v, _strings + (int, float, bool))):
+            wildcard_msg = (
+                ",\n                or wildcards: {}".format(wildcards)
+                if wildcards else ""
+            )
+            raise exceptions.IncorrectTypeException(
                 """
-                The element `{}` contains {} in its ID.
-                Periods are not allowed in IDs.
+                Wildcard {} ID values must be strings, numbers, bools{}
+                found {!r} in id {!r}
                 """.format(
-                    arg.component_id, invalid_characters
+                    arg.__class__.__name__, wildcard_msg, k, arg_id
                 )
             )
 
-        if validate_ids:
-            top_id = getattr(layout, "id", None)
-            arg_id = arg.component_id
-            arg_prop = getattr(arg, "component_property", None)
-            if arg_id not in layout and arg_id != top_id:
-                raise exceptions.NonExistentIdException(
-                    """
-                    Attempting to assign a callback to the component with
-                    id "{}" but no components with that id exist in the layout.
-
-                    Here is a list of IDs in layout:
-                    {}
-
-                    If you are assigning callbacks to components that are
-                    generated by other callbacks (and therefore not in the
-                    initial layout), you can suppress this exception by setting
-                    `suppress_callback_exceptions=True`.
-                    """.format(
-                        arg_id, [k for k in layout] + ([top_id] if top_id else [])
-                    )
-                )
 
-            component = layout if top_id == arg_id else layout[arg_id]
+def validate_id_string(arg, layout, validate_ids):
+    arg_id = arg.component_id
 
-            if (
-                arg_prop
-                and arg_prop not in component.available_properties
-                and not any(
-                    arg_prop.startswith(w)
-                    for w in component.available_wildcard_properties
-                )
-            ):
-                raise exceptions.NonExistentPropException(
-                    """
-                    Attempting to assign a callback with the property "{0}"
-                    but component "{1}" doesn't have "{0}" as a property.
-
-                    Here are the available properties in "{1}":
-                    {2}
-                    """.format(
-                        arg_prop, arg_id, component.available_properties
-                    )
-                )
+    invalid_chars = ".{"
+    invalid_found = [x for x in invalid_chars if x in arg_id]
+    if invalid_found:
+        raise exceptions.InvalidComponentIdError(
+            """
+            The element `{}` contains `{}` in its ID.
+            Characters `{}` are not allowed in IDs.
+            """.format(
+                arg_id, "`, `".join(invalid_found), "`, `".join(invalid_chars)
+            )
+        )
+
+    if validate_ids:
+        top_id = getattr(layout, "id", None)
+        if arg_id not in layout and arg_id != top_id:
+            raise exceptions.NonExistentIdException(
+                """
+                Attempting to assign a callback to the component with
+                id "{}" but no components with that id exist in the layout.
+
+                Here is a list of IDs in layout:
+                {}
 
-            if hasattr(arg, "component_event"):
-                raise exceptions.NonExistentEventException(
-                    """
-                    Events have been removed.
-                    Use the associated property instead.
-                    """
+                If you are assigning callbacks to components that are
+                generated by other callbacks (and therefore not in the
+                initial layout), you can suppress this exception by setting
+                `suppress_callback_exceptions=True`.
+                """.format(
+                    arg_id, [k for k in layout] + ([top_id] if top_id else [])
                 )
+            )
+
+        component = layout if top_id == arg_id else layout[arg_id]
+        validate_prop_for_component(arg, component)
+
+
+def validate_prop_for_component(arg, component):
+    arg_prop = arg.component_property
+    if arg_prop not in component.available_properties and not any(
+        arg_prop.startswith(w) for w in component.available_wildcard_properties
+    ):
+        raise exceptions.NonExistentPropException(
+            """
+            Attempting to assign a callback with the property "{0}"
+            but component "{1}" doesn't have "{0}" as a property.
+
+            Here are the available properties in "{1}":
+            {2}
+            """.format(
+                arg_prop, arg.component_id, component.available_properties
+            )
+        )
 
 
 def validate_multi_return(output, output_value, callback_id):
@@ -224,7 +308,7 @@ def validate_multi_return(output, output_value, callback_id):
             )
         )
 
-    if not len(output_value) == len(output):
+    if len(output_value) != len(output):
         raise exceptions.InvalidCallbackReturnValue(
             """
             Invalid number of output values for {}.
@@ -346,6 +430,13 @@ def fail_callback_output(output_value, output):
     )
 
 
+def get_wildcard_keys(dep, wildcards):
+    _id = dep.component_id
+    if not isinstance(_id, dict):
+        return set()
+    return {k for k, v in _id.items() if v in wildcards}
+
+
 def check_obsolete(kwargs):
     for key in kwargs:
         if key in ["components_cache_max_age", "static_folder"]:
diff --git a/dash/dash.py b/dash/dash.py
index 257f3e3a..fb92984b 100644
--- a/dash/dash.py
+++ b/dash/dash.py
@@ -305,6 +305,7 @@ class Dash(object):
 
         # list of dependencies
         self.callback_map = {}
+        self.used_outputs = []
 
         # list of inline scripts
         self._inline_scripts = []
@@ -806,15 +807,10 @@ class Dash(object):
         callback_id = create_callback_id(output)
 
         self.callback_map[callback_id] = {
-            "inputs": [
-                {"id": c.component_id, "property": c.component_property}
-                for c in inputs
-            ],
-            "state": [
-                {"id": c.component_id, "property": c.component_property}
-                for c in state
-            ],
+            "inputs": [c.to_dict() for c in inputs],
+            "state": [c.to_dict() for c in state],
         }
+        self.used_outputs.extend(output if callback_id.startswith("..") else [output])
 
         return callback_id
 
diff --git a/dash/dependencies.py b/dash/dependencies.py
index 6bc5413f..a570886d 100644
--- a/dash/dependencies.py
+++ b/dash/dependencies.py
@@ -1,20 +1,90 @@
-class DashDependency:
-    # pylint: disable=too-few-public-methods
+class _Wildcard:  # pylint: disable=too-few-public-methods
+    def __init__(self, name):
+        self._name = name
+
+    def __str__(self):
+        return self._name
+
+    def __repr__(self):
+        return "<{}>".format(self)
+
+    def to_json(self):
+        # used in serializing wildcards - arrays are not allowed as
+        # id values, so make the wildcards look like length-1 arrays.
+        return '["{}"]'.format(self._name)
+
+
+ANY = _Wildcard("ANY")
+ALL = _Wildcard("ALL")
+ALLSMALLER = _Wildcard("ALLSMALLER")
+PREVIOUS = _Wildcard("PREVIOUS")
+
+
+class DashDependency:  # pylint: disable=too-few-public-methods
     def __init__(self, component_id, component_property):
         self.component_id = component_id
         self.component_property = component_property
 
     def __str__(self):
-        return "{}.{}".format(
-            self.component_id,
-            self.component_property
-        )
+        return "{}.{}".format(self.component_id_str(), self.component_property)
 
     def __repr__(self):
         return "<{} `{}`>".format(self.__class__.__name__, self)
 
+    def component_id_str(self):
+        i = self.component_id
+
+        def json(k, v):
+            vstr = v.to_json() if hasattr(v, "to_json") else json.dumps(v)
+            return "{}:{}".format(json.dumps(k), vstr)
+
+        if isinstance(i, dict):
+            return ("{" + ",".join(json(k, i[k]) for k in sorted(i)) + "}")
+
+        return i
+
+    def to_dict(self):
+        return {"id": self.component_id_str(), "property": self.component_property}
+
     def __eq__(self, other):
-        return isinstance(other, DashDependency) and str(self) == str(other)
+        """
+        We use "==" to denote two deps that refer to the same prop on
+        the same component. In the case of wildcard deps, this means
+        the same prop on *at least one* of the same components.
+        """
+        return (
+            isinstance(other, DashDependency)
+            and self.component_property == other.component_property
+            and self._id_matches(other)
+        )
+
+    def _id_matches(self, other):
+        other_id = other.component_id
+        if isinstance(self.component_id, dict):
+            if not isinstance(other_id, dict):
+                return False
+            for k, v in self.component_id.items():
+                if k not in other_id:
+                    return False
+                other_v = other_id[k]
+                if v == other_v:
+                    continue
+                v_wild = isinstance(v, _Wildcard)
+                other_wild = isinstance(other_v, _Wildcard)
+                if v_wild or other_wild:
+                    if not (v_wild and other_wild):
+                        continue  # one wild, one not
+                    if v is ALL or other_v is ALL:
+                        continue  # either ALL
+                    if v is ANY or other_v is ANY:
+                        return False  # ANY and either ALLSMALLER or PREVIOUS
+                else:
+                    return False
+            return True
+        elif isinstance(other_id, dict):
+            return False
+        else:
+            return self.component_id == other_id
 
     def __hash__(self):
         return hash(str(self))
@@ -23,17 +93,22 @@ class DashDependency:
 class Output(DashDependency):  # pylint: disable=too-few-public-methods
     """Output of a callback."""
 
+    allowed_wildcards = (ANY, ALL)
+
 
 class Input(DashDependency):  # pylint: disable=too-few-public-methods
     """Input of callback: trigger an update when it is updated."""
 
+    allowed_wildcards = (ANY, ALL, ALLSMALLER, PREVIOUS)
+
 
 class State(DashDependency):  # pylint: disable=too-few-public-methods
     """Use the value of a State in a callback but don't trigger updates."""
 
+    allowed_wildcards = (ANY, ALL, ALLSMALLER, PREVIOUS)
 
-class ClientsideFunction:
-    # pylint: disable=too-few-public-methods
+
+class ClientsideFunction:  # pylint: disable=too-few-public-methods
     def __init__(self, namespace=None, function_name=None):
 
         if namespace.startswith('_dashprivate_'):
@@ -47,7 +122,4 @@ class ClientsideFunction:
         self.function_name = function_name
 
     def __repr__(self):
-        return "ClientsideFunction({}, {})".format(
-            self.namespace,
-            self.function_name
-        )
+        return "ClientsideFunction({}, {})".format(self.namespace, self.function_name)
diff --git a/dash/development/base_component.py b/dash/development/base_component.py
index 6f0b2ee2..50483ef0 100644
--- a/dash/development/base_component.py
+++ b/dash/development/base_component.py
@@ -7,6 +7,9 @@ from .._utils import patch_collections_abc
 
 MutableSequence = patch_collections_abc("MutableSequence")
 
+# py2/3 json.dumps-compatible strings - these are equivalent in py3, not in py2
+_strings = (type(u""), type(""))
+
 
 # pylint: disable=no-init,too-few-public-methods
 class ComponentRegistry:
@@ -122,6 +125,24 @@ class Component(with_metaclass(ComponentMeta, object)):
                     "Prop {} has value {}\n".format(k, repr(v))
                 )
 
+            if k == "id":
+                if isinstance(v, dict):
+                    for id_key, id_val in v.items():
+                        if not isinstance(id_key, _strings):
+                            raise TypeError(
+                                "dict id keys must be strings,\n" +
+                                "found {!r} in id {!r}".format(id_key, v)
+                            )
+                        if not isinstance(id_val, _strings + (int, float, bool)):
+                            raise TypeError(
+                                "dict id values must be strings, numbers or bools,\n" +
+                                "found {!r} in id {!r}".format(id_val, v)
+                            )
+                elif not isinstance(v, _strings):
+                    raise TypeError(
+                        "`id` prop must be a string or dict, not {!r}".format(v)
+                    )
+
             setattr(self, k, v)
 
     def to_plotly_json(self):
diff --git a/dash/exceptions.py b/dash/exceptions.py
index 9bf0c099..3f3aca59 100644
--- a/dash/exceptions.py
+++ b/dash/exceptions.py
@@ -64,6 +64,10 @@ class DuplicateCallbackOutput(CantHaveMultipleOutputs):
     pass
 
 
+class InconsistentCallbackWildcards(CallbackException):
+    pass
+
+
 class PreventUpdate(CallbackException):
     pass
 

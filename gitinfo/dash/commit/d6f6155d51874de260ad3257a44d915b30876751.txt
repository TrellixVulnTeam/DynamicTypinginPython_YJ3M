commit d6f6155d51874de260ad3257a44d915b30876751
Author: chriddyp <chris@plot.ly>
Date:   Wed Apr 19 12:06:54 2017 -0400

    set the response status before calling `.json()`

diff --git a/src/actions/index.js b/src/actions/index.js
index feb11147..18b72828 100644
--- a/src/actions/index.js
+++ b/src/actions/index.js
@@ -453,117 +453,119 @@ export const notifyObservers = function(payload) {
                 },
                 credentials: 'same-origin',
                 body: JSON.stringify(payload)
-            }).then(response => response.json().then(function handleResponse(data) {
+            }).then(function handleResponse(res) {
                 dispatch({
                     type: 'lastUpdateComponentRequest',
-                    payload: {status: response.status}
+                    payload: {status: res.status}
                 });
 
-                // clear this item from the request queue
-                dispatch(setRequestQueue(
-                    reject(
-                        id => id === outputIdAndProp,
-                        getState().requestQueue
-                    )
-                ));
+                return res.json().then(function handleJson(data) {
 
-                /*
-                 * it's possible that this output item is no longer visible.
-                 * for example, the could still be request running when
-                 * the user switched the chapter
-                 *
-                 * if it's not visible, then ignore the rest of the updates
-                 * to the store
-                 */
-                if (!has(outputComponentId, getState().paths)) {
-                    return;
-                }
-
-                // and update the props of the component
-                const observerUpdatePayload = {
-                    itempath: getState().paths[outputComponentId],
-                    // new prop from the server
-                    props: data.response.props,
-                    source: 'response'
-                };
-                dispatch(updateProps(observerUpdatePayload));
-
-                dispatch(notifyObservers({
-                    id: outputComponentId,
-                    props: data.response.props
-                }));
+                    // clear this item from the request queue
+                    dispatch(setRequestQueue(
+                        reject(
+                            id => id === outputIdAndProp,
+                            getState().requestQueue
+                        )
+                    ));
 
-                /*
-                 * If the response includes content, then we need to update our
-                 * paths store.
-                 * TODO - Do we need to wait for updateProps to finish?
-                 */
-                if (has('content', observerUpdatePayload.props)) {
+                    /*
+                     * it's possible that this output item is no longer visible.
+                     * for example, the could still be request running when
+                     * the user switched the chapter
+                     *
+                     * if it's not visible, then ignore the rest of the updates
+                     * to the store
+                     */
+                    if (!has(outputComponentId, getState().paths)) {
+                        return;
+                    }
 
-                    dispatch(computePaths({
-                        subTree: observerUpdatePayload.props.content,
-                        startingPath: concat(
-                            getState().paths[outputComponentId],
-                            ['props', 'content']
-                        )
+                    // and update the props of the component
+                    const observerUpdatePayload = {
+                        itempath: getState().paths[outputComponentId],
+                        // new prop from the server
+                        props: data.response.props,
+                        source: 'response'
+                    };
+                    dispatch(updateProps(observerUpdatePayload));
+
+                    dispatch(notifyObservers({
+                        id: outputComponentId,
+                        props: data.response.props
                     }));
 
                     /*
-                     * if content contains objects with IDs, then we
-                     * need to dispatch a propChange for all of these
-                     * new children components
+                     * If the response includes content, then we need to update our
+                     * paths store.
+                     * TODO - Do we need to wait for updateProps to finish?
                      */
-                    if (contains(
-                            type(observerUpdatePayload.props.content),
-                            ['Array', 'Object']
-                        ) && !isEmpty(observerUpdatePayload.props.content)
-                    ) {
+                    if (has('content', observerUpdatePayload.props)) {
+
+                        dispatch(computePaths({
+                            subTree: observerUpdatePayload.props.content,
+                            startingPath: concat(
+                                getState().paths[outputComponentId],
+                                ['props', 'content']
+                            )
+                        }));
+
                         /*
-                         * TODO: We're just naively crawling
-                         * the _entire_ layout to recompute the
-                         * the dependency graphs.
-                         * We don't need to do this - just need
-                         * to compute the subtree
+                         * if content contains objects with IDs, then we
+                         * need to dispatch a propChange for all of these
+                         * new children components
                          */
-                        const newProps = [];
-                        crawlLayout(
-                            observerUpdatePayload.props.content,
-                            function appendIds(child) {
-                                if (hasId(child)) {
-                                    keys(child.props).forEach(childProp => {
-                                        const inputId = (
-                                            `${child.props.id}.${childProp}`
-                                        );
-                                        if (has(inputId, InputGraph.nodes)) {
-                                            newProps.push({
-                                                id: child.props.id,
-                                                props: {
-                                                    [childProp]: child.props[childProp]
-                                                },
-                                                dontUpdateInputObservers
-                                            });
-                                        }
-                                    })
+                        if (contains(
+                                type(observerUpdatePayload.props.content),
+                                ['Array', 'Object']
+                            ) && !isEmpty(observerUpdatePayload.props.content)
+                        ) {
+                            /*
+                             * TODO: We're just naively crawling
+                             * the _entire_ layout to recompute the
+                             * the dependency graphs.
+                             * We don't need to do this - just need
+                             * to compute the subtree
+                             */
+                            const newProps = [];
+                            crawlLayout(
+                                observerUpdatePayload.props.content,
+                                function appendIds(child) {
+                                    if (hasId(child)) {
+                                        keys(child.props).forEach(childProp => {
+                                            const inputId = (
+                                                `${child.props.id}.${childProp}`
+                                            );
+                                            if (has(inputId, InputGraph.nodes)) {
+                                                newProps.push({
+                                                    id: child.props.id,
+                                                    props: {
+                                                        [childProp]: child.props[childProp]
+                                                    },
+                                                    dontUpdateInputObservers
+                                                });
+                                            }
+                                        })
+                                    }
                                 }
+                            );
+
+                            const depOrder = InputGraph.overallOrder();
+                            const sortedNewProps = sort((a, b) =>
+                                depOrder.indexOf(a.id) - depOrder.indexOf(b.id),
+                                newProps
+                            )
+                            if (!dontUpdateInputObservers) {
+                                sortedNewProps.forEach(function(propUpdate) {
+                                    dispatch(notifyObservers(propUpdate));
+                                });
                             }
-                        );
-
-                        const depOrder = InputGraph.overallOrder();
-                        const sortedNewProps = sort((a, b) =>
-                            depOrder.indexOf(a.id) - depOrder.indexOf(b.id),
-                            newProps
-                        )
-                        if (!dontUpdateInputObservers) {
-                            sortedNewProps.forEach(function(propUpdate) {
-                                dispatch(notifyObservers(propUpdate));
-                            });
                         }
-                    }
 
 
-                }
+                    }
 
-            })));
+            })}));
 
         }
 

commit f6e2ac0b0fe6673399da92b5948fe57ff9d0016e
Author: alexcjohnson <alex@plot.ly>
Date:   Wed Jan 9 21:20:30 2019 -0500

    remove events from src
    There were some (mostly skipped) tests of events, and rather than
    removing them, I adapted them to the corresponding event properties.
    This had the nice effects of 1) showing that the event behavior
    that was listed as broken is not broken as properties, and
    2) pointing out the need to skip the first call (using PreventUpdate)
    if we want an exact match to the old event behavior.

diff --git a/src/actions/index.js b/src/actions/index.js
index ab868e12..24e829a7 100644
--- a/src/actions/index.js
+++ b/src/actions/index.js
@@ -181,43 +181,38 @@ function reduceInputIds(nodeIds, InputGraph) {
 
 export function notifyObservers(payload) {
     return function(dispatch, getState) {
-        const {id, event, props, excludedOutputs} = payload;
+        const {id, props, excludedOutputs} = payload;
 
         const {graphs, requestQueue} = getState();
-        const {EventGraph, InputGraph} = graphs;
+        const {InputGraph} = graphs;
         /*
-         * Figure out all of the output id's that depend on this
-         * event or input.
+         * Figure out all of the output id's that depend on this input.
          * This includes id's that are direct children as well as
          * grandchildren.
          * grandchildren will get filtered out in a later stage.
          */
-        let outputObservers;
-        if (event) {
-            outputObservers = EventGraph.dependenciesOf(`${id}.${event}`);
-        } else {
-            const changedProps = keys(props);
-            outputObservers = [];
-            changedProps.forEach(propName => {
-                const node = `${id}.${propName}`;
-                if (!InputGraph.hasNode(node)) {
-                    return;
+        let outputObservers = [];
+
+        const changedProps = keys(props);
+        changedProps.forEach(propName => {
+            const node = `${id}.${propName}`;
+            if (!InputGraph.hasNode(node)) {
+                return;
+            }
+            InputGraph.dependenciesOf(node).forEach(outputId => {
+                /*
+                 * Multiple input properties that update the same
+                 * output can change at once.
+                 * For example, `n_clicks` and `n_clicks_previous`
+                 * on a button component.
+                 * We only need to update the output once for this
+                 * update, so keep outputObservers unique.
+                 */
+                if (!contains(outputId, outputObservers)) {
+                    outputObservers.push(outputId);
                 }
-                InputGraph.dependenciesOf(node).forEach(outputId => {
-                    /*
-                     * Multiple input properties that update the same
-                     * output can change at once.
-                     * For example, `n_clicks` and `n_clicks_previous`
-                     * on a button component.
-                     * We only need to update the output once for this
-                     * update, so keep outputObservers unique.
-                     */
-                    if (!contains(outputId, outputObservers)) {
-                        outputObservers.push(outputId);
-                    }
-                });
             });
-        }
+        });
 
         if (excludedOutputs) {
             outputObservers = reject(
@@ -263,13 +258,7 @@ export function notifyObservers(payload) {
              * this loop hits C because of the overallOrder sorting logic
              */
 
-            /*
-              * if the output just listens to events, then it won't be in
-              * the InputGraph
-              */
-            const controllers = InputGraph.hasNode(outputIdAndProp)
-                ? InputGraph.dependantsOf(outputIdAndProp)
-                : [];
+            const controllers = InputGraph.dependantsOf(outputIdAndProp);
 
             const controllersInFutureQueue = intersection(
                 queuedObservers,
@@ -349,7 +338,6 @@ export function notifyObservers(payload) {
                 updateOutput(
                     outputComponentId,
                     outputProp,
-                    event,
                     getState,
                     requestUid,
                     dispatch
@@ -366,7 +354,6 @@ export function notifyObservers(payload) {
 function updateOutput(
     outputComponentId,
     outputProp,
-    event,
     getState,
     requestUid,
     dispatch
@@ -375,62 +362,50 @@ function updateOutput(
     const {InputGraph} = graphs;
 
     /*
-     * Construct a payload of the input, state, and event.
+     * Construct a payload of the input and state.
      * For example:
-     * If the input triggered this update, then:
      * {
      *      inputs: [{'id': 'input1', 'property': 'new value'}],
      *      state: [{'id': 'state1', 'property': 'existing value'}]
      * }
-     *
-     * If an event triggered this udpate, then:
-     * {
-     *      state: [{'id': 'state1', 'property': 'existing value'}],
-     *      event: {'id': 'graph', 'event': 'click'}
-     * }
-     *
      */
     const payload = {
         output: {id: outputComponentId, property: outputProp},
     };
 
-    if (event) {
-        payload.event = event;
-    }
-
     const {inputs, state} = dependenciesRequest.content.find(
         dependency =>
             dependency.output.id === outputComponentId &&
             dependency.output.property === outputProp
     );
     const validKeys = keys(paths);
-    if (inputs.length > 0) {
-        payload.inputs = inputs.map(inputObject => {
-            // Make sure the component id exists in the layout
-            if (!contains(inputObject.id, validKeys)) {
-                throw new ReferenceError(
-                    'An invalid input object was used in an ' +
-                        '`Input` of a Dash callback. ' +
-                        'The id of this object is `' +
-                        inputObject.id +
-                        '` and the property is `' +
-                        inputObject.property +
-                        '`. The list of ids in the current layout is ' +
-                        '`[' +
-                        validKeys.join(', ') +
-                        ']`'
-                );
-            }
-            const propLens = lensPath(
-                concat(paths[inputObject.id], ['props', inputObject.property])
+
+    payload.inputs = inputs.map(inputObject => {
+        // Make sure the component id exists in the layout
+        if (!contains(inputObject.id, validKeys)) {
+            throw new ReferenceError(
+                'An invalid input object was used in an ' +
+                    '`Input` of a Dash callback. ' +
+                    'The id of this object is `' +
+                    inputObject.id +
+                    '` and the property is `' +
+                    inputObject.property +
+                    '`. The list of ids in the current layout is ' +
+                    '`[' +
+                    validKeys.join(', ') +
+                    ']`'
             );
-            return {
-                id: inputObject.id,
-                property: inputObject.property,
-                value: view(propLens, layout),
-            };
-        });
-    }
+        }
+        const propLens = lensPath(
+            concat(paths[inputObject.id], ['props', inputObject.property])
+        );
+        return {
+            id: inputObject.id,
+            property: inputObject.property,
+            value: view(propLens, layout),
+        };
+    });
+
     if (state.length > 0) {
         payload.state = state.map(stateObject => {
             // Make sure the component id exists in the layout
diff --git a/src/components/core/NotifyObservers.react.js b/src/components/core/NotifyObservers.react.js
index b72dc959..8eaa9c09 100644
--- a/src/components/core/NotifyObservers.react.js
+++ b/src/components/core/NotifyObservers.react.js
@@ -28,11 +28,6 @@ function mergeProps(stateProps, dispatchProps, ownProps) {
         dependencies: stateProps.dependencies,
         paths: stateProps.paths,
 
-        fireEvent: function fireEvent({event}) {
-            // Update this component's observers with the updated props
-            dispatch(notifyObservers({event, id: ownProps.id}));
-        },
-
         setProps: function setProps(newProps) {
             const payload = {
                 props: newProps,
@@ -56,14 +51,8 @@ function NotifyObserversComponent({
 
     dependencies,
 
-    fireEvent,
     setProps,
 }) {
-    const thisComponentTriggersEvents =
-        dependencies &&
-        dependencies.find(dependency =>
-            dependency.events.find(event => event.id === id)
-        );
     const thisComponentSharesState =
         dependencies &&
         dependencies.find(
@@ -72,19 +61,17 @@ function NotifyObserversComponent({
                 dependency.state.find(state => state.id === id)
         );
     /*
-     * Only pass in `setProps` and `fireEvent` if they are actually
-     * necessary.
-     * This allows component authors to skip computing data
-     * for `setProps` or `fireEvent` (which can be expensive)
-     * in the case when they aren't actually used.
+     * Only pass in `setProps` if necessary.
+     * This allows component authors to skip computing unneeded data
+     * for `setProps`, which can be expensive.
      * For example, consider `hoverData` for graphs. If it isn't
      * actually used, then the component author can skip binding
      * the events for the component.
      *
-     * TODO - A nice enhancement would be to pass in the actual events
-     * and properties that are used into the component so that the
-     * component author can check for something like `subscribed_events`
-     * or `subscribed_properties` instead of `fireEvent` and `setProps`.
+     * TODO - A nice enhancement would be to pass in the actual
+     * properties that are used into the component so that the
+     * component author can check for something like
+     * `subscribed_properties` instead of just `setProps`.
      */
     const extraProps = {};
     if (
@@ -98,9 +85,6 @@ function NotifyObserversComponent({
     ) {
         extraProps.setProps = setProps;
     }
-    if (thisComponentTriggersEvents && paths[id]) {
-        extraProps.fireEvent = fireEvent;
-    }
 
     if (!isEmpty(extraProps)) {
         return React.cloneElement(children, extraProps);
diff --git a/src/reducers/dependencyGraph.js b/src/reducers/dependencyGraph.js
index 69049bb6..bb63430f 100644
--- a/src/reducers/dependencyGraph.js
+++ b/src/reducers/dependencyGraph.js
@@ -7,10 +7,9 @@ const graphs = (state = initialGraph, action) => {
         case 'COMPUTE_GRAPHS': {
             const dependencies = action.payload;
             const inputGraph = new DepGraph();
-            const eventGraph = new DepGraph();
 
             dependencies.forEach(function registerDependency(dependency) {
-                const {output, inputs, events} = dependency;
+                const {output, inputs} = dependency;
                 const outputId = `${output.id}.${output.property}`;
                 inputs.forEach(inputObject => {
                     const inputId = `${inputObject.id}.${inputObject.property}`;
@@ -18,15 +17,9 @@ const graphs = (state = initialGraph, action) => {
                     inputGraph.addNode(inputId);
                     inputGraph.addDependency(inputId, outputId);
                 });
-                events.forEach(eventObject => {
-                    const eventId = `${eventObject.id}.${eventObject.event}`;
-                    eventGraph.addNode(outputId);
-                    eventGraph.addNode(eventId);
-                    eventGraph.addDependency(eventId, outputId);
-                });
             });
 
-            return {InputGraph: inputGraph, EventGraph: eventGraph};
+            return {InputGraph: inputGraph};
         }
 
         default:
diff --git a/tests/test_render.py b/tests/test_render.py
index 17dc4aea..6c2c8c18 100644
--- a/tests/test_render.py
+++ b/tests/test_render.py
@@ -2,7 +2,8 @@ import os
 import textwrap
 
 from dash import Dash
-from dash.dependencies import Input, Output, State, Event
+from dash.dependencies import Input, Output, State
+from dash.exceptions import PreventUpdate
 import dash
 from dash.development.base_component import Component
 import dash_html_components as html
@@ -14,7 +15,6 @@ import time
 import re
 import itertools
 import json
-import unittest
 
 
 class Tests(IntegrationTests):
@@ -374,11 +374,6 @@ class Tests(IntegrationTests):
                 "nodes": {},
                 "outgoingEdges": {},
                 "incomingEdges": {}
-              },
-              "EventGraph": {
-                "nodes": {},
-                "outgoingEdges": {},
-                "incomingEdges": {}
               }
             }
         )
@@ -972,8 +967,7 @@ class Tests(IntegrationTests):
 
         assert_clean_console(self)
 
-    @unittest.skip("button events are temporarily broken")
-    def test_events(self):
+    def test_event_properties(self):
         app = Dash(__name__)
         app.layout = html.Div([
             html.Button('Click Me', id='button'),
@@ -983,8 +977,10 @@ class Tests(IntegrationTests):
         call_count = Value('i', 0)
 
         @app.callback(Output('output', 'children'),
-                      events=[Event('button', 'click')])
-        def update_output():
+                      [Input('button', 'n_clicks')])
+        def update_output(n_clicks):
+            if(not n_clicks):
+                raise PreventUpdate
             call_count.value += 1
             return 'Click'
 
@@ -998,8 +994,7 @@ class Tests(IntegrationTests):
         wait_for(lambda: output().text == 'Click')
         self.assertEqual(call_count.value, 1)
 
-    @unittest.skip("button events are temporarily broken")
-    def test_events_and_state(self):
+    def test_event_properties_and_state(self):
         app = Dash(__name__)
         app.layout = html.Div([
             html.Button('Click Me', id='button'),
@@ -1010,9 +1005,11 @@ class Tests(IntegrationTests):
         call_count = Value('i', 0)
 
         @app.callback(Output('output', 'children'),
-                      state=[State('state', 'value')],
-                      events=[Event('button', 'click')])
-        def update_output(value):
+                      [Input('button', 'n_clicks')],
+                      [State('state', 'value')])
+        def update_output(n_clicks, value):
+            if(not n_clicks):
+                raise PreventUpdate
             call_count.value += 1
             return value
 
@@ -1038,8 +1035,7 @@ class Tests(IntegrationTests):
         wait_for(lambda: output().text == 'Initial Statex')
         self.assertEqual(call_count.value, 2)
 
-    @unittest.skip("button events are temporarily broken")
-    def test_events_state_and_inputs(self):
+    def test_event_properties_state_and_inputs(self):
         app = Dash(__name__)
         app.layout = html.Div([
             html.Button('Click Me', id='button'),
@@ -1051,10 +1047,9 @@ class Tests(IntegrationTests):
         call_count = Value('i', 0)
 
         @app.callback(Output('output', 'children'),
-                      inputs=[Input('input', 'value')],
-                      state=[State('state', 'value')],
-                      events=[Event('button', 'click')])
-        def update_output(input, state):
+                      [Input('input', 'value'), Input('button', 'n_clicks')],
+                      [State('state', 'value')])
+        def update_output(input, n_clicks, state):
             call_count.value += 1
             return 'input="{}", state="{}"'.format(input, state)
 
@@ -1144,7 +1139,7 @@ class Tests(IntegrationTests):
             output().text,
             'input="Initial Inputxy", state="Initial Statex"')
 
-    def test_event_creating_inputs(self):
+    def test_event_properties_creating_inputs(self):
         app = Dash(__name__)
 
         ids = {
@@ -1166,8 +1161,10 @@ class Tests(IntegrationTests):
 
         @app.callback(
             Output(ids['button-output'], 'children'),
-            events=[Event(ids['button'], 'click')])
-        def display():
+            [Input(ids['button'], 'n_clicks')])
+        def display(n_clicks):
+            if(not n_clicks):
+                raise PreventUpdate
             call_counts['button-output'].value += 1
             return html.Div([
                 dcc.Input(id=ids['input'], value='initial state'),
@@ -1353,8 +1350,8 @@ class Tests(IntegrationTests):
 
         @app.callback(
             Output('button-output', 'children'),
-            events=[Event('button', 'click')])
-        def this_callback_takes_forever():
+            [Input('button', 'n_clicks')])
+        def this_callback_takes_forever(n_clicks):
             time.sleep(5)
             call_counts['button-output'].value += 1
             return 'New value!'
@@ -2020,4 +2017,3 @@ class Tests(IntegrationTests):
         finally:
             with open(hot_reload_file, 'w') as f:
                 f.write(old_content)
-

commit e3e8cfb996e3878f471a8832bbd6d7d3952a9d93
Author: chriddyp <chris@plot.ly>
Date:   Thu Mar 23 21:25:35 2017 -0400

    refactor api, dependencies, and initialization routine

diff --git a/dash_renderer/version.py b/dash_renderer/version.py
index cd9b1375..0404d810 100644
--- a/dash_renderer/version.py
+++ b/dash_renderer/version.py
@@ -1 +1 @@
-__version__ = '0.2.9'
+__version__ = '0.3.0'
diff --git a/simple.py b/simple.py
new file mode 100644
index 00000000..21a63154
--- /dev/null
+++ b/simple.py
@@ -0,0 +1,23 @@
+from dash import Dash
+import dash
+import dash_html_components as html
+import dash_core_components as dcc
+
+app = Dash(__name__)
+app.scripts.config.serve_locally=True
+app.layout = html.Div([
+    dcc.Input(id='my-input', value='initial-input'),
+    html.Div(id='my-output')
+])
+
+
+@app.callback(
+    dash.dependencies.Output('my-output', 'content'),
+    [dash.dependencies.Input('my-input', 'value')]
+)
+def update(value):
+    return 'Output: {}'.format(value)
+
+
+if __name__ == '__main__':
+    app.run_server(debug=True)
diff --git a/src/AppContainer.react.js b/src/AppContainer.react.js
index d10e153c..2f71c751 100644
--- a/src/AppContainer.react.js
+++ b/src/AppContainer.react.js
@@ -4,11 +4,8 @@ import {Provider} from 'react-redux'
 import initializeStore from './store';
 import TreeContainer from './TreeContainer.react';
 import Loading from './components/core/Loading.react';
-import { initialize } from './actions';
 
 const store = initializeStore();
-// Initialization
-store.dispatch(initialize());
 
 const AppContainer = () => (
     <Provider store={store}>
diff --git a/src/TreeContainer.react.js b/src/TreeContainer.react.js
index 282d7783..914db1ba 100644
--- a/src/TreeContainer.react.js
+++ b/src/TreeContainer.react.js
@@ -1,31 +1,111 @@
 import { connect } from 'react-redux'
-import { isEmpty } from 'ramda'
-import React, {PropTypes} from 'react';
+import { contains, isEmpty, isNil } from 'ramda'
+import React, {Component, PropTypes} from 'react';
 import renderTree from './renderTree';
+import {
+    hydrateInitialOutputs,
+    computeGraphs,
+    computePaths,
+    setLayout
+} from './actions/index';
+import {getLayout, getDependencies} from './actions/api';
+import {APP_STATES} from './reducers/appLifecycle';
 
+/**
+ * Fire off API calls for initialization
+ */
+class UnconnectedContainer extends Component {
+    componentDidMount() {
+        this.initialization(this.props);
+    }
 
-const UnconnectedContainer = props => {
-    // TODO: Request status? Loading, error, ...
-    if (isEmpty(props.layout)) {
-        return (<div>loading...</div>);
+    componentWillReceiveProps(props) {
+        this.initialization(props);
+    }
+
+    initialization(props) {
+        const {
+            appLifecycle,
+            dependenciesRequest,
+            dispatch,
+            graphs,
+            layout,
+            layoutRequest,
+            paths
+        } = props;
+        if (isEmpty(layoutRequest)) {
+            dispatch(getLayout());
+        } else if (layoutRequest.status === 200) {
+            if (isEmpty(layout)) {
+                dispatch(setLayout(layoutRequest.content));
+            } else if (isNil(paths)) {
+                dispatch(computePaths({subTree: layout, startingPath: []}));
+            }
+        }
+
+        if (isEmpty(dependenciesRequest)) {
+            console.warn(
+                `GET dependencies: ${JSON.stringify(dependenciesRequest)}`
+            );
+            dispatch(getDependencies());
+        } else if (dependenciesRequest.status === 200) {
+            if (isEmpty(graphs)) {
+                dispatch(computeGraphs(dependenciesRequest.content));
+            } else if (appLifecycle === APP_STATES('STARTED')) {
+                dispatch(hydrateInitialOutputs());
+            }
+        }
     }
-    return renderTree(
-        props.layout,
-        props.dependencyGraph
-    );
-}
 
+    render () {
+        const {
+            appLifecycle,
+            dependenciesRequest,
+            layoutRequest,
+            layout
+        } = this.props;
+        if (layoutRequest.status &&
+            !contains(layoutRequest.status, [200, 'loading'])
+        ) {
+            return (<div>{'Error loading layout'}</div>);
+        } else if (
+            dependenciesRequest.status &&
+            !contains(dependenciesRequest.status, [200, 'loading'])
+        ) {
+            return (<div>{'Error loading dependencies'}</div>);
+        } else if (appLifecycle === APP_STATES('INITIALIZED')) {
+            return renderTree(
+                layout,
+                dependenciesRequest.content
+            );
+        } else {
+            return (<div>{'Loading...'}</div>);
+        }
+    }
+}
 UnconnectedContainer.propTypes = {
+    appLifecycle: PropTypes.oneOf([
+        APP_STATES('STARTED'),
+        APP_STATES('INITIALIZED')
+    ]),
+    dispatch: PropTypes.function,
+    dependenciesRequest: PropTypes.object,
+    layoutRequest: PropTypes.object,
     layout: PropTypes.object,
-    dependencyGraph: PropTypes.object
-};
+    paths: PropTypes.object
+}
 
 const Container = connect(
     // map state to props
     state => ({
+        appLifecycle: state.appLifecycle,
+        layoutRequest: state.layoutRequest,
+        dependenciesRequest: state.dependenciesRequest,
         layout: state.layout,
+        graphs: state.graphs,
         paths: state.paths
-    })
+    }),
+    dispatch => ({dispatch})
 )(UnconnectedContainer);
 
 export default Container;
diff --git a/src/actions/api.js b/src/actions/api.js
new file mode 100644
index 00000000..2dcad1ca
--- /dev/null
+++ b/src/actions/api.js
@@ -0,0 +1,77 @@
+/* global fetch: true */
+
+const request = {GET, POST};
+
+function GET(path) {
+    return fetch(`${path}`, {
+        method: 'GET',
+        credentials: 'include',
+        headers: {
+            'Accept': 'application/json',
+            'Content-Type': 'application/json'
+        }
+    });
+}
+
+function POST(path, body = {}) {
+    return fetch(`${path}`, {
+        method: 'POST',
+        credentials: 'include',
+        headers: {
+            'Accept': 'application/json',
+            'Content-Type': 'application/json'
+        },
+        body: body ? JSON.stringify(body) : null
+    });
+}
+
+function apiThunk(endpoint, method, store, id, body) {
+    return dispatch => {
+        dispatch({
+            type: store,
+            payload: {id, status: 'loading'}
+        });
+        return request[method](endpoint, body)
+        .then(res => res.json().then(
+            json => {
+                dispatch({
+                    type: store,
+                    payload: {
+                        status: res.status,
+                        content: json,
+                        id
+                    }
+                });
+                return json;
+            }
+        ))
+        .catch(err => {
+            /* eslint-disable no-console */
+            console.error(err);
+            /* eslint-enable no-console */
+            dispatch({
+                type: store,
+                payload: {
+                    id,
+                    status: 500
+                }
+            });
+        });
+    };
+}
+
+export function getLayout() {
+    return apiThunk(
+        '/layout',
+        'GET',
+        'layoutRequest'
+    )
+}
+
+export function getDependencies() {
+    return apiThunk(
+        '/dependencies',
+        'GET',
+        'dependenciesRequest'
+    )
+}
diff --git a/src/actions/index.js b/src/actions/index.js
index 3f521ef0..87c6c4ba 100644
--- a/src/actions/index.js
+++ b/src/actions/index.js
@@ -1,16 +1,12 @@
+/* global fetch:true */
 import {
     concat,
     contains,
     has,
     intersection,
     isEmpty,
-    isNil,
-    filter,
     keys,
     lensPath,
-    merge,
-    omit,
-    pick,
     reject,
     sort,
     type,
@@ -24,9 +20,10 @@ export const ACTIONS = (action) => {
     const actionList = {
         ON_PROP_CHANGE: 'ON_PROP_CHANGE',
         SET_REQUEST_QUEUE: 'SET_REQUEST_QUEUE',
-        SET_LAYOUT: 'SET_LAYOUT',
         COMPUTE_GRAPHS: 'COMPUTE_GRAPHS',
-        COMPUTE_PATHS: 'COMPUTE_PATHS'
+        COMPUTE_PATHS: 'COMPUTE_PATHS',
+        SET_LAYOUT: 'SET_LAYOUT',
+        SET_APP_LIFECYCLE: 'SET_APP_LIFECYCLE'
     };
     if (actionList[action]) return actionList[action];
     else throw new Error(`${action} is not defined.`)
@@ -34,116 +31,129 @@ export const ACTIONS = (action) => {
 
 export const updateProps = createAction(ACTIONS('ON_PROP_CHANGE'));
 export const setRequestQueue = createAction(ACTIONS('SET_REQUEST_QUEUE'));
-const setLayout = createAction(ACTIONS('SET_LAYOUT'));
-const computeGraphs = createAction(ACTIONS('COMPUTE_GRAPHS'));
-const computePaths = createAction(ACTIONS('COMPUTE_PATHS'));
+export const computeGraphs = createAction(ACTIONS('COMPUTE_GRAPHS'));
+export const computePaths = createAction(ACTIONS('COMPUTE_PATHS'));
+export const setLayout = createAction(ACTIONS('SET_LAYOUT'));
+export const setAppLifecycle = createAction(ACTIONS('SET_APP_LIFECYCLE'));
 
-export const initialize = function() {
+export const hydrateInitialOutputs = function() {
     return function (dispatch, getState) {
-        // TODO - Use whatwg-fetch
-        fetch('/initialize', {method: 'GET'}) /* global fetch: true */
-        .then(res => res.json().then(layout => {
-            // TODO: error handling
-            dispatch(setLayout(layout));
-            dispatch(computePaths({subTree: layout, startingPath: []}));
-        })).then(function() {
-            fetch('/dependencies', {method: 'GET'})
-            .then(res => res.json().then(dependencies => {
-                dispatch(computeGraphs(dependencies));
-                /*
-                 * Fire an initial propChange event for each of the controllers
-                 * so that the observer leaves can update
-                 */
-                // TODO - Use thunk instead of setTimeout
-                setTimeout(function(){
-                    const {graphs} = getState();
-                    const {EventGraph} = graphs;
-                    EventGraph.overallOrder().forEach(nodeId => {
-                        // Only fire updates for the visible controllers
-                        if (has(nodeId, getState().paths)) {
-                            dispatch(notifyObservers({
-                                event: 'propChange', id: nodeId
-                            }));
-                        }
+        const {graphs} = getState();
+        const {InputGraph} = graphs;
+        InputGraph.overallOrder().forEach(nodeId => {
+            const [componentId, componentProp] = nodeId.split('.');
 
-                    });
-                }, 50)
-            }));
+            // Filter out the outputs and the invisible inputs
+            if (InputGraph.dependenciesOf(nodeId).length > 0 &&
+                has(componentId, getState().paths)
+            ) {
+
+                // Get the initial property
+                const propLens = lensPath(
+                    concat(getState().paths[componentId],
+                    ['props', componentProp]
+                ));
+                const propValue = view(
+                    propLens,
+                    getState().layout
+                );
+
+                dispatch(notifyObservers({
+                    id: componentId,
+                    props: {[componentProp]: propValue}
+                }));
+
+            }
         });
+        dispatch(setAppLifecycle('INITIALIZED'));
     }
 }
 
-/*
- * TODO: Consider moving side effects to reducers via
- * https://github.com/gregwebs/redux-side-effect
- */
 export const notifyObservers = function(payload) {
     return function (dispatch, getState) {
         const {
+            id,
             event,
-            id
+            props
         } = payload
 
         const {
             layout,
             graphs,
             paths,
-            requestQueue
+            requestQueue,
+            dependenciesRequest
         } = getState();
-        const {EventGraph, StateGraph} = graphs;
+        const {EventGraph, InputGraph} = graphs;
 
         /*
-         * Each observer may depend on a different set of events.
-         * Filter away the observers that are listening to different events.
+         * Figure out all of the output id's that depend on this
+         * event or input.
+         * This includes id's that are direct children as well as
+         * grandchildren.
+         * grandchildren will get filtered out in a later stage.
          */
-        const observersAndEventSubscriptions = EventGraph.getNodeData(id);
-        let eventObservers = keys(filter(function filterObservers(observerEventSubscriptions) {
-            return contains(event, observerEventSubscriptions);
-        }, observersAndEventSubscriptions));
+        let outputObservers;
+        if (event) {
+            outputObservers = EventGraph.dependenciesOf(`${id}.${event}`);
+        } else {
+            const changedProps = keys(props);
+            outputObservers = [];
+            changedProps.forEach(propName => {
+                InputGraph.dependenciesOf(`${id}.${propName}`).forEach(outputId =>
+                    outputObservers.push(outputId)
+                );
+            });
+        }
 
-        /*
-         * If no components have subscribed to these events,
-         * then we have no one else to tell about it.
-         */
-        if (isEmpty(eventObservers)) {
+        if (isEmpty(outputObservers)) {
             return;
         }
 
         /*
-         * There may be several components that depend on this event.
+         * There may be several components that depend on this input.
          * And some components may depend on other components before
          * updating. Get this update order straightened out.
          */
-        const depOrder = EventGraph.overallOrder();
-        eventObservers = sort(
+        const depOrder = InputGraph.overallOrder();
+        outputObservers = sort(
             (a, b) => depOrder.indexOf(a) - depOrder.indexOf(b),
-            eventObservers
+            outputObservers
         );
 
-        // record the set of requests in the queue
-        dispatch(setRequestQueue(union(eventObservers, requestQueue)));
+        /*
+         * record the set of output IDs that will eventually need to be
+         * updated in a queue. not all of these requests will be fired in this
+         * action
+         */
+        dispatch(setRequestQueue(union(outputObservers, requestQueue)));
 
-        // update each observer
-        for (let i = 0; i < eventObservers.length; i++) {
-            const eventObserverId = eventObservers[i];
+        // update each output observer through an API call
+        for (let i = 0; i < outputObservers.length; i++) {
+            const outputIdAndProp = outputObservers[i];
+            const [outputComponentId, outputProp] = outputIdAndProp.split('.');
 
             /*
-             * before we make the POST, check that none of its event dependencies
-             * are already in the queue. if they are in the queue, then don't update.
-             * when each dependency updates, it'll dispatch its own `notifyObservers`
-             * action which will allow this component to update.
+             * before we make the POST, check that none of its input
+             * dependencies are already in the queue.
+             * if they are in the queue, then don't update.
+             * when each dependency updates, it'll dispatch its own
+             * `notifyObservers` action which will allow this
+             * component to update.
              *
              * for example, if A updates B and C (A -> [B, C]) and B updates C
-             * (B -> C), then when A updates, we can update B but not C until
-             * B is done updating. in this scenario, B is before C from the
+             * (B -> C), then when A updates, the requestQueue becomes
+             * [B, C] we can't update C until B is done updating.
+             * in this scenario, B is before C from the
              * overallOrder, so it'll get set in the requestQueue before C.
+             *
              */
             const dependenciesInQueue = intersection(
                 getState().requestQueue,
-                EventGraph.dependenciesOf(eventObserverId)
+                InputGraph.dependenciesOf(outputIdAndProp)
             );
 
-            if (dependenciesInQueue.length !== 0) {
+            if (dependenciesInQueue.length > 0) {
                 continue;
             }
 
@@ -154,53 +164,76 @@ export const notifyObservers = function(payload) {
              * of a controller change.
              * for example, perhaps the user has hidden one of the observers
              */
-            if (!has(eventObserverId, getState().paths)) {
+            if (!has(outputComponentId, getState().paths)) {
                 continue;
             }
 
             /*
-             * Construct a payload of the subscribed state
-             * For example, if graph depends on `input1` value and style
-             * and `input2` value, the payload would look like:
-             * {input1: {value: ..., style: ...,}, input2: ...}
+             * Construct a payload of the input, state, and event.
+             * For example:
+             * If the input triggered this update, then:
+             * {
+             *      inputs: [{'id': 'input1', 'property': 'new value'}],
+             *      state: [{'id': 'state1', 'property': 'existing value'}]
+             * }
+             *
+             * If an event triggered this udpate, then:
+             * {
+             *      state: [{'id': 'state1', 'property': 'existing value'}],
+             *      event: {'id': 'graph', 'event': 'click'}
+             * }
+             *
              */
-            let state = {};
-            StateGraph.dependenciesOf(eventObserverId).forEach(function reduceState(controllerId) {
-                const observedProps = StateGraph.getNodeData(controllerId)[eventObserverId];
-                /*
-                 * StateGraph.dependenciesOf doesn't just return neighbors,
-                 * it also returns grandparents and other non-direct-neighbor
-                 * nodes. Dang!
-                 * If a controller doesn't have this eventObserverId in it's
-                 * node data, then it's not an immediate dependency.
-                 */
-                if (isEmpty(observedProps) || isNil(observedProps)) {
-                    return;
-                }
-                state[controllerId] = {};
+             const payload = {
+                 output: {id: outputComponentId, property: outputProp}
+             };
 
-                const propLens = lensPath(concat(paths[controllerId], ['props']));
-                const props = view(propLens, layout);
-                // TODO - Is * and omit the right pattern?
-                if (observedProps[0] === '*') {
-                    state[controllerId] = omit(['content'], props);
-                } else {
-                    state[controllerId] = pick(observedProps, props);
-                }
-            });
+             if (event) {
+                 payload.event = event;
+             }
 
-            const body = {id: eventObserverId, state};
+            const {inputs, state} = dependenciesRequest.content.find(
+                dependency => (
+                    dependency.output.id === outputComponentId &&
+                    dependency.output.property === outputProp
+                )
+            )
+            if (inputs.length > 0) {
+                payload.inputs = inputs.map(inputObject => {
+                    const propLens = lensPath(
+                        concat(paths[inputObject.id],
+                        ['props', inputObject.property]
+                    ));
+                    return {
+                        id: inputObject.id,
+                        property: inputObject.property,
+                        value: view(propLens, layout)
+                    };
+                });
+            }
+            if (state.length > 0) {
+                payload.state = state.map(stateObject => {
+                    const propLens = lensPath(
+                        concat(paths[stateObject.id],
+                        ['props', stateObject.property]
+                    ));
+                    return {
+                        id: stateObject.id,
+                        property: stateObject.property,
+                        value: view(propLens, layout)
+                    };
+                });
+            }
 
-            // make the /POST
-            fetch('/interceptor', {
+            fetch('/update-component', {
                 method: 'POST',
                 headers: {'Content-Type': 'application/json'},
-                body: JSON.stringify(body)
+                body: JSON.stringify(payload)
             }).then(response => response.json().then(function handleResponse(data) {
                 // clear this item from the request queue
                 dispatch(setRequestQueue(
                     reject(
-                        id => id === eventObserverId,
+                        id => id === outputComponentId,
                         // in an async loop so grab the state again
                         getState().requestQueue
                     )
@@ -208,16 +241,16 @@ export const notifyObservers = function(payload) {
 
                 // and update the props of the component
                 const observerUpdatePayload = {
-                    itempath: paths[eventObserverId],
-                    // new props from the server
-                    props: merge(data.response.props, {content: data.response.children})
+                    itempath: paths[outputComponentId],
+                    // new prop from the server
+                    props: data.response.props
                 };
                 dispatch(updateProps(observerUpdatePayload));
 
-
-                // fire an event that the props have changed
-                // TODO - Need to wait for updateProps to finish?
-                dispatch(notifyObservers({event: 'propChange', id: eventObserverId}));
+                dispatch(notifyObservers({
+                    id: outputComponentId,
+                    props: data.response.props
+                }));
 
                 /*
                  * If the response includes content which includes or
@@ -228,12 +261,13 @@ export const notifyObservers = function(payload) {
                 if (contains(
                         type(observerUpdatePayload.props.content),
                         ['Array', 'Object']
-                    ) && !isEmpty(observerUpdatePayload.props.content)) {
+                    ) && !isEmpty(observerUpdatePayload.props.content)
+                ) {
 
                     dispatch(computePaths({
                         subTree: observerUpdatePayload.props.content,
                         startingPath: concat(
-                            getState().paths[eventObserverId],
+                            getState().paths[outputComponentId],
                             ['props', 'content']
                         )
                     }));
@@ -248,33 +282,37 @@ export const notifyObservers = function(payload) {
                      * We don't need to do this - just need
                      * to compute the subtree
                      */
-                    const newIds = [];
+                    const newProps = [];
                     crawlLayout(
                         observerUpdatePayload.props.content,
                         function appendIds(child) {
-                            if (hasId(child) &&
-                                /*
-                                 * Not all nodes that have IDs
-                                 * are necessarily bound to events
-                                 * TODO - Are we making that assumption anywhere else?
-                                 */
-                                has(child.props.id, EventGraph.nodes)
-                            ) {
-                                newIds.push(child.props.id);
+                            if (hasId(child)) {
+                                keys(child.props).forEach(childProp => {
+                                    const inputId = (
+                                        `${child.props.id}.${childProp}`
+                                    );
+                                    if (has(inputId, InputGraph.nodes)) {
+                                        newProps.push({
+                                            id: child.props.id,
+                                            props: {
+                                                [childProp]: child.props[childProp]
+                                            }
+                                        });
+                                    }
+                                })
                             }
                         }
                     );
 
                     // TODO - We might need to reset the
                     // request queue here.
-                    const depOrder = EventGraph.overallOrder();
-                    const sortedIds = sort((a, b) => depOrder.indexOf(a) - depOrder.indexOf(b),
-                        newIds
+                    const depOrder = InputGraph.overallOrder();
+                    const sortedNewProps = sort((a, b) =>
+                        depOrder.indexOf(a.id) - depOrder.indexOf(b.id),
+                        newProps
                     )
-                    sortedIds.forEach(function(newId) {
-                        dispatch(notifyObservers({
-                            event: 'propChange', id: newId
-                        }));
+                    sortedNewProps.forEach(function(propUpdate) {
+                        dispatch(notifyObservers(propUpdate));
                     });
 
                 }
diff --git a/src/components/core/NotifyObservers.react.js b/src/components/core/NotifyObservers.react.js
index 9ce65131..a86bfb77 100644
--- a/src/components/core/NotifyObservers.react.js
+++ b/src/components/core/NotifyObservers.react.js
@@ -1,5 +1,5 @@
 import {connect} from 'react-redux';
-import {isEmpty} from 'ramda';
+import {isEmpty, keys} from 'ramda';
 import {notifyObservers, updateProps} from '../../actions';
 import React, {PropTypes} from 'react';
 
@@ -9,7 +9,10 @@ import React, {PropTypes} from 'react';
  */
 
 function mapStateToProps (state) {
-    return {graphs: state.graphs, paths: state.paths};
+    return {
+        dependencies: state.dependenciesRequest.content,
+        paths: state.paths
+    };
 }
 
 function mapDispatchToProps (dispatch) {
@@ -22,9 +25,7 @@ function mergeProps(stateProps, dispatchProps, ownProps) {
     return {
         id: ownProps.id,
         children: ownProps.children,
-
-        EventGraph: stateProps.graphs.EventGraph,
-        StateGraph: stateProps.graphs.StateGraph,
+        dependencies: stateProps.dependencies,
 
         fireEvent: function fireEvent({event}) {
             // Update this component's observers with the updated props
@@ -41,10 +42,7 @@ function mergeProps(stateProps, dispatchProps, ownProps) {
             // Update this component's props
             dispatch(updateProps(payload));
 
-            // Fire an event that the props have changed.
-            // TODO - Will updateProps have finished by the time this is fired?
-            // TODO - Add support for subscribing to a particular prop change?
-            dispatch(notifyObservers({event: 'propChange', id: ownProps.id}));
+            dispatch(notifyObservers({id: ownProps.id, props: newProps}));
         }
     }
 
@@ -54,20 +52,37 @@ function NotifyObserversComponent ({
     children,
     id,
 
-    EventGraph,
-    StateGraph,
+    dependencies,
 
     fireEvent,
     setProps
 }) {
-
-    // TODO - Check if it triggers this particular event
     const thisComponentTriggersEvents = (
-        EventGraph.hasNode(id) && EventGraph.dependantsOf(id).length
+        dependencies && dependencies.find(dependency => (
+            dependency.events.find(event => event.id === id)
+        ))
     );
     const thisComponentSharesState = (
-        StateGraph.hasNode(id) && StateGraph.dependantsOf(id).length
+        dependencies && dependencies.find(dependency => (
+            dependency.inputs.find(input => input.id === id) ||
+            dependency.state.find(state => state.id === id)
+        ))
     );
+    /*
+     * Only pass in `setProps` and `fireEvent` if they are actually
+     * necessary.
+     * This allows component authors to skip computing data
+     * for `setProps` or `fireEvent` (which can be expensive)
+     * in the case when they aren't actually used.
+     * For example, consider `hoverData` for graphs. If it isn't
+     * actually used, then the component author can skip binding
+     * the events for the component.
+     *
+     * TODO - A nice enhancement would be to pass in the actual events
+     * and properties that are used into the component so that the
+     * component author can check for something like `subscribed_events`
+     * or `subscribed_properties` instead of `fireEvent` and `setProps`.
+     */
     const extraProps = {};
     if (thisComponentSharesState) {
         extraProps.setProps = setProps;
@@ -75,7 +90,7 @@ function NotifyObserversComponent ({
     if (thisComponentTriggersEvents) {
         extraProps.fireEvent = fireEvent;
     }
-
+    console.warn('extraProps: ', extraProps);
     if (!isEmpty(extraProps)) {
         return React.cloneElement(children, extraProps);
     } else {
diff --git a/src/index.js b/src/index.js
index 75d40fb7..b87a250c 100644
--- a/src/index.js
+++ b/src/index.js
@@ -4,7 +4,6 @@
 
 import React from 'react';
 import ReactDOM from 'react-dom';
-
 import AppContainer from './AppContainer.react';
 
 ReactDOM.render(
diff --git a/src/reducers/api.js b/src/reducers/api.js
new file mode 100644
index 00000000..cbeaf278
--- /dev/null
+++ b/src/reducers/api.js
@@ -0,0 +1,30 @@
+import {assoc, assocPath, merge} from 'ramda';
+
+function createApiReducer(store) {
+    return function ApiReducer(state = {}, action) {
+        let newState = state;
+        if (action.type === store) {
+            const {payload} = action;
+            if (Array.isArray(payload.id)) {
+                newState = assocPath(payload.id, {
+                    status: payload.status,
+                    content: payload.content
+                }, state);
+            } else if (payload.id) {
+                newState = assoc(payload.id, {
+                    status: payload.status,
+                    content: payload.content
+                }, state);
+            } else {
+                newState = merge(
+                    state,
+                    {status: payload.status, content: payload.content}
+                );
+            }
+        }
+        return newState;
+    };
+}
+
+export const layoutRequest = createApiReducer('layoutRequest');
+export const dependenciesRequest = createApiReducer('dependenciesRequest');
diff --git a/src/reducers/appLifecycle.js b/src/reducers/appLifecycle.js
new file mode 100644
index 00000000..df7c10f7
--- /dev/null
+++ b/src/reducers/appLifecycle.js
@@ -0,0 +1,21 @@
+import {ACTIONS} from '../actions/index.js';
+
+export function APP_STATES(state) {
+    const stateList = {
+        'STARTED': 'STARTED',
+        'INITIALIZED': 'INITIALIZED'
+    }
+    if (stateList[state]) return stateList[state];
+    else throw new Error (`${state} is not a valid app state.`);
+}
+
+function appLifecycle(state=APP_STATES('STARTED'), action) {
+    switch (action.type) {
+        case ACTIONS('SET_APP_LIFECYCLE'):
+            return APP_STATES(action.payload);
+        default:
+            return state;
+    }
+}
+
+export default appLifecycle;
diff --git a/src/reducers/dependencyGraph.js b/src/reducers/dependencyGraph.js
index fd9b2469..7da6e6fb 100644
--- a/src/reducers/dependencyGraph.js
+++ b/src/reducers/dependencyGraph.js
@@ -1,75 +1,32 @@
 import {DepGraph} from 'dependency-graph';
-import {append, keys, merge} from 'ramda';
 
-const initialStateGraph = new DepGraph();
-const initialEventGraph = new DepGraph();
-const initialGraph = {
-    StateGraph: initialStateGraph,
-    EventGraph: initialEventGraph
-};
-
-function computeGraph(dependencies, graph, graphType) {
-    return function(observerId) {
-        // Add observers to the graph
-        if(!graph.hasNode(observerId)) {
-            graph.addNode(observerId, {});
-        }
-
-        /*
-         * Add controllers to the graph with their data.
-         * data is either `state` or `event`.
-         * - `state`, which describes which props this controller
-         *            should include
-         * - `event`, which describes which events this controller
-         *            should respond to
-         */
-        dependencies[observerId][graphType].forEach(
-            function addStateNodes(controller) {
-                if(!graph.hasNode(controller.id)) {
-                    graph.addNode(controller.id, {[observerId]: []});
-                }
-                graph.addDependency(observerId, controller.id);
-                /*
-                 * A controller may be observed by several components
-                 * and each component may depend on different props or events
-                 *
-                 * {
-                 *      inputComponentId: {
-                 *          observerComponentId1: ['value', 'style'],
-                 *          observerComponentId2: ['className'],
-                 *      }
-                 * }
-                 */
-                const existingControllerData = graph.getNodeData(controller.id)[observerId]
-                const newControllerData = controller[
-                    graphType === 'state' ? 'prop' : 'event'
-                ];
-                const controllerData = append(
-                    newControllerData,
-                    existingControllerData
-                );
-                const allControllerData = merge(
-                    graph.getNodeData(controller.id),
-                    {[observerId]: controllerData}
-                );
-                graph.setNodeData(controller.id, allControllerData);
-            }
-        );
-    }
-}
+const initialGraph = {};
 
 const graphs = (state = initialGraph, action) => {
     switch (action.type) {
         case 'COMPUTE_GRAPHS': {
             const dependencies = action.payload;
-            const stateGraph = new DepGraph();
+            const inputGraph = new DepGraph();
             const eventGraph = new DepGraph();
 
-            // add ID's to all the components
-            keys(dependencies).forEach(computeGraph(dependencies, stateGraph, 'state'));
-            keys(dependencies).forEach(computeGraph(dependencies, eventGraph, 'events'));
-
-            return {StateGraph: stateGraph, EventGraph: eventGraph};
+            dependencies.forEach(function registerDependency(dependency) {
+                const {output, inputs, events} = dependency;
+                const outputId = `${output.id}.${output.property}`;
+                inputs.forEach(inputObject => {
+                    const inputId = `${inputObject.id}.${inputObject.property}`;
+                    inputGraph.addNode(outputId);
+                    inputGraph.addNode(inputId);
+                    inputGraph.addDependency(inputId, outputId);
+                });
+                events.forEach(eventObject => {
+                    const eventId = `${eventObject.id}.${eventObject.event}`;
+                    eventGraph.addNode(outputId);
+                    eventGraph.addNode(eventId);
+                    eventGraph.addDependency(eventId, outputId);
+                });
+            });
+
+            return {InputGraph: inputGraph, EventGraph: eventGraph};
 
         }
 
diff --git a/src/reducers/paths.js b/src/reducers/paths.js
index 6ac4933a..5c49d4a5 100644
--- a/src/reducers/paths.js
+++ b/src/reducers/paths.js
@@ -1,14 +1,17 @@
 import {crawlLayout, hasId} from './utils'
 import R from 'ramda'
+import {ACTIONS} from '../actions/index.js';
 
-const initialPaths = {};
+const initialPaths = null;
 
 
 const paths = (state = initialPaths, action) => {
     switch (action.type) {
-        case 'COMPUTE_PATHS': {
+        case ACTIONS('COMPUTE_PATHS'): {
             const {subTree, startingPath} = action.payload;
-
+            if (R.isNil(state)) {
+                state = {};
+            }
             let newState;
 
             // if we're updating a subtree, clear out all of the existing items
diff --git a/src/reducers/reducer.js b/src/reducers/reducer.js
index 11740ff7..9171024c 100644
--- a/src/reducers/reducer.js
+++ b/src/reducers/reducer.js
@@ -5,7 +5,17 @@ import layout from './layout';
 import graphs from './dependencyGraph';
 import paths from './paths';
 import requestQueue from './requestQueue';
+import appLifecycle from './appLifecycle';
+import {layoutRequest, dependenciesRequest} from './api';
 
-const reducer = combineReducers({layout, graphs, paths, requestQueue});
+const reducer = combineReducers({
+    appLifecycle,
+    layout,
+    graphs,
+    paths,
+    requestQueue,
+    layoutRequest,
+    dependenciesRequest
+});
 
 export default reducer;
diff --git a/src/renderTree.js b/src/renderTree.js
index 5ca28ab3..2d237b5d 100644
--- a/src/renderTree.js
+++ b/src/renderTree.js
@@ -39,7 +39,6 @@ export default function render(component) {
     }
 
     const element = Registry.resolve(component.type, component.namespace);
-
     const parent = React.createElement(
         element,
         R.omit(['content'], component.props),

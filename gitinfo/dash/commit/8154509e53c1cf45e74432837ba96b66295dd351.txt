commit 8154509e53c1cf45e74432837ba96b66295dd351
Author: Philippe Duval <philippe@plot.ly>
Date:   Tue Nov 27 16:24:38 2018 -0500

    Non breaking multi-output.

diff --git a/src/actions/index.js b/src/actions/index.js
index 15c43258..72bf6dcb 100644
--- a/src/actions/index.js
+++ b/src/actions/index.js
@@ -376,12 +376,24 @@ function updateOutput(
      *      state: [{'id': 'state1', 'property': 'existing value'}]
      * }
      */
+
+    const [outputComponentId, outputProp] = outputIdAndProp.split('.');
     const payload = {
-        output: outputIdAndProp,
+        output: config.multi_output ? outputIdAndProp :
+            {
+                id: outputComponentId,
+                property: outputProp
+            }
     };
 
     const {inputs, state} = dependenciesRequest.content.find(
-        dependency => dependency.output === outputIdAndProp
+        dependency => {
+            if (config.multi_output) {
+                return dependency.output === outputIdAndProp
+            }
+            return dependency.output.id === outputComponentId &&
+                dependency.output.property === outputProp
+        }
     );
     const validKeys = keys(paths);
 
@@ -541,10 +553,13 @@ function updateOutput(
              */
 
             const {paths} = getState();
+            const multi = data.multi;
 
-            Object.entries(data.response).forEach(([outputIdAndProp, props]) => {
+            const handleResponse = ([outputIdAndProp, props]) => {
+                // Backward compatibility
+                const pathKey = multi ? outputIdAndProp : outputComponentId;
                 const observerUpdatePayload = {
-                    itempath: paths[outputIdAndProp],
+                    itempath: paths[pathKey],
                     props,
                     source: 'response'
                 };
@@ -552,7 +567,7 @@ function updateOutput(
 
                 dispatch(
                     notifyObservers({
-                        id: outputIdAndProp,
+                        id: pathKey,
                         props: props,
                     })
                 );
@@ -567,7 +582,7 @@ function updateOutput(
                         computePaths({
                             subTree: observerUpdatePayload.props.children,
                             startingPath: concat(
-                                paths[outputIdAndProp],
+                                paths[pathKey],
                                 ['props', 'children']
                             ),
                         })
@@ -710,7 +725,15 @@ function updateOutput(
                         });
                     }
                 }
-            });
+            };
+            if (multi) {
+                Object.entries(data.response).forEach(handleResponse)
+            } else {
+                handleResponse([
+                    outputIdAndProp,
+                    data.response.props
+                ])
+            }
         });
     });
 }
diff --git a/src/reducers/dependencyGraph.js b/src/reducers/dependencyGraph.js
index 6992fb57..535b4df2 100644
--- a/src/reducers/dependencyGraph.js
+++ b/src/reducers/dependencyGraph.js
@@ -1,3 +1,4 @@
+import {type} from 'ramda';
 import {DepGraph} from 'dependency-graph';
 
 const initialGraph = {};
@@ -10,11 +11,16 @@ const graphs = (state = initialGraph, action) => {
 
             dependencies.forEach(function registerDependency(dependency) {
                 const {output, inputs} = dependency;
+
+                // Multi output supported will be a string already
+                // Backward compatibility by detecting object.
+                const outputId = type(output) === 'Object' ?
+                    `${output.id}.${output.property}` : output;
                 inputs.forEach(inputObject => {
                     const inputId = `${inputObject.id}.${inputObject.property}`;
-                    inputGraph.addNode(output);
+                    inputGraph.addNode(outputId);
                     inputGraph.addNode(inputId);
-                    inputGraph.addDependency(inputId, output);
+                    inputGraph.addDependency(inputId, outputId);
                 });
             });
 

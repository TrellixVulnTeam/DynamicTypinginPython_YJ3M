commit 5ff00cf8351a8fb4640dc422803d6fb1c6e2c535
Author: alexcjohnson <alex@plot.ly>
Date:   Wed Sep 11 01:12:10 2019 -0400

    unit test (and fix bugs) storage & fallbacks

diff --git a/.circleci/config.yml b/.circleci/config.yml
index 8251fed6..77e1a35e 100644
--- a/.circleci/config.yml
+++ b/.circleci/config.yml
@@ -55,10 +55,14 @@ jobs:
             pylint tests/unit tests/integration/devtools tests/integration/renderer tests/integration/dash_assets -d all -e C0410,C0411,C0412,C0413,W0109
             cd dash-renderer && npm install --ignore-scripts && npm run lint:test && npm run format:test
       - run:
-          name: üîé Unit Tests
+          name: üêç Python Unit Tests
           command: |
             . venv/bin/activate
             PYTHONPATH=~/dash/tests/assets pytest tests/unit
+      - run:
+          name: ‚òï JS Unit Tests
+          command: |
+            cd dash-renderer && npm run test:js
 
   "lint-unit-36":
       <<: *lint-unit
@@ -262,4 +266,4 @@ workflows:
       - "test-27":
           requires:
             - build-core-27
-            - build-misc-27
\ No newline at end of file
+            - build-misc-27
diff --git a/dash-renderer/jest.config.js b/dash-renderer/jest.config.js
new file mode 100644
index 00000000..06090ac5
--- /dev/null
+++ b/dash-renderer/jest.config.js
@@ -0,0 +1,181 @@
+// For a detailed explanation regarding each configuration property, visit:
+// https://jestjs.io/docs/en/configuration.html
+
+module.exports = {
+  // All imported modules in your tests should be mocked automatically
+  // automock: false,
+
+  // Stop running tests after the first failure
+  // bail: false,
+
+  // Respect "browser" field in package.json when resolving modules
+  // browser: false,
+
+  // The directory where Jest should store its cached dependency information
+  // cacheDirectory: "/var/folders/8m/wrr89jfx5kg5xhp7q2127bcc0000gn/T/jest_dx",
+
+  // Automatically clear mock calls and instances between every test
+  clearMocks: true,
+
+  // Indicates whether the coverage information should be collected while executing the test
+  // collectCoverage: false,
+
+  // An array of glob patterns indicating a set of files for which coverage information should be collected
+  // collectCoverageFrom: null,
+
+  // The directory where Jest should output its coverage files
+  coverageDirectory: "coverage",
+
+  // An array of regexp pattern strings used to skip coverage collection
+  // coveragePathIgnorePatterns: [
+  //   "/node_modules/"
+  // ],
+
+  // A list of reporter names that Jest uses when writing coverage reports
+  // coverageReporters: [
+  //   "json",
+  //   "text",
+  //   "lcov",
+  //   "clover"
+  // ],
+
+  // An object that configures minimum threshold enforcement for coverage results
+  // coverageThreshold: null,
+
+  // Make calling deprecated APIs throw helpful error messages
+  // errorOnDeprecated: false,
+
+  // Force coverage collection from ignored files usin a array of glob patterns
+  // forceCoverageMatch: [],
+
+  // A path to a module which exports an async function that is triggered once before all test suites
+  // globalSetup: null,
+
+  // A path to a module which exports an async function that is triggered once after all test suites
+  // globalTeardown: null,
+
+  // A set of global variables that need to be available in all test environments
+  // globals: {},
+
+  // An array of directory names to be searched recursively up from the requiring module's location
+  // moduleDirectories: [
+  //   "node_modules"
+  // ],
+
+  // An array of file extensions your modules use
+  // moduleFileExtensions: [
+  //   "js",
+  //   "json",
+  //   "jsx",
+  //   "node"
+  // ],
+
+  // A map from regular expressions to module names that allow to stub out resources with a single module
+  moduleNameMapper: {
+    "\\.(css|less)$": "identity-obj-proxy"
+  },
+
+  // An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader
+  // modulePathIgnorePatterns: [],
+
+  // Activates notifications for test results
+  // notify: false,
+
+  // An enum that specifies notification mode. Requires { notify: true }
+  // notifyMode: "always",
+
+  // A preset that is used as a base for Jest's configuration
+  // preset: null,
+
+  // Run tests from one or more projects
+  // projects: null,
+
+  // Use this configuration option to add custom reporters to Jest
+  // reporters: undefined,
+
+  // Automatically reset mock state between every test
+  // resetMocks: false,
+
+  // Reset the module registry before running each individual test
+  // resetModules: false,
+
+  // A path to a custom resolver
+  // resolver: null,
+
+  // Automatically restore mock state between every test
+  // restoreMocks: false,
+
+  // The root directory that Jest should scan for tests and modules within
+  // rootDir: null,
+
+  // A list of paths to directories that Jest should use to search for files in
+  roots: [
+    "<rootDir>/tests"
+  ],
+
+  // Allows you to use a custom runner instead of Jest's default test runner
+  // runner: "jest-runner",
+
+  // The paths to modules that run some code to configure or set up the testing environment before each test
+  // setupFiles: ['<rootDir>/tests/setupTests.js'],
+
+  // The path to a module that runs some code to configure or set up the testing framework before each test
+  // setupTestFrameworkScriptFile: null,
+
+  // A list of paths to snapshot serializer modules Jest should use for snapshot testing
+  // snapshotSerializers: [],
+
+  // The test environment that will be used for testing
+  testEnvironment: "jsdom",
+
+  // Options that will be passed to the testEnvironment
+  // testEnvironmentOptions: {},
+
+  // Adds a location field to test results
+  // testLocationInResults: false,
+
+  // The glob patterns Jest uses to detect test files
+  testMatch: [
+    "**/?(*.)+(spec|test).js?(x)"
+  ],
+
+  // An array of regexp pattern strings that are matched against all test paths, matched tests are skipped
+  // testPathIgnorePatterns: [
+  //   "/node_modules/"
+  // ],
+
+  // The regexp pattern Jest uses to detect test files
+  // testRegex: "",
+
+  // This option allows the use of a custom results processor
+  // testResultsProcessor: null,
+
+  // This option allows use of a custom test runner
+  // testRunner: "jasmine2",
+
+  // This option sets the URL for the jsdom environment. It is reflected in properties such as location.href
+  // testURL: "http://localhost",
+
+  // Setting this value to "fake" allows the use of fake timers for functions such as "setTimeout"
+  // timers: "real",
+
+  // A map from regular expressions to paths to transformers
+  // transform: null,
+
+  // An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation
+  // transformIgnorePatterns: [
+  //   "/node_modules/"
+  // ],
+
+  // An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them
+  // unmockedModulePathPatterns: undefined,
+
+  // Indicates whether each individual test should be reported during the run
+  // verbose: null,
+
+  // An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode
+  // watchPathIgnorePatterns: [],
+
+  // Whether to use watchman for file crawling
+  // watchman: true,
+};
diff --git a/dash-renderer/src/persistence.js b/dash-renderer/src/persistence.js
index eccedceb..e83d2fae 100644
--- a/dash-renderer/src/persistence.js
+++ b/dash-renderer/src/persistence.js
@@ -70,8 +70,7 @@ import uniqid from 'uniqid';
 
 import Registry from './registry';
 
-const storePrefix = '_dash_persistence.';
-const UNDEFINED = 'U';
+export const storePrefix = '_dash_persistence.';
 
 function err(e) {
     const error = typeof e === 'string' ? new Error(e) : e;
@@ -100,6 +99,10 @@ function keyPrefixMatch(prefix, separator) {
     return key => key === prefix || key.substr(0, fullLen) === fullStr;
 }
 
+const UNDEFINED = 'U';
+const _parse = val => val === UNDEFINED ? void 0 : JSON.parse(val || null);
+const _stringify = val => val === void 0 ? UNDEFINED : JSON.stringify(val);
+
 class WebStore {
     constructor(backEnd) {
         this._name = backEnd;
@@ -113,8 +116,7 @@ class WebStore {
     getItem(key) {
         // note: _storage.getItem returns null on missing keys
         // and JSON.parse(null) returns null as well
-        const gotVal = this._storage.getItem(storePrefix + key);
-        return gotVal === UNDEFINED ? void 0 : JSON.parse(gotVal);
+        return _parse(this._storage.getItem(storePrefix + key));
     }
 
     /*
@@ -122,9 +124,8 @@ class WebStore {
      * dispatch as a parameter, so it can report OOM to devtools
      */
     setItem(key, value, dispatch) {
-        const setVal = value === void 0 ? UNDEFINED : JSON.stringify(value);
         try {
-            this._storage.setItem(storePrefix + key, setVal);
+            this._storage.setItem(storePrefix + key, _stringify(value));
         } catch (e) {
             if (dispatch) {
                 dispatch(err(e));
@@ -173,11 +174,11 @@ class MemStore {
     getItem(key) {
         // run this storage through JSON too so we know we get a fresh object
         // each retrieval
-        return JSON.parse(this._data[key] || null);
+        return _parse(this._data[key]);
     }
 
     setItem(key, value) {
-        this._data[key] = JSON.stringify(value);
+        this._data[key] = _stringify(value);
     }
 
     removeItem(key) {
@@ -208,7 +209,7 @@ function longString() {
     return s;
 }
 
-const stores = {
+export const stores = {
     memory: new MemStore(),
     // Defer testing & making local/session stores until requested.
     // That way if we have errors here they can show up in devtools.
@@ -223,7 +224,7 @@ function tryGetWebStore(backEnd, dispatch) {
     const store = new WebStore(backEnd);
     const fallbackStore = stores.memory;
     const storeTest = longString();
-    const testKey = 'x.x';
+    const testKey = storePrefix + 'x.x';
     try {
         store.setItem(testKey, storeTest);
         if (store.getItem(testKey) !== storeTest) {
diff --git a/dash-renderer/tests/persistence.test.js b/dash-renderer/tests/persistence.test.js
new file mode 100644
index 00000000..926ea7a4
--- /dev/null
+++ b/dash-renderer/tests/persistence.test.js
@@ -0,0 +1,181 @@
+/* eslint-disable no-magic-numbers */
+/* eslint-disable no-undefined */
+/* eslint-disable no-console */
+import {recordUiEdit, stores, storePrefix} from '../src/persistence';
+
+const _dispatch = a => {
+    return evt => {
+        a.push(evt.payload.error.message);
+    }
+};
+
+const longString = pow => {
+    let s = 's';
+    for (let i = 0; i < pow; i++) {
+        s += s;
+    }
+    return s;
+};
+
+const fillStorage = (store, key) => {
+    // double the attempted string until we fail
+    // then a binary search to find the exact point of failure
+    const maxPow = 30;
+    let pow = 0;
+    for(; pow < maxPow; pow++) {
+        try {
+            store.setItem(key, longString(pow));
+        } catch(e) {
+            break;
+        }
+    }
+    pow--;
+    let s = longString(pow);
+    for(pow--; pow >= 0; pow--) {
+        const s2 = s + longString(pow);
+        try {
+            store.setItem(key, s2);
+            s = s2;
+        } catch(e) {
+            // s remains as is, next time we'll add half as much
+        }
+    }
+    // finally a sanity check that nothing more can be added
+    try {
+        store.setItem(key + '+', 'a');
+    } catch(e) {
+        return;
+    }
+    throw new Error('Something still fits in the store?');
+};
+
+const clearStores = () => {
+    window.localStorage.clear();
+    window.sessionStorage.clear();
+    stores.memory.clear();
+    // clear all record of having tested the stores
+    delete stores.local;
+    delete stores.session;
+};
+
+const layoutA = storeType => ({
+    namespace: 'my_components',
+    type: 'C',
+    props: {
+        id: 'a',
+        persistence: true,
+        persistence_type: storeType
+    }
+});
+
+
+describe('storage fallbacks and equivalence', () => {
+    const propVal = 42;
+    const propStr = String(propVal);
+    let originalConsoleErr;
+    let consoleCalls;
+
+    beforeEach(() => {
+        window.my_components = {
+            C: {
+                defaultProps: {
+                    persistence_type: 'local',
+                    persisted_props: ['p1', 'p2']
+                }
+            }
+        };
+
+        originalConsoleErr = console.error;
+        consoleCalls = [];
+        console.error = msg => {
+            consoleCalls.push(msg);
+        };
+
+        clearStores();
+    });
+
+    afterEach(() => {
+        delete window.my_components;
+        clearStores();
+        console.error = originalConsoleErr;
+    });
+
+    ['local', 'session'].forEach(storeType => {
+        const storeName = storeType + 'Storage';
+        const store = window[storeName];
+
+        const layout = layoutA(storeType);
+
+        test(`empty ${storeName} works`, () => {
+            const dispatchCalls = [];
+            store.clear();
+
+            recordUiEdit(layout, {p1: propVal}, _dispatch(dispatchCalls));
+            expect(dispatchCalls).toEqual([]);
+            expect(consoleCalls).toEqual([]);
+            expect(store.getItem(`${storePrefix}a.p1`)).toEqual(propStr);
+            expect(store.getItem(`${storePrefix}a.p1.orig`)).toEqual('U');
+        });
+
+        test(`${storeName} full from persistence works with warnings`, () => {
+            const dispatchCalls = [];
+            fillStorage(store, `${storePrefix}x.x`);
+
+            recordUiEdit(layout, {p1: propVal}, _dispatch(dispatchCalls));
+            expect(dispatchCalls).toEqual([
+                `${storeName} init first try failed; clearing and retrying`,
+                `${storeName} init set/get succeeded after clearing!`
+            ]);
+            expect(consoleCalls).toEqual(dispatchCalls);
+            expect(store.getItem(`${storePrefix}a.p1`)).toBe(propStr);
+            // Boolean so we don't see the very long value if test fails
+            const x = Boolean(store.getItem(`${storePrefix}x.x`));
+            expect(x).toBe(false);
+        });
+
+        test(`${storeName} full from other stuff falls back on memory`, () => {
+            const dispatchCalls = [];
+            fillStorage(store, 'not_ours');
+
+            recordUiEdit(layout, {p1: propVal}, _dispatch(dispatchCalls));
+            expect(dispatchCalls).toEqual([
+                `${storeName} init first try failed; clearing and retrying`,
+                `${storeName} init still failed, falling back to memory`
+            ]);
+            expect(consoleCalls).toEqual(dispatchCalls);
+            expect(stores.memory.getItem('a.p1')).toBe(propVal);
+            const x = Boolean(store.getItem('not_ours'));
+            expect(x).toBe(true);
+        });
+    });
+
+    ['local', 'session', 'memory'].forEach(storeType => {
+        const layout = layoutA(storeType);
+        const key = 'key';
+
+        test(`${storeType} primitives in/out match`, () => {
+            // ensure storage is instantiated
+            recordUiEdit(layout, {p1: propVal}, _dispatch());
+            const store = stores[storeType];
+            [
+                0, 1, 1.1, true, false, null, undefined, '', 'hi', '0', '1'
+            ].forEach(val => {
+                store.setItem(key, val);
+                expect(store.getItem(key)).toBe(val);
+            });
+        });
+
+        test(`${storeType} arrays and objects in/out are clones`, () => {
+            recordUiEdit(layout, {p1: propVal}, _dispatch());
+            const store = stores[storeType];
+
+            [[1, 2, 3], {a: 1, b: 2}].forEach(val => {
+
+                store.setItem(key, val);
+                const valOut = store.getItem(key);
+                expect(valOut).not.toBe(val);
+                expect(valOut).toEqual(val);
+            });
+        });
+    });
+});

commit 7e597649e2dafbf4205239b2518d8ab691e27e6c
Author: chriddyp <chris@plot.ly>
Date:   Tue Apr 26 17:48:17 2016 -0400

    :fireworks: recursive updateDependants action
    
    this function gets called when a component updates and dispatches
    `updateDependants`.
    this action:
    - looks at the component’s dependants
    - makes POSTs to /update-component for each of the component’s
    dependant’s with all of the necessary dependencies
    - update’s each of the dependant’s with the new values from the
    response of the /update-component POST
    - recursively continues, dispatching to `updateDependants` with each of
    those dependendant’s dependants
    
    consider: A depends on B which depends on C
    when C changes, it dispatches `updateDependants` to update the value of
    B. on the response of that POST, B updates and makes a dispatch to
    update A with B’s new values

diff --git a/renderer/package.json b/renderer/package.json
index 4465b1dc..a8805029 100644
--- a/renderer/package.json
+++ b/renderer/package.json
@@ -37,6 +37,7 @@
     "react-redux": "^4.4.5",
     "redux": "^3.4.0",
     "redux-actions": "^0.9.1",
+    "redux-thunk": "^2.0.1",
     "webpack": "^1.13.1",
     "webpack-partial": "^1.2.0"
   },
diff --git a/renderer/src/actions/index.js b/renderer/src/actions/index.js
index ae776146..e886906f 100644
--- a/renderer/src/actions/index.js
+++ b/renderer/src/actions/index.js
@@ -1,3 +1,4 @@
+import R from 'ramda';
 import { createAction } from 'redux-actions';
 
 export const ACTIONS = (action) => {
@@ -12,3 +13,71 @@ export const ACTIONS = (action) => {
 export const updateProps = createAction(ACTIONS('ON_PROP_CHANGE'));
 export const setRequestQueue = createAction(ACTIONS('SET_REQUEST_QUEUE'));
 
+// TODO: make the actual POST
+export const updateDependants = function(payload) {
+    return function (dispatch, getState) {
+        const {
+            layout,
+            dependencyGraph,
+            paths,
+            requestQueue
+        } = getState();
+        let dependentIds = dependencyGraph.dependantsOf(payload.id);
+
+        // order the dependent ids
+        const depOrder = dependencyGraph.overallOrder();
+        dependentIds = R.sort(
+            (a, b) => depOrder.indexOf(a) - depOrder.indexOf(b),
+            dependentIds
+        );
+
+        // record the set of requests in the queue
+        dispatch(setRequestQueue(R.union(dependentIds, requestQueue)));
+
+        for (let i = 0; i < dependentIds.length; i++) {
+            const dependentId = dependentIds[i];
+            const dependentComponent = layout.getIn(paths[dependentId]);
+
+            const payload = dependentComponent.get('dependencies').reduce(
+                (r, id) => {
+                    r[id] = layout.getIn(R.append('props', paths[id])).toJS();
+                    return r;
+                }, {target: dependentId}
+            );
+
+            /*
+             * before we make the POST, check that some recursive call hasn't
+             * already cleared this request from the queue
+             */
+            if (getState().requestQueue.indexOf(dependentId) > -1) {
+
+                // make the /POST
+                // xhr.POST(/update-component) ...
+                console.warn('POST /update-component', JSON.stringify(payload, null, 2));
+
+                // clear this item from the request queue
+                dispatch(setRequestQueue(
+                    R.reject(
+                        id => id === dependentId,
+                        // in an async loop so grab the state again
+                        getState().requestQueue)
+                    )
+                );
+
+                // and update the props of the component
+                const dependentUpdatePayload = {
+                    id: dependentId,
+                    itempath: paths[dependentId],
+                    // new props from the server, just hard coded here
+                    value: 1000*Math.random()
+                };
+                dispatch(updateProps(dependentUpdatePayload));
+
+                // and now update *this* component's dependencies
+                dispatch(updateDependants(dependentUpdatePayload));
+
+            }
+
+        }
+    }
+}

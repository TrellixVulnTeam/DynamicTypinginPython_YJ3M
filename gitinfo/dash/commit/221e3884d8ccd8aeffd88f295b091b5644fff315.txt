commit 221e3884d8ccd8aeffd88f295b091b5644fff315
Author: alexcjohnson <alex@plot.ly>
Date:   Tue Mar 31 21:03:19 2020 -0400

    fix wildcardOverlap for MATCH/ALLSMALLER case, fix mergeAllBlockers, test these and clientside wildcards

diff --git a/dash-renderer/src/actions/dependencies.js b/dash-renderer/src/actions/dependencies.js
index 111ffb62..fd5ebf44 100644
--- a/dash-renderer/src/actions/dependencies.js
+++ b/dash-renderer/src/actions/dependencies.js
@@ -31,6 +31,8 @@ import {
     zipObj,
 } from 'ramda';
 
+const mergeMax = mergeWith(Math.max);
+
 import {getPath} from './paths';
 
 import {crawlLayout} from './utils';
@@ -429,7 +431,18 @@ function findMismatchedWildcards(outputs, inputs, state, head, dispatchError) {
     });
 }
 
-const matchWildKeys = ([a, b]) => a === b || (a && a.wild) || (b && b.wild);
+const matchWildKeys = ([a, b]) => {
+    const aWild = a && a.wild;
+    const bWild = b && b.wild;
+    if (aWild && bWild) {
+        // Every wildcard combination overlaps except MATCH<->ALLSMALLER
+        return !(
+            (a === MATCH && b === ALLSMALLER) ||
+            (a === ALLSMALLER && b === MATCH)
+        );
+    }
+    return a === b || aWild || bWild;
+};
 
 function wildcardOverlap({id, property}, objs) {
     const idKeys = keys(id).sort();
@@ -1199,8 +1212,7 @@ export function getCallbacksInLayout(graphs, paths, layoutChunk, opts) {
         if (callback) {
             const foundIndex = foundCbIds[callback.resolvedId];
             if (foundIndex !== undefined) {
-                callbacks[foundIndex].changedPropIds = mergeWith(
-                    Math.max,
+                callbacks[foundIndex].changedPropIds = mergeMax(
                     callbacks[foundIndex].changedPropIds,
                     callback.changedPropIds
                 );
@@ -1410,8 +1422,7 @@ export function followForward(graphs, paths, callbacks_) {
                 allResolvedIds[nextCB.resolvedId] = existingIndex;
             } else {
                 const existingCB = callbacks[existingIndex];
-                existingCB.changedPropIds = mergeWith(
-                    Math.max,
+                existingCB.changedPropIds = mergeMax(
                     existingCB.changedPropIds,
                     nextCB.changedPropIds
                 );
@@ -1433,8 +1444,9 @@ export function followForward(graphs, paths, callbacks_) {
 function mergeAllBlockers(cb1, cb2) {
     function mergeBlockers(a, b) {
         if (cb1[a][cb2.resolvedId] && !cb2[b][cb1.resolvedId]) {
-            cb2[b] = mergeRight({[cb1.resolvedId]: 1}, cb1[b], cb2[b]);
-            cb1[a] = mergeRight({[cb2.resolvedId]: 1}, cb2[a], cb1[b]);
+            cb2[b][cb1.resolvedId] = cb1[a][cb2.resolvedId];
+            cb2[b] = mergeMax(cb1[b], cb2[b]);
+            cb1[a] = mergeMax(cb2[a], cb1[a]);
         }
     }
     mergeBlockers('blockedBy', 'blocking');
diff --git a/dash-renderer/src/actions/paths.js b/dash-renderer/src/actions/paths.js
index 5ab2ea94..d9eca5a6 100644
--- a/dash-renderer/src/actions/paths.js
+++ b/dash-renderer/src/actions/paths.js
@@ -67,7 +67,8 @@ export function getPath(paths, id) {
             return false;
         }
         const values = props(keys, id);
-        return find(propEq('values', values), keyPaths).path;
+        const pathObj = find(propEq('values', values), keyPaths);
+        return pathObj && pathObj.path;
     }
     return paths.strs[id];
 }
diff --git a/tests/integration/callbacks/test_wildcards.py b/tests/integration/callbacks/test_wildcards.py
index e718457b..82f314dc 100644
--- a/tests/integration/callbacks/test_wildcards.py
+++ b/tests/integration/callbacks/test_wildcards.py
@@ -1,5 +1,7 @@
 from multiprocessing import Value
+import pytest
 import re
+from selenium.webdriver.common.keys import Keys
 
 import dash_html_components as html
 import dash_core_components as dcc
@@ -214,3 +216,97 @@ def test_cbwc001_todo_app(dash_duo):
     # This was a tricky one - trigger based on deleted components
     dash_duo.wait_for_text_to_equal("#totals", "0 of 0 items completed")
     assert_count(0)
+
+
+def fibonacci_app(clientside):
+    # This app tests 2 things in particular:
+    # - clientside callbacks work the same as server-side
+    # - callbacks using ALLSMALLER as an input to MATCH of the exact same id/prop
+    app = dash.Dash(__name__)
+    app.layout = html.Div([
+        dcc.Input(id="n", type="number", min=0, max=10, value=4),
+        html.Div(id="series"),
+        html.Div(id="sum")
+    ])
+
+    @app.callback(
+        Output("series", "children"), [Input("n", "value")]
+    )
+    def items(n):
+        return [html.Div(id={"i": i}) for i in range(n)]
+
+    if clientside:
+        app.clientside_callback(
+            """
+            function(vals) {
+                var len = vals.length;
+                return len < 2 ? len : +(vals[len - 1] || 0) + +(vals[len - 2] || 0);
+            }
+            """,
+            Output({"i": MATCH}, "children"),
+            [Input({"i": ALLSMALLER}, "children")]
+        )
+
+        app.clientside_callback(
+            """
+            function(vals) {
+                var sum = vals.reduce(function(a, b) { return +a + +b; }, 0);
+                return vals.length + ' elements, sum: ' + sum;
+            }
+            """,
+            Output("sum", "children"),
+            [Input({"i": ALL}, "children")]
+        )
+
+    else:
+        @app.callback(
+            Output({"i": MATCH}, "children"),
+            [Input({"i": ALLSMALLER}, "children")]
+        )
+        def sequence(prev):
+            if (len(prev) < 2):
+                return len(prev)
+            return int(prev[-1] or 0) + int(prev[-2] or 0)
+
+        @app.callback(Output("sum", "children"), [Input({"i": ALL}, "children")])
+        def show_sum(seq):
+            return "{} elements, sum: {}".format(len(seq), sum(int(v or 0) for v in seq))
+
+    return app
+
+
+@pytest.mark.parametrize("clientside", (False, True))
+def test_cbwc002_fibonacci_app(clientside, dash_duo):
+    app = fibonacci_app(clientside)
+    dash_duo.start_server(app)
+
+    # app starts with 4 elements: 0, 1, 1, 2
+    dash_duo.wait_for_text_to_equal("#sum", "4 elements, sum: 4")
+
+    # add 5th item, "3"
+    dash_duo.find_element("#n").send_keys(Keys.UP)
+    dash_duo.wait_for_text_to_equal("#sum", "5 elements, sum: 7")
+
+    # add 6th item, "5"
+    dash_duo.find_element("#n").send_keys(Keys.UP)
+    dash_duo.wait_for_text_to_equal("#sum", "6 elements, sum: 12")
+
+    # add 7th item, "8"
+    dash_duo.find_element("#n").send_keys(Keys.UP)
+    dash_duo.wait_for_text_to_equal("#sum", "7 elements, sum: 20")
+
+    # back down all the way to no elements
+    dash_duo.find_element("#n").send_keys(Keys.DOWN)
+    dash_duo.wait_for_text_to_equal("#sum", "6 elements, sum: 12")
+    dash_duo.find_element("#n").send_keys(Keys.DOWN)
+    dash_duo.wait_for_text_to_equal("#sum", "5 elements, sum: 7")
+    dash_duo.find_element("#n").send_keys(Keys.DOWN)
+    dash_duo.wait_for_text_to_equal("#sum", "4 elements, sum: 4")
+    dash_duo.find_element("#n").send_keys(Keys.DOWN)
+    dash_duo.wait_for_text_to_equal("#sum", "3 elements, sum: 2")
+    dash_duo.find_element("#n").send_keys(Keys.DOWN)
+    dash_duo.wait_for_text_to_equal("#sum", "2 elements, sum: 1")
+    dash_duo.find_element("#n").send_keys(Keys.DOWN)
+    dash_duo.wait_for_text_to_equal("#sum", "1 elements, sum: 0")
+    dash_duo.find_element("#n").send_keys(Keys.DOWN)
+    dash_duo.wait_for_text_to_equal("#sum", "0 elements, sum: 0")

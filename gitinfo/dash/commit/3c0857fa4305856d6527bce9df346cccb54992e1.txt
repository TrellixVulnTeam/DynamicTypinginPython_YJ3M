commit 3c0857fa4305856d6527bce9df346cccb54992e1
Author: chriddyp <chris@plot.ly>
Date:   Mon Mar 20 23:39:16 2017 -0400

    handle richer react docgen metadata
    
    including types, descriptions, required values, and more

diff --git a/dash/development/base_component.py b/dash/development/base_component.py
index 8d16a56b..e538c6ac 100644
--- a/dash/development/base_component.py
+++ b/dash/development/base_component.py
@@ -1,4 +1,6 @@
 import collections
+import copy
+import sys
 import types
 
 
@@ -183,17 +185,17 @@ class Component(collections.MutableMapping):
         return length
 
 
-def generate_class(typename, component_arguments, namespace):
+def generate_class(typename, props, description, namespace):
     # Dynamically generate classes to have nicely formatted docstrings,
     # keyword arguments, and repr
     # Insired by http://jameso.be/2013/08/06/namedtuple.html
 
-    import sys
-
     # TODO - Tab out the repr for the repr of these components to make it
     # look more like a heirarchical tree
     # TODO - Include "description" "defaultValue" in the repr and docstring
+    #
     # TODO - Handle "required"
+    #
     # TODO - How to handle user-given `null` values? I want to include
     # an expanded docstring like Dropdown(value=None, id=None)
     # but by templating in those None values, I have no way of knowing
@@ -202,7 +204,7 @@ def generate_class(typename, component_arguments, namespace):
     # The solution might be to deal with default values better although
     # not all component authors will supply those.
     c = '''class {typename}(Component):
-        """A {typename} component.\nValid keys:\n{bullet_list_of_valid_keys}
+        """{docstring}
         """
         def __init__(self, {default_argtext}):
             self._prop_names = {list_of_valid_keys}
@@ -220,9 +222,9 @@ def generate_class(typename, component_arguments, namespace):
             else:
                 return '{typename}(' + repr(getattr(self, self._prop_names[0], None)) + ')'
     '''
-    list_of_valid_keys = repr(component_arguments)
+    list_of_valid_keys = repr(props.keys())
     bullet_list_of_valid_keys = ('- ' + '\n- '.join(
-        component_arguments
+        list_of_valid_keys
     ))
 
     if 'content' in component_arguments:
@@ -238,3 +240,121 @@ def generate_class(typename, component_arguments, namespace):
     exec d in scope
     result = scope[typename]
     return result
+
+def create_docstring(name, props, description):
+    if 'content' in props:
+        props = collections.OrderedDict(
+            [['content', props.pop('content')]] +
+            zip(props.keys(), props.values())
+        )
+    return '''A {name} component.{description}
+
+    Keyword arguments:
+    {args}
+
+    '''.format(
+        name=name,
+        description='\n{}'.format(description),
+        args='\n'.join(
+            ['- {}'.format(argument_doc(
+                p, prop['type'], prop['required'], prop['description']
+            )) for p, prop in filter_props(props).iteritems()]
+        )
+    ).replace('    ', '')
+
+def filter_props(args):
+    filtered_args = copy.deepcopy(args)
+    for arg_name in filtered_args:
+        arg_type =  args[arg_name]['type']['name']
+        if arg_type in ['func', 'symbol', 'instanceOf']:
+            filtered_args.pop(arg_name)
+    return filtered_args
+
+def js_to_py_type(type_object):
+    js_type_name = type_object['name']
+
+    js_to_py_types = {
+        'array': lambda: 'list',
+        'bool': lambda: 'boolean',
+        'number': lambda: 'number',
+        'string': lambda: 'string',
+        'object': lambda: 'dict',
+
+        'any': lambda: 'boolean | number | string | dict | list',
+        'element': lambda: 'dash component',
+        'node': lambda: (
+            'a list of or a singular dash component, string or number'
+        ),
+
+        # React's PropTypes.oneOf
+        'enum': lambda: 'a value equal to: {}'.format(', '.join([
+            '{}'.format(str(t['value'])) for t in type_object['value']
+        ])),
+
+        # React's PropTypes.oneOfType
+        'union': lambda: '{}'.format(' | '.join([
+            '{}'.format(js_to_py_type(subType))
+            for subType in type_object['value'] if js_to_py_type(subType) != ''
+        ])),
+
+        # React's PropTypes.arrayOf
+        'arrayOf': lambda: 'list'.format(
+            'of {}s'.format(js_to_py_type(type_object['value']))
+            if js_to_py_type(type_object['value']) != ''
+            else ''
+        ),
+
+        # React's PropTypes.objectOf
+        'objectOf': lambda: (
+            'dict with strings as keys and values of type {}'
+        ).format(js_to_py_type(type_object['value'])),
+
+        # React's PropTypes.shape
+        'shape': lambda: (
+            'dict containing keys {}.\n{}'.format(
+                ', '.join(
+                    ["'{}'".format(t) for t in type_object['value'].keys()]
+                ),
+                'Those keys have the following types: \n{}'.format(
+                    '\n'.join([
+                        '  - ' + argument_doc(
+                            prop_name,
+                            prop,
+                            prop['required'],
+                            prop.get('description', '')
+                        ) for
+                        prop_name, prop in type_object['value'].iteritems()
+                    ])
+                )
+            )
+        )
+
+    }
+    if 'computed' in type_object and type_object['computed']:
+        return ''
+    if js_type_name in js_to_py_types:
+        return js_to_py_types[js_type_name]()
+    else:
+        return ''
+
+def argument_doc(arg_name, type_object, required, description):
+    js_type_name = type_object['name']
+    py_type_name = js_to_py_type(type_object)
+    if '\n' in py_type_name:
+        return (
+            '{name} ({is_required}): {description}. '
+            '{name} has the following type: {type}'
+        ).format(
+            name=arg_name,
+            type=py_type_name,
+            description=description,
+            is_required='required' if required else 'optional'
+        )
+
+    else:
+        return '{name} ({type}{is_required}){description}'.format(
+            name=arg_name,
+            type='{}; '.format(py_type_name) if py_type_name else '',
+            description=': {}'.format(description) if description != '' else '',
+            is_required='required' if required else 'optional'
+        )
diff --git a/dash/development/component_loader.py b/dash/development/component_loader.py
index 9c451de9..116230cf 100644
--- a/dash/development/component_loader.py
+++ b/dash/development/component_loader.py
@@ -4,7 +4,6 @@ import json
 
 
 def load_components(metadata_path,
-                    default_props=[],
                     namespace='default_namespace'):
     """Load React component metadata into a format Dash can parse.
 
@@ -39,21 +38,19 @@ def load_components(metadata_path,
         # the name of the component atm.
         name = componentPath.split('/').pop().split('.')[0]
 
-        # Extract props
-        prop_names = componentData.get('props', {}).keys()
-        for prop in default_props:
-            if prop not in prop_names:
-                prop_names.insert(0, prop)
-
         # If "content" is a prop, then move it to the front to respect
         # dash convention
-        if 'content' in prop_names:
-            prop_names.remove('content')
-            prop_names.insert(0, 'content')
+        props = componentData['props']
+        if 'content' in props:
+            props = OrderedDict(
+                [('content', props.pop('content'), )] +
+                zip(props.keys(), props.values())
+            )
 
         component = generate_class(
             name,
-            prop_names,
+            props,
+            description,
             namespace
         )
 
diff --git a/tests/development/TestReactComponent.react.js b/tests/development/TestReactComponent.react.js
new file mode 100644
index 00000000..a08d6cb9
--- /dev/null
+++ b/tests/development/TestReactComponent.react.js
@@ -0,0 +1,108 @@
+import React from 'react';
+// A react component with all of the available proptypes to run tests over
+
+/**
+ * This is a description of the component.
+ * It's multiple lines long.
+ */
+class ReactComponent extends Component {
+    render() {
+        return '';
+    }
+}
+
+ReactComponent.propTypes = {
+    /**
+     * Description of optionalArray
+     */
+    optionalArray: React.PropTypes.array,
+    optionalBool: React.PropTypes.bool,
+    optionalFunc: React.PropTypes.func,
+    optionalNumber: React.PropTypes.number,
+    optionalObject: React.PropTypes.object,
+    optionalString: React.PropTypes.string,
+    optionalSymbol: React.PropTypes.symbol,
+
+    content: React.PropTypes.node,
+
+    // Anything that can be rendered: numbers, strings, elements or an array
+    // (or fragment) containing these types.
+    optionalNode: React.PropTypes.node,
+
+    // A React element.
+    optionalElement: React.PropTypes.element,
+
+    // You can also declare that a prop is an instance of a class. This uses
+    // JS's instanceof operator.
+    optionalMessage: React.PropTypes.instanceOf(Message),
+
+    // You can ensure that your prop is limited to specific values by treating
+    // it as an enum.
+    optionalEnum: React.PropTypes.oneOf(['News', 'Photos']),
+
+    // An object that could be one of many types
+    optionalUnion: React.PropTypes.oneOfType([
+        React.PropTypes.string,
+        React.PropTypes.number,
+        React.PropTypes.instanceOf(Message)
+    ]),
+
+    // An array of a certain type
+    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),
+
+    // An object with property values of a certain type
+    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),
+
+    // An object taking on a particular shape
+    optionalObjectWithShapeAndNestedDescription: React.PropTypes.shape({
+        color: React.PropTypes.string,
+        fontSize: React.PropTypes.number,
+        /**
+         * Figure is a plotly graph object
+         */
+        figure: React.PropTypes.shape({
+            /**
+             * data is a collection of traces
+             */
+            data: React.PropTypes.arrayOf(React.PropTypes.object),
+            /**
+             * layout describes the rest of the figure
+             */
+            layout: React.PropTypes.object
+        })
+    }),
+
+    // You can chain any of the above with `isRequired` to make sure a warning
+    // is shown if the prop isn't provided.
+    requiredFunc: React.PropTypes.func.isRequired,
+
+    // A value of any data type
+    requiredAny: React.PropTypes.any.isRequired,
+
+    requiredArray: React.PropTypes.array.isRequired,
+
+    customProp: function(props, propName, componentName) {
+        if (!/matchme/.test(props[propName])) {
+            return new Error(
+            'Invalid prop `' + propName + '` supplied to' +
+            ' `' + componentName + '`. Validation failed.'
+            );
+        }
+    },
+
+    customArrayProp: React.PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {
+        if (!/matchme/.test(propValue[key])) {
+            return new Error(
+            'Invalid prop `' + propFullName + '` supplied to' +
+            ' `' + componentName + '`. Validation failed.'
+            );
+        }
+    })
+};
+
+ReactComponent.defaultProps = {
+    optionalNumber: 42,
+    optionalString: 'hello world'
+};
+
+export default ReactComponent;
diff --git a/tests/development/metadata_test.json b/tests/development/metadata_test.json
new file mode 100644
index 00000000..be249d83
--- /dev/null
+++ b/tests/development/metadata_test.json
@@ -0,0 +1,225 @@
+{
+  "description": "This is a description of the component.\nIt's multiple lines long.",
+  "methods": [],
+  "props": {
+    "optionalArray": {
+      "type": {
+        "name": "array"
+      },
+      "required": false,
+      "description": "Description of optionalArray"
+    },
+    "optionalBool": {
+      "type": {
+        "name": "bool"
+      },
+      "required": false,
+      "description": ""
+    },
+    "optionalFunc": {
+      "type": {
+        "name": "func"
+      },
+      "required": false,
+      "description": ""
+    },
+    "optionalNumber": {
+      "type": {
+        "name": "number"
+      },
+      "required": false,
+      "description": "",
+      "defaultValue": {
+        "value": "42",
+        "computed": false
+      }
+    },
+    "optionalObject": {
+      "type": {
+        "name": "object"
+      },
+      "required": false,
+      "description": ""
+    },
+    "optionalString": {
+      "type": {
+        "name": "string"
+      },
+      "required": false,
+      "description": "",
+      "defaultValue": {
+        "value": "'hello world'",
+        "computed": false
+      }
+    },
+    "optionalSymbol": {
+      "type": {
+        "name": "symbol"
+      },
+      "required": false,
+      "description": ""
+    },
+    "content": {
+      "type": {
+        "name": "node"
+      },
+      "required": false,
+      "description": ""
+    },
+    "optionalNode": {
+      "type": {
+        "name": "node"
+      },
+      "required": false,
+      "description": ""
+    },
+    "optionalElement": {
+      "type": {
+        "name": "element"
+      },
+      "required": false,
+      "description": ""
+    },
+    "optionalMessage": {
+      "type": {
+        "name": "instanceOf",
+        "value": "Message"
+      },
+      "required": false,
+      "description": ""
+    },
+    "optionalEnum": {
+      "type": {
+        "name": "enum",
+        "value": [
+          {
+            "value": "'News'",
+            "computed": false
+          },
+          {
+            "value": "'Photos'",
+            "computed": false
+          }
+        ]
+      },
+      "required": false,
+      "description": ""
+    },
+    "optionalUnion": {
+      "type": {
+        "name": "union",
+        "value": [
+          {
+            "name": "string"
+          },
+          {
+            "name": "number"
+          },
+          {
+            "name": "instanceOf",
+            "value": "Message"
+          }
+        ]
+      },
+      "required": false,
+      "description": ""
+    },
+    "optionalArrayOf": {
+      "type": {
+        "name": "arrayOf",
+        "value": {
+          "name": "number"
+        }
+      },
+      "required": false,
+      "description": ""
+    },
+    "optionalObjectOf": {
+      "type": {
+        "name": "objectOf",
+        "value": {
+          "name": "number"
+        }
+      },
+      "required": false,
+      "description": ""
+    },
+    "optionalObjectWithShapeAndNestedDescription": {
+      "type": {
+        "name": "shape",
+        "value": {
+          "color": {
+            "name": "string",
+            "required": false
+          },
+          "fontSize": {
+            "name": "number",
+            "required": false
+          },
+          "figure": {
+            "name": "shape",
+            "value": {
+              "data": {
+                "name": "arrayOf",
+                "value": {
+                  "name": "object"
+                },
+                "description": "data is a collection of traces",
+                "required": false
+              },
+              "layout": {
+                "name": "object",
+                "description": "layout describes the rest of the figure",
+                "required": false
+              }
+            },
+            "description": "Figure is a plotly graph object",
+            "required": false
+          }
+        }
+      },
+      "required": false,
+      "description": ""
+    },
+    "requiredFunc": {
+      "type": {
+        "name": "func"
+      },
+      "required": true,
+      "description": ""
+    },
+    "requiredAny": {
+      "type": {
+        "name": "any"
+      },
+      "required": true,
+      "description": ""
+    },
+    "requiredArray": {
+      "type": {
+        "name": "array"
+      },
+      "required": true,
+      "description": ""
+    },
+    "customProp": {
+      "type": {
+        "name": "custom",
+        "raw": "function(props, propName, componentName) {\n    if (!/matchme/.test(props[propName])) {\n        return new Error(\n        'Invalid prop `' + propName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n        );\n    }\n}"
+      },
+      "required": false,
+      "description": ""
+    },
+    "customArrayProp": {
+      "type": {
+        "name": "arrayOf",
+        "value": {
+          "name": "custom",
+          "raw": "function(propValue, key, componentName, location, propFullName) {\n    if (!/matchme/.test(propValue[key])) {\n        return new Error(\n        'Invalid prop `' + propFullName + '` supplied to' +\n        ' `' + componentName + '`. Validation failed.'\n        );\n    }\n}"
+        }
+      },
+      "required": false,
+      "description": ""
+    }
+  }
+}
\ No newline at end of file
diff --git a/tests/development/test_base_component.py b/tests/development/test_base_component.py
index 810fff5e..a0a9d8f5 100644
--- a/tests/development/test_base_component.py
+++ b/tests/development/test_base_component.py
@@ -1,4 +1,10 @@
-from dash.development.base_component import generate_class, Component
+from collections import OrderedDict
+from dash.development.base_component import (
+    generate_class,
+    Component,
+    js_to_py_type,
+    create_docstring
+)
 import dash
 import inspect
 import json
@@ -566,3 +572,147 @@ class TestGenerateClass(unittest.TestCase):
             inspect.getargspec(self.ComponentClass.__init__).defaults,
             (None, )
         )
+
+
+class TestMetaDataConversions(unittest.TestCase):
+    def setUp(self):
+        import collections
+        import json
+        import os
+        path = os.path.join('tests', 'development', 'metadata_test.json')
+        with open(path) as data_file:
+            json_string = data_file.read()
+            data = json\
+                .JSONDecoder(object_pairs_hook=collections.OrderedDict)\
+                .decode(json_string)
+            self.data = data
+
+        self.expected_arg_strings = OrderedDict([
+            ['content', 'a list of or a singular dash component, string or number'],
+
+            ['optionalArray', 'list'],
+
+            ['optionalBool', 'boolean'],
+
+            ['optionalFunc', ''],
+
+            ['optionalNumber', 'number'],
+
+            ['optionalObject', 'dict'],
+
+            ['optionalString', 'string'],
+
+            ['optionalSymbol', ''],
+
+            ['optionalElement', 'dash component'],
+
+            ['optionalNode', 'a list of or a singular dash component, string or number'],
+
+            ['optionalMessage', ''],
+
+            ['optionalEnum', 'a value equal to: \'News\', \'Photos\''],
+
+            ['optionalUnion', 'string | number'],
+
+            ['optionalArrayOf', 'list'],
+
+            ['optionalObjectOf', 'dict with strings as keys and values of type number'],
+
+            ['optionalObjectWithShapeAndNestedDescription', '\n'.join([
+
+                "dict containing keys 'color', 'fontSize', 'figure'.",
+                "Those keys have the following types: ",
+                "  - color (string; optional)",
+                "  - fontSize (number; optional)",
+                "  - figure (optional): Figure is a plotly graph object. figure has the following type: dict containing keys 'data', 'layout'.",
+                "Those keys have the following types: ",
+                "  - data (list; optional): data is a collection of traces",
+                "  - layout (dict; optional): layout describes the rest of the figure"
+
+            ])],
+
+            ['requiredFunc', ''],
+
+            ['requiredAny', 'boolean | number | string | dict | list'],
+
+            ['requiredArray', 'list'],
+
+            ['customProp', ''],
+
+            ['customArrayProp', 'list'],
+        ])
+
+
+    def test_docstring(self):
+        docstring = create_docstring(
+            'MyComponent',
+            self.data['props'],
+            self.data['description'],
+        )
+
+        for i, line in enumerate(docstring.split('\n')):
+            self.assertEqual(
+                line,
+                ([
+                "A MyComponent component.",
+                "This is a description of the component.",
+                "It's multiple lines long.",
+                '',
+                "Keyword arguments:",
+                "- content (a list of or a singular dash component, string or number; optional)",
+                "- optionalArray (list; optional): Description of optionalArray",
+                "- optionalBool (boolean; optional)",
+                "- optionalNumber (number; optional)",
+                "- optionalObject (dict; optional)",
+                "- optionalString (string; optional)",
+
+                "- optionalNode (a list of or a singular dash component, "
+                "string or number; optional)",
+
+                "- optionalElement (dash component; optional)",
+                "- optionalEnum (a value equal to: 'News', 'Photos'; optional)",
+                "- optionalUnion (string | number; optional)",
+                "- optionalArrayOf (list; optional)",
+
+                "- optionalObjectOf (dict with strings as keys and values "
+                "of type number; optional)",
+
+                "- optionalObjectWithShapeAndNestedDescription (optional): . "
+                "optionalObjectWithShapeAndNestedDescription has the "
+                "following type: dict containing keys "
+                "'color', 'fontSize', 'figure'.",
+
+                "Those keys have the following types: ",
+                "  - color (string; optional)",
+                "  - fontSize (number; optional)",
+
+                "  - figure (optional): Figure is a plotly graph object. "
+                "figure has the following type: dict containing "
+                "keys 'data', 'layout'.",
+
+                "Those keys have the following types: ",
+                "  - data (list; optional): data is a collection of traces",
+
+                "  - layout (dict; optional): layout describes "
+                "the rest of the figure",
+
+                "- requiredAny (boolean | number | string | dict | "
+                "list; required)",
+
+                "- requiredArray (list; required)",
+                "- customProp (optional)",
+                "- customArrayProp (list; optional)",
+                "",
+                ""
+                ])[i]
+            )
+
+    def test_docgen_to_python_args(self):
+
+        props = self.data['props']
+
+        for prop_name, prop in props.iteritems():
+            self.assertEqual(
+                js_to_py_type(prop['type']),
+                self.expected_arg_strings[prop_name]
+            )
diff --git a/tests/development/test_component_loader.py b/tests/development/test_component_loader.py
index b5f37ac7..6ce85089 100644
--- a/tests/development/test_component_loader.py
+++ b/tests/development/test_component_loader.py
@@ -20,6 +20,12 @@ METADATA = '''{
                     "computed": false
                 }
             },
+            "content": {
+                "type": {
+                    "name": "object"
+                },
+                "description": "Content - children"
+            },
             "bar": {
                 "type": {
                     "name": "custom"
@@ -84,11 +90,10 @@ class TestLoadComponents(unittest.TestCase):
 
         A = generate_class(
             'A',
-            ('content', 'href',),
             'default_namespace'
         )
 
-        c = load_components(METADATA_PATH, ['content', 'style'])
+        c = load_components(METADATA_PATH)
 
         MyComponentKwargs = {
             'foo': 'Hello World',
diff --git a/tests/package.json b/tests/package.json
new file mode 100644
index 00000000..48a500de
--- /dev/null
+++ b/tests/package.json
@@ -0,0 +1,11 @@
+{
+  "name": "dash_tests",
+  "version": "1.0.0",
+  "description": "Utilities to help with dash tests",
+  "main": "na",
+  "scripts": {
+    "test": "echo \"Error: no test specified\" && exit 1"
+  },
+  "author": "chris@plot.ly",
+  "license": "ISC"
+}

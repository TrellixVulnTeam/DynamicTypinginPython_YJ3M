commit b2226dba94d2fa7df8f7c68a44ea8a2830af652d
Author: chriddyp <chris@plot.ly>
Date:   Sat Mar 4 17:50:45 2017 -0500

    handle callbacks returning arrays

diff --git a/src/actions/index.js b/src/actions/index.js
index 382e3d12..e79682a7 100644
--- a/src/actions/index.js
+++ b/src/actions/index.js
@@ -195,7 +195,6 @@ export const notifyObservers = function(payload) {
                 headers: {'Content-Type': 'application/json'},
                 body: JSON.stringify(body)
             }).then(response => response.json().then(function handleResponse(data) {
-
                 // clear this item from the request queue
                 dispatch(setRequestQueue(
                     reject(
@@ -224,8 +223,10 @@ export const notifyObservers = function(payload) {
                  * paths store.
                  * TODO - Do we need to wait for updateProps to finish?
                  */
-                if (type(observerUpdatePayload.props.content) === 'Object' &&
-                    !isEmpty(observerUpdatePayload.props.content)) {
+                if (contains(
+                        type(observerUpdatePayload.props.content),
+                        ['Array', 'Object']
+                    ) && !isEmpty(observerUpdatePayload.props.content)) {
 
                     dispatch(computePaths({
                         subTree: observerUpdatePayload.props.content,
@@ -249,24 +250,30 @@ export const notifyObservers = function(payload) {
                     crawlLayout(
                         observerUpdatePayload.props.content,
                         function appendIds(child) {
-                            if (hasId(child)) {
+                            if (hasId(child) &&
+                                /*
+                                 * Not all nodes that have IDs
+                                 * are necessarily bound to events
+                                 * TODO - Are we making that assumption anywhere else?
+                                 */
+                                has(child.props.id, EventGraph.nodes)
+                            ) {
                                 newIds.push(child.props.id);
                             }
                         }
                     );
+
                     // TODO - We might need to reset the
                     // request queue here.
                     const depOrder = EventGraph.overallOrder();
-                    const sortedIds = sort(
-                        (a, b) => depOrder.indexOf(a) - depOrder.indexOf(b),
+                    const sortedIds = sort((a, b) => depOrder.indexOf(a) - depOrder.indexOf(b),
                         newIds
-                    );
-
+                    )
                     sortedIds.forEach(function(newId) {
                         dispatch(notifyObservers({
                             event: 'propChange', id: newId
                         }));
-                    })
+                    });
 
                 }
 
diff --git a/src/reducers/paths.js b/src/reducers/paths.js
index eed74b82..6ac4933a 100644
--- a/src/reducers/paths.js
+++ b/src/reducers/paths.js
@@ -8,7 +8,18 @@ const paths = (state = initialPaths, action) => {
     switch (action.type) {
         case 'COMPUTE_PATHS': {
             const {subTree, startingPath} = action.payload;
-            const newState = Object.assign({}, state);
+
+            let newState;
+
+            // if we're updating a subtree, clear out all of the existing items
+            if (!R.isEmpty(startingPath)) {
+                const removeKeys = R.filter(k => (
+                    R.equals(startingPath, R.slice(0, startingPath.length, state[k]))
+                ), R.keys(state));
+                newState = R.omit(removeKeys, state);
+            } else {
+                newState = Object.assign({}, state);
+            }
 
             crawlLayout(subTree, function assignPath(child, itempath) {
                 if(hasId(child)) {
diff --git a/src/reducers/utils.js b/src/reducers/utils.js
index 9feedd61..0dcfbbe7 100644
--- a/src/reducers/utils.js
+++ b/src/reducers/utils.js
@@ -29,6 +29,22 @@ export const crawlLayout = (object, func, path=[]) => {
                 newPath
             );
         }
+    }  else if (R.type(object) === 'Array') {
+
+        /*
+         * Sometimes when we're updating a sub-tree
+         * (like when we're responding to a callback)
+         * that returns `{content: [{...}, {...}]}`
+         * then we'll need to start crawling from
+         * an array instead of an object.
+         */
+
+        object.forEach((child, i) => {
+            crawlLayout(
+                child,
+                func,
+                R.append(i, path));
+        });
 
     }
 }
diff --git a/src/renderTree.js b/src/renderTree.js
index da5fcbed..5ca28ab3 100644
--- a/src/renderTree.js
+++ b/src/renderTree.js
@@ -32,6 +32,7 @@ export default function render(component) {
 
         // One or multiple objects
         // Recursively render the tree
+        // TODO - I think we should pass in `key` here.
         children = (Array.isArray(props.content) ? props.content : [props.content])
                    .map(render);
 
diff --git a/tests/test_render.py b/tests/test_render.py
index e1bc8cef..02f0d8b1 100644
--- a/tests/test_render.py
+++ b/tests/test_render.py
@@ -274,9 +274,7 @@ class Tests(IntegrationTests):
         # things easy to verify.
         self.assertEqual(
             self.driver.execute_script(
-                'return JSON.parse(JSON.stringify('
-                'window.store.getState().paths'
-                '))'
+                'return window.store.getState().paths'
             ),
             {
                 "p.c.3": [
@@ -488,6 +486,298 @@ class Tests(IntegrationTests):
 
         assert_clean_console(self)
 
+    def test_radio_buttons_callbacks_generating_content(self):
+        dash = Dash(__name__)
+        dash.layout = html.Div([
+            html.Link(
+                rel="stylesheet",
+                href="https://unpkg.com/react-select@1.0.0-rc.3/dist/react-select.css"
+            ),
+            dash_core_components.RadioItems(
+                options=[
+                    {'label': 'Chapter 1', 'value': 'chapter1'},
+                    {'label': 'Chapter 2', 'value': 'chapter2'},
+                    {'label': 'Chapter 3', 'value': 'chapter3'}
+                ],
+                value='chapter1',
+                id='toc'
+            ),
+            html.Div(id='body')
+        ])
+
+        chapters = {
+            'chapter1': html.Div([
+                html.H1('Chapter 1', id='chapter1-header'),
+                dash_core_components.Dropdown(
+                    options=[{'label': i, 'value': i} for i in ['NYC', 'MTL', 'SF']],
+                    value='NYC',
+                    id='chapter1-controls'
+                ),
+                html.Label(id='chapter1-label'),
+                dash_core_components.Graph(id='chapter1-graph')
+            ]),
+            # Chapter 2 has the some of the same components in the same order
+            # as Chapter 1. This means that they won't get remounted
+            # unless they set their own keys are differently.
+            # Switching back and forth between 1 and 2 implicitly
+            # tests how components update when they aren't remounted.
+            'chapter2': html.Div([
+                html.H1('Chapter 2', id='chapter2-header'),
+                dash_core_components.RadioItems(
+                    options=[{'label': i, 'value': i}
+                             for i in ['USA', 'Canada']],
+                    value='USA',
+                    id='chapter2-controls'
+                ),
+                html.Label(id='chapter2-label'),
+                dash_core_components.Graph(id='chapter2-graph')
+            ]),
+            # Chapter 3 has a different layout and so the components
+            # should get rewritten
+            'chapter3': [html.Div(
+                html.Div([
+                    html.H3('Chapter 3', id='chapter3-header'),
+                    html.Label(id='chapter3-label'),
+                    dash_core_components.Graph(id='chapter3-graph'),
+                    dash_core_components.RadioItems(
+                        options=[{'label': i, 'value': i}
+                                 for i in ['Summer', 'Winter']],
+                        value='Winter',
+                        id='chapter3-controls'
+                    )
+                ])
+            )]
+        }
+
+        call_counts = {
+            'body': Value('i', 0),
+            'chapter1-graph': Value('i', 0),
+            'chapter1-label': Value('i', 0),
+            'chapter2-graph': Value('i', 0),
+            'chapter2-label': Value('i', 0),
+            'chapter3-graph': Value('i', 0),
+            'chapter3-label': Value('i', 0)
+        }
+
+        @dash.react('body', ['toc'])
+        def display_chapter(toc):
+            call_counts['body'].value += 1
+            return {
+                'content': chapters[toc['value']]
+            }
+
+        def generate_graph_callback(counterId):
+            def callback(options):
+                call_counts[counterId].value += 1
+                return {
+                    'figure': {
+                        'data': [{
+                            'x': ['Call Counter'],
+                            'y': [call_counts[counterId].value],
+                            'type': 'bar'
+                        }],
+                        'layout': {'title': options['value']}
+                    }
+                }
+            return callback
+
+        def generate_label_callback(id):
+            def update_label(options):
+                call_counts[id].value += 1
+                return {'content': options['value']}
+            return update_label
+
+        for chapter in ['chapter1', 'chapter2', 'chapter3']:
+            dash.react(
+                '{}-graph'.format(chapter),
+                ['{}-controls'.format(chapter)]
+            )(generate_graph_callback('{}-graph'.format(chapter)))
+
+            dash.react(
+                '{}-label'.format(chapter),
+                ['{}-controls'.format(chapter)]
+            )(generate_label_callback('{}-label'.format(chapter)))
+
+
+        self.startServer(dash)
+        # import ipdb; ipdb.set_trace()
+        wait_for(lambda: call_counts['body'].value == 1)
+        wait_for(lambda: call_counts['chapter1-graph'].value == 1)
+        wait_for(lambda: call_counts['chapter1-label'].value == 1)
+        self.assertEqual(call_counts['chapter2-graph'].value, 0)
+        self.assertEqual(call_counts['chapter2-label'].value, 0)
+        self.assertEqual(call_counts['chapter3-graph'].value, 0)
+        self.assertEqual(call_counts['chapter3-label'].value, 0)
+
+        def generic_chapter_assertions(chapter):
+            # each element should exist in the dom
+            paths = self.driver.execute_script(
+                'return window.store.getState().paths'
+            )
+            for key in paths:
+                self.driver.find_element_by_id(key)
+
+            if chapter == 'chapter3':
+                value = chapters[chapter][0][
+                    '{}-controls'.format(chapter)
+                ].value
+            else:
+                value = chapters[chapter]['{}-controls'.format(chapter)].value
+            # check the actual values
+            wait_for(
+                lambda: (
+                    self.driver.find_element_by_id(
+                        '{}-label'.format(chapter)
+                    ).text
+                    == value
+                )
+            )
+            wait_for(
+                lambda: (
+                    self.driver.execute_script(
+                        'return document.'
+                        'getElementById("{}-graph").'.format(chapter) +
+                        'layout.title'
+                    ) == value
+                )
+            )
+
+        def chapter1_assertions():
+            paths = self.driver.execute_script(
+                'return window.store.getState().paths'
+            )
+            self.assertEqual(paths, {
+                'toc': ['props', 'content', 1],
+                'body': ['props', 'content', 2],
+                'chapter1-header': [
+                    'props', 'content', 2,
+                    'props', 'content',
+                    'props', 'content', 0
+                ],
+                'chapter1-controls': [
+                    'props', 'content', 2,
+                    'props', 'content',
+                    'props', 'content', 1
+                ],
+                'chapter1-label': [
+                    'props', 'content', 2,
+                    'props', 'content',
+                    'props', 'content', 2
+                ],
+                'chapter1-graph': [
+                    'props', 'content', 2,
+                    'props', 'content',
+                    'props', 'content', 3
+                ]
+            })
+            generic_chapter_assertions('chapter1')
+
+        chapter1_assertions()
+
+        # switch chapters
+        (self.driver.find_elements_by_css_selector(
+            'input[type="radio"]'
+        )[1]).click()
+
+        # sleep just to make sure that no calls happen after our check
+        time.sleep(2)
+        wait_for(lambda: call_counts['body'].value == 2)
+        wait_for(lambda: call_counts['chapter2-graph'].value == 1)
+        wait_for(lambda: call_counts['chapter2-label'].value == 1)
+        self.assertEqual(call_counts['chapter1-graph'].value, 1)
+        self.assertEqual(call_counts['chapter1-label'].value, 1)
+
+        def chapter2_assertions():
+            paths = self.driver.execute_script(
+                'return window.store.getState().paths'
+            )
+            self.assertEqual(paths, {
+                'toc': ['props', 'content', 1],
+                'body': ['props', 'content', 2],
+                'chapter2-header': [
+                    'props', 'content', 2,
+                    'props', 'content',
+                    'props', 'content', 0
+                ],
+                'chapter2-controls': [
+                    'props', 'content', 2,
+                    'props', 'content',
+                    'props', 'content', 1
+                ],
+                'chapter2-label': [
+                    'props', 'content', 2,
+                    'props', 'content',
+                    'props', 'content', 2
+                ],
+                'chapter2-graph': [
+                    'props', 'content', 2,
+                    'props', 'content',
+                    'props', 'content', 3
+                ]
+            })
+            generic_chapter_assertions('chapter2')
+
+        chapter2_assertions()
+
+        # switch to 3
+        (self.driver.find_elements_by_css_selector(
+            'input[type="radio"]'
+        )[2]).click()
+        # sleep just to make sure that no calls happen after our check
+        time.sleep(2)
+        wait_for(lambda: call_counts['body'].value == 3)
+        wait_for(lambda: call_counts['chapter3-graph'].value == 1)
+        wait_for(lambda: call_counts['chapter3-label'].value == 1)
+        self.assertEqual(call_counts['chapter2-graph'].value, 1)
+        self.assertEqual(call_counts['chapter2-label'].value, 1)
+        self.assertEqual(call_counts['chapter1-graph'].value, 1)
+        self.assertEqual(call_counts['chapter1-label'].value, 1)
+
+        def chapter3_assertions():
+            paths = self.driver.execute_script(
+                'return window.store.getState().paths'
+            )
+            self.assertEqual(paths, {
+                'toc': ['props', 'content', 1],
+                'body': ['props', 'content', 2],
+                'chapter3-header': [
+                    'props', 'content', 2,
+                    'props', 'content', 0,
+                    'props', 'content',
+                    'props', 'content', 0
+                ],
+                'chapter3-label': [
+                    'props', 'content', 2,
+                    'props', 'content', 0,
+                    'props', 'content',
+                    'props', 'content', 1
+                ],
+                'chapter3-graph': [
+                    'props', 'content', 2,
+                    'props', 'content', 0,
+                    'props', 'content',
+                    'props', 'content', 2
+                ],
+                'chapter3-controls': [
+                    'props', 'content', 2,
+                    'props', 'content', 0,
+                    'props', 'content',
+                    'props', 'content', 3
+                ]
+            })
+            generic_chapter_assertions('chapter3')
+
+        chapter3_assertions()
+
+        # switch back to 1
+        (self.driver.find_elements_by_css_selector(
+            'input[type="radio"]'
+        )[0]).click()
+        chapter1_assertions()
+
+        ## HEY!!! WELCOME BACK!!
+        # TODO - ADD A CHAPTER THAT IS JUST A STRING!
+
     def test_dependencies_on_components_that_dont_exist(self):
         dash = Dash(__name__)
         dash.layout = html.Div([

commit e2e3566d99a3d4e58325e6cfc6e9708d33d4ee69
Author: alexcjohnson <alex@plot.ly>
Date:   Wed Oct 23 10:06:44 2019 -0400

    remove obsolete pre-multi-output fallback from dependencyGraph.js

diff --git a/dash-renderer/src/reducers/dependencyGraph.js b/dash-renderer/src/reducers/dependencyGraph.js
index 77063322..4278e09c 100644
--- a/dash-renderer/src/reducers/dependencyGraph.js
+++ b/dash-renderer/src/reducers/dependencyGraph.js
@@ -1,4 +1,3 @@
-import {type} from 'ramda';
 import {DepGraph} from 'dependency-graph';
 import {isMultiOutputProp, parseMultipleOutputs} from '../utils';
 
@@ -13,43 +12,35 @@ const graphs = (state = initialGraph, action) => {
         dependencies.forEach(function registerDependency(dependency) {
             const {output, inputs} = dependency;
 
-            // Multi output supported will be a string already
-            // Backward compatibility by detecting object.
-            let outputId;
-            if (type(output) === 'Object') {
-                outputId = `${output.id}.${output.property}`;
-            } else {
-                outputId = output;
-                if (isMultiOutputProp(output)) {
-                    parseMultipleOutputs(output).forEach(out => {
-                        multiGraph.addNode(out);
-                        inputs.forEach(i => {
-                            const inputId = `${i.id}.${i.property}`;
-                            if (!multiGraph.hasNode(inputId)) {
-                                multiGraph.addNode(inputId);
-                            }
-                            multiGraph.addDependency(inputId, out);
-                        });
-                    });
-                } else {
-                    multiGraph.addNode(output);
+            if (isMultiOutputProp(output)) {
+                parseMultipleOutputs(output).forEach(out => {
+                    multiGraph.addNode(out);
                     inputs.forEach(i => {
                         const inputId = `${i.id}.${i.property}`;
                         if (!multiGraph.hasNode(inputId)) {
                             multiGraph.addNode(inputId);
                         }
-                        multiGraph.addDependency(inputId, output);
+                        multiGraph.addDependency(inputId, out);
                     });
-                }
+                });
+            } else {
+                multiGraph.addNode(output);
+                inputs.forEach(i => {
+                    const inputId = `${i.id}.${i.property}`;
+                    if (!multiGraph.hasNode(inputId)) {
+                        multiGraph.addNode(inputId);
+                    }
+                    multiGraph.addDependency(inputId, output);
+                });
             }
 
             inputs.forEach(inputObject => {
                 const inputId = `${inputObject.id}.${inputObject.property}`;
-                inputGraph.addNode(outputId);
+                inputGraph.addNode(output);
                 if (!inputGraph.hasNode(inputId)) {
                     inputGraph.addNode(inputId);
                 }
-                inputGraph.addDependency(inputId, outputId);
+                inputGraph.addDependency(inputId, output);
             });
         });
 

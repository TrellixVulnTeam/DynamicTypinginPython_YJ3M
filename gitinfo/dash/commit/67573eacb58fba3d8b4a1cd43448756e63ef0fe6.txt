commit 67573eacb58fba3d8b4a1cd43448756e63ef0fe6
Author: chriddyp <chris@plot.ly>
Date:   Tue Apr 4 00:06:12 2017 -0400

    first pass at undo/redo, saved states, and named urls

diff --git a/src/TreeContainer.react.js b/src/TreeContainer.react.js
index 32836eda..980ff9bf 100644
--- a/src/TreeContainer.react.js
+++ b/src/TreeContainer.react.js
@@ -1,20 +1,28 @@
-import { connect } from 'react-redux'
-import { contains, isEmpty, isNil } from 'ramda'
+/* global window: true */
+import {connect} from 'react-redux'
+import {contains, isEmpty, isNil} from 'ramda'
 import React, {Component, PropTypes} from 'react';
 import renderTree from './renderTree';
 import {
-    hydrateInitialOutputs,
     computeGraphs,
     computePaths,
+    hydrateInitialOutputs,
+    loadStateFromRoute,
     setLayout
 } from './actions/index';
-import {getLayout, getDependencies} from './actions/api';
-import {APP_STATES} from './reducers/appLifecycle';
+import {getLayout, getDependencies, getRoutes} from './actions/api';
+import {APP_STATES} from './reducers/constants';
+
 
 /**
  * Fire off API calls for initialization
  */
 class UnconnectedContainer extends Component {
+    constructor(props) {
+        super(props);
+        this.initialization = this.initialization.bind(this);
+        this.handleHistory = this.handleHistory.bind(this);
+    }
     componentDidMount() {
         this.initialization(this.props);
     }
@@ -31,7 +39,8 @@ class UnconnectedContainer extends Component {
             graphs,
             layout,
             layoutRequest,
-            paths
+            paths,
+            routesRequest
         } = props;
         if (isEmpty(layoutRequest)) {
             dispatch(getLayout());
@@ -45,11 +54,28 @@ class UnconnectedContainer extends Component {
 
         if (isEmpty(dependenciesRequest)) {
             dispatch(getDependencies());
-        } else if (dependenciesRequest.status === 200) {
-            if (isEmpty(graphs)) {
-                dispatch(computeGraphs(dependenciesRequest.content));
-            } else if (appLifecycle === APP_STATES('STARTED')) {
-                dispatch(hydrateInitialOutputs());
+        } else if (dependenciesRequest.status === 200 && isEmpty(graphs)) {
+            dispatch(computeGraphs(dependenciesRequest.content));
+        }
+
+        if (isEmpty(routesRequest)) {
+            dispatch(getRoutes());
+        }
+
+        if (dependenciesRequest.status === 200 &&
+            !isEmpty(graphs) &&
+            routesRequest.status === 200 &&
+            appLifecycle === APP_STATES('STARTED')
+        ) {
+            dispatch(hydrateInitialOutputs());
+            this.handleHistory();
+        }
+    }
+
+    handleHistory() {
+        window.onpopstate = () => {
+            if (this.props.routesRequest.status === 200) {
+                this.props.dispatch(loadStateFromRoute());
             }
         }
     }
@@ -59,7 +85,7 @@ class UnconnectedContainer extends Component {
             appLifecycle,
             dependenciesRequest,
             layoutRequest,
-            layout
+            layout,
         } = this.props;
         if (layoutRequest.status &&
             !contains(layoutRequest.status, [200, 'loading'])
@@ -70,11 +96,8 @@ class UnconnectedContainer extends Component {
             !contains(dependenciesRequest.status, [200, 'loading'])
         ) {
             return (<div>{'Error loading dependencies'}</div>);
-        } else if (appLifecycle === APP_STATES('INITIALIZED')) {
-            return renderTree(
-                layout,
-                dependenciesRequest.content
-            );
+        } else if (appLifecycle === APP_STATES('HYDRATED')) {
+            return renderTree(layout, dependenciesRequest.content);
         } else {
             return (<div>{'Loading...'}</div>);
         }
@@ -83,13 +106,15 @@ class UnconnectedContainer extends Component {
 UnconnectedContainer.propTypes = {
     appLifecycle: PropTypes.oneOf([
         APP_STATES('STARTED'),
-        APP_STATES('INITIALIZED')
+        APP_STATES('HYDRATED')
     ]),
     dispatch: PropTypes.function,
     dependenciesRequest: PropTypes.object,
+    routesRequest: PropTypes.object,
     layoutRequest: PropTypes.object,
     layout: PropTypes.object,
-    paths: PropTypes.object
+    paths: PropTypes.object,
+    history: PropTypes.array
 }
 
 const Container = connect(
@@ -98,9 +123,11 @@ const Container = connect(
         appLifecycle: state.appLifecycle,
         layoutRequest: state.layoutRequest,
         dependenciesRequest: state.dependenciesRequest,
+        routesRequest: state.routesRequest,
         layout: state.layout,
         graphs: state.graphs,
-        paths: state.paths
+        paths: state.paths,
+        history: state.history
     }),
     dispatch => ({dispatch})
 )(UnconnectedContainer);
diff --git a/src/actions/api.js b/src/actions/api.js
index 2dcad1ca..de2b76d1 100644
--- a/src/actions/api.js
+++ b/src/actions/api.js
@@ -75,3 +75,11 @@ export function getDependencies() {
         'dependenciesRequest'
     )
 }
+
+export function getRoutes() {
+    return apiThunk(
+        '/routes',
+        'GET',
+        'routesRequest'
+    )
+}
diff --git a/src/actions/constants.js b/src/actions/constants.js
new file mode 100644
index 00000000..b2840fd6
--- /dev/null
+++ b/src/actions/constants.js
@@ -0,0 +1,12 @@
+export const ACTIONS = (action) => {
+    const actionList = {
+        ON_PROP_CHANGE: 'ON_PROP_CHANGE',
+        SET_REQUEST_QUEUE: 'SET_REQUEST_QUEUE',
+        COMPUTE_GRAPHS: 'COMPUTE_GRAPHS',
+        COMPUTE_PATHS: 'COMPUTE_PATHS',
+        SET_LAYOUT: 'SET_LAYOUT',
+        SET_APP_LIFECYCLE: 'SET_APP_LIFECYCLE'
+    };
+    if (actionList[action]) return actionList[action];
+    else throw new Error(`${action} is not defined.`)
+};
diff --git a/src/actions/index.js b/src/actions/index.js
index 1af7ab12..cbdf1604 100644
--- a/src/actions/index.js
+++ b/src/actions/index.js
@@ -1,4 +1,4 @@
-/* global fetch:true */
+/* global fetch:true, window:true, Promise:true */
 import {
     concat,
     contains,
@@ -7,6 +7,7 @@ import {
     isEmpty,
     keys,
     lensPath,
+    pluck,
     reject,
     sort,
     type,
@@ -15,19 +16,8 @@ import {
 } from 'ramda';
 import {createAction} from 'redux-actions';
 import {crawlLayout, hasId} from '../reducers/utils';
-
-export const ACTIONS = (action) => {
-    const actionList = {
-        ON_PROP_CHANGE: 'ON_PROP_CHANGE',
-        SET_REQUEST_QUEUE: 'SET_REQUEST_QUEUE',
-        COMPUTE_GRAPHS: 'COMPUTE_GRAPHS',
-        COMPUTE_PATHS: 'COMPUTE_PATHS',
-        SET_LAYOUT: 'SET_LAYOUT',
-        SET_APP_LIFECYCLE: 'SET_APP_LIFECYCLE'
-    };
-    if (actionList[action]) return actionList[action];
-    else throw new Error(`${action} is not defined.`)
-};
+import {APP_STATES} from '../reducers/constants';
+import {ACTIONS} from './constants';
 
 export const updateProps = createAction(ACTIONS('ON_PROP_CHANGE'));
 export const setRequestQueue = createAction(ACTIONS('SET_REQUEST_QUEUE'));
@@ -38,44 +28,243 @@ export const setAppLifecycle = createAction(ACTIONS('SET_APP_LIFECYCLE'));
 
 export const hydrateInitialOutputs = function() {
     return function (dispatch, getState) {
-        const {graphs} = getState();
-        const {InputGraph} = graphs;
-        const allNodes = InputGraph.overallOrder();
-        allNodes.reverse();
-        allNodes.forEach(nodeId => {
-            const [componentId, componentProp] = nodeId.split('.');
+        const {routesRequest} = getState();
+        if (!isEmpty(routesRequest.content) &&
+            contains(
+                window.location.pathname,
+                pluck('pathname', routesRequest.content)
+            )
+        ) {
+            loadStateFromRoute()(dispatch, getState);
+        } else {
+            triggerDefaultState(dispatch, getState);
+        }
+        dispatch(setAppLifecycle(APP_STATES('HYDRATED')));
+    }
+};
+
+export function loadStateFromRoute() {
+    return (dispatch, getState) => {
+        const {routesRequest} = getState();
+        const routes = routesRequest.content;
+        const route = routes.find(route => (
+            route.pathname === window.location.pathname
+        ));
+        const initialState = route.state;
+        loadSavedState(initialState)(dispatch, getState)
+    }
+}
+
+function loadSavedState(initialControls) {
+    return (dispatch, getState) => {
+        function recursivelyTriggerInputs(skipTheseInputs) {
+            const {
+                promises,
+                visibleInputsThatWereTriggered
+            } = loadSavedStateAndTriggerVisibleInputs(
+                dispatch, getState, skipTheseInputs, initialControls
+            );
+            if (promises.length === 0) {
+                return;
+            } else {
+                Promise.all(promises).then(function() {
+                    recursivelyTriggerInputs(union(
+                        skipTheseInputs,
+                        visibleInputsThatWereTriggered
+                    ));
+                });
+            }
+        }
+
+        recursivelyTriggerInputs([]);
+    }
+}
+
+function loadSavedStateAndTriggerVisibleInputs(dispatch, getState, skipTheseInputs, initialControls) {
+    const updatedInputs = [];
+    const {paths} = getState();
+
+    keys(initialControls).forEach((nodeId) => {
+        const [componentId, componentProp] = nodeId.split('.');
+
+        /*
+         * Don't update invisible inputs - they'll become visible
+         * as a result of a separate input on a later cycle
+         */
+        if (!(has(componentId, paths))) {
+            return;
+        }
+
+        // Some input nodes have already been updated in a previous cycle
+        if (contains(nodeId, skipTheseInputs)) {
+            return;
+        }
+
+        const payload = {
+            itempath: paths[componentId],
+            props: {[componentProp]: initialControls[nodeId]}
+        }
+        dispatch(updateProps(payload));
+        updatedInputs.push(nodeId);
+    });
+
+    const {graphs} = getState();
+    const InputGraph = graphs.InputGraph
+    const triggeredInputs = [];
+    const promises = [];
 
+    // Trigger an update for each of the output nodes
+    keys(InputGraph.nodes).forEach(nodeId => {
+        if (InputGraph.dependenciesOf(nodeId).length === 0) {
             /*
-             * Filter out the outputs,
-             * inputs that aren't leaves,
-             * and the invisible inputs
+             * If the output has more than one input, then just
+             * trigger an update on one of the updates.
+             * All of the inputs are already updated, so we don't
+             * need to trigger it more than once.
              */
-            if (InputGraph.dependenciesOf(nodeId).length > 0 &&
-                InputGraph.dependantsOf(nodeId).length == 0 &&
-                has(componentId, getState().paths)
-            ) {
-
-                // Get the initial property
-                const propLens = lensPath(
-                    concat(getState().paths[componentId],
-                    ['props', componentProp]
-                ));
-                const propValue = view(
-                    propLens,
-                    getState().layout
-                );
+            const anInputNode = InputGraph.dependantsOf(nodeId)[0];
 
-                dispatch(notifyObservers({
-                    id: componentId,
-                    props: {[componentProp]: propValue}
-                }));
+            /*
+             * It's possible that this output has already been updated
+             * by a different output that shared the same input
+             */
+            if (contains(anInputNode, triggeredInputs)) {
+                return;
+            }
 
+            const [anInputId, anInputProp] = anInputNode.split('.');
+
+            /*
+             * Don't update invisible inputs - they'll become visible
+             * as a result of a separate input on a later cycle
+             */
+            if (!(has(anInputId, getState().paths))) {
+                return;
             }
-        });
-        dispatch(setAppLifecycle('INITIALIZED'));
+
+            // Some input nodes have already been updated in a previous cycle
+            if (contains(anInputNode, skipTheseInputs)) {
+                return;
+            }
+
+            const propLens = lensPath(
+                concat(getState().paths[anInputId],
+                ['props', anInputProp]
+            ));
+            const propValue = view(
+                propLens,
+                getState().layout
+            );
+
+            /*
+             * We only want to update the nodes that aren't inputs -
+             * the input nodes have already been updated by the
+             * setProps action above
+             * (since the value of the inputs was saved)
+             */
+             const dontUpdateInputObservers = true;
+
+            promises.push(dispatch(notifyObservers({
+                id: anInputId,
+                props: {
+                    [anInputProp]: propValue
+                },
+                dontUpdateInputObservers
+            })));
+            triggeredInputs.push(anInputNode);
+        }
+    });
+
+    return {
+        promises,
+
+        // TODO - Do I really need to take the union?
+        // Isn't triggeredInputs just a subset of updatedInputs?
+        visibleInputsThatWereTriggered: union(triggeredInputs, updatedInputs)
+    };
+}
+
+function triggerDefaultState(dispatch, getState) {
+    const {graphs} = getState();
+    const {InputGraph} = graphs;
+    const allNodes = InputGraph.overallOrder();
+    allNodes.reverse();
+    allNodes.forEach(nodeId => {
+        const [componentId, componentProp] = nodeId.split('.');
+
+        /*
+         * Filter out the outputs,
+         * inputs that aren't leaves,
+         * and the invisible inputs
+         */
+        if (InputGraph.dependenciesOf(nodeId).length > 0 &&
+            InputGraph.dependantsOf(nodeId).length == 0 &&
+            has(componentId, getState().paths)
+        ) {
+
+            // Get the initial property
+            const propLens = lensPath(
+                concat(getState().paths[componentId],
+                ['props', componentProp]
+            ));
+            const propValue = view(
+                propLens,
+                getState().layout
+            );
+
+            dispatch(notifyObservers({
+                id: componentId,
+                props: {[componentProp]: propValue}
+            }));
+
+        }
+    });
+}
+
+export function redo() {
+    return function (dispatch, getState) {
+        const history = getState().history;
+        dispatch(createAction('REDO')());
+        const next = history.future[0];
+
+        // Update props
+        dispatch(createAction('REDO_PROP_CHANGE')({
+            itempath: getState().paths[next.id],
+            props: next.props
+        }));
+
+        // Notify observers
+        dispatch(notifyObservers({
+            id: next.id,
+            props: next.props
+        }));
+    }
+}
+
+
+export function undo() {
+    return function (dispatch, getState) {
+        const history = getState().history;
+        dispatch(createAction('UNDO')());
+        const previous = history.past[history.past.length - 1];
+
+        // Update props
+        dispatch(createAction('UNDO_PROP_CHANGE')({
+            itempath: getState().paths[previous.id],
+            props: previous.props
+        }));
+
+        // Notify observers
+        dispatch(notifyObservers({
+            id: previous.id,
+            props: previous.props
+        }));
     }
 }
 
+
+
+
 export const notifyObservers = function(payload) {
     return function (dispatch, getState) {
         const {
@@ -84,6 +273,11 @@ export const notifyObservers = function(payload) {
             props
         } = payload
 
+        const dontUpdateInputObservers = (
+            has('dontUpdateInputObservers', payload) ?
+            payload.dontUpdateInputObservers : false
+        );
+
         const {
             layout,
             graphs,
@@ -107,9 +301,17 @@ export const notifyObservers = function(payload) {
             const changedProps = keys(props);
             outputObservers = [];
             changedProps.forEach(propName => {
-                InputGraph.dependenciesOf(`${id}.${propName}`).forEach(outputId =>
-                    outputObservers.push(outputId)
-                );
+                InputGraph.dependenciesOf(`${id}.${propName}`).forEach(outputId => {
+                    if (dontUpdateInputObservers) {
+                        // Only update output elements
+                        if (InputGraph.dependenciesOf(outputId).length === 0) {
+                            outputObservers.push(outputId);
+                        }
+                    } else {
+                        outputObservers.push(outputId);
+                    }
+
+                });
             });
         }
 
@@ -178,7 +380,7 @@ export const notifyObservers = function(payload) {
          * action
          */
         dispatch(setRequestQueue(union(queuedObservers, requestQueue)));
-
+        const promises = [];
         for (let i = 0; i < queuedObservers.length; i++) {
             const outputIdAndProp = queuedObservers[i];
             const [outputComponentId, outputProp] = outputIdAndProp.split('.');
@@ -240,7 +442,9 @@ export const notifyObservers = function(payload) {
                 });
             }
 
-            fetch('/update-component', {
+
+
+            promises.push(fetch('/update-component', {
                 method: 'POST',
                 headers: {'Content-Type': 'application/json'},
                 body: JSON.stringify(payload)
@@ -269,7 +473,8 @@ export const notifyObservers = function(payload) {
                 const observerUpdatePayload = {
                     itempath: getState().paths[outputComponentId],
                     // new prop from the server
-                    props: data.response.props
+                    props: data.response.props,
+                    source: 'response'
                 };
                 dispatch(updateProps(observerUpdatePayload));
 
@@ -324,7 +529,8 @@ export const notifyObservers = function(payload) {
                                                 id: child.props.id,
                                                 props: {
                                                     [childProp]: child.props[childProp]
-                                                }
+                                                },
+                                                dontUpdateInputObservers
                                             });
                                         }
                                     })
@@ -337,16 +543,52 @@ export const notifyObservers = function(payload) {
                             depOrder.indexOf(a.id) - depOrder.indexOf(b.id),
                             newProps
                         )
-                        sortedNewProps.forEach(function(propUpdate) {
-                            dispatch(notifyObservers(propUpdate));
-                        });
-
+                        if (!dontUpdateInputObservers) {
+                            sortedNewProps.forEach(function(propUpdate) {
+                                dispatch(notifyObservers(propUpdate));
+                            });
+                        }
                     }
-                }
 
 
-            }));
+                }
+
+            })));
 
         }
+
+        return Promise.all(promises);
     }
 }
+
+export function serialize(state) {
+    // Record minimal input state in the url
+    const {graphs, paths, layout} = state;
+    const {InputGraph} = graphs;
+    const allNodes = InputGraph.nodes;
+    const savedState = {};
+    keys(allNodes).forEach(nodeId => {
+        const [componentId, componentProp] = nodeId.split('.');
+        /*
+         * Filter out the outputs,
+         * and the invisible inputs
+         */
+        if (InputGraph.dependenciesOf(nodeId).length > 0 &&
+            has(componentId, paths)
+        ) {
+            // Get the property
+            const propLens = lensPath(
+                concat(paths[componentId],
+                ['props', componentProp]
+            ));
+            const propValue = view(
+                propLens,
+                layout
+            );
+            savedState[nodeId] = propValue;
+        }
+    });
+
+    return savedState;
+
+}
diff --git a/src/components/core/Toolbar.react.js b/src/components/core/Toolbar.react.js
new file mode 100644
index 00000000..28c82f3d
--- /dev/null
+++ b/src/components/core/Toolbar.react.js
@@ -0,0 +1,99 @@
+import {connect} from 'react-redux';
+import React, {PropTypes} from 'react';
+import {merge} from 'ramda';
+import {redo, undo} from '../../actions/index.js';
+import Radium from 'radium';
+
+
+function UnconnectedToolbar(props) {
+    const {dispatch, history} = props;
+    const styles={
+        parentSpanStyle: {
+            display: 'inline-block'
+        },
+        iconStyle: {
+            fontSize: 20
+        },
+        labelStyle: {
+            fontSize: 15
+        }
+    }
+
+    const undoLink = (
+        <span
+            style={merge({
+                'color': history.past.length ? '#0074D9' : 'grey',
+                'cursor': history.past.length ? 'pointer' : 'default'
+            }, styles.parentSpanStyle)}
+            onClick={() => dispatch(undo())}
+        >
+            <div style={merge(
+                {transform: 'rotate(270deg)'},
+                styles.iconStyle
+            )}>
+                {'↺'}
+            </div>
+            <div style={styles.labelStyle}>
+                undo
+            </div>
+        </span>
+    );
+
+    const redoLink = (
+        <span
+            style={merge({
+                'color': history.future.length ? '#0074D9' : 'grey',
+                'cursor': history.future.length ? 'pointer' : 'default',
+                'marginLeft': 10
+            }, styles.parentSpanStyle)}
+            onClick={() => dispatch(redo())}
+        >
+        <div style={merge(
+            {transform: 'rotate(90deg)'},
+            styles.iconStyle
+        )}>
+                {'↻'}
+            </div>
+            <div style={styles.labelStyle}>
+                redo
+            </div>
+        </span>
+    );
+
+    return (
+        <div style={{
+            'position': 'fixed',
+            'bottom': '30px',
+            'left': '30px',
+            'fontSize': '20px',
+            'textAlign': 'center',
+            'zIndex': '9999',
+            'backgroundColor': 'rgba(255, 255, 255, 0.9)',
+            'opacity': '0.2',
+            ':hover': {
+                'opacity': 1
+            }
+        }}>
+            <div style={{
+                'position': 'relative'
+            }}>
+                {history.past.length > 0 ? undoLink : null}
+                {history.future.length > 0 ? redoLink : null}
+            </div>
+        </div>
+    );
+}
+
+UnconnectedToolbar.propTypes = {
+    history: PropTypes.object,
+    dispatch: PropTypes.function
+};
+
+const Toolbar = connect(
+    state => ({
+        history: state.history
+    }),
+    dispatch => ({dispatch})
+)(Radium(UnconnectedToolbar));
+
+export default Toolbar;
diff --git a/src/reducers/api.js b/src/reducers/api.js
index cbeaf278..dbef7647 100644
--- a/src/reducers/api.js
+++ b/src/reducers/api.js
@@ -28,3 +28,4 @@ function createApiReducer(store) {
 
 export const layoutRequest = createApiReducer('layoutRequest');
 export const dependenciesRequest = createApiReducer('dependenciesRequest');
+export const routesRequest = createApiReducer('routesRequest');
diff --git a/src/reducers/appLifecycle.js b/src/reducers/appLifecycle.js
index df7c10f7..190a3734 100644
--- a/src/reducers/appLifecycle.js
+++ b/src/reducers/appLifecycle.js
@@ -1,13 +1,5 @@
-import {ACTIONS} from '../actions/index.js';
-
-export function APP_STATES(state) {
-    const stateList = {
-        'STARTED': 'STARTED',
-        'INITIALIZED': 'INITIALIZED'
-    }
-    if (stateList[state]) return stateList[state];
-    else throw new Error (`${state} is not a valid app state.`);
-}
+import {ACTIONS} from '../actions/constants';
+import {APP_STATES} from './constants';
 
 function appLifecycle(state=APP_STATES('STARTED'), action) {
     switch (action.type) {
diff --git a/src/reducers/constants.js b/src/reducers/constants.js
new file mode 100644
index 00000000..78aa7adc
--- /dev/null
+++ b/src/reducers/constants.js
@@ -0,0 +1,8 @@
+export function APP_STATES(state) {
+    const stateList = {
+        'STARTED': 'STARTED',
+        'HYDRATED': 'HYDRATED'
+    }
+    if (stateList[state]) return stateList[state];
+    else throw new Error (`${state} is not a valid app state.`);
+}
diff --git a/src/reducers/history.js b/src/reducers/history.js
new file mode 100644
index 00000000..27bd96b9
--- /dev/null
+++ b/src/reducers/history.js
@@ -0,0 +1,40 @@
+const initialHistory = {
+    past: [],
+    present: {},
+    future: []
+};
+
+function history (state = initialHistory, action) {
+    switch (action.type) {
+
+        case 'UNDO': {
+            const {past, present, future} = state;
+            const previous = past[past.length - 1];
+            const newPast = past.slice(0, past.length - 1);
+            return {
+                past: newPast,
+                present: previous,
+                future: [ present, ...future ]
+            };
+        }
+
+        case 'REDO': {
+            const {past, present, future} = state;
+            const next = future[0];
+            const newFuture = future.slice(1);
+            return {
+                past: [...past, present],
+                present: next,
+                future: newFuture
+            };
+        }
+
+        default: {
+            return state;
+        }
+
+    }
+}
+
+
+export default history;
diff --git a/src/reducers/layout.js b/src/reducers/layout.js
index 7ab564b9..a9266e9d 100644
--- a/src/reducers/layout.js
+++ b/src/reducers/layout.js
@@ -1,25 +1,26 @@
-import {append, assocPath, lensPath, merge, view} from 'ramda';
+import {append, assocPath, contains, lensPath, merge, view} from 'ramda';
 
-// TODO: this should be a prop of the high-level component
-import {ACTIONS} from '../actions';
+import {ACTIONS} from '../actions/constants';
 
 const layout = (state = {}, action) => {
-    switch (action.type) {
-
-        case ACTIONS('SET_LAYOUT'):
-            return action.payload;
-
-        // Update the props of the component
-        case ACTIONS('ON_PROP_CHANGE'): {
-            let propPath = append('props', action.payload.itempath);
-            const existingProps = view(lensPath(propPath), state);
-            const mergedProps = merge(existingProps, action.payload.props);
-            state = assocPath(propPath, mergedProps, state);
-            return state;
-        }
-
-        default:
-            return state;
+    if (action.type === ACTIONS('SET_LAYOUT')) {
+
+        return action.payload;
+
+    } else if (contains(
+        action.type,
+        ['UNDO_PROP_CHANGE', 'REDO_PROP_CHANGE', ACTIONS('ON_PROP_CHANGE')]
+    )) {
+
+        let propPath = append('props', action.payload.itempath);
+        const existingProps = view(lensPath(propPath), state);
+        const mergedProps = merge(existingProps, action.payload.props);
+        state = assocPath(propPath, mergedProps, state);
+        return state;
+
+    } else {
+
+        return state;
 
     }
 }
diff --git a/src/reducers/paths.js b/src/reducers/paths.js
index 5c49d4a5..5da7f823 100644
--- a/src/reducers/paths.js
+++ b/src/reducers/paths.js
@@ -1,6 +1,6 @@
 import {crawlLayout, hasId} from './utils'
 import R from 'ramda'
-import {ACTIONS} from '../actions/index.js';
+import {ACTIONS} from '../actions/constants';
 
 const initialPaths = null;
 
diff --git a/src/reducers/reducer.js b/src/reducers/reducer.js
index 9171024c..0ab21ee5 100644
--- a/src/reducers/reducer.js
+++ b/src/reducers/reducer.js
@@ -1,12 +1,17 @@
+/* global window:true, document:true */
 'use strict'
-
-import { combineReducers } from 'redux';
+import R from 'ramda';
+import {concat, lensPath, view} from 'ramda';
+import {combineReducers} from 'redux';
 import layout from './layout';
 import graphs from './dependencyGraph';
 import paths from './paths';
 import requestQueue from './requestQueue';
 import appLifecycle from './appLifecycle';
-import {layoutRequest, dependenciesRequest} from './api';
+import history from './history';
+import {layoutRequest, dependenciesRequest, routesRequest} from './api';
+import {serialize} from '../actions/index';
+import {APP_STATES} from './constants';
 
 const reducer = combineReducers({
     appLifecycle,
@@ -15,7 +20,117 @@ const reducer = combineReducers({
     paths,
     requestQueue,
     layoutRequest,
-    dependenciesRequest
+    dependenciesRequest,
+    routesRequest,
+    history
 });
 
-export default reducer;
+
+function getInputHistoryState(itempath, props, state) {
+    const {graphs, layout, paths} = state;
+    const {InputGraph} = graphs;
+    const keyObj = R.filter(R.equals(itempath), paths);
+    let historyEntry;
+    if (!R.isEmpty(keyObj)) {
+        const id = R.keys(keyObj)[0];
+        historyEntry = {id, props: {}};
+        R.keys(props).forEach(propKey => {
+            const inputKey = `${id}.${propKey}`;
+            if (InputGraph.dependenciesOf(inputKey).length > 0) {
+                historyEntry.props[propKey] = view(
+                    lensPath(concat(paths[id], ['props', propKey])),
+                    layout
+                );
+            }
+        });
+    }
+    return historyEntry;
+}
+
+function recordHistory(reducer) {
+    return function (state, action) {
+        // Record initial state
+        if (action.type === 'ON_PROP_CHANGE' &&
+            R.isEmpty(state.history.present)
+        ) {
+            const {itempath, props} = action.payload;
+            const historyEntry = getInputHistoryState(itempath, props, state);
+            if (historyEntry && !R.isEmpty(historyEntry.props)) {
+                state.history.present = historyEntry;
+            }
+        }
+
+        const nextState = reducer(state, action);
+
+        if (action.type === 'ON_PROP_CHANGE' &&
+            action.payload.source !== 'response'
+        ) {
+            const {itempath, props} = action.payload;
+            /*
+             * if the prop change is an input, then
+             * record it so that it can be played back
+             */
+            const historyEntry = getInputHistoryState(itempath, props, nextState);
+            if (historyEntry && !R.isEmpty(historyEntry.props)) {
+
+                nextState.history = {
+                    past: [
+                        ...nextState.history.past,
+                        nextState.history.present
+                    ],
+                    present: historyEntry,
+                    future: []
+                }
+
+            }
+        }
+
+        return nextState;
+
+    }
+}
+
+function updateUrlPath(reducer) {
+    return function(state, action) {
+        const nextState = reducer(state, action);
+        if (nextState.routesRequest.status === 200 &&
+            nextState.appLifecycle == APP_STATES('HYDRATED')
+        ) {
+            const serialized = serialize(nextState);
+            const matchingRoute = R.filter(route => R.equals(
+                route.state,
+                R.pick(R.keys(route.state), serialized)
+            ), nextState.routesRequest.content);
+            if (matchingRoute.length === 1 &&
+                window.location.pathname !== matchingRoute[0].pathname
+            ) {
+                window.history.pushState(
+                    {},
+                    document.title,matchingRoute[0].pathname
+                );
+            } else if (matchingRoute.length > 1) {
+                const nMostMatchedKeys = R.reduce(
+                    (n, route) => R.max(n, R.keys(route.state).length),
+                    0, matchingRoute
+                );
+                const bestMatchedRoute = matchingRoute.filter(route =>
+                    R.keys(route.state).length === nMostMatchedKeys
+                );
+                if (bestMatchedRoute.length > 1) {
+                    /* eslint-disable no-console */
+                    console.error('Multiple URLs matched?', matchingRoute);
+                    /* eslint-enable no-console */
+                } else {
+                    window.history.pushState(
+                        {},
+                        document.title,
+                        bestMatchedRoute[0].pathname
+                    );
+                }
+            }
+        }
+        return nextState;
+    }
+}
+
+export default updateUrlPath(recordHistory(reducer));
diff --git a/src/renderTree.js b/src/renderTree.js
index 8380f808..1056765d 100644
--- a/src/renderTree.js
+++ b/src/renderTree.js
@@ -5,7 +5,6 @@ import React, {PropTypes} from 'react';
 import Registry from './registry';
 import NotifyObservers from './components/core/NotifyObservers.react';
 
-
 export default function render(component) {
     if (R.contains(R.type(component), ['String', 'Number', 'Null'])) {
         return component;

commit 48c48262b7bfd5a94c9e659677c238e50001155b
Author: byron <byron@plot.ly>
Date:   Fri May 24 17:42:45 2019 -0400

    :tada: basic set up for dash.testing

diff --git a/.circleci/requirements/dev-requirements-py37.txt b/.circleci/requirements/dev-requirements-py37.txt
index 127f48d5..723f0cac 100644
--- a/.circleci/requirements/dev-requirements-py37.txt
+++ b/.circleci/requirements/dev-requirements-py37.txt
@@ -14,4 +14,5 @@ requests
 beautifulsoup4
 pytest
 pytest-sugar
-pytest-mock
\ No newline at end of file
+pytest-mock
+waitress
\ No newline at end of file
diff --git a/.circleci/requirements/dev-requirements.txt b/.circleci/requirements/dev-requirements.txt
index c151ccc7..6533e7f5 100644
--- a/.circleci/requirements/dev-requirements.txt
+++ b/.circleci/requirements/dev-requirements.txt
@@ -14,3 +14,4 @@ pytest-mock
 lxml
 requests
 beautifulsoup4
+waitress
diff --git a/.pylintrc b/.pylintrc
index a9688e4e..c6b7ec6d 100644
--- a/.pylintrc
+++ b/.pylintrc
@@ -59,7 +59,8 @@ disable=fixme,
         invalid-name,
         too-many-lines,
         old-style-class,
-        superfluous-parens
+        superfluous-parens,
+        bad-continuation,
 
 # Enable the message, report, category or checker with the given id(s). You can
 # either give multiple identifier separated by comma (,) or put this option
diff --git a/.pylintrc37 b/.pylintrc37
index 57c45836..533bbade 100644
--- a/.pylintrc37
+++ b/.pylintrc37
@@ -147,7 +147,8 @@ disable=invalid-name,
         useless-object-inheritance,
         possibly-unused-variable,
         too-many-lines,
-        too-many-statements
+        too-many-statements,
+        bad-continuation
 
 # Enable the message, report, category or checker with the given id(s). You can
 # either give multiple identifier separated by comma (,) or put this option
diff --git a/dash/exceptions.py b/dash/exceptions.py
index 0b029662..477eb7d1 100644
--- a/dash/exceptions.py
+++ b/dash/exceptions.py
@@ -94,3 +94,23 @@ class SameInputOutputException(CallbackException):
 
 class MissingCallbackContextException(CallbackException):
     pass
+
+
+class DashTestingError(Exception):
+    """Base error for pytest-dash."""
+
+
+class InvalidDriverError(DashTestingError):
+    """An invalid selenium driver was specified."""
+
+
+class NoAppFoundError(DashTestingError):
+    """No `app` was found in the file."""
+
+
+class DashAppLoadingError(DashTestingError):
+    """The dash app failed to load"""
+
+
+class ServerCloseError(DashTestingError):
+    """The server cannot be closed"""
diff --git a/__init__.py b/dash/testing/__init__.py
similarity index 100%
rename from __init__.py
rename to dash/testing/__init__.py
diff --git a/dash/testing/application_runners.py b/dash/testing/application_runners.py
new file mode 100644
index 00000000..527b7065
--- /dev/null
+++ b/dash/testing/application_runners.py
@@ -0,0 +1,212 @@
+from __future__ import print_function
+
+import sys
+import uuid
+import shlex
+import threading
+import subprocess
+
+import six
+import runpy
+import flask
+import requests
+
+from dash.exceptions import (
+    NoAppFoundError,
+    # DashAppLoadingError,
+    ServerCloseError,
+)
+import dash.testing.wait as wait
+
+import logging
+
+logger = logging.getLogger(__name__)
+
+
+def import_app(app_file, application_name="app"):
+    """
+    Import a dash application from a module.
+    The import path is in dot notation to the module.
+    The variable named app will be returned.
+
+    :Example:
+
+        >>> app = import_app('my_app.app')
+
+    Will import the application in module `app` of the package `my_app`.
+
+    :param app_file: Path to the app (dot-separated).
+    :type app_file: str
+    :param application_name: The name of the dash application instance.
+    :raise: dash_tests.errors.NoAppFoundError
+    :return: App from module.
+    :rtype: dash.Dash
+    """
+    try:
+        app_module = runpy.run_module(app_file)
+        app = app_module[application_name]
+    except KeyError:
+        raise NoAppFoundError(
+            "No dash `app` instance was found in {}".format(app_file)
+        )
+    return app
+
+
+class BaseDashRunner(object):
+    """Base context manager class for running applications."""
+
+    def __init__(self, keep_open, stop_timeout):
+        self.port = 8050
+        self.started = None
+        self.keep_open = keep_open
+        self.stop_timeout = stop_timeout
+
+    def start(self, *args, **kwargs):
+        raise NotImplementedError  # pragma: no cover
+
+    def stop(self):
+        raise NotImplementedError  # pragma: no cover
+
+    def __call__(self, *args, **kwargs):
+        return self.start(*args, **kwargs)
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_val, traceback):
+        if self.started and not self.keep_open:
+            try:
+                logger.info("killing the app runner")
+                self.stop()
+            except TimeoutError:
+                raise ServerCloseError(
+                    "Cannot stop server within {} timeout".format(
+                        self.stop_timeout
+                    )
+                )
+
+    @property
+    def url(self):
+        """the default server url"""
+        return "http://localhost:{}".format(self.port)
+
+
+class ThreadedRunner(BaseDashRunner):
+    """Runs a dash application in a thread
+
+    this is the default flavor to use in dash integration tests
+    """
+
+    def __init__(self, keep_open=False, stop_timeout=1):
+        super(ThreadedRunner, self).__init__(
+            keep_open=keep_open, stop_timeout=stop_timeout
+        )
+        self.stop_route = "/_stop-{}".format(uuid.uuid4().hex)
+        self.thread = None
+
+    @staticmethod
+    def _stop_server():
+        # https://werkzeug.palletsprojects.com/en/0.15.x/serving/#shutting-down-the-server
+        stopper = flask.request.environ.get("werkzeug.server.shutdown")
+        if stopper is None:
+            raise RuntimeError("Not running with the Werkzeug Server")
+        stopper()
+        return "Flask server is shutting down"
+
+    # pylint: disable=arguments-differ,C0330
+    def start(self, app, **kwargs):
+        """Start the app server in threading flavor"""
+        app.server.add_url_rule(
+            self.stop_route, self.stop_route, self._stop_server
+        )
+
+        def _handle_error():
+            self._stop_server()
+
+        app.server.errorhandler(500)(_handle_error)
+
+        def run():
+            app.scripts.config.serve_locally = True
+            app.css.config.serve_locally = True
+            if "port" not in kwargs:
+                kwargs["port"] = self.port
+            app.run_server(threaded=True, **kwargs)
+
+        self.thread = threading.Thread(target=run)
+        self.thread.daemon = True
+
+        try:
+            self.thread.start()
+        except RuntimeError:  # multiple call on same thread
+            self.started = False
+
+        self.started = self.thread.is_alive()
+
+    def stop(self):
+        requests.get("{}{}".format(self.url, self.stop_route))
+        wait.until_not(self.thread.is_alive, self.stop_timeout)
+
+
+class ProcessRunner(BaseDashRunner):
+    """Runs a dash application in a waitress-serve subprocess
+
+    this flavor is closer to production environment but slower
+    """
+
+    def __init__(self, keep_open=False, stop_timeout=1):
+        super(ProcessRunner, self).__init__(
+            keep_open=keep_open, stop_timeout=stop_timeout
+        )
+        self.proc = None
+
+    # pylint: disable=arguments-differ
+    def start(self, app_module, application_name="app", port=8050):
+        """
+        Start the waitress-serve process.
+
+        .. seealso:: :py:func:`~.plugin.dash_subprocess`
+
+        :param app_module: Dot notation path to the app file.
+        :type app_module: str
+        :param application_name: Variable name of the dash instance.
+        :type application_name: str
+        :param port: Port to serve the application.
+        :type port: int
+        :return:
+        """
+        entrypoint = "{}:{}.server".format(app_module, application_name)
+        self.port = port
+
+        args = shlex.split(
+            "waitress-serve --listen=127.0.0.1:{} {}".format(port, entrypoint),
+            posix=sys.platform != "win32",
+        )
+        logger.debug("start dash process with %s", args)
+        try:
+            self.proc = subprocess.Popen(
+                args,
+                stdout=subprocess.PIPE,
+                stderr=subprocess.PIPE,
+            )
+        except (OSError, ValueError):
+            self.started = False
+
+        self.started = True
+
+    def stop(self):
+        self.proc.terminate()
+        try:
+            if six.PY3:
+                _except = subprocess.TimeoutExpired
+                return self.proc.communicate(timeout=self.stop_timeout)
+            else:
+                _except = OSError
+                return self.proc.communicate()
+
+        except _except:
+            logger.warning(
+                "subprocess terminate timeout %s reached, trying to kill "
+                "the subprocess in a safe manner", self.stop_timeout
+            )
+            self.proc.kill()
+            return self.proc.communicate()
diff --git a/dash/testing/plugin.py b/dash/testing/plugin.py
new file mode 100644
index 00000000..269a4c0e
--- /dev/null
+++ b/dash/testing/plugin.py
@@ -0,0 +1,72 @@
+import pytest
+
+from selenium import webdriver
+
+from dash.testing.application_runners import ThreadedRunner, ProcessRunner
+
+WEBDRIVERS = {
+    "Chrome": webdriver.Chrome,
+    "Firefox": webdriver.Firefox,
+    "Remote": webdriver.Remote,
+}
+
+
+def _get_config(config, key, default=None):
+    opt = config.getoption(key)
+    ini = config.getini(key)
+    return opt or ini or default
+
+
+###############################################################################
+# Plugin hooks.
+###############################################################################
+
+# pylint: disable=missing-docstring
+def pytest_addoption(parser):
+    # Add options to the pytest parser, either on the commandline or ini
+    # TODO add more options for the selenium driver.
+    dash = parser.getgroup("Dash", "Dash Integration Tests")
+    help_msg = "Name of the selenium driver to use"
+    dash.addoption(
+        "--webdriver", choices=tuple(WEBDRIVERS.keys()), help=help_msg
+    )
+    parser.addini("webdriver", help=help_msg)
+
+
+###############################################################################
+# Fixtures
+###############################################################################
+
+
+@pytest.fixture
+def thread_server():
+    """
+    Start a local dash server in a new thread. Stop the server in teardown.
+    :Example:
+    .. code-block:: python
+        import dash
+        import dash_html_components as html
+        def test_application(dash_threaded):
+            app = dash.Dash(__name__)
+            app.layout = html.Div('My app)
+            dash_threaded(app)
+    .. seealso:: :py:class:`pytest_dash.application_runners.DashThreaded`
+    """
+
+    with ThreadedRunner() as starter:
+        yield starter
+
+
+@pytest.fixture
+def process_server():
+    """
+    Start a Dash server with subprocess.Popen and waitress-serve.
+    :Example:
+    .. code-block:: python
+        def test_application(dash_subprocess):
+            # consider the application file is named `app.py`
+            dash_subprocess('app')
+    .. seealso:: :py:class:`pytest_dash.application_runners.DashSubprocess`
+    """
+    with ProcessRunner() as starter:
+        yield starter
diff --git a/dash/testing/wait.py b/dash/testing/wait.py
new file mode 100644
index 00000000..aa026173
--- /dev/null
+++ b/dash/testing/wait.py
@@ -0,0 +1,25 @@
+"""Utils methods for pytest-dash such wait_for wrappers"""
+import time
+
+
+def until(
+    wait_cond,
+    timeout,
+    poll=0.1,
+    msg="expected condition not met within timeout",
+):  # noqa: C0330
+    end_time = time.time() + timeout
+    while wait_cond():
+        time.sleep(poll)
+        if time.time() > end_time:
+            raise TimeoutError(msg)
+
+
+def until_not(
+    wait_cond, timeout, poll=0.1, msg="expected condition met within timeout"
+):  # noqa: C0330
+    end_time = time.time() + timeout
+    while not wait_cond():
+        time.sleep(poll)
+        if time.time() > end_time:
+            raise TimeoutError(msg)
diff --git a/pytest.ini b/pytest.ini
index 52c3d7b0..bfada58f 100644
--- a/pytest.ini
+++ b/pytest.ini
@@ -1,5 +1,9 @@
 [pytest]
+testpaths = tests/
 addopts = -rsxX -vv
+log_cli=true
+log_cli_level = DEBUG
+webdriver = Chrome
 
 
 
diff --git a/setup.py b/setup.py
index 64cda7e1..3d8070c8 100644
--- a/setup.py
+++ b/setup.py
@@ -12,8 +12,10 @@ setup(
     packages=find_packages(exclude=['tests*']),
     include_package_data=True,
     license='MIT',
-    description=('A Python framework for building reactive web-apps. '
-                 'Developed by Plotly.'),
+    description=(
+        'A Python framework for building reactive web-apps. '
+        'Developed by Plotly.'
+    ),
     long_description=io.open('README.md', encoding='utf-8').read(),
     long_description_content_type='text/markdown',
     install_requires=[
@@ -29,7 +31,10 @@ setup(
         'console_scripts': [
             'dash-generate-components ='
             ' dash.development.component_generator:cli'
-        ]
+        ],
+        'pytest11': [
+            'dash = dash.testing.plugin'
+        ],
     },
     url='https://plot.ly/dash',
     classifiers=[

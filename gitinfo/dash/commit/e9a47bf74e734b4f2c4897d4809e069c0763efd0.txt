commit e9a47bf74e734b4f2c4897d4809e069c0763efd0
Author: alexcjohnson <alex@plot.ly>
Date:   Fri Mar 20 05:18:48 2020 -0400

    move non-layout-linked callback validation to the front end

diff --git a/dash-renderer/src/actions/dependencies.js b/dash-renderer/src/actions/dependencies.js
index d4e3c82c..b58e2c3e 100644
--- a/dash-renderer/src/actions/dependencies.js
+++ b/dash-renderer/src/actions/dependencies.js
@@ -1,10 +1,12 @@
 import {DepGraph} from 'dependency-graph';
 import isNumeric from 'fast-isnumeric';
 import {
+    all,
     any,
     ap,
     assoc,
     clone,
+    difference,
     dissoc,
     equals,
     evolve,
@@ -12,6 +14,7 @@ import {
     forEachObjIndexed,
     includes,
     isEmpty,
+    keys,
     map,
     mergeDeepRight,
     mergeRight,
@@ -23,6 +26,7 @@ import {
     props,
     unnest,
     values,
+    zip,
     zipObj,
 } from 'ramda';
 
@@ -42,6 +46,14 @@ const ALL = {wild: 'ALL', multi: 1};
 const MATCH = {wild: 'MATCH'};
 const ALLSMALLER = {wild: 'ALLSMALLER', multi: 1, expand: 1};
 const wildcards = {ALL, MATCH, ALLSMALLER};
+const allowedWildcards = {
+    Output: {ALL, MATCH},
+    Input: wildcards,
+    State: wildcards,
+};
+const wildcardValTypes = ['string', 'number', 'boolean'];
+
+const idInvalidChars = ['.', '{'];
 
 /*
  * If this ID is a wildcard, it is a stringified JSON object
@@ -56,7 +68,7 @@ const isWildcardId = idStr => idStr.startsWith('{');
  */
 function parseWildcardId(idStr) {
     return map(
-        val => (Array.isArray(val) ? wildcards[val[0]] : val),
+        val => (Array.isArray(val) && wildcards[val[0]]) || val,
         JSON.parse(idStr)
     );
 }
@@ -99,9 +111,10 @@ export function stringifyId(id) {
     if (typeof id !== 'object') {
         return id;
     }
+    const stringifyVal = v => (v && v.wild) || JSON.stringify(v);
     const parts = Object.keys(id)
         .sort()
-        .map(k => JSON.stringify(k) + ':' + JSON.stringify(id[k]));
+        .map(k => JSON.stringify(k) + ':' + stringifyVal(id[k]));
     return '{' + parts.join(',') + '}';
 }
 
@@ -165,7 +178,267 @@ function addPattern(depMap, idSpec, prop, dependency) {
     valMatch.callbacks.push(dependency);
 }
 
-export function computeGraphs(dependencies) {
+function validateDependencies(parsedDependencies, dispatchError) {
+    const outStrs = {};
+    const outObjs = [];
+
+    parsedDependencies.forEach(dep => {
+        const {inputs, outputs, state} = dep;
+        let hasOutputs = true;
+        if (outputs.length === 1 && !outputs[0].id && !outputs[0].property) {
+            hasOutputs = false;
+            dispatchError('A callback is missing Outputs', [
+                'Please provide an output for this callback:',
+                JSON.stringify(dep, null, 2),
+            ]);
+        }
+
+        const head =
+            'In the callback for output(s):\n  ' +
+            outputs.map(combineIdAndProp).join('\n  ');
+
+        if (!inputs.length) {
+            dispatchError('A callback is missing Inputs', [
+                head,
+                'there are no `Input` elements.',
+                'Without `Input` elements, it will never get called.',
+                '',
+                'Subscribing to `Input` components will cause the',
+                'callback to be called whenever their values change.',
+            ]);
+        }
+
+        const spec = [[outputs, 'Output'], [inputs, 'Input'], [state, 'State']];
+        spec.forEach(([args, cls]) => {
+            if (cls === 'Output' && !hasOutputs) {
+                // just a quirk of how we pass & parse outputs - if you don't
+                // provide one, it looks like a single blank output. This is
+                // actually useful for graceful failure, so we work around it.
+                return;
+            }
+
+            if (!Array.isArray(args)) {
+                dispatchError(`Callback ${cls}(s) must be an Array`, [
+                    head,
+                    `For ${cls}(s) we found:`,
+                    JSON.stringify(args),
+                    'but we expected an Array.',
+                ]);
+            }
+            args.forEach((idProp, i) => {
+                validateArg(idProp, head, cls, i, dispatchError);
+            });
+        });
+
+        findDuplicateOutputs(outputs, head, dispatchError, outStrs, outObjs);
+        findInOutOverlap(outputs, inputs, head, dispatchError);
+        findMismatchedWildcards(outputs, inputs, state, head, dispatchError);
+    });
+}
+
+function validateArg({id, property}, head, cls, i, dispatchError) {
+    if (typeof property !== 'string' || !property) {
+        dispatchError('Callback property error', [
+            head,
+            `${cls}[${i}].property = ${JSON.stringify(property)}`,
+            'but we expected `property` to be a non-empty string.',
+        ]);
+    }
+
+    if (typeof id === 'object') {
+        if (isEmpty(id)) {
+            dispatchError('Callback item missing ID', [
+                head,
+                `${cls}[${i}].id = {}`,
+                'Every item linked to a callback needs an ID',
+            ]);
+        }
+
+        forEachObjIndexed((v, k) => {
+            if (!k) {
+                dispatchError('Callback wildcard ID error', [
+                    head,
+                    `${cls}[${i}].id has key "${k}"`,
+                    'Keys must be non-empty strings.',
+                ]);
+            }
+
+            if (typeof v === 'object' && v.wild) {
+                if (allowedWildcards[cls][v.wild] !== v) {
+                    dispatchError('Callback wildcard ID error', [
+                        head,
+                        `${cls}[${i}].id["${k}"] = ${v.wild}`,
+                        `Allowed wildcards for ${cls}s are:`,
+                        keys(allowedWildcards[cls]).join(', '),
+                    ]);
+                }
+            } else if (!includes(typeof v, wildcardValTypes)) {
+                dispatchError('Callback wildcard ID error', [
+                    head,
+                    `${cls}[${i}].id["${k}"] = ${JSON.stringify(v)}`,
+                    'Wildcard callback ID values must be either wildcards',
+                    'or constants of one of these types:',
+                    wildcardValTypes.join(', '),
+                ]);
+            }
+        }, id);
+    } else if (typeof id === 'string') {
+        if (!id) {
+            dispatchError('Callback item missing ID', [
+                head,
+                `${cls}[${i}].id = "${id}"`,
+                'Every item linked to a callback needs an ID',
+            ]);
+        }
+        const invalidChars = idInvalidChars.filter(c => includes(c, id));
+        if (invalidChars.length) {
+            dispatchError('Callback invalid ID string', [
+                head,
+                `${cls}[${i}].id = '${id}'`,
+                `characters '${invalidChars.join("', '")}' are not allowed.`,
+            ]);
+        }
+    } else {
+        dispatchError('Callback ID type error', [
+            head,
+            `${cls}[${i}].id = ${JSON.stringify(id)}`,
+            'IDs must be strings or wildcard-compatible objects.',
+        ]);
+    }
+}
+
+function findDuplicateOutputs(outputs, head, dispatchError, outStrs, outObjs) {
+    const newOutputStrs = {};
+    const newOutputObjs = [];
+    outputs.forEach(({id, property}, i) => {
+        if (typeof id === 'string') {
+            const idProp = combineIdAndProp({id, property});
+            if (newOutputStrs[idProp]) {
+                dispatchError('Duplicate callback Outputs', [
+                    head,
+                    `Output ${i} (${idProp}) is already used by this callback.`,
+                ]);
+            } else if (outStrs[idProp]) {
+                dispatchError('Duplicate callback outputs', [
+                    head,
+                    `Output ${i} (${idProp}) is already in use.`,
+                    'Any given output can only have one callback that sets it.',
+                    'To resolve this situation, try combining these into',
+                    'one callback function, distinguishing the trigger',
+                    'by using `dash.callback_context` if necessary.',
+                ]);
+            } else {
+                newOutputStrs[idProp] = 1;
+            }
+        } else {
+            const idObj = {id, property};
+            const selfOverlap = wildcardOverlap(idObj, newOutputObjs);
+            const otherOverlap = selfOverlap || wildcardOverlap(idObj, outObjs);
+            if (selfOverlap || otherOverlap) {
+                const idProp = combineIdAndProp(idObj);
+                const idProp2 = combineIdAndProp(selfOverlap || otherOverlap);
+                dispatchError('Overlapping wildcard callback outputs', [
+                    head,
+                    `Output ${i} (${idProp})`,
+                    `overlaps another output (${idProp2})`,
+                    `used in ${selfOverlap ? 'this' : 'a different'} callback.`,
+                ]);
+            } else {
+                newOutputObjs.push(idObj);
+            }
+        }
+    });
+    keys(newOutputStrs).forEach(k => {
+        outStrs[k] = 1;
+    });
+    newOutputObjs.forEach(idObj => {
+        outObjs.push(idObj);
+    });
+}
+
+function findInOutOverlap(outputs, inputs, head, dispatchError) {
+    outputs.forEach((out, outi) => {
+        const {id: outId, property: outProp} = out;
+        inputs.forEach((in_, ini) => {
+            const {id: inId, property: inProp} = in_;
+            if (outProp !== inProp || typeof outId !== typeof inId) {
+                return;
+            }
+            if (typeof outId === 'string') {
+                if (outId === inId) {
+                    dispatchError('Same `Input` and `Output`', [
+                        head,
+                        `Input ${ini} (${combineIdAndProp(in_)})`,
+                        `matches Output ${outi} (${combineIdAndProp(out)})`,
+                    ]);
+                }
+            } else if (wildcardOverlap(in_, [out])) {
+                dispatchError('Same `Input` and `Output`', [
+                    head,
+                    `Input ${ini} (${combineIdAndProp(in_)})`,
+                    'can match the same component(s) as',
+                    `Output ${outi} (${combineIdAndProp(out)})`,
+                ]);
+            }
+        });
+    });
+}
+
+function findMismatchedWildcards(outputs, inputs, state, head, dispatchError) {
+    const {anyKeys: out0AnyKeys} = findWildcardKeys(outputs[0].id);
+    outputs.forEach((out, outi) => {
+        if (outi && !equals(findWildcardKeys(out.id).anyKeys, out0AnyKeys)) {
+            dispatchError('Mismatched `MATCH` wildcards across `Output`s', [
+                head,
+                `Output ${outi} (${combineIdAndProp(out)})`,
+                'does not have MATCH wildcards on the same keys as',
+                `Output 0 (${combineIdAndProp(outputs[0])}).`,
+                'MATCH wildcards must be on the same keys for all Outputs.',
+                'ALL wildcards need not match, only MATCH.',
+            ]);
+        }
+    });
+    [[inputs, 'Input'], [state, 'State']].forEach(([args, cls]) => {
+        args.forEach((arg, i) => {
+            const {anyKeys, allsmallerKeys} = findWildcardKeys(arg.id);
+            const allWildcardKeys = anyKeys.concat(allsmallerKeys);
+            const diff = difference(allWildcardKeys, out0AnyKeys);
+            if (diff.length) {
+                diff.sort();
+                dispatchError('`Input` / `State` wildcards not in `Output`s', [
+                    head,
+                    `${cls} ${i} (${combineIdAndProp(arg)})`,
+                    `has MATCH or ALLSMALLER on key(s) ${diff.join(', ')}`,
+                    `where Output 0 (${combineIdAndProp(outputs[0])})`,
+                    'does not have a MATCH wildcard. Inputs and State do not',
+                    'need every MATCH from the Output(s), but they cannot have',
+                    'extras beyond the Output(s).',
+                ]);
+            }
+        });
+    });
+}
+
+const matchWildKeys = ([a, b]) => a === b || (a && a.wild) || (b && b.wild);
+
+function wildcardOverlap({id, property}, objs) {
+    const idKeys = keys(id).sort();
+    const idVals = props(idKeys, id);
+    for (const obj of objs) {
+        const {id: id2, property: property2} = obj;
+        if (
+            property2 === property &&
+            typeof id2 !== 'string' &&
+            equals(keys(id2).sort(), idKeys) &&
+            all(matchWildKeys, zip(idVals, props(idKeys, id2)))
+        ) {
+            return obj;
+        }
+    }
+    return false;
+}
+
+export function computeGraphs(dependencies, dispatchError) {
     const inputGraph = new DepGraph();
     // multiGraph is just for finding circular deps
     const multiGraph = new DepGraph();
@@ -183,6 +456,8 @@ export function computeGraphs(dependencies) {
         return out;
     }, dependencies);
 
+    validateDependencies(parsedDependencies, dispatchError);
+
     /*
      * For regular ids, outputMap and inputMap are:
      *   {[id]: {[prop]: [callback, ...]}}
@@ -319,18 +594,9 @@ export function computeGraphs(dependencies) {
         // Also collect MATCH keys in the output (all outputs must share these)
         // and ALL keys in the first output (need not be shared but we'll use
         // the first output for calculations) for later convenience.
-        const anyKeys = [];
-        let hasAll = false;
-        forEachObjIndexed((val, key) => {
-            if (val === MATCH) {
-                anyKeys.push(key);
-            } else if (val === ALL) {
-                hasAll = true;
-            }
-        }, outputs[0].id);
-        anyKeys.sort();
+        const {anyKeys, hasALL} = findWildcardKeys(outputs[0].id);
         const finalDependency = mergeRight(
-            {hasAll, anyKeys, outputs},
+            {hasALL, anyKeys, outputs},
             dependency
         );
 
@@ -375,6 +641,26 @@ export function computeGraphs(dependencies) {
     };
 }
 
+function findWildcardKeys(id) {
+    const anyKeys = [];
+    const allsmallerKeys = [];
+    let hasALL = false;
+    if (typeof id === 'object') {
+        forEachObjIndexed((val, key) => {
+            if (val === MATCH) {
+                anyKeys.push(key);
+            } else if (val === ALLSMALLER) {
+                allsmallerKeys.push(key);
+            } else if (val === ALL) {
+                hasALL = true;
+            }
+        }, id);
+        anyKeys.sort();
+        allsmallerKeys.sort();
+    }
+    return {anyKeys, allsmallerKeys, hasALL};
+}
+
 /*
  * Do the given id values `vals` match the pattern `patternVals`?
  * `keys`, `patternVals`, and `vals` are all arrays, and we already know that
@@ -583,8 +869,8 @@ function getCallbackByOutput(graphs, paths, id, prop) {
  * from an input to one item per combination of MATCH values.
  * That will give one result per callback invocation.
  */
-function reduceALLOuts(outs, anyKeys, hasAll) {
-    if (!hasAll) {
+function reduceALLOuts(outs, anyKeys, hasALL) {
+    if (!hasALL) {
         return outs;
     }
     if (!anyKeys.length) {
diff --git a/dash/_validate.py b/dash/_validate.py
index b23328fa..e208901d 100644
--- a/dash/_validate.py
+++ b/dash/_validate.py
@@ -2,7 +2,7 @@ import collections
 import re
 
 from .development.base_component import Component
-from .dependencies import Input, Output, State, MATCH, ALLSMALLER
+from .dependencies import Input, Output, State
 from . import exceptions
 from ._utils import patch_collections_abc, _strings, stringify_id
 
@@ -24,26 +24,11 @@ def validate_callback(app, layout, output, inputs, state):
             """
         )
 
-    if not inputs:
-        raise exceptions.MissingInputsException(
-            """
-            This callback has no `Input` elements.
-            Without `Input` elements, this callback will never get called.
-
-            Subscribing to Input components will cause the
-            callback to be called whenever their values change.
-            """
-        )
-
     outputs = output if is_multi else [output]
 
     for args, cls in [(outputs, Output), (inputs, Input), (state, State)]:
         validate_callback_args(args, cls, layout, validate_ids)
 
-    prevent_duplicate_outputs(app, outputs)
-    prevent_input_output_overlap(inputs, outputs)
-    prevent_inconsistent_wildcards(outputs, inputs, state)
-
 
 def validate_callback_args(args, cls, layout, validate_ids):
     name = cls.__name__
@@ -100,117 +85,6 @@ def validate_callback_args(args, cls, layout, validate_ids):
             )
 
 
-def prevent_duplicate_outputs(app, outputs):
-    for i, out in enumerate(outputs):
-        for out2 in outputs[i + 1:]:
-            if out == out2:
-                # Note: different but overlapping wildcards compare as equal
-                if str(out) == str(out2):
-                    raise exceptions.DuplicateCallbackOutput(
-                        """
-                        Same output {} was used more than once in a callback!
-                        """.format(
-                            str(out)
-                        )
-                    )
-                raise exceptions.DuplicateCallbackOutput(
-                    """
-                    Two outputs in a callback can match the same ID!
-                    {} and {}
-                    """.format(
-                        str(out), str(out2)
-                    )
-                )
-
-    dups = set()
-    for out in outputs:
-        for used_out in app.used_outputs:
-            if out == used_out:
-                dups.add(str(used_out))
-    if dups:
-        dups = list(dups)
-        if len(outputs) > 1 or len(dups) > 1 or str(outputs[0]) != dups[0]:
-            raise exceptions.DuplicateCallbackOutput(
-                """
-                One or more `Output` is already set by a callback.
-                Note that two wildcard outputs can refer to the same component
-                even if they don't match exactly.
-
-                The new callback lists output(s):
-                {}
-                Already used:
-                {}
-                """.format(
-                    ", ".join([str(out) for out in outputs]),
-                    ", ".join(dups)
-                )
-            )
-        raise exceptions.DuplicateCallbackOutput(
-            """
-            {} was already assigned to a callback.
-            Any given output can only have one callback that sets it.
-            Try combining your inputs and callback functions together
-            into one function.
-            """.format(
-                repr(outputs[0])
-            )
-        )
-
-
-def prevent_input_output_overlap(inputs, outputs):
-    for in_ in inputs:
-        for out in outputs:
-            if out == in_:
-                # Note: different but overlapping wildcards compare as equal
-                if str(out) == str(in_):
-                    raise exceptions.SameInputOutputException(
-                        "Same `Output` and `Input`: {}".format(out)
-                    )
-                raise exceptions.SameInputOutputException(
-                    """
-                    An `Input` and an `Output` in one callback
-                    can match the same ID!
-                    {} and {}
-                    """.format(
-                        str(in_), str(out)
-                    )
-                )
-
-
-def prevent_inconsistent_wildcards(outputs, inputs, state):
-    any_keys = get_wildcard_keys(outputs[0], (MATCH,))
-    for out in outputs[1:]:
-        if get_wildcard_keys(out, (MATCH,)) != any_keys:
-            raise exceptions.InconsistentCallbackWildcards(
-                """
-                All `Output` items must have matching wildcard `MATCH` values.
-                `ALL` wildcards need not match, only `MATCH`.
-
-                Output {} does not match the first output {}.
-                """.format(
-                    out, outputs[0]
-                )
-            )
-
-    matched_wildcards = (MATCH, ALLSMALLER)
-    for dep in list(inputs) + list(state):
-        wildcard_keys = get_wildcard_keys(dep, matched_wildcards)
-        if wildcard_keys - any_keys:
-            raise exceptions.InconsistentCallbackWildcards(
-                """
-                `Input` and `State` items can only have {}
-                wildcards on keys where the `Output`(s) have `MATCH` wildcards.
-                `ALL` wildcards need not match, and you need not match every
-                `MATCH` in the `Output`(s).
-
-                This callback has `MATCH` on keys {}.
-                {} has these wildcards on keys {}.
-                """.format(
-                    matched_wildcards, any_keys, dep, wildcard_keys
-                )
-            )
-
-
 def validate_id_dict(arg, layout, validate_ids, wildcards):
     arg_id = arg.component_id
 
@@ -238,7 +112,10 @@ def validate_id_dict(arg, layout, validate_ids, wildcards):
             validate_prop_for_component(arg, component)
 
     for k, v in arg_id.items():
-        if not (k and isinstance(k, _strings)):
+        # Need to keep key type validation on the Python side, since
+        # non-string keys will be converted to strings in json.dumps and may
+        # cause unwanted collisions
+        if not (isinstance(k, _strings)):
             raise exceptions.IncorrectTypeException(
                 """
                 Wildcard ID keys must be non-empty strings,
@@ -247,19 +124,6 @@ def validate_id_dict(arg, layout, validate_ids, wildcards):
                     k, arg_id
                 )
             )
-        if not (v in wildcards or isinstance(v, _strings + (int, float, bool))):
-            wildcard_msg = (
-                ",\n                or wildcards: {}".format(wildcards)
-                if wildcards else ""
-            )
-            raise exceptions.IncorrectTypeException(
-                """
-                Wildcard {} ID values must be strings, numbers, bools{}
-                found {!r} in id {!r}
-                """.format(
-                    arg.__class__.__name__, wildcard_msg, k, arg_id
-                )
-            )
 
 
 def validate_id_string(arg, layout, validate_ids):
@@ -480,13 +344,6 @@ def fail_callback_output(output_value, output):
     )
 
 
-def get_wildcard_keys(dep, wildcards):
-    _id = dep.component_id
-    if not isinstance(_id, dict):
-        return set()
-    return {k for k, v in _id.items() if v in wildcards}
-
-
 def check_obsolete(kwargs):
     for key in kwargs:
         if key in ["components_cache_max_age", "static_folder"]:
diff --git a/dash/exceptions.py b/dash/exceptions.py
index 3f3aca59..f1af1996 100644
--- a/dash/exceptions.py
+++ b/dash/exceptions.py
@@ -30,18 +30,10 @@ class NonExistentEventException(CallbackException):
     pass
 
 
-class UndefinedLayoutException(CallbackException):
-    pass
-
-
 class IncorrectTypeException(CallbackException):
     pass
 
 
-class MissingInputsException(CallbackException):
-    pass
-
-
 class LayoutIsNotDefined(CallbackException):
     pass
 
@@ -55,19 +47,6 @@ class InvalidComponentIdError(IDsCantContainPeriods):
     pass
 
 
-class CantHaveMultipleOutputs(CallbackException):
-    pass
-
-
-# Renamed for less confusion with multi output.
-class DuplicateCallbackOutput(CantHaveMultipleOutputs):
-    pass
-
-
-class InconsistentCallbackWildcards(CallbackException):
-    pass
-
-
 class PreventUpdate(CallbackException):
     pass
 
@@ -100,10 +79,6 @@ class ResourceException(DashException):
     pass
 
 
-class SameInputOutputException(CallbackException):
-    pass
-
-
 class MissingCallbackContextException(CallbackException):
     pass
 
diff --git a/tests/integration/devtools/test_callback_validation.py b/tests/integration/devtools/test_callback_validation.py
new file mode 100644
index 00000000..b5f189f3
--- /dev/null
+++ b/tests/integration/devtools/test_callback_validation.py
@@ -0,0 +1,344 @@
+import dash_core_components as dcc
+import dash_html_components as html
+import dash
+from dash.dependencies import Input, Output, State, MATCH, ALL, ALLSMALLER
+from dash.testing.wait import until_not
+
+debugging = dict(
+    debug=True,
+    use_reloader=False,
+    use_debugger=True,
+    dev_tools_hot_reload=False,
+)
+
+
+def check_error(dash_duo, index, message, snippets):
+    # This is not fully general - despite the selectors below, it only applies
+    # to front-end errors with no back-end errors in the list.
+    # Also the index is as on the page, which is opposite the execution order.
+
+    found_message = dash_duo.find_elements(".dash-fe-error__title")[index].text
+    assert found_message == message
+
+    if not snippets:
+        return
+
+    dash_duo.find_elements(".test-devtools-error-toggle")[index].click()
+
+    found_text = dash_duo.wait_for_element(".dash-backend-error").text
+    for snip in snippets:
+        assert snip in found_text
+
+    # hide the error detail again - so only one detail is be visible at a time
+    dash_duo.find_elements(".test-devtools-error-toggle")[index].click()
+    dash_duo.wait_for_no_elements(".dash-backend-error")
+
+
+def test_dvcv001_blank(dash_duo):
+    app = dash.Dash(__name__)
+    app.layout = html.Div()
+
+    @app.callback([], [])
+    def x():
+        return 42
+
+    dash_duo.start_server(app, **debugging)
+
+    dash_duo.wait_for_text_to_equal(dash_duo.devtools_error_count_locator, "2")
+
+    check_error(dash_duo, 0, "A callback is missing Inputs", [
+        "there are no `Input` elements."
+    ])
+    check_error(dash_duo, 1, "A callback is missing Outputs", [
+        "Please provide an output for this callback:"
+    ])
+
+
+def test_dvcv002_blank_id_prop(dash_duo):
+    # TODO: remove suppress_callback_exceptions after we move that part to FE
+    app = dash.Dash(__name__, suppress_callback_exceptions=True)
+    app.layout = html.Div([html.Div(id="a")])
+
+    @app.callback([Output("a", "children"), Output("", "")], [Input("", "")])
+    def x(a):
+        return a
+
+    dash_duo.start_server(app, **debugging)
+
+    dash_duo.wait_for_text_to_equal(dash_duo.devtools_error_count_locator, "6")
+
+    # the first 2 are just artifacts... the other 4 we care about
+    check_error(dash_duo, 0, "Circular Dependencies", [])
+    check_error(dash_duo, 1, "Same `Input` and `Output`", [])
+
+    check_error(dash_duo, 2, "Callback item missing ID", [
+        'Input[0].id = ""',
+        "Every item linked to a callback needs an ID",
+    ])
+    check_error(dash_duo, 3, "Callback property error", [
+        'Input[0].property = ""',
+        "expected `property` to be a non-empty string.",
+    ])
+    check_error(dash_duo, 4, "Callback item missing ID", [
+        'Output[1].id = ""',
+        "Every item linked to a callback needs an ID",
+    ])
+    check_error(dash_duo, 5, "Callback property error", [
+        'Output[1].property = ""',
+        "expected `property` to be a non-empty string.",
+    ])
+
+
+def test_dvcv003_duplicate_outputs_same_callback(dash_duo):
+    app = dash.Dash(__name__)
+    app.layout = html.Div([html.Div(id="a"), html.Div(id="b")])
+
+    @app.callback(
+        [Output("a", "children"), Output("a", "children")],
+        [Input("b", "children")]
+    )
+    def x(b):
+        return b, b
+
+    @app.callback(
+        [Output({"a": 1}, "children"), Output({"a": ALL}, "children")],
+        [Input("b", "children")]
+    )
+    def y(b):
+        return b, b
+
+    dash_duo.start_server(app, **debugging)
+
+    dash_duo.wait_for_text_to_equal(dash_duo.devtools_error_count_locator, "2")
+
+    check_error(dash_duo, 0, "Overlapping wildcard callback outputs", [
+        'Output 1 ({"a":ALL}.children)',
+        'overlaps another output ({"a":1}.children)',
+        "used in this callback",
+    ])
+    check_error(dash_duo, 1, "Duplicate callback Outputs", [
+        "Output 1 (a.children) is already used by this callback."
+    ])
+
+
+def test_dvcv004_duplicate_outputs_across_callbacks(dash_duo):
+    app = dash.Dash(__name__)
+    app.layout = html.Div([html.Div(id="a"), html.Div(id="b"), html.Div(id="c")])
+
+    @app.callback(
+        [Output("a", "children"), Output("a", "style")],
+        [Input("b", "children")]
+    )
+    def x(b):
+        return b, b
+
+    @app.callback(Output("b", "children"), [Input("b", "style")])
+    def y(b):
+        return b
+
+    @app.callback(Output("a", "children"), [Input("b", "children")])
+    def x2(b):
+        return b
+
+    @app.callback(
+        [Output("b", "children"), Output("b", "style")],
+        [Input("c", "children")]
+    )
+    def y2(c):
+        return c
+
+    @app.callback(
+        [Output({"a": 1}, "children"), Output({"b": ALL, "c": 1}, "children")],
+        [Input("b", "children")]
+    )
+    def z(b):
+        return b, b
+
+    @app.callback(
+        [Output({"a": ALL}, "children"), Output({"b": 1, "c": ALL}, "children")],
+        [Input("b", "children")]
+    )
+    def z2(b):
+        return b, b
+
+    @app.callback(
+        Output({"a": MATCH}, "children"),
+        [Input({"a": MATCH, "b": 1}, "children")]
+    )
+    def z3(ab):
+        return ab
+
+    dash_duo.start_server(app, **debugging)
+
+    dash_duo.wait_for_text_to_equal(dash_duo.devtools_error_count_locator, "5")
+
+    check_error(dash_duo, 0, "Overlapping wildcard callback outputs", [
+        'Output 0 ({"a":MATCH}.children)',
+        'overlaps another output ({"a":1}.children)',
+        "used in a different callback.",
+    ])
+
+    check_error(dash_duo, 1, "Overlapping wildcard callback outputs", [
+        'Output 1 ({"b":1,"c":ALL}.children)',
+        'overlaps another output ({"b":ALL,"c":1}.children)',
+        "used in a different callback.",
+    ])
+
+    check_error(dash_duo, 2, "Overlapping wildcard callback outputs", [
+        'Output 0 ({"a":ALL}.children)',
+        'overlaps another output ({"a":1}.children)',
+        "used in a different callback.",
+    ])
+
+    check_error(dash_duo, 3, "Duplicate callback outputs", [
+        "Output 0 (b.children) is already in use."
+    ])
+
+    check_error(dash_duo, 4, "Duplicate callback outputs", [
+        "Output 0 (a.children) is already in use."
+    ])
+
+
+def test_dvcv005_input_output_overlap(dash_duo):
+    app = dash.Dash(__name__)
+    app.layout = html.Div([html.Div(id="a"), html.Div(id="b"), html.Div(id="c")])
+
+    @app.callback(Output("a", "children"), [Input("a", "children")])
+    def x(a):
+        return a
+
+    @app.callback(
+        [Output("b", "children"), Output("c", "children")],
+        [Input("c", "children")]
+    )
+    def y(c):
+        return c, c
+
+    @app.callback(Output({"a": ALL}, "children"), [Input({"a": 1}, "children")])
+    def x2(a):
+        return [a]
+
+    @app.callback(
+        [Output({"b": MATCH}, "children"), Output({"b": MATCH, "c": 1}, "children")],
+        [Input({"b": MATCH, "c": 1}, "children")]
+    )
+    def y2(c):
+        return c, c
+
+    dash_duo.start_server(app, **debugging)
+
+    dash_duo.wait_for_text_to_equal(dash_duo.devtools_error_count_locator, "6")
+
+    check_error(dash_duo, 0, "Dependency Cycle Found: a.children -> a.children", [])
+    check_error(dash_duo, 1, "Circular Dependencies", [])
+
+    check_error(dash_duo, 2, "Same `Input` and `Output`", [
+        'Input 0 ({"b":MATCH,"c":1}.children)',
+        "can match the same component(s) as",
+        'Output 1 ({"b":MATCH,"c":1}.children)',
+    ])
+
+    check_error(dash_duo, 3, "Same `Input` and `Output`", [
+        'Input 0 ({"a":1}.children)',
+        "can match the same component(s) as",
+        'Output 0 ({"a":ALL}.children)',
+    ])
+
+    check_error(dash_duo, 4, "Same `Input` and `Output`", [
+        "Input 0 (c.children)",
+        "matches Output 1 (c.children)",
+    ])
+
+    check_error(dash_duo, 5, "Same `Input` and `Output`", [
+        "Input 0 (a.children)",
+        "matches Output 0 (a.children)",
+    ])
+
+
+def test_dvcv006_inconsistent_wildcards(dash_duo):
+    app = dash.Dash(__name__)
+    app.layout = html.Div()
+
+    @app.callback(
+        [Output({"b": MATCH}, "children"), Output({"b": ALL, "c": 1}, "children")],
+        [Input({"b": MATCH, "c": 2}, "children")]
+    )
+    def x(c):
+        return c, [c]
+
+    @app.callback(
+        [Output({"a": MATCH}, "children")],
+        [Input({"b": MATCH}, "children"), Input({"c": ALLSMALLER}, "children")],
+        [State({"d": MATCH, "dd": MATCH}, "children"), State({"e": ALL}, "children")]
+    )
+    def y(b, c, d, e):
+        return b + c + d + e
+
+    dash_duo.start_server(app, **debugging)
+
+    dash_duo.wait_for_text_to_equal(dash_duo.devtools_error_count_locator, "4")
+
+    check_error(dash_duo, 0, "`Input` / `State` wildcards not in `Output`s", [
+        'State 0 ({"d":MATCH,"dd":MATCH}.children)',
+        "has MATCH or ALLSMALLER on key(s) d, dd",
+        'where Output 0 ({"a":MATCH}.children)',
+    ])
+
+    check_error(dash_duo, 1, "`Input` / `State` wildcards not in `Output`s", [
+        'Input 1 ({"c":ALLSMALLER}.children)',
+        "has MATCH or ALLSMALLER on key(s) c",
+        'where Output 0 ({"a":MATCH}.children)',
+    ])
+
+    check_error(dash_duo, 2, "`Input` / `State` wildcards not in `Output`s", [
+        'Input 0 ({"b":MATCH}.children)',
+        "has MATCH or ALLSMALLER on key(s) b",
+        'where Output 0 ({"a":MATCH}.children)',
+    ])
+
+    check_error(dash_duo, 3, "Mismatched `MATCH` wildcards across `Output`s", [
+        'Output 1 ({"b":ALL,"c":1}.children)',
+        "does not have MATCH wildcards on the same keys as",
+        'Output 0 ({"b":MATCH}.children).',
+    ])
+
+
+def test_dvcv007_disallowed_ids(dash_duo):
+    app = dash.Dash(__name__)
+    app.layout = html.Div()
+
+    @app.callback(
+        Output({"": 1, "a": [4], "c": ALLSMALLER}, "children"),
+        [Input({"b": {"c": 1}}, "children")]
+    )
+    def y(b):
+        return b
+
+    dash_duo.start_server(app, **debugging)
+
+    dash_duo.wait_for_text_to_equal(dash_duo.devtools_error_count_locator, "4")
+
+    check_error(dash_duo, 0, "Callback wildcard ID error", [
+        'Input[0].id["b"] = {"c":1}',
+        "Wildcard callback ID values must be either wildcards",
+        "or constants of one of these types:",
+        "string, number, boolean",
+    ])
+
+    check_error(dash_duo, 1, "Callback wildcard ID error", [
+        'Output[0].id["c"] = ALLSMALLER',
+        "Allowed wildcards for Outputs are:",
+        "ALL, MATCH",
+    ])
+
+    check_error(dash_duo, 2, "Callback wildcard ID error", [
+        'Output[0].id["a"] = [4]',
+        "Wildcard callback ID values must be either wildcards",
+        "or constants of one of these types:",
+        "string, number, boolean",
+    ])
+
+    check_error(dash_duo, 3, "Callback wildcard ID error", [
+        'Output[0].id has key ""',
+        "Keys must be non-empty strings."
+    ])
diff --git a/tests/integration/test_integration.py b/tests/integration/test_integration.py
index 7c23526f..89ab27b4 100644
--- a/tests/integration/test_integration.py
+++ b/tests/integration/test_integration.py
@@ -1,6 +1,5 @@
 from multiprocessing import Value
 import datetime
-import time
 import pytest
 from copy import copy
 
@@ -18,8 +17,6 @@ from dash import Dash, no_update
 from dash.dependencies import Input, Output, State
 from dash.exceptions import (
     PreventUpdate,
-    DuplicateCallbackOutput,
-    CallbackException,
     InvalidCallbackReturnValue,
     IncorrectTypeException,
     NonExistentIdException,
@@ -383,125 +380,6 @@ def test_inin010_func_layout_accepted(dash_duo):
     assert dash_duo.find_element("#a").text == "Hello World"
 
 
-def test_inin011_multi_output(dash_duo):
-    app = Dash(__name__)
-
-    app.layout = html.Div(
-        [
-            html.Button("OUTPUT", id="output-btn"),
-            html.Table(
-                [
-                    html.Thead(
-                        [html.Tr([html.Th("Output 1"), html.Th("Output 2")])]
-                    ),
-                    html.Tbody(
-                        [
-                            html.Tr(
-                                [html.Td(id="output1"), html.Td(id="output2")]
-                            )
-                        ]
-                    ),
-                ]
-            ),
-            html.Div(id="output3"),
-            html.Div(id="output4"),
-            html.Div(id="output5"),
-        ]
-    )
-
-    @app.callback(
-        [Output("output1", "children"), Output("output2", "children")],
-        [Input("output-btn", "n_clicks")],
-        [State("output-btn", "n_clicks_timestamp")],
-    )
-    def on_click(n_clicks, n_clicks_timestamp):
-        if n_clicks is None:
-            raise PreventUpdate
-
-        return n_clicks, n_clicks_timestamp
-
-    # Dummy callback for DuplicateCallbackOutput test.
-    @app.callback(
-        Output("output3", "children"), [Input("output-btn", "n_clicks")]
-    )
-    def dummy_callback(n_clicks):
-        if n_clicks is None:
-            raise PreventUpdate
-
-        return "Output 3: {}".format(n_clicks)
-
-    with pytest.raises(DuplicateCallbackOutput) as err:
-
-        @app.callback(
-            Output("output1", "children"), [Input("output-btn", "n_clicks")]
-        )
-        def on_click_duplicate(n_clicks):
-            if n_clicks is None:
-                raise PreventUpdate
-            return "something else"
-
-        pytest.fail("multi output can't be included in a single output")
-
-    assert "output1" in err.value.args[0]
-
-    with pytest.raises(DuplicateCallbackOutput) as err:
-
-        @app.callback(
-            [Output("output3", "children"), Output("output4", "children")],
-            [Input("output-btn", "n_clicks")],
-        )
-        def on_click_duplicate_multi(n_clicks):
-            if n_clicks is None:
-                raise PreventUpdate
-            return "something else"
-
-        pytest.fail("multi output cannot contain a used single output")
-
-    assert "output3" in err.value.args[0]
-
-    with pytest.raises(DuplicateCallbackOutput) as err:
-
-        @app.callback(
-            [Output("output5", "children"), Output("output5", "children")],
-            [Input("output-btn", "n_clicks")],
-        )
-        def on_click_same_output(n_clicks):
-            return n_clicks
-
-        pytest.fail("same output cannot be used twice in one callback")
-
-    assert "output5" in err.value.args[0]
-
-    with pytest.raises(DuplicateCallbackOutput) as err:
-
-        @app.callback(
-            [Output("output1", "children"), Output("output5", "children")],
-            [Input("output-btn", "n_clicks")],
-        )
-        def overlapping_multi_output(n_clicks):
-            return n_clicks
-
-        pytest.fail(
-            "no part of an existing multi-output can be used in another"
-        )
-    assert (
-        "Already used:" in err.value.args[0] and
-        "output1.children" in err.value.args[0]
-    )
-
-    dash_duo.start_server(app)
-
-    t = time.time()
-
-    btn = dash_duo.find_element("#output-btn")
-    btn.click()
-    time.sleep(1)
-
-    dash_duo.wait_for_text_to_equal("#output1", "1")
-
-    assert int(dash_duo.find_element("#output2").text) > t
-
-
 def test_inin012_multi_output_no_update(dash_duo):
     app = Dash(__name__)
 
@@ -781,38 +659,6 @@ def test_inin017_late_component_register(dash_duo):
     dash_duo.find_element("#inserted-input")
 
 
-def test_inin018_output_input_invalid_callback():
-    app = Dash(__name__)
-    app.layout = html.Div(
-        [html.Div("child", id="input-output"), html.Div(id="out")]
-    )
-
-    with pytest.raises(CallbackException) as err:
-
-        @app.callback(
-            Output("input-output", "children"),
-            [Input("input-output", "children")],
-        )
-        def failure(children):
-            pass
-
-    msg = "Same `Output` and `Input`: input-output.children"
-    assert err.value.args[0] == msg
-
-    # Multi output version.
-    with pytest.raises(CallbackException) as err:
-
-        @app.callback(
-            [Output("out", "children"), Output("input-output", "children")],
-            [Input("input-output", "children")],
-        )
-        def failure2(children):
-            pass
-
-    msg = "Same `Output` and `Input`: input-output.children"
-    assert err.value.args[0] == msg
-
-
 def test_inin019_callback_dep_types():
     app = Dash(__name__)
     app.layout = html.Div(

commit ca9542bd5e1c716257b3206dba8b58d1df1900fe
Author: chriddyp <chris@plot.ly>
Date:   Wed Apr 27 15:56:42 2016 -0400

    :wrench: fix dispatch queue and mimic async POSTs with setTimeout

diff --git a/renderer/src/actions/index.js b/renderer/src/actions/index.js
index e886906f..a46c08d5 100644
--- a/renderer/src/actions/index.js
+++ b/renderer/src/actions/index.js
@@ -1,9 +1,10 @@
 import R from 'ramda';
 import { createAction } from 'redux-actions';
+import utils from '../reducers/utils';
 
 export const ACTIONS = (action) => {
     const actionList = {
-        ON_PROP_CHANGE: 'ON_PROP_CHANGE'
+        ON_PROP_CHANGE: 'ON_PROP_CHANGE',
         SET_REQUEST_QUEUE: 'SET_REQUEST_QUEUE'
     };
     if (actionList[action]) return actionList[action];
@@ -22,59 +23,72 @@ export const updateDependants = function(payload) {
             paths,
             requestQueue
         } = getState();
-        let dependentIds = dependencyGraph.dependantsOf(payload.id);
 
-        // order the dependent ids
+        // Grab the ids of any components that depend on this component
+        let dependantIds = dependencyGraph.dependantsOf(payload.id);
+
+        // order the dependant ids
         const depOrder = dependencyGraph.overallOrder();
-        dependentIds = R.sort(
+        dependantIds = R.sort(
             (a, b) => depOrder.indexOf(a) - depOrder.indexOf(b),
-            dependentIds
+            dependantIds
         );
 
         // record the set of requests in the queue
-        dispatch(setRequestQueue(R.union(dependentIds, requestQueue)));
-
-        for (let i = 0; i < dependentIds.length; i++) {
-            const dependentId = dependentIds[i];
-            const dependentComponent = layout.getIn(paths[dependentId]);
+        dispatch(setRequestQueue(R.union(dependantIds, requestQueue)));
 
-            const payload = dependentComponent.get('dependencies').reduce(
-                (r, id) => {
-                    r[id] = layout.getIn(R.append('props', paths[id])).toJS();
-                    return r;
-                }, {target: dependentId}
-            );
+        // update each dependant component
+        for (let i = 0; i < dependantIds.length; i++) {
+            const dependantId = dependantIds[i];
+            const dependantComponent = layout.getIn(paths[dependantId]);
 
             /*
-             * before we make the POST, check that some recursive call hasn't
-             * already cleared this request from the queue
+             * before we make the POST, check that none of it's dependencies
+             * are already in the queue. if they are in the queue, then don't update.
+             * when each dependency updates, it'll dispatch it's own `updateDependants`
+             * action which will allow this component to update.
              */
-            if (getState().requestQueue.indexOf(dependentId) > -1) {
+            if (R.intersection(
+                    getState().requestQueue,
+                    dependencyGraph.dependenciesOf(dependantId)
+                ).length === 0) {
+
+                // construct a payload of the props of all of the dependencies
+                const payload = dependantComponent.get('dependencies').reduce(
+                    (r, id) => {
+                        r[id] = layout.getIn(R.append('props', paths[id])).toJS();
+                        return r;
+                    }, {target: dependantId}
+                );
 
                 // make the /POST
                 // xhr.POST(/update-component) ...
                 console.warn('POST /update-component', JSON.stringify(payload, null, 2));
 
-                // clear this item from the request queue
-                dispatch(setRequestQueue(
-                    R.reject(
-                        id => id === dependentId,
-                        // in an async loop so grab the state again
-                        getState().requestQueue)
-                    )
-                );
+                // mimic async POST request behaviour with setTimeout
+                setTimeout(() => {
+                    // clear this item from the request queue
+                    console.warn(`RESPONSE ${dependantId}`);
+                    dispatch(setRequestQueue(
+                        R.reject(
+                            id => id === dependantId,
+                            // in an async loop so grab the state again
+                            getState().requestQueue)
+                        )
+                    );
 
-                // and update the props of the component
-                const dependentUpdatePayload = {
-                    id: dependentId,
-                    itempath: paths[dependentId],
-                    // new props from the server, just hard coded here
-                    value: 1000*Math.random()
-                };
-                dispatch(updateProps(dependentUpdatePayload));
+                    // and update the props of the component
+                    const dependantUpdatePayload = {
+                        itempath: paths[dependantId],
+                        // new props from the server, just hard coded here
+                        props: {value: 1000*Math.random()}
+                    };
+                    dispatch(updateProps(dependantUpdatePayload));
 
-                // and now update *this* component's dependencies
-                dispatch(updateDependants(dependentUpdatePayload));
+                    // and now update *this* component's dependencies
+                    dependantUpdatePayload.id = dependantId;
+                    dispatch(updateDependants(dependantUpdatePayload));
+                }, 10000*Math.random());
 
             }
 

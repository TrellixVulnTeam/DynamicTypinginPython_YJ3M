commit 5b10597b4e168173eda7be313bdd8b280cf1b2b0
Author: Philippe Duval <philippe@plot.ly>
Date:   Wed Aug 15 17:44:39 2018 -0400

    Add assets filewatcher to reload on assets changes.

diff --git a/dash/_utils.py b/dash/_utils.py
index 17dc247e..811da08e 100644
--- a/dash/_utils.py
+++ b/dash/_utils.py
@@ -1,3 +1,6 @@
+import uuid
+
+
 def interpolate_str(template, **data):
     s = template
     for k, v in data.items():
@@ -20,12 +23,15 @@ def format_tag(tag_name, attributes, inner='', closed=False, opened=False):
             '{}="{}"'.format(k, v) for k, v in attributes.items()]))
 
 
+def generate_hash():
+    return str(uuid.uuid4().hex).strip('-')
+
+
 def get_asset_path(
         requests_pathname,
         routes_pathname,
         asset_path,
         asset_url_path):
-
     i = requests_pathname.rfind(routes_pathname)
     req = requests_pathname[:i]
 
diff --git a/dash/_watch.py b/dash/_watch.py
new file mode 100644
index 00000000..e165cf0e
--- /dev/null
+++ b/dash/_watch.py
@@ -0,0 +1,26 @@
+import collections
+import os
+import re
+import time
+
+
+def watch(folders, on_change, pattern=None, sleep_time=0.1):
+    pattern = re.compile(pattern) if pattern else None
+    watched = collections.defaultdict(lambda: -1)
+
+    def walk():
+        for folder in folders:
+            for current, _, files, in os.walk(folder):
+                for f in files:
+                    if pattern and not pattern.search(f):
+                        continue
+                    path = os.path.join(current, f)
+                    info = os.stat(path)
+                    new_time = info.st_mtime
+                    if new_time > watched[path] > 0:
+                        on_change(path)
+                    watched[path] = new_time
+
+    while True:
+        walk()
+        time.sleep(sleep_time)
diff --git a/dash/dash.py b/dash/dash.py
index 975a471e..e738c188 100644
--- a/dash/dash.py
+++ b/dash/dash.py
@@ -6,7 +6,7 @@ import collections
 import importlib
 import json
 import pkgutil
-import uuid
+import threading
 import warnings
 import re
 
@@ -25,6 +25,8 @@ from . import exceptions
 from ._utils import AttributeDict as _AttributeDict
 from ._utils import interpolate_str as _interpolate
 from ._utils import format_tag as _format_tag
+from ._utils import generate_hash as _generate_hash
+from . import _watch
 from ._utils import get_asset_path as _get_asset_path
 from . import _configs
 
@@ -105,10 +107,6 @@ class Dash(object):
         )
         self._assets_url_path = assets_url_path
 
-        self._reload_hash = str(uuid.uuid4().hex).strip('-')\
-            if hot_reload else ''
-        self._reload_interval = hot_reload_interval
-
         # allow users to supply their own flask server
         self.server = server or Flask(name, static_folder=static_folder)
 
@@ -233,6 +231,20 @@ class Dash(object):
         self.server.errorhandler(exceptions.InvalidResourceError)(
             self._invalid_resources_handler)
 
+        # hot reload
+        self._reload_hash = _generate_hash() \
+            if hot_reload else ''
+        self._reload_interval = hot_reload_interval
+        self._hard_reload = False
+        self._lock = threading.RLock()
+        self._watch_thread = None
+        if hot_reload:
+            self._watch_thread = threading.Thread(
+                target=lambda: _watch.watch([self._assets_folder],
+                                            self._on_assets_change,
+                                            sleep_time=0.5))
+            self._watch_thread.start()
+
     def _add_url(self, name, view_func, methods=('GET',)):
         self.server.add_url_rule(
             name,
@@ -315,7 +327,10 @@ class Dash(object):
         return config
 
     def serve_reload_hash(self):
-        return flask.jsonify({'reloadHash': self._reload_hash})
+        return flask.jsonify({
+            'reloadHash': self._reload_hash,
+            'hard': self._hard_reload
+        })
 
     def serve_routes(self):
         return flask.Response(
@@ -1054,6 +1069,12 @@ class Dash(object):
         )
         return debug
 
+    def _on_assets_change(self, _):
+        self._lock.acquire()
+        self._hard_reload = True
+        self._reload_hash = _generate_hash()
+        self._lock.release()
+
     def run_server(self,
                    port=8050,
                    debug=False,

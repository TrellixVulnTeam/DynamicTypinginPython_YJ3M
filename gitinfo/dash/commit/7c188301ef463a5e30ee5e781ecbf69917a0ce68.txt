commit 7c188301ef463a5e30ee5e781ecbf69917a0ce68
Author: alexcjohnson <alex@plot.ly>
Date:   Tue Feb 4 19:05:52 2020 -0500

    trigger wildcard callbacks when items deleted from an array input

diff --git a/dash-renderer/src/actions/dependencies.js b/dash-renderer/src/actions/dependencies.js
index 07cc6fba..343d9e78 100644
--- a/dash-renderer/src/actions/dependencies.js
+++ b/dash-renderer/src/actions/dependencies.js
@@ -728,13 +728,18 @@ export function getWatchedKeys(id, newProps, graphs) {
  *
  * opts.outputsOnly: boolean, set true when crawling the *whole* layout,
  *   because outputs are enough to get everything.
+ * opts.removedArrayInputsOnly: boolean, set true to only look for inputs in
+ *   wildcard arrays (ALL or ALLSMALLER), no outputs. This gets used to tell
+ *   when the new *absence* of a given component should trigger a callback.
+ * opts.newPaths: paths object after the edit - to be used with
+ *   removedArrayInputsOnly to determine if the callback still has its outputs
  *
  * Returns an array of objects:
  *   {callback, resolvedId, getOutputs, getInputs, getState, ...etc}
  *   See getCallbackByOutput for details.
  */
 export function getCallbacksInLayout(graphs, paths, layoutChunk, opts) {
-    const {outputsOnly} = opts || {};
+    const {outputsOnly, removedArrayInputsOnly, newPaths} = opts || {};
     const foundCbIds = {};
     const callbacks = [];
 
@@ -753,6 +758,26 @@ export function getCallbacksInLayout(graphs, paths, layoutChunk, opts) {
         }
     }
 
+    function addCallbackIfArray(idStr) {
+        return cb =>
+            cb.getInputs(paths).some(ini => {
+                if (
+                    Array.isArray(ini) &&
+                    ini.some(inij => stringifyId(inij.id) === idStr)
+                ) {
+                    // This callback should trigger even with no changedProps,
+                    // since the props that changed no longer exist.
+                    if (flatten(cb.getOutputs(newPaths)).length) {
+                        cb.initialCall = true;
+                        cb.changedPropIds = {};
+                        addCallback(cb);
+                    }
+                    return true;
+                }
+                return false;
+            });
+    }
+
     function handleOneId(id, outIdCallbacks, inIdCallbacks) {
         if (outIdCallbacks) {
             for (const property in outIdCallbacks) {
@@ -765,9 +790,12 @@ export function getCallbacksInLayout(graphs, paths, layoutChunk, opts) {
             }
         }
         if (!outputsOnly && inIdCallbacks) {
+            const idStr = removedArrayInputsOnly && stringifyId(id);
             for (const property in inIdCallbacks) {
                 getCallbacksByInput(graphs, paths, id, property).forEach(
-                    addCallback
+                    removedArrayInputsOnly
+                        ? addCallbackIfArray(idStr)
+                        : addCallback
                 );
             }
         }
@@ -776,7 +804,7 @@ export function getCallbacksInLayout(graphs, paths, layoutChunk, opts) {
     crawlLayout(layoutChunk, child => {
         const id = path(['props', 'id'], child);
         if (id) {
-            if (typeof id === 'string') {
+            if (typeof id === 'string' && !removedArrayInputsOnly) {
                 handleOneId(id, graphs.outputMap[id], graphs.inputMap[id]);
             } else {
                 const keyStr = Object.keys(id)
@@ -784,7 +812,7 @@ export function getCallbacksInLayout(graphs, paths, layoutChunk, opts) {
                     .join(',');
                 handleOneId(
                     id,
-                    graphs.outputPatterns[keyStr],
+                    !removedArrayInputsOnly && graphs.outputPatterns[keyStr],
                     graphs.inputPatterns[keyStr]
                 );
             }
diff --git a/dash-renderer/src/actions/index.js b/dash-renderer/src/actions/index.js
index 90262764..26e84663 100644
--- a/dash-renderer/src/actions/index.js
+++ b/dash-renderer/src/actions/index.js
@@ -284,6 +284,8 @@ async function fireReadyCallbacks(dispatch, getState, callbacks) {
             Object.entries(data).forEach(([id, props]) => {
                 const parsedId = parseIfWildcard(id);
 
+                const {layout: oldLayout, paths: oldPaths} = getState();
+
                 const appliedProps = doUpdateProps(
                     dispatch,
                     getState,
@@ -296,16 +298,25 @@ async function fireReadyCallbacks(dispatch, getState, callbacks) {
                     });
 
                     if (has('children', appliedProps)) {
+                        const oldChildren = path(
+                            concat(getPath(oldPaths, parsedId), [
+                                'props',
+                                'children',
+                            ]),
+                            oldLayout
+                        );
                         // If components changed, need to update paths,
                         // check if all pending callbacks are still
                         // valid, and add all callbacks associated with
-                        // new components, either as inputs or outputs
+                        // new components, either as inputs or outputs,
+                        // or components removed from ALL/ALLSMALLER inputs
                         pendingCallbacks = updateChildPaths(
                             dispatch,
                             getState,
                             pendingCallbacks,
                             parsedId,
-                            appliedProps.children
+                            appliedProps.children,
+                            oldChildren
                         );
                     }
 
@@ -522,7 +533,14 @@ function doUpdateProps(dispatch, getState, id, updatedProps) {
     return props;
 }
 
-function updateChildPaths(dispatch, getState, pendingCallbacks, id, children) {
+function updateChildPaths(
+    dispatch,
+    getState,
+    pendingCallbacks,
+    id,
+    children,
+    oldChildren
+) {
     const {paths: oldPaths, graphs} = getState();
     const childrenPath = concat(getPath(oldPaths, id), ['props', 'children']);
     const paths = computePaths(children, childrenPath, oldPaths);
@@ -566,7 +584,21 @@ function updateChildPaths(dispatch, getState, pendingCallbacks, id, children) {
     });
 
     const newCallbacks = getCallbacksInLayout(graphs, paths, children);
-    return mergePendingCallbacks(cleanedCallbacks, newCallbacks);
+
+    // Wildcard callbacks with array inputs (ALL / ALLSMALLER) need to trigger
+    // even due to the deletion of components
+    const deletedComponentCallbacks = getCallbacksInLayout(
+        graphs,
+        oldPaths,
+        oldChildren,
+        {removedArrayInputsOnly: true, newPaths: paths}
+    );
+
+    const allNewCallbacks = mergePendingCallbacks(
+        newCallbacks,
+        deletedComponentCallbacks
+    );
+    return mergePendingCallbacks(cleanedCallbacks, allNewCallbacks);
 }
 
 export function notifyObservers({id, props}) {
diff --git a/tests/integration/callbacks/test_wildcards.py b/tests/integration/callbacks/test_wildcards.py
index f964f2c4..bffdbe1c 100644
--- a/tests/integration/callbacks/test_wildcards.py
+++ b/tests/integration/callbacks/test_wildcards.py
@@ -213,6 +213,6 @@ def test_cbwc001_todo_app(dash_duo):
     assert_item(1, "dates", True)
 
     clear_done.click()
-    # TODO - totals currently broken
-    # dash_duo.wait_for_text_to_equal("#totals", "0 of 0 items completed")
-    # assert_count(0)
+    # This was a tricky one - trigger based on deleted components
+    dash_duo.wait_for_text_to_equal("#totals", "0 of 0 items completed")
+    assert_count(0)

commit a7165ba0e6937f4e85c6e1cd60c70bafcb1d7b3e
Author: chriddyp <chris@plot.ly>
Date:   Wed Feb 8 16:45:34 2017 -0500

    tighten up abstract component class
    
    - ABC: inherit MutableMapping to get a bunch of methods for free
    - Make `content` a prop
    - Support `content` as a string, Component, or list
    - Support setting `None` as an argument (transformed into a `null` prop)

diff --git a/dash/development/base_component.py b/dash/development/base_component.py
index 785a43cc..3b1c27ce 100644
--- a/dash/development/base_component.py
+++ b/dash/development/base_component.py
@@ -1,97 +1,164 @@
 import collections
 import types
 
-class Component(collections.MutableSequence):
-    def __init__(self, **kwargs):
-        if 'dependencies' in kwargs:
-            self.dependencies = kwargs['dependencies']
-
-        # content is special and must be set here
-        self.content = kwargs.get('content', None)
-
-        # Iterate over kwargs and set all other properties
-        for prop in kwargs:
-            prop_value = kwargs.get(prop, None)
-            if (prop != 'content' and prop_value is not None):
-                setattr(self, prop, prop_value)
 
+class Component(collections.MutableMapping):
+    def __init__(self, **kwargs):
+        for k, v in kwargs.iteritems():
+            if k not in self._prop_names:
+                # TODO - What's the right exception here?
+                raise Exception(
+                    'Unexpected keyword argument `{}`'.format(k) +
+                    '\nAllowed arguments: {}'.format(
+                        ', '.join(self._prop_names)
+                    )
+                )
+            setattr(self, k, v)
 
     def to_plotly_json(self):
         as_json = {
             'props': {p: getattr(self, p)
                       for p in self._prop_names
-                      if p != 'content' and hasattr(self, p)},
+                      if hasattr(self, p)},
             'type': self._type,
-            'namespace': self._namespace,
-            'children': self.content
+            'namespace': self._namespace
         }
         if hasattr(self, 'dependencies'):
             as_json['dependencies'] = self.dependencies
         return as_json
 
-    def __getitem__(self, id):
-        if isinstance(self.content, basestring) or self.content is None:
+    def _check_if_has_indexable_content(self, item):
+        if (not hasattr(item, 'content') or
+                item.content is None or
+                isinstance(item.content, basestring)):
             raise KeyError
 
-        for item in self.content:
-            if isinstance(item, basestring) or self.content is None:
-                continue
-            elif getattr(item, 'id', None) == id:
-                return item
+    def _get_set_or_delete(self, id, operation, new_item=None):
+        self._check_if_has_indexable_content(self)
+
+        if isinstance(self.content, Component):
+            if getattr(self.content, 'id', None) is not None:
+                if self.content.id == id:
+                    if operation == 'get':
+                        return self.content
+                    elif operation == 'set':
+                        self.content = new_item
+                        return
+                    elif operation == 'delete':
+                        self.content = None
+                        return
+                else:
+                    raise KeyError
+
+        # if content is like a list
+        for (i, item) in enumerate(self.content):
+            # If the item itself is the one we're looking for
+            if getattr(item, 'id', None) == id:
+                if operation == 'get':
+                    return item
+                elif operation == 'set':
+                    self.content[i] = new_item
+                    return
+                elif operation == 'delete':
+                    del self.content[i]
+                    return
+
+            # Otherwise, recursively dig into that items subtree
             try:
-                component = item[id]
-            except:
+                if operation == 'get':
+                    return item.__getitem__(id)
+                elif operation == 'set':
+                    item.__setitem__(id, new_item)
+                    return
+                elif operation == 'delete':
+                    item.__delitem__(id)
+                    return
+            except KeyError:
                 pass
-            else:
-                return component
+
         raise KeyError
 
-    def __setitem__(self, index, component):
-        if isinstance(self.content, basestring) or self.content is None:
-            raise KeyError
-        self.content.__setitem__(index, component)
+    # Supply ABC methods for a MutableMapping:
+    # - __getitem__
+    # - __setitem__
+    # - __delitem__
+    # - __iter__
+    # - __len__
+
+    def __getitem__(self, id):
+        '''Recursively find the element with the given ID through the tree
+        of content.
+        '''
+        # TODO - Rename content to children
+        # A component's content can be undefined, a string, another component,
+        # or a list of components.
+        return self._get_set_or_delete(id, 'get')
+
+    def __setitem__(self, id, item):
+        return self._get_set_or_delete(id, 'set', item)
 
     def __delitem__(self, id):
-        if isinstance(self.content, basestring) or self.content is None:
-            raise KeyError
+        return self._get_set_or_delete(id, 'delete')
 
-        for i, item in enumerate(self.content):
-            if isinstance(item, basestring) or self.content is None:
-                continue
-            else:
-                if item.id == id:
-                    self.content.__delitem__(i)
-                    return
-            try:
-                item.__delitem__(id)
-            except:
-                pass
-            else:
-                return
-        raise KeyError
+    def __iter__(self):
+        content = getattr(self, 'content', None)
+
+        # content is just a component
+        if (isinstance(content, Component) and
+                getattr(self.content, 'id', None) is not None):
+
+            yield self.content.id
+
+        # content is a list of components
+        # TODO - Stronger check for list?
+        if (not isinstance(content, basestring) and
+                not isinstance(content, Component) and
+                content is not None):
+
+            for i in content:
+
+                if getattr(i, 'id', None) is not None:
+                    yield i.id
+
+                if hasattr(i, 'content'):
+                    for t in i.__iter__():
+                        yield t
 
     def __len__(self):
-        if isinstance(self.content, basestring) or self.content is None:
-            return 1
+        '''Return the number of items in the tree
+        '''
+        l = 0
+        if getattr(self, 'content', None) is None:
+            l = 0
+        elif isinstance(self.content, basestring):
+            l = 1
+        elif isinstance(self.content, Component):
+            l = 1
         else:
-            count = 1
-            for item in self.content:
-                if (isinstance(self.content, basestring) or
-                   self.content is None):
-                    count += 1
-                else:
-                    count += item.__len__()
-            return count
+            for c in self.content:
+                l += 1
+                l += len(c)
+        return l
 
-    def insert(self, index, component):
-        if isinstance(self.content, basestring) or self.content is None:
-            self.content = [self.content]
-        self.content.insert(index, component)
 
+def generate_class(typename, component_arguments, namespace):
+    # Dynamically generate classes to have nicely formatted docstrings,
+    # keyword arguments, and repr
+    # Insired by http://jameso.be/2013/08/06/namedtuple.html
 
-def generate_class(typename, component_arguments, setup, namespace):
-    # http://jameso.be/2013/08/06/namedtuple.html
     import sys
+
+    # TODO - Tab out the repr for the repr of these components to make it
+    # look more like a heirarchical tree
+    # TODO - Include "description" "defaultValue" in the repr and docstring
+    # TODO - Handle "required"
+    # TODO - How to handle user-given `null` values? I want to include
+    # an expanded docstring like Dropdown(value=None, id=None)
+    # but by templating in those None values, I have no way of knowing
+    # whether a property is None because the user explicitly wanted
+    # it to be `null` or whether that was just the default value.
+    # The solution might be to deal with default values better although
+    # not all component authors will supply those.
     c = '''class {typename}(Component):
         """A {typename} component.\nValid keys:\n{bullet_list_of_valid_keys}
         """
@@ -100,35 +167,32 @@ def generate_class(typename, component_arguments, setup, namespace):
             self._type = '{typename}'
             self._namespace = '{namespace}'
             super({typename}, self).__init__({argtext})
-            setup(self)
 
         def __repr__(self):
             if(any(getattr(self, c, None) is not None for c in self._prop_names
-                   if c is not "content")):
-                return '{typename}(\\n    '+', \\n    '.join([c+'='+repr(getattr(self, c, None))
-                                                for c in self._prop_names if getattr(self, c, None) is not None])+'\\n)'
+                   if c is not self._prop_names[0])):
+
+                return '{typename}('+', '.join([c+'='+repr(getattr(self, c, None))
+                                                for c in self._prop_names if getattr(self, c, None) is not None])+')'
+
             else:
-                return '{typename}(' + repr(self.content) + ')'
+                return '{typename}(' + repr(getattr(self, self._prop_names[0], None)) + ')'
     '''
-    # every component will at least have `content` argument
-    keyword_arguments = ['content']
-    keyword_arguments.extend([s for s in component_arguments if s not in keyword_arguments])
-    list_of_valid_keys = repr(keyword_arguments)
-    bullet_list_of_valid_keys = ('- ' + ' (dflt: None)\n- '.join(keyword_arguments) +
-                                 ' (dflt: None)')
-
-    default_argtext = ''
-    argtext = ''
-    for arg in keyword_arguments:
-        default_argtext += arg + '=None, '
-        argtext += arg + '=' + arg + ', '
-
-    default_argtext += '**kwargs'
-    argtext = argtext[:-2]
+    list_of_valid_keys = repr(component_arguments)
+    bullet_list_of_valid_keys = ('- ' + '\n- '.join(
+        component_arguments
+    ))
+
+    if 'content' in component_arguments:
+        default_argtext = 'content=None, **kwargs'
+        argtext = 'content=content, **kwargs'
+    else:
+        default_argtext = '**kwargs'
+        argtext = '**kwargs'
 
     d = c.format(**locals())
 
-    scope = {'Component': Component, 'setup': setup}
+    scope = {'Component': Component}
     exec d in scope
     result = scope[typename]
     return result

commit 7a192b28bf1653a10cd66a6dc92023d4e17ca8d3
Author: alexcjohnson <alex@plot.ly>
Date:   Mon Feb 10 09:20:35 2020 -0500

    simpler - and hopefully more robust - solution to callback race issue
    just set pendingCallbacks before the async await instead of after

diff --git a/dash-renderer/src/actions/index.js b/dash-renderer/src/actions/index.js
index 6cdf4d9a..ad915079 100644
--- a/dash-renderer/src/actions/index.js
+++ b/dash-renderer/src/actions/index.js
@@ -177,7 +177,7 @@ function unwrapIfNotMulti(paths, idProps, spec, anyVals, depType) {
     return idProps[0];
 }
 
-export function startCallbacks(callbacks) {
+function startCallbacks(callbacks) {
     return async function(dispatch, getState) {
         return await fireReadyCallbacks(dispatch, getState, callbacks);
     };
@@ -215,45 +215,15 @@ async function fireReadyCallbacks(dispatch, getState, callbacks) {
         return cbOut;
     });
 
-    const ids = uniq(
-        pluck(
-            'id',
-            flatten(
-                requestedCallbacks.map(cb =>
-                    concat(cb.getInputs(paths), cb.getState(paths))
-                )
-            )
-        )
-    );
-
-    await isAppReady(layout, paths, ids);
-
     const allCallbacks = concat(requestedCallbacks, blockedCallbacks);
-
-    // because of the async step above, make sure we haven't separately added
-    // more callbacks to the queue - this particular step should only be adding
-    // callbacks, not removing them.
-    const existingCallbacks = getState().pendingCallbacks;
-    if (existingCallbacks.length) {
-        const resolvedIds = {};
-        allCallbacks.forEach((cb, i) => {
-            resolvedIds[cb.resolvedId] = i;
-        });
-        existingCallbacks.forEach(existingCB => {
-            const iAll = resolvedIds[existingCB.resolvedId];
-            if (iAll === undefined) {
-                allCallbacks.push(existingCB);
-            } else if (existingCB.requestId && !allCallbacks[iAll].requestId) {
-                // already requested put the requested one in the queue
-                allCallbacks[iAll] = existingCB;
-            }
-            // otherwise either both are blocked, fine, either one will do...
-            // or both have been requested - either way keep the newer one
-        });
-    }
-
     dispatch(setPendingCallbacks(allCallbacks));
 
+    const ids = requestedCallbacks.map(cb => [
+        cb.getInputs(paths),
+        cb.getState(paths),
+    ]);
+    await isAppReady(layout, paths, uniq(pluck('id', flatten(ids))));
+
     function fireNext() {
         return fireReadyCallbacks(
             dispatch,

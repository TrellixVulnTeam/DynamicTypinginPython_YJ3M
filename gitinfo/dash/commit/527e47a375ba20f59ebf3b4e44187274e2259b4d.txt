commit 527e47a375ba20f59ebf3b4e44187274e2259b4d
Author: chriddyp <chris@plot.ly>
Date:   Wed Feb 15 14:23:49 2017 -0500

    separate state and events

diff --git a/package.json b/package.json
index 60eac9df..b20de617 100644
--- a/package.json
+++ b/package.json
@@ -22,7 +22,7 @@
     "babel-preset-es2015": "^6.6.0",
     "babel-preset-react": "^6.5.0",
     "clean-webpack-plugin": "^0.1.9",
-    "dependency-graph": "^0.4.1",
+    "dependency-graph": "^0.5.0",
     "immutable": "^3.8.1",
     "json-loader": "^0.5.4",
     "ramda": "^0.23.0",
diff --git a/src/TreeContainer.react.js b/src/TreeContainer.react.js
index 1bcd8013..ff17f111 100644
--- a/src/TreeContainer.react.js
+++ b/src/TreeContainer.react.js
@@ -19,7 +19,6 @@ const Container = connect(
     // map state to props
     state => ({
         layout: state.layout,
-        dependencyGraph: state.dependencyGraph,
         paths: state.paths
     })
 )(UnconnectedContainer);
diff --git a/src/actions/index.js b/src/actions/index.js
index a1c1cceb..42a6790d 100644
--- a/src/actions/index.js
+++ b/src/actions/index.js
@@ -1,5 +1,19 @@
-/* eslint-disable no-console */
-import R, {view, lensPath, merge} from 'ramda';
+import R, {
+    concat,
+    contains,
+    intersection,
+    isEmpty,
+    filter,
+    keys,
+    lensPath,
+    merge,
+    omit,
+    pick,
+    reject,
+    sort,
+    union,
+    view
+} from 'ramda';
 import { createAction } from 'redux-actions';
 
 export const ACTIONS = (action) => {
@@ -7,7 +21,7 @@ export const ACTIONS = (action) => {
         ON_PROP_CHANGE: 'ON_PROP_CHANGE',
         SET_REQUEST_QUEUE: 'SET_REQUEST_QUEUE',
         SET_LAYOUT: 'SET_LAYOUT',
-        COMPUTE_GRAPH: 'COMPUTE_GRAPH',
+        COMPUTE_GRAPHS: 'COMPUTE_GRAPHS',
         COMPUTE_PATHS: 'COMPUTE_PATHS'
     };
     if (actionList[action]) return actionList[action];
@@ -17,124 +31,180 @@ export const ACTIONS = (action) => {
 export const updateProps = createAction(ACTIONS('ON_PROP_CHANGE'));
 export const setRequestQueue = createAction(ACTIONS('SET_REQUEST_QUEUE'));
 const setLayout = createAction(ACTIONS('SET_LAYOUT'));
-const computeGraph = createAction(ACTIONS('COMPUTE_GRAPH'));
+const computeGraphs = createAction(ACTIONS('COMPUTE_GRAPHS'));
 const computePaths = createAction(ACTIONS('COMPUTE_PATHS'));
 
 export const initialize = function() {
-    return function (dispatch) {
+    return function (dispatch, getState) {
         console.warn('initializing GET.');
         fetch('/initialize', {method: 'GET'})
         .then(res => res.json().then(layout => {
             // TODO: error handling
-            console.warn(JSON.stringify(layout, null, 2));
             dispatch(setLayout(layout));
-            dispatch(computeGraph(layout));
-            dispatch(computePaths(layout))
+
+            // TODO - will need to recompute paths when the layout changes
+            // from request responses
+            dispatch(computePaths(layout));
+            const a = 3;
+            a = 8
         }));
+        fetch('/dependencies', {method: 'GET'})
+        .then(res => res.json().then(dependencies => {
+            dispatch(computeGraphs(dependencies));
+            /*
+             * Fire an initial propChange event for each of the controllers
+             * so that the observer leaves can update
+             */
+            // TODO - Remove this setTimeout
+            setTimeout(function(){
+                const {graphs} = getState();
+                const {EventGraph} = graphs;
+                EventGraph.overallOrder().forEach(nodeId => {
+                    dispatch(notifyObservers({event: 'propChange', id: nodeId}));
+                });
+            }, 0)
+        }))
     }
 }
 
-// TODO: Consider moving side effects to reducers via https://github.com/gregwebs/redux-side-effect
+/*
+ * TODO: Consider moving side effects to reducers via
+ * https://github.com/gregwebs/redux-side-effect
+ */
 export const notifyObservers = function(payload) {
     return function (dispatch, getState) {
+        const {
+            event,
+            id
+        } = payload
+
         const {
             layout,
-            dependencyGraph,
+            graphs,
             paths,
             requestQueue
         } = getState();
-
-        // debugger;
-
-        // Grab the ids of any components that depend on this component
-        let observerIds = dependencyGraph.dependantsOf(payload.id);
-
-        // order the observer ids
-        const depOrder = dependencyGraph.overallOrder();
-        observerIds = R.sort(
+        const {EventGraph, StateGraph} = graphs;
+
+        // Check if the event fired by `id` is actually registered
+        const allEventObservers = EventGraph.dependantsOf(id);
+
+        /*
+         * Each observer may depend on a different set of events.
+         * Filter away the observers that are listening to different events.
+         */
+        const observersAndEventSubscriptions = EventGraph.getNodeData(id);
+        let eventObservers = keys(filter(function filterObservers(observerEventSubscriptions) {
+            return contains(event, observerEventSubscriptions);
+        }, observersAndEventSubscriptions));
+
+        /*
+         * If no components have subscribed to these events,
+         * then we have no one else to tell about it.
+         */
+        if (isEmpty(eventObservers)) {
+            console.warn(`Ignore: ${id}.${event}`);
+            return;
+        }
+        console.warn(`Continue: ${id}.${event}`);
+
+        /*
+         * There may be several components that depend on this event.
+         * And some components may depend on other components before
+         * updating. Get this update order straightened out.
+         */
+        const depOrder = EventGraph.overallOrder();
+        eventObservers = sort(
             (a, b) => depOrder.indexOf(a) - depOrder.indexOf(b),
-            observerIds
+            eventObservers
         );
 
         // record the set of requests in the queue
-        dispatch(setRequestQueue(R.union(observerIds, requestQueue)));
+        dispatch(setRequestQueue(union(eventObservers, requestQueue)));
 
         // update each observer
-        for (let i = 0; i < observerIds.length; i++) {
-            const observerId = observerIds[i];
-            const observerComponent = view(lensPath(paths[observerId]), layout);
+        for (let i = 0; i < eventObservers.length; i++) {
+            const eventObserverId = eventObservers[i];
 
             /*
-             * before we make the POST, check that none of its dependencies
+             * before we make the POST, check that none of its event dependencies
              * are already in the queue. if they are in the queue, then don't update.
              * when each dependency updates, it'll dispatch its own `notifyObservers`
              * action which will allow this component to update.
+             *
+             * for example, if A updates B and C (A -> [B, C]) and B updates C
+             * (B -> C), then when A updates, we can update B but not C until
+             * B is done updating. in this scenario, B is before C from the
+             * overallOrder, so it'll get set in the requestQueue before C.
              */
 
-            const dependenciesInQueue = R.intersection(
+            const dependenciesInQueue = intersection(
                 getState().requestQueue,
-                dependencyGraph.dependenciesOf(observerId)
+                EventGraph.dependenciesOf(eventObserverId)
             );
-            if (dependenciesInQueue.length !== 0) {
-
-                console.warn(`SKIP updating ${observerId}, waiting for ${dependenciesInQueue} to update.`);
 
-            } else {
+            if (dependenciesInQueue.length !== 0) {
+                console.warn(`SKIP updating ${eventObserverId}, waiting for ${dependenciesInQueue} to update.`);
+                continue;
+            }
 
-                /*
-                 * Construct a payload of the props of all of the dependencies
-                 * (controller components of this observer component).
-                 */
-                const controllers = observerComponent.dependencies.reduce(
-                    (r, id) => {
-                        r[id] = view(lensPath(paths[id]), layout);
-                        return r;
-                    }, {}
-                );
-                const body = {
-                    target: view(lensPath(paths[observerId]), layout),
-                    parents: controllers
+            /*
+             * Construct a payload of the subscribed state
+             * For example, if graph depends on `input1` value and style
+             * and `input2` value, the payload would look like:
+             * {input1: {value: ..., style: ...,}, input2: ...}
+             */
+            let state = {};
+            StateGraph.dependenciesOf(eventObserverId).forEach(function reduceState(controllerId) {
+                state[controllerId] = {};
+                const observedProps = StateGraph.getNodeData(controllerId)[eventObserverId];
+                const propLens = lensPath(concat(paths[controllerId], ['props']));
+                const props = view(propLens, layout);
+                // TODO - Is * and omit the right pattern?
+                if (observedProps[0] === '*') {
+                    state[controllerId] = omit(['content'], props);
+                } else {
+                    state[controllerId] = pick(observedProps, props);
                 }
+            });
 
-                /* eslint-disable no-console */
+            const body = {id: eventObserverId, state};
 
-                // make the /POST
-                console.warn(`POST: ${observerId}`);
+            // make the /POST
+            console.warn(`POST: ${eventObserverId}`);
 
-                fetch('/interceptor', {
-                    method: 'POST',
-                    headers: {'Content-Type': 'application/json'},
-                    body: JSON.stringify(body)
-                }).then(response => response.json().then(function handleResponse(data) {
+            fetch('/interceptor', {
+                method: 'POST',
+                headers: {'Content-Type': 'application/json'},
+                body: JSON.stringify(body)
+            }).then(response => response.json().then(function handleResponse(data) {
 
-                    // clear this item from the request queue
-                    console.warn(
-                        `RESPONSE: ${observerId}`,
+                // clear this item from the request queue
+                console.warn(
+                    `RESPONSE: ${eventObserverId}`,
 //                        JSON.stringify(data, null, 2)
-                    );
-                    dispatch(setRequestQueue(
-                        R.reject(
-                            id => id === observerId,
-                            // in an async loop so grab the state again
-                            getState().requestQueue
-                        )
-                    ));
-
-                    // and update the props of the component
-                    const observerUpdatePayload = {
-                        itempath: paths[observerId],
-                        // new props from the server
-                        props: merge(data.response.props, {content: data.response.children})
-                    };
-                    dispatch(updateProps(observerUpdatePayload));
-
-                    // and now update *this* component's dependencies
-                    observerUpdatePayload.id = observerId;
-                    dispatch(notifyObservers(observerUpdatePayload));
-
-                }));
+                );
+                dispatch(setRequestQueue(
+                    reject(
+                        id => id === eventObserverId,
+                        // in an async loop so grab the state again
+                        getState().requestQueue
+                    )
+                ));
+
+                // and update the props of the component
+                const observerUpdatePayload = {
+                    itempath: paths[eventObserverId],
+                    // new props from the server
+                    props: merge(data.response.props, {content: data.response.children})
+                };
+                dispatch(updateProps(observerUpdatePayload));
+
+                // fire an event that the props have changed
+                // TODO - Need to wait for updateProps to finish?
+                dispatch(notifyObservers({event: 'propChange', id: eventObserverId}));
+            }));
 
-            }
         }
     }
 }
diff --git a/src/components/core/NotifyObservers.react.js b/src/components/core/NotifyObservers.react.js
index d27a9230..3c4a0ef3 100644
--- a/src/components/core/NotifyObservers.react.js
+++ b/src/components/core/NotifyObservers.react.js
@@ -1,46 +1,96 @@
+import {connect} from 'react-redux';
+import {isEmpty} from 'ramda';
+import {notifyObservers, updateProps} from '../../actions';
 import React, {PropTypes} from 'react';
-import { connect } from 'react-redux';
-
-import { notifyObservers, updateProps } from '../../actions';
 
 /*
  * NotifyObservers passes a connected `valueChanged` handler down to
  * its child as a prop
  */
 
-const mapStateToProps = () => ({});
+function mapStateToProps (state) {
+    return {graphs: state.graphs, paths: state.paths};
+}
+
+function mapDispatchToProps (dispatch) {
+    return {dispatch};
+};
+
+function mergeProps(stateProps, dispatchProps, ownProps) {
+    const {dispatch} = dispatchProps;
 
-const mapDispatchToProps = (dispatch, ownProps) => {
     return {
-        valueChanged: (newProps, event='default') => {
+        id: ownProps.id,
+        children: ownProps.children,
+
+        EventGraph: stateProps.graphs.EventGraph,
+        StateGraph: stateProps.graphs.StateGraph,
+
+        fireEvent: function fireEvent({event}) {
+            // Update this component's observers with the updated props
+            dispatch(notifyObservers({event, id: ownProps.id}));
+        },
+
+        valueChanged: function valueChanged(newProps) {
             const payload = {
-                // we *need* the ID, should we just pass / merge everything in?
-                id: React.Children.only(ownProps.children).props.id,
-                // TODO pass in the entire prop object or just updates?
                 props: newProps,
-                itempath: React.Children.only(ownProps.children).props.path
+                id: ownProps.id,
+                itempath: stateProps.paths[ownProps.id]
             };
 
             // Update this component's props
             dispatch(updateProps(payload));
 
-            // Update this component's observers with the updated props
-            dispatch(notifyObservers(payload, event));
-
+            // Fire an event that the props have changed.
+            // TODO - Will updateProps have finished by the time this is fired?
+            // TODO - Add support for subscribing to a particular prop change?
+            dispatch(notifyObservers({event: 'propChange', id: ownProps.id}));
         }
     }
-};
 
-const NotifyObservers = ({ valueChanged, children }) => {
-    // pass `valueChanged` handler as prop to the child element e.g. an <input>
-    return React.cloneElement(children, {valueChanged});
 }
 
-NotifyObservers.propTypes = {
-    valueChanged: PropTypes.func.isRequired
+function NotifyObserversComponent ({
+    children,
+    id,
+
+    EventGraph,
+    StateGraph,
+
+    fireEvent,
+    valueChanged
+}) {
+
+    // TODO - Check if it triggers this particular event
+    const thisComponentTriggersEvents = (
+        EventGraph.hasNode(id) && EventGraph.dependantsOf(id).length
+    );
+    const thisComponentSharesState = (
+        StateGraph.hasNode(id) && StateGraph.dependantsOf(id).length
+    );
+    const extraProps = {};
+    if (thisComponentSharesState) {
+        extraProps.valueChanged = valueChanged;
+    }
+    if (thisComponentTriggersEvents) {
+        extraProps.fireEvent = fireEvent;
+    }
+
+    if (!isEmpty(extraProps)) {
+        return React.cloneElement(children, extraProps);
+    } else {
+        return children;
+    }
+}
+
+NotifyObserversComponent.propTypes = {
+    id: PropTypes.string.isRequired,
+    children: PropTypes.node.isRequired,
+    path: PropTypes.array.isRequired
 };
 
 export default connect(
     mapStateToProps,
-    mapDispatchToProps
-)(NotifyObservers);
+    mapDispatchToProps,
+    mergeProps
+)(NotifyObserversComponent);
diff --git a/src/reducers/dependencyGraph.js b/src/reducers/dependencyGraph.js
index 481cbc6d..c624d981 100644
--- a/src/reducers/dependencyGraph.js
+++ b/src/reducers/dependencyGraph.js
@@ -1,41 +1,87 @@
 import {DepGraph} from 'dependency-graph';
+import {append, keys, merge} from 'ramda';
 
 import {crawlLayout} from './utils';
 
-const initialGraph = new DepGraph();
+const initialStateGraph = new DepGraph();
+const initialEventGraph = new DepGraph();
+const initialGraph = {
+    StateGraph: initialStateGraph,
+    EventGraph: initialEventGraph
+};
 
-const dependencyGraph = (state = initialGraph, action) => {
+function computeGraph(dependencies, graph, graphType) {
+    return function(observerId) {
+        // Add observers to the graph
+        if(!graph.hasNode(observerId)) {
+            console.warn(`adding '${observerId}' to graph`);
+            graph.addNode(observerId, {});
+        }
+
+        /*
+         * Add controllers to the graph with their data.
+         * data is either `state` or `event`.
+         * - `state`, which describes which props this controller
+         *            should include
+         * - `event`, which describes which events this controller
+         *            should respond to
+         */
+        dependencies[observerId][graphType].forEach(
+            function addStateNodes(controller) {
+                if(!graph.hasNode(controller.id)) {
+                    console.warn(`adding '${controller.id}' to graph`);
+                    graph.addNode(controller.id, {[observerId]: []});
+                }
+                graph.addDependency(observerId, controller.id);
+                /*
+                 * A controller may be observed by several components
+                 * and each component may depend on different props or events
+                 *
+                 * {
+                 *      inputComponentId: {
+                 *          observerComponentId1: ['value', 'style'],
+                 *          observerComponentId2: ['className'],
+                 *      }
+                 * }
+                 */
+                const existingControllerData = graph.getNodeData(controller.id)[observerId]
+                const newControllerData = controller[
+                    graphType === 'state' ? 'prop' : 'event'
+                ];
+                const controllerData = append(
+                    newControllerData,
+                    existingControllerData
+                );
+                const allControllerData = merge(
+                    graph.getNodeData(controller.id),
+                    {[observerId]: controllerData}
+                );
+                console.warn(`Setting ${JSON.stringify(allControllerData)} to ${controller.id}`);
+                graph.setNodeData(controller.id, allControllerData);
+            }
+        );
+    }
+}
+
+const graphs = (state = initialGraph, action) => {
     switch (action.type) {
-        case 'COMPUTE_GRAPH': {
-            const layout = action.payload;
-            const graph = new DepGraph();
+        case 'COMPUTE_GRAPHS': {
+            const dependencies = action.payload;
+            const stateGraph = new DepGraph();
+            const eventGraph = new DepGraph();
 
             // add ID's to all the components
-            crawlLayout(layout, child => {
-                if (child.props && child.props.id) {
-                    console.warn(`Adding node: ${child.props.id}`)
-                    graph.addNode(child.props.id);
-                }
-            });
-
-            // add dependencies to the graph
-            crawlLayout(layout, child => {
-                if (child.dependencies) {
-                    for (let i = 0; i < child.dependencies.length; i++) {
-                        console.warn(`Adding dependency: ${child.props.id} -> ${child.dependencies[i]}`)
-                        graph.addDependency(
-                            child.props.id,
-                            child.dependencies[i]
-                        );
-                    }
-                }
-            });
-            return graph;
+            keys(dependencies).forEach(computeGraph(dependencies, stateGraph, 'state'));
+            keys(dependencies).forEach(computeGraph(dependencies, eventGraph, 'events'));
+
+            return {StateGraph: stateGraph, EventGraph: eventGraph};
+
         }
 
         default:
             return state;
+
     }
 }
 
-export default dependencyGraph;
+export default graphs;
diff --git a/src/reducers/reducer.js b/src/reducers/reducer.js
index fe58301f..11740ff7 100644
--- a/src/reducers/reducer.js
+++ b/src/reducers/reducer.js
@@ -2,10 +2,10 @@
 
 import { combineReducers } from 'redux';
 import layout from './layout';
-import dependencyGraph from './dependencyGraph';
+import graphs from './dependencyGraph';
 import paths from './paths';
 import requestQueue from './requestQueue';
 
-const reducer = combineReducers({layout, dependencyGraph, paths, requestQueue});
+const reducer = combineReducers({layout, graphs, paths, requestQueue});
 
 export default reducer;
diff --git a/src/renderTree.js b/src/renderTree.js
index 7f29e337..1f7fac49 100644
--- a/src/renderTree.js
+++ b/src/renderTree.js
@@ -6,7 +6,7 @@ import Registry from './registry';
 import NotifyObservers from './components/core/NotifyObservers.react';
 import {createTreePath} from './reducers/utils';
 
-export default function render(component, dependencyGraph, path=[]) {
+export default function render(component, path=[]) {
     // Create list of child elements
     let children;
 
@@ -28,7 +28,7 @@ export default function render(component, dependencyGraph, path=[]) {
 
         // Recursively render the tree
         const renderChild = (child, i) =>
-            render(child, dependencyGraph, R.append(i, path))
+            render(child, R.append(i, path))
 
         children = (Array.isArray(content) ? content : [content])
                    .map(renderChild);
@@ -43,23 +43,9 @@ export default function render(component, dependencyGraph, path=[]) {
         ...children
     );
 
-    // has observers?
-    if (
-        props && props.id &&
-        /*
-         * in case it isn't initalized yet -
-         * TODO: we should be able to remove this check
-         * with like a initialization status store or something
-         */
-        dependencyGraph.hasNode(component.props.id) &&
-        dependencyGraph.dependantsOf(component.props.id).length
-    ) {
-        return (
-            <NotifyObservers>
-                {parent}
-            </NotifyObservers>
-        );
-    }
-
-    return parent;
+    return (
+        <NotifyObservers id={props.id}>
+            {parent}
+        </NotifyObservers>
+    );
 }
diff --git a/src/store.js b/src/store.js
index 8d599c69..e4fdaab1 100644
--- a/src/store.js
+++ b/src/store.js
@@ -18,6 +18,9 @@ const initializeStore = () => {
         applyMiddleware(thunk, logger)
     );
 
+    // TODO - Protect this under a debug mode?
+    window.store = store;
+
     if (module.hot) {
         // Enable hot module replacement for reducers
         module.hot.accept('./reducers/reducer', () => {

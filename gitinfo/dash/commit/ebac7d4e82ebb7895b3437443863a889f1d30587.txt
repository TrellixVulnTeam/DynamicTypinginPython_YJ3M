commit ebac7d4e82ebb7895b3437443863a889f1d30587
Author: Ryan Patrick Kyle <rpkyle@users.noreply.github.com>
Date:   Mon May 18 23:33:11 2020 -0400

    Add JuliaRunner to support Dash.jl integration tests (#1239)

diff --git a/dash/development/_r_components_generation.py b/dash/development/_r_components_generation.py
index 198cc3e8..1e50f301 100644
--- a/dash/development/_r_components_generation.py
+++ b/dash/development/_r_components_generation.py
@@ -185,7 +185,6 @@ def generate_class_string(name, props, project_shortname, prefix):
     props = reorder_props(props=props)
 
     prop_keys = list(props.keys())
-    prop_keys_wc = list(props.keys())
 
     wildcards = ""
     wildcard_declaration = ""
@@ -194,8 +193,8 @@ def generate_class_string(name, props, project_shortname, prefix):
     default_argtext = ""
     accepted_wildcards = ""
 
-    if any(key.endswith("-*") for key in prop_keys_wc):
-        accepted_wildcards = get_wildcards_r(prop_keys_wc)
+    if any(key.endswith("-*") for key in prop_keys):
+        accepted_wildcards = get_wildcards_r(prop_keys)
         wildcards = ", ..."
         wildcard_declaration = wildcard_template.format(
             accepted_wildcards.replace("-*", "")
@@ -222,6 +221,9 @@ def generate_class_string(name, props, project_shortname, prefix):
 
     default_argtext += ", ".join("{}=NULL".format(p) for p in prop_keys)
 
+    if wildcards == ", ...":
+        default_argtext += ", ..."
+
     # pylint: disable=C0301
     default_paramtext += ", ".join(
         "{0}={0}".format(p) if p != "children" else "{}=children".format(p)
@@ -380,15 +382,20 @@ def write_help_file(name, props, description, prefix, rpkg_data):
     funcname = format_fn_name(prefix, name)
     file_name = funcname + ".Rd"
 
+    wildcards = ""
     default_argtext = ""
     item_text = ""
+    accepted_wildcards = ""
 
     # the return value of all Dash components should be the same,
     # in an abstract sense -- they produce a list
     value_text = "named list of JSON elements corresponding to React.js properties and their values"  # noqa:E501
 
     prop_keys = list(props.keys())
-    prop_keys_wc = list(props.keys())
+
+    if any(key.endswith("-*") for key in prop_keys):
+        accepted_wildcards = get_wildcards_r(prop_keys)
+        wildcards = ", ..."
 
     # Filter props to remove those we don't want to expose
     for item in prop_keys[:]:
@@ -413,9 +420,9 @@ def write_help_file(name, props, description, prefix, rpkg_data):
     if "**Example Usage**" in description:
         description = description.split("**Example Usage**")[0].rstrip()
 
-    if any(key.endswith("-*") for key in prop_keys_wc):
-        default_argtext += ", ..."
-        item_text += wildcard_help_template.format(get_wildcards_r(prop_keys_wc))
+    if wildcards == ", ...":
+        default_argtext += wildcards
+        item_text += wildcard_help_template.format(accepted_wildcards)
 
     # in R, the online help viewer does not properly wrap lines for
     # the usage string -- we will hard wrap at 60 characters using
diff --git a/dash/testing/application_runners.py b/dash/testing/application_runners.py
index a14f421a..75b1dc0b 100644
--- a/dash/testing/application_runners.py
+++ b/dash/testing/application_runners.py
@@ -221,6 +221,10 @@ class ProcessRunner(BaseDashRunner):
             try:
                 logger.info("proc.terminate with pid %s", self.proc.pid)
                 self.proc.terminate()
+                if self.tmp_app_path and os.path.exists(self.tmp_app_path):
+                    logger.debug("removing temporary app path %s",
+                                 self.tmp_app_path)
+                    shutil.rmtree(self.tmp_app_path)
                 if utils.PY3:
                     # pylint:disable=no-member
                     _except = subprocess.TimeoutExpired
@@ -285,6 +289,24 @@ class RRunner(ProcessRunner):
                         break
             if cwd:
                 logger.info("RRunner inferred cwd from the Python call stack: %s", cwd)
+
+                # try copying all valid sub folders (i.e. assets) in cwd to tmp
+                # note that the R assets folder name can be any valid folder name
+                assets = [
+                    os.path.join(cwd, _)
+                    for _ in os.listdir(cwd)
+                    if not _.startswith("__") and os.path.isdir(os.path.join(cwd, _))
+                ]
+
+                for asset in assets:
+                    target = os.path.join(self.tmp_app_path, os.path.basename(asset))
+                    if os.path.exists(target):
+                        logger.debug("delete existing target %s", target)
+                        shutil.rmtree(target)
+                    logger.debug("copying %s => %s", asset, self.tmp_app_path)
+                    shutil.copytree(asset, target)
+                    logger.debug("copied with %s", os.listdir(target))
+
             else:
                 logger.warning(
                     "RRunner found no cwd in the Python call stack. "
@@ -293,23 +315,6 @@ class RRunner(ProcessRunner):
                     "dashr.run_server(app, cwd=os.path.dirname(__file__))"
                 )
 
-            # try copying all valid sub folders (i.e. assets) in cwd to tmp
-            # note that the R assets folder name can be any valid folder name
-            assets = [
-                os.path.join(cwd, _)
-                for _ in os.listdir(cwd)
-                if not _.startswith("__") and os.path.isdir(os.path.join(cwd, _))
-            ]
-
-            for asset in assets:
-                target = os.path.join(self.tmp_app_path, os.path.basename(asset))
-                if os.path.exists(target):
-                    logger.debug("delete existing target %s", target)
-                    shutil.rmtree(target)
-                logger.debug("copying %s => %s", asset, self.tmp_app_path)
-                shutil.copytree(asset, target)
-                logger.debug("copied with %s", os.listdir(target))
-
         logger.info("Run dashR app with Rscript => %s", app)
 
         args = shlex.split(
@@ -334,3 +339,100 @@ class RRunner(ProcessRunner):
             return
 
         self.started = True
+
+
+class JuliaRunner(ProcessRunner):
+    def __init__(self, keep_open=False, stop_timeout=3):
+        super(JuliaRunner, self).__init__(keep_open=keep_open, stop_timeout=stop_timeout)
+        self.proc = None
+
+    # pylint: disable=arguments-differ
+    def start(self, app, start_timeout=30, cwd=None):
+        """Start the server with subprocess and julia."""
+
+        if os.path.isfile(app) and os.path.exists(app):
+            # app is already a file in a dir - use that as cwd
+            if not cwd:
+                cwd = os.path.dirname(app)
+                logger.info("JuliaRunner inferred cwd from app path: %s", cwd)
+        else:
+            # app is a string chunk, we make a temporary folder to store app.jl
+            # and its relevants assets
+            self._tmp_app_path = os.path.join(
+                "/tmp" if not self.is_windows else os.getenv("TEMP"), uuid.uuid4().hex
+            )
+            try:
+                os.mkdir(self.tmp_app_path)
+            except OSError:
+                logger.exception("cannot make temporary folder %s", self.tmp_app_path)
+            path = os.path.join(self.tmp_app_path, "app.jl")
+
+            logger.info("JuliaRunner start => app is Julia code chunk")
+            logger.info("make a temporary Julia file for execution => %s", path)
+            logger.debug("content of the Dash.jl app")
+            logger.debug("%s", app)
+
+            with open(path, "w") as fp:
+                fp.write(app)
+
+            app = path
+
+            # try to find the path to the calling script to use as cwd
+            if not cwd:
+                for entry in inspect.stack():
+                    if "/dash/testing/" not in entry[1].replace("\\", "/"):
+                        cwd = os.path.dirname(os.path.realpath(entry[1]))
+                        logger.warning("get cwd from inspect => %s", cwd)
+                        break
+            if cwd:
+                logger.info("JuliaRunner inferred cwd from the Python call stack: %s", cwd)
+
+                # try copying all valid sub folders (i.e. assets) in cwd to tmp
+                # note that the R assets folder name can be any valid folder name
+                assets = [
+                    os.path.join(cwd, _)
+                    for _ in os.listdir(cwd)
+                    if not _.startswith("__") and os.path.isdir(os.path.join(cwd, _))
+                ]
+
+                for asset in assets:
+                    target = os.path.join(self.tmp_app_path, os.path.basename(asset))
+                    if os.path.exists(target):
+                        logger.debug("delete existing target %s", target)
+                        shutil.rmtree(target)
+                    logger.debug("copying %s => %s", asset, self.tmp_app_path)
+                    shutil.copytree(asset, target)
+                    logger.debug("copied with %s", os.listdir(target))
+
+            else:
+                logger.warning(
+                    "JuliaRunner found no cwd in the Python call stack. "
+                    "You may wish to specify an explicit working directory "
+                    "using something like: "
+                    "dashjl.run_server(app, cwd=os.path.dirname(__file__))"
+                )
+
+        logger.info("Run Dash.jl app with julia => %s", app)
+
+        args = shlex.split(
+            "julia {}".format(os.path.realpath(app)),
+            posix=not self.is_windows,
+        )
+        logger.debug("start Dash.jl process with %s", args)
+
+        try:
+            self.proc = subprocess.Popen(
+                args,
+                stdout=subprocess.PIPE,
+                stderr=subprocess.PIPE,
+                cwd=self.tmp_app_path if self.tmp_app_path else cwd,
+            )
+            # wait until server is able to answer http request
+            wait.until(lambda: self.accessible(self.url), timeout=start_timeout)
+
+        except (OSError, ValueError):
+            logger.exception("process server has encountered an error")
+            self.started = False
+            return
+
+        self.started = True
diff --git a/dash/testing/composite.py b/dash/testing/composite.py
index c45d20f8..8bb05a6d 100644
--- a/dash/testing/composite.py
+++ b/dash/testing/composite.py
@@ -29,3 +29,17 @@ class DashRComposite(Browser):
 
         # set the default server_url, it implicitly call wait_for_page
         self.server_url = self.server.url
+
+
+class DashJuliaComposite(Browser):
+    def __init__(self, server, **kwargs):
+        super(DashJuliaComposite, self).__init__(**kwargs)
+        self.server = server
+
+    def start_server(self, app, cwd=None):
+        # start server with Dash.jl app. The app sets its own run_server args
+        # on the Julia side, but we support overriding the automatic cwd
+        self.server(app, cwd=cwd)
+
+        # set the default server_url, it implicitly call wait_for_page
+        self.server_url = self.server.url
diff --git a/dash/testing/plugin.py b/dash/testing/plugin.py
index 3161df82..60e774fc 100644
--- a/dash/testing/plugin.py
+++ b/dash/testing/plugin.py
@@ -4,9 +4,9 @@ from .consts import SELENIUM_GRID_DEFAULT
 
 
 try:
-    from dash.testing.application_runners import ThreadedRunner, ProcessRunner, RRunner
+    from dash.testing.application_runners import ThreadedRunner, ProcessRunner, RRunner, JuliaRunner
     from dash.testing.browser import Browser
-    from dash.testing.composite import DashComposite, DashRComposite
+    from dash.testing.composite import DashComposite, DashRComposite, DashJuliaComposite
 except ImportError:
     pass
 
@@ -78,7 +78,7 @@ def pytest_runtest_makereport(item, call):  # pylint: disable=unused-argument
     if rep.when == "call" and rep.failed and hasattr(item, "funcargs"):
         for name, fixture in item.funcargs.items():
             try:
-                if name in {"dash_duo", "dash_br", "dashr"}:
+                if name in {"dash_duo", "dash_br", "dashr", "dashjl"}:
                     fixture.take_snapshot(item.name)
             except Exception as e:  # pylint: disable=broad-except
                 print(e)
@@ -109,6 +109,12 @@ def dashr_server():
         yield starter
 
 
+@pytest.fixture
+def dashjl_server():
+    with JuliaRunner() as starter:
+        yield starter
+
+
 @pytest.fixture
 def dash_br(request, tmpdir):
     with Browser(
@@ -157,3 +163,20 @@ def dashr(request, dashr_server, tmpdir):
         pause=request.config.getoption("pause"),
     ) as dc:
         yield dc
+
+
+@pytest.fixture
+def dashjl(request, dashjl_server, tmpdir):
+    with DashJuliaComposite(
+        dashjl_server,
+        browser=request.config.getoption("webdriver"),
+        remote=request.config.getoption("remote"),
+        remote_url=request.config.getoption("remote_url"),
+        headless=request.config.getoption("headless"),
+        options=request.config.hook.pytest_setup_options(),
+        download_path=tmpdir.mkdir("download").strpath,
+        percy_assets_root=request.config.getoption("percy_assets"),
+        percy_finalize=request.config.getoption("nopercyfinalize"),
+        pause=request.config.getoption("pause"),
+    ) as dc:
+        yield dc

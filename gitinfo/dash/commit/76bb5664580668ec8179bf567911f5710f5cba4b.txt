commit 76bb5664580668ec8179bf567911f5710f5cba4b
Author: Valentijn Nieman <valentijnnieman@gmail.com>
Date:   Tue Oct 9 14:02:24 2018 -0400

    Run formatting on src/

diff --git a/src/actions/api.js b/src/actions/api.js
index 8d63c33a..e7eb00c1 100644
--- a/src/actions/api.js
+++ b/src/actions/api.js
@@ -92,12 +92,7 @@ export function getDependencies() {
 }
 
 export function login(oauth_token) {
-    return apiThunk(
-        '_dash-login',
-        'POST',
-        'loginRequest',
-        '',
-        '',
-        {Authorization: `Bearer ${oauth_token}`}
-    );
+    return apiThunk('_dash-login', 'POST', 'loginRequest', '', '', {
+        Authorization: `Bearer ${oauth_token}`,
+    });
 }
diff --git a/src/actions/constants.js b/src/actions/constants.js
index 0a1ff07b..269dcd02 100644
--- a/src/actions/constants.js
+++ b/src/actions/constants.js
@@ -1,4 +1,4 @@
-export const getAction = (action) => {
+export const getAction = action => {
     const actionList = {
         ON_PROP_CHANGE: 'ON_PROP_CHANGE',
         SET_REQUEST_QUEUE: 'SET_REQUEST_QUEUE',
@@ -6,8 +6,10 @@ export const getAction = (action) => {
         COMPUTE_PATHS: 'COMPUTE_PATHS',
         SET_LAYOUT: 'SET_LAYOUT',
         SET_APP_LIFECYCLE: 'SET_APP_LIFECYCLE',
-        READ_CONFIG: 'READ_CONFIG'
+        READ_CONFIG: 'READ_CONFIG',
     };
-    if (actionList[action]) {return actionList[action];}
-    throw new Error(`${action} is not defined.`)
+    if (actionList[action]) {
+        return actionList[action];
+    }
+    throw new Error(`${action} is not defined.`);
 };
diff --git a/src/actions/index.js b/src/actions/index.js
index 7fb9856a..ab868e12 100644
--- a/src/actions/index.js
+++ b/src/actions/index.js
@@ -22,8 +22,8 @@ import {
     slice,
     sort,
     type,
-//    values,
-    view
+    //    values,
+    view,
 } from 'ramda';
 import {createAction} from 'redux-actions';
 import {crawlLayout, hasId} from '../reducers/utils';
@@ -31,7 +31,7 @@ import {getAppState} from '../reducers/constants';
 import {getAction} from './constants';
 import cookie from 'cookie';
 import {uid, urlBase} from '../utils';
-import {STATUS} from "../constants/constants"
+import {STATUS} from '../constants/constants';
 
 export const updateProps = createAction(getAction('ON_PROP_CHANGE'));
 export const setRequestQueue = createAction(getAction('SET_REQUEST_QUEUE'));
@@ -42,10 +42,10 @@ export const setAppLifecycle = createAction(getAction('SET_APP_LIFECYCLE'));
 export const readConfig = createAction(getAction('READ_CONFIG'));
 
 export function hydrateInitialOutputs() {
-    return function (dispatch, getState) {
+    return function(dispatch, getState) {
         triggerDefaultState(dispatch, getState);
         dispatch(setAppLifecycle(getAppState('HYDRATED')));
-    }
+    };
 }
 
 function triggerDefaultState(dispatch, getState) {
@@ -61,7 +61,8 @@ function triggerDefaultState(dispatch, getState) {
          * inputs that aren't leaves,
          * and the invisible inputs
          */
-        if (InputGraph.dependenciesOf(nodeId).length > 0 &&
+        if (
+            InputGraph.dependenciesOf(nodeId).length > 0 &&
             InputGraph.dependantsOf(nodeId).length === 0 &&
             has(componentId, getState().paths)
         ) {
@@ -73,67 +74,68 @@ function triggerDefaultState(dispatch, getState) {
         const [componentId, componentProp] = inputOutput.input.split('.');
         // Get the initial property
         const propLens = lensPath(
-            concat(getState().paths[componentId],
-            ['props', componentProp]
-        ));
-        const propValue = view(
-            propLens,
-            getState().layout
+            concat(getState().paths[componentId], ['props', componentProp])
         );
+        const propValue = view(propLens, getState().layout);
 
-        dispatch(notifyObservers({
-            id: componentId,
-            props: {[componentProp]: propValue},
-            excludedOutputs: inputOutput.excludedOutputs
-        }));
-
+        dispatch(
+            notifyObservers({
+                id: componentId,
+                props: {[componentProp]: propValue},
+                excludedOutputs: inputOutput.excludedOutputs,
+            })
+        );
     });
-
 }
 
 export function redo() {
-    return function (dispatch, getState) {
+    return function(dispatch, getState) {
         const history = getState().history;
         dispatch(createAction('REDO')());
         const next = history.future[0];
 
         // Update props
-        dispatch(createAction('REDO_PROP_CHANGE')({
-            itempath: getState().paths[next.id],
-            props: next.props
-        }));
+        dispatch(
+            createAction('REDO_PROP_CHANGE')({
+                itempath: getState().paths[next.id],
+                props: next.props,
+            })
+        );
 
         // Notify observers
-        dispatch(notifyObservers({
-            id: next.id,
-            props: next.props
-        }));
-    }
+        dispatch(
+            notifyObservers({
+                id: next.id,
+                props: next.props,
+            })
+        );
+    };
 }
 
-
 export function undo() {
-    return function (dispatch, getState) {
+    return function(dispatch, getState) {
         const history = getState().history;
         dispatch(createAction('UNDO')());
         const previous = history.past[history.past.length - 1];
 
         // Update props
-        dispatch(createAction('UNDO_PROP_CHANGE')({
-            itempath: getState().paths[previous.id],
-            props: previous.props
-        }));
+        dispatch(
+            createAction('UNDO_PROP_CHANGE')({
+                itempath: getState().paths[previous.id],
+                props: previous.props,
+            })
+        );
 
         // Notify observers
-        dispatch(notifyObservers({
-            id: previous.id,
-            props: previous.props
-        }));
-    }
+        dispatch(
+            notifyObservers({
+                id: previous.id,
+                props: previous.props,
+            })
+        );
+    };
 }
 
-
-
 function reduceInputIds(nodeIds, InputGraph) {
     /*
      * Create input-output(s) pairs,
@@ -144,7 +146,7 @@ function reduceInputIds(nodeIds, InputGraph) {
         input: nodeId,
         // TODO - Does this include grandchildren?
         outputs: InputGraph.dependenciesOf(nodeId),
-        excludedOutputs: []
+        excludedOutputs: [],
     }));
 
     const sortedInputOutputPairs = sort(
@@ -164,8 +166,9 @@ function reduceInputIds(nodeIds, InputGraph) {
      * to exclude.
      */
     sortedInputOutputPairs.forEach((pair, i) => {
-        const outputsThatWillBeUpdated = flatten(pluck(
-            'outputs', slice(0, i, sortedInputOutputPairs)));
+        const outputsThatWillBeUpdated = flatten(
+            pluck('outputs', slice(0, i, sortedInputOutputPairs))
+        );
         pair.outputs.forEach(output => {
             if (contains(output, outputsThatWillBeUpdated)) {
                 pair.excludedOutputs.push(output);
@@ -176,21 +179,11 @@ function reduceInputIds(nodeIds, InputGraph) {
     return sortedInputOutputPairs;
 }
 
-
-
 export function notifyObservers(payload) {
-    return function (dispatch, getState) {
-        const {
-            id,
-            event,
-            props,
-            excludedOutputs
-        } = payload
-
-        const {
-            graphs,
-            requestQueue,
-        } = getState();
+    return function(dispatch, getState) {
+        const {id, event, props, excludedOutputs} = payload;
+
+        const {graphs, requestQueue} = getState();
         const {EventGraph, InputGraph} = graphs;
         /*
          * Figure out all of the output id's that depend on this
@@ -206,7 +199,7 @@ export function notifyObservers(payload) {
             const changedProps = keys(props);
             outputObservers = [];
             changedProps.forEach(propName => {
-                const node = `${id}.${propName}`
+                const node = `${id}.${propName}`;
                 if (!InputGraph.hasNode(node)) {
                     return;
                 }
@@ -270,13 +263,13 @@ export function notifyObservers(payload) {
              * this loop hits C because of the overallOrder sorting logic
              */
 
-
-             /*
+            /*
               * if the output just listens to events, then it won't be in
               * the InputGraph
               */
-            const controllers = (InputGraph.hasNode(outputIdAndProp) ?
-                InputGraph.dependantsOf(outputIdAndProp) : []);
+            const controllers = InputGraph.hasNode(outputIdAndProp)
+                ? InputGraph.dependantsOf(outputIdAndProp)
+                : [];
 
             const controllersInFutureQueue = intersection(
                 queuedObservers,
@@ -296,8 +289,10 @@ export function notifyObservers(payload) {
              * the change for Child. if this update has already been queued up,
              * then skip the update for the other component
              */
-            const controllerIsInExistingQueue = any(r =>
-                contains(r.controllerId, controllers) && r.status === 'loading',
+            const controllerIsInExistingQueue = any(
+                r =>
+                    contains(r.controllerId, controllers) &&
+                    r.status === 'loading',
                 requestQueue
             );
 
@@ -321,13 +316,13 @@ export function notifyObservers(payload) {
              * of a controller change.
              * for example, perhaps the user has hidden one of the observers
              */
-             if (
-                 (controllersInFutureQueue.length === 0) &&
-                 (has(outputComponentId, getState().paths)) &&
-                 !controllerIsInExistingQueue
-             ) {
-                 queuedObservers.push(outputIdAndProp)
-             }
+            if (
+                controllersInFutureQueue.length === 0 &&
+                has(outputComponentId, getState().paths) &&
+                !controllerIsInExistingQueue
+            ) {
+                queuedObservers.push(outputIdAndProp);
+            }
         });
 
         /*
@@ -335,20 +330,13 @@ export function notifyObservers(payload) {
          * updated in a queue. not all of these requests will be fired in this
          * action
          */
-        const newRequestQueue = queuedObservers.map(
-            i => ({
-                controllerId: i,
-                status: 'loading',
-                uid: uid(),
-                requestTime: Date.now()
-            })
-        )
-        dispatch(setRequestQueue(
-            concat(
-                requestQueue,
-                newRequestQueue
-            )
-        ));
+        const newRequestQueue = queuedObservers.map(i => ({
+            controllerId: i,
+            status: 'loading',
+            uid: uid(),
+            requestTime: Date.now(),
+        }));
+        dispatch(setRequestQueue(concat(requestQueue, newRequestQueue)));
 
         const promises = [];
         for (let i = 0; i < queuedObservers.length; i++) {
@@ -357,20 +345,22 @@ export function notifyObservers(payload) {
 
             const requestUid = newRequestQueue[i].uid;
 
-            promises.push(updateOutput(
-                outputComponentId,
-                outputProp,
-                event,
-                getState,
-                requestUid,
-                dispatch
-            ))
+            promises.push(
+                updateOutput(
+                    outputComponentId,
+                    outputProp,
+                    event,
+                    getState,
+                    requestUid,
+                    dispatch
+                )
+            );
         }
 
         /* eslint-disable consistent-return */
         return Promise.all(promises);
         /* eslint-enableconsistent-return */
-    }
+    };
 }
 
 function updateOutput(
@@ -381,13 +371,7 @@ function updateOutput(
     requestUid,
     dispatch
 ) {
-    const {
-        config,
-        layout,
-        graphs,
-        paths,
-        dependenciesRequest
-    } = getState();
+    const {config, layout, graphs, paths, dependenciesRequest} = getState();
     const {InputGraph} = graphs;
 
     /*
@@ -406,43 +390,44 @@ function updateOutput(
      * }
      *
      */
-     const payload = {
-         output: {id: outputComponentId, property: outputProp}
-     };
+    const payload = {
+        output: {id: outputComponentId, property: outputProp},
+    };
 
-     if (event) {
+    if (event) {
         payload.event = event;
     }
 
     const {inputs, state} = dependenciesRequest.content.find(
-        dependency => (
+        dependency =>
             dependency.output.id === outputComponentId &&
             dependency.output.property === outputProp
-        )
     );
     const validKeys = keys(paths);
     if (inputs.length > 0) {
         payload.inputs = inputs.map(inputObject => {
             // Make sure the component id exists in the layout
             if (!contains(inputObject.id, validKeys)) {
-              throw new ReferenceError(
-                "An invalid input object was used in an " +
-                "`Input` of a Dash callback. " +
-                "The id of this object is `" +
-                inputObject.id + "` and the property is `" +
-                inputObject.property +
-                "`. The list of ids in the current layout is " +
-                "`[" + validKeys.join(", ") + "]`"
-              )
+                throw new ReferenceError(
+                    'An invalid input object was used in an ' +
+                        '`Input` of a Dash callback. ' +
+                        'The id of this object is `' +
+                        inputObject.id +
+                        '` and the property is `' +
+                        inputObject.property +
+                        '`. The list of ids in the current layout is ' +
+                        '`[' +
+                        validKeys.join(', ') +
+                        ']`'
+                );
             }
             const propLens = lensPath(
-                concat(paths[inputObject.id],
-                ['props', inputObject.property]
-            ));
+                concat(paths[inputObject.id], ['props', inputObject.property])
+            );
             return {
                 id: inputObject.id,
                 property: inputObject.property,
-                value: view(propLens, layout)
+                value: view(propLens, layout),
             };
         });
     }
@@ -450,24 +435,26 @@ function updateOutput(
         payload.state = state.map(stateObject => {
             // Make sure the component id exists in the layout
             if (!contains(stateObject.id, validKeys)) {
-              throw new ReferenceError(
-                "An invalid input object was used in a " +
-                "`State` object of a Dash callback. " +
-                "The id of this object is `" +
-                stateObject.id + "` and the property is `" +
-                stateObject.property +
-                "`. The list of ids in the current layout is " +
-                "`[" + validKeys.join(", ") + "]`"
-              )
+                throw new ReferenceError(
+                    'An invalid input object was used in a ' +
+                        '`State` object of a Dash callback. ' +
+                        'The id of this object is `' +
+                        stateObject.id +
+                        '` and the property is `' +
+                        stateObject.property +
+                        '`. The list of ids in the current layout is ' +
+                        '`[' +
+                        validKeys.join(', ') +
+                        ']`'
+                );
             }
             const propLens = lensPath(
-                concat(paths[stateObject.id],
-                ['props', stateObject.property]
-            ));
+                concat(paths[stateObject.id], ['props', stateObject.property])
+            );
             return {
                 id: stateObject.id,
                 property: stateObject.property,
-                value: view(propLens, layout)
+                value: view(propLens, layout),
             };
         });
     }
@@ -476,12 +463,11 @@ function updateOutput(
         method: 'POST',
         headers: {
             'Content-Type': 'application/json',
-            'X-CSRFToken': cookie.parse(document.cookie)._csrf_token
+            'X-CSRFToken': cookie.parse(document.cookie)._csrf_token,
         },
         credentials: 'same-origin',
-        body: JSON.stringify(payload)
+        body: JSON.stringify(payload),
     }).then(function handleResponse(res) {
-
         const getThisRequestIndex = () => {
             const postRequestQueue = getState().requestQueue;
             const thisRequestIndex = findIndex(
@@ -489,10 +475,10 @@ function updateOutput(
                 postRequestQueue
             );
             return thisRequestIndex;
-        }
+        };
 
         const updateRequestQueue = rejected => {
-            const postRequestQueue = getState().requestQueue
+            const postRequestQueue = getState().requestQueue;
             const thisRequestIndex = getThisRequestIndex();
             if (thisRequestIndex === -1) {
                 // It was already pruned away
@@ -502,25 +488,23 @@ function updateOutput(
                 merge(__, {
                     status: res.status,
                     responseTime: Date.now(),
-                    rejected
+                    rejected,
                 }),
                 thisRequestIndex,
                 postRequestQueue
             );
             // We don't need to store any requests before this one
-            const thisControllerId = postRequestQueue[
-                thisRequestIndex].controllerId;
-            const prunedQueue = updatedQueue.filter(
-                (queueItem, index) => {
-                    return (
-                        queueItem.controllerId !== thisControllerId ||
-                        index >= thisRequestIndex
-                    );
-                }
-            );
+            const thisControllerId =
+                postRequestQueue[thisRequestIndex].controllerId;
+            const prunedQueue = updatedQueue.filter((queueItem, index) => {
+                return (
+                    queueItem.controllerId !== thisControllerId ||
+                    index >= thisRequestIndex
+                );
+            });
 
             dispatch(setRequestQueue(prunedQueue));
-        }
+        };
 
         const isRejected = () => {
             const latestRequestIndex = findLastIndex(
@@ -536,7 +520,7 @@ function updateOutput(
              */
             const rejected = latestRequestIndex > getThisRequestIndex();
             return rejected;
-        }
+        };
 
         if (res.status !== STATUS.OK) {
             // update the status of this request
@@ -561,10 +545,10 @@ function updateOutput(
              * at different rates causing the parsed responses to
              * get out of order
              */
-             if (isRejected()) {
-                 updateRequestQueue(true);
-                 return;
-             }
+            if (isRejected()) {
+                updateRequestQueue(true);
+                return;
+            }
 
             updateRequestQueue(false);
 
@@ -585,14 +569,16 @@ function updateOutput(
                 itempath: getState().paths[outputComponentId],
                 // new prop from the server
                 props: data.response.props,
-                source: 'response'
+                source: 'response',
             };
             dispatch(updateProps(observerUpdatePayload));
 
-            dispatch(notifyObservers({
-                id: outputComponentId,
-                props: data.response.props
-            }));
+            dispatch(
+                notifyObservers({
+                    id: outputComponentId,
+                    props: data.response.props,
+                })
+            );
 
             /*
              * If the response includes children, then we need to update our
@@ -600,24 +586,27 @@ function updateOutput(
              * TODO - Do we need to wait for updateProps to finish?
              */
             if (has('children', observerUpdatePayload.props)) {
-
-                dispatch(computePaths({
-                    subTree: observerUpdatePayload.props.children,
-                    startingPath: concat(
-                        getState().paths[outputComponentId],
-                        ['props', 'children']
-                    )
-                }));
+                dispatch(
+                    computePaths({
+                        subTree: observerUpdatePayload.props.children,
+                        startingPath: concat(
+                            getState().paths[outputComponentId],
+                            ['props', 'children']
+                        ),
+                    })
+                );
 
                 /*
                  * if children contains objects with IDs, then we
                  * need to dispatch a propChange for all of these
                  * new children components
                  */
-                if (contains(
-                        type(observerUpdatePayload.props.children),
-                        ['Array', 'Object']
-                    ) && !isEmpty(observerUpdatePayload.props.children)
+                if (
+                    contains(type(observerUpdatePayload.props.children), [
+                        'Array',
+                        'Object',
+                    ]) &&
+                    !isEmpty(observerUpdatePayload.props.children)
                 ) {
                     /*
                      * TODO: We're just naively crawling
@@ -632,18 +621,24 @@ function updateOutput(
                         function appendIds(child) {
                             if (hasId(child)) {
                                 keys(child.props).forEach(childProp => {
-                                    const componentIdAndProp = (
-                                        `${child.props.id}.${childProp}`
-                                    );
-                                    if (has(componentIdAndProp, InputGraph.nodes)) {
-                                        newProps[componentIdAndProp] = ({
+                                    const componentIdAndProp = `${
+                                        child.props.id
+                                    }.${childProp}`;
+                                    if (
+                                        has(
+                                            componentIdAndProp,
+                                            InputGraph.nodes
+                                        )
+                                    ) {
+                                        newProps[componentIdAndProp] = {
                                             id: child.props.id,
                                             props: {
-                                                [childProp]: child.props[childProp]
-                                            }
-                                        });
+                                                [childProp]:
+                                                    child.props[childProp],
+                                            },
+                                        };
                                     }
-                                })
+                                });
                             }
                         }
                     );
@@ -674,7 +669,6 @@ function updateOutput(
                      * special case (no input changed?)
                      */
 
-
                     const outputIds = [];
                     keys(newProps).forEach(idAndProp => {
                         if (
@@ -696,10 +690,14 @@ function updateOutput(
 
                     // Dispatch updates to inputs
                     const reducedNodeIds = reduceInputIds(
-                        keys(newProps), InputGraph);
+                        keys(newProps),
+                        InputGraph
+                    );
                     const depOrder = InputGraph.overallOrder();
-                    const sortedNewProps = sort((a, b) =>
-                        depOrder.indexOf(a.input) - depOrder.indexOf(b.input),
+                    const sortedNewProps = sort(
+                        (a, b) =>
+                            depOrder.indexOf(a.input) -
+                            depOrder.indexOf(b.input),
                         reducedNodeIds
                     );
                     sortedNewProps.forEach(function(inputOutput) {
@@ -711,15 +709,20 @@ function updateOutput(
                     // Dispatch updates to lone outputs
                     outputIds.forEach(idAndProp => {
                         const requestUid = uid();
-                        dispatch(setRequestQueue(
-                            append({
-                                // TODO - Are there any implications of doing this??
-                                controllerId: null,
-                                status: 'loading',
-                                uid: requestUid,
-                                requestTime: Date.now()
-                            }, getState().requestQueue)
-                        ));
+                        dispatch(
+                            setRequestQueue(
+                                append(
+                                    {
+                                        // TODO - Are there any implications of doing this??
+                                        controllerId: null,
+                                        status: 'loading',
+                                        uid: requestUid,
+                                        requestTime: Date.now(),
+                                    },
+                                    getState().requestQueue
+                                )
+                            )
+                        );
                         updateOutput(
                             idAndProp.split('.')[0],
                             idAndProp.split('.')[1],
@@ -728,16 +731,11 @@ function updateOutput(
                             requestUid,
                             dispatch
                         );
-                    })
-
+                    });
                 }
-
-
             }
-
         });
     });
-
 }
 
 export function serialize(state) {
@@ -752,22 +750,18 @@ export function serialize(state) {
          * Filter out the outputs,
          * and the invisible inputs
          */
-        if (InputGraph.dependenciesOf(nodeId).length > 0 &&
+        if (
+            InputGraph.dependenciesOf(nodeId).length > 0 &&
             has(componentId, paths)
         ) {
             // Get the property
             const propLens = lensPath(
-                concat(paths[componentId],
-                ['props', componentProp]
-            ));
-            const propValue = view(
-                propLens,
-                layout
+                concat(paths[componentId], ['props', componentProp])
             );
+            const propValue = view(propLens, layout);
             savedState[nodeId] = propValue;
         }
     });
 
     return savedState;
-
 }
diff --git a/src/constants/constants.js b/src/constants/constants.js
index 52c021d0..1027aae9 100644
--- a/src/constants/constants.js
+++ b/src/constants/constants.js
@@ -2,5 +2,5 @@ export const REDIRECT_URI_PATHNAME = '/_oauth2/callback';
 export const OAUTH_COOKIE_NAME = 'plotly_oauth_token';
 
 export const STATUS = {
-    OK: 200
-}
+    OK: 200,
+};
diff --git a/src/reducers/api.js b/src/reducers/api.js
index a7e8d951..d4bb54bb 100644
--- a/src/reducers/api.js
+++ b/src/reducers/api.js
@@ -6,20 +6,28 @@ function createApiReducer(store) {
         if (action.type === store) {
             const {payload} = action;
             if (Array.isArray(payload.id)) {
-                newState = assocPath(payload.id, {
-                    status: payload.status,
-                    content: payload.content
-                }, state);
+                newState = assocPath(
+                    payload.id,
+                    {
+                        status: payload.status,
+                        content: payload.content,
+                    },
+                    state
+                );
             } else if (payload.id) {
-                newState = assoc(payload.id, {
-                    status: payload.status,
-                    content: payload.content
-                }, state);
-            } else {
-                newState = merge(
-                    state,
-                    {status: payload.status, content: payload.content}
+                newState = assoc(
+                    payload.id,
+                    {
+                        status: payload.status,
+                        content: payload.content,
+                    },
+                    state
                 );
+            } else {
+                newState = merge(state, {
+                    status: payload.status,
+                    content: payload.content,
+                });
             }
         }
         return newState;
diff --git a/src/reducers/appLifecycle.js b/src/reducers/appLifecycle.js
index 69adb3f4..93689c5b 100644
--- a/src/reducers/appLifecycle.js
+++ b/src/reducers/appLifecycle.js
@@ -1,7 +1,7 @@
 import {getAction} from '../actions/constants';
 import {getAppState} from './constants';
 
-function appLifecycle(state=getAppState('STARTED'), action) {
+function appLifecycle(state = getAppState('STARTED'), action) {
     switch (action.type) {
         case getAction('SET_APP_LIFECYCLE'):
             return getAppState(action.payload);
diff --git a/src/reducers/config.js b/src/reducers/config.js
index 2a1a2dd7..fdca9321 100644
--- a/src/reducers/config.js
+++ b/src/reducers/config.js
@@ -1,10 +1,9 @@
 /* global document:true */
 import {getAction} from '../actions/constants';
 
-export default function config (state = null, action) {
+export default function config(state = null, action) {
     if (action.type === getAction('READ_CONFIG')) {
         return JSON.parse(document.getElementById('_dash-config').textContent);
-    } 
-        return state;
-    
+    }
+    return state;
 }
diff --git a/src/reducers/dependencyGraph.js b/src/reducers/dependencyGraph.js
index 7da6e6fb..69049bb6 100644
--- a/src/reducers/dependencyGraph.js
+++ b/src/reducers/dependencyGraph.js
@@ -27,13 +27,11 @@ const graphs = (state = initialGraph, action) => {
             });
 
             return {InputGraph: inputGraph, EventGraph: eventGraph};
-
         }
 
         default:
             return state;
-
     }
-}
+};
 
 export default graphs;
diff --git a/src/reducers/history.js b/src/reducers/history.js
index 27bd96b9..8342b424 100644
--- a/src/reducers/history.js
+++ b/src/reducers/history.js
@@ -1,12 +1,11 @@
 const initialHistory = {
     past: [],
     present: {},
-    future: []
+    future: [],
 };
 
-function history (state = initialHistory, action) {
+function history(state = initialHistory, action) {
     switch (action.type) {
-
         case 'UNDO': {
             const {past, present, future} = state;
             const previous = past[past.length - 1];
@@ -14,7 +13,7 @@ function history (state = initialHistory, action) {
             return {
                 past: newPast,
                 present: previous,
-                future: [ present, ...future ]
+                future: [present, ...future],
             };
         }
 
@@ -25,16 +24,14 @@ function history (state = initialHistory, action) {
             return {
                 past: [...past, present],
                 present: next,
-                future: newFuture
+                future: newFuture,
             };
         }
 
         default: {
             return state;
         }
-
     }
 }
 
-
 export default history;
diff --git a/src/reducers/layout.js b/src/reducers/layout.js
index bc65010a..cce98739 100644
--- a/src/reducers/layout.js
+++ b/src/reducers/layout.js
@@ -4,24 +4,21 @@ import {getAction} from '../actions/constants';
 
 const layout = (state = {}, action) => {
     if (action.type === getAction('SET_LAYOUT')) {
-
         return action.payload;
-
-    } else if (contains(
-        action.type,
-        ['UNDO_PROP_CHANGE', 'REDO_PROP_CHANGE', getAction('ON_PROP_CHANGE')]
-    )) {
-
+    } else if (
+        contains(action.type, [
+            'UNDO_PROP_CHANGE',
+            'REDO_PROP_CHANGE',
+            getAction('ON_PROP_CHANGE'),
+        ])
+    ) {
         const propPath = append('props', action.payload.itempath);
         const existingProps = view(lensPath(propPath), state);
         const mergedProps = merge(existingProps, action.payload.props);
         return assocPath(propPath, mergedProps, state);
+    }
 
-    } 
-
-        return state;
-
-    
-}
+    return state;
+};
 
 export default layout;
diff --git a/src/reducers/paths.js b/src/reducers/paths.js
index 03660a27..c19a0037 100644
--- a/src/reducers/paths.js
+++ b/src/reducers/paths.js
@@ -1,5 +1,5 @@
-import {crawlLayout, hasId} from './utils'
-import R from 'ramda'
+import {crawlLayout, hasId} from './utils';
+import R from 'ramda';
 import {getAction} from '../actions/constants';
 
 const initialPaths = null;
@@ -16,19 +16,22 @@ const paths = (state = initialPaths, action) => {
 
             // if we're updating a subtree, clear out all of the existing items
             if (!R.isEmpty(startingPath)) {
-                const removeKeys = R.filter(k => (
-                    R.equals(startingPath, R.slice(0, startingPath.length, oldState[k]))
-                ), R.keys(oldState));
+                const removeKeys = R.filter(
+                    k =>
+                        R.equals(
+                            startingPath,
+                            R.slice(0, startingPath.length, oldState[k])
+                        ),
+                    R.keys(oldState)
+                );
                 newState = R.omit(removeKeys, oldState);
             } else {
                 newState = R.merge({}, oldState);
             }
 
             crawlLayout(subTree, function assignPath(child, itempath) {
-                if(hasId(child)) {
-
+                if (hasId(child)) {
                     newState[child.props.id] = R.concat(startingPath, itempath);
-
                 }
             });
 
@@ -39,6 +42,6 @@ const paths = (state = initialPaths, action) => {
             return state;
         }
     }
-}
+};
 
 export default paths;
diff --git a/src/reducers/reducer.js b/src/reducers/reducer.js
index 33ca050c..a77538af 100644
--- a/src/reducers/reducer.js
+++ b/src/reducers/reducer.js
@@ -1,4 +1,4 @@
-'use strict'
+'use strict';
 import R, {concat, lensPath, view} from 'ramda';
 import {combineReducers} from 'redux';
 import layout from './layout';
@@ -20,10 +20,9 @@ const reducer = combineReducers({
     dependenciesRequest: API.dependenciesRequest,
     layoutRequest: API.layoutRequest,
     loginRequest: API.loginRequest,
-    history
+    history,
 });
 
-
 function getInputHistoryState(itempath, props, state) {
     const {graphs, layout, paths} = state;
     const {InputGraph} = graphs;
@@ -34,8 +33,10 @@ function getInputHistoryState(itempath, props, state) {
         historyEntry = {id, props: {}};
         R.keys(props).forEach(propKey => {
             const inputKey = `${id}.${propKey}`;
-            if (InputGraph.hasNode(inputKey) &&
-                InputGraph.dependenciesOf(inputKey).length > 0) {
+            if (
+                InputGraph.hasNode(inputKey) &&
+                InputGraph.dependenciesOf(inputKey).length > 0
+            ) {
                 historyEntry.props[propKey] = view(
                     lensPath(concat(paths[id], ['props', propKey])),
                     layout
@@ -47,9 +48,10 @@ function getInputHistoryState(itempath, props, state) {
 }
 
 function recordHistory(reducer) {
-    return function (state, action) {
+    return function(state, action) {
         // Record initial state
-        if (action.type === 'ON_PROP_CHANGE' &&
+        if (
+            action.type === 'ON_PROP_CHANGE' &&
             R.isEmpty(state.history.present)
         ) {
             const {itempath, props} = action.payload;
@@ -61,7 +63,8 @@ function recordHistory(reducer) {
 
         const nextState = reducer(state, action);
 
-        if (action.type === 'ON_PROP_CHANGE' &&
+        if (
+            action.type === 'ON_PROP_CHANGE' &&
             action.payload.source !== 'response'
         ) {
             const {itempath, props} = action.payload;
@@ -69,24 +72,25 @@ function recordHistory(reducer) {
              * if the prop change is an input, then
              * record it so that it can be played back
              */
-            const historyEntry = getInputHistoryState(itempath, props, nextState);
+            const historyEntry = getInputHistoryState(
+                itempath,
+                props,
+                nextState
+            );
             if (historyEntry && !R.isEmpty(historyEntry.props)) {
-
                 nextState.history = {
                     past: [
                         ...nextState.history.past,
-                        nextState.history.present
+                        nextState.history.present,
                     ],
                     present: historyEntry,
-                    future: []
-                }
-
+                    future: [],
+                };
             }
         }
 
         return nextState;
-
-    }
+    };
 }
 
 export default recordHistory(reducer);
diff --git a/src/reducers/requestQueue.js b/src/reducers/requestQueue.js
index 455bbbd6..995285a9 100644
--- a/src/reducers/requestQueue.js
+++ b/src/reducers/requestQueue.js
@@ -8,6 +8,6 @@ const requestQueue = (state = [], action) => {
         default:
             return state;
     }
-}
+};
 
 export default requestQueue;
diff --git a/src/reducers/utils.js b/src/reducers/utils.js
index 540516a2..966fb0ad 100644
--- a/src/reducers/utils.js
+++ b/src/reducers/utils.js
@@ -1,36 +1,29 @@
 import R from 'ramda';
 
-const extend = R.reduce(R.flip(R.append))
+const extend = R.reduce(R.flip(R.append));
 
 // crawl a layout object, apply a function on every object
-export const crawlLayout = (object, func, path=[]) => {
+export const crawlLayout = (object, func, path = []) => {
     func(object, path);
 
     /*
      * object may be a string, a number, or null
      * R.has will return false for both of those types
      */
-    if (R.type(object) === 'Object' &&
+    if (
+        R.type(object) === 'Object' &&
         R.has('props', object) &&
         R.has('children', object.props)
     ) {
         const newPath = extend(path, ['props', 'children']);
         if (Array.isArray(object.props.children)) {
             object.props.children.forEach((child, i) => {
-                crawlLayout(
-                    child,
-                    func,
-                    R.append(i, newPath));
+                crawlLayout(child, func, R.append(i, newPath));
             });
         } else {
-            crawlLayout(
-                object.props.children,
-                func,
-                newPath
-            );
+            crawlLayout(object.props.children, func, newPath);
         }
-    }  else if (R.type(object) === 'Array') {
-
+    } else if (R.type(object) === 'Array') {
         /*
          * Sometimes when we're updating a sub-tree
          * (like when we're responding to a callback)
@@ -40,14 +33,10 @@ export const crawlLayout = (object, func, path=[]) => {
          */
 
         object.forEach((child, i) => {
-            crawlLayout(
-                child,
-                func,
-                R.append(i, path));
+            crawlLayout(child, func, R.append(i, path));
         });
-
     }
-}
+};
 
 export function hasId(child) {
     return (
diff --git a/src/styles/styles.js b/src/styles/styles.js
index 32b2c61c..868e2ec6 100644
--- a/src/styles/styles.js
+++ b/src/styles/styles.js
@@ -16,7 +16,7 @@ export const base = {
     html: {
         fontFamily: "'Open Sans', Helvetica, sans-serif",
         fontWeight: 400,
-        color: '#2A3F5F'
+        color: '#2A3F5F',
     },
 
     h2: {
@@ -52,7 +52,7 @@ export const base = {
     a: {
         color: '#119DFF',
         textDecoration: 'none',
-        cursor: 'pointer'
+        cursor: 'pointer',
     },
 
     caption: {
@@ -66,7 +66,7 @@ export const base = {
         marginRight: 'auto',
         width: '90%',
         maxWidth: '300px',
-    }
-}
+    },
+};
 
 export default base;

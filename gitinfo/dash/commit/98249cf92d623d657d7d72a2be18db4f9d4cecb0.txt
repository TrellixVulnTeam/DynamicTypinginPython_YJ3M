commit 98249cf92d623d657d7d72a2be18db4f9d4cecb0
Author: byron <byron@plot.ly>
Date:   Fri May 31 14:54:25 2019 -0400

    :tada: browser class for wd fixtures

diff --git a/dash/testing/browser.py b/dash/testing/browser.py
new file mode 100644
index 00000000..44ba17cc
--- /dev/null
+++ b/dash/testing/browser.py
@@ -0,0 +1,194 @@
+import os
+import sys
+import logging
+import percy
+
+from selenium import webdriver
+from selenium.webdriver.support import expected_conditions as EC
+from selenium.webdriver.common.by import By
+from selenium.webdriver.support.wait import WebDriverWait
+from selenium.webdriver.chrome.options import Options
+from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
+from selenium.common.exceptions import WebDriverException, TimeoutException
+
+from dash.testing.wait import text_to_equal
+from dash.exceptions import DashAppLoadingError
+
+logger = logging.getLogger(__name__)
+
+
+class Browser:
+    def __init__(self, browser, remote=None, wait_timeout=10):
+        self._browser = browser.lower()
+        self._wait_timeout = wait_timeout
+
+        self._driver = self.get_webdriver(remote)
+        self._driver.implicitly_wait(2)
+
+        self._wd_wait = WebDriverWait(
+            driver=self.driver, timeout=wait_timeout, poll_frequency=0.2
+        )
+        self._last_ts = 0
+        self._url = None
+
+        self.percy_runner = percy.Runner(
+            loader=percy.ResourceLoader(
+                webdriver=self.driver,
+                base_url="/assets",
+                root_dir="tests/assets",
+            )
+        )
+        self.percy_runner.initialize_build()
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, exc_type, exc_val, traceback):
+        try:
+            self.driver.quit()
+            self.percy_runner.finalize_build()
+        except WebDriverException:
+            logger.exception("webdriver quit was not successfully")
+        except percy.errors.Error:
+            logger.exception("percy runner failed to finalize properly")
+
+    def percy_snapshot(self, name=""):
+        snapshot_name = "{} - py{}.{}".format(
+            name, sys.version_info.major, sys.version_info.minor
+        )
+        logger.info("taking snapshot name => {}".format(snapshot_name))
+        self.percy_runner.snapshot(name=snapshot_name)
+
+    def _wait_for(self, method, args, timeout, msg):
+        """abstract generic pattern for explicit webdriver wait"""
+        _wait = (
+            self._wd_wait
+            if timeout is None
+            else WebDriverWait(self.driver, timeout)
+        )
+        return _wait.until(method(*args), msg)
+
+    # keep these two wait_for API for easy migration
+    def wait_for_element_by_css_selector(self, selector, timeout=None):
+        return self._wait_for(
+            EC.presence_of_element_located,
+            ((By.CSS_SELECTOR, selector),),
+            timeout,
+            "cannot find_element using the css selector",
+        )
+
+    def wait_for_text_to_equal(self, selector, text, timeout=None):
+        return self._wait_for(
+            text_to_equal,
+            (selector, text),
+            timeout,
+            "cannot wait until element contains expected text {}".format(text),
+        )
+
+    def wait_until_server_is_ready(self, timeout=10):
+
+        self.driver.get(self.server_url)
+        try:
+            self.wait_for_element_by_css_selector(
+                "#react-entry-point", timeout=timeout
+            )
+        except TimeoutException:
+            logger.exception(
+                "dash server is not loaded within {} seconds".format(timeout)
+            )
+            raise DashAppLoadingError(
+                "the expected Dash react entry point cannot be loaded"
+                " in browser\n HTML => {}\n Console Logs => {}\n".format(
+                    self.driver.find_element_by_tag_name("body").get_property(
+                        "innerHTML"
+                    ),
+                    "\n".join(self.get_logs()),
+                )
+            )
+
+    def get_webdriver(self, remote):
+        return (
+            getattr(self, "_get_{}".format(self._browser))()
+            if remote is None
+            else webdriver.Remote(
+                command_executor=remote,
+                desired_capabilities=getattr(
+                    DesiredCapabilities, self._browser.upper()
+                ),
+            )
+        )
+
+    def _get_chrome(self):
+        options = Options()
+        options.add_argument("--no-sandbox")
+
+        capabilities = DesiredCapabilities.CHROME
+        capabilities["loggingPrefs"] = {"browser": "SEVERE"}
+
+        if "DASH_TEST_CHROMEPATH" in os.environ:
+            options.binary_location = os.environ["DASH_TEST_CHROMEPATH"]
+
+        chrome = webdriver.Chrome(
+            options=options, desired_capabilities=capabilities
+        )
+        chrome.set_window_position(0, 0)
+        return chrome
+
+    def _get_firefox(self):
+
+        capabilities = DesiredCapabilities.FIREFOX
+        capabilities["loggingPrefs"] = {"browser": "SEVERE"}
+        capabilities["marionette"] = True
+
+        # https://developer.mozilla.org/en-US/docs/Download_Manager_preferences
+        fp = webdriver.FirefoxProfile()
+
+        # this will be useful if we wanna test download csv or other data
+        # files with selenium
+        # TODO this can be fed as a tmpdir fixture from pytest
+        fp.set_preference("browser.download.dir", "/tmp")
+        fp.set_preference("browser.download.folderList", 2)
+        fp.set_preference("browser.download.manager.showWhenStarting", False)
+
+        return webdriver.Firefox(fp, capabilities=capabilities)
+
+    def get_logs(self):
+        """get_logs works only with chrome webdriver"""
+        return (
+            [
+                entry
+                for entry in self.driver.get_log("browser")
+                if entry["timestamp"] > self._last_ts
+            ]
+            if self.driver.name == "chrome"
+            else []
+        )
+
+    def reset_log_timestamp(self):
+        '''reset_log_timestamp only work with chrome webdrier'''
+        if self.driver.name == "chrome":
+            entries = self.driver.get_log("browser")
+            if entries:
+                self._last_ts = entries[-1]["timestamp"]
+
+    @property
+    def driver(self):
+        return self._driver
+
+    @property
+    def session_id(self):
+        return self.driver.session_id
+
+    @property
+    def server_url(self):
+        return self._url
+
+    @server_url.setter
+    def server_url(self, value):
+        """property setter for server_url
+
+        Note: set server_url will implicitly check the server is ready
+        for selenium testing
+        """
+        self._url = value
+        self.wait_until_server_is_ready()
diff --git a/dash/testing/plugin.py b/dash/testing/plugin.py
index eadbcbb6..e881e9f1 100644
--- a/dash/testing/plugin.py
+++ b/dash/testing/plugin.py
@@ -4,6 +4,7 @@ import pytest
 from selenium import webdriver
 
 from dash.testing.application_runners import ThreadedRunner, ProcessRunner
+from dash.testing.browser import Browser
 
 WEBDRIVERS = {
     "Chrome": webdriver.Chrome,
@@ -12,27 +13,20 @@ WEBDRIVERS = {
 }
 
 
-def _get_config(config, key, default=None):
-    opt = config.getoption(key)
-    ini = config.getini(key)
-    return opt or ini or default
-
-
-###############################################################################
-# Plugin hooks.
-###############################################################################
-
 # pylint: disable=missing-docstring
 def pytest_addoption(parser):
+
     # Add options to the pytest parser, either on the commandline or ini
     # TODO add more options for the selenium driver.
     dash = parser.getgroup("Dash", "Dash Integration Tests")
-    help_msg = "Name of the selenium driver to use"
+
     dash.addoption(
-        "--webdriver", choices=tuple(WEBDRIVERS.keys()), help=help_msg
+        "-w",
+        "--webdriver",
+        choices=tuple(WEBDRIVERS.keys()),
+        default="Chrome",
+        help="Name of the selenium driver to use",
     )
-    parser.addini("webdriver", help=help_msg)
-
 
 ###############################################################################
 # Fixtures
@@ -41,33 +35,19 @@ def pytest_addoption(parser):
 
 @pytest.fixture
 def thread_server():
-    """
-    Start a local dash server in a new thread. Stop the server in teardown.
-    :Example:
-    .. code-block:: python
-        import dash
-        import dash_html_components as html
-        def test_application(dash_threaded):
-            app = dash.Dash(__name__)
-            app.layout = html.Div('My app)
-            dash_threaded(app)
-    .. seealso:: :py:class:`pytest_dash.application_runners.DashThreaded`
-    """
-
+    """Start a local dash server in a new thread"""
     with ThreadedRunner() as starter:
         yield starter
 
 
 @pytest.fixture
 def process_server():
-    """
-    Start a Dash server with subprocess.Popen and waitress-serve.
-    :Example:
-    .. code-block:: python
-        def test_application(dash_subprocess):
-            # consider the application file is named `app.py`
-            dash_subprocess('app')
-    .. seealso:: :py:class:`pytest_dash.application_runners.DashSubprocess`
-    """
+    """Start a Dash server with subprocess.Popen and waitress-serve"""
     with ProcessRunner() as starter:
         yield starter
+
+
+@pytest.fixture
+def br(request):
+    with Browser(request.config.getoption("webdriver")) as browser:
+        yield browser
diff --git a/dash/testing/wait.py b/dash/testing/wait.py
index 6306d2a2..df7d8718 100644
--- a/dash/testing/wait.py
+++ b/dash/testing/wait.py
@@ -24,3 +24,17 @@ def until_not(
         time.sleep(poll)
         if time.time() > end_time:
             raise TestingTimeoutError(msg)
+
+
+class text_to_equal(object):
+    def __init__(self, selector, text):
+        self.selector = selector
+        self.text = text
+
+    def __call__(self, driver):
+        elem = driver.find_element_by_css_selector(self.selector)
+        return (
+            str(elem.text) == self.text
+            or str(elem.get_attribute("value")) == self.text
+        )
+
diff --git a/pytest.ini b/pytest.ini
index bfada58f..c26b36e0 100644
--- a/pytest.ini
+++ b/pytest.ini
@@ -2,8 +2,5 @@
 testpaths = tests/
 addopts = -rsxX -vv
 log_cli=true
-log_cli_level = DEBUG
-webdriver = Chrome
-
-
-
+log_format = %(asctime)s | %(levelname)s | %(name)s:%(lineno)d | %(message)s
+log_cli_level = ERROR
diff --git a/tests/integration/test_devtools.py b/tests/integration/test_devtools.py
index bc49127d..a9c9ce4e 100644
--- a/tests/integration/test_devtools.py
+++ b/tests/integration/test_devtools.py
@@ -34,6 +34,12 @@ import pytest
 TIMEOUT = 20
 
 
+def test_wdr001_simple_br_dash_docs(br):
+    br.server_url = 'https://dash.plot.ly/'
+    br.wait_for_element_by_css_selector('#wait-for-layout')
+    assert not br.get_logs(), "no console errors"
+
+
 @pytest.mark.skip(
     reason="flakey with circleci, will readdressing after pytest fixture")
 class Tests(IntegrationTests):

commit 9d7ba787f4466c4a168d91a22e039d2d26505d8a
Author: alexcjohnson <alex@plot.ly>
Date:   Fri Sep 27 12:45:27 2019 -0400

    fix for toggling persistence on/off

diff --git a/dash-renderer/src/persistence.js b/dash-renderer/src/persistence.js
index 0e276188..11606388 100644
--- a/dash-renderer/src/persistence.js
+++ b/dash-renderer/src/persistence.js
@@ -280,30 +280,34 @@ const getValsKey = (id, persistedProp, persistence) =>
     `${id}.${persistedProp}.${JSON.stringify(persistence)}`;
 
 const getProps = layout => {
-    const {props} = layout;
-    const {id, persistence} = props;
-    if (!id || !persistence) {
-        // This component doesn't have persistence. To make downstream
-        // tests more efficient don't return either one, so we just have to
-        // test for truthy persistence.
-        // But we still need to return props for consumers that look for
-        // nested components
+    const {props, type, namespace} = layout;
+    if (!type || !namespace) {
+        // not a real component - just need the props for recursion
         return {props};
     }
+    const {id, persistence} = props;
 
     const element = Registry.resolve(layout);
     const persisted_props =
         props.persisted_props || element.defaultProps.persisted_props;
     const persistence_type =
         props.persistence_type || element.defaultProps.persistence_type;
-    if (!persisted_props || !persistence_type) {
-        return {props};
-    }
-    return {id, props, element, persistence, persisted_props, persistence_type};
+    const canPersist = id && persisted_props && persistence_type;
+
+    return {
+        canPersist,
+        id,
+        props,
+        element,
+        persistence,
+        persisted_props,
+        persistence_type,
+    };
 };
 
 export function recordUiEdit(layout, newProps, dispatch) {
     const {
+        canPersist,
         id,
         props,
         element,
@@ -311,7 +315,7 @@ export function recordUiEdit(layout, newProps, dispatch) {
         persisted_props,
         persistence_type,
     } = getProps(layout);
-    if (!persistence) {
+    if (!canPersist || !persistence) {
         return;
     }
 
@@ -378,6 +382,7 @@ function modProp(key, storage, element, props, persistedProp, update, undo) {
 
 function persistenceMods(layout, component, path, dispatch) {
     const {
+        canPersist,
         id,
         props,
         element,
@@ -387,7 +392,7 @@ function persistenceMods(layout, component, path, dispatch) {
     } = getProps(component);
 
     let layoutOut = layout;
-    if (persistence) {
+    if (canPersist && persistence) {
         const storage = getStore(persistence_type, dispatch);
         const update = {};
         forEach(
@@ -443,6 +448,7 @@ function persistenceMods(layout, component, path, dispatch) {
  */
 export function prunePersistence(layout, newProps, dispatch) {
     const {
+        canPersist,
         id,
         props,
         persistence,
@@ -455,7 +461,7 @@ export function prunePersistence(layout, newProps, dispatch) {
         propName in newProps ? newProps[propName] : prevVal;
     const finalPersistence = getFinal('persistence', persistence);
 
-    if (!persistence && !finalPersistence) {
+    if (!canPersist || !(persistence || finalPersistence)) {
         return newProps;
     }
 
@@ -471,6 +477,8 @@ export function prunePersistence(layout, newProps, dispatch) {
 
     const update = {};
 
+    let depersistedProps = props;
+
     if (persistenceChanged && persistence) {
         // clear previously-applied persistence
         const storage = getStore(persistence_type, dispatch);
@@ -487,6 +495,7 @@ export function prunePersistence(layout, newProps, dispatch) {
                 ),
             filter(notInNewProps, persisted_props)
         );
+        depersistedProps = mergeRight(props, update);
     }
 
     if (finalPersistence) {
@@ -497,10 +506,10 @@ export function prunePersistence(layout, newProps, dispatch) {
             forEach(
                 persistedProp =>
                     modProp(
-                        getValsKey(id, persistedProp, persistence),
+                        getValsKey(id, persistedProp, finalPersistence),
                         finalStorage,
                         element,
-                        props,
+                        depersistedProps,
                         persistedProp,
                         update
                     ),
@@ -516,11 +525,17 @@ export function prunePersistence(layout, newProps, dispatch) {
             if (propTransforms) {
                 for (const propPart in propTransforms) {
                     finalStorage.removeItem(
-                        getValsKey(id, `${propName}.${propPart}`, persistence)
+                        getValsKey(
+                            id,
+                            `${propName}.${propPart}`,
+                            finalPersistence
+                        )
                     );
                 }
             } else {
-                finalStorage.removeItem(getValsKey(id, propName, persistence));
+                finalStorage.removeItem(
+                    getValsKey(id, propName, finalPersistence)
+                );
             }
         }
     }
diff --git a/tests/integration/renderer/test_persistence.py b/tests/integration/renderer/test_persistence.py
index 034f920f..35a3bc12 100644
--- a/tests/integration/renderer/test_persistence.py
+++ b/tests/integration/renderer/test_persistence.py
@@ -3,6 +3,7 @@ from multiprocessing import Value
 import dash
 from dash.dependencies import Input, Output
 
+import dash_core_components as dcc
 import dash_html_components as html
 import dash_table as dt
 
@@ -51,6 +52,7 @@ def reloadable_app(**props_override):
 
     return app
 
+
 NEW_NAME = 'mango'
 
 
@@ -354,3 +356,102 @@ def test_rdps009_clear_prop_callback(dash_duo):
     dash_duo.find_element('#reset-names').click()
     # names are reset, but not hidden_columns
     check_table_names(dash_duo, ['a'])
+
+
+def test_rdps010_toggle_persistence(dash_duo):
+    def make_input(persistence):
+        return dcc.Input(id='persisted', value='a', persistence=persistence)
+
+    app = dash.Dash(__name__)
+    app.layout = html.Div([
+        dcc.Input(id='persistence-val', value=''),
+        html.Div(make_input(''), id='persisted-container'),
+        html.Div(id='out')
+    ])
+
+    @app.callback(
+        Output('persisted-container', 'children'),
+        [Input('persistence-val', 'value')]
+    )
+    def set_persistence(val):
+        return make_input(val)
+
+    @app.callback(Output('out', 'children'), [Input('persisted', 'value')])
+    def set_out(val):
+        return val
+
+    dash_duo.start_server(app)
+
+    dash_duo.wait_for_text_to_equal('#out', 'a')
+    dash_duo.find_element('#persisted').send_keys('lpaca')
+    dash_duo.wait_for_text_to_equal('#out', 'alpaca')
+
+    dash_duo.find_element('#persistence-val').send_keys('save!')
+    dash_duo.wait_for_text_to_equal('#out', 'a')
+    dash_duo.find_element('#persisted').send_keys('nchovies')
+    dash_duo.wait_for_text_to_equal('#out', 'anchovies')
+
+    dash_duo.find_element('#persistence-val').send_keys('2')
+    dash_duo.wait_for_text_to_equal('#out', 'a')
+    dash_duo.find_element('#persisted').send_keys('ardvark')
+    dash_duo.wait_for_text_to_equal('#out', 'aardvark')
+
+    # alpaca not saved with falsy persistence
+    dash_duo.clear_input('#persistence-val')
+    dash_duo.wait_for_text_to_equal('#out', 'a')
+
+    # anchovies and aardvark saved
+    dash_duo.find_element('#persistence-val').send_keys('save!')
+    dash_duo.wait_for_text_to_equal('#out', 'anchovies')
+    dash_duo.find_element('#persistence-val').send_keys('2')
+    dash_duo.wait_for_text_to_equal('#out', 'aardvark')
+
+
+def test_rdps011_toggle_persistence2(dash_duo):
+    def make_input(persistence):
+        return dcc.Input(id='persisted', value='a', persistence=persistence)
+
+    app = dash.Dash(__name__)
+    app.layout = html.Div([
+        dcc.Input(id='persistence-val', value=''),
+        dcc.Input(id='persisted', value='a', persistence=''),
+        html.Div(id='out')
+    ])
+
+    # this is not a good way to set persistence, as it doesn't allow you to
+    # get the right initial value. Much better is to update the whole component
+    # as we do in the previous test case... but it shouldn't break this way.
+    @app.callback(
+        Output('persisted', 'persistence'),
+        [Input('persistence-val', 'value')]
+    )
+    def set_persistence(val):
+        return val
+
+    @app.callback(Output('out', 'children'), [Input('persisted', 'value')])
+    def set_out(val):
+        return val
+
+    dash_duo.start_server(app)
+
+    dash_duo.wait_for_text_to_equal('#out', 'a')
+
+    dash_duo.find_element('#persistence-val').send_keys('save!')
+    dash_duo.wait_for_text_to_equal('#out', 'a')
+    dash_duo.find_element('#persisted').send_keys('pricot')
+    dash_duo.wait_for_text_to_equal('#out', 'apricot')
+
+    dash_duo.find_element('#persistence-val').send_keys('2')
+    dash_duo.wait_for_text_to_equal('#out', 'a')
+    dash_duo.find_element('#persisted').send_keys('rtichoke')
+    dash_duo.wait_for_text_to_equal('#out', 'artichoke')
+
+    # no persistence, still goes back to original value
+    dash_duo.clear_input('#persistence-val')
+    dash_duo.wait_for_text_to_equal('#out', 'a')
+
+    # apricot and artichoke saved
+    dash_duo.find_element('#persistence-val').send_keys('save!')
+    dash_duo.wait_for_text_to_equal('#out', 'apricot')
+    dash_duo.find_element('#persistence-val').send_keys('2')
+    dash_duo.wait_for_text_to_equal('#out', 'artichoke')

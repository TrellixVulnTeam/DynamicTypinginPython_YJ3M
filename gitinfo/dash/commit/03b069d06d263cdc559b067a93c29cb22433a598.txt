commit 03b069d06d263cdc559b067a93c29cb22433a598
Author: Ryan Patrick Kyle <ryan@plot.ly>
Date:   Wed Dec 5 00:19:55 2018 -0500

    refactored code to work with generator method

diff --git a/dash/development/_all_keywords.py b/dash/development/_all_keywords.py
index 76842b56..550c1d9f 100644
--- a/dash/development/_all_keywords.py
+++ b/dash/development/_all_keywords.py
@@ -3,7 +3,7 @@
 # >>> import keyword
 # >>> keyword.kwlist
 
-kwlist = set([
+python_keywords = set([
     'and',
     'elif',
     'is',
@@ -42,3 +42,31 @@ kwlist = set([
     'def',
     'lambda'
 ])
+
+# This is a set of R reserved words that cannot be used as function argument names.
+#
+# Reserved words can be obtained from R's help pages by executing the statement below:
+# > ?reserved
+
+r_keywords = set([
+    'if',
+    'else',
+    'repeat',
+    'while',
+    'function',
+    'for',
+    'in',
+    'next',
+    'break',
+    'TRUE',
+    'FALSE',
+    'NULL',
+    'Inf',
+    'NaN',
+    'NA',
+    'NA_integer_',
+    'NA_real_',
+    'NA_complex_',
+    'NA_character_',
+    '...'
+])
diff --git a/dash/development/_py_components_generation.py b/dash/development/_py_components_generation.py
index ba17ccd8..d187c3a0 100644
--- a/dash/development/_py_components_generation.py
+++ b/dash/development/_py_components_generation.py
@@ -4,7 +4,7 @@ import os
 import textwrap
 
 from dash.development.base_component import _explicitize_args
-from ._all_keywords import kwlist
+from ._all_keywords import python_keywords
 from .base_component import Component
 
 
@@ -122,7 +122,7 @@ def generate_class_string(typename, props, description, namespace):
           '{:s}=Component.UNDEFINED'.format(p))
          for p in prop_keys
          if not p.endswith("-*") and
-         p not in kwlist and
+         p not in python_keywords and
          p not in ['dashEvents', 'fireEvent', 'setProps']] + ['**kwargs']
     )
 
diff --git a/dash/development/_r_components_generation.py b/dash/development/_r_components_generation.py
new file mode 100644
index 00000000..89948891
--- /dev/null
+++ b/dash/development/_r_components_generation.py
@@ -0,0 +1,541 @@
+from __future__ import absolute_import
+
+import os
+import sys
+
+from ._all_keywords import r_keywords
+from ._py_components_generation import reorder_props
+
+
+# This is an initial attempt at resolving type inconsistencies
+# between R and JSON.
+def json_to_r_type(current_prop):
+    object_type = current_prop['type'].values()
+    if 'defaultValue' in current_prop and object_type == ['string']:
+        if current_prop['defaultValue']['value'].__contains__('\''):
+            argument = current_prop['defaultValue']['value']
+        else:
+            argument = "\'{:s}\'".format(current_prop['defaultValue']['value'])
+    elif 'defaultValue' in current_prop and object_type == ['object']:
+        argument = 'list()'
+    elif 'defaultValue' in current_prop and \
+            current_prop['defaultValue']['value'] == '[]':
+        argument = 'list()'
+    else:
+        argument = 'NULL'
+    return argument
+
+
+# pylint: disable=R0914
+def generate_class_string_r(name, props, project_shortname, prefix):
+    """
+    Dynamically generate class strings to have nicely formatted documentation,
+    and function arguments
+
+    Inspired by http://jameso.be/2013/08/06/namedtuple.html
+
+    Parameters
+    ----------
+    name
+    props
+    project_shortname
+    prefix
+
+    Returns
+    -------
+    string
+
+    """
+
+    c = '''{prefix}{name} <- function(..., {default_argtext}) {{
+
+    component <- list(
+        props = list({default_paramtext}),
+        type = '{name}',
+        project_shortname = '{project_shortname}',
+        propNames = c({prop_names}),
+        package = '{package_name}'
+        )
+
+    component$props <- filter_null(component$props)
+    component <- append_wildcard_props(component, wildcards = {default_wildcards}, ...)
+
+    structure(component, class = c('dash_component', 'list'))
+}}'''
+
+    # Here we convert from snake case to camel case
+    package_name = make_package_name_r(project_shortname)
+
+    prop_keys = list(props.keys())
+
+    default_paramtext = ''
+    default_argtext = ''
+    default_wildcards = ''
+
+    # Produce a string with all property names other than WCs
+    prop_names = ", ".join(
+        ('\'{:s}\''.format(p))
+        for p in prop_keys
+        if '*' not in p and
+        p not in ['setProps', 'dashEvents', 'fireEvent']
+    )
+
+    # in R, we set parameters with no defaults to NULL
+    # Here we'll do that if no default value exists
+    default_wildcards += ", ".join(
+        ('\'{:s}\''.format(p))
+         for p in prop_keys
+         if '*' in p
+    )
+
+    if default_wildcards == '':
+        default_wildcards = 'NULL'
+    else:
+        default_wildcards = 'c({:s})'.format(default_wildcards)
+
+    default_argtext += ", ".join(
+        ('{:s}={}'.format(p, json_to_r_type(props[p]))
+          if 'defaultValue' in props[p] else
+          '{:s}=NULL'.format(p))
+         for p in prop_keys
+         if not p.endswith("-*") and
+         p not in r_keywords and
+         p not in ['setProps', 'dashEvents', 'fireEvent']
+    )
+
+    if 'children' in props:
+        prop_keys.remove('children')
+
+    # pylint: disable=C0301
+    default_paramtext += ", ".join(
+        ('{:s}={:s}'.format(p, p)
+          if p != "children" else
+          '{:s}=c(children, assert_valid_children(..., wildcards = {:s}))'.format(p, default_wildcards))
+         for p in props.keys()
+         if not p.endswith("-*") and
+         p not in r_keywords and
+         p not in ['setProps', 'dashEvents', 'fireEvent']
+    )
+    return c.format(prefix=prefix,
+                    name=name,
+                    default_argtext=default_argtext,
+                    default_paramtext=default_paramtext,
+                    project_shortname=project_shortname,
+                    prop_names=prop_names,
+                    package_name=package_name,
+                    default_wildcards=default_wildcards)
+
+
+# pylint: disable=R0914
+def generate_js_metadata_r(project_shortname):
+    """
+    Dynamically generate R function to supply JavaScript
+    dependency information required by htmltools package,
+    which is loaded by dashR.
+
+    Inspired by http://jameso.be/2013/08/06/namedtuple.html
+
+    Parameters
+    ----------
+    project_shortname
+
+    Returns
+    -------
+    function_string
+    """
+
+    # import component library module into sys
+    mod = sys.modules[project_shortname]
+
+    jsdist = getattr(mod, '_js_dist', [])
+    project_ver = getattr(mod, '__version__', [])
+
+    rpkgname = make_package_name_r(project_shortname)
+
+    # since _js_dist may suggest more than one dependency, need
+    # a way to iterate over all dependencies for a given set.
+    # here we define an opening, element, and closing string --
+    # if the total number of dependencies > 1, we can concatenate
+    # them and write a list object in R with multiple elements
+    function_frame_open = '''.{rpkgname}_js_metadata <- function() {{
+deps_metadata <- list(
+'''.format(rpkgname=rpkgname)
+
+    function_frame = []
+
+    # the following string represents all the elements in an object
+    # of the html_dependency class, which will be propagated by
+    # iterating over _js_dist in __init__.py
+    function_frame_element = '''`{dep_name}` = structure(list(name = "{dep_name}",
+version = "{project_ver}", src = list(href = NULL,
+file = "lib/"), meta = NULL,
+script = "{dep_rpp}",
+stylesheet = NULL, head = NULL, attachment = NULL, package = "{rpkgname}",
+all_files = FALSE), class = "html_dependency")'''
+
+    if len(jsdist) > 1:
+        for dep in range(len(jsdist)):
+            if jsdist[dep]['relative_package_path'].__contains__('dash_'):
+                dep_name = jsdist[dep]['relative_package_path'].split('.')[0]
+            else:
+                dep_name = '{:s}_{:s}'.format(project_shortname, str(dep))
+                project_ver = str(dep)
+            function_frame += [function_frame_element.format(dep_name=dep_name,
+                                                             project_ver=project_ver,
+                                                             rpkgname=rpkgname,
+                                                             project_shortname=project_shortname,
+                                                             dep_rpp=jsdist[dep]['relative_package_path'])
+                               ]
+            function_frame_body = ',\n'.join(function_frame)
+    elif len(jsdist) == 1:
+        function_frame_body = '''`{project_shortname}` = structure(list(name = "{project_shortname}",
+version = "{project_ver}", src = list(href = NULL,
+file = "lib/"), meta = NULL,
+script = "{dep_rpp}",
+stylesheet = NULL, head = NULL, attachment = NULL, package = "{rpkgname}",
+all_files = FALSE), class = "html_dependency")'''.format(project_shortname=project_shortname,
+                                                         project_ver=project_ver,
+                                                         rpkgname=rpkgname,
+                                                         dep_rpp=jsdist[0]['relative_package_path'])
+
+    function_frame_close = ''')
+    return(deps_metadata)
+}'''
+
+    function_string = ''.join([function_frame_open,
+                              function_frame_body,
+                              function_frame_close]
+                              )
+
+    return function_string
+
+
+def write_help_file_r(name, props, description, prefix):
+    """
+    Write R documentation file (.Rd) given component name and properties
+
+    Parameters
+    ----------
+    name
+    props
+    description
+    prefix
+
+    Returns
+    -------
+
+
+    """
+    file_name = '{:s}{:s}.Rd'.format(prefix, name)
+    prop_keys = list(props.keys())
+
+    default_argtext = ''
+    item_text = ''
+
+    # Ensure props are ordered with children first
+    props = reorder_props(props=props)
+
+    default_argtext += ", ".join(
+        ('{:s}={}'.format(p, json_to_r_type(props[p]))
+          if 'defaultValue' in props[p] else
+          '{:s}=NULL'.format(p))
+         for p in prop_keys
+         if not p.endswith("-*") and
+         p not in r_keywords and
+         p not in ['setProps', 'dashEvents', 'fireEvent']
+    )
+
+    item_text += "\n\n".join(
+        ('\\item{{{:s}}}{{{:s}}}'.format(p, props[p]['description']))
+        for p in prop_keys
+        if not p.endswith("-*") and
+        p not in r_keywords and
+        p not in ['setProps', 'dashEvents', 'fireEvent']
+    )
+
+    help_string = '''% Auto-generated: do not edit by hand
+\\name{{{prefix}{name}}}
+\\alias{{{prefix}{name}}}
+\\title{{{name} component}}
+\\usage{{
+{prefix}{name}(..., {default_argtext})
+}}
+\\arguments{{
+{item_text}
+}}
+\\description{{
+{description}
+}}
+    '''
+    if not os.path.exists('man'):
+        os.makedirs('man')
+
+    file_path = os.path.join('man', file_name)
+    with open(file_path, 'w') as f:
+        f.write(help_string.format(
+            prefix=prefix,
+            name=name,
+            default_argtext=default_argtext,
+            item_text=item_text,
+            description=description.replace('\n', ' ')
+        ))
+
+
+def write_class_file_r(name, props, description, project_shortname, prefix=None):
+    """
+    Generate a R class file (.R) given a class string
+
+    Parameters
+    ----------
+    name
+    props
+    description
+    project_shortname
+    prefix
+
+    Returns
+    -------
+
+    """
+
+    import_string =\
+        "# AUTO GENERATED FILE - DO NOT EDIT\n\n"
+    class_string = generate_class_string_r(
+        name,
+        props,
+        project_shortname,
+        prefix
+    )
+    file_name = "{:s}{:s}.R".format(prefix, name)
+
+    if not os.path.exists('R'):
+        os.makedirs('R')
+
+    file_path = os.path.join('R', file_name)
+    with open(file_path, 'w') as f:
+        f.write(import_string)
+        f.write(class_string)
+
+    # generate the internal (not exported to the user) functions which
+    # supply the JavaScript dependencies to the htmlDependency package,
+    # which is required by DashR (this avoids having to generate an
+    # RData file from within Python, given the current package generation
+    # workflow)
+    write_js_metadata_r(
+        project_shortname
+    )
+
+    # generate the R help pages for each of the Dash components that we
+    # are transpiling -- this is done to avoid using Roxygen2 syntax,
+    # we may eventually be able to generate similar documentation using
+    # doxygen and an R plugin, but for now we'll just do it on our own
+    # from within Python
+    write_help_file_r(
+        name,
+        props,
+        description,
+        prefix
+    )
+
+
+# pylint: disable=unused-variable
+def generate_export_string_r(name, prefix):
+    if not name.endswith('-*') and \
+            str(name) not in r_keywords and \
+            str(name) not in ['setProps', 'children', 'dashEvents']:
+        return 'export({:s}{:s})\n'.format(prefix, name)
+
+
+def write_js_metadata_r(project_shortname):
+    """
+    Write an internal (not exported) function to return all JS
+    dependencies as required by htmlDependency package given a
+    function string
+
+    Parameters
+    ----------
+    project_shortname
+
+    Returns
+    -------
+
+    """
+    function_string = generate_js_metadata_r(
+        project_shortname
+    )
+    file_name = "internal.R"
+
+    # the R source directory for the package won't exist on first call
+    # create the R directory if it is missing
+    if not os.path.exists('R'):
+        os.makedirs('R')
+
+    file_path = os.path.join('R', file_name)
+    with open(file_path, 'w') as f:
+        f.write(function_string)
+
+    # now copy over all JS dependencies from the (Python) components dir
+    import shutil
+    import glob
+
+    # the inst/lib directory for the package won't exist on first call
+    # create this directory if it is missing
+    if not os.path.exists('inst'):
+        os.makedirs('inst')
+
+    if not os.path.exists('inst/lib'):
+        os.makedirs('inst/lib')
+
+    for javascript in glob.glob('{}/*.js'.format(project_shortname)):
+        shutil.copy(javascript, 'inst/lib/')
+
+
+# pylint: disable=R0914
+def generate_rpkg(pkg_data,
+                  project_shortname,
+                  export_string):
+    """
+    Generate documents for R package creation
+
+    Parameters
+    ----------
+    pkg_data
+    project_shortname
+    export_string
+
+    Returns
+    -------
+
+    """
+    # Leverage package.json to import specifics which are also applicable
+    # to R package that we're generating here
+    package_name = make_package_name_r(project_shortname)
+    package_description = pkg_data['description']
+    package_version = pkg_data['version']
+    package_issues = pkg_data['bugs']['url']
+    package_url = pkg_data['homepage']
+
+    package_author = pkg_data['author']
+
+    package_author_no_email = package_author.split(" <")[0] + ' [aut]'
+
+    if not (os.path.isfile('LICENSE') or os.path.isfile('LICENSE.txt')):
+        package_license = pkg_data['license']
+    else:
+        package_license = pkg_data['license'] + ' + file LICENSE'
+        # R requires that the LICENSE.txt file be named LICENSE
+        if not os.path.isfile('LICENSE'):
+            os.symlink("LICENSE.txt", "LICENSE")
+
+    import_string =\
+        '# AUTO GENERATED FILE - DO NOT EDIT\n\n'
+
+    description_string = \
+    '''Package: {package_name}
+Title: {package_description}
+Version: {package_version}
+Authors @R: as.person(c({package_author}))
+Description: {package_description}
+Suggests: testthat, roxygen2
+License: {package_license}
+URL: {package_url}
+BugReports: {package_issues}
+Encoding: UTF-8
+LazyData: true
+Author: {package_author_no_email}
+Maintainer: {package_author}
+'''
+
+    description_string = description_string.format(package_name=package_name,
+                                                   package_description=package_description,
+                                                   package_version=package_version,
+                                                   package_author=package_author,
+                                                   package_license=package_license,
+                                                   package_url=package_url,
+                                                   package_issues=package_issues,
+                                                   package_author_no_email=package_author_no_email)
+
+    rbuild_ignore_string = r'''# ignore JS config files/folders
+node_modules/
+coverage/
+src/
+lib/
+.babelrc
+.builderrc
+.eslintrc
+.npmignore
+
+# demo folder has special meaning in R
+# this should hopefully make it still
+# allow for the possibility to make R demos
+demo/*.js
+demo/*.html
+demo/*.css
+
+# ignore python files/folders
+setup.py
+usage.py
+setup.py
+requirements.txt
+MANIFEST.in
+CHANGELOG.md
+test/
+# CRAN has weird LICENSE requirements
+LICENSE.txt
+^.*\.Rproj$
+^\.Rproj\.user$
+'''
+
+    with open('NAMESPACE', 'w') as f:
+        f.write(import_string)
+        f.write(export_string)
+
+    with open('DESCRIPTION', 'w') as f2:
+        f2.write(description_string)
+
+    with open('.Rbuildignore', 'w') as f3:
+        f3.write(rbuild_ignore_string)
+
+
+# This converts a string from snake case to camel case
+# Not required for R package name to be in camel case,
+# but probably more conventional this way
+def make_package_name_r(namestring):
+    first, rest = namestring.split('_')[0], namestring.split('_')[1:]
+    return first + ''.join(word.capitalize() for word in rest)
+
+
+# For the R packages corresponding to the component
+# libraries, use 'project_shortname' to determine
+# the prefix for the set of R functions we're
+# generating that correspond to Dash components.
+#
+# e.g. the graph component in DCC will be prepended
+# with 'core', so that the R function is coreGraph()
+def get_shortname_prefix(project_shortname):
+    if project_shortname == 'dash_html_components':
+        prefix = 'html'
+    elif project_shortname == 'dash_core_components':
+        prefix = 'core'
+    else:
+        prefix = ''
+
+    return prefix
+
+# pylint: disable=unused-variable
+def generate_exports_r(project_shortname, components, metadata, pkg_data, prefix, **kwargs):
+    export_string = ''
+    for component in components:
+        if not component.endswith('-*') and \
+                str(component) not in r_keywords and \
+                str(component) not in ['setProps', 'children', 'dashEvents']:
+            export_string += 'export({:s}{:s})\n'.format(prefix, component)
+
+    # now, bundle up the package information and create all the requisite
+    # elements of an R package, so that the end result is installable either
+    # locally or directly from GitHub
+    generate_rpkg(
+        pkg_data,
+        project_shortname,
+        export_string
+    )
\ No newline at end of file
diff --git a/dash/development/component_generator.py b/dash/development/component_generator.py
index 8e04e0ea..2ce999f8 100644
--- a/dash/development/component_generator.py
+++ b/dash/development/component_generator.py
@@ -7,14 +7,18 @@ import shlex
 import os
 import argparse
 import shutil
+import functools
 
 import pkg_resources
+from .component_loader import _get_metadata
 
+from ._r_components_generation import write_class_file_r
+from ._r_components_generation import generate_exports_r
+from ._r_components_generation import get_shortname_prefix
 from ._py_components_generation import generate_class_file
 from ._py_components_generation import generate_imports
 from ._py_components_generation import generate_classes_files
 
-
 class _CombinedFormatter(argparse.ArgumentDefaultsHelpFormatter,
                          argparse.RawDescriptionHelpFormatter):
     pass
@@ -22,7 +26,17 @@ class _CombinedFormatter(argparse.ArgumentDefaultsHelpFormatter,
 
 # pylint: disable=too-many-locals
 def generate_components(components_source, project_shortname,
-                        package_info_filename='package.json'):
+                        package_info_filename='package.json',
+                        generate_r_components=False):
+    project_shortname = project_shortname.replace('-', '_').rstrip('/\\')
+
+    import importlib
+
+    # import component library module
+    importlib.import_module(project_shortname)
+
+    prefix = get_shortname_prefix(project_shortname)
+
     is_windows = sys.platform == 'win32'
 
     extract_path = pkg_resources.resource_filename('dash', 'extract-meta.js')
@@ -52,11 +66,18 @@ def generate_components(components_source, project_shortname,
         sys.exit(1)
 
     metadata = json.loads(out.decode())
+    generator_methods = [generate_class_file]
+    # pkg_generator_methods = [generate_imports]
+
+    if generate_r_components:
+        generator_methods.append(
+            functools.partial(write_class_file_r, prefix=prefix))
+        #generator_methods.append(generate_rpkg)
 
     components = generate_classes_files(
         project_shortname,
         metadata,
-        generate_class_file
+        *generator_methods
     )
 
     with open(os.path.join(project_shortname, 'metadata.json'), 'w') as f:
@@ -64,6 +85,44 @@ def generate_components(components_source, project_shortname,
 
     generate_imports(project_shortname, components)
 
+    if generate_r_components:
+        # -- do all the R stuff here, remove loop as it is unnecessary
+        # Remove the R NAMESPACE file if it exists, this will be repopulated
+        # if os.path.isfile('NAMESPACE'):
+        #    os.remove('NAMESPACE')
+
+        with open('package.json', 'r') as f:
+            pkg_data = json.load(f)
+
+        generate_exports_r(project_shortname, components, metadata, pkg_data, prefix)
+
+
+def generate_components_r(namespace,
+                          metadata_path='lib/metadata.json',
+                          pkgjson_path='package.json'):
+    """Load React component metadata into a format Dash can parse,
+    then create R files for component loading.
+
+    Usage: generate_classes_r()
+
+    Keyword arguments:
+    namespace -- name of the generated python package (also output dir)
+
+    metadata_path -- a path to a JSON file created by
+    [`react-docgen`](https://github.com/reactjs/react-docgen).
+
+    pkgjson_path -- a path to a JSON file created by
+    [`cookiecutter`](https://github.com/audreyr/cookiecutter).
+
+    Returns:
+    """
+
+    data = _get_metadata(metadata_path)
+    pkg_data = _get_metadata(pkgjson_path)
+    export_string = ''
+
+
+
 
 def cli():
     parser = argparse.ArgumentParser(
@@ -83,10 +142,16 @@ def cli():
         default='package.json',
         help='The filename of the copied `package.json` to `project_shortname`'
     )
+    parser.add_argument(
+        '-r', '--rlang',
+        action='store_true',
+        help='Generate Dash components for R, and package for installation.'
+    )
 
     args = parser.parse_args()
     generate_components(args.components_source, args.project_shortname,
-                        package_info_filename=args.package_info_filename)
+                        package_info_filename=args.package_info_filename,
+                        generate_r_components=args.rlang)
 
 
 if __name__ == '__main__':

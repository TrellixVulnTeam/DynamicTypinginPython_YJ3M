commit 316cdd87263bcd59e9196993d9eb57443e03d7b6
Author: alexcjohnson <alex@plot.ly>
Date:   Sat Feb 29 18:08:51 2020 -0500

    fix the fix for dcc.Location multi-path init case

diff --git a/dash-renderer/src/actions/dependencies.js b/dash-renderer/src/actions/dependencies.js
index 14d1adbc..a98ebd7a 100644
--- a/dash-renderer/src/actions/dependencies.js
+++ b/dash-renderer/src/actions/dependencies.js
@@ -1,7 +1,6 @@
 import {DepGraph} from 'dependency-graph';
 import isNumeric from 'fast-isnumeric';
 import {
-    all,
     any,
     ap,
     assoc,
@@ -803,7 +802,13 @@ export function getCallbacksInLayout(graphs, paths, layoutChunk, opts) {
         if (!outputsOnly && inIdCallbacks) {
             const idStr = removedArrayInputsOnly && stringifyId(id);
             for (const property in inIdCallbacks) {
-                getCallbacksByInput(graphs, paths, id, property).forEach(
+                getCallbacksByInput(
+                    graphs,
+                    paths,
+                    id,
+                    property,
+                    INDIRECT
+                ).forEach(
                     removedArrayInputsOnly
                         ? addCallbackIfArray(idStr)
                         : addCallback
@@ -843,9 +848,15 @@ export function getCallbacksInLayout(graphs, paths, layoutChunk, opts) {
     finalCallbacks.forEach(cb => {
         if (cb.initialCall && !isEmpty(cb.blockedBy)) {
             const inputs = flatten(cb.getInputs(paths));
-            if (all(i => cb.changedPropIds[combineIdAndProp(i)], inputs)) {
-                cb.initialCall = false;
-            }
+            cb.initialCall = false;
+            inputs.forEach(i => {
+                const propId = combineIdAndProp(i);
+                if (cb.changedPropIds[propId]) {
+                    cb.changedPropIds[propId] = INDIRECT;
+                } else {
+                    cb.initialCall = true;
+                }
+            });
         }
     });
 
@@ -867,7 +878,7 @@ export function removePendingCallback(
                     blockedBy: dissoc(removeResolvedId, blockedBy),
                     blocking: dissoc(removeResolvedId, blocking),
                     changedPropIds: pickBy(
-                        (v, k) => v === DIRECT || includes(k, skippedProps),
+                        (v, k) => v === DIRECT || !includes(k, skippedProps),
                         changedPropIds
                     ),
                 })
@@ -941,7 +952,13 @@ export function followForward(graphs, paths, callbacks_) {
     let callback;
 
     const followOutput = ({id, property}) => {
-        const nextCBs = getCallbacksByInput(graphs, paths, id, property, INDIRECT);
+        const nextCBs = getCallbacksByInput(
+            graphs,
+            paths,
+            id,
+            property,
+            INDIRECT
+        );
         nextCBs.forEach(nextCB => {
             let existingIndex = allResolvedIds[nextCB.resolvedId];
             if (existingIndex === undefined) {
diff --git a/tests/integration/callbacks/test_basic_callback.py b/tests/integration/callbacks/test_basic_callback.py
index fa1854cb..6458dee0 100644
--- a/tests/integration/callbacks/test_basic_callback.py
+++ b/tests/integration/callbacks/test_basic_callback.py
@@ -7,7 +7,7 @@ import dash_core_components as dcc
 import dash_html_components as html
 import dash_table
 import dash
-from dash.dependencies import Input, Output
+from dash.dependencies import Input, Output, State
 from dash.exceptions import PreventUpdate
 
 
@@ -163,7 +163,7 @@ def test_cbsc003_callback_with_unloaded_async_component(dash_duo):
     )
 
     @app.callback(Output("output", "children"), [Input("btn", "n_clicks")])
-    def update_graph(n_clicks):
+    def update_out(n_clicks):
         if n_clicks is None:
             raise PreventUpdate
 
@@ -171,12 +171,57 @@ def test_cbsc003_callback_with_unloaded_async_component(dash_duo):
 
     dash_duo.start_server(app)
 
+    dash_duo.wait_for_text_to_equal("#output", "Hello")
     dash_duo.find_element("#btn").click()
-    assert dash_duo.find_element("#output").text == "Bye"
+    dash_duo.wait_for_text_to_equal("#output", "Bye")
     assert dash_duo.get_logs() == []
 
 
-def test_cbsc004_children_types(dash_duo):
+@pytest.mark.skip(reason="https://github.com/plotly/dash/issues/1105")
+def test_cbsc004_callback_using_unloaded_async_component(dash_duo):
+    app = dash.Dash()
+    app.layout = html.Div(
+        children=[
+            dcc.Tabs(
+                children=[
+                    dcc.Tab(
+                        children=[
+                            html.Button(id="btn", children="Update Input"),
+                            html.Div(id="output", children=["Hello"]),
+                        ]
+                    ),
+                    dcc.Tab(
+                        children=dash_table.DataTable(
+                            id="other-table",
+                            columns=[{"id": "a", "name": "A"}],
+                            data=[{"a": "b"}]
+                        )
+                    ),
+                ]
+            )
+        ]
+    )
+
+    @app.callback(
+        Output("output", "children"),
+        [Input("btn", "n_clicks")],
+        [State("other-table", "data")]
+    )
+    def update_out(n_clicks, data):
+        if n_clicks is None:
+            return len(data)
+
+        return json.dumps(data) + ' - ' + str(n_clicks)
+
+    dash_duo.start_server(app)
+
+    dash_duo.wait_for_text_to_equal("#output", '[{"a": "b"}] - None')
+    dash_duo.find_element("#btn").click()
+    dash_duo.wait_for_text_to_equal("#output", '[{"a": "b"}] - 1')
+    assert dash_duo.get_logs() == []
+
+
+def test_cbsc005_children_types(dash_duo):
     app = dash.Dash()
     app.layout = html.Div([
         html.Button(id="btn"),
@@ -208,7 +253,7 @@ def test_cbsc004_children_types(dash_duo):
         dash_duo.wait_for_text_to_equal("#out", text)
 
 
-def test_cbsc005_array_of_objects(dash_duo):
+def test_cbsc006_array_of_objects(dash_duo):
     app = dash.Dash()
     app.layout = html.Div([
         html.Button(id="btn"),
@@ -238,7 +283,7 @@ def test_cbsc005_array_of_objects(dash_duo):
 
 
 @pytest.mark.parametrize("refresh", [False, True])
-def test_cbsc006_parallel_updates(refresh, dash_duo):
+def test_cbsc007_parallel_updates(refresh, dash_duo):
     # This is a funny case, that seems to mostly happen with dcc.Location
     # but in principle could happen in other cases too:
     # A callback chain (in this case the initial hydration) is set to update a

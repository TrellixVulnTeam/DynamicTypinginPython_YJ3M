commit dbdc4b6e5626e5657898c4944d2456d9293e8aec
Author: byron <byron@plot.ly>
Date:   Tue Mar 19 16:48:14 2019 -0400

    :art: npm run format

diff --git a/src/APIController.react.js b/src/APIController.react.js
index 6824a0c5..e471a2a4 100644
--- a/src/APIController.react.js
+++ b/src/APIController.react.js
@@ -100,7 +100,7 @@ class UnconnectedContainer extends Component {
         } else if (appLifecycle === getAppState('HYDRATED')) {
             return (
                 <GlobalErrorContainer>
-                    <TreeContainer _dashprivate_layout={layout}/>
+                    <TreeContainer _dashprivate_layout={layout} />
                 </GlobalErrorContainer>
             );
         }
@@ -119,8 +119,8 @@ UnconnectedContainer.propTypes = {
     layout: PropTypes.object,
     paths: PropTypes.object,
     history: PropTypes.array,
-    error: PropTypes.object
-}
+    error: PropTypes.object,
+};
 
 const Container = connect(
     // map state to props
@@ -132,7 +132,7 @@ const Container = connect(
         graphs: state.graphs,
         paths: state.paths,
         history: state.history,
-        error: state.error
+        error: state.error,
     }),
     dispatch => ({dispatch})
 )(UnconnectedContainer);
diff --git a/src/actions/api.js b/src/actions/api.js
index 8d8bf087..d6d12689 100644
--- a/src/actions/api.js
+++ b/src/actions/api.js
@@ -74,14 +74,16 @@ function apiThunk(endpoint, method, store, id, body, headers = {}) {
                 console.error(err);
                 /* eslint-enable no-console */
                 err.text().then(text => {
-                    dispatch(onError({
-                        type: 'backEnd',
-                        errorPage: text
-                    }));
+                    dispatch(
+                        onError({
+                            type: 'backEnd',
+                            errorPage: text,
+                        })
+                    );
                 });
             });
     };
-};
+}
 
 export function getLayout() {
     return apiThunk('_dash-layout', 'GET', 'layoutRequest');
diff --git a/src/actions/index.js b/src/actions/index.js
index 4de0b8a7..2efe5a50 100644
--- a/src/actions/index.js
+++ b/src/actions/index.js
@@ -44,7 +44,6 @@ export const setHooks = createAction(getAction('SET_HOOKS'));
 export const onError = createAction(getAction('ON_ERROR'));
 export const resolveError = createAction(getAction('RESOLVE_ERROR'));
 
-
 export function hydrateInitialOutputs() {
     return function(dispatch, getState) {
         triggerDefaultState(dispatch, getState);
@@ -142,28 +141,30 @@ export function undo() {
     };
 }
 
-
 export function revert() {
-    return function (dispatch, getState) {
+    return function(dispatch, getState) {
         const history = getState().history;
         dispatch(createAction('REVERT')());
         const previous = history.past[history.past.length - 1];
 
         // Update props
-        dispatch(createAction('UNDO_PROP_CHANGE')({
-            itempath: getState().paths[previous.id],
-            props: previous.props
-        }));
+        dispatch(
+            createAction('UNDO_PROP_CHANGE')({
+                itempath: getState().paths[previous.id],
+                props: previous.props,
+            })
+        );
 
         // Notify observers
-        dispatch(notifyObservers({
-            id: previous.id,
-            props: previous.props
-        }));
-    }
+        dispatch(
+            notifyObservers({
+                id: previous.id,
+                props: previous.props,
+            })
+        );
+    };
 }
 
-
 function reduceInputIds(nodeIds, InputGraph) {
     /*
      * Create input-output(s) pairs,
@@ -494,101 +495,101 @@ function updateOutput(
         },
         credentials: 'same-origin',
         body: JSON.stringify(payload),
-    }).then(function handleResponse(res) {
-
-        if (!res.ok) {
-            throw res;
-        }
+    })
+        .then(function handleResponse(res) {
+            if (!res.ok) {
+                throw res;
+            }
 
-        const getThisRequestIndex = () => {
-            const postRequestQueue = getState().requestQueue;
-            const thisRequestIndex = findIndex(
-                propEq('uid', requestUid),
-                postRequestQueue
-            );
-            return thisRequestIndex;
-        };
+            const getThisRequestIndex = () => {
+                const postRequestQueue = getState().requestQueue;
+                const thisRequestIndex = findIndex(
+                    propEq('uid', requestUid),
+                    postRequestQueue
+                );
+                return thisRequestIndex;
+            };
 
-        const updateRequestQueue = rejected => {
-            const postRequestQueue = getState().requestQueue;
-            const thisRequestIndex = getThisRequestIndex();
-            if (thisRequestIndex === -1) {
-                // It was already pruned away
-                return;
-            }
-            const updatedQueue = adjust(
-                merge(__, {
-                    status: res.status,
-                    responseTime: Date.now(),
-                    rejected,
-                }),
-                thisRequestIndex,
-                postRequestQueue
-            );
-            // We don't need to store any requests before this one
-            const thisControllerId =
-                postRequestQueue[thisRequestIndex].controllerId;
-            const prunedQueue = updatedQueue.filter((queueItem, index) => {
-                return (
-                    queueItem.controllerId !== thisControllerId ||
-                    index >= thisRequestIndex
+            const updateRequestQueue = rejected => {
+                const postRequestQueue = getState().requestQueue;
+                const thisRequestIndex = getThisRequestIndex();
+                if (thisRequestIndex === -1) {
+                    // It was already pruned away
+                    return;
+                }
+                const updatedQueue = adjust(
+                    merge(__, {
+                        status: res.status,
+                        responseTime: Date.now(),
+                        rejected,
+                    }),
+                    thisRequestIndex,
+                    postRequestQueue
                 );
-            });
+                // We don't need to store any requests before this one
+                const thisControllerId =
+                    postRequestQueue[thisRequestIndex].controllerId;
+                const prunedQueue = updatedQueue.filter((queueItem, index) => {
+                    return (
+                        queueItem.controllerId !== thisControllerId ||
+                        index >= thisRequestIndex
+                    );
+                });
 
-            dispatch(setRequestQueue(prunedQueue));
-        };
+                dispatch(setRequestQueue(prunedQueue));
+            };
 
-        const isRejected = () => {
-            const latestRequestIndex = findLastIndex(
-                propEq('controllerId', outputIdAndProp),
-                getState().requestQueue
-            );
-            /*
+            const isRejected = () => {
+                const latestRequestIndex = findLastIndex(
+                    propEq('controllerId', outputIdAndProp),
+                    getState().requestQueue
+                );
+                /*
              * Note that if the latest request is still `loading`
              * or even if the latest request failed,
              * we still reject this response in favor of waiting
              * for the latest request to finish.
              */
-            const rejected = latestRequestIndex > getThisRequestIndex();
-            return rejected;
-        };
+                const rejected = latestRequestIndex > getThisRequestIndex();
+                return rejected;
+            };
 
-        if (res.status !== STATUS.OK) {
-            // update the status of this request
-            updateRequestQueue(true);
-            return;
-        }
+            if (res.status !== STATUS.OK) {
+                // update the status of this request
+                updateRequestQueue(true);
+                return;
+            }
 
-        /*
+            /*
          * Check to see if another request has already come back
          * _after_ this one.
          * If so, ignore this request.
          */
-        if (isRejected()) {
-            updateRequestQueue(true);
-            return;
-        }
+            if (isRejected()) {
+                updateRequestQueue(true);
+                return;
+            }
 
-        res.json().then(function handleJson(data) {
-            /*
+            res.json().then(function handleJson(data) {
+                /*
              * Even if the `res` was received in the correct order,
              * the remainder of the response (res.json()) could happen
              * at different rates causing the parsed responses to
              * get out of order
              */
-            if (isRejected()) {
-                updateRequestQueue(true);
-                return;
-            }
+                if (isRejected()) {
+                    updateRequestQueue(true);
+                    return;
+                }
 
-            updateRequestQueue(false);
+                updateRequestQueue(false);
 
-            // Fire custom request_post hook if any
-            if (hooks.request_post !== null) {
-                hooks.request_post(payload, data.response);
-            }
+                // Fire custom request_post hook if any
+                if (hooks.request_post !== null) {
+                    hooks.request_post(payload, data.response);
+                }
 
-            /*
+                /*
              * it's possible that this output item is no longer visible.
              * for example, the could still be request running when
              * the user switched the chapter
@@ -597,92 +598,94 @@ function updateOutput(
              * to the store
              */
 
-            const multi = data.multi;
-
-            const handleResponse = ([outputIdAndProp, props]) => {
-                // Backward compatibility
-                const pathKey = multi ? outputIdAndProp : outputComponentId;
-                const observerUpdatePayload = {
-                    itempath: getState().paths[pathKey],
-                    props,
-                    source: 'response',
-                };
-                if (!observerUpdatePayload.itempath) {
-                    return;
-                }
-                dispatch(updateProps(observerUpdatePayload));
+                const multi = data.multi;
+
+                const handleResponse = ([outputIdAndProp, props]) => {
+                    // Backward compatibility
+                    const pathKey = multi ? outputIdAndProp : outputComponentId;
+                    const observerUpdatePayload = {
+                        itempath: getState().paths[pathKey],
+                        props,
+                        source: 'response',
+                    };
+                    if (!observerUpdatePayload.itempath) {
+                        return;
+                    }
+                    dispatch(updateProps(observerUpdatePayload));
 
-                dispatch(
-                    notifyObservers({
-                        id: pathKey,
-                        props: props,
-                    })
-                );
+                    dispatch(
+                        notifyObservers({
+                            id: pathKey,
+                            props: props,
+                        })
+                    );
 
-                /*
+                    /*
                  * If the response includes children, then we need to update our
                  * paths store.
                  * TODO - Do we need to wait for updateProps to finish?
                  */
-                if (has('children', observerUpdatePayload.props)) {
-                    dispatch(
-                        computePaths({
-                            subTree: observerUpdatePayload.props.children,
-                            startingPath: concat(getState().paths[pathKey], [
-                                'props',
-                                'children',
-                            ]),
-                        })
-                    );
+                    if (has('children', observerUpdatePayload.props)) {
+                        dispatch(
+                            computePaths({
+                                subTree: observerUpdatePayload.props.children,
+                                startingPath: concat(
+                                    getState().paths[pathKey],
+                                    ['props', 'children']
+                                ),
+                            })
+                        );
 
-                    /*
+                        /*
                     * if children contains objects with IDs, then we
                     * need to dispatch a propChange for all of these
                     * new children components
                     */
-                    if (
-                        contains(type(observerUpdatePayload.props.children), [
-                            'Array',
-                            'Object',
-                        ]) &&
-                        !isEmpty(observerUpdatePayload.props.children)
-                    ) {
-                        /*
+                        if (
+                            contains(
+                                type(observerUpdatePayload.props.children),
+                                ['Array', 'Object']
+                            ) &&
+                            !isEmpty(observerUpdatePayload.props.children)
+                        ) {
+                            /*
                          * TODO: We're just naively crawling
                          * the _entire_ layout to recompute the
                          * the dependency graphs.
                          * We don't need to do this - just need
                          * to compute the subtree
                          */
-                        const newProps = {};
-                        crawlLayout(
-                            observerUpdatePayload.props.children,
-                            function appendIds(child) {
-                                if (hasId(child)) {
-                                    keys(child.props).forEach(childProp => {
-                                        const componentIdAndProp = `${
-                                            child.props.id
-                                        }.${childProp}`;
-                                        if (
-                                            has(
-                                                componentIdAndProp,
-                                                InputGraph.nodes
-                                            )
-                                        ) {
-                                            newProps[componentIdAndProp] = {
-                                                id: child.props.id,
-                                                props: {
-                                                    [childProp]:
-                                                        child.props[childProp],
-                                                },
-                                            };
-                                        }
-                                    });
+                            const newProps = {};
+                            crawlLayout(
+                                observerUpdatePayload.props.children,
+                                function appendIds(child) {
+                                    if (hasId(child)) {
+                                        keys(child.props).forEach(childProp => {
+                                            const componentIdAndProp = `${
+                                                child.props.id
+                                            }.${childProp}`;
+                                            if (
+                                                has(
+                                                    componentIdAndProp,
+                                                    InputGraph.nodes
+                                                )
+                                            ) {
+                                                newProps[componentIdAndProp] = {
+                                                    id: child.props.id,
+                                                    props: {
+                                                        [childProp]:
+                                                            child.props[
+                                                                childProp
+                                                            ],
+                                                    },
+                                                };
+                                            }
+                                        });
+                                    }
                                 }
-                            }
-                        );
+                            );
 
-                        /*
+                            /*
                          * Organize props by shared outputs so that we
                          * only make one request per output component
                          * (even if there are multiple inputs).
@@ -692,7 +695,7 @@ function updateOutput(
                          * to make a single call, not 10 calls.
                          */
 
-                        /*
+                            /*
                          * In some cases, the new item will be an output
                          * with its inputs already rendered (not rendered)
                          * as part of this update.
@@ -708,88 +711,91 @@ function updateOutput(
                          * special case (no input changed?)
                          */
 
-                        const outputIds = [];
-                        keys(newProps).forEach(idAndProp => {
-                            if (
-                                // It's an output
-                                InputGraph.dependenciesOf(idAndProp).length ===
-                                    0 &&
-                                /*
+                            const outputIds = [];
+                            keys(newProps).forEach(idAndProp => {
+                                if (
+                                    // It's an output
+                                    InputGraph.dependenciesOf(idAndProp)
+                                        .length === 0 &&
+                                    /*
                                  * And none of its inputs are generated in this
                                  * request
                                  */
-                                intersection(
-                                    InputGraph.dependantsOf(idAndProp),
-                                    keys(newProps)
-                                ).length === 0
-                            ) {
-                                outputIds.push(idAndProp);
-                                delete newProps[idAndProp];
-                            }
-                        });
-
-                        // Dispatch updates to inputs
-                        const reducedNodeIds = reduceInputIds(
-                            keys(newProps),
-                            InputGraph
-                        );
-                        const depOrder = InputGraph.overallOrder();
-                        const sortedNewProps = sort(
-                            (a, b) =>
-                                depOrder.indexOf(a.input) -
-                                depOrder.indexOf(b.input),
-                            reducedNodeIds
-                        );
-                        sortedNewProps.forEach(function(inputOutput) {
-                            const payload = newProps[inputOutput.input];
-                            payload.excludedOutputs =
-                                inputOutput.excludedOutputs;
-                            dispatch(notifyObservers(payload));
-                        });
-
-                        // Dispatch updates to lone outputs
-                        outputIds.forEach(idAndProp => {
-                            const requestUid = uid();
-                            dispatch(
-                                setRequestQueue(
-                                    append(
-                                        {
-                                            // TODO - Are there any implications of doing this??
-                                            controllerId: null,
-                                            status: 'loading',
-                                            uid: requestUid,
-                                            requestTime: Date.now(),
-                                        },
-                                        getState().requestQueue
-                                    )
-                                )
-                            );
-                            updateOutput(
-                                idAndProp,
+                                    intersection(
+                                        InputGraph.dependantsOf(idAndProp),
+                                        keys(newProps)
+                                    ).length === 0
+                                ) {
+                                    outputIds.push(idAndProp);
+                                    delete newProps[idAndProp];
+                                }
+                            });
 
-                                getState,
-                                requestUid,
-                                dispatch,
-                                changedPropIds
+                            // Dispatch updates to inputs
+                            const reducedNodeIds = reduceInputIds(
+                                keys(newProps),
+                                InputGraph
+                            );
+                            const depOrder = InputGraph.overallOrder();
+                            const sortedNewProps = sort(
+                                (a, b) =>
+                                    depOrder.indexOf(a.input) -
+                                    depOrder.indexOf(b.input),
+                                reducedNodeIds
                             );
-                        });
+                            sortedNewProps.forEach(function(inputOutput) {
+                                const payload = newProps[inputOutput.input];
+                                payload.excludedOutputs =
+                                    inputOutput.excludedOutputs;
+                                dispatch(notifyObservers(payload));
+                            });
+
+                            // Dispatch updates to lone outputs
+                            outputIds.forEach(idAndProp => {
+                                const requestUid = uid();
+                                dispatch(
+                                    setRequestQueue(
+                                        append(
+                                            {
+                                                // TODO - Are there any implications of doing this??
+                                                controllerId: null,
+                                                status: 'loading',
+                                                uid: requestUid,
+                                                requestTime: Date.now(),
+                                            },
+                                            getState().requestQueue
+                                        )
+                                    )
+                                );
+                                updateOutput(
+                                    idAndProp,
+
+                                    getState,
+                                    requestUid,
+                                    dispatch,
+                                    changedPropIds
+                                );
+                            });
+                        }
                     }
+                };
+                if (multi) {
+                    Object.entries(data.response).forEach(handleResponse);
+                } else {
+                    handleResponse([outputIdAndProp, data.response.props]);
                 }
-            };
-            if (multi) {
-                Object.entries(data.response).forEach(handleResponse);
-            } else {
-                handleResponse([outputIdAndProp, data.response.props]);
-            }
+            });
+        })
+        .catch(err => {
+            err.text().then(text => {
+                dispatch(
+                    onError({
+                        type: 'backEnd',
+                        errorPage: text,
+                    })
+                );
+            });
         });
-    }).catch(err => {
-      err.text().then(text => {
-        dispatch(onError({
-          type: 'backEnd',
-          errorPage: text
-        }))
-      });
-    });
 }
 
 export function serialize(state) {
diff --git a/src/components/error/ComponentDisabledOverlay.react.js b/src/components/error/ComponentDisabledOverlay.react.js
index 091f320b..93d3bb67 100644
--- a/src/components/error/ComponentDisabledOverlay.react.js
+++ b/src/components/error/ComponentDisabledOverlay.react.js
@@ -2,35 +2,32 @@ import React from 'react';
 import PropTypes from 'prop-types';
 
 const styles = {
-  root: {
-    position: 'relative'
-  },
-  overlay: {
-    position: 'relative',
-    padding: '2px',
-    display: 'inline-block'
-  },
-  childWrapper: {
-    position: 'relative',
-    zIndex: -1
-  }
-}
+    root: {
+        position: 'relative',
+    },
+    overlay: {
+        position: 'relative',
+        padding: '2px',
+        display: 'inline-block',
+    },
+    childWrapper: {
+        position: 'relative',
+        zIndex: -1,
+    },
+};
 
-function ComponentDisabledOverlay({ children }) {
-  return (
-    <div style={styles.root}>
-      <div
-        style={styles.overlay}>
-        <div style={styles.childWrapper}>
-          {children}
+function ComponentDisabledOverlay({children}) {
+    return (
+        <div style={styles.root}>
+            <div style={styles.overlay}>
+                <div style={styles.childWrapper}>{children}</div>
+            </div>
         </div>
-      </div>
-    </div>
-  )
+    );
 }
 
 ComponentDisabledOverlay.propTypes = {
     children: PropTypes.object,
-}
+};
 
 export default ComponentDisabledOverlay;
diff --git a/src/components/error/ComponentErrorBoundary.react.js b/src/components/error/ComponentErrorBoundary.react.js
index 9fbd0abc..2bdd6681 100644
--- a/src/components/error/ComponentErrorBoundary.react.js
+++ b/src/components/error/ComponentErrorBoundary.react.js
@@ -1,125 +1,126 @@
 import {connect} from 'react-redux';
-import React, { Component } from 'react';
+import React, {Component} from 'react';
 import PropTypes from 'prop-types';
 import Radium from 'radium';
 import * as R from 'ramda';
 import uniqid from 'uniqid';
-import { onError, resolveError, revert } from '../../actions';
+import {onError, resolveError, revert} from '../../actions';
 import ComponentErrorOverlay from './ComponentErrorOverlay.react';
 import ComponentDisabledOverlay from './ComponentDisabledOverlay.react';
 
 class UnconnectedComponentErrorBoundary extends Component {
-  constructor(props) {
-    super(props);
-    this.state = {
-      myID: props.componentId,
-      myUID: uniqid(),
-      oldChildren: (<div>No Initial State</div>)
-    };
-  }
+    constructor(props) {
+        super(props);
+        this.state = {
+            myID: props.componentId,
+            myUID: uniqid(),
+            oldChildren: <div>No Initial State</div>,
+        };
+    }
 
-  componentDidCatch(error, info) {
-    const { dispatch } = this.props;
-    dispatch(onError({
-      myUID: this.state.myUID,
-      myID: this.state.myID,
-      type: 'frontEnd',
-      error,
-      info
-    }));
-    dispatch(revert);
-  }
+    componentDidCatch(error, info) {
+        const {dispatch} = this.props;
+        dispatch(
+            onError({
+                myUID: this.state.myUID,
+                myID: this.state.myID,
+                type: 'frontEnd',
+                error,
+                info,
+            })
+        );
+        dispatch(revert);
+    }
 
-  /* eslint-disable react/no-did-update-set-state */
-  componentDidUpdate(prevProps, prevState) {
-    const { error } = this.props;
-    const { myUID } = this.state;
-    const hasError = R.contains(myUID, R.pluck('myUID')(error.frontEnd));
-    if (!hasError &&
-        prevState.oldChildren !== prevProps.children &&
-        prevProps.children !== this.props.children) {
-      this.setState({
-        oldChildren: prevProps.children
-      });
+    /* eslint-disable react/no-did-update-set-state */
+    componentDidUpdate(prevProps, prevState) {
+        const {error} = this.props;
+        const {myUID} = this.state;
+        const hasError = R.contains(myUID, R.pluck('myUID')(error.frontEnd));
+        if (
+            !hasError &&
+            prevState.oldChildren !== prevProps.children &&
+            prevProps.children !== this.props.children
+        ) {
+            this.setState({
+                oldChildren: prevProps.children,
+            });
+        }
     }
-  }
-  /* eslint-enable react/no-did-update-set-state */
+    /* eslint-enable react/no-did-update-set-state */
 
-  getDisabledComponents(disabledIds, incomingMap) {
-    const possibleKeys = R.keys(incomingMap);
-    const enumeratedPossibleIds = R.zip(
-      R.range(0, R.length(possibleKeys)),
-      R.map((k) => k.split('.')[0], possibleKeys)
-    )
-    const affectedIndices = R.filter(
-      (idx) => !R.isNil(idx),
-      R.map(
-        (tuple) => R.contains(tuple[1], disabledIds) ? tuple[0] : null,
-        enumeratedPossibleIds
-      )
-    );
-    const affectedKeys = R.ap(
-      R.map(
-        R.nth,
-        affectedIndices
-      ),
-      R.of(possibleKeys)
-    );
-    const disabledKeys = R.flatten(R.map((key) => incomingMap[key],
-                                   affectedKeys));
-    const newDisabledIds = R.union(
-      disabledIds,
-      R.map((k) => k.split('.')[0], disabledKeys)
-    );
-    if (R.equals(disabledIds, newDisabledIds)) {
-      return disabledIds;
-    } 
-      return this.getDisabledComponents(newDisabledIds, incomingMap);
-    
-  }
+    getDisabledComponents(disabledIds, incomingMap) {
+        const possibleKeys = R.keys(incomingMap);
+        const enumeratedPossibleIds = R.zip(
+            R.range(0, R.length(possibleKeys)),
+            R.map(k => k.split('.')[0], possibleKeys)
+        );
+        const affectedIndices = R.filter(
+            idx => !R.isNil(idx),
+            R.map(
+                tuple => (R.contains(tuple[1], disabledIds) ? tuple[0] : null),
+                enumeratedPossibleIds
+            )
+        );
+        const affectedKeys = R.ap(
+            R.map(R.nth, affectedIndices),
+            R.of(possibleKeys)
+        );
+        const disabledKeys = R.flatten(
+            R.map(key => incomingMap[key], affectedKeys)
+        );
+        const newDisabledIds = R.union(
+            disabledIds,
+            R.map(k => k.split('.')[0], disabledKeys)
+        );
+        if (R.equals(disabledIds, newDisabledIds)) {
+            return disabledIds;
+        }
+        return this.getDisabledComponents(newDisabledIds, incomingMap);
+    }
 
-  resolveError(dispatch, myUID) {
-    dispatch(resolveError({type: 'frontEnd', myUID}))
-  }
+    resolveError(dispatch, myUID) {
+        dispatch(resolveError({type: 'frontEnd', myUID}));
+    }
 
-  render() {
-    const {
-      componentType,
-      componentId,
-      dispatch,
-      error,
-      graphs
-    } = this.props;
-    const { myUID } = this.state;
-    const hasError = R.contains(myUID, R.pluck('myUID')(error.frontEnd));
-    const disabledComponents = this.getDisabledComponents(
-      R.pluck('myID')(error.frontEnd),
-      graphs.InputGraph.incomingEdges
-    )
-    const disabled = R.contains(componentId, disabledComponents);
-    if ( hasError ) {
-      const errorToDisplay = R.find(
-        R.propEq('myUID', myUID)
-      )(error.frontEnd).error;
-      return (
-        <ComponentErrorOverlay
-          error={errorToDisplay}
-          componentId={componentId}
-          componentType={componentType}
-          resolve={() => this.resolveError(dispatch, myUID)}
-        >
-          {this.state.oldChildren}
-        </ComponentErrorOverlay>
-      )
-    } else if ( disabled ) {
-      return (
-        <ComponentDisabledOverlay>
-          {this.props.children}
-        </ComponentDisabledOverlay>
-      )
+    render() {
+        const {
+            componentType,
+            componentId,
+            dispatch,
+            error,
+            graphs,
+        } = this.props;
+        const {myUID} = this.state;
+        const hasError = R.contains(myUID, R.pluck('myUID')(error.frontEnd));
+        const disabledComponents = this.getDisabledComponents(
+            R.pluck('myID')(error.frontEnd),
+            graphs.InputGraph.incomingEdges
+        );
+        const disabled = R.contains(componentId, disabledComponents);
+        if (hasError) {
+            const errorToDisplay = R.find(R.propEq('myUID', myUID))(
+                error.frontEnd
+            ).error;
+            return (
+                <ComponentErrorOverlay
+                    error={errorToDisplay}
+                    componentId={componentId}
+                    componentType={componentType}
+                    resolve={() => this.resolveError(dispatch, myUID)}
+                >
+                    {this.state.oldChildren}
+                </ComponentErrorOverlay>
+            );
+        } else if (disabled) {
+            return (
+                <ComponentDisabledOverlay>
+                    {this.props.children}
+                </ComponentDisabledOverlay>
+            );
+        }
+        return this.props.children;
     }
-    return this.props.children;
-  }
 }
 
 UnconnectedComponentErrorBoundary.propTypes = {
@@ -128,13 +129,13 @@ UnconnectedComponentErrorBoundary.propTypes = {
     componentType: PropTypes.string,
     dispatch: PropTypes.func,
     error: PropTypes.object,
-    graphs: PropTypes.object
-}
+    graphs: PropTypes.object,
+};
 
 const ComponentErrorBoundary = connect(
     state => ({
-      error: state.error,
-      graphs: state.graphs
+        error: state.error,
+        graphs: state.graphs,
     }),
     dispatch => ({dispatch})
 )(Radium(UnconnectedComponentErrorBoundary));
diff --git a/src/components/error/ComponentErrorOverlay.react.js b/src/components/error/ComponentErrorOverlay.react.js
index 5a679559..d061a05d 100644
--- a/src/components/error/ComponentErrorOverlay.react.js
+++ b/src/components/error/ComponentErrorOverlay.react.js
@@ -4,19 +4,11 @@ import './ComponentErrorOverlay.css';
 
 export default class ComponentErrorOverlay extends Component {
     render() {
-        const {
-            componentId,
-            componentType,
-        } = this.props;
-        const errorLocationString =
-            `Error in <${componentType} id="${componentId}">`;
+        const {componentId, componentType} = this.props;
+        const errorLocationString = `Error in <${componentType} id="${componentId}">`;
 
         return (
-            <div
-                className={'dash-error-overlay'}
-            >
-                {errorLocationString}
-            </div>
+            <div className={'dash-error-overlay'}>{errorLocationString}</div>
         );
     }
 }
diff --git a/src/components/error/FrontEnd/FrontEndError.react.js b/src/components/error/FrontEnd/FrontEndError.react.js
index 73309e3f..e868e65c 100644
--- a/src/components/error/FrontEnd/FrontEndError.react.js
+++ b/src/components/error/FrontEnd/FrontEndError.react.js
@@ -35,9 +35,7 @@ class FrontEndError extends Component {
         }
         return collapsed ? (
             <div className="dash-error-card__list-item">
-                <ErrorIcon
-                    className="dash-fe-error__icon-error"
-                />
+                <ErrorIcon className="dash-fe-error__icon-error" />
                 <h6 className="dash-fe-error__title">
                     {e.error.message ||
                         'An error was thrown that was not an Error object, so info could not be gathered.'}
@@ -50,17 +48,19 @@ class FrontEndError extends Component {
         ) : (
             <div className={cardClasses}>
                 <div className="dash-fe-error-top">
-                    <ErrorIcon
-                        className="dash-fe-error__icon-error"
-                    />
+                    <ErrorIcon className="dash-fe-error__icon-error" />
                     <h6 className="dash-fe-error__title">
                         {e.error.message ||
                             'An error was thrown that was not an Error object, so info could not be gathered.'}
                     </h6>
-                    {this.props.isListItem ? <CollapseIcon
-                        className="dash-fe-error__collapse dash-fe-error__collapse--flipped"
-                        onClick={() => this.setState({collapsed: true})}
-                    /> : closeButton}
+                    {this.props.isListItem ? (
+                        <CollapseIcon
+                            className="dash-fe-error__collapse dash-fe-error__collapse--flipped"
+                            onClick={() => this.setState({collapsed: true})}
+                        />
+                    ) : (
+                        closeButton
+                    )}
                 </div>
                 <div className="dash-fe-error__st">
                     {e.error.stack &&
diff --git a/src/components/error/GlobalErrorContainer.react.js b/src/components/error/GlobalErrorContainer.react.js
index f89de7b2..a13b1584 100644
--- a/src/components/error/GlobalErrorContainer.react.js
+++ b/src/components/error/GlobalErrorContainer.react.js
@@ -38,9 +38,7 @@ class UnconnectedGlobalErrorContainer extends Component {
                     dispatch={dispatch}
                     resolveError={this.resolveError}
                 >
-                    <div id='_dash-app-content'>
-                        {this.props.children}
-                    </div>
+                    <div id="_dash-app-content">{this.props.children}</div>
                 </DebugMenu>
             </div>
         );
diff --git a/src/components/error/menu/DebugAlertContainer.react.js b/src/components/error/menu/DebugAlertContainer.react.js
index 5fa7e21b..93fb0087 100644
--- a/src/components/error/menu/DebugAlertContainer.react.js
+++ b/src/components/error/menu/DebugAlertContainer.react.js
@@ -29,9 +29,7 @@ class DebugAlertContainer extends Component {
                 </div>
                 <div className="dash-debug-alert">
                     {alertsOpened ? (
-                        <WarningIconWhite
-                            className="dash-debug-alert-container__icon dash-debug-alert-container__icon--warning"
-                        />
+                        <WarningIconWhite className="dash-debug-alert-container__icon dash-debug-alert-container__icon--warning" />
                     ) : (
                         <WarningIcon className="dash-debug-alert-container__icon dash-debug-alert-container__icon--warning" />
                     )}
diff --git a/src/reducers/error.js b/src/reducers/error.js
index 5eaac225..e3e63f45 100644
--- a/src/reducers/error.js
+++ b/src/reducers/error.js
@@ -1,53 +1,49 @@
-import { findIndex, propEq, remove } from 'ramda';
+import {findIndex, propEq, remove} from 'ramda';
 
 const initialError = {
-  frontEnd: [],
-  backEnd: {}
+    frontEnd: [],
+    backEnd: {},
 };
 
-function error (state = initialError, action) {
+function error(state = initialError, action) {
     switch (action.type) {
-
         case 'ON_ERROR': {
-          if (action.payload.type === 'frontEnd') {
-            return {
-                frontEnd: [...state.frontEnd, action.payload],
-                backEnd: state.backEnd
-            };
-          } else if (action.payload.type === 'backEnd') {
-            return {
-                frontEnd: state.frontEnd,
-                backEnd: action.payload
-            };
-          } 
-          return state;
-          
+            if (action.payload.type === 'frontEnd') {
+                return {
+                    frontEnd: [...state.frontEnd, action.payload],
+                    backEnd: state.backEnd,
+                };
+            } else if (action.payload.type === 'backEnd') {
+                return {
+                    frontEnd: state.frontEnd,
+                    backEnd: action.payload,
+                };
+            }
+            return state;
         }
 
         case 'RESOLVE_ERROR': {
-          if (action.payload.type === 'frontEnd') {
-            const removeIdx = findIndex(
-              propEq('myUID', action.payload.myUID)
-            )(state.frontEnd)
-            return {
-                frontEnd: remove(removeIdx, 1, state.frontEnd),
-                backEnd: state.backEnd
-            };
-          } else if (action.payload.type === 'backEnd') {
-            return {
-                frontEnd: state.frontEnd,
-                backEnd: {}
-            };
-          } 
-          return state;
-          
+            if (action.payload.type === 'frontEnd') {
+                const removeIdx = findIndex(
+                    propEq('myUID', action.payload.myUID)
+                )(state.frontEnd);
+                return {
+                    frontEnd: remove(removeIdx, 1, state.frontEnd),
+                    backEnd: state.backEnd,
+                };
+            } else if (action.payload.type === 'backEnd') {
+                return {
+                    frontEnd: state.frontEnd,
+                    backEnd: {},
+                };
+            }
+            return state;
         }
 
         default: {
             return state;
         }
-
     }
 }
 
-export default error;
\ No newline at end of file
+export default error;
diff --git a/src/reducers/history.js b/src/reducers/history.js
index d345c7af..091cfb32 100644
--- a/src/reducers/history.js
+++ b/src/reducers/history.js
@@ -35,7 +35,7 @@ function history(state = initialHistory, action) {
             return {
                 past: newPast,
                 present: previous,
-                future: [ ...future ]
+                future: [...future],
             };
         }
 
diff --git a/src/reducers/reducer.js b/src/reducers/reducer.js
index 9e61c9fb..f82564e8 100644
--- a/src/reducers/reducer.js
+++ b/src/reducers/reducer.js
@@ -81,10 +81,7 @@ function recordHistory(reducer) {
             );
             if (historyEntry && !R.isEmpty(historyEntry.props)) {
                 nextState.history = {
-                    past: [
-                        ...nextState.history.past, 
-                        state.history.present
-                    ],
+                    past: [...nextState.history.past, state.history.present],
                     present: historyEntry,
                     future: [],
                 };

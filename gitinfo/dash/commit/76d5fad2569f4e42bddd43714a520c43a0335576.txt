commit 76d5fad2569f4e42bddd43714a520c43a0335576
Author: alexcjohnson <alex@plot.ly>
Date:   Fri Oct 11 18:33:18 2019 -0400

    cleanup: break out validation, clean up usage
    - new _validate.py to centralize error checking
    - dash exceptions auto-dedent
    - clean up usage and cruft

diff --git a/dash/__init__.py b/dash/__init__.py
index ead91983..647c457e 100644
--- a/dash/__init__.py
+++ b/dash/__init__.py
@@ -4,6 +4,4 @@ from . import development  # noqa: F401
 from . import exceptions  # noqa: F401
 from . import resources  # noqa: F401
 from .version import __version__  # noqa: F401
-from ._callback_context import CallbackContext as _CallbackContext
-
-callback_context = _CallbackContext()
+from ._callback_context import callback_context  # noqa: F401
diff --git a/dash/_callback_context.py b/dash/_callback_context.py
index 04284cc6..231c19b3 100644
--- a/dash/_callback_context.py
+++ b/dash/_callback_context.py
@@ -39,3 +39,6 @@ class CallbackContext:
     @has_context
     def response(self):
         return getattr(flask.g, 'dash_response')
+
+
+callback_context = CallbackContext()
diff --git a/dash/_utils.py b/dash/_utils.py
index 6b0b36a6..f7952af3 100644
--- a/dash/_utils.py
+++ b/dash/_utils.py
@@ -7,7 +7,7 @@ import hashlib
 import collections
 import subprocess
 import logging
-from io import open  # pylint: disable=redefined-builtin
+import io
 from functools import wraps
 import future.utils as utils
 from . import exceptions
@@ -186,7 +186,7 @@ def run_command_with_process(cmd):
 
 
 def compute_md5(path):
-    with open(path, encoding="utf-8") as fp:
+    with io.open(path, encoding="utf-8") as fp:
         return hashlib.md5(fp.read().encode("utf-8")).hexdigest()
 
 
diff --git a/dash/_validate.py b/dash/_validate.py
new file mode 100644
index 00000000..f6d35607
--- /dev/null
+++ b/dash/_validate.py
@@ -0,0 +1,431 @@
+import collections
+from itertools import chain
+import pprint
+import re
+
+from .development.base_component import Component
+from .dependencies import Input, Output, State
+from . import exceptions
+from ._utils import create_callback_id, patch_collections_abc
+
+# py2/3 json.dumps-compatible strings - these are equivalent in py3, not in py2
+_strings = (type(u""), type(""))
+
+
+def validate_callback(app, layout, output, inputs, state):
+    is_multi = isinstance(output, (list, tuple))
+    validate_ids = not app.config.suppress_callback_exceptions
+
+    if layout is None and validate_ids:
+        # Without a layout, we can't do validation on the IDs and
+        # properties of the elements in the callback.
+        raise exceptions.LayoutIsNotDefined(
+            """
+            Attempting to assign a callback to the application but
+            the `layout` property has not been assigned.
+            Assign the `layout` property before assigning callbacks.
+            Alternatively, suppress this warning by setting
+            `suppress_callback_exceptions=True`
+            """
+        )
+
+    outputs = output if is_multi else [output]
+    for args, cls in [(outputs, Output), (inputs, Input), (state, State)]:
+        validate_callback_args(args, cls, layout, validate_ids)
+
+    if state and not inputs:
+        raise exceptions.MissingInputsException(
+            """
+            This callback has {} `State` element{} but no `Input` elements.
+
+            Without `Input` elements, this callback will never get called.
+
+            (Subscribing to Input components will cause the
+            callback to be called whenever their values change.)
+            """.format(
+                len(state), "s" if len(state) > 1 else ""
+            )
+        )
+
+    for i in inputs:
+        bad = None
+        if is_multi:
+            for o in output:
+                if o == i:
+                    bad = o
+        else:
+            if output == i:
+                bad = output
+        if bad:
+            raise exceptions.SameInputOutputException(
+                "Same output and input: {}".format(bad)
+            )
+
+    if is_multi:
+        if len(set(output)) != len(output):
+            raise exceptions.DuplicateCallbackOutput(
+                "Same output was used more than once in a "
+                "multi output callback!\nDuplicates:\n{}".format(
+                    ",\n".join(str(x) for x in output if output.count(x) > 1)
+                )
+            )
+
+    callback_id = create_callback_id(output)
+
+    callbacks = set(
+        chain(
+            *(
+                x[2:-2].split("...") if x.startswith("..") else [x]
+                for x in app.callback_map
+            )
+        )
+    )
+
+    if is_multi:
+        dups = callbacks.intersection(str(y) for y in output)
+        if dups:
+            raise exceptions.DuplicateCallbackOutput(
+                """
+                Multi output {} contains an `Output` object
+                that was already assigned.
+                Duplicates:
+                {}
+                """.format(
+                    callback_id, pprint.pformat(dups)
+                )
+            )
+    else:
+        if callback_id in callbacks:
+            raise exceptions.DuplicateCallbackOutput(
+                """
+                You have already assigned a callback to the output
+                with ID "{}" and property "{}". An output can only have
+                a single callback function. Try combining your inputs and
+                callback functions together into one function.
+                """.format(
+                    output.component_id, output.component_property
+                )
+            )
+
+
+def validate_callback_args(args, cls, layout, validate_ids):
+    name = cls.__name__
+    if not isinstance(args, (list, tuple)):
+        raise exceptions.IncorrectTypeException(
+            """
+            The {} argument `{}` must be a list or tuple of
+            `dash.dependencies.{}`s.
+            """.format(
+                name.lower(), str(args), name
+            )
+        )
+
+    for arg in args:
+        if not isinstance(arg, cls):
+            raise exceptions.IncorrectTypeException(
+                """
+                The {} argument `{}` must be of type `dash.dependencies.{}`.
+                """.format(
+                    name.lower(), str(arg), name
+                )
+            )
+
+        if not isinstance(arg.component_id, _strings):
+            raise exceptions.IncorrectTypeException(
+                """
+                component_id must be a string or dict, found {!r}
+                """.format(
+                    arg.component_id
+                )
+            )
+
+        if not isinstance(arg.component_property, _strings):
+            raise exceptions.IncorrectTypeException(
+                """
+                component_property must be a string, found {!r}
+                """.format(
+                    arg.component_property
+                )
+            )
+
+        invalid_characters = ["."]
+        if any(x in arg.component_id for x in invalid_characters):
+            raise exceptions.InvalidComponentIdError(
+                """
+                The element `{}` contains {} in its ID.
+                Periods are not allowed in IDs.
+                """.format(
+                    arg.component_id, invalid_characters
+                )
+            )
+
+        if validate_ids:
+            top_id = getattr(layout, "id", None)
+            arg_id = arg.component_id
+            arg_prop = getattr(arg, "component_property", None)
+            if arg_id not in layout and arg_id != top_id:
+                raise exceptions.NonExistentIdException(
+                    """
+                    Attempting to assign a callback to the component with
+                    id "{}" but no components with that id exist in the layout.
+
+                    Here is a list of IDs in layout:
+                    {}
+
+                    If you are assigning callbacks to components that are
+                    generated by other callbacks (and therefore not in the
+                    initial layout), you can suppress this exception by setting
+                    `suppress_callback_exceptions=True`.
+                    """.format(
+                        arg_id, [k for k in layout] + ([top_id] if top_id else [])
+                    )
+                )
+
+            component = layout if top_id == arg_id else layout[arg_id]
+
+            if (
+                arg_prop
+                and arg_prop not in component.available_properties
+                and not any(
+                    arg_prop.startswith(w)
+                    for w in component.available_wildcard_properties
+                )
+            ):
+                raise exceptions.NonExistentPropException(
+                    """
+                    Attempting to assign a callback with the property "{0}"
+                    but component "{1}" doesn't have "{0}" as a property.
+
+                    Here are the available properties in "{1}":
+                    {2}
+                    """.format(
+                        arg_prop, arg_id, component.available_properties
+                    )
+                )
+
+            if hasattr(arg, "component_event"):
+                raise exceptions.NonExistentEventException(
+                    """
+                    Events have been removed.
+                    Use the associated property instead.
+                    """
+                )
+
+
+def validate_multi_return(output, output_value, callback_id):
+    if not isinstance(output_value, (list, tuple)):
+        raise exceptions.InvalidCallbackReturnValue(
+            """
+            The callback {} is a multi-output.
+            Expected the output type to be a list or tuple but got:
+            {}.
+            """.format(
+                callback_id, repr(output_value)
+            )
+        )
+
+    if not len(output_value) == len(output):
+        raise exceptions.InvalidCallbackReturnValue(
+            """
+            Invalid number of output values for {}.
+            Expected {}, got {}
+            """.format(
+                callback_id, len(output), len(output_value)
+            )
+        )
+
+
+def fail_callback_output(output_value, output):
+    valid = _strings + (dict, int, float, type(None), Component)
+
+    def _raise_invalid(bad_val, outer_val, path, index=None, toplevel=False):
+        bad_type = type(bad_val).__name__
+        outer_id = (
+            "(id={:s})".format(outer_val.id) if getattr(outer_val, "id", False) else ""
+        )
+        outer_type = type(outer_val).__name__
+        if toplevel:
+            location = """
+            The value in question is either the only value returned,
+            or is in the top level of the returned list,
+            """
+        else:
+            index_string = "[*]" if index is None else "[{:d}]".format(index)
+            location = """
+            The value in question is located at
+            {} {} {}
+            {},
+            """.format(
+                index_string, outer_type, outer_id, path
+            )
+
+        raise exceptions.InvalidCallbackReturnValue(
+            """
+            The callback for `{output}`
+            returned a {object:s} having type `{type}`
+            which is not JSON serializable.
+
+            {location}
+            and has string representation
+            `{bad_val}`
+
+            In general, Dash properties can only be
+            dash components, strings, dictionaries, numbers, None,
+            or lists of those.
+            """.format(
+                output=repr(output),
+                object="tree with one value" if not toplevel else "value",
+                type=bad_type,
+                location=location,
+                bad_val=bad_val,
+            )
+        )
+
+    def _value_is_valid(val):
+        return isinstance(val, valid)
+
+    def _validate_value(val, index=None):
+        # val is a Component
+        if isinstance(val, Component):
+            # pylint: disable=protected-access
+            for p, j in val._traverse_with_paths():
+                # check each component value in the tree
+                if not _value_is_valid(j):
+                    _raise_invalid(bad_val=j, outer_val=val, path=p, index=index)
+
+                # Children that are not of type Component or
+                # list/tuple not returned by traverse
+                child = getattr(j, "children", None)
+                if not isinstance(child, (tuple, collections.MutableSequence)):
+                    if child and not _value_is_valid(child):
+                        _raise_invalid(
+                            bad_val=child,
+                            outer_val=val,
+                            path=p + "\n" + "[*] " + type(child).__name__,
+                            index=index,
+                        )
+
+            # Also check the child of val, as it will not be returned
+            child = getattr(val, "children", None)
+            if not isinstance(child, (tuple, collections.MutableSequence)):
+                if child and not _value_is_valid(child):
+                    _raise_invalid(
+                        bad_val=child,
+                        outer_val=val,
+                        path=type(child).__name__,
+                        index=index,
+                    )
+
+        # val is not a Component, but is at the top level of tree
+        elif not _value_is_valid(val):
+            _raise_invalid(
+                bad_val=val,
+                outer_val=type(val).__name__,
+                path="",
+                index=index,
+                toplevel=True,
+            )
+
+    if isinstance(output_value, list):
+        for i, val in enumerate(output_value):
+            _validate_value(val, index=i)
+    else:
+        _validate_value(output_value)
+
+    # if we got this far, raise a generic JSON error
+    raise exceptions.InvalidCallbackReturnValue(
+        """
+        The callback for property `{property:s}` of component `{id:s}`
+        returned a value which is not JSON serializable.
+
+        In general, Dash properties can only be dash components, strings,
+        dictionaries, numbers, None, or lists of those.
+        """.format(
+            property=output.component_property, id=output.component_id
+        )
+    )
+
+
+def check_obsolete(kwargs):
+    for key in kwargs:
+        if key in ["components_cache_max_age", "static_folder"]:
+            raise exceptions.ObsoleteKwargException(
+                """
+                {} is no longer a valid keyword argument in Dash since v1.0.
+                See https://dash.plot.ly for details.
+                """.format(
+                    key
+                )
+            )
+        # any other kwarg mimic the built-in exception
+        raise TypeError("Dash() got an unexpected keyword argument '" + key + "'")
+
+
+def validate_js_path(registered_paths, package_name, path_in_package_dist):
+    if package_name not in registered_paths:
+        raise exceptions.DependencyException(
+            """
+            Error loading dependency. "{}" is not a registered library.
+            Registered libraries are:
+            {}
+            """.format(
+                package_name, list(registered_paths.keys())
+            )
+        )
+
+    if path_in_package_dist not in registered_paths[package_name]:
+        raise exceptions.DependencyException(
+            """
+            "{}" is registered but the path requested is not valid.
+            The path requested: "{}"
+            List of registered paths: {}
+            """.format(
+                package_name, path_in_package_dist, registered_paths
+            )
+        )
+
+
+def validate_index(name, checks, index):
+    missing = [i for check, i in checks if not re.compile(check).search(index)]
+    if missing:
+        plural = "s" if len(missing) > 1 else ""
+        raise exceptions.InvalidIndexException(
+            "Missing item{pl} {items} in {name}.".format(
+                items=", ".join(missing), pl=plural, name=name
+            )
+        )
+
+
+def validate_layout_type(value):
+    if not isinstance(value, (Component, patch_collections_abc("Callable"))):
+        raise exceptions.NoLayoutException(
+            "Layout must be a dash component "
+            "or a function that returns a dash component."
+        )
+
+
+def validate_layout(layout, layout_value):
+    if layout is None:
+        raise exceptions.NoLayoutException(
+            """
+            The layout was `None` at the time that `run_server` was called.
+            Make sure to set the `layout` attribute of your application
+            before running the server.
+            """
+        )
+
+    layout_id = getattr(layout_value, "id", None)
+
+    component_ids = {layout_id} if layout_id else set()
+    # pylint: disable=protected-access
+    for component in layout_value._traverse():
+        component_id = getattr(component, "id", None)
+        if component_id and component_id in component_ids:
+            raise exceptions.DuplicateIdError(
+                """
+                Duplicate component id found in the initial layout: `{}`
+                """.format(
+                    component_id
+                )
+            )
+        component_ids.add(component_id)
diff --git a/dash/dash.py b/dash/dash.py
index 679ed0ee..257f3e3a 100644
--- a/dash/dash.py
+++ b/dash/dash.py
@@ -11,10 +11,8 @@ import pkgutil
 import threading
 import re
 import logging
-import pprint
 
 from functools import wraps
-from textwrap import dedent
 
 import flask
 from flask_compress import Compress
@@ -23,23 +21,25 @@ from werkzeug.debug.tbtools import get_current_traceback
 import plotly
 import dash_renderer
 
-from .dependencies import Input, Output, State
 from .fingerprint import build_fingerprint, check_fingerprint
 from .resources import Scripts, Css
-from .development.base_component import Component, ComponentRegistry
-from . import exceptions
-from ._utils import AttributeDict as _AttributeDict
-from ._utils import interpolate_str as _interpolate
-from ._utils import format_tag as _format_tag
-from ._utils import generate_hash as _generate_hash
-from ._utils import patch_collections_abc as _patch_collections_abc
-from . import _watch
-from ._utils import get_asset_path as _get_asset_path
-from ._utils import create_callback_id as _create_callback_id
-from ._utils import get_relative_path as _get_relative_path
-from ._utils import strip_relative_path as _strip_relative_path
-from ._configs import get_combined_config, pathname_configs
+from .development.base_component import ComponentRegistry
+from .exceptions import PreventUpdate, InvalidResourceError
 from .version import __version__
+from ._configs import get_combined_config, pathname_configs
+from ._utils import (
+    AttributeDict,
+    create_callback_id,
+    format_tag,
+    generate_hash,
+    get_asset_path,
+    get_relative_path,
+    interpolate_str,
+    patch_collections_abc,
+    strip_relative_path
+)
+from . import _validate
+from . import _watch
 
 _default_index = """<!DOCTYPE html>
 <html>
@@ -67,15 +67,14 @@ _app_entry = """
 </div>
 """
 
-_re_index_entry = re.compile(r"{%app_entry%}")
-_re_index_config = re.compile(r"{%config%}")
-_re_index_scripts = re.compile(r"{%scripts%}")
-_re_renderer_scripts = re.compile(r"{%renderer%}")
+_re_index_entry = "{%app_entry%}", "{%app_entry%}"
+_re_index_config = "{%config%}", "{%config%}"
+_re_index_scripts = "{%scripts%}", "{%scripts%}"
 
-_re_index_entry_id = re.compile(r'id="react-entry-point"')
-_re_index_config_id = re.compile(r'id="_dash-config"')
-_re_index_scripts_id = re.compile(r'src=".*dash[-_]renderer.*"')
-_re_renderer_scripts_id = re.compile(r'id="_dash-renderer')
+_re_index_entry_id = 'id="react-entry-point"', "#react-entry-point"
+_re_index_config_id = 'id="_dash-config"', "#_dash-config"
+_re_index_scripts_id = 'src="[^"]*dash[-_]renderer[^"]*"', "dash-renderer"
+_re_renderer_scripts_id = 'id="_dash-renderer', "new DashRenderer"
 
 
 class _NoUpdate(object):
@@ -87,6 +86,13 @@ class _NoUpdate(object):
 no_update = _NoUpdate()
 
 
+_inline_clientside_template = """
+var clientside = window.dash_clientside = window.dash_clientside || {{}};
+var ns = clientside["{namespace}"] = clientside["{namespace}"] || {{}};
+ns["{function_name}"] = {clientside_function};
+"""
+
+
 # pylint: disable=too-many-instance-attributes
 # pylint: disable=too-many-arguments, too-many-locals
 class Dash(object):
@@ -231,16 +237,7 @@ class Dash(object):
         plugins=None,
         **obsolete
     ):
-        for key in obsolete:
-            if key in ["components_cache_max_age", "static_folder"]:
-                raise exceptions.ObsoleteKwargException(
-                    key + " is no longer a valid keyword argument in Dash "
-                    "since v1.0. See https://dash.plot.ly for details."
-                )
-            # any other kwarg mimic the built-in exception
-            raise TypeError(
-                "Dash() got an unexpected keyword argument '" + key + "'"
-            )
+        _validate.check_obsolete(obsolete)
 
         # We have 3 cases: server is either True (we create the server), False
         # (defer server creation) or a Flask app instance (we use their server)
@@ -258,7 +255,7 @@ class Dash(object):
             url_base_pathname, routes_pathname_prefix, requests_pathname_prefix
         )
 
-        self.config = _AttributeDict(
+        self.config = AttributeDict(
             name=name,
             assets_folder=os.path.join(
                 flask.helpers.get_root_path(name), assets_folder
@@ -333,7 +330,7 @@ class Dash(object):
         self._cached_layout = None
 
         self._setup_dev_tools()
-        self._hot_reload = _AttributeDict(
+        self._hot_reload = AttributeDict(
             hash=None,
             hard=False,
             lock=threading.RLock(),
@@ -346,7 +343,7 @@ class Dash(object):
         self.logger = logging.getLogger(name)
         self.logger.addHandler(logging.StreamHandler(stream=sys.stdout))
 
-        if isinstance(plugins, _patch_collections_abc("Iterable")):
+        if isinstance(plugins, patch_collections_abc("Iterable")):
             for plugin in plugins:
                 plugin.plug(self)
 
@@ -380,65 +377,49 @@ class Dash(object):
             # gzip
             Compress(self.server)
 
-        @self.server.errorhandler(exceptions.PreventUpdate)
+        @self.server.errorhandler(PreventUpdate)
         def _handle_error(_):
             """Handle a halted callback and return an empty 204 response."""
             return "", 204
 
-        prefix = config.routes_pathname_prefix
-
         self.server.before_first_request(self._setup_server)
 
         # add a handler for components suites errors to return 404
-        self.server.errorhandler(exceptions.InvalidResourceError)(
+        self.server.errorhandler(InvalidResourceError)(
             self._invalid_resources_handler
         )
 
-        self._add_url("{}_dash-layout".format(prefix), self.serve_layout)
-
-        self._add_url("{}_dash-dependencies".format(prefix), self.dependencies)
-
-        self._add_url(
-            "{}_dash-update-component".format(prefix), self.dispatch, ["POST"]
-        )
-
         self._add_url(
-            (
-                "{}_dash-component-suites"
-                "/<string:package_name>"
-                "/<path:path_in_package_dist>"
-            ).format(prefix),
+            "_dash-component-suites/<string:package_name>/<path:fingerprinted_path>",
             self.serve_component_suites,
         )
-
-        self._add_url("{}_dash-routes".format(prefix), self.serve_routes)
-
-        self._add_url(prefix, self.index)
-
-        self._add_url("{}_reload-hash".format(prefix), self.serve_reload_hash)
+        self._add_url("_dash-layout", self.serve_layout)
+        self._add_url("_dash-dependencies", self.dependencies)
+        self._add_url("_dash-update-component", self.dispatch, ["POST"])
+        self._add_url("_reload-hash", self.serve_reload_hash)
+        self._add_url("_favicon.ico", self._serve_default_favicon)
+        self._add_url("", self.index)
 
         # catch-all for front-end routes, used by dcc.Location
-        self._add_url("{}<path:path>".format(prefix), self.index)
-
-        self._add_url(
-            "{}_favicon.ico".format(prefix), self._serve_default_favicon
-        )
+        self._add_url("<path:path>", self.index)
 
     def _add_url(self, name, view_func, methods=("GET",)):
+        full_name = self.config.routes_pathname_prefix + name
+
         self.server.add_url_rule(
-            name, view_func=view_func, endpoint=name, methods=list(methods)
+            full_name, view_func=view_func, endpoint=name, methods=list(methods)
         )
 
         # record the url in Dash.routes so that it can be accessed later
         # e.g. for adding authentication with flask_login
-        self.routes.append(name)
+        self.routes.append(full_name)
 
     @property
     def layout(self):
         return self._layout
 
     def _layout_value(self):
-        if isinstance(self._layout, _patch_collections_abc("Callable")):
+        if isinstance(self._layout, patch_collections_abc("Callable")):
             self._cached_layout = self._layout()
         else:
             self._cached_layout = self._layout
@@ -446,15 +427,7 @@ class Dash(object):
 
     @layout.setter
     def layout(self, value):
-        if not isinstance(value, Component) and not isinstance(
-            value, _patch_collections_abc("Callable")
-        ):
-            raise exceptions.NoLayoutException(
-                "Layout must be a dash component "
-                "or a function that returns "
-                "a dash component."
-            )
-
+        _validate.validate_layout_type(value)
         self._cached_layout = None
         self._layout = value
 
@@ -464,18 +437,8 @@ class Dash(object):
 
     @index_string.setter
     def index_string(self, value):
-        checks = (
-            (_re_index_entry.search(value), "app_entry"),
-            (_re_index_config.search(value), "config"),
-            (_re_index_scripts.search(value), "scripts"),
-        )
-        missing = [missing for check, missing in checks if not check]
-        if missing:
-            raise exceptions.InvalidIndexException(
-                "Did you forget to include {} in your index string ?".format(
-                    ", ".join("{%" + x + "%}" for x in missing)
-                )
-            )
+        checks = (_re_index_entry, _re_index_config, _re_index_scripts)
+        _validate.validate_index("index string", checks, value)
         self._index_string = value
 
     def serve_layout(self):
@@ -522,12 +485,6 @@ class Dash(object):
             }
         )
 
-    def serve_routes(self):
-        return flask.Response(
-            json.dumps(self.routes, cls=plotly.utils.PlotlyJSONEncoder),
-            mimetype="application/json",
-        )
-
     def _collect_and_register_resources(self, resources):
         # now needs the app context.
         # template in the necessary component suite JS bundles
@@ -593,7 +550,7 @@ class Dash(object):
 
         return "\n".join(
             [
-                _format_tag("link", link, opened=True)
+                format_tag("link", link, opened=True)
                 if isinstance(link, dict)
                 else '<link rel="stylesheet" href="{}">'.format(link)
                 for link in (external_links + links)
@@ -637,7 +594,7 @@ class Dash(object):
 
         return "\n".join(
             [
-                _format_tag("script", src)
+                format_tag("script", src)
                 if isinstance(src, dict)
                 else '<script src="{}"></script>'.format(src)
                 for src in srcs
@@ -677,33 +634,15 @@ class Dash(object):
         if not has_charset:
             tags.append('<meta charset="UTF-8">')
 
-        tags += [_format_tag("meta", x, opened=True) for x in meta_tags]
+        tags += [format_tag("meta", x, opened=True) for x in meta_tags]
 
         return "\n      ".join(tags)
 
     # Serve the JS bundles for each package
-    def serve_component_suites(self, package_name, path_in_package_dist):
-        path_in_package_dist, has_fingerprint = check_fingerprint(
-            path_in_package_dist
-        )
-
-        if package_name not in self.registered_paths:
-            raise exceptions.DependencyException(
-                "Error loading dependency.\n"
-                '"{}" is not a registered library.\n'
-                "Registered libraries are: {}".format(
-                    package_name, list(self.registered_paths.keys())
-                )
-            )
+    def serve_component_suites(self, package_name, fingerprinted_path):
+        path_in_pkg, has_fingerprint = check_fingerprint(fingerprinted_path)
 
-        if path_in_package_dist not in self.registered_paths[package_name]:
-            raise exceptions.DependencyException(
-                '"{}" is registered but the path requested is not valid.\n'
-                'The path requested: "{}"\n'
-                "List of registered paths: {}".format(
-                    package_name, path_in_package_dist, self.registered_paths
-                )
-            )
+        _validate.validate_js_path(self.registered_paths, package_name, path_in_pkg)
 
         mimetype = (
             {
@@ -711,19 +650,19 @@ class Dash(object):
                 "css": "text/css",
                 "map": "application/json",
             }
-        )[path_in_package_dist.split(".")[-1]]
+        )[path_in_pkg.split(".")[-1]]
 
         package = sys.modules[package_name]
         self.logger.debug(
             "serving -- package: %s[%s] resource: %s => location: %s",
             package_name,
             package.__version__,
-            path_in_package_dist,
+            path_in_pkg,
             package.__path__,
         )
 
         response = flask.Response(
-            pkgutil.get_data(package_name, path_in_package_dist),
+            pkgutil.get_data(package_name, path_in_pkg),
             mimetype=mimetype,
         )
 
@@ -764,7 +703,7 @@ class Dash(object):
                 self.config.requests_pathname_prefix, __version__
             )
 
-        favicon = _format_tag(
+        favicon = format_tag(
             "link",
             {"rel": "icon", "type": "image/x-icon", "href": favicon_url},
             opened=True,
@@ -782,21 +721,12 @@ class Dash(object):
         )
 
         checks = (
-            (_re_index_entry_id.search(index), "#react-entry-point"),
-            (_re_index_config_id.search(index), "#_dash-configs"),
-            (_re_index_scripts_id.search(index), "dash-renderer"),
-            (_re_renderer_scripts_id.search(index), "new DashRenderer"),
+            _re_index_entry_id,
+            _re_index_config_id,
+            _re_index_scripts_id,
+            _re_renderer_scripts_id,
         )
-        missing = [missing for check, missing in checks if not check]
-
-        if missing:
-            plural = "s" if len(missing) > 1 else ""
-            raise exceptions.InvalidIndexException(
-                "Missing element{pl} {ids} in index.".format(
-                    ids=", ".join(missing), pl=plural
-                )
-            )
-
+        _validate.validate_index("index", checks, index)
         return index
 
     def interpolate_index(
@@ -845,7 +775,7 @@ class Dash(object):
         :param favicon: A favicon <link> tag if found in assets folder.
         :return: The interpolated HTML string for the index.
         """
-        return _interpolate(
+        return interpolate_str(
             self.index_string,
             metas=metas,
             title=title,
@@ -870,339 +800,31 @@ class Dash(object):
             ]
         )
 
-    def _validate_callback(self, output, inputs, state):
-        # pylint: disable=too-many-branches
+    def _insert_callback(self, output, inputs, state):
         layout = self._cached_layout or self._layout_value()
-        is_multi = isinstance(output, (list, tuple))
-
-        if layout is None and not self.config.suppress_callback_exceptions:
-            # Without a layout, we can't do validation on the IDs and
-            # properties of the elements in the callback.
-            raise exceptions.LayoutIsNotDefined(
-                dedent(
-                    """
-                Attempting to assign a callback to the application but
-                the `layout` property has not been assigned.
-                Assign the `layout` property before assigning callbacks.
-                Alternatively, suppress this warning by setting
-                `suppress_callback_exceptions=True`
-            """
-                )
-            )
-
-        outputs = output if is_multi else [output]
-        for args, obj, name in [
-            (outputs, Output, "Output"),
-            (inputs, Input, "Input"),
-            (state, State, "State"),
-        ]:
-
-            if not isinstance(args, (list, tuple)):
-                raise exceptions.IncorrectTypeException(
-                    "The {} argument `{}` must be "
-                    "a list or tuple of `dash.dependencies.{}`s.".format(
-                        name.lower(), str(args), name
-                    )
-                )
-
-            for arg in args:
-                if not isinstance(arg, obj):
-                    raise exceptions.IncorrectTypeException(
-                        "The {} argument `{}` must be "
-                        "of type `dash.{}`.".format(
-                            name.lower(), str(arg), name
-                        )
-                    )
-
-                invalid_characters = ["."]
-                if any(x in arg.component_id for x in invalid_characters):
-                    raise exceptions.InvalidComponentIdError(
-                        "The element `{}` contains {} in its ID. "
-                        "Periods are not allowed in IDs.".format(
-                            arg.component_id, invalid_characters
-                        )
-                    )
-
-                if not self.config.suppress_callback_exceptions:
-                    layout_id = getattr(layout, "id", None)
-                    arg_id = arg.component_id
-                    arg_prop = getattr(arg, "component_property", None)
-                    if arg_id not in layout and arg_id != layout_id:
-                        all_ids = [k for k in layout]
-                        if layout_id:
-                            all_ids.append(layout_id)
-                        raise exceptions.NonExistentIdException(
-                            dedent(
-                                """
-                            Attempting to assign a callback to the
-                            component with the id "{0}" but no
-                            components with id "{0}" exist in the
-                            app\'s layout.\n\n
-                            Here is a list of IDs in layout:\n{1}\n\n
-                            If you are assigning callbacks to components
-                            that are generated by other callbacks
-                            (and therefore not in the initial layout), then
-                            you can suppress this exception by setting
-                            `suppress_callback_exceptions=True`.
-                        """
-                            ).format(arg_id, all_ids)
-                        )
-
-                    component = (
-                        layout if layout_id == arg_id else layout[arg_id]
-                    )
+        _validate.validate_callback(self, layout, output, inputs, state)
+        callback_id = create_callback_id(output)
 
-                    if (
-                        arg_prop
-                        and arg_prop not in component.available_properties
-                        and not any(
-                            arg_prop.startswith(w)
-                            for w in component.available_wildcard_properties
-                        )
-                    ):
-                        raise exceptions.NonExistentPropException(
-                            dedent(
-                                """
-                            Attempting to assign a callback with
-                            the property "{0}" but the component
-                            "{1}" doesn't have "{0}" as a property.\n
-                            Here are the available properties in "{1}":
-                            {2}
-                        """
-                            ).format(
-                                arg_prop,
-                                arg_id,
-                                component.available_properties,
-                            )
-                        )
-
-                    if hasattr(arg, "component_event"):
-                        raise exceptions.NonExistentEventException(
-                            dedent(
-                                """
-                            Events have been removed.
-                            Use the associated property instead.
-                        """
-                            )
-                        )
-
-        if state and not inputs:
-            raise exceptions.MissingInputsException(
-                dedent(
-                    """
-                This callback has {} `State` {}
-                but no `Input` elements.\n
-                Without `Input` elements, this callback
-                will never get called.\n
-                (Subscribing to input components will cause the
-                callback to be called whenever their values change.)
-            """
-                ).format(
-                    len(state), "elements" if len(state) > 1 else "element"
-                )
-            )
-
-        for i in inputs:
-            bad = None
-            if is_multi:
-                for o in output:
-                    if o == i:
-                        bad = o
-            else:
-                if output == i:
-                    bad = output
-            if bad:
-                raise exceptions.SameInputOutputException(
-                    "Same output and input: {}".format(bad)
-                )
-
-        if is_multi:
-            if len(set(output)) != len(output):
-                raise exceptions.DuplicateCallbackOutput(
-                    "Same output was used more than once in a "
-                    "multi output callback!\n Duplicates:\n {}".format(
-                        ",\n".join(
-                            k
-                            for k, v in (
-                                (str(x), output.count(x)) for x in output
-                            )
-                            if v > 1
-                        )
-                    )
-                )
-
-        callback_id = _create_callback_id(output)
-
-        callbacks = set(
-            itertools.chain(
-                *(
-                    x[2:-2].split("...") if x.startswith("..") else [x]
-                    for x in self.callback_map
-                )
-            )
-        )
-        ns = {"duplicates": set()}
-        if is_multi:
-
-            def duplicate_check():
-                ns["duplicates"] = callbacks.intersection(
-                    str(y) for y in output
-                )
-                return ns["duplicates"]
-
-        else:
-
-            def duplicate_check():
-                return callback_id in callbacks
-
-        if duplicate_check():
-            if is_multi:
-                msg = dedent(
-                    """
-                Multi output {} contains an `Output` object
-                that was already assigned.
-                Duplicates:
-                {}
-                """
-                ).format(callback_id, pprint.pformat(ns["duplicates"]))
-            else:
-                msg = dedent(
-                    """
-                You have already assigned a callback to the output
-                with ID "{}" and property "{}". An output can only have
-                a single callback function. Try combining your inputs and
-                callback functions together into one function.
-                """
-                ).format(output.component_id, output.component_property)
-            raise exceptions.DuplicateCallbackOutput(msg)
-
-    @staticmethod
-    def _validate_callback_output(output_value, output):
-        valid = [str, dict, int, float, type(None), Component]
-
-        def _raise_invalid(
-            bad_val, outer_val, path, index=None, toplevel=False
-        ):
-            bad_type = type(bad_val).__name__
-            outer_id = (
-                "(id={:s})".format(outer_val.id)
-                if getattr(outer_val, "id", False)
-                else ""
-            )
-            outer_type = type(outer_val).__name__
-            raise exceptions.InvalidCallbackReturnValue(
-                dedent(
-                    """
-            The callback for `{output:s}`
-            returned a {object:s} having type `{type:s}`
-            which is not JSON serializable.
-
-            {location_header:s}{location:s}
-            and has string representation
-            `{bad_val}`
-
-            In general, Dash properties can only be
-            dash components, strings, dictionaries, numbers, None,
-            or lists of those.
-            """
-                ).format(
-                    output=repr(output),
-                    object="tree with one value" if not toplevel else "value",
-                    type=bad_type,
-                    location_header=(
-                        "The value in question is located at"
-                        if not toplevel
-                        else "The value in question is either the only value "
-                        "returned,\nor is in the top level of the returned "
-                        "list,"
-                    ),
-                    location=(
-                        "\n"
-                        + (
-                            "[{:d}] {:s} {:s}".format(
-                                index, outer_type, outer_id
-                            )
-                            if index is not None
-                            else ("[*] " + outer_type + " " + outer_id)
-                        )
-                        + "\n"
-                        + path
-                        + "\n"
-                    )
-                    if not toplevel
-                    else "",
-                    bad_val=bad_val,
-                )
-            )
-
-        def _value_is_valid(val):
-            return (
-                # pylint: disable=unused-variable
-                any([isinstance(val, x) for x in valid])
-                or type(val).__name__ == "unicode"
-            )
-
-        def _validate_value(val, index=None):
-            # val is a Component
-            if isinstance(val, Component):
-                # pylint: disable=protected-access
-                for p, j in val._traverse_with_paths():
-                    # check each component value in the tree
-                    if not _value_is_valid(j):
-                        _raise_invalid(
-                            bad_val=j, outer_val=val, path=p, index=index
-                        )
-
-                    # Children that are not of type Component or
-                    # list/tuple not returned by traverse
-                    child = getattr(j, "children", None)
-                    if not isinstance(
-                        child, (tuple, collections.MutableSequence)
-                    ):
-                        if child and not _value_is_valid(child):
-                            _raise_invalid(
-                                bad_val=child,
-                                outer_val=val,
-                                path=p + "\n" + "[*] " + type(child).__name__,
-                                index=index,
-                            )
-
-                # Also check the child of val, as it will not be returned
-                child = getattr(val, "children", None)
-                if not isinstance(child, (tuple, collections.MutableSequence)):
-                    if child and not _value_is_valid(child):
-                        _raise_invalid(
-                            bad_val=child,
-                            outer_val=val,
-                            path=type(child).__name__,
-                            index=index,
-                        )
-
-            # val is not a Component, but is at the top level of tree
-            else:
-                if not _value_is_valid(val):
-                    _raise_invalid(
-                        bad_val=val,
-                        outer_val=type(val).__name__,
-                        path="",
-                        index=index,
-                        toplevel=True,
-                    )
+        self.callback_map[callback_id] = {
+            "inputs": [
+                {"id": c.component_id, "property": c.component_property}
+                for c in inputs
+            ],
+            "state": [
+                {"id": c.component_id, "property": c.component_property}
+                for c in state
+            ],
+        }
 
-        if isinstance(output_value, list):
-            for i, val in enumerate(output_value):
-                _validate_value(val, index=i)
-        else:
-            _validate_value(output_value)
+        return callback_id
 
-    # pylint: disable=dangerous-default-value
     def clientside_callback(
-        self, clientside_function, output, inputs=[], state=[]
+        self, clientside_function, output, inputs, state=()
     ):
         """Create a callback that updates the output by calling a clientside
         (JavaScript) function instead of a Python function.
 
-        Unlike `@app.calllback`, `clientside_callback` is not a decorator:
+        Unlike `@app.callback`, `clientside_callback` is not a decorator:
         it takes either a
         `dash.dependencies.ClientsideFunction(namespace, function_name)`
         argument that describes which JavaScript function to call
@@ -1259,8 +881,7 @@ class Dash(object):
         )
         ```
         """
-        self._validate_callback(output, inputs, state)
-        callback_id = _create_callback_id(output)
+        callback_id = self._insert_callback(output, inputs, state)
 
         # If JS source is explicitly given, create a namespace and function
         # name, then inject the code.
@@ -1274,13 +895,11 @@ class Dash(object):
             function_name = '{}'.format(out0.component_property)
 
             self._inline_scripts.append(
-                """
-                var clientside = window.dash_clientside = window.dash_clientside || {{}};
-                var ns = clientside["{0}"] = clientside["{0}"] || {{}};
-                ns["{1}"] = {2};
-                """.format(namespace.replace('"', '\\"'),
-                           function_name.replace('"', '\\"'),
-                           clientside_function)
+                _inline_clientside_template.format(
+                    namespace=namespace.replace('"', '\\"'),
+                    function_name=function_name.replace('"', '\\"'),
+                    clientside_function=clientside_function
+                )
             )
 
         # Callback is stored in an external asset.
@@ -1288,72 +907,24 @@ class Dash(object):
             namespace = clientside_function.namespace
             function_name = clientside_function.function_name
 
-        self.callback_map[callback_id] = {
-            "inputs": [
-                {"id": c.component_id, "property": c.component_property}
-                for c in inputs
-            ],
-            "state": [
-                {"id": c.component_id, "property": c.component_property}
-                for c in state
-            ],
-            "clientside_function": {
-                "namespace": namespace,
-                "function_name": function_name,
-            },
+        self.callback_map[callback_id]["clientside_function"] = {
+            "namespace": namespace,
+            "function_name": function_name,
         }
 
-    # TODO - Update nomenclature.
-    # "Parents" and "Children" should refer to the DOM tree
-    # and not the dependency tree.
-    # The dependency tree should use the nomenclature
-    # "observer" and "controller".
-    # "observers" listen for changes from their "controllers". For example,
-    # if a graph depends on a dropdown, the graph is the "observer" and the
-    # dropdown is a "controller". In this case the graph's "dependency" is
-    # the dropdown.
-    # TODO - Check this map for recursive or other ill-defined non-tree
-    # relationships
-    # pylint: disable=dangerous-default-value
-    def callback(self, output, inputs=[], state=[]):
-        self._validate_callback(output, inputs, state)
-
-        callback_id = _create_callback_id(output)
+    def callback(self, output, inputs, state=()):
+        callback_id = self._insert_callback(output, inputs, state)
         multi = isinstance(output, (list, tuple))
 
-        self.callback_map[callback_id] = {
-            "inputs": [
-                {"id": c.component_id, "property": c.component_property}
-                for c in inputs
-            ],
-            "state": [
-                {"id": c.component_id, "property": c.component_property}
-                for c in state
-            ],
-        }
-
         def wrap_func(func):
             @wraps(func)
             def add_context(*args, **kwargs):
                 # don't touch the comment on the next line - used by debugger
                 output_value = func(*args, **kwargs)  # %% callback invoked %%
                 if multi:
-                    if not isinstance(output_value, (list, tuple)):
-                        raise exceptions.InvalidCallbackReturnValue(
-                            "The callback {} is a multi-output.\n"
-                            "Expected the output type to be a list"
-                            " or tuple but got {}.".format(
-                                callback_id, repr(output_value)
-                            )
-                        )
-
-                    if not len(output_value) == len(output):
-                        raise exceptions.InvalidCallbackReturnValue(
-                            "Invalid number of output values for {}.\n"
-                            " Expected {} got {}".format(
-                                callback_id, len(output), len(output_value)
-                            )
-                        )
+                    _validate.validate_multi_return(
+                        output, output_value, callback_id
+                    )
 
                     component_ids = collections.defaultdict(dict)
                     has_update = False
@@ -1365,12 +936,12 @@ class Dash(object):
                             component_ids[o_id][o_prop] = val
 
                     if not has_update:
-                        raise exceptions.PreventUpdate
+                        raise PreventUpdate
 
                     response = {"response": component_ids, "multi": True}
                 else:
                     if isinstance(output_value, _NoUpdate):
-                        raise exceptions.PreventUpdate
+                        raise PreventUpdate
 
                     response = {
                         "response": {
@@ -1383,23 +954,7 @@ class Dash(object):
                         response, cls=plotly.utils.PlotlyJSONEncoder
                     )
                 except TypeError:
-                    self._validate_callback_output(output_value, output)
-                    raise exceptions.InvalidCallbackReturnValue(
-                        dedent(
-                            """
-                    The callback for property `{property:s}`
-                    of component `{id:s}` returned a value
-                    which is not JSON serializable.
-
-                    In general, Dash properties can only be
-                    dash components, strings, dictionaries, numbers, None,
-                    or lists of those.
-                    """
-                        ).format(
-                            property=output.component_property,
-                            id=output.component_id,
-                        )
-                    )
+                    _validate.fail_callback_output(output_value, output)
 
                 return jsonResponse
 
@@ -1436,53 +991,23 @@ class Dash(object):
             mimetype="application/json"
         )
 
+        def pluck_val(_props, component_registration):
+            for c in _props:
+                if (
+                    c["property"] == component_registration["property"] and
+                    c["id"] == component_registration["id"]
+                ):
+                    return c.get("value", None)
+
         for component_registration in self.callback_map[output]["inputs"]:
-            args.append(
-                [
-                    c.get("value", None)
-                    for c in inputs
-                    if c["property"] == component_registration["property"]
-                    and c["id"] == component_registration["id"]
-                ][0]
-            )
+            args.append(pluck_val(inputs, component_registration))
 
         for component_registration in self.callback_map[output]["state"]:
-            args.append(
-                [
-                    c.get("value", None)
-                    for c in state
-                    if c["property"] == component_registration["property"]
-                    and c["id"] == component_registration["id"]
-                ][0]
-            )
+            args.append(pluck_val(state, component_registration))
 
         response.set_data(self.callback_map[output]["callback"](*args))
         return response
 
-    def _validate_layout(self):
-        if self.layout is None:
-            raise exceptions.NoLayoutException(
-                "The layout was `None` "
-                "at the time that `run_server` was called. "
-                "Make sure to set the `layout` attribute of your application "
-                "before running the server."
-            )
-
-        to_validate = self._layout_value()
-
-        layout_id = getattr(self.layout, "id", None)
-
-        component_ids = {layout_id} if layout_id else set()
-        # pylint: disable=protected-access
-        for component in to_validate._traverse():
-            component_id = getattr(component, "id", None)
-            if component_id and component_id in component_ids:
-                raise exceptions.DuplicateIdError(
-                    "Duplicate component id found"
-                    " in the initial layout: `{}`".format(component_id)
-                )
-            component_ids.add(component_id)
-
     def _setup_server(self):
         # Apply _force_eager_loading overrides from modules
         eager_loading = self.config.eager_loading
@@ -1497,7 +1022,7 @@ class Dash(object):
         if self.config.include_assets_files:
             self._walk_assets_directory()
 
-        self._validate_layout()
+        _validate.validate_layout(self.layout, self._layout_value())
 
         self._generate_scripts_html()
         self._generate_css_dist_html()
@@ -1559,7 +1084,7 @@ class Dash(object):
         )
 
     def get_asset_url(self, path):
-        asset = _get_asset_path(
+        asset = get_asset_path(
             self.config.requests_pathname_prefix,
             path,
             self.config.assets_url_path.lstrip("/"),
@@ -1604,7 +1129,7 @@ class Dash(object):
                 return chapters.page_2
         ```
         """
-        asset = _get_relative_path(
+        asset = get_relative_path(
             self.config.requests_pathname_prefix,
             path,
         )
@@ -1658,14 +1183,14 @@ class Dash(object):
         `page-1/sub-page-1`
         ```
         """
-        return _strip_relative_path(
+        return strip_relative_path(
             self.config.requests_pathname_prefix,
             path,
         )
 
     def _setup_dev_tools(self, **kwargs):
         debug = kwargs.get("debug", False)
-        dev_tools = self._dev_tools = _AttributeDict()
+        dev_tools = self._dev_tools = AttributeDict()
 
         for attr in (
             "ui",
@@ -1798,7 +1323,7 @@ class Dash(object):
 
         if dev_tools.hot_reload:
             _reload = self._hot_reload
-            _reload.hash = _generate_hash()
+            _reload.hash = generate_hash()
 
             component_packages_dist = [
                 os.path.dirname(package.path)
@@ -1856,7 +1381,7 @@ class Dash(object):
         _reload = self._hot_reload
         with _reload.lock:
             _reload.hard = True
-            _reload.hash = _generate_hash()
+            _reload.hash = generate_hash()
 
             if self.config.assets_folder in filename:
                 asset_path = (
diff --git a/dash/dependencies.py b/dash/dependencies.py
index 3d9b583c..6bc5413f 100644
--- a/dash/dependencies.py
+++ b/dash/dependencies.py
@@ -5,13 +5,13 @@ class DashDependency:
         self.component_property = component_property
 
     def __str__(self):
-        return '{}.{}'.format(
+        return "{}.{}".format(
             self.component_id,
             self.component_property
         )
 
     def __repr__(self):
-        return '<{} `{}`>'.format(self.__class__.__name__, self)
+        return "<{} `{}`>".format(self.__class__.__name__, self)
 
     def __eq__(self, other):
         return isinstance(other, DashDependency) and str(self) == str(other)
@@ -25,11 +25,11 @@ class Output(DashDependency):  # pylint: disable=too-few-public-methods
 
 
 class Input(DashDependency):  # pylint: disable=too-few-public-methods
-    """Input of callback trigger an update when it is updated."""
+    """Input of callback: trigger an update when it is updated."""
 
 
 class State(DashDependency):  # pylint: disable=too-few-public-methods
-    """Use the value of a state in a callback but don't trigger updates."""
+    """Use the value of a State in a callback but don't trigger updates."""
 
 
 class ClientsideFunction:
@@ -47,7 +47,7 @@ class ClientsideFunction:
         self.function_name = function_name
 
     def __repr__(self):
-        return 'ClientsideFunction({}, {})'.format(
+        return "ClientsideFunction({}, {})".format(
             self.namespace,
             self.function_name
         )
diff --git a/dash/exceptions.py b/dash/exceptions.py
index 4756da91..9bf0c099 100644
--- a/dash/exceptions.py
+++ b/dash/exceptions.py
@@ -1,5 +1,9 @@
+from textwrap import dedent
+
+
 class DashException(Exception):
-    pass
+    def __init__(self, msg=""):
+        super(DashException, self).__init__(dedent(msg).strip())
 
 
 class ObsoleteKwargException(DashException):

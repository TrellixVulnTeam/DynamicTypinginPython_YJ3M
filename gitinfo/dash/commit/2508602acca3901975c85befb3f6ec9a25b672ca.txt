commit 2508602acca3901975c85befb3f6ec9a25b672ca
Author: byron <byron@plot.ly>
Date:   Tue Mar 19 18:21:06 2019 -0400

    :art: prettier

diff --git a/package.json b/package.json
index c7861387..7117e150 100644
--- a/package.json
+++ b/package.json
@@ -61,8 +61,8 @@
     "eslint": "^3.19.0",
     "eslint-config-prettier": "^3.3.0",
     "eslint-plugin-import": "^2.2.0",
-    "eslint-plugin-react": "^6.9.0",
-    "prettier": "^1.14.3",
+    "eslint-plugin-react": "^7.12.4",
+    "prettier": "1.16.4",
     "react-hot-loader": "^1.3.0",
     "redux-logger": "^2.8.0",
     "style-loader": "^0.23.1",
diff --git a/src/TreeContainer.js b/src/TreeContainer.js
index bfab27ca..0948cb7e 100644
--- a/src/TreeContainer.js
+++ b/src/TreeContainer.js
@@ -208,6 +208,10 @@ function mergeProps(stateProps, dispatchProps, ownProps) {
     };
 }
 
-export const AugmentedTreeContainer = connect(mapStateToProps, mapDispatchToProps, mergeProps)(TreeContainer);
+export const AugmentedTreeContainer = connect(
+    mapStateToProps, 
+    mapDispatchToProps, 
+    mergeProps
+)(TreeContainer);
 
 export default AugmentedTreeContainer;
diff --git a/src/actions/constants.js b/src/actions/constants.js
index 59a6f986..b796efd0 100644
--- a/src/actions/constants.js
+++ b/src/actions/constants.js
@@ -1,16 +1,17 @@
+const actionList = {
+    ON_PROP_CHANGE: 'ON_PROP_CHANGE',
+    SET_REQUEST_QUEUE: 'SET_REQUEST_QUEUE',
+    COMPUTE_GRAPHS: 'COMPUTE_GRAPHS',
+    COMPUTE_PATHS: 'COMPUTE_PATHS',
+    SET_LAYOUT: 'SET_LAYOUT',
+    SET_APP_LIFECYCLE: 'SET_APP_LIFECYCLE',
+    READ_CONFIG: 'READ_CONFIG',
+    ON_ERROR: 'ON_ERROR',
+    RESOLVE_ERROR: 'RESOLVE_ERROR',
+    SET_HOOKS: 'SET_HOOKS',
+};
+
 export const getAction = action => {
-    const actionList = {
-        ON_PROP_CHANGE: 'ON_PROP_CHANGE',
-        SET_REQUEST_QUEUE: 'SET_REQUEST_QUEUE',
-        COMPUTE_GRAPHS: 'COMPUTE_GRAPHS',
-        COMPUTE_PATHS: 'COMPUTE_PATHS',
-        SET_LAYOUT: 'SET_LAYOUT',
-        SET_APP_LIFECYCLE: 'SET_APP_LIFECYCLE',
-        READ_CONFIG: 'READ_CONFIG',
-        ON_ERROR: 'ON_ERROR',
-        RESOLVE_ERROR: 'RESOLVE_ERROR',
-        SET_HOOKS: 'SET_HOOKS',
-    };
     if (actionList[action]) {
         return actionList[action];
     }
diff --git a/src/actions/index.js b/src/actions/index.js
index 2efe5a50..714ce43d 100644
--- a/src/actions/index.js
+++ b/src/actions/index.js
@@ -26,7 +26,7 @@ import {
     view,
 } from 'ramda';
 import {createAction} from 'redux-actions';
-import {crawlLayout, hasId} from '../reducers/utils';
+import {crawlLayout, hasPropsId} from '../reducers/utils';
 import {getAppState} from '../reducers/constants';
 import {getAction} from './constants';
 import cookie from 'cookie';
@@ -545,11 +545,11 @@ function updateOutput(
                     getState().requestQueue
                 );
                 /*
-             * Note that if the latest request is still `loading`
-             * or even if the latest request failed,
-             * we still reject this response in favor of waiting
-             * for the latest request to finish.
-             */
+                 * Note that if the latest request is still `loading`
+                 * or even if the latest request failed,
+                 * we still reject this response in favor of waiting
+                 * for the latest request to finish.
+                 */
                 const rejected = latestRequestIndex > getThisRequestIndex();
                 return rejected;
             };
@@ -561,10 +561,10 @@ function updateOutput(
             }
 
             /*
-         * Check to see if another request has already come back
-         * _after_ this one.
-         * If so, ignore this request.
-         */
+             * Check to see if another request has already come back
+             * _after_ this one.
+             * If so, ignore this request.
+             */
             if (isRejected()) {
                 updateRequestQueue(true);
                 return;
@@ -572,11 +572,11 @@ function updateOutput(
 
             res.json().then(function handleJson(data) {
                 /*
-             * Even if the `res` was received in the correct order,
-             * the remainder of the response (res.json()) could happen
-             * at different rates causing the parsed responses to
-             * get out of order
-             */
+                 * Even if the `res` was received in the correct order,
+                 * the remainder of the response (res.json()) could happen
+                 * at different rates causing the parsed responses to
+                 * get out of order
+                 */
                 if (isRejected()) {
                     updateRequestQueue(true);
                     return;
@@ -590,13 +590,13 @@ function updateOutput(
                 }
 
                 /*
-             * it's possible that this output item is no longer visible.
-             * for example, the could still be request running when
-             * the user switched the chapter
-             *
-             * if it's not visible, then ignore the rest of the updates
-             * to the store
-             */
+                 * it's possible that this output item is no longer visible.
+                 * for example, the could still be request running when
+                 * the user switched the chapter
+                 *
+                 * if it's not visible, then ignore the rest of the updates
+                 * to the store
+                 */
 
                 const multi = data.multi;
 
@@ -621,10 +621,10 @@ function updateOutput(
                     );
 
                     /*
-                 * If the response includes children, then we need to update our
-                 * paths store.
-                 * TODO - Do we need to wait for updateProps to finish?
-                 */
+                     * If the response includes children, then we need to update our
+                     * paths store.
+                     * TODO - Do we need to wait for updateProps to finish?
+                     */
                     if (has('children', observerUpdatePayload.props)) {
                         dispatch(
                             computePaths({
@@ -637,10 +637,10 @@ function updateOutput(
                         );
 
                         /*
-                    * if children contains objects with IDs, then we
-                    * need to dispatch a propChange for all of these
-                    * new children components
-                    */
+                         * if children contains objects with IDs, then we
+                         * need to dispatch a propChange for all of these
+                         * new children components
+                         */
                         if (
                             contains(
                                 type(observerUpdatePayload.props.children),
@@ -649,17 +649,17 @@ function updateOutput(
                             !isEmpty(observerUpdatePayload.props.children)
                         ) {
                             /*
-                         * TODO: We're just naively crawling
-                         * the _entire_ layout to recompute the
-                         * the dependency graphs.
-                         * We don't need to do this - just need
-                         * to compute the subtree
-                         */
+                             * TODO: We're just naively crawling
+                             * the _entire_ layout to recompute the
+                             * the dependency graphs.
+                             * We don't need to do this - just need
+                             * to compute the subtree
+                             */
                             const newProps = {};
                             crawlLayout(
                                 observerUpdatePayload.props.children,
                                 function appendIds(child) {
-                                    if (hasId(child)) {
+                                    if (hasPropsId(child)) {
                                         keys(child.props).forEach(childProp => {
                                             const componentIdAndProp = `${
                                                 child.props.id
@@ -686,30 +686,30 @@ function updateOutput(
                             );
 
                             /*
-                         * Organize props by shared outputs so that we
-                         * only make one request per output component
-                         * (even if there are multiple inputs).
-                         *
-                         * For example, we might render 10 inputs that control
-                         * a single output. If that is the case, we only want
-                         * to make a single call, not 10 calls.
-                         */
+                             * Organize props by shared outputs so that we
+                             * only make one request per output component
+                             * (even if there are multiple inputs).
+                             *
+                             * For example, we might render 10 inputs that control
+                             * a single output. If that is the case, we only want
+                             * to make a single call, not 10 calls.
+                             */
 
                             /*
-                         * In some cases, the new item will be an output
-                         * with its inputs already rendered (not rendered)
-                         * as part of this update.
-                         * For example, a tab with global controls that
-                         * renders different content containers without any
-                         * additional inputs.
-                         *
-                         * In that case, we'll call `updateOutput` with that output
-                         * and just "pretend" that one if its inputs changed.
-                         *
-                         * If we ever add logic that informs the user on
-                         * "which input changed", we'll have to account for this
-                         * special case (no input changed?)
-                         */
+                             * In some cases, the new item will be an output
+                             * with its inputs already rendered (not rendered)
+                             * as part of this update.
+                             * For example, a tab with global controls that
+                             * renders different content containers without any
+                             * additional inputs.
+                             *
+                             * In that case, we'll call `updateOutput` with that output
+                             * and just "pretend" that one if its inputs changed.
+                             *
+                             * If we ever add logic that informs the user on
+                             * "which input changed", we'll have to account for this
+                             * special case (no input changed?)
+                             */
 
                             const outputIds = [];
                             keys(newProps).forEach(idAndProp => {
@@ -718,9 +718,9 @@ function updateOutput(
                                     InputGraph.dependenciesOf(idAndProp)
                                         .length === 0 &&
                                     /*
-                                 * And none of its inputs are generated in this
-                                 * request
-                                 */
+                                     * And none of its inputs are generated in this
+                                     * request
+                                     */
                                     intersection(
                                         InputGraph.dependantsOf(idAndProp),
                                         keys(newProps)
diff --git a/src/components/error/ComponentErrorBoundary.react.js b/src/components/error/ComponentErrorBoundary.react.js
index 2bdd6681..8bdb9876 100644
--- a/src/components/error/ComponentErrorBoundary.react.js
+++ b/src/components/error/ComponentErrorBoundary.react.js
@@ -137,7 +137,9 @@ const ComponentErrorBoundary = connect(
         error: state.error,
         graphs: state.graphs,
     }),
-    dispatch => ({dispatch})
+    dispatch => {
+        return {dispatch};
+    }
 )(Radium(UnconnectedComponentErrorBoundary));
 
 export default ComponentErrorBoundary;
diff --git a/src/reducers/paths.js b/src/reducers/paths.js
index c19a0037..360d24b1 100644
--- a/src/reducers/paths.js
+++ b/src/reducers/paths.js
@@ -1,4 +1,4 @@
-import {crawlLayout, hasId} from './utils';
+import {crawlLayout, hasPropsId} from './utils';
 import R from 'ramda';
 import {getAction} from '../actions/constants';
 
@@ -30,7 +30,7 @@ const paths = (state = initialPaths, action) => {
             }
 
             crawlLayout(subTree, function assignPath(child, itempath) {
-                if (hasId(child)) {
+                if (hasPropsId(child)) {
                     newState[child.props.id] = R.concat(startingPath, itempath);
                 }
             });
diff --git a/src/reducers/utils.js b/src/reducers/utils.js
index 966fb0ad..0f0454b9 100644
--- a/src/reducers/utils.js
+++ b/src/reducers/utils.js
@@ -2,6 +2,24 @@ import R from 'ramda';
 
 const extend = R.reduce(R.flip(R.append));
 
+const hasProps = R.allPass([R.is(Object), R.has('props')]);
+
+export const hasPropsId = R.allPass([
+    hasProps,
+    R.compose(
+        R.has('id'),
+        R.prop('props')
+    ),
+]);
+
+export const hasPropsChildren = R.allPass([
+    hasProps,
+    R.compose(
+        R.has('children'),
+        R.prop('props')
+    ),
+]);
+
 // crawl a layout object, apply a function on every object
 export const crawlLayout = (object, func, path = []) => {
     func(object, path);
@@ -10,11 +28,7 @@ export const crawlLayout = (object, func, path = []) => {
      * object may be a string, a number, or null
      * R.has will return false for both of those types
      */
-    if (
-        R.type(object) === 'Object' &&
-        R.has('props', object) &&
-        R.has('children', object.props)
-    ) {
+    if (hasPropsChildren(object)) {
         const newPath = extend(path, ['props', 'children']);
         if (Array.isArray(object.props.children)) {
             object.props.children.forEach((child, i) => {
@@ -23,7 +37,7 @@ export const crawlLayout = (object, func, path = []) => {
         } else {
             crawlLayout(object.props.children, func, newPath);
         }
-    } else if (R.type(object) === 'Array') {
+    } else if (R.is(Array, object)) {
         /*
          * Sometimes when we're updating a sub-tree
          * (like when we're responding to a callback)
@@ -37,11 +51,3 @@ export const crawlLayout = (object, func, path = []) => {
         });
     }
 };
-
-export function hasId(child) {
-    return (
-        R.type(child) === 'Object' &&
-        R.has('props', child) &&
-        R.has('id', child.props)
-    );
-}

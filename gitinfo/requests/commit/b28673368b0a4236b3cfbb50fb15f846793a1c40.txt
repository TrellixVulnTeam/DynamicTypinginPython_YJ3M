commit b28673368b0a4236b3cfbb50fb15f846793a1c40
Author: Arup Malakar <amalakar@gmail.com>
Date:   Wed May 23 14:12:18 2012 -0700

    Issue #505: Changed the store_cookie configuration to be part of the config dict, instead of being a new argument

diff --git a/requests/api.py b/requests/api.py
index cc6a1c7b..9cea79af 100644
--- a/requests/api.py
+++ b/requests/api.py
@@ -25,7 +25,6 @@ def request(method, url, **kwargs):
     :param data: (optional) Dictionary or bytes to send in the body of the :class:`Request`.
     :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
     :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.
-    :param store_cookies: (optional) if ``False``, the received cookies as part of the HTTP response would be ignored.
     :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.
     :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.
     :param timeout: (optional) Float describing the timeout of the request.
@@ -33,7 +32,7 @@ def request(method, url, **kwargs):
     :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.
     :param return_response: (optional) If False, an un-sent Request object will returned.
     :param session: (optional) A :class:`Session` object to be used for the request.
-    :param config: (optional) A configuration dictionary.
+    :param config: (optional) A configuration dictionary. See ``request.defaults`` for allowed keys and their default values.
     :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.
     :param prefetch: (optional) if ``True``, the response content will be immediately downloaded.
     :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.
diff --git a/requests/defaults.py b/requests/defaults.py
index 6a7ea270..41e279df 100644
--- a/requests/defaults.py
+++ b/requests/defaults.py
@@ -20,6 +20,7 @@ Configurations:
 :pool_connections: The number of active HTTP connection pools to use.
 :encode_uri: If true, URIs will automatically be percent-encoded.
 :trust_env: If true, the surrouding environment will be trusted (environ, netrc).
+:param store_cookies: If false, the received cookies as part of the HTTP response would be ignored.
 
 """
 
@@ -47,5 +48,6 @@ defaults['strict_mode'] = False
 defaults['keep_alive'] = True
 defaults['encode_uri'] = True
 defaults['trust_env'] = True
+defaults['store_cookies'] = True
 
 
diff --git a/requests/models.py b/requests/models.py
index 79a3bc36..7d3b1c82 100644
--- a/requests/models.py
+++ b/requests/models.py
@@ -59,7 +59,6 @@ class Request(object):
         params=dict(),
         auth=None,
         cookies=None,
-        store_cookies=True,
         timeout=None,
         redirect=False,
         allow_redirects=False,
@@ -110,9 +109,6 @@ class Request(object):
         # Dictionary mapping protocol to the URL of the proxy (e.g. {'http': 'foo.bar:3128'})
         self.proxies = dict(proxies or [])
 
-        #param store_cookies: (optional) if ``False``, the received cookies as part of the HTTP response would be ignored.
-        self.store_cookies = store_cookies
-
         # If no proxies are given, allow configuration by environment variables
         # HTTP_PROXY and HTTPS_PROXY.
         if not self.proxies and self.config.get('trust_env'):
@@ -201,7 +197,7 @@ class Request(object):
                 response.encoding = get_encoding_from_headers(response.headers)
 
                 # Add new cookies from the server. Don't if configured not to
-                if self.store_cookies:
+                if self.config.get('store_cookies'):
                     extract_cookies_to_jar(self.cookies, self, resp)
 
                 # Save cookies in Response.
diff --git a/requests/sessions.py b/requests/sessions.py
index e047ce56..3113c787 100644
--- a/requests/sessions.py
+++ b/requests/sessions.py
@@ -60,7 +60,6 @@ class Session(object):
     def __init__(self,
         headers=None,
         cookies=None,
-        store_cookies=True,
         auth=None,
         timeout=None,
         proxies=None,
@@ -81,7 +80,6 @@ class Session(object):
         self.prefetch = prefetch
         self.verify = verify
         self.cert = cert
-        self.store_cookies = store_cookies
 
         for (k, v) in list(defaults.items()):
             self.config.setdefault(k, deepcopy(v))
@@ -114,7 +112,6 @@ class Session(object):
         data=None,
         headers=None,
         cookies=None,
-        store_cookies=True,
         files=None,
         auth=None,
         timeout=None,
@@ -136,14 +133,13 @@ class Session(object):
         :param data: (optional) Dictionary or bytes to send in the body of the :class:`Request`.
         :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
         :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.
-        :param store_cookies: (optional) if ``False``, the received cookies as part of the HTTP response would be ignored.
         :param files: (optional) Dictionary of 'filename': file-like-objects for multipart encoding upload.
         :param auth: (optional) Auth tuple or callable to enable Basic/Digest/Custom HTTP Auth.
         :param timeout: (optional) Float describing the timeout of the request.
         :param allow_redirects: (optional) Boolean. Set to True by default.
         :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.
         :param return_response: (optional) If False, an un-sent Request object will returned.
-        :param config: (optional) A configuration dictionary.
+        :param config: (optional) A configuration dictionary. See ``request.defaults`` for allowed keys and their default values.
         :param prefetch: (optional) if ``True``, the response content will be immediately downloaded.
         :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.
         :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.
@@ -175,7 +171,6 @@ class Session(object):
             params=params,
             headers=headers,
             cookies=cookies,
-            store_cookies=store_cookies,
             files=files,
             auth=auth,
             hooks=hooks,
diff --git a/tests/test_cookies.py b/tests/test_cookies.py
index bdc9172a..60acdd8c 100755
--- a/tests/test_cookies.py
+++ b/tests/test_cookies.py
@@ -106,20 +106,22 @@ class CookieTests(TestBaseMixin, unittest.TestCase):
     def test_disabled_cookie_persistence(self):
         """Test that cookies are not persisted when configured accordingly."""
 
+        config = {'store_cookies' : False}
+
         # Check the case when no cookie is passed as part of the request and the one in response is ignored
-        cookies = requests.get(httpbin('cookies', 'set', 'key', 'value'), store_cookies = False).cookies
-        self.assertEqual(cookies.get("key"), None)
+        cookies = requests.get(httpbin('cookies', 'set', 'key', 'value'), config = config).cookies
+        self.assertIsNone(cookies.get("key"))
 
         # Test that the cookies passed while making the request still gets used and is available in response object.
         # only the ones received from server is not saved
-        cookies_2 = requests.get(httpbin('cookies', 'set', 'key', 'value'), store_cookies = False,\
+        cookies_2 = requests.get(httpbin('cookies', 'set', 'key', 'value'), config = config,\
                                                 cookies = {"key_2" : "value_2"}).cookies
         self.assertEqual(len(cookies_2), 1)
         self.assertEqual(cookies_2.get("key_2"), "value_2")
 
         # Use the session and make sure that the received cookie is not used in subsequent calls
         s = requests.session()
-        s.get(httpbin('cookies', 'set', 'key', 'value'), store_cookies = False)
+        s.get(httpbin('cookies', 'set', 'key', 'value'), config = config)
         r = s.get(httpbin('cookies'))
         self.assertEqual(json.loads(r.text)['cookies'], {})
 

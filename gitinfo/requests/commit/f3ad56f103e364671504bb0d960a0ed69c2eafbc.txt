commit f3ad56f103e364671504bb0d960a0ed69c2eafbc
Author: Pierre Chapuis <catwell@archlinux.us>
Date:   Thu Apr 12 17:49:48 2012 +0200

    Encode Multipart Post data at Request creation
    
    This fixes #298 (File upload not working with
    HTTP digest authentication)

diff --git a/requests/models.py b/requests/models.py
index 402adb6f..c3be7bad 100644
--- a/requests/models.py
+++ b/requests/models.py
@@ -80,7 +80,7 @@ class Request(object):
         self.headers = dict(headers or [])
 
         #: Dictionary of files to multipart upload (``{filename: content}``).
-        self.files = files
+        self.files = None
 
         #: HTTP Method to use.
         self.method = method
@@ -114,6 +114,7 @@ class Request(object):
 
         self.data, self._enc_data = self._encode_params(data)
         self.params, self._enc_params = self._encode_params(params)
+        self.files, self._enc_files = self._encode_files(files)
 
         #: :class:`Response <Response>` instance, containing
         #: content and metadata of HTTP Response, once :attr:`sent <send>`.
@@ -329,6 +330,29 @@ class Request(object):
         else:
             return data, data
 
+    def _encode_files(self,files):
+
+        if (not files) or isinstance(self.data, str):
+            return None, None
+
+        try:
+            fields = self.data.copy()
+        except AttributeError:
+            fields = dict(self.data)
+
+        for (k, v) in list(files.items()):
+            # support for explicit filename
+            if isinstance(v, (tuple, list)):
+                fn, fp = v
+            else:
+                fn = guess_filename(v) or k
+                fp = v
+            fields.update({k: (fn, fp.read())})
+
+        (body, content_type) = encode_multipart_formdata(fields)
+
+        return files, (body, content_type)
+
     @property
     def full_url(self):
         """Build the actual URL to use."""
@@ -447,26 +471,7 @@ class Request(object):
 
         # Multi-part file uploads.
         if self.files:
-            if not isinstance(self.data, str):
-
-                try:
-                    fields = self.data.copy()
-                except AttributeError:
-                    fields = dict(self.data)
-
-                for (k, v) in list(self.files.items()):
-                    # support for explicit filename
-                    if isinstance(v, (tuple, list)):
-                        fn, fp = v
-                    else:
-                        fn = guess_filename(v) or k
-                        fp = v
-                    fields.update({k: (fn, fp.read())})
-
-                (body, content_type) = encode_multipart_formdata(fields)
-            else:
-                pass
-                # TODO: Conflict?
+            (body, content_type) = self._enc_files
         else:
             if self.data:
 
@@ -763,7 +768,7 @@ class Response(object):
             except AttributeError:
                 self._content = None
 
-        self._content_consumed = True        
+        self._content_consumed = True
         return self._content
 
     def _detected_encoding(self):

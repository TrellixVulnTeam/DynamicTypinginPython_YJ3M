commit b6d6894f539f3568597901be354a54da7606062b
Author: Brett Higgins <brett.higgins@gmail.com>
Date:   Tue May 17 11:45:12 2016 -0400

    Allow graceful interruption of testserver.Server
    
    So that failing tests don't cause the server thread to hang
    indefinitely, waiting for connections that will never come.
    
    Rationale for suppressing error/traceback from interrupted
    _accept_connection in testserver.Server:
    https://gist.github.com/brettdh/b6e741227b2297f19d2118077f14dfa5
    
    * Move server socket close to just before join
    
    This way it handles the no-connections, no-exceptions case
    as well as the exception case. If the server thread doesn't
    exit by itself within 5 seconds of the context manager exit,
    the accept will be interrupted.
    
    * Address feedback
    
    - pytest.raises rather than except:pass
    - Move socket create/bind back to run()
    - Timeout on accepting connections

diff --git a/tests/test_testserver.py b/tests/test_testserver.py
index 027f8e50..9a35460e 100644
--- a/tests/test_testserver.py
+++ b/tests/test_testserver.py
@@ -135,3 +135,26 @@ class TestTestServer:
             sock.close()
             
         assert server.handler_results[0] == data
+
+    def test_server_finishes_on_error(self):
+        """the server thread exits even if an exception exits the context manager"""
+        server = Server.basic_response_server()
+        with pytest.raises(Exception):
+            with server:
+                raise Exception()
+
+        assert len(server.handler_results) == 0
+
+        # if the server thread fails to finish, the test suite will hang
+        # and get killed by the jenkins timeout.
+
+    def test_server_finishes_when_no_connections(self):
+        """the server thread exits even if there are no connections"""
+        server = Server.basic_response_server()
+        with server:
+            pass
+
+        assert len(server.handler_results) == 0
+
+        # if the server thread fails to finish, the test suite will hang
+        # and get killed by the jenkins timeout.
diff --git a/tests/testserver/server.py b/tests/testserver/server.py
index 5be478b3..7a92c87d 100644
--- a/tests/testserver/server.py
+++ b/tests/testserver/server.py
@@ -60,17 +60,17 @@ class Server(threading.Thread):
 
     def run(self):
         try:
-            sock = self._create_socket_and_bind()
+            self.server_sock = self._create_socket_and_bind()
             # in case self.port = 0
-            self.port = sock.getsockname()[1]
+            self.port = self.server_sock.getsockname()[1]
             self.ready_event.set()
-            self._handle_requests(sock)
+            self._handle_requests()
 
             if self.wait_to_close_event:
                 self.wait_to_close_event.wait(self.WAIT_EVENT_TIMEOUT)
         finally:
             self.ready_event.set() # just in case of exception
-            sock.close()
+            self._close_server_sock_ignore_errors()
             self.stop_event.set()
 
     def _create_socket_and_bind(self):
@@ -79,13 +79,32 @@ class Server(threading.Thread):
         sock.listen(0)
         return sock
 
-    def _handle_requests(self, server_sock):
+    def _close_server_sock_ignore_errors(self):
+        try:
+            self.server_sock.close()
+        except IOError:
+            pass
+
+    def _handle_requests(self):
         for _ in range(self.requests_to_handle):
-            sock = server_sock.accept()[0]
+            sock = self._accept_connection()
+            if not sock:
+                break
+
             handler_result = self.handler(sock)
 
             self.handler_results.append(handler_result)
 
+    def _accept_connection(self):
+        try:
+            ready, _, _ = select.select([self.server_sock], [], [], self.WAIT_EVENT_TIMEOUT)
+            if not ready:
+                return None
+
+            return self.server_sock.accept()[0]
+        except (select.error, socket.error):
+            return None
+
     def __enter__(self):
         self.start()
         self.ready_event.wait(self.WAIT_EVENT_TIMEOUT)
@@ -99,4 +118,8 @@ class Server(threading.Thread):
                 # avoid server from waiting for event timeouts
                 # if an exception is found in the main thread
                 self.wait_to_close_event.set()
+
+        # ensure server thread doesn't get stuck waiting for connections
+        self._close_server_sock_ignore_errors()
+        self.join()
         return False # allow exceptions to propagate

commit 69e7e94c4ce349b243d8dde82a69166d8792ab81
Author: Kenneth Reitz <me@kennethreitz.com>
Date:   Sat Nov 12 07:35:55 2011 -0800

    updated urllib3

diff --git a/requests/packages/__init__.py b/requests/packages/__init__.py
index ab2669e8..d62c4b71 100644
--- a/requests/packages/__init__.py
+++ b/requests/packages/__init__.py
@@ -1,3 +1,3 @@
 from __future__ import absolute_import
 
-from . import poster
+from . import urllib3
diff --git a/requests/packages/urllib3/__init__.py b/requests/packages/urllib3/__init__.py
old mode 100644
new mode 100755
index 7a2d0186..20b1fb4e
--- a/requests/packages/urllib3/__init__.py
+++ b/requests/packages/urllib3/__init__.py
@@ -10,7 +10,7 @@ urllib3 - Thread-safe connection pooling and re-using.
 
 __author__ = 'Andrey Petrov (andrey.petrov@shazow.net)'
 __license__ = 'MIT'
-__version__ = '1.0.1'
+__version__ = '1.0.2'
 
 
 from .connectionpool import (
diff --git a/requests/packages/urllib3/_collections.py b/requests/packages/urllib3/_collections.py
old mode 100644
new mode 100755
index bd01da33..e73f0ed4
--- a/requests/packages/urllib3/_collections.py
+++ b/requests/packages/urllib3/_collections.py
@@ -4,8 +4,9 @@
 # This module is part of urllib3 and is released under
 # the MIT License: http://www.opensource.org/licenses/mit-license.php
 
-from collections import MutableMapping, deque
+from collections import deque, MutableMapping
 
+from threading import RLock
 
 __all__ = ['RecentlyUsedContainer']
 
@@ -24,9 +25,6 @@ class RecentlyUsedContainer(MutableMapping):
     away the least-recently-used keys beyond ``maxsize``.
     """
 
-    # TODO: Make this threadsafe. _prune_invalidated_entries should be the
-    # only real pain-point for this.
-
     # If len(self.access_log) exceeds self._maxsize * CLEANUP_FACTOR, then we
     # will attempt to cleanup the invalidated entries in the access_log
     # datastructure during the next 'get' operation.
@@ -39,6 +37,7 @@ class RecentlyUsedContainer(MutableMapping):
 
         # We use a deque to to store our keys ordered by the last access.
         self.access_log = deque()
+        self.access_log_lock = RLock()
 
         # We look up the access log entry by the key to invalidate it so we can
         # insert a new authorative entry at the head without having to dig and
@@ -48,43 +47,58 @@ class RecentlyUsedContainer(MutableMapping):
         # Trigger a heap cleanup when we get past this size
         self.access_log_limit = maxsize * self.CLEANUP_FACTOR
 
-    def _push_entry(self, key):
-        "Push entry onto our access log, invalidate the old entry if exists."
-        # Invalidate old entry if it exists
+    def _invalidate_entry(self, key):
+        "If exists: Invalidate old entry and return it."
         old_entry = self.access_lookup.get(key)
         if old_entry:
             old_entry.is_valid = False
 
-        new_entry = AccessEntry(key)
+        return old_entry
 
+    def _push_entry(self, key):
+        "Push entry onto our access log, invalidate the old entry if exists."
+        self._invalidate_entry(key)
+
+        new_entry = AccessEntry(key)
         self.access_lookup[key] = new_entry
+
+        self.access_log_lock.acquire()
         self.access_log.appendleft(new_entry)
+        self.access_log_lock.release()
 
     def _prune_entries(self, num):
         "Pop entries from our access log until we popped ``num`` valid ones."
         while num > 0:
+            self.access_log_lock.acquire()
             p = self.access_log.pop()
+            self.access_log_lock.release()
 
             if not p.is_valid:
                 continue # Invalidated entry, skip
 
-            del self._container[p.key]
-            del self.access_lookup[p.key]
+            self._container.pop(p.key, None)
+            self.access_lookup.pop(p.key, None)
             num -= 1
 
     def _prune_invalidated_entries(self):
         "Rebuild our access_log without the invalidated entries."
+        self.access_log_lock.acquire()
         self.access_log = deque(e for e in self.access_log if e.is_valid)
+        self.access_log_lock.release()
 
     def _get_ordered_access_keys(self):
-        # Used for testing
-        return [e.key for e in self.access_log if e.is_valid]
+        "Return ordered access keys for inspection. Used for testing."
+        self.access_log_lock.acquire()
+        r = [e.key for e in self.access_log if e.is_valid]
+        self.access_log_lock.release()
+
+        return r
 
     def __getitem__(self, key):
         item = self._container.get(key)
 
         if not item:
-            return
+            raise KeyError(key)
 
         # Insert new entry with new high priority, also implicitly invalidates
         # the old entry.
@@ -108,7 +122,7 @@ class RecentlyUsedContainer(MutableMapping):
     def __delitem__(self, key):
         self._invalidate_entry(key)
         del self._container[key]
-        del self._access_lookup[key]
+        del self.access_lookup[key]
 
     def __len__(self):
         return self._container.__len__()
diff --git a/requests/packages/urllib3/connectionpool.py b/requests/packages/urllib3/connectionpool.py
old mode 100644
new mode 100755
diff --git a/requests/packages/urllib3/contrib/__init__.py b/requests/packages/urllib3/contrib/__init__.py
old mode 100644
new mode 100755
diff --git a/requests/packages/urllib3/contrib/ntlmpool.py b/requests/packages/urllib3/contrib/ntlmpool.py
old mode 100644
new mode 100755
diff --git a/requests/packages/urllib3/exceptions.py b/requests/packages/urllib3/exceptions.py
old mode 100644
new mode 100755
diff --git a/requests/packages/urllib3/filepost.py b/requests/packages/urllib3/filepost.py
old mode 100644
new mode 100755
diff --git a/requests/packages/urllib3/poolmanager.py b/requests/packages/urllib3/poolmanager.py
old mode 100644
new mode 100755
index 622789e5..c08e327f
--- a/requests/packages/urllib3/poolmanager.py
+++ b/requests/packages/urllib3/poolmanager.py
@@ -108,7 +108,7 @@ class PoolManager(RequestMethods):
         return conn.urlopen(method, url, assert_same_host=False, **kw)
 
 
-class ProxyManager(object):
+class ProxyManager(RequestMethods):
     """
     Given a ConnectionPool to a proxy, the ProxyManager's ``urlopen`` method
     will make requests to any url through the defined proxy.
diff --git a/requests/packages/urllib3/request.py b/requests/packages/urllib3/request.py
old mode 100644
new mode 100755
diff --git a/requests/packages/urllib3/response.py b/requests/packages/urllib3/response.py
old mode 100644
new mode 100755

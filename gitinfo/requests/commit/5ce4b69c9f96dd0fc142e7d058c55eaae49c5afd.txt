commit 5ce4b69c9f96dd0fc142e7d058c55eaae49c5afd
Author: Kenneth Reitz <me@kennethreitz.com>
Date:   Sat Dec 15 05:17:37 2012 -0500

    working!!!

diff --git a/requests/adapters.py b/requests/adapters.py
index d4165721..002a8d40 100644
--- a/requests/adapters.py
+++ b/requests/adapters.py
@@ -8,9 +8,21 @@ This module contains the transport adapters that Requests uses to define
 and maintain connections.
 """
 import os
+from .models import Response
 from .packages.urllib3.poolmanager import PoolManager
 from .utils import DEFAULT_CA_BUNDLE_PATH
 
+import socket
+from .structures import CaseInsensitiveDict
+from .packages.urllib3.exceptions import MaxRetryError, LocationParseError
+from .packages.urllib3.exceptions import TimeoutError
+from .packages.urllib3.exceptions import SSLError as _SSLError
+from .packages.urllib3.exceptions import HTTPError as _HTTPError
+from .packages.urllib3 import connectionpool, poolmanager
+from .packages.urllib3.filepost import encode_multipart_formdata
+from .exceptions import (
+ConnectionError, HTTPError, RequestException, Timeout, TooManyRedirects,
+URLRequired, SSLError, MissingSchema, InvalidSchema, InvalidURL)
 
 DEFAULT_POOLSIZE = 10
 DEFAULT_RETRIES = 0
@@ -22,8 +34,8 @@ class BaseAdapter(object):
     def __init__(self):
         super(BaseAdapter, self).__init__()
 
-    def send(self):
-        raise NotImplementedError
+    # def send(self):
+    #     raise NotImplementedError
 
     def close(self):
         raise NotImplementedError
@@ -44,13 +56,13 @@ class HTTPAdapter(BaseAdapter):
     def init_poolmanager(self, connections, maxsize):
         self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize)
 
-    def cert_verify(self, conn, verify, cert):
-        if url.startswith('https') and self.verify:
+    def cert_verify(self, conn, url, verify, cert):
+        if url.startswith('https') and verify:
 
             cert_loc = None
 
             # Allow self-specified cert location.
-            if self.verify is not True:
+            if verify is not True:
                 cert_loc = self.verify
 
             # Look for configuration.
@@ -73,12 +85,39 @@ class HTTPAdapter(BaseAdapter):
             conn.cert_reqs = 'CERT_NONE'
             conn.ca_certs = None
 
-        if self.cert:
-            if len(self.cert) == 2:
-                conn.cert_file = self.cert[0]
-                conn.key_file = self.cert[1]
+        if cert:
+            if len(cert) == 2:
+                conn.cert_file = cert[0]
+                conn.key_file = cert[1]
             else:
-                conn.cert_file = self.cert
+                conn.cert_file = cert
+
+    @staticmethod
+    def build_response(req, resp):
+        response = Response()
+
+        # Fallback to None if there's no status_code, for whatever reason.
+        response.status_code = getattr(resp, 'status', None)
+
+        # Make headers case-insensitive.
+        response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))
+
+        # Set encoding.
+        # response.encoding = get_encoding_from_headers(response.headers)
+        response.raw = resp
+
+        if isinstance(req.url, bytes):
+            response.url = req.url.decode('utf-8')
+        else:
+            response.url = req.url
+
+        return response
+        # Add new cookies from the server.
+        # extract_cookies_to_jar(self.cookies, self, resp)
+
+
+
+
 
     def close(self):
         """Dispose of any internal state.
@@ -88,11 +127,49 @@ class HTTPAdapter(BaseAdapter):
         """
         self.poolmanager.clear()
 
-    def send(self, request, timeout, verify, cert):
+    def send(self, request, prefetch=True, timeout=None, verify=True, cert=None):
         """Sends PreparedRequest object. Returns Response object."""
 
-        conn = self._poolmanager.connection_from_url(request.url)
-        self.cert_verify(conn, verify, cert)
+        conn = self.poolmanager.connection_from_url(request.url)
+        self.cert_verify(conn, request.url, verify, cert)
+
+        try:
+            # Send the request.
+            resp = conn.urlopen(
+                method=request.method,
+                url=request.path_url,
+                body=request.body,
+                headers=request.headers,
+                redirect=False,
+                assert_same_host=False,
+                preload_content=False,
+                decode_content=False,
+                retries=self.max_retries,
+                timeout=timeout,
+            )
+
+        except socket.error as sockerr:
+            raise ConnectionError(sockerr)
+
+        except MaxRetryError as e:
+            raise ConnectionError(e)
+
+        except (_SSLError, _HTTPError) as e:
+            if isinstance(e, _SSLError):
+                raise SSLError(e)
+            elif isinstance(e, TimeoutError):
+                raise Timeout(e)
+            else:
+                raise Timeout('Request timed out.')
+
+        r = self.build_response(request, resp)
+
+        if prefetch:
+            r.content
+
+        return r
+
+
 
 
 
diff --git a/requests/models.py b/requests/models.py
index 3d2fe963..aaaf1ef4 100644
--- a/requests/models.py
+++ b/requests/models.py
@@ -513,13 +513,13 @@ class OldRequest(object):
             if resp:
 
                 # Fallback to None if there's no status_code, for whatever reason.
-                response.status_code = getattr(resp, 'status', None)
+                # response.status_code = getattr(resp, 'status', None)
 
                 # Make headers case-insensitive.
-                response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))
+                # response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))
 
                 # Set encoding.
-                response.encoding = get_encoding_from_headers(response.headers)
+                # response.encoding = get_encoding_from_headers(response.headers)
 
                 # Add new cookies from the server.
                 extract_cookies_to_jar(self.cookies, self, resp)
@@ -546,7 +546,7 @@ class OldRequest(object):
         history = []
 
         r = build(resp)
-
+        # TODO: session level shit
         if r.status_code in REDIRECT_STATI and not self.redirect:
 
             while (('location' in r.headers and r.status_code in REDIRECT_STATI) and
@@ -775,45 +775,45 @@ class OldRequest(object):
         if not self.sent or anyway:
 
             # Skip if 'cookie' header is explicitly set.
-            if 'cookie' not in self.headers:
-                cookie_header = get_cookie_header(self.cookies, self)
-                if cookie_header is not None:
-                    self.headers['Cookie'] = cookie_header
+            # if 'cookie' not in self.headers:
+            #     cookie_header = get_cookie_header(self.cookies, self)
+            #     if cookie_header is not None:
+            #         self.headers['Cookie'] = cookie_header
 
             # Pre-send hook.
             r = dispatch_hook('pre_send', self.hooks, self)
             self.__dict__.update(r.__dict__)
 
             # catch urllib3 exceptions and throw Requests exceptions
-            try:
-                # Send the request.
-                r = conn.urlopen(
-                    method=self.method,
-                    url=self.path_url,
-                    body=body,
-                    headers=self.headers,
-                    redirect=False,
-                    assert_same_host=False,
-                    preload_content=False,
-                    decode_content=False,
-                    retries=self.config.get('max_retries', 0),
-                    timeout=self.timeout,
-                )
-                self.sent = True
-
-            except socket.error as sockerr:
-                raise ConnectionError(sockerr)
-
-            except MaxRetryError as e:
-                raise ConnectionError(e)
-
-            except (_SSLError, _HTTPError) as e:
-                if isinstance(e, _SSLError):
-                    raise SSLError(e)
-                elif isinstance(e, TimeoutError):
-                    raise Timeout(e)
-                else:
-                    raise Timeout('Request timed out.')
+            # try:
+            #     # Send the request.
+            #     r = conn.urlopen(
+            #         method=self.method,
+            #         url=self.path_url,
+            #         body=body,
+            #         headers=self.headers,
+            #         redirect=False,
+            #         assert_same_host=False,
+            #         preload_content=False,
+            #         decode_content=False,
+            #         retries=self.config.get('max_retries', 0),
+            #         timeout=self.timeout,
+            #     )
+            #     self.sent = True
+
+            # except socket.error as sockerr:
+            #     raise ConnectionError(sockerr)
+
+            # except MaxRetryError as e:
+            #     raise ConnectionError(e)
+
+            # except (_SSLError, _HTTPError) as e:
+            #     if isinstance(e, _SSLError):
+            #         raise SSLError(e)
+            #     elif isinstance(e, TimeoutError):
+            #         raise Timeout(e)
+            #     else:
+            #         raise Timeout('Request timed out.')
 
             # build_response can throw TooManyRedirects
             self._build_response(r)

commit 96cd8e9ca0b6953794b9b3244b244dd34f975544
Author: Josh Imhoff <joshimhoff13@gmail.com>
Date:   Mon May 21 20:14:12 2012 -0400

    Wrote tests for new CookieJar functionality and made them pass.

diff --git a/requests/cookies.py b/requests/cookies.py
index bc789f1a..4eab64c9 100644
--- a/requests/cookies.py
+++ b/requests/cookies.py
@@ -141,13 +141,12 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):
     Unlike a regular CookieJar, this class is pickleable.
     """
 
-    # TODO test, test, test
     def get(self, name, default=None, domain=None, path=None):
         """Dict-like get() that also supports optional domain and path args in
         order to resolve naming collisions from using one cookie jar over
         multiple domains. Caution: operation is O(n), not O(1)."""
         try:
-            return self._find(name, domain, path)
+            return self._find_no_duplicates(name, domain, path)
         except KeyError:
             return default
 
@@ -167,7 +166,7 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):
         self.set_cookie(c)
         return c
 
-    def keys():
+    def keys(self):
         """Dict-like keys() that returns a list of names of cookies from the jar.
         See values() and items()."""
         keys = []
@@ -175,21 +174,21 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):
             keys.append(cookie.name)
         return keys
 
-    def values():
+    def values(self):
         """Dict-like values() that returns a list of values of cookies from the jar.
         See keys() and items()."""
         values = []
         for cookie in iter(self):
-            values.append(cookie.values)
+            values.append(cookie.value)
         return values
     
-    def items():
+    def items(self):
         """Dict-like items() that returns a list of name-value tuples from the jar.
         See keys() and values(). Allows client-code to call "dict(RequestsCookieJar)
         and get a vanilla python dict of key value pairs."""
         items = []
         for cookie in iter(self):
-            items.append((cookies.name, cookie.values))
+            items.append((cookie.name, cookie.value))
         return items
 
     def list_domains(self):
@@ -208,11 +207,23 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):
                 paths.append(cookie.path)
         return paths
 
+    def multiple_domains(self):
+        """Returns True if there are multiple domains in the jar.
+        Returns False otherwise."""
+        domains = []
+        for cookie in iter(self):
+            if cookie.domain is not None and cookie.domain in domains:
+                return True
+            domains.append(cookie.domain)
+        return False # there is only one domain in jar
+
     def get_dict(self, domain=None, path=None):
         """Takes as an argument an optional domain and path and returns a plain old
         Python dict of name-value pairs of cookies that meet the requirements."""
         dictionary = {}
         for cookie in iter(self):
+            print path
+            print cookie.path
             if (domain == None or cookie.domain == domain) and (path == None 
                                                 or cookie.path == path):
                 dictionary[cookie.name] = cookie.value
@@ -222,7 +233,7 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):
         """Dict-like __getitem__() for compatibility with client code. Throws exception
         if there are more than one cookie with name. In that case, use the more
         explicit get() method instead. Caution: operation is O(n), not O(1)."""
-        return self._find(name)
+        return self._find_no_duplicates(name)
 
     def __setitem__(self, name, value):
         """Dict-like __setitem__ for compatibility with client code. Throws exception
@@ -235,10 +246,23 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):
         remove_cookie_by_name(self, name)
 
     def _find(self, name, domain=None, path=None):
-        """Requests uses this method internally to find cookies. Takes as args name 
-        and optional domain and path. Returns a cookie.value. Throws KeyError
-        if cookie is not found and CookieConflictError if there are multiple cookies
-        that match name and optionally domain and path."""
+        """Requests uses this method internally to get cookie values. Takes as args name 
+        and optional domain and path. Returns a cookie.value. If there are conflicting cookies,
+        _find arbitrarily chooses one. See _find_no_duplicates if you want an exception thrown
+        if there are conflicting cookies."""
+        for cookie in iter(self):
+            if cookie.name == name:
+                if domain is None or cookie.domain == domain:
+                    if path is None or cookie.path == path:
+                        return cookie.value
+
+        raise KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))
+
+    def _find_no_duplicates(self, name, domain=None, path=None):
+        """__get_item__ and get call _find_no_duplicates -- never used in Requests internally. 
+        Takes as args name and optional domain and path. Returns a cookie.value. 
+        Throws KeyError if cookie is not found and CookieConflictError if there are 
+        multiple cookies that match name and optionally domain and path."""
         toReturn = None
         for cookie in iter(self):
             if cookie.name == name:
@@ -252,24 +276,15 @@ class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):
             return toReturn
         raise KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))
 
-    def _multipleDomains(self):
-        """Returns True if there are multiple domains in the jar.
-        Returns False otherwise."""
-        domains = []
-        for cookie in iter(self):
-            if cookie.domain is not None and cookie.domain in domains:
-                return True
-            domains.append(cookie.domain)
-        return False # there is only one domain in jar
-
-    # TODO docstrings
     def __getstate__(self):
+        """Unlike a normal CookieJar, this class is pickleable."""
         state = self.__dict__.copy()
         # remove the unpickleable RLock object
         state.pop('_cookies_lock')
         return state
 
     def __setstate__(self, state):
+        """Unlike a normal CookieJar, this class is pickleable."""
         self.__dict__.update(state)
         if '_cookies_lock' not in self.__dict__:
             self._cookies_lock = threading.RLock()
diff --git a/tests/test_cookies.py b/tests/test_cookies.py
index 9cb97ea6..bdc9172a 100755
--- a/tests/test_cookies.py
+++ b/tests/test_cookies.py
@@ -24,6 +24,7 @@ class CookieTests(TestBaseMixin, unittest.TestCase):
 
         # test deprecated dictionary interface
         self.assertEqual(r.cookies['myname'], 'myvalue')
+        self.assertEqual(r.cookies.get('myname'), 'myvalue')
         # test CookieJar interface
         jar = r.cookies
         self.assertEqual(len(jar), 1)
@@ -122,6 +123,38 @@ class CookieTests(TestBaseMixin, unittest.TestCase):
         r = s.get(httpbin('cookies'))
         self.assertEqual(json.loads(r.text)['cookies'], {})
 
+    def test_jar_utility_functions(self):
+        """Test utility functions such as list_domains, list_paths, multiple_domains."""
+        r = requests.get("http://github.com")
+        c = r.cookies
+        # github should send us cookies
+        self.assertTrue(len(c) >= 1)
+        self.assertEqual(len(c), len(r.cookies.keys()))
+        self.assertEqual(len(c), len(r.cookies.values()))
+        self.assertEqual(len(c), len(r.cookies.items()))
+        
+        # domain and path utility functions
+        domain = r.cookies.list_domains()[0]
+        path = r.cookies.list_paths()[0]
+        self.assertEqual(dict(r.cookies), r.cookies.get_dict(domain=domain, path=path))
+        self.assertEqual(len(r.cookies.list_domains()), 1)
+        self.assertEqual(len(r.cookies.list_paths()), 1)
+        self.assertFalse(r.cookies.multiple_domains())
+
+    def test_convert_jar_to_dict(self):
+        """Test that keys, values, and items are defined and that we can convert
+        cookie jars to plain old Python dicts."""
+        r = requests.get(httpbin('cookies', 'set', 'myname', 'myvalue'))
+
+        # test keys, values, and items
+        self.assertEqual(r.cookies.keys(), ['myname'])
+        self.assertEqual(r.cookies.values(), ['myvalue'])
+        self.assertEqual(r.cookies.items(), [('myname','myvalue')])
+        
+        # test if we can convert jar to dict
+        dictOfCookies = dict(r.cookies)
+        self.assertEqual(dictOfCookies, {'myname':'myvalue'})
+        self.assertEqual(dictOfCookies, r.cookies.get_dict())
 
 class LWPCookieJarTest(TestBaseMixin, unittest.TestCase):
     """Check store/load of cookies to FileCookieJar's, specifically LWPCookieJar's."""

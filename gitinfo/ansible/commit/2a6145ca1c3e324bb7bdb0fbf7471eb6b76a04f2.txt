commit 2a6145ca1c3e324bb7bdb0fbf7471eb6b76a04f2
Author: Brian Coca <bcoca@ansible.com>
Date:   Tue Feb 21 16:45:57 2017 -0500

    prep for role passthrough instead of detection
    
    (cherry picked from commit 2125a23f2ab0903065a13f9ee68ae43ed348d6fb)

diff --git a/lib/ansible/parsing/dataloader.py b/lib/ansible/parsing/dataloader.py
index 2058a3d694..647d430e1c 100644
--- a/lib/ansible/parsing/dataloader.py
+++ b/lib/ansible/parsing/dataloader.py
@@ -22,12 +22,11 @@ __metaclass__ = type
 import copy
 import os
 import json
-import subprocess
 import tempfile
 from yaml import YAMLError
 
 from ansible.compat.six import text_type, string_types
-from ansible.errors import AnsibleFileNotFound, AnsibleParserError, AnsibleError
+from ansible.errors import AnsibleFileNotFound, AnsibleParserError
 from ansible.errors.yaml_strings import YAML_SYNTAX_ERROR
 from ansible.module_utils.basic import is_executable
 from ansible.module_utils._text import to_bytes, to_native, to_text
@@ -227,7 +226,7 @@ class DataLoader():
             basedir = to_text(self._basedir, errors='surrogate_or_strict')
             return os.path.abspath(os.path.join(basedir, given))
 
-    def path_dwim_relative(self, path, dirname, source):
+    def path_dwim_relative(self, path, dirname, source, is_role=False):
         '''
         find one file in either a role or playbook dir with or without
         explicitly named dirname subdirs
@@ -247,12 +246,14 @@ class DataLoader():
             search.append(os.path.join(path, dirname, source))
             basedir = unfrackpath(path)
 
-            # is it a role and if so make sure you get correct base path
+            #FIXME: this role detection will not work with alternate/missing main.yml
+            # is it a role and if so make sure you get correct base path 
             if path.endswith('tasks') and os.path.exists(to_bytes(os.path.join(path,'main.yml'), errors='surrogate_or_strict')) \
                     or os.path.exists(to_bytes(os.path.join(path,'tasks/main.yml'), errors='surrogate_or_strict')):
-                isrole = True
-                if path.endswith('tasks'):
-                    basedir = unfrackpath(os.path.dirname(path))
+                is_role = True
+
+            if is_role and path.endswith('tasks'):
+                basedir = unfrackpath(os.path.dirname(path))
 
             cur_basedir = self._basedir
             self.set_basedir(basedir)
@@ -277,7 +278,7 @@ class DataLoader():
 
         return candidate
 
-    def path_dwim_relative_stack(self, paths, dirname, source):
+    def path_dwim_relative_stack(self, paths, dirname, source, is_role=False):
         '''
         find one file in first path in stack taking roles into account and adding play basedir as fallback
 
@@ -307,10 +308,11 @@ class DataLoader():
                 b_upath = to_bytes(upath, errors='surrogate_or_strict')
                 b_mydir = os.path.dirname(b_upath)
 
+                # FIXME: this detection fails with non main.yml roles
                 # if path is in role and 'tasks' not there already, add it into the search
-                if b_upath.endswith(b'tasks') and os.path.exists(os.path.join(b_upath, b'main.yml')) \
+                if is_role or (b_upath.endswith(b'tasks') and os.path.exists(os.path.join(b_upath, b'main.yml')) \
                         or os.path.exists(os.path.join(b_upath, b'tasks/main.yml')) \
-                        or os.path.exists(os.path.join(b_mydir, b'tasks/main.yml')):
+                        or os.path.exists(os.path.join(b_mydir, b'tasks/main.yml'))):
                     if b_mydir.endswith(b'tasks'):
                         search.append(os.path.join(os.path.dirname(b_mydir), b_dirname, b_source))
                         search.append(os.path.join(b_mydir, b_source))

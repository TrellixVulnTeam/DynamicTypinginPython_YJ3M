commit 4d4512940ded2688d9be29b415aa2785112e49bd
Author: Pierre-Louis Bonicoli <pierre-louis.bonicoli@gmx.fr>
Date:   Wed Jul 1 17:15:40 2015 +0200

    Fix "AttributeError: 'ActionModule' object has no attribute '_shell'"
    
    '_shell' was removed with commit 2a5fbd85700b719df9c2af22f0ccc61633ee4ac6

diff --git a/lib/ansible/plugins/action/async.py b/lib/ansible/plugins/action/async.py
index 336457b0e5..0c73cd9d5c 100644
--- a/lib/ansible/plugins/action/async.py
+++ b/lib/ansible/plugins/action/async.py
@@ -36,8 +36,8 @@ class ActionModule(ActionBase):
             tmp = self._make_tmp_path()
 
         module_name = self._task.action
-        async_module_path  = self._shell.join_path(tmp, 'async_wrapper')
-        remote_module_path = self._shell.join_path(tmp, module_name)
+        async_module_path  = self._connection._shell.join_path(tmp, 'async_wrapper')
+        remote_module_path = self._connection._shell.join_path(tmp, module_name)
 
         env_string = self._compute_environment_string()
 
@@ -51,7 +51,7 @@ class ActionModule(ActionBase):
         self._transfer_data(async_module_path, async_module_data)
         self._remote_chmod(tmp, 'a+rx', async_module_path)
 
-        argsfile = self._transfer_data(self._shell.join_path(tmp, 'arguments'), json.dumps(self._task.args))
+        argsfile = self._transfer_data(self._connection._shell.join_path(tmp, 'arguments'), json.dumps(self._task.args))
 
         async_limit = self._task.async
         async_jid   = str(random.randint(0, 999999999999))
diff --git a/lib/ansible/plugins/action/copy.py b/lib/ansible/plugins/action/copy.py
index ef80275ec0..e556c80315 100644
--- a/lib/ansible/plugins/action/copy.py
+++ b/lib/ansible/plugins/action/copy.py
@@ -115,8 +115,8 @@ class ActionModule(ActionBase):
 
             # If it's recursive copy, destination is always a dir,
             # explicitly mark it so (note - copy module relies on this).
-            if not self._shell.path_has_trailing_slash(dest):
-                dest = self._shell.join_path(dest, '')
+            if not self._connection._shell.path_has_trailing_slash(dest):
+                dest = self._connection._shell.join_path(dest, '')
         else:
             source_files.append((source, os.path.basename(source)))
 
@@ -151,10 +151,10 @@ class ActionModule(ActionBase):
             # This is kind of optimization - if user told us destination is
             # dir, do path manipulation right away, otherwise we still check
             # for dest being a dir via remote call below.
-            if self._shell.path_has_trailing_slash(dest):
-                dest_file = self._shell.join_path(dest, source_rel)
+            if self._connection._shell.path_has_trailing_slash(dest):
+                dest_file = self._connection._shell.join_path(dest, source_rel)
             else:
-                dest_file = self._shell.join_path(dest)
+                dest_file = self._connection._shell.join_path(dest)
 
             # Attempt to get the remote checksum
             remote_checksum = self._remote_checksum(tmp, dest_file)
@@ -167,7 +167,7 @@ class ActionModule(ActionBase):
                     return dict(failed=True, msg="can not use content with a dir as dest")
                 else:
                     # Append the relative source location to the destination and retry remote_checksum
-                    dest_file = self._shell.join_path(dest, source_rel)
+                    dest_file = self._connection._shell.join_path(dest, source_rel)
                     remote_checksum = self._remote_checksum(tmp, dest_file)
 
             if remote_checksum != '1' and not force:
diff --git a/lib/ansible/plugins/action/fetch.py b/lib/ansible/plugins/action/fetch.py
index 2123c5b162..bc652265ba 100644
--- a/lib/ansible/plugins/action/fetch.py
+++ b/lib/ansible/plugins/action/fetch.py
@@ -52,7 +52,7 @@ class ActionModule(ActionBase):
         if source is None or dest is None:
             return dict(failed=True, msg="src and dest are required")
 
-        source = self._shell.join_path(source)
+        source = self._connection._shell.join_path(source)
         source = self._remote_expand_user(source, tmp)
 
         # calculate checksum for the remote file
@@ -78,7 +78,7 @@ class ActionModule(ActionBase):
                 pass
 
         # calculate the destination name
-        if os.path.sep not in self._shell.join_path('a', ''):
+        if os.path.sep not in self._connection._shell.join_path('a', ''):
             source_local = source.replace('\\', '/')
         else:
             source_local = source
diff --git a/lib/ansible/plugins/action/patch.py b/lib/ansible/plugins/action/patch.py
index 31dbd31fa4..f0dbdedf05 100644
--- a/lib/ansible/plugins/action/patch.py
+++ b/lib/ansible/plugins/action/patch.py
@@ -47,7 +47,7 @@ class ActionModule(ActionBase):
         if tmp is None or "-tmp-" not in tmp:
             tmp = self._make_tmp_path()
 
-        tmp_src = self._shell.join_path(tmp, os.path.basename(src))
+        tmp_src = self._connection._shell.join_path(tmp, os.path.basename(src))
         self._connection.put_file(src, tmp_src)
 
         if self._connection_info.become and self._connection_info.become_user != 'root':
diff --git a/lib/ansible/plugins/action/script.py b/lib/ansible/plugins/action/script.py
index 7c24845515..b3b95db9f8 100644
--- a/lib/ansible/plugins/action/script.py
+++ b/lib/ansible/plugins/action/script.py
@@ -71,7 +71,7 @@ class ActionModule(ActionBase):
             source = self._loader.path_dwim(source)
 
         # transfer the file to a remote tmp location
-        tmp_src = self._shell.join_path(tmp, os.path.basename(source))
+        tmp_src = self._connection._shell.join_path(tmp, os.path.basename(source))
         self._connection.put_file(source, tmp_src)
 
         sudoable = True
diff --git a/lib/ansible/plugins/action/template.py b/lib/ansible/plugins/action/template.py
index e841ab939c..0b93f559c3 100644
--- a/lib/ansible/plugins/action/template.py
+++ b/lib/ansible/plugins/action/template.py
@@ -121,8 +121,8 @@ class ActionModule(ActionBase):
             #            dest_contents = base64.b64decode(dest_contents)
             #        else:
             #            raise Exception("unknown encoding, failed: %s" % dest_result.result)
- 
-            xfered = self._transfer_data(self._shell.join_path(tmp, 'source'), resultant)
+
+            xfered = self._transfer_data(self._connection._shell.join_path(tmp, 'source'), resultant)
 
             # fix file permissions when the copy is done as a different user
             if self._connection_info.become and self._connection_info.become_user != 'root':

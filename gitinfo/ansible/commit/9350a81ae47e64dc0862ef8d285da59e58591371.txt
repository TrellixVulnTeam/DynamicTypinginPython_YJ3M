commit 9350a81ae47e64dc0862ef8d285da59e58591371
Author: Toshio Kuratomi <a.badger@gmail.com>
Date:   Wed Jun 20 06:35:27 2018 -0700

    Port modules away from __file__
    
    * __file__ won't work if we want to invoke modules via -m or if we
      figure out how to keep modules from hitting the disk with pipelining.
    * module.tmpdir is the new way to place a file where it will be cleaned
      automatically.
    
    Change format string to not depend on __file__:
    
    * cloud/amazon/ec2_elb_lb.py
    * cloud/amazon/elb_classic_lb.py
    
    Use module.tempdir:
    
    * packaging/os/apt.py
    * files/unarchive.py

diff --git a/changelogs/fragments/cleanup__file__.yaml b/changelogs/fragments/cleanup__file__.yaml
new file mode 100644
index 0000000000..a6aaa6c2a1
--- /dev/null
+++ b/changelogs/fragments/cleanup__file__.yaml
@@ -0,0 +1,6 @@
+---
+minor_changes:
+- The apt, ec2_elb_lb, elb_classic_lb, and unarchive modules have been ported
+  away from using __file__.  This is futureproofing as__file__ won't work if we
+  switch to using python -m to invoke modules in the future or if we figure out
+  a way to make a module never touch disk for pipelining purposes.
diff --git a/lib/ansible/modules/cloud/amazon/ec2_elb_lb.py b/lib/ansible/modules/cloud/amazon/ec2_elb_lb.py
index 2ba440036b..cf78659b5d 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_elb_lb.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_elb_lb.py
@@ -980,7 +980,7 @@ class ElbManager(object):
             self.elb_conn.modify_lb_attribute(self.name, 'ConnectingSettings', attributes.connecting_settings)
 
     def _policy_name(self, policy_type):
-        return __file__.split('/')[-1].split('.')[0].replace('_', '-') + '-' + policy_type
+        return 'ec2-elb-lb-{0}'.format(to_native(policy_type, errors='surrogate_or_strict'))
 
     def _create_policy(self, policy_param, policy_meth, policy):
         getattr(self.elb_conn, policy_meth)(policy_param, self.elb.name, policy)
diff --git a/lib/ansible/modules/cloud/amazon/elb_classic_lb.py b/lib/ansible/modules/cloud/amazon/elb_classic_lb.py
index 747ea528ef..e3d2cb38f1 100644
--- a/lib/ansible/modules/cloud/amazon/elb_classic_lb.py
+++ b/lib/ansible/modules/cloud/amazon/elb_classic_lb.py
@@ -977,7 +977,7 @@ class ElbManager(object):
             self.elb_conn.modify_lb_attribute(self.name, 'ConnectingSettings', attributes.connecting_settings)
 
     def _policy_name(self, policy_type):
-        return __file__.split('/')[-1].split('.')[0].replace('_', '-') + '-' + policy_type
+        return 'elb-classic-lb-{0}'.format(to_native(policy_type, errors='surrogate_or_strict'))
 
     def _create_policy(self, policy_param, policy_meth, policy):
         getattr(self.elb_conn, policy_meth)(policy_param, self.elb.name, policy)
diff --git a/lib/ansible/modules/files/unarchive.py b/lib/ansible/modules/files/unarchive.py
index e99a3d7e83..8a0bea8849 100644
--- a/lib/ansible/modules/files/unarchive.py
+++ b/lib/ansible/modules/files/unarchive.py
@@ -821,8 +821,7 @@ def main():
             module.fail_json(msg="Source '%s' failed to transfer" % src)
         # If remote_src=true, and src= contains ://, try and download the file to a temp directory.
         elif '://' in src:
-            tempdir = os.path.dirname(os.path.realpath(__file__))
-            package = os.path.join(tempdir, str(src.rsplit('/', 1)[1]))
+            new_src = os.path.join(module.tmpdir, to_native(src.rsplit('/', 1)[1], errors='surrogate_or_strict'))
             try:
                 rsp, info = fetch_url(module, src)
                 # If download fails, raise a proper exception
@@ -830,7 +829,7 @@ def main():
                     raise Exception(info['msg'])
 
                 # open in binary mode for python3
-                f = open(package, 'wb')
+                f = open(new_src, 'wb')
                 # Read 1kb at a time to save on ram
                 while True:
                     data = rsp.read(BUFSIZE)
@@ -841,7 +840,7 @@ def main():
 
                     f.write(data)
                 f.close()
-                src = package
+                src = new_src
             except Exception as e:
                 module.fail_json(msg="Failure downloading %s, %s" % (src, to_native(e)))
         else:
diff --git a/lib/ansible/modules/packaging/os/apt.py b/lib/ansible/modules/packaging/os/apt.py
index 037fdafe65..c5355af139 100644
--- a/lib/ansible/modules/packaging/os/apt.py
+++ b/lib/ansible/modules/packaging/os/apt.py
@@ -847,8 +847,7 @@ def upgrade(m, mode="yes", force=False, default_release=None,
 
 
 def download(module, deb):
-    tempdir = os.path.dirname(__file__)
-    package = os.path.join(tempdir, str(deb.rsplit('/', 1)[1]))
+    package = os.path.join(module.tmpdir, to_native(deb.rsplit('/', 1)[1], errors='surrogate_or_strict'))
     # When downloading a deb, how much of the deb to download before
     # saving to a tempfile (64k)
     BUFSIZE = 65536

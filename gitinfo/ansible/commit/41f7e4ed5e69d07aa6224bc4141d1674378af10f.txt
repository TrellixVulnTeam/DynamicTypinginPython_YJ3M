commit 41f7e4ed5e69d07aa6224bc4141d1674378af10f
Author: Robert Estelle <robert@getpreo.com>
Date:   Thu Nov 13 22:10:23 2014 -0500

    ec2_eip - PEP8 and minor style cleanups.

diff --git a/lib/ansible/modules/cloud/amazon/ec2_eip.py b/lib/ansible/modules/cloud/amazon/ec2_eip.py
index 7258ea0475..2dc2c2bb4a 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_eip.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_eip.py
@@ -37,13 +37,15 @@ options:
     version_added: "1.4"
   reuse_existing_ip_allowed:
     description:
-      - Reuse an EIP that is not associated to an instance (when available), instead of allocating a new one.
+      - Reuse an EIP that is not associated to an instance (when available),'''
+''' instead of allocating a new one.
     required: false
     default: false
     version_added: "1.6"
   wait_timeout:
     description:
-      - how long to wait in seconds for newly provisioned EIPs to become available
+      - how long to wait in seconds for newly provisioned EIPs to become'''
+''' available
     default: 300
     version_added: "1.7"
 
@@ -53,9 +55,9 @@ notes:
    - This module will return C(public_ip) on success, which will contain the
      public IP address associated with the instance.
    - There may be a delay between the time the Elastic IP is assigned and when
-     the cloud instance is reachable via the new address. Use wait_for and pause
-     to delay further playbook execution until the instance is reachable, if
-     necessary.
+     the cloud instance is reachable via the new address. Use wait_for and
+     pause to delay further playbook execution until the instance is reachable,
+     if necessary.
 '''
 
 EXAMPLES = '''
@@ -78,7 +80,8 @@ EXAMPLES = '''
   ec2_eip: state='present'
 
 - name: provision new instances with ec2
-  ec2: keypair=mykey instance_type=c1.medium image=ami-40603AD1 wait=yes group=webserver count=3
+  ec2: keypair=mykey instance_type=c1.medium image=emi-40603AD1 wait=yes'''
+''' group=webserver count=3
   register: ec2
 - name: associate new elastic IPs with each of the instances
   ec2_eip: "instance_id={{ item }}"
@@ -97,10 +100,12 @@ try:
 except ImportError:
     HAS_BOTO = False
 
-wait_timeout = 0  
+wait_timeout = 0
+
 
 def associate_ip_and_instance(ec2, address, instance_id, module):
-    if ip_is_associated_with_instance(ec2, address.public_ip, instance_id, module):
+    if ip_is_associated_with_instance(
+            ec2, address.public_ip, instance_id, module):
         module.exit_json(changed=False, public_ip=address.public_ip)
 
     # If we're in check mode, nothing else to do
@@ -108,21 +113,23 @@ def associate_ip_and_instance(ec2, address, instance_id, module):
         module.exit_json(changed=True)
 
     try:
-        if address.domain == "vpc":
-            res = ec2.associate_address(instance_id, allocation_id=address.allocation_id)
+        if address.domain == 'vpc':
+            res = ec2.associate_address(instance_id,
+                                        allocation_id=address.allocation_id)
         else:
-            res = ec2.associate_address(instance_id, public_ip=address.public_ip)
+            res = ec2.associate_address(instance_id,
+                                        public_ip=address.public_ip)
     except boto.exception.EC2ResponseError, e:
         module.fail_json(msg=str(e))
-    
+
     if res:
         module.exit_json(changed=True, public_ip=address.public_ip)
-    else:
-        module.fail_json(msg="association failed")
+    module.fail_json(msg='association failed')
 
 
 def disassociate_ip_and_instance(ec2, address, instance_id, module):
-    if not ip_is_associated_with_instance(ec2, address.public_ip, instance_id, module):
+    if not ip_is_associated_with_instance(
+            ec2, address.public_ip, instance_id, module):
         module.exit_json(changed=False, public_ip=address.public_ip)
 
     # If we're in check mode, nothing else to do
@@ -131,7 +138,8 @@ def disassociate_ip_and_instance(ec2, address, instance_id, module):
 
     try:
         if address.domain == "vpc":
-            res = ec2.disassociate_address(association_id=address.association_id)
+            res = ec2.disassociate_address(
+                association_id=address.association_id)
         else:
             res = ec2.disassociate_address(public_ip=address.public_ip)
     except boto.exception.EC2ResponseError, e:
@@ -144,7 +152,7 @@ def disassociate_ip_and_instance(ec2, address, instance_id, module):
 
 
 def find_address(ec2, public_ip, module, fail_on_not_found=True):
-    """ Find an existing Elastic IP address """  
+    """ Find an existing Elastic IP address """
     if wait_timeout != 0:
         timeout = time.time() + wait_timeout
         while timeout > time.time():
@@ -152,20 +160,21 @@ def find_address(ec2, public_ip, module, fail_on_not_found=True):
                 addresses = ec2.get_all_addresses([public_ip])
                 break
             except boto.exception.EC2ResponseError, e:
-                if "Address '%s' not found." % public_ip in e.message :
+                if "Address '%s' not found." % public_ip in e.message:
                     if not fail_on_not_found:
                         return None
                 else:
                     module.fail_json(msg=str(e.message))
             time.sleep(5)
-        
+
         if timeout <= time.time():
-            module.fail_json(msg = "wait for EIPs timeout on %s" % time.asctime())    
+            module.fail_json(msg="wait for EIPs timeout on %s" %
+                             time.asctime())
     else:
         try:
             addresses = ec2.get_all_addresses([public_ip])
         except boto.exception.EC2ResponseError, e:
-            if "Address '%s' not found." % public_ip in e.message :
+            if "Address '%s' not found." % public_ip in e.message:
                 if not fail_on_not_found:
                     return None
             module.fail_json(msg=str(e.message))
@@ -178,8 +187,8 @@ def ip_is_associated_with_instance(ec2, public_ip, instance_id, module):
     address = find_address(ec2, public_ip, module)
     if address:
         return address.instance_id == instance_id
-    else:
-        return False
+    return False
+
 
 def instance_is_associated(ec2, instance, module):
     """
@@ -192,6 +201,7 @@ def instance_is_associated(ec2, instance, module):
     eip = find_address(ec2, instance_ip, module, fail_on_not_found=False)
     return (eip and (eip.public_ip == instance_ip))
 
+
 def allocate_address(ec2, domain, module, reuse_existing_ip_allowed):
     """ Allocate a new elastic IP address (when needed) and return it """
     # If we're in check mode, nothing else to do
@@ -199,33 +209,27 @@ def allocate_address(ec2, domain, module, reuse_existing_ip_allowed):
         module.exit_json(change=True)
 
     if reuse_existing_ip_allowed:
-      if domain:
-        domain_filter = { 'domain' : domain }
-      else:
-        domain_filter = { 'domain' : 'standard' }
-      all_addresses = ec2.get_all_addresses(filters=domain_filter)
-
-      unassociated_addresses = filter(lambda a: not a.instance_id, all_addresses)
-      if unassociated_addresses:
-        address = unassociated_addresses[0];
-      else:
-        address = ec2.allocate_address(domain=domain)
-    else:
-      address = ec2.allocate_address(domain=domain)
+        domain_filter = {'domain': domain or 'standard'}
+        all_addresses = ec2.get_all_addresses(filters=domain_filter)
 
-    return address
+        unassociated_addresses = [a for a in all_addresses
+                                  if not a.instance_id]
+        if unassociated_addresses:
+            return unassociated_addresses[0]
+
+    return ec2.allocate_address(domain=domain)
 
 
 def release_address(ec2, public_ip, module):
     """ Release a previously allocated elastic IP address """
-    
+
     address = find_address(ec2, public_ip, module)
-    
+
     # If we're in check mode, nothing else to do
     if module.check_mode:
         module.exit_json(change=True)
-    
-    res = address.release()    
+
+    res = address.release()
     if res:
         module.exit_json(changed=True)
     else:
@@ -234,19 +238,19 @@ def release_address(ec2, public_ip, module):
 
 def find_instance(ec2, instance_id, module):
     """ Attempt to find the EC2 instance and return it """
-    
+
     try:
         reservations = ec2.get_all_reservations(instance_ids=[instance_id])
     except boto.exception.EC2ResponseError, e:
         module.fail_json(msg=str(e))
-    
+
     if len(reservations) == 1:
         instances = reservations[0].instances
         if len(instances) == 1:
             return instances[0]
-    
+
     module.fail_json(msg="could not find instance" + instance_id)
-    
+
 
 def allocate_eip(ec2, eip_domain, module, reuse_existing_ip_allowed, new_eip_timeout):
     # Allocate a new elastic IP
@@ -260,15 +264,15 @@ def allocate_eip(ec2, eip_domain, module, reuse_existing_ip_allowed, new_eip_tim
 def main():
     argument_spec = ec2_argument_spec()
     argument_spec.update(dict(
-            instance_id = dict(required=False),
-            public_ip = dict(required=False, aliases= ['ip']),
-            state = dict(required=False, default='present',
-                         choices=['present', 'absent']),
-            in_vpc = dict(required=False, type='bool', default=False),
-            reuse_existing_ip_allowed = dict(required=False, type='bool', default=False),
-            wait_timeout = dict(default=300),
-        )
-    )
+        instance_id=dict(required=False),
+        public_ip=dict(required=False, aliases=['ip']),
+        state=dict(required=False, default='present',
+                   choices=['present', 'absent']),
+        in_vpc=dict(required=False, type='bool', default=False),
+        reuse_existing_ip_allowed=dict(required=False, type='bool',
+                                       default=False),
+        wait_timeout=dict(default=300),
+    ))
 
     module = AnsibleModule(
         argument_spec=argument_spec,
@@ -284,7 +288,7 @@ def main():
     public_ip = module.params.get('public_ip')
     state = module.params.get('state')
     in_vpc = module.params.get('in_vpc')
-    domain  = "vpc" if in_vpc else None
+    domain = 'vpc' if in_vpc else None
     reuse_existing_ip_allowed = module.params.get('reuse_existing_ip_allowed')
     new_eip_timeout = int(module.params.get('wait_timeout'))
 
@@ -300,6 +304,7 @@ def main():
         if public_ip:
             address = find_address(ec2, public_ip, module)
 
+        # Allocate an IP for instance since no public_ip was provided
         if instance_id and not public_ip:
             instance = find_instance(ec2, instance_id, module)
 
@@ -316,22 +321,22 @@ def main():
             address = allocate_eip(
                 ec2, domain, module, reuse_existing_ip_allowed, new_eip_timeout)
 
-        # Associate address object (provided or allocated) with instance           
+        # Associate address object (provided or allocated) with instance
         associate_ip_and_instance(ec2, address, instance_id, module)
 
     else:
-        #disassociating address from instance
+        # disassociating address from instance
         if instance_id:
             address = find_address(ec2, public_ip, module)
             disassociate_ip_and_instance(ec2, address, instance_id, module)
-        #releasing address
+        # releasing address
         else:
             release_address(ec2, public_ip, module)
 
 
 # import module snippets
-from ansible.module_utils.basic import *
-from ansible.module_utils.ec2 import *
+from ansible.module_utils.basic import *  # noqa
+from ansible.module_utils.ec2 import *  # noqa
 
 if __name__ == '__main__':
     main()

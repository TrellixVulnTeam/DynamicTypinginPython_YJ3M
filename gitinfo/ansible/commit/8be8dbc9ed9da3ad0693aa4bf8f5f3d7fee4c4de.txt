commit 8be8dbc9ed9da3ad0693aa4bf8f5f3d7fee4c4de
Author: Richard C Isaacson <richard.c.isaacson@gmail.com>
Date:   Mon Feb 24 11:11:47 2014 -0600

    Formatting cleanup.

diff --git a/lib/ansible/runner/action_plugins/script.py b/lib/ansible/runner/action_plugins/script.py
index 67b0cac9f0..149be3cc11 100644
--- a/lib/ansible/runner/action_plugins/script.py
+++ b/lib/ansible/runner/action_plugins/script.py
@@ -25,8 +25,8 @@ from ansible import utils
 from ansible import errors
 from ansible.runner.return_data import ReturnData
 
-class ActionModule(object):
 
+class ActionModule(object):
     TRANSFERS_FILES = True
 
     def __init__(self, runner):
@@ -37,7 +37,8 @@ class ActionModule(object):
 
         if self.runner.noop_on_check(inject):
             # in check mode, always skip this module
-            return ReturnData(conn=conn, comm_ok=True, result=dict(skipped=True, msg='check mode not supported for this module'))
+            return ReturnData(conn=conn, comm_ok=True,
+                              result=dict(skipped=True, msg='check mode not supported for this module'))
 
         # extract ansible reserved parameters
         # From library/command keep in sync
@@ -52,68 +53,69 @@ class ActionModule(object):
                 removes = v
         module_args = r.sub("", module_args)
 
-
         if creates:
             # do not run the command if the line contains creates=filename
             # and the filename already exists. This allows idempotence
             # of command executions.
             module_args_tmp = "path=%s" % creates
-            module_return = self.runner._execute_module(conn, tmp, 'stat', module_args_tmp, inject=inject, complex_args=complex_args, persist_files=True)
+            module_return = self.runner._execute_module(conn, tmp, 'stat', module_args_tmp, inject=inject,
+                                                        complex_args=complex_args, persist_files=True)
             stat = module_return.result.get('stat', None)
             if stat and stat.get('exists', False):
                 return ReturnData(
-                        conn=conn,
-                        comm_ok=True,
-                        result=dict(
-                                skipped=True,
-                                msg=("skipped, since %s exists" % creates)
-                            )
-                        )
+                    conn=conn,
+                    comm_ok=True,
+                    result=dict(
+                        skipped=True,
+                        msg=("skipped, since %s exists" % creates)
+                    )
+                )
         if removes:
             # do not run the command if the line contains removes=filename
             # and the filename does not exist. This allows idempotence
             # of command executions.
             module_args_tmp = "path=%s" % removes
-            module_return = self.runner._execute_module(conn, tmp, 'stat', module_args_tmp, inject=inject, complex_args=complex_args, persist_files=True)
+            module_return = self.runner._execute_module(conn, tmp, 'stat', module_args_tmp, inject=inject,
+                                                        complex_args=complex_args, persist_files=True)
             stat = module_return.result.get('stat', None)
             if stat and not stat.get('exists', False):
                 return ReturnData(
-                        conn=conn,
-                        comm_ok=True,
-                        result=dict(
-                                skipped=True,
-                                msg=("skipped, since %s does not exist" % removes)
-                            )
-                        )
+                    conn=conn,
+                    comm_ok=True,
+                    result=dict(
+                        skipped=True,
+                        msg=("skipped, since %s does not exist" % removes)
+                    )
+                )
 
         # Decode the result of shlex.split() to UTF8 to get around a bug in that's been fixed in Python 2.7 but not Python 2.6.
         # See: http://bugs.python.org/issue6988
-        tokens  = shlex.split(module_args.encode('utf8'))
+        tokens = shlex.split(module_args.encode('utf8'))
         tokens = [s.decode('utf8') for s in tokens]
         # extract source script
-        source  = tokens[0]
+        source = tokens[0]
 
         # FIXME: error handling
-        args    = " ".join(tokens[1:])
-        source  = template.template(self.runner.basedir, source, inject)
+        args = " ".join(tokens[1:])
+        source = template.template(self.runner.basedir, source, inject)
         if '_original_file' in inject:
             source = utils.path_dwim_relative(inject['_original_file'], 'files', source, self.runner.basedir)
         else:
             source = utils.path_dwim(self.runner.basedir, source)
 
         # transfer the file to a remote tmp location
-        source  = source.replace('\x00','') # why does this happen here?
-        args    = args.replace('\x00','') # why does this happen here?
+        source = source.replace('\x00', '')  # why does this happen here?
+        args = args.replace('\x00', '')  # why does this happen here?
         tmp_src = os.path.join(tmp, os.path.basename(source))
         tmp_src = tmp_src.replace('\x00', '')
 
         conn.put_file(source, tmp_src)
 
-        sudoable=True
+        sudoable = True
         # set file permissions, more permisive when the copy is done as a different user
         if self.runner.sudo and self.runner.sudo_user != 'root':
             cmd_args_chmod = "chmod a+rx %s" % tmp_src
-            sudoable=False
+            sudoable = False
         else:
             cmd_args_chmod = "chmod +rx %s" % tmp_src
         self.runner._low_level_exec_command(conn, cmd_args_chmod, tmp, sudoable=sudoable)

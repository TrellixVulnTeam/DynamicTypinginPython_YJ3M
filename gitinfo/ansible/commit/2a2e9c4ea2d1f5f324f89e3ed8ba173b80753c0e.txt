commit 2a2e9c4ea2d1f5f324f89e3ed8ba173b80753c0e
Author: Abhijeet Kasurde <akasurde@redhat.com>
Date:   Tue Jan 22 20:21:27 2019 +0530

    dataloader: unit tests (#50942)
    
    * dataloader: unit tests
    
    Based on work from Alikins (https://github.com/ansible/ansible/pull/16500)
    
    Signed-off-by: Abhijeet Kasurde <akasurde@redhat.com>
    
    * review comments
    
    Signed-off-by: Abhijeet Kasurde <akasurde@redhat.com>

diff --git a/test/units/parsing/fixtures/vault.yml b/test/units/parsing/fixtures/vault.yml
new file mode 100644
index 0000000000..ca33ab25cb
--- /dev/null
+++ b/test/units/parsing/fixtures/vault.yml
@@ -0,0 +1,6 @@
+$ANSIBLE_VAULT;1.1;AES256
+33343734386261666161626433386662623039356366656637303939306563376130623138626165
+6436333766346533353463636566313332623130383662340a393835656134633665333861393331
+37666233346464636263636530626332623035633135363732623332313534306438393366323966
+3135306561356164310a343937653834643433343734653137383339323330626437313562306630
+3035
diff --git a/test/units/parsing/test_dataloader.py b/test/units/parsing/test_dataloader.py
index 264c9f7481..ebc407655b 100644
--- a/test/units/parsing/test_dataloader.py
+++ b/test/units/parsing/test_dataloader.py
@@ -23,7 +23,8 @@ import os
 
 from units.compat import unittest
 from units.compat.mock import patch, mock_open
-from ansible.errors import AnsibleParserError, yaml_strings
+from ansible.errors import AnsibleParserError, yaml_strings, AnsibleFileNotFound
+from ansible.parsing.vault import AnsibleVaultError
 from ansible.module_utils._text import to_text
 from ansible.module_utils.six import PY3
 
@@ -121,6 +122,79 @@ class TestDataLoader(unittest.TestCase):
             self.assertIn('tasks/included2.yml', called_args)
             self.assertIn('included2.yml', called_args)
 
+    def test_path_dwim_root(self):
+        self.assertEqual(self._loader.path_dwim('/'), '/')
+
+    def test_path_dwim_home(self):
+        self.assertEqual(self._loader.path_dwim('~'), os.path.expanduser('~'))
+
+    def test_path_dwim_tilde_slash(self):
+        self.assertEqual(self._loader.path_dwim('~/'), os.path.expanduser('~'))
+
+    def test_get_real_file(self):
+        self.assertEqual(self._loader.get_real_file(__file__), __file__)
+
+    def test_is_file(self):
+        self.assertTrue(self._loader.is_file(__file__))
+
+    def test_is_directory_positive(self):
+        self.assertTrue(self._loader.is_directory(os.path.dirname(__file__)))
+
+    def test_get_file_contents_none_path(self):
+        self.assertRaisesRegexp(AnsibleParserError, 'Invalid filename',
+                                self._loader._get_file_contents, None)
+
+    def test_get_file_contents_non_existent_path(self):
+        self.assertRaises(AnsibleFileNotFound, self._loader._get_file_contents, '/non_existent_file')
+
+
+class TestPathDwimRelativeDataLoader(unittest.TestCase):
+
+    def setUp(self):
+        self._loader = DataLoader()
+
+    def test_all_slash(self):
+        self.assertEquals(self._loader.path_dwim_relative('/', '/', '/'), '/')
+
+    def test_path_endswith_role(self):
+        self.assertEquals(self._loader.path_dwim_relative(path='foo/bar/tasks/', dirname='/', source='/'), '/')
+
+    def test_path_endswith_role_main_yml(self):
+        self.assertIn('main.yml', self._loader.path_dwim_relative(path='foo/bar/tasks/', dirname='/', source='main.yml'))
+
+    def test_path_endswith_role_source_tilde(self):
+        self.assertEquals(self._loader.path_dwim_relative(path='foo/bar/tasks/', dirname='/', source='~/'), os.path.expanduser('~'))
+
+
+class TestPathDwimRelativeStackDataLoader(unittest.TestCase):
+
+    def setUp(self):
+        self._loader = DataLoader()
+
+    def test_none(self):
+        self.assertRaisesRegexp(AnsibleFileNotFound, 'on the Ansible Controller', self._loader.path_dwim_relative_stack, None, None, None)
+
+    def test_empty_strings(self):
+        self.assertEqual(self._loader.path_dwim_relative_stack('', '', ''), './')
+
+    def test_empty_lists(self):
+        self.assertEqual(self._loader.path_dwim_relative_stack([], '', '~/'), os.path.expanduser('~'))
+
+    def test_all_slash(self):
+        self.assertEquals(self._loader.path_dwim_relative_stack('/', '/', '/'), '/')
+
+    def test_path_endswith_role(self):
+        self.assertEquals(self._loader.path_dwim_relative_stack(paths=['foo/bar/tasks/'], dirname='/', source='/'), '/')
+
+    def test_path_endswith_role_source_tilde(self):
+        self.assertEquals(self._loader.path_dwim_relative_stack(paths=['foo/bar/tasks/'], dirname='/', source='~/'), os.path.expanduser('~'))
+
+    def test_path_endswith_role_source_main_yml(self):
+        self.assertRaises(AnsibleFileNotFound, self._loader.path_dwim_relative_stack, ['foo/bar/tasks/'], '/', 'main.yml')
+
+    def test_path_endswith_role_source_main_yml_source_in_dirname(self):
+        self.assertRaises(AnsibleFileNotFound, self._loader.path_dwim_relative_stack, 'foo/bar/tasks/', 'tasks', 'tasks/main.yml')
+
 
 class TestDataLoaderWithVault(unittest.TestCase):
 
@@ -128,10 +202,27 @@ class TestDataLoaderWithVault(unittest.TestCase):
         self._loader = DataLoader()
         vault_secrets = [('default', TextVaultSecret('ansible'))]
         self._loader.set_vault_secrets(vault_secrets)
+        self.test_vault_data_path = os.path.join(os.path.dirname(__file__), 'fixtures', 'vault.yml')
 
     def tearDown(self):
         pass
 
+    def test_get_real_file_vault(self):
+        real_file_path = self._loader.get_real_file(self.test_vault_data_path)
+        self.assertTrue(os.path.exists(real_file_path))
+
+    def test_get_real_file_vault_no_vault(self):
+        self._loader.set_vault_secrets(None)
+        self.assertRaises(AnsibleParserError, self._loader.get_real_file, self.test_vault_data_path)
+
+    def test_get_real_file_vault_wrong_password(self):
+        wrong_vault = [('default', TextVaultSecret('wrong_password'))]
+        self._loader.set_vault_secrets(wrong_vault)
+        self.assertRaises(AnsibleVaultError, self._loader.get_real_file, self.test_vault_data_path)
+
+    def test_get_real_file_not_a_path(self):
+        self.assertRaisesRegexp(AnsibleParserError, 'Invalid filename', self._loader.get_real_file, None)
+
     @patch.multiple(DataLoader, path_exists=lambda s, x: True, is_file=lambda s, x: True)
     def test_parse_from_vault_1_1_file(self):
         vaulted_data = """$ANSIBLE_VAULT;1.1;AES256

commit 420f7d7ac6c75b133cddb0e5eaa1e769e4825f61
Author: martin f. krafft <madduck@madduck.net>
Date:   Wed Jun 19 09:06:33 2013 +0200

    Introduce non-purged package status
    
    A package may be removed but not purged with APT. The only way to
    identify this state is by looking at the list of installed files of
    a package. Even if the package has no files installed, this list will be
    non-empty until the package is removed:
    
      # python -c "import apt; c=apt.Cache(); c.update(); c.open(); p=c['ruby1.8']; print p, p.installed, p.installed_files"
      <Package: name:'ruby1.8' id:1425> None [u'']
    
      # dpkg --purge ruby1.8
      (Reading database ... 27904 files and directories currently installed.)
      Removing ruby1.8 ...
      Purging configuration files for ruby1.8 ...
    
      # python -c "import apt; c=apt.Cache(); c.update(); c.open(); p=c['ruby1.8']; print p, p.installed, p.installed_files"
      <Package: name:'ruby1.8' id:1425> None []
    
    See http://bugs.debian.org/712749 too.
    
    If a package is not marked installed but it still 'has_files', then it
    should be processed if the request is to purge it.
    
    Signed-off-by: martin f. krafft <madduck@madduck.net>

diff --git a/library/packaging/apt b/library/packaging/apt
index 37856074c9..a882c43c4a 100644
--- a/library/packaging/apt
+++ b/library/packaging/apt
@@ -151,25 +151,26 @@ def package_status(m, pkgname, version, cache, state):
         if state == 'install':
             m.fail_json(msg="No package matching '%s' is available" % pkgname)
         else:
-            return False, False
+            return False, False, False
+    has_files = len(pkg.installed_files) > 0
     if version:
         try :
-            return pkg.is_installed and fnmatch.fnmatch(pkg.installed.version, version), False
+            return pkg.is_installed and fnmatch.fnmatch(pkg.installed.version, version), False, has_files
         except AttributeError:
             #assume older version of python-apt is installed
-            return pkg.isInstalled and fnmatch.fnmatch(pkg.installedVersion, version), False
+            return pkg.isInstalled and fnmatch.fnmatch(pkg.installedVersion, version), False, has_files
     else:
         try :
-            return pkg.is_installed, pkg.is_upgradable
+            return pkg.is_installed, pkg.is_upgradable, has_files
         except AttributeError:
             #assume older version of python-apt is installed
-            return pkg.isInstalled, pkg.isUpgradable
+            return pkg.isInstalled, pkg.isUpgradable, has_files
 
 def install(m, pkgspec, cache, upgrade=False, default_release=None, install_recommends=True, force=False):
     packages = ""
     for package in pkgspec:
         name, version = package_split(package)
-        installed, upgradable = package_status(m, name, version, cache, state='install')
+        installed, upgradable, has_files = package_status(m, name, version, cache, state='install')
         if not installed or (upgrade and upgradable):
             packages += "'%s' " % package
 
@@ -203,8 +204,8 @@ def remove(m, pkgspec, cache, purge=False):
     packages = ""
     for package in pkgspec:
         name, version = package_split(package)
-        installed, upgradable = package_status(m, name, version, cache, state='remove')
-        if installed:
+        installed, upgradable, has_files = package_status(m, name, version, cache, state='remove')
+        if installed or (has_files and purge):
             packages += "'%s' " % package
 
     if len(packages) == 0:

commit 1faee38eaccb3fc581c885ed5e26f66fce1b6c4e
Author: Peter Oliver <git@mavit.org.uk>
Date:   Wed Dec 31 11:59:40 2014 +0000

    Add Solaris 11 package management
    
    - Module pkg5 handles installing and uninstalling packages.
    - Module pkg5_publisher manages repository configuration.

diff --git a/lib/ansible/modules/extras/packaging/os/pkg5.py b/lib/ansible/modules/extras/packaging/os/pkg5.py
new file mode 100644
index 0000000000..ffe9e083a6
--- /dev/null
+++ b/lib/ansible/modules/extras/packaging/os/pkg5.py
@@ -0,0 +1,109 @@
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+
+DOCUMENTATION = '''
+---
+module: pkg5
+author: Peter Oliver
+short_description: Manages packages with the Solaris 11 Image Packaging System
+description:
+  - IPS packages are the native packages in Solaris 11 and higher.
+notes:
+  - The naming of IPS packages is explained at http://www.oracle.com/technetwork/articles/servers-storage-admin/ips-package-versioning-2232906.html.
+options:
+  name:
+    description:
+      - An FRMI of the package(s) to be installed/removed/updated.
+      - Multiple packages may be specified, separated by C(,).  If C(,)
+        appears in an FRMI, you can replace it with C(-).
+    required: true
+  state:
+    description:
+      - Whether to install (C(present), C(latest)), or remove (C(absent)) a
+        package.
+    required: false
+    default: present
+    choices: [ present, latest, absent ]
+'''
+EXAMPLES = '''
+# Install Vim:
+- pkg5: name=editor/vim
+
+# Remove finger daemon:
+- pkg5: name=service/network/finger state=absent
+'''
+
+def main():
+    module = AnsibleModule(
+        argument_spec=dict(
+            name=dict(required=True, type='list'),
+            state=dict(
+                default='present',
+                choices=[
+                    'present',
+                    'installed',
+                    'latest',
+                    'absent',
+                    'uninstalled',
+                    'removed',
+                ]
+            ),
+        )
+    )
+
+    params = module.params
+    if params['state'] in ['present', 'installed']:
+        ensure(module, 'present', params['name'])
+    elif params['state'] in ['latest']:
+        ensure(module, 'latest', params['name'])
+    elif params['state'] in ['absent', 'uninstalled', 'removed']:
+        ensure(module, 'absent', params['name'])
+
+
+def ensure(module, state, packages):
+    response = {
+        'results': [],
+        'msg': '',
+    }
+    behaviour = {
+        'present': {
+            'filter': lambda p: not is_installed(module, p),
+            'subcommand': 'install',
+        },
+        'latest': {
+            'filter': lambda p: not is_latest(module, p),
+            'subcommand': 'install',
+        },
+        'absent': {
+            'filter': lambda p: is_installed(module, p),
+            'subcommand': 'uninstall',
+        },
+    }
+
+    to_modify = filter(behaviour[state]['filter'], packages)
+    if to_modify:
+        rc, out, err = module.run_command(
+            ['pkg', behaviour[state]['subcommand'], '-q', '--'] + to_modify
+        )
+        response['rc'] = rc
+        response['results'].append(out)
+        response['msg'] += err
+        response['changed'] = True
+        if rc != 0:
+            module.fail_json(**response)
+
+    module.exit_json(**response)
+
+
+def is_installed(module, package):
+    rc, out, err = module.run_command(['pkg', 'list', '--', package])
+    return True if rc == 0 else False
+
+
+def is_latest(module, package):
+    rc, out, err = module.run_command(['pkg', 'list', '-u', '--', package])
+    return True if rc == 1 else False
+
+
+from ansible.module_utils.basic import *
+main()
diff --git a/lib/ansible/modules/extras/packaging/os/pkg5_publisher.py b/lib/ansible/modules/extras/packaging/os/pkg5_publisher.py
new file mode 100644
index 0000000000..46bb6c6407
--- /dev/null
+++ b/lib/ansible/modules/extras/packaging/os/pkg5_publisher.py
@@ -0,0 +1,176 @@
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+
+DOCUMENTATION = '''
+---
+module: pkg5_publisher
+author: Peter Oliver
+short_description: Manages Solaris 11 Image Packaging System publishers
+description:
+  - IPS packages are the native packages in Solaris 11 and higher.
+  - This modules will configure which publishers a client will download IPS
+    packages from.
+options:
+  name:
+    description:
+      - The publisher's name.
+    required: true
+    aliases: [ publisher ]
+  state:
+    description:
+      - Whether to ensure that a publisher is present or absent.
+    required: false
+    default: present
+    choices: [ present, absent ]
+  sticky:
+    description:
+      - Packages installed from a sticky repository can only receive updates
+        from that repository.
+    required: false
+    default: null
+    choices: [ true, false ]
+  enabled:
+    description:
+      - Is the repository enabled or disabled?
+    required: false
+    default: null
+    choices: [ true, false ]
+  origin:
+    description:
+      - A path or URL to the repository.
+      - Multiple values may be provided.
+    required: false
+    default: null
+  mirror:
+    description:
+      - A path or URL to the repository mirror.
+      - Multiple values may be provided.
+    required: false
+    default: null
+'''
+EXAMPLES = '''
+# Fetch packages for the solaris publisher direct from Oracle:
+- pkg5_publisher: name=solaris sticky=true origin=https://pkg.oracle.com/solaris/support/
+
+# Configure a publisher for locally-produced packages:
+- pkg5_publisher: name=site origin=https://pkg.example.com/site/
+'''
+
+def main():
+    module = AnsibleModule(
+        argument_spec=dict(
+            name=dict(required=True, aliases=['publisher']),
+            state=dict(default='present', choices=['present', 'absent']),
+            sticky=dict(choices=BOOLEANS),
+            enabled=dict(choices=BOOLEANS),
+            # search_after=dict(),
+            # search_before=dict(),
+            origin=dict(type='list'),
+            mirror=dict(type='list'),
+        )
+    )
+
+    for option in ['origin', 'mirror']:
+        if module.params[option] == ['']:
+            module.params[option] = []
+
+    if module.params['state'] == 'present':
+        modify_publisher(module, module.params)
+    else:
+        unset_publisher(module, module.params['name'])
+
+
+def modify_publisher(module, params):
+    name = params['name']
+    existing = get_publishers(module)
+
+    if name in existing:
+        for option in ['origin', 'mirror', 'sticky', 'enabled']:
+            if params[option] != None:
+                if params[option] != existing[name][option]:
+                    return set_publisher(module, params)
+    else:
+        return set_publisher(module, params)
+
+    module.exit_json()
+
+
+def set_publisher(module, params):
+    name = params['name']
+    args = []
+
+    if params['origin'] != None:
+        args.append('--remove-origin=*')
+        args.extend(['--add-origin=' + u for u in params['origin']])
+    if params['mirror'] != None:
+        args.append('--remove-mirror=*')
+        args.extend(['--add-mirror=' + u for u in params['mirror']])
+
+    if params['sticky'] != None:
+        args.append('--sticky' if params['sticky'] else '--non-sticky')
+    if params['enabled'] != None:
+        args.append('--enable' if params['enabled'] else '--disable')
+
+    rc, out, err = module.run_command(
+        ["pkg", "set-publisher"] + args + [name],
+        check_rc=True
+    )
+    response = {
+        'rc': rc,
+        'results': [out],
+        'msg': err,
+        'changed': True,
+    }
+    module.exit_json(**response)
+
+
+def unset_publisher(module, publisher):
+    rc, out, err = module.run_command(
+        ["pkg", "unset-publisher", publisher],
+        check_rc=True
+    )
+    response = {
+        'rc': rc,
+        'results': [out],
+        'msg': err,
+        'changed': True,
+    }
+    module.exit_json(**response)
+
+
+def get_publishers(module):
+    rc, out, err = module.run_command(["pkg", "publisher", "-Ftsv"], True)
+
+    lines = out.splitlines()
+    keys = lines.pop(0).lower().split("\t")
+
+    publishers = {}
+    for line in lines:
+        values = dict(zip(keys, map(unstringify, line.split("\t"))))
+        name = values['publisher']
+
+        if not name in publishers:
+            publishers[name] = dict(
+                (k, values[k]) for k in ['sticky', 'enabled']
+            )
+            publishers[name]['origin'] = []
+            publishers[name]['mirror'] = []
+
+        publishers[name][values['type']].append(values['uri'])
+
+    return publishers
+
+
+def unstringify(val):
+    if val == "-":
+        return None
+    elif val == "true":
+        return True
+    elif val == "false":
+        return False
+    else:
+        return val
+
+
+from ansible.module_utils.basic import *
+main()

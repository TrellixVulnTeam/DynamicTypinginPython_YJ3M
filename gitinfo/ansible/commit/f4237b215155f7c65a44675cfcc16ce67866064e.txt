commit f4237b215155f7c65a44675cfcc16ce67866064e
Author: James Cammarata <jimi@sngx.net>
Date:   Mon Aug 15 15:21:37 2016 -0500

    Rework the way params are assigned to TaskIncludes when they're dynamic
    
    Copying the TaskInclude task (which is the parent) before loading the blocks
    makes the code much more simple and clean, and fixes a bug introduced during
    the performance improvement changes (and specifically the change which moved
    things to a single-parent model).
    
    Fixes #17064

diff --git a/lib/ansible/playbook/base.py b/lib/ansible/playbook/base.py
index b9edce54e4..5745e3f022 100644
--- a/lib/ansible/playbook/base.py
+++ b/lib/ansible/playbook/base.py
@@ -167,11 +167,11 @@ class Base:
     def dump_me(self, depth=0):
         if depth == 0:
             print("DUMPING OBJECT ------------------------------------------------------")
-        print("%s- %s (%s)" % (" " * depth, self.__class__.__name__, self))
+        print("%s- %s (%s, id=%s)" % (" " * depth, self.__class__.__name__, self, id(self)))
         if hasattr(self, '_parent') and self._parent:
             self._parent.dump_me(depth+2)
             dep_chain = self._parent.get_dep_chain()
-            print("%s^ dep chain: %s" % (" "*(depth+2), dep_chain))
+            #print("%s^ dep chain: %s" % (" "*(depth+2), dep_chain))
             if dep_chain:
                 for dep in dep_chain:
                     dep.dump_me(depth+2)
diff --git a/lib/ansible/plugins/strategy/__init__.py b/lib/ansible/plugins/strategy/__init__.py
index 5b3c461092..4a7c9f539e 100644
--- a/lib/ansible/plugins/strategy/__init__.py
+++ b/lib/ansible/plugins/strategy/__init__.py
@@ -609,11 +609,28 @@ class StrategyBase:
             elif not isinstance(data, list):
                 raise AnsibleError("included task files must contain a list of tasks")
 
+            ti_copy = included_file._task.copy()
+            temp_vars = ti_copy.vars.copy()
+            temp_vars.update(included_file._args)
+            # pop tags out of the include args, if they were specified there, and assign
+            # them to the include. If the include already had tags specified, we raise an
+            # error so that users know not to specify them both ways
+            tags = included_file._task.vars.pop('tags', [])
+            if isinstance(tags, string_types):
+                tags = tags.split(',')
+            if len(tags) > 0:
+                if len(included_file._task.tags) > 0:
+                    raise AnsibleParserError("Include tasks should not specify tags in more than one way (both via args and directly on the task). Mixing tag specify styles is prohibited for whole import hierarchy, not only for single import statement",
+                            obj=included_file._task._ds)
+                display.deprecated("You should not specify tags in the include parameters. All tags should be specified using the task-level option")
+                included_file._task.tags = tags
+            ti_copy.vars = temp_vars
+
             block_list = load_list_of_blocks(
                 data,
                 play=iterator._play,
                 parent_block=None,
-                task_include=included_file._task,
+                task_include=ti_copy,
                 role=included_file._task._role,
                 use_handlers=is_handler,
                 loader=self._loader,
@@ -636,26 +653,6 @@ class StrategyBase:
                 self._tqm.send_callback('v2_runner_on_failed', tr)
             return []
 
-        # set the vars for this task from those specified as params to the include
-        for b in block_list:
-            # first make a copy of the including task, so that each has a unique copy to modify
-            b._parent = included_file._task.copy()
-            # then we create a temporary set of vars to ensure the variable reference is unique
-            temp_vars = b._parent.vars.copy()
-            temp_vars.update(included_file._args.copy())
-            # pop tags out of the include args, if they were specified there, and assign
-            # them to the include. If the include already had tags specified, we raise an
-            # error so that users know not to specify them both ways
-            tags = temp_vars.pop('tags', [])
-            if isinstance(tags, string_types):
-                tags = tags.split(',')
-            if len(tags) > 0:
-                if len(b._parent.tags) > 0:
-                    raise AnsibleParserError("Include tasks should not specify tags in more than one way (both via args and directly on the task). Mixing tag specify styles is prohibited for whole import hierarchy, not only for single import statement",
-                            obj=included_file._task._ds)
-                display.deprecated("You should not specify tags in the include parameters. All tags should be specified using the task-level option")
-                b._parent.tags = tags
-            b._parent.vars = temp_vars
 
         # finally, send the callback and return the list of blocks loaded
         self._tqm.send_callback('v2_playbook_on_include', included_file)

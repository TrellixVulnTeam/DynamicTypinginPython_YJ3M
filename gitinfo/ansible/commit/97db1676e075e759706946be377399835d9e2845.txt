commit 97db1676e075e759706946be377399835d9e2845
Author: nate@bx.psu.edu <nate@bx.psu.edu>
Date:   Wed Feb 26 16:23:40 2014 -0600

    Bugfix for xattrless files and the capabilities module.

diff --git a/library/system/capabilities b/library/system/capabilities
index bd3832e710..1d5762d1b2 100644
--- a/library/system/capabilities
+++ b/library/system/capabilities
@@ -84,8 +84,6 @@ class CapabilitiesModule(object):
         self.setcap_cmd     = module.get_bin_path('setcap', required=True)
         self.capability_tup = self._parse_cap(self.capability, op_required=self.state=='present')
 
-        self.changed        = False
-
         self.run()
 
     def run(self):
@@ -102,15 +100,16 @@ class CapabilitiesModule(object):
                 current = filter(lambda x: x[0] != self.capability_tup[0], current)
                 # add new cap with correct op/flags
                 current.append( self.capability_tup )
-                self.module.exit_json(changed=True, msg='capabilities changed', stdout=self.setcap(self.path, current))
-        if self.state == 'absent' and self.capability_tup[0] in caps:
+                self.module.exit_json(changed=True, state=self.state, msg='capabilities changed', stdout=self.setcap(self.path, current))
+        elif self.state == 'absent' and self.capability_tup[0] in caps:
             # need to remove capability
             if self.module.check_mode:
                 self.module.exit_json(changed=True, msg='capabilities changed')
             else:
                 # remove from current cap list and then set current list
                 current = filter(lambda x: x[0] != self.capability_tup[0], current)
-                self.module.exit_json(changed=True, msg='capabilities changed', stdout=self.setcap(self.path, current))
+                self.module.exit_json(changed=True, state=self.state, msg='capabilities changed', stdout=self.setcap(self.path, current))
+        self.module.exit_json(changed=False, state=self.state)
 
     def getcap(self, path):
         rval = []
@@ -123,19 +122,20 @@ class CapabilitiesModule(object):
         # If the file does not eixst the output will be (with rc == 0...):
         #   '/foo (No such file or directory)'
         if rc != 0 or (stdout.strip() != path and stdout.count(' =') != 1):
-            self.module.fail_json(msg="Unable to get capabilities of %s" % path, stdout=stdout, stderr=stderr)
-        caps = stdout.split(' =')[1].strip().split()
-        for cap in caps:
-            cap = cap.lower()
-            # getcap condenses capabilities with the same op/flags into a
-            # comma-separated list, so we have to parse that
-            if ',' in cap:
-                cap_group = cap.split(',')
-                cap_group[-1], op, flags = self._parse_cap(cap_group[-1])
-                for subcap in cap_group:
-                    rval.append( ( subcap, op, flags ) )
-            else:
-                rval.append(self._parse_cap(cap))
+            self.module.fail_json(msg="Unable to get capabilities of %s" % path, stdout=stdout.strip(), stderr=stderr)
+        if stdout.strip() != path:
+            caps = stdout.split(' =')[1].strip().split()
+            for cap in caps:
+                cap = cap.lower()
+                # getcap condenses capabilities with the same op/flags into a
+                # comma-separated list, so we have to parse that
+                if ',' in cap:
+                    cap_group = cap.split(',')
+                    cap_group[-1], op, flags = self._parse_cap(cap_group[-1])
+                    for subcap in cap_group:
+                        rval.append( ( subcap, op, flags ) )
+                else:
+                    rval.append(self._parse_cap(cap))
         return rval
 
     def setcap(self, path, caps):

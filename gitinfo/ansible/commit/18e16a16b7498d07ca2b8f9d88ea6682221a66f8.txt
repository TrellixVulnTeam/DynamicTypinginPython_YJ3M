commit 18e16a16b7498d07ca2b8f9d88ea6682221a66f8
Author: Brian Coca <bcoca@ansible.com>
Date:   Mon May 11 14:36:11 2015 -0400

    fixed try/except/finally to be 2.4 compatible

diff --git a/lib/ansible/modules/utilities/helper/accelerate.py b/lib/ansible/modules/utilities/helper/accelerate.py
index 47374f4def..726195d72e 100644
--- a/lib/ansible/modules/utilities/helper/accelerate.py
+++ b/lib/ansible/modules/utilities/helper/accelerate.py
@@ -235,33 +235,34 @@ class LocalSocketThread(Thread):
                 while "\n" not in data:
                     data += conn.recv(2048)
                 try:
-                    new_key = AesKey.Read(data.strip())
-                    found = False
-                    for key in self.server.key_list:
-                        try:
-                            new_key.Decrypt(key.Encrypt("foo"))
-                            found = True
-                            break
-                        except:
-                            pass
-                    if not found:
-                        vv("adding new key to the key list")
-                        self.server.key_list.append(new_key)
-                        conn.sendall("OK\n")
-                    else:
-                        vv("key already exists in the key list, ignoring")
-                        conn.sendall("EXISTS\n")
-
-                    # update the last event time so the server doesn't
-                    # shutdown sooner than expected for new cliets
                     try:
-                        self.server.last_event_lock.acquire()
-                        self.server.last_event = datetime.now()
-                    finally:
-                        self.server.last_event_lock.release()
-                except Exception, e:
-                    vv("key loaded locally was invalid, ignoring (%s)" % e)
-                    conn.sendall("BADKEY\n")
+                        new_key = AesKey.Read(data.strip())
+                        found = False
+                        for key in self.server.key_list:
+                            try:
+                                new_key.Decrypt(key.Encrypt("foo"))
+                                found = True
+                                break
+                            except:
+                                pass
+                        if not found:
+                            vv("adding new key to the key list")
+                            self.server.key_list.append(new_key)
+                            conn.sendall("OK\n")
+                        else:
+                            vv("key already exists in the key list, ignoring")
+                            conn.sendall("EXISTS\n")
+
+                        # update the last event time so the server doesn't
+                        # shutdown sooner than expected for new cliets
+                        try:
+                            self.server.last_event_lock.acquire()
+                            self.server.last_event = datetime.now()
+                        finally:
+                            self.server.last_event_lock.release()
+                    except Exception, e:
+                        vv("key loaded locally was invalid, ignoring (%s)" % e)
+                        conn.sendall("BADKEY\n")
                 finally:
                     try:
                         conn.close()
@@ -588,21 +589,22 @@ def daemonize(module, password, port, timeout, minutes, use_ipv6, pid_file):
 
         def timer_handler(signum, _):
             try:
-                server.last_event_lock.acquire()
-                td = datetime.now() - server.last_event
-                # older python timedelta objects don't have total_seconds(),
-                # so we use the formula from the docs to calculate it
-                total_seconds = (td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) / 10**6
-                if total_seconds >= minutes * 60:
-                    log("server has been idle longer than the timeout, shutting down")
-                    server.running = False
-                    server.shutdown()
-                else:
-                    # reschedule the check
-                    vvvv("daemon idle for %d seconds (timeout=%d)" % (total_seconds,minutes*60))
-                    signal.alarm(30)
-            except:
-                pass
+                try:
+                    server.last_event_lock.acquire()
+                    td = datetime.now() - server.last_event
+                    # older python timedelta objects don't have total_seconds(),
+                    # so we use the formula from the docs to calculate it
+                    total_seconds = (td.microseconds + (td.seconds + td.days * 24 * 3600) * 10**6) / 10**6
+                    if total_seconds >= minutes * 60:
+                        log("server has been idle longer than the timeout, shutting down")
+                        server.running = False
+                        server.shutdown()
+                    else:
+                        # reschedule the check
+                        vvvv("daemon idle for %d seconds (timeout=%d)" % (total_seconds,minutes*60))
+                        signal.alarm(30)
+                except:
+                    pass
             finally:
                 server.last_event_lock.release()
 
@@ -623,7 +625,7 @@ def daemonize(module, password, port, timeout, minutes, use_ipv6, pid_file):
                 vv("Failed to create the TCP server (tries left = %d) (error: %s) " % (tries,e))
             tries -= 1
             time.sleep(0.2)
-        
+
         if tries == 0:
             vv("Maximum number of attempts to create the TCP server reached, bailing out")
             raise Exception("max # of attempts to serve reached")
@@ -704,14 +706,15 @@ def main():
         # try to connect to the file socket for the daemon if it exists
         s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
         try:
-            s.connect(SOCKET_FILE)
-            s.sendall(password + '\n')
-            data = ""
-            while '\n' not in data:
-                data += s.recv(2048)
-            res = data.strip()
-        except:
-            module.fail_json(msg="failed to connect to the local socket file")
+            try:
+                s.connect(SOCKET_FILE)
+                s.sendall(password + '\n')
+                data = ""
+                while '\n' not in data:
+                    data += s.recv(2048)
+                res = data.strip()
+            except:
+                module.fail_json(msg="failed to connect to the local socket file")
         finally:
             try:
                 s.close()

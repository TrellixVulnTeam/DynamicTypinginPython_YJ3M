commit 1211a0fa12d6ac9723298f53c1a0d6e184fcbfa3
Author: James Cammarata <jimi@sngx.net>
Date:   Mon Apr 25 11:05:33 2016 -0400

    Fixing the way we iterate over child states for tasks
    
    Previously we were first checking the fail/run state of the child
    state for tasks/rescue/always portions of the block. Instead we are now
    always recursively iterating over the child state and then evaluating
    whether the child state is failed or complete before changing the failed/
    run state within the current block.
    
    Fixes #14324

diff --git a/lib/ansible/executor/play_iterator.py b/lib/ansible/executor/play_iterator.py
index 5465137e4a..3ab2e289ac 100644
--- a/lib/ansible/executor/play_iterator.py
+++ b/lib/ansible/executor/play_iterator.py
@@ -322,14 +322,14 @@ class PlayIterator:
                 # have one recurse into it for the next task. If we're done with the child
                 # state, we clear it and drop back to geting the next task from the list.
                 if state.tasks_child_state:
-                    if state.tasks_child_state.fail_state != self.FAILED_NONE:
+                    (state.tasks_child_state, task) = self._get_next_task_from_state(state.tasks_child_state, host=host, peek=peek)
+                    if self._check_failed_state(state.tasks_child_state):
                         # failed child state, so clear it and move into the rescue portion
                         state.tasks_child_state = None
                         state.fail_state |= self.FAILED_TASKS
                         state.run_state = self.ITERATING_RESCUE
                     else:
                         # get the next task recursively
-                        (state.tasks_child_state, task) = self._get_next_task_from_state(state.tasks_child_state, host=host, peek=peek)
                         if task is None or state.tasks_child_state.run_state == self.ITERATING_COMPLETE:
                             # we're done with the child state, so clear it and continue
                             # back to the top of the loop to get the next task
@@ -362,13 +362,13 @@ class PlayIterator:
                 # The process here is identical to ITERATING_TASKS, except instead
                 # we move into the always portion of the block.
                 if state.rescue_child_state:
-                    if state.rescue_child_state.fail_state != self.FAILED_NONE:
+                    (state.rescue_child_state, task) = self._get_next_task_from_state(state.rescue_child_state, host=host, peek=peek)
+                    if self._check_failed_state(state.rescue_child_state):
                         state.rescue_child_state = None
                         state.fail_state |= self.FAILED_RESCUE
                         state.run_state = self.ITERATING_ALWAYS
                     else:
-                        (state.rescue_child_state, task) = self._get_next_task_from_state(state.rescue_child_state, host=host, peek=peek)
-                        if task is None:
+                        if task is None or state.rescue_child_state.run_state == self.ITERATING_COMPLETE:
                             state.rescue_child_state = None
                             continue
                 else:
@@ -393,13 +393,13 @@ class PlayIterator:
                 # run state to ITERATING_COMPLETE in the event of any errors, or when we
                 # have hit the end of the list of blocks.
                 if state.always_child_state:
-                    if state.always_child_state.fail_state != self.FAILED_NONE:
+                    (state.always_child_state, task) = self._get_next_task_from_state(state.always_child_state, host=host, peek=peek)
+                    if self._check_failed_state(state.always_child_state):
                         state.always_child_state = None
                         state.fail_state |= self.FAILED_ALWAYS
                         state.run_state = self.ITERATING_COMPLETE
                     else:
-                        (state.always_child_state, task) = self._get_next_task_from_state(state.always_child_state, host=host, peek=peek)
-                        if task is None:
+                        if task is None or state.always_child_state.run_state == self.ITERATING_COMPLETE:
                             state.always_child_state = None
                 else:
                     if state.cur_always_task >= len(block.always):
diff --git a/lib/ansible/plugins/strategy/linear.py b/lib/ansible/plugins/strategy/linear.py
index 750f154051..cc1f519ca9 100644
--- a/lib/ansible/plugins/strategy/linear.py
+++ b/lib/ansible/plugins/strategy/linear.py
@@ -92,7 +92,7 @@ class StrategyModule(StrategyBase):
                 num_rescue += 1
             elif s.run_state == PlayIterator.ITERATING_ALWAYS:
                 num_always += 1
-        display.debug("done counting tasks in each state of execution")
+        display.debug("done counting tasks in each state of execution:\n\tnum_setups: %s\n\tnum_tasks: %s\n\tnum_rescue: %s\n\tnum_always: %s" % (num_setups, num_tasks, num_rescue, num_always))
 
         def _advance_selected_hosts(hosts, cur_block, cur_state):
             '''

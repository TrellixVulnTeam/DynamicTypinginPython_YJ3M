commit 0fe0538a43ff441b3234d60ff42081061483d493
Author: QijunPan <panqijun@huawei.com>
Date:   Fri May 19 23:22:20 2017 +0800

    Contributing lib/ansible/modules/network/cloudengine/ce_command.py module to manage HUAWEI data center CloudEngine  (#21669)
    
    * update ce_command.py
    
    update ce_command.py
    
    * update ce_command
    
    update ce_command
    
    * update ce_command.py
    
    update ce_command.py
    
    * update ce_command module
    
    update ce_command module
    
    * update ce_command module
    
    update ce_command module

diff --git a/lib/ansible/modules/network/cloudengine/ce_command.py b/lib/ansible/modules/network/cloudengine/ce_command.py
index 1b91a0f286..d91fcc2c1c 100644
--- a/lib/ansible/modules/network/cloudengine/ce_command.py
+++ b/lib/ansible/modules/network/cloudengine/ce_command.py
@@ -28,13 +28,12 @@ DOCUMENTATION = """
 module: ce_command
 version_added: "2.3"
 author: "JackyGao2016 (@CloudEngine-Ansible)"
-short_description: Run arbitrary command on HUAWEI CloudEngine devices
+short_description: Run arbitrary command on HUAWEI CloudEngine devices.
 description:
   - Sends an arbitrary command to an HUAWEI CloudEngine node and returns
     the results read from the device.  The ce_command module includes an
     argument that will cause the module to wait for a specific condition
     before returning or timing out if the condition is not met.
-extends_documentation_fragment: cloudengine
 options:
   commands:
     description:
@@ -85,49 +84,49 @@ options:
 EXAMPLES = """
 # Note: examples below use the following provider dict to handle
 #       transport and authentication to the node.
----
-vars:
-  cli:
-    host: "{{ inventory_hostname }}"
-    username: admin
-    password: admin
-    transport: cli
 
----
-- name: run display version on remote devices
-  ce_command:
-    commands: display version
-    provider: "{{ cli }}"
-
-- name: run display version and check to see if output contains HUAWEI
-  ce_command:
-    commands: display version
-    wait_for: result[0] contains HUAWEI
-    provider: "{{ cli }}"
-
-- name: run multiple commands on remote nodes
-  ce_command:
-    commands:
-      - display version
-      - display device
-    provider: "{{ cli }}"
-
-- name: run multiple commands and evaluate the output
-  ce_command:
-    commands:
-      - display version
-      - display device
-    wait_for:
-      - result[0] contains HUAWEI
-      - result[1] contains Device
-    provider: "{{ cli }}"
-
-- name: run commands and specify the output format
-  ce_command:
-    commands:
-      - command: display version
-        output: json
-    provider: "{{ cli }}"
+- name: CloudEngine command test
+  hosts: cloudengine
+  connection: local
+  gather_facts: no
+  vars:
+    cli:
+      host: "{{ inventory_hostname }}"
+      port: "{{ ansible_ssh_port }}"
+      username: "{{ username }}"
+      password: "{{ password }}"
+      transport: cli
+
+  tasks:
+
+  tasks:
+  - name: "Run display version on remote devices"
+    ce_command:
+      commands: display version
+      provider: "{{ cli }}"
+
+  - name: "Run display version and check to see if output contains HUAWEI"
+    ce_command:
+      commands: display version
+      wait_for: result[0] contains HUAWEI
+      provider: "{{ cli }}"
+
+  - name: "Run multiple commands on remote nodes"
+    ce_command:
+      commands:
+        - display version
+        - display device
+      provider: "{{ cli }}"
+
+  - name: "Run multiple commands and evaluate the output"
+    ce_command:
+      commands:
+        - display version
+        - display device
+      wait_for:
+        - result[0] contains HUAWEI
+        - result[1] contains Device
+      provider: "{{ cli }}"
 """
 
 RETURN = """
@@ -151,46 +150,55 @@ failed_conditions:
 """
 
 
-from ansible.module_utils.basic import get_exception
-from ansible.module_utils.network import NetworkModule, NetworkError
-from ansible.module_utils.netcli import CommandRunner
-from ansible.module_utils.netcli import FailedConditionsError
-from ansible.module_utils.netcli import FailedConditionalError
-from ansible.module_utils.netcli import AddCommandError, AddConditionError
-import ansible.module_utils.cloudengine
-
+import time
 
-VALID_KEYS = ['command', 'output', 'prompt', 'response']
+from ansible.module_utils.ce import run_commands
+from ansible.module_utils.pycompat24 import get_exception
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.netcli import Conditional
+from ansible.module_utils.network_common import ComplexList
+from ansible.module_utils.ce import ce_argument_spec, check_args
 
 
 def to_lines(stdout):
-    """ to lines """
-
+    lines = list()
     for item in stdout:
         if isinstance(item, basestring):
             item = str(item).split('\n')
-        yield item
+        lines.append(item)
+    return lines
 
 
-def parse_commands(module):
-    """ parse commands """
+def parse_commands(module, warnings):
+    transform = ComplexList(dict(
+        command=dict(key=True),
+        output=dict(),
+        prompt=dict(),
+        response=dict()
+    ), module)
 
-    for cmd in module.params['commands']:
-        if isinstance(cmd, basestring):
-            cmd = dict(command=cmd, output=None)
-        elif 'command' not in cmd:
-            module.fail_json(msg='command keyword argument is required')
-        elif cmd.get('output') not in [None, 'text', 'json']:
-            module.fail_json(msg='invalid output specified for command')
-        elif not set(cmd.keys()).issubset(VALID_KEYS):
-            module.fail_json(msg='unknown keyword specified')
-        yield cmd
+    commands = transform(module.params['commands'])
 
+    for _, item in enumerate(commands):
+        if module.check_mode and not item['command'].startswith('dis'):
+            warnings.append(
+                'Only display commands are supported when using check_mode, not '
+                'executing %s' % item['command']
+            )
 
-def main():
-    """ main """
+    return commands
 
-    spec = dict(
+
+def to_cli(obj):
+    cmd = obj['command']
+    return cmd
+
+
+def main():
+    """entry point for module execution
+    """
+    argument_spec = dict(
+        # { command: <str>, output: <str>, prompt: <str>, response: <str> }
         commands=dict(type='list', required=True),
 
         wait_for=dict(type='list', aliases=['waitfor']),
@@ -200,67 +208,55 @@ def main():
         interval=dict(default=1, type='int')
     )
 
-    module = NetworkModule(argument_spec=spec,
+    argument_spec.update(ce_argument_spec)
+
+    module = AnsibleModule(argument_spec=argument_spec,
                            supports_check_mode=True)
 
-    commands = list(parse_commands(module))
-    conditionals = module.params['wait_for'] or list()
+    result = {'changed': False}
 
     warnings = list()
+    check_args(module, warnings)
+    commands = parse_commands(module, warnings)
+    result['warnings'] = warnings
 
-    runner = CommandRunner(module)
-
-    for cmd in commands:
-        if module.check_mode and not cmd['command'].startswith('dis'):
-            warnings.append('only display commands are supported when using '
-                            'check mode, not executing `%s`' % cmd['command'])
-        else:
-            if cmd['command'].startswith('sys'):
-                module.fail_json(msg='ce_command does not support running '
-                                     'config mode commands.  Please use '
-                                     'ce_config instead')
-            try:
-                runner.add_command(**cmd)
-            except AddCommandError:
-                exc = get_exception()
-                warnings.append('duplicate command detected: %s' % cmd)
+    wait_for = module.params['wait_for'] or list()
 
     try:
-        for item in conditionals:
-            runner.add_conditional(item)
-    except AddConditionError:
+        conditionals = [Conditional(c) for c in wait_for]
+    except AttributeError:
         exc = get_exception()
-        module.fail_json(msg=str(exc), condition=exc.condition)
+        module.fail_json(msg=str(exc))
 
-    runner.retries = module.params['retries']
-    runner.interval = module.params['interval']
-    runner.match = module.params['match']
+    retries = module.params['retries']
+    interval = module.params['interval']
+    match = module.params['match']
 
-    try:
-        runner.run()
-    except FailedConditionsError:
-        exc = get_exception()
-        module.fail_json(msg=str(exc), failed_conditions=exc.failed_conditions)
-    except FailedConditionalError:
-        exc = get_exception()
-        module.fail_json(
-            msg=str(exc), failed_conditional=exc.failed_conditional)
-    except NetworkError:
-        exc = get_exception()
-        module.fail_json(msg=str(exc), **exc.kwargs)
+    while retries > 0:
+        responses = run_commands(module, commands)
 
-    result = dict(changed=False)
+        for item in list(conditionals):
+            if item(responses):
+                if match == 'any':
+                    conditionals = list()
+                    break
+                conditionals.remove(item)
 
-    result['stdout'] = list()
-    for cmd in commands:
-        try:
-            output = runner.get_command(cmd['command'], cmd.get('output'))
-        except ValueError:
-            output = 'command not executed due to check_mode, see warnings'
-        result['stdout'].append(output)
+        if not conditionals:
+            break
 
-    result['warnings'] = warnings
-    result['stdout_lines'] = list(to_lines(result['stdout']))
+        time.sleep(interval)
+        retries -= 1
+
+    if conditionals:
+        failed_conditions = [item.raw for item in conditionals]
+        msg = 'One or more conditional statements have not be satisfied'
+        module.fail_json(msg=msg, failed_conditions=failed_conditions)
+
+    result.update({
+        'stdout': responses,
+        'stdout_lines': to_lines(responses)
+    })
 
     module.exit_json(**result)
 

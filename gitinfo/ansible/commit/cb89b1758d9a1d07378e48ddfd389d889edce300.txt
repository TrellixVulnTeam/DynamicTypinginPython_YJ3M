commit cb89b1758d9a1d07378e48ddfd389d889edce300
Author: Anil Kumar Muraleedharan <amuraleedhar@lenovo.com>
Date:   Wed Jan 9 21:16:56 2019 +0530

    Lenovo cnos l2interface (#50641)
    
    * Adding cnos_l2 interface module and its associated Integration test as well as Unit test code

diff --git a/lib/ansible/modules/network/cnos/cnos_l2_interface.py b/lib/ansible/modules/network/cnos/cnos_l2_interface.py
new file mode 100644
index 0000000000..65bed580c8
--- /dev/null
+++ b/lib/ansible/modules/network/cnos/cnos_l2_interface.py
@@ -0,0 +1,600 @@
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+#
+# Copyright (C) 2017 Lenovo, Inc.
+# (c) 2017, Ansible by Red Hat, inc
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+#
+# Module to send banner commands to Lenovo Switches
+# Two types of banners are supported login and motd
+# Lenovo Networking
+#
+
+from __future__ import absolute_import, division, print_function
+__metaclass__ = type
+
+
+ANSIBLE_METADATA = {'metadata_version': '1.1',
+                    'status': ['preview'],
+                    'supported_by': 'community'}
+
+
+DOCUMENTATION = """
+---
+module: cnos_l2_interface
+version_added: "2.8"
+short_description: Manage Layer-2 interface on Lenovo CNOS devices.
+description:
+  - This module provides declarative management of Layer-2 interfaces on
+    Lenovo CNOS devices.
+author:
+  - Anil Kumar Muraleedharan (@amuraleedhar)
+options:
+  name:
+    description:
+      - Full name of the interface excluding any logical
+        unit number, i.e. Ethernet1/3.
+    required: true
+    aliases: ['interface']
+  mode:
+    description:
+      - Mode in which interface needs to be configured.
+    default: access
+    choices: ['access', 'trunk']
+  access_vlan:
+    description:
+      - Configure given VLAN in access port.
+        If C(mode=access), used as the access VLAN ID.
+  trunk_vlans:
+    description:
+      - List of VLANs to be configured in trunk port.
+        If C(mode=trunk), used as the VLAN range to ADD or REMOVE
+        from the trunk.
+  native_vlan:
+    description:
+      - Native VLAN to be configured in trunk port.
+        If C(mode=trunk), used as the trunk native VLAN ID.
+  trunk_allowed_vlans:
+    description:
+      - List of allowed VLANs in a given trunk port.
+        If C(mode=trunk), these are the only VLANs that will be
+        configured on the trunk, i.e. "2-10,15".
+  aggregate:
+    description:
+      - List of Layer-2 interface definitions.
+  state:
+    description:
+      - Manage the state of the Layer-2 Interface configuration.
+    default:  present
+    choices: ['present','absent', 'unconfigured']
+  provider:
+    description:
+      - B(Deprecated)
+      - "Starting with Ansible 2.5 we recommend using
+         C(connection: network_cli)."
+      - For more information please see the
+        L(CNOS Platform Options guide, ../network/user_guide/platform_cnos.html).
+      - HORIZONTALLINE
+      - A dict object containing connection details.
+    version_added: "2.8"
+    suboptions:
+      host:
+        description:
+          - Specifies the DNS host name or address for connecting to the remote
+            device over the specified transport.  The value of host is used as
+            the destination address for the transport.
+        required: true
+      port:
+        description:
+          - Specifies the port to use when building the connection to the
+            remote device.
+        default: 22
+      username:
+        description:
+          - Configures the username to use to authenticate the connection to
+            the remote device.  This value is used to authenticate
+            the SSH session. If the value is not specified in the task, the
+            value of environment variable C(ANSIBLE_NET_USERNAME) will be used
+            instead.
+      password:
+        description:
+          - Specifies the password to use to authenticate the connection to
+            the remote device.   This value is used to authenticate
+            the SSH session. If the value is not specified in the task, the
+            value of environment variable C(ANSIBLE_NET_PASSWORD) will be used
+            instead.
+      timeout:
+        description:
+          - Specifies the timeout in seconds for communicating with the network
+            device for either connecting or sending commands.  If the timeout
+            is exceeded before the operation is completed, the module will
+            error.
+        default: 10
+      ssh_keyfile:
+        description:
+          - Specifies the SSH key to use to authenticate the connection to
+            the remote device.   This value is the path to the
+            key used to authenticate the SSH session. If the value is not
+            specified in the task, the value of environment variable
+            C(ANSIBLE_NET_SSH_KEYFILE)will be used instead.
+      authorize:
+        description:
+          - Instructs the module to enter privileged mode on the remote device
+            before sending any commands.  If not specified, the device will
+            attempt to execute all commands in non-privileged mode. If the
+            value is not specified in the task, the value of environment
+            variable C(ANSIBLE_NET_AUTHORIZE) will be used instead.
+        type: bool
+        default: 'no'
+      auth_pass:
+        description:
+          - Specifies the password to use if required to enter privileged mode
+            on the remote device.  If I(authorize) is false, then this argument
+            does nothing. If the value is not specified in the task, the value
+            of environment variable C(ANSIBLE_NET_AUTH_PASS) will be used
+            instead.
+"""
+
+EXAMPLES = """
+- name: Ensure Ethernet1/5 is in its default l2 interface state
+  cnos_l2_interface:
+    name: Ethernet1/5
+    state: unconfigured
+
+- name: Ensure Ethernet1/5 is configured for access vlan 20
+  cnos_l2_interface:
+    name: Ethernet1/5
+    mode: access
+    access_vlan: 20
+
+- name: Ensure Ethernet1/5 only has vlans 5-10 as trunk vlans
+  cnos_l2_interface:
+    name: Ethernet1/5
+    mode: trunk
+    native_vlan: 10
+    trunk_vlans: 5-10
+
+- name: Ensure Ethernet1/5 is a trunk port and ensure 2-50 are being tagged
+        (doesn't mean others aren't also being tagged)
+  cnos_l2_interface:
+    name: Ethernet1/5
+    mode: trunk
+    native_vlan: 10
+    trunk_vlans: 2-50
+
+- name: Ensure these VLANs are not being tagged on the trunk
+  cnos_l2_interface:
+    name: Ethernet1/5
+    mode: trunk
+    trunk_vlans: 51-4094
+    state: absent
+"""
+
+RETURN = """
+commands:
+  description: The list of configuration mode commands to send to the device
+  returned: always, except for the platforms that use Netconf transport to
+            manage the device.
+  type: list
+  sample:
+    - interface Ethernet1/5
+    - switchport access vlan 20
+"""
+
+import re
+from copy import deepcopy
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.common.utils import remove_default_spec
+from ansible.module_utils.network.cnos.cnos import get_config, load_config
+from ansible.module_utils.network.cnos.cnos import cnos_argument_spec
+from ansible.module_utils.network.cnos.cnos import run_commands
+
+
+def get_interface_type(interface):
+    intf_type = 'unknown'
+    if interface.upper()[:2] in ('ET', 'GI', 'FA', 'TE', 'FO', 'HU', 'TWE'):
+        intf_type = 'ethernet'
+    elif interface.upper().startswith('VL'):
+        intf_type = 'svi'
+    elif interface.upper().startswith('LO'):
+        intf_type = 'loopback'
+    elif interface.upper()[:2] in ('MG', 'MA'):
+        intf_type = 'management'
+    elif interface.upper().startswith('PO'):
+        intf_type = 'portchannel'
+    elif interface.upper().startswith('NV'):
+        intf_type = 'nve'
+
+    return intf_type
+
+
+def is_switchport(name, module):
+    intf_type = get_interface_type(name)
+
+    if intf_type in ('ethernet', 'portchannel'):
+        config = run_commands(module,
+                              ['show interface {0} switchport'.format(name)])[0]
+        match = re.search(r'Switchport              : enabled', config)
+        return bool(match)
+    return False
+
+
+def interface_is_portchannel(name, module):
+    if get_interface_type(name) == 'ethernet':
+        config = run_commands(module, ['show run interface {0}'.format(name)])[0]
+        if any(c in config for c in ['channel group', 'channel-group']):
+            return True
+    return False
+
+
+def get_switchport(name, module):
+    config = run_commands(module,
+                          ['show interface {0} switchport'.format(name)])[0]
+    mode = re.search(r'Switchport mode         : (?:.* )?(\w+)$', config, re.M)
+    access = re.search(r'Configured Vlans        : (\d+)', config)
+    native = re.search(r'Default/Native Vlan     : (\d+)', config)
+    trunk = re.search(r'Enabled Vlans           : (.+)$', config, re.M)
+    if mode:
+        mode = mode.group(1)
+    if access:
+        access = access.group(1)
+    if native:
+        native = native.group(1)
+    if trunk:
+        trunk = trunk.group(1)
+    if trunk == 'ALL':
+        trunk = '1-4094'
+
+    switchport_config = {
+        "interface": name,
+        "mode": mode,
+        "access_vlan": access,
+        "native_vlan": native,
+        "trunk_vlans": trunk,
+    }
+
+    return switchport_config
+
+
+def remove_switchport_config_commands(name, existing, proposed, module):
+    mode = proposed.get('mode')
+    commands = []
+    command = None
+
+    if mode == 'access':
+        av_check = existing.get('access_vlan') == proposed.get('access_vlan')
+        if av_check:
+            command = 'no switchport access vlan'
+            commands.append(command)
+
+    elif mode == 'trunk':
+        # Supported Remove Scenarios for trunk_vlans_list
+        # 1) Existing: 1,2,3 Proposed: 1,2,3 - Remove all
+        # 2) Existing: 1,2,3 Proposed: 1,2   - Remove 1,2 Leave 3
+        # 3) Existing: 1,2,3 Proposed: 2,3   - Remove 2,3 Leave 1
+        # 4) Existing: 1,2,3 Proposed: 4,5,6 - None removed.
+        # 5) Existing: None  Proposed: 1,2,3 - None removed.
+        existing_vlans = existing.get('trunk_vlans_list')
+        proposed_vlans = proposed.get('trunk_vlans_list')
+        vlans_to_remove = set(proposed_vlans).intersection(existing_vlans)
+
+        if vlans_to_remove:
+            proposed_allowed_vlans = proposed.get('trunk_allowed_vlans')
+            remove_trunk_allowed_vlans = proposed.get('trunk_vlans',
+                                                      proposed_allowed_vlans)
+            command = 'switchport trunk allowed vlan remove {0}'
+            command = command.format(remove_trunk_allowed_vlans)
+            commands.append(command)
+
+        native_check = existing.get('native_vlan') == proposed.get('native_vlan')
+        if native_check and proposed.get('native_vlan'):
+            command = 'no switchport trunk native vlan'
+            commands.append(command)
+
+    if commands:
+        commands.insert(0, 'interface ' + name)
+    return commands
+
+
+def get_switchport_config_commands(name, existing, proposed, module):
+    """Gets commands required to config a given switchport interface
+    """
+
+    proposed_mode = proposed.get('mode')
+    existing_mode = existing.get('mode')
+    commands = []
+    command = None
+
+    if proposed_mode != existing_mode:
+        if proposed_mode == 'trunk':
+            command = 'switchport mode trunk'
+        elif proposed_mode == 'access':
+            command = 'switchport mode access'
+
+    if command:
+        commands.append(command)
+
+    if proposed_mode == 'access':
+        av_check = str(existing.get('access_vlan')) == str(proposed.get('access_vlan'))
+        if not av_check:
+            command = 'switchport access vlan {0}'.format(proposed.get('access_vlan'))
+            commands.append(command)
+
+    elif proposed_mode == 'trunk':
+        tv_check = existing.get('trunk_vlans_list') == proposed.get('trunk_vlans_list')
+
+        if not tv_check:
+            if proposed.get('allowed'):
+                command = 'switchport trunk allowed vlan {0}'
+                command = command.format(proposed.get('trunk_allowed_vlans'))
+                commands.append(command)
+
+            else:
+                existing_vlans = existing.get('trunk_vlans_list')
+                proposed_vlans = proposed.get('trunk_vlans_list')
+                vlans_to_add = set(proposed_vlans).difference(existing_vlans)
+                if vlans_to_add:
+                    command = 'switchport trunk allowed vlan add {0}'
+                    command = command.format(proposed.get('trunk_vlans'))
+                    commands.append(command)
+
+        native_check = str(existing.get('native_vlan')) == str(proposed.get('native_vlan'))
+        if not native_check and proposed.get('native_vlan'):
+            command = 'switchport trunk native vlan {0}'
+            command = command.format(proposed.get('native_vlan'))
+            commands.append(command)
+
+    if commands:
+        commands.insert(0, 'interface ' + name)
+    return commands
+
+
+def is_switchport_default(existing):
+    """Determines if switchport has a default config based on mode
+    Args:
+        existing (dict): existing switchport configuration from Ansible mod
+    Returns:
+        boolean: True if switchport has OOB Layer 2 config, i.e.
+           vlan 1 and trunk all and mode is access
+    """
+
+    c1 = str(existing['access_vlan']) == '1'
+    c2 = str(existing['native_vlan']) == '1'
+    c3 = existing['trunk_vlans'] == '1-4094'
+    c4 = existing['mode'] == 'access'
+
+    default = c1 and c2 and c3 and c4
+
+    return default
+
+
+def default_switchport_config(name):
+    commands = []
+    commands.append('interface ' + name)
+    commands.append('switchport mode access')
+    commands.append('switch access vlan 1')
+    commands.append('switchport trunk native vlan 1')
+    commands.append('switchport trunk allowed vlan all')
+    return commands
+
+
+def vlan_range_to_list(vlans):
+    result = []
+    if vlans:
+        for part in vlans.split(','):
+            if part.lower() == 'none':
+                break
+            if part:
+                if '-' in part:
+                    start, stop = (int(i) for i in part.split('-'))
+                    result.extend(range(start, stop + 1))
+                else:
+                    result.append(int(part))
+    return sorted(result)
+
+
+def get_list_of_vlans(module):
+    config = run_commands(module, ['show vlan'])[0]
+    vlans = set()
+
+    lines = config.strip().splitlines()
+    for line in lines:
+        line_parts = line.split()
+        if line_parts:
+            try:
+                int(line_parts[0])
+            except ValueError:
+                continue
+            vlans.add(line_parts[0])
+
+    return list(vlans)
+
+
+def flatten_list(commands):
+    flat_list = []
+    for command in commands:
+        if isinstance(command, list):
+            flat_list.extend(command)
+        else:
+            flat_list.append(command)
+    return flat_list
+
+
+def map_params_to_obj(module):
+    obj = []
+
+    aggregate = module.params.get('aggregate')
+    if aggregate:
+        for item in aggregate:
+            for key in item:
+                if item.get(key) is None:
+                    item[key] = module.params[key]
+
+            obj.append(item.copy())
+    else:
+        obj.append({
+            'name': module.params['name'],
+            'mode': module.params['mode'],
+            'access_vlan': module.params['access_vlan'],
+            'native_vlan': module.params['native_vlan'],
+            'trunk_vlans': module.params['trunk_vlans'],
+            'trunk_allowed_vlans': module.params['trunk_allowed_vlans'],
+            'state': module.params['state']
+        })
+
+    return obj
+
+
+def main():
+    """ main entry point for module execution
+    """
+    element_spec = dict(
+        name=dict(type='str', aliases=['interface']),
+        mode=dict(choices=['access', 'trunk'], default='access'),
+        access_vlan=dict(type='str'),
+        native_vlan=dict(type='str'),
+        trunk_vlans=dict(type='str'),
+        trunk_allowed_vlans=dict(type='str'),
+        state=dict(choices=['absent', 'present', 'unconfigured'],
+                   default='present')
+    )
+
+    aggregate_spec = deepcopy(element_spec)
+
+    # remove default in aggregate spec, to handle common arguments
+    remove_default_spec(aggregate_spec)
+
+    argument_spec = dict(
+        aggregate=dict(type='list', elements='dict', options=aggregate_spec),
+    )
+
+    argument_spec.update(element_spec)
+    argument_spec.update(cnos_argument_spec)
+
+    module = AnsibleModule(argument_spec=argument_spec,
+                           mutually_exclusive=[['access_vlan', 'trunk_vlans'],
+                                               ['access_vlan', 'native_vlan'],
+                                               ['access_vlan', 'trunk_allowed_vlans']],
+                           supports_check_mode=True)
+
+    warnings = list()
+    commands = []
+    result = {'changed': False, 'warnings': warnings}
+
+    want = map_params_to_obj(module)
+    for w in want:
+        name = w['name']
+        mode = w['mode']
+        access_vlan = w['access_vlan']
+        state = w['state']
+        trunk_vlans = w['trunk_vlans']
+        native_vlan = w['native_vlan']
+        trunk_allowed_vlans = w['trunk_allowed_vlans']
+
+        args = dict(name=name, mode=mode, access_vlan=access_vlan,
+                    native_vlan=native_vlan, trunk_vlans=trunk_vlans,
+                    trunk_allowed_vlans=trunk_allowed_vlans)
+
+        proposed = dict((k, v) for k, v in args.items() if v is not None)
+
+        name = name.lower()
+
+        if mode == 'access' and state == 'present' and not access_vlan:
+            msg = 'access_vlan param required for mode=access && state=present'
+            module.fail_json(msg)
+
+        if mode == 'trunk' and access_vlan:
+            msg = 'access_vlan param not supported when using mode=trunk'
+            module.fail_json(msg)
+
+        if not is_switchport(name, module):
+            module.fail_json(msg='Ensure interface is configured to be a L2'
+                             '\nport first before using this module. You can use'
+                             '\nthe cnos_interface module for this.')
+
+        if interface_is_portchannel(name, module):
+            module.fail_json(msg='Cannot change L2 config on physical '
+                             '\nport because it is in a portchannel. '
+                             '\nYou should update the portchannel config.')
+
+        # existing will never be null for Eth intfs as there is always a default
+        existing = get_switchport(name, module)
+
+        # Safeguard check
+        # If there isn't an existing, something is wrong per previous comment
+        if not existing:
+            msg = 'Make sure you are using the FULL interface name'
+            module.fail_json(msg)
+
+        if trunk_vlans or trunk_allowed_vlans:
+            if trunk_vlans:
+                trunk_vlans_list = vlan_range_to_list(trunk_vlans)
+            elif trunk_allowed_vlans:
+                trunk_vlans_list = vlan_range_to_list(trunk_allowed_vlans)
+                proposed['allowed'] = True
+
+            existing_trunks_list = vlan_range_to_list((existing['trunk_vlans']))
+
+            existing['trunk_vlans_list'] = existing_trunks_list
+            proposed['trunk_vlans_list'] = trunk_vlans_list
+
+        current_vlans = get_list_of_vlans(module)
+
+        if state == 'present':
+            if access_vlan and access_vlan not in current_vlans:
+                module.fail_json(msg='You are trying to configure a VLAN'
+                                 ' on an interface that\ndoes not exist on the '
+                                 ' switch yet!', vlan=access_vlan)
+            elif native_vlan and native_vlan not in current_vlans:
+                module.fail_json(msg='You are trying to configure a VLAN on'
+                                 ' an interface that\ndoes not exist on the '
+                                 ' switch yet!', vlan=native_vlan)
+            else:
+                command = get_switchport_config_commands(name, existing,
+                                                         proposed, module)
+                commands.append(command)
+        elif state == 'unconfigured':
+            is_default = is_switchport_default(existing)
+            if not is_default:
+                command = default_switchport_config(name)
+                commands.append(command)
+        elif state == 'absent':
+            command = remove_switchport_config_commands(name, existing,
+                                                        proposed, module)
+            commands.append(command)
+
+        if trunk_vlans or trunk_allowed_vlans:
+            existing.pop('trunk_vlans_list')
+            proposed.pop('trunk_vlans_list')
+
+    cmds = flatten_list(commands)
+    if cmds:
+        if module.check_mode:
+            module.exit_json(changed=True, commands=cmds)
+        else:
+            result['changed'] = True
+            load_config(module, cmds)
+            if 'configure' in cmds:
+                cmds.pop(0)
+
+    result['commands'] = cmds
+
+    module.exit_json(**result)
+
+
+if __name__ == '__main__':
+    main()
diff --git a/test/integration/targets/cnos_l2_interface/aliases b/test/integration/targets/cnos_l2_interface/aliases
new file mode 100644
index 0000000000..cdb5033353
--- /dev/null
+++ b/test/integration/targets/cnos_l2_interface/aliases
@@ -0,0 +1,2 @@
+# No Lenovo Switch simulator yet, so not enabled
+unsupported
\ No newline at end of file
diff --git a/test/integration/targets/cnos_l2_interface/cnos_l2_interface_sample_hosts b/test/integration/targets/cnos_l2_interface/cnos_l2_interface_sample_hosts
new file mode 100644
index 0000000000..349674f5a4
--- /dev/null
+++ b/test/integration/targets/cnos_l2_interface/cnos_l2_interface_sample_hosts
@@ -0,0 +1,14 @@
+# You have to paste this dummy information  in /etc/ansible/hosts
+#    Notes:
+#    - Comments begin with the '#' character
+#    - Blank lines are ignored
+#    - Groups of hosts are delimited by [header] elements
+#    - You can enter hostnames or ip addresses
+#    - A hostname/ip can be a member of multiple groups
+#
+# In the /etc/ansible/hosts file u have to enter [cnos_l2_interface_sample] tag
+# Following you should specify IP Adresses details 
+# Please change <username> and <password> with appropriate value for your switch.
+
+[cnos_l2_interface_sample]
+10.241.107.39    ansible_network_os=cnos ansible_ssh_user=admin ansible_ssh_pass=admin deviceType=g8272_cnos test_interface=ethernet1/33 test_interface2=ethernet1/44
diff --git a/test/integration/targets/cnos_l2_interface/defaults/main.yaml b/test/integration/targets/cnos_l2_interface/defaults/main.yaml
new file mode 100644
index 0000000000..5f709c5aac
--- /dev/null
+++ b/test/integration/targets/cnos_l2_interface/defaults/main.yaml
@@ -0,0 +1,2 @@
+---
+testcase: "*"
diff --git a/test/integration/targets/cnos_l2_interface/tasks/cli.yaml b/test/integration/targets/cnos_l2_interface/tasks/cli.yaml
new file mode 100644
index 0000000000..6d2dbcbd6f
--- /dev/null
+++ b/test/integration/targets/cnos_l2_interface/tasks/cli.yaml
@@ -0,0 +1,24 @@
+---
+- name: collect all cli test cases
+  find:
+    paths: "{{ role_path }}/tests/cli"
+    patterns: "{{ testcase }}.yaml"
+  register: test_cases
+  delegate_to: localhost
+
+- name: set test_items
+  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
+
+- name: run test cases (connection=network_cli)
+  include: "{{ test_case_to_run }}"
+  with_items: "{{ test_items }}"
+  loop_control:
+    loop_var: test_case_to_run
+
+- name: run test case (connection=local)
+  include: "{{ test_case_to_run }} ansible_connection=local"
+  with_first_found:
+    - files: "{{ test_items|default([]) }}"
+      skip: true
+  loop_control:
+    loop_var: test_case_to_run
diff --git a/test/integration/targets/cnos_l2_interface/tasks/main.yaml b/test/integration/targets/cnos_l2_interface/tasks/main.yaml
new file mode 100644
index 0000000000..0863b30b81
--- /dev/null
+++ b/test/integration/targets/cnos_l2_interface/tasks/main.yaml
@@ -0,0 +1,5 @@
+---
+- { include: cli.yaml, tags: ['cli'] }
+#- block:
+#    - { include: cli.yaml, tags: ['cli'] }
+#  when: 'switch_type == "L2"'
diff --git a/test/integration/targets/cnos_l2_interface/tests/cli/agg.yaml b/test/integration/targets/cnos_l2_interface/tests/cli/agg.yaml
new file mode 100644
index 0000000000..ff15cee1af
--- /dev/null
+++ b/test/integration/targets/cnos_l2_interface/tests/cli/agg.yaml
@@ -0,0 +1,81 @@
+---
+- debug: msg="START connection={{ ansible_connection }} cnos_l2_interface aggregate test"
+
+- name: Setup - Ensure interfaces are switchport
+  cnos_config:
+    lines:
+      - switchport
+    parents:
+      - "interface {{ item }}"
+  loop:
+    - "{{ test_interface }}"
+    - "{{ test_interface2 }}"
+
+- name: "Setup vlans"
+  cnos_vlan:
+    aggregate:
+      - vlan_id: 6
+      - vlan_id: 15
+    provider: "{{ cli }}"
+
+- name: Setup - Remove interface aggregate before testing
+  cnos_l2_interface:
+    aggregate:
+      - { name: "{{ test_interface }}", mode: access, access_vlan: 6 }
+      - { name: "{{ test_interface2 }}", mode: access, access_vlan: 15 }
+    state: absent
+    provider: "{{ cli }}"
+
+- block:
+  - name: Configure interface for access_vlan aggregate
+    cnos_l2_interface: &conf_agg
+      aggregate:
+        - { name: "{{ test_interface }}", mode: access, access_vlan: 6 }
+        - { name: "{{ test_interface2 }}", mode: access, access_vlan: 15 }
+      provider: "{{ cli }}"
+    register: result
+
+  - assert:
+      that:
+        - "result.changed == true"
+
+  - name: Configure interface for access_vlan aggregate(Idempotence)
+    cnos_l2_interface: *conf_agg
+    register: result
+
+  - assert:
+      that:
+        - "result.changed == false"
+
+  - name: Remove interface aggregate
+    cnos_l2_interface: &rm_agg
+      aggregate:
+        - { name: "{{ test_interface }}", mode: access, access_vlan: 6 }
+        - { name: "{{ test_interface2 }}", mode: access, access_vlan: 15 }
+      provider: "{{ cli }}"
+      state: absent
+    register: result
+
+  - assert:
+      that:
+        - "result.changed == true"
+
+  - name: Remove interface aggregate(Idempotence)
+    cnos_l2_interface: *rm_agg
+    register: result
+
+  - assert:
+      that:
+        - "result.changed == false"
+
+  always:
+  - name: "remove vlans"
+    cnos_vlan:
+      aggregate:
+        - vlan_id: 6
+        - vlan_id: 15
+      state: absent
+      provider: "{{ cli }}"
+    ignore_errors: yes
+
+- debug: msg="END connection={{ ansible_connection }} cnos_l2_interface aggregate test"
diff --git a/test/integration/targets/cnos_l2_interface/tests/cli/sanity.yaml b/test/integration/targets/cnos_l2_interface/tests/cli/sanity.yaml
new file mode 100644
index 0000000000..d76d536be0
--- /dev/null
+++ b/test/integration/targets/cnos_l2_interface/tests/cli/sanity.yaml
@@ -0,0 +1,168 @@
+---
+- debug: msg="START connection={{ ansible_connection }} cnos_l2_interface sanity test"
+
+- name: "Setup interface"
+  cnos_config: &default
+    lines:
+      - "interface {{ test_interface }}"
+    provider: "{{ cli }}"
+
+#- name: set trunk encapsulation type
+#  cnos_config:
+#    lines:
+#      - switchport trunk encapsulation dot1q
+#    parents:
+#      - "interface {{ test_interface }}"
+#    provider: "{{ cli }}"
+
+- name: "Setup vlans"
+  cnos_vlan:
+    aggregate:
+      - vlan_id: 5
+      - vlan_id: 6
+      - vlan_id: 7
+      - vlan_id: 8
+      - vlan_id: 9
+      - vlan_id: 10
+      - vlan_id: 20
+    provider: "{{ cli }}"
+
+- block:
+  - name: Ensure interface is in its default switchport state
+    cnos_l2_interface: &def_swi
+      name: "{{ test_interface }}"
+      state: unconfigured
+      provider: "{{ cli }}"
+
+  - name: Ensure interface is configured for access vlan 20
+    cnos_l2_interface: &acc_vl
+      name: "{{ test_interface }}"
+      mode: access
+      access_vlan: 20
+      provider: "{{ cli }}"
+    register: result
+
+  - assert: &true
+      that:
+        - "result.changed == true"
+
+  - name: "access vlan Idempotence"
+    cnos_l2_interface: *acc_vl
+    register: result
+
+  - assert: &false
+      that:
+        - "result.changed == false"
+
+  - name: Ensure interface only has vlans 5-10 as trunk vlans
+    cnos_l2_interface: &tr_vl
+      name: "{{ test_interface }}"
+      mode: trunk
+      native_vlan: 10
+      trunk_allowed_vlans: 5-10
+      provider: "{{ cli }}"
+    register: result
+
+  - assert: *true
+
+  - name: "trunk vlan Idempotence"
+    cnos_l2_interface: *tr_vl
+    register: result
+
+  - assert: *false
+
+  - name: Ensure interface is a trunk port and ensure 2-50 are being tagged (doesn't mean others aren't also being tagged)
+    cnos_l2_interface: &tag
+      name: "{{ test_interface }}"
+      mode: trunk
+      native_vlan: 10
+      trunk_vlans: 2-50
+      provider: "{{ cli }}"
+    register: result
+
+  - assert: *true
+
+  - name: "tag vlan Idempotence"
+    cnos_l2_interface: *tag
+    register: result
+
+  - assert: *true
+
+  - name: Remove full trunk vlan range 2-50
+    cnos_l2_interface: &no_tag
+      name: "{{ test_interface }}"
+      mode: trunk
+      trunk_vlans: 2-50
+      state: absent
+      provider: "{{ cli }}"
+    register: result
+
+  - assert: *true
+
+  - name: Check Idempotence Remove full trunk vlan range 2-50
+    cnos_l2_interface: *no_tag
+    register: result
+
+  - assert: *false
+
+  - name: Reconfigure interface trunk port and ensure 2-50 are being tagged
+    cnos_l2_interface: *tag
+    register: result
+
+  - assert: *true
+
+  - name: Check Idempotence Reconfigure interface trunk port and ensure 2-50 are being tagged
+    cnos_l2_interface: *tag
+    register: result
+
+  - assert: *true
+
+  - name: Remove partial trunk vlan range 30-4094 are removed
+    cnos_l2_interface: &partial
+      name: "{{ test_interface }}"
+      mode: trunk
+      trunk_vlans: 30-4094
+      state: absent
+      provider: "{{ cli }}"
+    register: result
+
+  - assert: *false
+
+  - name: Check Idempotence Remove partial trunk vlan range 30-4094 are removed
+    cnos_l2_interface: *partial
+    register: result
+
+  - assert: *false
+
+  - name: put interface default state
+    cnos_l2_interface: *def_swi
+    register: result
+
+  - assert: *true
+
+  - name: "default state idempotence"
+    cnos_l2_interface: *def_swi
+    register: result
+
+  - assert: *true
+
+  always:
+    - name: "remove vlans"
+      cnos_vlan:
+        aggregate:
+          - vlan_id: 5
+          - vlan_id: 6
+          - vlan_id: 7
+          - vlan_id: 8
+          - vlan_id: 9
+          - vlan_id: 10
+          - vlan_id: 20
+        state: absent
+        provider: "{{ cli }}"
+      ignore_errors: yes
+
+    - name: "default interface"
+      cnos_config: *default
+      ignore_errors: yes
+
+- debug: msg="END connection={{ ansible_connection }} cnos_l2_interface sanity test"
diff --git a/test/integration/targets/cnos_l2_interface/vars/main.yaml b/test/integration/targets/cnos_l2_interface/vars/main.yaml
new file mode 100644
index 0000000000..aa25153ec8
--- /dev/null
+++ b/test/integration/targets/cnos_l2_interface/vars/main.yaml
@@ -0,0 +1,9 @@
+---
+cli:
+  host: "{{ inventory_hostname }}"
+  port: 22
+  username: admin
+  password: admin
+  timeout: 30
+  authorize: True
+  auth_pass:
diff --git a/test/units/modules/network/cnos/fixtures/show_interface_ethernet_1_33_switchport b/test/units/modules/network/cnos/fixtures/show_interface_ethernet_1_33_switchport
new file mode 100644
index 0000000000..a7c271c9a0
--- /dev/null
+++ b/test/units/modules/network/cnos/fixtures/show_interface_ethernet_1_33_switchport
@@ -0,0 +1,13 @@
+Interface Ethernet1/33
+  Switchport              : enabled
+  Switchport mode         : access
+  Ingress filter          : enable
+  Tag Ingress PVID        : disabled
+  Acceptable frame types  : all
+  Default/Native Vlan     : 1
+  Configured Vlans        : 1
+  Enabled Vlans           : 1
+  Egress-Tagged Vlans     : None
+  Private-VLAN            : Disabled
+  Private-VLAN Port Type  : None
+  Primary/Secondary VLAN  : None/None
diff --git a/test/units/modules/network/cnos/fixtures/show_interface_ethernet_1_44_switchport b/test/units/modules/network/cnos/fixtures/show_interface_ethernet_1_44_switchport
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/units/modules/network/cnos/fixtures/show_interface_ethernet_1_45_switchport b/test/units/modules/network/cnos/fixtures/show_interface_ethernet_1_45_switchport
new file mode 100644
index 0000000000..3001009112
--- /dev/null
+++ b/test/units/modules/network/cnos/fixtures/show_interface_ethernet_1_45_switchport
@@ -0,0 +1,14 @@
+Interface Ethernet1/45
+  Switchport              : enabled
+  Switchport mode         : access
+  Ingress filter          : enable
+  Tag Ingress PVID        : disabled
+  Acceptable frame types  : all
+  Default/Native Vlan     : 1
+  Configured Vlans        : 1
+  Enabled Vlans           : 1
+  Egress-Tagged Vlans     : None
+  Private-VLAN            : Disabled
+  Private-VLAN Port Type  : None
+  Primary/Secondary VLAN  : None/None
+
diff --git a/test/units/modules/network/cnos/fixtures/show_run_interface_ethernet_1_33 b/test/units/modules/network/cnos/fixtures/show_run_interface_ethernet_1_33
new file mode 100644
index 0000000000..a7c271c9a0
--- /dev/null
+++ b/test/units/modules/network/cnos/fixtures/show_run_interface_ethernet_1_33
@@ -0,0 +1,13 @@
+Interface Ethernet1/33
+  Switchport              : enabled
+  Switchport mode         : access
+  Ingress filter          : enable
+  Tag Ingress PVID        : disabled
+  Acceptable frame types  : all
+  Default/Native Vlan     : 1
+  Configured Vlans        : 1
+  Enabled Vlans           : 1
+  Egress-Tagged Vlans     : None
+  Private-VLAN            : Disabled
+  Private-VLAN Port Type  : None
+  Primary/Secondary VLAN  : None/None
diff --git a/test/units/modules/network/cnos/fixtures/show_run_interface_ethernet_1_45 b/test/units/modules/network/cnos/fixtures/show_run_interface_ethernet_1_45
new file mode 100644
index 0000000000..3001009112
--- /dev/null
+++ b/test/units/modules/network/cnos/fixtures/show_run_interface_ethernet_1_45
@@ -0,0 +1,14 @@
+Interface Ethernet1/45
+  Switchport              : enabled
+  Switchport mode         : access
+  Ingress filter          : enable
+  Tag Ingress PVID        : disabled
+  Acceptable frame types  : all
+  Default/Native Vlan     : 1
+  Configured Vlans        : 1
+  Enabled Vlans           : 1
+  Egress-Tagged Vlans     : None
+  Private-VLAN            : Disabled
+  Private-VLAN Port Type  : None
+  Primary/Secondary VLAN  : None/None
+
diff --git a/test/units/modules/network/cnos/fixtures/show_vlan b/test/units/modules/network/cnos/fixtures/show_vlan
new file mode 100644
index 0000000000..457992fee5
--- /dev/null
+++ b/test/units/modules/network/cnos/fixtures/show_vlan
@@ -0,0 +1,97 @@
+VLAN     Name                             Status  IPMC FLOOD Ports
+
+======== ================================ ======= ========== ===================
+1        default                          ACTIVE  IPv6
+                                                             po1(u)
+                                                             po2(u)
+                                                             po11(u)
+                                                             po12(u)
+                                                             po13(t)
+                                                             po14(u)
+                                                             po15(u)
+                                                             po17(t)
+                                                             po20(u)
+                                                             po100(t)
+                                                             po1001(u)
+                                                             po1002(u)
+                                                             po1003(t)
+                                                             po1004(t)
+                                                             Ethernet1/2(u)
+                                                             Ethernet1/3(t)
+                                                             Ethernet1/4(t)
+                                                             Ethernet1/9(u)
+                                                             Ethernet1/10(u)
+                                                             Ethernet1/14(u)
+                                                             Ethernet1/15(u)
+                                                             Ethernet1/16(u)
+                                                             Ethernet1/17(u)
+                                                             Ethernet1/18(u)
+                                                             Ethernet1/19(u)
+                                                             Ethernet1/20(u)
+                                                             Ethernet1/21(u)
+                                                             Ethernet1/22(u)
+                                                             Ethernet1/23(u)
+                                                             Ethernet1/24(u)
+                                                             Ethernet1/25(u)
+                                                             Ethernet1/26(u)
+                                                             Ethernet1/27(u)
+                                                             Ethernet1/28(u)
+                                                             Ethernet1/29(u)
+                                                             Ethernet1/30(u)
+                                                             Ethernet1/31(u)
+                                                             Ethernet1/32(u)
+                                                             Ethernet1/33(u)
+                                                             Ethernet1/34(u)
+                                                             Ethernet1/35(u)
+                                                             Ethernet1/36(u)
+                                                             Ethernet1/37(u)
+                                                             Ethernet1/38(u)
+                                                             Ethernet1/39(u)
+                                                             Ethernet1/40(u)
+                                                             Ethernet1/41(u)
+                                                             Ethernet1/42(u)
+                                                             Ethernet1/43(u)
+                                                             Ethernet1/44(u)
+                                                             Ethernet1/45(u)
+                                                             Ethernet1/46(u)
+                                                             Ethernet1/47(u)
+                                                             Ethernet1/48(u)
+                                                             Ethernet1/49(u)
+                                                             Ethernet1/50(u)
+                                                             Ethernet1/51(u)
+                                                             Ethernet1/52(u)
+                                                             Ethernet1/53(u)
+                                                             Ethernet1/54(u)
+2        VLAN0002                         ACTIVE  IPv6
+                                                             po13(t)
+                                                             po17(t)
+                                                             po100(t)
+                                                             po1003(t)
+                                                             po1004(t)
+                                                             Ethernet1/3(t)
+                                                             Ethernet1/4(t)
+3        VLAN0003                         ACTIVE  IPv4,IPv6
+                                                             po13(t)
+                                                             po17(t)
+                                                             po100(t)
+                                                             po1003(t)
+                                                             po1004(t)
+                                                             Ethernet1/3(t)
+                                                             Ethernet1/4(t)
+12       VLAN0012                         ACTIVE  IPv4,IPv6
+                                                             po13(t)
+                                                             po17(t)
+                                                             po100(t)
+                                                             po1003(t)
+                                                             po1004(t)
+                                                             Ethernet1/3(t)
+                                                             Ethernet1/4(t)
+13       anil                             ACTIVE  IPv4,IPv6
+                                                             po13(t)
+                                                             po17(t)
+                                                             po100(t)
+                                                             po1003(t)
+                                                             po1004(t)
+                                                             Ethernet1/3(t)
+                                                             Ethernet1/4(t)
+
diff --git a/test/units/modules/network/cnos/test_cnos_l2_interface.py b/test/units/modules/network/cnos/test_cnos_l2_interface.py
new file mode 100644
index 0000000000..ad1c1a65d5
--- /dev/null
+++ b/test/units/modules/network/cnos/test_cnos_l2_interface.py
@@ -0,0 +1,158 @@
+#
+# (c) 2018 Lenovo.
+#
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+#
+from __future__ import (absolute_import, division, print_function)
+__metaclass__ = type
+
+import re
+import json
+
+from units.compat.mock import patch
+from ansible.modules.network.cnos import cnos_l2_interface
+from units.modules.utils import set_module_args
+from .cnos_module import TestCnosModule, load_fixture
+
+
+class TestCnosL2InterfaceModule(TestCnosModule):
+    module = cnos_l2_interface
+
+    def setUp(self):
+        super(TestCnosL2InterfaceModule, self).setUp()
+        self._patch_get_config = patch(
+            'ansible.modules.network.cnos.cnos_l2_interface.get_config'
+        )
+        self._patch_load_config = patch(
+            'ansible.modules.network.cnos.cnos_l2_interface.load_config'
+        )
+        self._patch_run_commands = patch(
+            'ansible.modules.network.cnos.cnos_l2_interface.run_commands'
+        )
+
+        self._get_config = self._patch_get_config.start()
+        self._load_config = self._patch_load_config.start()
+        self._run_commands = self._patch_run_commands.start()
+        self._run_commands.side_effect = self.run_commands_load_fixtures
+
+    def run_commands_load_fixtures(self, module, commands, *args, **kwargs):
+        return self.load_fixtures(
+            commands,
+            destination=self._run_commands,
+            return_values=True
+        )
+
+    def tearDown(self):
+        super(TestCnosL2InterfaceModule, self).tearDown()
+        self._patch_get_config.stop()
+        self._patch_load_config.stop()
+        self._patch_run_commands.stop()
+
+    def load_fixtures(self, commands=None,
+                      destination=None, return_values=False):
+        side_effects = []
+
+        if not destination:
+            destination = self._get_config
+
+        if not commands:
+            commands = ['cnos_config_config.cfg']
+
+        for command in commands:
+            filename = str(command).replace(' ', '_')
+            filename = str(filename).replace('/', '_')
+            side_effects.append(load_fixture(filename))
+
+        if return_values is True:
+            return side_effects
+
+        destination.side_effect = side_effects
+        return None
+
+    def test_cnos_l2_interface_access_vlan(self, *args, **kwargs):
+        set_module_args(dict(
+            name='Ethernet 1/33',
+            mode='access',
+            access_vlan=13,
+        ))
+        result = self.execute_module(changed=True)
+        self.assertEqual(
+            result,
+            {
+                'commands': [
+                    'interface ethernet 1/33',
+                    'switchport access vlan 13'
+                ],
+                'changed': True,
+                'warnings': []
+            }
+        )
+
+    def test_cnos_l2_interface_vlan_does_not_exist(self, *args, **kwargs):
+        set_module_args(dict(
+            name='Ethernet 1/33',
+            mode='access',
+            access_vlan=10,
+        ))
+        result = self.execute_module(failed=True)
+        self.assertEqual(
+            result,
+            {
+                'msg': 'You are trying to configure a VLAN on an interface '
+                       'that\ndoes not exist on the  switch yet!',
+                'failed': True,
+                'vlan': '10'
+            }
+        )
+
+    def test_cnos_l2_interface_incorrect_state(self, *args, **kwargs):
+        set_module_args(dict(
+            name='Ethernet 1/44',
+            mode='access',
+            access_vlan=10,
+        ))
+        result = self.execute_module(failed=True)
+        self.assertEqual(
+            result,
+            {
+                'msg': 'Ensure interface is configured to be a L2\nport first '
+                       'before using this module. You can use\nthe cnos_'
+                       'interface module for this.',
+                'failed': True
+            }
+        )
+
+    def test_cnos_l2_interface_trunk(self, *args, **kwargs):
+        set_module_args(dict(
+            name='Ethernet 1/45',
+            mode='trunk',
+            native_vlan='12',
+            trunk_allowed_vlans='13,12'
+        ))
+        result = self.execute_module(changed=True)
+        self.assertEqual(
+            result,
+            {
+                'commands': [
+                    'interface ethernet 1/45',
+                    'switchport mode trunk',
+                    'switchport trunk allowed vlan 13,12',
+                    'switchport trunk native vlan 12'
+                ],
+                'changed': True,
+                'warnings': []
+            }
+        )

commit 5f7e1fc3069442eb46ec34ca4214364781e7b627
Author: Cove Schneider <covecs@gmail.com>
Date:   Mon Oct 14 13:49:53 2013 -0700

    Un-camelcase DockerContainers, rename class to DockerManager().

diff --git a/library/cloud/docker b/library/cloud/docker
index 1c9e6c61e6..e1a9b27f61 100644
--- a/library/cloud/docker
+++ b/library/cloud/docker
@@ -148,7 +148,7 @@ on the host:
     docker: image=centos command="service tomcat6 start" ports=:8080
 
 The tomcat server's port is NAT'ed to a dynamic port on the host, but you can determine which port the server was
-mapped to using $DockerContainers:
+mapped to using docker_containers:
 
 - hosts: web
   sudo: yes
@@ -157,7 +157,7 @@ mapped to using $DockerContainers:
     docker: image=centos command="service tomcat6 start" ports=8080 count=5
   - name: Display IP address and port mappings for containers
     debug: msg="Mapped to {{inventory_hostname}}:{{item.NetworkSettings.PortMapping.Tcp['8080']}}"
-    with_items: $DockerContainers
+    with_items: docker_containers
 
 Just as in the previous example, but iterates over the list of docker containers with a sequence:
 
@@ -169,16 +169,19 @@ Just as in the previous example, but iterates over the list of docker containers
   - name: run tomcat servers
     docker: image=centos command="service tomcat6 start" ports=8080 count={{start_containers_count}}
   - name: Display IP address and port mappings for containers
-    debug: msg="Mapped to {{inventory_hostname}}:{{DockerContainers[{{item}}].NetworkSettings.PortMapping.Tcp['8080']}}"
+    debug: msg="Mapped to {{inventory_hostname}}:{{docker_containers[{{item}}].NetworkSettings.PortMapping.Tcp['8080']}}"
     with_sequence: start=0 end={{start_containers_count - 1}}
 
-Stop and remove all of the running tomcat containers:
+Stop, remove all of the running tomcat containers and list the exit code from the stopped containers:
 
 - hosts: web
   sudo: yes
   tasks:
   - name: stop tomcat servers
     docker: image=centos command="service tomcat6 start" state=absent
+  - name: Display return codes from stopped containers
+    debug: msg="Returned {{inventory_hostname}}:{{item}}"
+    with_items: docker_containers
 '''
 
 try:
@@ -208,9 +211,9 @@ def _human_to_bytes(number):
     sys.exit(1)
 
 def _ansible_facts(container_list):
-    return {"DockerContainers": container_list}
+    return {"docker_containers": container_list}
 
-class AnsibleDocker:
+class DockerManager:
     
     counters = {'created':0, 'started':0, 'stopped':0, 'killed':0, 'removed':0, 'restarted':0, 'pull':0}
 
@@ -367,17 +370,17 @@ def main():
     )
 
     try:
-        docker_client = AnsibleDocker(module)
+        manager = DockerManager(module)
         state = module.params.get('state')
         count = int(module.params.get('count'))
 
         if count < 1:
             module.fail_json(msg="Count must be positive number")
     
-        running_containers = docker_client.get_running_containers()
+        running_containers = manager.get_running_containers()
         running_count = len(running_containers)
         delta = count - running_count
-        deployed_containers = docker_client.get_deployed_containers()
+        deployed_containers = manager.get_deployed_containers()
         facts = None
         failed = False
         changed = False
@@ -387,45 +390,45 @@ def main():
     
             # start more containers if we don't have enough
             if delta > 0:
-                containers = docker_client.create_containers(delta)
-                docker_client.start_containers(containers)
+                containers = manager.create_containers(delta)
+                manager.start_containers(containers)
                 
             # stop containers if we have too many
             elif delta < 0:
-                docker_client.stop_containers(running_containers[0:abs(delta)])
-                docker_client.remove_containers(running_containers[0:abs(delta)])
+                manager.stop_containers(running_containers[0:abs(delta)])
+                manager.remove_containers(running_containers[0:abs(delta)])
             
-            facts = docker_client.get_running_containers()
+            facts = manager.get_running_containers()
     
         # stop and remove containers
         elif state == "absent":
-            facts = docker_client.stop_containers(deployed_containers)
-            docker_client.remove_containers(containers)
+            facts = manager.stop_containers(deployed_containers)
+            manager.remove_containers(containers)
     
         # stop containers
         elif state == "stopped":
-            facts = docker_client.stop_containers(running_containers)
+            facts = manager.stop_containers(running_containers)
     
         # kill containers
         elif state == "killed":
-            docker_client.kill_containers(running_containers)
+            manager.kill_containers(running_containers)
     
         # restart containers
         elif state == "restarted":
-            docker_client.restart_containers(running_containers)        
+            manager.restart_containers(running_containers)        
     
         msg = "%s container(s) running image %s with command %s" % \
-                (docker_client.get_summary_counters_msg(), module.params.get('image'), module.params.get('command'))
-        changed = docker_client.has_changed()
+                (manager.get_summary_counters_msg(), module.params.get('image'), module.params.get('command'))
+        changed = manager.has_changed()
     
         module.exit_json(failed=failed, changed=changed, msg=msg, ansible_facts=_ansible_facts(facts))
 
     except docker.client.APIError as e:
-        changed = docker_client.has_changed()
+        changed = manager.has_changed()
         module.exit_json(failed=True, changed=changed, msg="Docker API error: " + e.explanation)
 
     except RequestException as e:
-        changed = docker_client.has_changed()
+        changed = manager.has_changed()
         module.exit_json(failed=True, changed=changed, msg=repr(e))
         
 # this is magic, see lib/ansible/module_common.py

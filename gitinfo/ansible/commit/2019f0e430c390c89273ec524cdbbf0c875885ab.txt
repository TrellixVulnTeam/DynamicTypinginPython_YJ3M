commit 2019f0e430c390c89273ec524cdbbf0c875885ab
Author: Paul Neumann <paul104x@yahoo.de>
Date:   Fri Nov 23 10:13:40 2018 +0100

    nxos_facts: Do not gather redundant neighbor data (#49024)
    
    * nxos_facts: Remove dead code
    
    The commit e51964e made this redundant as the structured case is handled
    elsewhere.
    
    * nxos_facts: Do not gather neighbors redundantly
    
    LLDP reports the neighbor using the abbreviated interface name, whereas
    CDP reports the neighbor using the full interface name. Normalize the
    local interface name in the LLDP case, so there is no redundant
    information. Due to the order of the gathering, CDP neighbors are saved
    in case both LLDP and CDP data is available on a certain interface.

diff --git a/lib/ansible/modules/network/nxos/nxos_facts.py b/lib/ansible/modules/network/nxos/nxos_facts.py
index 3c2c7f52a3..157974e7f2 100644
--- a/lib/ansible/modules/network/nxos/nxos_facts.py
+++ b/lib/ansible/modules/network/nxos/nxos_facts.py
@@ -130,7 +130,9 @@ ansible_net_interfaces:
   returned: when interfaces is configured
   type: dict
 ansible_net_neighbors:
-  description: The list of LLDP and CDP neighbors from the device
+  description:
+    - The list of LLDP and CDP neighbors from the device. If both,
+      CDP and LLDP neighbor data is present on one port, CDP is preferred.
   returned: when interfaces is configured
   type: dict
 
@@ -173,6 +175,7 @@ import re
 from ansible.module_utils.network.nxos.nxos import run_commands, get_config
 from ansible.module_utils.network.nxos.nxos import get_capabilities, get_interface_type
 from ansible.module_utils.network.nxos.nxos import nxos_argument_spec, check_args
+from ansible.module_utils.network.nxos.nxos import normalize_interface
 from ansible.module_utils.basic import AnsibleModule
 from ansible.module_utils.connection import ConnectionError
 from ansible.module_utils.six import string_types, iteritems
@@ -488,7 +491,7 @@ class Interfaces(FactsBase):
             data = [data]
 
         for item in data:
-            local_intf = item['l_port_id']
+            local_intf = normalize_interface(item['l_port_id'])
             objects[local_intf] = list()
             nbor = dict()
             nbor['port'] = item['port_id']
@@ -632,34 +635,20 @@ class Interfaces(FactsBase):
 
     def populate_neighbors(self, data):
         objects = dict()
-        if isinstance(data, str):
-            # if there are no neighbors the show command returns
-            # ERROR: No neighbour information
-            if data.startswith('ERROR'):
-                return dict()
+        # if there are no neighbors the show command returns
+        # ERROR: No neighbour information
+        if data.startswith('ERROR'):
+            return dict()
 
-            regex = re.compile(r'(\S+)\s+(\S+)\s+\d+\s+\w+\s+(\S+)')
+        regex = re.compile(r'(\S+)\s+(\S+)\s+\d+\s+\w+\s+(\S+)')
 
-            for item in data.split('\n')[4:-1]:
-                match = regex.match(item)
-                if match:
-                    nbor = {'host': match.group(1), 'port': match.group(3)}
-                    if match.group(2) not in objects:
-                        objects[match.group(2)] = []
-                    objects[match.group(2)].append(nbor)
-
-        elif isinstance(data, dict):
-            data = data['TABLE_nbor']['ROW_nbor']
-            if isinstance(data, dict):
-                data = [data]
-
-            for item in data:
-                local_intf = item['l_port_id']
+        for item in data.split('\n')[4:-1]:
+            match = regex.match(item)
+            if match:
+                nbor = {'host': match.group(1), 'port': match.group(3)}
+                local_intf = normalize_interface(match.group(2))
                 if local_intf not in objects:
-                    objects[local_intf] = list()
-                nbor = dict()
-                nbor['port'] = item['port_id']
-                nbor['host'] = item['chassis_id']
+                    objects[local_intf] = []
                 objects[local_intf].append(nbor)
 
         return objects

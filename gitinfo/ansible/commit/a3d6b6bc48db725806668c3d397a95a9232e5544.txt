commit a3d6b6bc48db725806668c3d397a95a9232e5544
Author: Andre Lehmann <aisberg@posteo.de>
Date:   Tue Mar 31 19:03:54 2020 +0200

    Add pacman support to package_facts (#66596)
    
    * Add pacman support

diff --git a/changelogs/fragments/66596-package_facts-add-pacman-support.yaml b/changelogs/fragments/66596-package_facts-add-pacman-support.yaml
new file mode 100644
index 0000000000..adefd662c0
--- /dev/null
+++ b/changelogs/fragments/66596-package_facts-add-pacman-support.yaml
@@ -0,0 +1,2 @@
+minor_changes:
+  - package_facts.py - Add support for Pacman package manager.
diff --git a/lib/ansible/modules/packaging/os/package_facts.py b/lib/ansible/modules/packaging/os/package_facts.py
index 9dd0575f29..b00db2fe2c 100644
--- a/lib/ansible/modules/packaging/os/package_facts.py
+++ b/lib/ansible/modules/packaging/os/package_facts.py
@@ -23,7 +23,7 @@ options:
       - Since 2.8 this is a list and can support multiple package managers per system.
       - The 'portage' and 'pkg' options were added in version 2.8.
     default: ['auto']
-    choices: ['auto', 'rpm', 'apt', 'portage', 'pkg']
+    choices: ['auto', 'rpm', 'apt', 'portage', 'pkg', 'pacman']
     required: False
     type: list
   strategy:
@@ -206,6 +206,8 @@ ansible_facts:
         }
 '''
 
+import re
+
 from ansible.module_utils._text import to_native, to_text
 from ansible.module_utils.basic import AnsibleModule, missing_required_lib
 from ansible.module_utils.common.process import get_bin_path
@@ -280,6 +282,44 @@ class APT(LibMgr):
         return dict(name=package, version=ac_pkg.version, arch=ac_pkg.architecture, category=ac_pkg.section, origin=ac_pkg.origins[0].origin)
 
 
+class PACMAN(CLIMgr):
+
+    CLI = 'pacman'
+
+    def list_installed(self):
+        rc, out, err = module.run_command([self._cli, '-Qi'], environ_update=dict(LC_ALL='C'))
+        if rc != 0 or err:
+            raise Exception("Unable to list packages rc=%s : %s" % (rc, err))
+        return out.split("\n\n")[:-1]
+
+    def get_package_details(self, package):
+        # parse values of details that might extend over several lines
+        raw_pkg_details = {}
+        last_detail = None
+        for line in package.splitlines():
+            m = re.match(r"([\w ]*[\w]) +: (.*)", line)
+            if m:
+                last_detail = m.group(1)
+                raw_pkg_details[last_detail] = m.group(2)
+            else:
+                # append value to previous detail
+                raw_pkg_details[last_detail] = raw_pkg_details[last_detail] + "  " + line.lstrip()
+
+        provides = None
+        if raw_pkg_details['Provides'] != 'None':
+            provides = [
+                p.split('=')[0]
+                for p in raw_pkg_details['Provides'].split('  ')
+            ]
+
+        return {
+            'name': raw_pkg_details['Name'],
+            'version': raw_pkg_details['Version'],
+            'arch': raw_pkg_details['Architecture'],
+            'provides': provides,
+        }
+
+
 class PKG(CLIMgr):
 
     CLI = 'pkg'

commit 96c9d9fdaa68a5872738e99591168a00738fe24d
Author: Tim Rupp <caphrim007@gmail.com>
Date:   Fri Nov 2 15:38:36 2018 -0700

    Removes the f5-sdk from bigip_sys_db (#48015)

diff --git a/lib/ansible/modules/network/f5/bigip_sys_db.py b/lib/ansible/modules/network/f5/bigip_sys_db.py
index 264523535e..99a586af45 100644
--- a/lib/ansible/modules/network/f5/bigip_sys_db.py
+++ b/lib/ansible/modules/network/f5/bigip_sys_db.py
@@ -1,7 +1,7 @@
 #!/usr/bin/python
 # -*- coding: utf-8 -*-
 #
-# Copyright (c) 2016 F5 Networks Inc.
+# Copyright: (c) 2016, F5 Networks Inc.
 # GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
 
 from __future__ import absolute_import, division, print_function
@@ -95,80 +95,135 @@ value:
 from ansible.module_utils.basic import AnsibleModule
 
 try:
-    from library.module_utils.network.f5.bigip import HAS_F5SDK
-    from library.module_utils.network.f5.bigip import F5Client
+    from library.module_utils.network.f5.bigip import F5RestClient
     from library.module_utils.network.f5.common import F5ModuleError
     from library.module_utils.network.f5.common import AnsibleF5Parameters
     from library.module_utils.network.f5.common import cleanup_tokens
     from library.module_utils.network.f5.common import f5_argument_spec
-
-    try:
-        from library.module_utils.network.f5.common import iControlUnexpectedHTTPError
-    except ImportError:
-        HAS_F5SDK = False
+    from library.module_utils.network.f5.common import exit_json
+    from library.module_utils.network.f5.common import fail_json
 except ImportError:
-    from ansible.module_utils.network.f5.bigip import HAS_F5SDK
-    from ansible.module_utils.network.f5.bigip import F5Client
+    from ansible.module_utils.network.f5.bigip import F5RestClient
     from ansible.module_utils.network.f5.common import F5ModuleError
     from ansible.module_utils.network.f5.common import AnsibleF5Parameters
     from ansible.module_utils.network.f5.common import cleanup_tokens
     from ansible.module_utils.network.f5.common import f5_argument_spec
-
-    try:
-        from ansible.module_utils.network.f5.common import iControlUnexpectedHTTPError
-    except ImportError:
-        HAS_F5SDK = False
+    from ansible.module_utils.network.f5.common import exit_json
+    from ansible.module_utils.network.f5.common import fail_json
 
 
 class Parameters(AnsibleF5Parameters):
     api_map = {
         'defaultValue': 'default_value'
     }
-    api_attributes = ['value']
-    updatables = ['value']
-    returnables = ['name', 'value', 'default_value']
+    api_attributes = [
+        'value',
+    ]
+    updatables = [
+        'value',
+    ]
+    returnables = [
+        'name',
+        'value',
+        'default_value',
+    ]
+
+
+class ApiParameters(Parameters):
+    pass
+
 
+class ModuleParameters(Parameters):
+    pass
+
+
+class Changes(Parameters):
     def to_return(self):
         result = {}
-        for returnable in self.returnables:
-            result[returnable] = getattr(self, returnable)
-        result = self._filter_params(result)
+        try:
+            for returnable in self.returnables:
+                change = getattr(self, returnable)
+                if isinstance(change, dict):
+                    result.update(change)
+                else:
+                    result[returnable] = change
+            result = self._filter_params(result)
+        except Exception:
+            pass
         return result
 
-    @property
-    def name(self):
-        return self._values['key']
 
-    @name.setter
-    def name(self, value):
-        self._values['key'] = value
+class UsableChanges(Changes):
+    pass
 
 
-class Changes(Parameters):
+class ReportableChanges(Changes):
     pass
 
 
+class Difference(object):
+    def __init__(self, want, have=None):
+        self.want = want
+        self.have = have
+
+    def compare(self, param):
+        try:
+            result = getattr(self, param)
+            return result
+        except AttributeError:
+            return self.__default(param)
+
+    def __default(self, param):
+        attr1 = getattr(self.want, param)
+        try:
+            attr2 = getattr(self.have, param)
+            if attr1 != attr2:
+                return attr1
+        except AttributeError:
+            return attr1
+
+    @property
+    def value(self):
+        if self.want.state == 'reset':
+            if str(self.have.value) != str(self.have.default_value):
+                return self.have.default_value
+        if self.want.value != self.have.value:
+            return self.want.value
+
+
 class ModuleManager(object):
     def __init__(self, *args, **kwargs):
-        self.module = kwargs.get('module', None)
-        self.client = kwargs.get('client', None)
-        self.have = None
-        self.want = Parameters(params=self.module.params)
-        self.changes = Changes()
+        self.module = kwargs.pop('module', None)
+        self.client = kwargs.pop('client', None)
+        self.want = ModuleParameters(params=self.module.params)
+        self.have = ApiParameters()
+        self.changes = UsableChanges()
+
+    def _announce_deprecations(self, result):
+        warnings = result.pop('__warnings', [])
+        for warning in warnings:
+            self.module.deprecate(
+                msg=warning['msg'],
+                version=warning['version']
+            )
 
     def _update_changed_options(self):
-        changed = {}
-        for key in Parameters.updatables:
-            if getattr(self.want, key) is not None:
-                attr1 = getattr(self.want, key)
-                attr2 = getattr(self.have, key)
-                if attr1 != attr2:
-                    changed[key] = attr1
-        if self.want.state == 'reset':
-            if str(self.have.value) != str(self.have.default_value):
-                changed[self.want.key] = self.have.default_value
+        diff = Difference(self.want, self.have)
+        updatables = Parameters.updatables
+        changed = dict()
+        for k in updatables:
+            change = diff.compare(k)
+            if change is None:
+                continue
+            else:
+                if isinstance(change, dict):
+                    changed.update(change)
+                else:
+                    changed[k] = change
         if changed:
-            self.changes = Changes(params=changed)
+            changed['name'] = self.want.key
+            changed['default_value'] = self.have.default_value
+            self.changes = UsableChanges(params=changed)
             return True
         return False
 
@@ -177,40 +232,40 @@ class ModuleManager(object):
         result = dict()
         state = self.want.state
 
-        try:
-            if state == "present":
-                changed = self.present()
-            elif state == "reset":
-                changed = self.reset()
-        except iControlUnexpectedHTTPError as e:
-            raise F5ModuleError(str(e))
-
-        changes = self.changes.to_return()
+        if state == "present":
+            changed = self.present()
+        elif state == "reset":
+            changed = self.reset()
+
+        reportable = ReportableChanges(params=self.changes.to_return())
+        changes = reportable.to_return()
         result.update(**changes)
         result.update(dict(changed=changed))
+        self._announce_deprecations(result)
         return result
 
-    def read_current_from_device(self):
-        resource = self.client.api.tm.sys.dbs.db.load(
-            name=self.want.key
-        )
-        result = resource.attrs
-        return Parameters(params=result)
-
-    def exists(self):
-        resource = self.client.api.tm.sys.dbs.db.load(
-            name=self.want.key
-        )
-        if str(resource.value) == str(self.want.value):
-            return True
-        return False
-
     def present(self):
         if self.exists():
             return False
         else:
             return self.update()
 
+    def reset(self):
+        self.have = self.read_current_from_device()
+        if not self.should_update():
+            return False
+        if self.module.check_mode:
+            return True
+        self.reset_on_device()
+        self.want.update({'key': self.want.key})
+        self.want.update({'value': self.have.default_value})
+        if self.exists():
+            return True
+        else:
+            raise F5ModuleError(
+                "Failed to reset the DB variable"
+            )
+
     def update(self):
         if self.want.value is None:
             raise F5ModuleError(
@@ -230,34 +285,86 @@ class ModuleManager(object):
             return True
         return False
 
+    def exists(self):
+        uri = "https://{0}:{1}/mgmt/tm/sys/db/{2}".format(
+            self.client.provider['server'],
+            self.client.provider['server_port'],
+            self.want.key
+        )
+        resp = self.client.api.get(uri)
+        try:
+            response = resp.json()
+        except ValueError as ex:
+            raise F5ModuleError(str(ex))
+        if str(response['value']) == str(self.want.value):
+            return True
+        return False
+
+    def read_current_from_device(self):
+        uri = "https://{0}:{1}/mgmt/tm/sys/db/{2}".format(
+            self.client.provider['server'],
+            self.client.provider['server_port'],
+            self.want.key
+        )
+
+        resp = self.client.api.get(uri)
+
+        try:
+            response = resp.json()
+        except ValueError as ex:
+            raise F5ModuleError(str(ex))
+
+        if 'code' in response and response['code'] == 400:
+            if 'message' in response:
+                raise F5ModuleError(response['message'])
+            else:
+                raise F5ModuleError(resp.content)
+
+        return ApiParameters(params=response)
+
     def update_on_device(self):
-        params = self.want.api_params()
-        resource = self.client.api.tm.sys.dbs.db.load(
-            name=self.want.key
+        params = self.changes.api_params()
+        uri = "https://{0}:{1}/mgmt/tm/sys/db/{2}".format(
+            self.client.provider['server'],
+            self.client.provider['server_port'],
+            self.want.key
         )
-        resource.update(**params)
 
-    def reset(self):
-        self.have = self.read_current_from_device()
-        if not self.should_update():
-            return False
-        if self.module.check_mode:
-            return True
-        self.reset_on_device()
-        self.want.update({'key': self.want.key})
-        self.want.update({'value': self.have.default_value})
-        if self.exists():
-            return True
-        else:
-            raise F5ModuleError(
-                "Failed to reset the DB variable"
-            )
+        resp = self.client.api.patch(uri, json=params)
+
+        try:
+            response = resp.json()
+        except ValueError as ex:
+            raise F5ModuleError(str(ex))
+
+        if 'code' in response and response['code'] == 400:
+            if 'message' in response:
+                raise F5ModuleError(response['message'])
+            else:
+                raise F5ModuleError(resp.content)
 
     def reset_on_device(self):
-        resource = self.client.api.tm.sys.dbs.db.load(
-            name=self.want.key
+        uri = "https://{0}:{1}/mgmt/tm/sys/db/{2}".format(
+            self.client.provider['server'],
+            self.client.provider['server_port'],
+            self.want.key
+        )
+        params = dict(
+            value=self.have.default_value
         )
-        resource.update(value=self.have.default_value)
+
+        resp = self.client.api.patch(uri, json=params)
+
+        try:
+            response = resp.json()
+        except ValueError as ex:
+            raise F5ModuleError(str(ex))
+
+        if 'code' in response and response['code'] == 400:
+            if 'message' in response:
+                raise F5ModuleError(response['message'])
+            else:
+                raise F5ModuleError(resp.content)
 
 
 class ArgumentSpec(object):
@@ -283,18 +390,17 @@ def main():
         argument_spec=spec.argument_spec,
         supports_check_mode=spec.supports_check_mode
     )
-    if not HAS_F5SDK:
-        module.fail_json(msg="The python f5-sdk module is required")
+
+    client = F5RestClient(**module.params)
 
     try:
-        client = F5Client(**module.params)
         mm = ModuleManager(module=module, client=client)
         results = mm.exec_module()
         cleanup_tokens(client)
-        module.exit_json(**results)
+        exit_json(module, results, client)
     except F5ModuleError as ex:
         cleanup_tokens(client)
-        module.fail_json(msg=str(ex))
+        fail_json(module, ex, client)
 
 
 if __name__ == '__main__':
diff --git a/test/units/modules/network/f5/test_bigip_sys_db.py b/test/units/modules/network/f5/test_bigip_sys_db.py
index 17f051eb99..91b26ceccf 100644
--- a/test/units/modules/network/f5/test_bigip_sys_db.py
+++ b/test/units/modules/network/f5/test_bigip_sys_db.py
@@ -14,25 +14,30 @@ from nose.plugins.skip import SkipTest
 if sys.version_info < (2, 7):
     raise SkipTest("F5 Ansible modules require Python >= 2.7")
 
-from units.compat import unittest
-from units.compat.mock import Mock
-from units.compat.mock import patch
 from ansible.module_utils.basic import AnsibleModule
 
 try:
     from library.modules.bigip_sys_db import Parameters
     from library.modules.bigip_sys_db import ModuleManager
     from library.modules.bigip_sys_db import ArgumentSpec
-    from library.module_utils.network.f5.common import F5ModuleError
-    from library.module_utils.network.f5.common import iControlUnexpectedHTTPError
-    from test.unit.modules.utils import set_module_args
+
+    # In Ansible 2.8, Ansible changed import paths.
+    from test.units.compat import unittest
+    from test.units.compat.mock import Mock
+    from test.units.compat.mock import patch
+
+    from test.units.modules.utils import set_module_args
 except ImportError:
     try:
         from ansible.modules.network.f5.bigip_sys_db import Parameters
         from ansible.modules.network.f5.bigip_sys_db import ModuleManager
         from ansible.modules.network.f5.bigip_sys_db import ArgumentSpec
-        from ansible.module_utils.network.f5.common import F5ModuleError
-        from ansible.module_utils.network.f5.common import iControlUnexpectedHTTPError
+
+        # Ansible 2.8 imports
+        from units.compat import unittest
+        from units.compat.mock import Mock
+        from units.compat.mock import patch
+
         from units.modules.utils import set_module_args
     except ImportError:
         raise SkipTest("F5 Ansible modules require the f5-sdk Python library")

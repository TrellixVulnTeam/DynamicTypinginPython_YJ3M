commit 4cdb266dac852859f695b0555cbe49e58343e69a
Author: Peter Sprygada <privateip@users.noreply.github.com>
Date:   Wed Jan 11 17:17:37 2017 -0500

    adds iosxr_system declarative module (#20134)
    
    * adds new module iosxr_system
    * adds unit test cases for module

diff --git a/lib/ansible/modules/network/iosxr/iosxr_system.py b/lib/ansible/modules/network/iosxr/iosxr_system.py
new file mode 100644
index 0000000000..4b267a2479
--- /dev/null
+++ b/lib/ansible/modules/network/iosxr/iosxr_system.py
@@ -0,0 +1,279 @@
+#!/usr/bin/python
+#
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+ANSIBLE_METADATA = {
+    'status': ['preview'],
+    'supported_by': 'core',
+    'version': '1.0'
+}
+
+DOCUMENTATION = """
+---
+module: iosxr_system
+version_added: "2.3"
+author: "Peter Sprygada (@privateip)"
+short_description: Manage the system attributes on Cisco IOS-XR devices
+description:
+  - This module provides declarative management of node system attributes
+    on Cisco IOS-XR devices.  It provides an option to configure host system
+    parameters or remove those parameters from the device active
+    configuration.
+options:
+  hostname:
+    description:
+      - The C(hostname) argument will configure the device hostname
+        parameter on Cisco IOS-XR devices.  The C(hostname) value is an
+        ASCII string value.
+    required: false
+    default: null
+  domain_name:
+    description:
+      - The C(description) argument will configure the IP domain name
+        on the remote device to the provided value.  The C(domain_name)
+        argument should be in the dotted name form and will be
+        appended to the C(hostname) to create a fully-qualified
+        domain name
+    required: false
+    default: null
+  domain_search:
+    description:
+      - The C(domain_list) provides the list of domain suffixes to
+        append to the hostname for the purpose of doing name resolution.
+        This argument accepts a list of names and will be reconciled
+        with the current active configuration on the running node.
+    required: false
+    default: null
+  lookup_source:
+    description:
+      - The C(lookup_source) argument provides one or more source
+        interfaces to use for performing DNS lookups.  The interface
+        provided in C(lookup_source) must be a valid interface configured
+        on the device.
+    required: false
+    default: null
+  lookup_enabled:
+    description:
+      - The C(lookup_enabled) argument provides administrative control
+        for enabling or disabling DNS lookups.  When this argument is
+        set to True, lookups are performed and when it is set to False,
+        lookups are not performed.
+    required: false
+    default: null
+    choices: ['true', 'false']
+  name_servers:
+    description:
+      - The C(name_serves) argument accepts a list of DNS name servers by
+        way of either FQDN or IP address to use to perform name resolution
+        lookups.  This argument accepts wither a list of DNS servers See
+        examples.
+    required: false
+    default: null
+  state:
+    description:
+      - The C(state) argument configures the state of the configuration
+        values in the device's current active configuration.  When set
+        to I(present), the values should be configured in the device active
+        configuration and when set to I(absent) the values should not be
+        in the device active configuration
+    required: false
+    default: present
+    choices: ['present', 'absent']
+"""
+
+EXAMPLES = """
+- name: configure hostname and domain-name
+  iosxr_system:
+    hostname: iosxr01
+    domain_name: eng.ansible.com
+    domain-search:
+      - ansible.com
+      - redhat.com
+      - cisco.com
+- name: remove configuration
+  iosxr_system:
+    state: absent
+- name: configure DNS lookup sources
+  iosxr_system:
+    lookup_source: MgmtEth0/0/CPU0/0
+    lookup_enabled: yes
+- name: configure name servers
+  iosxr_system:
+    name_servers:
+      - 8.8.8.8
+      - 8.8.4.4
+"""
+
+RETURN = """
+commands:
+  description: The list of configuration mode commands to send to the device
+  returned: always
+  type: list
+  sample:
+    - hostname iosxr01
+    - ip domain-name eng.ansible.com
+start:
+  description: The time the job started
+  returned: always
+  type: str
+  sample: "2016-11-16 10:38:15.126146"
+end:
+  description: The time the job ended
+  returned: always
+  type: str
+  sample: "2016-11-16 10:38:25.595612"
+delta:
+  description: The time elapsed to perform all operations
+  returned: always
+  type: str
+  sample: "0:00:10.469466"
+"""
+import re
+
+from ansible.module_utils.local import LocalAnsibleModule
+from ansible.module_utils.iosxr import get_config, load_config
+
+def diff_list(want, have):
+    adds = set(want).difference(have)
+    removes = set(have).difference(want)
+    return (adds, removes)
+
+def map_obj_to_commands(want, have, module):
+    commands = list()
+    state = module.params['state']
+
+    needs_update = lambda x: want.get(x) and (want.get(x) != have.get(x))
+
+    if state == 'absent':
+        if have['hostname'] != 'ios':
+            commands.append('no hostname')
+        if have['domain_name']:
+            commands.append('no domain name')
+        if have['lookup_source']:
+            commands.append('no domain lookup source-interface %s' % have['lookup_source'])
+        if not have['lookup_enabled']:
+            commands.append('no domain lookup disable')
+        for item in have['name_servers']:
+            commands.append('no domain name-server %s' % item)
+        for item in have['domain_search']:
+            commands.append('no domain list %s' % item)
+
+    elif state == 'present':
+        if needs_update('hostname'):
+            commands.append('hostname %s' % want['hostname'])
+
+        if needs_update('domain_name'):
+            commands.append('domain name %s' % want['domain_name'])
+
+        if needs_update('lookup_source'):
+            commands.append('domain lookup source-interface %s' % want['lookup_source'])
+
+        if needs_update('lookup_enabled'):
+            cmd = 'domain lookup disable'
+            if want['lookup_enabled']:
+                cmd = 'no %s' % cmd
+            commands.append(cmd)
+
+        if want['name_servers'] is not None:
+            adds, removes = diff_list(want['name_servers'], have['name_servers'])
+            for item in adds:
+                commands.append('domain name-server %s' % item)
+            for item in removes:
+                commands.append('no domain name-server %s' % item)
+
+        if want['domain_search'] is not None:
+            adds, removes = diff_list(want['domain_search'], have['domain_search'])
+            for item in adds:
+                commands.append('domain list %s' % item)
+            for item in removes:
+                commands.append('no domain list %s' % item)
+
+    return commands
+
+def parse_hostname(config):
+    match = re.search('^hostname (\S+)', config, re.M)
+    return match.group(1)
+
+def parse_domain_name(config):
+    match = re.search('^domain name (\S+)', config, re.M)
+    if match:
+        return match.group(1)
+
+def parse_lookup_source(config):
+    match = re.search('^domain lookup source-interface (\S+)', config, re.M)
+    if match:
+        return match.group(1)
+
+def map_config_to_obj(module):
+    config = get_config(module)
+    return {
+        'hostname': parse_hostname(config),
+        'domain_name': parse_domain_name(config),
+        'domain_search': re.findall('^domain list (\S+)', config, re.M),
+        'lookup_source': parse_lookup_source(config),
+        'lookup_enabled': 'domain lookup disable' not in config,
+        'name_servers': re.findall('^domain name-server (\S+)', config, re.M)
+    }
+
+def map_params_to_obj(module):
+    return {
+        'hostname': module.params['hostname'],
+        'domain_name': module.params['domain_name'],
+        'domain_search': module.params['domain_search'],
+        'lookup_source': module.params['lookup_source'],
+        'lookup_enabled': module.params['lookup_enabled'],
+        'name_servers': module.params['name_servers']
+    }
+
+def main():
+    """ Main entry point for Ansible module execution
+    """
+    argument_spec = dict(
+        hostname=dict(),
+        domain_name=dict(),
+        domain_search=dict(type='list'),
+
+        name_servers=dict(type='list'),
+        lookup_source=dict(),
+        lookup_enabled=dict(type='bool'),
+
+        state=dict(choices=['present', 'absent'], default='present')
+    )
+
+    module = LocalAnsibleModule(argument_spec=argument_spec,
+                                supports_check_mode=True)
+
+
+    result = {'changed': False}
+
+    want = map_params_to_obj(module)
+    have = map_config_to_obj(module)
+
+    commands = map_obj_to_commands(want, have, module)
+    result['commands'] = commands
+
+    if commands:
+        commit = not module.check_mode
+        response = load_config(module, commands, commit=commit)
+        if response.get('diff') and module._diff:
+            result['diff'] = {'prepared': response.get('diff')}
+        result['changed'] = True
+
+    module.exit_json(**result)
+
+if __name__ == "__main__":
+    main()
diff --git a/test/units/modules/network/iosxr/__init__.py b/test/units/modules/network/iosxr/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/units/modules/network/iosxr/fixtures/iosxr_system_config.cfg b/test/units/modules/network/iosxr/fixtures/iosxr_system_config.cfg
new file mode 100644
index 0000000000..fc6fd2b753
--- /dev/null
+++ b/test/units/modules/network/iosxr/fixtures/iosxr_system_config.cfg
@@ -0,0 +1,8 @@
+hostname iosxr01
+domain name eng.ansible.com
+domain lookup disable
+domain lookup source-interface MgmtEth0/0/CPU0/0
+domain list redhat.com
+domain list cisco.com
+domain name-server 8.8.8.8
+domain name-server 8.8.4.4
diff --git a/test/units/modules/network/iosxr/test_iosxr_system.py b/test/units/modules/network/iosxr/test_iosxr_system.py
new file mode 100644
index 0000000000..6831e0e168
--- /dev/null
+++ b/test/units/modules/network/iosxr/test_iosxr_system.py
@@ -0,0 +1,140 @@
+#!/usr/bin/env python
+#
+# (c) 2016 Red Hat Inc.
+#
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+
+# Make coding more python3-ish
+from __future__ import (absolute_import, division, print_function)
+__metaclass__ = type
+
+import os
+import json
+
+import ansible.module_utils.basic
+
+from ansible.compat.tests import unittest
+from ansible.compat.tests.mock import patch, MagicMock
+from ansible.errors import AnsibleModuleExit
+from ansible.modules.network.iosxr import iosxr_system
+from ansible.module_utils import basic
+from ansible.module_utils._text import to_bytes
+
+def set_module_args(args):
+    args = json.dumps({'ANSIBLE_MODULE_ARGS': args})
+    basic._ANSIBLE_ARGS = to_bytes(args)
+
+fixture_path = os.path.join(os.path.dirname(__file__), 'fixtures')
+fixture_data = {}
+
+def load_fixture(name):
+    path = os.path.join(fixture_path, name)
+
+    if path in fixture_data:
+        return fixture_data[path]
+
+    with open(path) as f:
+        data = f.read()
+
+    try:
+        data = json.loads(data)
+    except:
+        pass
+
+    fixture_data[path] = data
+    return data
+
+
+class TestIosxrSystemModule(unittest.TestCase):
+
+    def setUp(self):
+        self.mock_get_config = patch('ansible.modules.network.iosxr.iosxr_system.get_config')
+        self.get_config = self.mock_get_config.start()
+
+        self.mock_load_config = patch('ansible.modules.network.iosxr.iosxr_system.load_config')
+        self.load_config = self.mock_load_config.start()
+
+    def tearDown(self):
+        self.mock_get_config.stop()
+        self.mock_load_config.stop()
+
+    def execute_module(self, failed=False, changed=False, commands=None, sort=True):
+
+        self.get_config.return_value = load_fixture('iosxr_system_config.cfg')
+        self.load_config.return_value = dict(diff=None, session='session')
+
+        with self.assertRaises(AnsibleModuleExit) as exc:
+            iosxr_system.main()
+
+        result = exc.exception.result
+
+        if failed:
+            self.assertTrue(result['failed'], result)
+        else:
+            self.assertEqual(result['changed'], changed, result)
+
+        if commands:
+            if sort:
+                self.assertEqual(sorted(commands), sorted(result['commands']), result['commands'])
+            else:
+                self.assertEqual(commands, result['commands'])
+
+        return result
+
+    def test_iosxr_system_hostname_changed(self):
+        set_module_args(dict(hostname='foo'))
+        commands = ['hostname foo']
+        self.execute_module(changed=True, commands=commands)
+
+    def test_iosxr_system_domain_name(self):
+        set_module_args(dict(domain_name='test.com'))
+        commands = ['domain name test.com']
+        self.execute_module(changed=True, commands=commands)
+
+    def test_iosxr_system_domain_search(self):
+        set_module_args(dict(domain_search=['ansible.com', 'redhat.com']))
+        commands=['domain list ansible.com', 'no domain list cisco.com']
+        self.execute_module(changed=True, commands=commands)
+
+    def test_iosxr_system_lookup_source(self):
+        set_module_args(dict(lookup_source='Ethernet1'))
+        commands = ['domain lookup source-interface Ethernet1']
+        self.execute_module(changed=True, commands=commands)
+
+    def test_iosxr_system_lookup_enabled(self):
+        set_module_args(dict(lookup_enabled=True))
+        commands = ['no domain lookup disable']
+        self.execute_module(changed=True, commands=commands)
+
+    def test_iosxr_system_name_servers(self):
+        name_servers = ['8.8.8.8', '8.8.4.4', '1.1.1.1']
+        set_module_args(dict(name_servers=name_servers))
+        commands = ['domain name-server 1.1.1.1', 'no domain name-server 8.8.4.4']
+        self.execute_module(changed=True)
+
+    def test_iosxr_system_state_absent(self):
+        set_module_args(dict(state='absent'))
+        commands = ['no hostname', 'no domain name',
+                             'no domain lookup disable',
+                             'no domain lookup source-interface MgmtEth0/0/CPU0/0',
+                             'no domain list redhat.com', 'no domain list cisco.com',
+                             'no domain name-server 8.8.8.8', 'no domain name-server 8.8.4.4']
+        self.execute_module(changed=True, commands=commands)
+
+    def test_iosxr_system_no_change(self):
+        set_module_args(dict(hostname='iosxr01', domain_name='eng.ansible.com'))
+        self.execute_module()
+

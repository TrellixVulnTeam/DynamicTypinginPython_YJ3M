commit e511d6d458e247ea183bc750d5d7fc1df099c28c
Author: Marius Gedminas <marius@gedmin.as>
Date:   Tue Oct 13 09:41:08 2015 +0300

    Make UnsafeProxy work on Python 3
    
    Instead of str and unicode we have to deal with bytes and str.

diff --git a/lib/ansible/vars/unsafe_proxy.py b/lib/ansible/vars/unsafe_proxy.py
index ee5e7e875d..19707e10b3 100644
--- a/lib/ansible/vars/unsafe_proxy.py
+++ b/lib/ansible/vars/unsafe_proxy.py
@@ -56,20 +56,41 @@ __all__ = ['UnsafeProxy', 'AnsibleUnsafe', 'wrap_var']
 class AnsibleUnsafe(object):
     __UNSAFE__ = True
 
-class AnsibleUnsafeStr(str, AnsibleUnsafe):
-    pass
+try:
+    unicode
+except NameError:
+    # Python 3
+    class AnsibleUnsafeBytes(bytes, AnsibleUnsafe):
+        pass
 
-class AnsibleUnsafeUnicode(unicode, AnsibleUnsafe):
-    pass
+    class AnsibleUnsafeStr(str, AnsibleUnsafe):
+        pass
+
+    class UnsafeProxy(object):
+        def __new__(cls, obj, *args, **kwargs):
+            if obj.__class__ == str:
+                return AnsibleUnsafeStr(obj)
+            elif obj.__class__ == bytes:
+                return AnsibleUnsafeBytes(obj)
+            else:
+                return obj
+else:
+    # Python 2
+    class AnsibleUnsafeStr(str, AnsibleUnsafe):
+        pass
+
+    class AnsibleUnsafeUnicode(unicode, AnsibleUnsafe):
+        pass
+
+    class UnsafeProxy(object):
+        def __new__(cls, obj, *args, **kwargs):
+            if obj.__class__ == unicode:
+                return AnsibleUnsafeUnicode(obj)
+            elif obj.__class__ == str:
+                return AnsibleUnsafeStr(obj)
+            else:
+                return obj
 
-class UnsafeProxy(object):
-    def __new__(cls, obj, *args, **kwargs):
-        if obj.__class__ == unicode:
-            return AnsibleUnsafeUnicode(obj)
-        elif obj.__class__ == str:
-            return AnsibleUnsafeStr(obj)
-        else:
-            return obj
 
 def _wrap_dict(v):
     for k in v.keys():
@@ -77,12 +98,14 @@ def _wrap_dict(v):
             v[k] = wrap_var(v[k])
     return v
 
+
 def _wrap_list(v):
     for idx, item in enumerate(v):
         if item is not None:
             v[idx] = wrap_var(item)
     return v
 
+
 def wrap_var(v):
     if isinstance(v, dict):
         v = _wrap_dict(v)

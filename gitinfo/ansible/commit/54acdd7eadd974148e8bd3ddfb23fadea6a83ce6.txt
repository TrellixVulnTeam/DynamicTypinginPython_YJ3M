commit 54acdd7eadd974148e8bd3ddfb23fadea6a83ce6
Author: Toshio Kuratomi <a.badger@gmail.com>
Date:   Sun Apr 10 09:24:54 2016 -0700

    Remove workaround for fixed bug. (#15340)
    
    * Remove workaround for fixed bug.
    
    The bug where PluginLoader required objects to directly inherit from
    base_classes has been fixed.  Remove workaround from this strategy
    plugin   Also switched to using super so that we don't have to modify
    all of hte code anytime something like that happens.
    
    * These should be to_uniocde because they're being sent to display()

diff --git a/lib/ansible/plugins/__init__.py b/lib/ansible/plugins/__init__.py
index 14fc20fb9e..3216a9235b 100644
--- a/lib/ansible/plugins/__init__.py
+++ b/lib/ansible/plugins/__init__.py
@@ -31,7 +31,7 @@ import warnings
 from collections import defaultdict
 
 from ansible import constants as C
-from ansible.utils.unicode import to_str
+from ansible.utils.unicode import to_unicode
 
 try:
     from __main__ import display
@@ -248,7 +248,7 @@ class PluginLoader:
             try:
                 full_paths = (os.path.join(path, f) for f in os.listdir(path))
             except OSError as e:
-                display.warning("Error accessing plugin paths: %s" % to_str(e))
+                display.warning("Error accessing plugin paths: %s" % to_unicode(e))
 
             for full_path in (f for f in full_paths if os.path.isfile(f) and not f.endswith('__init__.py')):
                 full_name = os.path.basename(full_path)
@@ -370,7 +370,7 @@ class PluginLoader:
             try:
                 obj = getattr(self._module_cache[path], self.class_name)
             except AttributeError as e:
-                display.warning("Skipping plugin (%s) as it seems to be invalid: %s" % (path, to_str(e)))
+                display.warning("Skipping plugin (%s) as it seems to be invalid: %s" % (path, to_unicode(e)))
 
             if self.base_class:
                 # The import path is hardcoded and should be the right place,
diff --git a/lib/ansible/plugins/strategy/debug.py b/lib/ansible/plugins/strategy/debug.py
index fbfe01cbe1..eb9ba24633 100644
--- a/lib/ansible/plugins/strategy/debug.py
+++ b/lib/ansible/plugins/strategy/debug.py
@@ -7,7 +7,6 @@ import pprint
 import sys
 
 from ansible.plugins.strategy import linear
-from ansible.plugins.strategy import StrategyBase
 
 try:
     from __main__ import display
@@ -26,13 +25,10 @@ class NextAction(object):
         self.result = result
 
 
-class StrategyModule(linear.StrategyModule, StrategyBase):
-    # Usually inheriting linear.StrategyModule is enough. However, StrategyBase class must be
-    # direct ancestor to be considered as strategy plugin, and so we inherit the class here.
-
+class StrategyModule(linear.StrategyModule):
     def __init__(self, tqm):
         self.curr_tqm = tqm
-        StrategyBase.__init__(self, tqm)
+        super(StrategyModule, self).__init__(tqm)
 
     def _queue_task(self, host, task, task_vars, play_context):
         self.curr_host = host
@@ -40,14 +36,14 @@ class StrategyModule(linear.StrategyModule, StrategyBase):
         self.curr_task_vars = task_vars
         self.curr_play_context = play_context
 
-        StrategyBase._queue_task(self, host, task, task_vars, play_context)
+        super(StrategyModule, self)._queue_task(host, task, task_vars, play_context)
 
     def _process_pending_results(self, iterator, one_pass=False):
         if not hasattr(self, "curr_host"):
-            return StrategyBase._process_pending_results(self, iterator, one_pass)
+            return super(StrategyModule, self)._process_pending_results(iterator, one_pass)
 
         prev_host_state = iterator.get_host_state(self.curr_host)
-        results = StrategyBase._process_pending_results(self, iterator, one_pass)
+        results = super(StrategyModule, self)._process_pending_results(iterator, one_pass)
 
         while self._need_debug(results):
             next_action = NextAction()
@@ -64,8 +60,8 @@ class StrategyModule(linear.StrategyModule, StrategyBase):
                     self._tqm._stats.dark[self.curr_host.name] -= 1
 
                 # redo
-                StrategyBase._queue_task(self, self.curr_host, self.curr_task, self.curr_task_vars, self.curr_play_context)
-                results = StrategyBase._process_pending_results(self, iterator, one_pass)
+                super(StrategyModule, self)._queue_task(self.curr_host, self.curr_task, self.curr_task_vars, self.curr_play_context)
+                results = super(StrategyModule, self)._process_pending_results(iterator, one_pass)
             elif next_action.result == NextAction.CONTINUE:
                 break
             elif next_action.result == NextAction.EXIT:

commit e693d7e37c38c644537a03c2328d69beca349315
Author: Ethan Devenport <edevenport@users.noreply.github.com>
Date:   Tue Dec 19 03:31:39 2017 -0800

    New module: manage 1&1 cloud compute  (cloud/oneandone/oneandone_server) (#24878)
    
    * Added oneandone provider cloud server module.
    
    * Updated comments, idempotency, handling of multiple resources.
    
    * Added check mode support.
    
    * fix validation errors

diff --git a/lib/ansible/module_utils/oneandone.py b/lib/ansible/module_utils/oneandone.py
new file mode 100644
index 0000000000..8e12a1dc8e
--- /dev/null
+++ b/lib/ansible/module_utils/oneandone.py
@@ -0,0 +1,255 @@
+# This code is part of Ansible, but is an independent component.
+# This particular file snippet, and this file snippet only, is BSD licensed.
+# Modules you write using this snippet, which is embedded dynamically by Ansible
+# still belong to the author of the module, and may assign their own license
+# to the complete work.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+#    * Redistributions of source code must retain the above copyright
+#      notice, this list of conditions and the following disclaimer.
+#    * Redistributions in binary form must reproduce the above copyright notice,
+#      this list of conditions and the following disclaimer in the documentation
+#      and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+import time
+
+
+class OneAndOneResources:
+    firewall_policy, load_balancer, monitoring_policy, private_network, public_ip, role, server, user, vpn = range(9)
+
+
+def get_resource(oneandone_conn, resource_type, resource_id):
+    switcher = {
+        'firewall_policy': oneandone_conn.get_firewall,
+        'load_balancer': oneandone_conn.get_load_balancer,
+        'monitoring_policy': oneandone_conn.get_monitoring_policy,
+        'private_network': oneandone_conn.get_private_network,
+        'public_ip': oneandone_conn.get_public_ip,
+        'role': oneandone_conn.get_role,
+        'server': oneandone_conn.get_server,
+        'user': oneandone_conn.get_user,
+        'vpn': oneandone_conn.get_vpn,
+    }
+
+    return switcher.get(resource_type.name, None)(resource_id)
+
+
+def get_datacenter(oneandone_conn, datacenter, full_object=False):
+    """
+    Validates the datacenter exists by ID or country code.
+    Returns the datacenter ID.
+    """
+    for _datacenter in oneandone_conn.list_datacenters():
+        if datacenter in (_datacenter['id'], _datacenter['country_code']):
+            if full_object:
+                return _datacenter
+            return _datacenter['id']
+
+
+def get_fixed_instance_size(oneandone_conn, fixed_instance_size, full_object=False):
+    """
+    Validates the fixed instance size exists by ID or name.
+    Return the instance size ID.
+    """
+    for _fixed_instance_size in oneandone_conn.fixed_server_flavors():
+        if fixed_instance_size in (_fixed_instance_size['id'],
+                                   _fixed_instance_size['name']):
+            if full_object:
+                return _fixed_instance_size
+            return _fixed_instance_size['id']
+
+
+def get_appliance(oneandone_conn, appliance, full_object=False):
+    """
+    Validates the appliance exists by ID or name.
+    Return the appliance ID.
+    """
+    for _appliance in oneandone_conn.list_appliances(q='IMAGE'):
+        if appliance in (_appliance['id'], _appliance['name']):
+            if full_object:
+                return _appliance
+            return _appliance['id']
+
+
+def get_private_network(oneandone_conn, private_network, full_object=False):
+    """
+    Validates the private network exists by ID or name.
+    Return the private network ID.
+    """
+    for _private_network in oneandone_conn.list_private_networks():
+        if private_network in (_private_network['name'],
+                               _private_network['id']):
+            if full_object:
+                return _private_network
+            return _private_network['id']
+
+
+def get_monitoring_policy(oneandone_conn, monitoring_policy, full_object=False):
+    """
+    Validates the monitoring policy exists by ID or name.
+    Return the monitoring policy ID.
+    """
+    for _monitoring_policy in oneandone_conn.list_monitoring_policies():
+        if monitoring_policy in (_monitoring_policy['name'],
+                                 _monitoring_policy['id']):
+            if full_object:
+                return _monitoring_policy
+            return _monitoring_policy['id']
+
+
+def get_firewall_policy(oneandone_conn, firewall_policy, full_object=False):
+    """
+    Validates the firewall policy exists by ID or name.
+    Return the firewall policy ID.
+    """
+    for _firewall_policy in oneandone_conn.list_firewall_policies():
+        if firewall_policy in (_firewall_policy['name'],
+                               _firewall_policy['id']):
+            if full_object:
+                return _firewall_policy
+            return _firewall_policy['id']
+
+
+def get_load_balancer(oneandone_conn, load_balancer, full_object=False):
+    """
+    Validates the load balancer exists by ID or name.
+    Return the load balancer ID.
+    """
+    for _load_balancer in oneandone_conn.list_load_balancers():
+        if load_balancer in (_load_balancer['name'],
+                             _load_balancer['id']):
+            if full_object:
+                return _load_balancer
+            return _load_balancer['id']
+
+
+def get_server(oneandone_conn, instance, full_object=False):
+    """
+    Validates that the server exists whether by ID or name.
+    Returns the server if one was found.
+    """
+    for server in oneandone_conn.list_servers(per_page=1000):
+        if instance in (server['id'], server['name']):
+            if full_object:
+                return server
+            return server['id']
+
+
+def get_user(oneandone_conn, user, full_object=False):
+    """
+    Validates that the user exists by ID or a name.
+    Returns the user if one was found.
+    """
+    for _user in oneandone_conn.list_users(per_page=1000):
+        if user in (_user['id'], _user['name']):
+            if full_object:
+                return _user
+            return _user['id']
+
+
+def get_role(oneandone_conn, role, full_object=False):
+    """
+    Given a name, validates that the role exists
+    whether it is a proper ID or a name.
+    Returns the role if one was found, else None.
+    """
+    for _role in oneandone_conn.list_roles(per_page=1000):
+        if role in (_role['id'], _role['name']):
+            if full_object:
+                return _role
+            return _role['id']
+
+
+def get_vpn(oneandone_conn, vpn, full_object=False):
+    """
+    Validates that the vpn exists by ID or a name.
+    Returns the vpn if one was found.
+    """
+    for _vpn in oneandone_conn.list_vpns(per_page=1000):
+        if vpn in (_vpn['id'], _vpn['name']):
+            if full_object:
+                return _vpn
+            return _vpn['id']
+
+
+def wait_for_resource_creation_completion(oneandone_conn,
+                                          resource_type,
+                                          resource_id,
+                                          wait_timeout):
+    """
+    Waits for the resource create operation to complete based on the timeout period.
+    """
+    wait_timeout = time.time() + wait_timeout
+    while wait_timeout > time.time():
+        time.sleep(5)
+
+        # Refresh the resource info
+        resource = get_resource(oneandone_conn, resource_type, resource_id)
+
+        if resource_type == OneAndOneResources.server:
+            resource_state = resource['status']['state']
+        else:
+            resource_state = resource['state']
+
+        if ((resource_type == OneAndOneResources.server and resource_state.lower() == 'powered_on') or
+                (resource_type != OneAndOneResources.server and resource_state.lower() == 'active')):
+            return
+        elif resource_state.lower() == 'failed':
+            raise Exception('%s creation failed for %s' % (resource_type, resource_id))
+        elif resource_state.lower() in ('active',
+                                        'enabled',
+                                        'deploying',
+                                        'configuring'):
+            continue
+        else:
+            raise Exception(
+                'Unknown %s state %s' % (resource_type.name, resource_state))
+
+    raise Exception(
+        'Timed out waiting for %s completion for %s' % (resource_type.name, resource_id))
+
+
+def wait_for_resource_deletion_completion(oneandone_conn,
+                                          resource_type,
+                                          resource_id,
+                                          wait_timeout):
+    """
+    Waits for the resource delete operation to complete based on the timeout period.
+    """
+    wait_timeout = time.time() + wait_timeout
+    while wait_timeout > time.time():
+        time.sleep(5)
+
+        # Refresh the operation info
+        logs = oneandone_conn.list_logs(q='DELETE',
+                                        period='LAST_HOUR',
+                                        sort='-start_date')
+
+        if resource_type == OneAndOneResources.server:
+            _type = 'VM'
+        elif resource_type == OneAndOneResources.private_network:
+            _type = 'PRIVATENETWORK'
+        else:
+            raise Exception(
+                'Unsupported wait_for delete operation for %s resource' % resource_type.name)
+
+        for log in logs:
+            if (log['resource']['id'] == resource_id and
+                    log['action'] == 'DELETE' and
+                    log['type'] == _type and
+                    log['status']['state'] == 'OK'):
+                return
+    raise Exception(
+        'Timed out waiting for %s deletion for %s' % (resource_type.name, resource_id))
diff --git a/lib/ansible/modules/cloud/oneandone/__init__.py b/lib/ansible/modules/cloud/oneandone/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/lib/ansible/modules/cloud/oneandone/oneandone_server.py b/lib/ansible/modules/cloud/oneandone/oneandone_server.py
new file mode 100644
index 0000000000..b02c46871d
--- /dev/null
+++ b/lib/ansible/modules/cloud/oneandone/oneandone_server.py
@@ -0,0 +1,682 @@
+#!/usr/bin/python
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+
+from __future__ import absolute_import, division, print_function
+__metaclass__ = type
+
+ANSIBLE_METADATA = {'metadata_version': '1.1',
+                    'status': ['preview'],
+                    'supported_by': 'community'}
+
+
+DOCUMENTATION = '''
+---
+module: oneandone_server
+short_description: Create, destroy, start, stop, and reboot a 1&1 Host server.
+description:
+     - Create, destroy, update, start, stop, and reboot a 1&1 Host server.
+       When the server is created it can optionally wait for it to be 'running' before returning.
+version_added: "2.5"
+options:
+  state:
+    description:
+      - Define a server's state to create, remove, start or stop it.
+    required: false
+    default: present
+    choices: [ "present", "absent", "running", "stopped" ]
+  auth_token:
+    description:
+      - Authenticating API token provided by 1&1. Overrides the
+        ONEANDONE_AUTH_TOKEN environement variable.
+    required: true
+  datacenter:
+    description:
+      - The datacenter location.
+    required: false
+    default: US
+    choices: [ "US", "ES", "DE", "GB" ]
+  hostname:
+    description:
+      - The hostname or ID of the server. Only used when state is 'present'.
+    required: false
+  description:
+    description:
+      - The description of the server.
+    required: false
+  appliance:
+    description:
+      - The operating system name or ID for the server.
+        It is required only for 'present' state.
+    required: false
+  fixed_instance_size:
+    description:
+      - The instance size name or ID of the server.
+        It is required only for 'present' state, and it is mutually exclusive with
+        vcore, cores_per_processor, ram, and hdds parameters.
+    required: true
+    choices: [ "S", "M", "L", "XL", "XXL", "3XL", "4XL", "5XL" ]
+  vcore:
+    description:
+      - The total number of processors.
+        It must be provided with cores_per_processor, ram, and hdds parameters.
+    required: false
+  cores_per_processor:
+    description:
+      - The number of cores per processor.
+        It must be provided with vcore, ram, and hdds parameters.
+    required: false
+  ram:
+    description:
+      - The amount of RAM memory.
+        It must be provided with with vcore, cores_per_processor, and hdds parameters.
+    required: false
+  hdds:
+    description:
+      - A list of hard disks with nested "size" and "is_main" properties.
+        It must be provided with vcore, cores_per_processor, and ram parameters.
+    required: false
+  private_network:
+    description:
+      - The private network name or ID.
+    required: false
+  firewall_policy:
+    description:
+      - The firewall policy name or ID.
+    required: false
+  load_balancer:
+    description:
+      - The load balancer name or ID.
+    required: false
+  monitoring_policy:
+    description:
+      - The monitoring policy name or ID.
+    required: false
+  server:
+    description:
+      - Server identifier (ID or hostname). It is required for all states except 'running' and 'present'.
+    required: false
+  count:
+    description:
+      - The number of servers to create.
+    required: false
+    default: 1
+  ssh_key:
+    description:
+      - User's public SSH key (contents, not path).
+    required: false
+    default: None
+  wait:
+    description:
+      - Wait for the server to be in state 'running' before returning.
+        Also used for delete operation (set to 'false' if you don't want to wait
+        for each individual server to be deleted before moving on with
+        other tasks.)
+    required: false
+    default: "yes"
+    choices: [ "yes", "no" ]
+  wait_timeout:
+    description:
+      - how long before wait gives up, in seconds
+    default: 600
+  auto_increment:
+    description:
+      - When creating multiple servers at once, whether to differentiate
+        hostnames by appending a count after them or substituting the count
+        where there is a %02d or %03d in the hostname string.
+    default: "yes"
+    choices: [ "yes", "no" ]
+
+requirements:
+  - "1and1"
+  - "python >= 2.6"
+
+author:
+  -  "Amel Ajdinovic (@aajdinov)"
+  -  "Ethan Devenport (@edevenport)"
+
+'''
+
+EXAMPLES = '''
+
+# Provisioning example. Creates three servers and enumerate their names.
+
+- oneandone_server:
+    auth_token: oneandone_private_api_key
+    hostname: node%02d
+    fixed_instance_size: XL
+    datacenter: US
+    appliance: C5A349786169F140BCBC335675014C08
+    auto_increment: true
+    count: 3
+
+# Create three servers, passing in an ssh_key.
+
+- oneandone_server:
+    auth_token: oneandone_private_api_key
+    hostname: node%02d
+    vcore: 2
+    cores_per_processor: 4
+    ram: 8.0
+    hdds:
+      - size: 50
+        is_main: false
+    datacenter: ES
+    appliance: C5A349786169F140BCBC335675014C08
+    count: 3
+    wait: yes
+    wait_timeout: 600
+    ssh_key: SSH_PUBLIC_KEY
+
+# Removing server
+
+- oneandone_server:
+    auth_token: oneandone_private_api_key
+    state: absent
+    server: 'node01'
+
+# Starting server.
+
+- oneandone_server:
+    auth_token: oneandone_private_api_key
+    state: running
+    server: 'node01'
+
+# Stopping server
+
+- oneandone_server:
+    auth_token: oneandone_private_api_key
+    state: stopped
+    server: 'node01'
+'''
+
+RETURN = '''
+machines:
+    description: Information about each machine that was processed
+    type: list
+    sample: '[{"hostname": "my-server", "id": "server-id"}]'
+    returned: always
+'''
+
+import os
+import time
+from ansible.module_utils.six.moves import xrange
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.oneandone import (
+    get_datacenter,
+    get_fixed_instance_size,
+    get_appliance,
+    get_private_network,
+    get_monitoring_policy,
+    get_firewall_policy,
+    get_load_balancer,
+    get_server,
+    OneAndOneResources,
+    wait_for_resource_creation_completion,
+    wait_for_resource_deletion_completion
+)
+
+HAS_ONEANDONE_SDK = True
+
+try:
+    import oneandone.client
+except ImportError:
+    HAS_ONEANDONE_SDK = False
+
+DATACENTERS = ['US', 'ES', 'DE', 'GB']
+
+ONEANDONE_SERVER_STATES = (
+    'DEPLOYING',
+    'POWERED_OFF',
+    'POWERED_ON',
+    'POWERING_ON',
+    'POWERING_OFF',
+)
+
+
+def _check_mode(module, result):
+    if module.check_mode:
+        module.exit_json(
+            changed=result
+        )
+
+
+def _create_server(module, oneandone_conn, hostname, description,
+                   fixed_instance_size_id, vcore, cores_per_processor, ram,
+                   hdds, datacenter_id, appliance_id, ssh_key,
+                   private_network_id, firewall_policy_id, load_balancer_id,
+                   monitoring_policy_id, wait, wait_timeout):
+
+    try:
+        existing_server = get_server(oneandone_conn, hostname)
+
+        if existing_server:
+            if module.check_mode:
+                return False
+            return None
+
+        if module.check_mode:
+            return True
+
+        server = oneandone_conn.create_server(
+            oneandone.client.Server(
+                name=hostname,
+                description=description,
+                fixed_instance_size_id=fixed_instance_size_id,
+                vcore=vcore,
+                cores_per_processor=cores_per_processor,
+                ram=ram,
+                appliance_id=appliance_id,
+                datacenter_id=datacenter_id,
+                rsa_key=ssh_key,
+                private_network_id=private_network_id,
+                firewall_policy_id=firewall_policy_id,
+                load_balancer_id=load_balancer_id,
+                monitoring_policy_id=monitoring_policy_id,), hdds)
+
+        if wait:
+            wait_for_resource_creation_completion(
+                oneandone_conn,
+                OneAndOneResources.server,
+                server['id'],
+                wait_timeout)
+            server = oneandone_conn.get_server(server['id'])  # refresh
+
+        return server
+    except Exception as ex:
+        module.fail_json(msg=str(ex))
+
+
+def _insert_network_data(server):
+    for addr_data in server['ips']:
+        if addr_data['type'] == 'IPV6':
+            server['public_ipv6'] = addr_data['ip']
+        elif addr_data['type'] == 'IPV4':
+            server['public_ipv4'] = addr_data['ip']
+    return server
+
+
+def create_server(module, oneandone_conn):
+    """
+    Create new server
+
+    module : AnsibleModule object
+    oneandone_conn: authenticated oneandone object
+
+    Returns a dictionary containing a 'changed' attribute indicating whether
+    any server was added, and a 'servers' attribute with the list of the
+    created servers' hostname, id and ip addresses.
+    """
+    hostname = module.params.get('hostname')
+    description = module.params.get('description')
+    auto_increment = module.params.get('auto_increment')
+    count = module.params.get('count')
+    fixed_instance_size = module.params.get('fixed_instance_size')
+    vcore = module.params.get('vcore')
+    cores_per_processor = module.params.get('cores_per_processor')
+    ram = module.params.get('ram')
+    hdds = module.params.get('hdds')
+    datacenter = module.params.get('datacenter')
+    appliance = module.params.get('appliance')
+    ssh_key = module.params.get('ssh_key')
+    private_network = module.params.get('private_network')
+    monitoring_policy = module.params.get('monitoring_policy')
+    firewall_policy = module.params.get('firewall_policy')
+    load_balancer = module.params.get('load_balancer')
+    wait = module.params.get('wait')
+    wait_timeout = module.params.get('wait_timeout')
+
+    datacenter_id = get_datacenter(oneandone_conn, datacenter)
+    if datacenter_id is None:
+        _check_mode(module, False)
+        module.fail_json(
+            msg='datacenter %s not found.' % datacenter)
+
+    fixed_instance_size_id = None
+    if fixed_instance_size:
+        fixed_instance_size_id = get_fixed_instance_size(
+            oneandone_conn,
+            fixed_instance_size)
+        if fixed_instance_size_id is None:
+            _check_mode(module, False)
+            module.fail_json(
+                msg='fixed_instance_size %s not found.' % fixed_instance_size)
+
+    appliance_id = get_appliance(oneandone_conn, appliance)
+    if appliance_id is None:
+        _check_mode(module, False)
+        module.fail_json(
+            msg='appliance %s not found.' % appliance)
+
+    private_network_id = None
+    if private_network:
+        private_network_id = get_private_network(
+            oneandone_conn,
+            private_network)
+        if private_network_id is None:
+            _check_mode(module, False)
+            module.fail_json(
+                msg='private network %s not found.' % private_network)
+
+    monitoring_policy_id = None
+    if monitoring_policy:
+        monitoring_policy_id = get_monitoring_policy(
+            oneandone_conn,
+            monitoring_policy)
+        if monitoring_policy_id is None:
+            _check_mode(module, False)
+            module.fail_json(
+                msg='monitoring policy %s not found.' % monitoring_policy)
+
+    firewall_policy_id = None
+    if firewall_policy:
+        firewall_policy_id = get_firewall_policy(
+            oneandone_conn,
+            firewall_policy)
+        if firewall_policy_id is None:
+            _check_mode(module, False)
+            module.fail_json(
+                msg='firewall policy %s not found.' % firewall_policy)
+
+    load_balancer_id = None
+    if load_balancer:
+        load_balancer_id = get_load_balancer(
+            oneandone_conn,
+            load_balancer)
+        if load_balancer_id is None:
+            _check_mode(module, False)
+            module.fail_json(
+                msg='load balancer %s not found.' % load_balancer)
+
+    if auto_increment:
+        hostnames = _auto_increment_hostname(count, hostname)
+        descriptions = _auto_increment_description(count, description)
+    else:
+        hostnames = [hostname] * count
+        descriptions = [description] * count
+
+    hdd_objs = []
+    if hdds:
+        for hdd in hdds:
+            hdd_objs.append(oneandone.client.Hdd(
+                size=hdd['size'],
+                is_main=hdd['is_main']
+            ))
+
+    servers = []
+    for index, name in enumerate(hostnames):
+        server = _create_server(
+            module=module,
+            oneandone_conn=oneandone_conn,
+            hostname=name,
+            description=descriptions[index],
+            fixed_instance_size_id=fixed_instance_size_id,
+            vcore=vcore,
+            cores_per_processor=cores_per_processor,
+            ram=ram,
+            hdds=hdd_objs,
+            datacenter_id=datacenter_id,
+            appliance_id=appliance_id,
+            ssh_key=ssh_key,
+            private_network_id=private_network_id,
+            monitoring_policy_id=monitoring_policy_id,
+            firewall_policy_id=firewall_policy_id,
+            load_balancer_id=load_balancer_id,
+            wait=wait,
+            wait_timeout=wait_timeout)
+        if server:
+            servers.append(server)
+
+    changed = False
+
+    if servers:
+        for server in servers:
+            if server:
+                _check_mode(module, True)
+        _check_mode(module, False)
+        servers = [_insert_network_data(_server) for _server in servers]
+        changed = True
+
+    _check_mode(module, False)
+
+    return (changed, servers)
+
+
+def remove_server(module, oneandone_conn):
+    """
+    Removes a server.
+
+    module : AnsibleModule object
+    oneandone_conn: authenticated oneandone object.
+
+    Returns a dictionary containing a 'changed' attribute indicating whether
+    the server was removed, and a 'removed_server' attribute with
+    the removed server's hostname and id.
+    """
+    server_id = module.params.get('server')
+    wait = module.params.get('wait')
+    wait_timeout = module.params.get('wait_timeout')
+
+    changed = False
+    removed_server = None
+
+    server = get_server(oneandone_conn, server_id, True)
+    if server:
+        _check_mode(module, True)
+        try:
+            oneandone_conn.delete_server(server_id=server['id'])
+            if wait:
+                wait_for_resource_deletion_completion(oneandone_conn,
+                                                      OneAndOneResources.server,
+                                                      server['id'],
+                                                      wait_timeout)
+            changed = True
+        except Exception as ex:
+            module.fail_json(
+                msg="failed to terminate the server: %s" % str(ex))
+
+        removed_server = {
+            'id': server['id'],
+            'hostname': server['name']
+        }
+    _check_mode(module, False)
+
+    return (changed, removed_server)
+
+
+def startstop_server(module, oneandone_conn):
+    """
+    Starts or Stops a server.
+
+    module : AnsibleModule object
+    oneandone_conn: authenticated oneandone object.
+
+    Returns a dictionary with a 'changed' attribute indicating whether
+    anything has changed for the server as a result of this function
+    being run, and a 'server' attribute with basic information for
+    the server.
+    """
+    state = module.params.get('state')
+    server_id = module.params.get('server')
+    wait = module.params.get('wait')
+    wait_timeout = module.params.get('wait_timeout')
+
+    changed = False
+
+    # Resolve server
+    server = get_server(oneandone_conn, server_id, True)
+    if server:
+        # Attempt to change the server state, only if it's not already there
+        # or on its way.
+        try:
+            if state == 'stopped' and server['status']['state'] == 'POWERED_ON':
+                _check_mode(module, True)
+                oneandone_conn.modify_server_status(
+                    server_id=server['id'],
+                    action='POWER_OFF',
+                    method='SOFTWARE')
+            elif state == 'running' and server['status']['state'] == 'POWERED_OFF':
+                _check_mode(module, True)
+                oneandone_conn.modify_server_status(
+                    server_id=server['id'],
+                    action='POWER_ON',
+                    method='SOFTWARE')
+        except Exception as ex:
+            module.fail_json(
+                msg="failed to set server %s to state %s: %s" % (
+                    server_id, state, str(ex)))
+
+        _check_mode(module, False)
+
+        # Make sure the server has reached the desired state
+        if wait:
+            operation_completed = False
+            wait_timeout = time.time() + wait_timeout
+            while wait_timeout > time.time():
+                time.sleep(5)
+                server = oneandone_conn.get_server(server['id'])  # refresh
+                server_state = server['status']['state']
+                if state == 'stopped' and server_state == 'POWERED_OFF':
+                    operation_completed = True
+                    break
+                if state == 'running' and server_state == 'POWERED_ON':
+                    operation_completed = True
+                    break
+            if not operation_completed:
+                module.fail_json(
+                    msg="Timeout waiting for server %s to get to state %s" % (
+                        server_id, state))
+
+        changed = True
+        server = _insert_network_data(server)
+
+    _check_mode(module, False)
+
+    return (changed, server)
+
+
+def _auto_increment_hostname(count, hostname):
+    """
+    Allow a custom incremental count in the hostname when defined with the
+    string formatting (%) operator. Otherwise, increment using name-01,
+    name-02, name-03, and so forth.
+    """
+    if '%' not in hostname:
+        hostname = "%s-%%01d" % hostname
+
+    return [
+        hostname % i
+        for i in xrange(1, count + 1)
+    ]
+
+
+def _auto_increment_description(count, description):
+    """
+    Allow the incremental count in the description when defined with the
+    string formatting (%) operator. Otherwise, repeat the same description.
+    """
+    if '%' in description:
+        return [
+            description % i
+            for i in xrange(1, count + 1)
+        ]
+    else:
+        return [description] * count
+
+
+def main():
+    module = AnsibleModule(
+        argument_spec=dict(
+            auth_token=dict(
+                type='str',
+                default=os.environ.get('ONEANDONE_AUTH_TOKEN'),
+                no_log=True),
+            hostname=dict(type='str'),
+            description=dict(type='str'),
+            appliance=dict(type='str'),
+            fixed_instance_size=dict(type='str'),
+            vcore=dict(type='int'),
+            cores_per_processor=dict(type='int'),
+            ram=dict(type='float'),
+            hdds=dict(type='list'),
+            count=dict(type='int', default=1),
+            ssh_key=dict(type='raw'),
+            auto_increment=dict(type='bool', default=True),
+            server=dict(type='str'),
+            datacenter=dict(
+                choices=DATACENTERS,
+                default='US'),
+            private_network=dict(type='str'),
+            firewall_policy=dict(type='str'),
+            load_balancer=dict(type='str'),
+            monitoring_policy=dict(type='str'),
+            wait=dict(type='bool', default=True),
+            wait_timeout=dict(type='int', default=600),
+            state=dict(type='str', default='present', choices=['present', 'absent', 'running', 'stopped']),
+        ),
+        supports_check_mode=True,
+        mutually_exclusive=(['fixed_instance_size', 'vcore'], ['fixed_instance_size', 'cores_per_processor'],
+                            ['fixed_instance_size', 'ram'], ['fixed_instance_size', 'hdds'],),
+        required_together=(['vcore', 'cores_per_processor', 'ram', 'hdds'],)
+    )
+
+    if not HAS_ONEANDONE_SDK:
+        module.fail_json(msg='1and1 required for this module')
+
+    if not module.params.get('auth_token'):
+        module.fail_json(
+            msg='The "auth_token" parameter or ' +
+            'ONEANDONE_AUTH_TOKEN environment variable is required.')
+
+    oneandone_conn = oneandone.client.OneAndOneService(
+        api_token=module.params.get('auth_token'))
+
+    state = module.params.get('state')
+
+    if state == 'absent':
+        if not module.params.get('server'):
+            module.fail_json(
+                msg="'server' parameter is required for deleting a server.")
+        try:
+            (changed, servers) = remove_server(module, oneandone_conn)
+        except Exception as ex:
+            module.fail_json(msg=str(ex))
+
+    elif state in ('running', 'stopped'):
+        if not module.params.get('server'):
+            module.fail_json(
+                msg="'server' parameter is required for starting/stopping a server.")
+        try:
+            (changed, servers) = startstop_server(module, oneandone_conn)
+        except Exception as ex:
+            module.fail_json(msg=str(ex))
+
+    elif state == 'present':
+        for param in ('hostname',
+                      'appliance',
+                      'datacenter'):
+            if not module.params.get(param):
+                module.fail_json(
+                    msg="%s parameter is required for new server." % param)
+        try:
+            (changed, servers) = create_server(module, oneandone_conn)
+        except Exception as ex:
+            module.fail_json(msg=str(ex))
+
+    module.exit_json(changed=changed, servers=servers)
+
+
+if __name__ == '__main__':
+    main()

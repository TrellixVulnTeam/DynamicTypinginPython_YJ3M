commit e76209549771d15f9a12fe12aa696df8c88c468a
Author: Brian Coca <bcoca@ansible.com>
Date:   Thu Mar 3 19:50:52 2016 -0500

    better task parsing errors
    
    fixes #14790

diff --git a/lib/ansible/parsing/splitter.py b/lib/ansible/parsing/splitter.py
index fa26242fcf..8f3c5cc088 100644
--- a/lib/ansible/parsing/splitter.py
+++ b/lib/ansible/parsing/splitter.py
@@ -22,7 +22,7 @@ __metaclass__ = type
 import re
 import codecs
 
-from ansible.errors import AnsibleError
+from ansible.errors import AnsibleParserError
 from ansible.parsing.quoting import unquote
 
 # Decode escapes adapted from rspeer's answer here:
@@ -60,7 +60,7 @@ def parse_kv(args, check_raw=False):
             vargs = split_args(args)
         except ValueError as ve:
             if 'no closing quotation' in str(ve).lower():
-                raise AnsibleError("error parsing argument string, try quoting the entire line.")
+                raise AnsibleParsingError("error parsing argument string, try quoting the entire line.")
             else:
                 raise
 
@@ -256,6 +256,6 @@ def split_args(args):
     # If we're done and things are not at zero depth or we're still inside quotes,
     # raise an error to indicate that the args were unbalanced
     if print_depth or block_depth or comment_depth or inside_quotes:
-        raise AnsibleError("error while splitting arguments, either an unbalanced jinja2 block or quotes")
+        raise AnsibleParserError("failed at splitting arguments, either an unbalanced jinja2 block or quotes")
 
     return params
diff --git a/lib/ansible/playbook/task.py b/lib/ansible/playbook/task.py
index 556aea5043..c97e81e964 100644
--- a/lib/ansible/playbook/task.py
+++ b/lib/ansible/playbook/task.py
@@ -21,13 +21,12 @@ __metaclass__ = type
 
 from ansible.compat.six import iteritems, string_types
 
-from ansible.errors import AnsibleError
+from ansible.errors import AnsibleError, AnsibleParserError
 
 from ansible.parsing.mod_args import ModuleArgsParser
 from ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping, AnsibleUnicode
 
 from ansible.plugins import lookup_loader
-
 from ansible.playbook.attribute import FieldAttribute
 from ansible.playbook.base import Base
 from ansible.playbook.become import Become
@@ -36,6 +35,8 @@ from ansible.playbook.conditional import Conditional
 from ansible.playbook.role import Role
 from ansible.playbook.taggable import Taggable
 
+from ansible.utils.unicode import to_str
+
 try:
     from __main__ import display
 except ImportError:
@@ -168,7 +169,10 @@ class Task(Base, Conditional, Taggable, Become):
         # and the delegate_to value from the various possible forms
         # supported as legacy
         args_parser = ModuleArgsParser(task_ds=ds)
-        (action, args, delegate_to) = args_parser.parse()
+        try:
+            (action, args, delegate_to) = args_parser.parse()
+        except AnsibleParserError as e:
+            raise AnsibleParserError(to_str(e), obj=ds)
 
         # the command/shell/script modules used to support the `cmd` arg,
         # which corresponds to what we now call _raw_params, so move that

commit dcdcd9e9c518eafd533842664fe3c1545793a524
Author: Toshio Kuratomi <a.badger@gmail.com>
Date:   Fri Sep 25 07:46:09 2015 -0700

    Move is_executable to the toplevel of basic.py so we can utilize it from other code

diff --git a/lib/ansible/module_utils/basic.py b/lib/ansible/module_utils/basic.py
index b3b2a8cd81..1d6bc95252 100644
--- a/lib/ansible/module_utils/basic.py
+++ b/lib/ansible/module_utils/basic.py
@@ -168,21 +168,6 @@ except ImportError:
         return _convert(node_or_string)
 
 
-def get_exception():
-    """Get the current exception.
-
-    This code needs to work on Python 2.4 through 3.x, so we cannot use
-    "except Exception, e:" (SyntaxError on Python 3.x) nor
-    "except Exception as e:" (SyntaxError on Python 2.4-2.5).
-    Instead we must use ::
-
-        except Exception:
-            e = get_exception()
-
-    """
-    return sys.exc_info()[1]
-
-
 FILE_COMMON_ARGUMENTS=dict(
     src = dict(),
     mode = dict(),
@@ -210,6 +195,22 @@ PERM_BITS = int('07777', 8)      # file mode permission bits
 EXEC_PERM_BITS = int('00111', 8) # execute permission bits
 DEFAULT_PERM = int('0666', 8)    # default file permission bits
 
+
+def get_exception():
+    """Get the current exception.
+
+    This code needs to work on Python 2.4 through 3.x, so we cannot use
+    "except Exception, e:" (SyntaxError on Python 3.x) nor
+    "except Exception as e:" (SyntaxError on Python 2.4-2.5).
+    Instead we must use ::
+
+        except Exception:
+            e = get_exception()
+
+    """
+    return sys.exc_info()[1]
+
+
 def get_platform():
     ''' what's the platform?  example: Linux is a platform. '''
     return platform.system()
@@ -368,8 +369,14 @@ def heuristic_log_sanitize(data):
     return ''.join(output)
 
 
-class AnsibleModule(object):
+def is_executable(path):
+    '''is the given path executable?'''
+    return (stat.S_IXUSR & os.stat(path)[stat.ST_MODE]
+            or stat.S_IXGRP & os.stat(path)[stat.ST_MODE]
+            or stat.S_IXOTH & os.stat(path)[stat.ST_MODE])
 
+
+class AnsibleModule(object):
     def __init__(self, argument_spec, bypass_checks=False, no_log=False,
         check_invalid_arguments=True, mutually_exclusive=None, required_together=None,
         required_one_of=None, add_file_common_args=False, supports_check_mode=False,
@@ -1307,7 +1314,7 @@ class AnsibleModule(object):
                 paths.append(p)
         for d in paths:
             path = os.path.join(d, arg)
-            if os.path.exists(path) and self.is_executable(path):
+            if os.path.exists(path) and is_executable(path):
                 bin_path = path
                 break
         if required and bin_path is None:
@@ -1371,12 +1378,6 @@ class AnsibleModule(object):
         print(self.jsonify(kwargs))
         sys.exit(1)
 
-    def is_executable(self, path):
-        '''is the given path executable?'''
-        return (stat.S_IXUSR & os.stat(path)[stat.ST_MODE]
-                or stat.S_IXGRP & os.stat(path)[stat.ST_MODE]
-                or stat.S_IXOTH & os.stat(path)[stat.ST_MODE])
-
     def digest_from_file(self, filename, algorithm):
         ''' Return hex digest of local file for a digest_method specified by name, or None if file is not present. '''
         if not os.path.exists(filename):
@@ -1741,5 +1742,13 @@ class AnsibleModule(object):
                 break
         return '%.2f %s' % (float(size)/ limit, suffix)
 
+    #
+    # Backwards compat
+    #
+
+    # In 2.0, moved from inside the module to the toplevel
+    is_executable = is_executable
+
+
 def get_module_path():
     return os.path.dirname(os.path.realpath(__file__))
diff --git a/lib/ansible/parsing/__init__.py b/lib/ansible/parsing/__init__.py
index dcd76208ac..264423627f 100644
--- a/lib/ansible/parsing/__init__.py
+++ b/lib/ansible/parsing/__init__.py
@@ -33,6 +33,7 @@ from ansible.parsing.vault import VaultLib
 from ansible.parsing.splitter import unquote
 from ansible.parsing.yaml.loader import AnsibleLoader
 from ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleUnicode
+from ansible.module_utils.basic import is_executable
 from ansible.utils.path import unfrackpath
 from ansible.utils.unicode import to_unicode
 
@@ -138,7 +139,7 @@ class DataLoader():
     def is_executable(self, path):
         '''is the given path executable?'''
         path = self.path_dwim(path)
-        return (stat.S_IXUSR & os.stat(path)[stat.ST_MODE] or stat.S_IXGRP & os.stat(path)[stat.ST_MODE] or stat.S_IXOTH & os.stat(path)[stat.ST_MODE])
+        return is_executable(path)
 
     def _safe_load(self, stream, file_name=None):
         ''' Implements yaml.safe_load(), except using our custom loader class. '''

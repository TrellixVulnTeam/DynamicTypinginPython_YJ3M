commit 0d530f3bf02f0106adf16be975b348be478d783b
Author: Michael DeHaan <michael.dehaan@gmail.com>
Date:   Mon Apr 8 12:36:01 2013 -0400

    Change the retry logic to write a limit file, able to source limit from files by indicating with @filename

diff --git a/bin/ansible-playbook b/bin/ansible-playbook
index a4de6e42db..917d00e6ff 100755
--- a/bin/ansible-playbook
+++ b/bin/ansible-playbook
@@ -192,7 +192,7 @@ def main(args):
             if len(failed_hosts) > 0:
                 filename = pb.generate_retry_inventory(failed_hosts)
                 if filename:
-                    print "           to rerun against failed hosts only, use -i %s\n" % filename
+                    print "           to retry, use: --limit @%s\n" % filename
 
             for h in hosts:
                 t = pb.stats.summarize(h)
diff --git a/lib/ansible/inventory/__init__.py b/lib/ansible/inventory/__init__.py
index 564967dc2e..69a0431533 100644
--- a/lib/ansible/inventory/__init__.py
+++ b/lib/ansible/inventory/__init__.py
@@ -330,7 +330,17 @@ class Inventory(object):
             self._subset = None
         else:
             subset_pattern = subset_pattern.replace(',',':')
-            self._subset = subset_pattern.replace(";",":").split(":")
+            subset_pattern = subset_pattern.replace(";",":").split(":")
+            results = []
+            # allow Unix style @filename data
+            for x in subset_pattern:
+               if x.startswith("@"):
+                   fd = open(x[1:])
+                   results.extend(fd.read().split("\n"))
+                   fd.close()
+               else:
+                   results.append(x)
+            self._subset = results
 
     def lift_restriction(self):
         """ Do not restrict list operations """
diff --git a/lib/ansible/playbook/__init__.py b/lib/ansible/playbook/__init__.py
index 18579136ca..d654f79b81 100644
--- a/lib/ansible/playbook/__init__.py
+++ b/lib/ansible/playbook/__init__.py
@@ -426,79 +426,27 @@ class PlayBook(object):
         variable information in group_vars/host_vars but that is ok, and expected.
         ''' 
 
-        # TODO: move this into an inventory.serialize() method
-
         buf = StringIO.StringIO()
-
-        buf.write("# dynamically generated inventory file\n")
-        buf.write("# retries previously failed hosts only\n")
-        buf.write("\n")
-
-        inventory = self.inventory
-        basedir = inventory.basedir()
-        filename = ".%s.retry" % os.path.basename(self.filename)
-        filename = os.path.join(basedir, filename)
-
-        def _simple_kv_vars(host_vars):
-            buf = ""
-            for (k, v) in host_vars.items():
-                if type(v) not in [ list, dict ]:
-                   if isinstance(v,basestring):
-                       buf = buf + " %s=%s" % (k, pipes.quote(v))
-                   else:
-                       buf = buf + " %s=%s" % (k, v)
-            return buf
- 
-        # for all group names
-        for gname in inventory.groups_list():
-
-            # write the group name
-            group = inventory.get_group(gname)
-            group_vars = inventory.get_group_variables(gname)
-
-            # but only contain hosts that we want to replay
-            hostz = [ host.name for host in group.hosts ]
-            hostz = [ hname for hname in hostz if hname in replay_hosts ] 
-            if len(hostz):
-                buf.write("[%s]\n" % group.name)
-                for hostname in hostz:
-                    host = inventory.get_host(hostname)
-                    host_vars = host.vars
-                    hostname_vars = _simple_kv_vars(host_vars)
-                    buf.write("%s %s\n" % (hostname, hostname_vars))
-                buf.write("\n")
-
-            # write out any child groups if present
-            if len(group.child_groups) and group.name not in [ 'all', 'ungrouped' ]:
-                buf.write("\n")
-                buf.write("[%s:children]\n" % gname)
-                for child_group in group.child_groups:
-                    buf.write("%s\n" % child_group.name)
-                buf.write("\n")
-
-            # we do NOT write out group variables because they will have already
-            # been blended with the host
-
-            if len(group_vars.keys()) > 0 and group.name not in [ 'all', 'ungrouped' ]:
-                buf.write("[%s:vars]\n" % gname) 
-                for (k,v) in group_vars.items():
-                    if type(v) not in [list,dict]:
-                        if isinstance(type(k), basestring):
-                            buf.write("%s='%s'\n" % (k,v))  
-                        else:  
-                            buf.write("%s=%s\n" % (k,v))
-                buf.write("\n")
-
-        # if file isn't writeable, don't do anything.
-        # TODO: allow a environment variable to pick a different destination for this file
+        for x in replay_hosts:
+            buf.write("%s\n" % x)
+        basedir = self.inventory.basedir()
+        filename = "%s.retry" % os.path.basename(self.filename)
+
+        if not os.path.exists('/var/tmp/ansible'):
+            try:
+                os.makedirs('/var/tmp/ansible')
+            except:
+                pass
+        filename = os.path.join('/var/tmp/ansible', filename)
 
         try:
             fd = open(filename, 'w')
             fd.write(buf.getvalue())
             fd.close()
             return filename
-        except Exception, e:
-            return None
+        except:
+            pass
+        return None
 
     # *****************************************************
 

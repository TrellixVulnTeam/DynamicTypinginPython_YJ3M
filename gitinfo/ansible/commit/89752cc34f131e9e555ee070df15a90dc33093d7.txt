commit 89752cc34f131e9e555ee070df15a90dc33093d7
Author: Ganesh Nalawade <ganesh634@gmail.com>
Date:   Sun Apr 16 23:25:40 2017 +0530

    Make logging consistent for network platforms (#23605)

diff --git a/lib/ansible/plugins/action/dellos10.py b/lib/ansible/plugins/action/dellos10.py
index 2ce029fb27..171a917bee 100644
--- a/lib/ansible/plugins/action/dellos10.py
+++ b/lib/ansible/plugins/action/dellos10.py
@@ -64,6 +64,7 @@ class ActionModule(_ActionModule):
         pc.become = provider['authorize'] or False
         pc.become_pass = provider['auth_pass']
 
+        display.vvv('using connection plugin %s' % pc.connection, pc.remote_addr)
         connection = self._shared_loader_obj.connection_loader.get('persistent', pc, sys.stdin)
 
         socket_path = self._get_socket_path(pc)
@@ -72,6 +73,7 @@ class ActionModule(_ActionModule):
         if not os.path.exists(socket_path):
             # start the connection if it isn't started
             rc, out, err = connection.exec_command('open_shell()')
+            display.vvvv('open_shell() returned %s %s %s' % (rc, out, err))
             if not rc == 0:
                 return {'failed': True,
                         'msg': 'unable to open shell. Please see: ' +
@@ -82,7 +84,7 @@ class ActionModule(_ActionModule):
             # enable mode and not config module
             rc, out, err = connection.exec_command('prompt()')
             while str(out).strip().endswith(')#'):
-                display.debug('wrong context, sending exit to device')
+                display.vvvv('wrong context, sending exit to device', self._play_context.remote_addr)
                 connection.exec_command('exit')
                 rc, out, err = connection.exec_command('prompt()')
 
diff --git a/lib/ansible/plugins/action/dellos6.py b/lib/ansible/plugins/action/dellos6.py
index 722ad31c05..944e6b0a0b 100644
--- a/lib/ansible/plugins/action/dellos6.py
+++ b/lib/ansible/plugins/action/dellos6.py
@@ -60,6 +60,7 @@ class ActionModule(_ActionModule):
         pc.become = provider['authorize'] or False
         pc.become_pass = provider['auth_pass']
 
+        display.vvv('using connection plugin %s' % pc.connection, pc.remote_addr)
         connection = self._shared_loader_obj.connection_loader.get('persistent', pc, sys.stdin)
 
         socket_path = self._get_socket_path(pc)
@@ -68,6 +69,7 @@ class ActionModule(_ActionModule):
         if not os.path.exists(socket_path):
             # start the connection if it isn't started
             rc, out, err = connection.exec_command('open_shell()')
+            display.vvvv('open_shell() returned %s %s %s' % (rc, out, err))
             if not rc == 0:
                 return {'failed': True,
                         'msg': 'unable to open shell. Please see: ' +
@@ -78,7 +80,7 @@ class ActionModule(_ActionModule):
             # enable mode and not config module
             rc, out, err = connection.exec_command('prompt()')
             while str(out).strip().endswith(')#'):
-                display.debug('wrong context, sending exit to device')
+                display.vvvv('wrong context, sending exit to device', self._play_context.remote_addr)
                 connection.exec_command('exit')
                 rc, out, err = connection.exec_command('prompt()')
 
diff --git a/lib/ansible/plugins/action/dellos9.py b/lib/ansible/plugins/action/dellos9.py
index 36136e1699..d5ecdb161e 100644
--- a/lib/ansible/plugins/action/dellos9.py
+++ b/lib/ansible/plugins/action/dellos9.py
@@ -64,6 +64,7 @@ class ActionModule(_ActionModule):
         pc.become = provider['authorize'] or False
         pc.become_pass = provider['auth_pass']
 
+        display.vvv('using connection plugin %s' % pc.connection, pc.remote_addr)
         connection = self._shared_loader_obj.connection_loader.get('persistent', pc, sys.stdin)
 
         socket_path = self._get_socket_path(pc)
@@ -72,6 +73,7 @@ class ActionModule(_ActionModule):
         if not os.path.exists(socket_path):
             # start the connection if it isn't started
             rc, out, err = connection.exec_command('open_shell()')
+            display.vvvv('open_shell() returned %s %s %s' % (rc, out, err))
             if not rc == 0:
                 return {'failed': True,
                         'msg': 'unable to open shell. Please see: ' +
@@ -82,7 +84,7 @@ class ActionModule(_ActionModule):
             # enable mode and not config module
             rc, out, err = connection.exec_command('prompt()')
             while str(out).strip().endswith(')#'):
-                display.debug('wrong context, sending exit to device')
+                display.vvvv('wrong context, sending exit to device', self._play_context.remote_addr)
                 connection.exec_command('exit')
                 rc, out, err = connection.exec_command('prompt()')
 
diff --git a/lib/ansible/plugins/action/eos.py b/lib/ansible/plugins/action/eos.py
index f40d617972..d3b94f7bd6 100644
--- a/lib/ansible/plugins/action/eos.py
+++ b/lib/ansible/plugins/action/eos.py
@@ -65,6 +65,7 @@ class ActionModule(_ActionModule):
             pc.become = provider['authorize'] or False
             pc.become_pass = provider['auth_pass']
 
+            display.vvv('using connection plugin %s' % pc.connection, pc.remote_addr)
             connection = self._shared_loader_obj.connection_loader.get('persistent', pc, sys.stdin)
 
             socket_path = self._get_socket_path(pc)
@@ -72,8 +73,8 @@ class ActionModule(_ActionModule):
 
             if not os.path.exists(socket_path):
                 # start the connection if it isn't started
-                display.vvvv('calling open_shell()', pc.remote_addr)
                 rc, out, err = connection.exec_command('open_shell()')
+                display.vvvv('open_shell() returned %s %s %s' % (rc, out, err))
                 if not rc == 0:
                     return {'failed': True,
                             'msg': 'unable to open shell. Please see: ' +
diff --git a/lib/ansible/plugins/action/ios.py b/lib/ansible/plugins/action/ios.py
index cbfef17e07..fa3fb8bdde 100644
--- a/lib/ansible/plugins/action/ios.py
+++ b/lib/ansible/plugins/action/ios.py
@@ -63,12 +63,16 @@ class ActionModule(_ActionModule):
         pc.become = provider['authorize'] or False
         pc.become_pass = provider['auth_pass']
 
+        display.vvv('using connection plugin %s' % pc.connection, pc.remote_addr)
         connection = self._shared_loader_obj.connection_loader.get('persistent', pc, sys.stdin)
 
         socket_path = self._get_socket_path(pc)
+        display.vvvv('socket_path: %s' % socket_path, pc.remote_addr)
+
         if not os.path.exists(socket_path):
             # start the connection if it isn't started
             rc, out, err = connection.exec_command('open_shell()')
+            display.vvvv('open_shell() returned %s %s %s' % (rc, out, err))
             if not rc == 0:
                 return {'failed': True,
                         'msg': 'unable to open shell. Please see: ' +
@@ -79,7 +83,7 @@ class ActionModule(_ActionModule):
             # enable mode and not config module
             rc, out, err = connection.exec_command('prompt()')
             if str(out).strip().endswith(')#'):
-                display.vvv('wrong context, sending exit to device', self._play_context.remote_addr)
+                display.vvvv('wrong context, sending exit to device', self._play_context.remote_addr)
                 connection.exec_command('exit')
 
         task_vars['ansible_socket'] = socket_path
diff --git a/lib/ansible/plugins/action/iosxr.py b/lib/ansible/plugins/action/iosxr.py
index f7e78d2c0a..aa2ae69332 100644
--- a/lib/ansible/plugins/action/iosxr.py
+++ b/lib/ansible/plugins/action/iosxr.py
@@ -60,13 +60,16 @@ class ActionModule(_ActionModule):
         pc.password = provider['password'] or self._play_context.password
         pc.timeout = provider['timeout'] or self._play_context.timeout
 
+        display.vvv('using connection plugin %s' % pc.connection, pc.remote_addr)
         connection = self._shared_loader_obj.connection_loader.get('persistent', pc, sys.stdin)
 
         socket_path = self._get_socket_path(pc)
+        display.vvvv('socket_path: %s' % socket_path, pc.remote_addr)
+
         if not os.path.exists(socket_path):
             # start the connection if it isn't started
-            display.vvvv('calling open_shell()', pc.remote_addr)
             rc, out, err = connection.exec_command('open_shell()')
+            display.vvvv('open_shell() returned %s %s %s' % (rc, out, err))
             if rc != 0:
                 return {'failed': True,
                         'msg': 'unable to open shell. Please see: ' +
diff --git a/lib/ansible/plugins/action/junos.py b/lib/ansible/plugins/action/junos.py
index 06078a0ba7..7e5581ab67 100644
--- a/lib/ansible/plugins/action/junos.py
+++ b/lib/ansible/plugins/action/junos.py
@@ -82,8 +82,10 @@ class ActionModule(_ActionModule):
             # start the connection if it isn't started
             if pc.connection == 'netconf':
                 rc, out, err = connection.exec_command('open_session()')
+                display.vvvv('open_session() returned %s %s %s' % (rc, out, err))
             else:
                 rc, out, err = connection.exec_command('open_shell()')
+                display.vvvv('open_shell() returned %s %s %s' % (rc, out, err))
 
             if rc != 0:
                 return {'failed': True,
diff --git a/lib/ansible/plugins/action/nxos.py b/lib/ansible/plugins/action/nxos.py
index 9bdc508bb8..b50d46c2a9 100644
--- a/lib/ansible/plugins/action/nxos.py
+++ b/lib/ansible/plugins/action/nxos.py
@@ -64,6 +64,7 @@ class ActionModule(_ActionModule):
             pc.private_key_file = provider['ssh_keyfile'] or self._play_context.private_key_file
             pc.timeout = provider['timeout'] or self._play_context.timeout
 
+            display.vvv('using connection plugin %s' % pc.connection, pc.remote_addr)
             connection = self._shared_loader_obj.connection_loader.get('persistent', pc, sys.stdin)
 
             socket_path = self._get_socket_path(pc)
diff --git a/lib/ansible/plugins/action/sros.py b/lib/ansible/plugins/action/sros.py
index 3a37305244..d510a773af 100644
--- a/lib/ansible/plugins/action/sros.py
+++ b/lib/ansible/plugins/action/sros.py
@@ -70,6 +70,7 @@ class ActionModule(_ActionModule):
         if not os.path.exists(socket_path):
             # start the connection if it isn't started
             rc, out, err = connection.exec_command('open_shell()')
+            display.vvvv('open_shell() returned %s %s %s' % (rc, out, err))
             if not rc == 0:
                 return {'failed': True,
                         'msg': 'unable to open shell. Please see: ' +
diff --git a/lib/ansible/plugins/action/vyos.py b/lib/ansible/plugins/action/vyos.py
index 9da1f64ebe..f8668b8928 100644
--- a/lib/ansible/plugins/action/vyos.py
+++ b/lib/ansible/plugins/action/vyos.py
@@ -60,6 +60,7 @@ class ActionModule(_ActionModule):
         pc.private_key_file = provider['ssh_keyfile'] or self._play_context.private_key_file
         pc.timeout = provider['timeout'] or self._play_context.timeout
 
+        display.vvv('using connection plugin %s' % pc.connection, pc.remote_addr)
         connection = self._shared_loader_obj.connection_loader.get('persistent', pc, sys.stdin)
 
         socket_path = self._get_socket_path(pc)
@@ -68,8 +69,12 @@ class ActionModule(_ActionModule):
         if not os.path.exists(socket_path):
             # start the connection if it isn't started
             rc, out, err = connection.exec_command('open_shell()')
-            if rc != 0:
-                return {'failed': True, 'msg': 'unable to connect to control socket'}
+            display.vvvv('open_shell() returned %s %s %s' % (rc, out, err))
+            if not rc == 0:
+                return {'failed': True,
+                        'msg': 'unable to open shell. Please see: ' +
+                               'https://docs.ansible.com/ansible/network_debug_troubleshooting.html#unable-to-open-shell',
+                        'rc': rc}
         else:
             # make sure we are in the right cli context which should be
             # enable mode and not config module

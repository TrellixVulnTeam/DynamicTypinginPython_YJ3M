commit c414ded69a6b12fc22b4b2756e24cce9926bc84c
Author: Toshio Kuratomi <a.badger@gmail.com>
Date:   Mon Dec 5 08:40:38 2016 -0800

    Revert "minor updates to network_cli connection plugin (#18742)"
    
    This reverts commit 8e375913b0e80137e3449e7af40ee4c7eba6f121.
    
    This breaks testing as the PlayContext is not mocked out for the test.
    Temporarily reverting.

diff --git a/lib/ansible/plugins/connection/network_cli.py b/lib/ansible/plugins/connection/network_cli.py
index b65c2ba7b6..403358738e 100644
--- a/lib/ansible/plugins/connection/network_cli.py
+++ b/lib/ansible/plugins/connection/network_cli.py
@@ -27,12 +27,11 @@ import datetime
 from ansible.errors import AnsibleConnectionFailure
 from ansible.module_utils.six.moves import StringIO
 from ansible.plugins import terminal_loader
-from ansible.plugins.connection import ensure_connect
 from ansible.plugins.connection.paramiko_ssh import Connection as _Connection
 
 
 class Connection(_Connection):
-    ''' CLI (shell) SSH connections on Paramiko '''
+    ''' CLI SSH based connections on Paramiko '''
 
     transport = 'network_cli'
     has_pipelining = False
@@ -48,7 +47,6 @@ class Connection(_Connection):
         self._history = list()
 
     def update_play_context(self, play_context):
-        """Updates the play context information for the connection"""
         if self._play_context.become is False and play_context.become is True:
             auth_pass = play_context.become_pass
             self._terminal.on_authorize(passwd=auth_pass)
@@ -59,7 +57,6 @@ class Connection(_Connection):
         self._play_context = play_context
 
     def _connect(self):
-        """Connections to the device and sets the terminal type"""
         super(Connection, self)._connect()
 
         network_os = self._play_context.network_os
@@ -81,9 +78,7 @@ class Connection(_Connection):
 
         return (0, 'connected', '')
 
-    @ensure_connect
-    def open_shell(self):
-        """Opens the vty shell on the connection"""
+    def open_shell(self, timeout=10):
         self._shell = self.ssh.invoke_shell()
         self._shell.settimeout(self._play_context.timeout)
 
@@ -92,16 +87,16 @@ class Connection(_Connection):
         if self._shell:
             self._terminal.on_open_shell()
 
-        if getattr(self._play_context, 'become', None):
-            auth_pass = self._play_context.become_pass
-            self._terminal.on_authorize(passwd=auth_pass)
+        if hasattr(self._play_context, 'become'):
+            if self._play_context.become:
+                auth_pass = self._play_context.become_pass
+                self._terminal.on_authorize(passwd=auth_pass)
 
     def close(self):
         self.close_shell()
         super(Connection, self).close()
 
     def close_shell(self):
-        """Closes the vty shell if the device supports multiplexing"""
         if self._shell:
             self._terminal.on_close_shell()
 
@@ -112,7 +107,6 @@ class Connection(_Connection):
         return (0, 'shell closed', '')
 
     def receive(self, obj=None):
-        """Handles receiving of output from command"""
         recv = StringIO()
         handled = False
 
@@ -136,7 +130,6 @@ class Connection(_Connection):
                 return self._sanitize(resp, obj)
 
     def send(self, obj):
-        """Sends the command to the device in the opened shell"""
         try:
             command = obj['command']
             self._history.append(command)
@@ -146,13 +139,11 @@ class Connection(_Connection):
             raise AnsibleConnectionFailure("timeout trying to send command: %s" % command.strip())
 
     def _strip(self, data):
-        """Removes ANSI codes from device response"""
         for regex in self._terminal.ansi_re:
             data = regex.sub('', data)
         return data
 
     def _handle_prompt(self, resp, obj):
-        """Matches the command prompt and responds"""
         prompt = re.compile(obj['prompt'], re.I)
         answer = obj['answer']
         match = prompt.search(resp)
@@ -161,7 +152,6 @@ class Connection(_Connection):
             return True
 
     def _sanitize(self, resp, obj=None):
-        """Removes elements from the response before returning to the caller"""
         cleaned = []
         command = obj.get('command') if obj else None
         for line in resp.splitlines():
@@ -171,7 +161,6 @@ class Connection(_Connection):
         return str("\n".join(cleaned)).strip()
 
     def _find_prompt(self, response):
-        """Searches the buffered response for a matching command prompt"""
         for regex in self._terminal.terminal_errors_re:
             if regex.search(response):
                 raise AnsibleConnectionFailure(response)
@@ -184,28 +173,10 @@ class Connection(_Connection):
                 return True
 
     def alarm_handler(self, signum, frame):
-        """Alarm handler raised in case of command timeout """
         self.close_shell()
 
     def exec_command(self, cmd):
-        """Executes the cmd on in the shell and returns the output
-
-        The method accepts two forms of cmd.  The first form is as a
-        string that represents the command to be executed in the shell.  The
-        second form is as a JSON string with additional keyword.
-
-        Keywords supported for cmd:
-            * command - the command string to execute
-            * prompt - the expected prompt generated by executing command
-            * response - the string to respond to the prompt with
-
-        :arg cmd: the string that represents the command to be executed
-            which can be a single command or a json encoded string
-        :returns: a tuple of (return code, stdout, stderr).  The return
-            code is an integer and stdout and stderr are strings
-        """
-        # TODO: add support for timeout to the cmd to handle non return
-        # commands such as a system restart
+        ''' {'command': <str>, 'prompt': <str>, 'answer': <str>} '''
 
         try:
             obj = json.loads(cmd)

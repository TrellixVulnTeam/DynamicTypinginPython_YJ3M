commit 0810f2609529f13705299cbbb7b00882e20f6fab
Author: Michael DeHaan <michael.dehaan@gmail.com>
Date:   Mon Aug 6 20:02:02 2012 -0400

    whitespace

diff --git a/examples/scripts/cobbler_external_inventory.py b/examples/scripts/cobbler_external_inventory.py
index 7b6980e6a6..223f8e37be 100755
--- a/examples/scripts/cobbler_external_inventory.py
+++ b/examples/scripts/cobbler_external_inventory.py
@@ -6,15 +6,15 @@ Cobbler external inventory script
 
 Ansible has a feature where instead of reading from /etc/ansible/hosts
 as a text file, it can query external programs to obtain the list
-of hosts, groups the hosts are in, and even variables to assign to each host.  
+of hosts, groups the hosts are in, and even variables to assign to each host.
 
 To use this, copy this file over /etc/ansible/hosts and chmod +x the file.
 This, more or less, allows you to keep one central database containing
 info about all of your managed instances.
 
 This script is an example of sourcing that data from Cobbler
-(http://cobbler.github.com).  With cobbler each --mgmt-class in cobbler 
-will correspond to a group in Ansible, and --ks-meta variables will be 
+(http://cobbler.github.com).  With cobbler each --mgmt-class in cobbler
+will correspond to a group in Ansible, and --ks-meta variables will be
 passed down for use in templates or even in argument lines.
 
 NOTE: The cobbler system names will not be used.  Make sure a
@@ -23,11 +23,11 @@ appears with two DNS names we do not add it twice because we don't want
 ansible talking to it twice.  The first one found will be used. If no
 --dns-name is set the system will NOT be visible to ansible.  We do
 not add cobbler system names because there is no requirement in cobbler
-that those correspond to addresses.  
+that those correspond to addresses.
 
 See http://ansible.github.com/api.html for more info
 
-Tested with Cobbler 2.0.11. 
+Tested with Cobbler 2.0.11.
 """
 
 # (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
@@ -83,8 +83,8 @@ if len(sys.argv) == 2 and (sys.argv[1] == '--list'):
         for (iname, ivalue) in interfaces.iteritems():
             this_dns_name = ivalue.get('dns_name', None)
             if this_dns_name is not None:
-                dns_name = this_dns_name       
- 
+                dns_name = this_dns_name
+
         if dns_name is None:
             continue
 
@@ -95,7 +95,7 @@ if len(sys.argv) == 2 and (sys.argv[1] == '--list'):
             # hostname is not really what we want to insert, really insert the
             # first DNS name but no further DNS names
             groups[cls].append(dns_name)
- 
+
     print json.dumps(groups)
     sys.exit(0)
 
diff --git a/examples/scripts/ec2_external_inventory.py b/examples/scripts/ec2_external_inventory.py
index 9c2733e6d8..df5ce2c839 100755
--- a/examples/scripts/ec2_external_inventory.py
+++ b/examples/scripts/ec2_external_inventory.py
@@ -5,13 +5,13 @@ EC2 external inventory script
 =================================
 
 Generates inventory that Ansible can understand by making API request to
-AWS EC2 using the Boto library. 
+AWS EC2 using the Boto library.
 
 NOTE: This script assumes Ansible is being executed where the environment
 variables needed for Boto have already been set:
     export AWS_ACCESS_KEY_ID='AK123'
     export AWS_SECRET_ACCESS_KEY='abc123'
-    
+
 For more details, see: http://docs.pythonboto.org/en/latest/boto_config_tut.html
 
 When run against a specific host, this script returns the following variables:
@@ -80,7 +80,7 @@ In addition, if an instance has AWS Tags associated with it, each tag is a new
 variable named:
  - ec2_tag_[Key] = [Value]
 
-Security groups are comma-separated in 'ec2_security_group_ids' and 
+Security groups are comma-separated in 'ec2_security_group_ids' and
 'ec2_security_group_names'.
 '''
 
@@ -119,38 +119,38 @@ except ImportError:
 class Ec2Inventory(object):
     def __init__(self):
         ''' Main execution path '''
-        
+
         # Inventory grouped by instance IDs, tags, security groups, regions,
         # and availability zones
         self.inventory = {}
-        
+
         # Index of hostname (address) to instance ID
         self.index = {}
-        
+
         # Read settings and parse CLI arguments
         self.read_settings()
         self.parse_cli_args()
-        
+
         # Cache
         if self.args.refresh_cache:
-            self.do_api_calls_update_cache()  
+            self.do_api_calls_update_cache()
         elif not self.is_cache_valid():
             self.do_api_calls_update_cache()
-        
+
         # Data to print
         if self.args.host:
             data_to_print = self.get_host_info()
-        
+
         elif self.args.list:
             # Display list of instances for inventory
             if len(self.inventory) == 0:
                 data_to_print = self.get_inventory_from_cache()
             else:
                 data_to_print = self.json_format_dict(self.inventory, True)
-              
+
         print data_to_print
-        
-        
+
+
     def is_cache_valid(self):
         ''' Determines if the cache files have expired, or if it is still valid '''
 
@@ -160,16 +160,16 @@ class Ec2Inventory(object):
             if (mod_time + self.cache_max_age) > current_time:
                 if os.path.isfile(self.cache_path_index):
                     return True
-                
+
         return False
-        
-        
+
+
     def read_settings(self):
         ''' Reads the settings from the ec2.ini file '''
-        
+
         config = ConfigParser.SafeConfigParser()
         config.read(os.path.dirname(os.path.realpath(__file__)) + '/ec2.ini')
-        
+
         # Regions
         self.regions = []
         configRegions = config.get('ec2', 'regions')
@@ -178,7 +178,7 @@ class Ec2Inventory(object):
                 self.regions.append(regionInfo.name)
         else:
             self.regions = configRegions.split(",")
-        
+
         # Destination addresses
         self.destination_variable = config.get('ec2', 'destination_variable')
         self.vpc_destination_variable = config.get('ec2', 'vpc_destination_variable')
@@ -188,27 +188,27 @@ class Ec2Inventory(object):
         self.cache_path_cache = cache_path + "/ansible-ec2.cache"
         self.cache_path_index = cache_path + "/ansible-ec2.index"
         self.cache_max_age = config.getint('ec2', 'cache_max_age')
-        
-        
+
+
     def parse_cli_args(self):
         ''' Command line argument processing '''
-        
+
         parser = argparse.ArgumentParser(description='Produce an Ansible Inventory file based on EC2')
-        parser.add_argument('--list', action='store_true', default=True, 
+        parser.add_argument('--list', action='store_true', default=True,
                            help='List instances (default: True)')
-        parser.add_argument('--host', action='store', 
+        parser.add_argument('--host', action='store',
                            help='Get all the variables about a specific instance')
-        parser.add_argument('--refresh-cache', action='store_true', default=False, 
+        parser.add_argument('--refresh-cache', action='store_true', default=False,
                            help='Force refresh of cache by making API requests to EC2 (default: False - use cache files)')
         self.args = parser.parse_args()
-        
-        
+
+
     def do_api_calls_update_cache(self):
         ''' Do API calls to each region, and save data in cache files '''
-        
+
         for region in self.regions:
             self.get_instances_by_region(region)
-        
+
         self.write_to_cache(self.inventory, self.cache_path_cache)
         self.write_to_cache(self.index, self.cache_path_index)
 
@@ -216,7 +216,7 @@ class Ec2Inventory(object):
     def get_instances_by_region(self, region):
         ''' Makes an AWS EC2 API call to the list of instances in a particular
         region '''
-        
+
         conn = ec2.connect_to_region(region)
         reservations = conn.get_all_instances()
         for reservation in reservations:
@@ -231,16 +231,16 @@ class Ec2Inventory(object):
         for reservation in reservations:
             for instance in reservation.instances:
                 return instance
-            
-        
+
+
     def add_instance(self, instance, region):
         ''' Adds an instance to the inventory and index, as long as it is
         addressable '''
-        
+
         # Only want running instances
         if instance.state == 'terminated':
             return
-        
+
         # Select the best destination address
         if instance.subnet_id:
             dest = getattr(instance, self.vpc_destination_variable)
@@ -256,38 +256,38 @@ class Ec2Inventory(object):
 
         # Inventory: Group by instance ID (always a group of 1)
         self.inventory[instance.id] = [dest]
-        
+
         # Inventory: Group by region
         self.push(self.inventory, region, dest)
-                        
+
         # Inventory: Group by availability zone
         self.push(self.inventory, instance.placement, dest)
-        
+
         # Inventory: Group by security group
         for group in instance.groups:
             key = self.to_safe("security_group_" + group.name)
             self.push(self.inventory, key, dest)
-                
+
         # Inventory: Group by tag keys
         for k, v in instance.tags.iteritems():
             key = self.to_safe("tag_" + k + "=" + v)
-            self.push(self.inventory, key, dest)        
-    
-    
+            self.push(self.inventory, key, dest)
+
+
     def get_host_info(self):
         ''' Get variables about a specific host '''
-        
+
         if len(self.index) == 0:
             # Need to load index from cache
             self.load_index_from_cache()
-        
+
         (region, instance_id) = self.index[self.args.host]
         instance = self.get_instance(region, instance_id)
         instance_vars = {}
         for key in vars(instance):
             value = getattr(instance, key)
             key = self.to_safe('ec2_' + key)
-            
+
             # Handle complex types
             if type(value) in [int, bool]:
                 instance_vars[key] = value
@@ -315,20 +315,20 @@ class Ec2Inventory(object):
                 #print key
                 #print type(value)
                 #print value
-                           
-        return self.json_format_dict(instance_vars, True)        
-    
-    
+
+        return self.json_format_dict(instance_vars, True)
+
+
     def push(self, my_dict, key, element):
         ''' Pushed an element onto an array that may not have been defined in
         the dict '''
-        
+
         if key in my_dict:
             my_dict[key].append(element);
         else:
-            my_dict[key] = [element]        
-    
-    
+            my_dict[key] = [element]
+
+
     def get_inventory_from_cache(self):
         ''' Reads the inventory from the cache file and returns it as a JSON
         object '''
@@ -344,34 +344,34 @@ class Ec2Inventory(object):
         cache = open(self.cache_path_index, 'r')
         json_index = cache.read()
         self.index = json.loads(json_index)
-    
-    
+
+
     def write_to_cache(self, data, filename):
         ''' Writes data in JSON format to a file '''
-        
+
         json_data = self.json_format_dict(data, True)
         cache = open(filename, 'w')
         cache.write(json_data)
         cache.close()
-        
-        
+
+
     def to_safe(self, word):
         ''' Converts 'bad' characters in a string to underscores so they can be
         used as Ansible groups '''
-        
+
         return re.sub("[^A-Za-z0-9\-]", "_", word)
-        
-        
+
+
     def json_format_dict(self, data, pretty=False):
         ''' Converts a dict to a JSON object and dumps it as a formatted
         string '''
-        
+
         if pretty:
             return json.dumps(data, sort_keys=True, indent=2)
         else:
             return json.dumps(data)
-        
-    
+
+
 # Run the script
 Ec2Inventory()
 
diff --git a/examples/scripts/yaml_to_ini.py b/examples/scripts/yaml_to_ini.py
index 5b97d14b16..09b9b5ec82 100644
--- a/examples/scripts/yaml_to_ini.py
+++ b/examples/scripts/yaml_to_ini.py
@@ -45,7 +45,7 @@ class InventoryParserYaml(object):
         else:
             host = Host(hostname)
             self._hosts[hostname] = host
-            return host 
+            return host
 
     # see file 'test/yaml_hosts' for syntax
 
@@ -79,7 +79,7 @@ class InventoryParserYaml(object):
                         if type(vars) == list:
                             for subitem in vars:
                                 for (k,v) in subitem.items():
-                                    host.set_variable(k,v) 
+                                    host.set_variable(k,v)
                         elif type(vars) == dict:
                             for (k,v) in subresult.get('vars',{}).items():
                                 host.set_variable(k,v)
@@ -91,7 +91,7 @@ class InventoryParserYaml(object):
                 vars = item.get('vars',{})
                 if type(vars) == dict:
                     for (k,v) in item.get('vars',{}).items():
-                        group.set_variable(k,v) 
+                        group.set_variable(k,v)
                 elif type(vars) == list:
                     for subitem in vars:
                         if type(subitem) != dict:
@@ -159,7 +159,7 @@ if __name__ == "__main__":
 
         if group_name == 'all':
             continue
- 
+
         hosts = record.hosts
         result = result + "[%s]\n" % record.name
         for h in hosts:
@@ -186,7 +186,7 @@ if __name__ == "__main__":
         hostfh = open(hostfile, 'w')
         hostfh.write(yaml.dump(host_record.get_variables()))
         hostfh.close()
- 
+
 
     # also need to keep a hash of variables per each host
     # and variables per each group
@@ -198,7 +198,7 @@ if __name__ == "__main__":
     fdh.close()
 
     print "* COMPLETE: review your new inventory file and replace your original when ready"
-    print "*           new inventory file saved as %s" % newfilepath  
+    print "*           new inventory file saved as %s" % newfilepath
     print "*           edit group specific variables in %s/group_vars/" % dirname
     print "*           edit host specific variables in %s/host_vars/" % dirname
 

commit a6ca133da8d0f65536dc7495c75b1f34bf960ccb
Author: Brian Coca <bcoca@ansible.com>
Date:   Fri Jun 12 23:43:36 2015 -0400

    got first_available working with copy

diff --git a/lib/ansible/plugins/action/copy.py b/lib/ansible/plugins/action/copy.py
index 2d404029c5..90b1c3a901 100644
--- a/lib/ansible/plugins/action/copy.py
+++ b/lib/ansible/plugins/action/copy.py
@@ -43,14 +43,12 @@ class ActionModule(ActionBase):
         dest    = self._task.args.get('dest', None)
         raw     = boolean(self._task.args.get('raw', 'no'))
         force   = boolean(self._task.args.get('force', 'yes'))
+        faf     = task_vars.get('first_available_file', None)
 
-        # FIXME: first available file needs to be reworked somehow...
-        #if (source is None and content is None and not 'first_available_file' in inject) or dest is None:
-        #    result=dict(failed=True, msg="src (or content) and dest are required")
-        #    return ReturnData(conn=conn, result=result)
-        #elif (source is not None or 'first_available_file' in inject) and content is not None:
-        #    result=dict(failed=True, msg="src and content are mutually exclusive")
-        #    return ReturnData(conn=conn, result=result)
+        if (source is None and content is None and faf is None) or dest is None:
+            return dict(failed=True, msg="src (or content) and dest are required")
+        elif (source is not None or faf is not None) and content is not None:
+            return dict(failed=True, msg="src and content are mutually exclusive")
 
         # Check if the source ends with a "/"
         source_trailing_slash = False
@@ -65,7 +63,7 @@ class ActionModule(ActionBase):
             try:
                 # If content comes to us as a dict it should be decoded json.
                 # We need to encode it back into a string to write it out.
-                if isinstance(content, dict):
+                if isinstance(content, dict) or isinstance(content, list):
                     content_tempfile = self._create_content_tempfile(json.dumps(content))
                 else:
                     content_tempfile = self._create_content_tempfile(content)
@@ -73,27 +71,23 @@ class ActionModule(ActionBase):
             except Exception as err:
                 return dict(failed=True, msg="could not write content temp file: %s" % err)
 
-        ###############################################################################################
-        # FIXME: first_available_file needs to be reworked?
-        ###############################################################################################
         # if we have first_available_file in our vars
         # look up the files and use the first one we find as src
-        #elif 'first_available_file' in inject:
-        #    found = False
-        #    for fn in inject.get('first_available_file'):
-        #        fn_orig = fn
-        #        fnt = template.template(self.runner.basedir, fn, inject)
-        #        fnd = utils.path_dwim(self.runner.basedir, fnt)
-        #        if not os.path.exists(fnd) and '_original_file' in inject:
-        #            fnd = utils.path_dwim_relative(inject['_original_file'], 'files', fnt, self.runner.basedir, check=False)
-        #        if os.path.exists(fnd):
-        #            source = fnd
-        #            found = True
-        #            break
-        #    if not found:
-        #        results = dict(failed=True, msg="could not find src in first_available_file list")
-        #        return ReturnData(conn=conn, result=results)
-        ###############################################################################################
+        elif faf:
+            found = False
+            for fn in faf:
+                fn_orig = fn
+                fnt = self._templar.template(fn)
+                fnd = self._loader.path_dwim_relative(self._task._role._role_path, 'files', fnt)
+                of = task_vars.get('_original_file', None)
+                if not os.path.exists(fnd) and of is not None:
+                    fnd = self._loader.path_dwim_relative(of, 'files', fnt)
+                if os.path.exists(fnd):
+                    source = fnd
+                    found = True
+                    break
+            if not found:
+                return  dict(failed=True, msg="could not find src in first_available_file list")
         else:
             if self._task._role is not None:
                 source = self._loader.path_dwim_relative(self._task._role._role_path, 'files', source)

commit 0eb1c880ddac9547560040311739b5ca8291a642
Author: James Cammarata <jimi@sngx.net>
Date:   Sat Jun 27 15:18:18 2015 -0400

    Use itertools instead of set for tags, as the data may not hash well
    
    The tags field may contain bad data before it is post_validated, however
    some methods assumed it would be a simple list or string. Using itertools
    gets us around the problem of the data potentially not being hashable
    
    Fixes #9380

diff --git a/lib/ansible/playbook/base.py b/lib/ansible/playbook/base.py
index e33bedf3c8..4ff7f11c09 100644
--- a/lib/ansible/playbook/base.py
+++ b/lib/ansible/playbook/base.py
@@ -19,6 +19,7 @@
 from __future__ import (absolute_import, division, print_function)
 __metaclass__ = type
 
+import itertools
 import uuid
 
 from functools import partial
@@ -232,6 +233,10 @@ class Base:
         new_me._loader           = self._loader
         new_me._variable_manager = self._variable_manager
 
+        # if the ds value was set on the object, copy it to the new copy too
+        if hasattr(self, '_ds'):
+            new_me._ds = self._ds
+
         return new_me
 
     def post_validate(self, templar):
@@ -340,7 +345,8 @@ class Base:
         if not isinstance(new_value, list):
             new_value = [ new_value ]
 
-        return list(set(value + new_value))
+        #return list(set(value + new_value))
+        return [i for i,_ in itertools.groupby(value + new_value)]
 
     def __getstate__(self):
         return self.serialize()
diff --git a/lib/ansible/playbook/taggable.py b/lib/ansible/playbook/taggable.py
index 6ddd4b7439..d140f52a12 100644
--- a/lib/ansible/playbook/taggable.py
+++ b/lib/ansible/playbook/taggable.py
@@ -19,6 +19,7 @@
 from __future__ import (absolute_import, division, print_function)
 __metaclass__ = type
 
+import itertools
 from six import string_types
 
 from ansible.errors import AnsibleError
@@ -67,7 +68,7 @@ class Taggable:
                 else:
                     tags = set([tags])
             else:
-                tags = set(tags)
+                tags = [i for i,_ in itertools.groupby(tags)]
         else:
             # this makes intersection work for untagged
             tags = self.__class__.untagged

commit d8bf87b008d11573a120d9151aa23615d9667919
Author: Michael DeHaan <michael.dehaan@gmail.com>
Date:   Wed Apr 17 22:27:00 2013 -0400

    (A) include errors in inventory scripts should they occur.
    
    (B) allow registration with ignore_errors: True

diff --git a/lib/ansible/inventory/script.py b/lib/ansible/inventory/script.py
index 1692952426..a1ec467ce2 100644
--- a/lib/ansible/inventory/script.py
+++ b/lib/ansible/inventory/script.py
@@ -24,6 +24,7 @@ from ansible.inventory.host import Host
 from ansible.inventory.group import Group
 from ansible import utils
 from ansible import errors
+import sys
 
 class InventoryScript(object):
     ''' Host inventory parser for ansible using external inventory scripts. '''
@@ -41,9 +42,9 @@ class InventoryScript(object):
             raise errors.AnsibleError("problem running %s (%s)" % (' '.join(cmd), e))
         (stdout, stderr) = sp.communicate()
         self.data = stdout
-        self.groups = self._parse()
+        self.groups = self._parse(stderr)
 
-    def _parse(self):
+    def _parse(self, err):
 
         all_hosts = {}
         self.raw  = utils.parse_json(self.data)
@@ -52,7 +53,8 @@ class InventoryScript(object):
         group     = None
 
         if 'failed' in self.raw:
-            raise errors.AnsibleError("failed to parse executable inventory script results")
+            sys.stderr.write(err + "\n")
+            raise errors.AnsibleError("failed to parse executable inventory script results: %s" % self.raw)
 
         for (group_name, data) in self.raw.items():
 
diff --git a/lib/ansible/playbook/__init__.py b/lib/ansible/playbook/__init__.py
index 6759b51a43..2eb98fa05d 100644
--- a/lib/ansible/playbook/__init__.py
+++ b/lib/ansible/playbook/__init__.py
@@ -350,6 +350,14 @@ class PlayBook(object):
                     result['stdout_lines'] = result['stdout'].splitlines()
                 self.SETUP_CACHE[host][task.register] = result
 
+        # also have to register some failed, but ignored, tasks
+        if task.ignore_errors and task.register:
+            failed = results.get('failed', {})
+            for host, result in failed.iteritems():
+                if 'stdout' in result:
+                    result['stdout_lines'] = result['stdout'].splitlines()
+                self.SETUP_CACHE[host][task.register] = result
+
         # flag which notify handlers need to be run
         if len(task.notify) > 0:
             for host, results in results.get('contacted',{}).iteritems():

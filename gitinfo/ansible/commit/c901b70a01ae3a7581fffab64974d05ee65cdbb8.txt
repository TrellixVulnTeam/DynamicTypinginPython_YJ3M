commit c901b70a01ae3a7581fffab64974d05ee65cdbb8
Author: @ <@>
Date:   Mon Jun 13 11:40:13 2016 -0700

    Fixing compile time errors irt (, e => as e, print(), ocat now 0o not 0) exception handling for Python 3 (#3851)
    
    * Fixing compile time errors irt a) exception handling for Python 3 in util, also: b) problem octal usage (fixed) and c) print json_dump -> print(json_dump(xyz) ... et al
    
    * This code was not Python 2.4 compliant. Octal codes and exception handling is now working with Py 2.4, 2.6, & 3.5.
    
    * Fixing formating (or rather reverting an non 2.4 compatible change). Works in compile & runtime checking.
    
    * a) revert to use print sys.stderr not fail_json; b) fixed var name in exception
    
    * Python 3 compatible print (print >>sys.stderr will generate a TypeError - now uses sys.stderr.write instead).

diff --git a/lib/ansible/modules/utilities/logic/async_status.py b/lib/ansible/modules/utilities/logic/async_status.py
index b4c749760d..a35f3c0cc2 100644
--- a/lib/ansible/modules/utilities/logic/async_status.py
+++ b/lib/ansible/modules/utilities/logic/async_status.py
@@ -79,7 +79,7 @@ def main():
     data = file(log_path).read()
     try:
         data = json.loads(data)
-    except Exception, e:
+    except Exception:
         if data == '':
             # file not written yet?  That means it is running
             module.exit_json(results_file=log_path, ansible_job_id=jid, started=1, finished=0)
diff --git a/lib/ansible/modules/utilities/logic/async_wrapper.py b/lib/ansible/modules/utilities/logic/async_wrapper.py
index ce29d238ff..e0341aa801 100644
--- a/lib/ansible/modules/utilities/logic/async_wrapper.py
+++ b/lib/ansible/modules/utilities/logic/async_wrapper.py
@@ -46,14 +46,15 @@ def daemonize_self():
         if pid > 0:
             # exit first parent
             sys.exit(0)
-    except OSError, e:
-        print >>sys.stderr, "fork #1 failed: %d (%s)" % (e.errno, e.strerror)
+    except OSError:
+        e         = get_exception()
+        sys.stderr.write("fork #1 failed: %d (%s)\n" % (e.errno, e.strerror))
         sys.exit(1)
 
     # decouple from parent environment
     os.chdir("/")
     os.setsid()
-    os.umask(022)
+    os.umask(int('022', 8))
 
     # do second fork
     try:
@@ -61,8 +62,9 @@ def daemonize_self():
         if pid > 0:
             # print "Daemon PID %d" % pid
             sys.exit(0)
-    except OSError, e:
-        print >>sys.stderr, "fork #2 failed: %d (%s)" % (e.errno, e.strerror)
+    except OSError:
+        e = get_exception()
+        sys.stderr.write("fork #2 failed: %d (%s)\n" % (e.errno, e.strerror))
         sys.exit(1)
 
     dev_null = file('/dev/null','rw')
@@ -87,7 +89,8 @@ def _run_module(wrapped_cmd, jid, job_path):
         outdata = file(job_path).read()
         result = json.loads(outdata)
 
-    except (OSError, IOError), e:
+    except (OSError, IOError):
+        e = get_exception()
         result = {
             "failed": 1,
             "cmd" : wrapped_cmd,
@@ -113,10 +116,10 @@ def _run_module(wrapped_cmd, jid, job_path):
 if __name__ == '__main__':
 
     if len(sys.argv) < 3:
-        print json.dumps({
+        print(json.dumps({
             "failed" : True,
             "msg"    : "usage: async_wrapper <jid> <time_limit> <modulescript> <argsfile>.  Humans, do not call directly!"
-        })
+        }))
         sys.exit(1)
 
     jid = "%s.%d" % (sys.argv[1], os.getpid())
@@ -137,10 +140,10 @@ if __name__ == '__main__':
         try:
             os.makedirs(jobdir)
         except:
-            print json.dumps({
+            print(json.dumps({
                 "failed" : 1,
                 "msg" : "could not create: %s" % jobdir
-            })
+            }))
     # immediately exit this process, leaving an orphaned process
     # running which immediately forks a supervisory timing process
 
@@ -154,7 +157,7 @@ if __name__ == '__main__':
             # this probably could be done with some IPC later.  Modules should always read
             # the argsfile at the very first start of their execution anyway
             notice("Return async_wrapper task started.")
-            print json.dumps({ "started" : 1, "ansible_job_id" : jid, "results_file" : job_path })
+            print(json.dumps({ "started" : 1, "ansible_job_id" : jid, "results_file" : job_path }))
             sys.stdout.flush()
             time.sleep(1)
             sys.exit(0)
@@ -196,10 +199,11 @@ if __name__ == '__main__':
                 notice("Module complete (%s)"%os.getpid())
                 sys.exit(0)
 
-    except Exception, err:
-        notice("error: %s"%(err))
-        print json.dumps({
+    except Exception:
+        e = get_exception()
+        notice("error: %s"%(e))
+        print(json.dumps({
             "failed" : True,
-            "msg"    : "FATAL ERROR: %s" % str(err)
-        })
+            "msg"    : "FATAL ERROR: %s" % str(e)
+        }))
         sys.exit(1)

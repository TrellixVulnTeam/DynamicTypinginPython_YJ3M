commit c093ea5a28d69bfe1e2f02b9f10f0cfd1a7da492
Author: Nathaniel Case <this.is@nathanielca.se>
Date:   Fri Dec 21 10:30:33 2018 -0500

    Merge backup functionality across config action plugins (#50208)
    
    * Merge backup functionality across config action plugins
    
    * Port updated cli_config

diff --git a/lib/ansible/module_utils/network/common/backup.py b/lib/ansible/module_utils/network/common/backup.py
new file mode 100644
index 0000000000..6698daa50c
--- /dev/null
+++ b/lib/ansible/module_utils/network/common/backup.py
@@ -0,0 +1,50 @@
+# This code is part of Ansible, but is an independent component.
+# This particular file snippet, and this file snippet only, is BSD licensed.
+# Modules you write using this snippet, which is embedded dynamically by Ansible
+# still belong to the author of the module, and may assign their own license
+# to the complete work.
+#
+# (c) 2016 Red Hat Inc.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+#    * Redistributions of source code must retain the above copyright
+#      notice, this list of conditions and the following disclaimer.
+#    * Redistributions in binary form must reproduce the above copyright notice,
+#      this list of conditions and the following disclaimer in the documentation
+#      and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+import os
+import time
+import glob
+
+from ansible.module_utils._text import to_text
+
+
+def write_backup(module, host, contents, encoding='utf-8'):
+    cwd = module._loader.get_basedir()
+    if module._task._role is not None:
+        cwd = module._task._role._role_path
+
+    backup_path = os.path.join(cwd, 'backup')
+    if not os.path.exists(backup_path):
+        os.mkdir(backup_path)
+    for existing_backup in glob.glob('%s/%s_config.*' % (backup_path, host)):
+        os.remove(existing_backup)
+    tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
+    filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
+    open(filename, 'w').write(to_text(contents, encoding=encoding))
+
+    return filename
diff --git a/lib/ansible/plugins/action/aireos_config.py b/lib/ansible/plugins/action/aireos_config.py
index b94be5447a..860a44f2d4 100644
--- a/lib/ansible/plugins/action/aireos_config.py
+++ b/lib/ansible/plugins/action/aireos_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.aireos import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -48,9 +47,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -61,23 +58,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/aruba_config.py b/lib/ansible/plugins/action/aruba_config.py
index 7c9e1a77ae..137f43c8f8 100644
--- a/lib/ansible/plugins/action/aruba_config.py
+++ b/lib/ansible/plugins/action/aruba_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.aruba import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -48,9 +47,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -61,23 +58,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/asa_config.py b/lib/ansible/plugins/action/asa_config.py
index f878ba34d4..a2c972d3ac 100644
--- a/lib/ansible/plugins/action/asa_config.py
+++ b/lib/ansible/plugins/action/asa_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.asa import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -48,9 +47,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -61,23 +58,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/bigip_imish_config.py b/lib/ansible/plugins/action/bigip_imish_config.py
index eb02aa2256..e3d43f02c3 100644
--- a/lib/ansible/plugins/action/bigip_imish_config.py
+++ b/lib/ansible/plugins/action/bigip_imish_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
-from ansible.module_utils._text import to_text
 from ansible.plugins.action.bigip import ActionModule as _ActionModule
+from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 
 try:
@@ -55,9 +54,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -68,25 +65,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        fh = open(filename, 'w')
-        fh.write(contents)
-        fh.close()
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/ce_config.py b/lib/ansible/plugins/action/ce_config.py
index e422292e49..8881b74a0b 100644
--- a/lib/ansible/plugins/action/ce_config.py
+++ b/lib/ansible/plugins/action/ce_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.ce import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -48,9 +47,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -61,23 +58,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/cli_config.py b/lib/ansible/plugins/action/cli_config.py
index 433d52ad84..25f000ab8a 100644
--- a/lib/ansible/plugins/action/cli_config.py
+++ b/lib/ansible/plugins/action/cli_config.py
@@ -19,12 +19,11 @@
 from __future__ import (absolute_import, division, print_function)
 __metaclass__ = type
 
-import glob
 import os
 import re
-import time
 
 from ansible.plugins.action.normal import ActionModule as _ActionModule
+from ansible.module_utils.network.common.backup import write_backup
 
 
 PRIVATE_KEYS_RE = re.compile('__.+__')
@@ -41,9 +40,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -53,20 +50,3 @@ class ActionModule(_ActionModule):
                 del result[key]
 
         return result
-
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for existing_backup in glob.glob('%s/%s_config.*' % (backup_path, host)):
-            os.remove(existing_backup)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
diff --git a/lib/ansible/plugins/action/cnos_config.py b/lib/ansible/plugins/action/cnos_config.py
index 31699b3db0..cd693a56fe 100644
--- a/lib/ansible/plugins/action/cnos_config.py
+++ b/lib/ansible/plugins/action/cnos_config.py
@@ -17,11 +17,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.cnos import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -44,9 +43,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -57,23 +54,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/dellos10_config.py b/lib/ansible/plugins/action/dellos10_config.py
index b08f6d995d..1f96b0b715 100644
--- a/lib/ansible/plugins/action/dellos10_config.py
+++ b/lib/ansible/plugins/action/dellos10_config.py
@@ -23,11 +23,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.dellos10 import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -50,9 +49,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -63,23 +60,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/dellos6_config.py b/lib/ansible/plugins/action/dellos6_config.py
index 7e7854c429..ec4f480e2f 100644
--- a/lib/ansible/plugins/action/dellos6_config.py
+++ b/lib/ansible/plugins/action/dellos6_config.py
@@ -20,11 +20,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.dellos6 import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -47,9 +46,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -60,23 +57,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/dellos9_config.py b/lib/ansible/plugins/action/dellos9_config.py
index 85902e16e9..266bb01eec 100644
--- a/lib/ansible/plugins/action/dellos9_config.py
+++ b/lib/ansible/plugins/action/dellos9_config.py
@@ -23,11 +23,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.dellos9 import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -50,9 +49,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -63,23 +60,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/edgeos_config.py b/lib/ansible/plugins/action/edgeos_config.py
index 7c8334d166..52d2f82a41 100644
--- a/lib/ansible/plugins/action/edgeos_config.py
+++ b/lib/ansible/plugins/action/edgeos_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.normal import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 
 
@@ -50,9 +49,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -63,23 +60,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/enos_config.py b/lib/ansible/plugins/action/enos_config.py
index 2f74d97e04..669cd15a85 100644
--- a/lib/ansible/plugins/action/enos_config.py
+++ b/lib/ansible/plugins/action/enos_config.py
@@ -17,11 +17,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.enos import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -45,9 +44,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -58,23 +55,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/eos_config.py b/lib/ansible/plugins/action/eos_config.py
index 7ddeed1bb1..054cd7c874 100644
--- a/lib/ansible/plugins/action/eos_config.py
+++ b/lib/ansible/plugins/action/eos_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.eos import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -49,9 +48,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -62,23 +59,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/exos_config.py b/lib/ansible/plugins/action/exos_config.py
index 6d955dffc3..731b440052 100644
--- a/lib/ansible/plugins/action/exos_config.py
+++ b/lib/ansible/plugins/action/exos_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.normal import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -49,9 +48,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -62,23 +59,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/ios_config.py b/lib/ansible/plugins/action/ios_config.py
index bf47cef9bc..06a69bf9c3 100644
--- a/lib/ansible/plugins/action/ios_config.py
+++ b/lib/ansible/plugins/action/ios_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.ios import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -48,9 +47,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -61,23 +58,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/iosxr_config.py b/lib/ansible/plugins/action/iosxr_config.py
index d862e7fa33..fac3910eaa 100644
--- a/lib/ansible/plugins/action/iosxr_config.py
+++ b/lib/ansible/plugins/action/iosxr_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.iosxr import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -48,9 +47,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -61,23 +58,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/ironware_config.py b/lib/ansible/plugins/action/ironware_config.py
index c4cd817043..4d95205205 100644
--- a/lib/ansible/plugins/action/ironware_config.py
+++ b/lib/ansible/plugins/action/ironware_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.ironware import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -48,9 +47,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -61,23 +58,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/junos_config.py b/lib/ansible/plugins/action/junos_config.py
index d382714d1d..49eaf94595 100644
--- a/lib/ansible/plugins/action/junos_config.py
+++ b/lib/ansible/plugins/action/junos_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.junos import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text, to_bytes
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -48,9 +47,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'], encoding='latin-1')
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -61,24 +58,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        with open(filename, 'wb') as f:
-            f.write(to_bytes(to_text(contents, encoding='latin-1'), encoding='utf-8'))
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/netconf_config.py b/lib/ansible/plugins/action/netconf_config.py
index dbb4a53f0c..e8a91b02a2 100644
--- a/lib/ansible/plugins/action/netconf_config.py
+++ b/lib/ansible/plugins/action/netconf_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.netconf import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text, to_bytes
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 
 PRIVATE_KEYS_RE = re.compile('__.+__')
@@ -46,9 +45,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'], encoding='latin-1')
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -59,24 +56,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        with open(filename, 'wb') as f:
-            f.write(to_bytes(to_text(contents, encoding='latin-1'), encoding='utf-8'))
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/nos_config.py b/lib/ansible/plugins/action/nos_config.py
index db7801be20..87bc8da13a 100644
--- a/lib/ansible/plugins/action/nos_config.py
+++ b/lib/ansible/plugins/action/nos_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.normal import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -48,9 +47,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -61,23 +58,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/nxos_config.py b/lib/ansible/plugins/action/nxos_config.py
index a62b2a85b7..5503eae1f1 100644
--- a/lib/ansible/plugins/action/nxos_config.py
+++ b/lib/ansible/plugins/action/nxos_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.nxos import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -48,9 +47,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -61,23 +58,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/onyx_config.py b/lib/ansible/plugins/action/onyx_config.py
index e8c9b3564e..a59b3b4afb 100644
--- a/lib/ansible/plugins/action/onyx_config.py
+++ b/lib/ansible/plugins/action/onyx_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.normal import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 
 PRIVATE_KEYS_RE = re.compile('__.+__')
@@ -47,9 +46,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -60,23 +57,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/slxos_config.py b/lib/ansible/plugins/action/slxos_config.py
index db7801be20..87bc8da13a 100644
--- a/lib/ansible/plugins/action/slxos_config.py
+++ b/lib/ansible/plugins/action/slxos_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.normal import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -48,9 +47,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -61,23 +58,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/sros_config.py b/lib/ansible/plugins/action/sros_config.py
index 07ae645564..6667b8a21b 100644
--- a/lib/ansible/plugins/action/sros_config.py
+++ b/lib/ansible/plugins/action/sros_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.sros import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -48,9 +47,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -61,23 +58,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/voss_config.py b/lib/ansible/plugins/action/voss_config.py
index db7801be20..87bc8da13a 100644
--- a/lib/ansible/plugins/action/voss_config.py
+++ b/lib/ansible/plugins/action/voss_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.normal import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -48,9 +47,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -61,23 +58,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()
diff --git a/lib/ansible/plugins/action/vyos_config.py b/lib/ansible/plugins/action/vyos_config.py
index 618e26b93c..f67bc4ea1f 100644
--- a/lib/ansible/plugins/action/vyos_config.py
+++ b/lib/ansible/plugins/action/vyos_config.py
@@ -21,11 +21,10 @@ __metaclass__ = type
 
 import os
 import re
-import time
-import glob
 
 from ansible.plugins.action.vyos import ActionModule as _ActionModule
 from ansible.module_utils._text import to_text
+from ansible.module_utils.network.common.backup import write_backup
 from ansible.module_utils.six.moves.urllib.parse import urlsplit
 from ansible.utils.vars import merge_hash
 
@@ -49,9 +48,7 @@ class ActionModule(_ActionModule):
         if self._task.args.get('backup') and result.get('__backup__'):
             # User requested backup and no error occurred in module.
             # NOTE: If there is a parameter error, _backup key may not be in results.
-            filepath = self._write_backup(task_vars['inventory_hostname'],
-                                          result['__backup__'])
-
+            filepath = write_backup(self, task_vars['inventory_hostname'], result['__backup__'])
             result['backup_path'] = filepath
 
         # strip out any keys that have two leading and two trailing
@@ -62,23 +59,6 @@ class ActionModule(_ActionModule):
 
         return result
 
-    def _get_working_path(self):
-        cwd = self._loader.get_basedir()
-        if self._task._role is not None:
-            cwd = self._task._role._role_path
-        return cwd
-
-    def _write_backup(self, host, contents):
-        backup_path = self._get_working_path() + '/backup'
-        if not os.path.exists(backup_path):
-            os.mkdir(backup_path)
-        for fn in glob.glob('%s/%s*' % (backup_path, host)):
-            os.remove(fn)
-        tstamp = time.strftime("%Y-%m-%d@%H:%M:%S", time.localtime(time.time()))
-        filename = '%s/%s_config.%s' % (backup_path, host, tstamp)
-        open(filename, 'w').write(contents)
-        return filename
-
     def _handle_template(self):
         src = self._task.args.get('src')
         working_path = self._get_working_path()

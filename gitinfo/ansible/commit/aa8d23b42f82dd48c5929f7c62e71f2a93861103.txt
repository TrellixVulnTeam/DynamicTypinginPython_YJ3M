commit aa8d23b42f82dd48c5929f7c62e71f2a93861103
Author: Brian Coca <bcoca@users.noreply.github.com>
Date:   Tue Apr 16 15:50:52 2019 -0400

    ensure facts marked as unsafe (#55326)
    
    dont rely on plugin layer to do so

diff --git a/changelogs/fragments/ensure_facts_safe.yml b/changelogs/fragments/ensure_facts_safe.yml
new file mode 100644
index 0000000000..e014a0beb1
--- /dev/null
+++ b/changelogs/fragments/ensure_facts_safe.yml
@@ -0,0 +1,2 @@
+bugfixes:
+    - ensure facts are always unsafe objects and don't rely on plugin returns
diff --git a/lib/ansible/executor/task_executor.py b/lib/ansible/executor/task_executor.py
index 234c6deae3..40f0d62fc1 100644
--- a/lib/ansible/executor/task_executor.py
+++ b/lib/ansible/executor/task_executor.py
@@ -692,9 +692,10 @@ class TaskExecutor:
                     vars_copy.update(result['ansible_facts'])
                 else:
                     # TODO: cleaning of facts should eventually become part of taskresults instead of vars
-                    vars_copy.update(namespace_facts(result['ansible_facts']))
+                    af = wrap_var(result['ansible_facts'])
+                    vars_copy.update(namespace_facts(af))
                     if C.INJECT_FACTS_AS_VARS:
-                        vars_copy.update(clean_facts(result['ansible_facts']))
+                        vars_copy.update(clean_facts(af))
 
             # set the failed property if it was missing.
             if 'failed' not in result:
@@ -754,9 +755,10 @@ class TaskExecutor:
                 variables.update(result['ansible_facts'])
             else:
                 # TODO: cleaning of facts should eventually become part of taskresults instead of vars
-                variables.update(namespace_facts(result['ansible_facts']))
+                af = wrap_var(result['ansible_facts'])
+                variables.update(namespace_facts(af))
                 if C.INJECT_FACTS_AS_VARS:
-                    variables.update(clean_facts(result['ansible_facts']))
+                    variables.update(clean_facts(af))
 
         # save the notification target in the result, if it was specified, as
         # this task may be running in a loop in which case the notification

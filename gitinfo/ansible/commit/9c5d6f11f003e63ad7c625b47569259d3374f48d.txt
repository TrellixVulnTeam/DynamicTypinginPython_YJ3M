commit 9c5d6f11f003e63ad7c625b47569259d3374f48d
Author: Michael DeHaan <michael.dehaan@gmail.com>
Date:   Fri May 24 23:34:48 2013 -0400

    Fix tabs and spaces in OpenStack modules.

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 6ce59def68..acae744215 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -51,6 +51,7 @@ Modules added:
 * openstack: quantum_network
 * openstack: quantum_router
 * openstack: quantum_router_gateway
+* openstack: quantum_router_interface
 * openstack: quantum_subnet
 * airbrake_deployment - notify airbrake of new deployments
 
diff --git a/library/cloud/glance_image b/library/cloud/glance_image
old mode 100755
new mode 100644
index f3646abd7a..e6ec43befe
--- a/library/cloud/glance_image
+++ b/library/cloud/glance_image
@@ -152,48 +152,48 @@ def _get_glance_client(module, kwargs):
 def _glance_image_present(module, params, client):
     try:
         for image in client.images.list():
-	    if image.name == params['name']:
-		return image.id 
-	return None 
+            if image.name == params['name']:
+                return image.id 
+        return None 
     except Exception as e:
-  	module.fail_json(msg = "Error in fetching image list: %s" %e.message)
+        module.fail_json(msg = "Error in fetching image list: %s" %e.message)
 
 def _glance_image_create(module, params, client):
     kwargs = {
-		'name':             params.get('name'),
-  		'disk_format':      params.get('disk_format'),
-  		'container_format': params.get('container_format'),
-		'owner':            params.get('owner'),
-  		'is_public':        params.get('is_public'),
-  		'copy_from':        params.get('copy_from'),
+                'name':             params.get('name'),
+                'disk_format':      params.get('disk_format'),
+                'container_format': params.get('container_format'),
+                'owner':            params.get('owner'),
+                'is_public':        params.get('is_public'),
+                'copy_from':        params.get('copy_from'),
     }
-    try:	 	
+    try:                
         timeout = params.get('timeout')
-       	expire = time.time() + timeout
-	image = client.images.create(**kwargs)
-	if not params['copy_from']:
-	    image.update(data=open(params['file'], 'rb'))
-	while time.time() < expire:
-	    image = client.images.get(image.id)
-	    if image.status == 'active':
-		break
-	    time.sleep(5)
-    except Exception as e:		
-	module.fail_json(msg = "Error in creating image: %s" %e.message )		 
+        expire = time.time() + timeout
+        image = client.images.create(**kwargs)
+        if not params['copy_from']:
+            image.update(data=open(params['file'], 'rb'))
+        while time.time() < expire:
+            image = client.images.get(image.id)
+            if image.status == 'active':
+                break
+            time.sleep(5)
+    except Exception as e:              
+        module.fail_json(msg = "Error in creating image: %s" %e.message )                
     if image.status == 'active':
-	module.exit_json(changed = True, result = image.status, id=image.id)
+        module.exit_json(changed = True, result = image.status, id=image.id)
     else:
-	module.fail_json(msg = " The module timed out, please check manually " + image.status) 
+        module.fail_json(msg = " The module timed out, please check manually " + image.status) 
 
 def _glance_delete_image(module, params, client):
-    try:		
+    try:                
         for image in client.images.list():
-	    if image.name == params['name']:
-		client.images.delete(image)
+            if image.name == params['name']:
+                client.images.delete(image)
     except Exception as e:
-	module.fail_json(msg = "Error in deleting image: %s" %e.message)
+        module.fail_json(msg = "Error in deleting image: %s" %e.message)
     module.exit_json(changed = True, result = "Deleted")
-	
+        
 def main():
     
     module = AnsibleModule(
@@ -211,28 +211,28 @@ def main():
         min_ram          = dict(default=None),
         is_public        = dict(default=True),
         copy_from        = dict(default= None),
-	timeout          = dict(default=180), 
-	file             = dict(default=None), 
-        state	         = dict(default='present', choices=['absent', 'present'])
+        timeout          = dict(default=180), 
+        file             = dict(default=None), 
+        state            = dict(default='present', choices=['absent', 'present'])
         ),
-	    mutually_exclusive = [['file','copy_from']],
+            mutually_exclusive = [['file','copy_from']],
     )
     if module.params['state'] == 'present':
-	if not module.params['file'] and not module.params['copy_from']:
- 	    module.fail_json(msg = "Either file or copy_from variable should be set to create the image")
-	client = _get_glance_client(module, module.params)
+        if not module.params['file'] and not module.params['copy_from']:
+            module.fail_json(msg = "Either file or copy_from variable should be set to create the image")
+        client = _get_glance_client(module, module.params)
         id =  _glance_image_present(module, module.params, client)
-	if not id:
-	    _glance_image_create(module, module.params, client)
-	module.exit_json(changed = False, id = id, result = "success")
+        if not id:
+            _glance_image_create(module, module.params, client)
+        module.exit_json(changed = False, id = id, result = "success")
 
     if module.params['state'] == 'absent':
-	client = _get_glance_client(module, module.params)
+        client = _get_glance_client(module, module.params)
         id =  _glance_image_present(module, module.params, client)
-	if not id:	
-	    module.exit_json(changed = False, result = "Success")
-	else:
-	    _glance_delete_image(module, module.params, client)
+        if not id:      
+            module.exit_json(changed = False, result = "Success")
+        else:
+            _glance_delete_image(module, module.params, client)
 
 # this is magic, see lib/ansible/module.params['common.py
 #<<INCLUDE_ANSIBLE_MODULE_COMMON>>
diff --git a/library/cloud/nova_compute b/library/cloud/nova_compute
old mode 100755
new mode 100644
index aaa7cfd5f7..48aeceed0f
--- a/library/cloud/nova_compute
+++ b/library/cloud/nova_compute
@@ -126,117 +126,117 @@ requirements: ["novaclient"]
 def _delete_server(module, nova):
     name = None
     try:
-	server = nova.servers.list({'name': module.params['name']}).pop()
-	nova.servers.delete(server)
+        server = nova.servers.list({'name': module.params['name']}).pop()
+        nova.servers.delete(server)
     except Exception as e:
-	module.fail_json( msg = "Error in deleting vm: %s" % e.message)
+        module.fail_json( msg = "Error in deleting vm: %s" % e.message)
     if module.params['wait'] == 'no':
-	module.exit_json(changed = True, result = "deleted")
+        module.exit_json(changed = True, result = "deleted")
     expire = time.time() + module.params['wait_for']
     while time.time() < expire:
-	name = nova.servers.list({'name': module.params['name']})
-	if not name:
-	    module.exit_json(changed = True, result = "deleted")
-	time.sleep(5)
+        name = nova.servers.list({'name': module.params['name']})
+        if not name:
+            module.exit_json(changed = True, result = "deleted")
+        time.sleep(5)
     module.fail_json(msg = "Timed out waiting for server to get deleted, please check manually")
 
 
 def _create_server(module, nova):
     bootargs = [module.params['name'], module.params['image_id'], module.params['flavor_id']]
     bootkwargs = {
-		'nics' : module.params['nics'],
-		'meta' : module.params['meta'],
-		'key_name': module.params['key_name'],
-		'security_groups': module.params['security_groups'].split(','),
+                'nics' : module.params['nics'],
+                'meta' : module.params['meta'],
+                'key_name': module.params['key_name'],
+                'security_groups': module.params['security_groups'].split(','),
     }
     if not module.params['key_name']:
-	del bootkwargs['key_name']
+        del bootkwargs['key_name']
     try:
-	server = nova.servers.create(*bootargs, **bootkwargs )
-    	server = nova.servers.get(server.id)
+        server = nova.servers.create(*bootargs, **bootkwargs )
+        server = nova.servers.get(server.id)
     except Exception as e:
-	    module.fail_json( msg = "Error in creating instance: %s " % e.message)
+            module.fail_json( msg = "Error in creating instance: %s " % e.message)
     if module.params['wait'] == 'yes':
-	expire = time.time() + module.params['wait_for']
-	while time.time() < expire:
-	    try:
+        expire = time.time() + module.params['wait_for']
+        while time.time() < expire:
+            try:
                 server = nova.servers.get(server.id)
             except Exception as e:
                     module.fail_json( msg = "Error in getting info from instance: %s " % e.message)
-	    if server.status == 'ACTIVE':
-		private = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if x['OS-EXT-IPS:type'] == 'fixed']
-        	public  = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if x['OS-EXT-IPS:type'] == 'floating']
-		module.exit_json(changed = True, id = server.id, private_ip=''.join(private), public_ip=''.join(public), status = server.status, info = server._info)
-	    if server.status == 'ERROR':
-		module.fail_json(msg = "Error in creating the server, please check logs")
-	    time.sleep(2)
-		
-	module.fail_json(msg = "Timeout waiting for the server to come up.. Please check manually")
+            if server.status == 'ACTIVE':
+                private = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if x['OS-EXT-IPS:type'] == 'fixed']
+                public  = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if x['OS-EXT-IPS:type'] == 'floating']
+                module.exit_json(changed = True, id = server.id, private_ip=''.join(private), public_ip=''.join(public), status = server.status, info = server._info)
+            if server.status == 'ERROR':
+                module.fail_json(msg = "Error in creating the server, please check logs")
+            time.sleep(2)
+                
+        module.fail_json(msg = "Timeout waiting for the server to come up.. Please check manually")
     if server.status == 'ERROR':
-	    module.fail_json(msg = "Error in creating the server.. Please check manually")
+            module.fail_json(msg = "Error in creating the server.. Please check manually")
     private = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if x['OS-EXT-IPS:type'] == 'fixed']
     public  = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if x['OS-EXT-IPS:type'] == 'floating']
     module.exit_json(changed = True, id = info['id'], private_ip=''.join(private), public_ip=''.join(public), status = server.status, info = server._info)
 
-	 
+         
 def _get_server_state(module, nova):
     server = None
     try:
-	servers = nova.servers.list({'name': module.params['name']})
-	if servers:
-	    server = servers.pop()
+        servers = nova.servers.list({'name': module.params['name']})
+        if servers:
+            server = servers.pop()
     except Exception as e:
-	module.fail_json(msg = "Error in getting the server list: %s" % e.message)
+        module.fail_json(msg = "Error in getting the server list: %s" % e.message)
     if server and module.params['state'] == 'present':
-	if server.status != 'ACTIVE':
-	    module.fail_json( msg="The VM is available but not Active. state:" + server.status)
-	private = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if x['OS-EXT-IPS:type'] == 'fixed']
+        if server.status != 'ACTIVE':
+            module.fail_json( msg="The VM is available but not Active. state:" + server.status)
+        private = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if x['OS-EXT-IPS:type'] == 'fixed']
         public  = [ x['addr'] for x in getattr(server, 'addresses').itervalues().next() if x['OS-EXT-IPS:type'] == 'floating']
-	module.exit_json(changed = False, id = server.id, public_ip = ''.join(public), private_ip = ''.join(private), info = server._info)	
+        module.exit_json(changed = False, id = server.id, public_ip = ''.join(public), private_ip = ''.join(private), info = server._info)      
     if server and module.params['state'] == 'absent':
-	return True
+        return True
     if module.params['state'] == 'absent':
-	module.exit_json(changed = False, result = "not present")
+        module.exit_json(changed = False, result = "not present")
     return True
-		
+                
 
-	
+        
 def main():
     module = AnsibleModule(
-        argument_spec        		= dict(
-        login_username         		= dict(default='admin'),
-        login_password         		= dict(required=True),
-        login_tenant_name      		= dict(required='True'),
-        auth_url         		= dict(default='http://127.0.0.1:35357/v2.0/'),
-        region_name      		= dict(default=None),
-        name             		= dict(required=True),
-	image_id		        = dict(required=True), 
-        flavor_id			= dict(default=1),
-        key_name			= dict(default=None),
-        security_groups			= dict(default='default'),
-        nics				= dict(default=None),
-        meta				= dict(default=None),
-	wait				= dict(default='yes', choices=['yes', 'no']),
-	wait_for			= dict(default=120),
-	state	         		= dict(default='present', choices=['absent', 'present'])
+        argument_spec                   = dict(
+        login_username                  = dict(default='admin'),
+        login_password                  = dict(required=True),
+        login_tenant_name               = dict(required='True'),
+        auth_url                        = dict(default='http://127.0.0.1:35357/v2.0/'),
+        region_name                     = dict(default=None),
+        name                            = dict(required=True),
+        image_id                        = dict(required=True), 
+        flavor_id                       = dict(default=1),
+        key_name                        = dict(default=None),
+        security_groups                 = dict(default='default'),
+        nics                            = dict(default=None),
+        meta                            = dict(default=None),
+        wait                            = dict(default='yes', choices=['yes', 'no']),
+        wait_for                        = dict(default=120),
+        state                           = dict(default='present', choices=['absent', 'present'])
         ),
     )
-	
+        
     try:
-	nova = nova_client.Client( module.params['login_username'], 
-					   module.params['login_password'], 
-				           module.params['login_tenant_name'], 
-					   module.params['auth_url'], 
-					   service_type='compute')
+        nova = nova_client.Client( module.params['login_username'], 
+                                           module.params['login_password'], 
+                                           module.params['login_tenant_name'], 
+                                           module.params['auth_url'], 
+                                           service_type='compute')
     except Exception as e:
-	module.fail_json( msg = "Error in authenticating to nova: %s" % e.message)
+        module.fail_json( msg = "Error in authenticating to nova: %s" % e.message)
     if module.params['state'] == 'present':
-	_get_server_state(module, nova)
-	_create_server(module, nova)
+        _get_server_state(module, nova)
+        _create_server(module, nova)
     if module.params['state'] == 'absent':
-	_get_server_state(module, nova)
-	_delete_server(module, nova)
-		
+        _get_server_state(module, nova)
+        _delete_server(module, nova)
+                
 # this is magic, see lib/ansible/module.params['common.py
 #<<INCLUDE_ANSIBLE_MODULE_COMMON>>
 main()
diff --git a/library/cloud/nova_keypair b/library/cloud/nova_keypair
old mode 100755
new mode 100644
index bd6baaa3e8..5660c3ddc4
--- a/library/cloud/nova_keypair
+++ b/library/cloud/nova_keypair
@@ -81,42 +81,42 @@ requirements: ["novaclient"]
 
 def main():
     module = AnsibleModule(
-        argument_spec        		= dict(
-        login_username         		= dict(default='admin'),
-        login_password         		= dict(required=True),
-        login_tenant_name      		= dict(required='True'),
-        auth_url         		= dict(default='http://127.0.0.1:35357/v2.0/'),
-        region_name      		= dict(default=None),
-        name             		= dict(required=True),
-	public_key			= dict(default=None),
-	state	         		= dict(default='present', choices=['absent', 'present'])
+        argument_spec                   = dict(
+        login_username                  = dict(default='admin'),
+        login_password                  = dict(required=True),
+        login_tenant_name               = dict(required='True'),
+        auth_url                        = dict(default='http://127.0.0.1:35357/v2.0/'),
+        region_name                     = dict(default=None),
+        name                            = dict(required=True),
+        public_key                      = dict(default=None),
+        state                           = dict(default='present', choices=['absent', 'present'])
         ),
     )
-	
+        
     try:
-	nova = client.Client(module.params['login_username'], module.params['login_password'], 
-				     module.params['login_tenant_name'], module.params['auth_url'], service_type='compute')
+        nova = client.Client(module.params['login_username'], module.params['login_password'], 
+                                     module.params['login_tenant_name'], module.params['auth_url'], service_type='compute')
     except Exception as e:
-	module.fail_json( msg = " Error in authenticating to nova: %s" % e.message)
+        module.fail_json( msg = " Error in authenticating to nova: %s" % e.message)
     if module.params['state'] == 'present':
-	for key in nova.keypairs.list():
-	    if key.name == module.params['name']:
-		module.exit_json(changed = False, result = "Key present")
-	try:
-	    key = nova.keypairs.create(module.params['name'], module.params['public_key'])
-	except Exception as e:
-	    module.exit_json(msg = "Error in creating the keypair: %s" % e.message)
-	if not module.params['public_key']:
-	    module.exit_json(changed = True, key = key.private_key)
-	module.exit_json(changed = True, key = None)
+        for key in nova.keypairs.list():
+            if key.name == module.params['name']:
+                module.exit_json(changed = False, result = "Key present")
+        try:
+            key = nova.keypairs.create(module.params['name'], module.params['public_key'])
+        except Exception as e:
+            module.exit_json(msg = "Error in creating the keypair: %s" % e.message)
+        if not module.params['public_key']:
+            module.exit_json(changed = True, key = key.private_key)
+        module.exit_json(changed = True, key = None)
     if module.params['state'] == 'absent':
-	for key in nova.keypairs.list():
-	    if key.name == module.params['name']:
-		try:
-		    nova.keypairs.delete(module.params['name'])
-		except Exception as e:
-		    module.fail_json(msg = "The keypair deletion has failed: %s" % e.message)
-	        module.exit_json( changed = True, result = "deleted")
+        for key in nova.keypairs.list():
+            if key.name == module.params['name']:
+                try:
+                    nova.keypairs.delete(module.params['name'])
+                except Exception as e:
+                    module.fail_json(msg = "The keypair deletion has failed: %s" % e.message)
+                module.exit_json( changed = True, result = "deleted")
         module.exit_json(changed = False, result = "not present")
 
 # this is magic, see lib/ansible/module.params['common.py
diff --git a/library/cloud/quantum_floating_ip b/library/cloud/quantum_floating_ip
old mode 100755
new mode 100644
index bf613877e1..20f14d4100
--- a/library/cloud/quantum_floating_ip
+++ b/library/cloud/quantum_floating_ip
@@ -110,24 +110,24 @@ def _get_quantum_client(module, kwargs):
         quantum =  client.Client('2.0', **kwargs)
     except Exception as e:
         module.fail_json(msg = "Error in connecting to quantum: %s " % e.message)
-    return quantum	 
+    return quantum       
 
 def _get_server_state(module, nova):
     server_info = None
     server = None
     try:
         for server in nova.servers.list():
-	    if server:
-		info = server._info
-		if info['name'] == module.params['instance_name']:
-		    if info['status'] != 'ACTIVE' and module.params['state'] == 'present':
-			module.fail_json( msg="The VM is available but not Active. state:" + info['status'])
-		    server_info = info
-		    break
+            if server:
+                info = server._info
+                if info['name'] == module.params['instance_name']:
+                    if info['status'] != 'ACTIVE' and module.params['state'] == 'present':
+                        module.fail_json( msg="The VM is available but not Active. state:" + info['status'])
+                    server_info = info
+                    break
     except Exception as e:
-	module.fail_json(msg = "Error in getting the server list: %s" % e.message)
-    return server_info, server		
-				 
+        module.fail_json(msg = "Error in getting the server list: %s" % e.message)
+    return server_info, server          
+                                 
 def _get_port_info(quantum, module, instance_id):
     kwargs = {
             'device_id': instance_id,
@@ -139,7 +139,7 @@ def _get_port_info(quantum, module, instance_id):
     if not ports['ports']:
         return None, None
     return ports['ports'][0]['fixed_ips'][0]['ip_address'], ports['ports'][0]['id']
-	
+        
 def _get_floating_ip(module, quantum, fixed_ip_address):
     kwargs = {
             'fixed_ip_address': fixed_ip_address
@@ -154,13 +154,13 @@ def _get_floating_ip(module, quantum, fixed_ip_address):
 
 def _create_floating_ip(quantum, module, port_id, net_id):
     kwargs = {
-	    'port_id': port_id,
-	    'floating_network_id': net_id
+            'port_id': port_id,
+            'floating_network_id': net_id
     }
     try:
-	result = quantum.create_floatingip({'floatingip': kwargs})
+        result = quantum.create_floatingip({'floatingip': kwargs})
     except Exception as e:
-	module.fail_json( msg = "There was an error in updating the floating ip address: %s" % e.message)
+        module.fail_json( msg = "There was an error in updating the floating ip address: %s" % e.message)
     module.exit_json( changed = True, result = result, public_ip=result['floatingip']['floating_ip_address'] )
 
 def _get_net_id(quantum, module):
@@ -189,43 +189,43 @@ def _update_floating_ip(quantum, module, port_id, floating_ip_id):
 def main():
     
     module = AnsibleModule(
-        argument_spec        		= dict(
-        login_username         		= dict(default='admin'),
-        login_password         		= dict(required=True),
-        login_tenant_name      		= dict(required='True'),
-        auth_url         		= dict(default='http://127.0.0.1:35357/v2.0/'),
-        region_name      		= dict(default=None),
-        network_name           		= dict(required=True),
-	instance_name		        = dict(required=True), 
-	state	         		= dict(default='present', choices=['absent', 'present'])
+        argument_spec                   = dict(
+        login_username                  = dict(default='admin'),
+        login_password                  = dict(required=True),
+        login_tenant_name               = dict(required='True'),
+        auth_url                        = dict(default='http://127.0.0.1:35357/v2.0/'),
+        region_name                     = dict(default=None),
+        network_name                    = dict(required=True),
+        instance_name                   = dict(required=True), 
+        state                           = dict(default='present', choices=['absent', 'present'])
         ),
     )
-	
+        
     try:
-	nova = nova_client.Client(module.params['login_username'], module.params['login_password'], 
-				     module.params['login_tenant_name'], module.params['auth_url'], service_type='compute')
-	quantum = _get_quantum_client(module, module.params)
+        nova = nova_client.Client(module.params['login_username'], module.params['login_password'], 
+                                     module.params['login_tenant_name'], module.params['auth_url'], service_type='compute')
+        quantum = _get_quantum_client(module, module.params)
     except Exception as e:
-	module.fail_json( msg = " Error in authenticating to nova: %s" % e.message)
-	
+        module.fail_json( msg = " Error in authenticating to nova: %s" % e.message)
+        
     server_info, server_obj = _get_server_state(module, nova)
     if not server_info:
-	module.fail_json( msg = " The instance name provided cannot be found")
+        module.fail_json( msg = " The instance name provided cannot be found")
     fixed_ip, port_id = _get_port_info(quantum, module, server_info['id'])
     if not port_id:
-	module.fail_json(msg = "Cannot find a port for this instance, maybe fixed ip is not assigned")
+        module.fail_json(msg = "Cannot find a port for this instance, maybe fixed ip is not assigned")
     floating_id, floating_ip =  _get_floating_ip(module, quantum, fixed_ip)
     if module.params['state'] == 'present':
-	if floating_ip:
-	    module.exit_json(changed = False, public_ip=floating_ip)
-	net_id = _get_net_id(quantum, module)	
+        if floating_ip:
+            module.exit_json(changed = False, public_ip=floating_ip)
+        net_id = _get_net_id(quantum, module)   
         if not net_id:
-	    module.fail_json(msg = "cannot find the network specified, please check")
-	_create_floating_ip(quantum, module, port_id, net_id)
+            module.fail_json(msg = "cannot find the network specified, please check")
+        _create_floating_ip(quantum, module, port_id, net_id)
 
     if module.params['state'] == 'absent':
-	if floating_ip:
-	    _update_floating_ip(quantum, module, None, floating_id)
+        if floating_ip:
+            _update_floating_ip(quantum, module, None, floating_id)
         module.exit_json(changed=False)
 # this is magic, see lib/ansible/module.params['common.py
 #<<INCLUDE_ANSIBLE_MODULE_COMMON>>
diff --git a/library/cloud/quantum_floating_ip_associate b/library/cloud/quantum_floating_ip_associate
old mode 100755
new mode 100644
index b46037ed82..3ed36c2ca2
--- a/library/cloud/quantum_floating_ip_associate
+++ b/library/cloud/quantum_floating_ip_associate
@@ -110,24 +110,24 @@ def _get_quantum_client(module, kwargs):
         quantum =  client.Client('2.0', **kwargs)
     except Exception as e:
         module.fail_json(msg = "Error in connecting to quantum: %s " % e.message)
-    return quantum	 
+    return quantum       
 
 def _get_server_state(module, nova):
     server_info = None
     server = None
     try:
-	for server in nova.servers.list():
-	    if server:
-	        info = server._info
-		    if info['name'] == module.params['instance_name']:
-			if info['status'] != 'ACTIVE' and module.params['state'] == 'present':
-			    module.fail_json( msg="The VM is available but not Active. state:" + info['status'])
-			server_info = info
-			break
+        for server in nova.servers.list():
+            if server:
+                info = server._info
+                    if info['name'] == module.params['instance_name']:
+                        if info['status'] != 'ACTIVE' and module.params['state'] == 'present':
+                            module.fail_json( msg="The VM is available but not Active. state:" + info['status'])
+                        server_info = info
+                        break
     except Exception as e:
-	    module.fail_json(msg = "Error in getting the server list: %s" % e.message)
-    return server_info, server		
-				 
+            module.fail_json(msg = "Error in getting the server list: %s" % e.message)
+    return server_info, server          
+                                 
 def _get_port_id(quantum, module, instance_id):
     kwargs = {
             device_id': instance_id,
@@ -139,72 +139,72 @@ def _get_port_id(quantum, module, instance_id):
     if not ports['ports']:
             return None
     return ports['ports'][0]['id']
-	
+        
 def _get_floating_ip_id(module, quantum):
     kwargs = {
-	    'floating_ip_address': module.params['ip_address']
+            'floating_ip_address': module.params['ip_address']
     }
     try:
-	ips = quantum.list_floatingips(**kwargs)
+        ips = quantum.list_floatingips(**kwargs)
     except Exception as e:
-	module.fail_json(msg = "error in fetching the floatingips's %s" % e.message)
+        module.fail_json(msg = "error in fetching the floatingips's %s" % e.message)
     if not ips['floatingips']:
-	module.fail_json(msg = "Could find the ip specified in parameter, Please check")
+        module.fail_json(msg = "Could find the ip specified in parameter, Please check")
     ip = ips['floatingips'][0]['id']
     if not ips['floatingips'][0]['port_id']:
-	state =  "detached"
+        state =  "detached"
     else:
-	state = "attached"
+        state = "attached"
     return state, ip
 
 def _update_floating_ip(quantum, module, port_id, floating_ip_id):
     kwargs = {
-	    'port_id': port_id
+            'port_id': port_id
     }
     try:
-	result = quantum.update_floatingip(floating_ip_id, {'floatingip': kwargs})
+        result = quantum.update_floatingip(floating_ip_id, {'floatingip': kwargs})
     except Exception as e:
-	module.fail_json( msg = "There was an error in updating the floating ip address: %s" % e.message)
+        module.fail_json( msg = "There was an error in updating the floating ip address: %s" % e.message)
     module.exit_json( changed = True, result = result, public_ip=module.params['ip_address'])
 
 def main():
     
     module = AnsibleModule(
-        argument_spec        		= dict(
-        login_username         		= dict(default='admin'),
-        login_password         		= dict(required=True),
-        login_tenant_name      		= dict(required='True'),
-        auth_url         		= dict(default='http://127.0.0.1:35357/v2.0/'),
-        region_name      		= dict(default=None),
-        ip_address             		= dict(required=True),
-	instance_name		        = dict(required=True), 
-	state	         		= dict(default='present', choices=['absent', 'present'])
+        argument_spec                   = dict(
+        login_username                  = dict(default='admin'),
+        login_password                  = dict(required=True),
+        login_tenant_name               = dict(required='True'),
+        auth_url                        = dict(default='http://127.0.0.1:35357/v2.0/'),
+        region_name                     = dict(default=None),
+        ip_address                      = dict(required=True),
+        instance_name                   = dict(required=True), 
+        state                           = dict(default='present', choices=['absent', 'present'])
         ),
     )
-	
+        
     try:
-	nova = nova_client.Client(module.params['login_username'], module.params['login_password'],                                              			     module.params['login_tenant_name'], module.params['auth_url'], service_type='compute')
+        nova = nova_client.Client(module.params['login_username'], module.params['login_password'],                                                                          module.params['login_tenant_name'], module.params['auth_url'], service_type='compute')
     except Exception as e:
-	module.fail_json( msg = " Error in authenticating to nova: %s" % e.message)
+        module.fail_json( msg = " Error in authenticating to nova: %s" % e.message)
     quantum = _get_quantum_client(module, module.params)
-    state, floating_ip_id = _get_floating_ip_id(module, quantum)	
+    state, floating_ip_id = _get_floating_ip_id(module, quantum)        
     if module.params['state'] == 'present':
-	if state == 'attached':
-	    module.exit_json(changed = False, result = 'attached', public_ip=module.params['ip_address'])
-	server_info, server_obj = _get_server_state(module, nova)
-	if not server_info:
-	    module.fail_json( msg = " The instance name provided cannot be found")
-	port_id = _get_port_id(quantum, module, server_info['id'])
-	if not port_id:
-	    module.fail_json(msg = "Cannot find a port for this instance, maybe fixed ip is not assigned")
-	_update_floating_ip(quantum, module, port_id, floating_ip_id)
+        if state == 'attached':
+            module.exit_json(changed = False, result = 'attached', public_ip=module.params['ip_address'])
+        server_info, server_obj = _get_server_state(module, nova)
+        if not server_info:
+            module.fail_json( msg = " The instance name provided cannot be found")
+        port_id = _get_port_id(quantum, module, server_info['id'])
+        if not port_id:
+            module.fail_json(msg = "Cannot find a port for this instance, maybe fixed ip is not assigned")
+        _update_floating_ip(quantum, module, port_id, floating_ip_id)
 
     if module.params['state'] == 'absent':
-	if state == 'detached':
-	    module.exit_json(changed = False, result = 'detached')
-	if state == 'attached':
-	    _update_floating_ip(quantum, module, None, floating_ip_id)
-	module.exit_json( changed = True, result = "detached")
+        if state == 'detached':
+            module.exit_json(changed = False, result = 'detached')
+        if state == 'attached':
+            _update_floating_ip(quantum, module, None, floating_ip_id)
+        module.exit_json( changed = True, result = "detached")
 # this is magic, see lib/ansible/module.params['common.py
 #<<INCLUDE_ANSIBLE_MODULE_COMMON>>
 main()
diff --git a/library/cloud/quantum_network b/library/cloud/quantum_network
old mode 100755
new mode 100644
index 690c425781..4c51d6c623
--- a/library/cloud/quantum_network
+++ b/library/cloud/quantum_network
@@ -136,10 +136,10 @@ def _get_quantum_client(module, kwargs):
     endpoint = _get_endpoint(module, _ksclient)
     kwargs = {
             'token': token,
-	    'endpoint_url': endpoint
+            'endpoint_url': endpoint
     }
     try:
-    	quantum =  client.Client('2.0', **kwargs)
+        quantum =  client.Client('2.0', **kwargs)
     except Exception as e:
         module.fail_json(msg = " Error in connecting to quantum: %s " %e.message)
     return quantum
@@ -147,106 +147,106 @@ def _get_quantum_client(module, kwargs):
 def _set_tenant_id(module):
     global _os_tenant_id
     if not module.params['tenant_name']:
-	tenant_name = module.params['login_tenant_name']
+        tenant_name = module.params['login_tenant_name']
     else:
-	tenant_name = module.params['tenant_name']
-	
+        tenant_name = module.params['tenant_name']
+        
     for tenant in _os_keystone.tenants.list():
         if tenant.name == tenant_name:
             _os_tenant_id = tenant.id
             break;
     if not _os_tenant_id:
-	module.fail_json(msg = "The tenant id cannot be found, please check the paramters")
+        module.fail_json(msg = "The tenant id cannot be found, please check the paramters")
 
 
 def _get_net_id(quantum, module):
     kwargs = {
-	    'tenant_id': _os_tenant_id,
-	    'name': module.params['name'],
+            'tenant_id': _os_tenant_id,
+            'name': module.params['name'],
     }
     try:
-	networks = quantum.list_networks(**kwargs)
+        networks = quantum.list_networks(**kwargs)
     except Exception as e:
-	module.fail_json("Error in listing quantum networks: %s" % e.message)
-    if not networks['networks']:	
-	return None
+        module.fail_json("Error in listing quantum networks: %s" % e.message)
+    if not networks['networks']:        
+        return None
     return networks['networks'][0]['id']
 
 def _create_network(module, quantum):
     quantum.format = 'json'
     network = {
-	    'name': 	module.params.get('name'),
-	    'tenant_id': 	_os_tenant_id,
-	    'provider:network_type': module.params.get('provider_network_type'),
-	    'provider:physical_network': module.params.get('provider_physical_network'),
+            'name':     module.params.get('name'),
+            'tenant_id':        _os_tenant_id,
+            'provider:network_type': module.params.get('provider_network_type'),
+            'provider:physical_network': module.params.get('provider_physical_network'),
             'provider:segmentation_id': module.params.get('provider_segmentation_id'),
-	    'router:external': module.params.get('router_external'),
-	    'shared': module.params.get('shared'),
-	    'admin_state_up': module.params.get('admin_state_up'),
+            'router:external': module.params.get('router_external'),
+            'shared': module.params.get('shared'),
+            'admin_state_up': module.params.get('admin_state_up'),
     }
     if module.params['provider_network_type'] == 'local':
-	network.pop('provider:physical_network', None)
-	network.pop('provider:segmentation_id', None)
+        network.pop('provider:physical_network', None)
+        network.pop('provider:segmentation_id', None)
     if module.params['provider_network_type'] == 'flat':
-	network.pop('provider:segmentation_id', None)
+        network.pop('provider:segmentation_id', None)
     if module.params['provider_network_type'] == 'gre':
-	network.pop('provider:physical_network', None)
-		
+        network.pop('provider:physical_network', None)
+                
     try:
-	net = quantum.create_network({'network':network})
+        net = quantum.create_network({'network':network})
     except Exception as e:
-	module.fail_json(msg = "Error in creating network: %s" % e.message)
+        module.fail_json(msg = "Error in creating network: %s" % e.message)
     return net['network']['id']
-		
+                
 def _delete_network(module, net_id, quantum):
     try:
-	id = quantum.delete_network(net_id)
+        id = quantum.delete_network(net_id)
     except Exception as e: 
-	module.fail_json(msg = "Error in deleting the network: %s" % e.message)
+        module.fail_json(msg = "Error in deleting the network: %s" % e.message)
     return True
 
 def main():
     
     module = AnsibleModule(
-        argument_spec        		= dict(
-        login_username         		= dict(default='admin'),
-        login_password         		= dict(required=True),
-        login_tenant_name      		= dict(required='True'),
-        auth_url         		= dict(default='http://127.0.0.1:35357/v2.0/'),
-        region_name      		= dict(default=None),
-        name             		= dict(required=True),
+        argument_spec                   = dict(
+        login_username                  = dict(default='admin'),
+        login_password                  = dict(required=True),
+        login_tenant_name               = dict(required='True'),
+        auth_url                        = dict(default='http://127.0.0.1:35357/v2.0/'),
+        region_name                     = dict(default=None),
+        name                            = dict(required=True),
         tenant_name                     = dict(default=None),
-	provider_network_type           = dict(default='local', choices=['local', 'vlan', 'flat', 'gre']), 
-	provider_physical_network       = dict(default=None), 
-	provider_segmentation_id        = dict(default=None), 
-        router_external			= dict(default='false', choices=BOOLEANS),
-        shared				= dict(default='false', choices=BOOLEANS),
-        admin_state_up			= dict(default='true', choices=BOOLEANS),
-	state	         		= dict(default='present', choices=['absent', 'present'])
+        provider_network_type           = dict(default='local', choices=['local', 'vlan', 'flat', 'gre']), 
+        provider_physical_network       = dict(default=None), 
+        provider_segmentation_id        = dict(default=None), 
+        router_external                 = dict(default='false', choices=BOOLEANS),
+        shared                          = dict(default='false', choices=BOOLEANS),
+        admin_state_up                  = dict(default='true', choices=BOOLEANS),
+        state                           = dict(default='present', choices=['absent', 'present'])
         ),
     )
     if module.params['provider_network_type'] in ['vlan' , 'flat']:
-	    if not module.params['provider_physical_network']:
-		module.fail_json(msg = " for vlan and flat networks, variable provider_physical_network should be set.")
+            if not module.params['provider_physical_network']:
+                module.fail_json(msg = " for vlan and flat networks, variable provider_physical_network should be set.")
     if module.params['provider_network_type']  in ['vlan', 'gre']:
-	    if not module.params['provider_segmentation_id']:
-		module.fail_json(msg = " for vlan & gre networks, variable provider_segmentation_id should be set.")
+            if not module.params['provider_segmentation_id']:
+                module.fail_json(msg = " for vlan & gre networks, variable provider_segmentation_id should be set.")
     quantum = _get_quantum_client(module, module.params)
-    _set_tenant_id(module)	
-    if module.params['state'] == 'present':	
-       	network_id = _get_net_id(quantum, module)
-	if not network_id:
-	    network_id = _create_network(module, quantum)
-	    module.exit_json(changed = True, result = "Created", id = network_id)
-	else:
-	    module.exit_json(changed = False, result = "Success", id = network_id)
+    _set_tenant_id(module)      
+    if module.params['state'] == 'present':     
+        network_id = _get_net_id(quantum, module)
+        if not network_id:
+            network_id = _create_network(module, quantum)
+            module.exit_json(changed = True, result = "Created", id = network_id)
+        else:
+            module.exit_json(changed = False, result = "Success", id = network_id)
     if module.params['state'] == 'absent':
-       	network_id = _get_net_id(quantum, module)
-	if not network_id:
-	    module.exit_json(changed = False, result = "Success")
-	else:
-	    _delete_network(module, network_id, quantum)
-	    module.exit_json(changed = True, result = "Deleted")
+        network_id = _get_net_id(quantum, module)
+        if not network_id:
+            module.exit_json(changed = False, result = "Success")
+        else:
+            _delete_network(module, network_id, quantum)
+            module.exit_json(changed = True, result = "Deleted")
 
 
  
diff --git a/library/cloud/quantum_router b/library/cloud/quantum_router
old mode 100755
new mode 100644
index bccb29f626..addf8df977
--- a/library/cloud/quantum_router
+++ b/library/cloud/quantum_router
@@ -109,10 +109,10 @@ def _get_quantum_client(module, kwargs):
     endpoint = _get_endpoint(module, _ksclient)
     kwargs = {
             'token': token,
-	    'endpoint_url': endpoint
+            'endpoint_url': endpoint
     }
     try:
-    	quantum =  client.Client('2.0', **kwargs)
+        quantum =  client.Client('2.0', **kwargs)
     except Exception as e:
         module.fail_json(msg = "Error in connecting to quantum: %s " % e.message)
     return quantum
@@ -134,68 +134,68 @@ def _set_tenant_id(module):
 
 def _get_router_id(module, quantum):
     kwargs = {
-	    'name': module.params['name'],
-	    'tenant_id': _os_tenant_id,
+            'name': module.params['name'],
+            'tenant_id': _os_tenant_id,
     }
     try:
-	routers = quantum.list_routers(**kwargs)
+        routers = quantum.list_routers(**kwargs)
     except Exception as e:
-	module.fail_json(msg = "Error in getting the router list: %s " % e.message)
+        module.fail_json(msg = "Error in getting the router list: %s " % e.message)
     if not routers['routers']:
-	return None
+        return None
     return routers['routers'][0]['id']
 
 def _create_router(module, quantum):
     router = {
-	    'name': module.params['name'],
-	    'tenant_id': _os_tenant_id,
-	    'admin_state_up': module.params['admin_state_up'],
+            'name': module.params['name'],
+            'tenant_id': _os_tenant_id,
+            'admin_state_up': module.params['admin_state_up'],
     }
     try:
-	    new_router = quantum.create_router({'router': router })
+            new_router = quantum.create_router({'router': router })
     except Exception as e:
-	    module.fail_json( msg = "Error in creating router: %s" % e.message)
+            module.fail_json( msg = "Error in creating router: %s" % e.message)
     return new_router['router']['id']
 
 def _delete_router(module, quantum, router_id):
     try:
-	quantum.delete_router(router_id)
+        quantum.delete_router(router_id)
     except:
-	module.fail_json("Error in deleting the router")
+        module.fail_json("Error in deleting the router")
     return True
-		
+                
 def main():
     module = AnsibleModule(
-        argument_spec        		= dict(
-        login_username         		= dict(default='admin'),
-        login_password         		= dict(required=True),
-        login_tenant_name      		= dict(required='True'),
-        auth_url         		= dict(default='http://127.0.0.1:35357/v2.0/'),
-        region_name      		= dict(default=None),
-        name             		= dict(required=True),
+        argument_spec                   = dict(
+        login_username                  = dict(default='admin'),
+        login_password                  = dict(required=True),
+        login_tenant_name               = dict(required='True'),
+        auth_url                        = dict(default='http://127.0.0.1:35357/v2.0/'),
+        region_name                     = dict(default=None),
+        name                            = dict(required=True),
         tenant_name                     = dict(default=None),
-	state	         		= dict(default='present', choices=['absent', 'present']),
-	admin_state_up                  = dict(default='true', choices=BOOLEANS),
+        state                           = dict(default='present', choices=['absent', 'present']),
+        admin_state_up                  = dict(default='true', choices=BOOLEANS),
         ),
     )
-   		
+                
     quantum = _get_quantum_client(module, module.params)
     _set_tenant_id(module)
     if module.params['state'] == 'present':
-	router_id = _get_router_id(module, quantum)
-	if not router_id:
-	    router_id = _create_router(module, quantum)
-	    module.exit_json(changed = True, result = "Created" , id = router_id)
-	else:
-	    module.exit_json(changed = False, result = "success" , id = router_id)
+        router_id = _get_router_id(module, quantum)
+        if not router_id:
+            router_id = _create_router(module, quantum)
+            module.exit_json(changed = True, result = "Created" , id = router_id)
+        else:
+            module.exit_json(changed = False, result = "success" , id = router_id)
     else:
-	router_id = _get_router_id(module, quantum)
-	if not router_id:
-	    module.exit_json(changed = False, result = "success" )
-	else:
-	    _delete_router(module, quantum, router_id)
-	    module.exit_json(changed = True, result = "deleted" )
-		
+        router_id = _get_router_id(module, quantum)
+        if not router_id:
+            module.exit_json(changed = False, result = "success" )
+        else:
+            _delete_router(module, quantum, router_id)
+            module.exit_json(changed = True, result = "deleted" )
+                
 
  
 
diff --git a/library/cloud/quantum_router_gateway b/library/cloud/quantum_router_gateway
old mode 100755
new mode 100644
index 325379f927..bf830aaf7d
--- a/library/cloud/quantum_router_gateway
+++ b/library/cloud/quantum_router_gateway
@@ -102,10 +102,10 @@ def _get_quantum_client(module, kwargs):
     endpoint = _get_endpoint(module, _ksclient)
     kwargs = {
             'token': token,
-	    'endpoint_url': endpoint
+            'endpoint_url': endpoint
     }
     try:
-    	quantum =  client.Client('2.0', **kwargs)
+        quantum =  client.Client('2.0', **kwargs)
     except Exception as e:
         module.fail_json(msg = "Error in connecting to quantum: %s " % e.message)
     return quantum
@@ -125,7 +125,7 @@ def _get_router_id(module, quantum):
 def _get_net_id(quantum, module):
     kwargs = {
             'name': module.params['network_name'],
-	    'router:external': True
+            'router:external': True
     }
     try:
         networks = quantum.list_networks(**kwargs)
@@ -135,73 +135,73 @@ def _get_net_id(quantum, module):
         return None
     return networks['networks'][0]['id']
 
-		
+                
 def _get_port_id(quantum, module, router_id, network_id):
     kwargs = {
-	    'device_id': router_id,
-	    'network_id': network_id,
+            'device_id': router_id,
+            'network_id': network_id,
     }
     try:
-	ports = quantum.list_ports(**kwargs)
+        ports = quantum.list_ports(**kwargs)
     except Exception as e:
-	module.fail_json( msg = "Error in listing ports: %s" % e.message)
+        module.fail_json( msg = "Error in listing ports: %s" % e.message)
     if not ports['ports']:
-	return None
+        return None
     return ports['ports'][0]['id']
 
 def _add_gateway_router(quantum, module, router_id, network_id):
     kwargs = {
-	    'network_id': network_id
+            'network_id': network_id
     }
     try:
-	quantum.add_gateway_router(router_id, kwargs)
+        quantum.add_gateway_router(router_id, kwargs)
     except Exception as e:
-	module.fail_json(msg = "Error in adding gateway to router: %s" % e.message)
+        module.fail_json(msg = "Error in adding gateway to router: %s" % e.message)
     return True
-		
+                
 def  _remove_gateway_router(quantum, module, router_id):
     try:
         quantum.remove_gateway_router(router_id)
     except Exception as e:
             module.fail_json(msg = "Error in removing gateway to router: %s" % e.message)
     return True
- 	
+        
 def main():
     
     module = AnsibleModule(
-        argument_spec        		= dict(
-        login_username         		= dict(default='admin'),
-        login_password         		= dict(required=True),
-        login_tenant_name      		= dict(required='True'),
-        auth_url         		= dict(default='http://127.0.0.1:35357/v2.0/'),
-        region_name      		= dict(default=None),
-        router_name            		= dict(required=True),
-        network_name     	        = dict(required=True),
-	state	         		= dict(default='present', choices=['absent', 'present']),
+        argument_spec                   = dict(
+        login_username                  = dict(default='admin'),
+        login_password                  = dict(required=True),
+        login_tenant_name               = dict(required='True'),
+        auth_url                        = dict(default='http://127.0.0.1:35357/v2.0/'),
+        region_name                     = dict(default=None),
+        router_name                     = dict(required=True),
+        network_name                    = dict(required=True),
+        state                           = dict(default='present', choices=['absent', 'present']),
         ),
     )
-   		
+                
     quantum = _get_quantum_client(module, module.params)
     router_id = _get_router_id(module, quantum)
     if not router_id:
-	module.fail_json(msg = "failed to get the router id, please check the router name")
-    network_id = _get_net_id(quantum, module)	
+        module.fail_json(msg = "failed to get the router id, please check the router name")
+    network_id = _get_net_id(quantum, module)   
     if not network_id:
-	    module.fail_json(msg = "failed to get the network id, please check the network name and make sure it is external")
-		
+            module.fail_json(msg = "failed to get the network id, please check the network name and make sure it is external")
+                
     if module.params['state'] == 'present':
-	port_id = _get_port_id(quantum, module, router_id, network_id)
-	if not port_id:
-		_add_gateway_router(quantum, module, router_id, network_id)
-		module.exit_json(changed = True, result = "created")
-	module.exit_json(changed = False, result = "success")
+        port_id = _get_port_id(quantum, module, router_id, network_id)
+        if not port_id:
+                _add_gateway_router(quantum, module, router_id, network_id)
+                module.exit_json(changed = True, result = "created")
+        module.exit_json(changed = False, result = "success")
     if module.params['state'] == 'absent':
-	port_id = _get_port_id(quantum, module, router_id, network_id)
-	if not port_id:
-	    module.exit_json(changed = False, result = "Success")
-	_remove_gateway_router(quantum, module, router_id)
-	module.exit_json(changed = True, result = "Deleted")
-			
+        port_id = _get_port_id(quantum, module, router_id, network_id)
+        if not port_id:
+            module.exit_json(changed = False, result = "Success")
+        _remove_gateway_router(quantum, module, router_id)
+        module.exit_json(changed = True, result = "Deleted")
+                        
  
 
 # this is magic, see lib/ansible/module.params['common.py
diff --git a/library/cloud/quantum_router_interface b/library/cloud/quantum_router_interface
old mode 100755
new mode 100644
index e7d3f180ed..0271dc6c35
--- a/library/cloud/quantum_router_interface
+++ b/library/cloud/quantum_router_interface
@@ -109,10 +109,10 @@ def _get_quantum_client(module, kwargs):
     endpoint = _get_endpoint(module, _ksclient)
     kwargs = {
             'token': token,
-	    'endpoint_url': endpoint
+            'endpoint_url': endpoint
     }
     try:
-    	quantum =  client.Client('2.0', **kwargs)
+        quantum =  client.Client('2.0', **kwargs)
     except Exception as e:
         module.fail_json(msg = "Error in connecting to quantum: %s " % e.message)
     return quantum
@@ -158,34 +158,34 @@ def _get_subnet_id(module, quantum):
     if not subnets['subnets']:
         return None
     return subnets['subnets'][0]['id']
-		
+                
 def _get_port_id(quantum, module, router_id, subnet_id):
     kwargs = {
-	    'tenant_id': _os_tenant_id,
-	    'device_id': router_id,
+            'tenant_id': _os_tenant_id,
+            'device_id': router_id,
     }
     try:
-	ports = quantum.list_ports(**kwargs)
+        ports = quantum.list_ports(**kwargs)
     except Exception as e:
-	module.fail_json( msg = "Error in listing ports: %s" % e.message)
+        module.fail_json( msg = "Error in listing ports: %s" % e.message)
     if not ports['ports']:
-	return None
+        return None
     for port in  ports['ports']:
-	for subnet in port['fixed_ips']:
-	    if subnet['subnet_id'] == subnet_id:
-		return port['id']
+        for subnet in port['fixed_ips']:
+            if subnet['subnet_id'] == subnet_id:
+                return port['id']
     return None
 
 def _add_interface_router(quantum, module, router_id, subnet_id):
     kwargs = {
-	'subnet_id': subnet_id
+        'subnet_id': subnet_id
     }
     try:
-	quantum.add_interface_router(router_id, kwargs)
+        quantum.add_interface_router(router_id, kwargs)
     except Exception as e:
-	module.fail_json(msg = "Error in adding interface to router: %s" % e.message)
+        module.fail_json(msg = "Error in adding interface to router: %s" % e.message)
     return True
-		
+                
 def  _remove_interface_router(quantum, module, router_id, subnet_id):
     kwargs = {
         'subnet_id': subnet_id
@@ -195,44 +195,44 @@ def  _remove_interface_router(quantum, module, router_id, subnet_id):
     except Exception as e:
         module.fail_json(msg = "Error in removing interface from router: %s" % e.message)
     return True
- 	
+        
 def main():
     module = AnsibleModule(
-        argument_spec        		= dict(
-        login_username         		= dict(default='admin'),
-        login_password         		= dict(required=True),
-        login_tenant_name      		= dict(required='True'),
-        auth_url         		= dict(default='http://127.0.0.1:35357/v2.0/'),
-        region_name      		= dict(default=None),
-        router_name            		= dict(required=True),
-        subnet_name     	        = dict(required=True),
+        argument_spec                   = dict(
+        login_username                  = dict(default='admin'),
+        login_password                  = dict(required=True),
+        login_tenant_name               = dict(required='True'),
+        auth_url                        = dict(default='http://127.0.0.1:35357/v2.0/'),
+        region_name                     = dict(default=None),
+        router_name                     = dict(required=True),
+        subnet_name                     = dict(required=True),
         tenant_name                     = dict(default=None),
-	state	         		= dict(default='present', choices=['absent', 'present']),
+        state                           = dict(default='present', choices=['absent', 'present']),
         ),
     )
-   		
+                
     quantum = _get_quantum_client(module, module.params)
     _set_tenant_id(module)
     router_id = _get_router_id(module, quantum)
     if not router_id:
-	module.fail_json(msg = "failed to get the router id, please check the router name")
-    subnet_id = _get_subnet_id(module, quantum)	
+        module.fail_json(msg = "failed to get the router id, please check the router name")
+    subnet_id = _get_subnet_id(module, quantum) 
     if not subnet_id:
-	module.fail_json(msg = "failed to get the subnet id, please check the subnet name")
-		
+        module.fail_json(msg = "failed to get the subnet id, please check the subnet name")
+                
     if module.params['state'] == 'present':
-	port_id = _get_port_id(quantum, module, router_id, subnet_id)
-	if not port_id:
-	    _add_interface_router(quantum, module, router_id, subnet_id)
-	    module.exit_json(changed = True, result = "created", id = port_id)
-	module.exit_json(changed = False, result = "success", id = port_id)
+        port_id = _get_port_id(quantum, module, router_id, subnet_id)
+        if not port_id:
+            _add_interface_router(quantum, module, router_id, subnet_id)
+            module.exit_json(changed = True, result = "created", id = port_id)
+        module.exit_json(changed = False, result = "success", id = port_id)
     if module.params['state'] == 'absent':
-	port_id = _get_port_id(quantum, module, router_id, subnet_id)
-	if not port_id:
-	    module.exit_json(changed = False, result = "Sucess")
-	_remove_interface_router(quantum, module, router_id, subnet_id)
-	module.exit_json(changed = True, result = "Deleted")
-			
+        port_id = _get_port_id(quantum, module, router_id, subnet_id)
+        if not port_id:
+            module.exit_json(changed = False, result = "Sucess")
+        _remove_interface_router(quantum, module, router_id, subnet_id)
+        module.exit_json(changed = True, result = "Deleted")
+                        
  
 
 # this is magic, see lib/ansible/module.params['common.py
diff --git a/library/cloud/quantum_subnet b/library/cloud/quantum_subnet
old mode 100755
new mode 100644
index 69c5d41277..ced5899388
--- a/library/cloud/quantum_subnet
+++ b/library/cloud/quantum_subnet
@@ -137,10 +137,10 @@ def _get_quantum_client(module, kwargs):
     endpoint  = _get_endpoint(module, _ksclient)
     kwargs = {
             'token':        token,
-	    'endpoint_url': endpoint
+            'endpoint_url': endpoint
     }
     try:
-    	quantum =  client.Client('2.0', **kwargs)
+        quantum =  client.Client('2.0', **kwargs)
     except Exception as e:
         module.fail_json(msg = " Error in connecting to quantum: %s" % e.message)
     return quantum
@@ -178,92 +178,92 @@ def _get_subnet_id(module, quantum):
     subnet_id = None
     _os_network_id = _get_net_id(quantum, module)
     if not _os_network_id:
-	module.fail_json(msg = "network id of network not found.")
+        module.fail_json(msg = "network id of network not found.")
     else:
-	kwargs = {
+        kwargs = {
             'tenant_id': _os_tenant_id,
             'name': module.params['name'],
         }
-	try:
-	    subnets = quantum.list_subnets(**kwargs)
-	except Exception as e:
-	    module.fail_json( msg = " Error in getting the subnet list:%s " % e.message)
-	if not subnets['subnets']:
-	    return None
-	return subnets['subnets'][0]['id']
+        try:
+            subnets = quantum.list_subnets(**kwargs)
+        except Exception as e:
+            module.fail_json( msg = " Error in getting the subnet list:%s " % e.message)
+        if not subnets['subnets']:
+            return None
+        return subnets['subnets'][0]['id']
 
 def _create_subnet(module, quantum):
     quantum.format = 'json'
     subnet = {
-	    'name':        module.params['name'],
-	    'ip_version':  module.params['ip_version'],
-	    'enable_dhcp': module.params['enable_dhcp'],
-	    'tenant_id':   _os_tenant_id,
-	    'gateway_ip':  module.params['gateway_ip'],
-	    'network_id':  _os_network_id,
-	    'cidr':        module.params['cidr'],
+            'name':        module.params['name'],
+            'ip_version':  module.params['ip_version'],
+            'enable_dhcp': module.params['enable_dhcp'],
+            'tenant_id':   _os_tenant_id,
+            'gateway_ip':  module.params['gateway_ip'],
+            'network_id':  _os_network_id,
+            'cidr':        module.params['cidr'],
     }
     if module.params['allocation_pool_start'] and module.params['allocation_pool_end']:
-	    allocation_pools = [
-			    {'start': module.params['allocation_pool_start'],
-			    'end': module.params['allocation_pool_end']}
-	    ]
-	    subnet.update({'allocation_pools': allocation_pools})
+            allocation_pools = [
+                            {'start': module.params['allocation_pool_start'],
+                            'end': module.params['allocation_pool_end']}
+            ]
+            subnet.update({'allocation_pools': allocation_pools})
     if not module.params['gateway_ip']:
-	    subnet.pop('gateway_ip')
+            subnet.pop('gateway_ip')
     try:
-	    new_subnet = quantum.create_subnet({'subnet': subnet })
+            new_subnet = quantum.create_subnet({'subnet': subnet })
     except Exception as e:
-	    module.fail_json( msg = "Failure in creating subnet: %s" %e.message) 
+            module.fail_json( msg = "Failure in creating subnet: %s" %e.message) 
     return new_subnet['subnet']['id']
-	
-		
+        
+                
 def _delete_subnet(module, quantum, subnet_id):
     try:
-	quantum.delete_subnet(subnet_id)
+        quantum.delete_subnet(subnet_id)
     except Exception as e:
-	module.fail_json( msg = "Error in deleting subnet: %s" % e.message)
+        module.fail_json( msg = "Error in deleting subnet: %s" % e.message)
     return True
-	
-		
+        
+                
 def main():
     
     module = AnsibleModule(
-        argument_spec        	= dict(
-        login_username         	= dict(default='admin'),
-        login_password         	= dict(required=True),
-        login_tenant_name      	= dict(required='True'),
-        auth_url         	= dict(default='http://127.0.0.1:35357/v2.0/'),
-        region_name      	= dict(default=None),
-        name             	= dict(required=True),
+        argument_spec           = dict(
+        login_username          = dict(default='admin'),
+        login_password          = dict(required=True),
+        login_tenant_name       = dict(required='True'),
+        auth_url                = dict(default='http://127.0.0.1:35357/v2.0/'),
+        region_name             = dict(default=None),
+        name                    = dict(required=True),
         network_name            = dict(required=True),
-        cidr		        = dict(required=True),
+        cidr                    = dict(required=True),
         tenant_name             = dict(default=None),
-	state	         	= dict(default='present', choices=['absent', 'present']),
-	ip_version	        = dict(default='4', choices=['4', '6']),
-	enable_dhcp             = dict(default='true', choices=BOOLEANS),
-	gateway_ip              = dict(default=None),
-	allocation_pool_start   = dict(default=None),
-	allocation_pool_end     = dict(default=None),
+        state                   = dict(default='present', choices=['absent', 'present']),
+        ip_version              = dict(default='4', choices=['4', '6']),
+        enable_dhcp             = dict(default='true', choices=BOOLEANS),
+        gateway_ip              = dict(default=None),
+        allocation_pool_start   = dict(default=None),
+        allocation_pool_end     = dict(default=None),
         ),
     )
     quantum = _get_quantum_client(module, module.params)
     _set_tenant_id(module)
     if module.params['state'] == 'present':
-	subnet_id = _get_subnet_id(module, quantum)
-	if not subnet_id:
-	    subnet_id = _create_subnet(module, quantum)
-	    module.exit_json(changed = True, result = "Created" , id = subnet_id)
-	else:
-	    module.exit_json(changed = False, result = "success" , id = subnet_id)
+        subnet_id = _get_subnet_id(module, quantum)
+        if not subnet_id:
+            subnet_id = _create_subnet(module, quantum)
+            module.exit_json(changed = True, result = "Created" , id = subnet_id)
+        else:
+            module.exit_json(changed = False, result = "success" , id = subnet_id)
     else:
-	subnet_id = _get_subnet_id(module, quantum)
-	if not subnet_id:
-		module.exit_json(changed = False, result = "success" )
-	else:
-		_delete_subnet(module, quantum, subnet_id)
-		module.exit_json(changed = True, result = "deleted" )
-		
+        subnet_id = _get_subnet_id(module, quantum)
+        if not subnet_id:
+                module.exit_json(changed = False, result = "success" )
+        else:
+                _delete_subnet(module, quantum, subnet_id)
+                module.exit_json(changed = True, result = "deleted" )
+                
 # this is magic, see lib/ansible/module.params['common.py
 #<<INCLUDE_ANSIBLE_MODULE_COMMON>>
 main()

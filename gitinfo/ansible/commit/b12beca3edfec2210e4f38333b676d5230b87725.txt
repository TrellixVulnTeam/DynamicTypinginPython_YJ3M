commit b12beca3edfec2210e4f38333b676d5230b87725
Author: Ricardo Carrillo Cruz <ricardo.carrillo.cruz@gmail.com>
Date:   Mon May 22 19:48:59 2017 +0200

    Refactos nxos_ip_interface module (#24885)

diff --git a/lib/ansible/modules/network/nxos/nxos_ip_interface.py b/lib/ansible/modules/network/nxos/nxos_ip_interface.py
index 560431c5bc..d9561d32b0 100644
--- a/lib/ansible/modules/network/nxos/nxos_ip_interface.py
+++ b/lib/ansible/modules/network/nxos/nxos_ip_interface.py
@@ -136,7 +136,7 @@ end_state:
                            {"addr": "20.20.20.20", "mask": 24, "tag": 100, "secondary": true}],
             "interface": "ethernet1/32", "prefixes": ["11.11.0.0/17", "20.20.20.0/24"],
             "type": "ethernet", "vrf": "default"}
-updates:
+commands:
     description: commands sent to the device
     returned: always
     type: list
@@ -274,7 +274,7 @@ def parse_unstructured_data(body, interface_name, version, module):
                 address = each_line.strip().split(' ')[0]
                 if address not in address_list:
                     address_list.append(address)
-                    interface['prefixes'].append(str(ipaddress.ip_interface(address.decode('utf-8')).network))
+                    interface['prefixes'].append(str(ipaddress.ip_interface(address).network))
 
             if address_list:
                 for ipv6 in address_list:
@@ -299,7 +299,7 @@ def parse_unstructured_data(body, interface_name, version, module):
                         match_dict['secondary'] = True
                     match_dict['tag'] = int(match_dict['tag'])
                     interface['addresses'].append(match_dict)
-                    prefix = str(ipaddress.ip_interface("{addr}/{mask}".format(**match_dict).decode('utf-8')).network)
+                    prefix = str(ipaddress.ip_interface(u"%(addr)s/%(mask)s" % match_dict).network)
                     interface['prefixes'].append(prefix)
 
     try:
@@ -319,7 +319,6 @@ def parse_unstructured_data(body, interface_name, version, module):
 def get_ip_interface(interface_name, version, module):
     body = send_show_command(interface_name, version, module)
     interface = parse_unstructured_data(body, interface_name, version, module)
-
     return interface
 
 
@@ -435,7 +434,7 @@ def validate_params(addr, interface, mask, tag, allow_secondary, version, state,
                              mask=mask)
     if addr is not None and mask is not None:
         try:
-            ipaddress.ip_interface('{}/{}'.format(addr, mask).decode('utf-8'))
+            ipaddress.ip_interface(u'%s/%s' % (addr, mask))
         except ValueError:
             module.fail_json(msg="Warning! Invalid ip address or mask set.", addr=addr, mask=mask)
 
@@ -532,7 +531,7 @@ def main():
     results['proposed'] = proposed
     results['existing'] = existing
     results['end_state'] = end_state
-    results['updates'] = cmds
+    results['commands'] = cmds
     results['changed'] = changed
     results['warnings'] = warnings
 
diff --git a/test/runner/requirements/units.txt b/test/runner/requirements/units.txt
index 3429d091c9..9a43516b1c 100644
--- a/test/runner/requirements/units.txt
+++ b/test/runner/requirements/units.txt
@@ -15,6 +15,7 @@ redis
 setuptools > 0.6 # pytest-xdist installed via requirements does not work with very old setuptools (sanity_ok)
 unittest2 ; python_version < '2.7'
 netaddr
+ipaddress
 
 # requirements for F5 specific modules
 f5-sdk ; python_version >= '2.7'
diff --git a/test/units/modules/network/nxos/fixtures/nxos_ip_interface.cfg b/test/units/modules/network/nxos/fixtures/nxos_ip_interface.cfg
new file mode 100644
index 0000000000..9b93da845a
--- /dev/null
+++ b/test/units/modules/network/nxos/fixtures/nxos_ip_interface.cfg
@@ -0,0 +1,30 @@
+IP Interface Status for VRF "default"(1)
+Ethernet2/4, Interface status: protocol-up/link-up/admin-up, iod: 39,
+  IP address: 1.1.1.1, IP subnet: 1.1.1.0/8 route-preference: 0, tag: 0 
+  IP broadcast address: 255.255.255.255
+  IP multicast groups locally joined: none
+  IP MTU: 1500 bytes (using link MTU)
+  IP primary address route-preference: 0, tag: 0
+  IP proxy ARP : disabled
+  IP Local Proxy ARP : disabled
+  IP multicast routing: disabled
+  IP icmp redirects: enabled
+  IP directed-broadcast: disabled 
+  IP Forwarding: disabled 
+  IP icmp unreachables (except port): disabled
+  IP icmp port-unreachable: enabled
+  IP unicast reverse path forwarding: none
+  IP load sharing: none 
+  IP interface statistics last reset: never
+  IP interface software stats: (sent/received/forwarded/originated/consumed)
+    Unicast packets    : 0/0/0/0/0
+    Unicast bytes      : 0/0/0/0/0
+    Multicast packets  : 0/0/0/0/0
+    Multicast bytes    : 0/0/0/0/0
+    Broadcast packets  : 0/0/0/0/0
+    Broadcast bytes    : 0/0/0/0/0
+    Labeled packets    : 0/0/0/0/0
+    Labeled bytes      : 0/0/0/0/0
+  WCCP Redirect outbound: disabled
+  WCCP Redirect inbound: disabled
+  WCCP Redirect exclude: disabled
diff --git a/test/units/modules/network/nxos/test_nxos_ip_interface.py b/test/units/modules/network/nxos/test_nxos_ip_interface.py
new file mode 100644
index 0000000000..3125b1984c
--- /dev/null
+++ b/test/units/modules/network/nxos/test_nxos_ip_interface.py
@@ -0,0 +1,74 @@
+# (c) 2016 Red Hat Inc.
+#
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+
+# Make coding more python3-ish
+from __future__ import (absolute_import, division, print_function)
+__metaclass__ = type
+
+import json
+
+from ansible.compat.tests.mock import patch
+from ansible.modules.network.nxos import nxos_ip_interface
+from .nxos_module import TestNxosModule, load_fixture, set_module_args
+
+
+class TestNxosIPInterfaceModule(TestNxosModule):
+
+    module = nxos_ip_interface
+
+    def setUp(self):
+        self.mock_get_interface_mode = patch(
+            'ansible.modules.network.nxos.nxos_ip_interface.get_interface_mode')
+        self.get_interface_mode = self.mock_get_interface_mode.start()
+
+        self.mock_send_show_command = patch(
+            'ansible.modules.network.nxos.nxos_ip_interface.send_show_command')
+        self.send_show_command = self.mock_send_show_command.start()
+
+        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_ip_interface.load_config')
+        self.load_config = self.mock_load_config.start()
+
+    def tearDown(self):
+        self.mock_get_interface_mode.stop()
+        self.mock_send_show_command.stop()
+        self.mock_load_config.stop()
+
+    def load_fixtures(self, commands=None):
+        self.get_interface_mode.return_value = 'layer3'
+        self.send_show_command.return_value = [load_fixture('nxos_ip_interface.cfg')]
+        self.load_config.return_value = None
+
+    def test_nxos_ip_interface_ip_present(self):
+        set_module_args(dict(interface='eth2/1', addr='1.1.1.2', mask=8))
+        result = self.execute_module(changed=True)
+        self.assertEqual(result['commands'],
+                         ['interface eth2/1',
+                          'no ip address 1.1.1.1/8',
+                          'interface eth2/1',
+                          'ip address 1.1.1.2/8'])
+
+    def test_nxos_ip_interface_ip_idempotent(self):
+        set_module_args(dict(interface='eth2/1', addr='1.1.1.1', mask=8))
+        result = self.execute_module(changed=False)
+        self.assertEqual(result['commands'], [])
+
+    def test_nxos_ip_interface_ip_absent(self):
+        set_module_args(dict(interface='eth2/1', state='absent',
+                             addr='1.1.1.1', mask=8))
+        result = self.execute_module(changed=True)
+        self.assertEqual(result['commands'],
+                         ['interface eth2/1', 'no ip address 1.1.1.1/8'])

commit bb998a3cd23ca3282cce2701ef004c08f6571655
Author: Ganesh Nalawade <ganesh634@gmail.com>
Date:   Tue Aug 1 19:32:25 2017 +0530

    Add fix to read correct socket path recieved from ansible-connection (#27560)
    
    Currently socket path is send from `ansible-connection` (running as background
    process) over stdout. This can conflict with debug logs that are also send on
    stdout resulting in incorrect socket path received by the main process.
    
    To avoid this add a socket path delimiter string which is recevied by
    main process and socket path is retrieved based on delimiter string.
    
    This implementation will change in future when ansible-connection
    framework is made more robust.

diff --git a/bin/ansible-connection b/bin/ansible-connection
index 8e9114817c..fde1883e1f 100755
--- a/bin/ansible-connection
+++ b/bin/ansible-connection
@@ -249,7 +249,7 @@ class Server():
                 break
             time.sleep(1)
             timeout -= 1
-        return (0, self.socket_path, '')
+        return 0, b'\n#SOCKET_PATH#: %s\n' % self.socket_path, ''
 
 
 def communicate(sock, data):
diff --git a/lib/ansible/plugins/connection/persistent.py b/lib/ansible/plugins/connection/persistent.py
index 9b0df90cbb..7c7aa53208 100644
--- a/lib/ansible/plugins/connection/persistent.py
+++ b/lib/ansible/plugins/connection/persistent.py
@@ -66,11 +66,12 @@ class Connection(ConnectionBase):
         (stdout, stderr) = p.communicate()
         stdin.close()
 
-        return (p.returncode, stdout, stderr)
+        return (p, stdout, stderr)
 
     def exec_command(self, cmd, in_data=None, sudoable=True):
         super(Connection, self).exec_command(cmd, in_data=in_data, sudoable=sudoable)
-        return self._do_it('EXEC: ' + cmd)
+        p, out, err = self._do_it('EXEC: ' + cmd)
+        return p.returncode, out, err
 
     def put_file(self, in_path, out_path):
         super(Connection, self).put_file(in_path, out_path)
@@ -90,5 +91,16 @@ class Connection(ConnectionBase):
         socket path exists. If the path exists (or the timeout has expired),
         returns the socket path.
         """
-        rc, out, err = self._do_it('RUN:')
-        return to_text(out, errors='surrogate_or_strict')
+        p, out, err = self._do_it('RUN:')
+        while True:
+            out = out.strip()
+            if out == b'':
+                # EOF file found
+                return None
+            elif out.startswith(b'#SOCKET_PATH#'):
+                break
+            else:
+                out = p.stdout.readline()
+
+        socket_path = out.split(b'#SOCKET_PATH#: ', 1)[1]
+        return to_text(socket_path, errors='surrogate_or_strict')

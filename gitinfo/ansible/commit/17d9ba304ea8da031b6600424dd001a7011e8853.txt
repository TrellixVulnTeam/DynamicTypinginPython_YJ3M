commit 17d9ba304ea8da031b6600424dd001a7011e8853
Author: Tim Rupp <caphrim007@gmail.com>
Date:   Tue Jan 16 15:29:37 2018 -0800

    Adds module for bigip device group (#34958)
    
    This module can be used to manage a device group on a bigip

diff --git a/lib/ansible/modules/network/f5/bigip_device_group.py b/lib/ansible/modules/network/f5/bigip_device_group.py
new file mode 100644
index 0000000000..03b315f2c8
--- /dev/null
+++ b/lib/ansible/modules/network/f5/bigip_device_group.py
@@ -0,0 +1,467 @@
+#!/usr/bin/python
+# -*- coding: utf-8 -*-
+#
+# Copyright (c) 2017 F5 Networks Inc.
+# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
+
+from __future__ import absolute_import, division, print_function
+__metaclass__ = type
+
+
+ANSIBLE_METADATA = {'metadata_version': '1.1',
+                    'status': ['preview'],
+                    'supported_by': 'community'}
+
+DOCUMENTATION = r'''
+---
+module: bigip_device_group
+short_description: Manage device groups on a BIG-IP
+description:
+  - Managing device groups allows you to create HA pairs and clusters
+    of BIG-IP devices. Usage of this module should be done in conjunction
+    with the C(bigip_configsync_actions) to sync configuration across
+    the pair or cluster if auto-sync is disabled.
+version_added: "2.5"
+options:
+  name:
+    description:
+      - Specifies the name of the device group.
+    required: True
+  type:
+    description:
+      - Specifies that the type of group. A C(sync-failover) device group
+        contains devices that synchronize their configuration data and fail
+        over to one another when a device becomes unavailable. A C(sync-only)
+        device group has no such failover. When creating a new device group,
+        this option will default to C(sync-only). This setting cannot be
+        changed once it has been set.
+    choices:
+      - sync-failover
+      - sync-only
+  description:
+    description:
+      - Description of the device group.
+  auto_sync:
+    description:
+      - Indicates whether configuration synchronization occurs manually or
+        automatically. When creating a new device group, this option will
+        default to C(false).
+    type: bool
+  save_on_auto_sync:
+    description:
+      - When performing an auto-sync, specifies whether the configuration
+        will be saved or not. If C(false), only the running configuration
+        will be changed on the device(s) being synced to. When creating a
+        new device group, this option will default to C(false).
+    type: bool
+  full_sync:
+    description:
+      - Specifies whether the system synchronizes the entire configuration
+        during synchronization operations. When C(false), the system performs
+        incremental synchronization operations, based on the cache size
+        specified in C(max_incremental_sync_size). Incremental configuration
+        synchronization is a mechanism for synchronizing a device-group's
+        configuration among its members, without requiring a full configuration
+        load for each configuration change. In order for this to work, all
+        devices in the device-group must initially agree on the configuration.
+        Typically this requires at least one full configuration load to each
+        device. When creating a new device group, this option will default
+        to C(false).
+    type: bool
+  max_incremental_sync_size:
+    description:
+      - Specifies the size of the changes cache for incremental sync. For example,
+        using the default, if you make more than 1024 KB worth of incremental
+        changes, the system performs a full synchronization operation. Using
+        incremental synchronization operations can reduce the per-device sync/load
+        time for configuration changes. This setting is relevant only when
+        C(full_sync) is C(false).
+  partition:
+    description:
+      - Device partition to manage resources on.
+    default: Common
+  state:
+    description:
+      - When C(state) is C(present), ensures the device group exists.
+      - When C(state) is C(absent), ensures that the device group is removed.
+    choices:
+      - present
+      - absent
+notes:
+  - This module is primarily used as a component of configuring HA pairs of
+    BIG-IP devices.
+  - Requires BIG-IP >= 12.1.x.
+extends_documentation_fragment: f5
+author:
+  - Tim Rupp (@caphrim007)
+'''
+
+EXAMPLES = r'''
+- name: Create a sync-only device group
+  bigip_device_group:
+    name: foo-group
+    password: secret
+    server: lb.mydomain.com
+    state: present
+    user: admin
+  delegate_to: localhost
+
+- name: Create a sync-only device group with auto-sync enabled
+  bigip_device_group:
+    name: foo-group
+    auto_sync: yes
+    password: secret
+    server: lb.mydomain.com
+    state: present
+    user: admin
+  delegate_to: localhost
+'''
+
+RETURN = r'''
+save_on_auto_sync:
+  description: The new save_on_auto_sync value of the device group.
+  returned: changed
+  type: bool
+  sample: true
+full_sync:
+  description: The new full_sync value of the device group.
+  returned: changed
+  type: bool
+  sample: false
+description:
+  description: The new description of the device group.
+  returned: changed
+  type: string
+  sample: this is a device group
+type:
+  description: The new type of the device group.
+  returned: changed
+  type: string
+  sample: sync-failover
+auto_sync:
+  description: The new auto_sync value of the device group.
+  returned: changed
+  type: bool
+  sample: true
+max_incremental_sync_size:
+  description: The new sync size of the device group
+  returned: changed
+  type: int
+  sample: 1000
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.basic import env_fallback
+from ansible.module_utils.parsing.convert_bool import BOOLEANS_TRUE
+
+HAS_DEVEL_IMPORTS = False
+
+try:
+    # Sideband repository used for dev
+    from library.module_utils.network.f5.bigip import HAS_F5SDK
+    from library.module_utils.network.f5.bigip import F5Client
+    from library.module_utils.network.f5.common import F5ModuleError
+    from library.module_utils.network.f5.common import AnsibleF5Parameters
+    from library.module_utils.network.f5.common import cleanup_tokens
+    from library.module_utils.network.f5.common import fqdn_name
+    from library.module_utils.network.f5.common import f5_argument_spec
+    try:
+        from library.module_utils.network.f5.common import iControlUnexpectedHTTPError
+    except ImportError:
+        HAS_F5SDK = False
+    HAS_DEVEL_IMPORTS = True
+except ImportError:
+    # Upstream Ansible
+    from ansible.module_utils.network.f5.bigip import HAS_F5SDK
+    from ansible.module_utils.network.f5.bigip import F5Client
+    from ansible.module_utils.network.f5.common import F5ModuleError
+    from ansible.module_utils.network.f5.common import AnsibleF5Parameters
+    from ansible.module_utils.network.f5.common import cleanup_tokens
+    from ansible.module_utils.network.f5.common import fqdn_name
+    from ansible.module_utils.network.f5.common import f5_argument_spec
+    try:
+        from ansible.module_utils.network.f5.common import iControlUnexpectedHTTPError
+    except ImportError:
+        HAS_F5SDK = False
+
+
+class Parameters(AnsibleF5Parameters):
+    api_map = {
+        'saveOnAutoSync': 'save_on_auto_sync',
+        'fullLoadOnSync': 'full_sync',
+        'autoSync': 'auto_sync',
+        'incrementalConfigSyncSizeMax': 'max_incremental_sync_size'
+    }
+    api_attributes = [
+        'saveOnAutoSync', 'fullLoadOnSync', 'description', 'type', 'autoSync',
+        'incrementalConfigSyncSizeMax'
+    ]
+    returnables = [
+        'save_on_auto_sync', 'full_sync', 'description', 'type', 'auto_sync',
+        'max_incremental_sync_size'
+    ]
+    updatables = [
+        'save_on_auto_sync', 'full_sync', 'description', 'auto_sync',
+        'max_incremental_sync_size'
+    ]
+
+    @property
+    def save_on_auto_sync(self):
+        if self._values['save_on_auto_sync'] is None:
+            return None
+        elif self._values['save_on_auto_sync'] in BOOLEANS_TRUE:
+            return True
+        else:
+            return False
+
+    @property
+    def auto_sync(self):
+        if self._values['auto_sync'] is None:
+            return None
+        elif self._values['auto_sync'] in [True, 'enabled']:
+            return 'enabled'
+        else:
+            return 'disabled'
+
+    @property
+    def full_sync(self):
+        if self._values['full_sync'] is None:
+            return None
+        elif self._values['full_sync'] in BOOLEANS_TRUE:
+            return True
+        else:
+            return False
+
+    @property
+    def max_incremental_sync_size(self):
+        if not self.full_sync and self._values['max_incremental_sync_size'] is not None:
+            if self._values['__warnings'] is None:
+                self._values['__warnings'] = []
+            self._values['__warnings'].append(
+                [
+                    dict(
+                        msg='"max_incremental_sync_size has no effect if "full_sync" is not true',
+                        version='2.4'
+                    )
+                ]
+            )
+        if self._values['max_incremental_sync_size'] is None:
+            return None
+        return int(self._values['max_incremental_sync_size'])
+
+    def to_return(self):
+        result = {}
+        try:
+            for returnable in self.returnables:
+                result[returnable] = getattr(self, returnable)
+            result = self._filter_params(result)
+        except Exception:
+            pass
+        return result
+
+
+class Changes(Parameters):
+    @property
+    def auto_sync(self):
+        if self._values['auto_sync'] in BOOLEANS_TRUE:
+            return True
+        else:
+            return False
+
+
+class ModuleManager(object):
+    def __init__(self, *args, **kwargs):
+        self.module = kwargs.get('module', None)
+        self.client = kwargs.get('client', None)
+        self.want = Parameters(params=self.module.params)
+        self.have = None
+        self.changes = Parameters()
+
+    def _set_changed_options(self):
+        changed = {}
+        for key in Parameters.returnables:
+            if getattr(self.want, key) is not None:
+                changed[key] = getattr(self.want, key)
+        if changed:
+            self.changes = Changes(params=changed)
+
+    def _update_changed_options(self):
+        changed = {}
+        for key in Parameters.updatables:
+            if getattr(self.want, key) is not None:
+                attr1 = getattr(self.want, key)
+                attr2 = getattr(self.have, key)
+                if attr1 != attr2:
+                    changed[key] = attr1
+        if changed:
+            self.changes = Changes(params=changed)
+            return True
+        return False
+
+    def should_update(self):
+        result = self._update_changed_options()
+        if result:
+            return True
+        return False
+
+    def exec_module(self):
+        changed = False
+        result = dict()
+        state = self.want.state
+
+        try:
+            if state == "present":
+                changed = self.present()
+            elif state == "absent":
+                changed = self.absent()
+        except iControlUnexpectedHTTPError as e:
+            raise F5ModuleError(str(e))
+
+        changes = self.changes.to_return()
+        result.update(**changes)
+        result.update(dict(changed=changed))
+        self._announce_deprecations(result)
+        return result
+
+    def _announce_deprecations(self, result):
+        warnings = result.pop('__warnings', [])
+        for warning in warnings:
+            self.module.deprecate(
+                msg=warning['msg'],
+                version=warning['version']
+            )
+
+    def present(self):
+        if self.exists():
+            return self.update()
+        else:
+            return self.create()
+
+    def exists(self):
+        result = self.client.api.tm.cm.device_groups.device_group.exists(
+            name=self.want.name,
+            partition=self.want.partition
+        )
+        return result
+
+    def update(self):
+        self.have = self.read_current_from_device()
+        if not self.should_update():
+            return False
+        if self.module.check_mode:
+            return True
+        self.update_on_device()
+        return True
+
+    def remove(self):
+        if self.module.check_mode:
+            return True
+        self.remove_from_device()
+        if self.exists():
+            raise F5ModuleError("Failed to delete the device group")
+        return True
+
+    def create(self):
+        self._set_changed_options()
+        if self.module.check_mode:
+            return True
+        self.create_on_device()
+        return True
+
+    def create_on_device(self):
+        params = self.want.api_params()
+        self.client.api.tm.cm.device_groups.device_group.create(
+            name=self.want.name,
+            partition=self.want.partition,
+            **params
+        )
+
+    def update_on_device(self):
+        params = self.want.api_params()
+        resource = self.client.api.tm.cm.device_groups.device_group.load(
+            name=self.want.name,
+            partition=self.want.partition
+        )
+        resource.modify(**params)
+
+    def absent(self):
+        if self.exists():
+            return self.remove()
+        return False
+
+    def remove_from_device(self):
+        resource = self.client.api.tm.cm.device_groups.device_group.load(
+            name=self.want.name,
+            partition=self.want.partition
+        )
+        if resource:
+            resource.delete()
+
+    def read_current_from_device(self):
+        resource = self.client.api.tm.cm.device_groups.device_group.load(
+            name=self.want.name,
+            partition=self.want.partition
+        )
+        result = resource.attrs
+        return Parameters(params=result)
+
+
+class ArgumentSpec(object):
+    def __init__(self):
+        self.supports_check_mode = True
+        argument_spec = dict(
+            type=dict(
+                choices=['sync-failover', 'sync-only']
+            ),
+            description=dict(),
+            auto_sync=dict(
+                type='bool',
+                default='no'
+            ),
+            save_on_auto_sync=dict(
+                type='bool',
+            ),
+            full_sync=dict(
+                type='bool'
+            ),
+            name=dict(
+                required=True
+            ),
+            max_incremental_sync_size=dict(),
+            state=dict(
+                default='present',
+                choices=['absent', 'present']
+            ),
+            partition=dict(
+                default='Common',
+                fallback=(env_fallback, ['F5_PARTITION'])
+            )
+        )
+        self.argument_spec = {}
+        self.argument_spec.update(f5_argument_spec)
+        self.argument_spec.update(argument_spec)
+
+
+def main():
+    spec = ArgumentSpec()
+
+    module = AnsibleModule(
+        argument_spec=spec.argument_spec,
+        supports_check_mode=spec.supports_check_mode
+    )
+    if not HAS_F5SDK:
+        module.fail_json(msg="The python f5-sdk module is required")
+
+    try:
+        client = F5Client(**module.params)
+        mm = ModuleManager(module=module, client=client)
+        results = mm.exec_module()
+        cleanup_tokens(client)
+        module.exit_json(**results)
+    except F5ModuleError as ex:
+        cleanup_tokens(client)
+        module.fail_json(msg=str(ex))
+
+
+if __name__ == '__main__':
+    main()
diff --git a/test/units/modules/network/f5/fixtures/load_tm_cm_device_group.json b/test/units/modules/network/f5/fixtures/load_tm_cm_device_group.json
new file mode 100644
index 0000000000..6660234155
--- /dev/null
+++ b/test/units/modules/network/f5/fixtures/load_tm_cm_device_group.json
@@ -0,0 +1,19 @@
+{
+  "kind": "tm:cm:device-group:device-groupstate",
+  "name": "device_trust_group",
+  "partition": "Common",
+  "fullPath": "/Common/device_trust_group",
+  "generation": 1,
+  "selfLink": "https://localhost/mgmt/tm/cm/device-group/~Common~device_trust_group?ver=13.0.0",
+  "asmSync": "disabled",
+  "autoSync": "enabled",
+  "fullLoadOnSync": "false",
+  "incrementalConfigSyncSizeMax": 1024,
+  "networkFailover": "disabled",
+  "saveOnAutoSync": "false",
+  "type": "sync-only",
+  "devicesReference": {
+    "link": "https://localhost/mgmt/tm/cm/device-group/~Common~device_trust_group/devices?ver=13.0.0",
+    "isSubcollection": true
+  }
+}
diff --git a/test/units/modules/network/f5/test_bigip_device_group.py b/test/units/modules/network/f5/test_bigip_device_group.py
new file mode 100644
index 0000000000..a707940945
--- /dev/null
+++ b/test/units/modules/network/f5/test_bigip_device_group.py
@@ -0,0 +1,176 @@
+# -*- coding: utf-8 -*-
+#
+# Copyright (c) 2017 F5 Networks Inc.
+# GNU General Public License v3.0 (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
+
+from __future__ import (absolute_import, division, print_function)
+__metaclass__ = type
+
+import os
+import json
+import sys
+
+from nose.plugins.skip import SkipTest
+if sys.version_info < (2, 7):
+    raise SkipTest("F5 Ansible modules require Python >= 2.7")
+
+from ansible.compat.tests import unittest
+from ansible.compat.tests.mock import Mock
+from ansible.compat.tests.mock import patch
+from ansible.module_utils.basic import AnsibleModule
+
+try:
+    from library.bigip_device_group import Parameters
+    from library.bigip_device_group import ModuleManager
+    from library.bigip_device_group import ArgumentSpec
+    from library.module_utils.network.f5.common import F5ModuleError
+    from library.module_utils.network.f5.common import iControlUnexpectedHTTPError
+    from test.unit.modules.utils import set_module_args
+except ImportError:
+    try:
+        from ansible.modules.network.f5.bigip_device_group import Parameters
+        from ansible.modules.network.f5.bigip_device_group import ModuleManager
+        from ansible.modules.network.f5.bigip_device_group import ArgumentSpec
+        from ansible.module_utils.network.f5.common import F5ModuleError
+        from ansible.module_utils.network.f5.common import iControlUnexpectedHTTPError
+        from units.modules.utils import set_module_args
+    except ImportError:
+        raise SkipTest("F5 Ansible modules require the f5-sdk Python library")
+
+fixture_path = os.path.join(os.path.dirname(__file__), 'fixtures')
+fixture_data = {}
+
+
+def load_fixture(name):
+    path = os.path.join(fixture_path, name)
+
+    if path in fixture_data:
+        return fixture_data[path]
+
+    with open(path) as f:
+        data = f.read()
+
+    try:
+        data = json.loads(data)
+    except Exception:
+        pass
+
+    fixture_data[path] = data
+    return data
+
+
+class TestParameters(unittest.TestCase):
+    def test_module_parameters(self):
+        args = dict(
+            save_on_auto_sync=True,
+            full_sync=False,
+            description="my description",
+            type="sync-failover",
+            auto_sync=True
+        )
+
+        p = Parameters(params=args)
+        assert p.save_on_auto_sync is True
+        assert p.full_sync is False
+        assert p.description == "my description"
+        assert p.type == "sync-failover"
+        assert p.auto_sync == 'enabled'
+
+    def test_api_parameters(self):
+        args = dict(
+            asmSync="disabled",
+            autoSync="enabled",
+            fullLoadOnSync="false",
+            incrementalConfigSyncSizeMax=1024,
+            networkFailover="disabled",
+            saveOnAutoSync="false",
+            type="sync-only"
+        )
+
+        p = Parameters(params=args)
+        assert p.auto_sync == 'enabled'
+        assert p.full_sync is False
+        assert p.max_incremental_sync_size == 1024
+        assert p.save_on_auto_sync is False
+        assert p.type == 'sync-only'
+
+
+class TestModuleManager(unittest.TestCase):
+
+    def setUp(self):
+        self.spec = ArgumentSpec()
+
+    def test_create_default_device_group(self, *args):
+        set_module_args(
+            dict(
+                name="foo-group",
+                state="present",
+                server='localhost',
+                user='admin',
+                password='password'
+            )
+        )
+
+        module = AnsibleModule(
+            argument_spec=self.spec.argument_spec,
+            supports_check_mode=self.spec.supports_check_mode
+        )
+        mm = ModuleManager(module=module)
+
+        # Override methods to force specific logic in the module to happen
+        mm.create_on_device = Mock(return_value=True)
+        mm.exists = Mock(return_value=False)
+
+        results = mm.exec_module()
+        assert results['changed'] is True
+
+    def test_update_device_group(self, *args):
+        set_module_args(
+            dict(
+                full_sync=True,
+                name="foo-group",
+                state="present",
+                server='localhost',
+                user='admin',
+                password='password'
+            )
+        )
+
+        current = Parameters(params=load_fixture('load_tm_cm_device_group.json'))
+        module = AnsibleModule(
+            argument_spec=self.spec.argument_spec,
+            supports_check_mode=self.spec.supports_check_mode
+        )
+        mm = ModuleManager(module=module)
+
+        # Override methods to force specific logic in the module to happen
+        mm.update_on_device = Mock(return_value=True)
+        mm.exists = Mock(return_value=True)
+        mm.read_current_from_device = Mock(return_value=current)
+
+        results = mm.exec_module()
+        assert results['changed'] is True
+
+    def test_delete_device_group(self, *args):
+        set_module_args(
+            dict(
+                name="foo-group",
+                state="absent",
+                server='localhost',
+                user='admin',
+                password='password'
+            )
+        )
+
+        module = AnsibleModule(
+            argument_spec=self.spec.argument_spec,
+            supports_check_mode=self.spec.supports_check_mode
+        )
+        mm = ModuleManager(module=module)
+
+        # Override methods to force specific logic in the module to happen
+        mm.exists = Mock(side_effect=[True, False])
+        mm.remove_from_device = Mock(return_value=True)
+
+        results = mm.exec_module()
+        assert results['changed'] is True

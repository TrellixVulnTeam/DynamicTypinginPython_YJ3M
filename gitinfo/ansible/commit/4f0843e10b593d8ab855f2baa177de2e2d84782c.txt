commit 4f0843e10b593d8ab855f2baa177de2e2d84782c
Author: Matthew Landauer <matthew@oaf.org.au>
Date:   Wed Feb 18 12:14:58 2015 +1100

    Handle MX,NS,TXT records correctly and don't assume one record type per name

diff --git a/lib/ansible/modules/extras/network/dnsmadeeasy.py b/lib/ansible/modules/extras/network/dnsmadeeasy.py
index c502bfc5ce..b6320d65e6 100644
--- a/lib/ansible/modules/extras/network/dnsmadeeasy.py
+++ b/lib/ansible/modules/extras/network/dnsmadeeasy.py
@@ -134,6 +134,7 @@ class DME2:
         self.domain_map = None      # ["domain_name"] => ID
         self.record_map = None      # ["record_name"] => ID
         self.records = None         # ["record_ID"] => <record>
+        self.all_records = None
 
         # Lookup the domain ID if passed as a domain name vs. ID
         if not self.domain.isdigit():
@@ -191,11 +192,33 @@ class DME2:
 
         return self.records.get(record_id, False)
 
-    def getRecordByName(self, record_name):
-        if not self.record_map:
-            self._instMap('record')
-
-        return self.getRecord(self.record_map.get(record_name, 0))
+    # Try to find a single record matching this one.
+    # How we do this depends on the type of record. For instance, there
+    # can be several MX records for a single record_name while there can
+    # only be a single CNAME for a particular record_name. Note also that
+    # there can be several records with different types for a single name.
+    def getMatchingRecord(self, record_name, record_type, record_value):
+        # Get all the records if not already cached
+        if not self.all_records:
+            self.all_records = self.getRecords()
+
+        # TODO SRV type not yet implemented
+        if record_type in ["A", "AAAA", "CNAME", "HTTPRED", "PTR"]:
+            for result in self.all_records:
+                if result['name'] == record_name and result['type'] == record_type:
+                    return result
+            return False
+        elif record_type in ["MX", "NS", "TXT"]:
+            for result in self.all_records:
+                if record_type == "MX":
+                    value = record_value.split(" ")[1]
+                else:
+                    value = record_value
+                if result['name'] == record_name and result['type'] == record_type and result['value'] == value:
+                    return result
+            return False
+        else:
+            raise Exception('record_type not yet supported')
 
     def getRecords(self):
         return self.query(self.record_url, 'GET')['data']
@@ -262,6 +285,8 @@ def main():
                "account_secret"], module.params["domain"], module)
     state = module.params["state"]
     record_name = module.params["record_name"]
+    record_type = module.params["record_type"]
+    record_value = module.params["record_value"]
 
     # Follow Keyword Controlled Behavior
     if record_name is None:
@@ -272,11 +297,15 @@ def main():
         module.exit_json(changed=False, result=domain_records)
 
     # Fetch existing record + Build new one
-    current_record = DME.getRecordByName(record_name)
+    current_record = DME.getMatchingRecord(record_name, record_type, record_value)
     new_record = {'name': record_name}
     for i in ["record_value", "record_type", "record_ttl"]:
         if not module.params[i] is None:
             new_record[i[len("record_"):]] = module.params[i]
+    # Special handling for mx record
+    if new_record["type"] == "MX":
+        new_record["mxLevel"] = new_record["value"].split(" ")[0]
+        new_record["value"] = new_record["value"].split(" ")[1]
 
     # Compare new record against existing one
     changed = False

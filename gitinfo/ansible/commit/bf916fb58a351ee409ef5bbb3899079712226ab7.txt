commit bf916fb58a351ee409ef5bbb3899079712226ab7
Author: root <root@TINY.(none)>
Date:   Mon Nov 24 18:03:32 2014 +0000

    Adding first pass at win_copy, win_file and win_template modules.

diff --git a/lib/ansible/module_utils/powershell.ps1 b/lib/ansible/module_utils/powershell.ps1
index c097c69768..57d2c1b101 100644
--- a/lib/ansible/module_utils/powershell.ps1
+++ b/lib/ansible/module_utils/powershell.ps1
@@ -142,3 +142,25 @@ Function ConvertTo-Bool
     return
 }
 
+# Helper function to calculate md5 of a file in a way which powershell 3 
+# and above can handle:
+Function Get-FileMd5($path)
+{
+    $hash = ""
+    If (Test-Path -PathType Leaf $path)
+    {
+        $sp = new-object -TypeName System.Security.Cryptography.MD5CryptoServiceProvider;
+        $fp = [System.IO.File]::Open($path, [System.IO.Filemode]::Open, [System.IO.FileAccess]::Read);
+        [System.BitConverter]::ToString($sp.ComputeHash($fp)).Replace("-", "").ToLower();
+        $fp.Dispose();
+    }
+    ElseIf (Test-Path -PathType Container $path)
+    {
+        $hash= "3";
+    }
+    Else
+    {
+        $hash = "1";
+    }
+    return $hash
+}
diff --git a/lib/ansible/modules/core b/lib/ansible/modules/core
index e1f90635af..08c5cc06c6 160000
--- a/lib/ansible/modules/core
+++ b/lib/ansible/modules/core
@@ -1 +1 @@
-Subproject commit e1f90635af0e9ca09449fe47f94471bf9e4ffa5d
+Subproject commit 08c5cc06c6ad9a1e0016ad89eb0f7ca009cc8108
diff --git a/lib/ansible/modules/extras b/lib/ansible/modules/extras
index b8071a8d5e..317654dba5 160000
--- a/lib/ansible/modules/extras
+++ b/lib/ansible/modules/extras
@@ -1 +1 @@
-Subproject commit b8071a8d5eebe405250774a0b7c6c74451bc9532
+Subproject commit 317654dba5cae905b5d6eed78f5c6c6984cc2f02
diff --git a/lib/ansible/runner/action_plugins/fetch.py b/lib/ansible/runner/action_plugins/fetch.py
index 3fa748ccbd..61f9f032a3 100644
--- a/lib/ansible/runner/action_plugins/fetch.py
+++ b/lib/ansible/runner/action_plugins/fetch.py
@@ -127,13 +127,13 @@ class ActionModule(object):
             elif remote_checksum == '2':
                 result = dict(msg="no read permission on remote file, not transferring, ignored", file=source, changed=False)
             elif remote_checksum == '3':
-                result = dict(msg="remote file is a directory, fetch cannot work on directories", file=source, changed=False)
+                result = dict(failed=True, msg="remote file is a directory, fetch cannot work on directories", file=source, changed=False)
             elif remote_checksum == '4':
                 result = dict(msg="python isn't present on the system.  Unable to compute checksum", file=source, changed=False)
             return ReturnData(conn=conn, result=result)
 
         # calculate checksum for the local file
-        local_checksum = utils.checksum(dest)
+        local_checksum = utils.md5(dest)
 
         if remote_checksum != local_checksum:
             # create the containing directories, if needed
@@ -147,7 +147,8 @@ class ActionModule(object):
                 f = open(dest, 'w')
                 f.write(remote_data)
                 f.close()
-            new_checksum = utils.secure_hash(dest)
+            new_checksum = utils.md5(dest)
+            # new_checksum = utils.secure_hash(dest)
             # For backwards compatibility.  We'll return None on FIPS enabled
             # systems
             try:
diff --git a/lib/ansible/runner/action_plugins/win_copy.py b/lib/ansible/runner/action_plugins/win_copy.py
new file mode 100644
index 0000000000..28362195c9
--- /dev/null
+++ b/lib/ansible/runner/action_plugins/win_copy.py
@@ -0,0 +1,377 @@
+# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>
+#
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+
+import os
+
+from ansible import utils
+import ansible.constants as C
+import ansible.utils.template as template
+from ansible import errors
+from ansible.runner.return_data import ReturnData
+import base64
+import json
+import stat
+import tempfile
+import pipes
+
+## fixes https://github.com/ansible/ansible/issues/3518
+# http://mypy.pythonblogs.com/12_mypy/archive/1253_workaround_for_python_bug_ascii_codec_cant_encode_character_uxa0_in_position_111_ordinal_not_in_range128.html
+import sys
+reload(sys)
+sys.setdefaultencoding("utf8")
+
+
+class ActionModule(object):
+
+    def __init__(self, runner):
+        self.runner = runner
+
+    def run(self, conn, tmp_path, module_name, module_args, inject, complex_args=None, **kwargs):
+        ''' handler for file transfer operations '''
+
+        # load up options
+        options = {}
+        if complex_args:
+            options.update(complex_args)
+        options.update(utils.parse_kv(module_args))
+        source  = options.get('src', None)
+        content = options.get('content', None)
+        dest    = options.get('dest', None)
+        raw     = utils.boolean(options.get('raw', 'no'))
+        force   = utils.boolean(options.get('force', 'yes'))
+
+        # content with newlines is going to be escaped to safely load in yaml
+        # now we need to unescape it so that the newlines are evaluated properly
+        # when writing the file to disk
+        if content:
+            if isinstance(content, unicode):
+                try:
+                    content = content.decode('unicode-escape')
+                except UnicodeDecodeError:
+                    pass
+
+        if (source is None and content is None and not 'first_available_file' in inject) or dest is None:
+            result=dict(failed=True, msg="src (or content) and dest are required")
+            return ReturnData(conn=conn, result=result)
+        elif (source is not None or 'first_available_file' in inject) and content is not None:
+            result=dict(failed=True, msg="src and content are mutually exclusive")
+            return ReturnData(conn=conn, result=result)
+
+        # Check if the source ends with a "/"
+        source_trailing_slash = False
+        if source:
+            source_trailing_slash = source.endswith("/")
+
+        # Define content_tempfile in case we set it after finding content populated.
+        content_tempfile = None
+
+        # If content is defined make a temp file and write the content into it.
+        if content is not None:
+            try:
+                # If content comes to us as a dict it should be decoded json.
+                # We need to encode it back into a string to write it out.
+                if type(content) is dict:
+                    content_tempfile = self._create_content_tempfile(json.dumps(content))
+                else:
+                    content_tempfile = self._create_content_tempfile(content)
+                source = content_tempfile
+            except Exception, err:
+                result = dict(failed=True, msg="could not write content temp file: %s" % err)
+                return ReturnData(conn=conn, result=result)
+        # if we have first_available_file in our vars
+        # look up the files and use the first one we find as src
+        elif 'first_available_file' in inject:
+            found = False
+            for fn in inject.get('first_available_file'):
+                fn_orig = fn
+                fnt = template.template(self.runner.basedir, fn, inject)
+                fnd = utils.path_dwim(self.runner.basedir, fnt)
+                if not os.path.exists(fnd) and '_original_file' in inject:
+                    fnd = utils.path_dwim_relative(inject['_original_file'], 'files', fnt, self.runner.basedir, check=False)
+                if os.path.exists(fnd):
+                    source = fnd
+                    found = True
+                    break
+            if not found:
+                results = dict(failed=True, msg="could not find src in first_available_file list")
+                return ReturnData(conn=conn, result=results)
+        else:
+            source = template.template(self.runner.basedir, source, inject)
+            if '_original_file' in inject:
+                source = utils.path_dwim_relative(inject['_original_file'], 'files', source, self.runner.basedir)
+            else:
+                source = utils.path_dwim(self.runner.basedir, source)
+
+        # A list of source file tuples (full_path, relative_path) which will try to copy to the destination
+        source_files = []
+
+        # If source is a directory populate our list else source is a file and translate it to a tuple.
+        if os.path.isdir(source):
+            # Get the amount of spaces to remove to get the relative path.
+            if source_trailing_slash:
+                sz = len(source) + 1
+            else:
+                sz = len(source.rsplit('/', 1)[0]) + 1
+
+            # Walk the directory and append the file tuples to source_files.
+            for base_path, sub_folders, files in os.walk(source):
+                for file in files:
+                    full_path = os.path.join(base_path, file)
+                    rel_path = full_path[sz:]
+                    source_files.append((full_path, rel_path))
+
+            # If it's recursive copy, destination is always a dir,
+            # explicitly mark it so (note - copy module relies on this).
+            if not conn.shell.path_has_trailing_slash(dest):
+                dest = conn.shell.join_path(dest, '')
+        else:
+            source_files.append((source, os.path.basename(source)))
+
+        changed = False
+        diffs = []
+        module_result = {"changed": False}
+
+        # A register for if we executed a module.
+        # Used to cut down on command calls when not recursive.
+        module_executed = False
+
+        # Tell _execute_module to delete the file if there is one file.
+        delete_remote_tmp = (len(source_files) == 1)
+
+        # If this is a recursive action create a tmp_path that we can share as the _exec_module create is too late.
+        if not delete_remote_tmp:
+            if "-tmp-" not in tmp_path:
+                tmp_path = self.runner._make_tmp_path(conn)
+
+        # expand any user home dir specifier
+        dest = self.runner._remote_expand_user(conn, dest, tmp_path)
+
+        for source_full, source_rel in source_files:
+            # Generate a hash of the local file.
+            local_checksum = utils.checksum(source_full)
+
+            # If local_checksum is not defined we can't find the file so we should fail out.
+            if local_checksum is None:
+                result = dict(failed=True, msg="could not find src=%s" % source_full)
+                return ReturnData(conn=conn, result=result)
+
+            # This is kind of optimization - if user told us destination is
+            # dir, do path manipulation right away, otherwise we still check
+            # for dest being a dir via remote call below.
+            if conn.shell.path_has_trailing_slash(dest):
+                dest_file = conn.shell.join_path(dest, source_rel)
+            else:
+                dest_file = conn.shell.join_path(dest)
+
+            # Attempt to get the remote checksum
+            remote_checksum = self.runner._remote_checksum(conn, tmp_path, dest_file, inject)
+
+            if remote_checksum == '3':
+                # The remote_checksum was executed on a directory.
+                if content is not None:
+                    # If source was defined as content remove the temporary file and fail out.
+                    self._remove_tempfile_if_content_defined(content, content_tempfile)
+                    result = dict(failed=True, msg="can not use content with a dir as dest")
+                    return ReturnData(conn=conn, result=result)
+                else:
+                    # Append the relative source location to the destination and retry remote_checksum.
+                    dest_file = conn.shell.join_path(dest, source_rel)
+                    remote_checksum = self.runner._remote_checksum(conn, tmp_path, dest_file, inject)
+
+            if remote_checksum != '1' and not force:
+                # remote_file does not exist so continue to next iteration.
+                continue
+
+            if local_checksum != remote_checksum:
+                # The checksums don't match and we will change or error out.
+                changed = True
+
+                # Create a tmp_path if missing only if this is not recursive.
+                # If this is recursive we already have a tmp_path.
+                if delete_remote_tmp:
+                    if "-tmp-" not in tmp_path:
+                        tmp_path = self.runner._make_tmp_path(conn)
+
+                if self.runner.diff and not raw:
+                    diff = self._get_diff_data(conn, tmp_path, inject, dest_file, source_full)
+                else:
+                    diff = {}
+
+                if self.runner.noop_on_check(inject):
+                    self._remove_tempfile_if_content_defined(content, content_tempfile)
+                    diffs.append(diff)
+                    changed = True
+                    module_result = dict(changed=True)
+                    continue
+
+                # Define a remote directory that we will copy the file to.
+                tmp_src = tmp_path + 'source'
+
+                if not raw:
+                    conn.put_file(source_full, tmp_src)
+                else:
+                    conn.put_file(source_full, dest_file)
+
+                # We have copied the file remotely and no longer require our content_tempfile
+                self._remove_tempfile_if_content_defined(content, content_tempfile)
+
+                # fix file permissions when the copy is done as a different user
+                if (self.runner.sudo and self.runner.sudo_user != 'root' or self.runner.su and self.runner.su_user != 'root') and not raw:
+                    self.runner._remote_chmod(conn, 'a+r', tmp_src, tmp_path)
+
+                if raw:
+                    # Continue to next iteration if raw is defined.
+                    continue
+
+                # Run the copy module
+
+                # src and dest here come after original and override them
+                # we pass dest only to make sure it includes trailing slash in case of recursive copy
+                new_module_args = dict(
+                    src=tmp_src,
+                    dest=dest,
+                    original_basename=source_rel
+                )
+                if self.runner.noop_on_check(inject):
+                    new_module_args['CHECKMODE'] = True
+                if self.runner.no_log:
+                    new_module_args['NO_LOG'] = True
+
+                module_args_tmp = utils.merge_module_args(module_args, new_module_args)
+
+                module_return = self.runner._execute_module(conn, tmp_path, 'win_copy', module_args_tmp, inject=inject, complex_args=complex_args, delete_remote_tmp=delete_remote_tmp)
+                module_executed = True
+
+            else:
+                # no need to transfer the file, already correct md5, but still need to call
+                # the file module in case we want to change attributes
+                self._remove_tempfile_if_content_defined(content, content_tempfile)
+
+                if raw:
+                    # Continue to next iteration if raw is defined.
+                    # self.runner._remove_tmp_path(conn, tmp_path)
+                    continue
+
+                tmp_src = tmp_path + source_rel
+
+                # Build temporary module_args.
+                new_module_args = dict(
+                    src=tmp_src,
+                    dest=dest,
+                    original_basename=source_rel
+                )
+                if self.runner.noop_on_check(inject):
+                    new_module_args['CHECKMODE'] = True
+                if self.runner.no_log:
+                    new_module_args['NO_LOG'] = True
+
+                module_args_tmp = utils.merge_module_args(module_args, new_module_args)
+
+                # Execute the file module.
+                module_return = self.runner._execute_module(conn, tmp_path, 'win_file', module_args_tmp, inject=inject, complex_args=complex_args, delete_remote_tmp=delete_remote_tmp)
+                module_executed = True
+
+            module_result = module_return.result
+            if not module_result.get('checksum'):
+                module_result['checksum'] = local_checksum
+            if module_result.get('failed') == True:
+                return module_return
+            if module_result.get('changed') == True:
+                changed = True
+
+        # Delete tmp_path if we were recursive or if we did not execute a module.
+        if (not C.DEFAULT_KEEP_REMOTE_FILES and not delete_remote_tmp) \
+            or (not C.DEFAULT_KEEP_REMOTE_FILES and delete_remote_tmp and not module_executed):
+            self.runner._remove_tmp_path(conn, tmp_path)
+
+        # the file module returns the file path as 'path', but
+        # the copy module uses 'dest', so add it if it's not there
+        if 'path' in module_result and 'dest' not in module_result:
+            module_result['dest'] = module_result['path']
+
+        # TODO: Support detailed status/diff for multiple files
+        if len(source_files) == 1:
+            result = module_result
+        else:
+            result = dict(dest=dest, src=source, changed=changed)
+        if len(diffs) == 1:
+            return ReturnData(conn=conn, result=result, diff=diffs[0])
+        else:
+            return ReturnData(conn=conn, result=result)
+
+    def _create_content_tempfile(self, content):
+        ''' Create a tempfile containing defined content '''
+        fd, content_tempfile = tempfile.mkstemp()
+        f = os.fdopen(fd, 'w')
+        try:
+            f.write(content)
+        except Exception, err:
+            os.remove(content_tempfile)
+            raise Exception(err)
+        finally:
+            f.close()
+        return content_tempfile
+
+    def _get_diff_data(self, conn, tmp, inject, destination, source):
+        peek_result = self.runner._execute_module(conn, tmp, 'win_file', "path=%s diff_peek=1" % destination, inject=inject, persist_files=True)
+
+        if not peek_result.is_successful():
+            return {}
+
+        diff = {}
+        if peek_result.result['state'] == 'absent':
+            diff['before'] = ''
+        elif peek_result.result['appears_binary']:
+            diff['dst_binary'] = 1
+        elif peek_result.result['size'] > utils.MAX_FILE_SIZE_FOR_DIFF:
+            diff['dst_larger'] = utils.MAX_FILE_SIZE_FOR_DIFF
+        else:
+            dest_result = self.runner._execute_module(conn, tmp, 'slurp', "path=%s" % destination, inject=inject, persist_files=True)
+            if 'content' in dest_result.result:
+                dest_contents = dest_result.result['content']
+                if dest_result.result['encoding'] == 'base64':
+                    dest_contents = base64.b64decode(dest_contents)
+                else:
+                    raise Exception("unknown encoding, failed: %s" % dest_result.result)
+                diff['before_header'] = destination
+                diff['before'] = dest_contents
+
+        src = open(source)
+        src_contents = src.read(8192)
+        st = os.stat(source)
+        if "\x00" in src_contents:
+            diff['src_binary'] = 1
+        elif st[stat.ST_SIZE] > utils.MAX_FILE_SIZE_FOR_DIFF:
+            diff['src_larger'] = utils.MAX_FILE_SIZE_FOR_DIFF
+        else:
+            src.seek(0)
+            diff['after_header'] = source
+            diff['after'] = src.read()
+
+        return diff
+
+    def _remove_tempfile_if_content_defined(self, content, content_tempfile):
+        if content is not None:
+            os.remove(content_tempfile)
+
+
+    def _result_key_merge(self, options, results):
+        # add keys to file module results to mimic copy
+        if 'path' in results.result and 'dest' not in results.result:
+            results.result['dest'] = results.result['path']
+            del results.result['path']
+        return results
diff --git a/lib/ansible/runner/action_plugins/win_template.py b/lib/ansible/runner/action_plugins/win_template.py
new file mode 100644
index 0000000000..e284316191
--- /dev/null
+++ b/lib/ansible/runner/action_plugins/win_template.py
@@ -0,0 +1,147 @@
+# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
+#
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+
+import os
+import pipes
+from ansible.utils import template
+from ansible import utils
+from ansible import errors
+from ansible.runner.return_data import ReturnData
+import base64
+
+class ActionModule(object):
+
+    TRANSFERS_FILES = True
+
+    def __init__(self, runner):
+        self.runner = runner
+
+    def run(self, conn, tmp, module_name, module_args, inject, complex_args=None, **kwargs):
+        ''' handler for template operations '''
+
+        if not self.runner.is_playbook:
+            raise errors.AnsibleError("in current versions of ansible, templates are only usable in playbooks")
+
+        # load up options
+        options  = {}
+        if complex_args:
+            options.update(complex_args)
+        options.update(utils.parse_kv(module_args))
+
+        source   = options.get('src', None)
+        dest     = options.get('dest', None)
+
+        if (source is None and 'first_available_file' not in inject) or dest is None:
+            result = dict(failed=True, msg="src and dest are required")
+            return ReturnData(conn=conn, comm_ok=False, result=result)
+
+        # if we have first_available_file in our vars
+        # look up the files and use the first one we find as src
+
+        if 'first_available_file' in inject:
+            found = False
+            for fn in self.runner.module_vars.get('first_available_file'):
+                fn_orig = fn
+                fnt = template.template(self.runner.basedir, fn, inject)
+                fnd = utils.path_dwim(self.runner.basedir, fnt)
+                if not os.path.exists(fnd) and '_original_file' in inject:
+                    fnd = utils.path_dwim_relative(inject['_original_file'], 'templates', fnt, self.runner.basedir, check=False)
+                if os.path.exists(fnd):
+                    source = fnd
+                    found = True
+                    break
+            if not found:
+                result = dict(failed=True, msg="could not find src in first_available_file list")
+                return ReturnData(conn=conn, comm_ok=False, result=result)
+        else:
+            source = template.template(self.runner.basedir, source, inject)
+
+            if '_original_file' in inject:
+                source = utils.path_dwim_relative(inject['_original_file'], 'templates', source, self.runner.basedir)
+            else:
+                source = utils.path_dwim(self.runner.basedir, source)
+
+
+        if dest.endswith("\\"): # TODO: Check that this fixes the path for Windows hosts.
+            base = os.path.basename(source)
+            dest = os.path.join(dest, base)
+
+        # template the source data locally & get ready to transfer
+        try:
+            resultant = template.template_from_file(self.runner.basedir, source, inject, vault_password=self.runner.vault_pass)
+        except Exception, e:
+            result = dict(failed=True, msg=type(e).__name__ + ": " + str(e))
+            return ReturnData(conn=conn, comm_ok=False, result=result)
+
+        local_checksum = utils.checksum_s(resultant)
+        remote_checksum = self.runner._remote_checksum(conn, tmp, dest, inject)
+
+        if local_checksum != remote_checksum:
+
+            # template is different from the remote value
+
+            # if showing diffs, we need to get the remote value
+            dest_contents = ''
+
+            if self.runner.diff:
+                # using persist_files to keep the temp directory around to avoid needing to grab another
+                dest_result = self.runner._execute_module(conn, tmp, 'slurp', "path=%s" % dest, inject=inject, persist_files=True)
+                if 'content' in dest_result.result:
+                    dest_contents = dest_result.result['content']
+                    if dest_result.result['encoding'] == 'base64':
+                        dest_contents = base64.b64decode(dest_contents)
+                    else:
+                        raise Exception("unknown encoding, failed: %s" % dest_result.result)
+
+            xfered = self.runner._transfer_str(conn, tmp, 'source', resultant)
+
+            # fix file permissions when the copy is done as a different user
+            if self.runner.sudo and self.runner.sudo_user != 'root' or self.runner.su and self.runner.su_user != 'root':
+                self.runner._remote_chmod(conn, 'a+r', xfered, tmp)
+
+            # run the copy module
+            new_module_args = dict(
+               src=xfered,
+               dest=dest,
+               original_basename=os.path.basename(source),
+               follow=True,
+            )
+            module_args_tmp = utils.merge_module_args(module_args, new_module_args)
+
+            if self.runner.noop_on_check(inject):
+                return ReturnData(conn=conn, comm_ok=True, result=dict(changed=True), diff=dict(before_header=dest, after_header=source, before=dest_contents, after=resultant))
+            else:
+                res = self.runner._execute_module(conn, tmp, 'win_copy', module_args_tmp, inject=inject, complex_args=complex_args)
+                if res.result.get('changed', False):
+                    res.diff = dict(before=dest_contents, after=resultant)
+                return res
+        else:
+            # when running the file module based on the template data, we do
+            # not want the source filename (the name of the template) to be used,
+            # since this would mess up links, so we clear the src param and tell
+            # the module to follow links
+            new_module_args = dict(
+                src=None,
+                follow=True,
+            )
+            # be sure to inject the check mode param into the module args and
+            # rely on the file module to report its changed status
+            if self.runner.noop_on_check(inject):
+                new_module_args['CHECKMODE'] = True
+            module_args = utils.merge_module_args(module_args, new_module_args)
+            return self.runner._execute_module(conn, tmp, 'win_file', module_args, inject=inject, complex_args=complex_args)
+
diff --git a/test/integration/integration_config.yml b/test/integration/integration_config.yml
index 4c2fb2a0a5..bf5d6db3de 100644
--- a/test/integration/integration_config.yml
+++ b/test/integration/integration_config.yml
@@ -1,4 +1,5 @@
 ---
+win_output_dir: 'C:/temp/'
 output_dir: ~/ansible_testing
 non_root_test_user: ansible
 pip_test_package: epdb
diff --git a/test/integration/roles/prepare_win_tests/tasks/main.yml b/test/integration/roles/prepare_win_tests/tasks/main.yml
new file mode 100644
index 0000000000..756c977fb1
--- /dev/null
+++ b/test/integration/roles/prepare_win_tests/tasks/main.yml
@@ -0,0 +1,30 @@
+# test code for the windows versions of copy, file and template module
+# originally
+# (c) 2014, Michael DeHaan <michael.dehaan@gmail.com>
+
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+
+
+- name: clean out the test directory
+  win_file: name={{win_output_dir|mandatory}} state=absent
+  tags:
+    - prepare
+
+- name: create the test directory
+  win_file: name={{win_output_dir}} state=directory
+  tags:
+    - prepare
+
diff --git a/test/integration/roles/test_win_copy/files/foo.txt b/test/integration/roles/test_win_copy/files/foo.txt
new file mode 100644
index 0000000000..7c6ded14ec
--- /dev/null
+++ b/test/integration/roles/test_win_copy/files/foo.txt
@@ -0,0 +1 @@
+foo.txt
diff --git a/test/integration/roles/test_win_copy/files/subdir/bar.txt b/test/integration/roles/test_win_copy/files/subdir/bar.txt
new file mode 100644
index 0000000000..76018072e0
--- /dev/null
+++ b/test/integration/roles/test_win_copy/files/subdir/bar.txt
@@ -0,0 +1 @@
+baz
diff --git a/test/integration/roles/test_win_copy/files/subdir/subdir2/baz.txt b/test/integration/roles/test_win_copy/files/subdir/subdir2/baz.txt
new file mode 100644
index 0000000000..76018072e0
--- /dev/null
+++ b/test/integration/roles/test_win_copy/files/subdir/subdir2/baz.txt
@@ -0,0 +1 @@
+baz
diff --git a/test/integration/roles/test_win_copy/files/subdir/subdir2/subdir3/subdir4/qux.txt b/test/integration/roles/test_win_copy/files/subdir/subdir2/subdir3/subdir4/qux.txt
new file mode 100644
index 0000000000..78df5b06bd
--- /dev/null
+++ b/test/integration/roles/test_win_copy/files/subdir/subdir2/subdir3/subdir4/qux.txt
@@ -0,0 +1 @@
+qux
\ No newline at end of file
diff --git a/test/integration/roles/test_win_copy/meta/main.yml b/test/integration/roles/test_win_copy/meta/main.yml
new file mode 100644
index 0000000000..55200b3fc6
--- /dev/null
+++ b/test/integration/roles/test_win_copy/meta/main.yml
@@ -0,0 +1,3 @@
+dependencies: 
+  - prepare_win_tests
+
diff --git a/test/integration/roles/test_win_copy/tasks/main.yml b/test/integration/roles/test_win_copy/tasks/main.yml
new file mode 100644
index 0000000000..f0fe2d04c4
--- /dev/null
+++ b/test/integration/roles/test_win_copy/tasks/main.yml
@@ -0,0 +1,259 @@
+# test code for the copy module and action plugin
+# (c) 2014, Michael DeHaan <michael.dehaan@gmail.com>
+
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+
+- name: record the output directory
+  set_fact: output_file={{win_output_dir}}/foo.txt
+
+- name: initiate a basic copy
+#- name: initiate a basic copy, and also test the mode
+#  win_copy: src=foo.txt dest={{output_file}} mode=0444
+  win_copy: src=foo.txt dest={{output_file}} 
+  register: copy_result
+
+- debug: var=copy_result
+
+#- name: check the presence of the output file
+- name: check the mode of the output file
+  win_file: name={{output_file}} state=file
+  register: file_result_check
+
+- debug: var=file_result_check
+
+
+#- name: assert the mode is correct
+#  assert:
+#    that:
+#      - "file_result_check.mode == '0444'"
+
+- name: assert basic copy worked
+  assert: 
+    that: 
+      - "'changed' in copy_result"
+#      - "'dest' in copy_result"
+#      - "'group' in copy_result"
+#      - "'gid' in copy_result"
+      - "'checksum' in copy_result"
+#      - "'owner' in copy_result"
+#      - "'size' in copy_result"
+#      - "'src' in copy_result"
+#      - "'state' in copy_result"
+#      - "'uid' in copy_result"
+
+- name: verify that the file was marked as changed
+  assert:
+    that:
+      - "copy_result.changed == true"
+
+- name: verify that the file checksum is correct
+  assert: 
+    that: 
+      - "copy_result.checksum[0] == 'c47397529fe81ab62ba3f85e9f4c71f2'"
+
+- name: check the stat results of the file
+  win_stat: path={{output_file}}
+  register: stat_results
+
+- name: assert the stat results are correct
+  assert: 
+    that:
+      - "stat_results.stat.exists == true"
+#      - "stat_results.stat.isblk == false"
+#      - "stat_results.stat.isfifo == false"
+#      - "stat_results.stat.isreg == true"
+#      - "stat_results.stat.issock == false"
+      - "stat_results.stat.md5[0] == 'c47397529fe81ab62ba3f85e9f4c71f2'"
+
+- name: overwrite the file via same means
+  win_copy: src=foo.txt dest={{output_file}}
+  register: copy_result2
+
+- name: assert that the file was not changed
+  assert: 
+    that: 
+      - "not copy_result2|changed"
+
+# content system not available in win_copy right now
+#- name: overwrite the file using the content system
+#  win_copy: content="modified" dest={{output_file}}
+#  register: copy_result3
+#
+#- name: assert that the file has changed
+#  assert: 
+#     that: 
+#       - "copy_result3|changed"
+#       - "'content' not in copy_result3"
+
+# test recursive copy
+
+- name: set the output subdirectory
+  set_fact: output_subdir={{win_output_dir}}/sub/
+
+- name: make an output subdirectory
+  win_file: name={{output_subdir}} state=directory
+
+- name: test recursive copy to directory
+#  win_copy: src=subdir dest={{output_subdir}} directory_mode=0700
+  win_copy: src=subdir dest={{output_subdir}}
+  register: recursive_copy_result
+
+- debug: var=recursive_copy_result
+
+- name: check that a file in a directory was transferred
+  win_stat: path={{win_output_dir}}/sub/subdir/bar.txt
+  register: stat_bar
+
+- name: check that a file in a deeper directory was transferred
+  win_stat: path={{win_output_dir}}/sub/subdir/subdir2/baz.txt 
+  register: stat_bar2
+
+- name: check that a file in a directory whose parent contains a directory alone was transferred
+  win_stat: path={{win_output_dir}}/sub/subdir/subdir2/subdir3/subdir4/qux.txt
+  register: stat_bar3
+
+- name: assert recursive copy things
+  assert:
+    that:
+      - "stat_bar.stat.exists"
+      - "stat_bar2.stat.exists"
+      - "stat_bar3.stat.exists"
+
+- name: stat the recursively copied directories
+  win_stat: path={{win_output_dir}}/sub/{{item}}
+  register: dir_stats
+  with_items:
+    - "subdir"
+    - "subdir/subdir2"
+    - "subdir/subdir2/subdir3"
+    - "subdir/subdir2/subdir3/subdir4"
+
+# can't check file mode on windows so commenting this one out.
+#- name: assert recursive copied directories mode
+#  assert:
+#    that:
+#      - "{{item.stat.mode}} == 0700"
+#  with_items: dir_stats.results
+
+
+# errors on this aren't presently ignored so this test is commented out.  But it would be nice to fix.
+#
+
+# content param not available in win_copy
+#- name: overwrite the file again using the content system, also passing along file params
+#  win_copy: content="modified" dest={{output_file}} 
+#  register: copy_result4
+  
+#- name: assert invalid copy input location fails
+#  win_copy: src=invalid_file_location_does_not_exist dest={{win_output_dir}}/file.txt
+#  ignore_errors: True
+#  register: failed_copy
+
+# owner not available in win_copy, commenting out
+#- name: copy already copied directory again
+#  win_copy: src=subdir dest={{output_subdir | expanduser}} owner={{ansible_ssh_user}}
+#  register: copy_result5
+
+#- name: assert that the directory was not changed
+#  assert:
+#    that:
+#      - "not copy_result5|changed"
+
+# content not available in win_copy, commenting out.
+# issue 8394
+#- name: create a file with content and a literal multiline block
+#  win_copy: |
+#    content='this is the first line
+#    this is the second line
+#
+#    this line is after an empty line
+#    this line is the last line
+#    '
+#    dest={{win_output_dir}}/multiline.txt
+#  register: copy_result6
+
+#- debug: var=copy_result6
+
+#- name: assert the multiline file was created correctly
+#  assert:
+#    that:
+#      - "copy_result6.changed"
+#      - "copy_result6.dest == '{{win_output_dir|expanduser}}/multiline.txt'"
+#      - "copy_result6.checksum == '1627d51e7e607c92cf1a502bf0c6cce3'"
+
+# test overwriting a file as an unprivileged user (pull request #8624)
+# this can't be relative to {{win_output_dir}} as ~root usually has mode 700
+
+#- name: create world writable directory
+  #win_file: dest=/tmp/worldwritable state=directory mode=0777
+
+#- name: create world writable file
+#  win_copy: dest=/tmp/worldwritable/file.txt content="bar" mode=0666
+
+#- name: overwrite the file as user nobody
+#  win_copy: dest=/tmp/worldwritable/file.txt content="baz"
+#  sudo: yes
+#  sudo_user: nobody
+#  register: copy_result7
+
+#- name: assert the file was overwritten
+#  assert:
+#    that:
+#      - "copy_result7.changed"
+#      - "copy_result7.dest == '/tmp/worldwritable/file.txt'"
+#      - "copy_result7.checksum == '73feffa4b7f6bb68e44cf984c85f6e88'"
+
+#- name: clean up
+#  win_file: dest=/tmp/worldwritable state=absent
+
+# test overwritting a link using "follow=yes" so that the link
+# is preserved and the link target is updated
+
+#- name: create a test file to symlink to
+#  win_copy: dest={{win_output_dir}}/follow_test content="this is the follow test file\n"
+#
+#- name: create a symlink to the test file
+#  win_file: path={{win_output_dir}}/follow_link src='./follow_test' state=link
+#
+#- name: update the test file using follow=True to preserve the link
+#  win_copy: dest={{win_output_dir}}/follow_link content="this is the new content\n" follow=yes
+#  register: replace_follow_result
+
+#- name: stat the link path
+#  win_stat: path={{win_output_dir}}/follow_link
+#  register: stat_link_result
+#
+#- name: assert that the link is still a link
+#  assert:
+#    that:
+#    - stat_link_result.stat.islnk
+#
+#- name: get the md5 of the link target
+#  shell: checksum {{win_output_dir}}/follow_test | cut -f1 -sd ' '
+#  register: target_file_result
+
+#- name: assert that the link target was updated
+#  assert:
+#    that:
+#    - replace_follow_result.checksum == target_file_result.stdout
+
+- name: clean up sub
+  win_file: path={{win_output_dir}}/sub state=absent
+
+- name: clean up foo.txt
+  win_file: path={{win_output_dir}}/foo.txt state=absent
+
+
diff --git a/test/integration/roles/test_win_file/files/foo.txt b/test/integration/roles/test_win_file/files/foo.txt
new file mode 100644
index 0000000000..7c6ded14ec
--- /dev/null
+++ b/test/integration/roles/test_win_file/files/foo.txt
@@ -0,0 +1 @@
+foo.txt
diff --git a/test/integration/roles/test_win_file/files/foobar/directory/fileC b/test/integration/roles/test_win_file/files/foobar/directory/fileC
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/integration/roles/test_win_file/files/foobar/directory/fileD b/test/integration/roles/test_win_file/files/foobar/directory/fileD
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/integration/roles/test_win_file/files/foobar/fileA b/test/integration/roles/test_win_file/files/foobar/fileA
new file mode 100644
index 0000000000..ab47708c98
--- /dev/null
+++ b/test/integration/roles/test_win_file/files/foobar/fileA
@@ -0,0 +1 @@
+fileA
diff --git a/test/integration/roles/test_win_file/files/foobar/fileB b/test/integration/roles/test_win_file/files/foobar/fileB
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/test/integration/roles/test_win_file/meta/main.yml b/test/integration/roles/test_win_file/meta/main.yml
new file mode 100644
index 0000000000..55200b3fc6
--- /dev/null
+++ b/test/integration/roles/test_win_file/meta/main.yml
@@ -0,0 +1,3 @@
+dependencies: 
+  - prepare_win_tests
+
diff --git a/test/integration/roles/test_win_file/tasks/main.yml b/test/integration/roles/test_win_file/tasks/main.yml
new file mode 100644
index 0000000000..35ecfb6387
--- /dev/null
+++ b/test/integration/roles/test_win_file/tasks/main.yml
@@ -0,0 +1,421 @@
+# Test code for the file module.
+# (c) 2014, Richard Isaacson <richard.c.isaacson@gmail.com>
+
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+
+- set_fact: output_file={{win_output_dir}}\\foo.txt
+
+- name: prep with a basic win copy
+  win_copy: src=foo.txt dest={{output_file}}
+
+- name: verify that we are checking a file and it is present
+  win_file: path={{output_file}} state=file
+  register: file_result
+
+- name: verify that the file was marked as changed
+  assert:
+    that:
+      - "file_result.changed == false"
+#      - "file_result.state == 'file'"
+
+- name: verify that we are checking an absent file
+  win_file: path={{win_output_dir}}\bar.txt state=absent
+  register: file2_result
+
+- name: verify that the file was marked as changed
+  assert:
+    that:
+      - "file2_result.changed == false"
+#      - "file2_result.state == 'absent'"
+
+- name: verify we can touch a file
+  win_file: path={{win_output_dir}}\baz.txt state=touch
+  register: file3_result
+
+- name: verify that the file was marked as changed
+  assert:
+    that:
+      - "file3_result.changed == true"
+#      - "file3_result.state == 'file'"
+#      - "file3_result.mode == '0644'"
+
+#- name: change file mode
+#  win_file: path={{win_output_dir}}/baz.txt mode=0600
+#  register: file4_result
+
+#- name: verify that the file was marked as changed
+#  assert:
+#    that:
+#      - "file4_result.changed == true"
+#      - "file4_result.mode == '0600'"
+#
+#- name: change ownership and group
+#  win_file: path={{win_output_dir}}/baz.txt owner=1234 group=1234
+#
+#- name: setup a tmp-like directory for ownership test
+#  win_file: path=/tmp/worldwritable mode=1777 state=directory
+
+#- name: Ask to create a file without enough perms to change ownership
+#  win_file: path=/tmp/worldwritable/baz.txt state=touch owner=root
+#  sudo: yes
+#  sudo_user: nobody
+#  register: chown_result
+#  ignore_errors: True
+
+#- name: Ask whether the new file exists
+#  win_stat: path=/tmp/worldwritable/baz.txt
+#  register: file_exists_result
+
+#- name: Verify that the file doesn't exist on failure
+#  assert:
+#    that:
+#      - "chown_result.failed == True"
+#      - "file_exists_result.stat.exists == False"
+#
+- name: clean up
+  win_file: path=/tmp/worldwritable state=absent
+
+#- name: create soft link to file
+#  win_file: src={{output_file}} dest={{win_output_dir}}/soft.txt state=link
+#  register: file5_result
+
+#- name: verify that the file was marked as changed
+#  assert:
+#    that:
+#      - "file5_result.changed == true"
+#
+#- name: create hard link to file
+#  win_file: src={{output_file}} dest={{win_output_dir}}/hard.txt state=hard
+#  register: file6_result
+#
+#- name: verify that the file was marked as changed
+#  assert:
+#    that:
+#      - "file6_result.changed == true"
+#
+- name: create a directory
+  win_file: path={{win_output_dir}}\foobar state=directory
+  register: file7_result
+
+- debug: var=file7_result
+
+- name: verify that the file was marked as changed
+  assert:
+    that:
+      - "file7_result.changed == true"
+#      - "file7_result.state == 'directory'"
+
+# windows and selinux unlikely to ever mix, removing these tests:
+#- name: determine if selinux is installed
+#  shell: which getenforce || exit 0
+#  register: selinux_installed
+
+#- name: determine if selinux is enabled
+#  shell: getenforce
+#  register: selinux_enabled
+#  when: selinux_installed.stdout != ""
+#  ignore_errors: true
+
+#- name: decide to include or not include selinux tests
+#  include: selinux_tests.yml
+#  when: selinux_installed.stdout != "" and selinux_enabled.stdout != "Disabled"
+
+- name: remote directory foobar
+  win_file: path={{win_output_dir}}\foobar state=absent
+
+- name: remove file foo.txt
+  win_file: path={{win_output_dir}}\foo.txt state=absent
+
+- name: remove file bar.txt
+  win_file: path={{win_output_dir}}\foo.txt state=absent
+
+- name: remove file baz.txt
+  win_file: path={{win_output_dir}}\foo.txt state=absent
+
+- name: win copy directory structure over
+  win_copy: src=foobar dest={{win_output_dir}}
+
+- name: remove directory foobar
+  win_file: path={{win_output_dir}}\foobar state=absent
+  register: file14_result
+
+- debug: var=file14_result
+
+- name: verify that the directory was removed
+  assert:
+    that:
+      - 'file14_result.changed == true'
+#      - 'file14_result.state == "absent"'
+
+- name: create a test sub-directory
+  win_file: dest={{win_output_dir}}/sub1 state=directory
+  register: file15_result
+
+- name: verify that the new directory was created
+  assert:
+    that:
+      - 'file15_result.changed == true'
+#      - 'file15_result.state == "directory"'
+
+- name: create test files in the sub-directory
+  win_file: dest={{win_output_dir}}/sub1/{{item}} state=touch
+  with_items:
+  - file1
+  - file2
+  - file3
+  register: file16_result
+
+- name: verify the files were created
+  assert:
+    that:
+      - 'item.changed == true'
+#      - 'item.state == "file"'
+  with_items: file16_result.results
+
+#- name: try to force the sub-directory to a link
+#  win_file: src={{win_output_dir}}/testing dest={{win_output_dir}}/sub1 state=link force=yes
+#  register: file17_result
+#  ignore_errors: true
+
+#- name: verify the directory was not replaced with a link
+#  assert:
+#    that:
+#      - 'file17_result.failed == true'
+#      - 'file17_result.state == "directory"'
+
+#- name: create soft link to directory using absolute path
+#  win_file: src=/ dest={{win_output_dir}}/root state=link
+#  register: file18_result
+#
+#- name: verify that the result was marked as changed
+#  assert:
+#    that:
+#      - "file18_result.changed == true"
+#
+- name: create another test sub-directory
+  win_file: dest={{win_output_dir}}/sub2 state=directory
+  register: file19_result
+
+- name: verify that the new directory was created
+  assert:
+    that:
+      - 'file19_result.changed == true'
+#      - 'file19_result.state == "directory"'
+
+#- name: create soft link to relative file
+#  win_file: src=../sub1/file1 dest={{win_output_dir}}/sub2/link1 state=link
+#  register: file20_result
+#
+#- name: verify that the result was marked as changed
+#  assert:
+#    that:
+#      - "file20_result.changed == true"
+
+#- name: create soft link to relative directory
+#  win_file: src=sub1 dest={{win_output_dir}}/sub1-link state=link
+#  register: file21_result
+#
+#- name: verify that the result was marked as changed
+#  assert:
+#    that:
+#      - "file21_result.changed == true"
+#
+#- name: test file creation with symbolic mode
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=u=rwx,g=rwx,o=rwx
+#  register: result
+#
+#- name: assert file mode
+#  assert:
+#    that:
+#    - result.mode == '0777'
+
+#- name: modify symbolic mode for all
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=a=r
+#  register: result
+#
+#- name: assert file mode
+#  assert:
+#    that:
+#    - result.mode == '0444'
+
+#- name: modify symbolic mode for owner
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=u+w
+#  register: result
+#
+#- name: assert file mode
+#  assert:
+#    that:
+#    - result.mode == '0644'
+
+#- name: modify symbolic mode for group
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=g+w
+#  register: result
+#
+#- name: assert file mode
+#  assert:
+#    that:
+#    - result.mode == '0664'
+#
+#- name: modify symbolic mode for world
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=o+w
+#  register: result
+#
+#- name: assert file mode
+#  assert:
+#    that:
+#    - result.mode == '0666'
+#
+#- name: modify symbolic mode for owner
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=u+x
+#  register: result
+#
+#- name: assert file mode
+#  assert:
+#    that:
+#    - result.mode == '0766'
+##
+#- name: modify symbolic mode for group
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=g+x
+#  register: result
+#
+#- name: assert file mode
+#  assert:
+#    that:
+#    - result.mode == '0776'
+#
+#- name: modify symbolic mode for world
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=o+x
+#  register: result
+#
+#- name: assert file mode
+#  assert:
+#    that:
+#    - result.mode == '0777'
+
+#- name: remove symbolic mode for world
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=o-wx
+#  register: result
+#
+#- name: assert file mode
+#  assert:
+#    that:
+#    - result.mode == '0774'
+#
+#- name: remove symbolic mode for group
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=g-wx
+#  register: result
+#
+#- name: assert file mode
+###  assert:
+#    that:
+#    - result.mode == '0744'
+
+#- name: remove symbolic mode for owner
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=u-wx
+#  register: result
+
+#- name: assert file mode
+#  assert:
+#    that:
+#    - result.mode == '0444'
+#
+#- name: set sticky bit with symbolic mode
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=o+t
+#  register: result
+
+#- name: assert file mode
+#  assert:
+#    that:
+#    - result.mode == '01444'
+#
+#- name: remove sticky bit with symbolic mode
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=o-t
+#  register: result
+#
+#- name: assert file mode
+#  assert:
+#    that:
+#    - result.mode == '0444'
+
+#- name: add setgid with symbolic mode
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=g+s
+#  register: result
+#
+#- name: assert file mode
+#  assert:
+#    that:
+#    - result.mode == '02444'
+#
+#- name: remove setgid with symbolic mode
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=g-s
+#  register: result
+#
+#- name: assert file mode
+#  assert:
+#    that:
+#    - result.mode == '0444'
+
+#- name: add setuid with symbolic mode
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=u+s
+#  register: result
+#
+#- name: assert file mode
+#  assert:
+#    that:
+#    - result.mode == '04444'
+
+#- name: remove setuid with symbolic mode
+#  win_file: dest={{win_output_dir}}/test_symbolic state=touch mode=u-s
+#  register: result
+#
+#- name: assert file mode
+#  assert:
+#    that:
+#    - result.mode == '0444'
+
+# test the file module using follow=yes, so that the target of a
+# symlink is modified, rather than the link itself
+
+#- name: create a test file
+#  win_copy: dest={{win_output_dir}}\test_follow content="this is a test file\n" mode=0666
+
+#- name: create a symlink to the test file
+#  win_file: path={{win_output_dir}}\test_follow_link src="./test_follow" state=link
+#
+#- name: modify the permissions on the link using follow=yes
+#  win_file: path={{win_output_dir}}\test_follow_link mode=0644 follow=yes
+#  register: result
+
+#- name: assert that the chmod worked
+#  assert:
+#    that:
+#    - result.changed
+#
+#- name: stat the link target
+#  win_stat: path={{win_output_dir}}/test_follow
+#  register: result
+#
+#- name: assert that the link target was modified correctly
+#  assert:
+#    that:
+##    - result.stat.mode == '0644'
+
+- name: clean up sub1
+  win_file: path={{win_output_dir}}/sub1 state=absent
+
+- name: clean up sub2
+  win_file: path={{win_output_dir}}/sub2 state=absent
+
diff --git a/test/integration/roles/test_win_template/files/foo.txt b/test/integration/roles/test_win_template/files/foo.txt
new file mode 100644
index 0000000000..3e96db9b3e
--- /dev/null
+++ b/test/integration/roles/test_win_template/files/foo.txt
@@ -0,0 +1 @@
+templated_var_loaded
diff --git a/test/integration/roles/test_win_template/meta/main.yml b/test/integration/roles/test_win_template/meta/main.yml
new file mode 100644
index 0000000000..55200b3fc6
--- /dev/null
+++ b/test/integration/roles/test_win_template/meta/main.yml
@@ -0,0 +1,3 @@
+dependencies: 
+  - prepare_win_tests
+
diff --git a/test/integration/roles/test_win_template/tasks/main.yml b/test/integration/roles/test_win_template/tasks/main.yml
new file mode 100644
index 0000000000..9c2ea920ff
--- /dev/null
+++ b/test/integration/roles/test_win_template/tasks/main.yml
@@ -0,0 +1,103 @@
+# test code for the template module
+# (c) 2014, Michael DeHaan <michael.dehaan@gmail.com>
+
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+
+- name: fill in a basic template
+#  win_template: src=foo.j2 dest={{win_output_dir}}/foo.templated mode=0644
+  win_template: src=foo.j2 dest={{win_output_dir}}/foo.templated
+  register: template_result
+
+- assert: 
+    that: 
+        - "'changed' in template_result" 
+#        - "'dest' in template_result" 
+#        - "'group' in template_result" 
+#        - "'gid' in template_result" 
+#        - "'checksum' in template_result" 
+#        - "'owner' in template_result" 
+#        - "'size' in template_result" 
+#        - "'src' in template_result" 
+#        - "'state' in template_result" 
+#        - "'uid' in template_result" 
+
+- name: verify that the file was marked as changed
+  assert: 
+    that: 
+      - "template_result.changed == true"
+
+# VERIFY CONTENTS
+
+- name: copy known good into place
+  win_copy: src=foo.txt dest={{win_output_dir}}\foo.txt
+
+- name: compare templated file to known good
+  raw: fc.exe {{win_output_dir}}\foo.templated {{win_output_dir}}\foo.txt 
+  register: diff_result
+
+- debug: var=diff_result
+
+- name: verify templated file matches known good
+  assert:  
+    that: 
+#        - 'diff_result.stdout == ""' 
+        - 'diff_result.stdout_lines[1] == "FC: no differences encountered"'
+        - "diff_result.rc == 0" 
+
+# VERIFY MODE
+# can't set file mode on windows so commenting this test out
+#- name: set file mode
+#  win_file: path={{win_output_dir}}/foo.templated mode=0644
+#  register: file_result
+
+#- name: ensure file mode did not change
+#  assert:
+#    that:
+#      - "file_result.changed != True"
+
+# commenting out all the following tests as expanduser and file modes not windows concepts.
+
+# VERIFY dest as a directory does not break file attributes
+# Note: expanduser is needed to go down the particular codepath that was broken before
+#- name: setup directory for test
+#  win_file: state=directory dest={{win_output_dir | expanduser}}/template-dir mode=0755 owner=nobody group=root
+
+#- name: set file mode when the destination is a directory
+#  win_template: src=foo.j2 dest={{win_output_dir | expanduser}}/template-dir/ mode=0600 owner=root group=root
+
+#- name: set file mode when the destination is a directory
+#  win_template: src=foo.j2 dest={{win_output_dir | expanduser}}/template-dir/ mode=0600 owner=root group=root
+#  register: file_result
+#
+#- name: check that the file has the correct attributes
+#  win_stat: path={{win_output_dir | expanduser}}/template-dir/foo.j2
+#  register: file_attrs
+#
+#- assert:
+#    that:
+#      - "file_attrs.stat.uid == 0"
+#      - "file_attrs.stat.pw_name == 'root'"
+#      - "file_attrs.stat.mode == '0600'"
+#
+#- name: check that the containing directory did not change attributes
+#  win_stat: path={{win_output_dir | expanduser}}/template-dir/
+#  register: dir_attrs
+#
+#- assert:
+#    that:
+#      - "dir_attrs.stat.uid != 0"
+#      - "dir_attrs.stat.pw_name == 'nobody'"
+#      - "dir_attrs.stat.mode == '0755'"
diff --git a/test/integration/roles/test_win_template/templates/foo.j2 b/test/integration/roles/test_win_template/templates/foo.j2
new file mode 100644
index 0000000000..55aab8f1ea
--- /dev/null
+++ b/test/integration/roles/test_win_template/templates/foo.j2
@@ -0,0 +1 @@
+{{ templated_var }}
diff --git a/test/integration/roles/test_win_template/vars/main.yml b/test/integration/roles/test_win_template/vars/main.yml
new file mode 100644
index 0000000000..1e8f64ccf4
--- /dev/null
+++ b/test/integration/roles/test_win_template/vars/main.yml
@@ -0,0 +1 @@
+templated_var: templated_var_loaded
diff --git a/test/integration/test_winrm.yml b/test/integration/test_winrm.yml
index 415f381d46..e2a282e061 100644
--- a/test/integration/test_winrm.yml
+++ b/test/integration/test_winrm.yml
@@ -30,3 +30,6 @@
     - { role: test_win_msi, tags: test_win_msi }
     - { role: test_win_service, tags: test_win_service }
     - { role: test_win_feature, tags: test_win_feature }
+    - { role: test_win_file, tags: test_win_file }
+    - { role: test_win_copy, tags: test_win_copy }
+    - { role: test_win_template, tags: test_win_template }

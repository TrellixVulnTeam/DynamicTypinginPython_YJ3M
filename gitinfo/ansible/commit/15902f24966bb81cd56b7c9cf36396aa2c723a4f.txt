commit 15902f24966bb81cd56b7c9cf36396aa2c723a4f
Author: Toshio Kuratomi <a.badger@gmail.com>
Date:   Tue Aug 1 06:31:19 2017 -0700

    Fix for ansiballz filenames conflicting with python stdlib modules
    
    The AnsiBallZ wrapper is transferred to the remote machine with
    a filename similar to the Ansible-module it runs.  For modules like copy
    and tempfile, this can end up conflicting with stdlib modules on the
    remote machine depending on how python is setup there.  We have a little
    bit of code in the wrapper to deal with this by removing the path that
    the ansible module resides in from sys.path.
    
    On MacOSX, that code was having a problem.  The path the module ends up
    in included a symlinked directory so we were looking for a path in
    sys.path but we had to look for the unsymlinked path instead.
    
    Fix that by using os.path.realpath() instead of os.path.abspath()

diff --git a/lib/ansible/executor/module_common.py b/lib/ansible/executor/module_common.py
index c8ba1c27d3..d13d37d800 100644
--- a/lib/ansible/executor/module_common.py
+++ b/lib/ansible/executor/module_common.py
@@ -121,11 +121,11 @@ import __main__
 # stdlib module
 scriptdir = None
 try:
-    scriptdir = os.path.dirname(os.path.abspath(__main__.__file__))
+    scriptdir = os.path.dirname(os.path.realpath(__main__.__file__))
 except (AttributeError, OSError):
     # Some platforms don't set __file__ when reading from stdin
     # OSX raises OSError if using abspath() in a directory we don't have
-    # permission to read.
+    # permission to read (realpath calls abspath)
     pass
 if scriptdir is not None:
     sys.path = [p for p in sys.path if p != scriptdir]

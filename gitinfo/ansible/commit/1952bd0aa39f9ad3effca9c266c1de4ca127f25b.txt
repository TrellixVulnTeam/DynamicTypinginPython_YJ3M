commit 1952bd0aa39f9ad3effca9c266c1de4ca127f25b
Author: Michael DeHaan <michael.dehaan@gmail.com>
Date:   Thu Mar 8 22:50:00 2012 -0500

    add some docs

diff --git a/rst/examples.rst b/rst/examples.rst
index 0a5df0d90d..b061f31eaa 100644
--- a/rst/examples.rst
+++ b/rst/examples.rst
@@ -12,7 +12,7 @@ Examples
 Parallelism and Shell Commands
 ``````````````````````````````
 
-Reboot all web servers in Atlanta, 10 at a time::
+Let's use ansible's command line tool to reboot all web servers in Atlanta, 10 at a time::
 
     ssh-agent bash
     ssh-add ~/.ssh/id_rsa.pub
@@ -21,23 +21,24 @@ Reboot all web servers in Atlanta, 10 at a time::
 
 The -f 10 specifies the usage of 10 simultaneous processes.
 
-Note that other than the command module, ansible modules do not work like simple scripts. They make the remote system look like you state, and run the commands neccessary to get it there.
-
-
-Example 2: Time Limited Background Operations
-`````````````````````````````````````````````
+Note that other than the command module, ansible modules do not work like simple scripts. They make the remote system look like you state, and run the commands neccessary to get it there.  This is commonly refered to
+as 'idempotency'.
 
+Time Limited Background Operations
+``````````````````````````````````
 
 Long running operations can be backgrounded, and their status can be checked on later. The same job ID is given to the same task on all hosts, so you won't lose track. Polling support is pending in the command line.::
 
     ansible all -B 3600 -a "/usr/bin/long_running_operation --do-stuff"
     ansible all -n job_status -a jid=123456789
 
-Any module other than 'copy' or 'template' can be backgrounded.
+Any module other than 'copy' or 'template' can be backgrounded.  Typically you'll be backgrounding shell
+commands or software upgrades only.
 
+After the time limit (in seconds) runs out (-B), the process on the remote nodes will be killed.
 
-Examples 3: File Transfer & Templating
-``````````````````````````````````````
+File Transfer & Templating
+``````````````````````````
 
 Ansible can SCP lots of files to multiple machines in parallel, and optionally use them as template sources.
 
@@ -45,7 +46,7 @@ To just transfer a file directly to many different servers::
 
     ansible atlanta copy -a "/etc/hosts /tmp/hosts"
 
-To use templating, first run the setup module to put the template variables you would like to use on the remote host. Then use the template module to write the files using the templates. Templates are written in Jinja2 format. Playbooks (covered below) will run the setup module for you, making this even simpler.::
+To use templating, first run the setup module to put the template variables you would like to use on the remote host. Then use the template module to write the files using the templates. Templates are written in Jinja2 format. Playbooks (covered elsewhere in the documentation) will run the setup module for you, making this even simpler.::
 
     ansible webservers -m setup    -a "favcolor=red ntp_server=192.168.1.1"
     ansible webservers -m template -a "src=/srv/motd.j2 dest=/etc/motd"
@@ -53,8 +54,8 @@ To use templating, first run the setup module to put the template variables you
 
 Need something like the fqdn in a template? If facter or ohai are installed, data from these projects will also be made available to the template engine, using 'facter' and 'ohai' prefixes for each.
 
-Examples 3: Deploying From Source Control
-`````````````````````````````````````````
+Deploying From Source Control
+`````````````````````````````
 
 Deploy your webapp straight from git::
 
@@ -62,4 +63,15 @@ Deploy your webapp straight from git::
 
 Since ansible modules can notify change handlers (see 'Playbooks') it is possible to tell ansible to run specific tasks when the code is updated, such as deploying Perl/Python/PHP/Ruby directly from git and then restarting apache.
 
+Managing Services
+`````````````````
+
+Ensure a service is started on all webservers::
+
+    ansible webservers -m service name=httpd state=started
+
+Alternatively, restart a service on all webservers::
+
+    ansible webservers -m service name=httpd state=restarted
+
 
diff --git a/rst/gettingstarted.rst b/rst/gettingstarted.rst
index 638039c4a9..0024abcf71 100644
--- a/rst/gettingstarted.rst
+++ b/rst/gettingstarted.rst
@@ -7,20 +7,15 @@ How to download ansible and get started using it
 
    :doc:`examples`
        Examples of basic commands
-   :doc:`YAMLScripts`
-       Complete documentation of the YAML syntax `ansible` understands for playbooks.
    :doc:`playbooks`
        Learning ansible's configuration management language
-   :doc:`modules`
-       Learn about modules that ship with ansible
 
 Requirements
 ````````````
 
-Requirements are extremely minimal.
+Requirements for Ansible are extremely minimal.
 
-If you are running python 2.6 on the **overlord** machine, you will
-need:
+If you are running python 2.6 on the **overlord** machine (the machine that you'll be talking to the other machines from), you will need:
 
 * ``paramiko``
 * ``PyYAML``
@@ -44,7 +39,7 @@ Developer Requirements
 For developers, you may wish to have:
 
 * ``asciidoc`` (for building manpage documentation)
-* ``python-sphinx`` (for building content for ansible.github.com)
+* ``python-sphinx`` (for building content for the ansible.github.com project only)
 
 
 Getting Ansible
@@ -96,5 +91,6 @@ Now try this:
     ansible all -m ping
 
 Congratulations.  You've just contacted your nodes with Ansible.  It's now time to read some
-of the more real-world examples.
+of the more real-world examples, and explore what you can do with different modules, as well
+as the Ansible playbooks language.
 
diff --git a/rst/index.rst b/rst/index.rst
index 9aa197ace7..0c4288f030 100644
--- a/rst/index.rst
+++ b/rst/index.rst
@@ -10,15 +10,17 @@ Other tools in this space have been too complicated for too long, require too mu
 and have too much learning curve.  Ansible is dead simple and painless to extend.  For comparison, Puppet and Chef have about 60k lines of code.  Ansible's core is a little over 1000 lines.  
 
 Ansible isn't just for configuration -- it's also great for Ad-Hoc tasks, 
-quickly firing off commands against nodes.  Where Ansible excels though, is expressing complex multi-node deployment processes, executing complex sequences of commands on different hosts through the "playbooks" feature.
+quickly firing off commands against nodes.  Where Ansible excels though, is expressing complex multi-node deployment processes, executing complex sequences of commands on different hosts through "playbooks".
 
-Ansible does not require programming in any particular language -- you can write modules
-as scripts or programs that return simple JSON.
+Extending ansible does not require programming in any particular language -- you can write modules
+as scripts or programs that return simple JSON.  It's also trivially easy to just execute
+useful shell commands.
 
 Why use Ansible versus something else?  (Puppet, Chef, Fabric, Capistrano,
-mCollective, Func, SaltStack, etc?) It will have far less code, it
-will be more correct, and it will be the easiest thing to hack on and
+mCollective, Func, SaltStack, etc?) Ansible will have far less code, it
+will be (by extension) more correct, and it will be the easiest thing to hack on and
 use you'll ever see -- regardless of your favorite language of choice.
+
 Systems management doesn't have to be complicated.  Ansible's docs will remain 
 short & simple, and the source will be blindingly obvious.
 
@@ -32,7 +34,7 @@ Design Goals
 * No additional software required on client boxes
 * Modules can be written in ANY language
 * Awesome API for creating very powerful distributed scripts
-* Be usable as non-root
+* Be very usable as non-root
 * Create the easiest config management system to use, ever.
 
 Communicate and Get Involved
@@ -55,10 +57,10 @@ Contents
 
    gettingstarted
    patterns
+   examples
    modules
    YAMLScripts
    playbooks
-   examples
    api
    man
 
@@ -69,7 +71,7 @@ Ansible was originally developed by Michael DeHaan, a Raleigh, NC based software
 He created other popular DevOps programs such as Cobbler, the popular Linux install server.
 Cobbler is used to deploy mission critical systems all over the planet, in industries
 ranging from massively multiplayer gaming, core internet infrastructure, finance,
-chip design, and more.  Michael also helped co-author of Func, which is used
+chip design, and more.  Michael also helped co-author of Func, a precursor to Ansible, which is used
 to orchestrate systems in lots of diverse places.  He's worked on systems software for
-IBM, Motorola, Red Hat's Emerging Technologies Group, and rPath.
+IBM, Motorola, Red Hat's Emerging Technologies Group, Puppet Labs, and rPath.
 
diff --git a/rst/modules.rst b/rst/modules.rst
index b17d504448..9b52334153 100644
--- a/rst/modules.rst
+++ b/rst/modules.rst
@@ -13,13 +13,17 @@ ansible playbooks.
    :doc:`api`
        Examples of using modules with the Python API
 
-Module Idempotence
-```````````````````
+Nearly all modules take key=value parameters.  Some modules take no parameters, and the command
+module just takes arguments for the command you want to run.
+
+All modules return JSON format data, thoug if you are using the command line or playbooks, you
+don't really need to know much about that.
 
 Most modules other than command are idempotent, meaning they will seek to avoid changes
 unless a change needs to be made.  When using ansible playbooks, these modules can
 trigger change events.  Unless otherwise noted, all modules support change hooks.
 
+Stock modules:
 
 command
 ```````
@@ -31,6 +35,8 @@ Example usage::
 
     /sbin/shutdown -t now
 
+The given shell command will be executed on all selected nodes.
+
 This module does not support change hooks and returns the return code from the program as well as timing information about how long the command was running for.
 
 
@@ -41,12 +47,12 @@ The copy module moves a file on the local box to remote locations.
 
 *src*::
 
-Local absolute path to a file to copy to the remote server
+Local path to a file to copy to the remote server.  This can be an absolute or relative path.
 
 
 *dest*::
 
-Remote absolute path where the file should end up
+Remote absolute path where the file should end up.
 
 
 This module also returns md5sum information about the resultant file.
@@ -56,18 +62,19 @@ facter
 ``````
 
 Runs the discovery program 'facter' on the remote system, returning
-JSON data that can be useful for inventory purposes.
+JSON data that can be useful for inventory purposes.  
 
 Requires that 'facter' and 'ruby-json' be installed on the remote end.
 
 This module is informative only - it takes no parameters & does not support change hooks,
-nor does it make any changes on the system.
+nor does it make any changes on the system.   Playbooks do not actually use
+this module, they use the 'setup' module behind the scenes.
 
 
 git
 ```
 
-Deploys software from git checkouts.
+Deploys software (or files) from git checkouts.
 
 *repo*::
 
@@ -93,6 +100,8 @@ Requires that 'ohai' be installed on the remote end.
 This module is information only - it takes no parameters & does not
 support change hooks, nor does it make any changes on the system.
 
+Playbooks should not call the ohai module, playbooks call the 'setup'
+module behind the scenes instead.
 
 ping
 ````
@@ -100,9 +109,7 @@ ping
 A trivial test module, this module always returns the integer '1' on
 successful contact.
 
-This module does not support change hooks.
-
-This module is informative only - it takes no parameters & does not
+This module does not support change hooks and is informative only - it takes no parameters & does not
 support change hooks, nor does it make any changes on the system.
 
 
@@ -128,18 +135,14 @@ setup
 
 Writes a JSON file containing key/value data, for use in templating.
 Call this once before using the template modules.  Playbooks will
-execute this module automatically as the first step in each play.
+execute this module automatically as the first step in each play using
+the variables section, so it is unneccessary to make explicit calls to
+setup within a playbook.
 
 If facter or ohai are installed, variables from these programs will also
 be snapshotted into the JSON file for usage in templating. These variables
 are prefixed with 'facter_' and 'ohai_" so it's easy to tell their source.
-
-*metadata*
-
-Optionally overrides the default JSON file location of /etc/ansible/setup or ~/ansible/setup
-depending on what remote user has been specified.  
-
-If used, also supply the metadata parameter to the template module.
+All variables are then bubbled up to the caller.
 
 *anything*
 
@@ -154,43 +157,43 @@ Templates a file out to a remote server.  Call the setup module prior to usage.
 
 *src*
 
-path of a Jinja2 formatted template on the local server
-
+path of a Jinja2 formatted template on the local server.  This can be a relative
+or absolute path.
 
 *dest*
 
 location to render the template on the remote server
 
 
-*metadata*
-
-location of a JSON file to use to supply template data.  Default is /etc/ansible/setup
-which is the same as the default for the setup module.   Change if running as a non-root
-remote user who does not have permissions on /etc/ansible.
-
-
 This module also returns md5sum information about the resultant file.
 
 
-user
-````
+Writing your own modules
+````````````````````````
 
-This module is in plan.
+To write your own modules, simply follow the convention of those already available in
+/usr/share/ansible.  Modules must return JSON but can be written in any language.
+Modules should return hashes, but hashes can be nested.
 
+To support change hooks, modules should return hashes with a changed: True/False
+element at the top level::
 
-yum
-```
+    {
+        'changed'   : True,
+        'something' : 42
+    }
 
-This module is in plan.
+Modules can also choose to indicate a failure scenario by returning a top level 'failure' 
+element with a True value, and a 'msg' element describing the nature of the failure.  
+Other return values are up to the module.
 
+    {
+        'failure'   : True,
+        'msg'       : "here is what happened..."
+    }
+
+When shipping modules, drop them in /usr/share/ansible, or specify the module path to the
+command line tool or API.  It is easy to test modules by running them directly on
+the command line, passing them arguments just like they would be passed with ansible.
 
-writing your own modules
-````````````````````````
 
-To write your own modules, simply follow the convention of those already available in
-/usr/share/ansible.  Modules must return JSON but can be written in any language.
-Modules should return hashes, but hashes can be nested.
-To support change hooks, modules should return hashes with a changed: True/False
-element at the top level.  Modules can also choose to indicate a failure scenario
-by returning a top level 'failure' element with a True value, and a 'msg' element
-describing the nature of the failure.  Other values are up to the module.
diff --git a/rst/playbooks.rst b/rst/playbooks.rst
index fb23c4cf0a..7cbdd48e74 100644
--- a/rst/playbooks.rst
+++ b/rst/playbooks.rst
@@ -11,7 +11,11 @@ Playbooks: Ansible for Deployment, Configuration Management, and Orchestration
        Learn about how to select hosts
 
 
-Playbooks are a completely different way to use ansible and are particularly awesome.  They are the basis for a really simple configuration management and deployment system, unlike any that already exist, and one that is very well suited to deploying complex multi-machine applications. While you might run the main ansible program for ad-hoc tasks, playbooks are more likely to be kept in source control and used to push out your configuration or assure the configurations of your remote systems are in spec.
+Playbooks are a completely different way to use ansible and are particularly awesome.  
+
+They are the basis for a really simple configuration management and multi-machine deployment system, unlike any that already exist, and one that is very well suited to deploying complex applications. 
+
+While you might run the main /usr/bin/ansible program for ad-hoc tasks, playbooks are more likely to be kept in source control and used to push out your configuration or assure the configurations of your remote systems are in spec.
 
 
 Playbook Example
@@ -43,34 +47,43 @@ back on the webservers group, etc::
 Hosts line
 ``````````
 
-The hosts line is alist of one or more groups or host patterns, seperated by colons, as
-described in the 'patterns' documentation.
+The hosts line is a list of one or more groups or host patterns, seperated by colons, as
+described in the 'patterns' documentation.  This is just like the first parameter to /usr/bin/ansible.
 
 Vars section
 ````````````
 
-A list of variables that can be used in the templates, action lines, or included files.
-Variables are deferenced using ``jinja2`` syntax like this::
+A list of variables and values that can be used in the plays.  These can be used in templates
+or 'action' lines and are dereferenced using ```jinja2``` syntax like this:
 
    {{ varname }}
 
-These variables will be pushed down to the managed systems for use in templating operations, where
-the way to dereference them in templates is exactly the same.
-
 Further, if there are discovered variables about the system (say, if facter or ohai were
 installed) these variables bubble up back into the playbook, and can be used on each
 system just like explicitly set variables.  Facter variables are prefixed with 'facter_'
-and Ohai variables are prefixed with 'ohai_'.
+and Ohai variables are prefixed with 'ohai_'.  So for instance, if I wanted to write the
+hostname into the /etc/motd file, I could say:
+
+   - name: write the motd
+   - action: template src=/srv/templates/motd.j2 dest=/etc/motd
+
+And in /srv/templates/motd.j2:::
+
+   You are logged into {{ facter_hostname }}
+
+But we're getting ahead of ourselves.  Let's talk about tasks.
 
 Tasks list
 ``````````
 
 Each play contains a list of tasks.  Tasks are executed in order, one at a time, against 
 all machines matched by the play's host pattern, before moving on to the next task.  
+
 Hosts with failed tasks are taken out of the rotation for the entire playbook.  If things fail, 
-correct the problem and rerun.  Modules other than command are idempotent, meaning if you
-run them again, they will make the changes they are told to make to bring the system to
-the desired state.
+simply correct the playbook file and rerun.  
+
+Modules other than command are idempotent, meaning if you run them again, they will make the 
+changes they are told to make to bring the system to the desired state.
 
 Task name and action
 `````````````````````
@@ -81,27 +94,51 @@ The action line is the name of an ansible module followed by parameters.  Usuall
 are expressed in key=value form, except for the command module, which looks just like a Linux/Unix
 command line.  See the module documentation for more info.
 
+Variables, as mentioned above, can be used in action lines.  So if, hypothetically, you wanted
+to make a directory on each system named after the hostname ... yeah, that's I know silly ... you could
+do it like so:
+
+   - name: make a directory
+   - action: mkdir /tmp/{{ facter_hostname }}
+
 Notify statements
 `````````````````
 
 Nearly all modules are written to be 'idempotent' and can signal when they have affected a change
 on the remote system.  If a notify statement is used, the named handler will be run against
-each system where a change was effected, but NOT on systems where no change occurred.
+each system where a change was effected, but NOT on systems where no change occurred.  This happens
+after all of the tasks are run.  For example, if notifying Apache and potentially replacing lots of
+configuration files, you could have Apache restart just once, at the end of a run.  If you need
+Apache restarted in the middle of a run, you could just make a task for it, no harm done.  Notifiers
+are optional.
 
 Handlers
 ````````
 
 Handlers are lists of tasks, not really any different from regular tasks, that are referenced
-by name.  
+by name.  Handlers are what notifiers notify.  If nothing notifies a handler, it will not run.
+Regardless of how many things notify a handler, it will run only once, after all of the tasks
+complete in a particular play.
 
 Includes
 ````````
 
 Not all tasks have to be listed directly in the main file.  An include file can contain
 a list of tasks (in YAML) as well, optionally passing extra variables into the file.
-Variables passed in can be deferenced like this:
+Variables passed in can be deferenced like this (assume a variable named 'user')
+
+   {{ user }}
+
+For instance, if deploying multiple wordpress instances, I could contain all of my tasks
+in a wordpress.yml file, and use it like so:
+
+   - tasks:
+      - include: wordpress.yml user=timmy 
+      - include: wordpress.yml user=alice
+      - include: wordpress.yml user=bob
 
-   {{ variable }}
+In addition to the explicitly passed in parameters, all variables from the vars section
+are also available.
 
 Asynchronous Actions and Polling
 ````````````````````````````````

commit 7ecfa072dabd301fc60e2646853dff5a884dacb8
Author: Toshio Kuratomi <a.badger@gmail.com>
Date:   Wed Nov 11 08:09:11 2015 -0800

    Move the rest of the playbook code to use global display

diff --git a/lib/ansible/playbook/base.py b/lib/ansible/playbook/base.py
index e4c44eca0f..c41cef8d30 100644
--- a/lib/ansible/playbook/base.py
+++ b/lib/ansible/playbook/base.py
@@ -39,6 +39,7 @@ from ansible.utils.vars import combine_vars, isidentifier
 
 BASE_ATTRIBUTES = {}
 
+
 class Base:
 
     # connection/transport
@@ -75,13 +76,6 @@ class Base:
         # and initialize the base attributes
         self._initialize_base_attributes()
 
-        try:
-            from __main__ import display
-            self._display = display
-        except ImportError:
-            from ansible.utils.display import Display
-            self._display = Display()
-
     # The following three functions are used to programatically define data
     # descriptors (aka properties) for the Attributes of all of the playbook
     # objects (tasks, blocks, plays, etc).
@@ -134,9 +128,9 @@ class Base:
         base_attributes = dict()
         for (name, value) in getmembers(self.__class__):
             if isinstance(value, Attribute):
-               if name.startswith('_'):
-                   name = name[1:]
-               base_attributes[name] = value
+                if name.startswith('_'):
+                    name = name[1:]
+                base_attributes[name] = value
         BASE_ATTRIBUTES[self.__class__] = base_attributes
         return base_attributes
 
@@ -246,7 +240,8 @@ class Base:
                 value = getattr(self, name)
                 if value is not None:
                     if attribute.isa == 'string' and isinstance(value, (list, dict)):
-                        raise AnsibleParserError("The field '%s' is supposed to be a string type, however the incoming data structure is a %s" % (name, type(value)), obj=self.get_ds())
+                        raise AnsibleParserError("The field '%s' is supposed to be a string type,"
+                                " however the incoming data structure is a %s" % (name, type(value)), obj=self.get_ds())
 
     def copy(self):
         '''
@@ -336,7 +331,8 @@ class Base:
                         if attribute.listof is not None:
                             for item in value:
                                 if not isinstance(item, attribute.listof):
-                                    raise AnsibleParserError("the field '%s' should be a list of %s, but the item '%s' is a %s" % (name, attribute.listof, item, type(item)), obj=self.get_ds())
+                                    raise AnsibleParserError("the field '%s' should be a list of %s,"
+                                            " but the item '%s' is a %s" % (name, attribute.listof, item, type(item)), obj=self.get_ds())
                                 elif attribute.required and attribute.listof == string_types:
                                     if item is None or item.strip() == "":
                                         raise AnsibleParserError("the field '%s' is required, and cannot have empty values" % (name,), obj=self.get_ds())
@@ -358,10 +354,12 @@ class Base:
                 setattr(self, name, value)
 
             except (TypeError, ValueError) as e:
-                raise AnsibleParserError("the field '%s' has an invalid value (%s), and could not be converted to an %s. Error was: %s" % (name, value, attribute.isa, e), obj=self.get_ds())
+                raise AnsibleParserError("the field '%s' has an invalid value (%s), and could not be converted to an %s."
+                        " Error was: %s" % (name, value, attribute.isa, e), obj=self.get_ds())
             except UndefinedError as e:
                 if templar._fail_on_undefined_errors and name != 'name':
-                    raise AnsibleParserError("the field '%s' has an invalid value, which appears to include a variable that is undefined. The error was: %s" % (name,e), obj=self.get_ds())
+                    raise AnsibleParserError("the field '%s' has an invalid value, which appears to include a variable that is undefined."
+                            " The error was: %s" % (name,e), obj=self.get_ds())
 
     def serialize(self):
         '''
@@ -455,4 +453,3 @@ class Base:
     def __setstate__(self, data):
         self.__init__()
         self.deserialize(data)
-
diff --git a/lib/ansible/playbook/play.py b/lib/ansible/playbook/play.py
index e1d3453c52..db96c29372 100644
--- a/lib/ansible/playbook/play.py
+++ b/lib/ansible/playbook/play.py
@@ -21,21 +21,17 @@ __metaclass__ = type
 
 from ansible.compat.six import string_types
 
-from ansible.errors import AnsibleError, AnsibleParserError
+from ansible.errors import AnsibleParserError
 
-from ansible.playbook.attribute import Attribute, FieldAttribute
+from ansible.playbook.attribute import FieldAttribute
 from ansible.playbook.base import Base
 from ansible.playbook.become import Become
 from ansible.playbook.block import Block
 from ansible.playbook.helpers import load_list_of_blocks, load_list_of_roles
 from ansible.playbook.role import Role
 from ansible.playbook.taggable import Taggable
-from ansible.playbook.task import Task
 from ansible.vars import preprocess_vars
 
-
-__all__ = ['Play']
-
 try:
     from __main__ import display
     display = display
@@ -44,6 +40,9 @@ except ImportError:
     display = Display()
 
 
+__all__ = ['Play']
+
+
 class Play(Base, Taggable, Become):
 
     """
@@ -102,8 +101,8 @@ class Play(Base, Taggable, Become):
         return self.get_name()
 
     def get_name(self):
-       ''' return the name of the Play '''
-       return self._attributes.get('name')
+        ''' return the name of the Play '''
+        return self._attributes.get('name')
 
     @staticmethod
     def load(data, variable_manager=None, loader=None):
@@ -124,7 +123,8 @@ class Play(Base, Taggable, Become):
             # this should never happen, but error out with a helpful message
             # to the user if it does...
             if 'remote_user' in ds:
-                raise AnsibleParserError("both 'user' and 'remote_user' are set for %s. The use of 'user' is deprecated, and should be removed" % self.get_name(), obj=ds)
+                raise AnsibleParserError("both 'user' and 'remote_user' are set for %s."
+                        " The use of 'user' is deprecated, and should be removed" % self.get_name(), obj=ds)
 
             ds['remote_user'] = ds['user']
             del ds['user']
@@ -217,7 +217,7 @@ class Play(Base, Taggable, Become):
         vars_prompts = []
         for prompt_data in new_ds:
             if 'name' not in prompt_data:
-                self._display.deprecated("Using the 'short form' for vars_prompt has been deprecated")
+                display.deprecated("Using the 'short form' for vars_prompt has been deprecated")
                 for vname, prompt in prompt_data.iteritems():
                     vars_prompts.append(dict(
                         name      = vname,
@@ -345,4 +345,3 @@ class Play(Base, Taggable, Become):
         new_me.ROLE_CACHE = self.ROLE_CACHE.copy()
         new_me._included_path = self._included_path
         return new_me
-
diff --git a/lib/ansible/playbook/task.py b/lib/ansible/playbook/task.py
index 8a3d4c4a60..82226554c6 100644
--- a/lib/ansible/playbook/task.py
+++ b/lib/ansible/playbook/task.py
@@ -24,12 +24,11 @@ from ansible.compat.six import iteritems, string_types
 from ansible.errors import AnsibleError
 
 from ansible.parsing.mod_args import ModuleArgsParser
-from ansible.parsing.splitter import parse_kv
 from ansible.parsing.yaml.objects import AnsibleBaseYAMLObject, AnsibleMapping, AnsibleUnicode
 
-from ansible.plugins import module_loader, lookup_loader
+from ansible.plugins import lookup_loader
 
-from ansible.playbook.attribute import Attribute, FieldAttribute
+from ansible.playbook.attribute import FieldAttribute
 from ansible.playbook.base import Base
 from ansible.playbook.become import Become
 from ansible.playbook.block import Block
@@ -37,8 +36,6 @@ from ansible.playbook.conditional import Conditional
 from ansible.playbook.role import Role
 from ansible.playbook.taggable import Taggable
 
-__all__ = ['Task']
-
 try:
     from __main__ import display
     display = display
@@ -46,6 +43,9 @@ except ImportError:
     from ansible.utils.display import Display
     display = Display()
 
+__all__ = ['Task']
+
+
 class Task(Base, Conditional, Taggable, Become):
 
     """
@@ -94,24 +94,24 @@ class Task(Base, Conditional, Taggable, Become):
         super(Task, self).__init__()
 
     def get_path(self):
-       ''' return the absolute path of the task with its line number '''
+        ''' return the absolute path of the task with its line number '''
 
-       if hasattr(self, '_ds'):
-           return "%s:%s" % (self._ds._data_source, self._ds._line_number)
+        if hasattr(self, '_ds'):
+            return "%s:%s" % (self._ds._data_source, self._ds._line_number)
 
     def get_name(self):
-       ''' return the name of the task '''
-
-       if self._role and self.name:
-           return "%s : %s" % (self._role.get_name(), self.name)
-       elif self.name:
-           return self.name
-       else:
-           flattened_args = self._merge_kv(self.args)
-           if self._role:
-               return "%s : %s %s" % (self._role.get_name(), self.action, flattened_args)
-           else:
-               return "%s %s" % (self.action, flattened_args)
+        ''' return the name of the task '''
+
+        if self._role and self.name:
+            return "%s : %s" % (self._role.get_name(), self.name)
+        elif self.name:
+            return self.name
+        else:
+            flattened_args = self._merge_kv(self.args)
+            if self._role:
+                return "%s : %s %s" % (self._role.get_name(), self.action, flattened_args)
+            else:
+                return "%s %s" % (self.action, flattened_args)
 
     def _merge_kv(self, ds):
         if ds is None:
@@ -174,7 +174,8 @@ class Task(Base, Conditional, Taggable, Become):
         if action in ('command', 'shell', 'script'):
             if 'cmd' in args:
                 if args.get('_raw_params', '') != '':
-                    raise AnsibleError("The 'cmd' argument cannot be used when other raw parameters are specified. Please put everything in one or the other place.", obj=ds)
+                    raise AnsibleError("The 'cmd' argument cannot be used when other raw parameters are specified."
+                            " Please put everything in one or the other place.", obj=ds)
                 args['_raw_params'] = args.pop('cmd')
 
         new_ds['action']      = action
@@ -204,7 +205,9 @@ class Task(Base, Conditional, Taggable, Become):
                 # here, and show a deprecation message as we will remove this at
                 # some point in the future.
                 if action == 'include' and k not in self._get_base_attributes() and k not in self.DEPRECATED_ATTRIBUTES:
-                    self._display.deprecated("Specifying include variables at the top-level of the task is deprecated. Please see:\nhttp://docs.ansible.com/ansible/playbooks_roles.html#task-include-files-and-encouraging-reuse\n\nfor currently supported syntax regarding included files and variables")
+                    display.deprecated("Specifying include variables at the top-level of the task is deprecated."
+                            " Please see:\nhttp://docs.ansible.com/ansible/playbooks_roles.html#task-include-files-and-encouraging-reuse\n\n"
+                            " for currently supported syntax regarding included files and variables")
                     new_ds['vars'][k] = v
                 else:
                     new_ds[k] = v
@@ -249,7 +252,8 @@ class Task(Base, Conditional, Taggable, Become):
 
         for env_item in value:
             if isinstance(env_item, (string_types, AnsibleUnicode)) and env_item in templar._available_variables.keys():
-                self._display.deprecated("Using bare variables for environment is deprecated. Update your playbooks so that the environment value uses the full variable syntax ('{{foo}}')")
+                display.deprecated("Using bare variables for environment is deprecated."
+                        " Update your playbooks so that the environment value uses the full variable syntax ('{{foo}}')")
                 break
         return templar.template(value, convert_bare=True)
 
@@ -387,4 +391,3 @@ class Task(Base, Conditional, Taggable, Become):
         if parent_environment is not None:
             environment = self._extend_value(environment, parent_environment)
         return environment
-

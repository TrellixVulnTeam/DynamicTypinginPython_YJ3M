commit dca36c1d16064b24adfa14b417eb71637b960b96
Author: James Cammarata <jimi@sngx.net>
Date:   Mon Jul 20 14:36:31 2015 -0400

    Reestablishing the use of tags/when for role duplication detection
    
    Not figuring these in can cause problems with "diamond" pattern relationships,
    even though this is still not quite optimal.

diff --git a/lib/ansible/executor/process/result.py b/lib/ansible/executor/process/result.py
index 8961b43ce4..c1b1a4471e 100644
--- a/lib/ansible/executor/process/result.py
+++ b/lib/ansible/executor/process/result.py
@@ -141,7 +141,7 @@ class ResultProcess(multiprocessing.Process):
                                     if result._task._role:
                                         role_name = result._task._role.get_name()
                                         notify = "%s : %s" % (role_name, notify)
-                                    self._send_result(('notify_handler', result._host, notify))
+                                    self._send_result(('notify_handler', result, notify))
                             # now remove the notify field from the results, as its no longer needed
                             result_item.pop('ansible_notify')
 
diff --git a/lib/ansible/playbook/role/__init__.py b/lib/ansible/playbook/role/__init__.py
index d2f03e32b5..b805555729 100644
--- a/lib/ansible/playbook/role/__init__.py
+++ b/lib/ansible/playbook/role/__init__.py
@@ -101,6 +101,10 @@ class Role(Base, Become, Conditional, Taggable):
             # We use frozenset to make the dictionary hashable.
 
             params = role_include.get_role_params()
+            if role_include.when is not None:
+                params['when'] = role_include.when
+            if role_include.tags is not None:
+                params['tags'] = role_include.tags
             hashed_params = hash_params(params)
             if role_include.role in play.ROLE_CACHE:
                 for (entry, role_obj) in play.ROLE_CACHE[role_include.role].iteritems():
diff --git a/lib/ansible/plugins/strategies/__init__.py b/lib/ansible/plugins/strategies/__init__.py
index c9154556bf..45d2000f45 100644
--- a/lib/ansible/plugins/strategies/__init__.py
+++ b/lib/ansible/plugins/strategies/__init__.py
@@ -194,7 +194,12 @@ class StrategyBase:
                         # lookup the role in the ROLE_CACHE to make sure we're dealing
                         # with the correct object and mark it as executed
                         for (entry, role_obj) in iterator._play.ROLE_CACHE[task_result._task._role._role_name].iteritems():
-                            hashed_entry = hash_params(task_result._task._role._role_params)
+                            params = task_result._task._role._role_params
+                            if task_result._task._role.tags is not None:
+                                params['tags'] = task_result._task._role.tags
+                            if task_result._task._role.when is not None:
+                                params['when'] = task_result._task._role.when
+                            hashed_entry = hash_params(params)
                             if entry == hashed_entry:
                                 role_obj._had_task_run = True
 
@@ -211,13 +216,15 @@ class StrategyBase:
                     self._add_group(task, iterator)
 
                 elif result[0] == 'notify_handler':
-                    host         = result[1]
+                    task_result  = result[1]
                     handler_name = result[2]
+
+                    original_task = iterator.get_original_task(task_result._host, task_result._task)
                     if handler_name not in self._notified_handlers:
                         self._notified_handlers[handler_name] = []
 
-                    if host not in self._notified_handlers[handler_name]:
-                        self._notified_handlers[handler_name].append(host)
+                    if task_result._host not in self._notified_handlers[handler_name]:
+                        self._notified_handlers[handler_name].append(task_result._host)
 
                 elif result[0] == 'register_host_var':
                     # essentially the same as 'set_host_var' below, however we
diff --git a/test/integration/roles/test_conditionals/tasks/main.yml b/test/integration/roles/test_conditionals/tasks/main.yml
index 2ba008cc9e..4a2420408a 100644
--- a/test/integration/roles/test_conditionals/tasks/main.yml
+++ b/test/integration/roles/test_conditionals/tasks/main.yml
@@ -274,13 +274,12 @@
     with_items: "{{cond_bad_attribute.results}}"
     register: result
   - set_fact: skipped_bad_attribute=False
+  - name: assert the task was skipped
+    assert:
+      that:
+      - skipped_bad_attribute
   when: cond_bad_attribute is defined and 'results' in cond_bad_attribute
 
-- name: assert the task was skipped
-  assert:
-    that:
-    - skipped_bad_attribute
-
 - name: test a with_items loop skipping a single item
   debug: var=item
   with_items: cond_list_of_items.results

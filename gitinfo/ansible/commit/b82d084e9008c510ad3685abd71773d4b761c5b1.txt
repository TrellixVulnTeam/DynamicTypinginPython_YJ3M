commit b82d084e9008c510ad3685abd71773d4b761c5b1
Author: Ansible Core Team <info@ansible.com>
Date:   Mon Mar 9 09:40:36 2020 +0000

    Migrated to skydive.skydive

diff --git a/lib/ansible/module_utils/network/skydive/api.py b/lib/ansible/module_utils/network/skydive/api.py
deleted file mode 100644
index 951ec9498e..0000000000
--- a/lib/ansible/module_utils/network/skydive/api.py
+++ /dev/null
@@ -1,366 +0,0 @@
-# This code is part of Ansible, but is an independent component.
-# This particular file snippet, and this file snippet only, is BSD licensed.
-# Modules you write using this snippet, which is embedded dynamically by Ansible
-# still belong to the author of the module, and may assign their own license
-# to the complete work.
-#
-# (c) 2019 Red Hat Inc.
-#
-# Redistribution and use in source and binary forms, with or without modification,
-# are permitted provided that the following conditions are met:
-#
-#    * Redistributions of source code must retain the above copyright
-#      notice, this list of conditions and the following disclaimer.
-#    * Redistributions in binary form must reproduce the above copyright notice,
-#      this list of conditions and the following disclaimer in the documentation
-#      and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
-# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-#
-
-import os
-import uuid
-
-from ansible.module_utils.six import iteritems
-from ansible.module_utils.six import iterkeys
-from ansible.module_utils._text import to_text
-from ansible.module_utils.basic import env_fallback
-
-try:
-    from skydive.graph import Node, Edge
-    from skydive.rest.client import RESTClient
-    from skydive.websocket.client import NodeAddedMsgType, NodeUpdatedMsgType, NodeDeletedMsgType
-    from skydive.websocket.client import EdgeAddedMsgType, EdgeUpdatedMsgType, EdgeDeletedMsgType
-    from skydive.websocket.client import WSClient, WSClientDefaultProtocol, WSMessage
-    HAS_SKYDIVE_CLIENT = True
-except ImportError:
-    HAS_SKYDIVE_CLIENT = False
-
-# defining skydive constants
-SKYDIVE_GREMLIN_QUERY = 'G.V().Has'
-SKYDIVE_GREMLIN_EDGE_QUERY = 'G.E().Has'
-
-SKYDIVE_PROVIDER_SPEC = {
-    'endpoint': dict(fallback=(env_fallback, ['SKYDIVE_ENDPOINT'])),
-    'username': dict(fallback=(env_fallback, ['SKYDIVE_USERNAME'])),
-    'password': dict(fallback=(env_fallback, ['SKYDIVE_PASSWORD']), no_log=True),
-    'insecure': dict(type='bool', default=False, fallback=(env_fallback, ['SKYDIVE_INSECURE'])),
-    'ssl': dict(type='bool', default=False, fallback=(env_fallback, ['SKYDIVE_SSL']))
-}
-
-
-class skydive_client_check(object):
-    """ Base class for implementing Skydive Rest API """
-
-    provider_spec = {'provider': dict(type='dict', options=SKYDIVE_PROVIDER_SPEC)}
-
-    def __init__(self, **kwargs):
-        ''' Base class for implementing Skydive Rest API '''
-        if not HAS_SKYDIVE_CLIENT:
-            raise Exception('skydive-client is required but does not appear '
-                            'to be installed.  It can be installed using the '
-                            'command `pip install skydive-client`')
-
-        if not set(kwargs.keys()).issubset(SKYDIVE_PROVIDER_SPEC.keys()):
-            raise Exception('invalid or unsupported keyword argument for skydive_restclient connection.')
-        for key, value in iteritems(SKYDIVE_PROVIDER_SPEC):
-            if key not in kwargs:
-                # apply default values from SKYDIVE_PROVIDER_SPEC since we cannot just
-                # assume the provider values are coming from AnsibleModule
-                if 'default' in value:
-                    kwargs[key] = value['default']
-                # override any values with env variables unless they were
-                # explicitly set
-                env = ('SKYDIVE_%s' % key).upper()
-                if env in os.environ:
-                    kwargs[key] = os.environ.get(env)
-
-
-class skydive_inject_protocol(object):
-    """ Implements inject protocol for node and edge modules """
-
-    def onOpen(self):
-        module = self.factory.kwargs["module"]
-        params = self.factory.kwargs["params"]
-        result = self.factory.kwargs["result"]
-        if "node1" and "node2" in self.factory.kwargs:
-            node1 = self.factory.kwargs["node1"]
-            node2 = self.factory.kwargs["node2"]
-
-        if module.check_mode:
-            self.stop()
-            return
-        try:
-            host = params["host"]
-            if params["metadata"]:
-                metadata = module._check_type_dict(params["metadata"])
-            else:
-                metadata = {}
-            if "node_type" in params:
-                metadata["Name"] = params["name"]
-                metadata["Type"] = params["node_type"]
-                seed = params["seed"]
-                if not seed:
-                    seed = "%s:%s" % (params["name"], params["node_type"])
-                if module.params['state'] == 'present' or module.params['state'] == 'update':
-                    uid = str(uuid.uuid5(uuid.NAMESPACE_OID, seed))
-                    node = Node(uid, host, metadata=metadata)
-                    if module.params['state'] == 'present':
-                        msg = WSMessage("Graph", NodeAddedMsgType, node)
-                    else:
-                        msg = WSMessage("Graph", NodeUpdatedMsgType, node)
-                else:
-                    uid = params['id']
-                    node = Node(uid, host, metadata=metadata)
-                    msg = WSMessage("Graph", NodeDeletedMsgType, node)
-            elif "relation_type" in params:
-                metadata["RelationType"] = params["relation_type"]
-                if module.params['state'] == 'present' or module.params['state'] == 'update':
-                    uid = str(uuid.uuid5(uuid.NAMESPACE_OID, "%s:%s:%s" %
-                                         (node1, node2, params["relation_type"])))
-                    edge = Edge(uid, host, node1, node2, metadata=metadata)
-                    if module.params['state'] == 'present':
-                        msg = WSMessage("Graph", EdgeAddedMsgType, edge)
-                    else:
-                        msg = WSMessage("Graph", EdgeUpdatedMsgType, edge)
-                else:
-                    uid = module.params['id']
-                    edge = Edge(uid, host, node1, node2, metadata=metadata)
-                    msg = WSMessage("Graph", EdgeDeletedMsgType, edge)
-
-            self.sendWSMessage(msg)
-            if uid:
-                result["UUID"] = uid
-            result["changed"] = True
-        except Exception as e:
-            module.fail_json(
-                msg='Error during topology update %s' % e, **result)
-        finally:
-            self.stop()
-
-
-class skydive_wsclient(skydive_client_check):
-    """ Base class for implementing Skydive Websocket API """
-
-    def __init__(self, module, **kwargs):
-        super(skydive_wsclient, self).__init__(**kwargs)
-
-        class skydive_full_inject_protocol(skydive_inject_protocol, WSClientDefaultProtocol):
-            pass
-        kwargs['scheme'] = "ws"
-        if 'ssl' in kwargs:
-            if kwargs['ssl']:
-                kwargs['scheme'] = "wss"
-        if 'insecure' not in kwargs:
-            kwargs['insecure'] = False
-        scheme = kwargs['scheme']
-        self.result = dict(changed=False)
-        if "node_type" in module.params:
-            self.wsclient_object = WSClient("ansible-" + str(os.getpid()) + "-" + module.params['host'],
-                                            "%s://%s/ws/publisher" % (scheme, kwargs["endpoint"]),
-                                            protocol=type('skydive_full_inject_protocol', (skydive_inject_protocol,
-                                                                                           WSClientDefaultProtocol), dict()),
-                                            persistent=True,
-                                            insecure=kwargs["insecure"],
-                                            username=kwargs["username"],
-                                            password=kwargs["password"],
-                                            module=module,
-                                            params=module.params,
-                                            result=self.result)
-        elif "relation_type" in module.params:
-            self.parent_node = self.get_node_id(module.params['parent_node'])
-            self.child_node = self.get_node_id(module.params['child_node'])
-
-            self.wsclient_object = WSClient("ansible-" + str(os.getpid()) + "-" + module.params['host'],
-                                            "%s://%s/ws/publisher" % (scheme, kwargs["endpoint"]),
-                                            protocol=type('skydive_full_inject_protocol', (skydive_inject_protocol,
-                                                                                           WSClientDefaultProtocol), dict()),
-                                            persistent=True,
-                                            insecure=kwargs["insecure"],
-                                            username=kwargs["username"],
-                                            password=kwargs["password"],
-                                            module=module,
-                                            params=module.params,
-                                            node1=self.parent_node,
-                                            node2=self.child_node,
-                                            result=self.result)
-
-    def get_node_id(self, node_selector):
-        """ Checks if Gremlin expresssion is passed as input to get the nodes UUID """
-        if node_selector.startswith("G.") or node_selector.startswith("g."):
-            nodes = self.restclient_object.lookup_nodes(node_selector)
-            if len(nodes) == 0:
-                raise self.module.fail_json(msg=to_text("Node not found: {0}".format(node_selector)))
-            elif len(nodes) > 1:
-                raise self.module.fail_json(
-                    msg=to_text("Node selection should return only one node: {0}".format(node_selector)))
-            return str(nodes[0].id)
-        return node_selector
-
-
-class skydive_restclient(skydive_client_check):
-    """ Base class for implementing Skydive Rest API """
-
-    def __init__(self, **kwargs):
-        super(skydive_restclient, self).__init__(**kwargs)
-        kwargs['scheme'] = "http"
-        if 'ssl' in kwargs:
-            if kwargs['ssl']:
-                kwargs['scheme'] = "https"
-        if 'insecure' not in kwargs:
-            kwargs['insecure'] = False
-        self.restclient_object = RESTClient(kwargs['endpoint'],
-                                            scheme=kwargs['scheme'],
-                                            insecure=kwargs['insecure'],
-                                            username=kwargs['username'],
-                                            password=kwargs['password'])
-
-
-class skydive_lookup(skydive_restclient):
-    """ Implements Skydive Lookup queries """
-
-    provider_spec = {'provider': dict(type='dict', options=SKYDIVE_PROVIDER_SPEC)}
-
-    def __init__(self, provider):
-        super(skydive_lookup, self).__init__(**provider)
-        self.query_str = ""
-
-    def lookup_query(self, filter_data):
-        query_key = filter_data.keys()[0]
-        self.query_str = filter_data[query_key]
-        nodes = self.restclient_object.lookup_nodes(self.query_str)
-        result = []
-        for each in nodes:
-            result.append(each.__dict__)
-        if len(result) == 0:
-            raise Exception("Cannot find any entry for the input Gremlin query!")
-        return result
-
-
-class skydive_flow_capture(skydive_restclient):
-    """ Implements Skydive Flow capture modules """
-
-    def __init__(self, module):
-        self.module = module
-        provider = module.params['provider']
-
-        super(skydive_flow_capture, self).__init__(**provider)
-
-    def run(self, ib_spec):
-        state = self.module.params['state']
-        if state not in ('present', 'absent'):
-            self.module.fail_json(msg='state must be one of `present`, `absent`, got `%s`' % state)
-
-        result = {'changed': False}
-        obj_filter = dict([(k, self.module.params[k]) for k, v in iteritems(ib_spec) if v.get('ib_req')])
-
-        proposed_object = {}
-        for key in iterkeys(ib_spec):
-            if self.module.params[key] is not None:
-                proposed_object[key] = self.module.params[key]
-
-        if obj_filter['query']:
-            cature_query = obj_filter['query']
-        elif obj_filter['interface_name'] and obj_filter['type']:
-            cature_query = SKYDIVE_GREMLIN_QUERY + "('Name', '{0}', 'Type', '{1}')".format(obj_filter['interface_name'],
-                                                                                           obj_filter['type'])
-        else:
-            raise self.module.fail_json(msg="Interface name and Type is required if gremlin query is not defined!")
-
-        # to check current object ref for idempotency
-        captured_list_objs = self.restclient_object.capture_list()
-        current_ref_uuid = None
-        for each_capture in captured_list_objs:
-            if cature_query == each_capture.__dict__['query']:
-                current_ref_uuid = each_capture.__dict__['uuid']
-                break
-        if state == 'present':
-            if not current_ref_uuid:
-                try:
-                    self.restclient_object.capture_create(cature_query, obj_filter['capture_name'],
-                                                          obj_filter['description'], obj_filter['extra_tcp_metric'],
-                                                          obj_filter['ip_defrag'], obj_filter['reassemble_tcp'],
-                                                          obj_filter['layer_key_mode'])
-                except Exception as e:
-                    self.module.fail_json(msg=to_text(e))
-                result['changed'] = True
-        if state == 'absent':
-            if current_ref_uuid:
-                try:
-                    self.restclient_object.capture_delete(current_ref_uuid)
-                except Exception as e:
-                    self.module.fail_json(msg=to_text(e))
-                result['changed'] = True
-
-        return result
-
-
-class skydive_node(skydive_wsclient, skydive_restclient):
-    """ Implements Skydive Node modules """
-
-    def __init__(self, module):
-        self.module = module
-        provider = module.params['provider']
-        super(skydive_node, self).__init__(self.module, **provider)
-
-    def run(self):
-        try:
-            lookup_query = SKYDIVE_GREMLIN_QUERY + "('Name', '{0}', 'Type', '{1}')".format(self.module.params['name'],
-                                                                                           self.module.params['node_type'])
-            node_exists = self.restclient_object.lookup_nodes(lookup_query)
-
-            if not node_exists and self.module.params['state'] == 'present':
-                self.wsclient_object.connect()
-                self.wsclient_object.start()
-            elif len(node_exists) > 0 and self.module.params['state'] == 'update':
-                self.wsclient_object.connect()
-                self.wsclient_object.start()
-            elif len(node_exists) > 0 and self.module.params['state'] == 'absent':
-                self.module.params['id'] = node_exists[0].__dict__['id']
-                self.wsclient_object.connect()
-                self.wsclient_object.start()
-        except Exception as e:
-            self.module.fail_json(msg=to_text(e))
-        return self.result
-
-
-class skydive_edge(skydive_wsclient, skydive_restclient):
-    """ Implements Skydive Edge modules """
-
-    def __init__(self, module):
-        self.module = module
-        provider = module.params['provider']
-
-        super(skydive_edge, self).__init__(self.module, **provider)
-
-    def run(self):
-        try:
-            edge_exists = False
-            edge_query = SKYDIVE_GREMLIN_EDGE_QUERY + "('Parent', '{0}', 'Child', '{1}')".format(self.parent_node,
-                                                                                                 self.child_node)
-            query_result = self.restclient_object.lookup_edges(edge_query)
-            if query_result:
-                query_result = query_result[0].__dict__
-                edge_exists = True
-
-            if not edge_exists and self.module.params['state'] == 'present':
-                self.wsclient_object.connect()
-                self.wsclient_object.start()
-            elif edge_exists and self.module.params['state'] == 'update':
-                self.wsclient_object.connect()
-                self.wsclient_object.start()
-            elif edge_exists and self.module.params['state'] == 'absent':
-                self.module.params['id'] = query_result['id']
-                self.wsclient_object.connect()
-                self.wsclient_object.start()
-        except Exception as e:
-            self.module.fail_json(msg=to_text(e))
-        return self.result
diff --git a/lib/ansible/modules/network/skydive/skydive_capture.py b/lib/ansible/modules/network/skydive/skydive_capture.py
deleted file mode 100644
index 2e6a2a2f01..0000000000
--- a/lib/ansible/modules/network/skydive/skydive_capture.py
+++ /dev/null
@@ -1,180 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-
-# (c) 2019, Ansible by Red Hat, inc
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = """
----
-module: skydive_capture
-version_added: "2.8"
-author:
-  - "Sumit Jaiswal (@sjaiswal)"
-short_description: Module which manages flow capture on interfaces
-description:
-  - This module manages flow capture on interfaces. The Gremlin
-    expression is continuously evaluated which means that it is
-    possible to define a capture on nodes that do not exist yet.
-  - It is useful when you want to start a capture on all OpenvSwitch
-    whatever the number of Skydive agents you will start.
-  - While starting the capture, user can specify the capture name,
-    capture description and capture type optionally.
-requirements:
-  - skydive-client
-extends_documentation_fragment: skydive
-options:
-  query:
-    description:
-      - It's the complete gremlin query which the users can input,
-        I(G.V().Has('Name', 'eth0', 'Type', 'device')), to create
-        the capture. And, if the user directly inputs the gremlin
-        query then user is not required to input any other module
-        parameter as gremlin query takes care of creating the flow
-        capture.
-    required: false
-  interface_name:
-    description:
-      - To define flow capture interface name.
-    required: false
-  type:
-    description:
-      - To define flow capture interface type.
-    required: false
-  capture_name:
-    description:
-      - To define flow capture name.
-    required: false
-    default: ""
-  description:
-    description:
-      - Configures a text string to be associated with the instance
-        of this object.
-    default: ""
-  extra_tcp_metric:
-    description:
-      - To define flow capture ExtraTCPMetric.
-    type: bool
-    default: false
-  ip_defrag:
-    description:
-      - To define flow capture IPDefrag.
-    type: bool
-    default: false
-  reassemble_tcp:
-    description:
-      - To define flow capture ReassembleTCP.
-    type: bool
-    default: false
-  layer_key_mode:
-    description:
-      - To define flow capture Layer KeyMode.
-    type: str
-    default: L2
-  state:
-    description:
-      - State of the flow capture. If value is I(present) flow capture
-        will be created else if it is I(absent) it will be deleted.
-    default: present
-    choices:
-      - present
-      - absent
-"""
-
-EXAMPLES = """
-- name: start a new flow capture directly from gremlin query
-  skydive_capture:
-    query: G.V().Has('Name', 'eth0', 'Type', 'device')
-    state: present
-    provider:
-      endpoint: localhost:8082
-      username: admin
-      password: admin
-
-- name: stop the flow capture directly from gremlin query
-  skydive_capture:
-    query: G.V().Has('Name', 'eth0', 'Type', 'device')
-    state: absent
-    provider:
-      endpoint: localhost:8082
-      username: admin
-      password: admin
-
-- name: start a new flow capture from user's input
-  skydive_capture:
-    interface_name: Node1
-    type: myhost
-    capture_name: test_capture
-    description: test description
-    extra_tcp_metric: true
-    ip_defrag: true
-    reassemble_tcp: true
-    state: present
-    provider:
-      endpoint: localhost:8082
-      username: admin
-      password: admin
-
-- name: stop the flow capture
-  skydive_capture:
-    interface_name: Node1
-    type: myhost
-    capture_name: test_capture
-    description: test description
-    extra_tcp_metric: true
-    ip_defrag: true
-    reassemble_tcp: true
-    state: absent
-    provider:
-      endpoint: localhost:8082
-      username: admin
-      password: admin
-"""
-
-RETURN = """ # """
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.skydive.api import skydive_flow_capture
-
-
-def main():
-    ''' Main entry point for module execution
-    '''
-    ib_spec = dict(
-        query=dict(required=False, ib_req=True),
-        interface_name=dict(required=False, ib_req=True),
-        type=dict(required=False, ib_req=True),
-        capture_name=dict(required=False, default='', ib_req=True),
-        description=dict(default='', ib_req=True),
-        extra_tcp_metric=dict(type='bool', required=False, ib_req=True, default=False),
-        ip_defrag=dict(type='bool', required=False, ib_req=True, default=False),
-        reassemble_tcp=dict(type='bool', required=False, ib_req=True, default=False),
-        layer_key_mode=dict(required=False, ib_req=True, default='L2')
-    )
-
-    argument_spec = dict(
-        provider=dict(required=False),
-        state=dict(default='present', choices=['present', 'absent'])
-    )
-
-    argument_spec.update(ib_spec)
-    argument_spec.update(skydive_flow_capture.provider_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    skydive_obj = skydive_flow_capture(module)
-    result = skydive_obj.run(ib_spec)
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/skydive/skydive_edge.py b/lib/ansible/modules/network/skydive/skydive_edge.py
deleted file mode 100644
index 07efb5f06d..0000000000
--- a/lib/ansible/modules/network/skydive/skydive_edge.py
+++ /dev/null
@@ -1,198 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-
-# (c) 2019, Ansible by Red Hat, inc
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = """
----
-module: skydive_edge
-version_added: "2.8"
-author:
-  - "Sumit Jaiswal (@sjaiswal)"
-short_description: Module to add edges to Skydive topology
-description:
-  - This module handles setting up edges between two nodes based on the
-    relationship type to the Skydive topology.
-requirements:
-  - skydive-client
-extends_documentation_fragment: skydive
-options:
-  parent_node:
-    description:
-      - To defined the first node of the link, it can be either an ID or
-        a gremlin expression
-    required: true
-  child_node:
-    description:
-      - To defined the second node of the link, it can be either an ID or
-        a gremlin expression
-    required: true
-  relation_type:
-    description:
-      - To define relation type of the node I(ownership, layer2, layer3).
-    required: true
-  host:
-    description:
-      - To define the host of the node.
-    default: ""
-    required: False
-  metadata:
-    description:
-      - To define metadata for the edge.
-    required: false
-  state:
-    description:
-      - State of the Skydive Edge. If value is I(present) new edge
-        will be created else if it is I(absent) it will be deleted.
-    default: present
-    choices:
-      - present
-      - absent
-"""
-
-EXAMPLES = """
-- name: create tor
-  skydive_node:
-    name: 'TOR'
-    node_type: "fabric"
-    seed: TOR
-    metadata:
-      Model: Cisco xxxx
-    provider:
-      endpoint: localhost:8082
-      username: admin
-      password: admin
-  register: tor_result
-
-- name: create port 1
-  skydive_node:
-    name: 'PORT1'
-    node_type: 'fabric'
-    seed: PORT1
-    provider:
-      endpoint: localhost:8082
-      username: admin
-      password: admin
-  register: port1_result
-
-- name: create port 2
-  skydive_node:
-    name: 'PORT2'
-    node_type: 'fabric'
-    seed: PORT2
-    provider:
-      endpoint: localhost:8082
-      username: admin
-      password: admin
-  register: port2_result
-
-- name: link node tor and port 1
-  skydive_edge:
-    parent_node: "{{ tor_result.UUID }}"
-    child_node: "{{ port1_result.UUID }}"
-    relation_type: ownership
-    state: present
-    provider:
-      endpoint: localhost:8082
-      username: admin
-      password: admin
-
-- name: link node tor and port 2
-  skydive_edge:
-    parent_node: "{{ tor_result.UUID }}"
-    child_node: "{{ port2_result.UUID }}"
-    relation_type: ownership
-    state: present
-    provider:
-      endpoint: localhost:8082
-      username: admin
-      password: admin
-
-- name: update link node tor and port 1 relation
-  skydive_edge:
-    parent_node: "{{ tor_result.UUID }}"
-    child_node: "{{ port2_result.UUID }}"
-    relation_type: layer2
-    state: upadte
-    provider:
-      endpoint: localhost:8082
-      username: admin
-      password: admin
-
-- name: Unlink tor and port 2
-  skydive_edge:
-    parent_node: "{{ tor_result.UUID }}"
-    child_node: "{{ port2_result.UUID }}"
-    relation_type: ownership
-    state: absent
-    provider:
-      endpoint: localhost:8082
-      username: admin
-      password: admin
-
-- name: link tor and port 2 via Gremlin expression
-  skydive_edge:
-    parent_node: G.V().Has('Name', 'TOR')
-    child_node: G.V().Has('Name', 'PORT2')
-    relation_type: ownership
-    state: present
-    provider:
-      endpoint: localhost:8082
-      username: admin
-      password: admin
-
-- name: Unlink tor and port 2 via Gremlin expression
-  skydive_edge:
-    parent_node: G.V().Has('Name', 'TOR')
-    child_node: G.V().Has('Name', 'PORT2')
-    relation_type: ownership
-    state: absent
-    provider:
-      endpoint: localhost:8082
-      username: admin
-      password: admin
-"""
-
-RETURN = """ # """
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.skydive.api import skydive_edge
-
-
-def main():
-    ''' Main entry point for module execution
-    '''
-    ib_spec = dict(
-        relation_type=dict(type='str', required=True),
-        parent_node=dict(type='str', required=True),
-        child_node=dict(type='str', required=True),
-        host=dict(type='str', default=""),
-        metadata=dict(type='dict', default=dict())
-    )
-
-    argument_spec = dict(
-        provider=dict(required=False),
-        state=dict(default='present', choices=['present', 'absent'])
-    )
-
-    argument_spec.update(ib_spec)
-    argument_spec.update(skydive_edge.provider_spec)
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    skydive_obj = skydive_edge(module)
-    result = skydive_obj.run()
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/skydive/skydive_node.py b/lib/ansible/modules/network/skydive/skydive_node.py
deleted file mode 100644
index 59ba788998..0000000000
--- a/lib/ansible/modules/network/skydive/skydive_node.py
+++ /dev/null
@@ -1,133 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-
-# (c) 2019, Ansible by Red Hat, inc
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = """
----
-module: skydive_node
-version_added: "2.8"
-author:
-  - "Sumit Jaiswal (@sjaiswal)"
-short_description: Module which add nodes to Skydive topology
-description:
-  - This module handles adding node to the Skydive topology.
-requirements:
-  - skydive-client
-extends_documentation_fragment: skydive
-options:
-  name:
-    description:
-      - To define name for the node.
-    required: true
-  node_type:
-    description:
-      - To define type for the node.
-    required: true
-  host:
-    description:
-      - To define host for the node.
-    required: false
-  seed:
-    description:
-      - used to generate the UUID of the node
-    default: ""
-  metadata:
-    description:
-      - To define metadata for the node.
-    required: false
-  state:
-    description:
-      - State of the Skydive Node. If value is I(present) new node
-        will be created else if it is I(absent) it will be deleted.
-    default: present
-    choices:
-      - present
-      - update
-      - absent
-"""
-
-EXAMPLES = """
-- name: create tor node
-  skydive_node:
-    name: TOR
-    node_type: fabric
-    seed: TOR1
-    metadata:
-      Model: Cisco 5300
-    state: present
-    provider:
-      endpoint: localhost:8082
-      username: admin
-      password: admin
-
-- name: update tor node
-  skydive_node:
-    name: TOR
-    node_type: host
-    seed: TOR1
-    metadata:
-      Model: Cisco 3400
-    state: update
-    provider:
-      endpoint: localhost:8082
-      username: admin
-      password: admin
-
-- name: Delete the tor node
-  skydive_node:
-    name: TOR
-    node_type: host
-    seed: TOR1
-    metadata:
-      Model: Cisco 3400
-    state: absent
-    provider:
-      endpoint: localhost:8082
-      username: admin
-      password: admin
-"""
-
-RETURN = """ # """
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.skydive.api import skydive_node
-
-
-def main():
-    ''' Main entry point for module execution
-    '''
-    ib_spec = dict(
-        name=dict(required=True, ib_req=True),
-        node_type=dict(required=True, ib_req=True),
-        host=dict(required=False, ib_req=True, default=""),
-        seed=dict(required=False, ib_req=True, default=""),
-        metadata=dict(required=False, ib_req=True, default=dict())
-    )
-
-    argument_spec = dict(
-        provider=dict(required=False),
-        state=dict(default='present', choices=['present', 'update', 'absent'])
-    )
-
-    argument_spec.update(ib_spec)
-    argument_spec.update(skydive_node.provider_spec)
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    skydive_obj = skydive_node(module)
-    result = skydive_obj.run()
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/plugins/doc_fragments/skydive.py b/lib/ansible/plugins/doc_fragments/skydive.py
deleted file mode 100644
index c4abb7ed21..0000000000
--- a/lib/ansible/plugins/doc_fragments/skydive.py
+++ /dev/null
@@ -1,55 +0,0 @@
-#
-# (c) 2019, Sumit Jaiswal (@sjaiswal)
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-
-class ModuleDocFragment(object):
-
-    # Standard files documentation fragment
-    DOCUMENTATION = """
-options:
-  provider:
-    description:
-      - A dict object containing connection details.
-    suboptions:
-      endpoint:
-        description:
-          - Specifies the hostname/address along with the port as C(localhost:8082)for
-            connecting to the remote instance of SKYDIVE client over the REST API.
-        required: true
-      user:
-        description:
-          - Configures the username to use to authenticate the connection to
-            the remote instance of SKYDIVE client.
-      password:
-        description:
-          - Specifies the password to use to authenticate the connection to
-            the remote instance of SKYDIVE client.
-      insecure:
-        description:
-          - Ignore SSL certification verification.
-        type: bool
-        default: false
-      ssl:
-        description:
-          - Specifies the ssl parameter that decides if the connection type shall be
-            http or https.
-        type: bool
-        default: false
-notes:
-  - "This module must be run locally, which can be achieved by specifying C(connection: local)."
-"""
diff --git a/lib/ansible/plugins/lookup/skydive.py b/lib/ansible/plugins/lookup/skydive.py
deleted file mode 100644
index cefdc78121..0000000000
--- a/lib/ansible/plugins/lookup/skydive.py
+++ /dev/null
@@ -1,79 +0,0 @@
-#
-#  Copyright 2018 Red Hat | Ansible
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-from __future__ import (absolute_import, division, print_function)
-
-__metaclass__ = type
-
-DOCUMENTATION = """
----
-lookup: skydive
-version_added: "2.8"
-short_description: Query Skydive objects
-description:
-  - Uses the Skydive python REST client to return the queried object from
-    Skydive network analyzer.
-requirements:
-  - skydive-client
-extends_documentation_fragment: skydive
-options:
-    filter:
-      description: a dict object that is used to filter the return objects
-"""
-
-EXAMPLES = r"""
-- name: return skydive metdata if present based on Name
-  set_fact:
-    skydive_meta: >-
-        {{ lookup('skydive', filter={'query': "G.V().Has('Name', 'sumit-VirtualBox')"}) }}
-
-- name: return all the skydive metdata having parameter Name
-  set_fact:
-    skydive: >-
-        {{ lookup('skydive', filter={'query': "G.V().Has('Name')"},
-                      provider={'endpoint': 'localhost:8082', 'username': 'admin', 'password': 'password'}) }}
-"""
-
-RETURN = """
-_list:
-  description:
-    - The list of queried object metadata
-  returned: always
-  type: list
-"""
-
-
-from ansible.plugins.lookup import LookupBase
-from ansible.module_utils.network.skydive.api import skydive_lookup
-from ansible.module_utils._text import to_text
-from ansible.errors import AnsibleError
-
-
-class LookupModule(LookupBase):
-
-    def run(self, terms, variables=None, **kwargs):
-
-        provider = kwargs.pop('provider', {})
-        filter_data = kwargs.pop('filter', {})
-        try:
-            skydive_obj = skydive_lookup(provider)
-            result = skydive_obj.lookup_query(filter_data)
-        except Exception as exc:
-            raise AnsibleError(to_text(exc))
-
-        return [result]
diff --git a/test/sanity/ignore.txt b/test/sanity/ignore.txt
index ed02beeb3e..fa5c130eab 100644
--- a/test/sanity/ignore.txt
+++ b/test/sanity/ignore.txt
@@ -84,8 +84,6 @@ lib/ansible/module_utils/gcp_utils.py future-import-boilerplate
 lib/ansible/module_utils/gcp_utils.py metaclass-boilerplate
 lib/ansible/module_utils/json_utils.py future-import-boilerplate
 lib/ansible/module_utils/json_utils.py metaclass-boilerplate
-lib/ansible/module_utils/network/skydive/api.py future-import-boilerplate
-lib/ansible/module_utils/network/skydive/api.py metaclass-boilerplate
 lib/ansible/module_utils/network/vyos/vyos.py future-import-boilerplate
 lib/ansible/module_utils/network/vyos/vyos.py metaclass-boilerplate
 lib/ansible/module_utils/parsing/convert_bool.py future-import-boilerplate
@@ -1046,23 +1044,6 @@ lib/ansible/modules/network/ovs/openvswitch_db.py validate-modules:doc-missing-t
 lib/ansible/modules/network/ovs/openvswitch_db.py validate-modules:parameter-type-not-in-doc
 lib/ansible/modules/network/ovs/openvswitch_port.py validate-modules:doc-missing-type
 lib/ansible/modules/network/ovs/openvswitch_port.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/skydive/skydive_capture.py validate-modules:doc-missing-type
-lib/ansible/modules/network/skydive/skydive_capture.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/skydive/skydive_capture.py validate-modules:invalid-ansiblemodule-schema
-lib/ansible/modules/network/skydive/skydive_capture.py validate-modules:nonexistent-parameter-documented
-lib/ansible/modules/network/skydive/skydive_capture.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/skydive/skydive_capture.py validate-modules:undocumented-parameter
-lib/ansible/modules/network/skydive/skydive_edge.py validate-modules:doc-missing-type
-lib/ansible/modules/network/skydive/skydive_edge.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/skydive/skydive_edge.py validate-modules:nonexistent-parameter-documented
-lib/ansible/modules/network/skydive/skydive_edge.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/skydive/skydive_edge.py validate-modules:undocumented-parameter
-lib/ansible/modules/network/skydive/skydive_node.py validate-modules:doc-missing-type
-lib/ansible/modules/network/skydive/skydive_node.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/skydive/skydive_node.py validate-modules:invalid-ansiblemodule-schema
-lib/ansible/modules/network/skydive/skydive_node.py validate-modules:nonexistent-parameter-documented
-lib/ansible/modules/network/skydive/skydive_node.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/skydive/skydive_node.py validate-modules:undocumented-parameter
 lib/ansible/modules/network/vyos/_vyos_interface.py future-import-boilerplate
 lib/ansible/modules/network/vyos/_vyos_interface.py metaclass-boilerplate
 lib/ansible/modules/network/vyos/_vyos_interface.py validate-modules:doc-choices-do-not-match-spec
@@ -1347,8 +1328,6 @@ lib/ansible/plugins/doc_fragments/shell_common.py future-import-boilerplate
 lib/ansible/plugins/doc_fragments/shell_common.py metaclass-boilerplate
 lib/ansible/plugins/doc_fragments/shell_windows.py future-import-boilerplate
 lib/ansible/plugins/doc_fragments/shell_windows.py metaclass-boilerplate
-lib/ansible/plugins/doc_fragments/skydive.py future-import-boilerplate
-lib/ansible/plugins/doc_fragments/skydive.py metaclass-boilerplate
 lib/ansible/plugins/doc_fragments/url.py future-import-boilerplate
 lib/ansible/plugins/doc_fragments/url.py metaclass-boilerplate
 lib/ansible/plugins/doc_fragments/validate.py future-import-boilerplate

commit 171a67cfefc77ee535809974dcc9fcc3e2d141dc
Author: James Cammarata <jimi@sngx.net>
Date:   Thu Jan 29 10:55:00 2015 -0600

    Tweaking role path searching in v2 to be a bit more like v1

diff --git a/v2/ansible/parsing/__init__.py b/v2/ansible/parsing/__init__.py
index 861ab57acd..f8a3e96746 100644
--- a/v2/ansible/parsing/__init__.py
+++ b/v2/ansible/parsing/__init__.py
@@ -26,11 +26,11 @@ from yaml import load, YAMLError
 
 from ansible.errors import AnsibleParserError
 from ansible.errors.yaml_strings import YAML_SYNTAX_ERROR
-
 from ansible.parsing.vault import VaultLib
 from ansible.parsing.splitter import unquote
 from ansible.parsing.yaml.loader import AnsibleLoader
 from ansible.parsing.yaml.objects import AnsibleBaseYAMLObject
+from ansible.utils.path import unfrackpath
 
 class DataLoader():
 
@@ -179,8 +179,7 @@ class DataLoader():
 
         basedir = os.path.dirname(role_path)
         if os.path.islink(basedir):
-            # FIXME: implement unfrackpath
-            #basedir = unfrackpath(basedir)
+            basedir = unfrackpath(basedir)
             template2 = os.path.join(basedir, dirname, source)
         else:
             template2 = os.path.join(basedir, '..', dirname, source)
diff --git a/v2/ansible/playbook/role/definition.py b/v2/ansible/playbook/role/definition.py
index f91c2dfed5..c9ec4259c1 100644
--- a/v2/ansible/playbook/role/definition.py
+++ b/v2/ansible/playbook/role/definition.py
@@ -30,6 +30,7 @@ from ansible.playbook.attribute import Attribute, FieldAttribute
 from ansible.playbook.base import Base
 from ansible.playbook.conditional import Conditional
 from ansible.playbook.taggable import Taggable
+from ansible.utils.path import unfrackpath
 
 
 __all__ = ['RoleDefinition']
@@ -113,30 +114,28 @@ class RoleDefinition(Base, Conditional, Taggable):
         append it to the default role path
         '''
 
-        # FIXME: this should use unfrackpath once the utils code has been sorted out
-        role_path = os.path.normpath(role_name)
+        role_path = unfrackpath(role_name)
 
         if self._loader.path_exists(role_path):
             role_name = os.path.basename(role_name)
             return (role_name, role_path)
         else:
             # we always start the search for roles in the base directory of the playbook
-            role_search_paths = [os.path.join(self._loader.get_basedir(), 'roles'), './roles']
+            role_search_paths = [os.path.join(self._loader.get_basedir(), 'roles'), './roles', './']
 
             # also search in the configured roles path
-            configured_paths = C.DEFAULT_ROLES_PATH
-            if ':' in configured_paths:
-                configured_paths = configured_paths.split(':')
+            if C.DEFAULT_ROLES_PATH:
+                configured_paths = C.DEFAULT_ROLES_PATH.split(os.pathsep)
                 role_search_paths.extend(configured_paths)
-            else:
-                role_search_paths.append(configured_paths)
 
-            print("role search paths are: %s" % role_search_paths)
+            # finally, append the roles basedir, if it was set, so we can
+            # search relative to that directory for dependent roles
             if self._role_basedir:
-                role_search_paths = [self._role_basedir] + role_search_paths
+                role_search_paths.append(self._role_basedir)
 
+            # now iterate through the possible paths and return the first one we find
             for path in role_search_paths:
-                role_path = os.path.join(path, role_name)
+                role_path = unfrackpath(os.path.join(path, role_name))
                 if self._loader.path_exists(role_path):
                     return (role_name, role_path)
 
diff --git a/v2/ansible/utils/path.py b/v2/ansible/utils/path.py
index ad6e054727..ea7fc201a8 100644
--- a/v2/ansible/utils/path.py
+++ b/v2/ansible/utils/path.py
@@ -18,9 +18,18 @@
 import os
 import stat
 
-__all__ = ['is_executable']
+__all__ = ['is_executable', 'unfrackpath']
 
 def is_executable(path):
     '''is the given path executable?'''
     return (stat.S_IXUSR & os.stat(path)[stat.ST_MODE] or stat.S_IXGRP & os.stat(path)[stat.ST_MODE] or stat.S_IXOTH & os.stat(path)[stat.ST_MODE])
 
+def unfrackpath(path):
+    '''
+    returns a path that is free of symlinks, environment
+    variables, relative path traversals and symbols (~)
+    example:
+    '$HOME/../../var/mail' becomes '/var/spool/mail'
+    '''
+    return os.path.normpath(os.path.realpath(os.path.expandvars(os.path.expanduser(path))))
+

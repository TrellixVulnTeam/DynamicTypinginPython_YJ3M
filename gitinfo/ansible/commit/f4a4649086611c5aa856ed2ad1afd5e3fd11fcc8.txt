commit f4a4649086611c5aa856ed2ad1afd5e3fd11fcc8
Author: Michael DeHaan <michael.dehaan@gmail.com>
Date:   Tue Jul 24 19:03:18 2012 -0400

    Port async_status to use the new common code.

diff --git a/library/async_status b/library/async_status
index 33c09e653c..15c1fb527f 100755
--- a/library/async_status
+++ b/library/async_status
@@ -18,96 +18,54 @@
 # along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
 #
 
-try:
-    import json
-except ImportError:
-    import simplejson as json
-import shlex
-import os
-import subprocess
-import sys
 import datetime
 import traceback
-import syslog
-
-# ===========================================
-
-# FIXME: better error handling
-
-argsfile = sys.argv[1]
-args = open(argsfile, 'r').read()
-items = shlex.split(args)
-
-syslog.openlog('ansible-%s' % os.path.basename(__file__))
-syslog.syslog(syslog.LOG_NOTICE, 'Invoked with %s' % args)
-
-params = {}
-for x in items:
-    (k, v) = x.split("=")
-    params[k] = v
-
-mode = params.get('mode', 'status')
-jid  = params.get('jid', None)
-
-# ===========================================
-
-if jid is None:
-    print json.dumps({
-        "failed" : True,
-        "msg"    : "jid=INTEGER is required"
-    })
-    sys.exit(1)
-
-
-# setup logging directory
-logdir = os.path.expanduser("~/.ansible_async")
-log_path = os.path.join(logdir, jid)
-
-if not os.path.exists(log_path):
-    print json.dumps({
-        "failed" : 1,
-        "msg" : "could not find job",
-        "ansible_job_id" : jid
-    })
-    sys.exit(1)
-
-if mode == 'cleanup':
-    os.unlink(log_path)
-    print json.dumps({
-        "ansible_job_id" : jid,
-        "erased" : log_path
-    })
-    sys.exit(0)
-
-# NOT in cleanup mode, assume regular status mode
-# no remote kill mode currently exists, but probably should
-# consider log_path + ".pid" file and also unlink that above
-
-data = file(log_path).read()
-try:
-   data = json.loads(data)
-except Exception, e:
-   if data == '':
-       # file not written yet?  That means it is running
-       print json.dumps({
-           "results_file" : log_path,
-           "ansible_job_id" : jid,
-           "started" : 1,
-       })
-   else:
-       print json.dumps({
-           "failed" : True,
-           "ansible_job_id" : jid,
-           "results_file" : log_path,
-           "msg" : "Could not parse job output: %s" % data,
-       })
-   sys.exit(0)
-
-if not data.has_key("started"):
-   data['finished'] = 1
-data['ansible_job_id'] = jid
-
-print json.dumps(data)
-sys.exit(0)
+
+def main():
+
+    module = AnsibleModule(argument_spec=dict(
+        jid=dict(required=True),
+        mode=dict(default='status', choices=['status','cleanup']),
+    ))
+
+    mode = module.params['mode']
+    jid  = module.params['jid']
+
+    # setup logging directory
+    logdir = os.path.expanduser("~/.ansible_async")
+    log_path = os.path.join(logdir, jid)
+
+    if not os.path.exists(log_path):
+        module.fail_json(msg="could not find job", ansible_job_id=jid)
+
+    if mode == 'cleanup':
+        os.unlink(log_path)
+        module.exit_json(ansible_job_id=jid, erased=log_path)
+
+    # NOT in cleanup mode, assume regular status mode
+    # no remote kill mode currently exists, but probably should
+    # consider log_path + ".pid" file and also unlink that above
+
+    data = file(log_path).read()
+    try:
+        data = json.loads(data)
+    except Exception, e:
+        if data == '':
+            # file not written yet?  That means it is running
+            module.exit_json(results_file=log_path, ansible_job_id=jid, started=1)
+        else:
+            module_fail_json(ansible_job_id=jid, results_file=log_path, 
+                msg="Could not parse job output: %s" % data)
+
+    if not data.has_key("started"):
+        data['finished'] = 1
+        data['ansible_job_id'] = jid
+    module.exit_json(**data)
+
+# this is magic, see lib/ansible/module_common.py
+#<<INCLUDE_ANSIBLE_MODULE_COMMON>>
+main()
+
+
 
 

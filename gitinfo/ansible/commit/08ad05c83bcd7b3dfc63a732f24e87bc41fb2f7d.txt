commit 08ad05c83bcd7b3dfc63a732f24e87bc41fb2f7d
Author: James Cammarata <jimi@sngx.net>
Date:   Thu Jul 2 02:50:57 2015 -0400

    Make sure callbacks are loaded in the tqm a bit earlier
    
    Fixes #11463

diff --git a/lib/ansible/executor/playbook_executor.py b/lib/ansible/executor/playbook_executor.py
index cf9b6a0290..91d5a69fc1 100644
--- a/lib/ansible/executor/playbook_executor.py
+++ b/lib/ansible/executor/playbook_executor.py
@@ -122,6 +122,9 @@ class PlaybookExecutor:
                         entry['plays'].append(p)
 
                     else:
+                        # make sure the tqm has callbacks loaded
+                        self._tqm.load_callbacks()
+
                         # we are actually running plays
                         for batch in self._get_serialized_batches(new_play):
                             if len(batch) == 0:
diff --git a/lib/ansible/executor/task_queue_manager.py b/lib/ansible/executor/task_queue_manager.py
index c3143a3004..cdee3f045e 100644
--- a/lib/ansible/executor/task_queue_manager.py
+++ b/lib/ansible/executor/task_queue_manager.py
@@ -61,6 +61,7 @@ class TaskQueueManager:
         self._stats            = AggregateStats()
         self.passwords         = passwords
         self._stdout_callback  = stdout_callback
+        self._callback_plugins = []
 
         # a special flag to help us exit cleanly
         self._terminated = False
@@ -115,21 +116,19 @@ class TaskQueueManager:
         for handler in handler_list:
             self._notified_handlers[handler.get_name()] = []
 
-    def _load_callbacks(self, stdout_callback):
+    def load_callbacks(self):
         '''
         Loads all available callbacks, with the exception of those which
         utilize the CALLBACK_TYPE option. When CALLBACK_TYPE is set to 'stdout',
         only one such callback plugin will be loaded.
         '''
 
-        loaded_plugins = []
-
         stdout_callback_loaded = False
-        if stdout_callback is None:
-            stdout_callback = C.DEFAULT_STDOUT_CALLBACK
+        if self._stdout_callback is None:
+            self._stdout_callback = C.DEFAULT_STDOUT_CALLBACK
 
-        if stdout_callback not in callback_loader:
-            raise AnsibleError("Invalid callback for stdout specified: %s" % stdout_callback)
+        if self._stdout_callback not in callback_loader:
+            raise AnsibleError("Invalid callback for stdout specified: %s" % self._stdout_callback)
 
         for callback_plugin in callback_loader.all(class_only=True):
             if hasattr(callback_plugin, 'CALLBACK_VERSION') and callback_plugin.CALLBACK_VERSION >= 2.0:
@@ -139,17 +138,15 @@ class TaskQueueManager:
                 callback_type = getattr(callback_plugin, 'CALLBACK_TYPE', None)
                 (callback_name, _) = os.path.splitext(os.path.basename(callback_plugin._original_path))
                 if callback_type == 'stdout':
-                    if callback_name != stdout_callback or stdout_callback_loaded:
+                    if callback_name != self._stdout_callback or stdout_callback_loaded:
                         continue
                     stdout_callback_loaded = True
                 elif C.DEFAULT_CALLBACK_WHITELIST is None or callback_name not in C.DEFAULT_CALLBACK_WHITELIST:
                     continue
 
-                loaded_plugins.append(callback_plugin(self._display))
+                self._callback_plugins.append(callback_plugin(self._display))
             else:
-                loaded_plugins.append(callback_plugin())
-
-        return loaded_plugins
+                self._callback_plugins.append(callback_plugin())
 
     def _do_var_prompt(self, varname, private=True, prompt=None, encrypt=None, confirm=False, salt_size=None, salt=None, default=None):
 
@@ -204,9 +201,6 @@ class TaskQueueManager:
         are done with the current task).
         '''
 
-        # load callback plugins
-        self._callback_plugins = self._load_callbacks(self._stdout_callback)
-
         if play.vars_prompt:
             for var in play.vars_prompt:
                 if 'name' not in var:

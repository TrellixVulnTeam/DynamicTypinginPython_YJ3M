commit bce281014cfc8aaa2675c129ca3117a360041e5c
Author: Matt Martz <matt@sivel.net>
Date:   Thu Jun 4 13:27:18 2015 -0500

    Decorate the ConnectionBase methods, switch to calling super from individual connection classes

diff --git a/lib/ansible/plugins/connections/__init__.py b/lib/ansible/plugins/connections/__init__.py
index da0775530d..1d3a2bdeed 100644
--- a/lib/ansible/plugins/connections/__init__.py
+++ b/lib/ansible/plugins/connections/__init__.py
@@ -92,16 +92,19 @@ class ConnectionBase(with_metaclass(ABCMeta, object)):
         """Connect to the host we've been initialized with"""
         pass
 
+    @ensure_connect
     @abstractmethod
     def exec_command(self, cmd, tmp_path, executable=None, in_data=None):
         """Run a command on the remote host"""
         pass
 
+    @ensure_connect
     @abstractmethod
     def put_file(self, in_path, out_path):
         """Transfer a file from local to remote"""
         pass
 
+    @ensure_connect
     @abstractmethod
     def fetch_file(self, in_path, out_path):
         """Fetch a file from remote to local"""
diff --git a/lib/ansible/plugins/connections/local.py b/lib/ansible/plugins/connections/local.py
index 1dc6076b0d..85bc51de0a 100644
--- a/lib/ansible/plugins/connections/local.py
+++ b/lib/ansible/plugins/connections/local.py
@@ -49,6 +49,8 @@ class Connection(ConnectionBase):
     def exec_command(self, cmd, tmp_path, executable='/bin/sh', in_data=None):
         ''' run a command on the local host '''
 
+        super(Connection, self).exec_command(cmd, tmp_path, executable=executable, in_data=in_data)
+
         debug("in local.exec_command()")
         # su requires to be run from a terminal, and therefore isn't supported here (yet?)
         #if self._connection_info.su:
@@ -108,6 +110,8 @@ class Connection(ConnectionBase):
     def put_file(self, in_path, out_path):
         ''' transfer a file from local to local '''
 
+        super(Connection, self).put_file(in_path, out_path)
+
         #vvv("PUT {0} TO {1}".format(in_path, out_path), host=self.host)
         self._display.vvv("{0} PUT {1} TO {2}".format(self._connection_info.remote_addr, in_path, out_path))
         if not os.path.exists(in_path):
@@ -123,6 +127,9 @@ class Connection(ConnectionBase):
 
     def fetch_file(self, in_path, out_path):
         ''' fetch a file from local to local -- for copatibility '''
+
+        super(Connection, self).fetch_file(in_path, out_path)
+
         #vvv("FETCH {0} TO {1}".format(in_path, out_path), host=self.host)
         self._display.vvv("{0} FETCH {1} TO {2}".format(self._connection_info.remote_addr, in_path, out_path))
         self.put_file(in_path, out_path)
diff --git a/lib/ansible/plugins/connections/paramiko_ssh.py b/lib/ansible/plugins/connections/paramiko_ssh.py
index 8beaecf492..5a5259c5fc 100644
--- a/lib/ansible/plugins/connections/paramiko_ssh.py
+++ b/lib/ansible/plugins/connections/paramiko_ssh.py
@@ -41,7 +41,7 @@ from binascii import hexlify
 
 from ansible import constants as C
 from ansible.errors import AnsibleError, AnsibleConnectionFailure, AnsibleFileNotFound
-from ansible.plugins.connections import ConnectionBase, ensure_connect
+from ansible.plugins.connections import ConnectionBase
 from ansible.utils.path import makedirs_safe
 
 AUTHENTICITY_MSG="""
@@ -189,10 +189,11 @@ class Connection(ConnectionBase):
 
         return ssh
 
-    @ensure_connect
     def exec_command(self, cmd, tmp_path, executable='/bin/sh', in_data=None):
         ''' run a command on the remote host '''
 
+        super(Connection, self).exec_command(cmd, tmp_path, executable=executable, in_data=in_data)
+
         if in_data:
             raise AnsibleError("Internal Error: this module does not support optimized module pipelining")
 
@@ -250,10 +251,11 @@ class Connection(ConnectionBase):
 
         return (chan.recv_exit_status(), '', no_prompt_out + stdout, no_prompt_out + stderr)
 
-    @ensure_connect
     def put_file(self, in_path, out_path):
         ''' transfer a file from local to remote '''
 
+        super(Connection, self).put_file(in_path, out_path)
+
         self._display.vvv("PUT %s TO %s" % (in_path, out_path), host=self._connection_info.remote_addr)
 
         if not os.path.exists(in_path):
@@ -278,10 +280,11 @@ class Connection(ConnectionBase):
             result = SFTP_CONNECTION_CACHE[cache_key] = self._connect().ssh.open_sftp()
             return result
 
-    @ensure_connect
     def fetch_file(self, in_path, out_path):
         ''' save a remote file to the specified path '''
 
+        super(Connection, self).fetch_file(in_path, out_path)
+
         self._display.vvv("FETCH %s TO %s" % (in_path, out_path), host=self._connection_info.remote_addr)
 
         try:
diff --git a/lib/ansible/plugins/connections/ssh.py b/lib/ansible/plugins/connections/ssh.py
index 5a435093d0..e2251ca5b0 100644
--- a/lib/ansible/plugins/connections/ssh.py
+++ b/lib/ansible/plugins/connections/ssh.py
@@ -34,7 +34,7 @@ from hashlib import sha1
 
 from ansible import constants as C
 from ansible.errors import AnsibleError, AnsibleConnectionFailure, AnsibleFileNotFound
-from ansible.plugins.connections import ConnectionBase, ensure_connect
+from ansible.plugins.connections import ConnectionBase
 
 
 class Connection(ConnectionBase):
@@ -270,10 +270,11 @@ class Connection(ConnectionBase):
             self._display.vvv("EXEC previous known host file not found for {0}".format(host))
         return True
 
-    @ensure_connect
     def exec_command(self, cmd, tmp_path, executable='/bin/sh', in_data=None):
         ''' run a command on the remote host '''
 
+        super(Connection, self).exec_command(cmd, tmp_path, executable=executable, in_data=in_data)
+
         ssh_cmd = self._password_cmd()
         ssh_cmd += ("ssh", "-C")
         if not in_data:
@@ -392,9 +393,11 @@ class Connection(ConnectionBase):
 
         return (p.returncode, '', no_prompt_out + stdout, no_prompt_err + stderr)
 
-    @ensure_connect
     def put_file(self, in_path, out_path):
         ''' transfer a file from local to remote '''
+
+        super(Connection, self).put_file(in_path, out_path)
+
         self._display.vvv("PUT {0} TO {1}".format(in_path, out_path), host=self._connection_info.remote_addr)
         if not os.path.exists(in_path):
             raise AnsibleFileNotFound("file or module does not exist: {0}".format(in_path))
@@ -428,9 +431,11 @@ class Connection(ConnectionBase):
         if returncode != 0:
             raise AnsibleError("failed to transfer file to {0}:\n{1}\n{2}".format(out_path, stdout, stderr))
 
-    @ensure_connect
     def fetch_file(self, in_path, out_path):
         ''' fetch a file from remote to local '''
+
+        super(Connection, self).fetch_file(in_path, out_path)
+
         self._display.vvv("FETCH {0} TO {1}".format(in_path, out_path), host=self._connection_info.remote_addr)
         cmd = self._password_cmd()
 
diff --git a/lib/ansible/plugins/connections/winrm.py b/lib/ansible/plugins/connections/winrm.py
index ee28749189..2bc1ee0053 100644
--- a/lib/ansible/plugins/connections/winrm.py
+++ b/lib/ansible/plugins/connections/winrm.py
@@ -42,7 +42,7 @@ except ImportError:
 
 from ansible import constants as C
 from ansible.errors import AnsibleError, AnsibleConnectionFailure, AnsibleFileNotFound
-from ansible.plugins.connections import ConnectionBase, ensure_connect
+from ansible.plugins.connections import ConnectionBase
 from ansible.plugins import shell_loader
 from ansible.utils.path import makedirs_safe
 
@@ -152,8 +152,8 @@ class Connection(ConnectionBase):
             self.protocol = self._winrm_connect()
         return self
 
-    @ensure_connect
     def exec_command(self, cmd, tmp_path, executable='/bin/sh', in_data=None):
+        super(Connection, self).exec_command(cmd, tmp_path, executable=executable, in_data,in_data)
 
         cmd = cmd.encode('utf-8')
         cmd_parts = shlex.split(cmd, posix=False)
@@ -174,8 +174,9 @@ class Connection(ConnectionBase):
             raise AnsibleError("failed to exec cmd %s" % cmd)
         return (result.status_code, '', result.std_out.encode('utf-8'), result.std_err.encode('utf-8'))
 
-    @ensure_connect
     def put_file(self, in_path, out_path):
+        super(Connection, self).put_file(in_path, out_path)
+
         self._display.vvv("PUT %s TO %s" % (in_path, out_path), host=self._connection_info.remote_addr)
         if not os.path.exists(in_path):
             raise AnsibleFileNotFound("file or module does not exist: %s" % in_path)
@@ -213,8 +214,9 @@ class Connection(ConnectionBase):
                     traceback.print_exc()
                     raise AnsibleError("failed to transfer file to %s" % out_path)
 
-    @ensure_connect
     def fetch_file(self, in_path, out_path):
+        super(Connection, self).fetch_file(in_path, out_path)
+
         out_path = out_path.replace('\\', '/')
         self._display.vvv("FETCH %s TO %s" % (in_path, out_path), host=self._connection_info.remote_addr)
         buffer_size = 2**19 # 0.5MB chunks

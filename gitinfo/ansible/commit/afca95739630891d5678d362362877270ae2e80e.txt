commit afca95739630891d5678d362362877270ae2e80e
Author: Robin Roth <robin@rroth.de>
Date:   Wed Dec 14 17:36:15 2016 +0100

    Fix UnboundLocalError remote_head in git (#19057)
    
    * Fix UnboundLocalError remote_head in git
    
    Fixes #5505
    
    The use of remote_head was a leftover of #4562.
    remote_head is not necessary, since the repo is unchanged anyway and
    after is set correctly.
    
    Further changes:
    * Set changed=True and msg once local_mods are detected and reset.
    * Remove need_fetch that is always True (due to previous if) to improve
    clarity
    * Don't exit early for local_mods but run submodules update and
    switch_version
    
    * Add test for git with local modifications

diff --git a/lib/ansible/modules/source_control/git.py b/lib/ansible/modules/source_control/git.py
index 659c0428cc..ad505ed7b3 100644
--- a/lib/ansible/modules/source_control/git.py
+++ b/lib/ansible/modules/source_control/git.py
@@ -888,7 +888,7 @@ def main():
     ssh_opts  = module.params['ssh_opts']
     umask  = module.params['umask']
 
-    result = dict( warnings=list() )
+    result = dict(changed = False, warnings=list())
 
     # evaluate and set the umask before doing anything else
     if umask is not None:
@@ -968,7 +968,7 @@ def main():
         # this does no checking that the repo is the actual repo
         # requested.
         result['before'] = get_version(module, git_path, dest)
-        result.update(changed=False, after=result['before'])
+        result.update(after=result['before'])
         module.exit_json(**result)
     else:
         # else do a pull
@@ -981,6 +981,7 @@ def main():
             # if force and in non-check mode, do a reset
             if not module.check_mode:
                 reset(git_path, module, dest)
+                result.update(changed=True, msg='Local modifications exist.')
 
         # exit if already at desired sha version
         if module.check_mode:
@@ -990,27 +991,20 @@ def main():
             remote_url_changed = set_remote_url(git_path, module, repo, dest, remote)
         result.update(remote_url_changed=remote_url_changed)
 
-        if need_fetch:
-            if module.check_mode:
-                remote_head = get_remote_head(git_path, module, dest, version, remote, bare)
-                result.update(changed=(result['before'] != remote_head), after=remote_head)
-                # FIXME: This diff should fail since the new remote_head is not fetched yet?!
-                if module._diff:
-                    diff = get_diff(module, git_path, dest, repo, remote, depth, bare, result['before'], result['after'])
-                    if diff:
-                        result['diff'] = diff
-                module.exit_json(**result)
-            else:
-                fetch(git_path, module, repo, dest, version, remote, depth, bare, refspec, git_version_used)
+        if module.check_mode:
+            remote_head = get_remote_head(git_path, module, dest, version, remote, bare)
+            result.update(changed=(result['before'] != remote_head), after=remote_head)
+            # FIXME: This diff should fail since the new remote_head is not fetched yet?!
+            if module._diff:
+                diff = get_diff(module, git_path, dest, repo, remote, depth, bare, result['before'], result['after'])
+                if diff:
+                    result['diff'] = diff
+            module.exit_json(**result)
+        else:
+            fetch(git_path, module, repo, dest, version, remote, depth, bare, refspec, git_version_used)
 
         result['after'] = get_version(module, git_path, dest)
 
-        if result['before'] == result['after']:
-            if local_mods:
-                result.update(changed=True, after=remote_head, msg='Local modifications exist')
-                # no diff, since the repo didn't change
-                module.exit_json(**result)
-
     # switch to version specified regardless of whether
     # we got new revisions from the repository
     if not bare:
@@ -1033,7 +1027,6 @@ def main():
     # determine if we changed anything
     result['after'] = get_version(module, git_path, dest)
 
-    result.update(changed=False)
     if result['before'] != result['after'] or local_mods or submodules_updated or remote_url_changed:
         result.update(changed=True)
         if module._diff:
diff --git a/test/integration/targets/git/tasks/main.yml b/test/integration/targets/git/tasks/main.yml
index 7424deef3a..2f5373028d 100644
--- a/test/integration/targets/git/tasks/main.yml
+++ b/test/integration/targets/git/tasks/main.yml
@@ -447,7 +447,7 @@
 - name: clear checkout_dir
   file: state=absent path={{ checkout_dir }}
 
-- name: Clone example git repo that we're going to modify
+- name: "Clone example git repo that we're going to modify"
   git:
     repo: '{{ repo_update_url_1 }}'
     dest: '{{ checkout_dir }}/repo'
@@ -652,9 +652,6 @@
   register: git_fetch
   ignore_errors: yes
 
-- name: read file
-  shell: cat {{ checkout_dir }}/a
-
 - name: check update arrived
   assert:
     that:
@@ -718,3 +715,109 @@
     gpg_version.stdout and
     (git_version.stdout | version_compare("2.1.0", '>=') or
     gpg_version.stdout | version_compare("1.4.16", '>='))
+
+- name: clear checkout_dir
+  file: state=absent path={{ checkout_dir }}
+
+# test for https://github.com/ansible/ansible-modules-core/pull/5505
+- name: prepare old git repo
+  shell: rm -rf localmods; mkdir localmods; cd localmods; git init; echo "1" > a; git add a; git commit -m "1"
+  args:
+    chdir: "{{repo_dir}}"
+
+- name: checkout old repo
+  git:
+    repo: '{{ repo_dir }}/localmods'
+    dest: '{{ checkout_dir }}'
+
+- name: "update repo"
+  shell: echo "2" > a; git commit -a -m "2"
+  args:
+    chdir: "{{repo_dir}}/localmods"
+
+- name: "add local mods"
+  shell: echo "3" > a
+  args:
+    chdir: "{{ checkout_dir }}"
+
+- name: fetch with local mods without force (should fail)
+  git:
+    repo: '{{ repo_dir }}/localmods'
+    dest: '{{ checkout_dir }}'
+  register: git_fetch
+  ignore_errors: yes
+
+- name: check fetch with localmods failed
+  assert:
+    that:
+      - git_fetch|failed
+
+- name: fetch with local mods with force
+  git:
+    repo: '{{ repo_dir }}/localmods'
+    dest: '{{ checkout_dir }}'
+    force: True
+  register: git_fetch_force
+  ignore_errors: yes
+
+- name: check update arrived
+  assert:
+    that:
+      - "{{ lookup('file', checkout_dir+'/a' )}} == 2"
+      - git_fetch_force|changed
+
+- name: clear checkout_dir
+  file: state=absent path={{ checkout_dir }}
+
+# localmods and shallow clone
+- name: prepare old git repo
+  shell: rm -rf localmods; mkdir localmods; cd localmods; git init; echo "1" > a; git add a; git commit -m "1"
+  args:
+    chdir: "{{repo_dir}}"
+
+- name: checkout old repo
+  git:
+    repo: '{{ repo_dir }}/localmods'
+    dest: '{{ checkout_dir }}'
+    depth: 1
+
+- name: "update repo"
+  shell: echo "2" > a; git commit -a -m "2"
+  args:
+    chdir: "{{repo_dir}}/localmods"
+
+- name: "add local mods"
+  shell: echo "3" > a
+  args:
+    chdir: "{{ checkout_dir }}"
+
+- name: fetch with local mods without force (should fail)
+  git:
+    repo: '{{ repo_dir }}/localmods'
+    dest: '{{ checkout_dir }}'
+    depth: 1
+  register: git_fetch
+  ignore_errors: yes
+
+- name: check fetch with localmods failed
+  assert:
+    that:
+      - git_fetch|failed
+
+- name: fetch with local mods with force
+  git:
+    repo: '{{ repo_dir }}/localmods'
+    dest: '{{ checkout_dir }}'
+    depth: 1
+    force: True
+  register: git_fetch_force
+  ignore_errors: yes
+
+- name: check update arrived
+  assert:
+    that:
+      - "{{ lookup('file', checkout_dir+'/a' )}} == 2"
+      - git_fetch_force|changed
+
+- name: clear checkout_dir
+  file: state=absent path={{ checkout_dir }}

commit 02e738500239fe5b724a814066b3af3bc412bed7
Author: James Cammarata <jimi@sngx.net>
Date:   Wed Apr 15 01:10:24 2015 -0500

    Filter tasks based on tags during iterator setup in v2

diff --git a/v2/ansible/executor/play_iterator.py b/v2/ansible/executor/play_iterator.py
index 38bebb2113..dc4d4c7d5d 100644
--- a/v2/ansible/executor/play_iterator.py
+++ b/v2/ansible/executor/play_iterator.py
@@ -87,10 +87,15 @@ class PlayIterator:
     FAILED_RESCUE      = 4
     FAILED_ALWAYS      = 8
 
-    def __init__(self, inventory, play):
+    def __init__(self, inventory, play, connection_info, all_vars):
         self._play = play
 
-        self._blocks  = self._play.compile()
+        self._blocks = []
+        for block in self._play.compile():
+            new_block = block.filter_tagged_tasks(connection_info, all_vars)
+            if new_block.has_tasks():
+                self._blocks.append(new_block)
+
         self._host_states = {}
         for host in inventory.get_hosts(self._play.hosts):
              self._host_states[host.name] = HostState(blocks=self._blocks)
diff --git a/v2/ansible/executor/task_queue_manager.py b/v2/ansible/executor/task_queue_manager.py
index 026726b3d8..c5772942fe 100644
--- a/v2/ansible/executor/task_queue_manager.py
+++ b/v2/ansible/executor/task_queue_manager.py
@@ -161,7 +161,7 @@ class TaskQueueManager:
             raise AnsibleError("Invalid play strategy specified: %s" % new_play.strategy, obj=play._ds)
 
         # build the iterator
-        iterator = PlayIterator(inventory=self._inventory, play=new_play)
+        iterator = PlayIterator(inventory=self._inventory, play=new_play, connection_info=connection_info, all_vars=all_vars)
 
         # and run the play using the strategy
         return strategy.run(iterator, connection_info)
diff --git a/v2/ansible/playbook/block.py b/v2/ansible/playbook/block.py
index e0e607da3b..9fd3d77360 100644
--- a/v2/ansible/playbook/block.py
+++ b/v2/ansible/playbook/block.py
@@ -281,3 +281,25 @@ class Block(Base, Become, Conditional, Taggable):
 
         return value
 
+    def filter_tagged_tasks(self, connection_info, all_vars):
+        '''
+        Creates a new block, with task lists filtered based on the tags contained
+        within the connection_info object.
+        '''
+
+        def evaluate_and_append_task(target):
+            tmp_list = []
+            for task in target:
+                if task.evaluate_tags(connection_info.only_tags, connection_info.skip_tags, all_vars=all_vars):
+                    tmp_list.append(task)
+            return tmp_list
+
+        new_block = self.copy()
+        new_block.block  = evaluate_and_append_task(self.block)
+        new_block.rescue = evaluate_and_append_task(self.rescue)
+        new_block.always = evaluate_and_append_task(self.always)
+
+        return new_block
+
+    def has_tasks(self):
+        return len(self.block) > 0 or len(self.rescue) > 0 or len(self.always) > 0
diff --git a/v2/ansible/plugins/strategies/linear.py b/v2/ansible/plugins/strategies/linear.py
index fcda46a7af..9988bb3e2a 100644
--- a/v2/ansible/plugins/strategies/linear.py
+++ b/v2/ansible/plugins/strategies/linear.py
@@ -178,10 +178,6 @@ class StrategyModule(StrategyBase):
                             debug("'%s' skipped because role has already run" % task)
                             continue
 
-                    if not task.evaluate_tags(connection_info.only_tags, connection_info.skip_tags, task_vars) and task.action != 'setup':
-                        debug("'%s' failed tag evaluation" % task)
-                        continue
-
                     if task.action == 'meta':
                         # meta tasks store their args in the _raw_params field of args,
                         # since they do not use k=v pairs, so get that
diff --git a/v2/samples/test_tags.yml b/v2/samples/test_tags.yml
new file mode 100644
index 0000000000..c94b88e0a0
--- /dev/null
+++ b/v2/samples/test_tags.yml
@@ -0,0 +1,22 @@
+- hosts: localhost
+  gather_facts: no
+  tasks:
+  - block:
+      - debug: msg="this is the tagged block"
+    tags:
+    - block
+  - block:
+      - debug: msg="tagged debug from second block"
+        tags:
+        - tag1
+      - fail:
+        tags:
+        - tag1
+    rescue:
+      - debug: msg="tagged rescue from second block"
+        tags:
+        - rescue_tag
+    always:
+      - debug: msg="tagged always from second block"
+        tags:
+        - always_tag

commit 1d5f881f5c351ac619d7b90c8a970b602ac565dd
Author: Trishna Guha <trishnaguha17@gmail.com>
Date:   Mon Jul 23 22:45:55 2018 +0530

    Add text output along with structured output in nxos_facts (#42886)
    
    * nxos_facts to use default output instead of structured output
    
    Signed-off-by: Trishna Guha <trishnaguha17@gmail.com>
    
    * fix shippable error
    
    Signed-off-by: Trishna Guha <trishnaguha17@gmail.com>
    
    * nxos_facts refactor
    
    Signed-off-by: Trishna Guha <trishnaguha17@gmail.com>
    
    * Add structured output back
    
    Signed-off-by: Trishna Guha <trishnaguha17@gmail.com>

diff --git a/lib/ansible/modules/network/nxos/nxos_facts.py b/lib/ansible/modules/network/nxos/nxos_facts.py
index 1d7bb5836d..593ca6d0b4 100644
--- a/lib/ansible/modules/network/nxos/nxos_facts.py
+++ b/lib/ansible/modules/network/nxos/nxos_facts.py
@@ -38,8 +38,7 @@ author:
   - Jason Edelman (@jedelman8)
   - Gabriele Gerbino (@GGabriele)
 notes:
-  - This module is only supported on the NX-OS device that supports JSON
-    structured output. NX-OS OS version should be 6.0(2)A8 or 7.x or later.
+  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
 options:
   gather_subset:
     description:
@@ -172,9 +171,10 @@ vlan_list:
 import re
 
 from ansible.module_utils.network.nxos.nxos import run_commands, get_config
-from ansible.module_utils.network.nxos.nxos import get_capabilities
+from ansible.module_utils.network.nxos.nxos import get_capabilities, get_interface_type
 from ansible.module_utils.network.nxos.nxos import nxos_argument_spec, check_args
 from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.connection import ConnectionError
 from ansible.module_utils.six import string_types, iteritems
 
 
@@ -232,12 +232,57 @@ class Default(FactsBase):
     ])
 
     def populate(self):
-        data = self.run('show version', output='json')
+        data = None
+
+        try:
+            data = self.run('show version', output='json')
+        except ConnectionError:
+            data = self.run('show version')
         if data:
-            if data.get('sys_ver_str'):
-                self.facts.update(self.transform_dict(data, self.VERSION_MAP_7K))
+            if isinstance(data, dict):
+                if data.get('sys_ver_str'):
+                    self.facts.update(self.transform_dict(data, self.VERSION_MAP_7K))
+                else:
+                    self.facts.update(self.transform_dict(data, self.VERSION_MAP))
             else:
-                self.facts.update(self.transform_dict(data, self.VERSION_MAP))
+                self.facts['version'] = self.parse_version(data)
+                self.facts['serialnum'] = self.parse_serialnum(data)
+                self.facts['model'] = self.parse_model(data)
+                self.facts['image'] = self.parse_image(data)
+                self.facts['hostname'] = self.parse_hostname(data)
+
+    def parse_version(self, data):
+        match = re.search(r'\s+system:\s+version\s*(\S+)', data, re.M)
+        if match:
+            return match.group(1)
+        else:
+            match = re.search(r'\s+kickstart:\s+version\s*(\S+)', data, re.M)
+            if match:
+                return match.group(1)
+
+    def parse_serialnum(self, data):
+        match = re.search(r'Processor Board ID\s*(\S+)', data, re.M)
+        if match:
+            return match.group(1)
+
+    def parse_model(self, data):
+        match = re.search(r'Hardware\n\s+cisco\s*(\S+\s+\S+)', data, re.M)
+        if match:
+            return match.group(1)
+
+    def parse_image(self, data):
+        match = re.search(r'\s+system image file is:\s*(\S+)', data, re.M)
+        if match:
+            return match.group(1)
+        else:
+            match = re.search(r'\s+kickstart image file is:\s*(\S+)', data, re.M)
+            if match:
+                return match.group(1)
+
+    def parse_hostname(self, data):
+        match = re.search(r'\s+Device name:\s*(\S+)', data, re.M)
+        if match:
+            return match.group(1)
 
 
 class Config(FactsBase):
@@ -254,14 +299,34 @@ class Hardware(FactsBase):
         if data:
             self.facts['filesystems'] = self.parse_filesystems(data)
 
-        data = self.run('show system resources', output='json')
+        data = None
+        try:
+            data = self.run('show system resources', output='json')
+        except ConnectionError:
+            data = self.run('show system resources')
         if data:
-            self.facts['memtotal_mb'] = int(data['memory_usage_total']) / 1024
-            self.facts['memfree_mb'] = int(data['memory_usage_free']) / 1024
+            if isinstance(data, dict):
+                self.facts['memtotal_mb'] = int(data['memory_usage_total']) / 1024
+                self.facts['memfree_mb'] = int(data['memory_usage_free']) / 1024
+            else:
+                self.facts['memtotal_mb'] = self.parse_memtotal_mb(data)
+                self.facts['memfree_mb'] = self.parse_memfree_mb(data)
 
     def parse_filesystems(self, data):
         return re.findall(r'^Usage for (\S+)//', data, re.M)
 
+    def parse_memtotal_mb(self, data):
+        match = re.search(r'(\S+)K(\s+|)total', data, re.M)
+        if match:
+            memtotal = match.group(1)
+            return int(memtotal) / 1024
+
+    def parse_memfree_mb(self, data):
+        match = re.search(r'(\S+)K(\s+|)free', data, re.M)
+        if match:
+            memfree = match.group(1)
+            return int(memfree) / 1024
+
 
 class Interfaces(FactsBase):
 
@@ -301,35 +366,60 @@ class Interfaces(FactsBase):
     ])
 
     def ipv6_structure_op_supported(self):
-        data = self.run('show version', output='json')
+        data = get_capabilities(self.module)
         if data:
+            nxos_os_version = data['device_info']['network_os_version']
             unsupported_versions = ['I2', 'F1', 'A8']
             for ver in unsupported_versions:
-                if ver in data.get('kickstart_ver_str'):
+                if ver in nxos_os_version:
                     return False
             return True
 
     def populate(self):
         self.facts['all_ipv4_addresses'] = list()
         self.facts['all_ipv6_addresses'] = list()
+        data = None
 
-        data = self.run('show interface', output='json')
+        try:
+            data = self.run('show interface', output='json')
+        except ConnectionError:
+            data = self.run('show interface')
         if data:
-            self.facts['interfaces'] = self.populate_interfaces(data)
-
-        data = self.run('show ipv6 interface', output='json') if self.ipv6_structure_op_supported() else None
-        if data and not isinstance(data, string_types):
-            self.parse_ipv6_interfaces(data)
+            if isinstance(data, dict):
+                self.facts['interfaces'] = self.populate_structured_interfaces(data)
+            else:
+                interfaces = self.parse_interfaces(data)
+                self.facts['interfaces'] = self.populate_interfaces(interfaces)
+
+        if self.ipv6_structure_op_supported():
+            try:
+                data = self.run('show ipv6 interface', output='json')
+            except ConnectionError:
+                data = self.run('show ipv6 interface')
+        else:
+            data = None
+        if data:
+            if isinstance(data, dict):
+                self.populate_structured_ipv6_interfaces(data)
+            else:
+                interfaces = self.parse_interfaces(data)
+                self.populate_ipv6_interfaces(interfaces)
 
         data = self.run('show lldp neighbors')
         if data:
             self.facts['neighbors'] = self.populate_neighbors(data)
 
-        data = self.run('show cdp neighbors detail', output='json')
+        try:
+            data = self.run('show cdp neighbors detail', output='json')
+        except ConnectionError:
+            data = self.run('show cdp neighbors detail')
         if data:
-            self.facts['neighbors'] = self.populate_neighbors_cdp(data)
+            if isinstance(data, dict):
+                self.facts['neighbors'] = self.populate_structured_neighbors_cdp(data)
+            else:
+                self.facts['neighbors'] = self.populate_neighbors_cdp(data)
 
-    def populate_interfaces(self, data):
+    def populate_structured_interfaces(self, data):
         interfaces = dict()
         for item in data['TABLE_interface']['ROW_interface']:
             name = item['interface']
@@ -352,6 +442,159 @@ class Interfaces(FactsBase):
 
         return interfaces
 
+    def populate_structured_ipv6_interfaces(self, data):
+        try:
+            data = data['TABLE_intf']
+            if data:
+                if isinstance(data, dict):
+                    data = [data]
+                for item in data:
+                    name = item['ROW_intf']['intf-name']
+                    intf = self.facts['interfaces'][name]
+                    intf['ipv6'] = self.transform_dict(item, self.INTERFACE_IPV6_MAP)
+                    try:
+                        addr = item['ROW_intf']['addr']
+                    except KeyError:
+                        addr = item['ROW_intf']['TABLE_addr']['ROW_addr']['addr']
+                    self.facts['all_ipv6_addresses'].append(addr)
+            else:
+                return ""
+        except TypeError:
+            return ""
+
+    def populate_structured_neighbors_cdp(self, data):
+        objects = dict()
+        data = data['TABLE_cdp_neighbor_detail_info']['ROW_cdp_neighbor_detail_info']
+
+        if isinstance(data, dict):
+            data = [data]
+
+        for item in data:
+            local_intf = item['intf_id']
+            objects[local_intf] = list()
+            nbor = dict()
+            nbor['port'] = item['port_id']
+            nbor['sysname'] = item['device_id']
+            objects[local_intf].append(nbor)
+
+        return objects
+
+    def parse_interfaces(self, data):
+        parsed = dict()
+        key = ''
+        for line in data.split('\n'):
+            if len(line) == 0:
+                continue
+            elif line.startswith('admin') or line[0] == ' ':
+                parsed[key] += '\n%s' % line
+            else:
+                match = re.match(r'^(\S+)', line)
+                if match:
+                    key = match.group(1)
+                    if not key.startswith('admin') or not key.startswith('IPv6 Interface'):
+                        parsed[key] = line
+        return parsed
+
+    def populate_interfaces(self, interfaces):
+        facts = dict()
+        for key, value in iteritems(interfaces):
+            intf = dict()
+            if get_interface_type(key) == 'svi':
+                intf['state'] = self.parse_state(key, value, intf_type='svi')
+                intf['macaddress'] = self.parse_macaddress(value, intf_type='svi')
+                intf['mtu'] = self.parse_mtu(value, intf_type='svi')
+                intf['bandwidth'] = self.parse_bandwidth(value, intf_type='svi')
+                intf['type'] = self.parse_type(value, intf_type='svi')
+                if 'Internet Address' in value:
+                    intf['ipv4'] = self.parse_ipv4_address(value, intf_type='svi')
+                facts[key] = intf
+            else:
+                intf['state'] = self.parse_state(key, value)
+                intf['description'] = self.parse_description(value)
+                intf['macaddress'] = self.parse_macaddress(value)
+                intf['mode'] = self.parse_mode(value)
+                intf['mtu'] = self.parse_mtu(value)
+                intf['bandwidth'] = self.parse_bandwidth(value)
+                intf['duplex'] = self.parse_duplex(value)
+                intf['speed'] = self.parse_speed(value)
+                intf['type'] = self.parse_type(value)
+                if 'Internet Address' in value:
+                    intf['ipv4'] = self.parse_ipv4_address(value)
+                facts[key] = intf
+
+        return facts
+
+    def parse_state(self, key, value, intf_type='ethernet'):
+        match = None
+        if intf_type == 'svi':
+            match = re.search(r'line protocol is\s*(\S+)', value, re.M)
+        else:
+            match = re.search(r'%s is\s*(\S+)' % key, value, re.M)
+
+        if match:
+            return match.group(1)
+
+    def parse_macaddress(self, value, intf_type='ethernet'):
+        match = None
+        if intf_type == 'svi':
+            match = re.search(r'address is\s*(\S+)', value, re.M)
+        else:
+            match = re.search(r'address:\s*(\S+)', value, re.M)
+
+        if match:
+            return match.group(1)
+
+    def parse_mtu(self, value, intf_type='ethernet'):
+        match = re.search(r'MTU\s*(\S+)', value, re.M)
+        if match:
+            return match.group(1)
+
+    def parse_bandwidth(self, value, intf_type='ethernet'):
+        match = re.search(r'BW\s*(\S+)', value, re.M)
+        if match:
+            return match.group(1)
+
+    def parse_type(self, value, intf_type='ethernet'):
+        match = None
+        if intf_type == 'svi':
+            match = re.search(r'Hardware is\s*(\S+)', value, re.M)
+        else:
+            match = re.search(r'Hardware:\s*(.+),', value, re.M)
+
+        if match:
+            return match.group(1)
+
+    def parse_description(self, value, intf_type='ethernet'):
+        match = re.search(r'Description: (.+)$', value, re.M)
+        if match:
+            return match.group(1)
+
+    def parse_mode(self, value, intf_type='ethernet'):
+        match = re.search(r'Port mode is (\S+)', value, re.M)
+        if match:
+            return match.group(1)
+
+    def parse_duplex(self, value, intf_type='ethernet'):
+        match = re.search(r'(\S+)-duplex', value, re.M)
+        if match:
+            return match.group(1)
+
+    def parse_speed(self, value, intf_type='ethernet'):
+        match = re.search(r'duplex, (.+)$', value, re.M)
+        if match:
+            return match.group(1)
+
+    def parse_ipv4_address(self, value, intf_type='ethernet'):
+        ipv4 = {}
+        match = re.search(r'Internet Address is (.+)$', value, re.M)
+        if match:
+            address = match.group(1)
+            addr = address.split('/')[0]
+            ipv4['address'] = address.split('/')[0]
+            ipv4['masklen'] = address.split('/')[1]
+            self.facts['all_ipv4_addresses'].append(addr)
+        return ipv4
+
     def populate_neighbors(self, data):
         objects = dict()
         if isinstance(data, str):
@@ -387,41 +630,56 @@ class Interfaces(FactsBase):
         return objects
 
     def populate_neighbors_cdp(self, data):
-        objects = dict()
-        data = data['TABLE_cdp_neighbor_detail_info']['ROW_cdp_neighbor_detail_info']
-
-        if isinstance(data, dict):
-            data = [data]
+        facts = dict()
 
-        for item in data:
-            local_intf = item['intf_id']
-            objects[local_intf] = list()
-            nbor = dict()
-            nbor['port'] = item['port_id']
-            nbor['sysname'] = item['device_id']
-            objects[local_intf].append(nbor)
+        for item in data.split('----------------------------------------'):
+            if item == '':
+                continue
+            local_intf = self.parse_lldp_intf(item)
+            if local_intf not in facts:
+                facts[local_intf] = list()
+
+            fact = dict()
+            fact['port'] = self.parse_lldp_port(item)
+            fact['sysname'] = self.parse_lldp_sysname(item)
+            facts[local_intf].append(facts)
+
+        return facts
+
+    def parse_lldp_intf(self, data):
+        match = re.search(r'Interface:\s*(\S+)', data, re.M)
+        if match:
+            return match.group(1)
+
+    def parse_lldp_port(self, data):
+        match = re.search(r'Port ID \(outgoing port\):\s*(\S+)', data, re.M)
+        if match:
+            return match.group(1)
+
+    def parse_lldp_sysname(self, data):
+        match = re.search(r'Device ID:(.+)$', data, re.M)
+        if match:
+            return match.group(1)
+
+    def populate_ipv6_interfaces(self, interfaces):
+        facts = dict()
+        for key, value in iteritems(interfaces):
+            intf = dict()
+            intf['ipv6'] = self.parse_ipv6_address(value)
+            facts[key] = intf
 
-        return objects
+    def parse_ipv6_address(self, value):
+        ipv6 = {}
+        match_addr = re.search(r'IPv6 address:\s*(\S+)', value, re.M)
+        if match_addr:
+            addr = match_addr.group(1)
+            ipv6['address'] = addr
+            self.facts['all_ipv6_addresses'].append(addr)
+        match_subnet = re.search(r'IPv6 subnet:\s*(\S+)', value, re.M)
+        if match_subnet:
+            ipv6['subnet'] = match_subnet.group(1)
 
-    def parse_ipv6_interfaces(self, data):
-        try:
-            data = data['TABLE_intf']
-            if data:
-                if isinstance(data, dict):
-                    data = [data]
-                for item in data:
-                    name = item['ROW_intf']['intf-name']
-                    intf = self.facts['interfaces'][name]
-                    intf['ipv6'] = self.transform_dict(item, self.INTERFACE_IPV6_MAP)
-                    try:
-                        addr = item['ROW_intf']['addr']
-                    except KeyError:
-                        addr = item['ROW_intf']['TABLE_addr']['ROW_addr']['addr']
-                    self.facts['all_ipv6_addresses'].append(addr)
-            else:
-                return ""
-        except TypeError:
-            return ""
+        return ipv6
 
 
 class Legacy(FactsBase):
@@ -458,34 +716,77 @@ class Legacy(FactsBase):
     ])
 
     def populate(self):
-        data = self.run('show version', output='json')
+        data = None
+
+        try:
+            data = self.run('show version')
+        except ConnectionError:
+            data = self.run('show version', output='json')
         if data:
-            self.facts.update(self.transform_dict(data, self.VERSION_MAP))
+            if isinstance(data, dict):
+                self.facts.update(self.transform_dict(data, self.VERSION_MAP))
+            else:
+                self.facts['_hostname'] = self.parse_hostname(data)
+                self.facts['_os'] = self.parse_os(data)
+                self.facts['_platform'] = self.parse_platform(data)
 
-        data = self.run('show interface', output='json')
+        try:
+            data = self.run('show interface', output='json')
+        except ConnectionError:
+            data = self.run('show interface')
         if data:
-            self.facts['_interfaces_list'] = self.parse_interfaces(data)
+            if isinstance(data, dict):
+                self.facts['_interfaces_list'] = self.parse_structured_interfaces(data)
+            else:
+                self.facts['_interfaces_list'] = self.parse_interfaces(data)
 
-        data = self.run('show vlan brief', output='json')
+        try:
+            data = self.run('show vlan brief', output='json')
+        except ConnectionError:
+            data = self.run('show vlan brief')
         if data:
-            self.facts['_vlan_list'] = self.parse_vlans(data)
+            if isinstance(data, dict):
+                self.facts['_vlan_list'] = self.parse_structured_vlans(data)
+            else:
+                self.facts['_vlan_list'] = self.parse_vlans(data)
 
-        data = self.run('show module', output='json')
+        try:
+            data = self.run('show module', output='json')
+        except ConnectionError:
+            data = self.run('show module')
         if data:
-            self.facts['_module'] = self.parse_module(data)
+            if isinstance(data, dict):
+                self.facts['_module'] = self.parse_structured_module(data)
+            else:
+                self.facts['_module'] = self.parse_module(data)
 
-        data = self.run('show environment', output='json')
+        try:
+            data = self.run('show environment fan', output='json')
+        except ConnectionError:
+            data = self.run('show environment fan')
         if data:
-            self.facts['_fan_info'] = self.parse_fan_info(data)
-            self.facts['_power_supply_info'] = self.parse_power_supply_info(data)
+            if isinstance(data, dict):
+                self.facts['_fan_info'] = self.parse_structured_fan_info(data)
+            else:
+                self.facts['_fan_info'] = self.parse_fan_info(data)
 
-    def parse_interfaces(self, data):
+        try:
+            data = self.run('show environment power', output='json')
+        except ConnectionError:
+            data = self.run('show environment power')
+        if data:
+            if isinstance(data, dict):
+                self.facts['_power_supply_info'] = self.parse_structured_power_supply_info(data)
+            else:
+                self.facts['_power_supply_info'] = self.parse_power_supply_info(data)
+
+    def parse_structured_interfaces(self, data):
         objects = list()
         for item in data['TABLE_interface']['ROW_interface']:
             objects.append(item['interface'])
         return objects
 
-    def parse_vlans(self, data):
+    def parse_structured_vlans(self, data):
         objects = list()
         data = data['TABLE_vlanbriefxbrief']['ROW_vlanbriefxbrief']
         if isinstance(data, dict):
@@ -495,14 +796,14 @@ class Legacy(FactsBase):
                 objects.append(item['vlanshowbr-vlanid-utf'])
         return objects
 
-    def parse_module(self, data):
+    def parse_structured_module(self, data):
         data = data['TABLE_modinfo']['ROW_modinfo']
         if isinstance(data, dict):
             data = [data]
         objects = list(self.transform_iterable(data, self.MODULE_MAP))
         return objects
 
-    def parse_fan_info(self, data):
+    def parse_structured_fan_info(self, data):
         objects = list()
         if data.get('fandetails'):
             data = data['fandetails']['TABLE_faninfo']['ROW_faninfo']
@@ -513,7 +814,7 @@ class Legacy(FactsBase):
         objects = list(self.transform_iterable(data, self.FAN_MAP))
         return objects
 
-    def parse_power_supply_info(self, data):
+    def parse_structured_power_supply_info(self, data):
         if data.get('powersup').get('TABLE_psinfo_n3k'):
             data = data['powersup']['TABLE_psinfo_n3k']['ROW_psinfo_n3k']
         else:
@@ -521,6 +822,110 @@ class Legacy(FactsBase):
         objects = list(self.transform_iterable(data, self.POWERSUP_MAP))
         return objects
 
+    def parse_hostname(self, data):
+        match = re.search(r'\s+Device name:\s+(\S+)', data, re.M)
+        if match:
+            return match.group(1)
+
+    def parse_os(self, data):
+        match = re.search(r'\s+system:\s+version\s*(\S+)', data, re.M)
+        if match:
+            return match.group(1)
+        else:
+            match = re.search(r'\s+kickstart:\s+version\s*(\S+)', data, re.M)
+            if match:
+                return match.group(1)
+
+    def parse_platform(self, data):
+        match = re.search(r'Hardware\n\s+cisco\s+(\S+\s+\S+)', data, re.M)
+        if match:
+            return match.group(1)
+
+    def parse_interfaces(self, data):
+        objects = list()
+        for line in data.split('\n'):
+            if len(line) == 0:
+                continue
+            elif line.startswith('admin') or line[0] == ' ':
+                continue
+            else:
+                match = re.match(r'^(\S+)', line)
+                if match:
+                    intf = match.group(1)
+                    if get_interface_type(intf) != 'unknown':
+                        objects.append(intf)
+        return objects
+
+    def parse_vlans(self, data):
+        objects = list()
+        for line in data.splitlines():
+            if line == '':
+                continue
+            if line[0].isdigit():
+                vlan = line.split()[0]
+                objects.append(vlan)
+        return objects
+
+    def parse_module(self, data):
+        objects = list()
+        for line in data.splitlines():
+            if line == '':
+                break
+            if line[0].isdigit():
+                obj = {}
+                match_port = re.search(r'\d\s*(\d*)', line, re.M)
+                if match_port:
+                    obj['ports'] = match_port.group(1)
+
+                match = re.search(r'\d\s*\d*\s*(.+)$', line, re.M)
+                if match:
+                    l = match.group(1).split('  ')
+                    items = list()
+                    for item in l:
+                        if item == '':
+                            continue
+                        items.append(item.strip())
+
+                    if items:
+                        obj['type'] = items[0]
+                        obj['model'] = items[1]
+                        obj['status'] = items[2]
+
+                objects.append(obj)
+        return objects
+
+    def parse_fan_info(self, data):
+        objects = list()
+
+        for l in data.splitlines():
+            if '-----------------' in l or 'Status' in l:
+                continue
+            line = l.split()
+            if len(line) > 1:
+                obj = {}
+                obj['name'] = line[0]
+                obj['model'] = line[1]
+                obj['hw_ver'] = line[-2]
+                obj['status'] = line[-1]
+                objects.append(obj)
+        return objects
+
+    def parse_power_supply_info(self, data):
+        objects = list()
+
+        for l in data.splitlines():
+            if l == '':
+                break
+            if l[0].isdigit():
+                obj = {}
+                line = l.split()
+                obj['model'] = line[1]
+                obj['number'] = line[0]
+                obj['status'] = line[-1]
+
+                objects.append(obj)
+        return objects
+
 
 FACT_SUBSETS = dict(
     default=Default,
@@ -542,13 +947,6 @@ def main():
 
     module = AnsibleModule(argument_spec=spec, supports_check_mode=True)
 
-    capabilities = get_capabilities(module)
-    if capabilities:
-        os_version = capabilities['device_info']['network_os_version']
-        os_version_major = int(os_version[0])
-        if os_version_major < 7 and "6.0(2)A8" not in os_version:
-            module.fail_json(msg="this module requires JSON structured output support on the NX-OS device")
-
     warnings = list()
     check_args(module, warnings)
 

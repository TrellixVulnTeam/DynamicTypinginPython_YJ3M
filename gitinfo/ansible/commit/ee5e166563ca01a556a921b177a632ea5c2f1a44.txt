commit ee5e166563ca01a556a921b177a632ea5c2f1a44
Author: James Cammarata <jimi@sngx.net>
Date:   Thu Jun 4 15:43:07 2015 -0400

    Fixing ansible_*_interpreter use
    
    Fixes ansible/ansible-modules-core#1459

diff --git a/lib/ansible/executor/module_common.py b/lib/ansible/executor/module_common.py
index 535fbd45e3..85dcafb961 100644
--- a/lib/ansible/executor/module_common.py
+++ b/lib/ansible/executor/module_common.py
@@ -31,6 +31,7 @@ from ansible import __version__
 from ansible import constants as C
 from ansible.errors import AnsibleError
 from ansible.parsing.utils.jsonify import jsonify
+from ansible.utils.unicode import to_bytes
 
 REPLACER         = "#<<INCLUDE_ANSIBLE_MODULE_COMMON>>"
 REPLACER_ARGS    = "\"<<INCLUDE_ANSIBLE_MODULE_ARGS>>\""
@@ -113,7 +114,7 @@ def _find_snippet_imports(module_data, module_path, strip_comments):
 
 # ******************************************************************************
 
-def modify_module(module_path, module_args, strip_comments=False):
+def modify_module(module_path, module_args, task_vars=dict(), strip_comments=False):
     """
     Used to insert chunks of code into modules before transfer rather than
     doing regular python imports.  This allows for more efficient transfer in
@@ -158,7 +159,6 @@ def modify_module(module_path, module_args, strip_comments=False):
 
         (module_data, module_style) = _find_snippet_imports(module_data, module_path, strip_comments)
 
-        #module_args_json = jsonify(module_args)
         module_args_json = json.dumps(module_args)
         encoded_args = repr(module_args_json.encode('utf-8'))
 
@@ -166,14 +166,11 @@ def modify_module(module_path, module_args, strip_comments=False):
         module_data = module_data.replace(REPLACER_VERSION, repr(__version__))
         module_data = module_data.replace(REPLACER_COMPLEX, encoded_args)
 
-        # FIXME: we're not passing around an inject dictionary anymore, so
-        #        this needs to be fixed with whatever method we use for vars
-        #        like this moving forward
-        #if module_style == 'new':
-        #    facility = C.DEFAULT_SYSLOG_FACILITY
-        #    if 'ansible_syslog_facility' in inject:
-        #        facility = inject['ansible_syslog_facility']
-        #    module_data = module_data.replace('syslog.LOG_USER', "syslog.%s" % facility)
+        if module_style == 'new':
+            facility = C.DEFAULT_SYSLOG_FACILITY
+            if 'ansible_syslog_facility' in task_vars:
+                facility = task_vars['ansible_syslog_facility']
+            module_data = module_data.replace('syslog.LOG_USER', "syslog.%s" % facility)
 
         lines = module_data.split(b"\n", 1)
         shebang = None
@@ -183,11 +180,9 @@ def modify_module(module_path, module_args, strip_comments=False):
             interpreter = args[0]
             interpreter_config = 'ansible_%s_interpreter' % os.path.basename(interpreter)
 
-            # FIXME: more inject stuff here...
-            #from ansible.utils.unicode import to_bytes
-            #if interpreter_config in inject:
-            #    interpreter = to_bytes(inject[interpreter_config], errors='strict')
-            #    lines[0] = shebang = b"#!{0} {1}".format(interpreter, b" ".join(args[1:]))
+            if interpreter_config in task_vars:
+                interpreter = to_bytes(task_vars[interpreter_config], errors='strict')
+                lines[0] = shebang = b"#!{0} {1}".format(interpreter, b" ".join(args[1:]))
 
             lines.insert(1, ENCODING_STRING)
         else:
diff --git a/lib/ansible/plugins/action/__init__.py b/lib/ansible/plugins/action/__init__.py
index d6861118b2..5509bb2d94 100644
--- a/lib/ansible/plugins/action/__init__.py
+++ b/lib/ansible/plugins/action/__init__.py
@@ -67,7 +67,7 @@ class ActionBase:
 
         self._supports_check_mode = True
 
-    def _configure_module(self, module_name, module_args):
+    def _configure_module(self, module_name, module_args, task_vars=dict()):
         '''
         Handles the loading and templating of the module code through the
         modify_module() function.
@@ -86,7 +86,7 @@ class ActionBase:
                                    "run 'git submodule update --init --recursive' to correct this problem." % (module_name))
 
         # insert shared code and arguments into the module
-        (module_data, module_style, module_shebang) = modify_module(module_path, module_args)
+        (module_data, module_style, module_shebang) = modify_module(module_path, module_args, task_vars=task_vars)
 
         return (module_style, module_shebang, module_data)
 
@@ -314,7 +314,7 @@ class ActionBase:
                 filtered_lines.write(line + '\n')
         return filtered_lines.getvalue()
 
-    def _execute_module(self, module_name=None, module_args=None, tmp=None, persist_files=False, delete_remote_tmp=True):
+    def _execute_module(self, module_name=None, module_args=None, tmp=None, task_vars=dict(), persist_files=False, delete_remote_tmp=True):
         '''
         Transfer and run a module along with its arguments.
         '''
@@ -338,7 +338,7 @@ class ActionBase:
 
         debug("in _execute_module (%s, %s)" % (module_name, module_args))
 
-        (module_style, shebang, module_data) = self._configure_module(module_name=module_name, module_args=module_args)
+        (module_style, shebang, module_data) = self._configure_module(module_name=module_name, module_args=module_args, task_vars=task_vars)
         if not shebang:
             raise AnsibleError("module is missing interpreter line")
 
diff --git a/lib/ansible/plugins/action/assemble.py b/lib/ansible/plugins/action/assemble.py
index 4e796bddb6..49f861f08e 100644
--- a/lib/ansible/plugins/action/assemble.py
+++ b/lib/ansible/plugins/action/assemble.py
@@ -87,7 +87,7 @@ class ActionModule(ActionBase):
             return dict(failed=True, msg="src and dest are required")
 
         if boolean(remote_src):
-            return self._execute_module(tmp=tmp)
+            return self._execute_module(tmp=tmp, task_vars=task_vars)
         elif self._task._role is not None:
             src = self._loader.path_dwim_relative(self._task._role._role_path, 'files', src)
         else:
@@ -109,7 +109,7 @@ class ActionModule(ActionBase):
             resultant = file(path).read()
             # FIXME: diff needs to be moved somewhere else
             #if self.runner.diff:
-            #    dest_result = self._execute_module(module_name='slurp', module_args=dict(path=dest), tmp=tmp, persist_files=True)
+            #    dest_result = self._execute_module(module_name='slurp', module_args=dict(path=dest), task_vars=task_vars, tmp=tmp, persist_files=True)
             #    if 'content' in dest_result:
             #        dest_contents = dest_result['content']
             #        if dest_result['encoding'] == 'base64':
@@ -140,7 +140,7 @@ class ActionModule(ActionBase):
             #    res = self.runner._execute_module(conn, tmp, 'copy', module_args_tmp, inject=inject)
             #    res.diff = dict(after=resultant)
             #    return res
-            res = self._execute_module(module_name='copy', module_args=new_module_args, tmp=tmp)
+            res = self._execute_module(module_name='copy', module_args=new_module_args, task_vars=task_vars, tmp=tmp)
             #res.diff = dict(after=resultant)
             return res
         else:
@@ -153,4 +153,4 @@ class ActionModule(ActionBase):
                 )
             )
 
-            return self._execute_module(module_name='file', module_args=new_module_args, tmp=tmp)
+            return self._execute_module(module_name='file', module_args=new_module_args, task_vars=task_vars, tmp=tmp)
diff --git a/lib/ansible/plugins/action/async.py b/lib/ansible/plugins/action/async.py
index 7c02e09757..7fedd544d6 100644
--- a/lib/ansible/plugins/action/async.py
+++ b/lib/ansible/plugins/action/async.py
@@ -42,12 +42,12 @@ class ActionModule(ActionBase):
         env_string = self._compute_environment_string()
 
         # configure, upload, and chmod the target module
-        (module_style, shebang, module_data) = self._configure_module(module_name=module_name, module_args=self._task.args)
+        (module_style, shebang, module_data) = self._configure_module(module_name=module_name, module_args=self._task.args, task_vars=task_vars)
         self._transfer_data(remote_module_path, module_data)
         self._remote_chmod(tmp, 'a+rx', remote_module_path)
 
         # configure, upload, and chmod the async_wrapper module
-        (async_module_style, shebang, async_module_data) = self._configure_module(module_name='async_wrapper', module_args=dict())
+        (async_module_style, shebang, async_module_data) = self._configure_module(module_name='async_wrapper', module_args=dict(), task_vars=task_vars)
         self._transfer_data(async_module_path, async_module_data)
         self._remote_chmod(tmp, 'a+rx', async_module_path)
 
@@ -57,7 +57,7 @@ class ActionModule(ActionBase):
         async_jid   = str(random.randint(0, 999999999999))
 
         async_cmd = " ".join([str(x) for x in [async_module_path, async_jid, async_limit, remote_module_path, argsfile]])
-        result = self._low_level_execute_command(cmd=async_cmd, tmp=None)
+        result = self._low_level_execute_command(cmd=async_cmd, task_vars=task_vars, tmp=None)
 
         # clean up after
         if tmp and "tmp" in tmp and not C.DEFAULT_KEEP_REMOTE_FILES:
diff --git a/lib/ansible/plugins/action/copy.py b/lib/ansible/plugins/action/copy.py
index 6db130ad7f..2d404029c5 100644
--- a/lib/ansible/plugins/action/copy.py
+++ b/lib/ansible/plugins/action/copy.py
@@ -191,7 +191,7 @@ class ActionModule(ActionBase):
 
                 # FIXME: runner shouldn't have the diff option there
                 #if self.runner.diff and not raw:
-                #    diff = self._get_diff_data(tmp, dest_file, source_full)
+                #    diff = self._get_diff_data(tmp, dest_file, source_full, task_vars)
                 #else:
                 #    diff = {}
                 diff = {}
@@ -236,7 +236,7 @@ class ActionModule(ActionBase):
                     )
                 )
 
-                module_return = self._execute_module(module_name='copy', module_args=new_module_args, delete_remote_tmp=delete_remote_tmp)
+                module_return = self._execute_module(module_name='copy', module_args=new_module_args, task_vars=task_vars, delete_remote_tmp=delete_remote_tmp)
                 module_executed = True
 
             else:
@@ -260,7 +260,7 @@ class ActionModule(ActionBase):
                 )
 
                 # Execute the file module.
-                module_return = self._execute_module(module_name='file', module_args=new_module_args, delete_remote_tmp=delete_remote_tmp)
+                module_return = self._execute_module(module_name='file', module_args=new_module_args, task_vars=task_vars, delete_remote_tmp=delete_remote_tmp)
                 module_executed = True
 
             if not module_return.get('checksum'):
@@ -304,8 +304,8 @@ class ActionModule(ActionBase):
             f.close()
         return content_tempfile
 
-    def _get_diff_data(self, tmp, destination, source):
-        peek_result = self._execute_module(module_name='file', module_args=dict(path=destination, diff_peek=True), persist_files=True)
+    def _get_diff_data(self, tmp, destination, source, task_vars):
+        peek_result = self._execute_module(module_name='file', module_args=dict(path=destination, diff_peek=True), task_vars=task_vars, persist_files=True)
         if 'failed' in peek_result and peek_result['failed'] or peek_result.get('rc', 0) != 0:
             return {}
 
@@ -318,7 +318,7 @@ class ActionModule(ActionBase):
         #elif peek_result['size'] > utils.MAX_FILE_SIZE_FOR_DIFF:
         #    diff['dst_larger'] = utils.MAX_FILE_SIZE_FOR_DIFF
         else:
-            dest_result = self._execute_module(module_name='slurp', module_args=dict(path=destination), tmp=tmp, persist_files=True)
+            dest_result = self._execute_module(module_name='slurp', module_args=dict(path=destination), task_vars=task_vars, tmp=tmp, persist_files=True)
             if 'content' in dest_result:
                 dest_contents = dest_result['content']
                 if dest_result['encoding'] == 'base64':
diff --git a/lib/ansible/plugins/action/fetch.py b/lib/ansible/plugins/action/fetch.py
index 6a903ae5a2..2123c5b162 100644
--- a/lib/ansible/plugins/action/fetch.py
+++ b/lib/ansible/plugins/action/fetch.py
@@ -61,7 +61,7 @@ class ActionModule(ActionBase):
         # use slurp if sudo and permissions are lacking
         remote_data = None
         if remote_checksum in ('1', '2') or self._connection_info.become:
-            slurpres = self._execute_module(module_name='slurp', module_args=dict(src=source), tmp=tmp)
+            slurpres = self._execute_module(module_name='slurp', module_args=dict(src=source), task_vars=task_vars, tmp=tmp)
             if slurpres.get('rc') == 0:
                 if slurpres['encoding'] == 'base64':
                     remote_data = base64.b64decode(slurpres['content'])
diff --git a/lib/ansible/plugins/action/normal.py b/lib/ansible/plugins/action/normal.py
index 431d9b0eeb..445d8a7ae7 100644
--- a/lib/ansible/plugins/action/normal.py
+++ b/lib/ansible/plugins/action/normal.py
@@ -24,6 +24,6 @@ class ActionModule(ActionBase):
     def run(self, tmp=None, task_vars=dict()):
 
         #vv("REMOTE_MODULE %s %s" % (module_name, module_args), host=conn.host)
-        return self._execute_module(tmp)
+        return self._execute_module(tmp, task_vars=task_vars)
 
 
diff --git a/lib/ansible/plugins/action/patch.py b/lib/ansible/plugins/action/patch.py
index bf2af1be1e..31dbd31fa4 100644
--- a/lib/ansible/plugins/action/patch.py
+++ b/lib/ansible/plugins/action/patch.py
@@ -36,7 +36,7 @@ class ActionModule(ActionBase):
         elif remote_src:
             # everything is remote, so we just execute the module
             # without changing any of the module arguments
-            return self._execute_module()
+            return self._execute_module(task_vars=task_vars)
 
         if self._task._role is not None:
             src = self._loader.path_dwim_relative(self._task._role._role_path, 'files', src)
@@ -63,4 +63,4 @@ class ActionModule(ActionBase):
             )
         )
 
-        return self._execute_module('patch', module_args=new_module_args)
+        return self._execute_module('patch', module_args=new_module_args, task_vars=task_vars)
diff --git a/lib/ansible/plugins/action/script.py b/lib/ansible/plugins/action/script.py
index 3ca7dc6a34..7c24845515 100644
--- a/lib/ansible/plugins/action/script.py
+++ b/lib/ansible/plugins/action/script.py
@@ -42,7 +42,7 @@ class ActionModule(ActionBase):
             # do not run the command if the line contains creates=filename
             # and the filename already exists. This allows idempotence
             # of command executions.
-            result = self._execute_module(module_name='stat', module_args=dict(path=creates), tmp=tmp, persist_files=True)
+            result = self._execute_module(module_name='stat', module_args=dict(path=creates), task_vars=task_vars, tmp=tmp, persist_files=True)
             stat = result.get('stat', None)
             if stat and stat.get('exists', False):
                 return dict(skipped=True, msg=("skipped, since %s exists" % creates))
@@ -52,7 +52,7 @@ class ActionModule(ActionBase):
             # do not run the command if the line contains removes=filename
             # and the filename does not exist. This allows idempotence
             # of command executions.
-            result = self._execute_module(module_name='stat', module_args=dict(path=removes), tmp=tmp, persist_files=True)
+            result = self._execute_module(module_name='stat', module_args=dict(path=removes), task_vars=task_vars, tmp=tmp, persist_files=True)
             stat = result.get('stat', None)
             if stat and not stat.get('exists', False):
                 return dict(skipped=True, msg=("skipped, since %s does not exist" % removes))
diff --git a/lib/ansible/plugins/action/synchronize.py b/lib/ansible/plugins/action/synchronize.py
index 219a982cb1..aa0a810a2a 100644
--- a/lib/ansible/plugins/action/synchronize.py
+++ b/lib/ansible/plugins/action/synchronize.py
@@ -170,7 +170,7 @@ class ActionModule(ActionBase):
             self._task.args['ssh_args'] = constants.ANSIBLE_SSH_ARGS
 
         # run the module and store the result
-        result = self._execute_module('synchronize')
+        result = self._execute_module('synchronize', task_vars=task_vars)
 
         return result
 
diff --git a/lib/ansible/plugins/action/template.py b/lib/ansible/plugins/action/template.py
index 7300848e6b..ea033807df 100644
--- a/lib/ansible/plugins/action/template.py
+++ b/lib/ansible/plugins/action/template.py
@@ -152,7 +152,7 @@ class ActionModule(ActionBase):
             #        res.diff = dict(before=dest_contents, after=resultant)
             #    return res
 
-            result = self._execute_module(module_name='copy', module_args=new_module_args)
+            result = self._execute_module(module_name='copy', module_args=new_module_args, task_vars=task_vars)
             if result.get('changed', False):
                 result['diff'] = dict(before=dest_contents, after=resultant)
             return result
@@ -180,5 +180,5 @@ class ActionModule(ActionBase):
             #if self.runner.noop_on_check(task_vars):
             #    new_module_args['CHECKMODE'] = True
 
-            return self._execute_module(module_name='file', module_args=new_module_args)
+            return self._execute_module(module_name='file', module_args=new_module_args, task_vars=task_vars)
 
diff --git a/lib/ansible/plugins/action/unarchive.py b/lib/ansible/plugins/action/unarchive.py
index b7601ed910..ef5320b719 100644
--- a/lib/ansible/plugins/action/unarchive.py
+++ b/lib/ansible/plugins/action/unarchive.py
@@ -47,7 +47,7 @@ class ActionModule(ActionBase):
             # and the filename already exists. This allows idempotence
             # of command executions.
             module_args_tmp = "path=%s" % creates
-            result = self._execute_module(module_name='stat', module_args=dict(path=creates))
+            result = self._execute_module(module_name='stat', module_args=dict(path=creates), task_vars=task_vars)
             stat = result.get('stat', None)
             if stat and stat.get('exists', False):
                 return dict(skipped=True, msg=("skipped, since %s exists" % creates))
@@ -110,5 +110,5 @@ class ActionModule(ActionBase):
             #    module_args += " CHECKMODE=True"
 
         # execute the unarchive module now, with the updated args
-        return self._execute_module(module_args=new_module_args)
+        return self._execute_module(module_args=new_module_args, task_vars=task_vars)
 

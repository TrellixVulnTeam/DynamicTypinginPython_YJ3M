commit b6a34518ad688ec9a6adb6947c79f0a78aa47bb4
Author: James Cammarata <jimi@sngx.net>
Date:   Wed Jan 28 08:55:18 2015 -0600

    Fixing checkmode support and some other things in v2

diff --git a/v2/ansible/executor/connection_info.py b/v2/ansible/executor/connection_info.py
index 088dc41573..5c48ff0089 100644
--- a/v2/ansible/executor/connection_info.py
+++ b/v2/ansible/executor/connection_info.py
@@ -24,6 +24,7 @@ import random
 
 from ansible import constants as C
 from ansible.template import Templar
+from ansible.utils.boolean import boolean
 
 
 __all__ = ['ConnectionInformation']
@@ -55,6 +56,9 @@ class ConnectionInformation:
         self.only_tags   = set()
         self.skip_tags   = set()
 
+        self.no_log      = False
+        self.check_mode  = False
+
         if play:
             self.set_play(play)
 
@@ -97,6 +101,9 @@ class ConnectionInformation:
         if options.connection:
             self.connection = options.connection
 
+        if options.check:
+            self.check_mode = boolean(options.check)
+
         # get the tag info from options, converting a comma-separated list
         # of values into a proper list if need be. We check to see if the
         # options have the attribute, as it is not always added via the CLI
@@ -121,25 +128,36 @@ class ConnectionInformation:
         when merging in data from task overrides.
         '''
 
-        self.connection  = ci.connection
-        self.remote_user = ci.remote_user
-        self.password    = ci.password
-        self.port        = ci.port
-        self.su          = ci.su
-        self.su_user     = ci.su_user
-        self.su_pass     = ci.su_pass
-        self.sudo        = ci.sudo
-        self.sudo_user   = ci.sudo_user
-        self.sudo_pass   = ci.sudo_pass
-        self.verbosity   = ci.verbosity
+        #self.connection  = ci.connection
+        #self.remote_user = ci.remote_user
+        #self.password    = ci.password
+        #self.port        = ci.port
+        #self.su          = ci.su
+        #self.su_user     = ci.su_user
+        #self.su_pass     = ci.su_pass
+        #self.sudo        = ci.sudo
+        #self.sudo_user   = ci.sudo_user
+        #self.sudo_pass   = ci.sudo_pass
+        #self.verbosity   = ci.verbosity
 
         # other
-        self.no_log      = ci.no_log
-        self.environment = ci.environment
+        #self.no_log      = ci.no_log
+        #self.environment = ci.environment
 
         # requested tags
-        self.only_tags   = ci.only_tags.copy()
-        self.skip_tags   = ci.skip_tags.copy()
+        #self.only_tags   = ci.only_tags.copy()
+        #self.skip_tags   = ci.skip_tags.copy()
+
+        for field in self._get_fields():
+            value = getattr(ci, field, None)
+            if isinstance(value, dict):
+                setattr(self, field, value.copy())
+            elif isinstance(value, set):
+                setattr(self, field, value.copy())
+            elif isinstance(value, list):
+                setattr(self, field, value[:])
+            else:
+                setattr(self, field, value)
 
     def set_task_override(self, task):
         '''
@@ -180,6 +198,7 @@ class ConnectionInformation:
             pipes.quote('echo %s; %s' % (success_key, cmd))
         )
 
+        # FIXME: old code, can probably be removed as it's been commented out for a while
         #return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)
         return (sudocmd, prompt, success_key)
 
diff --git a/v2/ansible/module_utils/basic.py b/v2/ansible/module_utils/basic.py
index f772d6a706..cd4d602453 100644
--- a/v2/ansible/module_utils/basic.py
+++ b/v2/ansible/module_utils/basic.py
@@ -301,7 +301,7 @@ class AnsibleModule(object):
 
         self.params = self._load_params()
 
-        self._legal_inputs = ['CHECKMODE', 'NO_LOG']
+        self._legal_inputs = ['_ansible_check_mode', '_ansible_no_log']
         
         self.aliases = self._handle_aliases()
 
@@ -817,7 +817,7 @@ class AnsibleModule(object):
 
     def _check_for_check_mode(self):
         for (k,v) in self.params.iteritems():
-            if k == 'CHECKMODE':
+            if k == '_ansible_check_mode':
                 if not self.supports_check_mode:
                     self.exit_json(skipped=True, msg="remote module does not support check mode")
                 if self.supports_check_mode:
@@ -825,13 +825,13 @@ class AnsibleModule(object):
 
     def _check_for_no_log(self):
         for (k,v) in self.params.iteritems():
-            if k == 'NO_LOG':
+            if k == '_ansible_no_log':
                 self.no_log = self.boolean(v)
 
     def _check_invalid_arguments(self):
         for (k,v) in self.params.iteritems():
             # these should be in legal inputs already
-            #if k in ('CHECKMODE', 'NO_LOG'):
+            #if k in ('_ansible_check_mode', '_ansible_no_log'):
             #    continue
             if k not in self._legal_inputs:
                 self.fail_json(msg="unsupported parameter for module: %s" % k)
diff --git a/v2/ansible/modules/core b/v2/ansible/modules/core
index e2083bbe8a..890dfecb56 160000
--- a/v2/ansible/modules/core
+++ b/v2/ansible/modules/core
@@ -1 +1 @@
-Subproject commit e2083bbe8a6baf63a363617f5b4590a3a8ff6e89
+Subproject commit 890dfecb565b7287af7a21c1ad93d0051801dce7
diff --git a/v2/ansible/plugins/action/__init__.py b/v2/ansible/plugins/action/__init__.py
index 4ca179a104..6eb69e45d6 100644
--- a/v2/ansible/plugins/action/__init__.py
+++ b/v2/ansible/plugins/action/__init__.py
@@ -52,6 +52,8 @@ class ActionBase:
         self._module_loader   = module_loader
         self._shell           = self.get_shell()
 
+        self._supports_check_mode = True
+
     def get_shell(self):
 
         # FIXME: no more inject, get this from the host variables?
@@ -327,6 +329,16 @@ class ActionBase:
         if module_args is None:
             module_args = self._task.args
 
+        # set check mode in the module arguments, if required
+        if self._connection_info.check_mode and not self._task.always_run:
+            if not self._supports_check_mode:
+                raise AnsibleError("check mode is not supported for this operation")
+            module_args['_ansible_check_mode'] = True
+
+        # set no log in the module arguments, if required
+        if self._connection_info.no_log:
+            module_args['_ansible_no_log'] = True
+
         debug("in _execute_module (%s, %s)" % (module_name, module_args))
 
         (module_style, shebang, module_data) = self._configure_module(module_name=module_name, module_args=module_args)
@@ -339,7 +351,7 @@ class ActionBase:
             tmp = self._make_tmp_path()
             remote_module_path = self._shell.join_path(tmp, module_name)
 
-        # FIXME: async stuff here
+        # FIXME: async stuff here?
         #if (module_style != 'new' or async_jid is not None or not self._connection._has_pipelining or not C.ANSIBLE_SSH_PIPELINING or C.DEFAULT_KEEP_REMOTE_FILES):
         if remote_module_path:
             self._transfer_data(remote_module_path, module_data)
diff --git a/v2/ansible/plugins/action/normal.py b/v2/ansible/plugins/action/normal.py
index 23e6e22d27..66721b4eb2 100644
--- a/v2/ansible/plugins/action/normal.py
+++ b/v2/ansible/plugins/action/normal.py
@@ -21,19 +21,6 @@ class ActionModule(ActionBase):
 
     def run(self, tmp=None, task_vars=dict()):
 
-        # FIXME: a lot of this should pretty much go away with module
-        #        args being stored within the task being run itself
-
-        #if self.runner.noop_on_check(inject):
-        #    if module_name in [ 'shell', 'command' ]:
-        #        return ReturnData(conn=conn, comm_ok=True, result=dict(skipped=True, msg='check mode not supported for %s' % module_name))
-        #    # else let the module parsing code decide, though this will only be allowed for AnsibleModuleCommon using
-        #    # python modules for now
-        #    module_args += " CHECKMODE=True"
-
-        #if self.runner.no_log:
-        #    module_args += " NO_LOG=True"
-
         #vv("REMOTE_MODULE %s %s" % (module_name, module_args), host=conn.host)
         return self._execute_module(tmp)
 

commit 3ec469f90424d8ede69e754568a40d8a0779dd0d
Author: Kairo Araujo <kairo@kairo.eti.br>
Date:   Tue Jan 8 23:41:58 2019 +0100

     Included support to AIX group of subsystems on service module (#33043)
    
    * Included support to AIX group subsystems
    
    AIX systems has subsystems as services but also uses group
    subsystems.
    For example, spooler is a group subsystem to services
    qdaemon, writesrv, and lpd.
    This change enables the possibility to use also the group
    susbsystmes such as spooler, nfs, etc.
    
    When the service name is informed, first the module will
    check if the name is a subsystem, if not it will check if
    the name is a group subsystem and also it subsystems states.
    
    This change makes services more flexible with AIX systems.
    
    * Included test/legacy/aix_services.yml for tests
    
    As discussed on IRC ansible-devel channes, was include the
    legacy tests for further manual tests.

diff --git a/lib/ansible/modules/system/service.py b/lib/ansible/modules/system/service.py
index 7700128cfd..8ed4189304 100644
--- a/lib/ansible/modules/system/service.py
+++ b/lib/ansible/modules/system/service.py
@@ -68,6 +68,7 @@ options:
         default: auto
         version_added: 2.2
 notes:
+    - For AIX group subsystem names can be used.
     - For Windows targets, use the M(win_service) module instead.
 seealso:
 - module: win_service
@@ -1484,19 +1485,64 @@ class AIX(Service):
             self.running = False
 
     def get_aix_src_status(self):
+        # Check subsystem status
         rc, stdout, stderr = self.execute_command("%s -s %s" % (self.lssrc_cmd, self.name))
+        if rc == 1:
+            # If check for subsystem is not ok, check if service name is a
+            # group subsystem
+            rc, stdout, stderr = self.execute_command("%s -g %s" % (self.lssrc_cmd, self.name))
+            if rc == 1:
+                if stderr:
+                    self.module.fail_json(msg=stderr)
+                else:
+                    self.module.fail_json(msg=stdout)
+            else:
+                # Check all subsystem status, if one subsystem is not active
+                # the group is considered not active.
+                lines = stdout.splitlines()
+                for state in lines[1:]:
+                    if state.split()[-1].strip() != "active":
+                        status = state.split()[-1].strip()
+                        break
+                else:
+                    status = "active"
+
+                # status is one of: active, inoperative
+                return status
+        else:
+            lines = stdout.rstrip("\n").split("\n")
+            status = lines[-1].split(" ")[-1]
+
+            # status is one of: active, inoperative
+            return status
+
+    def service_control(self):
+
+        # Check if service name is a subsystem of a group subsystem
+        rc, stdout, stderr = self.execute_command("%s -a" % (self.lssrc_cmd))
         if rc == 1:
             if stderr:
                 self.module.fail_json(msg=stderr)
             else:
                 self.module.fail_json(msg=stdout)
+        else:
+            lines = stdout.splitlines()
+            subsystems = []
+            groups = []
+            for line in lines[1:]:
+                subsystem = line.split()[0].strip()
+                group = line.split()[1].strip()
+                subsystems.append(subsystem)
+                if group:
+                    groups.append(group)
+
+            # Define if service name parameter:
+            # -s subsystem or -g group subsystem
+            if self.name in subsystems:
+                srccmd_parameter = "-s"
+            elif self.name in groups:
+                srccmd_parameter = "-g"
 
-        lines = stdout.rstrip("\n").split("\n")
-        status = lines[-1].split(" ")[-1]
-        # status is one of: active, inoperative
-        return status
-
-    def service_control(self):
         if self.action == 'start':
             srccmd = self.startsrc_cmd
         elif self.action == 'stop':
@@ -1504,13 +1550,13 @@ class AIX(Service):
         elif self.action == 'reload':
             srccmd = self.refresh_cmd
         elif self.action == 'restart':
-            self.execute_command("%s -s %s" % (self.stopsrc_cmd, self.name))
+            self.execute_command("%s %s %s" % (self.stopsrc_cmd, srccmd_parameter, self.name))
             srccmd = self.startsrc_cmd
 
         if self.arguments and self.action == 'start':
-            return self.execute_command("%s -a \"%s\" -s %s" % (srccmd, self.arguments, self.name))
+            return self.execute_command("%s -a \"%s\" %s %s" % (srccmd, self.arguments, srccmd_parameter, self.name))
         else:
-            return self.execute_command("%s -s %s" % (srccmd, self.name))
+            return self.execute_command("%s %s %s" % (srccmd, srccmd_parameter, self.name))
 
 
 # ===========================================
diff --git a/test/legacy/aix_services.yml b/test/legacy/aix_services.yml
new file mode 100644
index 0000000000..4da434c935
--- /dev/null
+++ b/test/legacy/aix_services.yml
@@ -0,0 +1,24 @@
+---
+- name: Services/Subsystems tests for AIX
+  hosts: localhost
+  connection: local
+  tasks:
+    - name: spooler shutdown
+      service:
+        name: spooler
+        state: started
+
+    - name: stopping sendmail
+      service:
+        name: sendmail
+        state: stopped
+
+    - name: starting sendmail
+      service:
+        name: sendmail
+        state: started
+
+    - name: starting an inexistent subsystem and group subsystem
+      service:
+        name: fakeservice
+        state: stopped

commit 29209c49130665393967950154290188a8f609d6
Author: Michael DeHaan <michael.dehaan@gmail.com>
Date:   Wed Apr 10 16:37:49 2013 -0400

    Style fixes so "make pep8" is clean.

diff --git a/lib/ansible/inventory/__init__.py b/lib/ansible/inventory/__init__.py
index 69a0431533..f29d61a10e 100644
--- a/lib/ansible/inventory/__init__.py
+++ b/lib/ansible/inventory/__init__.py
@@ -334,12 +334,12 @@ class Inventory(object):
             results = []
             # allow Unix style @filename data
             for x in subset_pattern:
-               if x.startswith("@"):
-                   fd = open(x[1:])
-                   results.extend(fd.read().split("\n"))
-                   fd.close()
-               else:
-                   results.append(x)
+                if x.startswith("@"):
+                    fd = open(x[1:])
+                    results.extend(fd.read().split("\n"))
+                    fd.close()
+                else:
+                    results.append(x)
             self._subset = results
 
     def lift_restriction(self):
diff --git a/lib/ansible/playbook/__init__.py b/lib/ansible/playbook/__init__.py
index cf88ba7d83..4c1cc54e1d 100644
--- a/lib/ansible/playbook/__init__.py
+++ b/lib/ansible/playbook/__init__.py
@@ -505,7 +505,7 @@ class PlayBook(object):
                 host_list = self._list_available_hosts(play.hosts)
 
                 if task.any_errors_fatal and len(host_list) < hosts_count:
-                  host_list = None
+                    host_list = None
 
                 # if no hosts remain, drop out
                 if not host_list:
diff --git a/lib/ansible/playbook/play.py b/lib/ansible/playbook/play.py
index dcb67bdc0d..b589ccf9aa 100644
--- a/lib/ansible/playbook/play.py
+++ b/lib/ansible/playbook/play.py
@@ -90,7 +90,7 @@ class Play(object):
 
         load_vars = {}
         if self.playbook.inventory.basedir() is not None:
-            load_vars['inventory_dir'] = self.playbook.inventory.basedir();
+            load_vars['inventory_dir'] = self.playbook.inventory.basedir()
 
         self._tasks      = self._load_tasks(self._ds.get('tasks', []), load_vars)
         self._handlers   = self._load_tasks(self._ds.get('handlers', []), load_vars)
@@ -226,7 +226,7 @@ class Play(object):
                         mv[k] = utils.template(self.basedir, v, mv)
                     dirname = self.basedir
                     if original_file:
-                         dirname = os.path.dirname(original_file)     
+                        dirname = os.path.dirname(original_file)     
                     include_file = utils.template(dirname, tokens[0], mv)
                     include_filename = utils.path_dwim(dirname, include_file)
                     data = utils.parse_yaml_from_file(include_filename)
diff --git a/lib/ansible/utils/__init__.py b/lib/ansible/utils/__init__.py
index 5ed717601d..1000d035cb 100644
--- a/lib/ansible/utils/__init__.py
+++ b/lib/ansible/utils/__init__.py
@@ -674,33 +674,33 @@ def get_diff(diff):
         return ">> the files are different, but the diff library cannot compare unicode strings"
 
 def is_list_of_strings(items):
-   for x in items: 
-       if not isinstance(x, basestring):
-           return False
-   return True
+    for x in items: 
+        if not isinstance(x, basestring):
+            return False
+    return True
 
 def safe_eval(str):
-   ''' 
-   this is intended for allowing things like:
-   with_items: {{ a_list_variable }}
-   where Jinja2 would return a string
-   but we do not want to allow it to call functions (outside of Jinja2, where
-   the env is constrained)
-   '''
-   # FIXME: is there a more native way to do this?
+    ''' 
+    this is intended for allowing things like:
+    with_items: {{ a_list_variable }}
+    where Jinja2 would return a string
+    but we do not want to allow it to call functions (outside of Jinja2, where
+    the env is constrained)
+    '''
+    # FIXME: is there a more native way to do this?
     
-   def is_set(var):
-       return not var.startswith("$") and not '{{' in var
-   def is_unset(var):
-       return var.startswith("$") or '{{' in var
-
-   # do not allow method calls to modules
-   if re.search(r'\w\.\w+\(', str):
-       return str
-   # do not allow imports
-   if re.search(r'import \w+', str):
-       return str
-   return eval(str)
+    def is_set(var):
+        return not var.startswith("$") and not '{{' in var
+    def is_unset(var):
+        return var.startswith("$") or '{{' in var
+
+    # do not allow method calls to modules
+    if re.search(r'\w\.\w+\(', str):
+        return str
+    # do not allow imports
+    if re.search(r'import \w+', str):
+        return str
+    return eval(str)
 
 
 
diff --git a/library/ec2 b/library/ec2
index 70f0ea02bd..e923a6fbfa 100644
--- a/library/ec2
+++ b/library/ec2
@@ -267,13 +267,11 @@ def main():
         
     if id != None:
         filter_dict = {'client-token':id, 'instance-state-name' : 'running'}
-        previous_reservations = ec2.get_all_instances(None, filter_dict )
+        previous_reservations = ec2.get_all_instances(None, filter_dict)
         for res in previous_reservations:
             for prev_instance in res.instances:
                 running_instances.append(prev_instance)
         count_remaining = count_remaining - len(running_instances) 
-#        module.fail_json(msg = "known running instances: %s" % (running_instances)) 
-
     
     # Both min_count and max_count equal count parameter. This means the launch request is explicit (we want count, or fail) in how many instances we want.
 
diff --git a/library/macports b/library/macports
index 4b61b9ff91..2ba6effe37 100644
--- a/library/macports
+++ b/library/macports
@@ -136,7 +136,7 @@ def activate_packages(module, port_path, packages):
 
     for package in packages:
         if not query_package(module, port_path, package):
-           module.fail_json(msg="failed to activate %s, package(s) not present" % (package))
+            module.fail_json(msg="failed to activate %s, package(s) not present" % (package))
 
         if query_package(module, port_path, package, state="active"):
             continue
@@ -161,7 +161,7 @@ def deactivate_packages(module, port_path, packages):
 
     for package in packages:
         if not query_package(module, port_path, package):
-           module.fail_json(msg="failed to activate %s, package(s) not present" % (package))
+            module.fail_json(msg="failed to activate %s, package(s) not present" % (package))
 
         if not query_package(module, port_path, package, state="active"):
             continue
diff --git a/library/nagios b/library/nagios
index 86db27f5cb..38846306b8 100644
--- a/library/nagios
+++ b/library/nagios
@@ -345,7 +345,7 @@ class Nagios(object):
             notif_str += ";%s" % host
             
             if svc is not None:
-                notif_str += ";%s" %  svc
+                notif_str += ";%s" % svc
 
         notif_str += "\n"
 
diff --git a/library/openbsd_pkg b/library/openbsd_pkg
index 11556e34a2..f5bd6b5dbe 100644
--- a/library/openbsd_pkg
+++ b/library/openbsd_pkg
@@ -77,7 +77,7 @@ def get_current_name(name, specific_version):
 
     for line in stdout.splitlines():
         if syntax % name in line:
-           current_name = line.split()[0]
+            current_name = line.split()[0]
 
     return current_name
 
diff --git a/library/service b/library/service
index 2a419d41b4..61aa48990b 100644
--- a/library/service
+++ b/library/service
@@ -385,9 +385,9 @@ class LinuxService(Service):
 
             look_for = "%s.service" % name
             for line in out.splitlines():
-               if line.startswith(look_for):
-                   self.enable_cmd = location['systemctl']
-                   break
+                if line.startswith(look_for):
+                    self.enable_cmd = location['systemctl']
+                    break
 
         # Locate a tool for runtime service management (start, stop etc.)
         self.svc_cmd = ''
diff --git a/library/setup b/library/setup
index 7493aa5e40..3b1e988ca8 100644
--- a/library/setup
+++ b/library/setup
@@ -853,29 +853,29 @@ class AIX(Hardware):
         self.facts['firmware_version'] = data[1].strip('IBM,')
 
 class Darwin(Hardware):
-   """
-   Darwin-specific subclass of Hardware.  Defines memory and CPU facts:
-   - processor
-   - processor_cores
-   - memtotal_mb
-   - memfree_mb
-   - model
-   - osversion
-   - osrevision
-   """
-   platform = 'Darwin'
-
-   def __init__(self):
+    """
+    Darwin-specific subclass of Hardware.  Defines memory and CPU facts:
+    - processor
+    - processor_cores
+    - memtotal_mb
+    - memfree_mb
+    - model
+    - osversion
+    - osrevision
+    """
+    platform = 'Darwin'
+
+    def __init__(self):
         Hardware.__init__(self)
 
-   def populate(self):
+    def populate(self):
         self.sysctl = self.get_sysctl()
         self.get_mac_facts()
         self.get_cpu_facts()
         self.get_memory_facts()
         return self.facts
 
-   def get_sysctl(self):
+    def get_sysctl(self):
         rc, out, err = module.run_command(["/usr/sbin/sysctl", "hw", "machdep", "kern"])
         if rc != 0:
             return dict()
@@ -886,16 +886,16 @@ class Darwin(Hardware):
                 sysctl[key] = value.strip()
         return sysctl
 
-   def get_mac_facts(self):
+    def get_mac_facts(self):
         self.facts['model'] = self.sysctl['hw.model']
         self.facts['osversion'] = self.sysctl['kern.osversion']
         self.facts['osrevision'] = self.sysctl['kern.osrevision']
 
-   def get_cpu_facts(self):
+    def get_cpu_facts(self):
         self.facts['processor'] = self.sysctl['machdep.cpu.brand_string']
         self.facts['processor_cores'] = self.sysctl['machdep.cpu.core_count']
 
-   def get_memory_facts(self):
+    def get_memory_facts(self):
         self.facts['memtotal_mb'] = long(self.sysctl['hw.memsize']) / 1024 / 1024
         self.facts['memfree_mb'] = long(self.sysctl['hw.usermem']) / 1024 / 1024
 
diff --git a/library/vagrant b/library/vagrant
index a00be92b5f..3b97efc169 100644
--- a/library/vagrant
+++ b/library/vagrant
@@ -181,7 +181,7 @@ class VagrantWrapper(object):
             self._deserialize()
             
             this_instance_dict = self._get_instance(vm_name,icount)
-            if not this_instance_dict.has_key('box_name'): 
+            if not 'box_name' in this_instance_dict:
                 this_instance_dict['box_name'] = box_name   
                      
             this_instance_dict['forward_ports'] = ports  
@@ -205,7 +205,8 @@ class VagrantWrapper(object):
     def status(self, vm_name = None, index = -1):
         '''Return the run status of the VM instance. If no instance N is given, returns first instance.'''
         vm_names = []
-        if vm_name != None: vm_names = [vm_name]
+        if vm_name != None: 
+            vm_names = [vm_name]
         else:
             vm_names = self._instances().keys()
         
@@ -225,7 +226,8 @@ class VagrantWrapper(object):
     def config(self, vm_name, index = -1):
         '''Return info on SSH for the running instance.'''
         vm_names = []
-        if vm_name != None: vm_names = [vm_name]
+        if vm_name != None: 
+            vm_names = [vm_name]
         else:
             vm_names = self._instances().keys()
         
@@ -247,7 +249,8 @@ class VagrantWrapper(object):
         
         changed = False
         vm_names = []
-        if vm_name != None: vm_names = [vm_name]
+        if vm_name != None: 
+            vm_names = [vm_name]
         else:
             vm_names = self._instances().keys()
         
@@ -300,6 +303,7 @@ class VagrantWrapper(object):
 #
 # Helper Methods
 #
+
     def _instances(self): 
         return self.vg_data['instances']
     
@@ -308,7 +312,7 @@ class VagrantWrapper(object):
         instances = self._instances()
 
         inst_array = []        
-        if instances.has_key(vm_name):
+        if vm_name in instances:
             inst_array = instances[vm_name]
             
         if len(inst_array) > index: 
@@ -393,18 +397,17 @@ class VagrantWrapper(object):
                 name     = instance_dict['vagrant_name']
                 ip       = instance_dict['internal_ip']
                 box_name = instance_dict['box_name']
-                vfile.write(VAGRANT_FILE_VM_STANZA_HEAD % 
-                            (name, name, name, ip, name, box_name) )
-                if instance_dict.has_key('ram'):
-                    vfile.write(VAGRANT_FILE_MEMORY_LINE  % (name, instance_dict['ram'])  )   
-                vfile.write(VAGRANT_FILE_HOSTNAME_LINE  % (name, name.replace('_','-'))  )       
-                if instance_dict.has_key('forward_ports'):
+                vfile.write(VAGRANT_FILE_VM_STANZA_HEAD % (name, name, name, ip, name, box_name))
+                if 'ram' in instance_dict:
+                    vfile.write(VAGRANT_FILE_MEMORY_LINE  % (name, instance_dict['ram']))   
+                vfile.write(VAGRANT_FILE_HOSTNAME_LINE  % (name, name.replace('_','-')))       
+                if 'forward_ports' in instance_dict:
                     for port in instance_dict['forward_ports']:
                         port = int(port)
                         host_port = port
                         if port < 1024: 
                             host_port = port + 10000
-                        vfile.write(VAGRANT_FILE_PORT_FORWARD_LINE % (name, port, host_port) )
+                        vfile.write(VAGRANT_FILE_PORT_FORWARD_LINE % (name, port, host_port))
                 vfile.write(VAGRANT_FILE_VM_STANZA_TAIL)
   
         vfile.write(VAGRANT_FILE_TAIL)
@@ -522,14 +525,15 @@ def main():
             elif cmd == "config" or cmd == "conf":
             
                 if vm_name == None:
-                    module.fail_json(msg = "Error: you must specify a vm_name when calling config." )
+                    module.fail_json(msg = "Error: a vm_name is required when calling config.")
                 (changd, cnf) = vgw.config(vm_name)
                 module.exit_json(changed = changd, config = cnf)
 
             elif cmd == 'ssh':
-            
+                # this doesn't really seem to belong here, should just manage the VM with ansible -- MPD           
+ 
                 if vm_name == None:
-                    module.fail_json(msg = "Error: you must specify a vm_name when calling ssh." )             
+                    module.fail_json(msg = "Error: a vm_name is required when calling ssh.")
                             
                 (changd, cnf) = vgw.config(vm_name)
                 sshcmd = "ssh -i %s -p %s %s@%s" % (cnf["IdentityFile"], cnf["Port"], cnf["User"], cnf["HostName"])

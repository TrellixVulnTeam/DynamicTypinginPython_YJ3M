commit e802b769e6306c090a6a7f58c232aa855196a1be
Author: Steve Glendinning <steve.glendinning@shawell.net>
Date:   Tue Jan 9 19:07:31 2018 +0000

    Ios logging (#33151)
    
    * ios_logging: Handle IOS versions that dont put the word host in logging config
    
    This change allows the ansible module to parse and match either variant
    being present in running-config.
    
    * ios_logging: enhance logging buffered to handle both size and level
    
    This change allows ios_logging to ensure local (buffered) logging
    is configured with both the correct buffer size and logging level,
    when both are specified on the task.

diff --git a/lib/ansible/modules/network/ios/ios_logging.py b/lib/ansible/modules/network/ios/ios_logging.py
index 7515709be3..6ba3d3b4cc 100644
--- a/lib/ansible/modules/network/ios/ios_logging.py
+++ b/lib/ansible/modules/network/ios/ios_logging.py
@@ -169,7 +169,10 @@ def map_obj_to_commands(updates, module):
                 commands.append('logging on')
 
             elif dest == 'buffered' and size:
-                commands.append('logging buffered {0}'.format(size))
+                if level and level != 'debugging':
+                    commands.append('logging buffered {0} {1}'.format(size, level))
+                else:
+                    commands.append('logging buffered {0}'.format(size))
 
             else:
                 dest_cmd = 'logging {0}'.format(dest)
@@ -229,7 +232,11 @@ def parse_level(line, dest):
         level = 'debugging'
 
     else:
-        match = re.search(r'logging {0} (\S+)'.format(dest), line, re.M)
+        if dest == 'buffered':
+            match = re.search(r'logging buffered (?:\d+ )([a-z]+)', line, re.M)
+        else:
+            match = re.search(r'logging {0} (\S+)'.format(dest), line, re.M)
+
         if match:
             if match.group(1) in level_group:
                 level = match.group(1)
@@ -260,6 +267,16 @@ def map_config_to_obj(module):
                     'facility': parse_facility(line, dest),
                     'level': parse_level(line, dest)
                 })
+            else:
+                ip_match = re.search(r'\d+\.\d+\.\d+\.\d+', match.group(1), re.M)
+                if ip_match:
+                    dest = 'host'
+                    obj.append({
+                        'dest': dest,
+                        'name': match.group(1),
+                        'facility': parse_facility(line, dest),
+                        'level': parse_level(line, dest)
+                    })
     return obj
 
 

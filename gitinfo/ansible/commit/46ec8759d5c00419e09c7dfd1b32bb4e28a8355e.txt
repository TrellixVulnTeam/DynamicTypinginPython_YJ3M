commit 46ec8759d5c00419e09c7dfd1b32bb4e28a8355e
Author: Michael DeHaan <michael.dehaan@gmail.com>
Date:   Fri Feb 28 18:38:45 2014 -0500

    Remove the legacy templating code, which was guarded by deprecation warnings in the previous two releases, and undocumented for a long time.  use {{ foo }} to access variables instead of ${foo} or $foo.

diff --git a/lib/ansible/runner/__init__.py b/lib/ansible/runner/__init__.py
index 207862857a..a690f00857 100644
--- a/lib/ansible/runner/__init__.py
+++ b/lib/ansible/runner/__init__.py
@@ -75,11 +75,6 @@ def _executor_hook(job_queue, result_queue, new_stdin):
             host = job_queue.get(block=False)
             return_data = multiprocessing_runner._executor(host, new_stdin)
             result_queue.put(return_data)
-
-            if 'LEGACY_TEMPLATE_WARNING' in return_data.flags:
-                # pass data back up across the multiprocessing fork boundary
-                template.Flags.LEGACY_TEMPLATE_WARNING = True
-
         except Queue.Empty:
             pass
         except:
@@ -504,15 +499,6 @@ class Runner(object):
     def _executor(self, host, new_stdin):
         ''' handler for multiprocessing library '''
 
-        def get_flags():
-            # flags are a way of passing arbitrary event information
-            # back up the chain, since multiprocessing forks and doesn't
-            # allow state exchange
-            flags = []
-            if template.Flags.LEGACY_TEMPLATE_WARNING:
-                flags.append('LEGACY_TEMPLATE_WARNING')
-            return flags
-
         try:
             fileno = sys.stdin.fileno()
         except ValueError:
@@ -527,7 +513,6 @@ class Runner(object):
             exec_rc = self._executor_internal(host, new_stdin)
             if type(exec_rc) != ReturnData:
                 raise Exception("unexpected return type: %s" % type(exec_rc))
-            exec_rc.flags = get_flags()
             # redundant, right?
             if not exec_rc.comm_ok:
                 self.callbacks.on_unreachable(host, exec_rc.result)
@@ -535,11 +520,11 @@ class Runner(object):
         except errors.AnsibleError, ae:
             msg = str(ae)
             self.callbacks.on_unreachable(host, msg)
-            return ReturnData(host=host, comm_ok=False, result=dict(failed=True, msg=msg), flags=get_flags())
+            return ReturnData(host=host, comm_ok=False, result=dict(failed=True, msg=msg))
         except Exception:
             msg = traceback.format_exc()
             self.callbacks.on_unreachable(host, msg)
-            return ReturnData(host=host, comm_ok=False, result=dict(failed=True, msg=msg), flags=get_flags())
+            return ReturnData(host=host, comm_ok=False, result=dict(failed=True, msg=msg))
 
     # *****************************************************
 
diff --git a/lib/ansible/runner/return_data.py b/lib/ansible/runner/return_data.py
index 94e454cc98..8e2252d4a3 100644
--- a/lib/ansible/runner/return_data.py
+++ b/lib/ansible/runner/return_data.py
@@ -20,10 +20,10 @@ from ansible import utils
 class ReturnData(object):
     ''' internal return class for runner execute methods, not part of public API signature '''
 
-    __slots__ = [ 'result', 'comm_ok', 'host', 'diff', 'flags' ]
+    __slots__ = [ 'result', 'comm_ok', 'host', 'diff' ]
 
     def __init__(self, conn=None, host=None, result=None, 
-        comm_ok=True, diff=dict(), flags=None):
+        comm_ok=True, diff=dict()):
 
         # which host is this ReturnData about?
         if conn is not None:
@@ -51,10 +51,6 @@ class ReturnData(object):
         if type(self.result) != dict:
             raise Exception("dictionary result expected")
 
-        if flags is None:
-            flags = []
-        self.flags = []
-
     def communicated_ok(self):
         return self.comm_ok
 
diff --git a/lib/ansible/utils/template.py b/lib/ansible/utils/template.py
index 695524389c..fc4ff9fd20 100644
--- a/lib/ansible/utils/template.py
+++ b/lib/ansible/utils/template.py
@@ -93,219 +93,6 @@ def lookup(name, *args, **kwargs):
     else:
         raise errors.AnsibleError("lookup plugin (%s) not found" % name)
 
-def _legacy_varFindLimitSpace(basedir, vars, space, part, lookup_fatal, depth, expand_lists):
-    ''' limits the search space of space to part
-
-    basically does space.get(part, None), but with
-    templating for part and a few more things
-    '''
-
-    # Previous part couldn't be found, nothing to limit to
-    if space is None:
-        return space
-    # A part with escaped .s in it is compounded by { and }, remove them
-    if len(part) > 0 and part[0] == '{' and part[-1] == '}':
-        part = part[1:-1]
-    # Template part to resolve variables within (${var$var2})
-    part = legacy_varReplace(basedir, part, vars, lookup_fatal=lookup_fatal, depth=depth + 1, expand_lists=expand_lists)
-
-    # Now find it
-    if part in space:
-        space = space[part]
-    elif "[" in part:
-        m = _LISTRE.search(part)
-        if not m:
-            return None
-        else:
-            try:
-                space = space[m.group(1)][int(m.group(2))]
-            except (KeyError, IndexError):
-                return None
-    else:
-        return None
-
-    # if space is a string, check if it's a reference to another variable
-    if isinstance(space, basestring):
-        space = template(basedir, space, vars, lookup_fatal=lookup_fatal, depth=depth + 1, expand_lists=expand_lists)
-
-    return space
-
-def _legacy_varFind(basedir, text, vars, lookup_fatal, depth, expand_lists):
-    ''' Searches for a variable in text and finds its replacement in vars
-
-    The variables can have two formats;
-    - simple, $ followed by alphanumerics and/or underscores
-    - complex, ${ followed by alphanumerics, underscores, periods, braces and brackets, ended by a }
-
-    Examples:
-    - $variable: simple variable that will have vars['variable'] as its replacement
-    - ${variable.complex}: complex variable that will have vars['variable']['complex'] as its replacement
-    - $variable.complex: simple variable, identical to the first, .complex ignored
-
-    Complex variables are broken into parts by separating on periods, except if enclosed in {}.
-    ${variable.{fully.qualified.domain}} would be parsed as two parts, variable and fully.qualified.domain,
-    whereas ${variable.fully.qualified.domain} would be parsed as four parts.
-
-    Returns a dict(replacement=<value in vars>, start=<index into text where the variable stated>,
-        end=<index into text where the variable ends>)
-    or None if no variable could be found in text. If replacement is None, it should be replaced with the
-    original data in the caller.
-    '''
-
-    # short circuit this whole function if we have specified we don't want
-    # legacy var replacement
-    if C.DEFAULT_LEGACY_PLAYBOOK_VARIABLES == False:
-        return None
-
-    start = text.find("$")
-    if start == -1:
-        return None
-    # $ as last character
-    if start + 1 == len(text):
-        return None
-    # Escaped var
-    if start > 0 and text[start - 1] == '\\':
-        return {'replacement': '$', 'start': start - 1, 'end': start + 1}
-
-    var_start = start + 1
-    if text[var_start] == '{':
-        is_complex = True
-        brace_level = 1
-        var_start += 1
-    else:
-        is_complex = False
-        brace_level = 1
-
-    # is_lookup is true for $FILE(...) and friends
-    is_lookup = False
-    lookup_plugin_name = None
-    end = var_start
-
-    # part_start is an index of where the current part started
-    part_start = var_start
-    space = vars
-
-    while end < len(text) and (((is_lookup or is_complex) and brace_level > 0) or (not is_complex and not is_lookup)):
-
-        if text[end].isalnum() or text[end] == '_':
-            pass
-        elif not is_complex and not is_lookup and text[end] == '(' and text[part_start:end].isupper():
-            is_lookup = True
-            lookup_plugin_name = text[part_start:end]
-            part_start = end + 1
-        elif is_lookup and text[end] == '(':
-            brace_level += 1
-        elif is_lookup and text[end] == ')':
-            brace_level -= 1
-        elif is_lookup:
-            # lookups are allowed arbitrary contents
-            pass
-        elif is_complex and text[end] == '{':
-            brace_level += 1
-        elif is_complex and text[end] == '}':
-            brace_level -= 1
-        elif is_complex and text[end] in ('$', '[', ']', '-'):
-            pass
-        elif is_complex and text[end] == '.':
-            if brace_level == 1:
-                space = _legacy_varFindLimitSpace(basedir, vars, space, text[part_start:end], lookup_fatal, depth, expand_lists)
-                part_start = end + 1
-        else:
-            # This breaks out of the loop on non-variable name characters
-            break
-        end += 1
-
-    var_end = end
-
-    # Handle "This has $ in it"
-    if var_end == part_start:
-        return {'replacement': None, 'start': start, 'end': end}
-
-    # Handle lookup plugins
-    if is_lookup:
-        # When basedir is None, handle lookup plugins later
-        if basedir is None:
-            return {'replacement': None, 'start': start, 'end': end}
-        var_end -= 1
-        from ansible import utils
-        args = text[part_start:var_end]
-        if lookup_plugin_name == 'LOOKUP':
-            lookup_plugin_name, args = args.split(",", 1)
-            args = args.strip()
-        # args have to be templated
-        args = legacy_varReplace(basedir, args, vars, lookup_fatal, depth + 1, True)
-        if isinstance(args, basestring) and args.find('$') != -1:
-            # unable to evaluate something like $FILE($item) at this point, try to evaluate later
-            return None
-
-
-        instance = utils.plugins.lookup_loader.get(lookup_plugin_name.lower(), basedir=basedir)
-        if instance is not None:
-            try:
-                replacement = instance.run(args, inject=vars)
-                if expand_lists:
-                    replacement = ",".join([unicode(x) for x in replacement])
-            except:
-                if not lookup_fatal:
-                    replacement = None
-                else:
-                    raise
-
-        else:
-            replacement = None
-        return dict(replacement=replacement, start=start, end=end)
-
-    if is_complex:
-        var_end -= 1
-        if text[var_end] != '}' or brace_level != 0:
-            return None
-    space = _legacy_varFindLimitSpace(basedir, vars, space, text[part_start:var_end], lookup_fatal, depth, expand_lists)
-    return dict(replacement=space, start=start, end=end)
-
-def legacy_varReplace(basedir, raw, vars, lookup_fatal=True, depth=0, expand_lists=False):
-    ''' Perform variable replacement of $variables in string raw using vars dictionary '''
-    # this code originally from yum
-
-    orig = raw
-
-    if not isinstance(raw, unicode):
-        raw = raw.decode("utf-8")
-
-    if (depth > 20):
-        raise errors.AnsibleError("template recursion depth exceeded")
-
-    done = [] # Completed chunks to return
-
-    while raw:
-        m = _legacy_varFind(basedir, raw, vars, lookup_fatal, depth, expand_lists)
-        if not m:
-            done.append(raw)
-            break
-
-        # Determine replacement value (if unknown variable then preserve
-        # original)
-
-        replacement = m['replacement']
-        if expand_lists and isinstance(replacement, (list, tuple)):
-            replacement = ",".join([str(x) for x in replacement])
-        if isinstance(replacement, (str, unicode)):
-            replacement = legacy_varReplace(basedir, replacement, vars, lookup_fatal, depth=depth+1, expand_lists=expand_lists)
-        if replacement is None:
-            replacement = raw[m['start']:m['end']]
-
-        start, end = m['start'], m['end']
-        done.append(raw[:start])          # Keep stuff leading up to token
-        done.append(unicode(replacement)) # Append replacement value
-        raw = raw[end:]                   # Continue with remainder of string
-
-    result = ''.join(done)
-
-    if (not '\$' in orig) and (result != orig):
-        from ansible import utils
-        # above check against \$ as templating will remove the backslash
-        utils.deprecated("Legacy variable substitution, such as using ${foo} or $foo instead of {{ foo }} is currently valid but will be phased out and has been out of favor since version 1.2. This is the last of legacy features on our deprecation list. You may continue to use this if you have specific needs for now","1.6")
-    return result
-
 def template(basedir, varname, vars, lookup_fatal=True, depth=0, expand_lists=True, convert_bare=False, fail_on_undefined=False, filter_fatal=True):
     ''' templates a data structure by traversing it and substituting for other data structures '''
     from ansible import utils
@@ -325,21 +112,7 @@ def template(basedir, varname, vars, lookup_fatal=True, depth=0, expand_lists=Tr
                     if eval_results[1] is None:
                         varname = eval_results[0]
 
-            if not '$' in varname:
-                return varname
-    
-            m = _legacy_varFind(basedir, varname, vars, lookup_fatal, depth, expand_lists)
-            if not m:
-                return varname
-            if m['start'] == 0 and m['end'] == len(varname):
-                if m['replacement'] is not None:
-                    Flags.LEGACY_TEMPLATE_WARNING = True
-                    return template(basedir, m['replacement'], vars, lookup_fatal, depth, expand_lists)
-                else:
-                    return varname
-            else:
-                Flags.LEGACY_TEMPLATE_WARNING = True
-                return legacy_varReplace(basedir, varname, vars, lookup_fatal, depth, expand_lists)
+            return varname
     
         elif isinstance(varname, (list, tuple)):
             return [template(basedir, v, vars, lookup_fatal, depth, expand_lists, fail_on_undefined=fail_on_undefined) for v in varname]
@@ -537,9 +310,6 @@ def template_from_string(basedir, data, vars, fail_on_undefined=False):
             if os.path.exists(filesdir):
                 basedir = filesdir
 
-        # TODO: may need some way of using lookup plugins here seeing we aren't calling
-        # the legacy engine, lookup() as a function, perhaps?
-
         data = data.decode('utf-8')
         try:
             t = environment.from_string(data)
diff --git a/test/integration/roles/test_fetch/tasks/main.yml b/test/integration/roles/test_fetch/tasks/main.yml
index 172f84c77c..78a438f0ba 100644
--- a/test/integration/roles/test_fetch/tasks/main.yml
+++ b/test/integration/roles/test_fetch/tasks/main.yml
@@ -30,7 +30,7 @@
 # fetch module.
 
 - name: diff what we fetched with the original file
-  shell: diff {{ output_dir }}/orig {{ output_dir }}/fetched/127.0.0.1/root/ansible_testing/orig
+  shell: diff {{ output_dir }}/orig {{ output_dir }}/fetched/127.0.0.1{{ output_dir | expanduser }}/orig
   register: diff
 
 - name: check the diff to make sure they are the same

commit 74e4ccb59bbee1564e9a8c954caafbf9b2ed8c8a
Author: Michael DeHaan <michael.dehaan@gmail.com>
Date:   Tue Dec 10 19:23:52 2013 -0500

    Revert "ssh_alt.py / decrease # of ssh roundtrips"
    
    This reverts commit 7f8863f96db53144c73dfb79edce5173fa362b35.

diff --git a/lib/ansible/runner/__init__.py b/lib/ansible/runner/__init__.py
index 6c5f52b4f6..df9c3cacf1 100644
--- a/lib/ansible/runner/__init__.py
+++ b/lib/ansible/runner/__init__.py
@@ -286,7 +286,7 @@ class Runner(object):
     def _execute_module(self, conn, tmp, module_name, args,
         async_jid=None, async_module=None, async_limit=None, inject=None, persist_files=False, complex_args=None):
 
-        ''' transfer and run a module along with its arguments on the remote side'''
+        ''' runs a module that has already been transferred '''
 
         # hack to support fireball mode
         if module_name == 'fireball':
@@ -294,24 +294,12 @@ class Runner(object):
             if 'port' not in args:
                 args += " port=%s" % C.ZEROMQ_PORT
 
-        (
-        module_style,
-        shebang,
-        module_data
-        ) = self._configure_module(conn, module_name, args, inject, complex_args)
-
-        # a remote tmp path may be necessary and not already created
-        if self._late_needs_tmp_path(conn, tmp, module_style):
-            tmp = self._make_tmp_path(conn)
-
-        remote_module_path = os.path.join(tmp, module_name)
-
-        if not conn.has_pipelining:
-            self._transfer_str(conn, tmp, module_name, module_data)
+        (remote_module_path, module_style, shebang) = self._copy_module(conn, tmp, module_name, args, inject, complex_args)
 
         environment_string = self._compute_environment_string(inject)
 
-        if tmp.find("tmp") != -1 and self.sudo and self.sudo_user != 'root':
+        cmd_mod = ""
+        if self.sudo and self.sudo_user != 'root':
             # deal with possible umask issues once sudo'ed to other user
             cmd_chmod = "chmod a+r %s" % remote_module_path
             self._low_level_exec_command(conn, cmd_chmod, tmp, sudoable=False)
@@ -355,9 +343,6 @@ class Runner(object):
         if not shebang:
             raise errors.AnsibleError("module is missing interpreter line")
 
-        if conn.has_pipelining:
-            cmd = ""
-
         cmd = " ".join([environment_string.strip(), shebang.replace("#!","").strip(), cmd])
         cmd = cmd.strip()
 
@@ -372,16 +357,12 @@ class Runner(object):
             # specified in the play, not the sudo_user
             sudoable = False
 
-        in_data = None
-        if conn.has_pipelining:
-            in_data = module_data
+        res = self._low_level_exec_command(conn, cmd, tmp, sudoable=sudoable)
 
-        res = self._low_level_exec_command(conn, cmd, tmp, sudoable=sudoable, in_data=in_data)
-
-        if tmp.find("tmp") != -1 and not C.DEFAULT_KEEP_REMOTE_FILES and not persist_files:
-            if self.sudo and self.sudo_user != 'root':
+        if self.sudo and self.sudo_user != 'root':
             # not sudoing to root, so maybe can't delete files as that other user
             # have to clean up temp files as original user in a second step
+            if tmp.find("tmp") != -1 and not C.DEFAULT_KEEP_REMOTE_FILES and not persist_files:
                 cmd2 = "rm -rf %s >/dev/null 2>&1" % tmp
                 self._low_level_exec_command(conn, cmd2, tmp, sudoable=False)
 
@@ -689,8 +670,8 @@ class Runner(object):
             return ReturnData(host=host, comm_ok=False, result=result)
 
         tmp = ''
-        # action plugins may DECLARE via TRANSFERS_FILES = True that they need a remote tmp path working dir
-        if self._early_needs_tmp_path(module_name, handler):
+        # all modules get a tempdir, action plugins get one unless they have NEEDS_TMPPATH set to False
+        if getattr(handler, 'NEEDS_TMPPATH', True):
             tmp = self._make_tmp_path(conn)
 
         # render module_args and complex_args templates
@@ -716,7 +697,7 @@ class Runner(object):
                     delay = float(delay)
                     time.sleep(delay)
                     tmp = ''
-                    if self._early_needs_tmp_path(module_name, handler):
+                    if getattr(handler, 'NEEDS_TMPPATH', True):
                         tmp = self._make_tmp_path(conn)
                     result = handler.run(conn, tmp, module_name, module_args, inject, complex_args)
                     result.result['attempts'] = x
@@ -772,29 +753,9 @@ class Runner(object):
                 self.callbacks.on_ok(host, data)
         return result
 
-    def _early_needs_tmp_path(self, module_name, handler):
-        ''' detect if a tmp path should be created before the handler is called '''
-        if module_name in utils.plugins.action_loader:
-          return getattr(handler, 'TRANSFERS_FILES', False)
-        # other modules never need tmp path at early stage
-        return False
-
-    def _late_needs_tmp_path(self, conn, tmp, module_style):
-        if tmp.find("tmp") != -1:
-            # tmp has already been created
-            return False
-        if not conn.has_pipelining:
-            # tmp is necessary to store the module source code
-            return True
-        if module_style != "new":
-            # even when conn has pipelining, old style modules need tmp to store arguments
-            return True
-        return False
-    
-
     # *****************************************************
 
-    def _low_level_exec_command(self, conn, cmd, tmp, sudoable=False, executable=None, in_data=None):
+    def _low_level_exec_command(self, conn, cmd, tmp, sudoable=False, executable=None):
         ''' execute a command string over SSH, return the output '''
 
         if executable is None:
@@ -807,7 +768,7 @@ class Runner(object):
             if conn.user == sudo_user:
                 sudoable = False
 
-        rc, stdin, stdout, stderr = conn.exec_command(cmd, tmp, sudo_user, sudoable=sudoable, executable=executable, in_data=in_data)
+        rc, stdin, stdout, stderr = conn.exec_command(cmd, tmp, sudo_user, sudoable=sudoable, executable=executable)
 
         if type(stdout) not in [ str, unicode ]:
             out = ''.join(stdout.readlines())
@@ -897,39 +858,27 @@ class Runner(object):
             raise errors.AnsibleError('failed to resolve remote temporary directory from %s: `%s` returned empty string' % (basetmp, cmd))
         return rc
 
+
     # *****************************************************
 
     def _copy_module(self, conn, tmp, module_name, module_args, inject, complex_args=None):
         ''' transfer a module over SFTP, does not run it '''
-        (
-        module_style,
-        module_shebang,
-        module_data
-        ) = self._configure_module(conn, module_name, module_args, inject, complex_args)
-        module_remote_path = os.path.join(tmp, module_name)
-        
-        self._transfer_str(conn, tmp, module_name, module_data)
-         
-        return (module_remote_path, module_style, module_shebang)
-
-    # *****************************************************
-
-    def _configure_module(self, conn, module_name, module_args, inject, complex_args=None):
-        ''' find module and configure it '''
 
         # Search module path(s) for named module.
-        module_path = utils.plugins.module_finder.find_plugin(module_name)
-        if module_path is None:
+        in_path = utils.plugins.module_finder.find_plugin(module_name)
+        if in_path is None:
             raise errors.AnsibleFileNotFound("module %s not found in %s" % (module_name, utils.plugins.module_finder.print_paths()))
 
+        out_path = os.path.join(tmp, module_name)
 
         # insert shared code and arguments into the module
-        (module_data, module_style, module_shebang) = module_replacer.modify_module(
-            module_path, complex_args, module_args, inject
+        (module_data, module_style, shebang) = module_replacer.modify_module(
+            in_path, complex_args, module_args, inject
         )
 
-        return (module_style, module_shebang, module_data)
+        self._transfer_str(conn, tmp, module_name, module_data)
 
+        return (out_path, module_style, shebang)
 
     # *****************************************************
 
diff --git a/lib/ansible/runner/action_plugins/add_host.py b/lib/ansible/runner/action_plugins/add_host.py
index bcd1a90ae9..ef27d99275 100644
--- a/lib/ansible/runner/action_plugins/add_host.py
+++ b/lib/ansible/runner/action_plugins/add_host.py
@@ -29,7 +29,7 @@ class ActionModule(object):
 
     ### We need to be able to modify the inventory
     BYPASS_HOST_LOOP = True
-    TRANSFERS_FILES = False
+    NEEDS_TMPPATH = False
 
     def __init__(self, runner):
         self.runner = runner
diff --git a/lib/ansible/runner/action_plugins/assemble.py b/lib/ansible/runner/action_plugins/assemble.py
index 3f55023aa9..ad6caf3c6f 100644
--- a/lib/ansible/runner/action_plugins/assemble.py
+++ b/lib/ansible/runner/action_plugins/assemble.py
@@ -26,8 +26,6 @@ from ansible.runner.return_data import ReturnData
 
 class ActionModule(object):
 
-    TRANSFERS_FILES = True
-
     def __init__(self, runner):
         self.runner = runner
 
diff --git a/lib/ansible/runner/action_plugins/copy.py b/lib/ansible/runner/action_plugins/copy.py
index e65cab4426..00f12a8bc1 100644
--- a/lib/ansible/runner/action_plugins/copy.py
+++ b/lib/ansible/runner/action_plugins/copy.py
@@ -35,8 +35,6 @@ sys.setdefaultencoding("utf8")
 
 class ActionModule(object):
 
-    TRANSFERS_FILES = True
-
     def __init__(self, runner):
         self.runner = runner
 
diff --git a/lib/ansible/runner/action_plugins/debug.py b/lib/ansible/runner/action_plugins/debug.py
index 93879c1a8c..ee9c6ec32b 100644
--- a/lib/ansible/runner/action_plugins/debug.py
+++ b/lib/ansible/runner/action_plugins/debug.py
@@ -24,7 +24,7 @@ from ansible.runner.return_data import ReturnData
 class ActionModule(object):
     ''' Print statements during execution '''
 
-    TRANSFERS_FILES = False
+    NEEDS_TMPPATH = False
 
     def __init__(self, runner):
         self.runner = runner
diff --git a/lib/ansible/runner/action_plugins/fail.py b/lib/ansible/runner/action_plugins/fail.py
index 2bbaf40313..7c3a58cfb9 100644
--- a/lib/ansible/runner/action_plugins/fail.py
+++ b/lib/ansible/runner/action_plugins/fail.py
@@ -23,7 +23,7 @@ from ansible.runner.return_data import ReturnData
 class ActionModule(object):
     ''' Fail with custom message '''
 
-    TRANSFERS_FILES = False
+    NEEDS_TMPPATH = False
 
     def __init__(self, runner):
         self.runner = runner
diff --git a/lib/ansible/runner/action_plugins/group_by.py b/lib/ansible/runner/action_plugins/group_by.py
index f8b4f318db..2385df3863 100644
--- a/lib/ansible/runner/action_plugins/group_by.py
+++ b/lib/ansible/runner/action_plugins/group_by.py
@@ -28,7 +28,7 @@ class ActionModule(object):
 
     ### We need to be able to modify the inventory
     BYPASS_HOST_LOOP = True
-    TRANSFERS_FILES = False
+    NEEDS_TMPPATH = False
 
     def __init__(self, runner):
         self.runner = runner
diff --git a/lib/ansible/runner/action_plugins/include_vars.py b/lib/ansible/runner/action_plugins/include_vars.py
index 344cc82fa6..5a1f69a6c5 100644
--- a/lib/ansible/runner/action_plugins/include_vars.py
+++ b/lib/ansible/runner/action_plugins/include_vars.py
@@ -23,7 +23,7 @@ from ansible.runner.return_data import ReturnData
 
 class ActionModule(object):
 
-    TRANSFERS_FILES = False
+    NEEDS_TMPPATH = False
 
     def __init__(self, runner):
         self.runner = runner
diff --git a/lib/ansible/runner/action_plugins/raw.py b/lib/ansible/runner/action_plugins/raw.py
index ac6ed698d5..7fcfe92927 100644
--- a/lib/ansible/runner/action_plugins/raw.py
+++ b/lib/ansible/runner/action_plugins/raw.py
@@ -23,7 +23,7 @@ from ansible import errors
 from ansible.runner.return_data import ReturnData
 
 class ActionModule(object):
-    TRANSFERS_FILES = False
+    NEEDS_TMPPATH = False
 
     def __init__(self, runner):
         self.runner = runner
diff --git a/lib/ansible/runner/action_plugins/script.py b/lib/ansible/runner/action_plugins/script.py
index 6b584c15b6..c65e8cc8d1 100644
--- a/lib/ansible/runner/action_plugins/script.py
+++ b/lib/ansible/runner/action_plugins/script.py
@@ -26,8 +26,6 @@ from ansible.runner.return_data import ReturnData
 
 class ActionModule(object):
 
-    TRANSFERS_FILES = True
-
     def __init__(self, runner):
         self.runner = runner
 
diff --git a/lib/ansible/runner/action_plugins/set_fact.py b/lib/ansible/runner/action_plugins/set_fact.py
index 37502ce3a2..95d8cd6ef5 100644
--- a/lib/ansible/runner/action_plugins/set_fact.py
+++ b/lib/ansible/runner/action_plugins/set_fact.py
@@ -20,7 +20,7 @@ from ansible.runner.return_data import ReturnData
 
 class ActionModule(object):
 
-    TRANSFERS_FILES = False
+    NEEDS_TMPPATH = False
 
     def __init__(self, runner):
         self.runner = runner
diff --git a/lib/ansible/runner/action_plugins/template.py b/lib/ansible/runner/action_plugins/template.py
index b34c14ec6a..9ddc3340a4 100644
--- a/lib/ansible/runner/action_plugins/template.py
+++ b/lib/ansible/runner/action_plugins/template.py
@@ -25,8 +25,6 @@ import base64
 
 class ActionModule(object):
 
-    TRANSFERS_FILES = True
-
     def __init__(self, runner):
         self.runner = runner
 
diff --git a/lib/ansible/runner/action_plugins/unarchive.py b/lib/ansible/runner/action_plugins/unarchive.py
index 9733469ba6..f0b9dee945 100644
--- a/lib/ansible/runner/action_plugins/unarchive.py
+++ b/lib/ansible/runner/action_plugins/unarchive.py
@@ -35,8 +35,6 @@ import pipes
 
 class ActionModule(object):
 
-    TRANSFERS_FILES = True
-
     def __init__(self, runner):
         self.runner = runner
 
diff --git a/lib/ansible/runner/connection_plugins/accelerate.py b/lib/ansible/runner/connection_plugins/accelerate.py
index d260a63437..085c166288 100644
--- a/lib/ansible/runner/connection_plugins/accelerate.py
+++ b/lib/ansible/runner/connection_plugins/accelerate.py
@@ -49,7 +49,6 @@ class Connection(object):
         self.port = port[0]
         self.accport = port[1]
         self.is_connected = False
-        self.has_pipelining = False
 
         if not self.port:
             self.port = constants.DEFAULT_REMOTE_PORT
@@ -159,12 +158,9 @@ class Connection(object):
         except socket.timeout:
             raise errors.AnsibleError("timed out while waiting to receive data")
 
-    def exec_command(self, cmd, tmp_path, sudo_user, sudoable=False, executable='/bin/sh', in_data=None):
+    def exec_command(self, cmd, tmp_path, sudo_user, sudoable=False, executable='/bin/sh'):
         ''' run a command on the remote host '''
 
-        if in_data:
-            raise errors.AnsibleError("Internal Error: this module does not support optimized module pipelining")
-
         if executable == "":
             executable = constants.DEFAULT_EXECUTABLE
 
diff --git a/lib/ansible/runner/connection_plugins/chroot.py b/lib/ansible/runner/connection_plugins/chroot.py
index 1080ea54b5..305e9eb06b 100644
--- a/lib/ansible/runner/connection_plugins/chroot.py
+++ b/lib/ansible/runner/connection_plugins/chroot.py
@@ -30,7 +30,6 @@ class Connection(object):
 
     def __init__(self, runner, host, port, *args, **kwargs):
         self.chroot = host
-        self.has_pipelining = False
 
         if os.geteuid() != 0:
             raise errors.AnsibleError("chroot connection requires running as root")
@@ -60,12 +59,9 @@ class Connection(object):
 
         return self
 
-    def exec_command(self, cmd, tmp_path, sudo_user, sudoable=False, executable='/bin/sh', in_data=None):
+    def exec_command(self, cmd, tmp_path, sudo_user, sudoable=False, executable='/bin/sh'):
         ''' run a command on the chroot '''
 
-        if in_data:
-            raise errors.AnsibleError("Internal Error: this module does not support optimized module pipelining")
-
         # We enter chroot as root so sudo stuff can be ignored
 
         if executable:
diff --git a/lib/ansible/runner/connection_plugins/fireball.py b/lib/ansible/runner/connection_plugins/fireball.py
index 40848edead..727d6d279f 100644
--- a/lib/ansible/runner/connection_plugins/fireball.py
+++ b/lib/ansible/runner/connection_plugins/fireball.py
@@ -37,7 +37,6 @@ class Connection(object):
     def __init__(self, runner, host, port, *args, **kwargs):
 
         self.runner = runner
-        self.has_pipelining = False
 
         # attempt to work around shared-memory funness
         if getattr(self.runner, 'aes_keys', None):
@@ -68,12 +67,9 @@ class Connection(object):
 
         return self
 
-    def exec_command(self, cmd, tmp_path, sudo_user, sudoable=False, executable='/bin/sh', in_data=None):
+    def exec_command(self, cmd, tmp_path, sudo_user, sudoable=False, executable='/bin/sh'):
         ''' run a command on the remote host '''
 
-        if in_data:
-            raise errors.AnsibleError("Internal Error: this module does not support optimized module pipelining")
-
         vvv("EXEC COMMAND %s" % cmd)
 
         if self.runner.sudo and sudoable:
diff --git a/lib/ansible/runner/connection_plugins/funcd.py b/lib/ansible/runner/connection_plugins/funcd.py
index a5dc631ef8..5acdb4a30c 100644
--- a/lib/ansible/runner/connection_plugins/funcd.py
+++ b/lib/ansible/runner/connection_plugins/funcd.py
@@ -42,7 +42,6 @@ class Connection(object):
     def __init__(self, runner, host, port, *args, **kwargs):
         self.runner = runner
         self.host = host
-        self.has_pipelining = False
         # port is unused, this go on func
         self.port = port
 
@@ -54,12 +53,9 @@ class Connection(object):
         return self
 
     def exec_command(self, cmd, tmp_path, sudo_user, sudoable=False,
-                     executable='/bin/sh', in_data=None):
+                     executable='/bin/sh'):
         ''' run a command on the remote minion '''
 
-        if in_data:
-            raise errors.AnsibleError("Internal Error: this module does not support optimized module pipelining")
-
         vvv("EXEC %s" % (cmd), host=self.host)
         p = self.client.command.run(cmd)[self.host]
         return (p[0], '', p[1], p[2])
diff --git a/lib/ansible/runner/connection_plugins/jail.py b/lib/ansible/runner/connection_plugins/jail.py
index 89b13bbc44..b750874f06 100644
--- a/lib/ansible/runner/connection_plugins/jail.py
+++ b/lib/ansible/runner/connection_plugins/jail.py
@@ -60,7 +60,6 @@ class Connection(object):
         self.jail = host
         self.runner = runner
         self.host = host
-        self.has_pipelining = False
 
         if os.geteuid() != 0:
             raise errors.AnsibleError("jail connection requires running as root")
@@ -91,12 +90,9 @@ class Connection(object):
             local_cmd = '%s "%s" %s' % (self.jexec_cmd, self.jail, cmd)
         return local_cmd
 
-    def exec_command(self, cmd, tmp_path, sudo_user, sudoable=False, executable='/bin/sh', in_data=None):
+    def exec_command(self, cmd, tmp_path, sudo_user, sudoable=False, executable='/bin/sh'):
         ''' run a command on the chroot '''
 
-        if in_data:
-            raise errors.AnsibleError("Internal Error: this module does not support optimized module pipelining")
-
         # We enter chroot as root so sudo stuff can be ignored
         local_cmd = self._generate_cmd(executable, cmd)
 
diff --git a/lib/ansible/runner/connection_plugins/local.py b/lib/ansible/runner/connection_plugins/local.py
index 0cf7da42be..d62f2e4c06 100644
--- a/lib/ansible/runner/connection_plugins/local.py
+++ b/lib/ansible/runner/connection_plugins/local.py
@@ -34,19 +34,15 @@ class Connection(object):
         self.host = host
         # port is unused, since this is local
         self.port = port 
-        self.has_pipelining = False
 
     def connect(self, port=None):
         ''' connect to the local host; nothing to do here '''
 
         return self
 
-    def exec_command(self, cmd, tmp_path, sudo_user, sudoable=False, executable='/bin/sh', in_data=None):
+    def exec_command(self, cmd, tmp_path, sudo_user, sudoable=False, executable='/bin/sh'):
         ''' run a command on the local host '''
 
-        if in_data:
-            raise errors.AnsibleError("Internal Error: this module does not support optimized module pipelining")
-
         if not self.runner.sudo or not sudoable:
             if executable:
                 local_cmd = [executable, '-c', cmd]
diff --git a/lib/ansible/runner/connection_plugins/paramiko_ssh.py b/lib/ansible/runner/connection_plugins/paramiko_ssh.py
index 667e03c0e8..abf9dafc8f 100644
--- a/lib/ansible/runner/connection_plugins/paramiko_ssh.py
+++ b/lib/ansible/runner/connection_plugins/paramiko_ssh.py
@@ -121,7 +121,6 @@ class Connection(object):
         self.user = user
         self.password = password
         self.private_key_file = private_key_file
-        self.has_pipelining = False
 
     def _cache_key(self):
         return "%s__%s__" % (self.host, self.user)
@@ -176,12 +175,9 @@ class Connection(object):
 
         return ssh
 
-    def exec_command(self, cmd, tmp_path, sudo_user, sudoable=False, executable='/bin/sh', in_data=None):
+    def exec_command(self, cmd, tmp_path, sudo_user, sudoable=False, executable='/bin/sh'):
         ''' run a command on the remote host '''
 
-        if in_data:
-            raise errors.AnsibleError("Internal Error: this module does not support optimized module pipelining")
-
         bufsize = 4096
         try:
             chan = self.ssh.get_transport().open_session()
diff --git a/lib/ansible/runner/connection_plugins/ssh.py b/lib/ansible/runner/connection_plugins/ssh.py
index b630a76aea..68c6f17d4a 100644
--- a/lib/ansible/runner/connection_plugins/ssh.py
+++ b/lib/ansible/runner/connection_plugins/ssh.py
@@ -45,7 +45,6 @@ class Connection(object):
         self.password = password
         self.private_key_file = private_key_file
         self.HASHED_KEY_MAGIC = "|1|"
-        self.has_pipelining = False
 
         fcntl.lockf(self.runner.process_lockfile, fcntl.LOCK_EX)
         self.cp_dir = utils.prepare_writeable_dir('$HOME/.ansible/cp',mode=0700)
@@ -145,12 +144,9 @@ class Connection(object):
                     return False
         return True
 
-    def exec_command(self, cmd, tmp_path, sudo_user,sudoable=False, executable='/bin/sh', in_data=None):
+    def exec_command(self, cmd, tmp_path, sudo_user,sudoable=False, executable='/bin/sh'):
         ''' run a command on the remote host '''
 
-        if in_data:
-            raise errors.AnsibleError("Internal Error: this module does not support optimized module pipelining")
-
         ssh_cmd = self._password_cmd()
         ssh_cmd += ["ssh", "-tt"]
         if utils.VERBOSITY > 3:
diff --git a/lib/ansible/runner/connection_plugins/ssh_alt.py b/lib/ansible/runner/connection_plugins/ssh_alt.py
index 96a81f922e..68c6f17d4a 100644
--- a/lib/ansible/runner/connection_plugins/ssh_alt.py
+++ b/lib/ansible/runner/connection_plugins/ssh_alt.py
@@ -45,7 +45,6 @@ class Connection(object):
         self.password = password
         self.private_key_file = private_key_file
         self.HASHED_KEY_MAGIC = "|1|"
-        self.has_pipelining = True
 
         fcntl.lockf(self.runner.process_lockfile, fcntl.LOCK_EX)
         self.cp_dir = utils.prepare_writeable_dir('$HOME/.ansible/cp',mode=0700)
@@ -145,13 +144,11 @@ class Connection(object):
                     return False
         return True
 
-    def exec_command(self, cmd, tmp_path, sudo_user,sudoable=False, executable='/bin/sh', in_data=None):
+    def exec_command(self, cmd, tmp_path, sudo_user,sudoable=False, executable='/bin/sh'):
         ''' run a command on the remote host '''
 
         ssh_cmd = self._password_cmd()
-        ssh_cmd += ["ssh", "-C"]
-        if not in_data:
-            ssh_cmd += ["-tt"]
+        ssh_cmd += ["ssh", "-tt"]
         if utils.VERBOSITY > 3:
             ssh_cmd += ["-vvv"]
         else:
@@ -181,26 +178,19 @@ class Connection(object):
             fcntl.lockf(self.runner.process_lockfile, fcntl.LOCK_EX)
             fcntl.lockf(self.runner.output_lockfile, fcntl.LOCK_EX)
         
-        # create process
-        if in_data:
-            # do not use pseudo-pty
+
+
+        try:
+            # Make sure stdin is a proper (pseudo) pty to avoid: tcgetattr errors
+            master, slave = pty.openpty()
+            p = subprocess.Popen(ssh_cmd, stdin=slave,
+                                 stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+            stdin = os.fdopen(master, 'w', 0)
+            os.close(slave)
+        except:
             p = subprocess.Popen(ssh_cmd, stdin=subprocess.PIPE,
-                                     stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+                                 stdout=subprocess.PIPE, stderr=subprocess.PIPE)
             stdin = p.stdin
-        else:
-            # try to use upseudo-pty
-            try:
-                # Make sure stdin is a proper (pseudo) pty to avoid: tcgetattr errors
-                master, slave = pty.openpty()
-                p = subprocess.Popen(ssh_cmd, stdin=slave,
-                                     stdout=subprocess.PIPE, stderr=subprocess.PIPE)
-                stdin = os.fdopen(master, 'w', 0)
-                os.close(slave)
-            except:
-                p = subprocess.Popen(ssh_cmd, stdin=subprocess.PIPE,
-                                     stdout=subprocess.PIPE, stderr=subprocess.PIPE)
-                stdin = p.stdin
-        
 
         self._send_password()
 
@@ -208,9 +198,6 @@ class Connection(object):
             fcntl.fcntl(p.stdout, fcntl.F_SETFL,
                         fcntl.fcntl(p.stdout, fcntl.F_GETFL) | os.O_NONBLOCK)
             sudo_output = ''
-            if in_data:
-                # no terminal => no prompt on output. process is waiting for sudo_pass
-                stdin.write(self.runner.sudo_pass + '\n') 
             while not sudo_output.endswith(prompt) and success_key not in sudo_output:
                 rfd, wfd, efd = select.select([p.stdout], [],
                                               [p.stdout], self.runner.timeout)
@@ -225,16 +212,11 @@ class Connection(object):
             if success_key not in sudo_output:
                 stdin.write(self.runner.sudo_pass + '\n')
             fcntl.fcntl(p.stdout, fcntl.F_SETFL, fcntl.fcntl(p.stdout, fcntl.F_GETFL) & ~os.O_NONBLOCK)
+
         # We can't use p.communicate here because the ControlMaster may have stdout open as well
         stdout = ''
         stderr = ''
         rpipes = [p.stdout, p.stderr]
-        if in_data:
-            try:
-                stdin.write(in_data)
-                stdin.close()
-            except:
-                raise errors.AnsibleError('SSH Error: data could not be sent to the remote host. Make sure this host can be reached over ssh')
         while True:
             rfd, wfd, efd = select.select(rpipes, [], rpipes, 1)
 

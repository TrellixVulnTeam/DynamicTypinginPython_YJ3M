commit c4988262b5885c2ab3140bce4c419a8cde180227
Author: Toshio Kuratomi <a.badger@gmail.com>
Date:   Fri Aug 26 01:05:53 2016 -0700

    Fixes for lineinfile (#4553)
    
    Lineinfile deals heavily with Unic text files.  Makes some sense to deal
    with it all as byte strings.  So there is a lot of work done here to
    show that we're dealing with byte strings throughout.

diff --git a/lib/ansible/modules/files/lineinfile.py b/lib/ansible/modules/files/lineinfile.py
index e3d870c385..fbf61844eb 100644
--- a/lib/ansible/modules/files/lineinfile.py
+++ b/lib/ansible/modules/files/lineinfile.py
@@ -19,11 +19,6 @@
 # You should have received a copy of the GNU General Public License
 # along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
 
-import re
-import os
-import pipes
-import tempfile
-
 DOCUMENTATION = """
 ---
 module: lineinfile
@@ -146,11 +141,21 @@ EXAMPLES = r"""
 - lineinfile: dest=/etc/sudoers state=present regexp='^%ADMIN ALL\=' line='%ADMIN ALL=(ALL) NOPASSWD:ALL' validate='visudo -cf %s'
 """
 
-def write_changes(module,lines,dest):
+import re
+import os
+import tempfile
+
+# import module snippets
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.six import b
+from ansible.module_utils._text import to_bytes, to_native
+
+
+def write_changes(module, b_lines, dest):
 
     tmpfd, tmpfile = tempfile.mkstemp()
-    f = os.fdopen(tmpfd,'wb')
-    f.writelines(lines)
+    f = os.fdopen(tmpfd, 'wb')
+    f.writelines(b_lines)
     f.close()
 
     validate = module.params.get('validate', None)
@@ -158,14 +163,15 @@ def write_changes(module,lines,dest):
     if validate:
         if "%s" not in validate:
             module.fail_json(msg="validate must contain %%s: %s" % (validate))
-        (rc, out, err) = module.run_command(validate % tmpfile)
+        (rc, out, err) = module.run_command(to_bytes(validate % tmpfile))
         valid = rc == 0
         if rc != 0:
             module.fail_json(msg='failed to validate: '
-                                 'rc:%s error:%s' % (rc,err))
+                                 'rc:%s error:%s' % (rc, err))
     if valid:
         module.atomic_move(tmpfile, os.path.realpath(dest), unsafe_writes=module.params['unsafe_writes'])
 
+
 def check_file_attrs(module, changed, message, diff):
 
     file_args = module.load_file_common_arguments(module.params)
@@ -187,44 +193,46 @@ def present(module, dest, regexp, line, insertafter, insertbefore, create,
             'before_header': '%s (content)' % dest,
             'after_header': '%s (content)' % dest}
 
-    if not os.path.exists(dest):
+    b_dest = to_bytes(dest)
+    if not os.path.exists(b_dest):
         if not create:
             module.fail_json(rc=257, msg='Destination %s does not exist !' % dest)
-        destpath = os.path.dirname(dest)
-        if not os.path.exists(destpath) and not module.check_mode:
-            os.makedirs(destpath)
-        lines = []
+        b_destpath = os.path.dirname(b_dest)
+        if not os.path.exists(b_destpath) and not module.check_mode:
+            os.makedirs(b_destpath)
+        b_lines = []
     else:
-        f = open(dest, 'rb')
-        lines = f.readlines()
+        f = open(b_dest, 'rb')
+        b_lines = f.readlines()
         f.close()
 
     if module._diff:
-        diff['before'] = ''.join(lines)
+        diff['before'] = to_native(b('').join(b_lines))
 
     if regexp is not None:
-        mre = re.compile(regexp)
+        bre_m = re.compile(to_bytes(regexp))
 
     if insertafter not in (None, 'BOF', 'EOF'):
-        insre = re.compile(insertafter)
+        bre_ins = re.compile(to_bytes(insertafter))
     elif insertbefore not in (None, 'BOF'):
-        insre = re.compile(insertbefore)
+        bre_ins = re.compile(to_bytes(insertbefore))
     else:
-        insre = None
+        bre_ins = None
 
     # index[0] is the line num where regexp has been found
     # index[1] is the line num where insertafter/inserbefore has been found
     index = [-1, -1]
     m = None
-    for lineno, cur_line in enumerate(lines):
+    b_line = to_bytes(line)
+    for lineno, b_cur_line in enumerate(b_lines):
         if regexp is not None:
-            match_found = mre.search(cur_line)
+            match_found = bre_m.search(b_cur_line)
         else:
-            match_found = line == cur_line.rstrip('\r\n')
+            match_found = b_line == b_cur_line.rstrip(b('\r\n'))
         if match_found:
             index[0] = lineno
             m = match_found
-        elif insre is not None and insre.search(cur_line):
+        elif bre_ins is not None and bre_ins.search(b_cur_line):
             if insertafter:
                 # + 1 for the next line
                 index[1] = lineno + 1
@@ -235,18 +243,19 @@ def present(module, dest, regexp, line, insertafter, insertbefore, create,
     msg = ''
     changed = False
     # Regexp matched a line in the file
+    b_linesep = to_bytes(os.linesep)
     if index[0] != -1:
         if backrefs:
-            new_line = m.expand(line)
+            b_new_line = m.expand(b_line)
         else:
             # Don't do backref expansion if not asked.
-            new_line = line
+            b_new_line = b_line
 
-        if not new_line.endswith(os.linesep):
-            new_line += os.linesep
+        if not b_new_line.endswith(b_linesep):
+            b_new_line += b_linesep
 
-        if lines[index[0]] != new_line:
-            lines[index[0]] = new_line
+        if b_lines[index[0]] != b_new_line:
+            b_lines[index[0]] = b_new_line
             msg = 'line replaced'
             changed = True
     elif backrefs:
@@ -255,7 +264,7 @@ def present(module, dest, regexp, line, insertafter, insertbefore, create,
         pass
     # Add it to the beginning of the file
     elif insertbefore == 'BOF' or insertafter == 'BOF':
-        lines.insert(0, line + os.linesep)
+        b_lines.insert(0, b_line + b_linesep)
         msg = 'line added'
         changed = True
     # Add it to the end of the file if requested or
@@ -264,28 +273,28 @@ def present(module, dest, regexp, line, insertafter, insertbefore, create,
     elif insertafter == 'EOF' or index[1] == -1:
 
         # If the file is not empty then ensure there's a newline before the added line
-        if len(lines)>0 and not (lines[-1].endswith('\n') or lines[-1].endswith('\r')):
-            lines.append(os.linesep)
+        if len(b_lines) > 0 and not b_lines[-1][-1:] in (b('\n'), b('\r')):
+            b_lines.append(b_linesep)
 
-        lines.append(line + os.linesep)
+        b_lines.append(b_line + b_linesep)
         msg = 'line added'
         changed = True
     # insert* matched, but not the regexp
     else:
-        lines.insert(index[1], line + os.linesep)
+        b_lines.insert(index[1], b_line + b_linesep)
         msg = 'line added'
         changed = True
 
     if module._diff:
-        diff['after'] = ''.join(lines)
+        diff['after'] = to_native(b('').join(b_lines))
 
     backupdest = ""
     if changed and not module.check_mode:
-        if backup and os.path.exists(dest):
+        if backup and os.path.exists(b_dest):
             backupdest = module.backup_local(dest)
-        write_changes(module, lines, dest)
+        write_changes(module, b_lines, dest)
 
-    if module.check_mode and not os.path.exists(dest):
+    if module.check_mode and not os.path.exists(b_dest):
         module.exit_json(changed=changed, msg=msg, backup=backupdest, diff=diff)
 
     attr_diff = {}
@@ -300,7 +309,8 @@ def present(module, dest, regexp, line, insertafter, insertbefore, create,
 
 def absent(module, dest, regexp, line, backup):
 
-    if not os.path.exists(dest):
+    b_dest = to_bytes(dest)
+    if not os.path.exists(b_dest):
         module.exit_json(changed=False, msg="file not present")
 
     msg = ''
@@ -309,37 +319,38 @@ def absent(module, dest, regexp, line, backup):
             'before_header': '%s (content)' % dest,
             'after_header': '%s (content)' % dest}
 
-    f = open(dest, 'rb')
-    lines = f.readlines()
+    f = open(b_dest, 'rb')
+    b_lines = f.readlines()
     f.close()
 
     if module._diff:
-        diff['before'] = ''.join(lines)
+        diff['before'] = to_native(b('').join(b_lines))
 
     if regexp is not None:
-        cre = re.compile(regexp)
+        bre_c = re.compile(to_bytes(regexp))
     found = []
 
-    def matcher(cur_line):
+    b_line = to_bytes(line)
+    def matcher(b_cur_line):
         if regexp is not None:
-            match_found = cre.search(cur_line)
+            match_found = bre_c.search(b_cur_line)
         else:
-            match_found = line == cur_line.rstrip('\r\n')
+            match_found = b_line == b_cur_line.rstrip(b('\r\n'))
         if match_found:
-            found.append(cur_line)
+            found.append(b_cur_line)
         return not match_found
 
-    lines = filter(matcher, lines)
+    b_lines = [l for l in b_lines if matcher(l)]
     changed = len(found) > 0
 
     if module._diff:
-        diff['after'] = ''.join(lines)
+        diff['after'] = to_native(b('').join(b_lines))
 
     backupdest = ""
     if changed and not module.check_mode:
         if backup:
             backupdest = module.backup_local(dest)
-        write_changes(module, lines, dest)
+        write_changes(module, b_lines, dest)
 
     if changed:
         msg = "%s line(s) removed" % len(found)
@@ -358,7 +369,7 @@ def absent(module, dest, regexp, line, backup):
 def main():
     module = AnsibleModule(
         argument_spec=dict(
-            dest=dict(required=True, aliases=['name', 'destfile']),
+            dest=dict(required=True, aliases=['name', 'destfile'], type='path'),
             state=dict(default='present', choices=['absent', 'present']),
             regexp=dict(default=None),
             line=dict(aliases=['value']),
@@ -375,13 +386,13 @@ def main():
     )
 
     params = module.params
-    create = module.params['create']
-    backup = module.params['backup']
-    backrefs = module.params['backrefs']
-    dest = os.path.expanduser(params['dest'])
-
+    create = params['create']
+    backup = params['backup']
+    backrefs = params['backrefs']
+    dest = params['dest']
 
-    if os.path.isdir(dest):
+    b_dest = to_bytes(dest)
+    if os.path.isdir(b_dest):
         module.fail_json(rc=256, msg='Destination %s is a directory !' % dest)
 
     if params['state'] == 'present':
@@ -407,8 +418,5 @@ def main():
 
         absent(module, dest, params['regexp'], params.get('line', None), backup)
 
-# import module snippets
-from ansible.module_utils.basic import *
-from ansible.module_utils.splitter import *
 if __name__ == '__main__':
     main()

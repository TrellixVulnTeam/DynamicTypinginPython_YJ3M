commit a53e7045a6b3311ad16b0ce4837937d89fd198ea
Author: Yap Sok Ann <sokann@gmail.com>
Date:   Wed Oct 16 20:08:52 2013 +0800

    git: Always return the before/after revisions, even in check mode.
    
    The return values from check mode and non-check mode should match in all cases,
    except when a SHA-1 hash is used as version, as there is no way to check if it
    is a valid hash using `git ls-remote`.
    
    Also, to accomodate this change, the force flag for the reset function has been
    removed so that we can do the checking in main.

diff --git a/library/source_control/git b/library/source_control/git
index 9488283a7b..569a26875b 100644
--- a/library/source_control/git
+++ b/library/source_control/git
@@ -136,15 +136,13 @@ def has_local_mods(git_path, dest):
     lines = filter(lambda c: not re.search('^\\?\\?.*$', c), lines)
     return len(lines) > 0
 
-def reset(git_path, module, dest, force):
+def reset(git_path, module, dest):
     '''
     Resets the index and working tree to HEAD.
     Discards any changes to tracked files in working
     tree since that commit.
     '''
     os.chdir(dest)
-    if not force and has_local_mods(git_path, dest):
-        module.fail_json(msg="Local modifications exist in repository (force=no).")
     cmd = "%s reset --hard HEAD" % (git_path,)
     return module.run_command(cmd, check_rc=True)
 
@@ -343,7 +341,8 @@ def main():
     local_mods = False
     if not os.path.exists(gitconfig):
         if module.check_mode:
-            module.exit_json(changed=True)
+            remote_head = get_remote_head(git_path, module, dest, version, repo)
+            module.exit_json(changed=True, before=before, after=remote_head)
         clone(git_path, module, repo, dest, remote, depth, version)
     elif not update:
         # Just return having found a repo already in the dest path
@@ -355,31 +354,23 @@ def main():
         # else do a pull
         local_mods = has_local_mods(git_path, dest)
         before = get_version(git_path, dest)
-        # if force, do a reset
-        if local_mods and module.check_mode:
-            module.exit_json(changed=True, msg='Local modifications exist')
-        reset(git_path, module, dest, force)
-        # exit if already at desired sha version
-        if before == version:
-            module.exit_json(changed=False)
-        # check or get changes from remote
         remote_head = get_remote_head(git_path, module, dest, version, remote)
-        if module.check_mode:
-            changed = False
-            if remote_head == version:
-                # get_remote_head returned version as-is
-                # were given a sha1 object, see if it is present
-                (rc, out, err) = module.run_command("%s show %s" % (git_path, version))
-                if version in out:
-                    changed = False
-                else:
-                    changed = True
+        if local_mods:
+            # failure should happen regardless of check mode
+            if not force:
+                module.fail_json(msg="Local modifications exist in repository (force=no).")
+            # if force and in non-check mode, do a reset
+            if not module.check_mode:
+                reset(git_path, module, dest)
+        # exit if already at desired sha version
+        if before == remote_head:
+            if local_mods:
+                module.exit_json(changed=True, before=before, after=remote_head,
+                    msg="Local modifications exist")
             else:
-                if before != remote_head:
-                    changed = True
-                else:
-                    changed = False
-            module.exit_json(changed=changed, before=before, after=remote_head)
+                module.exit_json(changed=False, before=before, after=remote_head)
+        if module.check_mode:
+            module.exit_json(changed=True, before=before, after=remote_head)
         fetch(git_path, module, repo, dest, version, remote)
 
     # switch to version specified regardless of whether

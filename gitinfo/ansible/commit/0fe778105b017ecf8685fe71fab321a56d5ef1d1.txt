commit 0fe778105b017ecf8685fe71fab321a56d5ef1d1
Author: Sloane Hertel <shertel@redhat.com>
Date:   Mon Apr 9 17:03:36 2018 -0400

    Fix sporadic errors in ec2_vpc_subnet integration tests (#38473)

diff --git a/lib/ansible/modules/cloud/amazon/ec2_vpc_subnet.py b/lib/ansible/modules/cloud/amazon/ec2_vpc_subnet.py
index f1555fc3ce..0304fa75f1 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_vpc_subnet.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_vpc_subnet.py
@@ -362,14 +362,6 @@ def ensure_map_public(conn, module, subnet, map_public, check_mode, start_time):
     except (botocore.exceptions.ClientError, botocore.exceptions.BotoCoreError) as e:
         module.fail_json_aws(e, msg="Couldn't modify subnet attribute")
 
-    if module.params['wait']:
-        if map_public:
-            handle_waiter(conn, module, 'subnet_has_map_public',
-                          {'SubnetIds': [subnet['id']]}, start_time)
-        else:
-            handle_waiter(conn, module, 'subnet_no_map_public',
-                          {'SubnetIds': [subnet['id']]}, start_time)
-
 
 def ensure_assign_ipv6_on_create(conn, module, subnet, assign_instances_ipv6, check_mode, start_time):
     if check_mode:
@@ -379,14 +371,6 @@ def ensure_assign_ipv6_on_create(conn, module, subnet, assign_instances_ipv6, ch
     except (botocore.exceptions.ClientError, botocore.exceptions.BotoCoreError) as e:
         module.fail_json_aws(e, msg="Couldn't modify subnet attribute")
 
-    if module.params['wait']:
-        if assign_instances_ipv6:
-            handle_waiter(conn, module, 'subnet_has_assign_ipv6',
-                          {'SubnetIds': [subnet['id']]}, start_time)
-        else:
-            handle_waiter(conn, module, 'subnet_no_assign_ipv6',
-                          {'SubnetIds': [subnet['id']]}, start_time)
-
 
 def disassociate_ipv6_cidr(conn, module, subnet, start_time):
     if subnet.get('assign_ipv6_address_on_creation'):
@@ -512,6 +496,10 @@ def ensure_subnet_present(conn, module):
             changed = True
 
     subnet = get_matching_subnet(conn, module, module.params['vpc_id'], module.params['cidr'])
+    if not module.check_mode and module.params['wait']:
+        # GET calls are not monotonic for map_public_ip_on_launch and assign_ipv6_address_on_creation
+        # so we only wait for those if necessary just before returning the subnet
+        subnet = ensure_final_subnet(conn, module, subnet, start_time)
 
     return {
         'changed': changed,
@@ -519,6 +507,36 @@ def ensure_subnet_present(conn, module):
     }
 
 
+def ensure_final_subnet(conn, module, subnet, start_time):
+    for rewait in range(0, 10):
+        map_public_correct = False
+        assign_ipv6_correct = False
+
+        if module.params['map_public'] == subnet['map_public_ip_on_launch']:
+            map_public_correct = True
+        else:
+            if module.params['map_public']:
+                handle_waiter(conn, module, 'subnet_has_map_public', {'SubnetIds': [subnet['id']]}, start_time)
+            else:
+                handle_waiter(conn, module, 'subnet_no_map_public', {'SubnetIds': [subnet['id']]}, start_time)
+
+        if module.params['assign_instances_ipv6'] == subnet.get('assign_ipv6_address_on_creation'):
+            assign_ipv6_correct = True
+        else:
+            if module.params['assign_instances_ipv6']:
+                handle_waiter(conn, module, 'subnet_has_assign_ipv6', {'SubnetIds': [subnet['id']]}, start_time)
+            else:
+                handle_waiter(conn, module, 'subnet_no_assign_ipv6', {'SubnetIds': [subnet['id']]}, start_time)
+
+        if map_public_correct and assign_ipv6_correct:
+            break
+
+        time.sleep(3)
+        subnet = get_matching_subnet(conn, module, module.params['vpc_id'], module.params['cidr'])
+
+    return subnet
+
+
 def ensure_subnet_absent(conn, module):
     subnet = get_matching_subnet(conn, module, module.params['vpc_id'], module.params['cidr'])
     if subnet is None:

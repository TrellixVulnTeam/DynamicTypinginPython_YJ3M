commit f1a6d14d8e331ba99b7a90a026cda3414745edea
Author: Alexander Turner <git@alexturner.co>
Date:   Tue Feb 14 04:50:59 2017 -0800

    Added Ordnance network module. (#20436)
    
    * Added Ordnance network module.
    
    * Tidied up code base as per PR20436
    
    * Whitespace blocking PEP8 test
    
    * Removed acciental addition to VERSION
    
    * Removed acciental addition to VERSION
    
    * Documentation YAML issues
    
    * removed force arg (depreciated)

diff --git a/lib/ansible/modules/network/ordnance/__init__.py b/lib/ansible/modules/network/ordnance/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/lib/ansible/modules/network/ordnance/ordnance_config.py b/lib/ansible/modules/network/ordnance/ordnance_config.py
new file mode 100644
index 0000000000..c381b2fe33
--- /dev/null
+++ b/lib/ansible/modules/network/ordnance/ordnance_config.py
@@ -0,0 +1,377 @@
+#!/usr/bin/python
+#
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+ANSIBLE_METADATA = {'status': ['preview'],
+                    'supported_by': 'community',
+                    'version': '1.0'}
+
+DOCUMENTATION = """
+---
+module: Ordnance_config
+version_added: "2.3"
+author: "Alexander Turner (alex.turner@ordnance.io)"
+short_description: Manage Ordnance configuration sections
+description:
+  - Ordnance router configurations use a simple block indent file syntax
+    for segmenting configuration into sections.  This module provides
+    an implementation for working with these configuration sections in
+    a deterministic way.
+options:
+  commands:
+    description:
+      - The ordered set of commands that should be configured in the
+        section.  The commands must be the exact same commands as found
+        in the device running-config.  Be sure to note the configuration
+        command syntax as some commands are automatically modified by the
+        device config parser.
+    required: false
+    default: null
+    aliases: ['commands']
+  parents:
+    description:
+      - The ordered set of parents that uniquely identify the section
+        the commands should be checked against.  If the parents argument
+        is omitted, the commands are checked against the set of top
+        level or global commands.
+    required: false
+    default: null
+  src:
+    description:
+      - Specifies the source path to the file that contains the configuration
+        or configuration template to load.  The path to the source file can
+        either be the full path on the Ansible control host or a relative
+        path from the playbook or role root directory.  This argument is mutually
+        exclusive with I(lines).
+    required: false
+    default: null
+  before:
+    description:
+      - The ordered set of commands to push on to the command stack if
+        a change needs to be made.  This allows the playbook designer
+        the opportunity to perform configuration commands prior to pushing
+        any changes without affecting how the set of commands are matched
+        against the system.
+    required: false
+    default: null
+  after:
+    description:
+      - The ordered set of commands to append to the end of the command
+        stack if a change needs to be made.  Just like with I(before) this
+        allows the playbook designer to append a set of commands to be
+        executed after the command set.
+    required: false
+    default: null
+  match:
+    description:
+      - Instructs the module on the way to perform the matching of
+        the set of commands against the current device config.  If
+        match is set to I(line), commands are matched line by line.  If
+        match is set to I(strict), command lines are matched with respect
+        to position.  If match is set to I(exact), command lines
+        must be an equal match.  Finally, if match is set to I(none), the
+        module will not attempt to compare the source configuration with
+        the running configuration on the remote device.
+    required: false
+    default: line
+    choices: ['line', 'strict', 'exact', 'none']
+  replace:
+    description:
+      - Instructs the module on the way to perform the configuration
+        on the device.  If the replace argument is set to I(line) then
+        the modified lines are pushed to the device in configuration
+        mode.  If the replace argument is set to I(block) then the entire
+        command block is pushed to the device in configuration mode if any
+        line is not correct.
+    required: false
+    default: line
+    choices: ['line', 'block']
+  multiline_delimiter:
+    description:
+      - This arugment is used when pushing a multiline configuration
+        element to the Ordnance router.  It specifies the character to use
+        as the delimiting character.  This only applies to the
+        configuration action
+    required: false
+    default: "@"
+  backup:
+    description:
+      - This argument will cause the module to create a full backup of
+        the current C(running-config) from the remote device before any
+        changes are made.  The backup file is written to the C(backup)
+        folder in the playbook root directory.  If the directory does not
+        exist, it is created.
+    required: false
+    default: no
+    choices: ['yes', 'no']
+  config:
+    description:
+      - The C(config) argument allows the playbook designer to supply
+        the base configuration to be used to validate configuration
+        changes necessary.  If this argument is provided, the module
+        will not download the running-config from the remote node.
+    required: false
+    default: null
+  defaults:
+    description:
+      - This argument specifies whether or not to collect all defaults
+        when getting the remote device running config.  When enabled,
+        the module will get the current config by issuing the command
+        C(show running-config all).
+    required: false
+    default: no
+    choices: ['yes', 'no']
+  save:
+    description:
+      - The C(save) argument instructs the module to save the running-
+        config to the startup-config at the conclusion of the module
+        running.  If check mode is specified, this argument is ignored.
+    required: false
+    default: no
+    choices: ['yes', 'no']
+"""
+
+EXAMPLES = """
+# Note: examples below use the following provider dict to handle
+#       transport and authentication to the node.
+vars:
+  cli:
+    host: "{{ inventory_hostname }}"
+    username: RouterName
+    password: password
+    transport: cli
+
+- name: configure top level configuration
+  ordnance_config:
+    lines: hostname {{ inventory_hostname }}
+    provider: "{{ cli }}"
+
+- name: configure interface settings
+  ordnance_config:
+    lines:
+      - description test interface
+      - ip address 172.31.1.1 255.255.255.0
+    parents: interface Ethernet1
+    provider: "{{ cli }}"
+
+- name: configure bgp router
+  ordnance_config:
+    lines:
+      - neighbor 1.1.1.1 remote-as 1234
+      - network 10.0.0.0/24
+    parents: router bgp 65001
+    provider: "{{ cli }}"
+
+"""
+
+RETURN = """
+updates:
+  description: The set of commands that will be pushed to the remote device
+  returned: Only when commands is specified.
+  type: list
+  sample: ['...', '...']
+backup_path:
+  description: The full path to the backup file
+  returned: when backup is yes
+  type: path
+  sample: /playbooks/ansible/backup/ordnance_config.2016-07-16@22:28:34
+"""
+import re
+import time
+
+from ansible.module_utils.basic import get_exception
+from ansible.module_utils.six import iteritems
+from ansible.module_utils.ordnance import NetworkModule, NetworkError
+from ansible.module_utils.netcfg import NetworkConfig, dumps
+from ansible.module_utils.netcli import Command
+
+
+def check_args(module, warnings):
+    if module.params['multiline_delimiter']:
+        if len(module.params['multiline_delimiter']) != 1:
+            module.fail_json(msg='multiline_delimiter value can only be a '
+                                 'single character')
+    if module.params['force']:
+        warnings.append('The force argument is deprecated, please use '
+                        'match=none instead.  This argument will be '
+                        'removed in the future')
+
+def extract_banners(config):
+    banners = {}
+    banner_cmds = re.findall(r'^banner (\w+)', config, re.M)
+    for cmd in banner_cmds:
+        regex = r'banner %s \^C(.+?)(?=\^C)' % cmd
+        match = re.search(regex, config, re.S)
+        if match:
+            key = 'banner %s' % cmd
+            banners[key] = match.group(1).strip()
+
+    for cmd in banner_cmds:
+        regex = r'banner %s \^C(.+?)(?=\^C)' % cmd
+        match = re.search(regex, config, re.S)
+        if match:
+            config = config.replace(str(match.group(1)), '')
+
+    config = re.sub(r'banner \w+ \^C\^C', '!! banner removed', config)
+    return (config, banners)
+
+def diff_banners(want, have):
+    candidate = {}
+    for key, value in iteritems(want):
+        if value != have.get(key):
+            candidate[key] = value
+    return candidate
+
+def load_banners(module, banners):
+    delimiter = module.params['multiline_delimiter']
+    for key, value in iteritems(banners):
+        key += ' %s' % delimiter
+        for cmd in ['config terminal', key, value, delimiter, 'end']:
+            cmd += '\r'
+            module.connection.shell.shell.sendall(cmd)
+        time.sleep(1)
+        module.connection.shell.receive()
+
+def get_config(module, result):
+    contents = module.params['config']
+    if not contents:
+        defaults = module.params['defaults']
+        contents = module.config.get_config(include_defaults=defaults)
+
+    contents, banners = extract_banners(contents)
+    return NetworkConfig(indent=1, contents=contents), banners
+
+def get_candidate(module):
+    candidate = NetworkConfig(indent=1)
+    banners = {}
+
+    if module.params['src']:
+        src, banners = extract_banners(module.params['src'])
+        candidate.load(src)
+
+    elif module.params['lines']:
+        parents = module.params['parents'] or list()
+        candidate.add(module.params['lines'], parents=parents)
+
+    return candidate, banners
+
+def run(module, result):
+    match = module.params['match']
+    replace = module.params['replace']
+    path = module.params['parents']
+
+    candidate, want_banners = get_candidate(module)
+
+    if match != 'none':
+        config, have_banners = get_config(module, result)
+        path = module.params['parents']
+        configobjs = candidate.difference(config, path=path,match=match,
+                                          replace=replace)
+    else:
+        configobjs = candidate.items
+        have_banners = {}
+
+    banners = diff_banners(want_banners, have_banners)
+
+    if configobjs or banners:
+        commands = dumps(configobjs, 'commands').split('\n')
+
+        if module.params['lines']:
+            if module.params['before']:
+                commands[:0] = module.params['before']
+
+            if module.params['after']:
+                commands.extend(module.params['after'])
+
+        result['updates'] = commands
+        result['banners'] = banners
+
+        # send the configuration commands to the device and merge
+        # them with the current running config
+        if not module.check_mode:
+            if commands:
+                module.config(commands)
+            if banners:
+                load_banners(module, banners)
+
+        result['changed'] = True
+
+    if module.params['save']:
+        if not module.check_mode:
+            module.config.save_config()
+        result['changed'] = True
+
+def main():
+    """ main entry point for module execution
+    """
+
+    argument_spec = dict(
+        src=dict(type='path'),
+
+        lines=dict(aliases=['commands'], type='list'),
+        parents=dict(type='list'),
+
+        before=dict(type='list'),
+        after=dict(type='list'),
+
+        match=dict(default='line', choices=['line', 'strict', 'exact', 'none']),
+        replace=dict(default='line', choices=['line', 'block']),
+        multiline_delimiter=dict(default='@'),
+
+        config=dict(),
+        defaults=dict(type='bool', default=False),
+
+        backup=dict(type='bool', default=False),
+        save=dict(default=False, type='bool'),
+    )
+
+    mutually_exclusive = [('lines', 'src')]
+
+    required_if = [('match', 'strict', ['lines']),
+                   ('match', 'exact', ['lines']),
+                   ('replace', 'block', ['lines'])]
+
+    module = NetworkModule(argument_spec=argument_spec,
+                           connect_on_load=False,
+                           mutually_exclusive=mutually_exclusive,
+                           required_if=required_if,
+                           supports_check_mode=True)
+
+    if module.params['force'] is True:
+        module.params['match'] = 'none'
+
+    warnings = list()
+    check_args(module, warnings)
+
+    result = dict(changed=False, warnings=warnings)
+
+    if module.params['backup']:
+        result['__backup__'] = module.config.get_config()
+
+    try:
+        run(module, result)
+    except NetworkError:
+        exc = get_exception()
+        module.disconnect()
+        module.fail_json(msg=str(exc))
+
+    module.disconnect()
+    module.exit_json(**result)
+
+
+if __name__ == '__main__':
+    main()
diff --git a/lib/ansible/modules/network/ordnance/ordnance_facts.py b/lib/ansible/modules/network/ordnance/ordnance_facts.py
new file mode 100644
index 0000000000..897ed33d59
--- /dev/null
+++ b/lib/ansible/modules/network/ordnance/ordnance_facts.py
@@ -0,0 +1,297 @@
+#!/usr/bin/python
+#
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+#
+ANSIBLE_METADATA = {'status': ['preview'],
+                    'supported_by': 'community',
+                    'version': '1.0'}
+
+DOCUMENTATION = """
+---
+module: ordnance_facts
+version_added: "2.3"
+author: "Alexander Turner (alex.turner@ordnance.io)"
+short_description: Collect facts from Ordnance Virtual Routers over SSH
+description:
+  - Collects a base set of device facts from an Ordnance Virtual
+    router over SSH. This module prepends all of the
+    base network fact keys with C(ansible_net_<fact>).  The facts
+    module will always collect a base set of facts from the device
+    and can enable or disable collection of additional facts.
+options:
+  gather_subset:
+    description:
+      - When supplied, this argument will restrict the facts collected
+        to a given subset.  Possible values for this argument include
+        all, hardware, config, and interfaces.  Can specify a list of
+        values to include a larger subset.  Values can also be used
+        with an initial C(M(!)) to specify that a specific subset should
+        not be collected.
+    required: false
+    default: '!config'
+"""
+
+EXAMPLES = """
+# Note: examples below use the following provider dict to handle
+#       transport and authentication to the node.
+vars:
+  cli:
+    host: "{{ inventory_hostname }}"
+    username: RouterName
+    password: ordnance
+    transport: cli
+
+# Collect all facts from the device
+- ordnance_facts:
+    gather_subset: all
+    provider: "{{ cli }}"
+
+# Collect only the config and default facts
+- ordnance_facts:
+    gather_subset:
+      - config
+    provider: "{{ cli }}"
+
+# Do not collect hardware facts
+- ordnance_facts:
+    gather_subset:
+      - "!hardware"
+    provider: "{{ cli }}"
+"""
+
+RETURN = """
+ansible_net_gather_subset:
+  description: The list of fact subsets collected from the virtual router
+  returned: always
+  type: list
+
+# config
+ansible_net_config:
+  description: The current active config from the virtual router
+  returned: when config is configured
+  type: str
+
+# interfaces
+ansible_net_all_ipv4_addresses:
+  description: All IPv4 addresses configured on the virtual router
+  returned: when interfaces is configured
+  type: list
+ansible_net_all_ipv6_addresses:
+  description: All IPv6 addresses configured on the virtual router
+  returned: when interfaces is configured
+  type: list
+ansible_net_interfaces:
+  description: A hash of all interfaces running on the virtual router
+  returned: when interfaces is configured
+  type: dict
+"""
+import re
+import itertools
+
+import ansible.module_utils.ordnance
+from ansible.module_utils.network import NetworkModule
+from ansible.module_utils.six import iteritems
+from ansible.module_utils.six.moves import zip
+
+
+class FactsBase(object):
+
+    def __init__(self, module):
+        self.module = module
+        self.facts = dict()
+        self.failed_commands = list()
+
+    def run(self, cmd):
+        try:
+            return self.module.cli(cmd)[0]
+        except:
+            self.failed_commands.append(cmd)
+
+class Config(FactsBase):
+
+    def populate(self):
+        data = self.run('show running-config')
+        if data:
+            self.facts['config'] = data
+
+
+class Interfaces(FactsBase):
+
+    def populate(self):
+        self.facts['all_ipv4_addresses'] = list()
+        self.facts['all_ipv6_addresses'] = list()
+
+        data = self.run('show interfaces')
+        if data:
+            interfaces = self.parse_interfaces(data)
+            self.facts['interfaces'] = self.populate_interfaces(interfaces)
+
+        data = self.run('show ipv6 interface')
+        if data:
+            data = self.parse_interfaces(data)
+            self.populate_ipv6_interfaces(data)
+
+    def populate_interfaces(self, interfaces):
+        facts = dict()
+        for key, value in iteritems(interfaces):
+            intf = dict()
+            intf['description'] = self.parse_description(value)
+            intf['macaddress'] = self.parse_macaddress(value)
+
+            ipv4 = self.parse_ipv4(value)
+            intf['ipv4'] = self.parse_ipv4(value)
+            if ipv4:
+                self.add_ip_address(ipv4['address'], 'ipv4')
+
+            intf['duplex'] = self.parse_duplex(value)
+            intf['operstatus'] = self.parse_operstatus(value)
+            intf['type'] = self.parse_type(value)
+
+            facts[key] = intf
+        return facts
+
+    def populate_ipv6_interfaces(self, data):
+        for key, value in iteritems(data):
+            self.facts['interfaces'][key]['ipv6'] = list()
+            addresses = re.findall(r'\s+(.+), subnet', value, re.M)
+            subnets = re.findall(r', subnet is (.+)$', value, re.M)
+            for addr, subnet in zip(addresses, subnets):
+                ipv6 = dict(address=addr.strip(), subnet=subnet.strip())
+                self.add_ip_address(addr.strip(), 'ipv6')
+                self.facts['interfaces'][key]['ipv6'].append(ipv6)
+
+    def add_ip_address(self, address, family):
+        if family == 'ipv4':
+            self.facts['all_ipv4_addresses'].append(address)
+        else:
+            self.facts['all_ipv6_addresses'].append(address)
+
+    def parse_interfaces(self, data):
+        parsed = dict()
+        key = ''
+        for line in data.split('\n'):
+            if len(line) == 0:
+                continue
+            elif line[0] == ' ':
+                parsed[key] += '\n%s' % line
+            else:
+                match = re.match(r'^(\S+)', line)
+                if match:
+                    key = match.group(1)
+                    parsed[key] = line
+        return parsed
+
+    def parse_description(self, data):
+        match = re.search(r'Description: (.+)$', data, re.M)
+        if match:
+            return match.group(1)
+
+    def parse_macaddress(self, data):
+        match = re.search(r'address is (\S+)', data)
+        if match:
+            return match.group(1)
+
+    def parse_ipv4(self, data):
+        match = re.search(r'Internet address is (\S+)', data)
+        if match:
+            addr, masklen = match.group(1).split('/')
+            return dict(address=addr, masklen=int(masklen))
+
+    def parse_duplex(self, data):
+        match = re.search(r'(\w+) Duplex', data, re.M)
+        if match:
+            return match.group(1)
+
+    def parse_operstatus(self, data):
+        match = re.search(r'^(?:.+) is (.+),', data, re.M)
+        if match:
+            return match.group(1)
+
+FACT_SUBSETS = dict(
+    interfaces=Interfaces,
+    config=Config,
+)
+
+VALID_SUBSETS = frozenset(FACT_SUBSETS.keys())
+
+def main():
+    spec = dict(
+        gather_subset=dict(default=['!config'], type='list')
+    )
+
+    module = NetworkModule(argument_spec=spec, supports_check_mode=True)
+
+    gather_subset = module.params['gather_subset']
+
+    runable_subsets = set()
+    exclude_subsets = set()
+
+    for subset in gather_subset:
+        if subset == 'all':
+            runable_subsets.update(VALID_SUBSETS)
+            continue
+
+        if subset.startswith('!'):
+            subset = subset[1:]
+            if subset == 'all':
+                exclude_subsets.update(VALID_SUBSETS)
+                continue
+            exclude = True
+        else:
+            exclude = False
+
+        if subset not in VALID_SUBSETS:
+            module.fail_json(msg='Bad subset')
+
+        if exclude:
+            exclude_subsets.add(subset)
+        else:
+            runable_subsets.add(subset)
+
+    if not runable_subsets:
+        runable_subsets.update(VALID_SUBSETS)
+
+    runable_subsets.difference_update(exclude_subsets)
+    runable_subsets.add('default')
+
+    facts = dict()
+    facts['gather_subset'] = list(runable_subsets)
+
+    instances = list()
+    for key in runable_subsets:
+        instances.append(FACT_SUBSETS[key](module))
+
+    failed_commands = list()
+
+    try:
+        for inst in instances:
+            inst.populate()
+            failed_commands.extend(inst.failed_commands)
+            facts.update(inst.facts)
+    except Exception:
+        exc = get_exception()
+        module.fail_json(msg=str(exc))
+
+    ansible_facts = dict()
+    for key, value in iteritems(facts):
+        key = 'ansible_net_%s' % key
+        ansible_facts[key] = value
+
+    module.exit_json(ansible_facts=ansible_facts, failed_commands=failed_commands)
+
+
+if __name__ == '__main__':
+    main()

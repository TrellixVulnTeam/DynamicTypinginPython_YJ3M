commit bc69ad81479fe687163421a0e1d905b5780110b5
Author: Toshio Kuratomi <a.badger@gmail.com>
Date:   Mon Mar 23 18:42:28 2015 -0700

    Rename munge methods to preprocess_data.
    
    Remove the call to preprocess_loop data from playbook_include as
    includes can't be used with loops.

diff --git a/v2/ansible/playbook/base.py b/v2/ansible/playbook/base.py
index 4ac815552a..5aff5348ee 100644
--- a/v2/ansible/playbook/base.py
+++ b/v2/ansible/playbook/base.py
@@ -94,11 +94,11 @@ class Base:
             setattr(Base, name, property(getter, setter, deleter))
             setattr(self, name, value.default)
 
-    def munge(self, ds):
+    def preprocess_data(self, ds):
         ''' infrequently used method to do some pre-processing of legacy terms '''
 
         for base_class in self.__class__.mro():
-            method = getattr(self, "_munge_%s" % base_class.__name__.lower(), None)
+            method = getattr(self, "_preprocess_data_%s" % base_class.__name__.lower(), None)
             if method:
                 return method(ds)
         return ds
@@ -121,10 +121,10 @@ class Base:
         if isinstance(ds, string_types) or isinstance(ds, FileIO):
             ds = self._loader.load(ds)
 
-        # call the munge() function to massage the data into something
-        # we can more easily parse, and then call the validation function
-        # on it to ensure there are no incorrect key values
-        ds = self.munge(ds)
+        # call the preprocess_data() function to massage the data into
+        # something we can more easily parse, and then call the validation
+        # function on it to ensure there are no incorrect key values
+        ds = self.preprocess_data(ds)
         self._validate_attributes(ds)
 
         # Walk all attributes in the class.
diff --git a/v2/ansible/playbook/become.py b/v2/ansible/playbook/become.py
index 67eb52b15e..291cff2b71 100644
--- a/v2/ansible/playbook/become.py
+++ b/v2/ansible/playbook/become.py
@@ -51,7 +51,13 @@ class Become:
         elif has_sudo and has_su:
             raise errors.AnsibleParserError('sudo params ("sudo", "sudo_user") and su params ("su", "su_user") cannot be used together')
 
-    def _munge_become(self, ds):
+    def _preprocess_data_become(self, ds):
+        """Preprocess the playbook data for become attributes
+
+        This is called from the Base object's preprocess_data() method which
+        in turn is called pretty much anytime any sort of playbook object
+        (plays, tasks, blocks, etc) are created.
+        """
 
         self._detect_privilege_escalation_conflict(ds)
 
diff --git a/v2/ansible/playbook/block.py b/v2/ansible/playbook/block.py
index 03957bfe2f..6506345172 100644
--- a/v2/ansible/playbook/block.py
+++ b/v2/ansible/playbook/block.py
@@ -66,7 +66,7 @@ class Block(Base, Become, Conditional, Taggable):
         b = Block(parent_block=parent_block, role=role, task_include=task_include, use_handlers=use_handlers)
         return b.load_data(data, variable_manager=variable_manager, loader=loader)
 
-    def munge(self, ds):
+    def preprocess_data(self, ds):
         '''
         If a simple task is given, an implicit block for that single task
         is created, which goes in the main portion of the block
@@ -80,11 +80,11 @@ class Block(Base, Become, Conditional, Taggable):
 
         if not is_block:
             if isinstance(ds, list):
-                return super(Block, self).munge(dict(block=ds))
+                return super(Block, self).preprocess_data(dict(block=ds))
             else:
-                return super(Block, self).munge(dict(block=[ds]))
+                return super(Block, self).preprocess_data(dict(block=[ds]))
 
-        return super(Block, self).munge(ds)
+        return super(Block, self).preprocess_data(ds)
 
     def _load_block(self, attr, ds):
         return load_list_of_tasks(
diff --git a/v2/ansible/playbook/play.py b/v2/ansible/playbook/play.py
index cbe4e03861..a96e6e1eca 100644
--- a/v2/ansible/playbook/play.py
+++ b/v2/ansible/playbook/play.py
@@ -102,7 +102,7 @@ class Play(Base, Taggable, Become):
         p = Play()
         return p.load_data(data, variable_manager=variable_manager, loader=loader)
 
-    def munge(self, ds):
+    def preprocess_data(self, ds):
         '''
         Adjusts play datastructure to cleanup old/legacy items
         '''
@@ -121,7 +121,7 @@ class Play(Base, Taggable, Become):
             ds['remote_user'] = ds['user']
             del ds['user']
 
-        return super(Play, self).munge(ds)
+        return super(Play, self).preprocess_data(ds)
 
     def _load_vars(self, attr, ds):
         '''
diff --git a/v2/ansible/playbook/playbook_include.py b/v2/ansible/playbook/playbook_include.py
index e1d7f6be34..f7eae230f7 100644
--- a/v2/ansible/playbook/playbook_include.py
+++ b/v2/ansible/playbook/playbook_include.py
@@ -48,7 +48,8 @@ class PlaybookInclude(Base):
         from ansible.playbook import Playbook
 
         # first, we use the original parent method to correctly load the object
-        # via the munge/load_data system we normally use for other playbook objects
+        # via the load_data/preprocess_data system we normally use for other
+        # playbook objects
         new_obj = super(PlaybookInclude, self).load_data(ds, variable_manager, loader)
 
         # then we use the object to load a Playbook
@@ -67,7 +68,7 @@ class PlaybookInclude(Base):
 
         return pb
 
-    def munge(self, ds):
+    def preprocess_data(self, ds):
         '''
         Regorganizes the data for a PlaybookInclude datastructure to line
         up with what we expect the proper attributes to be
@@ -83,9 +84,7 @@ class PlaybookInclude(Base):
 
         for (k,v) in ds.iteritems():
             if k == 'include':
-                self._munge_include(ds, new_ds, k, v)
-            elif k.replace("with_", "") in lookup_loader:
-                self._munge_loop(ds, new_ds, k, v)
+                self._preprocess_include(ds, new_ds, k, v)
             else:
                 # some basic error checking, to make sure vars are properly
                 # formatted and do not conflict with k=v parameters
@@ -98,9 +97,9 @@ class PlaybookInclude(Base):
                         raise AnsibleParserError("vars for include statements must be specified as a dictionary", obj=ds)
                 new_ds[k] = v
 
-        return super(PlaybookInclude, self).munge(new_ds)
+        return super(PlaybookInclude, self).preprocess_data(new_ds)
 
-    def _munge_include(self, ds, new_ds, k, v):
+    def _preprocess_include(self, ds, new_ds, k, v):
         '''
         Splits the include line up into filename and parameters
         '''
diff --git a/v2/ansible/playbook/role/definition.py b/v2/ansible/playbook/role/definition.py
index bc1a0daacf..fb96a0e55f 100644
--- a/v2/ansible/playbook/role/definition.py
+++ b/v2/ansible/playbook/role/definition.py
@@ -54,12 +54,12 @@ class RoleDefinition(Base, Become, Conditional, Taggable):
     def load(data, variable_manager=None, loader=None):
         raise AnsibleError("not implemented")
 
-    def munge(self, ds):
+    def preprocess_data(self, ds):
 
         assert isinstance(ds, dict) or isinstance(ds, string_types)
 
         if isinstance(ds, dict):
-            ds = super(RoleDefinition, self).munge(ds)
+            ds = super(RoleDefinition, self).preprocess_data(ds)
 
         # we create a new data structure here, using the same
         # object used internally by the YAML parsing code so we
diff --git a/v2/ansible/playbook/role/requirement.py b/v2/ansible/playbook/role/requirement.py
index d321f6e17d..61db0cb1fd 100644
--- a/v2/ansible/playbook/role/requirement.py
+++ b/v2/ansible/playbook/role/requirement.py
@@ -61,7 +61,7 @@ class RoleRequirement(RoleDefinition):
         if isinstance(ds, string_types):
             role_name = ds
         else:
-            ds = self._munge_role_spec(ds)
+            ds = self._preprocess_role_spec(ds)
             (new_ds, role_params) = self._split_role_params(ds)
 
             # pull the role name out of the ds
@@ -70,7 +70,7 @@ class RoleRequirement(RoleDefinition):
 
         return (new_ds, role_name, role_params)
 
-    def _munge_role_spec(self, ds):
+    def _preprocess_role_spec(self, ds):
         if 'role' in ds:
             # Old style: {role: "galaxy.role,version,name", other_vars: "here" }
             role_info = self._role_spec_parse(ds['role'])
diff --git a/v2/ansible/playbook/task.py b/v2/ansible/playbook/task.py
index ab66898242..0f5e767486 100644
--- a/v2/ansible/playbook/task.py
+++ b/v2/ansible/playbook/task.py
@@ -137,7 +137,7 @@ class Task(Base, Conditional, Taggable, Become):
         ''' returns a human readable representation of the task '''
         return "TASK: %s" % self.get_name()
 
-    def _munge_loop(self, ds, new_ds, k, v):
+    def _preprocess_loop(self, ds, new_ds, k, v):
         ''' take a lookup plugin name and store it correctly '''
 
         loop_name = k.replace("with_", "")
@@ -146,7 +146,7 @@ class Task(Base, Conditional, Taggable, Become):
         new_ds['loop'] = loop_name
         new_ds['loop_args'] = v
 
-    def munge(self, ds):
+    def preprocess_data(self, ds):
         '''
         tasks are especially complex arguments so need pre-processing.
         keep it short.
@@ -178,11 +178,11 @@ class Task(Base, Conditional, Taggable, Become):
                 # determined by the ModuleArgsParser() above
                 continue
             elif k.replace("with_", "") in lookup_loader:
-                self._munge_loop(ds, new_ds, k, v)
+                self._preprocess_loop(ds, new_ds, k, v)
             else:
                 new_ds[k] = v
 
-        return super(Task, self).munge(new_ds)
+        return super(Task, self).preprocess_data(new_ds)
 
     def post_validate(self, all_vars=dict(), fail_on_undefined=True):
         '''

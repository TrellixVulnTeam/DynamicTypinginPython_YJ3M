commit 6c3af4df81772852bd1805941195fa7bc28d1f1a
Author: James Cammarata <jimi@sngx.net>
Date:   Tue Sep 10 11:15:30 2013 -0500

    Fix for update-rc.d based systems that also have systemd installed
    
    By default, the service module had assumed that if the system had the
    update-rc.d binary, the service was either managed via upstart or standard
    sysV init-style scripts. This patch adds a check for systemctl ahead
    of the other methods when update-rc.d is detected, and also simplifies
    the logic around the detection of systemctl-managed services

diff --git a/library/system/service b/library/system/service
index 61f99b3ff3..e711bbc302 100644
--- a/library/system/service
+++ b/library/system/service
@@ -387,38 +387,46 @@ class LinuxService(Service):
         for binary in binaries:
             location[binary] = self.module.get_bin_path(binary)
 
+        def check_systemd(name):
+            # verify service is managed by systemd
+            if not location.get('systemctl', None):
+                return False
+
+            rc, out, err = self.execute_command("%s list-unit-files" % (location['systemctl']))
+
+            # adjust the service name to account for template service unit files
+            index = name.find('@')
+            if index != -1:
+                name = name[:index+1]
+
+            look_for = "%s.service" % name
+            for line in out.splitlines():
+                if line.startswith(look_for):
+                    return True
+            return False
+
         # Locate a tool for enable options
         if location.get('chkconfig', None) and os.path.exists("/etc/init.d/%s" % self.name):
             # we are using a standard SysV service
             self.enable_cmd = location['chkconfig']
-        elif location.get('update-rc.d', None) and os.path.exists("/etc/init/%s.conf" % self.name):
-            # service is managed by upstart
-            self.enable_cmd = location['update-rc.d']
-        elif location.get('update-rc.d', None) and os.path.exists("/etc/init.d/%s" % self.name):
-            # service is managed by with SysV init scripts, but with update-rc.d
-            self.enable_cmd = location['update-rc.d']
+        elif location.get('update-rc.d', None):
+            if check_systemd(self.name):
+                # service is managed by systemd
+                self.enable_cmd = location['systemctl']
+            elif os.path.exists("/etc/init/%s.conf" % self.name):
+                # service is managed by upstart
+                self.enable_cmd = location['update-rc.d']
+            elif os.path.exists("/etc/init.d/%s" % self.name):
+                # service is managed by with SysV init scripts, but with update-rc.d
+                self.enable_cmd = location['update-rc.d']
         elif location.get('rc-service', None) and not location.get('systemctl', None):
             # service is managed by OpenRC
             self.svc_cmd = location['rc-service']
             self.enable_cmd = location['rc-update']
             return
-        elif location.get('systemctl', None):
-
-            # verify service is managed by systemd
-            rc, out, err = self.execute_command("%s list-unit-files" % (location['systemctl']))
-
-            # adjust the service name to account for template service unit files
-            index = self.name.find('@')
-            if index == -1:
-                name = self.name
-            else:
-                name = self.name[:index+1]
-
-            look_for = "%s.service" % name
-            for line in out.splitlines():
-                if line.startswith(look_for):
-                    self.enable_cmd = location['systemctl']
-                    break
+        elif check_systemd(self.name):
+            # service is managed by systemd
+            self.enable_cmd = location['systemctl']
 
         # Locate a tool for runtime service management (start, stop etc.)
         if location.get('service', None) and os.path.exists("/etc/init.d/%s" % self.name):

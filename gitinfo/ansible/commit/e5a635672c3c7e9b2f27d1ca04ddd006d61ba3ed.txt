commit e5a635672c3c7e9b2f27d1ca04ddd006d61ba3ed
Author: Stephen Fromm <sfromm@gmail.com>
Date:   Wed Aug 29 20:26:22 2012 -0700

    Migrate remaining modules to use get_bin_path in module_common.py
    
    * Migraed easy_install, pip, service, setup, and user.
    * Updated fail_json message in apt_repository
    * Fixed easy_install to not hardcode location of virtualenv in
      /usr/local/bin/.
    * Made handling of virtualenv more consistent between easy_install and
      pip.

diff --git a/library/apt_repository b/library/apt_repository
index e5d8d46c5f..60539a86c6 100755
--- a/library/apt_repository
+++ b/library/apt_repository
@@ -48,8 +48,7 @@ def main():
 
     add_apt_repository = module.get_bin_path(ADD_APT_REPO)
     if add_apt_repository is None:
-        module.fail_json(msg='Unabled to find any of the following executables '
-                             '%s' % binaries)
+        module.fail_json(msg='Unable to find executable %s' % ADD_APT_REPO)
 
     repo = module.params['repo']
     state = module.params['state']
diff --git a/library/easy_install b/library/easy_install
index 47d3f2c823..eeb010d1fb 100755
--- a/library/easy_install
+++ b/library/easy_install
@@ -19,18 +19,6 @@
 # along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
 #
 
-def _find_easy_install(env):
-    if env:
-        return os.path.join(env, 'bin', 'easy_install')
-
-    paths = ['/usr/local/bin', '/usr/bin']
-
-    for p in paths:
-        e = p + '/easy_install'
-        if os.path.exists(e):
-            return e
-
-
 def _ensure_virtualenv(env, virtualenv):
     if os.path.exists(os.path.join(env, 'bin', 'activate')):
         return 0, '', ''
@@ -62,14 +50,20 @@ def main():
 
     name = module.params['name']
     env = module.params['virtualenv']
-    easy_install = _find_easy_install(env)
+    easy_install = module.get_bin_path('easy_install', ['%s/bin' % env])
+    if easy_install is None:
+        module.fail_json(msg='easy_install is not installed')
 
     rc = 0
     err = ''
     out = ''
 
     if env:
-        rc_venv, out_venv, err_venv = _ensure_virtualenv(env, '/usr/local/bin/virtualenv')
+        virtualenv = module.get_bin_path('virtualenv')
+        if virtualenv is None:
+            module.fail_json(msg='virtualenv is not installed')
+
+        rc_venv, out_venv, err_venv = _ensure_virtualenv(env, virtualenv)
 
         rc += rc_venv
         out += out_venv
diff --git a/library/pip b/library/pip
index a2a337457c..5dbbea561d 100755
--- a/library/pip
+++ b/library/pip
@@ -27,32 +27,6 @@ def _get_full_name(name, version=None):
         resp = name + '==' + version
     return resp
 
-
-def _find_pip(module, env):
-    paths = ['/usr/local/bin', '/usr/bin']
-
-    if env:
-        paths = [os.path.join(env, 'bin')] + paths
-
-    for p in paths:
-        pe = p + '/pip'
-        if os.path.exists(pe):
-            return pe
-
-    module.fail_json(msg='pip is not installed')
-
-
-def _find_virtualenv(module):
-    paths = ['/usr/local/bin', '/usr/bin']
-
-    for p in paths:
-        ve = p + '/virtualenv'
-        if os.path.exists(ve):
-            return ve
-
-    module.fail_json(msg='virtualenv is not installed')
-
-
 def _ensure_virtualenv(module, env, virtualenv):
     if os.path.exists(os.path.join(env, 'bin', 'activate')):
         return 0, '', ''
@@ -103,7 +77,9 @@ def main():
     env = module.params['virtualenv']
 
     if env:
-        virtualenv = _find_virtualenv(module)
+        virtualenv = module.get_bin_path('virtualenv')
+        if virtualenv is None:
+            module.fail_json(msg='virtualenv is not installed')
 
         rc_venv, out_venv, err_venv = _ensure_virtualenv(module, env, virtualenv)
 
@@ -111,7 +87,9 @@ def main():
         out += out_venv
         err += err_venv
 
-    pip = _find_pip(module, env)
+    pip = module.get_bin_path('pip', ['%s/bin' % env])
+    if pip is None:
+        module.fail_json(msg='pip is not installed')
 
     state = module.params['state']
     name = module.params['name']
diff --git a/library/service b/library/service
index e884f902ed..0d918d4903 100755
--- a/library/service
+++ b/library/service
@@ -39,10 +39,7 @@ def _find_binaries(m):
         location[binary] = None
 
     for binary in binaries:
-        for path in paths:
-            if os.path.exists(path + '/' + binary):
-                location[binary] = path + '/' + binary
-                break
+        location[binary] = m.get_bin_path(binary)
 
     if location.get('systemctl', None):
         CHKCONFIG = location['systemctl']
diff --git a/library/setup b/library/setup
index 4ed85620cd..005919157b 100755
--- a/library/setup
+++ b/library/setup
@@ -436,7 +436,9 @@ class LinuxNetwork(Network):
         Network.__init__(self)
 
     def populate(self):
-        ip_path = self.get_ip_path()
+        ip_path = module.get_bin_path('ip')
+        if ip_path is None:
+            return self.facts
         default_ipv4, default_ipv6 = self.get_default_interfaces(ip_path)
         interfaces, ips = self.get_interfaces_info(ip_path, default_ipv4, default_ipv6)
         self.facts['interfaces'] = interfaces.keys()
@@ -448,15 +450,6 @@ class LinuxNetwork(Network):
         self.facts['all_ipv6_addresses'] = ips['all_ipv6_addresses']
         return self.facts
 
-    def get_ip_path(self):
-        paths = ['/sbin/ip', '/usr/sbin/ip']
-        ip_path = None
-        for path in paths:
-            if os.path.exists(path):
-                ip_path = path
-                break
-        return ip_path
-
     def get_default_interfaces(self, ip_path):
         # Use the commands:
         #     ip -4 route get 8.8.8.8                     -> Google public DNS
@@ -730,6 +723,7 @@ def run_setup(module):
     return setup_result
 
 def main():
+    global module
     module = AnsibleModule(
         argument_spec = dict()
     )
diff --git a/library/user b/library/user
index c90037efe6..a932978da8 100755
--- a/library/user
+++ b/library/user
@@ -36,12 +36,11 @@ if os.path.exists('/etc/master.passwd'):
 # That is, this won't work on FreeBSD.
 
 def get_bin_path(module, arg):
-    if os.path.exists('/usr/sbin/%s' % arg):
-        return '/usr/sbin/%s' % arg
-    elif os.path.exists('/sbin/%s' % arg):
-        return '/sbin/%s' % arg
-    else:
+    bin = module.get_bin_path(arg)
+    if bin is None:
         module.fail_json(msg="Cannot find %s" % arg)
+    else:
+        return bin
 
 def user_del(module, user, **kwargs):
     cmd = [get_bin_path(module, 'userdel')]

commit 91ee93ce133506508b2125918f41f3b7f667602e
Author: Dag Wieers <dag@wieers.com>
Date:   Fri Jun 2 09:42:40 2017 +0200

    patch: PEP8, imports, cosmetics (#24649)
    
    - Make PEP8 compliant
    - Ensure imports are specific
    - Few cosmetic changes (sort lists, casing, punctuation)

diff --git a/lib/ansible/modules/files/patch.py b/lib/ansible/modules/files/patch.py
index d76855b4f9..708369ca47 100644
--- a/lib/ansible/modules/files/patch.py
+++ b/lib/ansible/modules/files/patch.py
@@ -23,78 +23,73 @@ ANSIBLE_METADATA = {'metadata_version': '1.0',
                     'status': ['stableinterface'],
                     'supported_by': 'community'}
 
-
-DOCUMENTATION = '''
+DOCUMENTATION = r'''
 ---
 module: patch
 author:
-    - "Jakub Jirutka (@jirutka)"
-    - "Luis Alberto Perez Lazaro (@luisperlaz)"
-version_added: 1.9
+    - Jakub Jirutka (@jirutka)
+    - Luis Alberto Perez Lazaro (@luisperlaz)
+version_added: '1.9'
 description:
     - Apply patch files using the GNU patch tool.
-short_description: Apply patch files using the GNU patch tool.
+short_description: Apply patch files using the GNU patch tool
 options:
   basedir:
     description:
       - Path of a base directory in which the patch file will be applied.
         May be omitted when C(dest) option is specified, otherwise required.
-    required: false
   dest:
     description:
       - Path of the file on the remote machine to be patched.
       - The names of the files to be patched are usually taken from the patch
         file, but if there's just one file to be patched it can specified with
         this option.
-    required: false
-    aliases: [ "originalfile" ]
+    aliases: [ originalfile ]
   src:
     description:
       - Path of the patch file as accepted by the GNU patch tool. If
         C(remote_src) is 'no', the patch source file is looked up from the
-        module's "files" directory.
+        module's I(files) directory.
     required: true
-    aliases: [ "patchfile" ]
+    aliases: [ patchfile ]
   remote_src:
     description:
       - If C(no), it will search for src at originating/master machine, if C(yes) it will
-        go to the remote/target machine for the src. Default is C(no).
-    choices: [ "yes", "no" ]
-    required: false
-    default: "no"
+        go to the remote/target machine for the C(src).
+    choices: [ 'no', 'yes' ]
+    default: 'no'
   strip:
     description:
       - Number that indicates the smallest prefix containing leading slashes
         that will be stripped from each file name found in the patch file.
         For more information see the strip parameter of the GNU patch tool.
-    required: false
-    default: "0"
+    default: 0
   backup:
     version_added: "2.0"
     description:
-      - passes --backup --version-control=numbered to patch,
-        producing numbered backup copies
-    choices: [ 'yes', 'no' ]
+      - Passes C(--backup --version-control=numbered) to patch,
+        producing numbered backup copies.
+    choices: [ 'no', 'yes' ]
     default: 'no'
   binary:
     version_added: "2.0"
     description:
       - Setting to C(yes) will disable patch's heuristic for transforming CRLF
         line endings into LF. Line endings of src and dest must match. If set to
-        C(no), patch will replace CRLF in src files on POSIX.
-    required: false
-    default: "no"
+        C(no), C(patch) will replace CRLF in C(src) files on POSIX.
+    choices: [ 'no', 'yes' ]
+    default: 'no'
 notes:
   - This module requires GNU I(patch) utility to be installed on the remote host.
 '''
 
-EXAMPLES = '''
-- name: apply patch to one file
+EXAMPLES = r'''
+- name: Apply patch to one file
   patch:
     src: /tmp/index.html.patch
     dest: /var/www/index.html
 
-- name: apply patch to multiple files under basedir
+- name: Apply patch to multiple files under basedir
   patch:
     src: /tmp/customize.patch
     basedir: /var/www
@@ -102,7 +97,8 @@ EXAMPLES = '''
 '''
 
 import os
-from os import path, R_OK, W_OK
+
+from ansible.module_utils.basic import AnsibleModule, get_exception
 
 
 class PatchError(Exception):
@@ -143,41 +139,43 @@ def apply_patch(patch_func, patch_file, basedir, dest_file=None, binary=False, s
 
 def main():
     module = AnsibleModule(
-        argument_spec={
-            'src':     {'required': True, 'aliases': ['patchfile']},
-            'dest':    {'aliases': ['originalfile']},
-            'basedir': {},
-            'strip':   {'default': 0, 'type': 'int'},
-            'remote_src': {'default': False, 'type': 'bool'},
+        argument_spec=dict(
+            src=dict(type='path', required=True, aliases=['patchfile']),
+            dest=dict(type='path', aliases=['originalfile']),
+            basedir=dict(type='path'),
+            strip=dict(type='int', default=0),
+            remote_src=dict(type='bool', default=False),
             # NB: for 'backup' parameter, semantics is slightly different from standard
             #     since patch will create numbered copies, not strftime("%Y-%m-%d@%H:%M:%S~")
-            'backup': {'default': False, 'type': 'bool'},
-            'binary': {'default': False, 'type': 'bool'},
-        },
+            backup=dict(type='bool', default=False),
+            binary=dict(type='bool', default=False),
+        ),
         required_one_of=[['dest', 'basedir']],
-        supports_check_mode=True
+        supports_check_mode=True,
     )
 
     # Create type object as namespace for module params
     p = type('Params', (), module.params)
 
     p.src = os.path.expanduser(p.src)
-    if not os.access(p.src, R_OK):
+    if not os.access(p.src, os.R_OK):
         module.fail_json(msg="src %s doesn't exist or not readable" % (p.src))
 
-    if p.dest and not os.access(p.dest, W_OK):
+    if p.dest and not os.access(p.dest, os.W_OK):
         module.fail_json(msg="dest %s doesn't exist or not writable" % (p.dest))
 
-    if p.basedir and not path.exists(p.basedir):
+    if p.basedir and not os.path.exists(p.basedir):
         module.fail_json(msg="basedir %s doesn't exist" % (p.basedir))
 
     if not p.basedir:
-        p.basedir = path.dirname(p.dest)
+        p.basedir = os.path.dirname(p.dest)
 
     patch_bin = module.get_bin_path('patch')
     if patch_bin is None:
         module.fail_json(msg="patch command not found")
-    patch_func = lambda opts: module.run_command("%s %s" % (patch_bin, ' '.join(opts)))
+
+    def patch_func(opts):
+        return module.run_command('%s %s' % (patch_bin, ' '.join(opts)))
 
     # patch need an absolute file name
     p.src = os.path.abspath(p.src)
@@ -185,8 +183,8 @@ def main():
     changed = False
     if not is_already_applied(patch_func, p.src, p.basedir, dest_file=p.dest, binary=p.binary, strip=p.strip):
         try:
-            apply_patch( patch_func, p.src, p.basedir, dest_file=p.dest, binary=p.binary, strip=p.strip,
-                         dry_run=module.check_mode, backup=p.backup )
+            apply_patch(patch_func, p.src, p.basedir, dest_file=p.dest, binary=p.binary, strip=p.strip,
+                        dry_run=module.check_mode, backup=p.backup)
             changed = True
         except PatchError:
             e = get_exception()
@@ -194,8 +192,6 @@ def main():
 
     module.exit_json(changed=changed)
 
-# import module snippets
-from ansible.module_utils.basic import *
 
 if __name__ == '__main__':
     main()
diff --git a/test/sanity/pep8/legacy-files.txt b/test/sanity/pep8/legacy-files.txt
index b2ea62fedf..12e7070571 100644
--- a/test/sanity/pep8/legacy-files.txt
+++ b/test/sanity/pep8/legacy-files.txt
@@ -309,7 +309,6 @@ lib/ansible/modules/files/copy.py
 lib/ansible/modules/files/find.py
 lib/ansible/modules/files/ini_file.py
 lib/ansible/modules/files/iso_extract.py
-lib/ansible/modules/files/patch.py
 lib/ansible/modules/files/replace.py
 lib/ansible/modules/files/synchronize.py
 lib/ansible/modules/files/tempfile.py

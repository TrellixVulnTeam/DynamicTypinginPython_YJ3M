commit 43d2e3ad685044c00f25566d939479ac6d738951
Author: Marc Mettke <marc.mettke@gmail.com>
Date:   Wed Dec 16 07:03:18 2015 +0100

    Pacman Module Fixes
    
    Update: query_package documentation
    Fix: Number of Packages to Updated was one to high,
         'cause of counting the '\n'
    Fix: Pacman was reinstalling state=latest packages,
         even when it was unable to load the remote version

diff --git a/lib/ansible/modules/extras/packaging/os/pacman.py b/lib/ansible/modules/extras/packaging/os/pacman.py
index da85a6c0a1..1f955fa269 100644
--- a/lib/ansible/modules/extras/packaging/os/pacman.py
+++ b/lib/ansible/modules/extras/packaging/os/pacman.py
@@ -124,13 +124,13 @@ def get_version(pacman_output):
     return None
 
 def query_package(module, pacman_path, name, state="present"):
-    """Query the package status in both the local system and the repository. Returns a boolean to indicate if the package is installed, and a second boolean to indicate if the package is up-to-date."""
+    """Query the package status in both the local system and the repository. Returns a boolean to indicate if the package is installed, a second boolean to indicate if the package is up-to-date and a third boolean to indicate whether online information were available"""
     if state == "present":
         lcmd = "%s -Qi %s" % (pacman_path, name)
         lrc, lstdout, lstderr = module.run_command(lcmd, check_rc=False)
         if lrc != 0:
             # package is not installed locally
-            return False, False
+            return False, False, False
 
         # get the version installed locally (if any)
         lversion = get_version(lstdout)
@@ -143,9 +143,10 @@ def query_package(module, pacman_path, name, state="present"):
         if rrc == 0:
             # Return True to indicate that the package is installed locally, and the result of the version number comparison
             # to determine if the package is up-to-date.
-            return True, (lversion == rversion)
-
-        return False, False
+            return True, (lversion == rversion), False
+        
+    # package is installed but cannot fetch remote Version. Last True stands for the error
+        return True, True, True
 
 
 def update_package_db(module, pacman_path):
@@ -165,7 +166,7 @@ def upgrade(module, pacman_path):
     if rc == 0:
         if module.check_mode:
             data = stdout.split('\n')
-            module.exit_json(changed=True, msg="%s package(s) would be upgraded" % len(data))
+            module.exit_json(changed=True, msg="%s package(s) would be upgraded" % (len(data) - 1))
         rc, stdout, stderr = module.run_command(cmdupgrade, check_rc=False)
         if rc == 0:
             module.exit_json(changed=True, msg='System upgraded')
@@ -190,7 +191,7 @@ def remove_packages(module, pacman_path, packages):
     # Using a for loop incase of error, we can report the package that failed
     for package in packages:
         # Query the package first, to see if we even need to remove
-        installed, updated = query_package(module, pacman_path, package)
+        installed, updated, unknown = query_package(module, pacman_path, package)
         if not installed:
             continue
 
@@ -211,10 +212,15 @@ def remove_packages(module, pacman_path, packages):
 
 def install_packages(module, pacman_path, state, packages, package_files):
     install_c = 0
+    package_err = []
+    message = ""
 
     for i, package in enumerate(packages):
         # if the package is installed and state == present or state == latest and is up-to-date then skip
-        installed, updated = query_package(module, pacman_path, package)
+        installed, updated, latestError = query_package(module, pacman_path, package)
+        if latestError and state == 'latest':
+            package_err.append(package)
+            
         if installed and (state == 'present' or (state == 'latest' and updated)):
             continue
 
@@ -230,17 +236,19 @@ def install_packages(module, pacman_path, state, packages, package_files):
             module.fail_json(msg="failed to install %s" % (package))
 
         install_c += 1
-
+    
+    if state == 'latest' and len(package_err) > 0:
+        message = "But could not ensure 'latest' state for %s package(s) as remote version could not be fetched." % (package_err)
+    
     if install_c > 0:
-        module.exit_json(changed=True, msg="installed %s package(s)" % (install_c))
-
-    module.exit_json(changed=False, msg="package(s) already installed")
-
-
+        module.exit_json(changed=True, msg="installed %s package(s). %s" % (install_c, message))
+        
+    module.exit_json(changed=False, msg="package(s) already installed. %s" % (message))
+    
 def check_packages(module, pacman_path, packages, state):
     would_be_changed = []
     for package in packages:
-        installed, updated = query_package(module, pacman_path, package)
+        installed, updated, unknown = query_package(module, pacman_path, package)
         if ((state in ["present", "latest"] and not installed) or
                 (state == "absent" and installed) or
                 (state == "latest" and not updated)):

commit 273a3d1d514c522bd24fab4c950550f5f3a7b19d
Author: Yuwei Zhou <yuwzho@microsoft.com>
Date:   Thu Feb 8 17:32:27 2018 +0800

    Fixes #34913: azure_rm_loadbalance should accpet a list of rules instead of one (#35592)
    
    * azure_rm_loadbalance should accpet a list of rules instead of one
    
    * fix lint
    
    * fix
    
    * fix
    
    * hook up load balancer rules, doc fixes, test updates

diff --git a/lib/ansible/modules/cloud/azure/azure_rm_loadbalancer.py b/lib/ansible/modules/cloud/azure/azure_rm_loadbalancer.py
index 8b8e7bd5a1..b0231c23b7 100755
--- a/lib/ansible/modules/cloud/azure/azure_rm_loadbalancer.py
+++ b/lib/ansible/modules/cloud/azure/azure_rm_loadbalancer.py
@@ -1,22 +1,6 @@
 #!/usr/bin/python
-#
 # Copyright (c) 2016 Thomas Stringer, <tomstr@microsoft.com>
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
+# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
 
 from __future__ import absolute_import, division, print_function
 __metaclass__ = type
@@ -49,21 +33,162 @@ options:
         required: true
     state:
         description:
-            - Assert the state of the load balancer. Use 'present' to create or update a load balancer and
-              'absent' to delete a load balancer.
+            - Assert the state of the load balancer. Use C(present) to create/update a load balancer, or
+              C(absent) to delete one.
         default: present
         choices:
             - absent
             - present
-        required: false
     location:
         description:
             - Valid azure location. Defaults to location of the resource group.
         default: resource_group location
-        required: false
+    frontend_ip_configurations:
+        description: List of frontend IPs to be used
+        suboptions:
+            name:
+                description: Name of the frontend ip configuration.
+                required: True
+            public_ip_address:
+                description: Name of an existing public IP address object in the current resource group to associate with the security group.
+                required: True
+        version_added: 2.5
+    backend_address_pools:
+        description: List of backend address pools
+        suboptions:
+            name:
+                description: Name of the backend address pool.
+                required: True
+        version_added: 2.5
+    probes:
+        description: List of probe definitions used to check endpoint health.
+        suboptions:
+            name:
+                description: Name of the probe.
+                required: True
+            port:
+                description: Probe port for communicating the probe. Possible values range from 1 to 65535, inclusive.
+                required: True
+            protocol:
+                description:
+                    - The protocol of the end point to be probed.
+                    - If 'Tcp' is specified, a received ACK is required for the probe to be successful.
+                    - If 'Http' is specified, a 200 OK response from the specified URL is required for the probe to be successful.
+                choices:
+                    - Tcp
+                    - Http
+                default: Tcp
+            interval:
+                description:
+                    - The interval, in seconds, for how frequently to probe the endpoint for health status.
+                    - Slightly less than half the allocated timeout period, which allows two full probes before taking the instance out of rotation.
+                    - The default value is 15, the minimum value is 5.
+                default: 15
+            fail_count:
+                description:
+                    - The number of probes where if no response, will result in stopping further traffic from being delivered to the endpoint.
+                    - This values allows endpoints to be taken out of rotation faster or slower than the typical times used in Azure.
+                default: 3
+                aliases:
+                    - number_of_probes
+            request_path:
+                description:
+                    - The URI used for requesting health status from the VM.
+                    - Path is required if a protocol is set to http. Otherwise, it is not allowed.
+        version_added: 2.5
+    inbound_nat_pools:
+        description:
+            - Defines an external port range for inbound NAT to a single backend port on NICs associated with a load balancer.
+            - Inbound NAT rules are created automatically for each NIC associated with the Load Balancer using an external port from this range.
+            - Defining an Inbound NAT pool on your Load Balancer is mutually exclusive with defining inbound Nat rules.
+            - Inbound NAT pools are referenced from virtual machine scale sets.
+            - NICs that are associated with individual virtual machines cannot reference an inbound NAT pool.
+            - They have to reference individual inbound NAT rules.
+        suboptions:
+            name:
+                description: Name of the inbound NAT pool.
+                required: True
+            frontend_ip_configuration_name:
+                description: A reference to frontend IP addresses.
+                required: True
+            protocol:
+                description: IP protocol for the NAT pool
+                choices:
+                    - Tcp
+                    - Udp
+                    - All
+                default: Tcp
+            frontend_port_range_start:
+                description:
+                    - The first port in the range of external ports that will be used to provide inbound NAT to NICs associated with the load balancer.
+                    - Acceptable values range between 1 and 65534.
+                required: True
+            frontend_port_range_end:
+                description:
+                    - The last port in the range of external ports that will be used to provide inbound NAT to NICs associated with the load balancer.
+                    - Acceptable values range between 1 and 65535.
+                required: True
+            backend_port:
+                description:
+                    - The port used for internal connections on the endpoint.
+                    - Acceptable values are between 1 and 65535.
+        version_added: 2.5
+    load_balancing_rules:
+        description:
+            - Object collection representing the load balancing rules Gets the provisioning.
+        suboptions:
+            name:
+                description: name of the load balancing rule.
+                required: True
+            frontend_ip_configuration:
+                description: A reference to frontend IP addresses.
+                required: True
+            backend_address_pool:
+                description: A reference to a pool of DIPs. Inbound traffic is randomly load balanced across IPs in the backend IPs.
+                required: True
+            probe:
+                description: The name of the load balancer probe this rule should use for health checks.
+                required: True
+            protocol:
+                description: IP protocol for the load balancing rule.
+                choices:
+                    - Tcp
+                    - Udp
+                    - All
+                default: Tcp
+            load_distribution:
+                description:
+                    - The session persistence policy for this rule; C(Default) is no persistence.
+                choices:
+                    - Default
+                    - SourceIP
+                    - SourceIPProtocol
+                default: Default
+            frontend_port:
+                description:
+                    - The port for the external endpoint.
+                    - Frontend port numbers must be unique across all rules within the load balancer.
+                    - Acceptable values are between 0 and 65534.
+                    - Note that value 0 enables "Any Port"
+            backend_port:
+                description:
+                    - The port used for internal connections on the endpoint.
+                    - Acceptable values are between 0 and 65535.
+                    - Note that value 0 enables "Any Port"
+            idle_timeout:
+                description:
+                    - The timeout for the TCP idle connection.
+                    - The value can be set between 4 and 30 minutes.
+                    - The default value is 4 minutes.
+                    - This element is only used when the protocol is set to TCP.
+            enable_floating_ip:
+                description:
+                    - Configures SNAT for the VMs in the backend pool to use the publicIP address specified in the frontend of the load balancing rule.
+        version_added: 2.5
     public_ip_address_name:
         description:
-            - Name of an existing public IP address object to associate with the security group.
+            - (deprecated) Name of an existing public IP address object to associate with the security group.
+            - This option has been deprecated, and will be removed in 2.9. Use I(frontend_ip_configurations) instead.
         aliases:
             - public_ip_address
             - public_ip_name
@@ -71,39 +196,46 @@ options:
         required: false
     probe_port:
         description:
-            - The port that the health probe will use.
+            - (deprecated) The port that the health probe will use.
+            - This option has been deprecated, and will be removed in 2.9. Use I(probes) instead.
         required: false
     probe_protocol:
         description:
-            - The protocol to use for the health probe.
+            - (deprecated) The protocol to use for the health probe.
+            - This option has been deprecated, and will be removed in 2.9. Use I(probes) instead.
         required: false
         choices:
             - Tcp
             - Http
     probe_interval:
         description:
-            - How much time (in seconds) to probe the endpoint for health.
+            - (deprecated) Time (in seconds) between endpoint health probes.
+            - This option has been deprecated, and will be removed in 2.9. Use I(probes) instead.
         default: 15
         required: false
     probe_fail_count:
         description:
-            - The amount of probe failures for the load balancer to make a health determination.
+            - (deprecated) The amount of probe failures for the load balancer to make a health determination.
+            - This option has been deprecated, and will be removed in 2.9. Use I(probes) instead.
         default: 3
         required: false
     probe_request_path:
         description:
-            - The URL that an HTTP probe will use (only relevant if probe_protocol is set to Http).
+            - (deprecated) The URL that an HTTP probe will use (only relevant if probe_protocol is set to Http).
+            - This option has been deprecated, and will be removed in 2.9. Use I(probes) instead.
         required: false
     protocol:
         description:
-            - The protocol (TCP or UDP) that the load balancer will use.
+            - (deprecated) The protocol (TCP or UDP) that the load balancer will use.
+            - This option has been deprecated, and will be removed in 2.9. Use I(load_balancing_rules) instead.
         required: false
         choices:
             - Tcp
             - Udp
     load_distribution:
         description:
-            - The type of load distribution that the load balancer will employ.
+            - (deprecated) The type of load distribution that the load balancer will employ.
+            - This option has been deprecated, and will be removed in 2.9. Use I(load_balancing_rules) instead.
         required: false
         choices:
             - Default
@@ -111,32 +243,39 @@ options:
             - SourceIPProtocol
     frontend_port:
         description:
-            - Frontend port that will be exposed for the load balancer.
+            - (deprecated) Frontend port that will be exposed for the load balancer.
+            - This option has been deprecated, and will be removed in 2.9. Use I(load_balancing_rules) instead.
         required: false
     backend_port:
         description:
-            - Backend port that will be exposed for the load balancer.
+            - (deprecated) Backend port that will be exposed for the load balancer.
+            - This option has been deprecated, and will be removed in 2.9. Use I(load_balancing_rules) instead.
         required: false
     idle_timeout:
         description:
-            - Timeout for TCP idle connection in minutes.
+            - (deprecated) Timeout for TCP idle connection in minutes.
+            - This option has been deprecated, and will be removed in 2.9. Use I(load_balancing_rules) instead.
         default: 4
         required: false
     natpool_frontend_port_start:
         description:
-            - Start of the port range for a NAT pool.
+            - (deprecated) Start of the port range for a NAT pool.
+            - This option has been deprecated, and will be removed in 2.9. Use I(inbound_nat_pools) instead.
         required: false
     natpool_frontend_port_end:
         description:
-            - End of the port range for a NAT pool.
+            - (deprecated) End of the port range for a NAT pool.
+            - This option has been deprecated, and will be removed in 2.9. Use I(inbound_nat_pools) instead.
         required: false
     natpool_backend_port:
         description:
-            - Backend port used by the NAT pool.
+            - (deprecated) Backend port used by the NAT pool.
+            - This option has been deprecated, and will be removed in 2.9. Use I(inbound_nat_pools) instead.
         required: false
     natpool_protocol:
         description:
-            - The protocol for the NAT pool.
+            - (deprecated) The protocol for the NAT pool.
+            - This option has been deprecated, and will be removed in 2.9. Use I(inbound_nat_pools) instead.
         required: false
 extends_documentation_fragment:
     - azure
@@ -144,9 +283,11 @@ extends_documentation_fragment:
 
 author:
     - "Thomas Stringer (@tstringer)"
+    - "Yuwei Zhou (@yuwzho)"
 '''
 
 EXAMPLES = '''
+    # TODO: this example needs update for 2.5+ module args
     - name: Create a load balancer
       azure_rm_loadbalancer:
         name: myloadbalancer
@@ -183,12 +324,135 @@ import random
 from ansible.module_utils.azure_rm_common import AzureRMModuleBase
 
 try:
+    from msrestazure.tools import parse_resource_id
     from msrestazure.azure_exceptions import CloudError
 except ImportError:
     # This is handled in azure_rm_common
     pass
 
 
+frontend_ip_configuration_spec = dict(
+    name=dict(
+        type='str',
+        required=True
+    ),
+    public_ip_address=dict(
+        type='str',
+        required=True
+    )
+)
+
+
+backend_address_pool_spec = dict(
+    name=dict(
+        type='str',
+        required=True
+    )
+)
+
+
+probes_spec = dict(
+    name=dict(
+        type='str',
+        required=True
+    ),
+    port=dict(
+        type='int',
+        required=True
+    ),
+    protocol=dict(
+        type='str',
+        choices=['Tcp', 'Http'],
+        default='Tcp'
+    ),
+    interval=dict(
+        type='int',
+        default=15
+    ),
+    fail_count=dict(
+        type='int',
+        default=3,
+        aliases=['number_of_probes']
+    ),
+    request_path=dict(
+        type='str'
+    )
+)
+
+
+inbound_nat_pool_spec = dict(
+    name=dict(
+        type='str',
+        required=True
+    ),
+    frontend_ip_configuration_name=dict(
+        type='str',
+        required=True
+    ),
+    protocol=dict(
+        type='str',
+        choices=['Tcp', 'Udp', 'All'],
+        default='Tcp'
+    ),
+    frontend_port_range_start=dict(
+        type='int',
+        required=True
+    ),
+    frontend_port_range_end=dict(
+        type='int',
+        required=True
+    ),
+    backend_port=dict(
+        type='int',
+        required=True
+    )
+)
+
+
+load_balancing_rule_spec = dict(
+    name=dict(
+        type='str',
+        required=True
+    ),
+    frontend_ip_configuration=dict(
+        type='str',
+        required=True
+    ),
+    backend_address_pool=dict(
+        type='str',
+        required=True
+    ),
+    probe=dict(
+        type='str',
+        required=True
+    ),
+    protocol=dict(
+        type='str',
+        choices=['Tcp', 'Udp', 'All'],
+        default='Tcp'
+    ),
+    load_distribution=dict(
+        type='str',
+        choices=['Default', 'SourceIP', 'SourceIPProtocol'],
+        default='Default'
+    ),
+    frontend_port=dict(
+        type='int',
+        required=True
+    ),
+    backend_port=dict(
+        type='int'
+    ),
+    idle_timeout=dict(
+        type='int',
+        default=4
+    ),
+    enable_floating_ip=dict(
+        type='bool'
+    )
+)
+
+
 class AzureRMLoadBalancer(AzureRMModuleBase):
     """Configuration class for an Azure RM load balancer resource"""
 
@@ -204,26 +468,46 @@ class AzureRMLoadBalancer(AzureRMModuleBase):
             ),
             state=dict(
                 type='str',
-                required=False,
                 default='present',
                 choices=['present', 'absent']
             ),
             location=dict(
-                type='str',
-                required=False
+                type='str'
+            ),
+            frontend_ip_configurations=dict(
+                type='list',
+                elements='dict',
+                options=frontend_ip_configuration_spec
+            ),
+            backend_address_pools=dict(
+                type='list',
+                elements='dict',
+                options=backend_address_pool_spec
+            ),
+            probes=dict(
+                type='list',
+                elements='dict',
+                options=probes_spec
+            ),
+            inbound_nat_pools=dict(
+                type='list',
+                elements='dict',
+                options=inbound_nat_pool_spec
+            ),
+            load_balancing_rules=dict(
+                type='list',
+                elements='dict',
+                options=load_balancing_rule_spec
             ),
             public_ip_address_name=dict(
                 type='str',
-                required=False,
                 aliases=['public_ip_address', 'public_ip_name', 'public_ip']
             ),
             probe_port=dict(
-                type='int',
-                required=False
+                type='int'
             ),
             probe_protocol=dict(
                 type='str',
-                required=False,
                 choices=['Tcp', 'Http']
             ),
             probe_interval=dict(
@@ -235,26 +519,21 @@ class AzureRMLoadBalancer(AzureRMModuleBase):
                 default=3
             ),
             probe_request_path=dict(
-                type='str',
-                required=False
+                type='str'
             ),
             protocol=dict(
                 type='str',
-                required=False,
                 choices=['Tcp', 'Udp']
             ),
             load_distribution=dict(
                 type='str',
-                required=False,
                 choices=['Default', 'SourceIP', 'SourceIPProtocol']
             ),
             frontend_port=dict(
-                type='int',
-                required=False
+                type='int'
             ),
             backend_port=dict(
-                type='int',
-                required=False
+                type='int'
             ),
             idle_timeout=dict(
                 type='int',
@@ -277,6 +556,11 @@ class AzureRMLoadBalancer(AzureRMModuleBase):
         self.resource_group = None
         self.name = None
         self.location = None
+        self.frontend_ip_configurations = None
+        self.backend_address_pools = None
+        self.probes = None
+        self.inbound_nat_pools = None
+        self.load_balancing_rules = None
         self.public_ip_address_name = None
         self.state = None
         self.probe_port = None
@@ -296,12 +580,9 @@ class AzureRMLoadBalancer(AzureRMModuleBase):
 
         self.results = dict(changed=False, state=dict())
 
-        required_if = [('state', 'present', ['public_ip_address_name'])]
-
         super(AzureRMLoadBalancer, self).__init__(
             derived_arg_spec=self.module_args,
-            supports_check_mode=True,
-            required_if=required_if
+            supports_check_mode=True
         )
 
     def exec_module(self, **kwargs):
@@ -309,164 +590,195 @@ class AzureRMLoadBalancer(AzureRMModuleBase):
         for key in self.module_args.keys():
             setattr(self, key, kwargs[key])
 
-        results = dict()
         changed = False
-        pip = None
-        load_balancer_props = dict()
 
         resource_group = self.get_resource_group(self.resource_group)
         if not self.location:
             self.location = resource_group.location
-        load_balancer_props['location'] = self.location
-
-        if self.state == 'present':
-            # handle present status
-
-            frontend_ip_config_name = random_name('feipconfig')
-            frontend_ip_config_id = frontend_ip_configuration_id(
-                subscription_id=self.subscription_id,
-                resource_group_name=self.resource_group,
-                load_balancer_name=self.name,
-                name=frontend_ip_config_name
-            )
-            if self.public_ip_address_name:
-                pip = self.get_public_ip_address(self.public_ip_address_name)
-                load_balancer_props['frontend_ip_configurations'] = [
-                    self.network_models.FrontendIPConfiguration(
-                        name=frontend_ip_config_name,
-                        public_ip_address=pip
-                    )
-                ]
-        elif self.state == 'absent':
-            try:
-                self.network_client.load_balancers.delete(
-                    resource_group_name=self.resource_group,
-                    load_balancer_name=self.name
-                ).wait()
-                changed = True
-            except CloudError:
-                changed = False
-
-            self.results['changed'] = changed
-            return self.results
-
-        try:
-            # before we do anything, we need to attempt to retrieve the load balancer
-            # knowing whether or not it exists will tell us what to do in the future
-            self.log('Fetching load balancer {}'.format(self.name))
-            load_balancer = self.network_client.load_balancers.get(self.resource_group, self.name)
-
-            self.log('Load balancer {} exists'.format(self.name))
-            self.check_provisioning_state(load_balancer, self.state)
-            results = load_balancer_to_dict(load_balancer)
-            self.log(results, pretty_print=True)
 
-            if self.state == 'present':
-                update_tags, results['tags'] = self.update_tags(results['tags'])
+        load_balancer = self.get_load_balancer()
 
-                if update_tags:
-                    changed = True
-        except CloudError:
-            self.log('Load balancer {} does not exist'.format(self.name))
-            if self.state == 'present':
-                self.log(
-                    'CHANGED: load balancer {} does not exist but requested status \'present\''
-                    .format(self.name)
-                )
-                changed = True
-
-        backend_address_pool_name = random_name('beap')
-        backend_addr_pool_id = backend_address_pool_id(
-            subscription_id=self.subscription_id,
-            resource_group_name=self.resource_group,
-            load_balancer_name=self.name,
-            name=backend_address_pool_name
-        )
-        load_balancer_props['backend_address_pools'] = [self.network_models.BackendAddressPool(name=backend_address_pool_name)]
-
-        probe_name = random_name('probe')
-        prb_id = probe_id(
-            subscription_id=self.subscription_id,
-            resource_group_name=self.resource_group,
-            load_balancer_name=self.name,
-            name=probe_name
-        )
-
-        if self.probe_protocol:
-            load_balancer_props['probes'] = [
-                self.network_models.Probe(
-                    name=probe_name,
-                    protocol=self.probe_protocol,
+        if self.state == 'present':
+            # compatible parameters
+            if not self.frontend_ip_configurations and not self.backend_address_pools and not self.probes and not self.inbound_nat_pools:
+                self.deprecate('Discrete load balancer config settings are deprecated and will be removed.'
+                               ' Use frontend_ip_configurations, backend_address_pools, probes, inbound_nat_pools lists instead.', version='2.9')
+                frontend_ip_name = 'frontendip0'
+                backend_address_pool_name = 'backendaddrp0'
+                prob_name = 'prob0'
+                inbound_nat_pool_name = 'inboundnatp0'
+                lb_rule_name = 'lbr'
+                self.frontend_ip_configurations = [dict(
+                    name=frontend_ip_name,
+                    public_ip_address=self.public_ip_address_name
+                )]
+                self.backend_address_pools = [dict(
+                    name=backend_address_pool_name
+                )]
+                self.probes = [dict(
+                    name=prob_name,
                     port=self.probe_port,
-                    interval_in_seconds=self.probe_interval,
-                    number_of_probes=self.probe_fail_count,
+                    protocol=self.probe_protocol,
+                    interval=self.probe_interval,
+                    fail_count=self.probe_fail_count,
                     request_path=self.probe_request_path
-                )
-            ]
-
-        load_balancing_rule_name = random_name('lbr')
-        if self.protocol:
-            load_balancer_props['load_balancing_rules'] = [
-                self.network_models.LoadBalancingRule(
-                    name=load_balancing_rule_name,
-                    frontend_ip_configuration=self.network_models.SubResource(id=frontend_ip_config_id),
-                    backend_address_pool=self.network_models.SubResource(id=backend_addr_pool_id),
-                    probe=self.network_models.SubResource(id=prb_id),
-                    protocol=self.protocol,
-                    load_distribution=self.load_distribution,
-                    frontend_port=self.frontend_port,
-                    backend_port=self.backend_port,
-                    idle_timeout_in_minutes=self.idle_timeout,
-                    enable_floating_ip=False
-                )
-            ]
-
-        inbound_nat_pool_name = random_name('inp')
-        if frontend_ip_config_id and self.natpool_protocol:
-            load_balancer_props['inbound_nat_pools'] = [
-                self.network_models.InboundNatPool(
+                )] if self.probe_protocol else None
+                self.inbound_nat_pools = [dict(
                     name=inbound_nat_pool_name,
-                    frontend_ip_configuration=self.network_models.Subnet(id=frontend_ip_config_id),
+                    frontend_ip_configuration_name=frontend_ip_name,
                     protocol=self.natpool_protocol,
                     frontend_port_range_start=self.natpool_frontend_port_start,
                     frontend_port_range_end=self.natpool_frontend_port_end,
                     backend_port=self.natpool_backend_port
-                )
-            ]
+                )] if self.natpool_protocol else None
+                self.load_balancing_rules = [dict(
+                    name=lb_rule_name,
+                    frontend_ip_configuration=frontend_ip_name,
+                    backend_address_pool=backend_address_pool_name,
+                    probe=prob_name,
+                    protocol=self.protocol,
+                    load_distribution=self.load_distribution,
+                    frontend_port=self.frontend_port,
+                    backend_port=self.backend_port,
+                    idle_timeout=self.idle_timeout,
+                    enable_floating_ip=False
+                )] if self.protocol else None
+            if load_balancer:
+                # check update, NIE
+                changed = False
+            else:
+                changed = True
+        elif self.state == 'absent' and load_balancer:
+            changed = True
 
+        self.results['state'] = load_balancer_to_dict(load_balancer)
         self.results['changed'] = changed
-        self.results['state'] = (
-            results if results
-            else load_balancer_to_dict(self.network_models.LoadBalancer(**load_balancer_props))
-        )
 
-        if self.check_mode:
-            return self.results
+        if self.state == 'present' and changed:
+            # create or update
+            frontend_ip_configurations_param = [self.network_models.FrontendIPConfiguration(
+                name=item.get('name'),
+                public_ip_address=self.get_public_ip_address(item.get('public_ip_address'))
+            ) for item in self.frontend_ip_configurations] if self.frontend_ip_configurations else None
+
+            backend_address_pools_param = [self.network_models.BackendAddressPool(
+                name=item.get('name')
+            ) for item in self.backend_address_pools] if self.backend_address_pools else None
+
+            probes_param = [self.network_models.Probe(
+                name=item.get('name'),
+                port=item.get('port'),
+                protocol=item.get('protocol'),
+                interval_in_seconds=item.get('interval'),
+                request_path=item.get('request_path'),
+                number_of_probes=item.get('fail_count')
+            ) for item in self.probes] if self.probes else None
+
+            inbound_nat_pools_param = [self.network_models.InboundNatPool(
+                name=item.get('name'),
+                frontend_ip_configuration=self.network_models.SubResource(
+                    frontend_ip_configuration_id(
+                        self.subscription_id,
+                        self.resource_group,
+                        self.name,
+                        item.get('frontend_ip_configuration_name'))),
+                protocol=item.get('protocol'),
+                frontend_port_range_start=item.get('frontend_port_range_start'),
+                frontend_port_range_end=item.get('frontend_port_range_end'),
+                backend_port=item.get('backend_port')
+            ) for item in self.inbound_nat_pools] if self.inbound_nat_pools else None
+
+            load_balancing_rules_param = [self.network_models.LoadBalancingRule(
+                name=item.get('name'),
+                frontend_ip_configuration=self.network_models.SubResource(
+                    frontend_ip_configuration_id(
+                        self.subscription_id,
+                        self.resource_group,
+                        self.name,
+                        item.get('frontend_ip_configuration')
+                    )
+                ),
+                backend_address_pool=self.network_models.SubResource(
+                    backend_address_pool_id(
+                        self.subscription_id,
+                        self.resource_group,
+                        self.name,
+                        item.get('backend_address_pool')
+                    )
+                ),
+                probe=self.network_models.SubResource(
+                    probe_id(
+                        self.subscription_id,
+                        self.resource_group,
+                        self.name,
+                        item.get('probe')
+                    )
+                ),
+                protocol=item.get('protocol'),
+                load_distribution=item.get('load_distribution'),
+                frontend_port=item.get('frontend_port'),
+                backend_port=item.get('backend_port'),
+                idle_timeout_in_minutes=item.get('idle_timeout'),
+                enable_floating_ip=item.get('enable_floating_ip')
+            ) for item in self.load_balancing_rules] if self.load_balancing_rules else None
+
+            param = self.network_models.LoadBalancer(
+                location=self.location,
+                frontend_ip_configurations=frontend_ip_configurations_param,
+                backend_address_pools=backend_address_pools_param,
+                probes=probes_param,
+                inbound_nat_pools=inbound_nat_pools_param,
+                load_balancing_rules=load_balancing_rules_param
+            )
 
-        try:
-            self.network_client.load_balancers.create_or_update(
-                resource_group_name=self.resource_group,
-                load_balancer_name=self.name,
-                parameters=self.network_models.LoadBalancer(**load_balancer_props)
-            ).wait()
-        except CloudError as err:
-            self.fail('Error creating load balancer {}'.format(err))
+            self.create_or_update_load_balancer(param)
+        elif self.state == 'absent' and changed:
+            self.delete_load_balancer()
+            self.results['state'] = None
 
         return self.results
 
-    def get_public_ip_address(self, name):
+    def get_public_ip_address(self, id):
         """Get a reference to the public ip address resource"""
-
-        self.log('Fetching public ip address {}'.format(name))
+        self.log('Fetching public ip address {}'.format(id))
+        pip_dict = parse_resource_id(id)
+        resource_group = pip_dict.get('resource_group', self.resource_group)
+        name = pip_dict.get('name')
         try:
-            public_ip = self.network_client.public_ip_addresses.get(self.resource_group, name)
+            return self.network_client.public_ip_addresses.get(resource_group, name)
         except CloudError as err:
             self.fail('Error fetching public ip address {} - {}'.format(name, str(err)))
-        return public_ip
+
+    def get_load_balancer(self):
+        """Get a load balancer"""
+        self.log('Fetching loadbalancer {0}'.format(self.name))
+        try:
+            return self.network_client.load_balancers.get(self.resource_group, self.name)
+        except CloudError:
+            return None
+
+    def delete_load_balancer(self):
+        """Delete a load balancer"""
+        self.log('Deleting loadbalancer {0}'.format(self.name))
+        try:
+            poller = self.network_client.load_balancers.delete(self.resource_group, self.name)
+            return self.get_poller_result(poller)
+        except CloudError as exc:
+            self.fail("Error deleting loadbalancer {0} - {1}".format(self.name, str(exc)))
+
+    def create_or_update_load_balancer(self, param):
+        try:
+            poller = self.network_client.load_balancers.create_or_update(self.resource_group, self.name, param)
+            new_lb = self.get_poller_result(poller)
+            return load_balancer_to_dict(new_lb)
+        except CloudError as exc:
+            self.fail("Error creating or updating load balancer {0} - {1}".format(self.name, str(exc)))
 
 
 def load_balancer_to_dict(load_balancer):
     """Seralialize a LoadBalancer object to a dict"""
+    if not load_balancer:
+        return dict()
 
     result = dict(
         id=load_balancer.id,
@@ -583,11 +895,6 @@ def load_balancer_to_dict(load_balancer):
     return result
 
 
-def random_name(prefix):
-    """Generate a random name with a specific prefix"""
-    return '{}{}'.format(prefix, random.randint(10000, 99999))
-
-
 def frontend_ip_configuration_id(subscription_id, resource_group_name, load_balancer_name, name):
     """Generate the id for a frontend ip configuration"""
     return '/subscriptions/{}/resourceGroups/{}/providers/Microsoft.Network/loadBalancers/{}/frontendIPConfigurations/{}'.format(
diff --git a/test/integration/targets/azure_rm_loadbalancer/aliases b/test/integration/targets/azure_rm_loadbalancer/aliases
index b1cd4a5978..9e23ddb721 100644
--- a/test/integration/targets/azure_rm_loadbalancer/aliases
+++ b/test/integration/targets/azure_rm_loadbalancer/aliases
@@ -1,2 +1,3 @@
 cloud/azure
+posix/ci/cloud/group2/azure
 destructive
diff --git a/test/integration/targets/azure_rm_loadbalancer/tasks/main.yml b/test/integration/targets/azure_rm_loadbalancer/tasks/main.yml
index 91e4c3c350..5901f8ef15 100644
--- a/test/integration/targets/azure_rm_loadbalancer/tasks/main.yml
+++ b/test/integration/targets/azure_rm_loadbalancer/tasks/main.yml
@@ -3,6 +3,12 @@
     name: ansiblepip3
     resource_group: '{{ resource_group }}'
 
+- name: clear load balancer
+  azure_rm_loadbalancer:
+    resource_group: '{{ resource_group }}'
+    name: lbtestfromansible
+    state: absent
+
 - name: create load balancer
   azure_rm_loadbalancer:
     resource_group: '{{ resource_group }}'
@@ -25,6 +31,17 @@
   assert:
     that: output.changed
 
+- name: delete load balancer (idempotent)
+  azure_rm_loadbalancer:
+    resource_group: '{{ resource_group }}'
+    name: lbtestfromansible
+    state: absent
+  register: output
+
+- name: assert load balancer deleted (idempotent)
+  assert:
+    that: not output.changed
+
 - name: create another load balancer with more options
   azure_rm_loadbalancer:
     resource_group: '{{ resource_group }}'
@@ -55,6 +72,44 @@
     name: lbtestfromansible
     state: absent
 
+- name: create load balancer with multiple parameters
+  azure_rm_loadbalancer:
+    resource_group: '{{ resource_group }}'
+    name: lbtestfromansible
+    frontend_ip_configurations:
+      - name: frontendipconf0
+        public_ip_address: ansiblepip3
+    backend_address_pools:
+      - name: backendaddrpool0
+    probes:
+      - name: prob0
+        port: 80
+    inbound_nat_pools:
+      - name: inboundnatpool0
+        frontend_ip_configuration_name: frontendipconf0
+        protocol: Tcp
+        frontend_port_range_start: 80
+        frontend_port_range_end: 81
+        backend_port: 8080
+    load_balancing_rules:
+      - name: lbrbalancingrule0
+        frontend_ip_configuration: frontendipconf0
+        backend_address_pool: backendaddrpool0
+        frontend_port: 80
+        backend_port: 80
+        probe: prob0
+  register: output
+
+- name: assert complex load balancer created
+  assert:
+    that: output.changed
+
+- name: delete load balancer
+  azure_rm_loadbalancer:
+    resource_group: '{{ resource_group }}'
+    name: lbtestfromansible
+    state: absent
+
 - name: cleanup public ip
   azure_rm_publicipaddress:
     name: ansiblepip3

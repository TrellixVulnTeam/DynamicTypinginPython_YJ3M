commit 3fa745eef936894d2ac79d8ceaa605833f9f7618
Author: @ <@>
Date:   Thu Jun 2 12:56:48 2016 -0700

    Fixing error exception handling for python3. Does not need to be compaâ€¦ (#3840)
    
    * Fixing error exception handling for python. Does not need to be compatible with Python2.4 b/c boto is Python 2.6 and above.
    
    * Fixing error exception handling for python. Does not need to be compatible with Python2.4 b/c boto is Python 2.6 and above.
    
    * Fixing compile time errors IRT error exception handling for Python 3.5.
    This does not need to be compatible with Python2.4 b/c Boto is Python 2.6 and above.

diff --git a/lib/ansible/modules/cloud/amazon/ec2_ami.py b/lib/ansible/modules/cloud/amazon/ec2_ami.py
index a543c341a9..f6140f8f35 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_ami.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_ami.py
@@ -387,7 +387,7 @@ def create_image(module, ec2):
             params['block_device_mapping'] = bdm
 
         image_id = ec2.create_image(**params)
-    except boto.exception.BotoServerError, e:
+    except boto.exception.BotoServerError as e:
         module.fail_json(msg="%s: %s" % (e.error_code, e.error_message))
 
     # Wait until the image is recognized. EC2 API has eventual consistency,
@@ -399,7 +399,7 @@ def create_image(module, ec2):
 
             if img.state == 'available':
                 break
-        except boto.exception.EC2ResponseError, e:
+        except boto.exception.EC2ResponseError as e:
             if ('InvalidAMIID.NotFound' not in e.error_code and 'InvalidAMIID.Unavailable' not in e.error_code) and wait and i == wait_timeout - 1:
                 module.fail_json(msg="Error while trying to find the new image. Using wait=yes and/or a longer wait_timeout may help. %s: %s" % (e.error_code, e.error_message))
         finally:
@@ -411,13 +411,13 @@ def create_image(module, ec2):
     if tags:
         try:
             ec2.create_tags(image_id, tags)
-        except boto.exception.EC2ResponseError, e:
+        except boto.exception.EC2ResponseError as e:
             module.fail_json(msg = "Image tagging failed => %s: %s" % (e.error_code, e.error_message))
     if launch_permissions:
         try:
             img = ec2.get_image(image_id)
             img.set_launch_permissions(**launch_permissions)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             module.fail_json(msg="%s: %s" % (e.error_code, e.error_message), image_id=image_id)
 
     module.exit_json(msg="AMI creation operation complete", changed=True, **get_ami_info(img))
@@ -450,7 +450,7 @@ def deregister_image(module, ec2):
             params = {'image_id': image_id,
                       'delete_snapshot': delete_snapshot}
             res = ec2.deregister_image(**params)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             module.fail_json(msg = "%s: %s" % (e.error_code, e.error_message))
     else:
         module.exit_json(msg = "Image %s has already been deleted" % image_id, changed=False)
@@ -471,7 +471,7 @@ def deregister_image(module, ec2):
         try:
             for snapshot_id in snapshots:
                 ec2.delete_snapshot(snapshot_id)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             if e.error_code == 'InvalidSnapshot.NotFound':
                 # Don't error out if root volume snapshot was already deleted as part of deregister_image
                 pass
@@ -507,7 +507,7 @@ def update_image(module, ec2):
         else:
             module.exit_json(msg="AMI not updated", launch_permissions=set_permissions, changed=False)
 
-    except boto.exception.BotoServerError, e:
+    except boto.exception.BotoServerError as e:
         module.fail_json(msg = "%s: %s" % (e.error_code, e.error_message))
 
 def main():
@@ -534,7 +534,7 @@ def main():
 
     try:
         ec2 = ec2_connect(module)
-    except Exception, e:
+    except Exception as e:
         module.fail_json(msg="Error while connecting to aws: %s" % str(e))
 
     if module.params.get('state') == 'absent':
diff --git a/lib/ansible/modules/cloud/amazon/ec2_asg.py b/lib/ansible/modules/cloud/amazon/ec2_asg.py
index cabf9e1e93..32f593c793 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_asg.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_asg.py
@@ -294,7 +294,7 @@ def elb_dreg(asg_connection, module, group_name, instance_id):
     if as_group.load_balancers and as_group.health_check_type == 'ELB':
         try:
             elb_connection = connect_to_aws(boto.ec2.elb, region, **aws_connect_params)
-        except boto.exception.NoAuthHandlerFound, e:
+        except boto.exception.NoAuthHandlerFound as e:
             module.fail_json(msg=str(e))
     else:
         return
@@ -356,7 +356,7 @@ def wait_for_elb(asg_connection, module, group_name):
         log.debug("Waiting for ELB to consider intances healthy.")
         try:
             elb_connection = connect_to_aws(boto.ec2.elb, region, **aws_connect_params)
-        except boto.exception.NoAuthHandlerFound, e:
+        except boto.exception.NoAuthHandlerFound as e:
             module.fail_json(msg=str(e))
 
         wait_timeout = time.time() + wait_timeout
@@ -393,7 +393,7 @@ def create_autoscaling_group(connection, module):
         region, ec2_url, aws_connect_params = get_aws_connection_info(module)
         try:
             ec2_connection = connect_to_aws(boto.ec2, region, **aws_connect_params)
-        except (boto.exception.NoAuthHandlerFound, AnsibleAWSError), e:
+        except (boto.exception.NoAuthHandlerFound, AnsibleAWSError) as e:
             module.fail_json(msg=str(e))
     elif vpc_zone_identifier:
         vpc_zone_identifier = ','.join(vpc_zone_identifier)
@@ -437,7 +437,7 @@ def create_autoscaling_group(connection, module):
             asg_properties = get_properties(as_group)
             changed = True
             return(changed, asg_properties)
-        except BotoServerError, e:
+        except BotoServerError as e:
             module.fail_json(msg=str(e))
     else:
         as_group = as_groups[0]
@@ -492,7 +492,7 @@ def create_autoscaling_group(connection, module):
         if changed:
             try:
                 as_group.update()
-            except BotoServerError, e:
+            except BotoServerError as e:
                 module.fail_json(msg=str(e))
 
         if wait_for_instances:
@@ -501,7 +501,7 @@ def create_autoscaling_group(connection, module):
         try:
             as_group = connection.get_all_groups(names=[group_name])[0]
             asg_properties = get_properties(as_group)
-        except BotoServerError, e:
+        except BotoServerError as e:
             module.fail_json(msg=str(e))
         return(changed, asg_properties)
 
@@ -815,7 +815,7 @@ def main():
         connection = connect_to_aws(boto.ec2.autoscale, region, **aws_connect_params)
         if not connection:
             module.fail_json(msg="failed to connect to AWS for the given region: %s" % str(region))
-    except boto.exception.NoAuthHandlerFound, e:
+    except boto.exception.NoAuthHandlerFound as e:
         module.fail_json(msg=str(e))
     changed = create_changed = replace_changed = False
 
diff --git a/lib/ansible/modules/cloud/amazon/ec2_eip.py b/lib/ansible/modules/cloud/amazon/ec2_eip.py
index 689deeb2ef..98a94d90d9 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_eip.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_eip.py
@@ -234,7 +234,7 @@ def find_device(ec2, device_id, isinstance=True):
     if isinstance:
         try:
             reservations = ec2.get_all_reservations(instance_ids=[device_id])
-        except boto.exception.EC2ResponseError, e:
+        except boto.exception.EC2ResponseError as e:
             module.fail_json(msg=str(e))
 
         if len(reservations) == 1:
@@ -244,7 +244,7 @@ def find_device(ec2, device_id, isinstance=True):
     else:
         try:
             interfaces = ec2.get_all_network_interfaces(network_interface_ids=[device_id])
-        except boto.exception.EC2ResponseError, e:
+        except boto.exception.EC2ResponseError as e:
             module.fail_json(msg=str(e))
 
         if len(interfaces) == 1:
diff --git a/lib/ansible/modules/cloud/amazon/ec2_elb.py b/lib/ansible/modules/cloud/amazon/ec2_elb.py
index c4d99bf8a0..7785f7a862 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_elb.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_elb.py
@@ -242,7 +242,7 @@ class ElbManager:
         """
         try:
             status = lb.get_instance_health([self.instance_id])[0]
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             if e.error_code == 'InvalidInstance':
                 return None
             else:
@@ -260,7 +260,7 @@ class ElbManager:
 
         try:
             elb = connect_to_aws(boto.ec2.elb, self.region, **self.aws_connect_params)
-        except (boto.exception.NoAuthHandlerFound, AnsibleAWSError), e:
+        except (boto.exception.NoAuthHandlerFound, AnsibleAWSError) as e:
             self.module.fail_json(msg=str(e))
 
         elbs = []
@@ -293,7 +293,7 @@ class ElbManager:
 
         try:
            asg = connect_to_aws(boto.ec2.autoscale, self.region, **self.aws_connect_params)
-        except (boto.exception.NoAuthHandlerFound, AnsibleAWSError), e:
+        except (boto.exception.NoAuthHandlerFound, AnsibleAWSError) as e:
             self.module.fail_json(msg=str(e))
 
         asg_instances = asg.get_all_autoscaling_instances([self.instance_id])
@@ -317,7 +317,7 @@ class ElbManager:
         """Returns a boto.ec2.InstanceObject for self.instance_id"""
         try:
             ec2 = connect_to_aws(boto.ec2, self.region, **self.aws_connect_params)
-        except (boto.exception.NoAuthHandlerFound, AnsibleAWSError), e:
+        except (boto.exception.NoAuthHandlerFound, AnsibleAWSError) as e:
             self.module.fail_json(msg=str(e))
         return ec2.get_only_instances(instance_ids=[self.instance_id])[0]
 
diff --git a/lib/ansible/modules/cloud/amazon/ec2_elb_lb.py b/lib/ansible/modules/cloud/amazon/ec2_elb_lb.py
index d540893996..a566fe7e9d 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_elb_lb.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_elb_lb.py
@@ -406,7 +406,7 @@ def _throttleable_operation(max_retries):
             while True:
                 try:
                     return op(*args, **kwargs)
-                except boto.exception.BotoServerError, e:
+                except boto.exception.BotoServerError as e:
                     if retry < max_retries and e.code in \
                             ("Throttling", "RequestLimitExceeded"):
                         retry = retry + 1
@@ -622,7 +622,7 @@ class ElbManager(object):
         for x in range(0, max_retries):
             try:
                 result = self.elb_conn.get_all_lb_attributes(self.name)
-            except (boto.exception.BotoServerError, StandardError), e:
+            except (boto.exception.BotoServerError, StandardError) as e:
                 if "LoadBalancerNotFound" in e.code:
                     status_achieved = True
                     break
@@ -650,7 +650,7 @@ class ElbManager(object):
                         break
                     else:
                         time.sleep(polling_increment_secs)
-                except (boto.exception.BotoServerError, StandardError), e:
+                except (boto.exception.BotoServerError, StandardError) as e:
                     if 'InvalidNetworkInterfaceID' in e.code:
                         status_achieved = True
                         break
@@ -671,14 +671,14 @@ class ElbManager(object):
         try:
             return connect_to_aws(boto.ec2.elb, self.region,
                                   **self.aws_connect_params)
-        except (boto.exception.NoAuthHandlerFound, AnsibleAWSError), e:
+        except (boto.exception.NoAuthHandlerFound, AnsibleAWSError) as e:
             self.module.fail_json(msg=str(e))
 
     def _get_ec2_connection(self):
         try:
             return connect_to_aws(boto.ec2, self.region,
                                   **self.aws_connect_params)
-        except (boto.exception.NoAuthHandlerFound, StandardError), e:
+        except (boto.exception.NoAuthHandlerFound, StandardError) as e:
             self.module.fail_json(msg=str(e))
 
     @_throttleable_operation(_THROTTLING_RETRIES)
@@ -815,7 +815,7 @@ class ElbManager(object):
     def _enable_zones(self, zones):
         try:
             self.elb.enable_zones(zones)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             if "Invalid Availability Zone" in e.error_message:
                 self.module.fail_json(msg=e.error_message)
             else:
@@ -825,7 +825,7 @@ class ElbManager(object):
     def _disable_zones(self, zones):
         try:
             self.elb.disable_zones(zones)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             if "Invalid Availability Zone" in e.error_message:
                 self.module.fail_json(msg=e.error_message)
             else:
@@ -1296,7 +1296,7 @@ def main():
 
                 group_id = [ str(grp.id) for grp in grp_details if str(grp.name) in group_name ]
                 security_group_ids.extend(group_id)
-        except boto.exception.NoAuthHandlerFound, e:
+        except boto.exception.NoAuthHandlerFound as e:
             module.fail_json(msg = str(e))
 
 
diff --git a/lib/ansible/modules/cloud/amazon/ec2_group.py b/lib/ansible/modules/cloud/amazon/ec2_group.py
index 8620bc1d68..5b069c19a9 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_group.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_group.py
@@ -290,7 +290,7 @@ def main():
             '''found a match, delete it'''
             try:
                 group.delete()
-            except Exception, e:
+            except Exception as e:
                 module.fail_json(msg="Unable to delete security group '%s' - %s" % (group, e))
             else:
                 group = None
diff --git a/lib/ansible/modules/cloud/amazon/ec2_key.py b/lib/ansible/modules/cloud/amazon/ec2_key.py
index fc33257cf3..4a6c6424f8 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_key.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_key.py
@@ -153,7 +153,7 @@ def main():
                             time.sleep(1)
                         if not action_complete:
                             module.fail_json(msg="timed out while waiting for the key to be removed")
-                except Exception, e:
+                except Exception as e:
                     module.fail_json(msg="Unable to delete key pair '%s' - %s" % (key, e))
             key = None
             changed = True
diff --git a/lib/ansible/modules/cloud/amazon/ec2_lc.py b/lib/ansible/modules/cloud/amazon/ec2_lc.py
index 863c7ccf2c..f593e64c04 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_lc.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_lc.py
@@ -224,7 +224,7 @@ def create_launch_config(connection, module):
             connection.create_launch_configuration(lc)
             launch_configs = connection.get_all_launch_configurations(names=[name])
             changed = True
-        except BotoServerError, e:
+        except BotoServerError as e:
             module.fail_json(msg=str(e))
 
     result = dict(
@@ -303,7 +303,7 @@ def main():
 
     try:
         connection = connect_to_aws(boto.ec2.autoscale, region, **aws_connect_params)
-    except (boto.exception.NoAuthHandlerFound, AnsibleAWSError), e:
+    except (boto.exception.NoAuthHandlerFound, AnsibleAWSError) as e:
         module.fail_json(msg=str(e))
 
     state = module.params.get('state')
diff --git a/lib/ansible/modules/cloud/amazon/ec2_metric_alarm.py b/lib/ansible/modules/cloud/amazon/ec2_metric_alarm.py
index 960df28158..2781fe79da 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_metric_alarm.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_metric_alarm.py
@@ -163,7 +163,7 @@ def create_metric_alarm(connection, module):
             connection.create_alarm(alm)
             changed = True
             alarms = connection.describe_alarms(alarm_names=[name])
-        except BotoServerError, e:
+        except BotoServerError as e:
             module.fail_json(msg=str(e))
 
     else:
@@ -198,7 +198,7 @@ def create_metric_alarm(connection, module):
         try:
             if changed:
                 connection.create_alarm(alarm)
-        except BotoServerError, e:
+        except BotoServerError as e:
             module.fail_json(msg=str(e))
     result = alarms[0]
     module.exit_json(changed=changed, name=result.name,
@@ -230,7 +230,7 @@ def delete_metric_alarm(connection, module):
         try:
             connection.delete_alarms([name])
             module.exit_json(changed=True)
-        except BotoServerError, e:
+        except BotoServerError as e:
             module.fail_json(msg=str(e))
     else:
         module.exit_json(changed=False)
@@ -270,7 +270,7 @@ def main():
     if region:
         try:
             connection = connect_to_aws(boto.ec2.cloudwatch, region, **aws_connect_params)
-        except (boto.exception.NoAuthHandlerFound, AnsibleAWSError), e:
+        except (boto.exception.NoAuthHandlerFound, AnsibleAWSError) as e:
             module.fail_json(msg=str(e))
     else:
         module.fail_json(msg="region must be specified")
diff --git a/lib/ansible/modules/cloud/amazon/ec2_scaling_policy.py b/lib/ansible/modules/cloud/amazon/ec2_scaling_policy.py
index 8d3e472995..e2503446d3 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_scaling_policy.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_scaling_policy.py
@@ -104,7 +104,7 @@ def create_scaling_policy(connection, module):
             connection.create_scaling_policy(sp)
             policy = connection.get_all_policies(as_group=asg_name,policy_names=[sp_name])[0]
             module.exit_json(changed=True, name=policy.name, arn=policy.policy_arn, as_name=policy.as_name, scaling_adjustment=policy.scaling_adjustment, cooldown=policy.cooldown, adjustment_type=policy.adjustment_type, min_adjustment_step=policy.min_adjustment_step)
-        except BotoServerError, e:
+        except BotoServerError as e:
             module.fail_json(msg=str(e))
     else:
         policy = scalingPolicies[0]
@@ -131,7 +131,7 @@ def create_scaling_policy(connection, module):
                 connection.create_scaling_policy(policy)
                 policy = connection.get_all_policies(as_group=asg_name,policy_names=[sp_name])[0]
             module.exit_json(changed=changed, name=policy.name, arn=policy.policy_arn, as_name=policy.as_name, scaling_adjustment=policy.scaling_adjustment, cooldown=policy.cooldown, adjustment_type=policy.adjustment_type, min_adjustment_step=policy.min_adjustment_step)
-        except BotoServerError, e:
+        except BotoServerError as e:
             module.fail_json(msg=str(e))
 
 
@@ -145,7 +145,7 @@ def delete_scaling_policy(connection, module):
         try:
             connection.delete_policy(sp_name, asg_name)
             module.exit_json(changed=True)
-        except BotoServerError, e:
+        except BotoServerError as e:
             module.exit_json(changed=False, msg=str(e))
     else:
         module.exit_json(changed=False)
@@ -176,7 +176,7 @@ def main():
 
     try:
         connection = connect_to_aws(boto.ec2.autoscale, region, **aws_connect_params)
-    except (boto.exception.NoAuthHandlerFound, AnsibleAWSError), e:
+    except (boto.exception.NoAuthHandlerFound, AnsibleAWSError) as e:
         module.fail_json(msg = str(e))
 
     if state == 'present':
diff --git a/lib/ansible/modules/cloud/amazon/ec2_snapshot.py b/lib/ansible/modules/cloud/amazon/ec2_snapshot.py
index 7f0bfcee3c..ce52dec144 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_snapshot.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_snapshot.py
@@ -196,7 +196,7 @@ def create_snapshot(module, ec2, state=None, description=None, wait=None,
     if instance_id:
         try:
             volumes = ec2.get_all_volumes(filters={'attachment.instance-id': instance_id, 'attachment.device': device_name})
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             module.fail_json(msg = "%s: %s" % (e.error_code, e.error_message))
 
         if not volumes:
@@ -209,7 +209,7 @@ def create_snapshot(module, ec2, state=None, description=None, wait=None,
             module.fail_json(msg = 'snapshot_id must be set when state is absent')
         try:
             ec2.delete_snapshot(snapshot_id)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             # exception is raised if snapshot does not exist
             if e.error_code == 'InvalidSnapshot.NotFound':
                 module.exit_json(changed=False)
@@ -222,7 +222,7 @@ def create_snapshot(module, ec2, state=None, description=None, wait=None,
     if last_snapshot_min_age > 0:
         try:
             current_snapshots = ec2.get_all_snapshots(filters={'volume_id': volume_id})
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             module.fail_json(msg="%s: %s" % (e.error_code, e.error_message))
 
         last_snapshot_min_age = last_snapshot_min_age * 60 # Convert to seconds
@@ -239,7 +239,7 @@ def create_snapshot(module, ec2, state=None, description=None, wait=None,
         if snapshot_tags:
             for k, v in snapshot_tags.items():
                 snapshot.add_tag(k, v)
-    except boto.exception.BotoServerError, e:
+    except boto.exception.BotoServerError as e:
         module.fail_json(msg="%s: %s" % (e.error_code, e.error_message))
 
     module.exit_json(changed=changed,
diff --git a/lib/ansible/modules/cloud/amazon/ec2_vol.py b/lib/ansible/modules/cloud/amazon/ec2_vol.py
index 86801ddf68..31dae26dd1 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_vol.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_vol.py
@@ -262,7 +262,7 @@ def get_volume(module, ec2):
         volume_ids = [id]
     try:
         vols = ec2.get_all_volumes(volume_ids=volume_ids, filters=filters)
-    except boto.exception.BotoServerError, e:
+    except boto.exception.BotoServerError as e:
         module.fail_json(msg = "%s: %s" % (e.error_code, e.error_message))
 
     if not vols:
@@ -288,7 +288,7 @@ def get_volumes(module, ec2):
             vols = ec2.get_all_volumes()
         else:
             vols = ec2.get_all_volumes(filters={'attachment.instance-id': instance})
-    except boto.exception.BotoServerError, e:
+    except boto.exception.BotoServerError as e:
         module.fail_json(msg = "%s: %s" % (e.error_code, e.error_message))
     return vols
 
@@ -342,7 +342,7 @@ def create_volume(module, ec2, zone):
 
             if name:
                 ec2.create_tags([volume.id], {"Name": name})
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             module.fail_json(msg = "%s: %s" % (e.error_code, e.error_message))
 
     return volume, changed
@@ -367,7 +367,7 @@ def attach_volume(module, ec2, volume, instance):
                 device_name = '/dev/sdf'
             else:
                 device_name = '/dev/xvdf'
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             module.fail_json(msg = "%s: %s" % (e.error_code, e.error_message))
 
     if volume.attachment_state() is not None:
@@ -385,7 +385,7 @@ def attach_volume(module, ec2, volume, instance):
                 time.sleep(3)
                 volume.update()
             changed = True
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             module.fail_json(msg = "%s: %s" % (e.error_code, e.error_message))
 
         modify_dot_attribute(module, ec2, instance, device_name)
@@ -402,7 +402,7 @@ def modify_dot_attribute(module, ec2, instance, device_name):
     try:
         instance.update()
         dot = instance.block_device_mapping[device_name].delete_on_termination
-    except boto.exception.BotoServerError, e:
+    except boto.exception.BotoServerError as e:
         module.fail_json(msg = "%s: %s" % (e.error_code, e.error_message))
 
     if delete_on_termination != dot:
@@ -417,7 +417,7 @@ def modify_dot_attribute(module, ec2, instance, device_name):
                 time.sleep(3)
                 instance.update()
             changed = True
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             module.fail_json(msg = "%s: %s" % (e.error_code, e.error_message))
 
     return changed
@@ -522,7 +522,7 @@ def main():
     if region:
         try:
             ec2 = connect_to_aws(boto.ec2, region, **aws_connect_params)
-        except (boto.exception.NoAuthHandlerFound, AnsibleAWSError), e:
+        except (boto.exception.NoAuthHandlerFound, AnsibleAWSError) as e:
             module.fail_json(msg=str(e))
     else:
         module.fail_json(msg="region must be specified")
diff --git a/lib/ansible/modules/cloud/amazon/ec2_vpc.py b/lib/ansible/modules/cloud/amazon/ec2_vpc.py
index 61c4a4ed5a..58fbaf177a 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_vpc.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_vpc.py
@@ -360,7 +360,7 @@ def create_vpc(module, vpc_conn):
                             pending = False
                 # sometimes vpc_conn.create_vpc() will return a vpc that can't be found yet by vpc_conn.get_all_vpcs()
                 # when that happens, just wait a bit longer and try again
-                except boto.exception.BotoServerError, e:
+                except boto.exception.BotoServerError as e:
                     if e.error_code != 'InvalidVpcID.NotFound':
                         raise
                 if pending:
@@ -369,7 +369,7 @@ def create_vpc(module, vpc_conn):
                 # waiting took too long
                 module.fail_json(msg = "wait for vpc availability timeout on %s" % time.asctime())
 
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             module.fail_json(msg = "%s: %s" % (e.error_code, e.error_message))
 
     # Done with base VPC, now change to attributes and features.
@@ -427,7 +427,7 @@ def create_vpc(module, vpc_conn):
                             subnet_tags_delete = [key[0] for key in subnet_tags_delete]
                             delete_subnet_tag = vpc_conn.delete_tags(csn.id, subnet_tags_delete)
                             changed = True
-                        except EC2ResponseError, e:
+                        except EC2ResponseError as e:
                             module.fail_json(msg='Unable to delete resource tag, error {0}'.format(e))
                     # Add new subnet tags if not current
 
@@ -436,7 +436,7 @@ def create_vpc(module, vpc_conn):
                             changed = True
                             create_subnet_tag = vpc_conn.create_tags(csn.id, new_subnet_tags)
 
-                        except EC2ResponseError, e:
+                        except EC2ResponseError as e:
                             module.fail_json(msg='Unable to create resource tag, error: {0}'.format(e))
 
             if add_subnet:
@@ -454,7 +454,7 @@ def create_vpc(module, vpc_conn):
                         vpc_conn.create_tags(new_subnet.id, new_subnet_tags)
 
                     changed = True
-                except EC2ResponseError, e:
+                except EC2ResponseError as e:
                     module.fail_json(msg='Unable to create subnet {0}, error: {1}'.format(subnet['cidr'], e))
 
         # Now delete all absent subnets
@@ -467,7 +467,7 @@ def create_vpc(module, vpc_conn):
                 try:
                     vpc_conn.delete_subnet(csubnet.id)
                     changed = True
-                except EC2ResponseError, e:
+                except EC2ResponseError as e:
                     module.fail_json(msg='Unable to delete subnet {0}, error: {1}'.format(csubnet.cidr_block, e))
 
     # Handle Internet gateway (create/delete igw)
@@ -481,7 +481,7 @@ def create_vpc(module, vpc_conn):
                 igw = vpc_conn.create_internet_gateway()
                 vpc_conn.attach_internet_gateway(igw.id, vpc.id)
                 changed = True
-            except EC2ResponseError, e:
+            except EC2ResponseError as e:
                 module.fail_json(msg='Unable to create Internet Gateway, error: {0}'.format(e))
         else:
             # Set igw variable to the current igw instance for use in route tables.
@@ -492,7 +492,7 @@ def create_vpc(module, vpc_conn):
                 vpc_conn.detach_internet_gateway(igws[0].id, vpc.id)
                 vpc_conn.delete_internet_gateway(igws[0].id)
                 changed = True
-            except EC2ResponseError, e:
+            except EC2ResponseError as e:
                 module.fail_json(msg='Unable to delete Internet Gateway, error: {0}'.format(e))
 
     # Handle route tables - this may be worth splitting into a
@@ -565,7 +565,7 @@ def create_vpc(module, vpc_conn):
 
                 all_route_tables.append(new_rt)
                 changed = True
-            except EC2ResponseError, e:
+            except EC2ResponseError as e:
                 module.fail_json(
                     msg='Unable to create and associate route table {0}, error: ' \
                     '{1}'.format(rt, e)
@@ -594,7 +594,7 @@ def create_vpc(module, vpc_conn):
                     if not is_main:
                         vpc_conn.delete_route_table(rt.id)
                         changed = True
-                except EC2ResponseError, e:
+                except EC2ResponseError as e:
                     module.fail_json(msg='Unable to delete old route table {0}, error: {1}'.format(rt.id, e))
 
     vpc_dict = get_vpc_info(vpc)
@@ -671,7 +671,7 @@ def terminate_vpc(module, vpc_conn, vpc_id=None, cidr=None):
                         vpc_conn.delete_route_table(rt.id)
 
                 vpc_conn.delete_vpc(vpc.id)
-            except EC2ResponseError, e:
+            except EC2ResponseError as e:
                 module.fail_json(
                     msg='Unable to delete VPC {0}, error: {1}'.format(vpc.id, e)
                 )
@@ -714,7 +714,7 @@ def main():
     if region:
         try:
             vpc_conn = connect_to_aws(boto.vpc, region, **aws_connect_kwargs)
-        except boto.exception.NoAuthHandlerFound, e:
+        except boto.exception.NoAuthHandlerFound as e:
             module.fail_json(msg = str(e))
     else:
         module.fail_json(msg="region must be specified")
diff --git a/lib/ansible/modules/cloud/amazon/ec2_vpc_net.py b/lib/ansible/modules/cloud/amazon/ec2_vpc_net.py
index e36de13a05..a6563feb5a 100644
--- a/lib/ansible/modules/cloud/amazon/ec2_vpc_net.py
+++ b/lib/ansible/modules/cloud/amazon/ec2_vpc_net.py
@@ -120,7 +120,7 @@ def vpc_exists(module, vpc, name, cidr_block, multi):
 
     try:
         matching_vpcs=vpc.get_all_vpcs(filters={'tag:Name' : name, 'cidr-block' : cidr_block})
-    except Exception, e:
+    except Exception as e:
         e_msg=boto_exception(e)
         module.fail_json(msg=e_msg)
 
@@ -148,7 +148,7 @@ def update_vpc_tags(vpc, module, vpc_obj, tags, name):
             return True
         else:
             return False
-    except Exception, e:
+    except Exception as e:
         e_msg=boto_exception(e)
         module.fail_json(msg=e_msg)
 
@@ -214,7 +214,7 @@ def main():
     if region:
         try:
             connection = connect_to_aws(boto.vpc, region, **aws_connect_params)
-        except (boto.exception.NoAuthHandlerFound, AnsibleAWSError), e:
+        except (boto.exception.NoAuthHandlerFound, AnsibleAWSError) as e:
             module.fail_json(msg=str(e))
     else:
         module.fail_json(msg="region must be specified")
@@ -231,21 +231,21 @@ def main():
             try:
                 vpc_obj = connection.create_vpc(cidr_block, instance_tenancy=tenancy)
                 changed = True
-            except BotoServerError, e:
+            except BotoServerError as e:
                 module.fail_json(msg=e)
 
         if dhcp_id is not None:
             try:
                 if update_dhcp_opts(connection, module, vpc_obj, dhcp_id):
                     changed = True
-            except BotoServerError, e:
+            except BotoServerError as e:
                 module.fail_json(msg=e)
 
         if tags is not None or name is not None:
             try:
                 if update_vpc_tags(connection, module, vpc_obj, tags, name):
                     changed = True
-            except BotoServerError, e:
+            except BotoServerError as e:
                 module.fail_json(msg=e)
 
         # Note: Boto currently doesn't currently provide an interface to ec2-describe-vpc-attribute
@@ -254,14 +254,14 @@ def main():
         try:
             connection.modify_vpc_attribute(vpc_obj.id, enable_dns_support=dns_support)
             connection.modify_vpc_attribute(vpc_obj.id, enable_dns_hostnames=dns_hostnames)
-        except BotoServerError, e:
+        except BotoServerError as e:
             e_msg=boto_exception(e)
             module.fail_json(msg=e_msg)
 
         # get the vpc obj again in case it has changed
         try:
             vpc_obj = connection.get_all_vpcs(vpc_obj.id)[0]
-        except BotoServerError, e:
+        except BotoServerError as e:
             e_msg=boto_exception(e)
             module.fail_json(msg=e_msg)
 
@@ -277,7 +277,7 @@ def main():
                 connection.delete_vpc(vpc_obj.id)
                 vpc_obj = None
                 changed = True
-            except BotoServerError, e:
+            except BotoServerError as e:
                 e_msg = boto_exception(e)
                 module.fail_json(msg="%s. You may want to use the ec2_vpc_subnet, ec2_vpc_igw, "
                 "and/or ec2_vpc_route_table modules to ensure the other components are absent." % e_msg)
diff --git a/lib/ansible/modules/cloud/amazon/elasticache.py b/lib/ansible/modules/cloud/amazon/elasticache.py
index 08b6b6eebc..70a397d445 100644
--- a/lib/ansible/modules/cloud/amazon/elasticache.py
+++ b/lib/ansible/modules/cloud/amazon/elasticache.py
@@ -229,7 +229,7 @@ class ElastiCacheManager(object):
                                                       cache_subnet_group_name=self.cache_subnet_group,
                                                       preferred_availability_zone=self.zone,
                                                       port=self.cache_port)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             self.module.fail_json(msg=e.message)
 
         self._refresh_data()
@@ -256,7 +256,7 @@ class ElastiCacheManager(object):
 
         try:
             response = self.conn.delete_cache_cluster(cache_cluster_id=self.name)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             self.module.fail_json(msg=e.message)
         cache_cluster_data = response['DeleteCacheClusterResponse']['DeleteCacheClusterResult']['CacheCluster']
         self._refresh_data(cache_cluster_data)
@@ -305,7 +305,7 @@ class ElastiCacheManager(object):
                                                   security_group_ids=self.security_group_ids,
                                                   apply_immediately=True,
                                                   engine_version=self.cache_engine_version)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             self.module.fail_json(msg=e.message)
 
         self._refresh_data()
@@ -333,7 +333,7 @@ class ElastiCacheManager(object):
         try:
             response = self.conn.reboot_cache_cluster(cache_cluster_id=self.name,
                                                       cache_node_ids_to_reboot=cache_node_ids)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             self.module.fail_json(msg=e.message)
 
         self._refresh_data()
@@ -432,7 +432,7 @@ class ElastiCacheManager(object):
                 region=connect_region,
                 **self.aws_connect_kwargs
             )
-        except boto.exception.NoAuthHandlerFound, e:
+        except boto.exception.NoAuthHandlerFound as e:
             self.module.fail_json(msg=e.message)
 
     def _get_port(self):
diff --git a/lib/ansible/modules/cloud/amazon/elasticache_subnet_group.py b/lib/ansible/modules/cloud/amazon/elasticache_subnet_group.py
index 5956fa37e8..d740c4f3e7 100644
--- a/lib/ansible/modules/cloud/amazon/elasticache_subnet_group.py
+++ b/lib/ansible/modules/cloud/amazon/elasticache_subnet_group.py
@@ -122,7 +122,7 @@ def main():
         endpoint = "elasticache.%s.amazonaws.com" % region
         connect_region = RegionInfo(name=region, endpoint=endpoint)
         conn = ElastiCacheConnection(region=connect_region, **aws_connect_kwargs)
-    except boto.exception.NoAuthHandlerFound, e:
+    except boto.exception.NoAuthHandlerFound as e:
         module.fail_json(msg=e.message)
 
     try:
@@ -132,7 +132,7 @@ def main():
         try:
             matching_groups = conn.describe_cache_subnet_groups(group_name, max_records=100)
             exists = len(matching_groups) > 0
-        except BotoServerError, e:
+        except BotoServerError as e:
             if e.error_code != 'CacheSubnetGroupNotFoundFault':
                 module.fail_json(msg = e.error_message)
 
@@ -148,7 +148,7 @@ def main():
                 changed_group = conn.modify_cache_subnet_group(group_name, cache_subnet_group_description=group_description, subnet_ids=group_subnets)
                 changed = True
 
-    except BotoServerError, e:
+    except BotoServerError as e:
         if e.error_message != 'No modifications were requested.':
             module.fail_json(msg = e.error_message)
         else:
diff --git a/lib/ansible/modules/cloud/amazon/iam.py b/lib/ansible/modules/cloud/amazon/iam.py
index e5d06682b6..9276615230 100644
--- a/lib/ansible/modules/cloud/amazon/iam.py
+++ b/lib/ansible/modules/cloud/amazon/iam.py
@@ -177,7 +177,7 @@ def create_user(module, iam, name, pwd, path, key_state, key_count):
                     key_qty += 1
         else:
             keys = None
-    except boto.exception.BotoServerError, err:
+    except boto.exception.BotoServerError as err:
         module.fail_json(changed=False, msg=str(err))
     else:
         user_info = dict(created_user=user_meta, password=pwd, access_keys=keys)
@@ -193,7 +193,7 @@ def delete_user(module, iam, name):
             iam.delete_access_key(key, name)
         try:
             login_profile = iam.get_login_profiles(name).get_login_profile_response
-        except boto.exception.BotoServerError, err:
+        except boto.exception.BotoServerError as err:
             error_msg = boto_exception(err)
             if ('Cannot find Login Profile') in error_msg:
                del_meta = iam.delete_user(name).delete_user_response
@@ -207,7 +207,7 @@ def delete_user(module, iam, name):
                 iam.delete_user_policy(name, policy)
             try:
                 del_meta = iam.delete_user(name)
-            except boto.exception.BotoServerError, err:
+            except boto.exception.BotoServerError as err:
                 error_msg = boto_exception(err)
                 if ('must detach all policies first') in error_msg:
                       module.fail_json(changed=changed, msg="All inline polices have been removed. Though it appears"
@@ -236,7 +236,7 @@ def update_user(module, iam, name, new_name, new_path, key_state, key_count, key
             [ck['status'] for ck in
                 iam.get_all_access_keys(name).list_access_keys_result.access_key_metadata]
         key_qty = len(current_keys)
-    except boto.exception.BotoServerError, err:
+    except boto.exception.BotoServerError as err:
         error_msg = boto_exception(err)
         if 'cannot be found' in error_msg and updated:
             current_keys, status = \
@@ -263,7 +263,7 @@ def update_user(module, iam, name, new_name, new_path, key_state, key_count, key
                         name, new_path=new_path).update_user_response.response_metadata
                 user['updates'] = dict(
                     old_username=name, new_username=new_name, old_path=c_path, new_path=new_path)
-            except boto.exception.BotoServerError, err:
+            except boto.exception.BotoServerError as err:
                 error_msg = boto_exception(err)
                 module.fail_json(changed=False, msg=str(err))
             else:
@@ -278,7 +278,7 @@ def update_user(module, iam, name, new_name, new_path, key_state, key_count, key
             try:
                 iam.create_login_profile(name, pwd)
                 changed = True
-            except boto.exception.BotoServerError, err:
+            except boto.exception.BotoServerError as err:
                 error_msg = boto_exception(str(err))
                 if 'Password does not conform to the account password policy' in error_msg:
                     module.fail_json(changed=False, msg="Passsword doesn't conform to policy")
@@ -293,7 +293,7 @@ def update_user(module, iam, name, new_name, new_path, key_state, key_count, key
                 key_qty += 1
                 changed = True
 
-        except boto.exception.BotoServerError, err:
+        except boto.exception.BotoServerError as err:
             module.fail_json(changed=False, msg=str(err))
 
     if keys and key_state:
@@ -304,7 +304,7 @@ def update_user(module, iam, name, new_name, new_path, key_state, key_count, key
                         try:
                             iam.update_access_key(
                                 access_key, key_state.capitalize(), user_name=name)
-                        except boto.exception.BotoServerError, err:
+                        except boto.exception.BotoServerError as err:
                             module.fail_json(changed=False, msg=str(err))
                         else:
                             changed = True
@@ -312,7 +312,7 @@ def update_user(module, iam, name, new_name, new_path, key_state, key_count, key
                 if key_state == 'remove':
                     try:
                         iam.delete_access_key(access_key, user_name=name)
-                    except boto.exception.BotoServerError, err:
+                    except boto.exception.BotoServerError as err:
                         module.fail_json(changed=False, msg=str(err))
                     else:
                         changed = True
@@ -327,7 +327,7 @@ def update_user(module, iam, name, new_name, new_path, key_state, key_count, key
                 iam.get_all_access_keys(name).
                 list_access_keys_result.
                 access_key_metadata]
-    except boto.exception.BotoServerError, err:
+    except boto.exception.BotoServerError as err:
         module.fail_json(changed=changed, msg=str(err))
 
     for fk, fks in zip(final_keys, final_key_status):
@@ -353,7 +353,7 @@ new_name=None):
             rg for rg in frozenset(orig_users_groups).difference(groups)]
         new_groups = [
             ng for ng in frozenset(groups).difference(orig_users_groups)]
-    except boto.exception.BotoServerError, err:
+    except boto.exception.BotoServerError as err:
         module.fail_json(changed=changed, msg=str(err))
     else:
         if len(orig_users_groups) > 0:
@@ -365,7 +365,7 @@ new_name=None):
             for group in groups:
                 try:
                     iam.add_user_to_group(group, name)
-                except boto.exception.BotoServerError, err:
+                except boto.exception.BotoServerError as err:
                     error_msg = boto_exception(err)
                     if ('The group with name %s cannot be found.' % group) in error_msg:
                         module.fail_json(changed=False, msg="Group %s doesn't exist" % group)
@@ -382,7 +382,7 @@ def create_group(module=None, iam=None, name=None, path=None):
     try:
         iam.create_group(
             name, path).create_group_response.create_group_result.group
-    except boto.exception.BotoServerError, err:
+    except boto.exception.BotoServerError as err:
         module.fail_json(changed=changed, msg=str(err))
     else:
         changed = True
@@ -393,14 +393,14 @@ def delete_group(module=None, iam=None, name=None):
     changed = False
     try:
         iam.delete_group(name)
-    except boto.exception.BotoServerError, err:
+    except boto.exception.BotoServerError as err:
         error_msg = boto_exception(err)
         if ('must detach all policies first') in error_msg:
             for policy in iam.get_all_group_policies(name).list_group_policies_result.policy_names:
                 iam.delete_group_policy(name, policy)
             try:
                 iam.delete_group(name)
-            except boto.exception.BotoServerError, err:
+            except boto.exception.BotoServerError as  err:
                 error_msg = boto_exception(err)
                 if ('must detach all policies first') in error_msg:
                       module.fail_json(changed=changed, msg="All inline polices have been removed. Though it appears"
@@ -429,7 +429,7 @@ def update_group(module=None, iam=None, name=None, new_name=None, new_path=None)
                 iam.update_group(name, new_group_name=new_name, new_path=new_path)
                 changed = True
                 name = new_name
-    except boto.exception.BotoServerError, err:
+    except boto.exception.BotoServerError as err:
         module.fail_json(changed=changed, msg=str(err))
 
     return changed, name, new_path, current_group_path
@@ -449,7 +449,7 @@ def create_role(module, iam, name, path, role_list, prof_list):
                 instance_profile_result = iam.create_instance_profile(name, 
                     path=path).create_instance_profile_response.create_instance_profile_result.instance_profile
                 iam.add_role_to_instance_profile(name, name)
-    except boto.exception.BotoServerError, err:
+    except boto.exception.BotoServerError as err:
         module.fail_json(changed=changed, msg=str(err))
     else:
         updated_role_list = [rl['role_name'] for rl in iam.list_roles().list_roles_response.
@@ -472,14 +472,14 @@ def delete_role(module, iam, name, role_list, prof_list):
                 iam.remove_role_from_instance_profile(profile, name)
             try:
               iam.delete_role(name)
-            except boto.exception.BotoServerError, err:
+            except boto.exception.BotoServerError as err:
               error_msg = boto_exception(err)
               if ('must detach all policies first') in error_msg:
                 for policy in iam.list_role_policies(name).list_role_policies_result.policy_names:
                   iam.delete_role_policy(name, policy)
               try:
                 iam_role_result = iam.delete_role(name)
-              except boto.exception.BotoServerError, err:
+              except boto.exception.BotoServerError as err:
                   error_msg = boto_exception(err)
                   if ('must detach all policies first') in error_msg:
                       module.fail_json(changed=changed, msg="All inline polices have been removed. Though it appears"
@@ -497,7 +497,7 @@ def delete_role(module, iam, name, role_list, prof_list):
         for prof in prof_list:
             if name == prof:
                 instance_profile_result = iam.delete_instance_profile(name)
-    except boto.exception.BotoServerError, err:
+    except boto.exception.BotoServerError as err:
         module.fail_json(changed=changed, msg=str(err))
     else:
         updated_role_list = [rl['role_name'] for rl in iam.list_roles().list_roles_response.
@@ -577,7 +577,7 @@ def main():
             iam = connect_to_aws(boto.iam, region, **aws_connect_kwargs)
         else:
             iam = boto.iam.connection.IAMConnection(**aws_connect_kwargs)
-    except boto.exception.NoAuthHandlerFound, e:
+    except boto.exception.NoAuthHandlerFound as e:
         module.fail_json(msg=str(e))
 
     result = {}
@@ -600,7 +600,7 @@ def main():
                 list_instance_profiles_response.
                 list_instance_profiles_result.
                 instance_profiles]
-    except boto.exception.BotoServerError, err:
+    except boto.exception.BotoServerError as err:
         module.fail_json(msg=err.message)
 
     if iam_type == 'user':
diff --git a/lib/ansible/modules/cloud/amazon/iam_cert.py b/lib/ansible/modules/cloud/amazon/iam_cert.py
index 827b1fa044..ce2209eae5 100644
--- a/lib/ansible/modules/cloud/amazon/iam_cert.py
+++ b/lib/ansible/modules/cloud/amazon/iam_cert.py
@@ -249,7 +249,7 @@ def main():
             iam = connect_to_aws(boto.iam, region, **aws_connect_kwargs)
         else:
             iam = boto.iam.connection.IAMConnection(**aws_connect_kwargs)
-    except boto.exception.NoAuthHandlerFound, e:
+    except boto.exception.NoAuthHandlerFound as e:
         module.fail_json(msg=str(e))
 
     state = module.params.get('state')
@@ -284,7 +284,7 @@ def main():
     try:
         cert_action(module, iam, name, path, new_name, new_path, state,
                 cert, key, cert_chain, orig_certs, orig_bodies, dup_ok)
-    except boto.exception.BotoServerError, err:
+    except boto.exception.BotoServerError as err:
         module.fail_json(changed=changed, msg=str(err), debug=[cert,key])
 
 
diff --git a/lib/ansible/modules/cloud/amazon/iam_policy.py b/lib/ansible/modules/cloud/amazon/iam_policy.py
index df18c7ca36..572e5eca93 100644
--- a/lib/ansible/modules/cloud/amazon/iam_policy.py
+++ b/lib/ansible/modules/cloud/amazon/iam_policy.py
@@ -158,7 +158,7 @@ def user_action(module, iam, name, policy_name, skip, pdoc, state):
       try:
         iam.delete_user_policy(name, policy_name)
         changed = True
-      except boto.exception.BotoServerError, err:
+      except boto.exception.BotoServerError as err:
         error_msg = boto_exception(err)
         if 'cannot be found.' in error_msg:
           changed = False
@@ -167,7 +167,7 @@ def user_action(module, iam, name, policy_name, skip, pdoc, state):
     updated_policies = [cp for cp in iam.get_all_user_policies(name).
                                         list_user_policies_result.
                                         policy_names]
-  except boto.exception.BotoServerError, err:
+  except boto.exception.BotoServerError as err:
     error_msg = boto_exception(err)
     module.fail_json(changed=changed, msg=error_msg)
 
@@ -207,7 +207,7 @@ def role_action(module, iam, name, policy_name, skip, pdoc, state):
       try:
         iam.delete_role_policy(name, policy_name)
         changed = True
-      except boto.exception.BotoServerError, err:
+      except boto.exception.BotoServerError as err:
         error_msg = boto_exception(err)
         if 'cannot be found.' in error_msg:
           changed = False
@@ -219,7 +219,7 @@ def role_action(module, iam, name, policy_name, skip, pdoc, state):
     updated_policies = [cp for cp in iam.list_role_policies(name).
                                         list_role_policies_result.
                                         policy_names]
-  except boto.exception.BotoServerError, err:
+  except boto.exception.BotoServerError as err:
     error_msg = boto_exception(err)
     module.fail_json(changed=changed, msg=error_msg)
 
@@ -252,7 +252,7 @@ def group_action(module, iam, name, policy_name, skip, pdoc, state):
       try:
         iam.delete_group_policy(name, policy_name)
         changed = True
-      except boto.exception.BotoServerError, err:
+      except boto.exception.BotoServerError as err:
         error_msg = boto_exception(err)
         if 'cannot be found.' in error_msg:
           changed = False
@@ -262,7 +262,7 @@ def group_action(module, iam, name, policy_name, skip, pdoc, state):
     updated_policies = [cp for cp in iam.get_all_group_policies(name).
                                         list_group_policies_result.
                                         policy_names]
-  except boto.exception.BotoServerError, err:
+  except boto.exception.BotoServerError as err:
     error_msg = boto_exception(err)
     module.fail_json(changed=changed, msg=error_msg)
 
@@ -322,7 +322,7 @@ def main():
         iam = connect_to_aws(boto.iam, region, **aws_connect_kwargs)
     else:
         iam = boto.iam.connection.IAMConnection(**aws_connect_kwargs)
-  except boto.exception.NoAuthHandlerFound, e:
+  except boto.exception.NoAuthHandlerFound as e:
       module.fail_json(msg=str(e))
 
   changed = False
diff --git a/lib/ansible/modules/cloud/amazon/rds.py b/lib/ansible/modules/cloud/amazon/rds.py
index 2e2e646cac..a12c9cedb6 100755
--- a/lib/ansible/modules/cloud/amazon/rds.py
+++ b/lib/ansible/modules/cloud/amazon/rds.py
@@ -344,19 +344,19 @@ class RDSConnection:
     def __init__(self, module, region, **aws_connect_params):
         try:
             self.connection  = connect_to_aws(boto.rds, region, **aws_connect_params)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
              module.fail_json(msg=e.error_message)
 
     def get_db_instance(self, instancename):
         try:
             return RDSDBInstance(self.connection.get_all_dbinstances(instancename)[0])
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             return None
 
     def get_db_snapshot(self, snapshotid):
         try:
             return RDSSnapshot(self.connection.get_all_dbsnapshots(snapshot_id=snapshotid)[0])
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             return None
 
     def create_db_instance(self, instance_name, size, instance_class, db_engine,
@@ -366,63 +366,63 @@ class RDSConnection:
             result = self.connection.create_dbinstance(instance_name, size, instance_class,
                     username, password, **params)
             return RDSDBInstance(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
     def create_db_instance_read_replica(self, instance_name, source_instance, **params):
         try:
             result = self.connection.createdb_instance_read_replica(instance_name, source_instance, **params)
             return RDSDBInstance(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
     def delete_db_instance(self, instance_name, **params):
         try:
             result = self.connection.delete_dbinstance(instance_name, **params)
             return RDSDBInstance(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
     def delete_db_snapshot(self, snapshot):
         try:
             result = self.connection.delete_dbsnapshot(snapshot)
             return RDSSnapshot(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
     def modify_db_instance(self, instance_name, **params):
         try:
             result = self.connection.modify_dbinstance(instance_name, **params)
             return RDSDBInstance(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
     def reboot_db_instance(self, instance_name, **params):
         try:
             result = self.connection.reboot_dbinstance(instance_name)
             return RDSDBInstance(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
     def restore_db_instance_from_db_snapshot(self, instance_name, snapshot, instance_type, **params):
         try:
             result = self.connection.restore_dbinstance_from_dbsnapshot(snapshot, instance_name, instance_type, **params)
             return RDSDBInstance(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
     def create_db_snapshot(self, snapshot, instance_name, **params):
         try:
             result = self.connection.create_dbsnapshot(snapshot, instance_name)
             return RDSSnapshot(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
     def promote_read_replica(self, instance_name, **params):
         try:
             result = self.connection.promote_read_replica(instance_name, **params)
             return RDSDBInstance(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
 
@@ -430,7 +430,7 @@ class RDS2Connection:
     def __init__(self, module, region, **aws_connect_params):
         try:
             self.connection  = connect_to_aws(boto.rds2, region, **aws_connect_params)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
              module.fail_json(msg=e.error_message)
 
     def get_db_instance(self, instancename):
@@ -438,9 +438,9 @@ class RDS2Connection:
             dbinstances = self.connection.describe_db_instances(db_instance_identifier=instancename)['DescribeDBInstancesResponse']['DescribeDBInstancesResult']['DBInstances']
             result =  RDS2DBInstance(dbinstances[0])
             return result
-        except boto.rds2.exceptions.DBInstanceNotFound, e:
+        except boto.rds2.exceptions.DBInstanceNotFound as e:
             return None
-        except Exception, e:
+        except Exception as e:
             raise e
 
     def get_db_snapshot(self, snapshotid):
@@ -448,7 +448,7 @@ class RDS2Connection:
             snapshots = self.connection.describe_db_snapshots(db_snapshot_identifier=snapshotid, snapshot_type='manual')['DescribeDBSnapshotsResponse']['DescribeDBSnapshotsResult']['DBSnapshots']
             result = RDS2Snapshot(snapshots[0])
             return result
-        except boto.rds2.exceptions.DBSnapshotNotFound, e:
+        except boto.rds2.exceptions.DBSnapshotNotFound as e:
             return None
 
     def create_db_instance(self, instance_name, size, instance_class, db_engine,
@@ -457,63 +457,63 @@ class RDS2Connection:
             result = self.connection.create_db_instance(instance_name, size, instance_class,
                 db_engine, username, password, **params)['CreateDBInstanceResponse']['CreateDBInstanceResult']['DBInstance']
             return RDS2DBInstance(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
     def create_db_instance_read_replica(self, instance_name, source_instance, **params):
         try:
             result = self.connection.create_db_instance_read_replica(instance_name, source_instance, **params)['CreateDBInstanceReadReplicaResponse']['CreateDBInstanceReadReplicaResult']['DBInstance']
             return RDS2DBInstance(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
     def delete_db_instance(self, instance_name, **params):
         try:
             result = self.connection.delete_db_instance(instance_name, **params)['DeleteDBInstanceResponse']['DeleteDBInstanceResult']['DBInstance']
             return RDS2DBInstance(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
     def delete_db_snapshot(self, snapshot):
         try:
             result = self.connection.delete_db_snapshot(snapshot)['DeleteDBSnapshotResponse']['DeleteDBSnapshotResult']['DBSnapshot']
             return RDS2Snapshot(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
     def modify_db_instance(self, instance_name, **params):
         try:
             result = self.connection.modify_db_instance(instance_name, **params)['ModifyDBInstanceResponse']['ModifyDBInstanceResult']['DBInstance']
             return RDS2DBInstance(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
     def reboot_db_instance(self, instance_name, **params):
         try:
             result = self.connection.reboot_db_instance(instance_name, **params)['RebootDBInstanceResponse']['RebootDBInstanceResult']['DBInstance']
             return RDS2DBInstance(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
     def restore_db_instance_from_db_snapshot(self, instance_name, snapshot, instance_type, **params):
         try:
             result = self.connection.restore_db_instance_from_db_snapshot(instance_name, snapshot, **params)['RestoreDBInstanceFromDBSnapshotResponse']['RestoreDBInstanceFromDBSnapshotResult']['DBInstance']
             return RDS2DBInstance(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
     def create_db_snapshot(self, snapshot, instance_name, **params):
         try:
             result = self.connection.create_db_snapshot(snapshot, instance_name, **params)['CreateDBSnapshotResponse']['CreateDBSnapshotResult']['DBSnapshot']
             return RDS2Snapshot(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
     def promote_read_replica(self, instance_name, **params):
         try:
             result = self.connection.promote_read_replica(instance_name, **params)['PromoteReadReplicaResponse']['PromoteReadReplicaResult']['DBInstance']
             return RDS2DBInstance(result)
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             raise RDSException(e)
 
 
@@ -554,7 +554,7 @@ class RDSDBInstance:
         # ReadReplicaSourceDBInstanceIdentifier may or may not exist
         try:
             d["replication_source"] = self.instance.ReadReplicaSourceDBInstanceIdentifier
-        except Exception, e:
+        except Exception as e:
             d["replication_source"] = None
         return d
 
@@ -689,7 +689,7 @@ def create_db_instance(module, conn):
                     module.params.get('instance_type'), module.params.get('db_engine'),
                     module.params.get('username'), module.params.get('password'), **params)
             changed = True
-        except RDSException, e:
+        except RDSException as e:
             module.fail_json(msg="Failed to create instance: %s" % e.message)
 
     if module.params.get('wait'):
@@ -716,7 +716,7 @@ def replicate_db_instance(module, conn):
         try:
             result = conn.create_db_instance_read_replica(instance_name, source_instance, **params)
             changed = True
-        except RDSException, e:
+        except RDSException as e:
             module.fail_json(msg="Failed to create replica instance: %s " % e.message)
 
     if module.params.get('wait'):
@@ -755,7 +755,7 @@ def delete_db_instance_or_snapshot(module, conn):
             result = conn.delete_db_instance(instance_name, **params)
         else:
             result = conn.delete_db_snapshot(snapshot)
-    except RDSException, e:
+    except RDSException as e:
         module.fail_json(msg="Failed to delete instance: %s" % e.message)
 
     # If we're not waiting for a delete to complete then we're all done
@@ -765,12 +765,12 @@ def delete_db_instance_or_snapshot(module, conn):
     try:
         resource = await_resource(conn, result, 'deleted', module)
         module.exit_json(changed=True)
-    except RDSException, e:
+    except RDSException as e:
         if e.code == 'DBInstanceNotFound':
             module.exit_json(changed=True)
         else:
             module.fail_json(msg=e.message)
-    except Exception, e:
+    except Exception as e:
         module.fail_json(msg=str(e))
 
 
@@ -808,7 +808,7 @@ def modify_db_instance(module, conn):
 
     try:
         result = conn.modify_db_instance(instance_name, **params)
-    except RDSException, e:
+    except RDSException as e:
         module.fail_json(msg=e.message)
     if params.get('apply_immediately'):
         if new_instance_name:
@@ -846,7 +846,7 @@ def promote_db_instance(module, conn):
         try:
             result = conn.promote_read_replica(instance_name, **params)
             changed = True
-        except RDSException, e:
+        except RDSException as e:
             module.fail_json(msg=e.message)
     else:
         changed = False
@@ -871,7 +871,7 @@ def snapshot_db_instance(module, conn):
         try:
             result = conn.create_db_snapshot(snapshot, instance_name, **params)
             changed = True
-        except RDSException, e:
+        except RDSException as e:
             module.fail_json(msg=e.message)
 
     if module.params.get('wait'):
@@ -896,7 +896,7 @@ def reboot_db_instance(module, conn):
     try:
         result = conn.reboot_db_instance(instance_name, **params)
         changed = True
-    except RDSException, e:
+    except RDSException as e:
         module.fail_json(msg=e.message)
 
     if module.params.get('wait'):
@@ -927,7 +927,7 @@ def restore_db_instance(module, conn):
         try:
             result = conn.restore_db_instance_from_db_snapshot(instance_name, snapshot, instance_type, **params)
             changed = True
-        except RDSException, e:
+        except RDSException as e:
             module.fail_json(msg=e.message)
 
     if module.params.get('wait'):
diff --git a/lib/ansible/modules/cloud/amazon/rds_param_group.py b/lib/ansible/modules/cloud/amazon/rds_param_group.py
index 2992d8d979..a421eb1679 100644
--- a/lib/ansible/modules/cloud/amazon/rds_param_group.py
+++ b/lib/ansible/modules/cloud/amazon/rds_param_group.py
@@ -247,7 +247,7 @@ def main():
 
     try:
         conn = connect_to_aws(boto.rds, region, **aws_connect_kwargs)
-    except boto.exception.BotoServerError, e:
+    except boto.exception.BotoServerError as e:
         module.fail_json(msg = e.error_message)
 
     group_was_added = False
@@ -258,7 +258,7 @@ def main():
         try:
             all_groups = conn.get_all_dbparameter_groups(group_name, max_records=100)
             exists = len(all_groups) > 0
-        except BotoServerError, e:
+        except BotoServerError as e:
             if e.error_code != 'DBParameterGroupNotFound':
                 module.fail_json(msg = e.error_message)
             exists = False
@@ -287,10 +287,10 @@ def main():
                 else:
                     break
 
-    except BotoServerError, e:
+    except BotoServerError as e:
         module.fail_json(msg = e.error_message)
 
-    except NotModifiableError, e:
+    except NotModifiableError as e:
         msg = e.error_message
         if group_was_added:
             msg = '%s The group "%s" was added first.' % (msg, group_name)
diff --git a/lib/ansible/modules/cloud/amazon/rds_subnet_group.py b/lib/ansible/modules/cloud/amazon/rds_subnet_group.py
index bc0655a652..52ca970fde 100644
--- a/lib/ansible/modules/cloud/amazon/rds_subnet_group.py
+++ b/lib/ansible/modules/cloud/amazon/rds_subnet_group.py
@@ -117,7 +117,7 @@ def main():
 
     try:
         conn = connect_to_aws(boto.rds, region, **aws_connect_kwargs)
-    except boto.exception.BotoServerError, e:
+    except boto.exception.BotoServerError as e:
         module.fail_json(msg = e.error_message)
 
     try:
@@ -127,7 +127,7 @@ def main():
         try:
             matching_groups = conn.get_all_db_subnet_groups(group_name, max_records=100)
             exists = len(matching_groups) > 0
-        except BotoServerError, e:
+        except BotoServerError as e:
             if e.error_code != 'DBSubnetGroupNotFoundFault':
                 module.fail_json(msg = e.error_message)
         
@@ -146,7 +146,7 @@ def main():
                 if ( (matching_groups[0].name != group_name) or (matching_groups[0].description != group_description) or (matching_groups[0].subnet_ids != group_subnets) ):
                     changed_group = conn.modify_db_subnet_group(group_name, description=group_description, subnet_ids=group_subnets)
                     changed = True
-    except BotoServerError, e:
+    except BotoServerError as e:
         module.fail_json(msg = e.error_message)
 
     module.exit_json(changed=changed)
diff --git a/lib/ansible/modules/cloud/amazon/route53.py b/lib/ansible/modules/cloud/amazon/route53.py
index 07920aa907..a8396d7e96 100644
--- a/lib/ansible/modules/cloud/amazon/route53.py
+++ b/lib/ansible/modules/cloud/amazon/route53.py
@@ -338,7 +338,7 @@ def commit(changes, retry_interval, wait, wait_timeout):
             retry -= 1
             result = changes.commit()
             break
-        except boto.route53.exception.DNSServerError, e:
+        except boto.route53.exception.DNSServerError as e:
             code = e.body.split("<Code>")[1]
             code = code.split("</Code>")[0]
             if code != 'PriorRequestNotComplete' or retry < 0:
@@ -366,7 +366,7 @@ def invoke_with_throttling_retries(function_ref, *argv):
         try:
             retval=function_ref(*argv)
             return retval
-        except boto.exception.BotoServerError, e:
+        except boto.exception.BotoServerError as e:
             if e.code != IGNORE_CODE or retries==MAX_RETRIES:
                 raise e
         time.sleep(5 * (2**retries))
@@ -470,7 +470,7 @@ def main():
     # connect to the route53 endpoint
     try:
         conn = Route53Connection(**aws_connect_kwargs)
-    except boto.exception.BotoServerError, e:
+    except boto.exception.BotoServerError as e:
         module.fail_json(msg = e.error_message)
 
     # Get all the existing hosted zones and save their ID's
@@ -574,7 +574,7 @@ def main():
 
     try:
         result = invoke_with_throttling_retries(commit, changes, retry_interval_in, wait_in, wait_timeout_in)
-    except boto.route53.exception.DNSServerError, e:
+    except boto.route53.exception.DNSServerError as e:
         txt = e.body.split("<Message>")[1]
         txt = txt.split("</Message>")[0]
         if "but it already exists" in txt:
diff --git a/lib/ansible/modules/cloud/amazon/s3.py b/lib/ansible/modules/cloud/amazon/s3.py
index 0a972ae8d9..999a7f33eb 100755
--- a/lib/ansible/modules/cloud/amazon/s3.py
+++ b/lib/ansible/modules/cloud/amazon/s3.py
@@ -205,7 +205,7 @@ def key_check(module, s3, bucket, obj, version=None):
     try:
         bucket = s3.lookup(bucket)
         key_check = bucket.get_key(obj, version_id=version)
-    except s3.provider.storage_response_error, e:
+    except s3.provider.storage_response_error as e:
         if version is not None and e.status == 400: # If a specified version doesn't exist a 400 is returned.
             key_check = None
         else:
@@ -229,7 +229,7 @@ def keysum(module, s3, bucket, obj, version=None):
 def bucket_check(module, s3, bucket):
     try:
         result = s3.lookup(bucket)
-    except s3.provider.storage_response_error, e:
+    except s3.provider.storage_response_error as e:
         module.fail_json(msg= str(e))
     if result:
         return True
@@ -243,7 +243,7 @@ def create_bucket(module, s3, bucket, location=None):
         bucket = s3.create_bucket(bucket, location=location)
         for acl in module.params.get('permission'):
             bucket.set_acl(acl)
-    except s3.provider.storage_response_error, e:
+    except s3.provider.storage_response_error as e:
         module.fail_json(msg= str(e))
     if bucket:
         return True
@@ -251,7 +251,7 @@ def create_bucket(module, s3, bucket, location=None):
 def get_bucket(module, s3, bucket):
     try:
         return s3.lookup(bucket)
-    except s3.provider.storage_response_error, e:
+    except s3.provider.storage_response_error as e:
         module.fail_json(msg= str(e))
 
 def list_keys(module, bucket_object, prefix, marker, max_keys):
@@ -268,7 +268,7 @@ def delete_bucket(module, s3, bucket):
         bucket.delete_keys([key.name for key in bucket_contents])
         bucket.delete()
         return True
-    except s3.provider.storage_response_error, e:
+    except s3.provider.storage_response_error as e:
         module.fail_json(msg= str(e))
 
 def delete_key(module, s3, bucket, obj):
@@ -276,7 +276,7 @@ def delete_key(module, s3, bucket, obj):
         bucket = s3.lookup(bucket)
         bucket.delete_key(obj)
         module.exit_json(msg="Object deleted from bucket %s"%bucket, changed=True)
-    except s3.provider.storage_response_error, e:
+    except s3.provider.storage_response_error as e:
         module.fail_json(msg= str(e))
 
 def create_dirkey(module, s3, bucket, obj):
@@ -285,7 +285,7 @@ def create_dirkey(module, s3, bucket, obj):
         key = bucket.new_key(obj)
         key.set_contents_from_string('')
         module.exit_json(msg="Virtual directory %s created in bucket %s" % (obj, bucket.name), changed=True)
-    except s3.provider.storage_response_error, e:
+    except s3.provider.storage_response_error as e:
         module.fail_json(msg= str(e))
 
 def path_check(path):
@@ -308,7 +308,7 @@ def upload_s3file(module, s3, bucket, obj, src, expiry, metadata, encrypt, heade
             key.set_acl(acl)
         url = key.generate_url(expiry)
         module.exit_json(msg="PUT operation complete", url=url, changed=True)
-    except s3.provider.storage_copy_error, e:
+    except s3.provider.storage_copy_error as e:
         module.fail_json(msg= str(e))
 
 def download_s3file(module, s3, bucket, obj, dest, retries, version=None):
@@ -320,7 +320,7 @@ def download_s3file(module, s3, bucket, obj, dest, retries, version=None):
         try:
             key.get_contents_to_filename(dest)
             module.exit_json(msg="GET operation complete", changed=True)
-        except s3.provider.storage_copy_error, e:
+        except s3.provider.storage_copy_error as e:
             module.fail_json(msg= str(e))
         except SSLError as e:
             # actually fail on last pass through the loop.
@@ -335,7 +335,7 @@ def download_s3str(module, s3, bucket, obj, version=None):
         key = bucket.get_key(obj, version_id=version)
         contents = key.get_contents_as_string()
         module.exit_json(msg="GET operation complete", contents=contents, changed=True)
-    except s3.provider.storage_copy_error, e:
+    except s3.provider.storage_copy_error as e:
         module.fail_json(msg= str(e))
 
 def get_download_url(module, s3, bucket, obj, expiry, changed=True):
@@ -344,7 +344,7 @@ def get_download_url(module, s3, bucket, obj, expiry, changed=True):
         key = bucket.lookup(obj)
         url = key.generate_url(expiry)
         module.exit_json(msg="Download url:", url=url, expiry=expiry, changed=changed)
-    except s3.provider.storage_response_error, e:
+    except s3.provider.storage_response_error as e:
         module.fail_json(msg= str(e))
 
 def is_fakes3(s3_url):
@@ -466,9 +466,9 @@ def main():
                 # use this as fallback because connect_to_region seems to fail in boto + non 'classic' aws accounts in some cases
                 s3 = boto.connect_s3(**aws_connect_kwargs)
 
-    except boto.exception.NoAuthHandlerFound, e:
+    except boto.exception.NoAuthHandlerFound as e:
         module.fail_json(msg='No Authentication Handler found: %s ' % str(e))
-    except Exception, e:
+    except Exception as e:
         module.fail_json(msg='Failed to connect to S3: %s' % str(e))
 
     if s3 is None: # this should never happen

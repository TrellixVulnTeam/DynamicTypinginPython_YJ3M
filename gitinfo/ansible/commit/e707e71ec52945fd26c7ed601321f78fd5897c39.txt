commit e707e71ec52945fd26c7ed601321f78fd5897c39
Author: Toshio Kuratomi <a.badger@gmail.com>
Date:   Mon Mar 26 13:30:16 2018 -0700

    Except in specific cases, we want to use text strings on the controller

diff --git a/lib/ansible/inventory/manager.py b/lib/ansible/inventory/manager.py
index 845022aa52..0f0df1c32f 100644
--- a/lib/ansible/inventory/manager.py
+++ b/lib/ansible/inventory/manager.py
@@ -28,7 +28,7 @@ from ansible import constants as C
 from ansible.errors import AnsibleError, AnsibleOptionsError, AnsibleParserError
 from ansible.inventory.data import InventoryData
 from ansible.module_utils.six import string_types
-from ansible.module_utils._text import to_bytes, to_native, to_text
+from ansible.module_utils._text import to_bytes, to_text
 from ansible.parsing.utils.addresses import parse_address
 from ansible.plugins.loader import inventory_loader
 from ansible.utils.path import unfrackpath
@@ -86,12 +86,12 @@ def split_host_pattern(pattern):
     if isinstance(pattern, list):
         return list(itertools.chain(*map(split_host_pattern, pattern)))
     elif not isinstance(pattern, string_types):
-        pattern = to_native(pattern)
+        pattern = to_text(pattern, errors='surrogate_or_strict')
 
     # If it's got commas in it, we'll treat it as a straightforward
     # comma-separated list of patterns.
-    if ',' in pattern:
-        patterns = pattern.split(',')
+    if u',' in pattern:
+        patterns = pattern.split(u',')
 
     # If it doesn't, it could still be a single pattern. This accounts for
     # non-separator uses of colons: IPv6 addresses and [x:y] host ranges.
@@ -104,12 +104,12 @@ def split_host_pattern(pattern):
             # This mishandles IPv6 addresses, and is retained only for backwards
             # compatibility.
             patterns = re.findall(
-                r'''(?:             # We want to match something comprising:
+                to_text(r'''(?:     # We want to match something comprising:
                         [^\s:\[\]]  # (anything other than whitespace or ':[]'
                         |           # ...or...
                         \[[^\]]*\]  # a single complete bracketed expression)
                     )+              # occurring once or more
-                ''', pattern, re.X
+                '''), pattern, re.X
             )
 
     return [p.strip() for p in patterns]
@@ -236,9 +236,9 @@ class InventoryManager(object):
                     continue
 
                 # recursively deal with directory entries
-                fullpath = os.path.join(b_source, i)
-                parsed_this_one = self.parse_source(to_native(fullpath), cache=cache)
-                display.debug(u'parsed %s as %s' % (fullpath, parsed_this_one))
+                b_fullpath = os.path.join(b_source, i)
+                parsed_this_one = self.parse_source(b_fullpath, cache=cache)
+                display.debug(u'parsed %s as %s' % (to_text(b_fullpath), parsed_this_one))
                 if not parsed:
                     parsed = parsed_this_one
         else:
@@ -254,7 +254,7 @@ class InventoryManager(object):
             # try source with each plugin
             failures = []
             for plugin in self._inventory_plugins:
-                plugin_name = to_native(getattr(plugin, '_load_name', getattr(plugin, '_original_path', '')))
+                plugin_name = to_text(getattr(plugin, '_load_name', getattr(plugin, '_original_path', '')))
                 display.debug(u'Attempting to use plugin %s (%s)' % (plugin_name, plugin._original_path))
 
                 # initialize and figure out if plugin wants to attempt parsing this file
@@ -337,10 +337,10 @@ class InventoryManager(object):
             pattern_hash = pattern
 
         if not ignore_limits and self._subset:
-            pattern_hash += ":%s" % to_native(self._subset)
+            pattern_hash += u":%s" % to_text(self._subset, errors='surrogate_or_strict')
 
         if not ignore_restrictions and self._restriction:
-            pattern_hash += ":%s" % to_native(self._restriction)
+            pattern_hash += u":%s" % to_text(self._restriction, errors='surrogate_or_strict')
 
         if pattern_hash not in self._hosts_patterns_cache:
 

commit c431d18e28ea94497b5564bb32575b454ee77819
Author: Zim Kalinowski <zikalino@microsoft.com>
Date:   Thu Mar 21 07:07:30 2019 +0800

    Additional DevTest Lab modules (#53091)
    
    * [WIP] Additional DevTest Lab modules
    
    * updates
    
    * try global schedule again
    
    * dtl schedule
    
    * try full dtl schedule test
    
    * fixing schedule
    
    * fixed problem
    
    * another fix
    
    * fixed test
    
    * different time format
    
    * fixed absent state
    
    * test policy idempotence
    
    * more updates
    
    * updated devtestlabpolicy
    
    * fixed syntax
    
    * updated dtl policy test
    
    * updated image id
    
    * fixed test
    
    * fixed bug
    
    * fixed bugs and docs
    
    * fixed bug
    
    * + small cleanup
    
    * reenabled tests but disabled leaking tests
    
    * disabled test

diff --git a/lib/ansible/modules/cloud/azure/azure_rm_devtestlabcustomimage.py b/lib/ansible/modules/cloud/azure/azure_rm_devtestlabcustomimage.py
new file mode 100644
index 0000000000..761ce462b9
--- /dev/null
+++ b/lib/ansible/modules/cloud/azure/azure_rm_devtestlabcustomimage.py
@@ -0,0 +1,383 @@
+#!/usr/bin/python
+#
+# Copyright (c) 2019 Zim Kalinowski, (@zikalino)
+#
+# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
+
+from __future__ import absolute_import, division, print_function
+__metaclass__ = type
+
+
+ANSIBLE_METADATA = {'metadata_version': '1.1',
+                    'status': ['preview'],
+                    'supported_by': 'community'}
+
+
+DOCUMENTATION = '''
+---
+module: azure_rm_devtestlabcustomimage
+version_added: "2.8"
+short_description: Manage Azure DevTest Lab Custom Image instance.
+description:
+    - Create, update and delete instance of Azure DevTest Lab Custom Image.
+
+options:
+    resource_group:
+        description:
+            - The name of the resource group.
+        required: True
+    lab_name:
+        description:
+            - The name of the lab.
+        required: True
+    name:
+        description:
+            - The name of the custom image.
+        required: True
+    source_vm:
+        description:
+            - Source DevTest Lab virtual machine name.
+    windows_os_state:
+        description:
+            - The state of the Windows OS.
+        choices:
+            - 'non_sysprepped'
+            - 'sysprep_requested'
+            - 'sysprep_applied'
+    linux_os_state:
+        description:
+            - The state of the Linux OS.
+        choices:
+            - 'non_deprovisioned'
+            - 'deprovision_requested'
+            - 'deprovision_applied'
+    description:
+        description:
+            - The description of the custom image.
+    author:
+        description:
+            - The author of the custom image.
+    state:
+      description:
+        - Assert the state of the Custom Image.
+        - Use C(present) to create or update an Custom Image and C(absent) to delete it.
+      default: present
+      choices:
+        - absent
+        - present
+
+extends_documentation_fragment:
+    - azure
+    - azure_tags
+
+author:
+    - "Zim Kalinowski (@zikalino)"
+
+'''
+
+EXAMPLES = '''
+- name: Create instance of DevTest Lab Image
+  azure_rm_devtestlabcustomimage:
+    resource_group: myResourceGroup
+    lab_name: myLab
+    name: myImage
+    source_vm: myDevTestLabVm
+    linux_os_state: non_deprovisioned
+'''
+
+RETURN = '''
+id:
+    description:
+        - The identifier of the resource.
+    returned: always
+    type: str
+    sample: "/subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/resourcegroups/myResourceGroup/providers/microsoft.devtestlab/labs/myLab/images/myImage"
+'''
+
+import time
+from ansible.module_utils.azure_rm_common import AzureRMModuleBase
+from ansible.module_utils.common.dict_transformations import _snake_to_camel
+
+try:
+    from msrestazure.azure_exceptions import CloudError
+    from msrest.polling import LROPoller
+    from msrestazure.azure_operation import AzureOperationPoller
+    from azure.mgmt.devtestlabs import DevTestLabsClient
+    from msrest.serialization import Model
+except ImportError:
+    # This is handled in azure_rm_common
+    pass
+
+
+class Actions:
+    NoAction, Create, Update, Delete = range(4)
+
+
+class AzureRMDtlCustomImage(AzureRMModuleBase):
+    """Configuration class for an Azure RM Custom Image resource"""
+
+    def __init__(self):
+        self.module_arg_spec = dict(
+            resource_group=dict(
+                type='str',
+                required=True
+            ),
+            lab_name=dict(
+                type='str',
+                required=True
+            ),
+            name=dict(
+                type='str',
+                required=True
+            ),
+            source_vm=dict(
+                type='str'
+            ),
+            windows_os_state=dict(
+                type='str',
+                choices=['non_sysprepped',
+                         'sysprep_requested',
+                         'sysprep_applied']
+            ),
+            linux_os_state=dict(
+                type='str',
+                choices=['non_deprovisioned',
+                         'deprovision_requested',
+                         'deprovision_applied']
+            ),
+            description=dict(
+                type='str'
+            ),
+            author=dict(
+                type='str'
+            ),
+            state=dict(
+                type='str',
+                default='present',
+                choices=['present', 'absent']
+            )
+        )
+
+        self.resource_group = None
+        self.lab_name = None
+        self.name = None
+        self.custom_image = dict()
+
+        self.results = dict(changed=False)
+        self.mgmt_client = None
+        self.state = None
+        self.to_do = Actions.NoAction
+
+        required_if = [
+            ('state', 'present', [
+             'source_vm'])
+        ]
+
+        super(AzureRMDtlCustomImage, self).__init__(derived_arg_spec=self.module_arg_spec,
+                                                    supports_check_mode=True,
+                                                    supports_tags=True,
+                                                    required_if=required_if)
+
+    def exec_module(self, **kwargs):
+        """Main module execution method"""
+
+        for key in list(self.module_arg_spec.keys()) + ['tags']:
+            if hasattr(self, key):
+                setattr(self, key, kwargs[key])
+            elif kwargs[key] is not None:
+                self.custom_image[key] = kwargs[key]
+
+        if self.state == 'present':
+            windows_os_state = self.custom_image.pop('windows_os_state', False)
+            linux_os_state = self.custom_image.pop('linux_os_state', False)
+            source_vm_name = self.custom_image.pop('source_vm')
+            temp = "/subscriptions/{0}/resourcegroups/{1}/providers/microsoft.devtestlab/labs/{2}/virtualmachines/{3}"
+            self.custom_image['vm'] = {}
+            self.custom_image['vm']['source_vm_id'] = temp.format(self.subscription_id, self.resource_group, self.lab_name, source_vm_name)
+            if windows_os_state:
+                self.custom_image['vm']['windows_os_info'] = {'windows_os_state': _snake_to_camel(windows_os_state, True)}
+            elif linux_os_state:
+                self.custom_image['vm']['linux_os_info'] = {'linux_os_state': _snake_to_camel(linux_os_state, True)}
+            else:
+                self.fail("Either 'linux_os_state' or 'linux_os_state' must be specified")
+
+        response = None
+
+        self.mgmt_client = self.get_mgmt_svc_client(DevTestLabsClient,
+                                                    base_url=self._cloud_environment.endpoints.resource_manager)
+
+        old_response = self.get_customimage()
+
+        if not old_response:
+            self.log("Custom Image instance doesn't exist")
+            if self.state == 'absent':
+                self.log("Old instance didn't exist")
+            else:
+                self.to_do = Actions.Create
+        else:
+            self.log("Custom Image instance already exists")
+            if self.state == 'absent':
+                self.to_do = Actions.Delete
+            elif self.state == 'present':
+                if (not default_compare(self.custom_image, old_response, '', self.results)):
+                    self.to_do = Actions.Update
+
+        if (self.to_do == Actions.Create) or (self.to_do == Actions.Update):
+            self.log("Need to Create / Update the Custom Image instance")
+
+            if self.check_mode:
+                self.results['changed'] = True
+                return self.results
+
+            response = self.create_update_customimage()
+
+            self.results['changed'] = True
+            self.log("Creation / Update done")
+        elif self.to_do == Actions.Delete:
+            self.log("Custom Image instance deleted")
+            self.results['changed'] = True
+
+            if self.check_mode:
+                return self.results
+
+            self.delete_customimage()
+            # This currently doesnt' work as there is a bug in SDK / Service
+            if isinstance(response, LROPoller) or isinstance(response, AzureOperationPoller):
+                response = self.get_poller_result(response)
+        else:
+            self.log("Custom Image instance unchanged")
+            self.results['changed'] = False
+            response = old_response
+
+        if self.state == 'present':
+            self.results.update({
+                'id': response.get('id', None)
+            })
+        return self.results
+
+    def create_update_customimage(self):
+        '''
+        Creates or updates Custom Image with the specified configuration.
+
+        :return: deserialized Custom Image instance state dictionary
+        '''
+        self.log("Creating / Updating the Custom Image instance {0}".format(self.name))
+
+        try:
+            response = self.mgmt_client.custom_images.create_or_update(resource_group_name=self.resource_group,
+                                                                       lab_name=self.lab_name,
+                                                                       name=self.name,
+                                                                       custom_image=self.custom_image)
+            if isinstance(response, LROPoller) or isinstance(response, AzureOperationPoller):
+                response = self.get_poller_result(response)
+
+        except CloudError as exc:
+            self.log('Error attempting to create the Custom Image instance.')
+            self.fail("Error creating the Custom Image instance: {0}".format(str(exc)))
+        return response.as_dict()
+
+    def delete_customimage(self):
+        '''
+        Deletes specified Custom Image instance in the specified subscription and resource group.
+
+        :return: True
+        '''
+        self.log("Deleting the Custom Image instance {0}".format(self.name))
+        try:
+            response = self.mgmt_client.custom_images.delete(resource_group_name=self.resource_group,
+                                                             lab_name=self.lab_name,
+                                                             name=self.name)
+        except CloudError as e:
+            self.log('Error attempting to delete the Custom Image instance.')
+            self.fail("Error deleting the Custom Image instance: {0}".format(str(e)))
+
+        return True
+
+    def get_customimage(self):
+        '''
+        Gets the properties of the specified Custom Image.
+
+        :return: deserialized Custom Image instance state dictionary
+        '''
+        self.log("Checking if the Custom Image instance {0} is present".format(self.name))
+        found = False
+        try:
+            response = self.mgmt_client.custom_images.get(resource_group_name=self.resource_group,
+                                                          lab_name=self.lab_name,
+                                                          name=self.name)
+            found = True
+            self.log("Response : {0}".format(response))
+            self.log("Custom Image instance : {0} found".format(response.name))
+        except CloudError as e:
+            self.log('Did not find the Custom Image instance.')
+        if found is True:
+            return response.as_dict()
+
+        return False
+
+
+def default_compare(new, old, path, result):
+    if new is None:
+        return True
+    elif isinstance(new, dict):
+        if not isinstance(old, dict):
+            result['compare'] = 'changed [' + path + '] old dict is null'
+            return False
+        for k in new.keys():
+            if not default_compare(new.get(k), old.get(k, None), path + '/' + k, result):
+                return False
+        return True
+    elif isinstance(new, list):
+        if not isinstance(old, list) or len(new) != len(old):
+            result['compare'] = 'changed [' + path + '] length is different or null'
+            return False
+        if isinstance(old[0], dict):
+            key = None
+            if 'id' in old[0] and 'id' in new[0]:
+                key = 'id'
+            elif 'name' in old[0] and 'name' in new[0]:
+                key = 'name'
+            else:
+                key = list(old[0])[0]
+            new = sorted(new, key=lambda x: x.get(key, None))
+            old = sorted(old, key=lambda x: x.get(key, None))
+        else:
+            new = sorted(new)
+            old = sorted(old)
+        for i in range(len(new)):
+            if not default_compare(new[i], old[i], path + '/*', result):
+                return False
+        return True
+    else:
+        if path == '/location':
+            new = new.replace(' ', '').lower()
+            old = new.replace(' ', '').lower()
+        if new == old:
+            return True
+        else:
+            result['compare'] = 'changed [' + path + '] ' + str(new) + ' != ' + str(old)
+            return False
+
+
+def dict_camelize(d, path, camelize_first):
+    if isinstance(d, list):
+        for i in range(len(d)):
+            dict_camelize(d[i], path, camelize_first)
+    elif isinstance(d, dict):
+        if len(path) == 1:
+            old_value = d.get(path[0], None)
+            if old_value is not None:
+                d[path[0]] = _snake_to_camel(old_value, camelize_first)
+        else:
+            sd = d.get(path[0], None)
+            if sd is not None:
+                dict_camelize(sd, path[1:], camelize_first)
+
+
+def main():
+    """Main execution"""
+    AzureRMDtlCustomImage()
+
+
+if __name__ == '__main__':
+    main()
diff --git a/lib/ansible/modules/cloud/azure/azure_rm_devtestlabenvironment.py b/lib/ansible/modules/cloud/azure/azure_rm_devtestlabenvironment.py
new file mode 100644
index 0000000000..2d52966096
--- /dev/null
+++ b/lib/ansible/modules/cloud/azure/azure_rm_devtestlabenvironment.py
@@ -0,0 +1,379 @@
+#!/usr/bin/python
+#
+# Copyright (c) 2019 Zim Kalinowski, (@zikalino)
+#
+# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
+
+from __future__ import absolute_import, division, print_function
+__metaclass__ = type
+
+
+ANSIBLE_METADATA = {'metadata_version': '1.1',
+                    'status': ['preview'],
+                    'supported_by': 'community'}
+
+
+DOCUMENTATION = '''
+---
+module: azure_rm_devtestlabenvironment
+version_added: "2.8"
+short_description: Manage Azure DevTest Lab Environment instance.
+description:
+    - Create, update and delete instance of Azure DevTest Lab Environment.
+
+options:
+    resource_group:
+        description:
+            - The name of the resource group.
+        required: True
+    lab_name:
+        description:
+            - The name of the lab.
+        required: True
+    user_name:
+        description:
+            - The name of the user profile.
+        required: True
+    name:
+        description:
+            - The name of the environment.
+        required: True
+    location:
+        description:
+            - The location of the resource.
+    deployment_template:
+        description:
+            - "The Azure Resource Manager template's identifier."
+    deployment_parameters:
+        description:
+            - The parameters of the Azure Resource Manager template.
+        type: list
+        suboptions:
+            name:
+                description:
+                    - The name of the template parameter.
+            value:
+                description:
+                    - The value of the template parameter.
+    state:
+      description:
+        - Assert the state of the Environment.
+        - Use 'present' to create or update an Environment and 'absent' to delete it.
+      default: present
+      choices:
+        - absent
+        - present
+
+extends_documentation_fragment:
+    - azure
+    - azure_tags
+
+author:
+    - "Zim Kalinowski (@zikalino)"
+
+'''
+
+EXAMPLES = '''
+- name: Create instance of DevTest Lab Environment from public environment repo
+  azure_rm_devtestlabenvironment:
+    resource_group: myResourceGroup
+    lab_name: myLab
+    user_name: user
+    name: myEnvironment
+    location: eastus
+    deployment_template:
+      artifact_source_name: public environment repo
+      name: WebApp
+'''
+
+RETURN = '''
+id:
+    description:
+        - The identifier of the resource.
+    returned: always
+    type: str
+    sample: "/subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/resourcegroups/myResourceGroup/providers/microsoft.devtestlab/labs/myLab/environment
+             s/myEnvironment"
+
+'''
+
+import time
+from ansible.module_utils.azure_rm_common import AzureRMModuleBase
+from ansible.module_utils.common.dict_transformations import _snake_to_camel
+
+try:
+    from msrestazure.azure_exceptions import CloudError
+    from msrest.polling import LROPoller
+    from msrestazure.azure_operation import AzureOperationPoller
+    from azure.mgmt.devtestlabs import DevTestLabsClient
+    from msrest.serialization import Model
+except ImportError:
+    # This is handled in azure_rm_common
+    pass
+
+
+class Actions:
+    NoAction, Create, Update, Delete = range(4)
+
+
+class AzureRMDtlEnvironment(AzureRMModuleBase):
+    """Configuration class for an Azure RM Environment resource"""
+
+    def __init__(self):
+        self.module_arg_spec = dict(
+            resource_group=dict(
+                type='str',
+                required=True
+            ),
+            lab_name=dict(
+                type='str',
+                required=True
+            ),
+            user_name=dict(
+                type='str',
+                required=True
+            ),
+            name=dict(
+                type='str',
+                required=True
+            ),
+            location=dict(
+                type='str'
+            ),
+            deployment_template=dict(
+                type='raw'
+            ),
+            deployment_parameters=dict(
+                type='list',
+                options=dict(
+                    name=dict(
+                        type='str'
+                    ),
+                    value=dict(
+                        type='str'
+                    )
+                )
+            ),
+            state=dict(
+                type='str',
+                default='present',
+                choices=['present', 'absent']
+            )
+        )
+
+        self.resource_group = None
+        self.lab_name = None
+        self.user_name = None
+        self.name = None
+        self.dtl_environment = dict()
+
+        self.results = dict(changed=False)
+        self.mgmt_client = None
+        self.state = None
+        self.to_do = Actions.NoAction
+
+        super(AzureRMDtlEnvironment, self).__init__(derived_arg_spec=self.module_arg_spec,
+                                                    supports_check_mode=True,
+                                                    supports_tags=True)
+
+    def exec_module(self, **kwargs):
+        """Main module execution method"""
+
+        for key in list(self.module_arg_spec.keys()) + ['tags']:
+            if hasattr(self, key):
+                setattr(self, key, kwargs[key])
+            elif kwargs[key] is not None:
+                self.dtl_environment[key] = kwargs[key]
+
+        response = None
+
+        self.mgmt_client = self.get_mgmt_svc_client(DevTestLabsClient,
+                                                    base_url=self._cloud_environment.endpoints.resource_manager)
+
+        resource_group = self.get_resource_group(self.resource_group)
+        deployment_template = self.dtl_environment.pop('deployment_template', None)
+        if deployment_template:
+            if isinstance(deployment_template, dict):
+                if all(key in deployment_template for key in ('artifact_source_name', 'name')):
+                    tmp = '/subscriptions/{0}/resourcegroups/{1}/providers/microsoft.devtestlab/labs/{2}/artifactSources/{3}/armTemplates/{4}'
+                    deployment_template = tmp.format(self.subscription_id,
+                                                     self.resource_group,
+                                                     self.lab_name,
+                                                     deployment_template['artifact_source_name'],
+                                                     deployment_template['name'])
+            if not isinstance(deployment_template, str):
+                self.fail("parameter error: expecting deployment_template to contain [artifact_source, name]")
+            self.dtl_environment['deployment_properties'] = {}
+            self.dtl_environment['deployment_properties']['arm_template_id'] = deployment_template
+            self.dtl_environment['deployment_properties']['parameters'] = self.dtl_environment.pop('deployment_parameters', None)
+
+        old_response = self.get_environment()
+
+        if not old_response:
+            self.log("Environment instance doesn't exist")
+            if self.state == 'absent':
+                self.log("Old instance didn't exist")
+            else:
+                self.to_do = Actions.Create
+        else:
+            self.log("Environment instance already exists")
+            if self.state == 'absent':
+                self.to_do = Actions.Delete
+            elif self.state == 'present':
+                if (not default_compare(self.dtl_environment, old_response, '', self.results)):
+                    self.to_do = Actions.Update
+
+        if (self.to_do == Actions.Create) or (self.to_do == Actions.Update):
+            self.log("Need to Create / Update the Environment instance")
+
+            if self.check_mode:
+                self.results['changed'] = True
+                return self.results
+
+            response = self.create_update_environment()
+
+            self.results['changed'] = True
+            self.log("Creation / Update done")
+        elif self.to_do == Actions.Delete:
+            self.log("Environment instance deleted")
+            self.results['changed'] = True
+
+            if self.check_mode:
+                return self.results
+
+            self.delete_environment()
+            # This currently doesnt' work as there is a bug in SDK / Service
+            if isinstance(response, LROPoller) or isinstance(response, AzureOperationPoller):
+                response = self.get_poller_result(response)
+        else:
+            self.log("Environment instance unchanged")
+            self.results['changed'] = False
+            response = old_response
+
+        if self.state == 'present':
+            self.results.update({
+                'id': response.get('id', None)
+            })
+        return self.results
+
+    def create_update_environment(self):
+        '''
+        Creates or updates Environment with the specified configuration.
+
+        :return: deserialized Environment instance state dictionary
+        '''
+        self.log("Creating / Updating the Environment instance {0}".format(self.name))
+
+        try:
+            if self.to_do == Actions.Create:
+                response = self.mgmt_client.environments.create_or_update(resource_group_name=self.resource_group,
+                                                                          lab_name=self.lab_name,
+                                                                          user_name=self.user_name,
+                                                                          name=self.name,
+                                                                          dtl_environment=self.dtl_environment)
+            else:
+                response = self.mgmt_client.environments.update(resource_group_name=self.resource_group,
+                                                                lab_name=self.lab_name,
+                                                                user_name=self.user_name,
+                                                                name=self.name,
+                                                                dtl_environment=self.dtl_environment)
+            if isinstance(response, LROPoller) or isinstance(response, AzureOperationPoller):
+                response = self.get_poller_result(response)
+
+        except CloudError as exc:
+            self.log('Error attempting to create the Environment instance.')
+            self.fail("Error creating the Environment instance: {0}".format(str(exc)))
+        return response.as_dict()
+
+    def delete_environment(self):
+        '''
+        Deletes specified Environment instance in the specified subscription and resource group.
+
+        :return: True
+        '''
+        self.log("Deleting the Environment instance {0}".format(self.name))
+        try:
+            response = self.mgmt_client.environments.delete(resource_group_name=self.resource_group,
+                                                            lab_name=self.lab_name,
+                                                            user_name=self.user_name,
+                                                            name=self.name)
+        except CloudError as e:
+            self.log('Error attempting to delete the Environment instance.')
+            self.fail("Error deleting the Environment instance: {0}".format(str(e)))
+
+        return True
+
+    def get_environment(self):
+        '''
+        Gets the properties of the specified Environment.
+
+        :return: deserialized Environment instance state dictionary
+        '''
+        self.log("Checking if the Environment instance {0} is present".format(self.name))
+        found = False
+        try:
+            response = self.mgmt_client.environments.get(resource_group_name=self.resource_group,
+                                                         lab_name=self.lab_name,
+                                                         user_name=self.user_name,
+                                                         name=self.name)
+            found = True
+            self.log("Response : {0}".format(response))
+            self.log("Environment instance : {0} found".format(response.name))
+        except CloudError as e:
+            self.log('Did not find the Environment instance.')
+        if found is True:
+            return response.as_dict()
+
+        return False
+
+
+def default_compare(new, old, path, result):
+    if new is None:
+        return True
+    elif isinstance(new, dict):
+        if not isinstance(old, dict):
+            result['compare'] = 'changed [' + path + '] old dict is null'
+            return False
+        for k in new.keys():
+            if not default_compare(new.get(k), old.get(k, None), path + '/' + k, result):
+                return False
+        return True
+    elif isinstance(new, list):
+        if not isinstance(old, list) or len(new) != len(old):
+            result['compare'] = 'changed [' + path + '] length is different or null'
+            return False
+        if isinstance(old[0], dict):
+            key = None
+            if 'id' in old[0] and 'id' in new[0]:
+                key = 'id'
+            elif 'name' in old[0] and 'name' in new[0]:
+                key = 'name'
+            else:
+                key = list(old[0])[0]
+            new = sorted(new, key=lambda x: x.get(key, None))
+            old = sorted(old, key=lambda x: x.get(key, None))
+        else:
+            new = sorted(new)
+            old = sorted(old)
+        for i in range(len(new)):
+            if not default_compare(new[i], old[i], path + '/*', result):
+                return False
+        return True
+    else:
+        if path == '/location':
+            new = new.replace(' ', '').lower()
+            old = new.replace(' ', '').lower()
+        if new == old:
+            return True
+        else:
+            result['compare'] = 'changed [' + path + '] ' + str(new) + ' != ' + str(old)
+            return False
+
+
+def main():
+    """Main execution"""
+    AzureRMDtlEnvironment()
+
+
+if __name__ == '__main__':
+    main()
diff --git a/lib/ansible/modules/cloud/azure/azure_rm_devtestlabpolicy.py b/lib/ansible/modules/cloud/azure/azure_rm_devtestlabpolicy.py
new file mode 100644
index 0000000000..35f055b0d3
--- /dev/null
+++ b/lib/ansible/modules/cloud/azure/azure_rm_devtestlabpolicy.py
@@ -0,0 +1,401 @@
+#!/usr/bin/python
+#
+# Copyright (c) 2019 Zim Kalinowski, (@zikalino)
+#
+# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
+
+from __future__ import absolute_import, division, print_function
+__metaclass__ = type
+
+
+ANSIBLE_METADATA = {'metadata_version': '1.1',
+                    'status': ['preview'],
+                    'supported_by': 'community'}
+
+
+DOCUMENTATION = '''
+---
+module: azure_rm_devtestlabpolicy
+version_added: "2.8"
+short_description: Manage Azure Policy instance.
+description:
+    - Create, update and delete instance of Azure Policy.
+
+options:
+    resource_group:
+        description:
+            - The name of the resource group.
+        required: True
+    lab_name:
+        description:
+            - The name of the lab.
+        required: True
+    policy_set_name:
+        description:
+            - The name of the policy set.
+        required: True
+    name:
+        description:
+            - The name of the policy.
+        required: True
+    description:
+        description:
+            - The description of the policy.
+    fact_name:
+        description:
+            - The fact name of the policy (e.g. C(lab_vm_count), C(lab_vm_size), MaxVmsAllowedPerLab, etc.
+        choices:
+            - 'user_owned_lab_vm_count'
+            - 'user_owned_lab_premium_vm_count'
+            - 'lab_vm_count'
+            - 'lab_premium_vm_count'
+            - 'lab_vm_size'
+            - 'gallery_image'
+            - 'user_owned_lab_vm_count_in_subnet'
+            - 'lab_target_cost'
+    threshold:
+        description:
+            - The threshold of the policy (it could be either a maximum value or a list of allowed values).
+        type: raw
+    state:
+      description:
+        - Assert the state of the Policy.
+        - Use C(present) to create or update an Policy and C(absent) to delete it.
+      default: present
+      choices:
+        - absent
+        - present
+
+extends_documentation_fragment:
+    - azure
+    - azure_tags
+
+author:
+    - "Zim Kalinowski (@zikalino)"
+
+'''
+
+EXAMPLES = '''
+- name: Create DevTest Lab Policy
+  azure_rm_devtestlabpolicy:
+    resource_group: myResourceGroup
+    lab_name: myLab
+    policy_set_name: myPolicySet
+    name: myPolicy
+    fact_name: user_owned_lab_vm_count
+    threshold: 5
+'''
+
+RETURN = '''
+id:
+    description:
+        - The identifier of the resource.
+    returned: always
+    type: str
+    sample: "/subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/resourcegroups/myResourceGroup/providers/microsoft.devtestlab/labs/myLab/policySets/
+             myPolicySet/policies/myPolicy"
+
+'''
+
+import time
+from ansible.module_utils.azure_rm_common import AzureRMModuleBase
+from ansible.module_utils.common.dict_transformations import _snake_to_camel
+
+try:
+    from msrestazure.azure_exceptions import CloudError
+    from msrest.polling import LROPoller
+    from msrestazure.azure_operation import AzureOperationPoller
+    from azure.mgmt.devtestlabs import DevTestLabsClient
+    from msrest.serialization import Model
+except ImportError:
+    # This is handled in azure_rm_common
+    pass
+
+
+class Actions:
+    NoAction, Create, Update, Delete = range(4)
+
+
+class AzureRMDtlPolicy(AzureRMModuleBase):
+    """Configuration class for an Azure RM Policy resource"""
+
+    def __init__(self):
+        self.module_arg_spec = dict(
+            resource_group=dict(
+                type='str',
+                required=True
+            ),
+            lab_name=dict(
+                type='str',
+                required=True
+            ),
+            policy_set_name=dict(
+                type='str',
+                required=True
+            ),
+            name=dict(
+                type='str',
+                required=True
+            ),
+            description=dict(
+                type='str'
+            ),
+            fact_name=dict(
+                type='str',
+                choices=['user_owned_lab_vm_count',
+                         'user_owned_lab_premium_vm_count',
+                         'lab_vm_count',
+                         'lab_premium_vm_count',
+                         'lab_vm_size',
+                         'gallery_image',
+                         'user_owned_lab_vm_count_in_subnet',
+                         'lab_target_cost']
+            ),
+            threshold=dict(
+                type='raw'
+            ),
+            state=dict(
+                type='str',
+                default='present',
+                choices=['present', 'absent']
+            )
+        )
+
+        self.resource_group = None
+        self.lab_name = None
+        self.policy_set_name = None
+        self.name = None
+        self.policy = dict()
+
+        self.results = dict(changed=False)
+        self.mgmt_client = None
+        self.state = None
+        self.to_do = Actions.NoAction
+
+        required_if = [
+            ('state', 'present', ['threshold', 'fact_name'])
+        ]
+
+        super(AzureRMDtlPolicy, self).__init__(derived_arg_spec=self.module_arg_spec,
+                                               supports_check_mode=True,
+                                               supports_tags=True,
+                                               required_if=required_if)
+
+    def exec_module(self, **kwargs):
+        """Main module execution method"""
+
+        for key in list(self.module_arg_spec.keys()) + ['tags']:
+            if hasattr(self, key):
+                setattr(self, key, kwargs[key])
+            elif kwargs[key] is not None:
+                self.policy[key] = kwargs[key]
+
+        if self.state == 'present':
+            self.policy['status'] = 'Enabled'
+            dict_camelize(self.policy, ['fact_name'], True)
+            if isinstance(self.policy['threshold'], list):
+                self.policy['evaluator_type'] = 'AllowedValuesPolicy'
+            else:
+                self.policy['evaluator_type'] = 'MaxValuePolicy'
+
+        response = None
+
+        self.mgmt_client = self.get_mgmt_svc_client(DevTestLabsClient,
+                                                    base_url=self._cloud_environment.endpoints.resource_manager)
+
+        resource_group = self.get_resource_group(self.resource_group)
+
+        old_response = self.get_policy()
+
+        if not old_response:
+            self.log("Policy instance doesn't exist")
+            if self.state == 'absent':
+                self.log("Old instance didn't exist")
+            else:
+                self.to_do = Actions.Create
+        else:
+            self.log("Policy instance already exists")
+            if self.state == 'absent':
+                self.to_do = Actions.Delete
+            elif self.state == 'present':
+                if (not default_compare(self.policy, old_response, '', self.results)):
+                    self.to_do = Actions.Update
+
+        if (self.to_do == Actions.Create) or (self.to_do == Actions.Update):
+            self.log("Need to Create / Update the Policy instance")
+
+            if self.check_mode:
+                self.results['changed'] = True
+                return self.results
+
+            response = self.create_update_policy()
+
+            self.results['changed'] = True
+            self.log("Creation / Update done")
+        elif self.to_do == Actions.Delete:
+            self.log("Policy instance deleted")
+            self.results['changed'] = True
+
+            if self.check_mode:
+                return self.results
+
+            self.delete_policy()
+            # This currently doesnt' work as there is a bug in SDK / Service
+            if isinstance(response, LROPoller) or isinstance(response, AzureOperationPoller):
+                response = self.get_poller_result(response)
+        else:
+            self.log("Policy instance unchanged")
+            self.results['changed'] = False
+            response = old_response
+
+        if self.state == 'present':
+            self.results.update({
+                'id': response.get('id', None),
+                'status': response.get('status', None)
+            })
+        return self.results
+
+    def create_update_policy(self):
+        '''
+        Creates or updates Policy with the specified configuration.
+
+        :return: deserialized Policy instance state dictionary
+        '''
+        self.log("Creating / Updating the Policy instance {0}".format(self.name))
+
+        try:
+            response = self.mgmt_client.policies.create_or_update(resource_group_name=self.resource_group,
+                                                                  lab_name=self.lab_name,
+                                                                  policy_set_name=self.policy_set_name,
+                                                                  name=self.name,
+                                                                  policy=self.policy)
+            if isinstance(response, LROPoller) or isinstance(response, AzureOperationPoller):
+                response = self.get_poller_result(response)
+
+        except CloudError as exc:
+            self.log('Error attempting to create the Policy instance.')
+            self.fail("Error creating the Policy instance: {0}".format(str(exc)))
+        return response.as_dict()
+
+    def delete_policy(self):
+        '''
+        Deletes specified Policy instance in the specified subscription and resource group.
+
+        :return: True
+        '''
+        self.log("Deleting the Policy instance {0}".format(self.name))
+        try:
+            response = self.mgmt_client.policies.delete(resource_group_name=self.resource_group,
+                                                        lab_name=self.lab_name,
+                                                        policy_set_name=self.policy_set_name,
+                                                        name=self.name)
+        except CloudError as e:
+            self.log('Error attempting to delete the Policy instance.')
+            self.fail("Error deleting the Policy instance: {0}".format(str(e)))
+
+        return True
+
+    def get_policy(self):
+        '''
+        Gets the properties of the specified Policy.
+
+        :return: deserialized Policy instance state dictionary
+        '''
+        self.log("Checking if the Policy instance {0} is present".format(self.name))
+        found = False
+        try:
+            response = self.mgmt_client.policies.get(resource_group_name=self.resource_group,
+                                                     lab_name=self.lab_name,
+                                                     policy_set_name=self.policy_set_name,
+                                                     name=self.name)
+            found = True
+            self.log("Response : {0}".format(response))
+            self.log("Policy instance : {0} found".format(response.name))
+        except CloudError as e:
+            self.log('Did not find the Policy instance.')
+        if found is True:
+            return response.as_dict()
+
+        return False
+
+
+def default_compare(new, old, path, result):
+    if new is None:
+        return True
+    elif isinstance(new, dict):
+        if not isinstance(old, dict):
+            result['compare'] = 'changed [' + path + '] old dict is null'
+            return False
+        for k in new.keys():
+            if not default_compare(new.get(k), old.get(k, None), path + '/' + k, result):
+                return False
+        return True
+    elif isinstance(new, list):
+        if not isinstance(old, list) or len(new) != len(old):
+            result['compare'] = 'changed [' + path + '] length is different or null'
+            return False
+        if isinstance(old[0], dict):
+            key = None
+            if 'id' in old[0] and 'id' in new[0]:
+                key = 'id'
+            elif 'name' in old[0] and 'name' in new[0]:
+                key = 'name'
+            else:
+                key = list(old[0])[0]
+            new = sorted(new, key=lambda x: x.get(key, None))
+            old = sorted(old, key=lambda x: x.get(key, None))
+        else:
+            new = sorted(new)
+            old = sorted(old)
+        for i in range(len(new)):
+            if not default_compare(new[i], old[i], path + '/*', result):
+                return False
+        return True
+    else:
+        if path == '/location':
+            new = new.replace(' ', '').lower()
+            old = new.replace(' ', '').lower()
+        if str(new) == str(old):
+            return True
+        else:
+            result['compare'] = 'changed [' + path + '] ' + str(new) + ' != ' + str(old)
+            return False
+
+
+def dict_camelize(d, path, camelize_first):
+    if isinstance(d, list):
+        for i in range(len(d)):
+            dict_camelize(d[i], path, camelize_first)
+    elif isinstance(d, dict):
+        if len(path) == 1:
+            old_value = d.get(path[0], None)
+            if old_value is not None:
+                d[path[0]] = _snake_to_camel(old_value, camelize_first)
+        else:
+            sd = d.get(path[0], None)
+            if sd is not None:
+                dict_camelize(sd, path[1:], camelize_first)
+
+
+def dict_map(d, path, map):
+    if isinstance(d, list):
+        for i in range(len(d)):
+            dict_map(d[i], path, map)
+    elif isinstance(d, dict):
+        if len(path) == 1:
+            old_value = d.get(path[0], None)
+            if old_value is not None:
+                d[path[0]] = map.get(old_value, old_value)
+        else:
+            sd = d.get(path[0], None)
+            if sd is not None:
+                dict_map(sd, path[1:], map)
+
+
+def main():
+    """Main execution"""
+    AzureRMDtlPolicy()
+
+
+if __name__ == '__main__':
+    main()
diff --git a/lib/ansible/modules/cloud/azure/azure_rm_devtestlabschedule.py b/lib/ansible/modules/cloud/azure/azure_rm_devtestlabschedule.py
new file mode 100644
index 0000000000..b861f7fd05
--- /dev/null
+++ b/lib/ansible/modules/cloud/azure/azure_rm_devtestlabschedule.py
@@ -0,0 +1,341 @@
+#!/usr/bin/python
+#
+# Copyright (c) 2019 Zim Kalinowski, (@zikalino)
+#
+# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
+
+from __future__ import absolute_import, division, print_function
+__metaclass__ = type
+
+
+ANSIBLE_METADATA = {'metadata_version': '1.1',
+                    'status': ['preview'],
+                    'supported_by': 'community'}
+
+
+DOCUMENTATION = '''
+---
+module: azure_rm_devtestlabschedule
+version_added: "2.8"
+short_description: Manage Azure DevTest Lab Schedule instance.
+description:
+    - Create, update and delete instance of Azure DecTest Lab Schedule.
+
+options:
+    resource_group:
+        description:
+            - The name of the resource group.
+        required: True
+    lab_name:
+        description:
+            - The name of the lab.
+        required: True
+    name:
+        description:
+            - The name of the schedule.
+        required: True
+        choices:
+            - lab_vms_startup
+            - lab_vms_shutdown
+    time:
+        description:
+            - The time of day the schedule will occur.
+    time_zone_id:
+        description:
+            - The time zone ID.
+    state:
+      description:
+        - Assert the state of the Schedule.
+        - Use C(present) to create or update an Schedule and C(absent) to delete it.
+      default: present
+      choices:
+        - absent
+        - present
+
+extends_documentation_fragment:
+    - azure
+    - azure_tags
+
+author:
+    - "Zim Kalinowski (@zikalino)"
+
+'''
+
+EXAMPLES = '''
+  - name: Create (or update) DevTest Lab Schedule
+    azure_rm_devtestlabschedule:
+      resource_group: myResourceGroup
+      lab_name: myLab
+      name: lab_vms_shutdown
+      time: "1030"
+      time_zone_id: "UTC+12"
+'''
+
+RETURN = '''
+id:
+    description:
+        - The identifier of the resource.
+    returned: always
+    type: str
+    sample: "/subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/resourcegroups/myResourceGroup/providers/microsoft.devtestlab/labs/myLab/schedules/l
+             abVmsShutdown"
+'''
+
+import time
+from ansible.module_utils.azure_rm_common import AzureRMModuleBase
+from ansible.module_utils.common.dict_transformations import _snake_to_camel
+
+try:
+    from msrestazure.azure_exceptions import CloudError
+    from msrest.polling import LROPoller
+    from msrestazure.azure_operation import AzureOperationPoller
+    from azure.mgmt.devtestlabs import DevTestLabsClient
+    from msrest.serialization import Model
+except ImportError:
+    # This is handled in azure_rm_common
+    pass
+
+
+class Actions:
+    NoAction, Create, Update, Delete = range(4)
+
+
+class AzureRMSchedule(AzureRMModuleBase):
+    """Configuration class for an Azure RM Schedule resource"""
+
+    def __init__(self):
+        self.module_arg_spec = dict(
+            resource_group=dict(
+                type='str',
+                required=True
+            ),
+            lab_name=dict(
+                type='str',
+                required=True
+            ),
+            name=dict(
+                type='str',
+                required=True,
+                choices=['lab_vms_startup', 'lab_vms_shutdown']
+            ),
+            time=dict(
+                type='str'
+            ),
+            time_zone_id=dict(
+                type='str'
+            ),
+            state=dict(
+                type='str',
+                default='present',
+                choices=['present', 'absent']
+            )
+        )
+
+        self.resource_group = None
+        self.lab_name = None
+        self.name = None
+        self.schedule = dict()
+
+        self.results = dict(changed=False)
+        self.mgmt_client = None
+        self.state = None
+        self.to_do = Actions.NoAction
+
+        required_if = [
+            ('state', 'present', ['time', 'time_zone_id'])
+        ]
+
+        super(AzureRMSchedule, self).__init__(derived_arg_spec=self.module_arg_spec,
+                                              supports_check_mode=True,
+                                              supports_tags=True,
+                                              required_if=required_if)
+
+    def exec_module(self, **kwargs):
+        """Main module execution method"""
+
+        for key in list(self.module_arg_spec.keys()) + ['tags']:
+            if hasattr(self, key):
+                setattr(self, key, kwargs[key])
+            elif kwargs[key] is not None:
+                self.schedule[key] = kwargs[key]
+
+        self.schedule['status'] = "Enabled"
+
+        if self.name == 'lab_vms_startup':
+            self.name = 'LabVmsStartup'
+            self.schedule['task_type'] = 'LabVmsStartupTask'
+        elif self.name == 'lab_vms_shutdown':
+            self.name = 'LabVmsShutdown'
+            self.schedule['task_type'] = 'LabVmsShutdownTask'
+
+        if self.state == 'present':
+            self.schedule['daily_recurrence'] = {'time': self.schedule.pop('time')}
+            self.schedule['time_zone_id'] = self.schedule['time_zone_id'].upper()
+
+        response = None
+
+        self.mgmt_client = self.get_mgmt_svc_client(DevTestLabsClient,
+                                                    base_url=self._cloud_environment.endpoints.resource_manager)
+
+        resource_group = self.get_resource_group(self.resource_group)
+
+        old_response = self.get_schedule()
+
+        if not old_response:
+            self.log("Schedule instance doesn't exist")
+            if self.state == 'absent':
+                self.log("Old instance didn't exist")
+            else:
+                self.to_do = Actions.Create
+        else:
+            self.log("Schedule instance already exists")
+            if self.state == 'absent':
+                self.to_do = Actions.Delete
+            elif self.state == 'present':
+                if (not default_compare(self.schedule, old_response, '', self.results)):
+                    self.to_do = Actions.Update
+
+        if (self.to_do == Actions.Create) or (self.to_do == Actions.Update):
+            self.log("Need to Create / Update the Schedule instance")
+
+            if self.check_mode:
+                self.results['changed'] = True
+                return self.results
+
+            response = self.create_update_schedule()
+
+            self.results['changed'] = True
+            self.log("Creation / Update done")
+        elif self.to_do == Actions.Delete:
+            self.log("Schedule instance deleted")
+            self.results['changed'] = True
+
+            if self.check_mode:
+                return self.results
+
+            self.delete_schedule()
+            # This currently doesnt' work as there is a bug in SDK / Service
+            if isinstance(response, LROPoller) or isinstance(response, AzureOperationPoller):
+                response = self.get_poller_result(response)
+        else:
+            self.log("Schedule instance unchanged")
+            self.results['changed'] = False
+            response = old_response
+
+        if self.state == 'present':
+            self.results.update({
+                'id': response.get('id', None)
+            })
+        return self.results
+
+    def create_update_schedule(self):
+        '''
+        Creates or updates Schedule with the specified configuration.
+
+        :return: deserialized Schedule instance state dictionary
+        '''
+        self.log("Creating / Updating the Schedule instance {0}".format(self.name))
+
+        try:
+            response = self.mgmt_client.schedules.create_or_update(resource_group_name=self.resource_group,
+                                                                   lab_name=self.lab_name,
+                                                                   name=self.name,
+                                                                   schedule=self.schedule)
+            if isinstance(response, LROPoller) or isinstance(response, AzureOperationPoller):
+                response = self.get_poller_result(response)
+
+        except CloudError as exc:
+            self.log('Error attempting to create the Schedule instance.')
+            self.fail("Error creating the Schedule instance: {0}".format(str(exc)))
+        return response.as_dict()
+
+    def delete_schedule(self):
+        '''
+        Deletes specified Schedule instance in the specified subscription and resource group.
+
+        :return: True
+        '''
+        self.log("Deleting the Schedule instance {0}".format(self.name))
+        try:
+            response = self.mgmt_client.schedules.delete(resource_group_name=self.resource_group,
+                                                         lab_name=self.lab_name,
+                                                         name=self.name)
+        except CloudError as e:
+            self.log('Error attempting to delete the Schedule instance.')
+            self.fail("Error deleting the Schedule instance: {0}".format(str(e)))
+
+        return True
+
+    def get_schedule(self):
+        '''
+        Gets the properties of the specified Schedule.
+
+        :return: deserialized Schedule instance state dictionary
+        '''
+        self.log("Checking if the Schedule instance {0} is present".format(self.name))
+        found = False
+        try:
+            response = self.mgmt_client.schedules.get(resource_group_name=self.resource_group,
+                                                      lab_name=self.lab_name,
+                                                      name=self.name)
+            found = True
+            self.log("Response : {0}".format(response))
+            self.log("Schedule instance : {0} found".format(response.name))
+        except CloudError as e:
+            self.log('Did not find the Schedule instance.')
+        if found is True:
+            return response.as_dict()
+
+        return False
+
+
+def default_compare(new, old, path, result):
+    if new is None:
+        return True
+    elif isinstance(new, dict):
+        if not isinstance(old, dict):
+            result['compare'] = 'changed [' + path + '] old dict is null'
+            return False
+        for k in new.keys():
+            if not default_compare(new.get(k), old.get(k, None), path + '/' + k, result):
+                return False
+        return True
+    elif isinstance(new, list):
+        if not isinstance(old, list) or len(new) != len(old):
+            result['compare'] = 'changed [' + path + '] length is different or null'
+            return False
+        if isinstance(old[0], dict):
+            key = None
+            if 'id' in old[0] and 'id' in new[0]:
+                key = 'id'
+            elif 'name' in old[0] and 'name' in new[0]:
+                key = 'name'
+            else:
+                key = list(old[0])[0]
+            new = sorted(new, key=lambda x: x.get(key, None))
+            old = sorted(old, key=lambda x: x.get(key, None))
+        else:
+            new = sorted(new)
+            old = sorted(old)
+        for i in range(len(new)):
+            if not default_compare(new[i], old[i], path + '/*', result):
+                return False
+        return True
+    else:
+        if path == '/location':
+            new = new.replace(' ', '').lower()
+            old = new.replace(' ', '').lower()
+        if new == old:
+            return True
+        else:
+            result['compare'] = 'changed [' + path + '] ' + str(new) + ' != ' + str(old)
+            return False
+
+
+def main():
+    """Main execution"""
+    AzureRMSchedule()
+
+
+if __name__ == '__main__':
+    main()
diff --git a/test/integration/targets/azure_rm_devtestlab/aliases b/test/integration/targets/azure_rm_devtestlab/aliases
index 5d60c42681..fc6fecf8d5 100644
--- a/test/integration/targets/azure_rm_devtestlab/aliases
+++ b/test/integration/targets/azure_rm_devtestlab/aliases
@@ -1,6 +1,17 @@
 cloud/azure
 destructive
 shippable/azure/group2
-disabled
-azure_rm_devtestlabvirtualnetwork
 azure_rm_devtestlab_facts
+azure_rm_devtestlabarmtemplate
+azure_rm_devtestlabartifact
+azure_rm_devtestlabartifactsource_facts
+azure_rm_devtestlabartifactsource
+azure_rm_devtestlabcustomimage
+azure_rm_devtestlabpolicy
+azure_rm_devtestlabschedule
+azure_rm_devtestlabvirtualmachine_facts
+azure_rm_devtestlabvirtualmachine_facts
+azure_rm_devtestlabvirtualnetwork_facts
+azure_rm_devtestlabvirtualnetwork
+disabled
+
diff --git a/test/integration/targets/azure_rm_devtestlab/tasks/main.yml b/test/integration/targets/azure_rm_devtestlab/tasks/main.yml
index a84b4d8e6e..c29ab22980 100644
--- a/test/integration/targets/azure_rm_devtestlab/tasks/main.yml
+++ b/test/integration/targets/azure_rm_devtestlab/tasks/main.yml
@@ -28,7 +28,7 @@
     location: eastus
     storage_type: standard
     premium_data_disks: no
-  register: output
+  register: output_lab
 - name: Check if the change was correctly reported
   assert:
     that:
@@ -60,44 +60,168 @@
     that:
       - output.changed
 
+- name: List DevTest Lab in a resource group
+  azure_rm_devtestlab_facts:
+    resource_group: "{{ resource_group }}"
+  register: output_lab
+- name: Assert that facts are returned
+  assert:
+    that:
+      - output_lab.changed == False
+      - output_lab.labs[0]['id'] != None
+      - output_lab.labs[0]['resource_group'] != None
+      - output_lab.labs[0]['name'] != None
+      - output_lab.labs[0]['location'] != None
+      - output_lab.labs[0]['storage_type'] != None
+      - output_lab.labs[0]['premium_data_disks'] != None
+      - output_lab.labs[0]['provisioning_state'] != None
+      - output_lab.labs[0]['vault_name'] != None
+
 - name: Get DevTest Lab facts
   azure_rm_devtestlab_facts:
     resource_group: "{{ resource_group }}"
     name: "{{ lab_name }}"
-  register: output
+  register: output_lab
 - name: Assert that facts are returned
   assert:
     that:
-      - output.changed == False
-      - output.labs[0]['id'] != None
-      - output.labs[0]['resource_group'] != None
-      - output.labs[0]['name'] != None
-      - output.labs[0]['location'] != None
-      - output.labs[0]['storage_type'] != None
-      - output.labs[0]['premium_data_disks'] != None
-      - output.labs[0]['provisioning_state'] != None
-      - output.labs[0]['artifacts_storage_account'] != None
-      - output.labs[0]['default_premium_storage_account'] != None
-      - output.labs[0]['default_storage_account'] != None
-      - output.labs[0]['premium_data_disk_storage_account'] != None
-      - output.labs[0]['vault_name'] != None
+      - output_lab.changed == False
+      - output_lab.labs[0]['id'] != None
+      - output_lab.labs[0]['resource_group'] != None
+      - output_lab.labs[0]['name'] != None
+      - output_lab.labs[0]['location'] != None
+      - output_lab.labs[0]['storage_type'] != None
+      - output_lab.labs[0]['premium_data_disks'] != None
+      - output_lab.labs[0]['provisioning_state'] != None
+      - output_lab.labs[0]['artifacts_storage_account'] != None
+      - output_lab.labs[0]['default_premium_storage_account'] != None
+      - output_lab.labs[0]['default_storage_account'] != None
+      - output_lab.labs[0]['premium_data_disk_storage_account'] != None
+      - output_lab.labs[0]['vault_name'] != None
+
+# azure_rm_devtestlabpolicy
+- name: Create instance of DevTest Lab Policy
+  azure_rm_devtestlabpolicy:
+    resource_group: "{{ resource_group }}"
+    lab_name: "{{ lab_name }}"
+    policy_set_name: myDtlPolicySet
+    name: myDtlPolicy
+    fact_name: user_owned_lab_vm_count
+    threshold: 5
+  register: output
+- debug:
+    var: output
+- name: Assert if the change was correctly reported
+  assert:
+    that:
+      - output.changed
 
-- name: List DevTest Lab in a resource group
-  azure_rm_devtestlab_facts:
+- name: Create instance of DevTest Lab Policy -- idempotent
+  azure_rm_devtestlabpolicy:
     resource_group: "{{ resource_group }}"
+    lab_name: "{{ lab_name }}"
+    policy_set_name: myDtlPolicySet
+    name: myDtlPolicy
+    fact_name: user_owned_lab_vm_count
+    threshold: 5
   register: output
-- name: Assert that facts are returned
+- debug:
+    var: output
+- name: Assert if the change was not reported
   assert:
     that:
-      - output.changed == False
-      - output.labs[0]['id'] != None
-      - output.labs[0]['resource_group'] != None
-      - output.labs[0]['name'] != None
-      - output.labs[0]['location'] != None
-      - output.labs[0]['storage_type'] != None
-      - output.labs[0]['premium_data_disks'] != None
-      - output.labs[0]['provisioning_state'] != None
-      - output.labs[0]['vault_name'] != None
+      - not output.changed
+
+- name: Create instance of DevTest Lab Policy -- change value
+  azure_rm_devtestlabpolicy:
+    resource_group: "{{ resource_group }}"
+    lab_name: "{{ lab_name }}"
+    policy_set_name: myDtlPolicySet
+    name: myDtlPolicy
+    fact_name: user_owned_lab_vm_count
+    threshold: 6
+  register: output
+- debug:
+    var: output
+- name: Assert if the change was correctly reported
+  assert:
+    that:
+      - output.changed
+
+- name: Delete instance of DevTest Lab Policy
+  azure_rm_devtestlabpolicy:
+    resource_group: "{{ resource_group }}"
+    lab_name: "{{ lab_name }}"
+    policy_set_name: myDtlPolicySet
+    name: myDtlPolicy
+    state: absent
+  register: output
+- debug:
+    var: output
+- name: Assert if the change was correctly reported
+  assert:
+    that:
+      - output.changed
+
+# azure_rm_devtestlabschedule
+- name: Create instance of DevTest Lab Schedule
+  azure_rm_devtestlabschedule:
+    resource_group: "{{ resource_group }}"
+    lab_name: "{{ lab_name }}"
+    name: lab_vms_shutdown
+    time: "1030"
+    time_zone_id: "UTC+12"
+  register: output
+- debug:
+    var: output
+- name: Assert if the change was correctly reported
+  assert:
+    that:
+      - output.changed
+
+- name: Update instance of DevTest Lab Schedule -- idempotent
+  azure_rm_devtestlabschedule:
+    resource_group: "{{ resource_group }}"
+    lab_name: "{{ lab_name }}"
+    name: lab_vms_shutdown
+    time: "1030"
+    time_zone_id: "UTC+12"
+  register: output
+- debug:
+    var: output
+- name: Assert if the change was correctly reported
+  assert:
+    that:
+      - not output.changed
+
+- name: Update instance of DevTest Lab Schedule -- change time
+  azure_rm_devtestlabschedule:
+    resource_group: "{{ resource_group }}"
+    lab_name: "{{ lab_name }}"
+    name: lab_vms_shutdown
+    time: "1130"
+    time_zone_id: "UTC+12"
+  register: output
+- debug:
+    var: output
+- name: Assert if the change was correctly reported
+  assert:
+    that:
+      - output.changed
+
+- name: Delete instance of DevTest Lab Schedule
+  azure_rm_devtestlabschedule:
+    resource_group: "{{ resource_group }}"
+    lab_name: "{{ lab_name }}"
+    name: lab_vms_shutdown
+    state: absent
+  register: output
+- debug:
+    var: output
+- name: Assert if the change was correctly reported
+  assert:
+    that:
+      - output.changed
 
 - name: Create instance of DevTest Labs virtual network
   azure_rm_devtestlabvirtualnetwork:
@@ -261,11 +385,13 @@
     allow_claim: no
     expiration_date: "2029-02-22T01:49:12.117974Z"
   register: output
+  when: "github_token | length > 0"
 
 - name: Assert that change was registered
   assert:
     that:
       - output.changed
+  when: "github_token | length > 0"
 
 - name: Update instance of DTL Virtual Machine with same parameters
   azure_rm_devtestlabvirtualmachine:
@@ -291,11 +417,13 @@
     allow_claim: no
     expiration_date: "2029-02-22T01:49:12.117974Z"
   register: output
+  when: "github_token | length > 0"
 
 - name: Assert that nothing has changed
   assert:
     that:
       - output.changed == false
+  when: "github_token | length > 0"
 
 - name: Update instance of DTL Virtual Machine - change notes
   azure_rm_devtestlabvirtualmachine:
@@ -321,66 +449,70 @@
     allow_claim: no
     expiration_date: "2029-02-22T01:49:12.117974Z"
   register: output
+  when: "github_token | length > 0"
 
 - name: Assert that change was registered
   assert:
     that:
       - output.changed
+  when: "github_token | length > 0"
 
 - name: Get Facts of DTL Virtual Machine
   azure_rm_devtestlabvirtualmachine_facts:
     resource_group: "{{ resource_group }}"
     lab_name: "{{ lab_name }}"
     name: "{{ vm_name }}"
-  register: output
+  register: output_vm
 - name: Assert that facts are returned
   assert:
     that:
-      - output.changed == False
-      - output.virtualmachines[0]['id'] != None
-      - output.virtualmachines[0]['resource_group'] != None
-      - output.virtualmachines[0]['lab_name'] != None
-      - output.virtualmachines[0]['name'] != None
-      - output.virtualmachines[0]['compute_vm_id'] != None
-      - output.virtualmachines[0]['compute_vm_resource_group'] != None
-      - output.virtualmachines[0]['compute_vm_name'] != None
-      - output.virtualmachines[0]['disallow_public_ip_address'] != None
-      - output.virtualmachines[0]['expiration_date'] != None
-      - output.virtualmachines[0]['fqdn'] != None
-      - output.virtualmachines[0]['id'] != None
-      - output.virtualmachines[0]['image'] != None
-      - output.virtualmachines[0]['notes'] != None
-      - output.virtualmachines[0]['os_type'] != None
-      - output.virtualmachines[0]['provisioning_state'] != None
-      - output.virtualmachines[0]['storage_type'] != None
-      - output.virtualmachines[0]['user_name'] != None
-      - output.virtualmachines[0]['vm_size'] != None
+      - output_vm.changed == False
+      - output_vm.virtualmachines[0]['id'] != None
+      - output_vm.virtualmachines[0]['resource_group'] != None
+      - output_vm.virtualmachines[0]['lab_name'] != None
+      - output_vm.virtualmachines[0]['name'] != None
+      - output_vm.virtualmachines[0]['compute_vm_id'] != None
+      - output_vm.virtualmachines[0]['compute_vm_resource_group'] != None
+      - output_vm.virtualmachines[0]['compute_vm_name'] != None
+      - output_vm.virtualmachines[0]['disallow_public_ip_address'] != None
+      - output_vm.virtualmachines[0]['expiration_date'] != None
+      - output_vm.virtualmachines[0]['fqdn'] != None
+      - output_vm.virtualmachines[0]['id'] != None
+      - output_vm.virtualmachines[0]['image'] != None
+      - output_vm.virtualmachines[0]['notes'] != None
+      - output_vm.virtualmachines[0]['os_type'] != None
+      - output_vm.virtualmachines[0]['provisioning_state'] != None
+      - output_vm.virtualmachines[0]['storage_type'] != None
+      - output_vm.virtualmachines[0]['user_name'] != None
+      - output_vm.virtualmachines[0]['vm_size'] != None
+  when: "github_token | length > 0"
 
 - name: List Facts of DTL Virtual Machine
   azure_rm_devtestlabvirtualmachine_facts:
     resource_group: "{{ resource_group }}"
     lab_name: "{{ lab_name }}"
-  register: output
+  register: output_vm
 - name: Assert that facts are returned
   assert:
     that:
-      - output.changed == False
-      - output.virtualmachines[0]['id'] != None
-      - output.virtualmachines[0]['resource_group'] != None
-      - output.virtualmachines[0]['lab_name'] != None
-      - output.virtualmachines[0]['name'] != None
-      - output.virtualmachines[0]['compute_vm_id'] != None
-      - output.virtualmachines[0]['disallow_public_ip_address'] != None
-      - output.virtualmachines[0]['expiration_date'] != None
-      - output.virtualmachines[0]['fqdn'] != None
-      - output.virtualmachines[0]['id'] != None
-      - output.virtualmachines[0]['image'] != None
-      - output.virtualmachines[0]['notes'] != None
-      - output.virtualmachines[0]['os_type'] != None
-      - output.virtualmachines[0]['provisioning_state'] != None
-      - output.virtualmachines[0]['storage_type'] != None
-      - output.virtualmachines[0]['user_name'] != None
-      - output.virtualmachines[0]['vm_size'] != None
+      - output_vm.changed == False
+      - output_vm.virtualmachines[0]['id'] != None
+      - output_vm.virtualmachines[0]['resource_group'] != None
+      - output_vm.virtualmachines[0]['lab_name'] != None
+      - output_vm.virtualmachines[0]['name'] != None
+      - output_vm.virtualmachines[0]['compute_vm_id'] != None
+      - output_vm.virtualmachines[0]['disallow_public_ip_address'] != None
+      - output_vm.virtualmachines[0]['expiration_date'] != None
+      - output_vm.virtualmachines[0]['fqdn'] != None
+      - output_vm.virtualmachines[0]['id'] != None
+      - output_vm.virtualmachines[0]['image'] != None
+      - output_vm.virtualmachines[0]['notes'] != None
+      - output_vm.virtualmachines[0]['os_type'] != None
+      - output_vm.virtualmachines[0]['provisioning_state'] != None
+      - output_vm.virtualmachines[0]['storage_type'] != None
+      - output_vm.virtualmachines[0]['user_name'] != None
+      - output_vm.virtualmachines[0]['vm_size'] != None
+  when: "github_token | length > 0"
 
 
 - name: List all artifact sources
@@ -525,6 +657,80 @@
       - output.artifacts[0]['publisher'] != None
       - "output.artifacts | length == 1"
 
+- name: Create instance of DevTest Lab Environment
+  azure_rm_devtestlabenvironment:
+    resource_group: "{{ resource_group }}"
+    lab_name: "{{ lab_name }}"
+    user_name: zim
+    name: myEnvironment
+    location: eastus
+    deployment_template: "{{ output_lab.labs[0].id }}/artifactSources/public environment repo/armTemplates/WebApp"
+  register: output
+- name: Assert if the change was correctly reported
+  assert:
+    that:
+      - output.changed
+  when: "github_token | length > 0"
+
+- name: Create instance of DevTest Lab Environment - idempotent
+  azure_rm_devtestlabenvironment:
+    resource_group: "{{ resource_group }}"
+    lab_name: "{{ lab_name }}"
+    user_name: zim
+    name: myEnvironment
+    location: eastus
+    deployment_template:
+      artifact_source_name: public environment repo
+      name: WebApp
+  register: output
+- name: Assert if the change was not detected
+  assert:
+    that:
+      - not output.changed
+  when: "github_token | length > 0"
+
+- name: Delete instance of DevTest Lab Environment
+  azure_rm_devtestlabenvironment:
+    resource_group: "{{ resource_group }}"
+    lab_name: "{{ lab_name }}"
+    user_name: zim
+    name: myEnvironment
+    state: absent
+  register: output
+- name: Assert that change was detected
+  assert:
+    that:
+      - output.changed
+  when: "github_token | length > 0"
+
+- name: Create instance of DevTest Lab Image
+  azure_rm_devtestlabcustomimage:
+    resource_group: "{{ resource_group }}"
+    lab_name: "{{ lab_name }}"
+    name: myImage
+    source_vm: "{{ output_vm.virtualmachines[0]['name'] }}"
+    linux_os_state: non_deprovisioned
+  register: output
+- name: Assert that change was detected
+  assert:
+    that:
+      - output.changed
+  when: "github_token | length > 0"
+  
+- name: Create instance of DevTest Lab Image -- idempotent
+  azure_rm_devtestlabcustomimage:
+    resource_group: "{{ resource_group }}"
+    lab_name: "{{ lab_name }}"
+    name: myImage
+    source_vm: "{{ output_vm.virtualmachines[0]['name'] }}"
+    linux_os_state: non_deprovisioned
+  register: output
+- name: Assert that change was detected
+  assert:
+    that:
+      - not output.changed
+  when: "github_token | length > 0"
+
 - name: Delete instance of Lab -- check mode
   azure_rm_devtestlab:
     resource_group: "{{ resource_group }}"

commit a199c9b04fd12a54c46e8e3576a68f1bd37a624b
Author: markusbloch <34344724+markusbloch@users.noreply.github.com>
Date:   Sat May 12 10:58:12 2018 +0200

    add state parameter to patch module (#33692)
    
    * add state parameter to patch module
    
    * add "version_added" to state parameter docu
    
    * fix state parameter call
    
    * change version_added to 2.6

diff --git a/lib/ansible/modules/files/patch.py b/lib/ansible/modules/files/patch.py
index 42a4cade4c..e1534ef257 100644
--- a/lib/ansible/modules/files/patch.py
+++ b/lib/ansible/modules/files/patch.py
@@ -42,6 +42,12 @@ options:
         module's I(files) directory.
     required: true
     aliases: [ patchfile ]
+  state:
+    version_added: "2.6"
+    description:
+      - Whether the patch should be applied or reverted.
+    choices: [ absent, present ]
+    default: present
   remote_src:
     description:
       - If C(no), it will search for src at originating/master machine, if C(yes) it will
@@ -84,6 +90,12 @@ EXAMPLES = r'''
     src: /tmp/customize.patch
     basedir: /var/www
     strip: 1
+
+- name: Revert patch to one file
+  patch:
+    src: /tmp/index.html.patch
+    dest: /var/www/index.html
+    state: absent
 '''
 
 import os
@@ -96,20 +108,22 @@ class PatchError(Exception):
     pass
 
 
-def is_already_applied(patch_func, patch_file, basedir, dest_file=None, binary=False, strip=0):
-    opts = ['--quiet', '--reverse', '--forward', '--dry-run',
+def is_already_applied(patch_func, patch_file, basedir, dest_file=None, binary=False, strip=0, state='present'):
+    opts = ['--quiet', '--forward', '--dry-run',
             "--strip=%s" % strip, "--directory='%s'" % basedir,
             "--input='%s'" % patch_file]
     if binary:
         opts.append('--binary')
     if dest_file:
         opts.append("'%s'" % dest_file)
+    if state == 'present':
+        opts.append('--reverse')
 
     (rc, _, _) = patch_func(opts)
     return rc == 0
 
 
-def apply_patch(patch_func, patch_file, basedir, dest_file=None, binary=False, strip=0, dry_run=False, backup=False):
+def apply_patch(patch_func, patch_file, basedir, dest_file=None, binary=False, strip=0, dry_run=False, backup=False, state='present'):
     opts = ['--quiet', '--forward', '--batch', '--reject-file=-',
             "--strip=%s" % strip, "--directory='%s'" % basedir,
             "--input='%s'" % patch_file]
@@ -121,6 +135,8 @@ def apply_patch(patch_func, patch_file, basedir, dest_file=None, binary=False, s
         opts.append("'%s'" % dest_file)
     if backup:
         opts.append('--backup --version-control=numbered')
+    if state == 'absent':
+        opts.append('--reverse')
 
     (rc, out, err) = patch_func(opts)
     if rc != 0:
@@ -140,6 +156,7 @@ def main():
             #     since patch will create numbered copies, not strftime("%Y-%m-%d@%H:%M:%S~")
             backup=dict(type='bool', default=False),
             binary=dict(type='bool', default=False),
+            state=dict(type='str', default='present', choices=['absent', 'present']),
         ),
         required_one_of=[['dest', 'basedir']],
         supports_check_mode=True,
@@ -171,10 +188,10 @@ def main():
     p.src = os.path.abspath(p.src)
 
     changed = False
-    if not is_already_applied(patch_func, p.src, p.basedir, dest_file=p.dest, binary=p.binary, strip=p.strip):
+    if not is_already_applied(patch_func, p.src, p.basedir, dest_file=p.dest, binary=p.binary, strip=p.strip, state=p.state):
         try:
             apply_patch(patch_func, p.src, p.basedir, dest_file=p.dest, binary=p.binary, strip=p.strip,
-                        dry_run=module.check_mode, backup=p.backup)
+                        dry_run=module.check_mode, backup=p.backup, state=p.state)
             changed = True
         except PatchError as e:
             module.fail_json(msg=to_native(e), exception=format_exc())

commit f8e4aff4c19650176201ddba61274e830115a0db
Author: Toshio Kuratomi <a.badger@gmail.com>
Date:   Thu Jul 23 12:11:10 2015 -0700

    Cleanups:
    
    * Don't reference __class__ when we can use the instance itself
    * use isdisjoint() as it can stop once a match is found
    * Remove a condtional that was taken care of in the conditonal just above

diff --git a/lib/ansible/playbook/taggable.py b/lib/ansible/playbook/taggable.py
index 1e9c6e82bf..1f55f95a2e 100644
--- a/lib/ansible/playbook/taggable.py
+++ b/lib/ansible/playbook/taggable.py
@@ -28,7 +28,7 @@ from ansible.template import Templar
 
 class Taggable:
 
-    untagged = set(['untagged'])
+    untagged = frozenset(['untagged'])
     _tags = FieldAttribute(isa='list', default=[], listof=(string_types,int))
 
     def __init__(self):
@@ -70,8 +70,8 @@ class Taggable:
             else:
                 tags = set([i for i,_ in itertools.groupby(tags)])
         else:
-            # this makes intersection work for untagged
-            tags = self.__class__.untagged
+            # this makes isdisjoint work for untagged
+            tags = self.untagged
 
         if only_tags:
 
@@ -79,9 +79,9 @@ class Taggable:
 
             if 'always' in tags or 'all' in only_tags:
                  should_run = True
-            elif tags.intersection(only_tags):
+            elif not tags.isdisjoint(only_tags):
                 should_run = True
-            elif 'tagged' in only_tags and tags != self.__class__.untagged:
+            elif 'tagged' in only_tags and tags != self.untagged:
                 should_run = True
 
         if should_run and skip_tags:
@@ -90,9 +90,9 @@ class Taggable:
             if 'all' in skip_tags:
                 if 'always' not in tags or 'always' in skip_tags:
                     should_run = False
-            elif tags.intersection(skip_tags):
+            elif not tags.isdisjoint(skip_tags):
                 should_run = False
-            elif 'tagged' in skip_tags and tags != self.__class__.untagged:
+            elif 'tagged' in skip_tags and tags != self.untagged:
                 should_run = False
 
         return should_run
diff --git a/lib/ansible/plugins/action/__init__.py b/lib/ansible/plugins/action/__init__.py
index feca808d25..51b5ceb338 100644
--- a/lib/ansible/plugins/action/__init__.py
+++ b/lib/ansible/plugins/action/__init__.py
@@ -118,10 +118,7 @@ class ActionBase:
         if tmp and "tmp" in tmp:
             # tmp has already been created
             return False
-        if not self._connection.__class__.has_pipelining or not C.ANSIBLE_SSH_PIPELINING or C.DEFAULT_KEEP_REMOTE_FILES or self._play_context.become:
-            # tmp is necessary to store module source code
-            return True
-        if not self._connection.__class__.has_pipelining:
+        if not self._connection.has_pipelining or not C.ANSIBLE_SSH_PIPELINING or C.DEFAULT_KEEP_REMOTE_FILES or self._play_context.become:
             # tmp is necessary to store the module source code
             # or we want to keep the files on the target system
             return True
@@ -363,7 +360,7 @@ class ActionBase:
         # FIXME: all of the old-module style and async stuff has been removed from here, and
         #        might need to be re-added (unless we decide to drop support for old-style modules
         #        at this point and rework things to support non-python modules specifically)
-        if self._connection.__class__.has_pipelining and C.ANSIBLE_SSH_PIPELINING and not C.DEFAULT_KEEP_REMOTE_FILES:
+        if self._connection.has_pipelining and C.ANSIBLE_SSH_PIPELINING and not C.DEFAULT_KEEP_REMOTE_FILES:
             in_data = module_data
         else:
             if remote_module_path:
diff --git a/lib/ansible/plugins/connections/__init__.py b/lib/ansible/plugins/connections/__init__.py
index af86c5fec6..1ad2876381 100644
--- a/lib/ansible/plugins/connections/__init__.py
+++ b/lib/ansible/plugins/connections/__init__.py
@@ -87,7 +87,7 @@ class ConnectionBase(with_metaclass(ABCMeta, object)):
     def _become_method_supported(self):
         ''' Checks if the current class supports this privilege escalation method '''
 
-        if self._play_context.become_method in self.__class__.become_methods:
+        if self._play_context.become_method in self.become_methods:
             return True
 
         raise AnsibleError("Internal Error: this connection module does not support running commands via %s" % become_method)

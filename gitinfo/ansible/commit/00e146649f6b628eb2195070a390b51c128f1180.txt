commit 00e146649f6b628eb2195070a390b51c128f1180
Author: Quentin Stafford-Fraser <quentin@pobox.com>
Date:   Sun May 3 20:58:21 2015 +0100

    Add webfaction modules

diff --git a/lib/ansible/modules/extras/cloud/webfaction/__init__.py b/lib/ansible/modules/extras/cloud/webfaction/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/lib/ansible/modules/extras/cloud/webfaction/webfaction_app.py b/lib/ansible/modules/extras/cloud/webfaction/webfaction_app.py
new file mode 100644
index 0000000000..b1ddcd5a9c
--- /dev/null
+++ b/lib/ansible/modules/extras/cloud/webfaction/webfaction_app.py
@@ -0,0 +1,153 @@
+#! /usr/bin/python
+# Create a Webfaction application using Ansible and the Webfaction API
+#
+# Valid application types can be found by looking here:
+# http://docs.webfaction.com/xmlrpc-api/apps.html#application-types
+#
+# Quentin Stafford-Fraser 2015
+
+DOCUMENTATION = '''
+---
+module: webfaction_app
+short_description: Add or remove applications on a Webfaction host
+description:
+    - Add or remove applications on a Webfaction host.  Further documentation at http://github.com/quentinsf/ansible-webfaction.
+author: Quentin Stafford-Fraser
+version_added: 1.99
+notes:
+    - "You can run playbooks that use this on a local machine, or on a Webfaction host, or elsewhere, since the scripts use the remote webfaction API - the location is not important. However, running them on multiple hosts I(simultaneously) is best avoided. If you don't specify I(localhost) as your host, you may want to add C(serial: 1) to the plays."
+    - See `the webfaction API <http://docs.webfaction.com/xmlrpc-api/>`_ for more info.
+
+options:
+    name:
+        description:
+            - The name of the application
+        required: true
+        default: null
+
+    state:
+        description:
+            - Whether the application should exist
+        required: false
+        choices: ['present', 'absent']
+        default: "present"
+
+    type:
+        description:
+            - The type of application to create. See the Webfaction docs at http://docs.webfaction.com/xmlrpc-api/apps.html for a list.
+        required: true
+
+    autostart:
+        description:
+            - Whether the app should restart with an autostart.cgi script
+        required: false
+        default: "no"
+
+    extra_info:
+        description:
+            - Any extra parameters required by the app
+        required: false
+        default: null
+
+    open_port:
+        required: false
+        default: false
+
+    login_name:
+        description:
+            - The webfaction account to use
+        required: true
+
+    login_password:
+        description:
+            - The webfaction password to use
+        required: true
+'''
+
+import xmlrpclib
+from ansible.module_utils.basic import *
+
+webfaction = xmlrpclib.ServerProxy('https://api.webfaction.com/')
+
+def main():
+
+    module = AnsibleModule(
+        argument_spec = dict(
+            name = dict(required=True, default=None),
+            state = dict(required=False, default='present'),
+            type = dict(required=True),
+            autostart = dict(required=False, choices=BOOLEANS, default='false'),
+            extra_info = dict(required=False, default=""),
+            port_open = dict(required=False, default="false"),
+            login_name = dict(required=True),
+            login_password = dict(required=True),
+        ),
+        supports_check_mode=True
+    )
+    app_name  = module.params['name']
+    app_type = module.params['type']
+    app_state = module.params['state']
+
+    session_id, account = webfaction.login(
+        module.params['login_name'],
+        module.params['login_password']
+    )
+
+    app_list = webfaction.list_apps(session_id)
+    app_map = dict([(i['name'], i) for i in app_list])
+    existing_app = app_map.get(app_name)
+
+    result = {}
+    
+    # Here's where the real stuff happens
+
+    if app_state == 'present':
+
+        # Does an app with this name already exist?
+        if existing_app:
+            if existing_app['type'] != app_type:
+                module.fail_json(msg="App already exists with different type. Please fix by hand.")
+
+            # If it exists with the right type, we don't change it
+            # Should check other parameters.
+            module.exit_json(
+                changed = False,
+            )
+
+        if not module.check_mode:
+            # If this isn't a dry run, create the app
+            result.update(
+                webfaction.create_app(
+                    session_id, app_name, app_type, 
+                    module.boolean(module.params['autostart']), 
+                    module.params['extra_info'],
+                    module.boolean(module.params['port_open'])
+                )
+            )
+
+    elif app_state == 'absent':
+
+        # If the app's already not there, nothing changed.
+        if not existing_app:
+            module.exit_json(
+                changed = False,
+            )
+
+        if not module.check_mode:
+            # If this isn't a dry run, delete the app
+            result.update(
+                webfaction.delete_app(session_id, app_name)
+            )
+
+    else:
+        module.fail_json(msg="Unknown state specified: {}".format(app_state))
+
+
+    module.exit_json(
+        changed = True,
+        result = result
+    )
+
+# The conventional ending
+main()
+
diff --git a/lib/ansible/modules/extras/cloud/webfaction/webfaction_db.py b/lib/ansible/modules/extras/cloud/webfaction/webfaction_db.py
new file mode 100644
index 0000000000..7205a084ef
--- /dev/null
+++ b/lib/ansible/modules/extras/cloud/webfaction/webfaction_db.py
@@ -0,0 +1,147 @@
+#! /usr/bin/python
+# Create webfaction database using Ansible and the Webfaction API
+#
+# Quentin Stafford-Fraser 2015
+
+DOCUMENTATION = '''
+---
+module: webfaction_db
+short_description: Add or remove a database on Webfaction
+description:
+    - Add or remove a database on a Webfaction host. Further documentation at http://github.com/quentinsf/ansible-webfaction.
+author: Quentin Stafford-Fraser
+version_added: 1.99
+notes:
+    - "You can run playbooks that use this on a local machine, or on a Webfaction host, or elsewhere, since the scripts use the remote webfaction API - the location is not important. However, running them on multiple hosts I(simultaneously) is best avoided. If you don't specify I(localhost) as your host, you may want to add C(serial: 1) to the plays."
+    - See `the webfaction API <http://docs.webfaction.com/xmlrpc-api/>`_ for more info.
+options:
+
+    name:
+        description:
+            - The name of the database
+        required: true
+        default: null
+
+    state:
+        description:
+            - Whether the database should exist
+        required: false
+        choices: ['present', 'absent']
+        default: "present"
+
+    type:
+        description:
+            - The type of database to create.
+        required: true
+        choices: ['mysql', 'postgresql']
+
+    login_name:
+        description:
+            - The webfaction account to use
+        required: true
+
+    login_password:
+        description:
+            - The webfaction password to use
+        required: true
+'''
+
+EXAMPLES = '''
+  # This will also create a default DB user with the same
+  # name as the database, and the specified password.
+  
+  - name: Create a database
+    webfaction_db:
+      name: "{{webfaction_user}}_db1"
+      password: mytestsql
+      type: mysql
+      login_name: "{{webfaction_user}}"
+      login_password: "{{webfaction_passwd}}"
+'''
+
+import socket
+import xmlrpclib
+from ansible.module_utils.basic import *
+
+webfaction = xmlrpclib.ServerProxy('https://api.webfaction.com/')
+
+def main():
+
+    module = AnsibleModule(
+        argument_spec = dict(
+            name = dict(required=True, default=None),
+            state = dict(required=False, default='present'),
+            # You can specify an IP address or hostname.
+            type = dict(required=True, default=None),
+            password = dict(required=False, default=None),
+            login_name = dict(required=True),
+            login_password = dict(required=True),
+        ),
+        supports_check_mode=True
+    )
+    db_name  = module.params['name']
+    db_state = module.params['state']
+    db_type  = module.params['type']
+    db_passwd = module.params['password']
+
+    session_id, account = webfaction.login(
+        module.params['login_name'],
+        module.params['login_password']
+    )
+
+    db_list = webfaction.list_dbs(session_id)
+    db_map = dict([(i['name'], i) for i in db_list])
+    existing_db = db_map.get(db_name)
+
+    result = {}
+    
+    # Here's where the real stuff happens
+
+    if db_state == 'present':
+
+        # Does an app with this name already exist?
+        if existing_db:
+            # Yes, but of a different type - fail
+            if existing_db['db_type'] != db_type:
+                module.fail_json(msg="Database already exists but is a different type. Please fix by hand.")
+
+            # If it exists with the right type, we don't change anything.
+            module.exit_json(
+                changed = False,
+            )
+
+
+        if not module.check_mode:
+            # If this isn't a dry run, create the app
+            # print positional_args
+            result.update(
+                webfaction.create_db(
+                    session_id, db_name, db_type, db_passwd
+                )
+            )
+
+    elif db_state == 'absent':
+
+        # If the app's already not there, nothing changed.
+        if not existing_db:
+            module.exit_json(
+                changed = False,
+            )
+
+        if not module.check_mode:
+            # If this isn't a dry run, delete the app
+            result.update(
+                webfaction.delete_db(session_id, db_name, db_type)
+            )
+
+    else:
+        module.fail_json(msg="Unknown state specified: {}".format(db_state))
+
+    module.exit_json(
+        changed = True,
+        result = result
+    )
+
+# The conventional ending
+main()
+
diff --git a/lib/ansible/modules/extras/cloud/webfaction/webfaction_domain.py b/lib/ansible/modules/extras/cloud/webfaction/webfaction_domain.py
new file mode 100644
index 0000000000..2f3c854275
--- /dev/null
+++ b/lib/ansible/modules/extras/cloud/webfaction/webfaction_domain.py
@@ -0,0 +1,134 @@
+#! /usr/bin/python
+# Create Webfaction domains and subdomains using Ansible and the Webfaction API
+#
+# Quentin Stafford-Fraser 2015
+
+DOCUMENTATION = '''
+---
+module: webfaction_domain
+short_description: Add or remove domains and subdomains on Webfaction
+description:
+    - Add or remove domains or subdomains on a Webfaction host. Further documentation at http://github.com/quentinsf/ansible-webfaction.
+author: Quentin Stafford-Fraser
+version_added: 1.99
+notes:
+    - If you are I(deleting) domains by using C(state=absent), then note that if you specify subdomains, just those particular subdomains will be deleted.  If you don't specify subdomains, the domain will be deleted.
+    - "You can run playbooks that use this on a local machine, or on a Webfaction host, or elsewhere, since the scripts use the remote webfaction API - the location is not important. However, running them on multiple hosts I(simultaneously) is best avoided. If you don't specify I(localhost) as your host, you may want to add C(serial: 1) to the plays."
+    - See `the webfaction API <http://docs.webfaction.com/xmlrpc-api/>`_ for more info.
+
+options:
+
+    name:
+        description:
+            - The name of the domain
+        required: true
+        default: null
+
+    state:
+        description:
+            - Whether the domain should exist
+        required: false
+        choices: ['present', 'absent']
+        default: "present"
+
+    subdomains:
+        description:
+            - Any subdomains to create.
+        required: false
+        default: null
+
+    login_name:
+        description:
+            - The webfaction account to use
+        required: true
+
+    login_password:
+        description:
+            - The webfaction password to use
+        required: true
+'''
+
+import socket
+import xmlrpclib
+from ansible.module_utils.basic import *
+
+webfaction = xmlrpclib.ServerProxy('https://api.webfaction.com/')
+
+def main():
+
+    module = AnsibleModule(
+        argument_spec = dict(
+            name = dict(required=True, default=None),
+            state = dict(required=False, default='present'),
+            subdomains = dict(required=False, default=[]),
+            login_name = dict(required=True),
+            login_password = dict(required=True),
+        ),
+        supports_check_mode=True
+    )
+    domain_name  = module.params['name']
+    domain_state = module.params['state']
+    domain_subdomains = module.params['subdomains']
+
+    session_id, account = webfaction.login(
+        module.params['login_name'],
+        module.params['login_password']
+    )
+
+    domain_list = webfaction.list_domains(session_id)
+    domain_map = dict([(i['domain'], i) for i in domain_list])
+    existing_domain = domain_map.get(domain_name)
+
+    result = {}
+    
+    # Here's where the real stuff happens
+
+    if domain_state == 'present':
+
+        # Does an app with this name already exist?
+        if existing_domain:
+
+            if set(existing_domain['subdomains']) >= set(domain_subdomains):
+                # If it exists with the right subdomains, we don't change anything.
+                module.exit_json(
+                    changed = False,
+                )
+
+        positional_args = [session_id, domain_name] + domain_subdomains
+
+        if not module.check_mode:
+            # If this isn't a dry run, create the app
+            # print positional_args
+            result.update(
+                webfaction.create_domain(
+                    *positional_args
+                )
+            )
+
+    elif domain_state == 'absent':
+
+        # If the app's already not there, nothing changed.
+        if not existing_domain:
+            module.exit_json(
+                changed = False,
+            )
+
+        positional_args = [session_id, domain_name] + domain_subdomains
+
+        if not module.check_mode:
+            # If this isn't a dry run, delete the app
+            result.update(
+                webfaction.delete_domain(*positional_args)
+            )
+
+    else:
+        module.fail_json(msg="Unknown state specified: {}".format(domain_state))
+
+    module.exit_json(
+        changed = True,
+        result = result
+    )
+
+# The conventional ending
+main()
+
diff --git a/lib/ansible/modules/extras/cloud/webfaction/webfaction_mailbox.py b/lib/ansible/modules/extras/cloud/webfaction/webfaction_mailbox.py
new file mode 100644
index 0000000000..3ac848d6a9
--- /dev/null
+++ b/lib/ansible/modules/extras/cloud/webfaction/webfaction_mailbox.py
@@ -0,0 +1,112 @@
+#! /usr/bin/python
+# Create webfaction mailbox using Ansible and the Webfaction API
+#
+# Quentin Stafford-Fraser and Andy Baker 2015
+
+DOCUMENTATION = '''
+---
+module: webfaction_mailbox
+short_description: Add or remove mailboxes on Webfaction
+description:
+    - Add or remove mailboxes on a Webfaction account. Further documentation at http://github.com/quentinsf/ansible-webfaction.
+author: Quentin Stafford-Fraser
+version_added: 1.99
+notes:
+    - "You can run playbooks that use this on a local machine, or on a Webfaction host, or elsewhere, since the scripts use the remote webfaction API - the location is not important. However, running them on multiple hosts I(simultaneously) is best avoided. If you don't specify I(localhost) as your host, you may want to add C(serial: 1) to the plays."
+    - See `the webfaction API <http://docs.webfaction.com/xmlrpc-api/>`_ for more info.
+options:
+
+    mailbox_name:
+        description:
+            - The name of the mailbox
+        required: true
+        default: null
+
+    mailbox_password:
+        description:
+            - The password for the mailbox
+        required: true
+        default: null
+
+    state:
+        description:
+            - Whether the mailbox should exist
+        required: false
+        choices: ['present', 'absent']
+        default: "present"
+
+    login_name:
+        description:
+            - The webfaction account to use
+        required: true
+
+    login_password:
+        description:
+            - The webfaction password to use
+        required: true
+'''
+
+import socket
+import xmlrpclib
+from ansible.module_utils.basic import *
+
+webfaction = xmlrpclib.ServerProxy('https://api.webfaction.com/')
+
+def main():
+
+    module = AnsibleModule(
+        argument_spec=dict(
+            mailbox_name=dict(required=True, default=None),
+            mailbox_password=dict(required=True),
+            state=dict(required=False, default='present'),
+            login_name=dict(required=True),
+            login_password=dict(required=True),
+        ),
+        supports_check_mode=True
+    )
+
+    mailbox_name = module.params['mailbox_name']
+    site_state = module.params['state']
+
+    session_id, account = webfaction.login(
+        module.params['login_name'],
+        module.params['login_password']
+    )
+
+    mailbox_list = webfaction.list_mailboxes(session_id)
+    existing_mailbox = mailbox_name in mailbox_list
+
+    result = {}
+    
+    # Here's where the real stuff happens
+
+    if site_state == 'present':
+
+        # Does a mailbox with this name already exist?
+        if existing_mailbox:
+            module.exit_json(changed=False,)
+
+        positional_args = [session_id, mailbox_name]
+
+        if not module.check_mode:
+            # If this isn't a dry run, create the mailbox
+            result.update(webfaction.create_mailbox(*positional_args))
+
+    elif site_state == 'absent':
+
+        # If the mailbox is already not there, nothing changed.
+        if not existing_mailbox:
+            module.exit_json(changed=False)
+
+        if not module.check_mode:
+            # If this isn't a dry run, delete the mailbox
+            result.update(webfaction.delete_mailbox(session_id, mailbox_name))
+
+    else:
+        module.fail_json(msg="Unknown state specified: {}".format(site_state))
+
+    module.exit_json(changed=True, result=result)
+
+# The conventional ending
+main()
+
diff --git a/lib/ansible/modules/extras/cloud/webfaction/webfaction_site.py b/lib/ansible/modules/extras/cloud/webfaction/webfaction_site.py
new file mode 100644
index 0000000000..5db8935596
--- /dev/null
+++ b/lib/ansible/modules/extras/cloud/webfaction/webfaction_site.py
@@ -0,0 +1,189 @@
+#! /usr/bin/python
+# Create Webfaction website using Ansible and the Webfaction API
+#
+# Quentin Stafford-Fraser 2015
+
+DOCUMENTATION = '''
+---
+module: webfaction_site
+short_description: Add or remove a website on a Webfaction host
+description:
+    - Add or remove a website on a Webfaction host.  Further documentation at http://github.com/quentinsf/ansible-webfaction.
+author: Quentin Stafford-Fraser
+version_added: 1.99
+notes:
+    - Sadly, you I(do) need to know your webfaction hostname for the C(host) parameter.  But at least, unlike the API, you don't need to know the IP address - you can use a DNS name.
+    - If a site of the same name exists in the account but on a different host, the operation will exit.
+    - "You can run playbooks that use this on a local machine, or on a Webfaction host, or elsewhere, since the scripts use the remote webfaction API - the location is not important. However, running them on multiple hosts I(simultaneously) is best avoided. If you don't specify I(localhost) as your host, you may want to add C(serial: 1) to the plays."
+    - See `the webfaction API <http://docs.webfaction.com/xmlrpc-api/>`_ for more info.
+
+options:
+
+    name:
+        description:
+            - The name of the website
+        required: true
+        default: null
+
+    state:
+        description:
+            - Whether the website should exist
+        required: false
+        choices: ['present', 'absent']
+        default: "present"
+            
+    host:
+        description:
+            - The webfaction host on which the site should be created.
+        required: true
+
+    https:
+        description:
+            - Whether or not to use HTTPS
+        required: false
+        choices: BOOLEANS 
+        default: 'false'
+
+    site_apps:
+        description:
+            - A mapping of URLs to apps
+        required: false
+
+    subdomains:
+        description:
+            - A list of subdomains associated with this site.
+        required: false
+        default: null
+
+    login_name:
+        description:
+            - The webfaction account to use
+        required: true
+
+    login_password:
+        description:
+            - The webfaction password to use
+        required: true
+'''
+
+EXAMPLES = '''
+  - name: create website
+    webfaction_site:
+      name: testsite1
+      state: present
+      host: myhost.webfaction.com 
+      subdomains: 
+        - 'testsite1.my_domain.org'
+      site_apps:
+        - ['testapp1', '/']
+      https: no
+      login_name: "{{webfaction_user}}"
+      login_password: "{{webfaction_passwd}}"
+'''
+
+import socket
+import xmlrpclib
+from ansible.module_utils.basic import *
+
+webfaction = xmlrpclib.ServerProxy('https://api.webfaction.com/')
+
+def main():
+
+    module = AnsibleModule(
+        argument_spec = dict(
+            name = dict(required=True, default=None),
+            state = dict(required=False, default='present'),
+            # You can specify an IP address or hostname.
+            host = dict(required=True, default=None),
+            https = dict(required=False, choices=BOOLEANS, default='false'),
+            subdomains = dict(required=False, default=[]),
+            site_apps = dict(required=False, default=[]),
+            login_name = dict(required=True),
+            login_password = dict(required=True),
+        ),
+        supports_check_mode=True
+    )
+    site_name  = module.params['name']
+    site_state = module.params['state']
+    site_host = module.params['host']
+    site_ip = socket.gethostbyname(site_host)
+
+    session_id, account = webfaction.login(
+        module.params['login_name'],
+        module.params['login_password']
+    )
+
+    site_list = webfaction.list_websites(session_id)
+    site_map = dict([(i['name'], i) for i in site_list])
+    existing_site = site_map.get(site_name)
+
+    result = {}
+    
+    # Here's where the real stuff happens
+
+    if site_state == 'present':
+
+        # Does a site with this name already exist?
+        if existing_site:
+
+            # If yes, but it's on a different IP address, then fail.
+            # If we wanted to allow relocation, we could add a 'relocate=true' option
+            # which would get the existing IP address, delete the site there, and create it
+            # at the new address.  A bit dangerous, perhaps, so for now we'll require manual
+            # deletion if it's on another host.
+
+            if existing_site['ip'] != site_ip:
+                module.fail_json(msg="Website already exists with a different IP address. Please fix by hand.")
+
+            # If it's on this host and the key parameters are the same, nothing needs to be done.
+
+            if (existing_site['https'] == module.boolean(module.params['https'])) and \
+               (set(existing_site['subdomains']) == set(module.params['subdomains'])) and \
+               (dict(existing_site['website_apps']) == dict(module.params['site_apps'])):
+                module.exit_json(
+                    changed = False
+                )
+
+        positional_args = [ 
+            session_id, site_name, site_ip, 
+            module.boolean(module.params['https']),
+            module.params['subdomains'],
+        ]
+        for a in module.params['site_apps']:
+            positional_args.append( (a[0], a[1]) )
+
+        if not module.check_mode:
+            # If this isn't a dry run, create or modify the site
+            result.update(
+                    webfaction.create_website(
+                        *positional_args
+                    ) if not existing_site else webfaction.update_website (
+                        *positional_args
+                    )
+            )
+
+    elif site_state == 'absent':
+
+        # If the site's already not there, nothing changed.
+        if not existing_site:
+            module.exit_json(
+                changed = False,
+            )
+
+        if not module.check_mode:
+            # If this isn't a dry run, delete the site
+            result.update(
+                webfaction.delete_website(session_id, site_name, site_ip)
+            )
+
+    else:
+        module.fail_json(msg="Unknown state specified: {}".format(site_state))
+
+    module.exit_json(
+        changed = True,
+        result = result
+    )
+
+# The conventional ending
+main()
+

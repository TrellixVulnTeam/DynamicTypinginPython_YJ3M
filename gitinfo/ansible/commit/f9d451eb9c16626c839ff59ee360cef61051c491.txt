commit f9d451eb9c16626c839ff59ee360cef61051c491
Author: James Cammarata <jimi@sngx.net>
Date:   Tue Jan 20 14:03:26 2015 -0600

    Adding post-validation method to connection info object

diff --git a/v2/ansible/executor/connection_info.py b/v2/ansible/executor/connection_info.py
index 19f027aaef..088dc41573 100644
--- a/v2/ansible/executor/connection_info.py
+++ b/v2/ansible/executor/connection_info.py
@@ -23,6 +23,7 @@ import pipes
 import random
 
 from ansible import constants as C
+from ansible.template import Templar
 
 
 __all__ = ['ConnectionInformation']
@@ -182,3 +183,16 @@ class ConnectionInformation:
         #return ('/bin/sh -c ' + pipes.quote(sudocmd), prompt, success_key)
         return (sudocmd, prompt, success_key)
 
+    def _get_fields(self):
+        return [i for i in self.__dict__.keys() if i[:1] != '_']
+
+    def post_validate(self, variables, loader):
+        '''
+        Finalizes templated values which may be set on this objects fields.
+        '''
+
+        templar = Templar(loader=loader, variables=variables)
+        for field in self._get_fields():
+            value = templar.template(getattr(self, field))
+            setattr(self, field, value)
+
diff --git a/v2/ansible/executor/task_executor.py b/v2/ansible/executor/task_executor.py
index 7c4cd9cdd8..677f95f1c4 100644
--- a/v2/ansible/executor/task_executor.py
+++ b/v2/ansible/executor/task_executor.py
@@ -167,15 +167,26 @@ class TaskExecutor:
         if variables is None:
             variables = self._job_vars
 
+        # fields set from the play/task may be based on variables, so we have to
+        # do the same kind of post validation step on it here before we use it
+        self._connection_info.post_validate(variables=variables, loader=self._loader)
+
+        # get the connection and the handler for this execution
         self._connection = self._get_connection()
         self._handler    = self._get_action_handler(connection=self._connection)
 
+        # Evaluate the conditional (if any) for this task, which we do before running
+        # the final task post-validation. We do this before the post validation due to
+        # the fact that the conditional may specify that the task be skipped due to a
+        # variable not being present which would otherwise cause validation to fail
         if not self._task.evaluate_conditional(variables):
             debug("when evaulation failed, skipping this task")
             return dict(changed=False, skipped=True, skip_reason='Conditional check failed')
 
+        # Now we do final validation on the task, which sets all fields to their final values
         self._task.post_validate(variables)
 
+        # Read some values from the task, so that we can modify them if need be
         retries = self._task.retries
         if retries <= 0:
             retries = 1
@@ -192,7 +203,7 @@ class TaskExecutor:
         result = None
         for attempt in range(retries):
             if attempt > 0:
-                # FIXME: this should use the callback mechanism
+                # FIXME: this should use the callback/message passing mechanism
                 print("FAILED - RETRYING: %s (%d retries left)" % (self._task, retries-attempt))
                 result['attempts'] = attempt + 1
 
diff --git a/v2/ansible/playbook/task_include.py b/v2/ansible/playbook/task_include.py
index c2bfb6fdae..f48fc2f72a 100644
--- a/v2/ansible/playbook/task_include.py
+++ b/v2/ansible/playbook/task_include.py
@@ -175,6 +175,8 @@ class TaskInclude(Base, Conditional, Taggable):
         all_vars = dict()
         if self._task_include:
             all_vars.update(self._task_include.get_vars())
+        if self._block:
+            all_vars.update(self._block.get_vars())
         all_vars.update(self.vars)
         return all_vars
 

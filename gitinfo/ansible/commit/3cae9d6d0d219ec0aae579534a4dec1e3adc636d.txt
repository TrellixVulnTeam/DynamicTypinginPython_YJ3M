commit 3cae9d6d0d219ec0aae579534a4dec1e3adc636d
Author: Benjamin Schwarze <benjamin.schwarze@mailboxd.de>
Date:   Thu May 30 22:50:37 2013 +0200

    use module.get_bin_path('git', True) once and pass git_path to functions

diff --git a/library/source_control/git b/library/source_control/git
index 1b4b733505..4343867655 100644
--- a/library/source_control/git
+++ b/library/source_control/git
@@ -85,15 +85,15 @@ examples:
 import re
 import tempfile
 
-def get_version(dest):
+def get_version(git_path, dest):
     ''' samples the version of the git repo '''
     os.chdir(dest)
-    cmd = "git show --abbrev-commit"
+    cmd = "%s show --abbrev-commit" % (git_path,)
     sha = os.popen(cmd).read().split("\n")
     sha = sha[0].split()[1]
     return sha
 
-def clone(module, repo, dest, remote, depth):
+def clone(git_path, module, repo, dest, remote, depth):
     ''' makes a new git repo if it does not already exist '''
     dest_dirname = os.path.dirname(dest)
     try:
@@ -101,39 +101,40 @@ def clone(module, repo, dest, remote, depth):
     except:
         pass
     os.chdir(dest_dirname)
-    cmd = [ module.get_bin_path('git', True), 'clone', '-o', remote ]
+    cmd = [ git_path, 'clone', '-o', remote ]
     if depth:
         cmd.extend([ '--depth', str(depth) ])
     cmd.extend([ repo, dest ])
     return module.run_command(cmd, check_rc=True)
 
-def has_local_mods(dest):
+def has_local_mods(git_path, dest):
     os.chdir(dest)
-    cmd = "git status -s"
+    cmd = "%s status -s" % (git_path,)
     lines = os.popen(cmd).read().splitlines()
     lines = filter(lambda c: not re.search('^\\?\\?.*$', c), lines)
     return len(lines) > 0
 
-def reset(module, dest, force):
+def reset(git_path, module, dest, force):
     '''
     Resets the index and working tree to HEAD.
     Discards any changes to tracked files in working
     tree since that commit.
     '''
     os.chdir(dest)
-    if not force and has_local_mods(dest):
+    if not force and has_local_mods(git_path, dest):
         module.fail_json(msg="Local modifications exist in repository (force=no).")
-    return module.run_command("git reset --hard HEAD", check_rc=True)
+    cmd = "%s reset --hard HEAD" % (git_path,)
+    return module.run_command(cmd, check_rc=True)
 
-def get_remote_head(module, dest, version, remote):
+def get_remote_head(git_path, module, dest, version, remote):
     cmd = ''
     os.chdir(dest)
     if version == 'HEAD':
-        version = get_head_branch(module, dest, remote)
-    if is_remote_branch(module, dest, remote, version):
-        cmd = 'git ls-remote %s -h refs/heads/%s' % (remote, version)
-    elif is_remote_tag(module, dest, remote, version):
-        cmd = 'git ls-remote %s -t refs/tags/%s' % (remote, version)
+        version = get_head_branch(git_path, module, dest, remote)
+    if is_remote_branch(git_path, module, dest, remote, version):
+        cmd = '%s ls-remote %s -h refs/heads/%s' % (git_path, remote, version)
+    elif is_remote_tag(git_path, module, dest, remote, version):
+        cmd = '%s ls-remote %s -t refs/tags/%s' % (git_path, remote, version)
     else:
         # appears to be a sha1.  return as-is since it appears
         # cannot check for a specific sha1 on remote
@@ -144,35 +145,36 @@ def get_remote_head(module, dest, version, remote):
     rev = out.split()[0]
     return rev
 
-def is_remote_tag(module, dest, remote, version):
+def is_remote_tag(git_path, module, dest, remote, version):
     os.chdir(dest)
-    cmd = 'git ls-remote %s -t refs/tags/%s' % (remote, version)
+    cmd = '%s ls-remote %s -t refs/tags/%s' % (git_path, remote, version)
     (rc, out, err) = module.run_command(cmd)
     if version in out:
         return True
     else:
         return False
 
-def get_branches(module, dest):
+def get_branches(git_path, module, dest):
     os.chdir(dest)
     branches = []
-    (rc, out, err) = module.run_command("git branch -a")
+    cmd = '%s branch -a' % (git_path,)
+    (rc, out, err) = module.run_command(cmd)
     if rc != 0:
         module.fail_json(msg="Could not determine branch data - received %s" % out)
     for line in out.split('\n'):
         branches.append(line.strip())
     return branches
 
-def is_remote_branch(module, dest, remote, branch):
-    branches = get_branches(module, dest)
+def is_remote_branch(git_path, module, dest, remote, branch):
+    branches = get_branches(git_path, module, dest)
     rbranch = 'remotes/%s/%s' % (remote, branch)
     if rbranch in branches:
         return True
     else:
         return False
 
-def is_local_branch(module, dest, branch):
-    branches = get_branches(module, dest)
+def is_local_branch(git_path, module, dest, branch):
+    branches = get_branches(git_path, module, dest)
     lbranch = '%s' % branch
     if lbranch in branches:
         return True
@@ -181,8 +183,8 @@ def is_local_branch(module, dest, branch):
     else:
         return False
 
-def is_current_branch(module, dest, branch):
-    branches = get_branches(module, dest)
+def is_current_branch(git_path, module, dest, branch):
+    branches = get_branches(git_path, module, dest)
     for b in branches:
         if b.startswith('* '):
             cur_branch = b
@@ -191,14 +193,14 @@ def is_current_branch(module, dest, branch):
     else:
         return True
 
-def is_not_a_branch(module, dest):
-    branches = get_branches(module, dest)
+def is_not_a_branch(git_path, module, dest):
+    branches = get_branches(git_path, module, dest)
     for b in branches:
         if b.startswith('* ') and 'no branch' in b:
             return True
     return False
 
-def get_head_branch(module, dest, remote):
+def get_head_branch(git_path, module, dest, remote):
     '''
     Determine what branch HEAD is associated with.  This is partly
     taken from lib/ansible/utils/__init__.py.  It finds the correct
@@ -222,46 +224,46 @@ def get_head_branch(module, dest, remote):
     # If we're in a detached HEAD state, look up the branch associated with
     # the remote HEAD in .git/refs/remotes/<remote>/HEAD
     f = open(os.path.join(repo_path, "HEAD"))
-    if is_not_a_branch(module, dest):
+    if is_not_a_branch(git_path, module, dest):
         f.close()
         f = open(os.path.join(repo_path, 'refs', 'remotes', remote, 'HEAD'))
     branch = f.readline().split('/')[-1].rstrip("\n")
     f.close()
     return branch
 
-def fetch(module, repo, dest, version, remote):
+def fetch(git_path, module, repo, dest, version, remote):
     ''' updates repo from remote sources '''
     os.chdir(dest)
-    (rc, out1, err1) = module.run_command("git fetch %s" % remote)
+    (rc, out1, err1) = module.run_command("%s fetch %s" % (git_path, remote))
     if rc != 0:
         module.fail_json(msg="Failed to download remote objects and refs")
 
-    (rc, out2, err2) = module.run_command("git fetch --tags %s" % remote)
+    (rc, out2, err2) = module.run_command("%s fetch --tags %s" % (git_path, remote))
     if rc != 0:
         module.fail_json(msg="Failed to download remote objects and refs")
     return (rc, out1 + out2, err1 + err2)
 
-def switch_version(module, dest, remote, version):
+def switch_version(git_path, module, dest, remote, version):
     ''' once pulled, switch to a particular SHA, tag, or branch '''
     os.chdir(dest)
     cmd = ''
     if version != 'HEAD':
-        if is_remote_branch(module, dest, remote, version):
-            if not is_local_branch(module, dest, version):
-                cmd = "git checkout --track -b %s %s/%s" % (version, remote, version)
+        if is_remote_branch(git_path, module, dest, remote, version):
+            if not is_local_branch(git_path, module, dest, version):
+                cmd = "%s checkout --track -b %s %s/%s" % (git_path, version, remote, version)
             else:
-                (rc, out, err) = module.run_command("git checkout --force %s" % version)
+                (rc, out, err) = module.run_command("%s checkout --force %s" % (git_path, version))
                 if rc != 0:
                     module.fail_json(msg="Failed to checkout branch %s" % version)
-                cmd = "git reset --hard %s/%s" % (remote, version)
+                cmd = "%s reset --hard %s/%s" % (git_path, remote, version)
         else:
-            cmd = "git checkout --force %s" % version
+            cmd = "%s checkout --force %s" % (git_path, version)
     else:
-        branch = get_head_branch(module, dest, remote)
-        (rc, out, err) = module.run_command("git checkout --force %s" % branch)
+        branch = get_head_branch(git_path, module, dest, remote)
+        (rc, out, err) = module.run_command("%s checkout --force %s" % (git_path, branch))
         if rc != 0:
             module.fail_json(msg="Failed to checkout branch %s" % branch)
-        cmd = "git reset --hard %s" % remote
+        cmd = "%s reset --hard %s" % (git_path, remote)
     return module.run_command(cmd, check_rc=True)
 
 # ===========================================
@@ -288,6 +290,7 @@ def main():
     depth   = module.params['depth']
     update  = module.params['update']
 
+    git_path = module.get_bin_path('git', True)
     gitconfig = os.path.join(dest, '.git', 'config')
 
     rc, out, err, status = (0, None, None, None)
@@ -299,31 +302,31 @@ def main():
     if not os.path.exists(gitconfig):
         if module.check_mode:
             module.exit_json(changed=True)
-        (rc, out, err) = clone(module, repo, dest, remote, depth)
+        (rc, out, err) = clone(git_path, module, repo, dest, remote, depth)
     elif not update:
         # Just return having found a repo already in the dest path
         # this does no checking that the repo is the actual repo
         # requested.
-        before = get_version(dest)
+        before = get_version(git_path, dest)
         module.exit_json(changed=False, before=before, after=before)
     else:
         # else do a pull
-        local_mods = has_local_mods(dest)
-        before = get_version(dest)
+        local_mods = has_local_mods(git_path, dest)
+        before = get_version(git_path, dest)
         # if force, do a reset
         if local_mods and module.check_mode:
             module.exit_json(changed=True, msg='Local modifications exist')
-        (rc, out, err) = reset(module,dest,force)
+        (rc, out, err) = reset(git_path, module, dest, force)
         if rc != 0:
             module.fail_json(msg=err)
         # check or get changes from remote
-        remote_head = get_remote_head(module, dest, version, remote)
+        remote_head = get_remote_head(git_path, module, dest, version, remote)
         if module.check_mode:
             changed = False
             if remote_head == version:
                 # get_remote_head returned version as-is
                 # were given a sha1 object, see if it is present
-                (rc, out, err) = module.run_command("git show %s" % version)
+                (rc, out, err) = module.run_command("%s show %s" % (git_path, version))
                 if version in out:
                     changed = False
                 else:
@@ -335,16 +338,16 @@ def main():
                 else:
                     changed = False
             module.exit_json(changed=changed, before=before, after=remote_head)
-        (rc, out, err) = fetch(module, repo, dest, version, remote)
+        (rc, out, err) = fetch(git_path, module, repo, dest, version, remote)
         if rc != 0:
             module.fail_json(msg=err)
 
     # switch to version specified regardless of whether
     # we cloned or pulled
-    (rc, out, err) = switch_version(module, dest, remote, version)
+    (rc, out, err) = switch_version(git_path, module, dest, remote, version)
 
     # determine if we changed anything
-    after = get_version(dest)
+    after = get_version(git_path, dest)
     changed = False
 
     if before != after or local_mods:

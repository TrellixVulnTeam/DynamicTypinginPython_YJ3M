commit 6676720ce5b272fbfe886c92ed72a458d98ff596
Author: Christian Berendt <berendt@b1-systems.de>
Date:   Sat May 3 18:40:05 2014 +0200

    fixed typos found by RETF rules in PY files
    
    rules are avaialble at https://en.wikipedia.org/wiki/Wikipedia:AutoWikiBrowser/Typos

diff --git a/lib/ansible/color.py b/lib/ansible/color.py
index 069684f16c..b3127d85fe 100644
--- a/lib/ansible/color.py
+++ b/lib/ansible/color.py
@@ -42,7 +42,7 @@ if constants.ANSIBLE_FORCE_COLOR:
 # --- begin "pretty"
 #
 # pretty - A miniature library that provides a Python print and stdout
-# wrapper that makes colored terminal text easier to use (eg. without
+# wrapper that makes colored terminal text easier to use (e.g. without
 # having to mess around with ANSI escape sequences). This code is public
 # domain - there is no license except that you must leave this header.
 #
diff --git a/lib/ansible/inventory/__init__.py b/lib/ansible/inventory/__init__.py
index 830d74c01e..c7a66c8b9f 100644
--- a/lib/ansible/inventory/__init__.py
+++ b/lib/ansible/inventory/__init__.py
@@ -86,7 +86,7 @@ class Inventory(object):
                 else:
                     if ":" in x:
                         tokens = x.rsplit(":", 1)
-                        # if there is ':' in the address, then this is a ipv6
+                        # if there is ':' in the address, then this is an ipv6
                         if ':' in tokens[0]:
                             all.add_host(Host(x))
                         else:
@@ -215,7 +215,7 @@ class Inventory(object):
 
     def __get_hosts(self, pattern):
         """ 
-        finds hosts that postively match a particular pattern.  Does not
+        finds hosts that positively match a particular pattern.  Does not
         take into account negative matches.
         """
 
diff --git a/lib/ansible/inventory/expand_hosts.py b/lib/ansible/inventory/expand_hosts.py
index b1cc0dcb82..f129740935 100644
--- a/lib/ansible/inventory/expand_hosts.py
+++ b/lib/ansible/inventory/expand_hosts.py
@@ -28,7 +28,7 @@ formatting hint when the range is expanded. e.g. [001:010] is to be
 expanded into 001, 002 ...009, 010.
 
 Note that when beg is specified with left zero padding, then the length of
-end must be the same as that of beg, else a exception is raised.
+end must be the same as that of beg, else an exception is raised.
 '''
 import string
 
@@ -37,7 +37,7 @@ from ansible import errors
 def detect_range(line = None):
     '''
     A helper function that checks a given host line to see if it contains
-    a range pattern descibed in the docstring above.
+    a range pattern described in the docstring above.
 
     Returnes True if the given line contains a pattern, else False.
     '''
@@ -102,7 +102,7 @@ def expand_hostname_range(line = None):
             if i_beg > i_end:
                 raise errors.AnsibleError("host range format incorrectly specified!")
             seq = string.ascii_letters[i_beg:i_end+1]
-        except ValueError:  # not a alpha range
+        except ValueError:  # not an alpha range
             seq = range(int(beg), int(end)+1, int(step))
 
         for rseq in seq:
diff --git a/lib/ansible/inventory/vars_plugins/group_vars.py b/lib/ansible/inventory/vars_plugins/group_vars.py
index 93edceeecb..36cbbef1e7 100644
--- a/lib/ansible/inventory/vars_plugins/group_vars.py
+++ b/lib/ansible/inventory/vars_plugins/group_vars.py
@@ -173,7 +173,7 @@ class VarsModule(object):
 
             scan_pass = scan_pass + 1
 
-            # it's not an eror if the directory does not exist, keep moving
+            # it's not an error if the directory does not exist, keep moving
             if not os.path.exists(basedir):
                 continue
 
diff --git a/lib/ansible/module_utils/basic.py b/lib/ansible/module_utils/basic.py
index c0b00d3865..643749d35b 100644
--- a/lib/ansible/module_utils/basic.py
+++ b/lib/ansible/module_utils/basic.py
@@ -570,7 +570,7 @@ class AnsibleModule(object):
             required = v.get('required', False)
             if default is not None and required:
                 # not alias specific but this is a good place to check this
-                self.fail_json(msg="internal error: required and default are mutally exclusive for %s" % k)
+                self.fail_json(msg="internal error: required and default are mutually exclusive for %s" % k)
             if aliases is None:
                 continue
             if type(aliases) != list:
@@ -991,7 +991,7 @@ class AnsibleModule(object):
             # Optimistically try a rename, solves some corner cases and can avoid useless work, throws exception if not atomic.
             os.rename(src, dest)
         except (IOError,OSError), e:
-            # only try workarounds for errno 18 (cross device), 1 (not permited) and 13 (permission denied)
+            # only try workarounds for errno 18 (cross device), 1 (not permitted) and 13 (permission denied)
             if e.errno != errno.EPERM and e.errno != errno.EXDEV and e.errno != errno.EACCES:
                 self.fail_json(msg='Could not replace file: %s to %s: %s' % (src, dest, e))
 
@@ -1121,7 +1121,7 @@ class AnsibleModule(object):
             try:
                 os.chdir(cwd)
             except (OSError, IOError), e:
-                self.fail_json(rc=e.errno, msg="Could not open %s , %s" % (cwd, str(e)))
+                self.fail_json(rc=e.errno, msg="Could not open %s, %s" % (cwd, str(e)))
 
         try:
             cmd = subprocess.Popen(args, **kwargs)
diff --git a/lib/ansible/module_utils/facts.py b/lib/ansible/module_utils/facts.py
index bcdfd2a7e0..7e5b86073d 100644
--- a/lib/ansible/module_utils/facts.py
+++ b/lib/ansible/module_utils/facts.py
@@ -73,7 +73,7 @@ class Facts(object):
     """
     This class should only attempt to populate those facts that
     are mostly generic to all systems.  This includes platform facts,
-    service facts (eg. ssh keys or selinux), and distribution facts.
+    service facts (e.g. ssh keys or selinux), and distribution facts.
     Anything that requires extensive code or may have more than one
     possible implementation to establish facts for a given topic should
     subclass Facts.
@@ -1009,7 +1009,7 @@ class FreeBSDHardware(Hardware):
                 if line.startswith('#') or line.strip() == '':
                     continue
                 fields = re.sub(r'\s+',' ',line.rstrip('\n')).split()
-                self.facts['mounts'].append({'mount': fields[1] , 'device': fields[0], 'fstype' : fields[2], 'options': fields[3]})
+                self.facts['mounts'].append({'mount': fields[1], 'device': fields[0], 'fstype' : fields[2], 'options': fields[3]})
 
     def get_device_facts(self):
         sysdir = '/dev'
@@ -1136,7 +1136,7 @@ class NetBSDHardware(Hardware):
                 if line.startswith('#') or line.strip() == '':
                     continue
                 fields = re.sub(r'\s+',' ',line.rstrip('\n')).split()
-                self.facts['mounts'].append({'mount': fields[1] , 'device': fields[0], 'fstype' : fields[2], 'options': fields[3]})
+                self.facts['mounts'].append({'mount': fields[1], 'device': fields[0], 'fstype' : fields[2], 'options': fields[3]})
 
 class AIX(Hardware):
     """
@@ -1524,7 +1524,7 @@ class LinuxNetwork(Network):
                     if os.path.exists(path):
                         interfaces[device]['all_slaves_active'] = open(path).read() == '1'
 
-            # Check whether a interface is in promiscuous mode
+            # Check whether an interface is in promiscuous mode
             if os.path.exists(os.path.join(path,'flags')):
                 promisc_mode = False
                 # The second byte indicates whether the interface is in promiscuous mode.
diff --git a/lib/ansible/module_utils/redhat.py b/lib/ansible/module_utils/redhat.py
index 7457ae0663..bf19ccf390 100644
--- a/lib/ansible/module_utils/redhat.py
+++ b/lib/ansible/module_utils/redhat.py
@@ -241,7 +241,7 @@ class RhsmPools(object):
 
     def _load_product_list(self):
         """
-            Loads list of all availaible pools for system in data structure
+            Loads list of all available pools for system in data structure
         """
         args = "subscription-manager list --available"
         rc, stdout, stderr = self.module.run_command(args, check_rc=True)
@@ -250,7 +250,7 @@ class RhsmPools(object):
         for line in stdout.split('\n'):
             # Remove leading+trailing whitespace
             line = line.strip()
-            # An empty line implies the end of a output group
+            # An empty line implies the end of an output group
             if len(line) == 0:
                 continue
             # If a colon ':' is found, parse
diff --git a/lib/ansible/playbook/__init__.py b/lib/ansible/playbook/__init__.py
index 021d62890d..c58efb704d 100644
--- a/lib/ansible/playbook/__init__.py
+++ b/lib/ansible/playbook/__init__.py
@@ -84,7 +84,7 @@ class PlayBook(object):
         playbook:         path to a playbook file
         host_list:        path to a file like /etc/ansible/hosts
         module_path:      path to ansible modules, like /usr/share/ansible/
-        forks:            desired level of paralellism
+        forks:            desired level of parallelism
         timeout:          connection timeout
         remote_user:      run as this user if not specified in a particular play
         remote_pass:      use this remote password (for all plays) vs using SSH keys
@@ -93,7 +93,7 @@ class PlayBook(object):
         transport:        how to connect to hosts that don't specify a transport (local, paramiko, etc)
         callbacks         output callbacks for the playbook
         runner_callbacks: more callbacks, this time for the runner API
-        stats:            holds aggregrate data about events occuring to each host
+        stats:            holds aggregrate data about events occurring to each host
         sudo:             if not specified per play, requests all plays use sudo mode
         inventory:        can be specified instead of host_list to use a pre-existing inventory object
         check:            don't change anything, just try to detect some potential changes
@@ -195,7 +195,7 @@ class PlayBook(object):
         utils.plugins.push_basedir(basedir)
         for play in playbook_data:
             if type(play) != dict:
-                raise errors.AnsibleError("parse error: each play in a playbook must be a YAML dictionary (hash), recieved: %s" % play)
+                raise errors.AnsibleError("parse error: each play in a playbook must be a YAML dictionary (hash), received: %s" % play)
 
             if 'include' in play:
                 # a playbook (list of plays) decided to include some other list of plays
@@ -415,7 +415,7 @@ class PlayBook(object):
 
         # template ignore_errors
         cond = template(play.basedir, task.ignore_errors, task.module_vars, expand_lists=False)
-        task.ignore_errors =  utils.check_conditional(cond , play.basedir, task.module_vars, fail_on_undefined=C.DEFAULT_UNDEFINED_VAR_BEHAVIOR)
+        task.ignore_errors =  utils.check_conditional(cond, play.basedir, task.module_vars, fail_on_undefined=C.DEFAULT_UNDEFINED_VAR_BEHAVIOR)
 
         # load up an appropriate ansible runner to run the task in parallel
         results = self._run_task_internal(task)
@@ -552,7 +552,7 @@ class PlayBook(object):
 
     def generate_retry_inventory(self, replay_hosts):
         '''
-        called by /usr/bin/ansible when a playbook run fails. It generates a inventory
+        called by /usr/bin/ansible when a playbook run fails. It generates an inventory
         that allows re-running on ONLY the failed hosts.  This may duplicate some
         variable information in group_vars/host_vars but that is ok, and expected.
         '''
@@ -655,7 +655,7 @@ class PlayBook(object):
                 if task.any_errors_fatal and len(host_list) < hosts_count:
                     play.max_fail_pct = 0
 
-                # If threshold for max nodes failed is exceeded , bail out.
+                # If threshold for max nodes failed is exceeded, bail out.
                 if play.serial > 0:
                     # if serial is set, we need to shorten the size of host_count
                     play_count = len(play._play_hosts)
diff --git a/lib/ansible/playbook/play.py b/lib/ansible/playbook/play.py
index 639f4c065b..97e38c3c98 100644
--- a/lib/ansible/playbook/play.py
+++ b/lib/ansible/playbook/play.py
@@ -368,7 +368,7 @@ class Play(object):
 
         roles = self._build_role_dependencies(roles, [], self.vars)
 
-        # give each role a uuid
+        # give each role an uuid
         for idx, val in enumerate(roles):
             this_uuid = str(uuid.uuid4())
             roles[idx][-2]['role_uuid'] = this_uuid
@@ -746,7 +746,7 @@ class Play(object):
                     else:
                         role_tags[this_role] += task['vars']['tags']
 
-        # apply each role's tags to it's tasks
+        # apply each role's tags to its tasks
         for idx, val in enumerate(self._tasks):
             if getattr(val, 'role_name', None) is not None:
                 this_role = val.role_name + "-" + val.module_vars['role_uuid']
diff --git a/lib/ansible/playbook/task.py b/lib/ansible/playbook/task.py
index 0a7e5515a8..5d6c905c30 100644
--- a/lib/ansible/playbook/task.py
+++ b/lib/ansible/playbook/task.py
@@ -253,7 +253,7 @@ class Task(object):
         if len(incompatibles) > 1:
             raise errors.AnsibleError("with_(plugin), and first_available_file are mutually incompatible in a single task")
 
-        # make first_available_file accessable to Runner code
+        # make first_available_file accessible to Runner code
         if self.first_available_file:
             self.module_vars['first_available_file'] = self.first_available_file
 
diff --git a/lib/ansible/runner/__init__.py b/lib/ansible/runner/__init__.py
index feda312456..d89aeb7b6e 100644
--- a/lib/ansible/runner/__init__.py
+++ b/lib/ansible/runner/__init__.py
@@ -329,7 +329,7 @@ class Runner(object):
 
         this_host = delegate['host']
 
-        # get the vars for the delegate by it's name        
+        # get the vars for the delegate by its name
         try:
             this_info = delegate['inject']['hostvars'][this_host]
         except:
@@ -353,7 +353,7 @@ class Runner(object):
         delegate['sudo_pass'] = this_info.get('ansible_sudo_pass', self.sudo_pass)
 
         # Last chance to get private_key_file from global variables.
-        # this is usefull if delegated host is not defined in the inventory
+        # this is useful if delegated host is not defined in the inventory
         if delegate['private_key_file'] is None:
             delegate['private_key_file'] = remote_inject.get(
                 'ansible_ssh_private_key_file', None)
@@ -369,7 +369,7 @@ class Runner(object):
 
     def _compute_delegate_user(self, host, inject):
 
-        """ Caculate the remote user based on an order of preference """
+        """ Calculate the remote user based on an order of preference """
 
         # inventory > playbook > original_host
 
@@ -795,7 +795,7 @@ class Runner(object):
             if actual_transport == 'accelerate':
                 # for accelerate, we stuff both ports into a single
                 # variable so that we don't have to mangle other function
-                # calls just to accomodate this one case
+                # calls just to accommodate this one case
                 actual_port = [actual_port, self.accelerate_port]
             elif actual_port is not None:
                 actual_port = int(template.template(self.basedir, actual_port, inject))
diff --git a/lib/ansible/runner/action_plugins/script.py b/lib/ansible/runner/action_plugins/script.py
index 6951d6154a..ccf6940c43 100644
--- a/lib/ansible/runner/action_plugins/script.py
+++ b/lib/ansible/runner/action_plugins/script.py
@@ -112,7 +112,7 @@ class ActionModule(object):
         conn.put_file(source, tmp_src)
 
         sudoable = True
-        # set file permissions, more permisive when the copy is done as a different user
+        # set file permissions, more permissive when the copy is done as a different user
         if ((self.runner.sudo and self.runner.sudo_user != 'root') or
                 (self.runner.su and self.runner.su_user != 'root')):
             cmd_args_chmod = "chmod a+rx %s" % tmp_src
diff --git a/lib/ansible/utils/__init__.py b/lib/ansible/utils/__init__.py
index 55e1c7d536..84ee52c31d 100644
--- a/lib/ansible/utils/__init__.py
+++ b/lib/ansible/utils/__init__.py
@@ -86,7 +86,7 @@ try:
             system_warning(
                 "The version of gmp you have installed has a known issue regarding " + \
                 "timing vulnerabilities when used with pycrypto. " + \
-                "If possible, you should update it (ie. yum update gmp)."
+                "If possible, you should update it (i.e. yum update gmp)."
             )
             warnings.resetwarnings()
             warnings.simplefilter("ignore")
@@ -643,7 +643,7 @@ def _gitinfo():
         if os.path.isfile(repo_path):
             try:
                 gitdir = yaml.safe_load(open(repo_path)).get('gitdir')
-                # There is a posibility the .git file to have an absolute path.
+                # There is a possibility the .git file to have an absolute path.
                 if os.path.isabs(gitdir):
                     repo_path = gitdir
                 else:
diff --git a/lib/ansible/utils/template.py b/lib/ansible/utils/template.py
index 8ec27ac097..22fae9bbd2 100644
--- a/lib/ansible/utils/template.py
+++ b/lib/ansible/utils/template.py
@@ -194,7 +194,7 @@ class J2Template(jinja2.environment.Template):
     This class prevents Jinja2 from running _jinja2_vars through dict()
     Without this, {% include %} and similar will create new contexts unlike
     the special one created in template_from_file. This ensures they are all
-    alike, with the exception of potential locals.
+    alike, except for potential locals.
     '''
     def new_context(self, vars=None, shared=False, locals=None):
         return jinja2.runtime.Context(self.environment, vars.add_locals(locals), self.name, self.blocks)
@@ -349,7 +349,7 @@ def template_from_string(basedir, data, vars, fail_on_undefined=False):
                     "Make sure your variable name does not contain invalid characters like '-'."
                 )
             else:
-                raise errors.AnsibleError("an unexpected type error occured. Error was %s" % te)
+                raise errors.AnsibleError("an unexpected type error occurred. Error was %s" % te)
         return res
     except (jinja2.exceptions.UndefinedError, errors.AnsibleUndefinedVariable):
         if fail_on_undefined:
diff --git a/plugins/callbacks/mail.py b/plugins/callbacks/mail.py
index 2281150f2c..d670ca7c9d 100644
--- a/plugins/callbacks/mail.py
+++ b/plugins/callbacks/mail.py
@@ -69,17 +69,17 @@ class CallbackModule(object):
     def runner_on_error(self, host, msg):
         sender = '"Ansible: %s" <root>' % host
         subject = 'Error: %s' % msg.strip('\r\n').split('\n')[0]
-        body = 'An error occured for host ' + host + ' with the following message:\n\n' + msg
+        body = 'An error occurred for host ' + host + ' with the following message:\n\n' + msg
         mail(sender=sender, subject=subject, body=body)
 
     def runner_on_unreachable(self, host, res):
         sender = '"Ansible: %s" <root>' % host
         if isinstance(res, basestring):
             subject = 'Unreachable: %s' % res.strip('\r\n').split('\n')[-1]
-            body = 'An error occured for host ' + host + ' with the following message:\n\n' + res
+            body = 'An error occurred for host ' + host + ' with the following message:\n\n' + res
         else:
             subject = 'Unreachable: %s' % res['msg'].strip('\r\n').split('\n')[0]
-            body = 'An error occured for host ' + host + ' with the following message:\n\n' + \
+            body = 'An error occurred for host ' + host + ' with the following message:\n\n' + \
                    res['msg'] + '\n\nA complete dump of the error:\n\n' + str(res)
         mail(sender=sender, subject=subject, body=body)
 
@@ -87,9 +87,9 @@ class CallbackModule(object):
         sender = '"Ansible: %s" <root>' % host
         if isinstance(res, basestring):
             subject = 'Async failure: %s' % res.strip('\r\n').split('\n')[-1]
-            body = 'An error occured for host ' + host + ' with the following message:\n\n' + res
+            body = 'An error occurred for host ' + host + ' with the following message:\n\n' + res
         else:
             subject = 'Async failure: %s' % res['msg'].strip('\r\n').split('\n')[0]
-            body = 'An error occured for host ' + host + ' with the following message:\n\n' + \
+            body = 'An error occurred for host ' + host + ' with the following message:\n\n' + \
                    res['msg'] + '\n\nA complete dump of the error:\n\n' + str(res)
         mail(sender=sender, subject=subject, body=body)
diff --git a/plugins/inventory/digital_ocean.py b/plugins/inventory/digital_ocean.py
index e74f2678d6..1c3eccd21e 100755
--- a/plugins/inventory/digital_ocean.py
+++ b/plugins/inventory/digital_ocean.py
@@ -157,7 +157,7 @@ class DigitalOceanInventory(object):
         # DigitalOceanInventory data
         self.data = {}      # All DigitalOcean data
         self.inventory = {} # Ansible Inventory
-        self.index = {}     # Varous indices of Droplet metadata
+        self.index = {}     # Various indices of Droplet metadata
 
         # Define defaults
         self.cache_path = '.'
@@ -368,7 +368,7 @@ or environment variables (DO_CLIENT_ID and DO_API_KEY)'''
 
 
     def load_droplet_variables_for_host(self):
-        '''Generate a JSON reponse to a --host call'''
+        '''Generate a JSON response to a --host call'''
         host = self.to_safe(str(self.args.host))
 
         if not host in self.index['host_to_droplet']:
diff --git a/plugins/inventory/docker.py b/plugins/inventory/docker.py
index 275be2b301..92df2f039a 100755
--- a/plugins/inventory/docker.py
+++ b/plugins/inventory/docker.py
@@ -25,7 +25,7 @@
 # inventory information.
 #
 # This plugin does not support targeting of specific hosts using the --host
-# flag. Instead, it it queries the Docker API for each container, running
+# flag. Instead, it queries the Docker API for each container, running
 # or not, and returns this data all once.
 #
 # The plugin returns the following custom attributes on Docker containers:
@@ -196,7 +196,7 @@ def setup():
                 write_stderr(e)
                 sys.exit(1)
 
-    # Enviroment Variables
+    # Environment Variables
     env_base_url = os.environ.get('DOCKER_HOST')
     env_version = os.environ.get('DOCKER_VERSION')
     env_timeout = os.environ.get('DOCKER_TIMEOUT')
diff --git a/plugins/inventory/jail.py b/plugins/inventory/jail.py
index c6caf38289..29c34aef8e 100755
--- a/plugins/inventory/jail.py
+++ b/plugins/inventory/jail.py
@@ -34,4 +34,4 @@ if len(sys.argv) == 2 and sys.argv[1] == '--list':
 elif len(sys.argv) == 3 and sys.argv[1] == '--host':
     print json.dumps({'ansible_connection': 'jail'})
 else:
-    print "Need a argument, either --list or --host <host>"
+    print "Need an argument, either --list or --host <host>"
diff --git a/plugins/inventory/libvirt_lxc.py b/plugins/inventory/libvirt_lxc.py
index f588a671fa..ff037265cd 100755
--- a/plugins/inventory/libvirt_lxc.py
+++ b/plugins/inventory/libvirt_lxc.py
@@ -34,4 +34,4 @@ if len(sys.argv) == 2 and sys.argv[1] == '--list':
 elif len(sys.argv) == 3 and sys.argv[1] == '--host':
     print json.dumps({'ansible_connection': 'lxc'})
 else:
-    print "Need a argument, either --list or --host <host>"
+    print "Need an argument, either --list or --host <host>"
diff --git a/plugins/inventory/openshift.py b/plugins/inventory/openshift.py
index 967dff7666..c6acb6ff8c 100755
--- a/plugins/inventory/openshift.py
+++ b/plugins/inventory/openshift.py
@@ -23,7 +23,7 @@ inventory: openshift
 short_description: Openshift gears external inventory script
 description:
   - Generates inventory of Openshift gears using the REST interface
-  - this permit to reuse playbook to setup a Openshift gear
+  - this permit to reuse playbook to setup an Openshift gear
 version_added: None
 author: Michael Scherer
 '''
@@ -113,4 +113,4 @@ if len(sys.argv) == 2 and sys.argv[1] == '--list':
 elif len(sys.argv) == 3 and sys.argv[1] == '--host':
     print json.dumps({})
 else:
-    print "Need a argument, either --list or --host <host>"
+    print "Need an argument, either --list or --host <host>"
diff --git a/plugins/inventory/vmware.py b/plugins/inventory/vmware.py
index 6ed7386589..c957775480 100755
--- a/plugins/inventory/vmware.py
+++ b/plugins/inventory/vmware.py
@@ -8,11 +8,11 @@ shamelessly copied from existing inventory scripts.
 
 This script and it's ini can be used more than once,
 
-i.e vmware.py/vmware_colo.ini vmware_idf.py/vmware_idf.ini
+i.e. vmware.py/vmware_colo.ini vmware_idf.py/vmware_idf.ini
 (script can be link)
 
 so if you don't have clustered vcenter  but multiple esx machines or
-just diff clusters you can have a inventory  per each and automatically
+just diff clusters you can have an inventory  per each and automatically
 group hosts based on file name or specify a group in the ini.
 '''
 
diff --git a/test/units/TestSynchronize.py b/test/units/TestSynchronize.py
index c6fa31bf9c..be8a8af129 100644
--- a/test/units/TestSynchronize.py
+++ b/test/units/TestSynchronize.py
@@ -133,7 +133,7 @@ class TestSynchronize(unittest.TestCase):
 
     def test_synchronize_action_vagrant(self):
 
-        """ Verify the action plugin accomodates the common 
+        """ Verify the action plugin accommodates the common
             scenarios for vagrant boxes. """
 
         runner = FakeRunner()

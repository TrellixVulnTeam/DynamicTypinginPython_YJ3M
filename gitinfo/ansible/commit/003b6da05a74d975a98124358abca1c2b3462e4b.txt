commit 003b6da05a74d975a98124358abca1c2b3462e4b
Author: Peter Sprygada <psprygada@ansible.com>
Date:   Sat Aug 20 14:26:47 2016 -0400

    add new functionality to iosxr_command module
    
    * commands argument now accepts a dict arguments[1]
    * waitfor has been renamed to wait_for with an alias to waitfor
    * only show commands are allowd when check mode is specified
    * config mode is no longer allowed in the command stack
    * add argument match with valid values any, all
    
    [1] The commands argument will now accept a dict argument that can
    specifiy the output format of the command.  To specify a dict argument
    use the form of { command: <str>, output: <str>, prompt: <str>,
    response: <str> }.

diff --git a/lib/ansible/modules/network/iosxr/iosxr_command.py b/lib/ansible/modules/network/iosxr/iosxr_command.py
index 4996837bbf..3e97ab4b3d 100644
--- a/lib/ansible/modules/network/iosxr/iosxr_command.py
+++ b/lib/ansible/modules/network/iosxr/iosxr_command.py
@@ -21,37 +21,53 @@ DOCUMENTATION = """
 module: iosxr_command
 version_added: "2.1"
 author: "Peter Sprygada (@privateip)"
-short_description: Run arbitrary commands on ios devices.
+short_description: Run commands on remote devices running Cisco iosxr
 description:
-  - Sends arbitrary commands to an IOSXR node and returns the results
+  - Sends arbitrary commands to an iosxr node and returns the results
     read from the device. This module includes an
     argument that will cause the module to wait for a specific condition
     before returning or timing out if the condition is not met.
+  - This module does not support running commands in configuration mode.
+    Please use M(iosxr_config) to configure iosxr devices.
 extends_documentation_fragment: iosxr
 options:
   commands:
     description:
-      - List of commands to send to the remote ios device over the
+      - List of commands to send to the remote iosxr device over the
         configured provider. The resulting output from the command
-        is returned. If the I(waitfor) argument is provided, the
+        is returned. If the I(wait_for) argument is provided, the
         module is not returned until the condition is satisfied or
-        the number of retires as expired.
+        the number of retries has expired.
     required: true
-  waitfor:
+  wait_for:
     description:
       - List of conditions to evaluate against the output of the
-        command. The task will wait for a each condition to be true
+        command. The task will wait for each condition to be true
         before moving forward. If the conditional is not true
         within the configured number of retries, the task fails.
         See examples.
     required: false
     default: null
+    aliases: ['waitfor']
+    version_added: "2.2"
+  match:
+    description:
+      - The I(match) argument is used in conjunction with the
+        I(wait_for) argument to specify the match policy.  Valid
+        values are C(all) or C(any).  If the value is set to C(all)
+        then all conditionals in the wait_for must be satisfied.  If
+        the value is set to C(any) then only one of the values must be
+        satisfied.
+    required: false
+    default: all
+    choices: ['any', 'all']
+    version_added: "2.2"
   retries:
     description:
       - Specifies the number of retries a command should by tried
         before it is considered failed. The command is run on the
         target device every retry and evaluated against the
-        waitfor conditions.
+        I(wait_for) conditions.
     required: false
     default: 10
   interval:
@@ -65,31 +81,47 @@ options:
 """
 
 EXAMPLES = """
-
-- iosxr_command:
-    commands:
-      - show version
-  register: output
-
-- iosxr_command:
-    commands:
-      - show version
-    waitfor:
-      - "result[0] contains 6.0.0"
-
-- iosxr_command:
-  commands:
-    - show version
-    - show interfaces
-  waitfor:
-    - "result[1] contains MgmtEth0/0/CPU0/0"
-    - "result[0] contains 6.0.0"
-
+# Note: examples below use the following provider dict to handle
+#       transport and authentication to the node.
+vars:
+  cli:
+    host: "{{ inventory_hostname }}"
+    username: root
+    password: root
+
+tasks:
+  - name: run show version on remote devices
+    iosxr_command:
+      commands: show version
+      provider "{{ cli }}"
+
+  - name: run show version and check to see if output contains iosxr
+    iosxr_command:
+      commands: show version
+      wait_for: result[0] contains IOS-XR
+      provider "{{ cli }}"
+
+  - name: run multiple commands on remote nodes
+     iosxr_command:
+      commands:
+        - show version
+        - show interfaces
+      provider "{{ cli }}"
+
+  - name: run multiple commands and evaluate the output
+    iosxr_command:
+      commands:
+        - show version
+        - show interfaces
+      wait_for:
+        - result[0] contains IOS-XR
+        - result[1] contains Loopback0
+      provider: "{{ cli }}"
 """
 
 RETURN = """
 stdout:
-  description: the set of responses from the commands
+  description: The set of responses from the commands
   returned: always
   type: list
   sample: ['...', '...']
@@ -101,78 +133,105 @@ stdout_lines:
   sample: [['...', '...'], ['...'], ['...']]
 
 failed_conditions:
-  description: the conditionals that failed
-  retured: failed
+  description: The list of conditionals that have failed
+  returned: failed
   type: list
   sample: ['...', '...']
 """
+from ansible.module_utils.basic import get_exception
+from ansible.module_utils.netcli import CommandRunner
+from ansible.module_utils.netcli import AddCommandError, FailedConditionsError
+from ansible.module_utils.iosxr import NetworkModule, NetworkError
 
-import time
-import shlex
-import re
+VALID_KEYS = ['command', 'output', 'prompt', 'response']
 
-INDEX_RE = re.compile(r'(\[\d+\])')
-
-def iterlines(stdout):
+def to_lines(stdout):
     for item in stdout:
         if isinstance(item, basestring):
             item = str(item).split('\n')
         yield item
 
+def parse_commands(module):
+    for cmd in module.params['commands']:
+        if isinstance(cmd, basestring):
+            cmd = dict(command=cmd, output=None)
+        elif 'command' not in cmd:
+            module.fail_json(msg='command keyword argument is required')
+        elif cmd.get('output') not in [None, 'text']:
+            module.fail_json(msg='invalid output specified for command')
+        elif not set(cmd.keys()).issubset(VALID_KEYS):
+            module.fail_json(msg='unknown command keyword specified.  Valid '
+                                 'values are %s' % ', '.join(VALID_KEYS))
+        yield cmd
 
 def main():
     spec = dict(
-        commands=dict(type='list'),
-        waitfor=dict(type='list'),
+        # { command: <str>, output: <str>, prompt: <str>, response: <str> }
+        commands=dict(type='list', required=True),
+
+        wait_for=dict(type='list', aliases=['waitfor']),
+        match=dict(default='all', choices=['all', 'any']),
+
         retries=dict(default=10, type='int'),
         interval=dict(default=1, type='int')
     )
 
-    module = get_module(argument_spec=spec,
-                        supports_check_mode=True)
+    module = NetworkModule(argument_spec=spec,
+                           connect_on_load=False,
+                           supports_check_mode=True)
 
-    commands = module.params['commands']
+    commands = list(parse_commands(module))
+    conditionals = module.params['wait_for'] or list()
 
-    retries = module.params['retries']
-    interval = module.params['interval']
+    warnings = list()
 
-    try:
-        queue = set()
-        for entry in (module.params['waitfor'] or list()):
-            queue.add(Conditional(entry))
-    except AttributeError:
-        exc = get_exception()
-        module.fail_json(msg=exc.message)
+    runner = CommandRunner(module)
+
+    for cmd in commands:
+        if module.check_mode and not cmd['command'].startswith('show'):
+            warnings.append('only show commands are supported when using '
+                            'check mode, not executing `%s`' % cmd['command'])
+        else:
+            if cmd['command'].startswith('conf'):
+                module.fail_json(msg='iosxr_command does not support running '
+                                     'config mode commands.  Please use '
+                                     'iosxr_config instead')
+            try:
+                runner.add_command(**cmd)
+            except AddCommandError:
+                exc = get_exception()
+                warnings.append('duplicate command detected: %s' % cmd)
 
+    for item in conditionals:
+        runner.add_conditional(item)
 
-    result = dict(changed=False)
+    runner.retries = module.params['retries']
+    runner.interval = module.params['interval']
+    runner.match = module.params['match']
 
-    while retries > 0:
-        response = module.execute(commands)
-        result['stdout'] = response
+    try:
+        runner.run()
+    except FailedConditionsError:
+        exc = get_exception()
+        module.fail_json(msg=str(exc), failed_conditions=exc.failed_conditions)
+    except NetworkError:
+        exc = get_exception()
+        module.fail_json(msg=str(exc))
 
-        for item in list(queue):
-            if item(response):
-                queue.remove(item)
+    result = dict(changed=False, stdout=list())
 
-        if not queue:
-            break
+    for cmd in commands:
+        try:
+            output = runner.get_command(cmd['command'])
+        except ValueError:
+            output = 'command not executed due to check_mode, see warnings'
+        result['stdout'].append(output)
 
-        time.sleep(interval)
-        retries -= 1
-    else:
-        failed_conditions = [item.raw for item in queue]
-        module.fail_json(msg='timeout waiting for value', failed_conditions=failed_conditions)
+    result['warnings'] = warnings
+    result['stdout_lines'] = list(to_lines(result['stdout']))
 
-    result['stdout_lines'] = list(iterlines(result['stdout']))
-    return module.exit_json(**result)
+    module.exit_json(**result)
 
 
-from ansible.module_utils.basic import *
-from ansible.module_utils.urls import *
-from ansible.module_utils.shell import *
-from ansible.module_utils.netcfg import *
-from ansible.module_utils.iosxr import *
 if __name__ == '__main__':
-        main()
-
+    main()

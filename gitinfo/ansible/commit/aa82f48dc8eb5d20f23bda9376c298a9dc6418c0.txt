commit aa82f48dc8eb5d20f23bda9376c298a9dc6418c0
Author: Nathaniel Case <this.is@nathanielca.se>
Date:   Tue Sep 27 17:06:03 2016 -0400

    Network module code cleanup (#5061)
    
    * Fix imports in junos_template
    
    * Python 3 compatibility in eos_command
    
    * Python 3 compatibility for ios_command
    
    * Clean up issues with ios_facts
    
    * Python 3 compatibility for ios_facts
    
    * Import shuffle in ios_template
    
    * Python 3 compatibility for iosxr_command
    
    * Clean up iosxr_facts.py
    
    * Python 3 compatibility for iosxr_facts
    
    * Python 3 compatibility for junos_command
    
    * Python 3 compatibility for ops_command
    
    * Cleanup issues with ops_facts
    
    * Python 3 compatibility for ops_facts
    
    * Cleanup issues with ops_template
    
    * Python 3 compatibility for vyos_command
    
    * Cleanup issues with vyos_facts
    
    * Python 3 compatibility for vyos_facts

diff --git a/lib/ansible/modules/network/eos/eos_command.py b/lib/ansible/modules/network/eos/eos_command.py
index b0ab3286b6..a506075b26 100644
--- a/lib/ansible/modules/network/eos/eos_command.py
+++ b/lib/ansible/modules/network/eos/eos_command.py
@@ -152,18 +152,19 @@ from ansible.module_utils.netcli import CommandRunner
 from ansible.module_utils.netcli import AddCommandError
 from ansible.module_utils.netcli import FailedConditionsError
 from ansible.module_utils.netcli import FailedConditionalError
+from ansible.module_utils.six import string_types
 
 VALID_KEYS = ['command', 'output', 'prompt', 'response']
 
 def to_lines(stdout):
     for item in stdout:
-        if isinstance(item, basestring):
+        if isinstance(item, string_types):
             item = str(item).split('\n')
         yield item
 
 def parse_commands(module):
     for cmd in module.params['commands']:
-        if isinstance(cmd, basestring):
+        if isinstance(cmd, string_types):
             cmd = dict(command=cmd, output=None)
         elif 'command' not in cmd:
             module.fail_json(msg='command keyword argument is required')
diff --git a/lib/ansible/modules/network/ios/ios_command.py b/lib/ansible/modules/network/ios/ios_command.py
index 5f2e12780b..4204a73a68 100644
--- a/lib/ansible/modules/network/ios/ios_command.py
+++ b/lib/ansible/modules/network/ios/ios_command.py
@@ -139,22 +139,24 @@ failed_conditions:
   type: list
   sample: ['...', '...']
 """
+import ansible.module_utils.ios
 from ansible.module_utils.basic import get_exception
 from ansible.module_utils.netcli import CommandRunner
 from ansible.module_utils.netcli import AddCommandError, FailedConditionsError
-from ansible.module_utils.ios import NetworkModule, NetworkError
+from ansible.module_utils.network import NetworkModule, NetworkError
+from ansible.module_utils.six import string_types
 
 VALID_KEYS = ['command', 'prompt', 'response']
 
 def to_lines(stdout):
     for item in stdout:
-        if isinstance(item, basestring):
+        if isinstance(item, string_types):
             item = str(item).split('\n')
         yield item
 
 def parse_commands(module):
     for cmd in module.params['commands']:
-        if isinstance(cmd, basestring):
+        if isinstance(cmd, string_types):
             cmd = dict(command=cmd, output=None)
         elif 'command' not in cmd:
             module.fail_json(msg='command keyword argument is required')
diff --git a/lib/ansible/modules/network/ios/ios_facts.py b/lib/ansible/modules/network/ios/ios_facts.py
index 884e9b5b29..699637d9c0 100644
--- a/lib/ansible/modules/network/ios/ios_facts.py
+++ b/lib/ansible/modules/network/ios/ios_facts.py
@@ -126,9 +126,11 @@ ansible_net_neighbors:
 import re
 import itertools
 
-from ansible.module_utils.basic import get_exception
+import ansible.module_utils.ios
 from ansible.module_utils.netcli import CommandRunner, AddCommandError
-from ansible.module_utils.ios import NetworkModule
+from ansible.module_utils.network import NetworkModule
+from ansible.module_utils.six import iteritems
+from ansible.module_utils.six.moves import zip
 
 
 def add_command(runner, command):
@@ -147,6 +149,9 @@ class FactsBase(object):
 
         self.commands()
 
+    def commands(self):
+        raise NotImplementedError
+
 class Default(FactsBase):
 
     def commands(self):
@@ -199,7 +204,7 @@ class Hardware(FactsBase):
         self.facts['filesystems'] = self.parse_filesystems(data)
 
         data = self.runner.get_command('show memory statistics | include Processor')
-        match = re.findall('\s(\d+)\s', data)
+        match = re.findall(r'\s(\d+)\s', data)
         if match:
             self.facts['memtotal_mb'] = int(match[0]) / 1024
             self.facts['memfree_mb'] = int(match[1]) / 1024
@@ -244,7 +249,7 @@ class Interfaces(FactsBase):
 
     def populate_interfaces(self, interfaces):
         facts = dict()
-        for key, value in interfaces.iteritems():
+        for key, value in iteritems(interfaces):
             intf = dict()
             intf['description'] = self.parse_description(value)
             intf['macaddress'] = self.parse_macaddress(value)
@@ -266,11 +271,11 @@ class Interfaces(FactsBase):
         return facts
 
     def populate_ipv6_interfaces(self, data):
-        for key, value in data.iteritems():
+        for key, value in iteritems(data):
             self.facts['interfaces'][key]['ipv6'] = list()
             addresses = re.findall(r'\s+(.+), subnet', value, re.M)
             subnets = re.findall(r', subnet is (.+)$', value, re.M)
-            for addr, subnet in itertools.izip(addresses, subnets):
+            for addr, subnet in zip(addresses, subnets):
                 ipv6 = dict(address=addr.strip(), subnet=subnet.strip())
                 self.add_ip_address(addr.strip(), 'ipv6')
                 self.facts['interfaces'][key]['ipv6'].append(ipv6)
@@ -297,6 +302,7 @@ class Interfaces(FactsBase):
 
     def parse_interfaces(self, data):
         parsed = dict()
+        key = ''
         for line in data.split('\n'):
             if len(line) == 0:
                 continue
@@ -444,7 +450,7 @@ def main():
         module.exit_json(out=module.from_json(runner.items))
 
     ansible_facts = dict()
-    for key, value in facts.iteritems():
+    for key, value in iteritems(facts):
         key = 'ansible_net_%s' % key
         ansible_facts[key] = value
 
diff --git a/lib/ansible/modules/network/ios/ios_template.py b/lib/ansible/modules/network/ios/ios_template.py
index 52e82f26e3..90b9554e8a 100644
--- a/lib/ansible/modules/network/ios/ios_template.py
+++ b/lib/ansible/modules/network/ios/ios_template.py
@@ -114,8 +114,9 @@ responses:
   type: list
   sample: ['...', '...']
 """
+import ansible.module_utils.ios
 from ansible.module_utils.netcfg import NetworkConfig, dumps
-from ansible.module_utils.ios import NetworkModule, NetworkError
+from ansible.module_utils.ios import NetworkModule
 
 def get_config(module):
     config = module.params['config'] or dict()
diff --git a/lib/ansible/modules/network/iosxr/iosxr_command.py b/lib/ansible/modules/network/iosxr/iosxr_command.py
index 1d6acc887b..b66d1ec3f0 100644
--- a/lib/ansible/modules/network/iosxr/iosxr_command.py
+++ b/lib/ansible/modules/network/iosxr/iosxr_command.py
@@ -138,22 +138,24 @@ failed_conditions:
   type: list
   sample: ['...', '...']
 """
+import ansible.module_utils.iosxr
 from ansible.module_utils.basic import get_exception
 from ansible.module_utils.netcli import CommandRunner
 from ansible.module_utils.netcli import AddCommandError, FailedConditionsError
-from ansible.module_utils.iosxr import NetworkModule, NetworkError
+from ansible.module_utils.network import NetworkModule, NetworkError
+from ansible.module_utils.six import string_types
 
 VALID_KEYS = ['command', 'output', 'prompt', 'response']
 
 def to_lines(stdout):
     for item in stdout:
-        if isinstance(item, basestring):
+        if isinstance(item, string_types):
             item = str(item).split('\n')
         yield item
 
 def parse_commands(module):
     for cmd in module.params['commands']:
-        if isinstance(cmd, basestring):
+        if isinstance(cmd, string_types):
             cmd = dict(command=cmd, output=None)
         elif 'command' not in cmd:
             module.fail_json(msg='command keyword argument is required')
diff --git a/lib/ansible/modules/network/iosxr/iosxr_facts.py b/lib/ansible/modules/network/iosxr/iosxr_facts.py
index f045080ee6..7af1023ffd 100644
--- a/lib/ansible/modules/network/iosxr/iosxr_facts.py
+++ b/lib/ansible/modules/network/iosxr/iosxr_facts.py
@@ -116,11 +116,12 @@ ansible_net_neighbors:
   type: dict
 """
 import re
-import itertools
 
-from ansible.module_utils.basic import get_exception
+import ansible.module_utils.iosxr
 from ansible.module_utils.netcli import CommandRunner, AddCommandError
-from ansible.module_utils.iosxr import NetworkModule
+from ansible.module_utils.network import NetworkModule
+from ansible.module_utils.six import iteritems
+from ansible.module_utils.six.moves import zip
 
 
 def add_command(runner, command):
@@ -139,6 +140,9 @@ class FactsBase(object):
 
         self.commands()
 
+    def commands(self):
+        raise NotImplementedError
+
 class Default(FactsBase):
 
     def commands(self):
@@ -223,7 +227,7 @@ class Interfaces(FactsBase):
 
     def populate_interfaces(self, interfaces):
         facts = dict()
-        for key, value in interfaces.iteritems():
+        for key, value in iteritems(interfaces):
             intf = dict()
             intf['description'] = self.parse_description(value)
             intf['macaddress'] = self.parse_macaddress(value)
@@ -244,11 +248,11 @@ class Interfaces(FactsBase):
         return facts
 
     def populate_ipv6_interfaces(self, data):
-        for key, value in data.iteritems():
+        for key, value in iteritems(data):
             self.facts['interfaces'][key]['ipv6'] = list()
             addresses = re.findall(r'\s+(.+), subnet', value, re.M)
             subnets = re.findall(r', subnet is (.+)$', value, re.M)
-            for addr, subnet in itertools.izip(addresses, subnets):
+            for addr, subnet in zip(addresses, subnets):
                 ipv6 = dict(address=addr.strip(), subnet=subnet.strip())
                 self.add_ip_address(addr.strip(), 'ipv6')
                 self.facts['interfaces'][key]['ipv6'].append(ipv6)
@@ -276,6 +280,7 @@ class Interfaces(FactsBase):
 
     def parse_interfaces(self, data):
         parsed = dict()
+        key = ''
         for line in data.split('\n'):
             if len(line) == 0:
                 continue
@@ -416,11 +421,10 @@ def main():
             inst.populate()
             facts.update(inst.facts)
     except Exception:
-        raise
         module.exit_json(out=module.from_json(runner.items))
 
     ansible_facts = dict()
-    for key, value in facts.iteritems():
+    for key, value in iteritems(facts):
         key = 'ansible_net_%s' % key
         ansible_facts[key] = value
 
diff --git a/lib/ansible/modules/network/junos/junos_command.py b/lib/ansible/modules/network/junos/junos_command.py
index faf6a4772e..fb80f0acad 100644
--- a/lib/ansible/modules/network/junos/junos_command.py
+++ b/lib/ansible/modules/network/junos/junos_command.py
@@ -158,16 +158,14 @@ xml:
   type: list
   sample: [['...', '...'], ['...', '...']]
 """
-import re
 
 import ansible.module_utils.junos
-
-
 from ansible.module_utils.basic import get_exception
 from ansible.module_utils.network import NetworkModule, NetworkError
 from ansible.module_utils.netcli import CommandRunner
 from ansible.module_utils.netcli import AddCommandError, FailedConditionsError
 from ansible.module_utils.junos import xml_to_json
+from ansible.module_utils.six import string_types
 
 VALID_KEYS = {
     'cli': frozenset(['command', 'output', 'prompt', 'response']),
@@ -177,7 +175,7 @@ VALID_KEYS = {
 
 def to_lines(stdout):
     for item in stdout:
-        if isinstance(item, basestring):
+        if isinstance(item, string_types):
             item = str(item).split('\n')
         yield item
 
@@ -189,7 +187,7 @@ def parse(module, command_type):
 
     parsed = list()
     for item in (items or list()):
-        if isinstance(item, basestring):
+        if isinstance(item, string_types):
             item = dict(command=item, output=None)
         elif 'command' not in item:
             module.fail_json(msg='command keyword argument is required')
@@ -302,4 +300,3 @@ def main():
 
 if __name__ == '__main__':
     main()
-
diff --git a/lib/ansible/modules/network/openswitch/ops_command.py b/lib/ansible/modules/network/openswitch/ops_command.py
index f74ef6191f..43dab36a83 100644
--- a/lib/ansible/modules/network/openswitch/ops_command.py
+++ b/lib/ansible/modules/network/openswitch/ops_command.py
@@ -126,22 +126,24 @@ failed_conditions:
   type: list
   sample: ['...', '...']
 """
+import ansible.module_utils.openswitch
 from ansible.module_utils.basic import get_exception
 from ansible.module_utils.netcli import CommandRunner
 from ansible.module_utils.netcli import AddCommandError, FailedConditionsError
-from ansible.module_utils.openswitch import NetworkModule, NetworkError
+from ansible.module_utils.network import NetworkModule, NetworkError
+from ansible.module_utils.six import string_types
 
 VALID_KEYS = ['command', 'prompt', 'response']
 
 def to_lines(stdout):
     for item in stdout:
-        if isinstance(item, basestring):
+        if isinstance(item, string_types):
             item = str(item).split('\n')
         yield item
 
 def parse_commands(module):
     for cmd in module.params['commands']:
-        if isinstance(cmd, basestring):
+        if isinstance(cmd, string_types):
             cmd = dict(command=cmd, output=None)
         elif 'command' not in cmd:
             module.fail_json(msg='command keyword argument is required')
@@ -220,4 +222,3 @@ def main():
 
 if __name__ == '__main__':
     main()
-
diff --git a/lib/ansible/modules/network/openswitch/ops_facts.py b/lib/ansible/modules/network/openswitch/ops_facts.py
index 162dc710f5..5be10b38d4 100644
--- a/lib/ansible/modules/network/openswitch/ops_facts.py
+++ b/lib/ansible/modules/network/openswitch/ops_facts.py
@@ -171,9 +171,10 @@ endpoints:
 """
 import re
 
-from ansible.module_utils.basic import get_exception
+import ansible.module_utils.openswitch
 from ansible.module_utils.netcli import CommandRunner, AddCommandError
-from ansible.module_utils.openswitch import NetworkModule
+from ansible.module_utils.network import NetworkModule
+from ansible.module_utils.six import iteritems
 
 
 def add_command(runner, command):
@@ -196,6 +197,9 @@ class FactsBase(object):
         if self.transport == 'cli':
             self.commands()
 
+    def commands(self):
+        raise NotImplementedError
+
     def populate(self):
         getattr(self, self.transport)()
 
@@ -395,11 +399,10 @@ def main():
             inst.populate()
             facts.update(inst.facts)
     except Exception:
-        raise
         module.exit_json(out=module.from_json(runner.items))
 
     ansible_facts = dict()
-    for key, value in facts.iteritems():
+    for key, value in iteritems(facts):
         # this is to maintain capability with ops_facts 2.1
         if key.startswith('_'):
             ansible_facts[key[1:]] = value
diff --git a/lib/ansible/modules/network/openswitch/ops_template.py b/lib/ansible/modules/network/openswitch/ops_template.py
index 48f21c0ce9..a47abda3a5 100644
--- a/lib/ansible/modules/network/openswitch/ops_template.py
+++ b/lib/ansible/modules/network/openswitch/ops_template.py
@@ -95,10 +95,11 @@ responses:
   type: list
   sample: [...]
 """
-import copy
 
+import ansible.module_utils.openswitch
 from ansible.module_utils.netcfg import NetworkConfig, dumps
-from ansible.module_utils.openswitch import NetworkModule
+from ansible.module_utils.network import NetworkModule
+from ansible.module_utils.openswitch import HAS_OPS
 
 
 def get_config(module):
diff --git a/lib/ansible/modules/network/vyos/vyos_command.py b/lib/ansible/modules/network/vyos/vyos_command.py
index 49e41b6127..0d09c4320f 100644
--- a/lib/ansible/modules/network/vyos/vyos_command.py
+++ b/lib/ansible/modules/network/vyos/vyos_command.py
@@ -126,22 +126,24 @@ warnings:
   type: list
   sample: ['...', '...']
 """
+import ansible.module_utils.vyos
 from ansible.module_utils.basic import get_exception
 from ansible.module_utils.netcli import CommandRunner
 from ansible.module_utils.netcli import AddCommandError, FailedConditionsError
-from ansible.module_utils.vyos import NetworkModule, NetworkError
+from ansible.module_utils.network import NetworkModule, NetworkError
+from ansible.module_utils.six import string_types
 
 VALID_KEYS = ['command', 'output', 'prompt', 'response']
 
 def to_lines(stdout):
     for item in stdout:
-        if isinstance(item, basestring):
+        if isinstance(item, string_types):
             item = str(item).split('\n')
         yield item
 
 def parse_commands(module):
     for cmd in module.params['commands']:
-        if isinstance(cmd, basestring):
+        if isinstance(cmd, string_types):
             cmd = dict(command=cmd, output=None)
         elif 'command' not in cmd:
             module.fail_json(msg='command keyword argument is required')
diff --git a/lib/ansible/modules/network/vyos/vyos_facts.py b/lib/ansible/modules/network/vyos/vyos_facts.py
index 3c09f36505..5be19a78e4 100644
--- a/lib/ansible/modules/network/vyos/vyos_facts.py
+++ b/lib/ansible/modules/network/vyos/vyos_facts.py
@@ -100,8 +100,11 @@ ansible_net_gather_subset:
 """
 import re
 
-from ansible.module_utils.netcmd import CommandRunner
-from ansible.module_utils.vyos import NetworkModule
+import ansible.module_utils.vyos
+from ansible.module_utils.pycompat24 import get_exception
+from ansible.module_utils.netcli import CommandRunner
+from ansible.module_utils.network import NetworkModule
+from ansible.module_utils.six import iteritems
 
 
 class FactsBase(object):
@@ -112,6 +115,9 @@ class FactsBase(object):
 
         self.commands()
 
+    def commands(self):
+        raise NotImplementedError
+
 
 class Default(FactsBase):
 
@@ -160,7 +166,7 @@ class Config(FactsBase):
         entry = None
 
         for line in commits.split('\n'):
-            match = re.match('(\d+)\s+(.+)by(.+)via(.+)', line)
+            match = re.match(r'(\d+)\s+(.+)by(.+)via(.+)', line)
             if match:
                 if entry:
                     entries.append(entry)
@@ -288,7 +294,7 @@ def main():
     for key in runable_subsets:
         instances.append(FACT_SUBSETS[key](runner))
 
-    runner.run_commands()
+    runner.run()
 
     try:
         for inst in instances:
@@ -299,7 +305,7 @@ def main():
         module.fail_json(msg='unknown failure', output=runner.items, exc=str(exc))
 
     ansible_facts = dict()
-    for key, value in facts.iteritems():
+    for key, value in iteritems(facts):
         key = 'ansible_net_%s' % key
         ansible_facts[key] = value
 

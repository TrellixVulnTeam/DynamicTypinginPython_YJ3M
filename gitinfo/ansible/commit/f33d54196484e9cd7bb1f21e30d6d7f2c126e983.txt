commit f33d54196484e9cd7bb1f21e30d6d7f2c126e983
Author: Abhijit Menon-Sen <ams@2ndQuadrant.com>
Date:   Mon Sep 28 20:58:30 2015 +0530

    Move sshpass checking into a separate method
    
    Checking for sshpass is peripheral to the calling code, so it's easier
    to follow when the details are moved into a method.

diff --git a/lib/ansible/plugins/connection/ssh.py b/lib/ansible/plugins/connection/ssh.py
index c7bbfc4f44..f9ee77d0dd 100644
--- a/lib/ansible/plugins/connection/ssh.py
+++ b/lib/ansible/plugins/connection/ssh.py
@@ -92,21 +92,7 @@ class Connection(ConnectionBase):
         # write the password to sshpass.
 
         if self._play_context.password:
-            global SSHPASS_AVAILABLE
-
-            # We test once if sshpass is available, and remember the result. It
-            # would be nice to use distutils.spawn.find_executable for this, but
-            # distutils isn't always available; shutils.which() is Python3-only.
-
-            if SSHPASS_AVAILABLE is None:
-                try:
-                    p = subprocess.Popen(["sshpass"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
-                    p.communicate()
-                    SSHPASS_AVAILABLE = True
-                except OSError:
-                    SSHPASS_AVAILABLE = False
-
-            if not SSHPASS_AVAILABLE:
+            if not self._sshpass_available():
                 raise AnsibleError("to use the 'ssh' connection type with passwords, you must install the sshpass program")
 
             self.sshpass_pipe = os.pipe()
@@ -646,6 +632,23 @@ class Connection(ConnectionBase):
 
     # Utility functions
 
+    def _sshpass_available(self):
+        global SSHPASS_AVAILABLE
+
+        # We test once if sshpass is available, and remember the result. It
+        # would be nice to use distutils.spawn.find_executable for this, but
+        # distutils isn't always available; shutils.which() is Python3-only.
+
+        if SSHPASS_AVAILABLE is None:
+            try:
+                p = subprocess.Popen(["sshpass"], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+                p.communicate()
+                SSHPASS_AVAILABLE = True
+            except OSError:
+                SSHPASS_AVAILABLE = False
+
+        return SSHPASS_AVAILABLE
+
     def _terminate_process(self, p):
         try:
             p.terminate()

commit bdd73e31dc62bfdeadc250ad5cb1fdecf866a10e
Author: Toshio Kuratomi <a.badger@gmail.com>
Date:   Fri Apr 22 16:04:04 2016 -0700

    Have test-module clean up the local temp dir when it exits
    
    Get test-module's debugger switch to do something useful with ziploader modules

diff --git a/hacking/test-module b/hacking/test-module
index 6db1a12fe3..9f05ec30c0 100755
--- a/hacking/test-module
+++ b/hacking/test-module
@@ -35,6 +35,7 @@ import os
 import subprocess
 import sys
 import traceback
+import shutil
 
 import ansible.utils.vars as utils_vars
 from ansible.parsing.dataloader import DataLoader
@@ -141,18 +142,43 @@ def boilerplate_module(modfile, args, interpreter, check, destfile):
         task_vars=task_vars
     )
 
+    if module_style == 'new' and 'ZIPLOADER_WRAPPER = True' in module_data:
+        module_style = 'ziploader'
+
     modfile2_path = os.path.expanduser(destfile)
     print("* including generated source, if any, saving to: %s" % modfile2_path)
-    print("* this may offset any line numbers in tracebacks/debuggers!")
+    if module_style not in ('ziploader', 'old'):
+        print("* this may offset any line numbers in tracebacks/debuggers!")
     modfile2 = open(modfile2_path, 'w')
     modfile2.write(module_data)
     modfile2.close()
     modfile = modfile2_path
 
-    return (modfile2_path, module_style)
+    return (modfile2_path, modname, module_style)
+
+def ziploader_setup(modfile, modname):
+    os.system("chmod +x %s" % modfile)
+
+    cmd = subprocess.Popen([modfile, 'explode'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
+    out, err = cmd.communicate()
+    lines = out.splitlines()
+    if len(lines) != 2 or 'Module expanded into' not in lines[0]:
+        print("*" * 35)
+        print("INVALID OUTPUT FROM ZIPLOADER MODULE WRAPPER")
+        print(out)
+        sys.exit(1)
+    debug_dir = lines[1].strip()
+
+    argsfile = os.path.join(debug_dir, 'args')
+    modfile = os.path.join(debug_dir, 'ansible_module_%s.py' % modname)
+
+    print("* ziploader module detected; extracted module source to: %s" % debug_dir)
+    return modfile, argsfile
 
-def runtest( modfile, argspath):
+def runtest(modstyle, modfile, argspath, modname, module_style):
     """Test run a module, piping it's output for reporting."""
+    if module_style == 'ziploader':
+        modfile, argspath = ziploader_setup(modfile, modname)
 
     os.system("chmod +x %s" % modfile)
 
@@ -164,25 +190,28 @@ def runtest( modfile, argspath):
     (out, err) = cmd.communicate()
 
     try:
-        print("***********************************")
+        print("*" * 35)
         print("RAW OUTPUT")
         print(out)
         print(err)
         results = json.loads(out)
     except:
-        print("***********************************")
+        print("*" * 35)
         print("INVALID OUTPUT FORMAT")
         print(out)
         traceback.print_exc()
         sys.exit(1)
 
-    print("***********************************")
+    print("*" * 35)
     print("PARSED OUTPUT")
     print(jsonify(results,format=True))
 
-def rundebug(debugger, modfile, argspath):
+def rundebug(debugger, modfile, argspath, modname, module_style):
     """Run interactively with console debugger."""
 
+    if module_style == 'ziploader':
+        modfile, argspath = ziploader_setup(modfile, modname)
+
     if argspath is not None:
         subprocess.call("%s %s %s" % (debugger, modfile, argspath), shell=True)
     else:
@@ -191,10 +220,10 @@ def rundebug(debugger, modfile, argspath):
 def main():
 
     options, args = parse()
-    (modfile, module_style) = boilerplate_module(options.module_path, options.module_args, options.interpreter, options.check, options.filename)
+    (modfile, modname, module_style) = boilerplate_module(options.module_path, options.module_args, options.interpreter, options.check, options.filename)
 
     argspath = None
-    if module_style != 'new':
+    if module_style not in ('new', 'ziploader'):
         if module_style == 'non_native_want_json':
             argspath = write_argsfile(options.module_args, json=True)
         elif module_style == 'old':
@@ -203,10 +232,13 @@ def main():
             raise Exception("internal error, unexpected module style: %s" % module_style)
     if options.execute:
         if options.debugger:
-            rundebug(options.debugger, modfile, argspath)
+            rundebug(options.debugger, modfile, argspath, modname, module_style)
         else:
-            runtest(modfile, argspath)
+            runtest(modfile, argspath, modname, module_style)
 
 if __name__ == "__main__":
-    main()
+    try:
+        main()
+    finally:
+        shutil.rmtree(C.DEFAULT_LOCAL_TMP, True)
 
diff --git a/lib/ansible/executor/module_common.py b/lib/ansible/executor/module_common.py
index ec50ab4031..2d10bd8ac7 100644
--- a/lib/ansible/executor/module_common.py
+++ b/lib/ansible/executor/module_common.py
@@ -60,6 +60,7 @@ _SNIPPET_PATH = os.path.join(os.path.dirname(__file__), '..', 'module_utils')
 
 ZIPLOADER_TEMPLATE = u'''%(shebang)s
 %(coding)s
+ZIPLOADER_WRAPPER = True # For test-module script to tell this is a ZIPLOADER_WRAPPER
 # This code is part of Ansible, but is an independent component.
 # The code in this particular templatable string, and this templatable string
 # only, is BSD licensed.  Modules which end up using this snippet, which is

commit 23a74eb12537f0747e16a9675874268361c16cc9
Author: Joel <joel@deport.me>
Date:   Tue Mar 22 12:12:51 2016 -0500

    Sort plugins by basename to support ordering callbacks

diff --git a/lib/ansible/plugins/__init__.py b/lib/ansible/plugins/__init__.py
index 9ac54a8d06..e190b219fb 100644
--- a/lib/ansible/plugins/__init__.py
+++ b/lib/ansible/plugins/__init__.py
@@ -348,36 +348,38 @@ class PluginLoader:
         ''' instantiates all plugins with the same arguments '''
 
         class_only = kwargs.pop('class_only', False)
+        all_matches = []
+ 
         for i in self._get_paths():
-            matches = glob.glob(os.path.join(i, "*.py"))
-            matches.sort()
-            for path in matches:
-                name, _ = os.path.splitext(path)
-                if '__init__' in name:
-                    continue
-
-                if path not in self._module_cache:
-                    self._module_cache[path] = self._load_module_source(name, path)
-
-                obj = getattr(self._module_cache[path], self.class_name)
-                if self.base_class:
-                    # The import path is hardcoded and should be the right place,
-                    # so we are not expecting an ImportError.
-                    module = __import__(self.package, fromlist=[self.base_class])
-                    # Check whether this obj has the required base class.
-                    try:
-                        plugin_class = getattr(module, self.base_class)
-                    except AttributeError:
-                        continue
-                    if not issubclass(obj, plugin_class):
-                        continue
-
-                if not class_only:
-                    obj = obj(*args, **kwargs)
-
-                # set extra info on the module, in case we want it later
-                setattr(obj, '_original_path', path)
-                yield obj
+            all_matches.extend(glob.glob(os.path.join(i, "*.py")))
+
+        for path in sorted(all_matches, key=lambda match: os.path.basename(match)):
+            name, _ = os.path.splitext(path)
+            if '__init__' in name:
+                continue
+
+            if path not in self._module_cache:
+                self._module_cache[path] = self._load_module_source(name, path)
+
+            obj = getattr(self._module_cache[path], self.class_name)
+            if self.base_class:
+                # The import path is hardcoded and should be the right place,
+                # so we are not expecting an ImportError.
+                module = __import__(self.package, fromlist=[self.base_class])
+                # Check whether this obj has the required base class.
+                try:
+                   plugin_class = getattr(module, self.base_class)
+                except AttributeError:
+                   continue
+                if not issubclass(obj, plugin_class):
+                   continue
+
+            if not class_only:
+                obj = obj(*args, **kwargs)
+
+            # set extra info on the module, in case we want it later
+            setattr(obj, '_original_path', path)
+            yield obj
 
 action_loader = PluginLoader(
     'ActionModule',

commit 1d04e4b3d27b0ae16619eda4136a939fe6f3299c
Author: James Cammarata <jimi@sngx.net>
Date:   Wed Oct 15 17:59:51 2014 -0700

    Updating unittests for v2 stuff

diff --git a/test/v2/plugins/__init__.py b/test/v2/plugins/__init__.py
new file mode 100644
index 0000000000..1f84012e01
--- /dev/null
+++ b/test/v2/plugins/__init__.py
@@ -0,0 +1,16 @@
+# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>
+#
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
diff --git a/test/v2/plugins/test_plugins.py b/test/v2/plugins/test_plugins.py
new file mode 100644
index 0000000000..62d8ee4dfb
--- /dev/null
+++ b/test/v2/plugins/test_plugins.py
@@ -0,0 +1,75 @@
+# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>
+#
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+
+import os
+import unittest
+
+from mock import mock_open, patch, MagicMock
+
+from ansible.plugins import MODULE_CACHE, PATH_CACHE, PLUGIN_PATH_CACHE, _basedirs, push_basedir, PluginLoader
+
+class TestErrors(unittest.TestCase):
+
+    def setUp(self):
+        pass
+
+    def tearDown(self):
+        pass
+
+    def test_push_basedir(self):
+        push_basedir('/root/foo/bar')
+        self.assertEqual(_basedirs, ['/root/foo/bar'])
+
+    @patch.object(PluginLoader, '_get_paths')
+    def test_print_paths(self, mock_method):
+        mock_method.return_value = ['/path/one', '/path/two', '/path/three']
+        pl = PluginLoader('foo', 'foo', '', 'test_plugins')
+        paths = pl.print_paths()
+        expected_paths = os.pathsep.join(['/path/one', '/path/two', '/path/three'])
+        self.assertEqual(paths, expected_paths)
+
+    def test_plugins__get_package_paths_no_package(self):
+        pl = PluginLoader('test', '', 'test', 'test_plugin')
+        self.assertEqual(pl._get_package_paths(), [])
+
+    def test_plugins__get_package_paths_with_package(self):
+        # the _get_package_paths() call uses __import__ to load a
+        # python library, and then uses the __file__ attribute of
+        # the result for that to get the library path, so we mock
+        # that here and patch the builtin to use our mocked result
+        m = MagicMock()
+        m.return_value.__file__ = '/path/to/my/test.py'
+        pl = PluginLoader('test', 'foo.bar.bam', 'test', 'test_plugin')
+        with patch('__builtin__.__import__', m):
+            self.assertEqual(pl._get_package_paths(), ['/path/to/my/bar/bam'])
+
+    def test_plugins__get_paths(self):
+        pl = PluginLoader('test', '', 'test', 'test_plugin')
+        pl._paths = ['/path/one', '/path/two']
+        self.assertEqual(pl._get_paths(), ['/path/one', '/path/two'])
+
+        # NOT YET WORKING
+        #def fake_glob(path):
+        #    if path == 'test/*':
+        #        return ['test/foo', 'test/bar', 'test/bam']
+        #    elif path == 'test/*/*'
+        #m._paths = None
+        #mock_glob = MagicMock()
+        #mock_glob.return_value = []
+        #with patch('glob.glob', mock_glob):
+        #    pass
+
diff --git a/v2/ansible/errors/__init__.py b/v2/ansible/errors/__init__.py
index ccc8a1a203..a0ae94111a 100644
--- a/v2/ansible/errors/__init__.py
+++ b/v2/ansible/errors/__init__.py
@@ -38,9 +38,7 @@ class AnsibleError(Exception):
     def _get_line_from_file(self, filename, line_number):
         with open(filename, 'r') as f:
             lines = f.readlines()
-            if line_number < len(lines):
-                return lines[line_number]
-        return None
+            return lines[line_number]
 
     def _get_extended_error(self):
         error_message = ''
diff --git a/v2/ansible/plugins/__init__.py b/v2/ansible/plugins/__init__.py
index 958ed2850f..5ab704b8a1 100644
--- a/v2/ansible/plugins/__init__.py
+++ b/v2/ansible/plugins/__init__.py
@@ -112,7 +112,6 @@ class PluginLoader:
         for basedir in _basedirs:
             fullpath = os.path.realpath(os.path.join(basedir, self.subdir))
             if os.path.isdir(fullpath):
-
                 files = glob.glob("%s/*" % fullpath)
 
                 # allow directories to be two levels deep
diff --git a/v2/test/errors/test_errors.py b/v2/test/errors/test_errors.py
index 42174ae08c..60ba7eb858 100644
--- a/v2/test/errors/test_errors.py
+++ b/v2/test/errors/test_errors.py
@@ -31,22 +31,43 @@ class TestErrors(unittest.TestCase):
     def setUp(self):
         self.message = 'this is the error message'
 
+        self.obj = AnsibleBaseYAMLObject()
+
     def tearDown(self):
         pass
 
     def test_basic_error(self):
         e = AnsibleError(self.message)
         self.assertEqual(e.message, self.message)
+        self.assertEqual(e.__repr__(), self.message)
 
-    def test_error_with_object(self):
-        obj = AnsibleBaseYAMLObject()
-        obj._data_source   = 'foo.yml'
-        obj._line_number   = 1
-        obj._column_number = 1
+    @patch.object(AnsibleError, '_get_line_from_file')
+    def test_error_with_object(self, mock_method):
+        self.obj._data_source   = 'foo.yml'
+        self.obj._line_number   = 1
+        self.obj._column_number = 1
 
-        m = mock_open()
-        m.return_value.readlines.return_value = ['this is line 1\n', 'this is line 2\n', 'this is line 3\n']
-        with patch('{0}.open'.format(BUILTINS), m):
-            e = AnsibleError(self.message, obj)
+        mock_method.return_value = 'this is line 1\n'
+        e = AnsibleError(self.message, self.obj)
 
         self.assertEqual(e.message, 'this is the error message\nThe error occurred on line 1 of the file foo.yml:\nthis is line 1\n^')
+
+    def test_error_get_line_from_file(self):
+        m = mock_open()
+        m.return_value.readlines.return_value = ['this is line 1\n']
+
+        with patch('__builtin__.open', m):
+            # this line will be found in the file
+            self.obj._data_source   = 'foo.yml'
+            self.obj._line_number   = 1
+            self.obj._column_number = 1
+            e = AnsibleError(self.message, self.obj)
+            self.assertEqual(e.message, 'this is the error message\nThe error occurred on line 1 of the file foo.yml:\nthis is line 1\n^')
+
+            # this line will not be found, as it is out of the index range
+            self.obj._data_source   = 'foo.yml'
+            self.obj._line_number   = 2
+            self.obj._column_number = 1
+            e = AnsibleError(self.message, self.obj)
+            self.assertEqual(e.message, 'this is the error message\nThe error occurred on line 2 of the file foo.yml:\n\n(specified line no longer in file, maybe it changed?)')
+        

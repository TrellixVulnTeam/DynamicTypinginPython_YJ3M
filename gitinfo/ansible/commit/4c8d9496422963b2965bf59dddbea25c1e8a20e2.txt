commit 4c8d9496422963b2965bf59dddbea25c1e8a20e2
Author: Nikhil Singh <nix85@ymail.com>
Date:   Thu Jul 26 16:21:49 2012 +0530

    Standardizing the apt module

diff --git a/library/apt b/library/apt
index 5f26114a35..c6ecdb3108 100755
--- a/library/apt
+++ b/library/apt
@@ -17,17 +17,7 @@
 # along with this software.  If not, see <http://www.gnu.org/licenses/>.
 #
 
-try:
-    import json
-except ImportError:
-    import simplejson as json
-import os
-import sys
-import shlex
-import subprocess
-import syslog
 import traceback
-
 # added to stave off future warnings about apt api
 import warnings; 
 warnings.filterwarnings('ignore', "apt API not stable yet", FutureWarning)
@@ -35,18 +25,11 @@ warnings.filterwarnings('ignore', "apt API not stable yet", FutureWarning)
 APT_PATH = "/usr/bin/apt-get"
 APT = "DEBIAN_FRONTEND=noninteractive DEBIAN_PRIORITY=critical %s" % APT_PATH
 
-def exit_json(rc=0, **kwargs):
-    print json.dumps(kwargs)
-    sys.exit(rc)
-
-def fail_json(**kwargs):
-    kwargs['failed'] = True
-    exit_json(rc=1, **kwargs)
-
 try:
     import apt, apt_pkg
 except ImportError:
-    fail_json(msg="could not import apt, please install the python-apt package on this host")
+    json.dumps(msg="could not import apt, please install the python-apt package on this host", failed=True)
+    sys.exit(1)
 
 def run_apt(command):
     try:
@@ -104,107 +87,91 @@ def install(pkgspec, cache, upgrade=False, default_release=None, install_recomme
             cmd += " -t '%s'" % (default_release,)
         if not install_recommends:
             cmd += " --no-install-recommends"
+
         rc, out, err = run_apt(cmd)
-        if rc:
-            fail_json(msg="'apt-get install %s' failed: %s" % (pkgspec, err))
-        return True
+        return rc, out, err
     else:
-        return False
+        return -1, "", "" # -1 depicts that nothing was changed
 
 def remove(pkgspec, cache, purge=False):
     name, version = package_split(pkgspec)
     installed, upgradable = package_status(name, version, cache)
     if not installed:
-        return False
+        return -1, "", "" # -1 depicts nothing was changed
     else:
         purge = '--purge' if purge else ''
         cmd = "%s -q -y %s remove '%s'" % (APT, purge, name)
         rc, out, err = run_apt(cmd)
-        if rc:
-            fail_json(msg="'apt-get remove %s' failed: %s" % (name, err))
-        return True
+        return rc, out, error
     
 
-# ===========================================
-
-if not os.path.exists(APT_PATH):
-    fail_json(msg="Cannot find apt-get")
-
-argfile = sys.argv[1]
-args    = open(argfile, 'r').read()
-items   = shlex.split(args)
-syslog.openlog('ansible-%s' % os.path.basename(__file__))
-syslog.syslog(syslog.LOG_NOTICE, 'Invoked with %s' % args)
-
-if not len(items):
-    fail_json(msg='the module requires arguments -a')
-    sys.exit(1)
-
-params = {}
-for x in items:
-    (k, v) = x.split("=", 1)
-    params[k] = v
-
-state              = params.get('state', 'installed')
-package            = params.get('pkg', params.get('package', params.get('name', None)))
-update_cache       = params.get('update-cache', 'no')
-purge              = params.get('purge', 'no')
-default_release    = params.get('default-release', None)
-install_recommends = params.get('install-recommends', 'yes')
-force              = params.get('force', 'no')
-
-if state not in ['installed', 'latest', 'removed']:
-    fail_json(msg='invalid state')
-
-if update_cache not in ['yes', 'no']:
-    fail_json(msg='invalid value for update_cache (requires yes or no -- default is no')
-
-if purge not in ['yes', 'no']:
-    fail_json(msg='invalid value for purge (requires yes or no -- default is no)')
-
-if force not in ['yes', 'no']:
-    fail_json(msg='invalid option for force (requires yes or no -- default is no)')
-
-if package is None and update_cache != 'yes':
-    fail_json(msg='pkg=name and/or update-cache=yes is required')
-
-if install_recommends not in ['yes', 'no']:
-    fail_json(msg='invalid value for install-recommends (requires yes or no -- default is yes)')
-install_recommends = (install_recommends == 'yes')
-
-cache = apt.Cache()
-if default_release:
-    apt_pkg.config['APT::Default-Release'] = default_release
-    # reopen cache w/ modified config
-    cache.open(progress=None)
-
-if update_cache == 'yes':
-    cache.update()
-    cache.open(progress=None)
-    if package == None:
-        exit_json(changed=False)
-
-if force == 'yes':
-    force_yes = True
-else:
-    force_yes = False
-
-if package.count('=') > 1:
-    fail_json(msg='invalid package spec')
-
-if state == 'latest':
-    if '=' in package:
-        fail_json(msg='version number inconsistent with state=latest') 
-    changed = install(package, cache, upgrade=True,
-                      default_release=default_release,
-                      install_recommends=install_recommends,
-                      force=force_yes)
-elif state == 'installed':
-    changed = install(package, cache, default_release=default_release,
-                      install_recommends=install_recommends,force=force_yes)
-elif state == 'removed':
-    changed = remove(package, cache, purge == 'yes')
-
-exit_json(changed=changed)
+def main():
+    module = AnsibleModule(
+        argument_spec = dict(
+            state = dict(default='installed', choices=['installed', 'latest', 'removed']),
+            update_cache = dict(default='no', choices=['yes', 'no']),
+            purge = dict(default='no', choices=['yes', 'no']),
+            package = dict(default=None, aliases=['pkg', 'name']),
+            default_release = dict(default=None, aliases=['default-release']),
+            install_recommends = dict(default='yes', aliases=['install-recommends'], choices=['yes', 'no']),
+            force = dict(default='no', choices=['yes', 'no'])
+        )
+    )
+
+    if not os.path.exists(APT_PATH):
+        module.fail_json(msg="Cannot find apt-get")
+
+    p = module.params
+    if p['package'] is None and p['update_cache'] != 'yes':
+        module.fail_json(msg='pkg=name and/or update-cache=yes is required')
+    
+    install_recommends = (p['install_recommends'] == 'yes')
+    
+    cache = apt.Cache()
+    if p['default_release']:
+        apt_pkg.config['APT::Default-Release'] = p['default_release']
+        # reopen cache w/ modified config
+        cache.open(progress=None)
+    
+    if p['update_cache'] == 'yes':
+        cache.update()
+        cache.open(progress=None)
+        if p['package'] == None:
+            module.exit_json(changed=False)
+    
+    if p['force'] == 'yes':
+        force_yes = True
+    else:
+        force_yes = False
+    
+    if p['package'].count('=') > 1:
+        module.fail_json(msg='invalid package spec')
+    
+    if p['state'] == 'latest':
+        if '=' in package:
+            module.fail_json(msg='version number inconsistent with state=latest') 
+
+        rc, out, err = install(p['package'], cache, upgrade=True,
+                          default_release=p['default_release'],
+                          install_recommends=install_recommends,
+                          force=force_yes)
+
+    elif p['state'] == 'installed':
+        rc, out, err = install(p['package'], cache, default_release=p['default_release'],
+                          install_recommends=install_recommends,force=force_yes)
+    elif p['state'] == 'removed':
+        rc, out, err = remove(p['package'], cache, purge == 'yes')
+    
+    if rc:
+        if rc == -1:
+            module.exit_json(changed=False)
+        else:
+            module.fail_json(msg=err)
+    else:
+        module.exit_json(changed=True)
+    
+# this is magic, see lib/ansible/module_common.py
+#<<INCLUDE_ANSIBLE_MODULE_COMMON>>
 
+main()
 

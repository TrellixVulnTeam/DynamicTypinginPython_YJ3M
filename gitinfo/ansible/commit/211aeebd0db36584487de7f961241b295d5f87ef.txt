commit 211aeebd0db36584487de7f961241b295d5f87ef
Author: James Cassell <code@james.cassell.me>
Date:   Tue Sep 11 03:11:03 2018 -0400

    remove unused templar._clean_data() (#42739)

diff --git a/lib/ansible/template/__init__.py b/lib/ansible/template/__init__.py
index e5a3295416..fd438a395f 100644
--- a/lib/ansible/template/__init__.py
+++ b/lib/ansible/template/__init__.py
@@ -355,66 +355,6 @@ class Templar:
 
         return jinja_exts
 
-    def _clean_data(self, orig_data):
-        ''' remove jinja2 template tags from data '''
-
-        if hasattr(orig_data, '__ENCRYPTED__'):
-            ret = orig_data
-
-        elif isinstance(orig_data, list):
-            clean_list = []
-            for list_item in orig_data:
-                clean_list.append(self._clean_data(list_item))
-            ret = clean_list
-
-        elif isinstance(orig_data, (dict, Mapping)):
-            clean_dict = {}
-            for k in orig_data:
-                clean_dict[self._clean_data(k)] = self._clean_data(orig_data[k])
-            ret = clean_dict
-
-        elif isinstance(orig_data, string_types):
-            # This will error with str data (needs unicode), but all strings should already be converted already.
-            # If you get exception, the problem is at the data origin, do not add to_text here.
-            with contextlib.closing(StringIO(orig_data)) as data:
-                # these variables keep track of opening block locations, as we only
-                # want to replace matched pairs of print/block tags
-                print_openings = []
-                block_openings = []
-                for mo in self._clean_regex.finditer(orig_data):
-                    token = mo.group(0)
-                    token_start = mo.start(0)
-
-                    if token[0] == self.environment.variable_start_string[0]:
-                        if token == self.environment.block_start_string:
-                            block_openings.append(token_start)
-                        elif token == self.environment.variable_start_string:
-                            print_openings.append(token_start)
-
-                    elif token[1] == self.environment.variable_end_string[1]:
-                        prev_idx = None
-                        if token == self.environment.block_end_string and block_openings:
-                            prev_idx = block_openings.pop()
-                        elif token == self.environment.variable_end_string and print_openings:
-                            prev_idx = print_openings.pop()
-
-                        if prev_idx is not None:
-                            # replace the opening
-                            data.seek(prev_idx, os.SEEK_SET)
-                            data.write(to_text(self.environment.comment_start_string))
-                            # replace the closing
-                            data.seek(token_start, os.SEEK_SET)
-                            data.write(to_text(self.environment.comment_end_string))
-
-                    else:
-                        raise AnsibleError("Error while cleaning data for safety: unhandled regex match")
-
-                ret = data.getvalue()
-        else:
-            ret = orig_data
-
-        return ret
-
     def set_available_variables(self, variables):
         '''
         Sets the list of template variables this Templar instance will use
diff --git a/test/units/template/test_templar.py b/test/units/template/test_templar.py
index cbc1417c44..ce12a8f2cd 100644
--- a/test/units/template/test_templar.py
+++ b/test/units/template/test_templar.py
@@ -176,23 +176,6 @@ class TestTemplarTemplate(BaseTemplar, unittest.TestCase):
         res = self.templar.template(unsafe_obj)
         self.assertTrue(self.is_unsafe(res), 'returned value from template.template (%s) is not marked unsafe' % res)
 
-    # TODO: not sure what template is supposed to do it, but it currently throws attributeError
-    @patch('ansible.template.Templar._clean_data')
-    def test_template_unsafe_non_string_clean_data_exception(self, mock_clean_data):
-        msg = 'Error raised from _clean_data by test_template_unsafe_non_string_clean_data_exception'
-        mock_clean_data.side_effect = AnsibleError(msg)
-        unsafe_obj = AnsibleUnsafe()
-        res = self.templar.template(unsafe_obj)
-        self.assertTrue(self.is_unsafe(res), 'returned value from template.template (%s) is not marked unsafe' % res)
-
-    # TODO: not sure what template is supposed to do it, but it currently throws attributeError
-    @patch('ansible.template.Templar._clean_data', side_effect=AnsibleError)
-    def test_template_unsafe_non_string_subclass_clean_data_exception(self, mock_clean_data):
-        unsafe_obj = SomeUnsafeClass()
-        self.assertTrue(self.is_unsafe(unsafe_obj))
-        res = self.templar.template(unsafe_obj)
-        self.assertTrue(self.is_unsafe(res), 'returned value from template.template (%s) is not marked unsafe' % res)
-
     def test_weird(self):
         data = u'''1 2 #}huh{# %}ddfg{% }}dfdfg{{  {%what%} {{#foo#}} {%{bar}%} {#%blip%#} {{asdfsd%} 3 4 {{foo}} 5 6 7'''
         self.assertRaisesRegexp(AnsibleError,
@@ -201,48 +184,6 @@ class TestTemplarTemplate(BaseTemplar, unittest.TestCase):
                                 data)
 
 
-class TestTemplarCleanData(BaseTemplar, unittest.TestCase):
-    def test_clean_data(self):
-        res = self.templar._clean_data(u'some string')
-        self.assertEqual(res, u'some string')
-
-    def test_clean_data_not_stringtype(self):
-        res = self.templar._clean_data(None)
-        # None vs NoneType
-        self.assertEqual(res, None)
-
-    def test_clean_data_jinja(self):
-        res = self.templar._clean_data(u'1 2 {what} 3 4 {{foo}} 5 6 7')
-        self.assertEqual(res, u'1 2 {what} 3 4 {#foo#} 5 6 7')
-
-    def test_clean_data_block(self):
-        res = self.templar._clean_data(u'1 2 {%what%} 3 4 {{foo}} 5 6 7')
-        self.assertEqual(res, u'1 2 {#what#} 3 4 {#foo#} 5 6 7')
-
-#    def test_clean_data_weird(self):
-#        res = self.templar._clean_data(u'1 2 #}huh{# %}ddfg{% }}dfdfg{{  {%what%} {{#foo#}} {%{bar}%} {#%blip%#} {{asdfsd%} 3 4 {{foo}} 5 6 7')
-#        print(res)
-
-        self.assertEqual(res, u'1 2 {#what#} 3 4 {#foo#} 5 6 7')
-
-    def test_clean_data_object(self):
-        obj = {u'foo': [1, 2, 3, u'bdasdf', u'{what}', u'{{foo}}', 5]}
-        clean_obj = {u'foo': [1, 2, 3, u'bdasdf', u'{what}', u'{#foo#}', 5]}
-        res = self.templar._clean_data(obj)
-        self.assertNotEqual(res, obj)
-        self.assertEqual(res, clean_obj)
-
-    def test_clean_data_bad_dict(self):
-        res = self.templar._clean_data(u'{{bad_dict}}')
-        self.assertEqual(res, u'{#bad_dict#}')
-
-    def test_clean_data_unsafe_obj(self):
-        some_obj = SomeClass()
-        unsafe_obj = wrap_var(some_obj)
-        res = self.templar._clean_data(unsafe_obj)
-        self.assertIsInstance(res, SomeClass)
-
-
 class TestTemplarMisc(BaseTemplar, unittest.TestCase):
     def test_templar_simple(self):
 

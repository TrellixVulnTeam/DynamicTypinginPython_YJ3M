commit b8c9391d0c555f20ff0c5d03a9a41053d2dc607a
Author: Kevin Houdebert <kevin@qwazerty.eu>
Date:   Mon Aug 31 02:35:14 2015 +0200

    Change to python3 syntax

diff --git a/hacking/get_library.py b/hacking/get_library.py
index 571183b688..bdb96f680f 100755
--- a/hacking/get_library.py
+++ b/hacking/get_library.py
@@ -22,7 +22,7 @@ import ansible.constants as C
 import sys
 
 def main():
-    print C.DEFAULT_MODULE_PATH
+    print(C.DEFAULT_MODULE_PATH)
     return 0
 
 if __name__ == '__main__':
diff --git a/hacking/module_formatter.py b/hacking/module_formatter.py
index 30b8d6a103..755fc9e0d6 100755
--- a/hacking/module_formatter.py
+++ b/hacking/module_formatter.py
@@ -18,6 +18,7 @@
 # along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
 #
 
+from __future__ import print_function
 import os
 import glob
 import sys
@@ -120,7 +121,7 @@ def write_data(text, options, outputname, module):
         f.write(text.encode('utf-8'))
         f.close()
     else:
-        print text
+        print(text)
 
 #####################################################################################
 
@@ -249,7 +250,7 @@ def process_module(module, options, env, template, outputname, module_map, alias
         deprecated = True
         module = module.replace("_","",1)
 
-    print "rendering: %s" % module
+    print("rendering: %s" % module)
 
     # use ansible core library to parse out doc metadata YAML and plaintext examples
     doc, examples, returndocs = module_docs.get_docstring(fname, verbose=options.verbose)
@@ -345,7 +346,7 @@ def process_category(category, categories, options, env, template, outputname):
 
     category_file_path = os.path.join(options.output_dir, "list_of_%s_modules.rst" % category)
     category_file = open(category_file_path, "w")
-    print "*** recording category %s in %s ***" % (category, category_file_path)
+    print("*** recording category %s in %s ***" % (category, category_file_path))
 
     # start a new category file
 
@@ -419,13 +420,13 @@ def validate_options(options):
     ''' validate option parser options '''
 
     if not options.module_dir:
-        print >>sys.stderr, "--module-dir is required"
+        print("--module-dir is required", file=sys.stderr)
         sys.exit(1)
     if not os.path.exists(options.module_dir):
-        print >>sys.stderr, "--module-dir does not exist: %s" % options.module_dir
+        print("--module-dir does not exist: %s" % options.module_dir, file=sys.stderr)
         sys.exit(1)
     if not options.template_dir:
-        print "--template-dir must be specified"
+        print("--template-dir must be specified")
         sys.exit(1)
 
 #####################################################################################
diff --git a/hacking/test-module b/hacking/test-module
index bdb91d0d5b..543e803b97 100755
--- a/hacking/test-module
+++ b/hacking/test-module
@@ -119,7 +119,7 @@ def boilerplate_module(modfile, args, interpreter, check, destfile):
     task_vars = {}
     if interpreter:
         if '=' not in interpreter:
-            print 'interpreter must by in the form of ansible_python_interpreter=/usr/bin/python'
+            print("interpreter must by in the form of ansible_python_interpreter=/usr/bin/python")
             sys.exit(1)
         interpreter_type, interpreter_path = interpreter.split('=')
         if not interpreter_type.startswith('ansible_'):
@@ -138,8 +138,8 @@ def boilerplate_module(modfile, args, interpreter, check, destfile):
     )
 
     modfile2_path = os.path.expanduser(destfile)
-    print "* including generated source, if any, saving to: %s" % modfile2_path
-    print "* this may offset any line numbers in tracebacks/debuggers!"
+    print("* including generated source, if any, saving to: %s" % modfile2_path)
+    print("* this may offset any line numbers in tracebacks/debuggers!")
     modfile2 = open(modfile2_path, 'w')
     modfile2.write(module_data)
     modfile2.close()
@@ -153,28 +153,28 @@ def runtest( modfile, argspath):
     os.system("chmod +x %s" % modfile)
 
     invoke = "%s" % (modfile)
-    if argspath is not None:     
+    if argspath is not None:
         invoke = "%s %s" % (modfile, argspath)
 
     cmd = subprocess.Popen(invoke, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
     (out, err) = cmd.communicate()
 
     try:
-        print "***********************************"
-        print "RAW OUTPUT"
-        print out
-        print err
+        print("***********************************")
+        print("RAW OUTPUT")
+        print(out)
+        print(err)
         results = json.loads(out)
     except:
-        print "***********************************"
-        print "INVALID OUTPUT FORMAT"
-        print out
+        print("***********************************")
+        print("INVALID OUTPUT FORMAT")
+        print(out)
         traceback.print_exc()
         sys.exit(1)
 
-    print "***********************************"
-    print "PARSED OUTPUT"
-    print jsonify(results,format=True)
+    print("***********************************")
+    print("PARSED OUTPUT")
+    print(jsonify(results,format=True))
 
 def rundebug(debugger, modfile, argspath):
     """Run interactively with console debugger."""
@@ -184,7 +184,7 @@ def rundebug(debugger, modfile, argspath):
     else:
         subprocess.call("%s %s" % (debugger, modfile), shell=True)
 
-def main(): 
+def main():
 
     options, args = parse()
     (modfile, module_style) = boilerplate_module(options.module_path, options.module_args, options.interpreter, options.check, options.filename)
@@ -202,7 +202,7 @@ def main():
             rundebug(options.debugger, modfile, argspath)
         else:
             runtest(modfile, argspath)
-        
+
 if __name__ == "__main__":
     main()
 

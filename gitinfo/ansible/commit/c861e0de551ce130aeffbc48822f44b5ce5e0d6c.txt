commit c861e0de551ce130aeffbc48822f44b5ce5e0d6c
Author: Michael DeHaan <michael.dehaan@gmail.com>
Date:   Sun Mar 18 17:16:12 2012 -0400

    Fix "import *" and resultant new things detectable from "make pyflakes"

diff --git a/lib/ansible/connection.py b/lib/ansible/connection.py
index fa94edbf9e..d803f62665 100755
--- a/lib/ansible/connection.py
+++ b/lib/ansible/connection.py
@@ -20,8 +20,8 @@
 
 import paramiko
 import os
-from ansible.errors import *
-    
+from ansible import errors
+
 ################################################
 
 class Connection(object):
@@ -68,7 +68,7 @@ class ParamikoConnection(object):
                 timeout=self.runner.timeout
             )
         except Exception, e:
-            raise AnsibleConnectionFailed(str(e))
+            raise errors.AnsibleConnectionFailed(str(e))
         return self
 
     def exec_command(self, cmd):
@@ -79,12 +79,12 @@ class ParamikoConnection(object):
     def put_file(self, in_path, out_path):
         ''' transfer a file from local to remote '''
         if not os.path.exists(in_path):
-            raise AnsibleFileNotFound("file or module does not exist: %s" % in_path)
+            raise errors.AnsibleFileNotFound("file or module does not exist: %s" % in_path)
         sftp = self.ssh.open_sftp()
         try:
             sftp.put(in_path, out_path)
         except IOError:
-            raise AnsibleException("failed to transfer file to %s" % out_path)
+            raise errors.AnsibleException("failed to transfer file to %s" % out_path)
         sftp.close()
 
     def close(self):
diff --git a/lib/ansible/playbook.py b/lib/ansible/playbook.py
index 8bb24bcec3..486e72c817 100755
--- a/lib/ansible/playbook.py
+++ b/lib/ansible/playbook.py
@@ -19,8 +19,8 @@
 
 import ansible.runner
 import ansible.constants as C
-from ansible.utils import *
-from ansible.errors import *
+from ansible import utils
+from ansible import errors
 import yaml
 import shlex
 import os
@@ -89,10 +89,10 @@ class PlayBook(object):
     def _get_vars(self, play, dirname):
         vars = play.get('vars', {})
         if type(vars) != dict:
-            raise AnsibleError("'vars' section must contain only key/value pairs")
+            raise errors.AnsibleError("'vars' section must contain only key/value pairs")
         vars_files = play.get('vars_files', [])
         for f in vars_files:
-            path = path_dwim(dirname, f)
+            path = utils.path_dwim(dirname, f)
             # FIXME: better error handling if not valid YAML 
             # or file not found
             # raise typed exception
@@ -105,7 +105,7 @@ class PlayBook(object):
         # an include line looks like:
         # include: some.yml a=2 b=3 c=4
         include_tokens = task['include'].split()
-        path = path_dwim(dirname, include_tokens[0])
+        path = utils.path_dwim(dirname, include_tokens[0])
         inject_vars = self._get_vars(play, dirname)
         for i,x in enumerate(include_tokens):
             if x.find("=") != -1:
@@ -119,7 +119,7 @@ class PlayBook(object):
                 new_tasks.append(x)
 
     def _include_handlers(self, play, handler, dirname, new_handlers):
-        path = path_dwim(dirname, handler['include'])
+        path = utils.path_dwim(dirname, handler['include'])
         included = file(path).read()
         inject_vars = self._get_vars(play, dirname)
         template = jinja2.Template(included)
@@ -376,7 +376,7 @@ class PlayBook(object):
         for host, results in contacted.iteritems():
             self.processed[host] = 1
    
-            if is_failed(results):
+            if utils.is_failed(results):
                 self.callbacks.on_failed(host, results)
                 if not host in self.failures:
                     self.failures[host] = 1
@@ -471,7 +471,7 @@ class PlayBook(object):
         for (host, host_result) in contacted_hosts.iteritems():
             if 'failed' in host_result:
                 self.callbacks.on_failed(host, host_result)
-                self.failed[hosts] = 1
+                self.failed[host] = 1
 
         # now for each result, load into the setup cache so we can
         # let runner template out future commands
diff --git a/lib/ansible/runner.py b/lib/ansible/runner.py
index 7464089bd8..2747b4a5fd 100755
--- a/lib/ansible/runner.py
+++ b/lib/ansible/runner.py
@@ -32,10 +32,15 @@ import tempfile
 import subprocess
 
 from ansible import utils
-from ansible.errors import *
+from ansible import errors
 
 # should be True except in debug
 CLEANUP_FILES = True
+
+try:
+   import json
+except ImportError:
+   import simplejson as json
     
 ################################################
 
@@ -52,7 +57,7 @@ def _executor_hook(job_queue, result_queue):
             pass
         except errors.AnsibleError, ae:
             result_queue.put([host, False, str(ae)])
-        except Exception, ee:
+        except Exception:
             # probably should include the full trace
             result_queue.put([host, False, traceback.format_exc()])
             
@@ -135,7 +140,7 @@ class Runner(object):
         host_list = os.path.expanduser(host_list)
 
         if not os.path.exists(host_list):
-            raise AnsibleFileNotFound("inventory file not found: %s" % host_list)
+            raise errors.AnsibleFileNotFound("inventory file not found: %s" % host_list)
 
         results    = []
         groups     = { 'ungrouped' : [] }
@@ -211,7 +216,7 @@ class Runner(object):
 
         try:
             return [ True, self.connector.connect(host) ]
-        except AnsibleConnectionFailed, e:
+        except errors.AnsibleConnectionFailed, e:
             return [ False, "FAILED: %s" % str(e) ]
 
     # *****************************************************
@@ -557,10 +562,10 @@ class Runner(object):
         ''' transfer a module over SFTP, does not run it '''
 
         if module.startswith("/"):
-            raise AnsibleFileNotFound("%s is not a module" % module)
+            raise errors.AnsibleFileNotFound("%s is not a module" % module)
         in_path = os.path.expanduser(os.path.join(self.module_path, module))
         if not os.path.exists(in_path):
-            raise AnsibleFileNotFound("module not found: %s" % in_path)
+            raise errors.AnsibleFileNotFound("module not found: %s" % in_path)
 
         out_path = tmp + module
         conn.put_file(in_path, out_path)
diff --git a/lib/ansible/utils.py b/lib/ansible/utils.py
index 5096c2c591..8acee184d8 100755
--- a/lib/ansible/utils.py
+++ b/lib/ansible/utils.py
@@ -20,7 +20,7 @@
 import sys
 import os
 import shlex
-from ansible.errors import *
+from ansible import errors
 
 try:
     import json
@@ -196,7 +196,7 @@ def parse_json(data):
         tokens = shlex.split(data)
         for t in tokens:
             if t.find("=") == -1:
-                raise AnsibleError("failed to parse: %s" % data)
+                raise errors.AnsibleError("failed to parse: %s" % data)
             (key,value) = t.split("=", 1)
             if key == 'changed' or 'failed':
                 if value.lower() in [ 'true', '1' ]:

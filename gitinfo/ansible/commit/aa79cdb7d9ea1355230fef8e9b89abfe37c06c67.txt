commit aa79cdb7d9ea1355230fef8e9b89abfe37c06c67
Author: Peter Sprygada <psprygada@ansible.com>
Date:   Thu Jul 14 06:52:57 2016 -0700

    added new functionality to ios_command
    
    * commands argument now accepts a dict arguments[1]
    * waitfor has been renamed to wait_for with an alias to waitfor
    * only show commands are allowd when check mode is specified
    * config mode is no longer allowed in the command stack
    * add argument match with valid values any, all
    
    [1] The commands argument will now accept a dict argument that can
    specifiy the output format of the command.  To specify a dict argument
    use the form of { command: <str>, output: <str>, prompt: <str>,
    response: <str> }.  Command and output are required arguments. Output
    accepts valid values text and json.

diff --git a/lib/ansible/modules/network/ios/ios_command.py b/lib/ansible/modules/network/ios/ios_command.py
index a368ba1d9c..31ae8da963 100644
--- a/lib/ansible/modules/network/ios/ios_command.py
+++ b/lib/ansible/modules/network/ios/ios_command.py
@@ -50,6 +50,18 @@ options:
     default: null
     aliases: ['waitfor']
     version_added: "2.2"
+  match:
+    description:
+      - The I(match) argument is used in conjunction with the
+        I(wait_for) argument to specify the match policy.  Valid
+        values are C(all) or C(any).  If the value is set to C(all)
+        then all conditionals in the wait_for must be satisfied.  If
+        the value is set to C(any) then only one of the values must be
+        satisfied.
+    required: false
+    default: all
+    choices: ['any', 'all']
+    version_added: "2.2"
   retries:
     description:
       - Specifies the number of retries a command should by tried
@@ -126,27 +138,40 @@ failed_conditions:
   returned: failed
   type: list
   sample: ['...', '...']
-
-warnings:
-  description: The list of warnings (if any) generated by module based on arguments
-  returned: always
-  type: list
-  sample: ['...', '...']
 """
 from ansible.module_utils.basic import get_exception
-from ansible.module_utils.netcmd import CommandRunner, FailedConditionsError
+from ansible.module_utils.netcli import CommandRunner
+from ansible.module_utils.netcli import AddCommandError, FailedConditionsError
 from ansible.module_utils.ios import NetworkModule, NetworkError
 
+VALID_KEYS = ['command', 'output', 'prompt', 'response']
+
 def to_lines(stdout):
     for item in stdout:
         if isinstance(item, basestring):
             item = str(item).split('\n')
         yield item
 
+def parse_commands(module):
+    for cmd in module.params['commands']:
+        if isinstance(cmd, basestring):
+            cmd = dict(command=cmd, output=None)
+        elif 'command' not in cmd:
+            module.fail_json(msg='command keyword argument is required')
+        elif cmd.get('output') not in [None, 'text', 'json']:
+            module.fail_json(msg='invalid output specified for command')
+        elif not set(cmd.keys()).issubset(VALID_KEYS):
+            module.fail_json(msg='unknown keyword specified')
+        yield cmd
+
 def main():
     spec = dict(
+        # { command: <str>, output: <str>, prompt: <str>, response: <str> }
         commands=dict(type='list', required=True),
+
         wait_for=dict(type='list', aliases=['waitfor']),
+        match=dict(default='all', choices=['all', 'any']),
+
         retries=dict(default=10, type='int'),
         interval=dict(default=1, type='int')
     )
@@ -155,7 +180,7 @@ def main():
                            connect_on_load=False,
                            supports_check_mode=True)
 
-    commands = module.params['commands']
+    commands = list(parse_commands(module))
     conditionals = module.params['wait_for'] or list()
 
     warnings = list()
@@ -163,21 +188,26 @@ def main():
     runner = CommandRunner(module)
 
     for cmd in commands:
-        if module.check_mode and not cmd.startswith('show'):
+        if module.check_mode and not cmd['command'].startswith('show'):
             warnings.append('only show commands are supported when using '
-                            'check mode, not executing `%s`' % cmd)
+                            'check mode, not executing `%s`' % cmd['command'])
         else:
-            if cmd.startswith('conf'):
+            if cmd['command'].startswith('conf'):
                 module.fail_json(msg='ios_command does not support running '
                                      'config mode commands.  Please use '
                                      'ios_config instead')
-            runner.add_command(cmd)
+            try:
+                runner.add_command(**cmd)
+            except AddCommandError:
+                exc = get_exception()
+                warnings.append('duplicate command detected: %s' % cmd)
 
     for item in conditionals:
         runner.add_conditional(item)
 
     runner.retries = module.params['retries']
     runner.interval = module.params['interval']
+    runner.match = module.params['match']
 
     try:
         runner.run()
@@ -188,17 +218,15 @@ def main():
         exc = get_exception()
         module.fail_json(msg=str(exc))
 
-    result = dict(changed=False)
+    result = dict(changed=False, stdout=list())
 
-    result['stdout'] = list()
     for cmd in commands:
         try:
-            output = runner.get_command(cmd)
+            output = runner.get_command(cmd['command'])
         except ValueError:
             output = 'command not executed due to check_mode, see warnings'
         result['stdout'].append(output)
 
-
     result['warnings'] = warnings
     result['stdout_lines'] = list(to_lines(result['stdout']))
 
@@ -207,4 +235,3 @@ def main():
 
 if __name__ == '__main__':
     main()
-

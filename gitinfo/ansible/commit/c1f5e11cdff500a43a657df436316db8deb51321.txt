commit c1f5e11cdff500a43a657df436316db8deb51321
Author: Jordan Borean <jborean93@gmail.com>
Date:   Thu Mar 8 09:43:42 2018 +1000

    win_uri: return response info on non 200 responses, convert DateTime values to ISO 8601 (#37104)

diff --git a/lib/ansible/modules/windows/win_uri.ps1 b/lib/ansible/modules/windows/win_uri.ps1
index 2d90a82f16..f3a2343801 100644
--- a/lib/ansible/modules/windows/win_uri.ps1
+++ b/lib/ansible/modules/windows/win_uri.ps1
@@ -176,17 +176,33 @@ if ($null -ne $body) {
 
 try {
     $response = $client.GetResponse()
+} catch [System.Net.WebException] {
+    $response = $null
+    if ($_.Exception.PSObject.Properties.Name -match "Response") {
+        # was a non-successful response but we at least have a response and
+        # should parse it below according to module input
+        $response = $_.Exception.Response
+    }
+
+    # in the case a response (or empty response) was on the exception like in
+    # a timeout scenario, we should still fail
+    if ($null -eq $response) {
+        Fail-Json -obj $result -message "WebException occurred when sending web request: $($_.Exception.Message)"
+    }
 } catch [System.Net.ProtocolViolationException] {
     Fail-Json -obj $result -message "ProtocolViolationException when sending web request: $($_.Exception.Message)"
-} catch [System.Net.WebException] {
-    Fail-Json -obj $result -message "WebException occurred when sending web request: $($_.Exception.Message)"
 } catch {
     Fail-Json -obj $result -message "Unhandled exception occured when sending web request. Exception: $($_.Exception.Message)"
 }
 
 ForEach ($prop in $response.psobject.properties) {
     $result_key = Convert-StringToSnakeCase -string $prop.Name
-    $result.$result_key = $prop.Value
+    $prop_value = $prop.Value
+    # convert and DateTime values to ISO 8601 standard
+    if ($prop_value -is [System.DateTime]) {
+        $prop_value = $prop_value.ToString("o", [System.Globalization.CultureInfo]::InvariantCulture)
+    }
+    $result.$result_key = $prop_value
 }
 
 # manually get the headers as not all of them are in the response properties
@@ -197,10 +213,6 @@ foreach ($header_key in $response.Headers.GetEnumerator()) {
     $result.$header_key = $header_value
 }
 
-if ($status_code -notcontains $response.StatusCode) {
-    Fail-Json -obj $result -message "Status code of request '$($response.StatusCode)' is not in list of valid status codes $status_code."
-}
-
 # we only care about the return body if we need to return the content or create a file
 if ($return_content -or $dest) {
     $resp_st = $response.GetResponseStream()
@@ -252,5 +264,8 @@ if ($return_content -or $dest) {
     }
 }
 
-Exit-Json -obj $result
+if ($status_code -notcontains $response.StatusCode) {
+    Fail-Json -obj $result -message "Status code of request '$($response.StatusCode)' is not in list of valid status codes $status_code."
+}
 
+Exit-Json -obj $result
diff --git a/test/integration/targets/win_uri/tasks/test.yml b/test/integration/targets/win_uri/tasks/test.yml
index bf1333afbf..206648d743 100644
--- a/test/integration/targets/win_uri/tasks/test.yml
+++ b/test/integration/targets/win_uri/tasks/test.yml
@@ -320,3 +320,21 @@
     timeout: 5
   register: get_with_timeout_fail
   failed_when: '"The operation has timed out" not in get_with_timeout_fail.msg'
+
+- name: connect to fakepath that does not exist
+  win_uri:
+    url: http://{{httpbin_host}}/fakepath
+    status_code: 404
+    return_content: yes
+  register: invalid_path
+
+# verifies the return values are still set on a non 200 response
+- name: assert connect to fakepath that does not exist
+  assert:
+    that:
+    - not invalid_path.changed
+    - invalid_path.status_code == 404
+    - invalid_path.status_description == 'NOT FOUND'
+    - invalid_path.content is defined
+    - invalid_path.method == 'GET'
+    - invalid_path.connection is defined

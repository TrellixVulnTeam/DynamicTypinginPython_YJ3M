commit 07498ebed3bb7b1505e5ba932ff023f1259fccbe
Author: Trishna Guha <trishnaguha17@gmail.com>
Date:   Mon Jul 10 18:53:52 2017 +0530

    fix nxos_overlay_global (#26422)
    
    * fix nxos_overlay_global
    
    Signed-off-by: Trishna Guha <trishnaguha17@gmail.com>
    
    * swap check_mode with candidate
    
    Signed-off-by: Trishna Guha <trishnaguha17@gmail.com>

diff --git a/lib/ansible/modules/network/nxos/nxos_overlay_global.py b/lib/ansible/modules/network/nxos/nxos_overlay_global.py
index e7ceaa82a5..c47ddce4f8 100644
--- a/lib/ansible/modules/network/nxos/nxos_overlay_global.py
+++ b/lib/ansible/modules/network/nxos/nxos_overlay_global.py
@@ -16,10 +16,10 @@
 # along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
 #
 
-ANSIBLE_METADATA = {'metadata_version': '1.0',
-                    'status': ['preview'],
-                    'supported_by': 'community'}
-
+ANSIBLE_METADATA = {
+    'metadata_version': '1.0',
+    'status': ['preview'],
+    'supported_by': 'community'}
 
 DOCUMENTATION = '''
 ---
@@ -28,86 +28,31 @@ extends_documentation_fragment: nxos
 version_added: "2.2"
 short_description: Configures anycast gateway MAC of the switch.
 description:
-    - Configures anycast gateway MAC of the switch.
+  - Configures anycast gateway MAC of the switch.
 author: Gabriele Gerbino (@GGabriele)
 notes:
-    - Default restores params default value
-    - Supported MAC address format are "E.E.E", "EE-EE-EE-EE-EE-EE",
-      "EE:EE:EE:EE:EE:EE" and "EEEE.EEEE.EEEE"
+  - Default restores params default value
+  - Supported MAC address format are "E.E.E", "EE-EE-EE-EE-EE-EE",
+    "EE:EE:EE:EE:EE:EE" and "EEEE.EEEE.EEEE"
 options:
-    anycast_gateway_mac:
-        description:
-            - Anycast gateway mac of the switch.
-        required: true
-        default: null
+  anycast_gateway_mac:
+    description:
+      - Anycast gateway mac of the switch.
+    required: true
+    default: null
 '''
 
 EXAMPLES = '''
 - nxos_overlay_global:
     anycast_gateway_mac: "b.b.b"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-    host: "{{ inventory_hostname }}"
 '''
 
 RETURN = '''
-proposed:
-    description: k/v pairs of parameters passed into module
-    returned: verbose mode
-    type: dict
-    sample: {"asn": "65535", "router_id": "1.1.1.1", "vrf": "test"}
-existing:
-    description: k/v pairs of existing BGP configuration
-    returned: verbose mode
-    type: dict
-    sample: {"asn": "65535", "bestpath_always_compare_med": false,
-            "bestpath_aspath_multipath_relax": false,
-            "bestpath_compare_neighborid": false,
-            "bestpath_compare_routerid": false,
-            "bestpath_cost_community_ignore": false,
-            "bestpath_med_confed": false,
-            "bestpath_med_missing_as_worst": false,
-            "bestpath_med_non_deterministic": false, "cluster_id": "",
-            "confederation_id": "", "confederation_peers": "",
-            "graceful_restart": true, "graceful_restart_helper": false,
-            "graceful_restart_timers_restart": "120",
-            "graceful_restart_timers_stalepath_time": "300", "local_as": "",
-            "log_neighbor_changes": false, "maxas_limit": "",
-            "neighbor_down_fib_accelerate": false, "reconnect_interval": "60",
-            "router_id": "11.11.11.11", "suppress_fib_pending": false,
-            "timer_bestpath_limit": "", "timer_bgp_hold": "180",
-            "timer_bgp_keepalive": "60", "vrf": "test"}
-end_state:
-    description: k/v pairs of BGP configuration after module execution
-    returned: verbose mode
-    type: dict
-    sample: {"asn": "65535", "bestpath_always_compare_med": false,
-            "bestpath_aspath_multipath_relax": false,
-            "bestpath_compare_neighborid": false,
-            "bestpath_compare_routerid": false,
-            "bestpath_cost_community_ignore": false,
-            "bestpath_med_confed": false,
-            "bestpath_med_missing_as_worst": false,
-            "bestpath_med_non_deterministic": false, "cluster_id": "",
-            "confederation_id": "", "confederation_peers": "",
-            "graceful_restart": true, "graceful_restart_helper": false,
-            "graceful_restart_timers_restart": "120",
-            "graceful_restart_timers_stalepath_time": "300", "local_as": "",
-            "log_neighbor_changes": false, "maxas_limit": "",
-            "neighbor_down_fib_accelerate": false, "reconnect_interval": "60",
-            "router_id": "1.1.1.1",  "suppress_fib_pending": false,
-            "timer_bestpath_limit": "", "timer_bgp_hold": "180",
-            "timer_bgp_keepalive": "60", "vrf": "test"}
-updates:
+commands:
     description: commands sent to the device
     returned: always
     type: list
-    sample: ["router bgp 65535", "vrf test", "router-id 1.1.1.1"]
-changed:
-    description: check to see if a change was made on the device
-    returned: always
-    type: boolean
-    sample: true
+    sample: ["fabric forwarding anycast-gateway-mac 000B.000B.000B"]
 '''
 
 import re
@@ -121,26 +66,17 @@ PARAM_TO_COMMAND_KEYMAP = {
 }
 
 
-def invoke(name, *args, **kwargs):
-    func = globals().get(name)
-    if func:
-        return func(*args, **kwargs)
-
-
-def get_value(arg, config, module):
-    REGEX = re.compile(r'(?:{0}\s)(?P<value>.*)$'.format(PARAM_TO_COMMAND_KEYMAP[arg]), re.M)
-    value = ''
-    if PARAM_TO_COMMAND_KEYMAP[arg] in config:
-        value = REGEX.search(config).group('value')
-    return value
-
-
 def get_existing(module, args):
     existing = {}
     config = str(get_config(module))
 
     for arg in args:
-        existing[arg] = get_value(arg, config, module)
+        command = PARAM_TO_COMMAND_KEYMAP[arg]
+        has_command = re.match(r'(?:{0}\s)(?P<value>.*)$'.format(command), config, re.M)
+        value = ''
+        if has_command:
+            value = has_command.group('value')
+        existing[arg] = value
     return existing
 
 
@@ -148,12 +84,8 @@ def apply_key_map(key_map, table):
     new_dict = {}
     for key, value in table.items():
         new_key = key_map.get(key)
-        if new_key:
-            value = table.get(key)
-            if value:
-                new_dict[new_key] = value
-            else:
-                new_dict[new_key] = value
+        if value:
+            new_dict[new_key] = value
     return new_dict
 
 
@@ -213,8 +145,7 @@ def normalize_mac(proposed_mac, module):
         else:
             raise ValueError
     except ValueError:
-        module.fail_json(msg='Invalid MAC address format',
-                             proposed_mac=proposed_mac)
+        module.fail_json(msg='Invalid MAC address format', proposed_mac=proposed_mac)
 
     joined_mac = ''.join(splitted_mac)
     mac = [joined_mac[i:i+4] for i in range(0, len(joined_mac), 4)]
@@ -224,7 +155,6 @@ def normalize_mac(proposed_mac, module):
 def main():
     argument_spec = dict(
         anycast_gateway_mac=dict(required=True, type='str'),
-        m_facts=dict(required=False, default=False, type='bool'),
     )
 
     argument_spec.update(nxos_argument_spec)
@@ -234,34 +164,27 @@ def main():
 
     warnings = list()
     check_args(module, warnings)
+    result = {'changed': False, 'commands': [], 'warnings': warnings}
 
-    args =  [
-        'anycast_gateway_mac'
-    ]
+    args = PARAM_TO_COMMAND_KEYMAP.keys()
 
-    existing = invoke('get_existing', module, args)
-    end_state = existing
+    existing = get_existing(module, args)
     proposed = dict((k, v) for k, v in module.params.items()
-                    if v is not None and k in args)
+                     if v is not None and k in args)
 
-    result = {}
     candidate = CustomNetworkConfig(indent=3)
-    invoke('get_commands', module, existing, proposed, candidate)
+    get_commands(module, existing, proposed, candidate)
 
-    if not module.check_mode:
-        load_config(module, candidate)
+    if candidate:
+        candidate = candidate.items_text()
+        result['commands'] = candidate
 
-    if module._verbosity > 0:
-        end_state = invoke('get_existing', module, args)
-        result['end_state'] = end_state
-        result['existing'] = existing
-        result['proposed'] = proposed
-
-    result['warnings'] = True
+        if not module.check_mode:
+            load_config(module, candidate)
+            result['changed'] = True
 
     module.exit_json(**result)
 
 
 if __name__ == '__main__':
     main()
-
diff --git a/test/units/modules/network/nxos/test_nxos_overlay_global.py b/test/units/modules/network/nxos/test_nxos_overlay_global.py
new file mode 100644
index 0000000000..3bcc9f8a61
--- /dev/null
+++ b/test/units/modules/network/nxos/test_nxos_overlay_global.py
@@ -0,0 +1,50 @@
+# (c) 2016 Red Hat Inc.
+#
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+
+# Make coding more python3-ish
+from __future__ import (absolute_import, division, print_function)
+__metaclass__ = type
+
+import json
+
+from ansible.compat.tests.mock import patch
+from ansible.modules.network.nxos import nxos_overlay_global
+from .nxos_module import TestNxosModule, load_fixture, set_module_args
+
+
+class TestNxosOverlayGlobalModule(TestNxosModule):
+
+    module = nxos_overlay_global
+
+    def setUp(self):
+        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_overlay_global.load_config')
+        self.load_config = self.mock_load_config.start()
+
+        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_overlay_global.get_config')
+        self.get_config = self.mock_get_config.start()
+
+    def tearDown(self):
+        self.mock_load_config.stop()
+        self.mock_get_config.stop()
+
+    def load_fixtures(self, commands=None, device=''):
+        self.load_config.return_value = None
+
+    def test_nxos_overlay_global_up(self):
+        set_module_args(dict(anycast_gateway_mac="b.b.b"))
+        result = self.execute_module(changed=True)
+        self.assertEqual(result['commands'], ['fabric forwarding anycast-gateway-mac 000B.000B.000B'])

commit cf51d0a790c50cc9429d0e00b25f4a846b67dc5d
Author: James Cammarata <jimi@sngx.net>
Date:   Wed Jul 1 15:10:25 2015 -0400

    Fixing up some check-mode stuff

diff --git a/lib/ansible/module_utils/basic.py b/lib/ansible/module_utils/basic.py
index e89809ff12..62caf384ff 100644
--- a/lib/ansible/module_utils/basic.py
+++ b/lib/ansible/module_utils/basic.py
@@ -908,11 +908,11 @@ class AnsibleModule(object):
 
     def _check_for_check_mode(self):
         for (k,v) in self.params.iteritems():
-            if k == '_ansible_check_mode':
+            if k == '_ansible_check_mode' and v:
                 if not self.supports_check_mode:
                     self.exit_json(skipped=True, msg="remote module does not support check mode")
-                if self.supports_check_mode:
-                    self.check_mode = True
+                self.check_mode = True
+                break
 
     def _check_for_no_log(self):
         for (k,v) in self.params.iteritems():
diff --git a/lib/ansible/plugins/action/add_host.py b/lib/ansible/plugins/action/add_host.py
index e28361b714..d7019d0f00 100644
--- a/lib/ansible/plugins/action/add_host.py
+++ b/lib/ansible/plugins/action/add_host.py
@@ -31,9 +31,8 @@ class ActionModule(ActionBase):
 
     def run(self, tmp=None, task_vars=dict()):
 
-        # FIXME: is this necessary in v2?
-        #if self.runner.noop_on_check(inject):
-        #    return ReturnData(conn=conn, comm_ok=True, result=dict(skipped=True, msg='check mode not supported for this module'))
+        if self._connection_info.check_mode:
+            return dict(skipped=True, msg='check mode not supported for this module')
 
         # Parse out any hostname:port patterns
         new_name = self._task.args.get('name', self._task.args.get('hostname', None))
diff --git a/lib/ansible/plugins/action/assemble.py b/lib/ansible/plugins/action/assemble.py
index 49f861f08e..82a77519d6 100644
--- a/lib/ansible/plugins/action/assemble.py
+++ b/lib/ansible/plugins/action/assemble.py
@@ -133,14 +133,8 @@ class ActionModule(ActionBase):
                 )
             )
 
-            # FIXME: checkmode stuff
-            #if self.runner.noop_on_check(inject):
-            #    return ReturnData(conn=conn, comm_ok=True, result=dict(changed=True), diff=dict(before_header=dest, after_header=src, after=resultant))
-            #else:
-            #    res = self.runner._execute_module(conn, tmp, 'copy', module_args_tmp, inject=inject)
-            #    res.diff = dict(after=resultant)
-            #    return res
             res = self._execute_module(module_name='copy', module_args=new_module_args, task_vars=task_vars, tmp=tmp)
+            # FIXME: diff stuff
             #res.diff = dict(after=resultant)
             return res
         else:
diff --git a/lib/ansible/plugins/action/async.py b/lib/ansible/plugins/action/async.py
index 0c73cd9d5c..d7b164935a 100644
--- a/lib/ansible/plugins/action/async.py
+++ b/lib/ansible/plugins/action/async.py
@@ -28,9 +28,8 @@ class ActionModule(ActionBase):
     def run(self, tmp=None, task_vars=dict()):
         ''' transfer the given module name, plus the async module, then run it '''
 
-        # FIXME: noop stuff needs to be sorted ut
-        #if self.runner.noop_on_check(inject):
-        #    return ReturnData(conn=conn, comm_ok=True, result=dict(skipped=True, msg='check mode not supported for this module'))
+        if self._connection_info.check_mode:
+            return dict(skipped=True, msg='check mode not supported for this module')
 
         if not tmp:
             tmp = self._make_tmp_path()
diff --git a/lib/ansible/plugins/action/copy.py b/lib/ansible/plugins/action/copy.py
index e556c80315..9a984f03a5 100644
--- a/lib/ansible/plugins/action/copy.py
+++ b/lib/ansible/plugins/action/copy.py
@@ -191,13 +191,13 @@ class ActionModule(ActionBase):
                 #    diff = {}
                 diff = {}
 
-                # FIXME: noop stuff
-                #if self.runner.noop_on_check(inject):
-                #    self._remove_tempfile_if_content_defined(content, content_tempfile)
-                #    diffs.append(diff)
-                #    changed = True
-                #    module_result = dict(changed=True)
-                #    continue
+                if self._connection_info.check_mode:
+                    self._remove_tempfile_if_content_defined(content, content_tempfile)
+                    # FIXME: diff stuff
+                    #diffs.append(diff)
+                    changed = True
+                    module_return = dict(changed=True)
+                    continue
 
                 # Define a remote directory that we will copy the file to.
                 tmp_src = tmp + 'source'
diff --git a/lib/ansible/plugins/action/fetch.py b/lib/ansible/plugins/action/fetch.py
index bc652265ba..a00ad154cc 100644
--- a/lib/ansible/plugins/action/fetch.py
+++ b/lib/ansible/plugins/action/fetch.py
@@ -36,9 +36,8 @@ class ActionModule(ActionBase):
     def run(self, tmp=None, task_vars=dict()):
         ''' handler for fetch operations '''
 
-        # FIXME: is this even required anymore?
-        #if self.runner.noop_on_check(inject):
-        #    return ReturnData(conn=conn, comm_ok=True, result=dict(skipped=True, msg='check mode not (yet) supported for this module'))
+        if self._connection_info.check_mode:
+            return dict(skipped=True, msg='check mode not (yet) supported for this module')
 
         source            = self._task.args.get('src', None)
         dest              = self._task.args.get('dest', None)
diff --git a/lib/ansible/plugins/action/patch.py b/lib/ansible/plugins/action/patch.py
index f0dbdedf05..e50b647bcb 100644
--- a/lib/ansible/plugins/action/patch.py
+++ b/lib/ansible/plugins/action/patch.py
@@ -51,10 +51,8 @@ class ActionModule(ActionBase):
         self._connection.put_file(src, tmp_src)
 
         if self._connection_info.become and self._connection_info.become_user != 'root':
-            # FIXME: noop stuff here
-            #if not self.runner.noop_on_check(inject):
-            #    self._remote_chmod('a+r', tmp_src, tmp)
-            self._remote_chmod('a+r', tmp_src, tmp)
+            if not self._connection_info.check_mode:
+                self._remote_chmod('a+r', tmp_src, tmp)
 
         new_module_args = self._task.args.copy()
         new_module_args.update(
diff --git a/lib/ansible/plugins/action/raw.py b/lib/ansible/plugins/action/raw.py
index f9cd56572b..a0da97798a 100644
--- a/lib/ansible/plugins/action/raw.py
+++ b/lib/ansible/plugins/action/raw.py
@@ -24,10 +24,9 @@ class ActionModule(ActionBase):
 
     def run(self, tmp=None, task_vars=dict()):
 
-        # FIXME: need to rework the noop stuff still
-        #if self.runner.noop_on_check(inject):
-        #    # in --check mode, always skip this module execution
-        #    return ReturnData(conn=conn, comm_ok=True, result=dict(skipped=True))
+        if self._connection_info.check_mode:
+            # in --check mode, always skip this module execution
+            return dict(skipped=True)
 
         executable = self._task.args.get('executable')
         result = self._low_level_execute_command(self._task.args.get('_raw_params'), tmp=tmp, executable=executable)
diff --git a/lib/ansible/plugins/action/script.py b/lib/ansible/plugins/action/script.py
index b3b95db9f8..c377aa62fe 100644
--- a/lib/ansible/plugins/action/script.py
+++ b/lib/ansible/plugins/action/script.py
@@ -28,11 +28,8 @@ class ActionModule(ActionBase):
     def run(self, tmp=None, task_vars=None):
         ''' handler for file transfer operations '''
 
-        # FIXME: noop stuff still needs to be sorted out
-        #if self.runner.noop_on_check(inject):
-        #    # in check mode, always skip this module
-        #    return ReturnData(conn=conn, comm_ok=True,
-        #                      result=dict(skipped=True, msg='check mode not supported for this module'))
+        if self._connection_info.check_mode:
+            return dict(skipped=True, msg='check mode not supported for this module')
 
         if not tmp:
             tmp = self._make_tmp_path()
diff --git a/lib/ansible/plugins/action/template.py b/lib/ansible/plugins/action/template.py
index 0b93f559c3..54520b2f7e 100644
--- a/lib/ansible/plugins/action/template.py
+++ b/lib/ansible/plugins/action/template.py
@@ -139,15 +139,6 @@ class ActionModule(ActionBase):
                 ),
             )
 
-            # FIXME: noop stuff needs to be sorted out
-            #if self.runner.noop_on_check(task_vars):
-            #    return ReturnData(conn=conn, comm_ok=True, result=dict(changed=True), diff=dict(before_header=dest, after_header=source, before=dest_contents, after=resultant))
-            #else:
-            #    res = self.runner._execute_module(conn, tmp, 'copy', module_args_tmp, task_vars=task_vars, complex_args=complex_args)
-            #    if res.result.get('changed', False):
-            #        res.diff = dict(before=dest_contents, after=resultant)
-            #    return res
-
             result = self._execute_module(module_name='copy', module_args=new_module_args, task_vars=task_vars)
             if result.get('changed', False):
                 result['diff'] = dict(before=dest_contents, after=resultant)
@@ -169,12 +160,5 @@ class ActionModule(ActionBase):
                 ),
             )
 
-            # FIXME: this may not be required anymore, as the checkmod params
-            #        should be in the regular module args?
-            # be sure to task_vars the check mode param into the module args and
-            # rely on the file module to report its changed status
-            #if self.runner.noop_on_check(task_vars):
-            #    new_module_args['CHECKMODE'] = True
-
             return self._execute_module(module_name='file', module_args=new_module_args, task_vars=task_vars)
 
diff --git a/lib/ansible/plugins/action/unarchive.py b/lib/ansible/plugins/action/unarchive.py
index ef5320b719..e5b143e597 100644
--- a/lib/ansible/plugins/action/unarchive.py
+++ b/lib/ansible/plugins/action/unarchive.py
@@ -78,10 +78,8 @@ class ActionModule(ActionBase):
         # fix file permissions when the copy is done as a different user
         if copy:
             if self._connection_info.become and self._connection_info.become_user != 'root':
-                # FIXME: noop stuff needs to be reworked
-                #if not self.runner.noop_on_check(task_vars):
-                #    self.runner._remote_chmod(conn, 'a+r', tmp_src, tmp)
-                self._remote_chmod(tmp, 'a+r', tmp_src)
+                if not self._connection_info.check_mode:
+                    self._remote_chmod(tmp, 'a+r', tmp_src)
 
             # Build temporary module_args.
             new_module_args = self._task.args.copy()
@@ -92,11 +90,6 @@ class ActionModule(ActionBase):
                 ),
             )
 
-            # make sure checkmod is passed on correctly
-            # FIXME: noop again, probably doesn't need to be done here anymore?
-            #if self.runner.noop_on_check(task_vars):
-            #    new_module_args['CHECKMODE'] = True
-
         else:
             new_module_args = self._task.args.copy()
             new_module_args.update(
@@ -104,10 +97,6 @@ class ActionModule(ActionBase):
                     original_basename=os.path.basename(source),
                 ),
             )
-            # make sure checkmod is passed on correctly
-            # FIXME: noop again, probably doesn't need to be done here anymore?
-            #if self.runner.noop_on_check(task_vars):
-            #    module_args += " CHECKMODE=True"
 
         # execute the unarchive module now, with the updated args
         return self._execute_module(module_args=new_module_args, task_vars=task_vars)

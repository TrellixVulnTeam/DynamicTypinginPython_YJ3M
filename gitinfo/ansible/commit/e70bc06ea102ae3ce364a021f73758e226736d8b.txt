commit e70bc06ea102ae3ce364a021f73758e226736d8b
Author: Ricardo Carrillo Cruz <ricardo.carrillo.cruz@gmail.com>
Date:   Mon Jan 30 17:52:19 2017 +0100

    Refactor iosxr_command to make use of network_connection plugin (#20772)

diff --git a/lib/ansible/modules/network/iosxr/iosxr_command.py b/lib/ansible/modules/network/iosxr/iosxr_command.py
index e266700bbf..5560321b92 100644
--- a/lib/ansible/modules/network/iosxr/iosxr_command.py
+++ b/lib/ansible/modules/network/iosxr/iosxr_command.py
@@ -24,7 +24,7 @@ DOCUMENTATION = """
 ---
 module: iosxr_command
 version_added: "2.1"
-author: "Peter Sprygada (@privateip)"
+author: "Ricardo Carrillo Cruz (@rcarrillocruz)"
 short_description: Run commands on remote devices running Cisco iosxr
 description:
   - Sends arbitrary commands to an iosxr node and returns the results
@@ -33,7 +33,6 @@ description:
     before returning or timing out if the condition is not met.
   - This module does not support running commands in configuration mode.
     Please use M(iosxr_config) to configure iosxr devices.
-extends_documentation_fragment: iosxr
 options:
   commands:
     description:
@@ -85,32 +84,21 @@ options:
 """
 
 EXAMPLES = """
-# Note: examples below use the following provider dict to handle
-#       transport and authentication to the node.
-vars:
-  cli:
-    host: "{{ inventory_hostname }}"
-    username: root
-    password: root
-
 tasks:
   - name: run show version on remote devices
     iosxr_command:
       commands: show version
-      provider: "{{ cli }}"
 
   - name: run show version and check to see if output contains iosxr
     iosxr_command:
       commands: show version
       wait_for: result[0] contains IOS-XR
-      provider: "{{ cli }}"
 
   - name: run multiple commands on remote nodes
      iosxr_command:
       commands:
         - show version
         - show interfaces
-      provider: "{{ cli }}"
 
   - name: run multiple commands and evaluate the output
     iosxr_command:
@@ -120,7 +108,6 @@ tasks:
       wait_for:
         - result[0] contains IOS-XR
         - result[1] contains Loopback0
-      provider: "{{ cli }}"
 """
 
 RETURN = """
@@ -129,24 +116,38 @@ stdout:
   returned: always
   type: list
   sample: ['...', '...']
-
 stdout_lines:
   description: The value of stdout split into a list
   returned: always
   type: list
   sample: [['...', '...'], ['...'], ['...']]
-
 failed_conditions:
   description: The list of conditionals that have failed
   returned: failed
   type: list
   sample: ['...', '...']
+start:
+  description: The time the job started
+  returned: always
+  type: str
+  sample: "2016-11-16 10:38:15.126146"
+end:
+  description: The time the job ended
+  returned: always
+  type: str
+  sample: "2016-11-16 10:38:25.595612"
+delta:
+  description: The time elapsed to perform all operations
+  returned: always
+  type: str
+  sample: "0:00:10.469466"
 """
-import ansible.module_utils.iosxr
-from ansible.module_utils.basic import get_exception
-from ansible.module_utils.netcli import CommandRunner
-from ansible.module_utils.netcli import AddCommandError, FailedConditionsError
-from ansible.module_utils.network import NetworkModule, NetworkError
+import time
+
+from ansible.module_utils.local import LocalAnsibleModule
+from ansible.module_utils.iosxr import run_commands
+from ansible.module_utils.network_common import ComplexList
+from ansible.module_utils.netcli import Conditional
 from ansible.module_utils.six import string_types
 
 VALID_KEYS = ['command', 'output', 'prompt', 'response']
@@ -157,18 +158,27 @@ def to_lines(stdout):
             item = str(item).split('\n')
         yield item
 
-def parse_commands(module):
-    for cmd in module.params['commands']:
-        if isinstance(cmd, string_types):
-            cmd = dict(command=cmd, output=None)
-        elif 'command' not in cmd:
-            module.fail_json(msg='command keyword argument is required')
-        elif cmd.get('output') not in [None, 'text']:
-            module.fail_json(msg='invalid output specified for command')
-        elif not set(cmd.keys()).issubset(VALID_KEYS):
-            module.fail_json(msg='unknown command keyword specified.  Valid '
-                                 'values are %s' % ', '.join(VALID_KEYS))
-        yield cmd
+def parse_commands(module, warnings):
+    command = ComplexList(dict(
+        command=dict(key=True),
+        prompt=dict(),
+        response=dict()
+    ))
+    commands = command(module.params['commands'])
+
+    for index, item in enumerate(commands):
+        if module.check_mode and not item['command'].startswith('show'):
+            warnings.append(
+                'only show commands are supported when using check mode, not '
+                'executing `%s`' % item['command']
+            )
+        elif item['command'].startswith('conf'):
+            module.fail_json(
+                msg='iosxr_command does not support running config mode '
+                    'commands.  Please use iosxr_config instead'
+            )
+        commands[index] = module.jsonify(item)
+    return commands
 
 def main():
     spec = dict(
@@ -182,62 +192,49 @@ def main():
         interval=dict(default=1, type='int')
     )
 
-    module = NetworkModule(argument_spec=spec,
-                           connect_on_load=False,
+    module = LocalAnsibleModule(argument_spec=spec,
                            supports_check_mode=True)
 
-    commands = list(parse_commands(module))
-    conditionals = module.params['wait_for'] or list()
-
     warnings = list()
+    commands = parse_commands(module, warnings)
 
-    runner = CommandRunner(module)
-
-    for cmd in commands:
-        if module.check_mode and not cmd['command'].startswith('show'):
-            warnings.append('only show commands are supported when using '
-                            'check mode, not executing `%s`' % cmd['command'])
-        else:
-            if cmd['command'].startswith('conf'):
-                module.fail_json(msg='iosxr_command does not support running '
-                                     'config mode commands.  Please use '
-                                     'iosxr_config instead')
-            try:
-                runner.add_command(**cmd)
-            except AddCommandError:
-                exc = get_exception()
-                warnings.append('duplicate command detected: %s' % cmd)
-
-    for item in conditionals:
-        runner.add_conditional(item)
-
-    runner.retries = module.params['retries']
-    runner.interval = module.params['interval']
-    runner.match = module.params['match']
-
-    try:
-        runner.run()
-    except FailedConditionsError:
-        exc = get_exception()
-        module.fail_json(msg=str(exc), failed_conditions=exc.failed_conditions)
-    except NetworkError:
-        exc = get_exception()
-        module.fail_json(msg=str(exc))
-
-    result = dict(changed=False, stdout=list())
-
-    for cmd in commands:
-        try:
-            output = runner.get_command(cmd['command'])
-        except ValueError:
-            output = 'command not executed due to check_mode, see warnings'
-        result['stdout'].append(output)
-
-    result['warnings'] = warnings
-    result['stdout_lines'] = list(to_lines(result['stdout']))
+    wait_for = module.params['wait_for'] or list()
+    conditionals = [Conditional(c) for c in wait_for]
 
-    module.exit_json(**result)
+    retries = module.params['retries']
+    interval = module.params['interval']
+    match = module.params['match']
 
+    while retries > 0:
+        responses = run_commands(module, commands)
+
+        for item in list(conditionals):
+            if item(responses):
+                if match == 'any':
+                    conditionals = list()
+                    break
+                conditionals.remove(item)
+
+        if not conditionals:
+            break
+
+        time.sleep(interval)
+        retries -= 1
+
+    if conditionals:
+        failed_conditions = [item.raw for item in conditionals]
+        msg = 'One or more conditional statements have not be satisfied'
+        module.fail_json(msg=msg, failed_conditions=failed_conditions)
+
+
+    result = {
+        'changed': False,
+        'stdout': responses,
+        'warnings': warnings,
+        'stdout_lines': list(to_lines(responses))
+    }
+
+    module.exit_json(**result)
 
 if __name__ == '__main__':
     main()
diff --git a/test/units/modules/network/iosxr/fixtures/show_version b/test/units/modules/network/iosxr/fixtures/show_version
new file mode 100644
index 0000000000..faecfffdcb
--- /dev/null
+++ b/test/units/modules/network/iosxr/fixtures/show_version
@@ -0,0 +1,84 @@
+Cisco IOS XR Software, Version 6.0.0[Default]
+Copyright (c) 2015 by Cisco Systems, Inc.
+
+ROM: GRUB, Version 1.99(0), DEV RELEASE
+
+iosxr01 uptime is 11 weeks, 2 days, 5 hours, 48 minutes
+System image file is "bootflash:disk0/xrvr-os-mbi-6.0.0/mbixrvr-rp.vm"
+
+cisco IOS XRv Series (Pentium Celeron Stepping 3) processor with 3169911K bytes of memory.
+Pentium Celeron Stepping 3 processor at 3836MHz, Revision 2.174
+IOS XRv Chassis
+
+1 Management Ethernet
+6 GigabitEthernet
+97070k bytes of non-volatile configuration memory.
+866M bytes of hard disk.
+2321392k bytes of disk0: (Sector size 512 bytes).
+
+Configuration register on node 0/0/CPU0 is 0x2102
+Boot device on node 0/0/CPU0 is disk0:
+Package active on node 0/0/CPU0:
+iosxr-infra, V 6.0.0[Default], Cisco Systems, at disk0:iosxr-infra-6.0.0
+    Built on Thu Dec 24 08:53:49 UTC 2015
+    By iox-lnx-010 in /auto/srcarchive16/production/6.0.0/xrvr/workspace for pie
+
+iosxr-fwding, V 6.0.0[Default], Cisco Systems, at disk0:iosxr-fwding-6.0.0
+    Built on Thu Dec 24 08:53:49 UTC 2015
+    By iox-lnx-010 in /auto/srcarchive16/production/6.0.0/xrvr/workspace for pie
+
+iosxr-routing, V 6.0.0[Default], Cisco Systems, at disk0:iosxr-routing-6.0.0
+    Built on Thu Dec 24 08:53:49 UTC 2015
+    By iox-lnx-010 in /auto/srcarchive16/production/6.0.0/xrvr/workspace for pie
+
+iosxr-ce, V 6.0.0[Default], Cisco Systems, at disk0:iosxr-ce-6.0.0
+    Built on Thu Dec 24 08:53:49 UTC 2015
+    By iox-lnx-010 in /auto/srcarchive16/production/6.0.0/xrvr/workspace for pie
+
+xrvr-os-mbi, V 6.0.0[Default], Cisco Systems, at disk0:xrvr-os-mbi-6.0.0
+    Built on Thu Dec 24 08:54:41 UTC 2015
+    By iox-lnx-010 in /auto/srcarchive16/production/6.0.0/xrvr/workspace for pie
+
+xrvr-base, V 6.0.0[Default], Cisco Systems, at disk0:xrvr-base-6.0.0
+    Built on Thu Dec 24 08:53:49 UTC 2015
+    By iox-lnx-010 in /auto/srcarchive16/production/6.0.0/xrvr/workspace for pie
+
+xrvr-fwding, V 6.0.0[Default], Cisco Systems, at disk0:xrvr-fwding-6.0.0
+    Built on Thu Dec 24 08:53:49 UTC 2015
+    By iox-lnx-010 in /auto/srcarchive16/production/6.0.0/xrvr/workspace for pie
+
+xrvr-mgbl-x, V 6.0.0[Default], Cisco Systems, at disk0:xrvr-mgbl-x-6.0.0
+    Built on Thu Dec 24 08:53:57 UTC 2015
+    By iox-lnx-010 in /auto/srcarchive16/production/6.0.0/xrvr/workspace for pie
+
+iosxr-mpls, V 6.0.0[Default], Cisco Systems, at disk0:iosxr-mpls-6.0.0
+    Built on Thu Dec 24 08:53:49 UTC 2015
+    By iox-lnx-010 in /auto/srcarchive16/production/6.0.0/xrvr/workspace for pie
+
+iosxr-mgbl, V 6.0.0[Default], Cisco Systems, at disk0:iosxr-mgbl-6.0.0
+    Built on Thu Dec 24 08:53:49 UTC 2015
+    By iox-lnx-010 in /auto/srcarchive16/production/6.0.0/xrvr/workspace for pie
+
+iosxr-mcast, V 6.0.0[Default], Cisco Systems, at disk0:iosxr-mcast-6.0.0
+    Built on Thu Dec 24 08:53:49 UTC 2015
+    By iox-lnx-010 in /auto/srcarchive16/production/6.0.0/xrvr/workspace for pie
+
+xrvr-mcast-supp, V 6.0.0[Default], Cisco Systems, at disk0:xrvr-mcast-supp-6.0.0
+    Built on Thu Dec 24 08:53:49 UTC 2015
+    By iox-lnx-010 in /auto/srcarchive16/production/6.0.0/xrvr/workspace for pie
+
+iosxr-bng, V 6.0.0[Default], Cisco Systems, at disk0:iosxr-bng-6.0.0
+    Built on Thu Dec 24 08:53:47 UTC 2015
+    By iox-lnx-010 in /auto/srcarchive16/production/6.0.0/xrvr/workspace for pie
+
+xrvr-bng-supp, V 6.0.0[Default], Cisco Systems, at disk0:xrvr-bng-supp-6.0.0
+    Built on Thu Dec 24 08:53:47 UTC 2015
+    By iox-lnx-010 in /auto/srcarchive16/production/6.0.0/xrvr/workspace for pie
+
+iosxr-security, V 6.0.0[Default], Cisco Systems, at disk0:iosxr-security-6.0.0
+    Built on Thu Dec 24 08:53:41 UTC 2015
+    By iox-lnx-010 in /auto/srcarchive16/production/6.0.0/xrvr/workspace for pie
+
+xrvr-fullk9-x, V 6.0.0[Default], Cisco Systems, at disk0:xrvr-fullk9-x-6.0.0
+    Built on Thu Dec 24 08:55:12 UTC 2015
+    By iox-lnx-010 in /auto/srcarchive16/production/6.0.0/xrvr/workspace for pie
diff --git a/test/units/modules/network/iosxr/test_iosxr_command.py b/test/units/modules/network/iosxr/test_iosxr_command.py
new file mode 100644
index 0000000000..c837296dc4
--- /dev/null
+++ b/test/units/modules/network/iosxr/test_iosxr_command.py
@@ -0,0 +1,143 @@
+# (c) 2016 Red Hat Inc.
+#
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+
+# Make coding more python3-ish
+from __future__ import (absolute_import, division, print_function)
+__metaclass__ = type
+
+import os
+import json
+
+from ansible.compat.tests import unittest
+from ansible.compat.tests.mock import patch, MagicMock
+from ansible.errors import AnsibleModuleExit
+from ansible.modules.network.iosxr import iosxr_command
+from ansible.module_utils import basic
+from ansible.module_utils._text import to_bytes
+
+
+def set_module_args(args):
+    args = json.dumps({'ANSIBLE_MODULE_ARGS': args})
+    basic._ANSIBLE_ARGS = to_bytes(args)
+
+fixture_path = os.path.join(os.path.dirname(__file__), 'fixtures')
+fixture_data = {}
+
+def load_fixture(name):
+    path = os.path.join(fixture_path, name)
+
+    if path in fixture_data:
+        return fixture_data[path]
+
+    with open(path) as f:
+        data = f.read()
+
+    try:
+        data = json.loads(data)
+    except:
+        pass
+
+    fixture_data[path] = data
+    return data
+
+
+class TestIosxrCommandModule(unittest.TestCase):
+
+    def setUp(self):
+        self.mock_run_commands = patch('ansible.modules.network.iosxr.iosxr_command.run_commands')
+        self.run_commands = self.mock_run_commands.start()
+
+    def tearDown(self):
+        self.mock_run_commands.stop()
+
+    def execute_module(self, failed=False, changed=False):
+
+        def load_from_file(*args, **kwargs):
+            module, commands = args
+            output = list()
+
+            for item in commands:
+                try:
+                    obj = json.loads(item)
+                    command = obj['command']
+                except ValueError:
+                    command = item
+                filename = str(command).replace(' ', '_')
+                output.append(load_fixture(filename))
+            return output
+
+        self.run_commands.side_effect = load_from_file
+
+        with self.assertRaises(AnsibleModuleExit) as exc:
+            iosxr_command.main()
+
+        result = exc.exception.result
+
+        if failed:
+            self.assertTrue(result.get('failed'))
+        else:
+            self.assertEqual(result.get('changed'), changed, result)
+
+        return result
+
+    def test_iosxr_command_simple(self):
+        set_module_args(dict(commands=['show version']))
+        result = self.execute_module()
+        self.assertEqual(len(result['stdout']), 1)
+        self.assertTrue(result['stdout'][0].startswith('Cisco IOS XR Software'))
+
+    def test_iosxr_command_multiple(self):
+        set_module_args(dict(commands=['show version', 'show version']))
+        result = self.execute_module()
+        self.assertEqual(len(result['stdout']), 2)
+        self.assertTrue(result['stdout'][0].startswith('Cisco IOS XR Software'))
+
+    def test_iosxr_command_wait_for(self):
+        wait_for = 'result[0] contains "Cisco IOS"'
+        set_module_args(dict(commands=['show version'], wait_for=wait_for))
+        self.execute_module()
+
+    def test_iosxr_command_wait_for_fails(self):
+        wait_for = 'result[0] contains "test string"'
+        set_module_args(dict(commands=['show version'], wait_for=wait_for))
+        self.execute_module(failed=True)
+        self.assertEqual(self.run_commands.call_count, 10)
+
+    def test_iosxr_command_retries(self):
+        wait_for = 'result[0] contains "test string"'
+        set_module_args(dict(commands=['show version'], wait_for=wait_for, retries=2))
+        self.execute_module(failed=True)
+        self.assertEqual(self.run_commands.call_count, 2)
+
+    def test_iosxr_command_match_any(self):
+        wait_for = ['result[0] contains "Cisco IOS"',
+                    'result[0] contains "test string"']
+        set_module_args(dict(commands=['show version'], wait_for=wait_for, match='any'))
+        self.execute_module()
+
+    def test_iosxr_command_match_all(self):
+        wait_for = ['result[0] contains "Cisco IOS"',
+                    'result[0] contains "XR Software"']
+        set_module_args(dict(commands=['show version'], wait_for=wait_for, match='all'))
+        self.execute_module()
+
+    def test_iosxr_command_match_all_failure(self):
+        wait_for = ['result[0] contains "Cisco IOS"',
+                    'result[0] contains "test string"']
+        commands = ['show version', 'show version']
+        set_module_args(dict(commands=commands, wait_for=wait_for, match='all'))
+        self.execute_module(failed=True)

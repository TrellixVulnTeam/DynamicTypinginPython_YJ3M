commit 3149db08698887fe4581d1fe52a01eed314d2b29
Author: Ansible Core Team <info@ansible.com>
Date:   Mon Mar 9 09:40:35 2020 +0000

    Migrated to cisco.nxos

diff --git a/lib/ansible/module_utils/network/nxos/argspec/acl_interfaces/acl_interfaces.py b/lib/ansible/module_utils/network/nxos/argspec/acl_interfaces/acl_interfaces.py
deleted file mode 100644
index baa1a70a28..0000000000
--- a/lib/ansible/module_utils/network/nxos/argspec/acl_interfaces/acl_interfaces.py
+++ /dev/null
@@ -1,91 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-"""
-The arg spec for the nxos_acl_interfaces module
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-class Acl_interfacesArgs(object):  # pylint: disable=R0903
-    """The arg spec for the nxos_acl_interfaces module
-    """
-
-    def __init__(self, **kwargs):
-        pass
-
-    argument_spec = {
-        'config': {
-            'elements': 'dict',
-            'options': {
-                'access_groups': {
-                    'elements': 'dict',
-                    'options': {
-                        'acls': {
-                            'elements': 'dict',
-                            'options': {
-                                'direction': {
-                                    'choices': ['in', 'out'],
-                                    'required': True,
-                                    'type': 'str'
-                                },
-                                'name': {
-                                    'required': True,
-                                    'type': 'str'
-                                },
-                                'port': {
-                                    'type': 'bool'
-                                }
-                            },
-                            'type': 'list'
-                        },
-                        'afi': {
-                            'choices': ['ipv4', 'ipv6'],
-                            'required': True,
-                            'type': 'str'
-                        }
-                    },
-                    'type': 'list'
-                },
-                'name': {
-                    'required': True,
-                    'type': 'str'
-                }
-            },
-            'type': 'list'
-        },
-        'running_config': {
-            'type': 'str'
-        },
-        'state': {
-            'choices': [
-                'deleted', 'gathered', 'merged', 'overridden', 'rendered',
-                'replaced', 'parsed'
-            ],
-            'default':
-            'merged',
-            'type':
-            'str'
-        }
-    }  # pylint: disable=C0301
diff --git a/lib/ansible/module_utils/network/nxos/argspec/acls/acls.py b/lib/ansible/module_utils/network/nxos/argspec/acls/acls.py
deleted file mode 100644
index 01e13f1893..0000000000
--- a/lib/ansible/module_utils/network/nxos/argspec/acls/acls.py
+++ /dev/null
@@ -1,425 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-"""
-The arg spec for the nxos_acls module
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-class AclsArgs(object):  # pylint: disable=R0903
-    """The arg spec for the nxos_acls module
-    """
-
-    def __init__(self, **kwargs):
-        pass
-
-    argument_spec = {
-        'config': {
-            'elements': 'dict',
-            'options': {
-                'acls': {
-                    'elements': 'dict',
-                    'options': {
-                        'aces': {
-                            'elements': 'dict',
-                            'mutually_exclusive': [['grant', 'remark']],
-                            'options': {
-                                'destination': {
-                                    'mutually_exclusive':
-                                    [['address', 'any', 'host', 'prefix'],
-                                     [
-                                         'wildcard_bits', 'any', 'host',
-                                         'prefix'
-                                    ]],
-                                    'options': {
-                                        'address': {
-                                            'type': 'str'
-                                        },
-                                        'any': {
-                                            'type': 'bool'
-                                        },
-                                        'host': {
-                                            'type': 'str'
-                                        },
-                                        'port_protocol': {
-                                            'mutually_exclusive': [[
-                                                'eq', 'lt', 'neq', 'gt',
-                                                'range'
-                                            ]],
-                                            'options': {
-                                                'eq': {
-                                                    'type': 'str'
-                                                },
-                                                'gt': {
-                                                    'type': 'str'
-                                                },
-                                                'lt': {
-                                                    'type': 'str'
-                                                },
-                                                'neq': {
-                                                    'type': 'str'
-                                                },
-                                                'range': {
-                                                    'options': {
-                                                        'end': {
-                                                            'type': 'str'
-                                                        },
-                                                        'start': {
-                                                            'type': 'str'
-                                                        }
-                                                    },
-                                                    'required_together':
-                                                    [['start', 'end']],
-                                                    'type': 'dict'
-                                                }
-                                            },
-                                            'type': 'dict'
-                                        },
-                                        'prefix': {
-                                            'type': 'str'
-                                        },
-                                        'wildcard_bits': {
-                                            'type': 'str'
-                                        }
-                                    },
-                                    'required_together':
-                                    [['address', 'wildcard_bits']],
-                                    'type': 'dict'
-                                },
-                                'dscp': {
-                                    'type': 'str'
-                                },
-                                'fragments': {
-                                    'type': 'bool'
-                                },
-                                'grant': {
-                                    'choices': ['permit', 'deny'],
-                                    'type': 'str'
-                                },
-                                'log': {
-                                    'type': 'bool'
-                                },
-                                'precedence': {
-                                    'type': 'str'
-                                },
-                                'protocol': {
-                                    'type': 'str'
-                                },
-                                'protocol_options': {
-                                    'mutually_exclusive':
-                                    [['icmp', 'igmp', 'tcp']],
-                                    'options': {
-                                        'icmp': {
-                                            'options': {
-                                                'administratively_prohibited':
-                                                {
-                                                    'type': 'bool'
-                                                },
-                                                'alternate_address': {
-                                                    'type': 'bool'
-                                                },
-                                                'conversion_error': {
-                                                    'type': 'bool'
-                                                },
-                                                'dod_host_prohibited': {
-                                                    'type': 'bool'
-                                                },
-                                                'dod_net_prohibited': {
-                                                    'type': 'bool'
-                                                },
-                                                'echo': {
-                                                    'type': 'bool'
-                                                },
-                                                'echo_reply': {
-                                                    'type': 'bool'
-                                                },
-                                                'general_parameter_problem': {
-                                                    'type': 'bool'
-                                                },
-                                                'host_isolated': {
-                                                    'type': 'bool'
-                                                },
-                                                'host_precedence_unreachable':
-                                                {
-                                                    'type': 'bool'
-                                                },
-                                                'host_redirect': {
-                                                    'type': 'bool'
-                                                },
-                                                'host_tos_redirect': {
-                                                    'type': 'bool'
-                                                },
-                                                'host_tos_unreachable': {
-                                                    'type': 'bool'
-                                                },
-                                                'host_unknown': {
-                                                    'type': 'bool'
-                                                },
-                                                'host_unreachable': {
-                                                    'type': 'bool'
-                                                },
-                                                'information_reply': {
-                                                    'type': 'bool'
-                                                },
-                                                'information_request': {
-                                                    'type': 'bool'
-                                                },
-                                                'mask_reply': {
-                                                    'type': 'bool'
-                                                },
-                                                'mask_request': {
-                                                    'type': 'bool'
-                                                },
-                                                'message_code': {
-                                                    'type': 'int'
-                                                },
-                                                'message_type': {
-                                                    'type': 'int'
-                                                },
-                                                'mobile_redirect': {
-                                                    'type': 'bool'
-                                                },
-                                                'net_redirect': {
-                                                    'type': 'bool'
-                                                },
-                                                'net_tos_redirect': {
-                                                    'type': 'bool'
-                                                },
-                                                'net_tos_unreachable': {
-                                                    'type': 'bool'
-                                                },
-                                                'net_unreachable': {
-                                                    'type': 'bool'
-                                                },
-                                                'network_unknown': {
-                                                    'type': 'bool'
-                                                },
-                                                'no_room_for_option': {
-                                                    'type': 'bool'
-                                                },
-                                                'option_missing': {
-                                                    'type': 'bool'
-                                                },
-                                                'packet_too_big': {
-                                                    'type': 'bool'
-                                                },
-                                                'parameter_problem': {
-                                                    'type': 'bool'
-                                                },
-                                                'port_unreachable': {
-                                                    'type': 'bool'
-                                                },
-                                                'precedence_unreachable': {
-                                                    'type': 'bool'
-                                                },
-                                                'protocol_unreachable': {
-                                                    'type': 'bool'
-                                                },
-                                                'reassembly_timeout': {
-                                                    'type': 'bool'
-                                                },
-                                                'redirect': {
-                                                    'type': 'bool'
-                                                },
-                                                'router_advertisement': {
-                                                    'type': 'bool'
-                                                },
-                                                'router_solicitation': {
-                                                    'type': 'bool'
-                                                },
-                                                'source_quench': {
-                                                    'type': 'bool'
-                                                },
-                                                'source_route_failed': {
-                                                    'type': 'bool'
-                                                },
-                                                'time_exceeded': {
-                                                    'type': 'bool'
-                                                },
-                                                'timestamp_reply': {
-                                                    'type': 'bool'
-                                                },
-                                                'timestamp_request': {
-                                                    'type': 'bool'
-                                                },
-                                                'traceroute': {
-                                                    'type': 'bool'
-                                                },
-                                                'ttl_exceeded': {
-                                                    'type': 'bool'
-                                                },
-                                                'unreachable': {
-                                                    'type': 'bool'
-                                                }
-                                            },
-                                            'type': 'dict'
-                                        },
-                                        'igmp': {
-                                            'mutually_exclusive': [[
-                                                'dvmrp', 'host_query',
-                                                'host_report'
-                                            ]],
-                                            'options': {
-                                                'dvmrp': {
-                                                    'type': 'bool'
-                                                },
-                                                'host_query': {
-                                                    'type': 'bool'
-                                                },
-                                                'host_report': {
-                                                    'type': 'bool'
-                                                }
-                                            },
-                                            'type':
-                                            'dict'
-                                        },
-                                        'tcp': {
-                                            'options': {
-                                                'ack': {
-                                                    'type': 'bool'
-                                                },
-                                                'established': {
-                                                    'type': 'bool'
-                                                },
-                                                'fin': {
-                                                    'type': 'bool'
-                                                },
-                                                'psh': {
-                                                    'type': 'bool'
-                                                },
-                                                'rst': {
-                                                    'type': 'bool'
-                                                },
-                                                'syn': {
-                                                    'type': 'bool'
-                                                },
-                                                'urg': {
-                                                    'type': 'bool'
-                                                }
-                                            },
-                                            'type': 'dict'
-                                        }
-                                    },
-                                    'type': 'dict'
-                                },
-                                'remark': {
-                                    'type': 'str'
-                                },
-                                'sequence': {
-                                    'type': 'int'
-                                },
-                                'source': {
-                                    'mutually_exclusive':
-                                    [['address', 'any', 'host', 'prefix'],
-                                     [
-                                         'wildcard_bits', 'host', 'any',
-                                         'prefix'
-                                    ]],
-                                    'options': {
-                                        'address': {
-                                            'type': 'str'
-                                        },
-                                        'any': {
-                                            'type': 'bool'
-                                        },
-                                        'host': {
-                                            'type': 'str'
-                                        },
-                                        'port_protocol': {
-                                            'mutually_exclusive':
-                                            [['eq', 'lt', 'neq', 'range'],
-                                             ['eq', 'gt', 'neq', 'range']],
-                                            'options': {
-                                                'eq': {
-                                                    'type': 'str'
-                                                },
-                                                'gt': {
-                                                    'type': 'str'
-                                                },
-                                                'lt': {
-                                                    'type': 'str'
-                                                },
-                                                'neq': {
-                                                    'type': 'str'
-                                                },
-                                                'range': {
-                                                    'options': {
-                                                        'end': {
-                                                            'type': 'str'
-                                                        },
-                                                        'start': {
-                                                            'type': 'str'
-                                                        }
-                                                    },
-                                                    'type': 'dict'
-                                                }
-                                            },
-                                            'type':
-                                            'dict'
-                                        },
-                                        'prefix': {
-                                            'type': 'str'
-                                        },
-                                        'wildcard_bits': {
-                                            'type': 'str'
-                                        }
-                                    },
-                                    'required_together':
-                                    [['address', 'wildcard_bits']],
-                                    'type':
-                                    'dict'
-                                }
-                            },
-                            'type': 'list'
-                        },
-                        'name': {
-                            'required': True,
-                            'type': 'str'
-                        }
-                    },
-                    'type': 'list'
-                },
-                'afi': {
-                    'choices': ['ipv4', 'ipv6'],
-                    'required': True,
-                    'type': 'str'
-                }
-            },
-            'type': 'list'
-        },
-        'running_config': {
-            'type': 'str'
-        },
-        'state': {
-            'choices': [
-                'deleted', 'gathered', 'merged', 'overridden', 'rendered',
-                'replaced', 'parsed'
-            ],
-            'default':
-            'merged',
-            'type':
-            'str'
-        }
-    }  # pylint: disable=C0301
diff --git a/lib/ansible/module_utils/network/nxos/argspec/bfd_interfaces/bfd_interfaces.py b/lib/ansible/module_utils/network/nxos/argspec/bfd_interfaces/bfd_interfaces.py
deleted file mode 100644
index 3c41030fe9..0000000000
--- a/lib/ansible/module_utils/network/nxos/argspec/bfd_interfaces/bfd_interfaces.py
+++ /dev/null
@@ -1,56 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Cisco and/or its affiliates.
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-"""
-The arg spec for the nxos_bfd_interfaces module
-"""
-
-
-class Bfd_interfacesArgs(object):  # pylint: disable=R0903
-    """The arg spec for the nxos_bfd_interfaces module
-    """
-
-    def __init__(self, **kwargs):
-        pass
-
-    argument_spec = {
-        'config': {
-            'elements': 'dict',
-            'options': {
-                'name': {'type': 'str'},
-                'bfd': {
-                    'choices': ['enable', 'disable'], 'type': 'str'},
-                'echo': {
-                    'choices': ['enable', 'disable'], 'type': 'str'},
-            },
-            'type': 'list'
-        },
-        'state': {
-            'choices': ['merged', 'replaced', 'overridden', 'deleted'],
-            'default': 'merged',
-            'type': 'str'
-        }
-    }  # pylint: disable=C0301
diff --git a/lib/ansible/module_utils/network/nxos/argspec/facts/facts.py b/lib/ansible/module_utils/network/nxos/argspec/facts/facts.py
deleted file mode 100644
index 889ae5f34b..0000000000
--- a/lib/ansible/module_utils/network/nxos/argspec/facts/facts.py
+++ /dev/null
@@ -1,21 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The arg spec for the nxos facts module.
-"""
-
-
-class FactsArgs(object):
-    """ The arg spec for the nxos facts module
-    """
-
-    def __init__(self, **kwargs):
-        pass
-
-    argument_spec = {
-        'gather_subset': dict(default=['!config'], type='list'),
-        'gather_network_resources': dict(type='list'),
-    }
diff --git a/lib/ansible/module_utils/network/nxos/argspec/hsrp_interfaces/hsrp_interfaces.py b/lib/ansible/module_utils/network/nxos/argspec/hsrp_interfaces/hsrp_interfaces.py
deleted file mode 100644
index 5183ce7ac8..0000000000
--- a/lib/ansible/module_utils/network/nxos/argspec/hsrp_interfaces/hsrp_interfaces.py
+++ /dev/null
@@ -1,54 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Cisco and/or its affiliates.
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-"""
-The arg spec for the nxos_hsrp_interfaces module
-"""
-
-
-class Hsrp_interfacesArgs(object):  # pylint: disable=R0903
-    """The arg spec for the nxos_hsrp_interfaces module
-    """
-
-    def __init__(self, **kwargs):
-        pass
-
-    argument_spec = {
-        'config': {
-            'type': 'list',
-            'elements': 'dict',
-            'options': {
-                'name': {'type': 'str'},
-                'bfd': {
-                    'choices': ['enable', 'disable'], 'type': 'str'},
-            },
-        },
-        'state': {
-            'choices': ['merged', 'replaced', 'overridden', 'deleted'],
-            'default': 'merged',
-            'type': 'str'
-        }
-    }  # pylint: disable=C0301
diff --git a/lib/ansible/module_utils/network/nxos/argspec/interfaces/interfaces.py b/lib/ansible/module_utils/network/nxos/argspec/interfaces/interfaces.py
deleted file mode 100644
index 1d9b7d0ead..0000000000
--- a/lib/ansible/module_utils/network/nxos/argspec/interfaces/interfaces.py
+++ /dev/null
@@ -1,80 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-"""
-The arg spec for the nxos_interfaces module
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-class InterfacesArgs(object):  # pylint: disable=R0903
-    """The arg spec for the nxos_interfaces module
-    """
-
-    def __init__(self, **kwargs):
-        pass
-
-    argument_spec = {
-        'config': {
-            'elements': 'dict',
-            'options': {
-                'description': {
-                    'type': 'str'
-                },
-                'duplex': {
-                    'choices': ['full', 'half', 'auto'],
-                    'type': 'str'
-                },
-                'enabled': {
-                    'type': 'bool'
-                },
-                'fabric_forwarding_anycast_gateway': {
-                    'type': 'bool'
-                },
-                'ip_forward': {
-                    'type': 'bool'
-                },
-                'mode': {
-                    'choices': ['layer2', 'layer3'],
-                    'type': 'str'
-                },
-                'mtu': {
-                    'type': 'str'
-                },
-                'name': {
-                    'required': True,
-                    'type': 'str'
-                },
-                'speed': {
-                    'type': 'str'
-                }
-            },
-            'type': 'list'
-        },
-        'state': {
-            'choices': ['merged', 'replaced', 'overridden', 'deleted'],
-            'default': 'merged',
-            'type': 'str'
-        }
-    }  # pylint: disable=C0301
diff --git a/lib/ansible/module_utils/network/nxos/argspec/l2_interfaces/l2_interfaces.py b/lib/ansible/module_utils/network/nxos/argspec/l2_interfaces/l2_interfaces.py
deleted file mode 100644
index db723be790..0000000000
--- a/lib/ansible/module_utils/network/nxos/argspec/l2_interfaces/l2_interfaces.py
+++ /dev/null
@@ -1,77 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-"""
-The arg spec for the nxos_l2_interfaces module
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-class L2_interfacesArgs(object):  # pylint: disable=R0903
-    """The arg spec for the nxos_l2_interfaces module
-    """
-
-    def __init__(self, **kwargs):
-        pass
-
-    argument_spec = {
-        'config': {
-            'elements': 'dict',
-            'options': {
-                'access': {
-                    'options': {
-                        'vlan': {
-                            'type': 'int'
-                        }
-                    },
-                    'type': 'dict'
-                },
-                'mode': {
-                    'type': 'str',
-                    'choices': ['access', 'trunk']
-                },
-                'name': {
-                    'required': True,
-                    'type': 'str'
-                },
-                'trunk': {
-                    'options': {
-                        'allowed_vlans': {
-                            'type': 'str'
-                        },
-                        'native_vlan': {
-                            'type': 'int'
-                        }
-                    },
-                    'type': 'dict'
-                }
-            },
-            'type': 'list'
-        },
-        'state': {
-            'choices': ['merged', 'replaced', 'overridden', 'deleted'],
-            'default': 'merged',
-            'type': 'str'
-        }
-    }  # pylint: disable=C0301
diff --git a/lib/ansible/module_utils/network/nxos/argspec/l3_interfaces/l3_interfaces.py b/lib/ansible/module_utils/network/nxos/argspec/l3_interfaces/l3_interfaces.py
deleted file mode 100644
index d6f2098bd6..0000000000
--- a/lib/ansible/module_utils/network/nxos/argspec/l3_interfaces/l3_interfaces.py
+++ /dev/null
@@ -1,90 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-"""
-The arg spec for the nxos_l3_interfaces module
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-class L3_interfacesArgs(object):  # pylint: disable=R0903
-    """The arg spec for the nxos_l3_interfaces module
-    """
-
-    def __init__(self, **kwargs):
-        pass
-
-    argument_spec = {
-        'config': {
-            'elements': 'dict',
-            'options': {
-                'dot1q': {
-                    'type': 'int'
-                },
-                'ipv4': {
-                    'elements': 'dict',
-                    'options': {
-                        'address': {
-                            'type': 'str'
-                        },
-                        'secondary': {
-                            'type': 'bool'
-                        },
-                        'tag': {
-                            'type': 'int'
-                        }
-                    },
-                    'type': 'list'
-                },
-                'ipv6': {
-                    'elements': 'dict',
-                    'options': {
-                        'address': {
-                            'type': 'str'
-                        },
-                        'tag': {
-                            'type': 'int'
-                        }
-                    },
-                    'type': 'list'
-                },
-                'name': {
-                    'required': True,
-                    'type': 'str'
-                },
-                'redirects': {
-                    'type': 'bool',
-                },
-                'unreachables': {
-                    'type': 'bool',
-                },
-            },
-            'type': 'list'
-        },
-        'state': {
-            'choices': ['merged', 'replaced', 'overridden', 'deleted'],
-            'default': 'merged',
-            'type': 'str'
-        }
-    }  # pylint: disable=C0301
diff --git a/lib/ansible/module_utils/network/nxos/argspec/lacp/lacp.py b/lib/ansible/module_utils/network/nxos/argspec/lacp/lacp.py
deleted file mode 100644
index b63c10f471..0000000000
--- a/lib/ansible/module_utils/network/nxos/argspec/lacp/lacp.py
+++ /dev/null
@@ -1,69 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-"""
-The arg spec for the nxos_lacp module
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-class LacpArgs(object):
-    """The arg spec for the nxos_lacp module
-    """
-
-    def __init__(self, **kwargs):
-        pass
-
-    argument_spec = {
-        'config': {
-            'options': {
-                'system': {
-                    'options': {
-                        'mac': {
-                            'options': {
-                                'address': {
-                                    'type': 'str'
-                                },
-                                'role': {
-                                    'choices': ['primary', 'secondary'],
-                                    'type': 'str'
-                                }
-                            },
-                            'type': 'dict'
-                        },
-                        'priority': {
-                            'type': 'int'
-                        }
-                    },
-                    'type': 'dict'
-                }
-            },
-            'type': 'dict'
-        },
-        'state': {
-            'choices': ['merged', 'replaced', 'deleted'],
-            'default': 'merged',
-            'type': 'str'
-        }
-    }
diff --git a/lib/ansible/module_utils/network/nxos/argspec/lacp_interfaces/lacp_interfaces.py b/lib/ansible/module_utils/network/nxos/argspec/lacp_interfaces/lacp_interfaces.py
deleted file mode 100644
index 5f72f21a1b..0000000000
--- a/lib/ansible/module_utils/network/nxos/argspec/lacp_interfaces/lacp_interfaces.py
+++ /dev/null
@@ -1,90 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-"""
-The arg spec for the nxos_lacp_interfaces module
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-class Lacp_interfacesArgs(object):
-    """The arg spec for the nxos_lacp_interfaces module
-    """
-
-    def __init__(self, **kwargs):
-        pass
-
-    argument_spec = {
-        'config': {
-            'elements': 'dict',
-            'options': {
-                'convergence': {
-                    'options': {
-                        'graceful': {
-                            'type': 'bool'
-                        },
-                        'vpc': {
-                            'type': 'bool'
-                        }
-                    },
-                    'type': 'dict'
-                },
-                'links': {
-                    'options': {
-                        'max': {
-                            'type': 'int'
-                        },
-                        'min': {
-                            'type': 'int'
-                        }
-                    },
-                    'type': 'dict'
-                },
-                'mode': {
-                    'choices': ['delay'],
-                    'type': 'str'
-                },
-                'name': {
-                    'required': True,
-                    'type': 'str'
-                },
-                'port_priority': {
-                    'type': 'int'
-                },
-                'rate': {
-                    'choices': ['fast', 'normal'],
-                    'type': 'str'
-                },
-                'suspend_individual': {
-                    'type': 'bool'
-                }
-            },
-            'type': 'list'
-        },
-        'state': {
-            'choices': ['merged', 'replaced', 'overridden', 'deleted'],
-            'default': 'merged',
-            'type': 'str'
-        }
-    }
diff --git a/lib/ansible/module_utils/network/nxos/argspec/lag_interfaces/lag_interfaces.py b/lib/ansible/module_utils/network/nxos/argspec/lag_interfaces/lag_interfaces.py
deleted file mode 100644
index dd200c177d..0000000000
--- a/lib/ansible/module_utils/network/nxos/argspec/lag_interfaces/lag_interfaces.py
+++ /dev/null
@@ -1,49 +0,0 @@
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-
-"""
-The arg spec for the nxos_lag_interfaces module
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-class Lag_interfacesArgs(object):
-    """The arg spec for the nxos_lag_interfaces module
-    """
-
-    def __init__(self, **kwargs):
-        pass
-
-    argument_spec = {'config': {'elements': 'dict',
-                                'options': {'members': {'elements': 'dict',
-                                                        'options': {'member': {'type': 'str'},
-                                                                    'mode': {'type': 'str',
-                                                                             'choices': ['active', 'on', 'passive']},
-                                                                    'force': {'type': 'bool'}},
-                                                        'type': 'list'},
-                                            'name': {'required': True, 'type': 'str'}},
-                                'type': 'list'},
-                     'state': {'choices': ['merged', 'replaced', 'overridden', 'deleted'],
-                               'default': 'merged',
-                               'type': 'str'}}
diff --git a/lib/ansible/module_utils/network/nxos/argspec/lldp_global/lldp_global.py b/lib/ansible/module_utils/network/nxos/argspec/lldp_global/lldp_global.py
deleted file mode 100644
index d3289fbf39..0000000000
--- a/lib/ansible/module_utils/network/nxos/argspec/lldp_global/lldp_global.py
+++ /dev/null
@@ -1,109 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-"""
-The arg spec for the nxos_lldp_global module
-"""
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-
-class Lldp_globalArgs(object):  # pylint: disable=R0903
-    """The arg spec for the nxos_lldp_global module
-    """
-
-    def __init__(self, **kwargs):
-        pass
-
-    argument_spec = {
-        'config': {
-            'options': {
-                'holdtime': {
-                    'type': 'int'
-                },
-                'port_id': {
-                    'choices': [0, 1],
-                    'type': 'int'
-                },
-                'reinit': {
-                    'type': 'int'
-                },
-                'timer': {
-                    'type': 'int'
-                },
-                'tlv_select': {
-                    'options': {
-                        'dcbxp': {
-                            'type': 'bool'
-                        },
-                        'management_address': {
-                            'options': {
-                                'v4': {
-                                    'type': 'bool'
-                                },
-                                'v6': {
-                                    'type': 'bool'
-                                }
-                            },
-                            'type': 'dict'
-                        },
-                        'port': {
-                            'options': {
-                                'description': {
-                                    'type': 'bool'
-                                },
-                                'vlan': {
-                                    'type': 'bool'
-                                }
-                            },
-                            'type': 'dict'
-                        },
-                        'power_management': {
-                            'type': 'bool'
-                        },
-                        'system': {
-                            'options': {
-                                'capabilities': {
-                                    'type': 'bool'
-                                },
-                                'description': {
-                                    'type': 'bool'
-                                },
-                                'name': {
-                                    'type': 'bool'
-                                }
-                            },
-                            'type': 'dict'
-                        }
-                    },
-                    'type': 'dict'
-                }
-            },
-            'type': 'dict'
-        },
-        'state': {
-            'choices': ['merged', 'replaced', 'deleted'],
-            'default': 'merged',
-            'type': 'str'
-        }
-    }
diff --git a/lib/ansible/module_utils/network/nxos/argspec/lldp_interfaces/lldp_interfaces.py b/lib/ansible/module_utils/network/nxos/argspec/lldp_interfaces/lldp_interfaces.py
deleted file mode 100644
index ee223eafe5..0000000000
--- a/lib/ansible/module_utils/network/nxos/argspec/lldp_interfaces/lldp_interfaces.py
+++ /dev/null
@@ -1,75 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-"""
-The arg spec for the nxos_lldp_interfaces module
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-class Lldp_interfacesArgs(object):  # pylint: disable=R0903
-    """The arg spec for the nxos_lldp_interfaces module
-    """
-
-    def __init__(self, **kwargs):
-        pass
-
-    argument_spec = {
-        'config': {
-            'elements': 'dict',
-            'options': {
-                'name': {
-                    'required': True,
-                    'type': 'str'
-                },
-                'receive': {
-                    'type': 'bool'
-                },
-                'tlv_set': {
-                    'options': {
-                        'management_address': {
-                            'type': 'str'
-                        },
-                        'vlan': {
-                            'type': 'int'
-                        }
-                    },
-                    'type': 'dict'
-                },
-                'transmit': {
-                    'type': 'bool'
-                }
-            },
-            'type': 'list'
-        },
-        'running_config': {
-            'type': 'str'
-        },
-        'state': {
-            'choices': ['deleted', 'gathered', 'merged', 'overridden', 'rendered',
-                        'replaced', 'parsed'],
-            'default': 'merged',
-            'type': 'str'
-        }
-    }  # pylint: disable=C0301
diff --git a/lib/ansible/module_utils/network/nxos/argspec/telemetry/telemetry.py b/lib/ansible/module_utils/network/nxos/argspec/telemetry/telemetry.py
deleted file mode 100644
index fd9753e245..0000000000
--- a/lib/ansible/module_utils/network/nxos/argspec/telemetry/telemetry.py
+++ /dev/null
@@ -1,90 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Cisco and/or its affiliates.
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-
-"""
-The arg spec for the nxos_telemetry module
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-class TelemetryArgs(object):  # pylint: disable=R0903
-    """The arg spec for the nxos_telemetry module
-    """
-
-    def __init__(self, **kwargs):
-        pass
-
-    argument_spec = {
-        'config': {
-            'options': {
-                'certificate': {
-                    'options': {
-                        'hostname': {'type': 'str'},
-                        'key': {'type': 'str'}},
-                    'type': 'dict'},
-                'compression': {'choices': ['gzip'], 'type': 'str'},
-                'source_interface': {'type': 'str'},
-                'vrf': {'type': 'str'},
-                'destination_groups': {
-                    'options': {
-                        'destination': {
-                            'options': {
-                                'encoding': {'choices': ['GPB', 'JSON'],
-                                             'type': 'str'},
-                                'ip': {'type': 'str'},
-                                'port': {'type': 'int'},
-                                'protocol': {'choices': ['HTTP', 'TCP', 'UDP', 'gRPC'],
-                                             'type': 'str'}},
-                            'type': 'dict'},
-                        'id': {'type': 'int'}},
-                    'type': 'list'},
-                'sensor_groups': {
-                    'options': {
-                        'data_source': {'choices': ['NX-API', 'DME', 'YANG'],
-                                        'type': 'str'},
-                        'id': {'type': 'int'},
-                        'path': {
-                            'options': {
-                                'depth': {'type': 'str'},
-                                'filter_condition': {'type': 'str'},
-                                'name': {'type': 'str'},
-                                'query_condition': {'type': 'str'}},
-                            'type': 'dict'}},
-                        'type': 'list'},
-                'subscriptions': {
-                    'options': {
-                        'destination_group': {'type': 'int'},
-                        'id': {'type': 'int'},
-                        'sensor_group': {
-                            'options': {
-                                'id': {'type': 'int'},
-                                'sample_interval': {'type': 'int'}},
-                            'type': 'dict'}},
-                    'type': 'list'}},
-            'type': 'dict'},
-        'state': {
-            'choices': ['merged', 'replaced', 'deleted'],
-            'default': 'merged',
-            'type': 'str'}}  # pylint: disable=C0301
diff --git a/lib/ansible/module_utils/network/nxos/argspec/vlans/vlans.py b/lib/ansible/module_utils/network/nxos/argspec/vlans/vlans.py
deleted file mode 100644
index e323c5dd4d..0000000000
--- a/lib/ansible/module_utils/network/nxos/argspec/vlans/vlans.py
+++ /dev/null
@@ -1,51 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-
-"""
-The arg spec for the nxos_vlans module
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-class VlansArgs(object):
-    """The arg spec for the nxos_vlans module
-    """
-
-    def __init__(self, **kwargs):
-        pass
-
-    argument_spec = {'config': {'elements': 'dict',
-                                'options': {'enabled': {'type': 'bool'},
-                                            'mapped_vni': {'type': 'int'},
-                                            'mode': {'choices': ['ce', 'fabricpath'],
-                                                     'type': 'str'},
-                                            'name': {'type': 'str'},
-                                            'vlan_id': {'required': True, 'type': 'int'},
-                                            'state': {'choices': ['active', 'suspend'],
-                                                      'type': 'str'}},
-                                'type': 'list'},
-                     'state': {'choices': ['merged', 'replaced', 'overridden', 'deleted'],
-                               'default': 'merged',
-                               'type': 'str'}}
diff --git a/lib/ansible/module_utils/network/nxos/cmdref/telemetry/telemetry.py b/lib/ansible/module_utils/network/nxos/cmdref/telemetry/telemetry.py
deleted file mode 100644
index 39f3604518..0000000000
--- a/lib/ansible/module_utils/network/nxos/cmdref/telemetry/telemetry.py
+++ /dev/null
@@ -1,145 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Cisco and/or its affiliates.
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-#
-# Telemetry Command Reference File
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-TMS_GLOBAL = '''
-# The cmd_ref is a yaml formatted list of module commands.
-# A leading underscore denotes a non-command variable; e.g. _template.
-# TMS does not have convenient global json data so this cmd_ref uses raw cli configs.
----
-_template: # _template holds common settings for all commands
-  # Enable feature telemetry if disabled
-  feature: telemetry
-  # Common get syntax for TMS commands
-  get_command: show run telemetry all
-  # Parent configuration for TMS commands
-  context:
-    - telemetry
-certificate:
-  _exclude: ['N3K', 'N5K', 'N6k', 'N7k']
-  kind: dict
-  getval: certificate (?P<key>\\S+) (?P<hostname>\\S+)$
-  setval: certificate {key} {hostname}
-  default:
-    key: ~
-    hostname: ~
-compression:
-  _exclude: ['N3K', 'N5K', 'N6k', 'N7k']
-  kind: str
-  getval: use-compression (\\S+)$
-  setval: 'use-compression {0}'
-  default: ~
-  context: &dpcontext
-    - telemetry
-    - destination-profile
-source_interface:
-  _exclude: ['N3K', 'N5K', 'N6k', 'N7k']
-  kind: str
-  getval: source-interface (\\S+)$
-  setval: 'source-interface {0}'
-  default: ~
-  context: *dpcontext
-vrf:
-  _exclude: ['N3K', 'N5K', 'N6k', 'N7k']
-  kind: str
-  getval: use-vrf (\\S+)$
-  setval: 'use-vrf {0}'
-  default: ~
-  context: *dpcontext
-'''
-
-TMS_DESTGROUP = '''
-# The cmd_ref is a yaml formatted list of module commands.
-# A leading underscore denotes a non-command variable; e.g. _template.
-# TBD: Use Structured Where Possible
----
-_template: # _template holds common settings for all commands
-  # Enable feature telemetry if disabled
-  feature: telemetry
-  # Common get syntax for TMS commands
-  get_command: show run telemetry all
-  # Parent configuration for TMS commands
-  context:
-    - telemetry
-destination:
-  _exclude: ['N3K', 'N5K', 'N6k', 'N7k']
-  multiple: true
-  kind: dict
-  getval: ip address (?P<ip>\\S+) port (?P<port>\\S+) protocol (?P<protocol>\\S+) encoding (?P<encoding>\\S+)
-  setval: ip address {ip} port {port} protocol {protocol} encoding {encoding}
-  default:
-    ip: ~
-    port: ~
-    protocol: ~
-    encoding: ~
-'''
-
-TMS_SENSORGROUP = '''
-# The cmd_ref is a yaml formatted list of module commands.
-# A leading underscore denotes a non-command variable; e.g. _template.
-# TBD: Use Structured Where Possible
----
-_template: # _template holds common settings for all commands
-  # Enable feature telemetry if disabled
-  feature: telemetry
-  # Common get syntax for TMS commands
-  get_command: show run telemetry all
-  # Parent configuration for TMS commands
-  context:
-    - telemetry
-data_source:
-  _exclude: ['N3K', 'N5K', 'N6k', 'N7k']
-  kind: str
-  getval: data-source (\\S+)$
-  setval: 'data-source {0}'
-  default: ~
-path:
-  _exclude: ['N3K', 'N5K', 'N6k', 'N7k']
-  multiple: true
-  kind: dict
-  getval: path (?P<name>(\\S+|".*"))( depth (?P<depth>\\S+))?( query-condition (?P<query_condition>\\S+))?( filter-condition (?P<filter_condition>\\S+))?$
-  setval: path {name} depth {depth} query-condition {query_condition} filter-condition {filter_condition}
-  default:
-    name: ~
-    depth: ~
-    query_condition: ~
-    filter_condition: ~
-'''
-
-TMS_SUBSCRIPTION = '''
-# The cmd_ref is a yaml formatted list of module commands.
-# A leading underscore denotes a non-command variable; e.g. _template.
-# TBD: Use Structured Where Possible
----
-_template: # _template holds common settings for all commands
-  # Enable feature telemetry if disabled
-  feature: telemetry
-  # Common get syntax for TMS commands
-  get_command: show run telemetry all
-  # Parent configuration for TMS commands
-  context:
-    - telemetry
-destination_group:
-  _exclude: ['N3K', 'N5K', 'N6k', 'N7k']
-  multiple: true
-  kind: int
-  getval: dst-grp (\\S+)$
-  setval: 'dst-grp {0}'
-  default: ~
-sensor_group:
-  _exclude: ['N3K', 'N5K', 'N6k', 'N7k']
-  multiple: true
-  kind: dict
-  getval: snsr-grp (?P<id>\\S+) sample-interval (?P<sample_interval>\\S+)$
-  setval: snsr-grp {id} sample-interval {sample_interval}
-  default:
-    id: ~
-    sample_interval: ~
-'''
diff --git a/lib/ansible/module_utils/network/nxos/config/acl_interfaces/acl_interfaces.py b/lib/ansible/module_utils/network/nxos/config/acl_interfaces/acl_interfaces.py
deleted file mode 100644
index e5b56f82b1..0000000000
--- a/lib/ansible/module_utils/network/nxos/config/acl_interfaces/acl_interfaces.py
+++ /dev/null
@@ -1,303 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos_acl_interfaces class
-It is in this file where the current configuration (as dict)
-is compared to the provided configuration (as dict) and the command set
-necessary to bring the current configuration to it's desired end-state is
-created
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-from ansible.module_utils.network.common.cfg.base import ConfigBase
-from ansible.module_utils.network.common.utils import to_list, remove_empties, dict_diff
-from ansible.module_utils.network.nxos.facts.facts import Facts
-from ansible.module_utils.network.nxos.utils.utils import flatten_dict, search_obj_in_list, get_interface_type, normalize_interface
-
-
-class Acl_interfaces(ConfigBase):
-    """
-    The nxos_acl_interfaces class
-    """
-
-    gather_subset = [
-        '!all',
-        '!min',
-    ]
-
-    gather_network_resources = [
-        'acl_interfaces',
-    ]
-
-    def __init__(self, module):
-        super(Acl_interfaces, self).__init__(module)
-
-    def get_acl_interfaces_facts(self, data=None):
-        """ Get the 'facts' (the current configuration)
-
-        :rtype: A dictionary
-        :returns: The current configuration as a dictionary
-        """
-        facts, _warnings = Facts(self._module).get_facts(
-            self.gather_subset, self.gather_network_resources, data=data)
-        acl_interfaces_facts = facts['ansible_network_resources'].get(
-            'acl_interfaces')
-        if not acl_interfaces_facts:
-            return []
-        return acl_interfaces_facts
-
-    def edit_config(self, commands):
-        """Wrapper method for `_connection.edit_config()`
-        This exists solely to allow the unit test framework to mock device connection calls.
-        """
-        return self._connection.edit_config(commands)
-
-    def execute_module(self):
-        """ Execute the module
-
-        :rtype: A dictionary
-        :returns: The result from module execution
-        """
-        result = {'changed': False}
-        warnings = list()
-        commands = list()
-        state = self._module.params['state']
-        action_states = ['merged', 'replaced', 'deleted', 'overridden']
-
-        if state == 'gathered':
-            result['gathered'] = self.get_acl_interfaces_facts()
-        elif state == 'rendered':
-            result['rendered'] = self.set_config({})
-            # no need to fetch facts for rendered
-        elif state == 'parsed':
-            result['parsed'] = self.set_config({})
-            # no need to fetch facts for parsed
-        else:
-            existing_acl_interfaces_facts = self.get_acl_interfaces_facts()
-            commands.extend(self.set_config(existing_acl_interfaces_facts))
-            if commands and state in action_states:
-                if not self._module.check_mode:
-                    self._connection.edit_config(commands)
-                result['changed'] = True
-                result['before'] = existing_acl_interfaces_facts
-                result['commands'] = commands
-
-            changed_acl_interfaces_facts = self.get_acl_interfaces_facts()
-            if result['changed']:
-                result['after'] = changed_acl_interfaces_facts
-        result['warnings'] = warnings
-        return result
-
-    def set_config(self, existing_acl_interfaces_facts):
-        """ Collect the configuration from the args passed to the module,
-            collect the current configuration (as a dict from facts)
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        config = self._module.params['config']
-        want = []
-        if config:
-            for w in config:
-                if get_interface_type(w['name']) == 'loopback':
-                    self._module.fail_json(
-                        msg='This module works with ethernet, management or port-channe')
-                w.update({'name': normalize_interface(w['name'])})
-                want.append(remove_empties(w))
-        have = existing_acl_interfaces_facts
-        resp = self.set_state(want, have)
-        return to_list(resp)
-
-    def set_state(self, want, have):
-        """ Select the appropriate function based on the state provided
-
-        :param want: the desired configuration as a dictionary
-        :param have: the current configuration as a dictionary
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        state = self._module.params['state']
-        commands = []
-        if state == 'overridden':
-            commands = (self._state_overridden(want, have))
-        elif state == 'deleted':
-            commands = (self._state_deleted(want, have))
-        elif state == 'rendered':
-            commands = self._state_rendered(want)
-        elif state == 'parsed':
-            want = self._module.params['running_config']
-            commands = self._state_parsed(want)
-        else:
-            for w in want:
-                if state == 'merged':
-                    commands.extend(self._state_merged(w, have))
-                elif state == 'replaced':
-                    commands.extend(self._state_replaced(w, have))
-        return commands
-
-    def _state_parsed(self, want):
-        return self.get_acl_interfaces_facts(want)
-
-    def _state_rendered(self, want):
-        commands = []
-        for w in want:
-            commands.extend(self.set_commands(w, {}))
-        return commands
-
-    def _state_replaced(self, want, have):
-        """ The command generator when state is replaced
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        new_commands = []
-        del_dict = {'name': want['name'], 'access_groups': []}
-        obj_in_have = search_obj_in_list(want['name'], have, 'name')
-        if obj_in_have != want:
-            commands = []
-            if obj_in_have and 'access_groups' in obj_in_have.keys():
-                for ag in obj_in_have['access_groups']:
-                    want_afi = []
-                    if want.get('access_groups'):
-                        want_afi = search_obj_in_list(
-                            ag['afi'], want['access_groups'], 'afi')
-                    if not want_afi:
-                        # whatever in have is not in want
-                        del_dict['access_groups'].append(ag)
-                    else:
-                        del_acl = []
-                        for acl in ag['acls']:
-                            if want_afi.get('acls'):
-                                if acl not in want_afi['acls']:
-                                    del_acl.append(acl)
-                            else:
-                                del_acl.append(acl)
-                        afi = want_afi['afi']
-                        del_dict['access_groups'].append(
-                            {'afi': afi, 'acls': del_acl})
-
-            commands.extend(self._state_deleted([del_dict], have))
-            commands.extend(self._state_merged(want, have))
-            new_commands.append(commands[0])
-            commands = [commands[i]
-                        for i in range(1, len(commands)) if commands[i] != commands[0]]
-            new_commands.extend(commands)
-        return new_commands
-
-    def _state_overridden(self, want, have):
-        """ The command generator when state is overridden
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        commands = []
-        want_intf = [w['name'] for w in want]
-        for h in have:
-            if h['name'] not in want_intf:
-                commands.extend(self._state_deleted([h], have))
-        for w in want:
-            commands.extend(self._state_replaced(w, have))
-        return commands
-
-    def _state_merged(self, want, have):
-        """ The command generator when state is merged
-
-        :rtype: A list
-        :returns: the commands necessary to merge the provided into
-                  the current configuration
-        """
-        return self.set_commands(want, have)
-
-    def set_commands(self, want, have, deleted=False):
-        commands = []
-        have_name = search_obj_in_list(want['name'], have, 'name')
-        if have_name and have_name.get('access_groups'):
-            if want.get('access_groups'):
-                for w_afi in want['access_groups']:
-                    ip = 'ipv6'
-                    if w_afi['afi'] == 'ipv4':
-                        ip = 'ip'
-                    have_afi = search_obj_in_list(
-                        w_afi['afi'], have_name['access_groups'], 'afi')
-                    if have_afi:
-                        new_acls = []
-                        if deleted:
-                            if w_afi.get('acls') and have_afi.get('acls'):
-                                new_acls = [
-                                    acl for acl in w_afi.get('acls') if acl in have_afi.get('acls')]
-                            elif 'acls' not in w_afi.keys():
-                                new_acls = have_afi.get('acls')
-                        else:
-                            if w_afi.get('acls'):
-                                new_acls = [
-                                    acl for acl in w_afi['acls'] if acl not in have_afi['acls']]
-                        commands.extend(self.process_acl(
-                            new_acls, ip, deleted))
-                    else:
-                        if not deleted:
-                            if w_afi.get('acls'):
-                                commands.extend(
-                                    self.process_acl(w_afi['acls'], ip))
-            else:
-                # only name is given to delete
-                if deleted and 'access_groups' in have_name.keys():
-                    commands.extend(self.process_access_group(have_name, True))
-        else:
-            if not deleted:  # and 'access_groups' in have_name.keys():
-                commands.extend(self.process_access_group(want))
-
-        if len(commands) > 0:
-            commands.insert(0, 'interface ' + want['name'])
-        return commands
-
-    def process_access_group(self, item, deleted=False):
-        commands = []
-        for ag in item['access_groups']:
-            ip = 'ipv6'
-            if ag['afi'] == 'ipv4':
-                ip = 'ip'
-            if ag.get('acls'):
-                commands.extend(self.process_acl(
-                    ag['acls'], ip, deleted))
-        return commands
-
-    def process_acl(self, acls, ip, deleted=False):
-        commands = []
-        no = ''
-        if deleted:
-            no = 'no '
-        for acl in acls:
-            port = ''
-            if acl.get('port'):
-                port = ' port'
-            ag = ' access-group '
-            if ip == 'ipv6':
-                ag = ' traffic-filter '
-            commands.append(no + ip + port + ag +
-                            acl['name'] + ' ' + acl['direction'])
-        return commands
-
-    def _state_deleted(self, main_want, have):
-        """ The command generator when state is deleted
-
-        :rtype: A list
-        :returns: the commands necessary to remove the current configuration
-                  of the provided objects
-        """
-        commands = []
-        if main_want:
-            for want in main_want:
-                commands.extend(self.set_commands(want, have, deleted=True))
-        else:
-            for h in have:
-                commands.extend(self.set_commands(h, have, deleted=True))
-
-        return commands
diff --git a/lib/ansible/module_utils/network/nxos/config/acls/acls.py b/lib/ansible/module_utils/network/nxos/config/acls/acls.py
deleted file mode 100644
index 37c8b3d23a..0000000000
--- a/lib/ansible/module_utils/network/nxos/config/acls/acls.py
+++ /dev/null
@@ -1,690 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos_acls class
-It is in this file where the current configuration (as dict)
-is compared to the provided configuration (as dict) and the command set
-necessary to bring the current configuration to it's desired end-state is
-created
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-import socket
-import re
-from copy import deepcopy
-from ansible.module_utils.network.common.cfg.base import ConfigBase
-from ansible.module_utils.network.common.utils import to_list, remove_empties, dict_diff
-from ansible.module_utils.network.nxos.facts.facts import Facts
-from ansible.module_utils.network.nxos.argspec.acls.acls import AclsArgs
-from ansible.module_utils.network.common import utils
-from ansible.module_utils.network.nxos.utils.utils import flatten_dict, search_obj_in_list, get_interface_type, normalize_interface
-
-
-class Acls(ConfigBase):
-    """
-    The nxos_acls class
-    """
-
-    gather_subset = [
-        '!all',
-        '!min',
-    ]
-
-    gather_network_resources = [
-        'acls',
-    ]
-
-    def __init__(self, module):
-        super(Acls, self).__init__(module)
-
-    def get_acls_facts(self, data=None):
-        """ Get the 'facts' (the current configuration)
-
-        :rtype: A dictionary
-        :returns: The current configuration as a dictionary
-        """
-        facts, _warnings = Facts(self._module).get_facts(
-            self.gather_subset, self.gather_network_resources, data=data)
-        acls_facts = facts['ansible_network_resources'].get('acls')
-        if not acls_facts:
-            return []
-        return acls_facts
-
-    def edit_config(self, commands):
-        """Wrapper method for `_connection.edit_config()`
-        This exists solely to allow the unit test framework to mock device connection calls.
-        """
-        return self._connection.edit_config(commands)
-
-    def execute_module(self):
-        """ Execute the module
-
-        :rtype: A dictionary
-        :returns: The result from module execution
-        """
-        result = {'changed': False}
-        warnings = list()
-        commands = list()
-        state = self._module.params['state']
-        action_states = ['merged', 'replaced', 'deleted', 'overridden']
-
-        if state == 'gathered':
-            result['gathered'] = self.get_acls_facts()
-        elif state == 'rendered':
-            result['rendered'] = self.set_config({})
-        elif state == 'parsed':
-            result['parsed'] = self.set_config({})
-        else:
-            existing_acls_facts = self.get_acls_facts()
-            commands.extend(self.set_config(existing_acls_facts))
-            if commands and state in action_states:
-                if not self._module.check_mode:
-                    self._connection.edit_config(commands)
-                result['changed'] = True
-                result['before'] = existing_acls_facts
-                result['commands'] = commands
-
-            changed_acls_facts = self.get_acls_facts()
-            if result['changed']:
-                result['after'] = changed_acls_facts
-        result['warnings'] = warnings
-        return result
-
-    def set_config(self, existing_acls_facts):
-        """ Collect the configuration from the args passed to the module,
-            collect the current configuration (as a dict from facts)
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        config = self._module.params['config']
-        want = []
-        if config:
-            for w in config:
-                want.append(remove_empties(w))
-        have = existing_acls_facts
-        if want:
-            want = self.convert_values(want)
-        resp = self.set_state(want, have)
-        return to_list(resp)
-
-    def convert_values(self, want):
-        '''
-        This method is used to map and convert the user given values with what will actually be present in the device configuation
-        '''
-        port_protocol = {
-            515: 'lpd',
-            517: 'talk',
-            7: 'echo',
-            9: 'discard',
-            12: 'exec',
-            13: 'login',
-            14: 'cmd',
-            109: 'pop2',
-            19: 'chargen',
-            20: 'ftp-data',
-            21: 'ftp',
-            23: 'telnet',
-            25: 'smtp',
-            540: 'uucp',
-            543: 'klogin',
-            544: 'kshell',
-            37: 'time',
-            43: 'whois',
-            49: 'tacacs',
-            179: 'bgp',
-            53: 'domain',
-            194: 'irc',
-            70: 'gopher',
-            79: 'finger',
-            80: 'www',
-            101: 'hostname',
-            3949: 'drip',
-            110: 'pop3',
-            111: 'sunrpc',
-            496: 'pim-auto-rp',
-            113: 'ident',
-            119: 'nntp'
-        }
-        protocol = {
-            1: 'icmp',
-            2: 'igmp',
-            4: 'ip',
-            6: 'tcp',
-            103: 'pim',
-            108: 'pcp',
-            47: 'gre',
-            17: 'udp',
-            50: 'esp',
-            51: 'ahp',
-            88: 'eigrp',
-            89: 'ospf',
-            94: 'nos'
-        }
-        precedence = {
-            0: 'routine',
-            1: 'priority',
-            2: 'immediate',
-            3: 'flash',
-            4: 'flash-override',
-            5: 'critical',
-            6: 'internet',
-            7: 'network'
-        }
-        dscp = {
-            10: 'AF11',
-            12: 'AF12',
-            14: 'AF13',
-            18: 'AF21',
-            20: 'AF22',
-            22: 'AF23',
-            26: 'AF31',
-            28: 'AF32',
-            30: 'AF33',
-            34: 'AF41',
-            36: 'AF42',
-            38: 'AF43',
-            8: 'CS1',
-            16: 'CS2',
-            24: 'CS3',
-            32: 'CS4',
-            40: 'CS5',
-            48: 'CS6',
-            56: 'CS7',
-            0: 'Default',
-            46: 'EF'
-        }
-        # port_pro_num = list(protocol.keys())
-        for afi in want:
-            if 'acls' in afi.keys():
-                for acl in afi['acls']:
-                    if 'aces' in acl.keys():
-                        for ace in acl['aces']:
-                            if 'dscp' in ace.keys():
-                                if ace['dscp'].isdigit():
-                                    ace['dscp'] = dscp[int(ace['dscp'])]
-                                ace['dscp'] = ace['dscp'].lower()
-                            if 'precedence' in ace.keys():
-                                if ace['precedence'].isdigit():
-                                    ace['precedence'] = precedence[int(
-                                        ace['precedence'])]
-                            if 'protocol' in ace.keys(
-                            ) and ace['protocol'].isdigit() and int(
-                                    ace['protocol']) in protocol.keys():
-                                ace['protocol'] = protocol[int(
-                                    ace['protocol'])]
-                                # convert number to name
-                            if 'protocol' in ace.keys(
-                            ) and ace['protocol'] in ['tcp', 'udp']:
-                                for end in ['source', 'destination']:
-                                    if 'port_protocol' in ace[end].keys():
-                                        key = list(ace[end]
-                                                   ['port_protocol'].keys())[0]
-                                        # key could be eq,gt,lt,neq or range
-                                        if key != 'range':
-                                            val = ace[end]['port_protocol'][
-                                                key]
-                                            if val.isdigit() and int(val) in port_protocol.keys(
-                                            ):
-                                                ace[end]['port_protocol'][
-                                                    key] = port_protocol[int(
-                                                        val)]
-                                        else:
-                                            st = int(ace[end]['port_protocol']
-                                                     ['range']['start'])
-
-                                            end = int(ace[end]['port_protocol']
-                                                      ['range']['end'])
-
-                                            if st in port_protocol.keys():
-                                                ace[end]['port_protocol'][
-                                                    'range'][
-                                                        'start'] = port_protocol[
-                                                            st]
-                                            if end in port_protocol.keys():
-                                                ace[end]['port_protocol'][
-                                                    'range'][
-                                                        'end'] = port_protocol[
-                                                            end]
-        return want
-
-    def set_state(self, want, have):
-        """ Select the appropriate function based on the state provided
-
-        :param want: the desired configuration as a dictionary
-        :param have: the current configuration as a dictionary
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        state = self._module.params['state']
-        commands = []
-        if state == 'overridden':
-            commands = (self._state_overridden(want, have))
-        elif state == 'deleted':
-            commands = (self._state_deleted(want, have))
-        elif state == 'rendered':
-            commands = self._state_rendered(want)
-        elif state == 'parsed':
-            want = self._module.params['running_config']
-            commands = self._state_parsed(want)
-        else:
-            for w in want:
-                if state == 'merged':
-                    commands.extend(self._state_merged(w, have))
-                elif state == 'replaced':
-                    commands.extend(self._state_replaced(w, have))
-        if state != 'parsed':
-            commands = [c.strip() for c in commands]
-        return commands
-
-    def _state_parsed(self, want):
-        return self.get_acls_facts(want)
-
-    def _state_rendered(self, want):
-        commands = []
-        for w in want:
-            commands.extend(self.set_commands(w, {}))
-        return commands
-
-    def _state_replaced(self, want, have):
-        """ The command generator when state is replaced
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        commands = []
-        have_afi = search_obj_in_list(want['afi'], have, 'afi')
-        del_dict = {'acls': []}
-        want_names = []
-        if have_afi != want:
-            if have_afi:
-                del_dict.update({'afi': have_afi['afi'], 'acls': []})
-                if want.get('acls'):
-                    want_names = [w['name'] for w in want['acls']]
-                    have_names = [h['name'] for h in have_afi['acls']]
-                    want_acls = want.get('acls')
-                    for w in want_acls:
-                        acl_commands = []
-                        if w['name'] not in have_names:
-                            # creates new ACL in replaced state
-                            merge_dict = {'afi': want['afi'], 'acls': [w]}
-                            commands.extend(
-                                self._state_merged(merge_dict, have))
-                        else:
-                            # acl in want exists in have
-                            have_name = search_obj_in_list(
-                                w['name'], have_afi['acls'], 'name')
-                            have_aces = have_name.get('aces') if have_name.get(
-                                'aces') else []
-                            merge_aces = []
-                            del_aces = []
-                            w_aces = w.get('aces') if w.get('aces') else []
-
-                            for ace in have_aces:
-                                if ace not in w_aces:
-                                    del_aces.append(ace)
-                            for ace in w_aces:
-                                if ace not in have_aces:
-                                    merge_aces.append(ace)
-                            merge_dict = {
-                                'afi': want['afi'],
-                                'acls': [{
-                                    'name': w['name'],
-                                    'aces': merge_aces
-                                }]
-                            }
-                            del_dict = {
-                                'afi': want['afi'],
-                                'acls': [{
-                                    'name': w['name'],
-                                    'aces': del_aces
-                                }]
-                            }
-                            if del_dict['acls']:
-                                acl_commands.extend(
-                                    self._state_deleted([del_dict], have))
-                            acl_commands.extend(
-                                self._state_merged(merge_dict, have))
-
-                            for i in range(1, len(acl_commands)):
-                                if acl_commands[i] == acl_commands[0]:
-                                    acl_commands[i] = ''
-                            commands.extend(acl_commands)
-                else:
-                    acls = []
-                    # no acls given in want, so delete all have acls
-                    for acl in have_afi['acls']:
-                        acls.append({'name': acl['name']})
-                    del_dict['acls'] = acls
-                    if del_dict['acls']:
-                        commands.extend(self._state_deleted([del_dict], have))
-
-            else:
-                # want_afi is not present in have
-                commands.extend(self._state_merged(want, have))
-
-        commands = list(filter(None, commands))
-        return commands
-
-    def _state_overridden(self, want, have):
-        """ The command generator when state is overridden
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        commands = []
-        want_afi = [w['afi'] for w in want]
-        for h in have:
-            if h['afi'] in want_afi:
-                w = search_obj_in_list(h['afi'], want, 'afi')
-                for h_acl in h['acls']:
-                    w_acl = search_obj_in_list(h_acl['name'], w['acls'],
-                                               'name')
-                    if not w_acl:
-                        del_dict = {
-                            'afi': h['afi'],
-                            'acls': [{
-                                'name': h_acl['name']
-                            }]
-                        }
-                        commands.extend(self._state_deleted([del_dict], have))
-            else:
-                # if afi is not in want
-                commands.extend(self._state_deleted([{'afi': h['afi']}], have))
-        for w in want:
-            commands.extend(self._state_replaced(w, have))
-        return commands
-
-    def _state_merged(self, want, have):
-        """ The command generator when state is merged
-
-        :rtype: A list
-        :returns: the commands necessary to merge the provided into
-                  the current configuration
-        """
-        return self.set_commands(want, have)
-
-    def _state_deleted(self, want, have):
-        """ The command generator when state is deleted
-
-        :rtype: A list
-        :returns: the commands necessary to remove the current configuration
-                  of the provided objects
-        """
-        commands = []
-        if want:  # and have != want:
-            for w in want:
-                ip = 'ipv6' if w['afi'] == 'ipv6' else 'ip'
-                acl_names = []
-                have_afi = search_obj_in_list(w['afi'], have, 'afi')
-                # if want['afi] not in have, ignore
-                if have_afi:
-                    if w.get('acls'):
-                        for acl in w['acls']:
-                            if 'aces' in acl.keys():
-                                have_name = search_obj_in_list(
-                                    acl['name'], have_afi['acls'], 'name')
-                                if have_name:
-                                    ace_commands = []
-                                    flag = 0
-                                    for ace in acl['aces']:
-                                        if list(ace.keys()) == ['sequence']:
-                                            # only sequence number is specified to be deleted
-                                            if 'aces' in have_name.keys():
-                                                for h_ace in have_name['aces']:
-                                                    if h_ace[
-                                                            'sequence'] == ace[
-                                                                'sequence']:
-                                                        ace_commands.append(
-                                                            'no ' +
-                                                            str(ace['sequence']
-                                                                ))
-                                                        flag = 1
-                                        else:
-                                            if 'aces' in have_name.keys():
-                                                for h_ace in have_name['aces']:
-                                                    # when want['ace'] does not have seq number
-                                                    if 'sequence' not in ace.keys(
-                                                    ):
-                                                        del h_ace['sequence']
-                                                    if ace == h_ace:
-                                                        ace_commands.append(
-                                                            'no ' +
-                                                            self.process_ace(
-                                                                ace))
-                                                        flag = 1
-                                    if flag:
-                                        ace_commands.insert(
-                                            0,
-                                            ip + ' access-list ' + acl['name'])
-                                    commands.extend(ace_commands)
-                            else:
-                                # only name given
-                                for h in have_afi['acls']:
-                                    if h['name'] == acl['name']:
-                                        acl_names.append(acl['name'])
-                        for name in acl_names:
-                            commands.append('no ' + ip + ' access-list ' +
-                                            name)
-
-                    else:
-                        # 'only afi is given'
-                        if have_afi.get('acls'):
-                            for h in have_afi['acls']:
-                                acl_names.append(h['name'])
-                            for name in acl_names:
-                                commands.append('no ' + ip + ' access-list ' +
-                                                name)
-        else:
-            v6 = []
-            v4 = []
-            v6_local = v4_local = None
-            for h in have:
-                if h['afi'] == 'ipv6':
-                    v6 = (acl['name'] for acl in h['acls'])
-                    if 'match_local_traffic' in h.keys():
-                        v6_local = True
-                else:
-                    v4 = (acl['name'] for acl in h['acls'])
-                    if 'match_local_traffic' in h.keys():
-                        v4_local = True
-
-            self.no_commands(v4, commands, v4_local, 'ip')
-            self.no_commands(v6, commands, v6_local, 'ipv6')
-
-            for name in v6:
-                commands.append('no ipv6 access-list ' + name)
-            if v4_local:
-                commands.append('no ipv6 access-list match-local-traffic')
-
-        return commands
-
-    def no_commands(self, v_list, commands, match_local, ip):
-        for name in v_list:
-            commands.append('no ' + ip + ' access-list ' + name)
-        if match_local:
-            commands.append('no ' + ip + ' access-list match-local-traffic')
-
-    def set_commands(self, want, have):
-        commands = []
-        have_afi = search_obj_in_list(want['afi'], have, 'afi')
-        ip = ''
-        if 'v6' in want['afi']:
-            ip = 'ipv6 '
-        else:
-            ip = 'ip '
-
-        if have_afi:
-            if want.get('acls'):
-                for w_acl in want['acls']:
-                    have_acl = search_obj_in_list(w_acl['name'],
-                                                  have_afi['acls'], 'name')
-                    name = w_acl['name']
-                    flag = 0
-                    ace_commands = []
-                    if have_acl != w_acl:
-                        if have_acl:
-                            ace_list = []
-                            if w_acl.get('aces') and have_acl.get('aces'):
-                                # case 1 --> sequence number not given in want --> new ace
-                                # case 2 --> new sequence number in want --> new ace
-                                # case 3 --> existing sequence number given --> update rule (only for merged state.
-                                #            For replaced and overridden, rule is deleted in the state's config)
-
-                                ace_list = [
-                                    item for item in w_acl['aces']
-                                    if 'sequence' not in item.keys()
-                                ]  # case 1
-
-                                want_seq = [
-                                    item['sequence'] for item in w_acl['aces']
-                                    if 'sequence' in item.keys()
-                                ]
-
-                                have_seq = [
-                                    item['sequence']
-                                    for item in have_acl['aces']
-                                ]
-
-                                new_seq = list(set(want_seq) - set(have_seq))
-                                common_seq = list(
-                                    set(want_seq).intersection(set(have_seq)))
-
-                                temp_list = [
-                                    item for item in w_acl['aces']
-                                    if 'sequence' in item.keys()
-                                    and item['sequence'] in new_seq
-                                ]  # case 2
-                                ace_list.extend(temp_list)
-                                for w in w_acl['aces']:
-                                    self.argument_spec = AclsArgs.argument_spec
-                                    params = utils.validate_config(
-                                        self.argument_spec, {
-                                            'config': [{
-                                                'afi':
-                                                want['afi'],
-                                                'acls': [{
-                                                    'name': name,
-                                                    'aces': ace_list
-                                                }]
-                                            }]
-                                        })
-                                    if 'sequence' in w.keys(
-                                    ) and w['sequence'] in common_seq:
-                                        temp_obj = search_obj_in_list(
-                                            w['sequence'], have_acl['aces'],
-                                            'sequence')  # case 3
-                                        if temp_obj != w:
-                                            for key, val in w.items():
-                                                temp_obj[key] = val
-                                            ace_list.append(temp_obj)
-                                            if self._module.params[
-                                                    'state'] == 'merged':
-                                                ace_commands.append(
-                                                    'no ' + str(w['sequence']))
-                                        # remove existing rule to update it
-                            elif w_acl.get('aces'):
-                                # 'have' has ACL defined without any ACE
-                                ace_list = [item for item in w_acl['aces']]
-                            for w_ace in ace_list:
-                                ace_commands.append(
-                                    self.process_ace(w_ace).strip())
-                                flag = 1
-
-                            if flag:
-                                ace_commands.insert(0,
-                                                    ip + 'access-list ' + name)
-
-                        else:
-                            commands.append(ip + 'access-list ' + name)
-                            if 'aces' in w_acl.keys():
-                                for w_ace in w_acl['aces']:
-                                    commands.append(
-                                        self.process_ace(w_ace).strip())
-                    commands.extend(ace_commands)
-        else:
-            if want.get('acls'):
-                for w_acl in want['acls']:
-                    name = w_acl['name']
-                    commands.append(ip + 'access-list ' + name)
-                    if 'aces' in w_acl.keys():
-                        for w_ace in w_acl['aces']:
-                            commands.append(self.process_ace(w_ace).strip())
-
-        return commands
-
-    def process_ace(self, w_ace):
-        command = ''
-        ace_keys = w_ace.keys()
-        if 'remark' in ace_keys:
-            command += 'remark ' + w_ace['remark'] + ' '
-        else:
-            command += w_ace['grant'] + ' '
-            if 'protocol' in ace_keys:
-                command += w_ace['protocol'] + ' '
-                src = self.get_address(w_ace['source'], w_ace['protocol'])
-                dest = self.get_address(w_ace['destination'],
-                                        w_ace['protocol'])
-                command += src + dest
-                if 'protocol_options' in ace_keys:
-                    pro = list(w_ace['protocol_options'].keys())[0]
-                    if pro != w_ace['protocol']:
-                        self._module.fail_json(
-                            msg='protocol and protocol_options mismatch')
-                    flags = ''
-                    for k in w_ace['protocol_options'][pro].keys():
-                        k = re.sub('_', '-', k)
-                        flags += k + ' '
-                    command += flags
-                if 'dscp' in ace_keys:
-                    command += 'dscp ' + w_ace['dscp'] + ' '
-                if 'fragments' in ace_keys:
-                    command += 'fragments '
-                if 'precedence' in ace_keys:
-                    command += 'precedence ' + w_ace['precedence'] + ' '
-            if 'log' in ace_keys:
-                command += 'log '
-        if 'sequence' in ace_keys:
-            command = str(w_ace['sequence']) + ' ' + command
-        return command
-
-    def get_address(self, endpoint, pro=''):
-        ret_addr = ''
-        keys = list(endpoint.keys())
-        if 'address' in keys:
-            if 'wildcard_bits' not in keys:
-                self._module.fail_json(
-                    msg='wildcard bits not specified for address')
-            else:
-                ret_addr = endpoint['address'] + \
-                    ' ' + endpoint['wildcard_bits'] + ' '
-        elif 'any' in keys:
-            ret_addr = 'any '
-        elif 'host' in keys:
-            ret_addr = 'host ' + endpoint['host'] + ' '
-        elif 'prefix' in keys:
-            ret_addr = endpoint['prefix'] + ' '
-
-        if pro in ['tcp', 'udp']:
-            if 'port_protocol' in keys:
-                options = self.get_options(endpoint['port_protocol'])
-                ret_addr += options
-        return ret_addr
-
-    def get_options(self, item):
-        com = ''
-        subkey = list(item.keys())
-        if 'range' in subkey:
-            com = 'range ' + item['range']['start'] + \
-                ' ' + item['range']['end'] + ' '
-        else:
-            com = subkey[0] + ' ' + item[subkey[0]] + ' '
-        return com
diff --git a/lib/ansible/module_utils/network/nxos/config/bfd_interfaces/bfd_interfaces.py b/lib/ansible/module_utils/network/nxos/config/bfd_interfaces/bfd_interfaces.py
deleted file mode 100644
index 3b0d2e7af7..0000000000
--- a/lib/ansible/module_utils/network/nxos/config/bfd_interfaces/bfd_interfaces.py
+++ /dev/null
@@ -1,264 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Cisco and/or its affiliates.
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-nxos_bfd_interfaces class
-This class creates a command set to bring the current device configuration
-to a desired end-state. The command set is based on a comparison of the
-current configuration (as dict) and the provided configuration (as dict).
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-import re
-from ansible.module_utils.network.common.cfg.base import ConfigBase
-from ansible.module_utils.network.common.utils import dict_diff, to_list
-from ansible.module_utils.network.nxos.facts.facts import Facts
-from ansible.module_utils.network.nxos.utils.utils import flatten_dict, search_obj_in_list
-
-
-class Bfd_interfaces(ConfigBase):
-    """
-    The nxos_bfd_interfaces class
-    """
-
-    gather_subset = [
-        '!all',
-        '!min',
-    ]
-    gather_network_resources = [
-        'bfd_interfaces',
-    ]
-    # exclude_params = []
-
-    def __init__(self, module):
-        super(Bfd_interfaces, self).__init__(module)
-
-    def get_bfd_interfaces_facts(self):
-        """ Get the 'facts' (the current configuration)
-
-        :returns: A list of interface configs and a platform string
-        """
-        facts, _warnings = Facts(self._module).get_facts(self.gather_subset, self.gather_network_resources)
-        bfd_interfaces_facts = facts['ansible_network_resources'].get('bfd_interfaces', [])
-        platform = facts.get('ansible_net_platform', '')
-        return bfd_interfaces_facts, platform
-
-    def edit_config(self, commands):
-        return self._connection.edit_config(commands)
-
-    def execute_module(self):
-        """ Execute the module
-
-        :rtype: A dictionary
-        :returns: The result from module execution
-        """
-        result = {'changed': False}
-        warnings = list()
-        cmds = list()
-
-        existing_bfd_interfaces_facts, platform = self.get_bfd_interfaces_facts()
-        cmds.extend(self.set_config(existing_bfd_interfaces_facts, platform))
-        if cmds:
-            if not self._module.check_mode:
-                self.edit_config(cmds)
-            result['changed'] = True
-        result['commands'] = cmds
-
-        changed_bfd_interfaces_facts, platform = self.get_bfd_interfaces_facts()
-        result['before'] = existing_bfd_interfaces_facts
-        if result['changed']:
-            result['after'] = changed_bfd_interfaces_facts
-
-        result['warnings'] = warnings
-        return result
-
-    def set_config(self, existing_bfd_interfaces_facts, platform):
-        """ Collect the configuration from the args passed to the module,
-            collect the current configuration (as a dict from facts)
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        if re.search('N[56]K', platform):
-            # Some platforms do not support the 'bfd' interface keyword;
-            # remove the 'bfd' key from each want/have interface.
-            orig_want = self._module.params['config']
-            want = []
-            for w in orig_want:
-                del w['bfd']
-                want.append(w)
-            orig_have = existing_bfd_interfaces_facts
-            have = []
-            for h in orig_have:
-                del h['bfd']
-                have.append(h)
-        else:
-            want = self._module.params['config']
-            have = existing_bfd_interfaces_facts
-
-        resp = self.set_state(want, have)
-        return to_list(resp)
-
-    def set_state(self, want, have):
-        """ Select the appropriate function based on the state provided
-
-        :param want: the desired configuration as a dictionary
-        :param have: the current configuration as a dictionary
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        state = self._module.params['state']
-        if state in ('overridden', 'merged', 'replaced') and not want:
-            self._module.fail_json(msg='config is required for state {0}'.format(state))
-
-        cmds = list()
-        if state == 'overridden':
-            cmds.extend(self._state_overridden(want, have))
-        elif state == 'deleted':
-            cmds.extend(self._state_deleted(want, have))
-        else:
-            for w in want:
-                if state == 'merged':
-                    cmds.extend(self._state_merged(flatten_dict(w), have))
-                elif state == 'replaced':
-                    cmds.extend(self._state_replaced(flatten_dict(w), have))
-        return cmds
-
-    def _state_replaced(self, want, have):
-        """ The command generator when state is replaced
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        cmds = []
-        obj_in_have = search_obj_in_list(want['name'], have, 'name')
-        if obj_in_have:
-            diff = dict_diff(want, obj_in_have)
-        else:
-            diff = want
-        merged_cmds = self.set_commands(want, have)
-        if 'name' not in diff:
-            diff['name'] = want['name']
-
-        replaced_cmds = []
-        if obj_in_have:
-            replaced_cmds = self.del_attribs(diff)
-        if replaced_cmds or merged_cmds:
-            for cmd in set(replaced_cmds).intersection(set(merged_cmds)):
-                merged_cmds.remove(cmd)
-            cmds.extend(replaced_cmds)
-            cmds.extend(merged_cmds)
-        return cmds
-
-    def _state_overridden(self, want, have):
-        """ The command generator when state is overridden
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        cmds = []
-        for h in have:
-            # Clean up bfd attrs for any interfaces not listed in the play
-            h = flatten_dict(h)
-            obj_in_want = flatten_dict(search_obj_in_list(h['name'], want, 'name'))
-            if obj_in_want:
-                # Let the 'want' loop handle all vals for this interface
-                continue
-            cmds.extend(self.del_attribs(h))
-        for w in want:
-            # Update any want attrs if needed. The overridden state considers
-            # the play as the source of truth for the entire device, therefore
-            # set any unspecified attrs to their default state.
-            w = self.set_none_vals_to_defaults(flatten_dict(w))
-            cmds.extend(self.set_commands(w, have))
-        return cmds
-
-    def _state_merged(self, want, have):
-        """ The command generator when state is merged
-
-        :rtype: A list
-        :returns: the commands necessary to merge the provided into
-                  the current configuration
-        """
-        return self.set_commands(want, have)
-
-    def _state_deleted(self, want, have):
-        """ The command generator when state is deleted
-
-        :rtype: A list
-        :returns: the commands necessary to remove the current configuration
-                  of the provided objects
-        """
-        if not (want or have):
-            return []
-        cmds = []
-        if want:
-            for w in want:
-                obj_in_have = flatten_dict(search_obj_in_list(w['name'], have, 'name'))
-                cmds.extend(self.del_attribs(obj_in_have))
-        else:
-            for h in have:
-                cmds.extend(self.del_attribs(flatten_dict(h)))
-        return cmds
-
-    def del_attribs(self, obj):
-        if not obj or len(obj.keys()) == 1:
-            return []
-        cmds = []
-        # 'bfd' and 'bfd echo' are enabled by default so the handling is
-        # counter-intuitive; we are enabling them to remove them. The end result
-        # is that they are removed from the interface config on the device.
-        if 'bfd' in obj and 'disable' in obj['bfd']:
-            cmds.append('bfd')
-        if 'echo' in obj and 'disable' in obj['echo']:
-            cmds.append('bfd echo')
-        if cmds:
-            cmds.insert(0, 'interface ' + obj['name'])
-        return cmds
-
-    def set_none_vals_to_defaults(self, want):
-        # Set dict None values to default states
-        if 'bfd' in want and want['bfd'] is None:
-            want['bfd'] = 'enable'
-        if 'echo' in want and want['echo'] is None:
-            want['echo'] = 'enable'
-        return want
-
-    def diff_of_dicts(self, want, obj_in_have):
-        diff = set(want.items()) - set(obj_in_have.items())
-        diff = dict(diff)
-        if diff and want['name'] == obj_in_have['name']:
-            diff.update({'name': want['name']})
-        return diff
-
-    def add_commands(self, want):
-        if not want:
-            return []
-        cmds = []
-        if 'bfd' in want and want['bfd'] is not None:
-            cmd = 'bfd' if want['bfd'] == 'enable' else 'no bfd'
-            cmds.append(cmd)
-        if 'echo' in want and want['echo'] is not None:
-            cmd = 'bfd echo' if want['echo'] == 'enable' else 'no bfd echo'
-            cmds.append(cmd)
-
-        if cmds:
-            cmds.insert(0, 'interface ' + want['name'])
-        return cmds
-
-    def set_commands(self, want, have):
-        cmds = []
-        obj_in_have = flatten_dict(search_obj_in_list(want['name'], have, 'name'))
-        if not obj_in_have:
-            cmds = self.add_commands(want)
-        else:
-            diff = self.diff_of_dicts(want, obj_in_have)
-            cmds = self.add_commands(diff)
-        return cmds
diff --git a/lib/ansible/module_utils/network/nxos/config/hsrp_interfaces/hsrp_interfaces.py b/lib/ansible/module_utils/network/nxos/config/hsrp_interfaces/hsrp_interfaces.py
deleted file mode 100644
index e3ef78e540..0000000000
--- a/lib/ansible/module_utils/network/nxos/config/hsrp_interfaces/hsrp_interfaces.py
+++ /dev/null
@@ -1,248 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Cisco and/or its affiliates.
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos hsrp_interfaces class
-This class creates a command set to bring the current device configuration
-to a desired end-state. The command set is based on a comparison of the
-current configuration (as dict) and the provided configuration (as dict).
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-from ansible.module_utils.network.common.cfg.base import ConfigBase
-from ansible.module_utils.network.common.utils import dict_diff, to_list, remove_empties
-from ansible.module_utils.network.nxos.facts.facts import Facts
-from ansible.module_utils.network.nxos.utils.utils import flatten_dict, get_interface_type, normalize_interface, search_obj_in_list, vlan_range_to_list
-
-
-class Hsrp_interfaces(ConfigBase):
-    """
-    The nxos_hsrp_interfaces class
-    """
-
-    gather_subset = [
-        '!all',
-        '!min',
-    ]
-
-    gather_network_resources = [
-        'hsrp_interfaces',
-    ]
-
-    def __init__(self, module):
-        super(Hsrp_interfaces, self).__init__(module)
-
-    def get_hsrp_interfaces_facts(self):
-        """ Get the 'facts' (the current configuration)
-
-        :rtype: A dictionary
-        :returns: The current configuration as a dictionary
-        """
-        facts, _warnings = Facts(self._module).get_facts(self.gather_subset, self.gather_network_resources)
-        hsrp_interfaces_facts = facts['ansible_network_resources'].get('hsrp_interfaces', [])
-        return hsrp_interfaces_facts
-
-    def edit_config(self, commands):
-        return self._connection.edit_config(commands)
-
-    def execute_module(self):
-        """ Execute the module
-
-        :rtype: A dictionary
-        :returns: The result from module execution
-        """
-        result = {'changed': False}
-        warnings = list()
-        cmds = list()
-
-        existing_hsrp_interfaces_facts = self.get_hsrp_interfaces_facts()
-        cmds.extend(self.set_config(existing_hsrp_interfaces_facts))
-        if cmds:
-            if not self._module.check_mode:
-                self.edit_config(cmds)
-            result['changed'] = True
-        result['commands'] = cmds
-        changed_hsrp_interfaces_facts = self.get_hsrp_interfaces_facts()
-
-        result['before'] = existing_hsrp_interfaces_facts
-        if result['changed']:
-            result['after'] = changed_hsrp_interfaces_facts
-
-        result['warnings'] = warnings
-        return result
-
-    def set_config(self, existing_hsrp_interfaces_facts):
-        """ Collect the configuration from the args passed to the module,
-            collect the current configuration (as a dict from facts)
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        config = self._module.params['config']
-        want = []
-        if config:
-            for w in config:
-                w.update({'name': normalize_interface(w['name'])})
-                want.append(w)
-        have = existing_hsrp_interfaces_facts
-        resp = self.set_state(want, have)
-        return to_list(resp)
-
-    def set_state(self, want, have):
-        """ Select the appropriate function based on the state provided
-
-        :param want: the desired configuration as a dictionary
-        :param have: the current configuration as a dictionary
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        state = self._module.params['state']
-        # check for 'config' keyword in play
-        if state in ('overridden', 'merged', 'replaced') and not want:
-            self._module.fail_json(msg='config is required for state {0}'.format(state))
-
-        cmds = list()
-        if state == 'overridden':
-            cmds.extend(self._state_overridden(want, have))
-        elif state == 'deleted':
-            cmds.extend(self._state_deleted(want, have))
-        else:
-            for w in want:
-                if state == 'merged':
-                    cmds.extend(self._state_merged(flatten_dict(w), have))
-                elif state == 'replaced':
-                    cmds.extend(self._state_replaced(flatten_dict(w), have))
-        return cmds
-
-    def _state_replaced(self, want, have):
-        """ The command generator when state is replaced
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        cmds = []
-        obj_in_have = search_obj_in_list(want['name'], have, 'name')
-        if obj_in_have:
-            diff = dict_diff(want, obj_in_have)
-        else:
-            diff = want
-        merged_cmds = self.set_commands(want, have)
-        if 'name' not in diff:
-            diff['name'] = want['name']
-
-        replaced_cmds = []
-        if obj_in_have:
-            replaced_cmds = self.del_attribs(diff)
-        if replaced_cmds or merged_cmds:
-            for cmd in set(replaced_cmds).intersection(set(merged_cmds)):
-                merged_cmds.remove(cmd)
-            cmds.extend(replaced_cmds)
-            cmds.extend(merged_cmds)
-        return cmds
-
-    def _state_overridden(self, want, have):
-        """ The command generator when state is overridden
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        cmds = []
-        for h in have:
-            # Check existing states, set to default if not in want or different than want
-            h = flatten_dict(h)
-            obj_in_want = search_obj_in_list(h['name'], want, 'name')
-            if obj_in_want:
-                # Let the 'want' loop handle all vals for this interface
-                continue
-            cmds.extend(self.del_attribs(h))
-        for w in want:
-            # Update any want attrs if needed. The overridden state considers
-            # the play as the source of truth for the entire device, therefore
-            # set any unspecified attrs to their default state.
-            w = self.set_none_vals_to_defaults(flatten_dict(w))
-            cmds.extend(self.set_commands(w, have))
-        return cmds
-
-    def _state_merged(self, want, have):
-        """ The command generator when state is merged
-
-        :rtype: A list
-        :returns: the commands necessary to merge the provided into
-                  the current configuration
-        """
-        return self.set_commands(want, have)
-
-    def _state_deleted(self, want, have):
-        """ The command generator when state is deleted
-
-        :rtype: A list
-        :returns: the commands necessary to remove the current configuration
-                  of the provided objects
-        """
-        if not (want or have):
-            return []
-        cmds = []
-        if want:
-            for w in want:
-                obj_in_have = flatten_dict(search_obj_in_list(w['name'], have, 'name'))
-                cmds.extend(self.del_attribs(obj_in_have))
-        else:
-            for h in have:
-                cmds.extend(self.del_attribs(flatten_dict(h)))
-        return cmds
-
-    def del_attribs(self, obj):
-        if not obj or len(obj.keys()) == 1:
-            return []
-        cmds = []
-        if 'bfd' in obj:
-            cmds.append('no hsrp bfd')
-        if cmds:
-            cmds.insert(0, 'interface ' + obj['name'])
-        return cmds
-
-    def set_none_vals_to_defaults(self, want):
-        # Set dict None values to default states
-        if 'bfd' in want and want['bfd'] is None:
-            want['bfd'] = 'disable'
-        return want
-
-    def diff_of_dicts(self, want, obj_in_have):
-        diff = set(want.items()) - set(obj_in_have.items())
-        diff = dict(diff)
-        if diff and want['name'] == obj_in_have['name']:
-            diff.update({'name': want['name']})
-        return diff
-
-    def add_commands(self, want, obj_in_have):
-        if not want:
-            return []
-        cmds = []
-        if 'bfd' in want and want['bfd'] is not None:
-            if want['bfd'] == 'enable':
-                cmd = 'hsrp bfd'
-                cmds.append(cmd)
-            elif want['bfd'] == 'disable' and obj_in_have and obj_in_have.get('bfd') == 'enable':
-                cmd = 'no hsrp bfd'
-                cmds.append(cmd)
-
-        if cmds:
-            cmds.insert(0, 'interface ' + want['name'])
-        return cmds
-
-    def set_commands(self, want, have):
-        cmds = []
-        obj_in_have = search_obj_in_list(want['name'], have, 'name')
-        if not obj_in_have:
-            cmds = self.add_commands(want, obj_in_have)
-        else:
-            diff = self.diff_of_dicts(want, obj_in_have)
-            cmds = self.add_commands(diff, obj_in_have)
-        return cmds
diff --git a/lib/ansible/module_utils/network/nxos/config/interfaces/interfaces.py b/lib/ansible/module_utils/network/nxos/config/interfaces/interfaces.py
deleted file mode 100644
index 0082b376b7..0000000000
--- a/lib/ansible/module_utils/network/nxos/config/interfaces/interfaces.py
+++ /dev/null
@@ -1,379 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos_interfaces class
-It is in this file where the current configuration (as dict)
-is compared to the provided configuration (as dict) and the command set
-necessary to bring the current configuration to it's desired end-state is
-created
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-from copy import deepcopy
-import re
-
-from ansible.module_utils.network.common.cfg.base import ConfigBase
-from ansible.module_utils.network.common.utils import dict_diff, to_list, remove_empties
-from ansible.module_utils.network.nxos.facts.facts import Facts
-from ansible.module_utils.network.nxos.utils.utils import normalize_interface, search_obj_in_list
-from ansible.module_utils.network.nxos.utils.utils import remove_rsvd_interfaces
-from ansible.module_utils.network.nxos.nxos import default_intf_enabled
-
-
-class Interfaces(ConfigBase):
-    """
-    The nxos_interfaces class
-    """
-
-    gather_subset = [
-        '!all',
-        '!min',
-    ]
-
-    gather_network_resources = [
-        'interfaces',
-    ]
-
-    exclude_params = [
-        'description',
-        'mtu',
-        'speed',
-        'duplex',
-    ]
-
-    def __init__(self, module):
-        super(Interfaces, self).__init__(module)
-
-    def get_interfaces_facts(self, get_default_interfaces=False):
-        """ Get the 'facts' (the current configuration)
-
-        :get_default_interfaces: boolean - when True include a list of existing-but-default interface names in the facts dict.
-          - The defaults list is primarily used to detect non-existent virtual interfaces.
-        :rtype: A dictionary
-        :returns: The current configuration as a dictionary
-        """
-        facts, _warnings = Facts(self._module).get_facts(self.gather_subset, self.gather_network_resources)
-        interfaces_facts = facts['ansible_network_resources'].get('interfaces')
-        interfaces_facts = remove_rsvd_interfaces(interfaces_facts)
-        if get_default_interfaces:
-            default_interfaces = facts['ansible_network_resources'].get('default_interfaces', [])
-            interfaces_facts.append(default_interfaces)
-
-        self.intf_defs = facts.get('intf_defs', {})
-        return interfaces_facts
-
-    def edit_config(self, commands):
-        """Wrapper method for `_connection.edit_config()`
-        This method exists solely to allow the unit test framework to mock device connection calls.
-        """
-        return self._connection.edit_config(commands)
-
-    def execute_module(self):
-        """ Execute the module
-
-        :rtype: A dictionary
-        :returns: The result from module execution
-        """
-        result = {'changed': False}
-        commands = list()
-        warnings = list()
-
-        existing_interfaces_facts = self.get_interfaces_facts(get_default_interfaces=True)
-        default_intf_list = existing_interfaces_facts.pop()
-        commands.extend(self.set_config(existing_interfaces_facts, default_intf_list))
-        if commands:
-            if not self._module.check_mode:
-                self.edit_config(commands)
-            result['changed'] = True
-        result['commands'] = commands
-
-        changed_interfaces_facts = self.get_interfaces_facts()
-
-        result['before'] = existing_interfaces_facts
-        if result['changed']:
-            result['after'] = changed_interfaces_facts
-
-        result['warnings'] = warnings
-        return result
-
-    def set_config(self, existing_interfaces_facts, default_intf_list):
-        """ Collect the configuration from the args passed to the module,
-            collect the current configuration (as a dict from facts)
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        config = self._module.params.get('config')
-        want = []
-        if config:
-            for w in config:
-                w.update({'name': normalize_interface(w['name'])})
-                want.append(remove_empties(w))
-        have = deepcopy(existing_interfaces_facts)
-        for i in want:
-            # 'have' does not include objects from the default_interfaces list.
-            # Add any 'want' names from default_interfaces to the 'have' list.
-            if i['name'] in default_intf_list:
-                have.append({'name': i['name']})
-        resp = self.set_state(want, have)
-        return to_list(resp)
-
-    def set_state(self, want, have):
-        """ Select the appropriate function based on the state provided
-
-        :param want: the desired configuration as a dictionary
-        :param have: the current configuration as a dictionary
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        state = self._module.params['state']
-        if state in ('overridden', 'merged', 'replaced') and not want:
-            self._module.fail_json(msg='config is required for state {0}'.format(state))
-
-        commands = list()
-        if state == 'overridden':
-            commands.extend(self._state_overridden(want, have))
-        elif state == 'deleted':
-            commands.extend(self._state_deleted(want, have))
-        else:
-            for w in want:
-                if state == 'merged':
-                    commands.extend(self._state_merged(w, have))
-                elif state == 'replaced':
-                    commands.extend(self._state_replaced(w, have))
-        return commands
-
-    def _state_replaced(self, w, have):
-        """ The command generator when state is replaced
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        commands = []
-        name = w['name']
-        obj_in_have = search_obj_in_list(name, have, 'name')
-        if obj_in_have:
-            # If 'w' does not specify mode then intf may need to change to its
-            # default mode, however default mode may depend on sysdef.
-            if not w.get('mode') and re.search('Ethernet|port-channel', name):
-                sysdefs = self.intf_defs['sysdefs']
-                sysdef_mode = sysdefs['mode']
-                if obj_in_have.get('mode') != sysdef_mode:
-                    w['mode'] = sysdef_mode
-            diff = dict_diff(w, obj_in_have)
-        else:
-            diff = w
-
-        merged_commands = self.set_commands(w, have)
-        if merged_commands:
-            # merged_commands:
-            #   - These commands are changes specified by the playbook.
-            #   - merged_commands apply to both existing and new objects
-            # replaced_commands:
-            #   - These are the unspecified commands, used to reset any params
-            #     that are not already set to default states
-            #   - replaced_commands should only be used on 'have' objects
-            #     (interfaces that already exist)
-            if obj_in_have:
-                if 'name' not in diff:
-                    diff['name'] = name
-                wkeys = w.keys()
-                dkeys = diff.keys()
-                for k in wkeys:
-                    if k in self.exclude_params and k in dkeys:
-                        del diff[k]
-                replaced_commands = self.del_attribs(diff)
-                cmds = set(replaced_commands).intersection(set(merged_commands))
-                for cmd in cmds:
-                    merged_commands.remove(cmd)
-                commands.extend(replaced_commands)
-
-            commands.extend(merged_commands)
-        return commands
-
-    def _state_overridden(self, want, have):
-        """ The command generator when state is overridden
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        # overridden is the same as replaced behavior except for the scope.
-        cmds = []
-        existing_interfaces = []
-        for h in have:
-            existing_interfaces.append(h['name'])
-            obj_in_want = search_obj_in_list(h['name'], want, 'name')
-            if obj_in_want:
-                if h != obj_in_want:
-                    replaced_cmds = self._state_replaced(obj_in_want, [h])
-                    if replaced_cmds:
-                        cmds.extend(replaced_cmds)
-            else:
-                cmds.extend(self.del_attribs(h))
-
-        for w in want:
-            if w['name'] not in existing_interfaces:
-                # This is an object that was excluded from the 'have' list
-                # because all of its params are currently set to default states
-                # -OR- it's a new object that does not exist on the device yet.
-                cmds.extend(self.add_commands(w))
-        return cmds
-
-    def _state_merged(self, w, have):
-        """ The command generator when state is merged
-
-        :rtype: A list
-        :returns: the commands necessary to merge the provided into
-                  the current configuration
-        """
-        return self.set_commands(w, have)
-
-    def _state_deleted(self, want, have):
-        """ The command generator when state is deleted
-
-        :rtype: A list
-        :returns: the commands necessary to remove the current configuration
-                  of the provided objects
-        """
-        commands = []
-        if want:
-            for w in want:
-                obj_in_have = search_obj_in_list(w['name'], have, 'name')
-                commands.extend(self.del_attribs(obj_in_have))
-        else:
-            if not have:
-                return commands
-            for h in have:
-                commands.extend(self.del_attribs(h))
-        return commands
-
-    def default_enabled(self, want=None, have=None, action=''):
-        # 'enabled' default state depends on the interface type and L2 state.
-        # Note that the current default could change when changing L2/L3 modes.
-        if want is None:
-            want = {}
-        if have is None:
-            have = {}
-        name = have.get('name')
-        if name is None:
-            return None
-
-        sysdefs = self.intf_defs['sysdefs']
-        sysdef_mode = sysdefs['mode']
-
-        # Get the default enabled state for this interface. This was collected
-        # during Facts gathering.
-        intf_def_enabled = self.intf_defs.get(name)
-
-        have_mode = have.get('mode', sysdef_mode)
-        if action == 'delete' and not want:
-            want_mode = sysdef_mode
-        else:
-            want_mode = want.get('mode', have_mode)
-        if (want_mode and have_mode) is None or (want_mode != have_mode) or intf_def_enabled is None:
-            # L2-L3 is changing or this is a new virtual intf. Get new default.
-            intf_def_enabled = default_intf_enabled(name=name, sysdefs=sysdefs, mode=want_mode)
-
-        return intf_def_enabled
-
-    def del_attribs(self, obj):
-        commands = []
-        if not obj or len(obj.keys()) == 1:
-            return commands
-        # mode/switchport changes should occur before other changes
-        sysdef_mode = self.intf_defs['sysdefs']['mode']
-        if 'mode' in obj and obj['mode'] != sysdef_mode:
-            no_cmd = 'no ' if sysdef_mode == 'layer3' else ''
-            commands.append(no_cmd + 'switchport')
-        if 'description' in obj:
-            commands.append('no description')
-        if 'speed' in obj:
-            commands.append('no speed')
-        if 'duplex' in obj:
-            commands.append('no duplex')
-        if 'enabled' in obj:
-            sysdef_enabled = self.default_enabled(have=obj, action='delete')
-            if obj['enabled'] is False and sysdef_enabled is True:
-                commands.append('no shutdown')
-            elif obj['enabled'] is True and sysdef_enabled is False:
-                commands.append('shutdown')
-        if 'mtu' in obj:
-            commands.append('no mtu')
-        if 'ip_forward' in obj and obj['ip_forward'] is True:
-            commands.append('no ip forward')
-        if 'fabric_forwarding_anycast_gateway' in obj and obj['fabric_forwarding_anycast_gateway'] is True:
-            commands.append('no fabric forwarding mode anycast-gateway')
-        if commands:
-            commands.insert(0, 'interface ' + obj['name'])
-
-        return commands
-
-    def diff_of_dicts(self, w, obj):
-        diff = set(w.items()) - set(obj.items())
-        diff = dict(diff)
-        if diff and w['name'] == obj['name']:
-            diff.update({'name': w['name']})
-        return diff
-
-    def add_commands(self, d, obj_in_have=None):
-        commands = []
-        if not d:
-            return commands
-        if obj_in_have is None:
-            obj_in_have = {}
-        # mode/switchport changes should occur before other changes
-        if 'mode' in d:
-            sysdef_mode = self.intf_defs['sysdefs']['mode']
-            have_mode = obj_in_have.get('mode', sysdef_mode)
-            want_mode = d['mode']
-            if have_mode == 'layer2':
-                if want_mode == 'layer3':
-                    commands.append('no switchport')
-            elif want_mode == 'layer2':
-                commands.append('switchport')
-        if 'description' in d:
-            commands.append('description ' + d['description'])
-        if 'speed' in d:
-            commands.append('speed ' + str(d['speed']))
-        if 'duplex' in d:
-            commands.append('duplex ' + d['duplex'])
-        if 'enabled' in d:
-            have_enabled = obj_in_have.get('enabled', self.default_enabled(d, obj_in_have))
-            if d['enabled'] is False and have_enabled is True:
-                commands.append('shutdown')
-            elif d['enabled'] is True and have_enabled is False:
-                commands.append('no shutdown')
-        if 'mtu' in d:
-            commands.append('mtu ' + str(d['mtu']))
-        if 'ip_forward' in d:
-            if d['ip_forward'] is True:
-                commands.append('ip forward')
-            else:
-                commands.append('no ip forward')
-        if 'fabric_forwarding_anycast_gateway' in d:
-            if d['fabric_forwarding_anycast_gateway'] is True:
-                commands.append('fabric forwarding mode anycast-gateway')
-            else:
-                commands.append('no fabric forwarding mode anycast-gateway')
-        if commands or not obj_in_have:
-            commands.insert(0, 'interface' + ' ' + d['name'])
-        return commands
-
-    def set_commands(self, w, have):
-        commands = []
-        obj_in_have = search_obj_in_list(w['name'], have, 'name')
-        if not obj_in_have:
-            commands = self.add_commands(w)
-        else:
-            diff = self.diff_of_dicts(w, obj_in_have)
-            commands = self.add_commands(diff, obj_in_have)
-        return commands
diff --git a/lib/ansible/module_utils/network/nxos/config/l2_interfaces/l2_interfaces.py b/lib/ansible/module_utils/network/nxos/config/l2_interfaces/l2_interfaces.py
deleted file mode 100644
index dba9afc981..0000000000
--- a/lib/ansible/module_utils/network/nxos/config/l2_interfaces/l2_interfaces.py
+++ /dev/null
@@ -1,301 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos_l2_interfaces class
-It is in this file where the current configuration (as dict)
-is compared to the provided configuration (as dict) and the command set
-necessary to bring the current configuration to it's desired end-state is
-created
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-from ansible.module_utils.network.common.cfg.base import ConfigBase
-from ansible.module_utils.network.common.utils import dict_diff, to_list, remove_empties
-from ansible.module_utils.network.nxos.facts.facts import Facts
-from ansible.module_utils.network.nxos.utils.utils import flatten_dict, normalize_interface, search_obj_in_list, vlan_range_to_list
-
-
-class L2_interfaces(ConfigBase):
-    """
-    The nxos_l2_interfaces class
-    """
-
-    gather_subset = [
-        '!all',
-        '!min',
-    ]
-
-    gather_network_resources = [
-        'l2_interfaces',
-    ]
-
-    exclude_params = [
-        'vlan',
-        'allowed_vlans',
-        'native_vlans',
-    ]
-
-    def __init__(self, module):
-        super(L2_interfaces, self).__init__(module)
-
-    def get_l2_interfaces_facts(self):
-        """ Get the 'facts' (the current configuration)
-
-        :rtype: A dictionary
-        :returns: The current configuration as a dictionary
-        """
-        facts, _warnings = Facts(self._module).get_facts(self.gather_subset, self.gather_network_resources)
-        l2_interfaces_facts = facts['ansible_network_resources'].get('l2_interfaces')
-        if not l2_interfaces_facts:
-            return []
-        return l2_interfaces_facts
-
-    def execute_module(self):
-        """ Execute the module
-
-        :rtype: A dictionary
-        :returns: The result from module execution
-        """
-        result = {'changed': False}
-        commands = list()
-        warnings = list()
-
-        existing_l2_interfaces_facts = self.get_l2_interfaces_facts()
-        commands.extend(self.set_config(existing_l2_interfaces_facts))
-        if commands:
-            if not self._module.check_mode:
-                self._connection.edit_config(commands)
-            result['changed'] = True
-        result['commands'] = commands
-
-        changed_l2_interfaces_facts = self.get_l2_interfaces_facts()
-
-        result['before'] = existing_l2_interfaces_facts
-        if result['changed']:
-            result['after'] = changed_l2_interfaces_facts
-
-        result['warnings'] = warnings
-        return result
-
-    def set_config(self, existing_l2_interfaces_facts):
-        """ Collect the configuration from the args passed to the module,
-            collect the current configuration (as a dict from facts)
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        config = self._module.params.get('config')
-        want = []
-        if config:
-            for w in config:
-                w.update({'name': normalize_interface(w['name'])})
-                self.expand_trunk_allowed_vlans(w)
-                want.append(remove_empties(w))
-        have = existing_l2_interfaces_facts
-        for h in have:
-            self.expand_trunk_allowed_vlans(h)
-        resp = self.set_state(want, have)
-        return to_list(resp)
-
-    def expand_trunk_allowed_vlans(self, d):
-        if not d:
-            return None
-        if 'trunk' in d and d['trunk']:
-            if 'allowed_vlans' in d['trunk']:
-                allowed_vlans = vlan_range_to_list(d['trunk']['allowed_vlans'])
-                vlans_list = [str(l) for l in sorted(allowed_vlans)]
-                d['trunk']['allowed_vlans'] = ",".join(vlans_list)
-
-    def set_state(self, want, have):
-        """ Select the appropriate function based on the state provided
-
-        :param want: the desired configuration as a dictionary
-        :param have: the current configuration as a dictionary
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        state = self._module.params['state']
-        if state in ('overridden', 'merged', 'replaced') and not want:
-            self._module.fail_json(msg='config is required for state {0}'.format(state))
-
-        commands = list()
-        if state == 'overridden':
-            commands.extend(self._state_overridden(want, have))
-        elif state == 'deleted':
-            commands.extend(self._state_deleted(want, have))
-        else:
-            for w in want:
-                if state == 'merged':
-                    commands.extend(self._state_merged(flatten_dict(w), have))
-                elif state == 'replaced':
-                    commands.extend(self._state_replaced(flatten_dict(w), have))
-        return commands
-
-    def _state_replaced(self, w, have):
-        """ The command generator when state is replaced
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        commands = []
-        obj_in_have = flatten_dict(search_obj_in_list(w['name'], have, 'name'))
-        if obj_in_have:
-            diff = dict_diff(w, obj_in_have)
-        else:
-            diff = w
-        merged_commands = self.set_commands(w, have, True)
-        if 'name' not in diff:
-            diff['name'] = w['name']
-
-        dkeys = diff.keys()
-        for k in w.copy():
-            if k in self.exclude_params and k in dkeys:
-                del diff[k]
-        replaced_commands = self.del_attribs(diff)
-
-        if merged_commands:
-            cmds = set(replaced_commands).intersection(set(merged_commands))
-            for cmd in cmds:
-                merged_commands.remove(cmd)
-            commands.extend(replaced_commands)
-            commands.extend(merged_commands)
-        return commands
-
-    def _state_overridden(self, want, have):
-        """ The command generator when state is overridden
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        commands = []
-        for h in have:
-            h = flatten_dict(h)
-            obj_in_want = flatten_dict(search_obj_in_list(h['name'], want, 'name'))
-            if h == obj_in_want:
-                continue
-            for w in want:
-                w = flatten_dict(w)
-                if h['name'] == w['name']:
-                    wkeys = w.keys()
-                    hkeys = h.keys()
-                    for k in wkeys:
-                        if k in self.exclude_params and k in hkeys:
-                            del h[k]
-            commands.extend(self.del_attribs(h))
-        for w in want:
-            commands.extend(self.set_commands(flatten_dict(w), have, True))
-        return commands
-
-    def _state_merged(self, w, have):
-        """ The command generator when state is merged
-
-        :rtype: A list
-        :returns: the commands necessary to merge the provided into
-                  the current configuration
-        """
-        return self.set_commands(w, have)
-
-    def _state_deleted(self, want, have):
-        """ The command generator when state is deleted
-
-        :rtype: A list
-        :returns: the commands necessary to remove the current configuration
-                  of the provided objects
-        """
-        commands = []
-        if want:
-            for w in want:
-                obj_in_have = flatten_dict(search_obj_in_list(w['name'], have, 'name'))
-                commands.extend(self.del_attribs(obj_in_have))
-        else:
-            if not have:
-                return commands
-            for h in have:
-                commands.extend(self.del_attribs(flatten_dict(h)))
-        return commands
-
-    def del_attribs(self, obj):
-        commands = []
-        if not obj or len(obj.keys()) == 1:
-            return commands
-
-        cmd = 'no switchport '
-        if 'vlan' in obj:
-            commands.append(cmd + 'access vlan')
-        if 'mode' in obj:
-            commands.append(cmd + 'mode')
-        if 'allowed_vlans' in obj:
-            commands.append(cmd + 'trunk allowed vlan')
-        if 'native_vlan' in obj:
-            commands.append(cmd + 'trunk native vlan')
-        if commands:
-            commands.insert(0, 'interface ' + obj['name'])
-        return commands
-
-    def diff_of_dicts(self, w, obj):
-        diff = set(w.items()) - set(obj.items())
-        diff = dict(diff)
-        if diff and w['name'] == obj['name']:
-            diff.update({'name': w['name']})
-        return diff
-
-    def add_commands(self, d, vlan_exists=False):
-        commands = []
-        if not d:
-            return commands
-
-        cmd = 'switchport '
-        if 'mode' in d:
-            commands.append(cmd + 'mode {0}'.format(d['mode']))
-        if 'vlan' in d:
-            commands.append(cmd + 'access vlan ' + str(d['vlan']))
-        if 'allowed_vlans' in d:
-            if vlan_exists:
-                commands.append(cmd + 'trunk allowed vlan add ' + str(d['allowed_vlans']))
-            else:
-                commands.append(cmd + 'trunk allowed vlan ' + str(d['allowed_vlans']))
-        if 'native_vlan' in d:
-            commands.append(cmd + 'trunk native vlan ' + str(d['native_vlan']))
-        if commands:
-            commands.insert(0, 'interface ' + d['name'])
-        return commands
-
-    def set_commands(self, w, have, replace=False):
-        commands = []
-
-        obj_in_have = flatten_dict(search_obj_in_list(w['name'], have, 'name'))
-        if not obj_in_have:
-            commands = self.add_commands(w)
-        else:
-            diff = self.diff_of_dicts(w, obj_in_have)
-            if diff and not replace:
-                if 'mode' in diff.keys() and diff['mode']:
-                    commands = self.add_commands(diff)
-                if "allowed_vlans" in diff.keys() and diff["allowed_vlans"]:
-                    vlan_tobe_added = diff["allowed_vlans"].split(',')
-                    vlan_list = vlan_tobe_added[:]
-                    if obj_in_have.get("allowed_vlans"):
-                        have_vlans = obj_in_have["allowed_vlans"].split(',')
-                    else:
-                        have_vlans = []
-                    for w_vlans in vlan_list:
-                        if w_vlans in have_vlans:
-                            vlan_tobe_added.pop(vlan_tobe_added.index(w_vlans))
-                    if vlan_tobe_added:
-                        diff.update({"allowed_vlans": ','.join(vlan_tobe_added)})
-                        if have_vlans:
-                            commands = self.add_commands(diff, True)
-                        else:
-                            commands = self.add_commands(diff)
-                    return commands
-            commands = self.add_commands(diff)
-        return commands
diff --git a/lib/ansible/module_utils/network/nxos/config/l3_interfaces/l3_interfaces.py b/lib/ansible/module_utils/network/nxos/config/l3_interfaces/l3_interfaces.py
deleted file mode 100644
index 6febab96d7..0000000000
--- a/lib/ansible/module_utils/network/nxos/config/l3_interfaces/l3_interfaces.py
+++ /dev/null
@@ -1,488 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos_l3_interfaces class
-It is in this file where the current configuration (as dict)
-is compared to the provided configuration (as dict) and the command set
-necessary to bring the current configuration to it's desired end-state is
-created
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-import re
-
-from copy import deepcopy
-from ansible.module_utils.network.common.cfg.base import ConfigBase
-from ansible.module_utils.network.common.utils import to_list, remove_empties
-from ansible.module_utils.network.nxos.facts.facts import Facts
-from ansible.module_utils.network.nxos.utils.utils import normalize_interface, search_obj_in_list
-from ansible.module_utils.network.nxos.utils.utils import remove_rsvd_interfaces, get_interface_type
-
-
-class L3_interfaces(ConfigBase):
-    """
-    The nxos_l3_interfaces class
-    """
-
-    gather_subset = [
-        '!all',
-        '!min',
-    ]
-
-    gather_network_resources = [
-        'l3_interfaces',
-    ]
-
-    exclude_params = [
-    ]
-
-    def __init__(self, module):
-        super(L3_interfaces, self).__init__(module)
-
-    def get_l3_interfaces_facts(self):
-        """ Get the 'facts' (the current configuration)
-
-        :rtype: A dictionary
-        :returns: The current configuration as a dictionary
-        """
-        facts, _warnings = Facts(self._module).get_facts(self.gather_subset, self.gather_network_resources)
-        l3_interfaces_facts = facts['ansible_network_resources'].get('l3_interfaces')
-        if not l3_interfaces_facts:
-            return []
-
-        self.platform = self.get_platform_type()
-        return remove_rsvd_interfaces(l3_interfaces_facts)
-
-    def get_platform_type(self):
-        default, _warnings = Facts(self._module).get_facts(legacy_facts_type=['default'])
-        return default.get('ansible_net_platform', '')
-
-    def edit_config(self, commands):
-        return self._connection.edit_config(commands)
-
-    def execute_module(self):
-        """ Execute the module
-
-        :rtype: A dictionary
-        :returns: The result from module execution
-        """
-        result = {'changed': False}
-        commands = list()
-        warnings = list()
-
-        existing_l3_interfaces_facts = self.get_l3_interfaces_facts()
-        commands.extend(self.set_config(existing_l3_interfaces_facts))
-        if commands:
-            if not self._module.check_mode:
-                self.edit_config(commands)
-            result['changed'] = True
-        result['commands'] = commands
-
-        changed_l3_interfaces_facts = self.get_l3_interfaces_facts()
-
-        result['before'] = existing_l3_interfaces_facts
-        if result['changed']:
-            result['after'] = changed_l3_interfaces_facts
-
-        result['warnings'] = warnings
-        return result
-
-    def set_config(self, existing_l3_interfaces_facts):
-        """ Collect the configuration from the args passed to the module,
-            collect the current configuration (as a dict from facts)
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        config = self._module.params.get('config')
-        want = []
-        if config:
-            for w in config:
-                w.update({'name': normalize_interface(w['name'])})
-                if get_interface_type(w['name']) == 'management':
-                    self._module.fail_json(msg="The 'management' interface is not allowed to be managed by this module")
-                want.append(remove_empties(w))
-        have = deepcopy(existing_l3_interfaces_facts)
-        self.init_check_existing(have)
-        resp = self.set_state(want, have)
-        return to_list(resp)
-
-    def set_state(self, want, have):
-        """ Select the appropriate function based on the state provided
-
-        :param want: the desired configuration as a dictionary
-        :param have: the current configuration as a dictionary
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        state = self._module.params['state']
-        if state in ('overridden', 'merged', 'replaced') and not want:
-            self._module.fail_json(msg='config is required for state {0}'.format(state))
-
-        commands = list()
-        if state == 'overridden':
-            commands.extend(self._state_overridden(want, have))
-        elif state == 'deleted':
-            commands.extend(self._state_deleted(want, have))
-        else:
-            for w in want:
-                if state == 'merged':
-                    commands.extend(self._state_merged(w, have))
-                elif state == 'replaced':
-                    commands.extend(self._state_replaced(w, have))
-        return commands
-
-    def _state_replaced(self, want, have):
-        """ The command generator when state is replaced
-        Scope is limited to interface objects defined in the playbook.
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        cmds = []
-        name = want['name']
-        obj_in_have = search_obj_in_list(want['name'], have, 'name')
-
-        have_v4 = obj_in_have.pop('ipv4', []) if obj_in_have else []
-        have_v6 = obj_in_have.pop('ipv6', []) if obj_in_have else []
-
-        # Process lists of dicts separately
-        v4_cmds = self._v4_cmds(want.pop('ipv4', []), have_v4, state='replaced')
-        v6_cmds = self._v6_cmds(want.pop('ipv6', []), have_v6, state='replaced')
-
-        # Process remaining attrs
-        if obj_in_have:
-            # Find 'want' changes first
-            diff = self.diff_of_dicts(want, obj_in_have)
-            rmv = {'name': name}
-            haves_not_in_want = set(obj_in_have.keys()) - set(want.keys()) - set(diff.keys())
-            for i in haves_not_in_want:
-                rmv[i] = obj_in_have[i]
-            cmds.extend(self.generate_delete_commands(rmv))
-        else:
-            diff = want
-
-        cmds.extend(self.add_commands(diff, name=name))
-        cmds.extend(v4_cmds)
-        cmds.extend(v6_cmds)
-        self.cmd_order_fixup(cmds, name)
-        return cmds
-
-    def _state_overridden(self, want, have):
-        """ The command generator when state is overridden
-        Scope includes all interface objects on the device.
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        # overridden behavior is the same as replaced except for scope.
-        cmds = []
-        existing_vlans = []
-        for i in have:
-            obj_in_want = search_obj_in_list(i['name'], want, 'name')
-            if obj_in_want:
-                if i != obj_in_want:
-                    v4_cmds = self._v4_cmds(obj_in_want.pop('ipv4', []), i.pop('ipv4', []), state='overridden')
-                    replaced_cmds = self._state_replaced(obj_in_want, [i])
-                    replaced_cmds.extend(v4_cmds)
-                    self.cmd_order_fixup(replaced_cmds, obj_in_want['name'])
-                    cmds.extend(replaced_cmds)
-            else:
-                deleted_cmds = self.generate_delete_commands(i)
-                self.cmd_order_fixup(deleted_cmds, i['name'])
-                cmds.extend(deleted_cmds)
-
-        for i in want:
-            if [item for item in have if i['name'] == item['name']]:
-                continue
-            cmds.extend(self.add_commands(i, name=i['name']))
-
-        return cmds
-
-    def _state_merged(self, w, have):
-        """ The command generator when state is merged
-
-        :rtype: A list
-        :returns: the commands necessary to merge the provided into
-                  the current configuration
-        """
-        return self.set_commands(w, have)
-
-    def _v4_cmds(self, want, have, state=None):
-        """Helper method for processing ipv4 changes.
-        This is needed to handle primary/secondary address changes, which require a specific sequence when changing.
-        """
-        # The ip address cli does not allow removing primary addresses while
-        # secondaries are present, but it does allow changing a primary to a
-        # new address as long as the address is not a current secondary.
-        # Be aware of scenarios where a secondary is taking over
-        # the role of the primary, which must be changed in sequence.
-        # In general, primaries/secondaries should change in this order:
-        # Step 1. Remove secondaries that are being changed or removed
-        # Step 2. Change the primary if needed
-        # Step 3. Merge secondaries
-
-        # Normalize inputs (add tag key if not present)
-        for i in want:
-            i['tag'] = i.get('tag')
-        for i in have:
-            i['tag'] = i.get('tag')
-
-        merged = True if state == 'merged' else False
-        replaced = True if state == 'replaced' else False
-        overridden = True if state == 'overridden' else False
-
-        # Create secondary and primary wants/haves
-        sec_w = [i for i in want if i.get('secondary')]
-        sec_h = [i for i in have if i.get('secondary')]
-        pri_w = [i for i in want if not i.get('secondary')]
-        pri_h = [i for i in have if not i.get('secondary')]
-        pri_w = pri_w[0] if pri_w else {}
-        pri_h = pri_h[0] if pri_h else {}
-        cmds = []
-
-        # Remove all addrs when no primary is specified in want (pri_w)
-        if pri_h and not pri_w and (replaced or overridden):
-            cmds.append('no ip address')
-            return cmds
-
-        # 1. Determine which secondaries are changing and remove them. Need a have/want
-        # diff instead of want/have because a have sec addr may be changing to a pri.
-        sec_to_rmv = []
-        sec_diff = self.diff_list_of_dicts(sec_h, sec_w)
-        for i in sec_diff:
-            if overridden or [w for w in sec_w if w['address'] == i['address']]:
-                sec_to_rmv.append(i['address'])
-
-        # Check if new primary is currently a secondary
-        if pri_w and [h for h in sec_h if h['address'] == pri_w['address']]:
-            if not overridden:
-                sec_to_rmv.append(pri_w['address'])
-
-        # Remove the changing secondaries
-        cmds.extend(['no ip address %s secondary' % i for i in sec_to_rmv])
-
-        # 2. change primary
-        if pri_w:
-            diff = dict(set(pri_w.items()) - set(pri_h.items()))
-            if diff:
-                cmd = 'ip address %s' % diff['address']
-                tag = diff.get('tag')
-                cmd += ' tag %s' % tag if tag else ''
-                cmds.append(cmd)
-
-        # 3. process remaining secondaries last
-        sec_w_to_chg = self.diff_list_of_dicts(sec_w, sec_h)
-        for i in sec_w_to_chg:
-            cmd = 'ip address %s secondary' % i['address']
-            cmd += ' tag %s' % i['tag'] if i['tag'] else ''
-            cmds.append(cmd)
-
-        return cmds
-
-    def _v6_cmds(self, want, have, state=''):
-        """Helper method for processing ipv6 changes.
-        This is needed to avoid unnecessary churn on the device when removing or changing multiple addresses.
-        """
-        # Normalize inputs (add tag key if not present)
-        for i in want:
-            i['tag'] = i.get('tag')
-        for i in have:
-            i['tag'] = i.get('tag')
-
-        cmds = []
-        # items to remove (items in 'have' only)
-        if state == 'replaced':
-            for i in self.diff_list_of_dicts(have, want):
-                want_addr = [w for w in want if w['address'] == i['address']]
-                if not want_addr:
-                    cmds.append('no ipv6 address %s' % i['address'])
-                elif i['tag'] and not want_addr[0]['tag']:
-                    # Must remove entire cli when removing tag
-                    cmds.append('no ipv6 address %s' % i['address'])
-
-        # items to merge/add
-        for i in self.diff_list_of_dicts(want, have):
-            addr = i['address']
-            tag = i['tag']
-            if not tag and state == 'merged':
-                # When want is IP-no-tag and have is IP+tag it will show up in diff,
-                # but for merged nothing has changed, so ignore it for idempotence.
-                have_addr = [h for h in have if h['address'] == addr]
-                if have_addr and have_addr[0].get('tag'):
-                    continue
-            cmd = 'ipv6 address %s' % i['address']
-            cmd += ' tag %s' % tag if tag else ''
-            cmds.append(cmd)
-
-        return cmds
-
-    def _state_deleted(self, want, have):
-        """ The command generator when state is deleted
-
-        :rtype: A list
-        :returns: the commands necessary to remove the current configuration
-                  of the provided objects
-        """
-        commands = []
-        if want:
-            for w in want:
-                obj_in_have = search_obj_in_list(w['name'], have, 'name')
-                commands.extend(self.del_all_attribs(obj_in_have))
-        else:
-            if not have:
-                return commands
-            for h in have:
-                commands.extend(self.del_all_attribs(h))
-        return commands
-
-    def del_all_attribs(self, obj):
-        commands = []
-        if not obj or len(obj.keys()) == 1:
-            return commands
-        commands = self.generate_delete_commands(obj)
-        self.cmd_order_fixup(commands, obj['name'])
-        return commands
-
-    def generate_delete_commands(self, obj):
-        """Generate CLI commands to remove non-default settings.
-        obj: dict of attrs to remove
-        """
-        commands = []
-        name = obj.get('name')
-        if 'dot1q' in obj:
-            commands.append('no encapsulation dot1q')
-        if 'redirects' in obj:
-            if not self.check_existing(name, 'has_secondary') or re.match('N[3567]', self.platform):
-                # device auto-enables redirects when secondaries are removed;
-                # auto-enable may fail on legacy platforms so always do explicit enable
-                commands.append('ip redirects')
-        if 'unreachables' in obj:
-            commands.append('no ip unreachables')
-        if 'ipv4' in obj:
-            commands.append('no ip address')
-        if 'ipv6' in obj:
-            commands.append('no ipv6 address')
-        return commands
-
-    def init_check_existing(self, have):
-        """Creates a class var dict for easier access to existing states
-        """
-        self.existing_facts = dict()
-        have_copy = deepcopy(have)
-        for intf in have_copy:
-            name = intf['name']
-            self.existing_facts[name] = intf
-            # Check for presence of secondaries; used for ip redirects logic
-            if [i for i in intf.get('ipv4', []) if i.get('secondary')]:
-                self.existing_facts[name]['has_secondary'] = True
-
-    def check_existing(self, name, query):
-        """Helper method to lookup existing states on an interface.
-        This is needed for attribute changes that have additional dependencies;
-        e.g. 'ip redirects' may auto-enable when all secondary ip addrs are removed.
-        """
-        if name:
-            have = self.existing_facts.get(name, {})
-            if 'has_secondary' in query:
-                return have.get('has_secondary', False)
-            if 'redirects' in query:
-                return have.get('redirects', True)
-            if 'unreachables' in query:
-                return have.get('unreachables', False)
-        return None
-
-    def diff_of_dicts(self, w, obj):
-        diff = set(w.items()) - set(obj.items())
-        diff = dict(diff)
-        if diff and w['name'] == obj['name']:
-            diff.update({'name': w['name']})
-        return diff
-
-    def diff_list_of_dicts(self, w, h):
-        diff = []
-        set_w = set(tuple(sorted(d.items())) for d in w) if w else set()
-        set_h = set(tuple(sorted(d.items())) for d in h) if h else set()
-        difference = set_w.difference(set_h)
-        for element in difference:
-            diff.append(dict((x, y) for x, y in element))
-        return diff
-
-    def add_commands(self, diff, name=''):
-        commands = []
-        if not diff:
-            return commands
-        if 'dot1q' in diff:
-            commands.append('encapsulation dot1q ' + str(diff['dot1q']))
-        if 'redirects' in diff:
-            # Note: device will auto-disable redirects when secondaries are present
-            if diff['redirects'] != self.check_existing(name, 'redirects'):
-                no_cmd = 'no ' if diff['redirects'] is False else ''
-                commands.append(no_cmd + 'ip redirects')
-                self.cmd_order_fixup(commands, name)
-        if 'unreachables' in diff:
-            if diff['unreachables'] != self.check_existing(name, 'unreachables'):
-                no_cmd = 'no ' if diff['unreachables'] is False else ''
-                commands.append(no_cmd + 'ip unreachables')
-        if 'ipv4' in diff:
-            commands.extend(self.generate_afi_commands(diff['ipv4']))
-        if 'ipv6' in diff:
-            commands.extend(self.generate_afi_commands(diff['ipv6']))
-        self.cmd_order_fixup(commands, name)
-
-        return commands
-
-    def generate_afi_commands(self, diff):
-        cmds = []
-        for i in diff:
-            cmd = 'ipv6 address ' if re.search('::', i['address']) else 'ip address '
-            cmd += i['address']
-            if i.get('secondary'):
-                cmd += ' secondary'
-            if i.get('tag'):
-                cmd += ' tag ' + str(i['tag'])
-            cmds.append(cmd)
-        return cmds
-
-    def set_commands(self, w, have):
-        commands = []
-        name = w['name']
-        obj_in_have = search_obj_in_list(name, have, 'name')
-        if not obj_in_have:
-            commands = self.add_commands(w, name=name)
-        else:
-            # lists of dicts must be processed separately from non-list attrs
-            v4_cmds = self._v4_cmds(w.pop('ipv4', []), obj_in_have.pop('ipv4', []), state='merged')
-            v6_cmds = self._v6_cmds(w.pop('ipv6', []), obj_in_have.pop('ipv6', []), state='merged')
-
-            # diff remaining attrs
-            diff = self.diff_of_dicts(w, obj_in_have)
-            commands = self.add_commands(diff, name=name)
-            commands.extend(v4_cmds)
-            commands.extend(v6_cmds)
-
-        self.cmd_order_fixup(commands, name)
-        return commands
-
-    def cmd_order_fixup(self, cmds, name):
-        """Inserts 'interface <name>' config at the beginning of populated command list; reorders dependent commands that must process after others.
-        """
-        if cmds:
-            if name and not [item for item in cmds if item.startswith('interface')]:
-                cmds.insert(0, 'interface ' + name)
-
-            redirects = [item for item in cmds if re.match('(no )*ip redirects', item)]
-            if redirects:
-                # redirects should occur after ipv4 commands, just move to end of list
-                redirects = redirects.pop()
-                cmds.remove(redirects)
-                cmds.append(redirects)
diff --git a/lib/ansible/module_utils/network/nxos/config/lacp/lacp.py b/lib/ansible/module_utils/network/nxos/config/lacp/lacp.py
deleted file mode 100644
index ebed250184..0000000000
--- a/lib/ansible/module_utils/network/nxos/config/lacp/lacp.py
+++ /dev/null
@@ -1,203 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos_lacp class
-It is in this file where the current configuration (as dict)
-is compared to the provided configuration (as dict) and the command set
-necessary to bring the current configuration to it's desired end-state is
-created
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-from ansible.module_utils.network.common.cfg.base import ConfigBase
-from ansible.module_utils.network.common.utils import dict_diff, to_list, remove_empties
-from ansible.module_utils.network.nxos.facts.facts import Facts
-
-
-class Lacp(ConfigBase):
-    """
-    The nxos_lacp class
-    """
-
-    gather_subset = [
-        '!all',
-        '!min',
-    ]
-
-    gather_network_resources = [
-        'lacp',
-    ]
-
-    exclude_params = [
-        'priority',
-        'mac',
-    ]
-
-    def __init__(self, module):
-        super(Lacp, self).__init__(module)
-
-    def get_lacp_facts(self):
-        """ Get the 'facts' (the current configuration)
-
-        :rtype: A dictionary
-        :returns: The current configuration as a dictionary
-        """
-        facts, _warnings = Facts(self._module).get_facts(self.gather_subset, self.gather_network_resources)
-        lacp_facts = facts['ansible_network_resources'].get('lacp')
-        if not lacp_facts:
-            return []
-        return lacp_facts
-
-    def execute_module(self):
-        """ Execute the module
-
-        :rtype: A dictionary
-        :returns: The result from module execution
-        """
-        result = {'changed': False}
-        commands = list()
-        warnings = list()
-
-        existing_lacp_facts = self.get_lacp_facts()
-        commands.extend(self.set_config(existing_lacp_facts))
-        if commands:
-            if not self._module.check_mode:
-                self._connection.edit_config(commands)
-            result['changed'] = True
-        result['commands'] = commands
-
-        changed_lacp_facts = self.get_lacp_facts()
-
-        result['before'] = existing_lacp_facts
-        if result['changed']:
-            result['after'] = changed_lacp_facts
-
-        result['warnings'] = warnings
-        return result
-
-    def set_config(self, existing_lacp_facts):
-        """ Collect the configuration from the args passed to the module,
-            collect the current configuration (as a dict from facts)
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        want = remove_empties(self._module.params['config'])
-        have = existing_lacp_facts
-        resp = self.set_state(want, have)
-        return to_list(resp)
-
-    def set_state(self, want, have):
-        """ Select the appropriate function based on the state provided
-
-        :param want: the desired configuration as a dictionary
-        :param have: the current configuration as a dictionary
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        state = self._module.params['state']
-        commands = list()
-
-        if state == 'overridden':
-            commands.extend(self._state_overridden(want, have))
-        elif state == 'deleted':
-            commands.extend(self._state_deleted(want, have))
-        elif state == 'merged':
-            commands.extend(self._state_merged(want, have))
-        elif state == 'replaced':
-            commands.extend(self._state_replaced(want, have))
-        return commands
-
-    def _state_replaced(self, want, have):
-        """ The command generator when state is replaced
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        commands = []
-        diff = dict_diff(want, have)
-        wkeys = want.keys()
-        dkeys = diff.keys()
-        for k in wkeys:
-            if k in self.exclude_params and k in dkeys:
-                del diff[k]
-        deleted_commands = self.del_all(diff)
-        merged_commands = self._state_merged(want, have)
-
-        commands.extend(deleted_commands)
-        if merged_commands:
-            commands.extend(merged_commands)
-
-        return commands
-
-    def _state_merged(self, want, have):
-        """ The command generator when state is merged
-
-        :rtype: A list
-        :returns: the commands necessary to merge the provided into
-                  the current configuration
-        """
-        return self.set_commands(want, have)
-
-    def _state_deleted(self, want, have):
-        """ The command generator when state is deleted
-
-        :rtype: A list
-        :returns: the commands necessary to remove the current configuration
-                  of the provided objects
-        """
-        commands = []
-        if not have:
-            return commands
-        commands.extend(self.del_all(have))
-        return commands
-
-    def get_diff(self, comparable, base):
-        diff = {}
-        if not base:
-            diff = comparable
-        else:
-            diff = dict_diff(base, comparable)
-        return diff
-
-    def del_all(self, diff):
-        commands = []
-        base = 'no lacp system-'
-        diff = diff.get('system')
-        if diff:
-            if 'priority' in diff:
-                commands.append(base + 'priority')
-            if 'mac' in diff:
-                commands.append(base + 'mac')
-        return commands
-
-    def add_commands(self, diff):
-        commands = []
-        base = 'lacp system-'
-        diff = diff.get('system')
-        if diff and 'priority' in diff:
-            cmd = base + 'priority' + ' ' + str(diff['priority'])
-            commands.append(cmd)
-        if diff and 'mac' in diff:
-            cmd = ''
-            if 'address' in diff['mac']:
-                cmd += base + 'mac' + ' ' + diff['mac']['address']
-            if 'role' in diff['mac']:
-                cmd += ' ' + 'role' + ' ' + diff['mac']['role']
-            if cmd:
-                commands.append(cmd)
-
-        return commands
-
-    def set_commands(self, want, have):
-        if not want:
-            return []
-        diff = self.get_diff(want, have)
-        return self.add_commands(diff)
diff --git a/lib/ansible/module_utils/network/nxos/config/lacp_interfaces/lacp_interfaces.py b/lib/ansible/module_utils/network/nxos/config/lacp_interfaces/lacp_interfaces.py
deleted file mode 100644
index 891d2466c8..0000000000
--- a/lib/ansible/module_utils/network/nxos/config/lacp_interfaces/lacp_interfaces.py
+++ /dev/null
@@ -1,284 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos_lacp_interfaces class
-It is in this file where the current configuration (as dict)
-is compared to the provided configuration (as dict) and the command set
-necessary to bring the current configuration to it's desired end-state is
-created
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-from ansible.module_utils.network.common.cfg.base import ConfigBase
-from ansible.module_utils.network.common.utils import to_list, dict_diff, remove_empties
-from ansible.module_utils.network.nxos.facts.facts import Facts
-from ansible.module_utils.network.nxos.utils.utils import flatten_dict, search_obj_in_list, get_interface_type, normalize_interface
-
-
-class Lacp_interfaces(ConfigBase):
-    """
-    The nxos_lacp_interfaces class
-    """
-
-    gather_subset = [
-        '!all',
-        '!min',
-    ]
-
-    gather_network_resources = [
-        'lacp_interfaces',
-    ]
-
-    exclude_params = [
-        'port_priority',
-        'rate',
-        'min',
-        'max',
-    ]
-
-    def __init__(self, module):
-        super(Lacp_interfaces, self).__init__(module)
-
-    def get_lacp_interfaces_facts(self):
-        """ Get the 'facts' (the current configuration)
-
-        :rtype: A dictionary
-        :returns: The current configuration as a dictionary
-        """
-        facts, _warnings = Facts(self._module).get_facts(self.gather_subset, self.gather_network_resources)
-        lacp_interfaces_facts = facts['ansible_network_resources'].get('lacp_interfaces')
-        if not lacp_interfaces_facts:
-            return []
-        return lacp_interfaces_facts
-
-    def execute_module(self):
-        """ Execute the module
-
-        :rtype: A dictionary
-        :returns: The result from module execution
-        """
-        result = {'changed': False}
-        commands = list()
-        warnings = list()
-
-        existing_lacp_interfaces_facts = self.get_lacp_interfaces_facts()
-        commands.extend(self.set_config(existing_lacp_interfaces_facts))
-        if commands:
-            if not self._module.check_mode:
-                self._connection.edit_config(commands)
-            result['changed'] = True
-        result['commands'] = commands
-
-        changed_lacp_interfaces_facts = self.get_lacp_interfaces_facts()
-
-        result['before'] = existing_lacp_interfaces_facts
-        if result['changed']:
-            result['after'] = changed_lacp_interfaces_facts
-
-        result['warnings'] = warnings
-        return result
-
-    def set_config(self, existing_lacp_interfaces_facts):
-        """ Collect the configuration from the args passed to the module,
-            collect the current configuration (as a dict from facts)
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        config = self._module.params.get('config')
-        want = []
-        if config:
-            for w in config:
-                if get_interface_type(w['name']) not in ('portchannel', 'ethernet'):
-                    self._module.fail_json(msg='This module works with either portchannel or ethernet')
-                w.update({'name': normalize_interface(w['name'])})
-                want.append(remove_empties(w))
-        have = existing_lacp_interfaces_facts
-        resp = self.set_state(want, have)
-        return to_list(resp)
-
-    def set_state(self, want, have):
-        """ Select the appropriate function based on the state provided
-
-        :param want: the desired configuration as a dictionary
-        :param have: the current configuration as a dictionary
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        state = self._module.params['state']
-        if state in ('overridden', 'merged', 'replaced') and not want:
-            self._module.fail_json(msg='config is required for state {0}'.format(state))
-        commands = list()
-
-        if state == 'overridden':
-            commands.extend(self._state_overridden(want, have))
-        elif state == 'deleted':
-            commands.extend(self._state_deleted(want, have))
-        else:
-            for w in want:
-                if state == 'merged':
-                    commands.extend(self._state_merged(flatten_dict(w), have))
-                elif state == 'replaced':
-                    commands.extend(self._state_replaced(flatten_dict(w), have))
-        return commands
-
-    def _state_replaced(self, w, have):
-        """ The command generator when state is replaced
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        commands = []
-        obj_in_have = flatten_dict(search_obj_in_list(w['name'], have, 'name'))
-        diff = dict_diff(w, obj_in_have)
-        merged_commands = self.set_commands(w, have)
-        if 'name' not in diff:
-            diff['name'] = w['name']
-        wkeys = w.keys()
-        dkeys = diff.keys()
-        for k in wkeys:
-            if k in self.exclude_params and k in dkeys:
-                del diff[k]
-        replaced_commands = self.del_attribs(diff)
-
-        if merged_commands:
-            cmds = set(replaced_commands).intersection(set(merged_commands))
-            for cmd in cmds:
-                merged_commands.remove(cmd)
-            commands.extend(replaced_commands)
-            commands.extend(merged_commands)
-        return commands
-
-    def _state_overridden(self, want, have):
-        """ The command generator when state is overridden
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        commands = []
-        for h in have:
-            h = flatten_dict(h)
-            obj_in_want = flatten_dict(search_obj_in_list(h['name'], want, 'name'))
-            if h == obj_in_want:
-                continue
-            for w in want:
-                w = flatten_dict(w)
-                if h['name'] == w['name']:
-                    wkeys = w.keys()
-                    hkeys = h.keys()
-                    for k in wkeys:
-                        if k in self.exclude_params and k in hkeys:
-                            del h[k]
-            commands.extend(self.del_attribs(h))
-        for w in want:
-            commands.extend(self.set_commands(flatten_dict(w), have))
-        return commands
-
-    def _state_merged(self, w, have):
-        """ The command generator when state is merged
-
-        :rtype: A list
-        :returns: the commands necessary to merge the provided into
-                  the current configuration
-        """
-        return self.set_commands(w, have)
-
-    def _state_deleted(self, want, have):
-        """ The command generator when state is deleted
-
-        :rtype: A list
-        :returns: the commands necessary to remove the current configuration
-                  of the provided objects
-        """
-        commands = []
-        if want:
-            for w in want:
-                obj_in_have = flatten_dict(search_obj_in_list(w['name'], have, 'name'))
-                commands.extend(self.del_attribs(obj_in_have))
-        else:
-            if not have:
-                return commands
-            for h in have:
-                commands.extend(self.del_attribs(flatten_dict(h)))
-        return commands
-
-    def del_attribs(self, obj):
-        commands = []
-        if not obj or len(obj.keys()) == 1:
-            return commands
-        commands.append('interface ' + obj['name'])
-        if 'graceful' in obj:
-            commands.append('lacp graceful-convergence')
-        if 'vpc' in obj:
-            commands.append('no lacp vpn-convergence')
-        if 'suspend_individual' in obj:
-            commands.append('lacp suspend_individual')
-        if 'mode' in obj:
-            commands.append('no lacp mode ' + obj['mode'])
-        if 'max' in obj:
-            commands.append('no lacp max-bundle')
-        if 'min' in obj:
-            commands.append('no lacp min-links')
-        if 'port_priority' in obj:
-            commands.append('no lacp port-priority')
-        if 'rate' in obj:
-            commands.append('no lacp rate')
-        return commands
-
-    def diff_of_dicts(self, w, obj):
-        diff = set(w.items()) - set(obj.items())
-        diff = dict(diff)
-        if diff and w['name'] == obj['name']:
-            diff.update({'name': w['name']})
-        return diff
-
-    def add_commands(self, d):
-        commands = []
-        if not d:
-            return commands
-        commands.append('interface' + ' ' + d['name'])
-
-        if 'port_priority' in d:
-            commands.append('lacp port-priority ' + str(d['port_priority']))
-        if 'rate' in d:
-            commands.append('lacp rate ' + str(d['rate']))
-        if 'min' in d:
-            commands.append('lacp min-links ' + str(d['min']))
-        if 'max' in d:
-            commands.append('lacp max-bundle ' + str(d['max']))
-        if 'mode' in d:
-            commands.append('lacp mode ' + d['mode'])
-        if 'suspend_individual' in d:
-            if d['suspend_individual'] is True:
-                commands.append('lacp suspend-individual')
-            else:
-                commands.append('no lacp suspend-individual')
-        if 'graceful' in d:
-            if d['graceful'] is True:
-                commands.append('lacp graceful-convergence')
-            else:
-                commands.append('no lacp graceful-convergence')
-        if 'vpc' in d:
-            if d['vpc'] is True:
-                commands.append('lacp vpc-convergence')
-            else:
-                commands.append('no lacp vpc-convergence')
-        return commands
-
-    def set_commands(self, w, have):
-        commands = []
-        obj_in_have = flatten_dict(search_obj_in_list(w['name'], have, 'name'))
-        if not obj_in_have:
-            commands = self.add_commands(w)
-        else:
-            diff = self.diff_of_dicts(w, obj_in_have)
-            commands = self.add_commands(diff)
-        return commands
diff --git a/lib/ansible/module_utils/network/nxos/config/lag_interfaces/lag_interfaces.py b/lib/ansible/module_utils/network/nxos/config/lag_interfaces/lag_interfaces.py
deleted file mode 100644
index ed000f5467..0000000000
--- a/lib/ansible/module_utils/network/nxos/config/lag_interfaces/lag_interfaces.py
+++ /dev/null
@@ -1,273 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The junos_lag_interfaces class
-It is in this file where the current configuration (as dict)
-is compared to the provided configuration (as dict) and the command set
-necessary to bring the current configuration to it's desired end-state is
-created
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-from ansible.module_utils.network.common.cfg.base import ConfigBase
-from ansible.module_utils.network.common.utils import to_list, remove_empties, dict_diff, search_obj_in_list
-from ansible.module_utils.network.nxos.facts.facts import Facts
-from ansible.module_utils.network.nxos.utils.utils import normalize_interface
-
-
-class Lag_interfaces(ConfigBase):
-    """
-    The nxos_lag_interfaces class
-    """
-
-    gather_subset = [
-        '!all',
-        '!min',
-    ]
-
-    gather_network_resources = [
-        'lag_interfaces',
-    ]
-
-    def __init__(self, module):
-        super(Lag_interfaces, self).__init__(module)
-
-    def get_lag_interfaces_facts(self):
-        """ Get the 'facts' (the current configuration)
-
-        :rtype: A dictionary
-        :returns: The current configuration as a dictionary
-        """
-        facts, _warnings = Facts(self._module).get_facts(self.gather_subset, self.gather_network_resources)
-        lag_interfaces_facts = facts['ansible_network_resources'].get('lag_interfaces')
-        if not lag_interfaces_facts:
-            return []
-        return lag_interfaces_facts
-
-    def execute_module(self):
-        """ Execute the module
-
-        :rtype: A dictionary
-        :returns: The result from module execution
-        """
-        result = {'changed': False}
-        commands = list()
-        warnings = list()
-
-        existing_lag_interfaces_facts = self.get_lag_interfaces_facts()
-        commands.extend(self.set_config(existing_lag_interfaces_facts))
-        if commands:
-            if not self._module.check_mode:
-                resp = self._connection.edit_config(commands)
-                if 'response' in resp:
-                    for item in resp['response']:
-                        if item:
-                            err_str = item
-                            if err_str.lower().startswith('cannot add'):
-                                self._module.fail_json(msg=err_str)
-            result['changed'] = True
-        result['commands'] = commands
-
-        changed_lag_interfaces_facts = self.get_lag_interfaces_facts()
-
-        result['before'] = existing_lag_interfaces_facts
-        if result['changed']:
-            result['after'] = changed_lag_interfaces_facts
-
-        result['warnings'] = warnings
-        return result
-
-    def set_config(self, existing_lag_interfaces_facts):
-        """ Collect the configuration from the args passed to the module,
-            collect the current configuration (as a dict from facts)
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        want = self._module.params.get('config')
-        if want:
-            for w in want:
-                w.update(remove_empties(w))
-                if 'members' in w and w['members']:
-                    for item in w['members']:
-                        item.update({'member': normalize_interface(item['member'])})
-        have = existing_lag_interfaces_facts
-        resp = self.set_state(want, have)
-        return to_list(resp)
-
-    def set_state(self, want, have):
-        """ Select the appropriate function based on the state provided
-
-        :param want: the desired configuration as a dictionary
-        :param have: the current configuration as a dictionary
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        state = self._module.params['state']
-        commands = list()
-
-        if state == 'overridden':
-            commands.extend(self._state_overridden(want, have))
-        elif state == 'deleted':
-            commands.extend(self._state_deleted(want, have))
-        else:
-            for w in want:
-                if state == 'merged':
-                    commands.extend(self._state_merged(w, have))
-                if state == 'replaced':
-                    commands.extend(self._state_replaced(w, have))
-        return commands
-
-    def _state_replaced(self, w, have):
-        """ The command generator when state is replaced
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        commands = []
-        merged_commands = self.set_commands(w, have)
-        replaced_commands = self.del_intf_commands(w, have)
-        if merged_commands:
-            commands.extend(replaced_commands)
-            commands.extend(merged_commands)
-        return commands
-
-    def _state_overridden(self, want, have):
-        """ The command generator when state is overridden
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        commands = []
-        for h in have:
-            obj_in_want = search_obj_in_list(h['name'], want, 'name')
-            if obj_in_want:
-                diff = self.diff_list_of_dicts(h['members'], obj_in_want['members'])
-                if not diff:
-                    continue
-            commands.extend(self.del_all_commands(h))
-        for w in want:
-            commands.extend(self.set_commands(w, have))
-        return commands
-
-    def _state_merged(self, w, have):
-        """ The command generator when state is merged
-
-        :rtype: A list
-        :returns: the commands necessary to merge the provided into
-                  the current configuration
-        """
-        return self.set_commands(w, have)
-
-    def _state_deleted(self, want, have):
-        """ The command generator when state is deleted
-
-        :rtype: A list
-        :returns: the commands necessary to remove the current configuration
-                  of the provided objects
-        """
-        commands = []
-        if want:
-            for w in want:
-                obj_in_have = search_obj_in_list(w['name'], have, 'name')
-                commands.extend(self.del_all_commands(obj_in_have))
-        else:
-            if not have:
-                return commands
-            for h in have:
-                commands.extend(self.del_all_commands(h))
-        return commands
-
-    def diff_list_of_dicts(self, want, have):
-        if not want:
-            want = []
-
-        if not have:
-            have = []
-
-        diff = []
-        for w_item in want:
-            h_item = search_obj_in_list(w_item['member'], have, key='member') or {}
-            delta = dict_diff(h_item, w_item)
-            if delta:
-                if h_item:
-                    if 'mode' in delta.keys() and delta['mode'] == 'on' and 'mode' not in h_item.keys():
-                        # mode = on will not be displayed in running-config
-                        continue
-                if 'member' not in delta.keys():
-                    delta['member'] = w_item['member']
-                diff.append(delta)
-
-        return diff
-
-    def intersect_list_of_dicts(self, w, h):
-        intersect = []
-        wmem = []
-        hmem = []
-        for d in w:
-            wmem.append({'member': d['member']})
-        for d in h:
-            hmem.append({'member': d['member']})
-        set_w = set(tuple(sorted(d.items())) for d in wmem)
-        set_h = set(tuple(sorted(d.items())) for d in hmem)
-        intersection = set_w.intersection(set_h)
-        for element in intersection:
-            intersect.append(dict((x, y) for x, y in element))
-        return intersect
-
-    def add_commands(self, diff, name):
-        commands = []
-        name = name.strip('port-channel')
-        for d in diff:
-            commands.append('interface' + ' ' + d['member'])
-            cmd = ''
-            group_cmd = 'channel-group {0}'.format(name)
-            if 'force' in d:
-                cmd = group_cmd + ' force ' + d['force']
-            if 'mode' in d:
-                if cmd:
-                    cmd = cmd + ' mode ' + d['mode']
-                else:
-                    cmd = group_cmd + ' mode ' + d['mode']
-            if not cmd:
-                cmd = group_cmd
-            commands.append(cmd)
-        return commands
-
-    def set_commands(self, w, have):
-        commands = []
-        obj_in_have = search_obj_in_list(w['name'], have, 'name')
-        if not obj_in_have:
-            commands = self.add_commands(w['members'], w['name'])
-        else:
-            diff = self.diff_list_of_dicts(w['members'], obj_in_have['members'])
-            commands = self.add_commands(diff, w['name'])
-        return commands
-
-    def del_all_commands(self, obj_in_have):
-        commands = []
-        if not obj_in_have:
-            return commands
-        for m in obj_in_have['members']:
-            commands.append('interface' + ' ' + m['member'])
-            commands.append('no channel-group')
-        return commands
-
-    def del_intf_commands(self, w, have):
-        commands = []
-        obj_in_have = search_obj_in_list(w['name'], have, 'name')
-        if obj_in_have:
-            lst_to_del = self.intersect_list_of_dicts(w['members'], obj_in_have['members'])
-            if lst_to_del:
-                for item in lst_to_del:
-                    commands.append('interface' + ' ' + item['member'])
-                    commands.append('no channel-group')
-        return commands
diff --git a/lib/ansible/module_utils/network/nxos/config/lldp_global/lldp_global.py b/lib/ansible/module_utils/network/nxos/config/lldp_global/lldp_global.py
deleted file mode 100644
index 75f0d753ff..0000000000
--- a/lib/ansible/module_utils/network/nxos/config/lldp_global/lldp_global.py
+++ /dev/null
@@ -1,240 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos_lldp_global class
-It is in this file where the current configuration (as dict)
-is compared to the provided configuration (as dict) and the command set
-necessary to bring the current configuration to it's desired end-state is
-created
-"""
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from ansible.module_utils.network.common.cfg.base import ConfigBase
-from ansible.module_utils.network.common.utils import remove_empties, dict_diff
-from ansible.module_utils.network.nxos.facts.facts import Facts
-
-
-class Lldp_global(ConfigBase):
-    """
-    The nxos_lldp_global class
-    """
-    gather_subset = [
-        '!all',
-        '!min',
-    ]
-
-    gather_network_resources = [
-        'lldp_global',
-    ]
-
-    def __init__(self, module):
-        super(Lldp_global, self).__init__(module)
-
-    def get_lldp_global_facts(self):
-        """ Get the 'facts' (the current configuration)
-
-        :rtype: A dictionary
-        :returns: The current configuration as a dictionary
-        """
-        facts, _warnings = Facts(self._module).get_facts(
-            self.gather_subset, self.gather_network_resources)
-        lldp_global_facts = facts['ansible_network_resources'].get(
-            'lldp_global')
-        if not lldp_global_facts:
-            return {}
-        return lldp_global_facts
-
-    def execute_module(self):
-        """ Execute the module
-
-        :rtype: A dictionary
-        :returns: The result from module execution
-        """
-        result = {'changed': False}
-        commands = list()
-        warnings = list()
-
-        existing_lldp_global_facts = self.get_lldp_global_facts()
-        commands.extend(self.set_config(existing_lldp_global_facts))
-        if commands:
-            if not self._module.check_mode:
-                self._connection.edit_config(commands)
-            result['changed'] = True
-        result['commands'] = commands
-
-        changed_lldp_global_facts = self.get_lldp_global_facts()
-
-        result['before'] = dict(existing_lldp_global_facts)
-        if result['changed']:
-            result['after'] = dict(changed_lldp_global_facts)
-        result['warnings'] = warnings
-        return result
-
-    def set_config(self, existing_lldp_global_facts):
-        """ Collect the configuration from the args passed to the module,
-            collect the current configuration (as a dict from facts)
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        want = self._module.params['config']
-        have = existing_lldp_global_facts
-        resp = self.set_state(remove_empties(want), have)
-        return resp
-
-    def set_state(self, want, have):
-        """ Select the appropriate function based on the state provided
-
-        :param want: the desired configuration as a dictionary
-        :param have: the current configuration as a dictionary
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        state = self._module.params['state']
-        if state == 'deleted':
-            commands = self._state_deleted(have)
-        elif state == 'merged':
-            commands = self._state_merged(want, have)
-        elif state == 'replaced':
-            commands = self._state_replaced(want, have)
-        return commands
-
-    def _state_replaced(self, want, have):
-        """ The command generator when state is replaced
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        commands = []
-        merge_dict = dict_diff(have, want)
-        #  merge_dict will contain new and unique values in want
-        delete_dict = self.find_delete_params(have, want)
-        self._module.params['state'] = 'deleted'
-        commands.extend(self._state_deleted(delete_dict))  # delete
-        self._module.params['state'] = 'merged'
-        commands.extend(self.set_commands(merge_dict))  # merge
-        self._module.params['state'] = 'replaced'
-        return commands
-
-    def delete_nested_dict(self, have, want):
-        """
-        Returns tlv_select nested dict that needs to be defaulted
-        """
-        outer_dict = {}
-        for key, val in have.items():
-            inner_dict = {}
-            if not isinstance(val, dict):
-                if key not in want.keys():
-                    inner_dict.update({key: val})
-                    return inner_dict
-            else:
-                if key in want.keys():
-                    outer_dict.update(
-                        {key: self.delete_nested_dict(val, want[key])})
-                else:
-                    outer_dict.update({key: val})
-        return outer_dict
-
-    def find_delete_params(self, have, want):
-        """
-        Returns parameters that are present in have and not in want, that need to be defaulted
-        """
-        delete_dict = {}
-        for key, val in have.items():
-            if key not in want.keys():
-                delete_dict.update({key: val})
-            else:
-                if key == 'tlv_select':
-                    delete_dict.update({key: self.delete_nested_dict(
-                        have['tlv_select'], want['tlv_select'])})
-        return delete_dict
-
-    def _state_merged(self, want, have):
-        """ The command generator when state is merged
-
-        :rtype: A list
-        :returns: the commands necessary to merge the provided into
-                  the current configuration
-        """
-        commands = []
-        diff = dict_diff(have, want)
-        commands.extend(self.set_commands(diff))
-        return commands
-
-    def _state_deleted(self, have):
-        """ The command generator when state is deleted
-
-        :rtype: A list
-        :returns: the commands necessary to remove the current configuration
-                  of the provided objects
-        """
-        commands = []
-        if have:
-            for key, val in have.items():
-                if 'tlv_select' in key:
-                    commands.extend(self.process_nested_dict(val))
-                else:
-                    if key == 'port_id':
-                        key = 'portid-subtype'
-                    commands.append('no lldp ' + key + ' ' + str(val))
-
-        return commands
-
-    def set_commands(self, diff):
-        commands = []
-        for key, val in diff.items():
-            commands.extend(self.add_commands(key, val))
-        return commands
-
-    def add_commands(self, key, val):
-        command = []
-        if 'port_id' in key:
-            command.append('lldp portid-subtype ' + str(val))
-        elif 'tlv_select' in key:
-            command.extend(self.process_nested_dict(val))
-        else:
-            if val:
-                command.append('lldp ' + key + ' ' + str(val))
-        return command
-
-    def process_nested_dict(self, val):
-        nested_commands = []
-        for k, v in val.items():
-            if isinstance(v, dict):
-                for k1, v1 in v.items():
-                    com1 = 'lldp tlv-select '
-                    com2 = ''
-                    if 'system' in k:
-                        com2 = 'system-' + k1
-                    elif 'management_address' in k:
-                        com2 = 'management-address ' + k1
-                    elif 'port' in k:
-                        com2 = 'port-' + k1
-
-                    com1 += com2
-                    com1 = self.negate_command(com1, v1)
-                    nested_commands.append(com1)
-            else:
-                com1 = 'lldp tlv-select '
-                if 'power_management' in k:
-                    com1 += 'power-management'
-                else:
-                    com1 += k
-
-                com1 = self.negate_command(com1, v)
-                nested_commands.append(com1)
-        return nested_commands
-
-    def negate_command(self, command, val):
-        # for merged, replaced vals need to be checked to add 'no'
-        if self._module.params['state'] == 'merged':
-            if not val:
-                command = 'no ' + command
-        return command
diff --git a/lib/ansible/module_utils/network/nxos/config/lldp_interfaces/lldp_interfaces.py b/lib/ansible/module_utils/network/nxos/config/lldp_interfaces/lldp_interfaces.py
deleted file mode 100644
index 37e29ae5c6..0000000000
--- a/lib/ansible/module_utils/network/nxos/config/lldp_interfaces/lldp_interfaces.py
+++ /dev/null
@@ -1,304 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos_lldp_interfaces class
-It is in this file where the current configuration (as dict)
-is compared to the provided configuration (as dict) and the command set
-necessary to bring the current configuration to it's desired end-state is
-created
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-from ansible.module_utils.network.common.cfg.base import ConfigBase
-from ansible.module_utils.network.common.utils import to_list, remove_empties, dict_diff
-from ansible.module_utils.network.nxos.facts.facts import Facts
-from ansible.module_utils.network.nxos.utils.utils import flatten_dict, search_obj_in_list, get_interface_type, normalize_interface
-
-
-class Lldp_interfaces(ConfigBase):
-    """
-    The nxos_lldp_interfaces class
-    """
-
-    gather_subset = [
-        '!all',
-        '!min',
-    ]
-
-    gather_network_resources = [
-        'lldp_interfaces',
-    ]
-
-    def __init__(self, module):
-        super(Lldp_interfaces, self).__init__(module)
-
-    def get_lldp_interfaces_facts(self, data=None):
-        """ Get the 'facts' (the current configuration)
-
-        :rtype: A dictionary
-        :returns: The current configuration as a dictionary
-        """
-        facts, _warnings = Facts(self._module).get_facts(
-            self.gather_subset, self.gather_network_resources, data=data)
-        lldp_interfaces_facts = facts['ansible_network_resources'].get(
-            'lldp_interfaces')
-        if not lldp_interfaces_facts:
-            return []
-        return lldp_interfaces_facts
-
-    def edit_config(self, commands):
-        """Wrapper method for `_connection.edit_config()`
-        This exists solely to allow the unit test framework to mock device connection calls.
-        """
-        return self._connection.edit_config(commands)
-
-    def execute_module(self):
-        """ Execute the module
-
-        :rtype: A dictionary
-        :returns: The result from module execution
-        """
-        result = {'changed': False}
-        commands = list()
-        warnings = list()
-        state = self._module.params['state']
-        action_states = ['merged', 'replaced', 'deleted', 'overridden']
-
-        if state == 'gathered':
-            result['gathered'] = self.get_lldp_interfaces_facts()
-        elif state == 'rendered':
-            result['rendered'] = self.set_config({})
-        elif state == 'parsed':
-            result['parsed'] = self.set_config({})
-        else:
-            existing_lldp_interfaces_facts = self.get_lldp_interfaces_facts()
-            commands.extend(self.set_config(existing_lldp_interfaces_facts))
-            if commands and state in action_states:
-                if not self._module.check_mode:
-                    self._connection.edit_config(commands)
-                result['changed'] = True
-                result['before'] = existing_lldp_interfaces_facts
-                result['commands'] = commands
-            result['commands'] = commands
-
-            changed_lldp_interfaces_facts = self.get_lldp_interfaces_facts()
-
-            if result['changed']:
-                result['after'] = changed_lldp_interfaces_facts
-
-        result['warnings'] = warnings
-        return result
-
-    def set_config(self, existing_lldp_interfaces_facts):
-        """ Collect the configuration from the args passed to the module,
-            collect the current configuration (as a dict from facts)
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        config = self._module.params['config']
-        want = []
-        if config:
-            for w in config:
-                if get_interface_type(w['name']) not in ('management',
-                                                         'ethernet'):
-                    self._module.fail_json(
-                        msg='This module works with either management or ethernet')
-                w.update({'name': normalize_interface(w['name'])})
-                want.append(remove_empties(w))
-        have = existing_lldp_interfaces_facts
-        resp = self.set_state(want, have)
-        return to_list(resp)
-
-    def set_state(self, want, have):
-        """ Select the appropriate function based on the state provided
-
-        :param want: the desired configuration as a dictionary
-        :param have: the current configuration as a dictionary
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        commands = []
-        state = self._module.params['state']
-        if state == 'overridden':
-            commands = self._state_overridden(want, have)
-        elif state == 'deleted':
-            commands = self._state_deleted(want, have)
-        elif state == 'rendered':
-            commands = self._state_rendered(want)
-        elif state == 'parsed':
-            want = self._module.params['running_config']
-            commands = self._state_parsed(want)
-        else:
-            for w in want:
-                if state == 'merged':
-                    commands.extend(self._state_merged(flatten_dict(w), have))
-                elif state == 'replaced':
-                    commands.extend(self._state_replaced(
-                        flatten_dict(w), have))
-        return commands
-
-    def _state_parsed(self, want):
-        return self.get_lldp_interfaces_facts(want)
-
-    def _state_rendered(self, want):
-        commands = []
-        for w in want:
-            commands.extend(self.set_commands(w, {}))
-        return commands
-
-    def _state_gathered(self, have):
-        """ The command generator when state is gathered
-
-        :rtype: A list
-        :returns: the commands necessary to reproduce the current configuration
-        """
-        commands = []
-        want = {}
-        commands.append(self.set_commands(want, have))
-        return commands
-
-    def _state_replaced(self, want, have):
-        """ The command generator when state is replaced
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        commands = []
-        del_commands = []
-        delete_dict = {}
-        obj_in_have = flatten_dict(
-            search_obj_in_list(want['name'], have, 'name'))
-        for k1 in obj_in_have.keys():
-            if k1 not in want.keys():
-                delete_dict.update({k1: obj_in_have[k1]})
-
-        if delete_dict:
-            delete_dict.update({'name': want['name']})
-            del_commands = self.del_commands(delete_dict)
-        merged_commands = self.set_commands(want, have)
-
-        if merged_commands:
-            cmds = set(del_commands).intersection(set(merged_commands))
-            for cmd in cmds:
-                merged_commands.remove(cmd)
-
-        commands.extend(del_commands)
-        commands.extend(merged_commands)
-        return commands
-
-    def _state_overridden(self, want, have):
-        """ The command generator when state is overridden
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        commands = []
-        want_intfs = [w['name'] for w in want]
-        for h in have:
-            h = flatten_dict(h)
-            delete_dict = {}
-            if h['name'] in want_intfs:
-                for w in want:
-                    if w['name'] == h['name']:
-                        delete_keys = list(set(h) - set(flatten_dict(w)))
-                        for k in delete_keys:
-                            delete_dict.update({k: h[k]})
-                        delete_dict.update({'name': h['name']})
-                        break
-            else:
-                delete_dict.update(h)
-            commands.extend(self.del_commands(delete_dict))
-        for w in want:
-            commands.extend(self.set_commands(flatten_dict(w), have))
-        return commands
-
-    def _state_merged(self, want, have):
-        """ The command generator when state is merged
-
-        :rtype: A list
-        :returns: the commands necessary to merge the provided into
-                  the current configuration
-        """
-        return self.set_commands(want, have)
-
-    def _state_deleted(self, want, have):
-        """ The command generator when state is deleted
-
-        :rtype: A list
-        :returns: the commands necessary to remove the current configuration
-        of the provided objects
-        """
-        commands = []
-        if want:
-            for w in want:
-                obj_in_have = flatten_dict(
-                    search_obj_in_list(w['name'], have, 'name'))
-                commands.extend(self.del_commands(obj_in_have))
-        else:
-            if not have:
-                return commands
-            for h in have:
-                commands.extend(self.del_commands(flatten_dict(h)))
-        return commands
-
-    def set_commands(self, want, have):
-        commands = []
-        obj_in_have = flatten_dict(
-            search_obj_in_list(want['name'], have, 'name'))
-        if not obj_in_have:
-            commands = self.add_commands(flatten_dict(want))
-        else:
-            diff = dict_diff(obj_in_have, want)
-            if diff:
-                diff.update({'name': want['name']})
-                commands = self.add_commands(diff)
-        return commands
-
-    def add_commands(self, d):
-        commands = []
-        if not d:
-            return commands
-        commands.append('interface ' + d['name'])
-        if 'transmit' in d:
-            if (d['transmit']):
-                commands.append('lldp transmit')
-            else:
-                commands.append('no lldp transmit')
-        if 'receive' in d:
-            if (d['receive']):
-                commands.append('lldp receive')
-            else:
-                commands.append('no lldp receive')
-        if 'management_address' in d:
-            commands.append('lldp tlv-set management-address ' +
-                            d['management_address'])
-        if 'vlan' in d:
-            commands.append('lldp tlv-set vlan ' + str(d['vlan']))
-
-        return commands
-
-    def del_commands(self, obj):
-        commands = []
-        if not obj or len(obj.keys()) == 1:
-            return commands
-        commands.append('interface ' + obj['name'])
-        if 'transmit' in obj:
-            commands.append('lldp transmit')
-        if 'receive' in obj:
-            commands.append('lldp receive')
-        if 'management_address' in obj:
-            commands.append('no lldp tlv-set management-address ' +
-                            obj['management_address'])
-        if 'vlan' in obj:
-            commands.append('no lldp tlv-set vlan ' + str(obj['vlan']))
-
-        return commands
diff --git a/lib/ansible/module_utils/network/nxos/config/telemetry/telemetry.py b/lib/ansible/module_utils/network/nxos/config/telemetry/telemetry.py
deleted file mode 100644
index dac91b232c..0000000000
--- a/lib/ansible/module_utils/network/nxos/config/telemetry/telemetry.py
+++ /dev/null
@@ -1,503 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Cisco and/or its affiliates.
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos_telemetry class
-It is in this file where the current configuration (as dict)
-is compared to the provided configuration (as dict) and the command set
-necessary to bring the current configuration to it's desired end-state is
-created
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-from ansible.module_utils.network.common.cfg.base import ConfigBase
-from ansible.module_utils.network.common.utils import to_list
-from ansible.module_utils.network.nxos.facts.facts import Facts
-from ansible.module_utils.network.nxos.cmdref.telemetry.telemetry import TMS_GLOBAL, TMS_DESTGROUP, TMS_SENSORGROUP, TMS_SUBSCRIPTION
-from ansible.module_utils.network.nxos.utils.telemetry.telemetry import normalize_data, remove_duplicate_context
-from ansible.module_utils.network.nxos.utils.telemetry.telemetry import valiate_input, get_setval_path, massage_data
-from ansible.module_utils.network.nxos.utils.telemetry.telemetry import get_module_params_subsection, remove_duplicate_commands
-from ansible.module_utils.network.nxos.utils.utils import normalize_interface
-from ansible.module_utils.network.nxos.nxos import NxosCmdRef
-
-
-class Telemetry(ConfigBase):
-    """
-    The nxos_telemetry class
-    """
-
-    gather_subset = [
-        '!all',
-        '!min',
-    ]
-
-    gather_network_resources = [
-        'telemetry',
-    ]
-
-    def __init__(self, module):
-        super(Telemetry, self).__init__(module)
-
-    def get_telemetry_facts(self):
-        """ Get the 'facts' (the current configuration)
-        :rtype: A dictionary
-        :returns: The current configuration as a dictionary
-        """
-        facts, _warnings = Facts(self._module).get_facts(self.gather_subset, self.gather_network_resources)
-        telemetry_facts = facts['ansible_network_resources'].get('telemetry')
-        if not telemetry_facts:
-            return {}
-        return telemetry_facts
-
-    def edit_config(self, commands):
-        return self._connection.edit_config(commands)
-
-    def execute_module(self):
-        """ Execute the module
-        :rtype: A dictionary
-        :returns: The result from module execution
-        """
-        result = {'changed': False}
-        commands = list()
-        warnings = list()
-
-        state = self._module.params['state']
-        if 'overridden' in state:
-            self._module.fail_json(msg='State <overridden> is invalid for this module.')
-        # When state is 'deleted', the module_params should not contain data
-        # under the 'config' key
-        if 'deleted' in state and self._module.params.get('config'):
-            self._module.fail_json(msg='Remove config key from playbook when state is <deleted>')
-
-        if self._module.params['config'] is None:
-            self._module.params['config'] = {}
-        # Normalize interface name.
-        int = self._module.params['config'].get('source_interface')
-        if int:
-            self._module.params['config']['source_interface'] = normalize_interface(int)
-
-        existing_telemetry_facts = self.get_telemetry_facts()
-        commands.extend(self.set_config(existing_telemetry_facts))
-        if commands:
-            if not self._module.check_mode:
-                self.edit_config(commands)
-                # TODO: edit_config is only available for network_cli. Once we
-                # add support for httpapi, we will need to switch to load_config
-                # or add support to httpapi for edit_config
-                #
-                # self._connection.load_config(commands)
-            result['changed'] = True
-        result['commands'] = commands
-
-        changed_telemetry_facts = self.get_telemetry_facts()
-
-        result['before'] = existing_telemetry_facts
-        if result['changed']:
-            result['after'] = changed_telemetry_facts
-
-        result['warnings'] = warnings
-        return result
-
-    def set_config(self, existing_tms_global_facts):
-        """ Collect the configuration from the args passed to the module,
-            collect the current configuration (as a dict from facts)
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        config = self._module.params['config']
-        want = dict((k, v) for k, v in config.items() if v is not None)
-        have = existing_tms_global_facts
-        resp = self.set_state(want, have)
-        return to_list(resp)
-
-    def set_state(self, want, have):
-        """ Select the appropriate function based on the state provided
-        :param want: the desired configuration as a dictionary
-        :param have: the current configuration as a dictionary
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        state = self._module.params['state']
-
-        # The deleted case is very simple since we purge all telemetry config
-        # and does not require any processing using NxosCmdRef objects.
-        if state == 'deleted':
-            return self._state_deleted(want, have)
-        elif state == 'replaced':
-            if want == have:
-                return []
-            return self._state_replaced(want, have)
-
-        # Save off module params
-        ALL_MP = self._module.params['config']
-
-        cmd_ref = {}
-        cmd_ref['TMS_GLOBAL'] = {}
-        cmd_ref['TMS_DESTGROUP'] = {}
-        cmd_ref['TMS_SENSORGROUP'] = {}
-        cmd_ref['TMS_SUBSCRIPTION'] = {}
-
-        # Build Telemetry Global NxosCmdRef Object
-        cmd_ref['TMS_GLOBAL']['ref'] = []
-        self._module.params['config'] = get_module_params_subsection(ALL_MP, 'TMS_GLOBAL')
-        cmd_ref['TMS_GLOBAL']['ref'].append(NxosCmdRef(self._module, TMS_GLOBAL))
-        ref = cmd_ref['TMS_GLOBAL']['ref'][0]
-        ref.set_context()
-        ref.get_existing()
-        ref.get_playvals()
-        device_cache = ref.cache_existing
-
-        def build_cmdref_objects(td):
-            cmd_ref[td['type']]['ref'] = []
-            saved_ids = []
-            if want.get(td['name']):
-                for playvals in want[td['name']]:
-                    valiate_input(playvals, td['name'], self._module)
-                    if playvals['id'] in saved_ids:
-                        continue
-                    saved_ids.append(playvals['id'])
-                    resource_key = td['cmd'].format(playvals['id'])
-                    # Only build the NxosCmdRef object for the td['name'] module parameters.
-                    self._module.params['config'] = get_module_params_subsection(ALL_MP, td['type'], playvals['id'])
-                    cmd_ref[td['type']]['ref'].append(NxosCmdRef(self._module, td['obj']))
-                    ref = cmd_ref[td['type']]['ref'][-1]
-                    ref.set_context([resource_key])
-                    if td['type'] == 'TMS_SENSORGROUP' and get_setval_path(self._module):
-                        # Sensor group path setting can contain optional values.
-                        # Call get_setval_path helper function to process any
-                        # optional setval keys.
-                        ref._ref['path']['setval'] = get_setval_path(self._module)
-                    ref.get_existing(device_cache)
-                    ref.get_playvals()
-                    if td['type'] == 'TMS_DESTGROUP':
-                        normalize_data(ref)
-
-        # Build Telemetry Destination Group NxosCmdRef Objects
-        td = {'name': 'destination_groups', 'type': 'TMS_DESTGROUP',
-              'obj': TMS_DESTGROUP, 'cmd': 'destination-group {0}'}
-        build_cmdref_objects(td)
-
-        # Build Telemetry Sensor Group NxosCmdRef Objects
-        td = {'name': 'sensor_groups', 'type': 'TMS_SENSORGROUP',
-              'obj': TMS_SENSORGROUP, 'cmd': 'sensor-group {0}'}
-        build_cmdref_objects(td)
-
-        # Build Telemetry Subscription NxosCmdRef Objects
-        td = {'name': 'subscriptions', 'type': 'TMS_SUBSCRIPTION',
-              'obj': TMS_SUBSCRIPTION, 'cmd': 'subscription {0}'}
-        build_cmdref_objects(td)
-
-        if state == 'merged':
-            if want == have:
-                return []
-            commands = self._state_merged(cmd_ref)
-        return commands
-
-    @staticmethod
-    def _state_replaced(want, have):
-        """ The command generator when state is replaced
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        commands = []
-        massaged_have = massage_data(have)
-        massaged_want = massage_data(want)
-
-        ref = {}
-        ref['tms_global'] = NxosCmdRef([], TMS_GLOBAL, ref_only=True)
-        ref['tms_destgroup'] = NxosCmdRef([], TMS_DESTGROUP, ref_only=True)
-        ref['tms_sensorgroup'] = NxosCmdRef([], TMS_SENSORGROUP, ref_only=True)
-        ref['tms_subscription'] = NxosCmdRef([], TMS_SUBSCRIPTION, ref_only=True)
-
-        # Order matters for state replaced.
-        # First remove all subscriptions, followed by sensor-groups and destination-groups.
-        # Second add all destination-groups, followed by sensor-groups and subscriptions
-        add = {'TMS_GLOBAL': [], 'TMS_DESTGROUP': [], 'TMS_SENSORGROUP': [], 'TMS_SUBSCRIPTION': []}
-        delete = {'TMS_DESTGROUP': [], 'TMS_SENSORGROUP': [], 'TMS_SUBSCRIPTION': []}
-
-        # Process Telemetry Global Want and Have Values
-        # Possible states:
-        # - want and have are (set) (equal: no action, not equal: replace with want)
-        # - want (set) have (not set) (add want)
-        # - want (not set) have (set) (delete have)
-        # - want (not set) have (not set) (no action)
-        # global_ctx = ref['tms_global']._ref['_template']['context']
-        # property_ctx = ref['tms_global']._ref['certificate'].get('context')
-        # setval = ref['tms_global']._ref['certificate']['setval']
-        #
-        all_global_properties = ['certificate', 'compression', 'source_interface', 'vrf']
-        dest_profile_properties = ['compression', 'source_interface', 'vrf']
-        dest_profile_remote_commands = []
-        for property in all_global_properties:
-            cmd = None
-            global_ctx = ref['tms_global']._ref['_template']['context']
-            property_ctx = ref['tms_global']._ref[property].get('context')
-            setval = ref['tms_global']._ref[property]['setval']
-            kind = ref['tms_global']._ref[property]['kind']
-            if want.get(property) is not None:
-                if have.get(property) is not None:
-                    if want.get(property) != have.get(property):
-                        if kind == 'dict':
-                            cmd = [setval.format(**want.get(property))]
-                        else:
-                            cmd = [setval.format(want.get(property))]
-                elif have.get(property) is None:
-                    if kind == 'dict':
-                        cmd = [setval.format(**want.get(property))]
-                    else:
-                        cmd = [setval.format(want.get(property))]
-            elif want.get(property) is None:
-                if have.get(property) is not None:
-                    if kind == 'dict':
-                        cmd = ['no ' + setval.format(**have.get(property))]
-                    else:
-                        cmd = ['no ' + setval.format(have.get(property))]
-                    if property in dest_profile_properties:
-                        dest_profile_remote_commands.extend(cmd)
-
-            if cmd is not None:
-                ctx = global_ctx
-                if property_ctx is not None:
-                    ctx.extend(property_ctx)
-                add['TMS_GLOBAL'].extend(ctx)
-                add['TMS_GLOBAL'].extend(cmd)
-
-        add['TMS_GLOBAL'] = remove_duplicate_commands(add['TMS_GLOBAL'])
-        # If all destination profile commands are being removed then just
-        # remove the config context instead.
-        if len(dest_profile_remote_commands) == 3:
-            for item in dest_profile_remote_commands:
-                add['TMS_GLOBAL'].remove(item)
-            add['TMS_GLOBAL'].remove('destination-profile')
-            add['TMS_GLOBAL'].extend(['no destination-profile'])
-
-        # Process Telemetry destination_group, sensor_group and subscription Want and Have Values
-        # Possible states:
-        # - want (not set) have (set) (delete have)
-        # - want and have are (set) (equal: no action, not equal: replace with want)
-        # - want (set) have (not set) (add want)
-        # - want (not set) have (not set) (no action)
-        tms_resources = ['TMS_DESTGROUP', 'TMS_SENSORGROUP', 'TMS_SUBSCRIPTION']
-        for resource in tms_resources:
-            if resource == 'TMS_DESTGROUP':
-                name = 'destination-group'
-                cmd_property = 'destination'
-                global_ctx = ref['tms_destgroup']._ref['_template']['context']
-                setval = ref['tms_destgroup']._ref['destination']['setval']
-                want_resources = massaged_want.get('destination_groups')
-                have_resources = massaged_have.get('destination_groups')
-            if resource == 'TMS_SENSORGROUP':
-                name = 'sensor-group'
-                global_ctx = ref['tms_sensorgroup']._ref['_template']['context']
-                setval = {}
-                setval['data_source'] = ref['tms_sensorgroup']._ref['data_source']['setval']
-                setval['path'] = ref['tms_sensorgroup']._ref['path']['setval']
-                want_resources = massaged_want.get('sensor_groups')
-                have_resources = massaged_have.get('sensor_groups')
-            if resource == 'TMS_SUBSCRIPTION':
-                name = 'subscription'
-                global_ctx = ref['tms_subscription']._ref['_template']['context']
-                setval = {}
-                setval['destination_group'] = ref['tms_subscription']._ref['destination_group']['setval']
-                setval['sensor_group'] = ref['tms_subscription']._ref['sensor_group']['setval']
-                want_resources = massaged_want.get('subscriptions')
-                have_resources = massaged_have.get('subscriptions')
-
-            if not want_resources and have_resources:
-                # want not and have not set so delete have
-                for key in have_resources.keys():
-                    remove_context = ['{0} {1} {2}'.format('no', name, key)]
-                    delete[resource].extend(global_ctx)
-                    if remove_context[0] not in delete[resource]:
-                        delete[resource].extend(remove_context)
-            else:
-                # want and have are set.
-                # process wants:
-                for want_key in want_resources.keys():
-                    if want_key not in have_resources.keys():
-                        # Want resource key not in have resource key so add it
-                        property_ctx = ['{0} {1}'.format(name, want_key)]
-                        for item in want_resources[want_key]:
-                            if resource == 'TMS_DESTGROUP':
-                                cmd = [setval.format(**item[cmd_property])]
-                                add[resource].extend(global_ctx)
-                                if property_ctx[0] not in add[resource]:
-                                    add[resource].extend(property_ctx)
-                                add[resource].extend(cmd)
-                            if resource == 'TMS_SENSORGROUP':
-                                cmd = {}
-                                if item.get('data_source'):
-                                    cmd['data_source'] = [setval['data_source'].format(item['data_source'])]
-                                if item.get('path'):
-                                    setval['path'] = get_setval_path(item.get('path'))
-                                    cmd['path'] = [setval['path'].format(**item['path'])]
-                                add[resource].extend(global_ctx)
-                                if property_ctx[0] not in add[resource]:
-                                    add[resource].extend(property_ctx)
-                                if cmd.get('data_source'):
-                                    add[resource].extend(cmd['data_source'])
-                                if cmd.get('path'):
-                                    add[resource].extend(cmd['path'])
-                            if resource == 'TMS_SUBSCRIPTION':
-                                cmd = {}
-                                if item.get('destination_group'):
-                                    cmd['destination_group'] = [setval['destination_group'].format(item['destination_group'])]
-                                if item.get('sensor_group'):
-                                    cmd['sensor_group'] = [setval['sensor_group'].format(**item['sensor_group'])]
-                                add[resource].extend(global_ctx)
-                                if property_ctx[0] not in add[resource]:
-                                    add[resource].extend(property_ctx)
-                                if cmd.get('destination_group'):
-                                    add[resource].extend(cmd['destination_group'])
-                                if cmd.get('sensor_group'):
-                                    add[resource].extend(cmd['sensor_group'])
-
-                    elif want_key in have_resources.keys():
-                        # Want resource key exists in have resource keys but we need to
-                        # inspect the individual items under the resource key
-                        # for differences
-                        for item in want_resources[want_key]:
-                            if item not in have_resources[want_key]:
-                                if item is None:
-                                    continue
-                                # item wanted but does not exist so add it
-                                property_ctx = ['{0} {1}'.format(name, want_key)]
-                                if resource == 'TMS_DESTGROUP':
-                                    cmd = [setval.format(**item[cmd_property])]
-                                    add[resource].extend(global_ctx)
-                                    if property_ctx[0] not in add[resource]:
-                                        add[resource].extend(property_ctx)
-                                    add[resource].extend(cmd)
-                                if resource == 'TMS_SENSORGROUP':
-                                    cmd = {}
-                                    if item.get('data_source'):
-                                        cmd['data_source'] = [setval['data_source'].format(item['data_source'])]
-                                    if item.get('path'):
-                                        setval['path'] = get_setval_path(item.get('path'))
-                                        cmd['path'] = [setval['path'].format(**item['path'])]
-                                    add[resource].extend(global_ctx)
-                                    if property_ctx[0] not in add[resource]:
-                                        add[resource].extend(property_ctx)
-                                    if cmd.get('data_source'):
-                                        add[resource].extend(cmd['data_source'])
-                                    if cmd.get('path'):
-                                        add[resource].extend(cmd['path'])
-                                if resource == 'TMS_SUBSCRIPTION':
-                                    cmd = {}
-                                    if item.get('destination_group'):
-                                        cmd['destination_group'] = [setval['destination_group'].format(item['destination_group'])]
-                                    if item.get('sensor_group'):
-                                        cmd['sensor_group'] = [setval['sensor_group'].format(**item['sensor_group'])]
-                                    add[resource].extend(global_ctx)
-                                    if property_ctx[0] not in add[resource]:
-                                        add[resource].extend(property_ctx)
-                                    if cmd.get('destination_group'):
-                                        add[resource].extend(cmd['destination_group'])
-                                    if cmd.get('sensor_group'):
-                                        add[resource].extend(cmd['sensor_group'])
-
-                # process haves:
-                for have_key in have_resources.keys():
-                    if have_key not in want_resources.keys():
-                        # Want resource key is not in have resource keys so remove it
-                        cmd = ['no ' + '{0} {1}'.format(name, have_key)]
-                        delete[resource].extend(global_ctx)
-                        delete[resource].extend(cmd)
-                    elif have_key in want_resources.keys():
-                        # Have resource key exists in want resource keys but we need to
-                        # inspect the individual items under the resource key
-                        # for differences
-                        for item in have_resources[have_key]:
-                            if item not in want_resources[have_key]:
-                                if item is None:
-                                    continue
-                                # have item not wanted so remove it
-                                property_ctx = ['{0} {1}'.format(name, have_key)]
-                                if resource == 'TMS_DESTGROUP':
-                                    cmd = ['no ' + setval.format(**item[cmd_property])]
-                                    delete[resource].extend(global_ctx)
-                                    if property_ctx[0] not in delete[resource]:
-                                        delete[resource].extend(property_ctx)
-                                    delete[resource].extend(cmd)
-                                if resource == 'TMS_SENSORGROUP':
-                                    cmd = {}
-                                    if item.get('data_source'):
-                                        cmd['data_source'] = ['no ' + setval['data_source'].format(item['data_source'])]
-                                    if item.get('path'):
-                                        setval['path'] = get_setval_path(item.get('path'))
-                                        cmd['path'] = ['no ' + setval['path'].format(**item['path'])]
-                                    delete[resource].extend(global_ctx)
-                                    if property_ctx[0] not in delete[resource]:
-                                        delete[resource].extend(property_ctx)
-                                    if cmd.get('data_source'):
-                                        delete[resource].extend(cmd['data_source'])
-                                    if cmd.get('path'):
-                                        delete[resource].extend(cmd['path'])
-                                if resource == 'TMS_SUBSCRIPTION':
-                                    cmd = {}
-                                    if item.get('destination_group'):
-                                        cmd['destination_group'] = ['no ' + setval['destination_group'].format(item['destination_group'])]
-                                    if item.get('sensor_group'):
-                                        cmd['sensor_group'] = ['no ' + setval['sensor_group'].format(**item['sensor_group'])]
-                                    delete[resource].extend(global_ctx)
-                                    if property_ctx[0] not in delete[resource]:
-                                        delete[resource].extend(property_ctx)
-                                    if cmd.get('destination_group'):
-                                        delete[resource].extend(cmd['destination_group'])
-                                    if cmd.get('sensor_group'):
-                                        delete[resource].extend(cmd['sensor_group'])
-
-            add[resource] = remove_duplicate_context(add[resource])
-            delete[resource] = remove_duplicate_context(delete[resource])
-
-        commands.extend(delete['TMS_SUBSCRIPTION'])
-        commands.extend(delete['TMS_SENSORGROUP'])
-        commands.extend(delete['TMS_DESTGROUP'])
-        commands.extend(add['TMS_DESTGROUP'])
-        commands.extend(add['TMS_SENSORGROUP'])
-        commands.extend(add['TMS_SUBSCRIPTION'])
-        commands.extend(add['TMS_GLOBAL'])
-        commands = remove_duplicate_context(commands)
-
-        return commands
-
-    @staticmethod
-    def _state_merged(cmd_ref):
-        """ The command generator when state is merged
-        :rtype: A list
-        :returns: the commands necessary to merge the provided into
-                  the current configuration
-        """
-        commands = cmd_ref['TMS_GLOBAL']['ref'][0].get_proposed()
-
-        if cmd_ref['TMS_DESTGROUP'].get('ref'):
-            for cr in cmd_ref['TMS_DESTGROUP']['ref']:
-                commands.extend(cr.get_proposed())
-
-        if cmd_ref['TMS_SENSORGROUP'].get('ref'):
-            for cr in cmd_ref['TMS_SENSORGROUP']['ref']:
-                commands.extend(cr.get_proposed())
-
-        if cmd_ref['TMS_SUBSCRIPTION'].get('ref'):
-            for cr in cmd_ref['TMS_SUBSCRIPTION']['ref']:
-                commands.extend(cr.get_proposed())
-
-        return remove_duplicate_context(commands)
-
-    @staticmethod
-    def _state_deleted(want, have):
-        """ The command generator when state is deleted
-        :rtype: A list
-        :returns: the commands necessary to remove the current configuration
-                  of the provided objects
-        """
-        commands = []
-        if want != have:
-            commands = ['no telemetry']
-        return commands
diff --git a/lib/ansible/module_utils/network/nxos/config/vlans/vlans.py b/lib/ansible/module_utils/network/nxos/config/vlans/vlans.py
deleted file mode 100644
index 16a8cfa856..0000000000
--- a/lib/ansible/module_utils/network/nxos/config/vlans/vlans.py
+++ /dev/null
@@ -1,290 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos_vlans class
-It is in this file where the current configuration (as dict)
-is compared to the provided configuration (as dict) and the command set
-necessary to bring the current configuration to it's desired end-state is
-created
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-from ansible.module_utils.network.common.cfg.base import ConfigBase
-from ansible.module_utils.network.common.utils import dict_diff, to_list, remove_empties
-from ansible.module_utils.network.nxos.facts.facts import Facts
-from ansible.module_utils.network.nxos.utils.utils import search_obj_in_list
-
-
-class Vlans(ConfigBase):
-    """
-    The nxos_vlans class
-    """
-
-    gather_subset = [
-        '!all',
-        '!min',
-    ]
-
-    gather_network_resources = [
-        'vlans',
-    ]
-
-    def __init__(self, module):
-        super(Vlans, self).__init__(module)
-
-    def get_vlans_facts(self):
-        """ Get the 'facts' (the current configuration)
-
-        :rtype: A dictionary
-        :returns: The current configuration as a dictionary
-        """
-        facts, _warnings = Facts(self._module).get_facts(self.gather_subset, self.gather_network_resources)
-        vlans_facts = facts['ansible_network_resources'].get('vlans')
-        if not vlans_facts:
-            return []
-
-        # Remove vlan 1 from facts list
-        vlans_facts = [i for i in vlans_facts if (int(i['vlan_id'])) != 1]
-        return vlans_facts
-
-    def edit_config(self, commands):
-        """Wrapper method for `_connection.edit_config()`
-        This exists solely to allow the unit test framework to mock device connection calls.
-        """
-        return self._connection.edit_config(commands)
-
-    def execute_module(self):
-        """ Execute the module
-
-        :rtype: A dictionary
-        :returns: The result from module execution
-        """
-        result = {'changed': False}
-        commands = list()
-        warnings = list()
-
-        existing_vlans_facts = self.get_vlans_facts()
-        commands.extend(self.set_config(existing_vlans_facts))
-        if commands:
-            if not self._module.check_mode:
-                self.edit_config(commands)
-            result['changed'] = True
-        result['commands'] = commands
-
-        changed_vlans_facts = self.get_vlans_facts()
-
-        result['before'] = existing_vlans_facts
-        if result['changed']:
-            result['after'] = changed_vlans_facts
-
-        result['warnings'] = warnings
-        return result
-
-    def set_config(self, existing_vlans_facts):
-        """ Collect the configuration from the args passed to the module,
-            collect the current configuration (as a dict from facts)
-
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        config = self._module.params.get('config')
-        want = []
-        if config:
-            for w in config:
-                if int(w['vlan_id']) == 1:
-                    self._module.fail_json(msg="Vlan 1 is not allowed to be managed by this module")
-                want.append(remove_empties(w))
-        have = existing_vlans_facts
-        resp = self.set_state(want, have)
-        return to_list(resp)
-
-    def set_state(self, want, have):
-        """ Select the appropriate function based on the state provided
-
-        :param want: the desired configuration as a dictionary
-        :param have: the current configuration as a dictionary
-        :rtype: A list
-        :returns: the commands necessary to migrate the current configuration
-                  to the desired configuration
-        """
-        state = self._module.params['state']
-        if state in ('overridden', 'merged', 'replaced') and not want:
-            self._module.fail_json(msg='config is required for state {0}'.format(state))
-
-        commands = list()
-        if state == 'overridden':
-            commands.extend(self._state_overridden(want, have))
-        elif state == 'deleted':
-            commands.extend(self._state_deleted(want, have))
-        else:
-            for w in want:
-                if state == 'merged':
-                    commands.extend(self._state_merged(w, have))
-                elif state == 'replaced':
-                    commands.extend(self._state_replaced(w, have))
-        return commands
-
-    def remove_default_states(self, obj):
-        """Removes non-empty but default states from the obj.
-        """
-        default_states = {
-            'enabled': True,
-            'state': 'active',
-            'mode': 'ce',
-        }
-        for k in default_states.keys():
-            if obj[k] == default_states[k]:
-                obj.pop(k, None)
-        return obj
-
-    def _state_replaced(self, want, have):
-        """ The command generator when state is replaced.
-        Scope is limited to vlan objects defined in the playbook.
-        :rtype: A list
-        :returns: The minimum command set required to migrate the current
-                  configuration to the desired configuration.
-        """
-        obj_in_have = search_obj_in_list(want['vlan_id'], have, 'vlan_id')
-        if obj_in_have:
-            # ignore states that are already reset, then diff what's left
-            obj_in_have = self.remove_default_states(obj_in_have)
-            diff = dict_diff(want, obj_in_have)
-            # Remove merge items from diff; what's left will be used to
-            # remove states not specified in the playbook
-            for k in dict(set(want.items()) - set(obj_in_have.items())).keys():
-                diff.pop(k, None)
-        else:
-            diff = want
-
-        # merged_cmds: 'want' cmds to update 'have' states that don't match
-        # replaced_cmds: remaining 'have' cmds that need to be reset to default
-        merged_cmds = self.set_commands(want, have)
-        replaced_cmds = []
-        if obj_in_have:
-            # Remaining diff items are used to reset states to default
-            replaced_cmds = self.del_attribs(diff)
-        cmds = []
-        if replaced_cmds or merged_cmds:
-            cmds += ['vlan %s' % str(want['vlan_id'])]
-            cmds += merged_cmds + replaced_cmds
-        return cmds
-
-    def _state_overridden(self, want, have):
-        """ The command generator when state is overridden.
-        Scope includes all vlan objects on the device.
-        :rtype: A list
-        :returns: the minimum command set required to migrate the current
-                  configuration to the desired configuration.
-        """
-        # overridden behavior is the same as replaced except for scope.
-        cmds = []
-        existing_vlans = []
-        for h in have:
-            existing_vlans.append(h['vlan_id'])
-            obj_in_want = search_obj_in_list(h['vlan_id'], want, 'vlan_id')
-            if obj_in_want:
-                if h != obj_in_want:
-                    replaced_cmds = self._state_replaced(obj_in_want, [h])
-                    if replaced_cmds:
-                        cmds.extend(replaced_cmds)
-            else:
-                cmds.append('no vlan %s' % h['vlan_id'])
-
-        # Add wanted vlans that don't exist on the device yet
-        for w in want:
-            if w['vlan_id'] not in existing_vlans:
-                new_vlan = ['vlan %s' % w['vlan_id']]
-                cmds.extend(new_vlan + self.add_commands(w))
-        return cmds
-
-    def _state_merged(self, w, have):
-        """ The command generator when state is merged
-
-        :rtype: A list
-        :returns: the commands necessary to merge the provided into
-                  the current configuration
-        """
-        cmds = self.set_commands(w, have)
-        if cmds:
-            cmds.insert(0, 'vlan %s' % str(w['vlan_id']))
-        return(cmds)
-
-    def _state_deleted(self, want, have):
-        """ The command generator when state is deleted
-
-        :rtype: A list
-        :returns: the commands necessary to remove the current configuration
-                  of the provided objects
-        """
-        commands = []
-        if want:
-            for w in want:
-                obj_in_have = search_obj_in_list(w['vlan_id'], have, 'vlan_id')
-                if obj_in_have:
-                    commands.append('no vlan ' + str(obj_in_have['vlan_id']))
-        else:
-            if not have:
-                return commands
-            for h in have:
-                commands.append('no vlan ' + str(h['vlan_id']))
-        return commands
-
-    def del_attribs(self, obj):
-        """Returns a list of commands to reset states to default
-        """
-        commands = []
-        if not obj:
-            return commands
-        default_cmds = {
-            'name': 'no name',
-            'state': 'no state',
-            'enabled': 'no shutdown',
-            'mode': 'mode ce',
-            'mapped_vni': 'no vn-segment',
-        }
-        for k in obj:
-            commands.append(default_cmds[k])
-        return commands
-
-    def diff_of_dicts(self, w, obj):
-        diff = set(w.items()) - set(obj.items())
-        diff = dict(diff)
-        if diff and w['vlan_id'] == obj['vlan_id']:
-            diff.update({'vlan_id': w['vlan_id']})
-        return diff
-
-    def add_commands(self, d):
-        commands = []
-        if not d:
-            return commands
-        if 'name' in d:
-            commands.append('name ' + d['name'])
-        if 'state' in d:
-            commands.append('state ' + d['state'])
-        if 'enabled' in d:
-            if d['enabled'] is True:
-                commands.append('no shutdown')
-            else:
-                commands.append('shutdown')
-        if 'mode' in d:
-            commands.append('mode ' + d['mode'])
-        if 'mapped_vni' in d:
-            commands.append('vn-segment %s' % d['mapped_vni'])
-
-        return commands
-
-    def set_commands(self, w, have):
-        commands = []
-        obj_in_have = search_obj_in_list(w['vlan_id'], have, 'vlan_id')
-        if not obj_in_have:
-            commands = self.add_commands(w)
-        else:
-            diff = self.diff_of_dicts(w, obj_in_have)
-            commands = self.add_commands(diff)
-        return commands
diff --git a/lib/ansible/module_utils/network/nxos/facts/acl_interfaces/acl_interfaces.py b/lib/ansible/module_utils/network/nxos/facts/acl_interfaces/acl_interfaces.py
deleted file mode 100644
index 87d522df67..0000000000
--- a/lib/ansible/module_utils/network/nxos/facts/acl_interfaces/acl_interfaces.py
+++ /dev/null
@@ -1,119 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos acl_interfaces fact class
-It is in this file the configuration is collected from the device
-for a given resource, parsed, and the facts tree is populated
-based on the configuration.
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-import re
-from copy import deepcopy
-from ansible.module_utils.network.common import utils
-from ansible.module_utils.network.nxos.argspec.acl_interfaces.acl_interfaces import Acl_interfacesArgs
-from ansible.module_utils.network.nxos.utils.utils import normalize_interface
-
-
-class Acl_interfacesFacts(object):
-    """ The nxos acl_interfaces fact class
-    """
-
-    def __init__(self, module, subspec='config', options='options'):
-        self._module = module
-        self.argument_spec = Acl_interfacesArgs.argument_spec
-        spec = deepcopy(self.argument_spec)
-        if subspec:
-            if options:
-                facts_argument_spec = spec[subspec][options]
-            else:
-                facts_argument_spec = spec[subspec]
-        else:
-            facts_argument_spec = spec
-
-        self.generated_spec = utils.generate_dict(facts_argument_spec)
-
-    def get_device_data(self, connection):
-        return connection.get('show running-config | section interface')
-
-    def populate_facts(self, connection, ansible_facts, data=None):
-        """ Populate the facts for acl_interfaces
-        :param connection: the device connection
-        :param ansible_facts: Facts dictionary
-        :param data: previously collected conf
-        :rtype: dictionary
-        :returns: facts
-        """
-        if not data:
-            data = self.get_device_data(connection)
-        data = data.split('interface')
-
-        resources = []
-        for i in range(len(data)):
-            intf = data[i].split('\n')
-            for l in range(1, len(intf)):
-                if not re.search('ip(v6)?( port)? (access-group|traffic-filter)', intf[l]):
-                    intf[l] = ''
-            intf = list(filter(None, intf))
-            resources.append(intf)
-
-        objs = []
-        for resource in resources:
-            if resource:
-                obj = self.render_config(self.generated_spec, resource)
-                if obj:
-                    objs.append(obj)
-
-        ansible_facts['ansible_network_resources'].pop('acl_interfaces', None)
-        facts = {}
-        if objs:
-            params = utils.validate_config(
-                self.argument_spec, {'config': objs})
-            params = utils.remove_empties(params)
-            facts['acl_interfaces'] = params['config']
-
-        ansible_facts['ansible_network_resources'].update(facts)
-        return ansible_facts
-
-    def render_config(self, spec, conf):
-        """
-        Render config as dictionary structure and delete keys
-          from spec for null values
-
-        :param spec: The facts tree, generated from the argspec
-        :param conf: The configuration
-        :rtype: dictionary
-        :returns: The generated config
-        """
-        config = deepcopy(spec)
-        name = conf[0].strip()
-        config['name'] = normalize_interface(name)
-        config['access_groups'] = []
-        v4 = {'afi': 'ipv4', 'acls': []}
-        v6 = {'afi': 'ipv6', 'acls': []}
-        for c in conf[1:]:
-            if c:
-                acl4 = re.search(r'ip( port)? access-group (\w*) (\w*)', c)
-                acl6 = re.search(r'ipv6( port)? traffic-filter (\w*) (\w*)', c)
-                if acl4:
-                    acl = {'name': acl4.group(2).strip(
-                    ), 'direction': acl4.group(3).strip()}
-                    if acl4.group(1):
-                        acl.update({'port': True})
-                    v4['acls'].append(acl)
-                elif acl6:
-                    acl = {'name': acl6.group(2), 'direction': acl6.group(3)}
-                    if acl6.group(1):
-                        acl.update({'port': True})
-                    v6['acls'].append(acl)
-
-        if len(v4['acls']) > 0:
-            config['access_groups'].append(v4)
-        if len(v6['acls']) > 0:
-            config['access_groups'].append(v6)
-
-        return utils.remove_empties(config)
diff --git a/lib/ansible/module_utils/network/nxos/facts/acls/acls.py b/lib/ansible/module_utils/network/nxos/facts/acls/acls.py
deleted file mode 100644
index e9b97b2456..0000000000
--- a/lib/ansible/module_utils/network/nxos/facts/acls/acls.py
+++ /dev/null
@@ -1,236 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos acls fact class
-It is in this file the configuration is collected from the device
-for a given resource, parsed, and the facts tree is populated
-based on the configuration.
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-import re
-from copy import deepcopy
-
-from ansible.module_utils.network.common import utils
-from ansible.module_utils.network.nxos.argspec.acls.acls import AclsArgs
-
-
-class AclsFacts(object):
-    """ The nxos acls fact class
-    """
-
-    def __init__(self, module, subspec='config', options='options'):
-        self._module = module
-        self.argument_spec = AclsArgs.argument_spec
-        spec = deepcopy(self.argument_spec)
-        if subspec:
-            if options:
-                facts_argument_spec = spec[subspec][options]
-            else:
-                facts_argument_spec = spec[subspec]
-        else:
-            facts_argument_spec = spec
-        self.generated_spec = utils.generate_dict(facts_argument_spec)
-
-    def get_device_data(self, connection):
-        return connection.get(
-            "show running-config | section 'ip(v6)* access-list'")
-
-    def populate_facts(self, connection, ansible_facts, data=None):
-        """ Populate the facts for acls
-        :param connection: the device connection
-        :param ansible_facts: Facts dictionary
-        :param data: previously collected conf
-        :rtype: dictionary
-        :returns: facts
-        """
-        if not data:
-            data = self.get_device_data(connection)
-        data = re.split('\nip', data)
-        v6 = []
-        v4 = []
-
-        for i in range(len(data)):
-            if str(data[i]):
-                if 'v6' in str(data[i]).split()[0]:
-                    v6.append(data[i])
-                else:
-                    v4.append(data[i])
-
-        resources = []
-        resources.append(v6)
-        resources.append(v4)
-        objs = []
-        for resource in resources:
-            if resource:
-                obj = self.render_config(self.generated_spec, resource)
-                if obj:
-                    objs.append(obj)
-
-        ansible_facts['ansible_network_resources'].pop('acls', None)
-        facts = {}
-        if objs:
-            params = utils.validate_config(self.argument_spec,
-                                           {'config': objs})
-            params = utils.remove_empties(params)
-            facts['acls'] = params['config']
-
-        ansible_facts['ansible_network_resources'].update(facts)
-        return ansible_facts
-
-    def get_endpoint(self, ace, pro):
-        ret_dict = {}
-        option = ace.split()[0]
-        if option == 'any':
-            ret_dict.update({'any': True})
-        else:
-            # it could be a.b.c.d or a.b.c.d/x or a.b.c.d/32
-            if '/' in option:  # or 'host' in option:
-                ip = re.search(r'(.*)/(\d+)', option)
-                if int(ip.group(2)) < 32 or 32 < int(ip.group(2)) < 128:
-                    ret_dict.update({'prefix': option})
-                else:
-                    ret_dict.update({'host': ip.group(1)})
-            else:
-                ret_dict.update({'address': option})
-                wb = ace.split()[1]
-                ret_dict.update({'wildcard_bits': wb})
-                ace = re.sub('{0}'.format(wb), '', ace, 1)
-        ace = re.sub(option, '', ace, 1)
-        if pro in ['tcp', 'udp']:
-            keywords = ['eq', 'lt', 'gt', 'neq', 'range']
-            if len(ace.split()) and ace.split()[0] in keywords:
-                port_protocol = {}
-                port_pro = re.search(r'(eq|lt|gt|neq) (\w*)', ace)
-                if port_pro:
-                    port_protocol.update(
-                        {port_pro.group(1): port_pro.group(2)})
-                    ace = re.sub(port_pro.group(1), '', ace, 1)
-                    ace = re.sub(port_pro.group(2), '', ace, 1)
-                else:
-                    limit = re.search(r'(range) (\w*) (\w*)', ace)
-                    if limit:
-                        port_protocol.update({
-                            'range': {
-                                'start': limit.group(2),
-                                'end': limit.group(3)
-                            }
-                        })
-                        ace = re.sub(limit.group(2), '', ace, 1)
-                        ace = re.sub(limit.group(3), '', ace, 1)
-                if port_protocol:
-                    ret_dict.update({'port_protocol': port_protocol})
-        return ace, ret_dict
-
-    def render_config(self, spec, conf):
-        """
-        Render config as dictionary structure and delete keys
-          from spec for null values
-
-        :param spec: The facts tree, generated from the argspec
-        :param conf: The configuration
-        :rtype: dictionary
-        :returns: The generated config
-        """
-        config = deepcopy(spec)
-        protocol_options = {
-            'tcp': ['fin', 'established', 'psh', 'rst', 'syn', 'urg', 'ack'],
-            'icmp': [
-                'administratively_prohibited', 'alternate_address',
-                'conversion_error', 'dod_host_prohibited',
-                'dod_net_prohibited', 'echo', 'echo_reply',
-                'general_parameter_problem', 'host_isolated',
-                'host_precedence_unreachable', 'host_redirect',
-                'host_tos_redirect', 'host_tos_unreachable', 'host_unknown',
-                'host_unreachable', 'information_reply', 'information_request',
-                'mask_reply', 'mask_request', 'mobile_redirect',
-                'net_redirect', 'net_tos_redirect', 'net_tos_unreachable',
-                'net_unreachable', 'network_unknown', 'no_room_for_option',
-                'option_missing', 'packet_too_big', 'parameter_problem',
-                'port_unreachable', 'precedence_unreachable',
-                'protocol_unreachable', 'reassembly_timeout', 'redirect',
-                'router_advertisement', 'router_solicitation', 'source_quench',
-                'source_route_failed', 'time_exceeded', 'timestamp_reply',
-                'timestamp_request', 'traceroute', 'ttl_exceeded',
-                'unreachable'
-            ],
-            'igmp': ['dvmrp', 'host_query', 'host_report'],
-        }
-        if conf:
-            if 'v6' in conf[0].split()[0]:
-                config['afi'] = 'ipv6'
-            else:
-                config['afi'] = 'ipv4'
-            config['acls'] = []
-            for acl in conf:
-                acls = {}
-                if 'match-local-traffic' in acl:
-                    config['match_local_traffic'] = True
-                    continue
-                acl = acl.split('\n')
-                acl = [a.strip() for a in acl]
-                acl = list(filter(None, acl))
-                acls['name'] = re.match(r'(ip)?(v6)?\s?access-list (.*)',
-                                        acl[0]).group(3)
-                acls['aces'] = []
-                for ace in list(filter(None, acl[1:])):
-                    if re.search(r'ip(.*)access-list.*', ace):
-                        break
-                    entry = {}
-                    ace = ace.strip()
-                    seq = re.match(r'(\d*)', ace).group(0)
-                    entry.update({'sequence': seq})
-                    ace = re.sub(seq, '', ace, 1)
-                    grant = ace.split()[0]
-                    rem = ''
-                    if grant != 'remark':
-                        entry.update({'grant': grant})
-                    else:
-                        rem = re.match('.*remark (.*)', ace).group(1)
-                        entry.update({'remark': rem})
-
-                    if not rem:
-                        ace = re.sub(grant, '', ace, 1)
-                        pro = ace.split()[0]
-                        entry.update({'protocol': pro})
-                        ace = re.sub(pro, '', ace, 1)
-                        ace, source = self.get_endpoint(ace, pro)
-                        entry.update({'source': source})
-                        ace, dest = self.get_endpoint(ace, pro)
-                        entry.update({'destination': dest})
-
-                        dscp = re.search(r'dscp (\w*)', ace)
-                        if dscp:
-                            entry.update({'dscp': dscp.group(1)})
-
-                        frag = re.search(r'fragments', ace)
-                        if frag:
-                            entry.update({'fragments': True})
-
-                        prec = re.search(r'precedence (\w*)', ace)
-                        if prec:
-                            entry.update({'precedence': prec.group(1)})
-
-                        log = re.search('log', ace)
-                        if log:
-                            entry.update({'log': True})
-
-                        if pro == 'tcp' or pro == 'icmp' or pro == 'igmp':
-                            pro_options = {}
-                            options = {}
-                            for option in protocol_options[pro]:
-                                option = re.sub('_', '-', option)
-                                if option in ace:
-                                    option = re.sub('-', '_', option)
-                                    options.update({option: True})
-                            if options:
-                                pro_options.update({pro: options})
-                            if pro_options:
-                                entry.update({'protocol_options': pro_options})
-                    acls['aces'].append(entry)
-                config['acls'].append(acls)
-        return utils.remove_empties(config)
diff --git a/lib/ansible/module_utils/network/nxos/facts/bfd_interfaces/bfd_interfaces.py b/lib/ansible/module_utils/network/nxos/facts/bfd_interfaces/bfd_interfaces.py
deleted file mode 100644
index ad1c63a859..0000000000
--- a/lib/ansible/module_utils/network/nxos/facts/bfd_interfaces/bfd_interfaces.py
+++ /dev/null
@@ -1,97 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Cisco and/or its affiliates.
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-"""
-The nxos bfd_interfaces fact class
-Populate the facts tree based on the current device configuration.
-"""
-import re
-from copy import deepcopy
-
-from ansible.module_utils.network.common import utils
-from ansible.module_utils.network.nxos.argspec.bfd_interfaces.bfd_interfaces import Bfd_interfacesArgs
-from ansible.module_utils.network.nxos.utils.utils import get_interface_type
-
-
-class Bfd_interfacesFacts(object):
-    """ The nxos_bfd_interfaces fact class
-    """
-
-    def __init__(self, module, subspec='config', options='options'):
-        self._module = module
-        self.argument_spec = Bfd_interfacesArgs.argument_spec
-        spec = deepcopy(self.argument_spec)
-        if subspec:
-            if options:
-                facts_argument_spec = spec[subspec][options]
-            else:
-                facts_argument_spec = spec[subspec]
-        else:
-            facts_argument_spec = spec
-
-        self.generated_spec = utils.generate_dict(facts_argument_spec)
-
-    def populate_facts(self, connection, ansible_facts, data=None):
-        """ Populate the facts for bfd_interfaces
-        :param connection: the device connection
-        :param ansible_facts: Facts dictionary
-        :param data: previously collected conf
-        :rtype: dictionary
-        :returns: facts
-        """
-        objs = []
-
-        if not data:
-            data = connection.get("show running-config | section '^interface|^feature bfd'")
-
-        # Some of the bfd attributes
-        if 'feature bfd' in data.split('\n'):
-            resources = data.split('interface ')
-            resources.pop(0)
-        else:
-            resources = []
-        for resource in resources:
-            if resource:
-                obj = self.render_config(self.generated_spec, resource)
-                if obj and len(obj.keys()) > 1:
-                    objs.append(obj)
-
-        ansible_facts['ansible_network_resources'].pop('bfd_interfaces', None)
-        facts = {}
-        if objs:
-            facts['bfd_interfaces'] = []
-            params = utils.validate_config(self.argument_spec, {'config': objs})
-            for cfg in params['config']:
-                facts['bfd_interfaces'].append(utils.remove_empties(cfg))
-
-        ansible_facts['ansible_network_resources'].update(facts)
-        return ansible_facts
-
-    def render_config(self, spec, conf):
-        """
-        Render config as dictionary structure and delete keys
-          from spec for null values
-
-        :param spec: The facts tree, generated from the argspec
-        :param conf: The configuration
-        :rtype: dictionary
-        :returns: The generated config
-        """
-        config = deepcopy(spec)
-
-        match = re.search(r'^(\S+)', conf)
-        intf = match.group(1)
-        if get_interface_type(intf) == 'unknown':
-            return {}
-        config['name'] = intf
-        # 'bfd'/'bfd echo' do not nvgen when enabled thus set to 'enable' when None.
-        # 'bfd' is not supported on some platforms
-        config['bfd'] = utils.parse_conf_cmd_arg(conf, 'bfd', 'enable', 'disable') or 'enable'
-        config['echo'] = utils.parse_conf_cmd_arg(conf, 'bfd echo', 'enable', 'disable') or 'enable'
-
-        return utils.remove_empties(config)
diff --git a/lib/ansible/module_utils/network/nxos/facts/facts.py b/lib/ansible/module_utils/network/nxos/facts/facts.py
deleted file mode 100644
index 301652b385..0000000000
--- a/lib/ansible/module_utils/network/nxos/facts/facts.py
+++ /dev/null
@@ -1,82 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The facts class for nxos
-this file validates each subset of facts and selectively
-calls the appropriate facts gathering function
-"""
-
-from ansible.module_utils.network.common.facts.facts import FactsBase
-from ansible.module_utils.network.nxos.facts.legacy.base import Default, Legacy, Hardware, Config, Interfaces, Features
-from ansible.module_utils.network.nxos.facts.bfd_interfaces.bfd_interfaces import Bfd_interfacesFacts
-from ansible.module_utils.network.nxos.facts.hsrp_interfaces.hsrp_interfaces import Hsrp_interfacesFacts
-from ansible.module_utils.network.nxos.facts.interfaces.interfaces import InterfacesFacts
-from ansible.module_utils.network.nxos.facts.l2_interfaces.l2_interfaces import L2_interfacesFacts
-from ansible.module_utils.network.nxos.facts.lacp.lacp import LacpFacts
-from ansible.module_utils.network.nxos.facts.l3_interfaces.l3_interfaces import L3_interfacesFacts
-from ansible.module_utils.network.nxos.facts.lag_interfaces.lag_interfaces import Lag_interfacesFacts
-from ansible.module_utils.network.nxos.facts.telemetry.telemetry import TelemetryFacts
-from ansible.module_utils.network.nxos.facts.vlans.vlans import VlansFacts
-from ansible.module_utils.network.nxos.facts.lacp_interfaces.lacp_interfaces import Lacp_interfacesFacts
-from ansible.module_utils.network.nxos.facts.lldp_global.lldp_global import Lldp_globalFacts
-from ansible.module_utils.network.nxos.facts.lldp_interfaces.lldp_interfaces import Lldp_interfacesFacts
-from ansible.module_utils.network.nxos.facts.acl_interfaces.acl_interfaces import Acl_interfacesFacts
-from ansible.module_utils.network.nxos.facts.acls.acls import AclsFacts
-
-
-FACT_LEGACY_SUBSETS = dict(
-    default=Default,
-    legacy=Legacy,
-    hardware=Hardware,
-    interfaces=Interfaces,
-    config=Config,
-    features=Features,
-)
-FACT_RESOURCE_SUBSETS = dict(
-    bfd_interfaces=Bfd_interfacesFacts,
-    hsrp_interfaces=Hsrp_interfacesFacts,
-    lag_interfaces=Lag_interfacesFacts,
-    lldp_global=Lldp_globalFacts,
-    telemetry=TelemetryFacts,
-    vlans=VlansFacts,
-    lacp=LacpFacts,
-    lacp_interfaces=Lacp_interfacesFacts,
-    interfaces=InterfacesFacts,
-    l3_interfaces=L3_interfacesFacts,
-    l2_interfaces=L2_interfacesFacts,
-    lldp_interfaces=Lldp_interfacesFacts,
-    acl_interfaces=Acl_interfacesFacts,
-    acls=AclsFacts,
-)
-
-
-class Facts(FactsBase):
-    """ The fact class for nxos
-    """
-
-    VALID_LEGACY_GATHER_SUBSETS = frozenset(FACT_LEGACY_SUBSETS.keys())
-    VALID_RESOURCE_SUBSETS = frozenset(FACT_RESOURCE_SUBSETS.keys())
-
-    def __init__(self, module):
-        super(Facts, self).__init__(module)
-
-    def get_facts(self, legacy_facts_type=None, resource_facts_type=None, data=None):
-        """ Collect the facts for nxos
-        :param legacy_facts_type: List of legacy facts types
-        :param resource_facts_type: List of resource fact types
-        :param data: previously collected conf
-        :rtype: dict
-        :return: the facts gathered
-        """
-        if self.VALID_RESOURCE_SUBSETS:
-            self.get_network_resources_facts(
-                FACT_RESOURCE_SUBSETS, resource_facts_type, data)
-
-        if self.VALID_LEGACY_GATHER_SUBSETS:
-            self.get_network_legacy_facts(
-                FACT_LEGACY_SUBSETS, legacy_facts_type)
-
-        return self.ansible_facts, self._warnings
diff --git a/lib/ansible/module_utils/network/nxos/facts/hsrp_interfaces/hsrp_interfaces.py b/lib/ansible/module_utils/network/nxos/facts/hsrp_interfaces/hsrp_interfaces.py
deleted file mode 100644
index b63eca4afd..0000000000
--- a/lib/ansible/module_utils/network/nxos/facts/hsrp_interfaces/hsrp_interfaces.py
+++ /dev/null
@@ -1,89 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Cisco and/or its affiliates.
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-"""
-The nxos hsrp_interfaces fact class
-Populate the facts tree based on the current device configuration.
-"""
-import re
-from copy import deepcopy
-
-from ansible.module_utils.network.common import utils
-from ansible.module_utils.network.nxos.argspec.hsrp_interfaces.hsrp_interfaces import Hsrp_interfacesArgs
-from ansible.module_utils.network.nxos.utils.utils import get_interface_type
-
-
-class Hsrp_interfacesFacts(object):
-    """ The nxos hsrp_interfaces fact class
-    """
-
-    def __init__(self, module, subspec='config', options='options'):
-        self._module = module
-        self.argument_spec = Hsrp_interfacesArgs.argument_spec
-        spec = deepcopy(self.argument_spec)
-        if subspec:
-            if options:
-                facts_argument_spec = spec[subspec][options]
-            else:
-                facts_argument_spec = spec[subspec]
-        else:
-            facts_argument_spec = spec
-
-        self.generated_spec = utils.generate_dict(facts_argument_spec)
-
-    def populate_facts(self, connection, ansible_facts, data=None):
-        """ Populate the facts for hsrp_interfaces
-        :param connection: the device connection
-        :param ansible_facts: Facts dictionary
-        :param data: previously collected conf
-        :rtype: dictionary
-        :returns: facts
-        """
-        objs = []
-
-        if not data:
-            data = connection.get('show running-config | section ^interface')
-
-        resources = data.split('interface ')
-        for resource in resources:
-            if resource:
-                obj = self.render_config(self.generated_spec, resource)
-                if obj and len(obj.keys()) > 1:
-                    objs.append(obj)
-
-        ansible_facts['ansible_network_resources'].pop('hsrp_interfaces', None)
-        facts = {}
-        if objs:
-            facts['hsrp_interfaces'] = []
-            params = utils.validate_config(self.argument_spec, {'config': objs})
-            for cfg in params['config']:
-                facts['hsrp_interfaces'].append(utils.remove_empties(cfg))
-
-        ansible_facts['ansible_network_resources'].update(facts)
-        return ansible_facts
-
-    def render_config(self, spec, conf):
-        """
-        Render config as dictionary structure and delete keys
-          from spec for null values
-
-        :param spec: The facts tree, generated from the argspec
-        :param conf: The configuration
-        :rtype: dictionary
-        :returns: The generated config
-        """
-        config = deepcopy(spec)
-
-        match = re.search(r'^(\S+)', conf)
-        intf = match.group(1)
-        if get_interface_type(intf) == 'unknown':
-            return {}
-        config['name'] = intf
-        config['bfd'] = utils.parse_conf_cmd_arg(conf, 'hsrp bfd', 'enable', 'disable')
-
-        return utils.remove_empties(config)
diff --git a/lib/ansible/module_utils/network/nxos/facts/interfaces/interfaces.py b/lib/ansible/module_utils/network/nxos/facts/interfaces/interfaces.py
deleted file mode 100644
index 59a49376cc..0000000000
--- a/lib/ansible/module_utils/network/nxos/facts/interfaces/interfaces.py
+++ /dev/null
@@ -1,151 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)#!/usr/bin/python
-"""
-The nxos interfaces fact class
-It is in this file the configuration is collected from the device
-for a given resource, parsed, and the facts tree is populated
-based on the configuration.
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-import re
-from copy import deepcopy
-
-from ansible.module_utils.network.common import utils
-from ansible.module_utils.network.nxos.argspec.interfaces.interfaces import InterfacesArgs
-from ansible.module_utils.network.nxos.utils.utils import get_interface_type
-from ansible.module_utils.network.nxos.nxos import default_intf_enabled
-
-
-class InterfacesFacts(object):
-    """ The nxos interfaces fact class
-    """
-
-    def __init__(self, module, subspec='config', options='options'):
-        self._module = module
-        self.argument_spec = InterfacesArgs.argument_spec
-        spec = deepcopy(self.argument_spec)
-        if subspec:
-            if options:
-                facts_argument_spec = spec[subspec][options]
-            else:
-                facts_argument_spec = spec[subspec]
-        else:
-            facts_argument_spec = spec
-
-        self.generated_spec = utils.generate_dict(facts_argument_spec)
-
-    def populate_facts(self, connection, ansible_facts, data=None):
-        """ Populate the facts for interfaces
-        :param connection: the device connection
-        :param data: previously collected conf
-        :rtype: dictionary
-        :returns: facts
-        """
-        objs = []
-        if not data:
-            data = connection.get("show running-config all | incl 'system default switchport'")
-            data += connection.get('show running-config | section ^interface')
-
-        # Collect device defaults & per-intf defaults
-        self.render_system_defaults(data)
-        intf_defs = {'sysdefs': self.sysdefs}
-
-        config = data.split('interface ')
-        default_interfaces = []
-        for conf in config:
-            conf = conf.strip()
-            if conf:
-                obj = self.render_config(self.generated_spec, conf)
-                if obj:
-                    intf_defs[obj['name']] = obj.pop('enabled_def', None)
-                    if len(obj.keys()) > 1:
-                        objs.append(obj)
-                    elif len(obj.keys()) == 1:
-                        # Existing-but-default interfaces are not included in the
-                        # objs list; however a list of default interfaces is
-                        # necessary to prevent idempotence issues and to help
-                        # with virtual interfaces that haven't been created yet.
-                        default_interfaces.append(obj['name'])
-
-        ansible_facts['ansible_network_resources'].pop('interfaces', None)
-        facts = {}
-        facts['interfaces'] = []
-        if objs:
-            params = utils.validate_config(self.argument_spec, {'config': objs})
-            for cfg in params['config']:
-                facts['interfaces'].append(utils.remove_empties(cfg))
-
-        ansible_facts['ansible_network_resources'].update(facts)
-        ansible_facts['ansible_network_resources']['default_interfaces'] = default_interfaces
-        ansible_facts['intf_defs'] = intf_defs
-        return ansible_facts
-
-    def _device_info(self):
-        return self._module._capabilities.get('device_info', {})
-
-    def render_system_defaults(self, config):
-        """Collect user-defined-default states for 'system default switchport' configurations.
-        These configurations determine default L2/L3 modes and enabled/shutdown
-        states. The default values for user-defined-default configurations may
-        be different for legacy platforms.
-        Notes:
-        - L3 enabled default state is False on N9K,N7K but True for N3K,N6K
-        - Changing L2-L3 modes may change the default enabled value.
-        - '(no) system default switchport shutdown' only applies to L2 interfaces.
-        """
-        platform = self._device_info().get('network_os_platform', '')
-        L3_enabled = True if re.search('N[356]K', platform) else False
-        sysdefs = {
-            'mode': None,
-            'L2_enabled': None,
-            'L3_enabled': L3_enabled
-        }
-        pat = '(no )*system default switchport$'
-        m = re.search(pat, config, re.MULTILINE)
-        if m:
-            sysdefs['mode'] = 'layer3' if 'no ' in m.groups() else 'layer2'
-
-        pat = '(no )*system default switchport shutdown$'
-        m = re.search(pat, config, re.MULTILINE)
-        if m:
-            sysdefs['L2_enabled'] = True if 'no ' in m.groups() else False
-
-        self.sysdefs = sysdefs
-
-    def render_config(self, spec, conf):
-        """
-        Render config as dictionary structure and delete keys
-          from spec for null values
-        :param spec: The facts tree, generated from the argspec
-        :param conf: The configuration
-        :rtype: dictionary
-        :returns: The generated config
-        """
-        config = deepcopy(spec)
-
-        match = re.search(r'^(\S+)', conf)
-        intf = match.group(1)
-        if get_interface_type(intf) == 'unknown':
-            return {}
-        config['name'] = intf
-        config['description'] = utils.parse_conf_arg(conf, 'description')
-        config['speed'] = utils.parse_conf_arg(conf, 'speed')
-        config['mtu'] = utils.parse_conf_arg(conf, 'mtu')
-        config['duplex'] = utils.parse_conf_arg(conf, 'duplex')
-        config['mode'] = utils.parse_conf_cmd_arg(conf, 'switchport', 'layer2', 'layer3')
-
-        config['enabled'] = utils.parse_conf_cmd_arg(conf, 'shutdown', False, True)
-
-        # Capture the default 'enabled' state, which may be interface-specific
-        config['enabled_def'] = default_intf_enabled(name=intf, sysdefs=self.sysdefs, mode=config['mode'])
-
-        config['fabric_forwarding_anycast_gateway'] = utils.parse_conf_cmd_arg(conf, 'fabric forwarding mode anycast-gateway', True)
-        config['ip_forward'] = utils.parse_conf_cmd_arg(conf, 'ip forward', True)
-
-        interfaces_cfg = utils.remove_empties(config)
-        return interfaces_cfg
diff --git a/lib/ansible/module_utils/network/nxos/facts/l2_interfaces/l2_interfaces.py b/lib/ansible/module_utils/network/nxos/facts/l2_interfaces/l2_interfaces.py
deleted file mode 100644
index 2063dd495e..0000000000
--- a/lib/ansible/module_utils/network/nxos/facts/l2_interfaces/l2_interfaces.py
+++ /dev/null
@@ -1,94 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)#!/usr/bin/python
-"""
-The nxos l2_interfaces fact class
-It is in this file the configuration is collected from the device
-for a given resource, parsed, and the facts tree is populated
-based on the configuration.
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-import re
-from copy import deepcopy
-
-from ansible.module_utils.network.common import utils
-from ansible.module_utils.network.nxos.argspec.l2_interfaces.l2_interfaces import L2_interfacesArgs
-from ansible.module_utils.network.nxos.utils.utils import get_interface_type
-
-
-class L2_interfacesFacts(object):
-    """The nxos l2_interfaces fact class
-    """
-
-    def __init__(self, module, subspec='config', options='options'):
-        self._module = module
-        self.argument_spec = L2_interfacesArgs.argument_spec
-        spec = deepcopy(self.argument_spec)
-        if subspec:
-            if options:
-                facts_argument_spec = spec[subspec][options]
-            else:
-                facts_argument_spec = spec[subspec]
-        else:
-            facts_argument_spec = spec
-
-        self.generated_spec = utils.generate_dict(facts_argument_spec)
-
-    def populate_facts(self, connection, ansible_facts, data=None):
-        """ Populate the facts for l2_interfaces
-        :param connection: the device connection
-        :param data: previously collected conf
-        :rtype: dictionary
-        :returns: facts
-        """
-        objs = []
-        if not data:
-            data = connection.get('show running-config | section ^interface')
-
-        config = data.split('interface ')
-        for conf in config:
-            conf = conf.strip()
-            if conf:
-                obj = self.render_config(self.generated_spec, conf)
-                if obj and len(obj.keys()) > 1:
-                    objs.append(obj)
-
-        ansible_facts['ansible_network_resources'].pop('l2_interfaces', None)
-        facts = {}
-        if objs:
-            facts['l2_interfaces'] = []
-            params = utils.validate_config(self.argument_spec, {'config': objs})
-            for cfg in params['config']:
-                facts['l2_interfaces'].append(utils.remove_empties(cfg))
-
-        ansible_facts['ansible_network_resources'].update(facts)
-        return ansible_facts
-
-    def render_config(self, spec, conf):
-        """
-        Render config as dictionary structure and delete keys
-          from spec for null values
-        :param spec: The facts tree, generated from the argspec
-        :param conf: The configuration
-        :rtype: dictionary
-        :returns: The generated config
-        """
-        config = deepcopy(spec)
-
-        match = re.search(r'^(\S+)', conf)
-        intf = match.group(1)
-        if get_interface_type(intf) == 'unknown':
-            return {}
-
-        config['name'] = intf
-        config['mode'] = utils.parse_conf_arg(conf, 'switchport mode')
-        config['ip_forward'] = utils.parse_conf_arg(conf, 'ip forward')
-        config['access']['vlan'] = utils.parse_conf_arg(conf, 'switchport access vlan')
-        config['trunk']['allowed_vlans'] = utils.parse_conf_arg(conf, 'switchport trunk allowed vlan')
-        config['trunk']['native_vlan'] = utils.parse_conf_arg(conf, 'switchport trunk native vlan')
-
-        return utils.remove_empties(config)
diff --git a/lib/ansible/module_utils/network/nxos/facts/l3_interfaces/l3_interfaces.py b/lib/ansible/module_utils/network/nxos/facts/l3_interfaces/l3_interfaces.py
deleted file mode 100644
index c5be39a4dc..0000000000
--- a/lib/ansible/module_utils/network/nxos/facts/l3_interfaces/l3_interfaces.py
+++ /dev/null
@@ -1,126 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)#!/usr/bin/python
-"""
-The nxos l3_interfaces fact class
-It is in this file the configuration is collected from the device
-for a given resource, parsed, and the facts tree is populated
-based on the configuration.
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-import re
-from copy import deepcopy
-
-from ansible.module_utils.network.common import utils
-from ansible.module_utils.network.nxos.argspec.l3_interfaces.l3_interfaces import L3_interfacesArgs
-from ansible.module_utils.network.nxos.utils.utils import get_interface_type
-
-
-class L3_interfacesFacts(object):
-    """ The nxos l3_interfaces fact class
-    """
-
-    def __init__(self, module, subspec='config', options='options'):
-        self._module = module
-        self.argument_spec = L3_interfacesArgs.argument_spec
-        spec = deepcopy(self.argument_spec)
-        if subspec:
-            if options:
-                facts_argument_spec = spec[subspec][options]
-            else:
-                facts_argument_spec = spec[subspec]
-        else:
-            facts_argument_spec = spec
-
-        self.generated_spec = utils.generate_dict(facts_argument_spec)
-
-    def populate_facts(self, connection, ansible_facts, data=None):
-        """ Populate the facts for l3_interfaces
-        :param connection: the device connection
-        :param data: previously collected conf
-        :rtype: dictionary
-        :returns: facts
-        """
-        objs = []
-        if not data:
-            data = connection.get('show running-config | section ^interface')
-
-        config = data.split('interface ')
-        for conf in config:
-            conf = conf.strip()
-            if conf:
-                obj = self.render_config(self.generated_spec, conf)
-                if obj and len(obj.keys()) > 1:
-                    objs.append(obj)
-
-        ansible_facts['ansible_network_resources'].pop('l3_interfaces', None)
-        facts = {}
-        if objs:
-            facts['l3_interfaces'] = []
-            params = utils.validate_config(self.argument_spec, {'config': objs})
-            for cfg in params['config']:
-                facts['l3_interfaces'].append(utils.remove_empties(cfg))
-
-        ansible_facts['ansible_network_resources'].update(facts)
-        return ansible_facts
-
-    def render_config(self, spec, conf):
-        """
-        Render config as dictionary structure and delete keys
-          from spec for null values
-        :param spec: The facts tree, generated from the argspec
-        :param conf: The configuration
-        :rtype: dictionary
-        :returns: The generated config
-        """
-        config = deepcopy(spec)
-        match = re.search(r'^(\S+)', conf)
-        intf = match.group(1)
-        if get_interface_type(intf) == 'unknown':
-            return {}
-        config['name'] = intf
-        config['dot1q'] = utils.parse_conf_arg(conf, 'encapsulation dot1[qQ]')
-        config['redirects'] = utils.parse_conf_cmd_arg(conf, 'no ip redirects', False, True)
-        config['unreachables'] = utils.parse_conf_cmd_arg(conf, 'ip unreachables', True, False)
-        ipv4_match = re.compile(r'\n  ip address (.*)')
-        matches = ipv4_match.findall(conf)
-        if matches:
-            if matches[0]:
-                config['ipv4'] = []
-                for m in matches:
-                    ipv4_conf = m.split()
-                    addr = ipv4_conf[0]
-                    if addr:
-                        config_dict = {'address': addr}
-                        if len(ipv4_conf) > 1:
-                            d = ipv4_conf[1]
-                            if d == 'secondary':
-                                config_dict.update({'secondary': True})
-                                if len(ipv4_conf) == 4:
-                                    if ipv4_conf[2] == 'tag':
-                                        config_dict.update({'tag': int(ipv4_conf[-1])})
-                            elif d == 'tag':
-                                config_dict.update({'tag': int(ipv4_conf[-1])})
-                        config['ipv4'].append(config_dict)
-
-        ipv6_match = re.compile(r'\n  ipv6 address (.*)')
-        matches = ipv6_match.findall(conf)
-        if matches:
-            if matches[0]:
-                config['ipv6'] = []
-                for m in matches:
-                    ipv6_conf = m.split()
-                    addr = ipv6_conf[0]
-                    if addr:
-                        config_dict = {'address': addr}
-                        if len(ipv6_conf) > 1:
-                            d = ipv6_conf[1]
-                            if d == 'tag':
-                                config_dict.update({'tag': int(ipv6_conf[-1])})
-                        config['ipv6'].append(config_dict)
-
-        return utils.remove_empties(config)
diff --git a/lib/ansible/module_utils/network/nxos/facts/lacp/lacp.py b/lib/ansible/module_utils/network/nxos/facts/lacp/lacp.py
deleted file mode 100644
index 90524503db..0000000000
--- a/lib/ansible/module_utils/network/nxos/facts/lacp/lacp.py
+++ /dev/null
@@ -1,84 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos lacp fact class
-It is in this file the configuration is collected from the device
-for a given resource, parsed, and the facts tree is populated
-based on the configuration.
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-import re
-from copy import deepcopy
-
-from ansible.module_utils.network.common import utils
-from ansible.module_utils.network.nxos.argspec.lacp.lacp import LacpArgs
-
-
-class LacpFacts(object):
-    """ The nxos lacp fact class
-    """
-
-    def __init__(self, module, subspec='config', options='options'):
-        self._module = module
-        self.argument_spec = LacpArgs.argument_spec
-        spec = deepcopy(self.argument_spec)
-        if subspec:
-            if options:
-                facts_argument_spec = spec[subspec][options]
-            else:
-                facts_argument_spec = spec[subspec]
-        else:
-            facts_argument_spec = spec
-
-        self.generated_spec = utils.generate_dict(facts_argument_spec)
-
-    def populate_facts(self, connection, ansible_facts, data=None):
-        """ Populate the facts for lacp
-        :param connection: the device connection
-        :param ansible_facts: Facts dictionary
-        :param data: previously collected conf
-        :rtype: dictionary
-        :returns: facts
-        """
-        if not data:
-            data = connection.get("show running-config | include lacp")
-        resources = data.strip()
-        objs = self.render_config(self.generated_spec, resources)
-        ansible_facts['ansible_network_resources'].pop('lacp', None)
-        facts = {}
-        if objs:
-            params = utils.validate_config(self.argument_spec, {'config': objs})
-            facts['lacp'] = utils.remove_empties(params['config'])
-        ansible_facts['ansible_network_resources'].update(facts)
-        return ansible_facts
-
-    def render_config(self, spec, conf):
-        """
-        Render config as dictionary structure and delete keys
-          from spec for null values
-
-        :param spec: The facts tree, generated from the argspec
-        :param conf: The configuration
-        :rtype: dictionary
-        :returns: The generated config
-        """
-        config = deepcopy(spec)
-
-        p_match = re.search(r'lacp system-priority (\d+)', conf, re.M)
-        if p_match:
-            config['system']['priority'] = p_match.group(1)
-
-        a_match = re.search(r'lacp system-mac (\S+)', conf, re.M)
-        if a_match:
-            address = a_match.group(1)
-            config['system']['mac']['address'] = address
-            r_match = re.search(r'lacp system-mac {0} role (\S+)'.format(address), conf, re.M)
-            if r_match:
-                config['system']['mac']['role'] = r_match.group(1)
-
-        return utils.remove_empties(config)
diff --git a/lib/ansible/module_utils/network/nxos/facts/lacp_interfaces/lacp_interfaces.py b/lib/ansible/module_utils/network/nxos/facts/lacp_interfaces/lacp_interfaces.py
deleted file mode 100644
index 000e1de72b..0000000000
--- a/lib/ansible/module_utils/network/nxos/facts/lacp_interfaces/lacp_interfaces.py
+++ /dev/null
@@ -1,108 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos lacp_interfaces fact class
-It is in this file the configuration is collected from the device
-for a given resource, parsed, and the facts tree is populated
-based on the configuration.
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-import re
-from copy import deepcopy
-
-from ansible.module_utils.network.common import utils
-from ansible.module_utils.network.nxos.argspec.lacp_interfaces.lacp_interfaces import Lacp_interfacesArgs
-from ansible.module_utils.network.nxos.utils.utils import get_interface_type
-
-
-class Lacp_interfacesFacts(object):
-    """ The nxos lacp_interfaces fact class
-    """
-
-    def __init__(self, module, subspec='config', options='options'):
-        self._module = module
-        self.argument_spec = Lacp_interfacesArgs.argument_spec
-        spec = deepcopy(self.argument_spec)
-        if subspec:
-            if options:
-                facts_argument_spec = spec[subspec][options]
-            else:
-                facts_argument_spec = spec[subspec]
-        else:
-            facts_argument_spec = spec
-
-        self.generated_spec = utils.generate_dict(facts_argument_spec)
-
-    def populate_facts(self, connection, ansible_facts, data=None):
-        """ Populate the facts for lacp_interfaces
-        :param connection: the device connection
-        :param ansible_facts: Facts dictionary
-        :param data: previously collected conf
-        :rtype: dictionary
-        :returns: facts
-        """
-        objs = []
-
-        if not data:
-            data = connection.get('show running-config | section ^interface')
-
-        resources = data.split('interface ')
-        for resource in resources:
-            if resource and re.search(r'lacp', resource):
-                obj = self.render_config(self.generated_spec, resource)
-                if obj and len(obj.keys()) > 1:
-                    objs.append(obj)
-
-        ansible_facts['ansible_network_resources'].pop('lacp_interfaces', None)
-        facts = {}
-        if objs:
-            facts['lacp_interfaces'] = []
-            params = utils.validate_config(self.argument_spec, {'config': objs})
-            for cfg in params['config']:
-                facts['lacp_interfaces'].append(utils.remove_empties(cfg))
-
-        ansible_facts['ansible_network_resources'].update(facts)
-        return ansible_facts
-
-    def render_config(self, spec, conf):
-        """
-        Render config as dictionary structure and delete keys
-          from spec for null values
-
-        :param spec: The facts tree, generated from the argspec
-        :param conf: The configuration
-        :rtype: dictionary
-        :returns: The generated config
-        """
-        config = deepcopy(spec)
-
-        match = re.search(r'^(\S+)', conf)
-        intf = match.group(1)
-        if get_interface_type(intf) == 'unknown':
-            return {}
-        config['name'] = intf
-        config['port_priority'] = utils.parse_conf_arg(conf, 'lacp port-priority')
-        config['rate'] = utils.parse_conf_arg(conf, 'lacp rate')
-        config['mode'] = utils.parse_conf_arg(conf, 'mode')
-        suspend_individual = re.search(r'no lacp suspend-individual', conf)
-        if suspend_individual:
-            config['suspend_individual'] = False
-        max_links = utils.parse_conf_arg(conf, 'lacp max-bundle')
-        if max_links:
-            config['links']['max'] = max_links
-        min_links = utils.parse_conf_arg(conf, 'lacp min-links')
-        if min_links:
-            config['links']['min'] = min_links
-        graceful = re.search(r'no lacp graceful-convergence', conf)
-        if graceful:
-            config['convergence']['gracefule'] = False
-        vpc = re.search(r'lacp vpc-convergence', conf)
-        if vpc:
-            config['convergence']['vpc'] = True
-
-        return utils.remove_empties(config)
diff --git a/lib/ansible/module_utils/network/nxos/facts/lag_interfaces/lag_interfaces.py b/lib/ansible/module_utils/network/nxos/facts/lag_interfaces/lag_interfaces.py
deleted file mode 100644
index 983212409d..0000000000
--- a/lib/ansible/module_utils/network/nxos/facts/lag_interfaces/lag_interfaces.py
+++ /dev/null
@@ -1,124 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)#!/usr/bin/python
-"""
-The nxos lag_interfaces fact class
-It is in this file the configuration is collected from the device
-for a given resource, parsed, and the facts tree is populated
-based on the configuration.
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-import re
-from copy import deepcopy
-
-from ansible.module_utils.network.common import utils
-from ansible.module_utils.network.nxos.argspec.lag_interfaces.lag_interfaces import Lag_interfacesArgs
-from ansible.module_utils.network.nxos.utils.utils import get_interface_type, normalize_interface
-
-
-class Lag_interfacesFacts(object):
-    """ The nxos lag_interfaces fact class
-    """
-
-    def __init__(self, module, subspec='config', options='options'):
-        self._module = module
-        self.argument_spec = Lag_interfacesArgs.argument_spec
-        spec = deepcopy(self.argument_spec)
-        if subspec:
-            if options:
-                facts_argument_spec = spec[subspec][options]
-            else:
-                facts_argument_spec = spec[subspec]
-        else:
-            facts_argument_spec = spec
-
-        self.generated_spec = utils.generate_dict(facts_argument_spec)
-
-    def populate_facts(self, connection, ansible_facts, data=None):
-        """ Populate the facts for lag_interfaces
-        :param connection: the device connection
-        :param data: previously collected conf
-        :rtype: dictionary
-        :returns: facts
-        """
-        objs = []
-        if not data:
-            data = connection.get('show running-config | include channel-group')
-        config = re.split('(\n  |)channel-group ', data)
-        config = list(dict.fromkeys(config))
-        for conf in config:
-            if conf:
-                obj = self.render_config(self.generated_spec, conf, connection)
-                if obj and len(obj.keys()) > 1:
-                    objs.append(obj)
-
-        ansible_facts['ansible_network_resources'].pop('lag_interfaces', None)
-        facts = {}
-        if objs:
-            facts['lag_interfaces'] = []
-            params = utils.validate_config(self.argument_spec, {'config': objs})
-            for cfg in params['config']:
-                facts['lag_interfaces'].append(utils.remove_empties(cfg))
-
-        ansible_facts['ansible_network_resources'].update(facts)
-        return ansible_facts
-
-    def get_members(self, id, connection):
-        """
-        Returns members associated with a channel-group
-
-        :param name: The channel group
-        :rtype: list
-        :returns: Members
-        """
-        members = []
-        data = connection.get('show port-channel summary')
-        match = re.search(r'{0} (.+)(|\n)'.format(id), data)
-        if match:
-            interfaces = re.search(r'Eth\d(.+)$', match.group())
-            if interfaces:
-                for i in interfaces.group().split():
-                    if get_interface_type(i[:-3]) != 'unknown':
-                        members.append(normalize_interface(i[:-3]))
-
-        return members
-
-    def render_config(self, spec, conf, connection):
-        """
-        Render config as dictionary structure and delete keys
-          from spec for null values
-
-        :param spec: The facts tree, generated from the argspec
-        :param conf: The configuration
-        :rtype: dictionary
-        :returns: The generated config
-        """
-        config = deepcopy(spec)
-        match = re.search(r'(\d+)( |)(force )?(mode \S+)?', conf, re.M)
-        if match:
-            matches = match.groups()
-            config['name'] = 'port-channel' + str(matches[0])
-            config['members'] = []
-            members = self.get_members(config['name'].strip('port-channel'), connection)
-            if members:
-                for m in members:
-                    m_dict = {}
-                    if matches[2]:
-                        m_dict['force'] = matches[2]
-                    if matches[3]:
-                        m_dict['mode'] = matches[3][5:]
-                    m_dict['member'] = m
-                    config['members'].append(m_dict)
-        else:
-            config = {}
-
-        lag_intf_cfg = utils.remove_empties(config)
-        # if lag interfaces config is not present return empty dict
-        if len(lag_intf_cfg) == 1:
-            return {}
-        else:
-            return lag_intf_cfg
diff --git a/lib/ansible/module_utils/network/nxos/facts/legacy/base.py b/lib/ansible/module_utils/network/nxos/facts/legacy/base.py
deleted file mode 100644
index 28be70b6b6..0000000000
--- a/lib/ansible/module_utils/network/nxos/facts/legacy/base.py
+++ /dev/null
@@ -1,756 +0,0 @@
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-import platform
-import re
-
-from ansible.module_utils.network.nxos.nxos import run_commands, get_config, get_capabilities
-from ansible.module_utils.network.nxos.utils.utils import get_interface_type, normalize_interface
-from ansible.module_utils.six import iteritems
-
-
-g_config = None
-
-
-class FactsBase(object):
-
-    def __init__(self, module):
-        self.module = module
-        self.warnings = list()
-        self.facts = dict()
-        self.capabilities = get_capabilities(self.module)
-
-    def populate(self):
-        pass
-
-    def run(self, command, output='text'):
-        command_string = command
-        command = {
-            'command': command,
-            'output': output
-        }
-        resp = run_commands(self.module, [command], check_rc='retry_json')
-        try:
-            return resp[0]
-        except IndexError:
-            self.warnings.append('command %s failed, facts for this command will not be populated' % command_string)
-            return None
-
-    def get_config(self):
-        global g_config
-        if not g_config:
-            g_config = get_config(self.module)
-        return g_config
-
-    def transform_dict(self, data, keymap):
-        transform = dict()
-        for key, fact in keymap:
-            if key in data:
-                transform[fact] = data[key]
-        return transform
-
-    def transform_iterable(self, iterable, keymap):
-        for item in iterable:
-            yield self.transform_dict(item, keymap)
-
-
-class Default(FactsBase):
-
-    def populate(self):
-        data = None
-        data = self.run('show version')
-
-        if data:
-            self.facts['serialnum'] = self.parse_serialnum(data)
-
-        data = self.run('show license host-id')
-        if data:
-            self.facts['license_hostid'] = self.parse_license_hostid(data)
-
-        self.facts.update(self.platform_facts())
-
-    def parse_serialnum(self, data):
-        match = re.search(r'Processor Board ID\s*(\S+)', data, re.M)
-        if match:
-            return match.group(1)
-
-    def platform_facts(self):
-        platform_facts = {}
-
-        resp = self.capabilities
-        device_info = resp['device_info']
-
-        platform_facts['system'] = device_info['network_os']
-
-        for item in ('model', 'image', 'version', 'platform', 'hostname'):
-            val = device_info.get('network_os_%s' % item)
-            if val:
-                platform_facts[item] = val
-
-        platform_facts['api'] = resp['network_api']
-        platform_facts['python_version'] = platform.python_version()
-
-        return platform_facts
-
-    def parse_license_hostid(self, data):
-        match = re.search(r'License hostid: VDH=(.+)$', data, re.M)
-        if match:
-            return match.group(1)
-
-
-class Config(FactsBase):
-
-    def populate(self):
-        super(Config, self).populate()
-        self.facts['config'] = self.get_config()
-
-
-class Features(FactsBase):
-
-    def populate(self):
-        super(Features, self).populate()
-        data = self.get_config()
-
-        if data:
-            features = []
-            for line in data.splitlines():
-                if line.startswith('feature'):
-                    features.append(line.replace('feature', '').strip())
-
-            self.facts['features_enabled'] = features
-
-
-class Hardware(FactsBase):
-
-    def populate(self):
-        data = self.run('dir')
-        if data:
-            self.facts['filesystems'] = self.parse_filesystems(data)
-
-        data = None
-        data = self.run('show system resources', output='json')
-
-        if data:
-            if isinstance(data, dict):
-                self.facts['memtotal_mb'] = int(data['memory_usage_total']) / 1024
-                self.facts['memfree_mb'] = int(data['memory_usage_free']) / 1024
-            else:
-                self.facts['memtotal_mb'] = self.parse_memtotal_mb(data)
-                self.facts['memfree_mb'] = self.parse_memfree_mb(data)
-
-    def parse_filesystems(self, data):
-        return re.findall(r'^Usage for (\S+)//', data, re.M)
-
-    def parse_memtotal_mb(self, data):
-        match = re.search(r'(\S+)K(\s+|)total', data, re.M)
-        if match:
-            memtotal = match.group(1)
-            return int(memtotal) / 1024
-
-    def parse_memfree_mb(self, data):
-        match = re.search(r'(\S+)K(\s+|)free', data, re.M)
-        if match:
-            memfree = match.group(1)
-            return int(memfree) / 1024
-
-
-class Interfaces(FactsBase):
-
-    INTERFACE_MAP = frozenset([
-        ('state', 'state'),
-        ('desc', 'description'),
-        ('eth_bw', 'bandwidth'),
-        ('eth_duplex', 'duplex'),
-        ('eth_speed', 'speed'),
-        ('eth_mode', 'mode'),
-        ('eth_hw_addr', 'macaddress'),
-        ('eth_mtu', 'mtu'),
-        ('eth_hw_desc', 'type')
-    ])
-
-    INTERFACE_SVI_MAP = frozenset([
-        ('svi_line_proto', 'state'),
-        ('svi_bw', 'bandwidth'),
-        ('svi_mac', 'macaddress'),
-        ('svi_mtu', 'mtu'),
-        ('type', 'type')
-    ])
-
-    INTERFACE_IPV4_MAP = frozenset([
-        ('eth_ip_addr', 'address'),
-        ('eth_ip_mask', 'masklen')
-    ])
-
-    INTERFACE_SVI_IPV4_MAP = frozenset([
-        ('svi_ip_addr', 'address'),
-        ('svi_ip_mask', 'masklen')
-    ])
-
-    INTERFACE_IPV6_MAP = frozenset([
-        ('addr', 'address'),
-        ('prefix', 'subnet')
-    ])
-
-    def ipv6_structure_op_supported(self):
-        data = self.capabilities
-        if data:
-            nxos_os_version = data['device_info']['network_os_version']
-            unsupported_versions = ['I2', 'F1', 'A8']
-            for ver in unsupported_versions:
-                if ver in nxos_os_version:
-                    return False
-            return True
-
-    def populate(self):
-        self.facts['all_ipv4_addresses'] = list()
-        self.facts['all_ipv6_addresses'] = list()
-        self.facts['neighbors'] = {}
-        data = None
-
-        data = self.run('show interface', output='json')
-
-        if data:
-            if isinstance(data, dict):
-                self.facts['interfaces'] = self.populate_structured_interfaces(data)
-            else:
-                interfaces = self.parse_interfaces(data)
-                self.facts['interfaces'] = self.populate_interfaces(interfaces)
-
-        if self.ipv6_structure_op_supported():
-            data = self.run('show ipv6 interface', output='json')
-        else:
-            data = None
-        if data:
-            if isinstance(data, dict):
-                self.populate_structured_ipv6_interfaces(data)
-            else:
-                interfaces = self.parse_interfaces(data)
-                self.populate_ipv6_interfaces(interfaces)
-
-        data = self.run('show lldp neighbors', output='json')
-        if data:
-            if isinstance(data, dict):
-                self.facts['neighbors'].update(self.populate_structured_neighbors_lldp(data))
-            else:
-                self.facts['neighbors'].update(self.populate_neighbors(data))
-
-        data = self.run('show cdp neighbors detail', output='json')
-        if data:
-            if isinstance(data, dict):
-                self.facts['neighbors'].update(self.populate_structured_neighbors_cdp(data))
-            else:
-                self.facts['neighbors'].update(self.populate_neighbors_cdp(data))
-
-        self.facts['neighbors'].pop(None, None)  # Remove null key
-
-    def populate_structured_interfaces(self, data):
-        interfaces = dict()
-        for item in data['TABLE_interface']['ROW_interface']:
-            name = item['interface']
-
-            intf = dict()
-            if 'type' in item:
-                intf.update(self.transform_dict(item, self.INTERFACE_SVI_MAP))
-            else:
-                intf.update(self.transform_dict(item, self.INTERFACE_MAP))
-
-            if 'eth_ip_addr' in item:
-                intf['ipv4'] = self.transform_dict(item, self.INTERFACE_IPV4_MAP)
-                self.facts['all_ipv4_addresses'].append(item['eth_ip_addr'])
-
-            if 'svi_ip_addr' in item:
-                intf['ipv4'] = self.transform_dict(item, self.INTERFACE_SVI_IPV4_MAP)
-                self.facts['all_ipv4_addresses'].append(item['svi_ip_addr'])
-
-            interfaces[name] = intf
-
-        return interfaces
-
-    def populate_structured_ipv6_interfaces(self, data):
-        try:
-            data = data['TABLE_intf']
-            if data:
-                if isinstance(data, dict):
-                    data = [data]
-                for item in data:
-                    name = item['ROW_intf']['intf-name']
-                    intf = self.facts['interfaces'][name]
-                    intf['ipv6'] = self.transform_dict(item, self.INTERFACE_IPV6_MAP)
-                    try:
-                        addr = item['ROW_intf']['addr']
-                    except KeyError:
-                        addr = item['ROW_intf']['TABLE_addr']['ROW_addr']['addr']
-                    self.facts['all_ipv6_addresses'].append(addr)
-            else:
-                return ""
-        except TypeError:
-            return ""
-
-    def populate_structured_neighbors_lldp(self, data):
-        objects = dict()
-        data = data['TABLE_nbor']['ROW_nbor']
-
-        if isinstance(data, dict):
-            data = [data]
-
-        for item in data:
-            local_intf = normalize_interface(item['l_port_id'])
-            objects[local_intf] = list()
-            nbor = dict()
-            nbor['port'] = item['port_id']
-            nbor['host'] = nbor['sysname'] = item['chassis_id']
-            objects[local_intf].append(nbor)
-
-        return objects
-
-    def populate_structured_neighbors_cdp(self, data):
-        objects = dict()
-        data = data['TABLE_cdp_neighbor_detail_info']['ROW_cdp_neighbor_detail_info']
-
-        if isinstance(data, dict):
-            data = [data]
-
-        for item in data:
-            local_intf = item['intf_id']
-            objects[local_intf] = list()
-            nbor = dict()
-            nbor['port'] = item['port_id']
-            nbor['host'] = nbor['sysname'] = item['device_id']
-            objects[local_intf].append(nbor)
-
-        return objects
-
-    def parse_interfaces(self, data):
-        parsed = dict()
-        key = ''
-        for line in data.split('\n'):
-            if len(line) == 0:
-                continue
-            elif line.startswith('admin') or line[0] == ' ':
-                parsed[key] += '\n%s' % line
-            else:
-                match = re.match(r'^(\S+)', line)
-                if match:
-                    key = match.group(1)
-                    if not key.startswith('admin') or not key.startswith('IPv6 Interface'):
-                        parsed[key] = line
-        return parsed
-
-    def populate_interfaces(self, interfaces):
-        facts = dict()
-        for key, value in iteritems(interfaces):
-            intf = dict()
-            if get_interface_type(key) == 'svi':
-                intf['state'] = self.parse_state(key, value, intf_type='svi')
-                intf['macaddress'] = self.parse_macaddress(value, intf_type='svi')
-                intf['mtu'] = self.parse_mtu(value, intf_type='svi')
-                intf['bandwidth'] = self.parse_bandwidth(value, intf_type='svi')
-                intf['type'] = self.parse_type(value, intf_type='svi')
-                if 'Internet Address' in value:
-                    intf['ipv4'] = self.parse_ipv4_address(value, intf_type='svi')
-                facts[key] = intf
-            else:
-                intf['state'] = self.parse_state(key, value)
-                intf['description'] = self.parse_description(value)
-                intf['macaddress'] = self.parse_macaddress(value)
-                intf['mode'] = self.parse_mode(value)
-                intf['mtu'] = self.parse_mtu(value)
-                intf['bandwidth'] = self.parse_bandwidth(value)
-                intf['duplex'] = self.parse_duplex(value)
-                intf['speed'] = self.parse_speed(value)
-                intf['type'] = self.parse_type(value)
-                if 'Internet Address' in value:
-                    intf['ipv4'] = self.parse_ipv4_address(value)
-                facts[key] = intf
-
-        return facts
-
-    def parse_state(self, key, value, intf_type='ethernet'):
-        match = None
-        if intf_type == 'svi':
-            match = re.search(r'line protocol is\s*(\S+)', value, re.M)
-        else:
-            match = re.search(r'%s is\s*(\S+)' % key, value, re.M)
-
-        if match:
-            return match.group(1)
-
-    def parse_macaddress(self, value, intf_type='ethernet'):
-        match = None
-        if intf_type == 'svi':
-            match = re.search(r'address is\s*(\S+)', value, re.M)
-        else:
-            match = re.search(r'address:\s*(\S+)', value, re.M)
-
-        if match:
-            return match.group(1)
-
-    def parse_mtu(self, value, intf_type='ethernet'):
-        match = re.search(r'MTU\s*(\S+)', value, re.M)
-        if match:
-            return match.group(1)
-
-    def parse_bandwidth(self, value, intf_type='ethernet'):
-        match = re.search(r'BW\s*(\S+)', value, re.M)
-        if match:
-            return match.group(1)
-
-    def parse_type(self, value, intf_type='ethernet'):
-        match = None
-        if intf_type == 'svi':
-            match = re.search(r'Hardware is\s*(\S+)', value, re.M)
-        else:
-            match = re.search(r'Hardware:\s*(.+),', value, re.M)
-
-        if match:
-            return match.group(1)
-
-    def parse_description(self, value, intf_type='ethernet'):
-        match = re.search(r'Description: (.+)$', value, re.M)
-        if match:
-            return match.group(1)
-
-    def parse_mode(self, value, intf_type='ethernet'):
-        match = re.search(r'Port mode is (\S+)', value, re.M)
-        if match:
-            return match.group(1)
-
-    def parse_duplex(self, value, intf_type='ethernet'):
-        match = re.search(r'(\S+)-duplex', value, re.M)
-        if match:
-            return match.group(1)
-
-    def parse_speed(self, value, intf_type='ethernet'):
-        match = re.search(r'duplex, (.+)$', value, re.M)
-        if match:
-            return match.group(1)
-
-    def parse_ipv4_address(self, value, intf_type='ethernet'):
-        ipv4 = {}
-        match = re.search(r'Internet Address is (.+)$', value, re.M)
-        if match:
-            address = match.group(1)
-            addr = address.split('/')[0]
-            ipv4['address'] = address.split('/')[0]
-            ipv4['masklen'] = address.split('/')[1]
-            self.facts['all_ipv4_addresses'].append(addr)
-        return ipv4
-
-    def populate_neighbors(self, data):
-        objects = dict()
-        # if there are no neighbors the show command returns
-        # ERROR: No neighbour information
-        if data.startswith('ERROR'):
-            return dict()
-
-        regex = re.compile(r'(\S+)\s+(\S+)\s+\d+\s+\w+\s+(\S+)')
-
-        for item in data.split('\n')[4:-1]:
-            match = regex.match(item)
-            if match:
-                nbor = dict()
-                nbor['host'] = nbor['sysname'] = match.group(1)
-                nbor['port'] = match.group(3)
-                local_intf = normalize_interface(match.group(2))
-                if local_intf not in objects:
-                    objects[local_intf] = []
-                objects[local_intf].append(nbor)
-
-        return objects
-
-    def populate_neighbors_cdp(self, data):
-        facts = dict()
-
-        for item in data.split('----------------------------------------'):
-            if item == '':
-                continue
-            local_intf = self.parse_lldp_intf(item)
-            if local_intf not in facts:
-                facts[local_intf] = list()
-
-            fact = dict()
-            fact['port'] = self.parse_lldp_port(item)
-            fact['sysname'] = self.parse_lldp_sysname(item)
-            facts[local_intf].append(fact)
-
-        return facts
-
-    def parse_lldp_intf(self, data):
-        match = re.search(r'Interface:\s*(\S+)', data, re.M)
-        if match:
-            return match.group(1).strip(',')
-
-    def parse_lldp_port(self, data):
-        match = re.search(r'Port ID \(outgoing port\):\s*(\S+)', data, re.M)
-        if match:
-            return match.group(1)
-
-    def parse_lldp_sysname(self, data):
-        match = re.search(r'Device ID:(.+)$', data, re.M)
-        if match:
-            return match.group(1)
-
-    def populate_ipv6_interfaces(self, interfaces):
-        facts = dict()
-        for key, value in iteritems(interfaces):
-            intf = dict()
-            intf['ipv6'] = self.parse_ipv6_address(value)
-            facts[key] = intf
-
-    def parse_ipv6_address(self, value):
-        ipv6 = {}
-        match_addr = re.search(r'IPv6 address:\s*(\S+)', value, re.M)
-        if match_addr:
-            addr = match_addr.group(1)
-            ipv6['address'] = addr
-            self.facts['all_ipv6_addresses'].append(addr)
-        match_subnet = re.search(r'IPv6 subnet:\s*(\S+)', value, re.M)
-        if match_subnet:
-            ipv6['subnet'] = match_subnet.group(1)
-
-        return ipv6
-
-
-class Legacy(FactsBase):
-    # facts from nxos_facts 2.1
-
-    VERSION_MAP = frozenset([
-        ('host_name', '_hostname'),
-        ('kickstart_ver_str', '_os'),
-        ('chassis_id', '_platform')
-    ])
-
-    MODULE_MAP = frozenset([
-        ('model', 'model'),
-        ('modtype', 'type'),
-        ('ports', 'ports'),
-        ('status', 'status')
-    ])
-
-    FAN_MAP = frozenset([
-        ('fanname', 'name'),
-        ('fanmodel', 'model'),
-        ('fanhwver', 'hw_ver'),
-        ('fandir', 'direction'),
-        ('fanstatus', 'status')
-    ])
-
-    POWERSUP_MAP = frozenset([
-        ('psmodel', 'model'),
-        ('psnum', 'number'),
-        ('ps_status', 'status'),
-        ('ps_status_3k', 'status'),
-        ('actual_out', 'actual_output'),
-        ('actual_in', 'actual_in'),
-        ('total_capa', 'total_capacity'),
-        ('input_type', 'input_type'),
-        ('watts', 'watts'),
-        ('amps', 'amps')
-    ])
-
-    def populate(self):
-        data = None
-
-        data = self.run('show version', output='json')
-        if data:
-            if isinstance(data, dict):
-                self.facts.update(self.transform_dict(data, self.VERSION_MAP))
-            else:
-                self.facts['hostname'] = self.parse_hostname(data)
-                self.facts['os'] = self.parse_os(data)
-                self.facts['platform'] = self.parse_platform(data)
-
-        data = self.run('show interface', output='json')
-        if data:
-            if isinstance(data, dict):
-                self.facts['interfaces_list'] = self.parse_structured_interfaces(data)
-            else:
-                self.facts['interfaces_list'] = self.parse_interfaces(data)
-
-        data = self.run('show vlan brief', output='json')
-        if data:
-            if isinstance(data, dict):
-                self.facts['vlan_list'] = self.parse_structured_vlans(data)
-            else:
-                self.facts['vlan_list'] = self.parse_vlans(data)
-
-        data = self.run('show module', output='json')
-        if data:
-            if isinstance(data, dict):
-                self.facts['module'] = self.parse_structured_module(data)
-            else:
-                self.facts['module'] = self.parse_module(data)
-
-        data = self.run('show environment fan', output='json')
-        if data:
-            if isinstance(data, dict):
-                self.facts['fan_info'] = self.parse_structured_fan_info(data)
-            else:
-                self.facts['fan_info'] = self.parse_fan_info(data)
-
-        data = self.run('show environment power', output='json')
-        if data:
-            if isinstance(data, dict):
-                self.facts['power_supply_info'] = self.parse_structured_power_supply_info(data)
-            else:
-                self.facts['power_supply_info'] = self.parse_power_supply_info(data)
-
-    def parse_structured_interfaces(self, data):
-        objects = list()
-        for item in data['TABLE_interface']['ROW_interface']:
-            objects.append(item['interface'])
-        return objects
-
-    def parse_structured_vlans(self, data):
-        objects = list()
-        data = data['TABLE_vlanbriefxbrief']['ROW_vlanbriefxbrief']
-        if isinstance(data, dict):
-            objects.append(data['vlanshowbr-vlanid-utf'])
-        elif isinstance(data, list):
-            for item in data:
-                objects.append(item['vlanshowbr-vlanid-utf'])
-        return objects
-
-    def parse_structured_module(self, data):
-        data = data['TABLE_modinfo']['ROW_modinfo']
-        if isinstance(data, dict):
-            data = [data]
-        objects = list(self.transform_iterable(data, self.MODULE_MAP))
-        return objects
-
-    def parse_structured_fan_info(self, data):
-        objects = list()
-
-        for key in ("fandetails", "fandetails_3k"):
-            if data.get(key):
-                try:
-                    data = data[key]['TABLE_faninfo']['ROW_faninfo']
-                except KeyError:
-                    # Some virtual images don't actually report faninfo. In this case, move on and
-                    # just return an empty list.
-                    pass
-                else:
-                    objects = list(self.transform_iterable(data, self.FAN_MAP))
-                break
-
-        return objects
-
-    def parse_structured_power_supply_info(self, data):
-        if data.get('powersup').get('TABLE_psinfo_n3k'):
-            fact = data['powersup']['TABLE_psinfo_n3k']['ROW_psinfo_n3k']
-        else:
-            if isinstance(data['powersup']['TABLE_psinfo'], list):
-                fact = []
-                for i in data['powersup']['TABLE_psinfo']:
-                    fact.append(i['ROW_psinfo'])
-            else:
-                fact = data['powersup']['TABLE_psinfo']['ROW_psinfo']
-
-        objects = list(self.transform_iterable(fact, self.POWERSUP_MAP))
-        return objects
-
-    def parse_hostname(self, data):
-        match = re.search(r'\s+Device name:\s+(\S+)', data, re.M)
-        if match:
-            return match.group(1)
-
-    def parse_os(self, data):
-        match = re.search(r'\s+system:\s+version\s*(\S+)', data, re.M)
-        if match:
-            return match.group(1)
-        else:
-            match = re.search(r'\s+kickstart:\s+version\s*(\S+)', data, re.M)
-            if match:
-                return match.group(1)
-
-    def parse_platform(self, data):
-        match = re.search(r'Hardware\n\s+cisco\s+(\S+\s+\S+)', data, re.M)
-        if match:
-            return match.group(1)
-
-    def parse_interfaces(self, data):
-        objects = list()
-        for line in data.split('\n'):
-            if len(line) == 0:
-                continue
-            elif line.startswith('admin') or line[0] == ' ':
-                continue
-            else:
-                match = re.match(r'^(\S+)', line)
-                if match:
-                    intf = match.group(1)
-                    if get_interface_type(intf) != 'unknown':
-                        objects.append(intf)
-        return objects
-
-    def parse_vlans(self, data):
-        objects = list()
-        for line in data.splitlines():
-            if line == '':
-                continue
-            if line[0].isdigit():
-                vlan = line.split()[0]
-                objects.append(vlan)
-        return objects
-
-    def parse_module(self, data):
-        objects = list()
-        for line in data.splitlines():
-            if line == '':
-                break
-            if line[0].isdigit():
-                obj = {}
-                match_port = re.search(r'\d\s*(\d*)', line, re.M)
-                if match_port:
-                    obj['ports'] = match_port.group(1)
-
-                match = re.search(r'\d\s*\d*\s*(.+)$', line, re.M)
-                if match:
-                    l = match.group(1).split('  ')
-                    items = list()
-                    for item in l:
-                        if item == '':
-                            continue
-                        items.append(item.strip())
-
-                    if items:
-                        obj['type'] = items[0]
-                        obj['model'] = items[1]
-                        obj['status'] = items[2]
-
-                objects.append(obj)
-        return objects
-
-    def parse_fan_info(self, data):
-        objects = list()
-
-        for l in data.splitlines():
-            if '-----------------' in l or 'Status' in l:
-                continue
-            line = l.split()
-            if len(line) > 1:
-                obj = {}
-                obj['name'] = line[0]
-                obj['model'] = line[1]
-                obj['hw_ver'] = line[-2]
-                obj['status'] = line[-1]
-                objects.append(obj)
-        return objects
-
-    def parse_power_supply_info(self, data):
-        objects = list()
-
-        for l in data.splitlines():
-            if l == '':
-                break
-            if l[0].isdigit():
-                obj = {}
-                line = l.split()
-                obj['model'] = line[1]
-                obj['number'] = line[0]
-                obj['status'] = line[-1]
-
-                objects.append(obj)
-        return objects
diff --git a/lib/ansible/module_utils/network/nxos/facts/lldp_global/lldp_global.py b/lib/ansible/module_utils/network/nxos/facts/lldp_global/lldp_global.py
deleted file mode 100644
index c780c2030c..0000000000
--- a/lib/ansible/module_utils/network/nxos/facts/lldp_global/lldp_global.py
+++ /dev/null
@@ -1,105 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos lldp_global fact class
-It is in this file the configuration is collected from the device
-for a given resource, parsed, and the facts tree is populated
-based on the configuration.
-"""
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-import re
-from copy import deepcopy
-
-from ansible.module_utils.network.common import utils
-from ansible.module_utils.network.nxos.argspec.lldp_global.lldp_global import Lldp_globalArgs
-
-
-class Lldp_globalFacts(object):
-    """ The nxos lldp_global fact class
-    """
-
-    def __init__(self, module, subspec='config', options='options'):
-        self._module = module
-        self.argument_spec = Lldp_globalArgs.argument_spec
-        spec = deepcopy(self.argument_spec)
-        if subspec:
-            if options:
-                facts_argument_spec = spec[subspec][options]
-            else:
-                facts_argument_spec = spec[subspec]
-        else:
-            facts_argument_spec = spec
-
-        self.generated_spec = utils.generate_dict(facts_argument_spec)
-
-    def populate_facts(self, connection, ansible_facts, data=None):
-        """ Populate the facts for lldp_global
-        :param connection: the device connection
-        :param ansible_facts: Facts dictionary
-        :param data: previously collected conf
-        :rtype: dictionary
-        :returns: facts
-        """
-
-        if not data:
-            data = connection.get('show running-config | include lldp')
-
-        objs = {}
-        objs = self.render_config(self.generated_spec, data)
-        ansible_facts['ansible_network_resources'].pop('lldp_global', None)
-        facts = {}
-        if objs:
-            params = utils.validate_config(
-                self.argument_spec, {'config': objs})
-            facts['lldp_global'] = params['config']
-            facts = utils.remove_empties(facts)
-        ansible_facts['ansible_network_resources'].update((facts))
-        return ansible_facts
-
-    def render_config(self, spec, conf):
-        """
-        Render config as dictionary structure and delete keys
-          from spec for null values
-
-        :param spec: The facts tree, generated from the argspec
-        :param conf: The configuration
-        :rtype: dictionary
-        :returns: The generated config
-        """
-        config = deepcopy(spec)
-        conf = re.split('\n', conf)
-        for command in conf:
-            param = re.search(
-                r'(.*)lldp (\w+(-?)\w+)',
-                command)  # get the word after 'lldp'
-            if param:
-                # get the nested-dict/value for that param
-                key2 = re.search(r'%s(.*)' % param.group(2), command)
-                key2 = key2.group(1).strip()
-                key1 = param.group(2).replace('-', '_')
-
-                if key1 == 'portid_subtype':
-                    key1 = 'port_id'
-                    config[key1] = key2
-                elif key1 == 'tlv_select':
-                    key2 = key2.split()
-                    key2[0] = key2[0].replace('-', '_')
-                    if len(key2) == 1:
-                        if 'port' in key2[0] or 'system' in key2[0]:  # nested dicts
-                            key2 = key2[0].split('_')
-                            # config[tlv_select][system][name]=False
-                            config[key1][key2[0]][key2[1]] = False
-                        else:
-                            # config[tlv_select][dcbxp]=False
-                            config[key1][key2[0]] = False
-                    else:
-                        # config[tlv_select][management_address][v6]=False
-                        config[key1][key2[0]][key2[1]] = False
-                else:
-                    config[key1] = key2  # config[reinit]=4
-        return utils.remove_empties(config)
diff --git a/lib/ansible/module_utils/network/nxos/facts/lldp_interfaces/lldp_interfaces.py b/lib/ansible/module_utils/network/nxos/facts/lldp_interfaces/lldp_interfaces.py
deleted file mode 100644
index 63ee03e7f6..0000000000
--- a/lib/ansible/module_utils/network/nxos/facts/lldp_interfaces/lldp_interfaces.py
+++ /dev/null
@@ -1,121 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos lldp_interfaces fact class
-It is in this file the configuration is collected from the device
-for a given resource, parsed, and the facts tree is populated
-based on the configuration.
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-import re
-from copy import deepcopy
-
-from ansible.module_utils.network.common import utils
-from ansible.module_utils.network.nxos.argspec.lldp_interfaces.lldp_interfaces import Lldp_interfacesArgs
-from ansible.module_utils.network.nxos.utils.utils import get_interface_type
-
-
-class Lldp_interfacesFacts(object):
-    """ The nxos lldp_interfaces fact class
-    """
-
-    def __init__(self, module, subspec='config', options='options'):
-        self._module = module
-        self.argument_spec = Lldp_interfacesArgs.argument_spec
-        spec = deepcopy(self.argument_spec)
-        if subspec:
-            if options:
-                facts_argument_spec = spec[subspec][options]
-            else:
-                facts_argument_spec = spec[subspec]
-        else:
-            facts_argument_spec = spec
-
-        self.generated_spec = utils.generate_dict(facts_argument_spec)
-
-    def get_device_data(self, connection):
-        return connection.get('show running-config | section ^interface')
-
-    def populate_facts(self, connection, ansible_facts, data=None):
-        """ Populate the facts for lldp_interfaces
-        :param connection: the device connection
-        :param ansible_facts: Facts dictionary
-        :param data: previously collected conf
-        :rtype: dictionary
-        :returns: facts
-        """
-        if not data:
-            data = self.get_device_data(connection)
-
-        objs = []
-
-        data = data.split('interface')
-        resources = []
-
-        for i in range(len(data)):
-            intf = data[i].split('\n')
-            for l in range(1, len(intf)):
-                if not re.search('lldp', intf[l]):
-                    intf[l] = ''
-            intf = list(filter(None, intf))
-            intf = ''.join(i for i in intf)
-            resources.append(intf)
-
-        for resource in resources:
-            if resource:  # and re.search(r'lldp', resource):
-                obj = self.render_config(self.generated_spec, resource)
-                if obj and len(obj.keys()) >= 1:
-                    objs.append(obj)
-
-        ansible_facts['ansible_network_resources'].pop('lldp_interfaces', None)
-        facts = {}
-        if objs:
-            facts['lldp_interfaces'] = []
-            params = utils.validate_config(
-                self.argument_spec, {'config': objs})
-            for cfg in params['config']:
-                facts['lldp_interfaces'].append(utils.remove_empties(cfg))
-
-        ansible_facts['ansible_network_resources'].update(facts)
-
-        return ansible_facts
-
-    def render_config(self, spec, conf):
-        """
-        Render config as dictionary structure and delete keys
-          from spec for null values
-
-        :param spec: The facts tree, generated from the argspec
-        :param conf: The configuration
-        :rtype: dictionary
-        :returns: The generated config
-        """
-        config = deepcopy(spec)
-        match = re.search(r'^ (\S+)', conf)
-        if match is None:
-            return {}
-        intf = match.group(1)
-        if get_interface_type(intf) not in ['management', 'ethernet']:
-            return {}
-        config['name'] = intf
-        if 'lldp receive' in conf:  # for parsed state only
-            config['receive'] = True
-        if 'no lldp receive' in conf:
-            config['receive'] = False
-
-        if 'lldp transmit' in conf:  # for parsed state only
-            config['transmit'] = True
-        if 'no lldp transmit' in conf:
-            config['transmit'] = False
-        if 'management-address' in conf:
-            config['tlv_set']['management_address'] = re.search(
-                r'management-address (\S*)', conf).group(1)
-        if 'vlan' in conf:
-            config['tlv_set']['vlan'] = re.search(
-                r'vlan (\S*)', conf).group(1)
-        return utils.remove_empties(config)
diff --git a/lib/ansible/module_utils/network/nxos/facts/telemetry/telemetry.py b/lib/ansible/module_utils/network/nxos/facts/telemetry/telemetry.py
deleted file mode 100644
index 825d1bc8df..0000000000
--- a/lib/ansible/module_utils/network/nxos/facts/telemetry/telemetry.py
+++ /dev/null
@@ -1,163 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Cisco and/or its affiliates.
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos telemetry fact class
-It is in this file the configuration is collected from the device
-for a given resource, parsed, and the facts tree is populated
-based on the configuration.
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-import re
-from copy import deepcopy
-
-from ansible.module_utils.network.common import utils
-from ansible.module_utils.network.nxos.argspec.telemetry.telemetry import TelemetryArgs
-from ansible.module_utils.network.nxos.cmdref.telemetry.telemetry import TMS_GLOBAL, TMS_DESTGROUP, TMS_SENSORGROUP, TMS_SUBSCRIPTION
-from ansible.module_utils.network.nxos.utils.telemetry.telemetry import get_instance_data, cr_key_lookup
-from ansible.module_utils.network.nxos.utils.telemetry.telemetry import normalize_data
-from ansible.module_utils.network.nxos.nxos import NxosCmdRef
-
-
-class TelemetryFacts(object):
-    """ The nxos telemetry fact class
-    """
-
-    def __init__(self, module, subspec='config', options='options'):
-        self._module = module
-        self.argument_spec = TelemetryArgs.argument_spec
-        spec = deepcopy(self.argument_spec)
-        if subspec:
-            if options:
-                facts_argument_spec = spec[subspec][options]
-            else:
-                facts_argument_spec = spec[subspec]
-        else:
-            facts_argument_spec = spec
-
-        self.generated_spec = utils.generate_dict(facts_argument_spec)
-
-    def populate_facts(self, connection, ansible_facts, data=None):
-        """ Populate the facts for telemetry
-        :param connection: the device connection
-        :param ansible_facts: Facts dictionary
-        :param data: previously collected conf
-        :rtype: dictionary
-        :returns: facts
-        """
-        if connection:  # just for linting purposes, remove
-            pass
-
-        cmd_ref = {}
-        cmd_ref['TMS_GLOBAL'] = {}
-        cmd_ref['TMS_DESTGROUP'] = {}
-        cmd_ref['TMS_SENSORGROUP'] = {}
-        cmd_ref['TMS_SUBSCRIPTION'] = {}
-
-        # For fact gathering, module state should be 'present' when using
-        # NxosCmdRef to query state
-        if self._module.params.get('state'):
-            saved_module_state = self._module.params['state']
-            self._module.params['state'] = 'present'
-
-        # Get Telemetry Global Data
-        cmd_ref['TMS_GLOBAL']['ref'] = []
-        cmd_ref['TMS_GLOBAL']['ref'].append(NxosCmdRef(self._module, TMS_GLOBAL))
-        ref = cmd_ref['TMS_GLOBAL']['ref'][0]
-        ref.set_context()
-        ref.get_existing()
-        device_cache = ref.cache_existing
-
-        if device_cache is None:
-            device_cache_lines = []
-        else:
-            device_cache_lines = device_cache.split("\n")
-
-        # Get Telemetry Destination Group Data
-        cmd_ref['TMS_DESTGROUP']['ref'] = []
-        for line in device_cache_lines:
-            if re.search(r'destination-group', line):
-                resource_key = line.strip()
-                cmd_ref['TMS_DESTGROUP']['ref'].append(NxosCmdRef(self._module, TMS_DESTGROUP))
-                ref = cmd_ref['TMS_DESTGROUP']['ref'][-1]
-                ref.set_context([resource_key])
-                ref.get_existing(device_cache)
-                normalize_data(ref)
-
-        # Get Telemetry Sensorgroup Group Data
-        cmd_ref['TMS_SENSORGROUP']['ref'] = []
-        for line in device_cache_lines:
-            if re.search(r'sensor-group', line):
-                resource_key = line.strip()
-                cmd_ref['TMS_SENSORGROUP']['ref'].append(NxosCmdRef(self._module, TMS_SENSORGROUP))
-                ref = cmd_ref['TMS_SENSORGROUP']['ref'][-1]
-                ref.set_context([resource_key])
-                ref.get_existing(device_cache)
-
-        # Get Telemetry Subscription Data
-        cmd_ref['TMS_SUBSCRIPTION']['ref'] = []
-        for line in device_cache_lines:
-            if re.search(r'subscription', line):
-                resource_key = line.strip()
-                cmd_ref['TMS_SUBSCRIPTION']['ref'].append(NxosCmdRef(self._module, TMS_SUBSCRIPTION))
-                ref = cmd_ref['TMS_SUBSCRIPTION']['ref'][-1]
-                ref.set_context([resource_key])
-                ref.get_existing(device_cache)
-
-        objs = []
-        objs = self.render_config(self.generated_spec, cmd_ref)
-        facts = {'telemetry': {}}
-        if objs:
-            # params = utils.validate_config(self.argument_spec, {'config': objs})
-            facts['telemetry'] = objs
-
-        ansible_facts['ansible_network_resources'].update(facts)
-        if self._module.params.get('state'):
-            self._module.params['state'] = saved_module_state
-        return ansible_facts
-
-    def render_config(self, spec, cmd_ref):
-        """
-        Render config as dictionary structure and delete keys
-          from spec for null values
-
-        :param spec: The facts tree, generated from the argspec
-        :param conf: The configuration
-        :rtype: dictionary
-        :returns: The generated config
-        """
-        config = deepcopy(spec)
-        config['destination_groups'] = []
-        config['sensor_groups'] = []
-        config['subscriptions'] = []
-        managed_objects = ['TMS_GLOBAL', 'TMS_DESTGROUP', 'TMS_SENSORGROUP', 'TMS_SUBSCRIPTION']
-
-        # Walk the argspec and cmd_ref objects and build out config dict.
-        for key in config.keys():
-            for mo in managed_objects:
-                for cr in cmd_ref[mo]['ref']:
-                    cr_keys = cr_key_lookup(key, mo)
-                    for cr_key in cr_keys:
-                        if cr._ref.get(cr_key) and cr._ref[cr_key].get('existing'):
-                            if isinstance(config[key], dict):
-                                for k in config[key].keys():
-                                    for existing_key in cr._ref[cr_key]['existing'].keys():
-                                        config[key][k] = cr._ref[cr_key]['existing'][existing_key][k]
-                                continue
-                            if isinstance(config[key], list):
-                                for existing_key in cr._ref[cr_key]['existing'].keys():
-                                    data = get_instance_data(key, cr_key, cr, existing_key)
-                                    config[key].append(data)
-                                continue
-                            for existing_key in cr._ref[cr_key]['existing'].keys():
-                                config[key] = cr._ref[cr_key]['existing'][existing_key]
-                        elif cr._ref.get(cr_key):
-                            data = get_instance_data(key, cr_key, cr, None)
-                            if isinstance(config[key], list) and data not in config[key]:
-                                config[key].append(data)
-
-        return utils.remove_empties(config)
diff --git a/lib/ansible/module_utils/network/nxos/facts/vlans/vlans.py b/lib/ansible/module_utils/network/nxos/facts/vlans/vlans.py
deleted file mode 100644
index 260fae1a23..0000000000
--- a/lib/ansible/module_utils/network/nxos/facts/vlans/vlans.py
+++ /dev/null
@@ -1,172 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)#!/usr/bin/python
-"""
-The nxos vlans fact class
-It is in this file the configuration is collected from the device
-for a given resource, parsed, and the facts tree is populated
-based on the configuration.
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-import re
-import ast
-from copy import deepcopy
-
-from ansible.module_utils.network.common import utils
-from ansible.module_utils.network.common.utils import parse_conf_arg, parse_conf_cmd_arg
-from ansible.module_utils.network.nxos.argspec.vlans.vlans import VlansArgs
-
-
-class VlansFacts(object):
-    """ The nxos vlans fact class
-    """
-
-    def __init__(self, module, subspec='config', options='options'):
-        self._module = module
-        self.argument_spec = VlansArgs.argument_spec
-        spec = deepcopy(self.argument_spec)
-        if subspec:
-            if options:
-                facts_argument_spec = spec[subspec][options]
-            else:
-                facts_argument_spec = spec[subspec]
-        else:
-            facts_argument_spec = spec
-
-        self.generated_spec = utils.generate_dict(facts_argument_spec)
-
-    def get_device_data(self, connection, show_cmd):
-        """Wrapper method for `connection.get()`
-        This exists solely to allow the unit test framework to mock device connection calls.
-        """
-        return connection.get(show_cmd)
-
-    def populate_facts(self, connection, ansible_facts, data=None):
-        """ Populate the facts for vlans
-        :param connection: the device connection
-        :param data: previously collected conf
-        :rtype: dictionary
-        :returns: facts
-        """
-        objs = []
-        # **TBD**
-        # N7K EOL/legacy image 6.2 does not support show vlan | json output.
-        # If support is still required for this image then:
-        # - Wrapp the json calls below in a try/except
-        # - When excepted, use a helper method to parse the run_cfg_output,
-        #   using the run_cfg_output data to generate compatible json data that
-        #   can be read by normalize_table_data.
-        if not data:
-            # Use structured for most of the vlan parameter states.
-            # This data is consistent across the supported nxos platforms.
-            structured = self.get_device_data(connection, 'show vlan | json')
-
-            # Raw cli config is needed for mapped_vni, which is not included in structured.
-            run_cfg_output = self.get_device_data(connection, 'show running-config | section ^vlan')
-
-            # Create a single dictionary from all data sources
-            data = self.normalize_table_data(structured, run_cfg_output)
-
-        for vlan in data:
-            obj = self.render_config(self.generated_spec, vlan)
-            if obj:
-                objs.append(obj)
-
-        ansible_facts['ansible_network_resources'].pop('vlans', None)
-        facts = {}
-        if objs:
-            facts['vlans'] = []
-            params = utils.validate_config(self.argument_spec, {'config': objs})
-            for cfg in params['config']:
-                facts['vlans'].append(utils.remove_empties(cfg))
-        ansible_facts['ansible_network_resources'].update(facts)
-        return ansible_facts
-
-    def render_config(self, spec, vlan):
-        """
-        Render config as dictionary structure and delete keys
-          from spec for null values
-        :param spec: The facts tree, generated from the argspec
-        :param vlan: structured data vlan settings (dict) and raw cfg from device
-        :rtype: dictionary
-        :returns: The generated config
-        Sample inputs: test/units/modules/network/nxos/fixtures/nxos_vlans/show_vlan
-        """
-        obj = deepcopy(spec)
-
-        obj['vlan_id'] = vlan['vlan_id']
-
-        # name: 'VLAN000x' (default name) or custom name
-        name = vlan['vlanshowbr-vlanname']
-        if name and re.match("VLAN%04d" % int(vlan['vlan_id']), name):
-            name = None
-        obj['name'] = name
-
-        # mode: 'ce-vlan' or 'fabricpath-vlan'
-        obj['mode'] = vlan['vlanshowinfo-vlanmode'].replace('-vlan', '')
-
-        # enabled: shutdown, noshutdown
-        obj['enabled'] = True if 'noshutdown' in vlan['vlanshowbr-shutstate'] else False
-
-        # state: active, suspend
-        obj['state'] = vlan['vlanshowbr-vlanstate']
-
-        # non-structured data
-        obj['mapped_vni'] = parse_conf_arg(vlan['run_cfg'], 'vn-segment')
-
-        return utils.remove_empties(obj)
-
-    def normalize_table_data(self, structured, run_cfg_output):
-        """Normalize structured output and raw running-config output into
-        a single dict to simplify render_config usage.
-        This is needed because:
-        - The NXOS devices report most of the vlan settings within two
-          structured data keys: 'vlanbrief' and 'mtuinfo', but the output is
-          incomplete and therefore raw running-config data is also needed.
-        - running-config by itself is insufficient because of major differences
-          in the cli config syntax across platforms.
-        - Thus a helper method combines settings from the separate top-level keys,
-          and adds a 'run_cfg' key containing raw cli from the device.
-        """
-        # device output may be string, convert to list
-        structured = ast.literal_eval(str(structured))
-
-        vlanbrief = []
-        mtuinfo = []
-        if 'TABLE_vlanbrief' in structured:
-            # SAMPLE: {"TABLE_vlanbriefid": {"ROW_vlanbriefid": {
-            #   "vlanshowbr-vlanid": "4", "vlanshowbr-vlanid-utf": "4",
-            #   "vlanshowbr-vlanname": "VLAN0004", "vlanshowbr-vlanstate": "active",
-            #   "vlanshowbr-shutstate": "noshutdown"}},
-            vlanbrief = structured['TABLE_vlanbrief']['ROW_vlanbrief']
-
-            # SAMPLE: "TABLE_mtuinfoid": {"ROW_mtuinfoid": {
-            #   "vlanshowinfo-vlanid": "4", "vlanshowinfo-media-type": "enet",
-            #   "vlanshowinfo-vlanmode": "ce-vlan"}}
-            mtuinfo = structured['TABLE_mtuinfo']['ROW_mtuinfo']
-
-        if type(vlanbrief) is not list:
-            # vlanbrief is not a list when only one vlan is found.
-            vlanbrief = [vlanbrief]
-            mtuinfo = [mtuinfo]
-
-        # split out any per-vlan cli config
-        run_cfg_list = re.split(r'[\n^]vlan ', run_cfg_output)
-
-        # Create a list of vlan dicts where each dict contains vlanbrief,
-        # mtuinfo, and non-structured running-config data for one vlan.
-        vlans = []
-        for index, v in enumerate(vlanbrief):
-            v['vlan_id'] = v.get('vlanshowbr-vlanid-utf')
-            vlan = {}
-            vlan.update(v)
-            vlan.update(mtuinfo[index])
-
-            run_cfg = [i for i in run_cfg_list if "%s\n" % v['vlan_id'] in i] or ['']
-            vlan['run_cfg'] = run_cfg.pop()
-            vlans.append(vlan)
-        return vlans
diff --git a/lib/ansible/module_utils/network/nxos/nxos.py b/lib/ansible/module_utils/network/nxos/nxos.py
deleted file mode 100644
index 431691c47c..0000000000
--- a/lib/ansible/module_utils/network/nxos/nxos.py
+++ /dev/null
@@ -1,1310 +0,0 @@
-#
-# This code is part of Ansible, but is an independent component.
-#
-# This particular file snippet, and this file snippet only, is BSD licensed.
-# Modules you write using this snippet, which is embedded dynamically by Ansible
-# still belong to the author of the module, and may assign their own license
-# to the complete work.
-#
-# Copyright: (c) 2017, Red Hat Inc.
-#
-# Redistribution and use in source and binary forms, with or without modification,
-# are permitted provided that the following conditions are met:
-#
-#    * Redistributions of source code must retain the above copyright
-#      notice, this list of conditions and the following disclaimer.
-#    * Redistributions in binary form must reproduce the above copyright notice,
-#      this list of conditions and the following disclaimer in the documentation
-#      and/or other materials provided with the distribution.
-#
-# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
-# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
-# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
-# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-import collections
-import json
-import re
-import sys
-from copy import deepcopy
-
-from ansible.module_utils._text import to_text
-from ansible.module_utils.basic import env_fallback
-from ansible.module_utils.network.common.utils import to_list, ComplexList
-from ansible.module_utils.connection import Connection, ConnectionError
-from ansible.module_utils.common._collections_compat import Mapping
-from ansible.module_utils.network.common.config import NetworkConfig, dumps
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-from ansible.module_utils.six import iteritems, PY2, PY3
-from ansible.module_utils.urls import fetch_url
-
-try:
-    import yaml
-    HAS_YAML = True
-except ImportError:
-    HAS_YAML = False
-
-try:
-    if sys.version_info[:2] < (2, 7):
-        from ordereddict import OrderedDict
-    else:
-        from collections import OrderedDict
-    HAS_ORDEREDDICT = True
-except ImportError:
-    HAS_ORDEREDDICT = False
-
-_DEVICE_CONNECTION = None
-
-nxos_provider_spec = {
-    'host': dict(type='str'),
-    'port': dict(type='int'),
-
-    'username': dict(type='str', fallback=(env_fallback, ['ANSIBLE_NET_USERNAME'])),
-    'password': dict(type='str', no_log=True, fallback=(env_fallback, ['ANSIBLE_NET_PASSWORD'])),
-    'ssh_keyfile': dict(type='str', fallback=(env_fallback, ['ANSIBLE_NET_SSH_KEYFILE'])),
-
-    'authorize': dict(type='bool', fallback=(env_fallback, ['ANSIBLE_NET_AUTHORIZE'])),
-    'auth_pass': dict(type='str', no_log=True, fallback=(env_fallback, ['ANSIBLE_NET_AUTH_PASS'])),
-
-    'use_ssl': dict(type='bool'),
-    'use_proxy': dict(type='bool', default=True),
-    'validate_certs': dict(type='bool'),
-
-    'timeout': dict(type='int'),
-
-    'transport': dict(type='str', default='cli', choices=['cli', 'nxapi'])
-}
-nxos_argument_spec = {
-    'provider': dict(type='dict', options=nxos_provider_spec, removed_in_version=2.14),
-}
-
-
-def get_provider_argspec():
-    return nxos_provider_spec
-
-
-def get_connection(module):
-    global _DEVICE_CONNECTION
-    if not _DEVICE_CONNECTION:
-        if is_local_nxapi(module):
-            conn = LocalNxapi(module)
-        else:
-            connection_proxy = Connection(module._socket_path)
-            cap = json.loads(connection_proxy.get_capabilities())
-            if cap['network_api'] == 'cliconf':
-                conn = Cli(module)
-            elif cap['network_api'] == 'nxapi':
-                conn = HttpApi(module)
-        _DEVICE_CONNECTION = conn
-    return _DEVICE_CONNECTION
-
-
-class Cli:
-
-    def __init__(self, module):
-        self._module = module
-        self._device_configs = {}
-        self._connection = None
-
-    def _get_connection(self):
-        if self._connection:
-            return self._connection
-        self._connection = Connection(self._module._socket_path)
-
-        return self._connection
-
-    def get_config(self, flags=None):
-        """Retrieves the current config from the device or cache
-        """
-        flags = [] if flags is None else flags
-
-        cmd = 'show running-config '
-        cmd += ' '.join(flags)
-        cmd = cmd.strip()
-
-        try:
-            return self._device_configs[cmd]
-        except KeyError:
-            connection = self._get_connection()
-            try:
-                out = connection.get_config(flags=flags)
-            except ConnectionError as exc:
-                self._module.fail_json(msg=to_text(exc, errors='surrogate_then_replace'))
-
-            cfg = to_text(out, errors='surrogate_then_replace').strip() + '\n'
-            self._device_configs[cmd] = cfg
-            return cfg
-
-    def run_commands(self, commands, check_rc=True):
-        """Run list of commands on remote device and return results
-        """
-        connection = self._get_connection()
-
-        try:
-            out = connection.run_commands(commands, check_rc)
-            if check_rc == 'retry_json':
-                capabilities = self.get_capabilities()
-                network_api = capabilities.get('network_api')
-
-                if network_api == 'cliconf' and out:
-                    for index, resp in enumerate(out):
-                        if ('Invalid command at' in resp or 'Ambiguous command at' in resp) and 'json' in resp:
-                            if commands[index]['output'] == 'json':
-                                commands[index]['output'] = 'text'
-                                out = connection.run_commands(commands, check_rc)
-            return out
-        except ConnectionError as exc:
-            self._module.fail_json(msg=to_text(exc))
-
-    def load_config(self, config, return_error=False, opts=None, replace=None):
-        """Sends configuration commands to the remote device
-        """
-        if opts is None:
-            opts = {}
-
-        connection = self._get_connection()
-        responses = []
-        try:
-            resp = connection.edit_config(config, replace=replace)
-            if isinstance(resp, Mapping):
-                resp = resp['response']
-        except ConnectionError as e:
-            code = getattr(e, 'code', 1)
-            message = getattr(e, 'err', e)
-            err = to_text(message, errors='surrogate_then_replace')
-            if opts.get('ignore_timeout') and code:
-                responses.append(err)
-                return responses
-            elif code and 'no graceful-restart' in err:
-                if 'ISSU/HA will be affected if Graceful Restart is disabled' in err:
-                    msg = ['']
-                    responses.extend(msg)
-                    return responses
-                else:
-                    self._module.fail_json(msg=err)
-            elif code:
-                self._module.fail_json(msg=err)
-
-        responses.extend(resp)
-        return responses
-
-    def get_diff(self, candidate=None, running=None, diff_match='line', diff_ignore_lines=None, path=None, diff_replace='line'):
-        conn = self._get_connection()
-        try:
-            response = conn.get_diff(candidate=candidate, running=running, diff_match=diff_match, diff_ignore_lines=diff_ignore_lines, path=path,
-                                     diff_replace=diff_replace)
-        except ConnectionError as exc:
-            self._module.fail_json(msg=to_text(exc, errors='surrogate_then_replace'))
-        return response
-
-    def get_capabilities(self):
-        """Returns platform info of the remove device
-        """
-        if hasattr(self._module, '_capabilities'):
-            return self._module._capabilities
-
-        connection = self._get_connection()
-        try:
-            capabilities = connection.get_capabilities()
-        except ConnectionError as exc:
-            self._module.fail_json(msg=to_text(exc, errors='surrogate_then_replace'))
-        self._module._capabilities = json.loads(capabilities)
-        return self._module._capabilities
-
-    def read_module_context(self, module_key):
-        connection = self._get_connection()
-        try:
-            module_context = connection.read_module_context(module_key)
-        except ConnectionError as exc:
-            self._module.fail_json(msg=to_text(exc, errors='surrogate_then_replace'))
-
-        return module_context
-
-    def save_module_context(self, module_key, module_context):
-        connection = self._get_connection()
-        try:
-            connection.save_module_context(module_key, module_context)
-        except ConnectionError as exc:
-            self._module.fail_json(msg=to_text(exc, errors='surrogate_then_replace'))
-
-        return None
-
-
-class LocalNxapi:
-
-    OUTPUT_TO_COMMAND_TYPE = {
-        'text': 'cli_show_ascii',
-        'json': 'cli_show',
-        'bash': 'bash',
-        'config': 'cli_conf'
-    }
-
-    def __init__(self, module):
-        self._module = module
-        self._nxapi_auth = None
-        self._device_configs = {}
-        self._module_context = {}
-
-        provider = self._module.params.get("provider") or {}
-        self._module.params['url_username'] = provider.get('username')
-        self._module.params['url_password'] = provider.get('password')
-
-        host = provider.get('host')
-        port = provider.get('port')
-
-        if provider.get('use_ssl'):
-            proto = 'https'
-            port = port or 443
-        else:
-            proto = 'http'
-            port = port or 80
-
-        self._url = '%s://%s:%s/ins' % (proto, host, port)
-
-    def _error(self, msg, **kwargs):
-        self._nxapi_auth = None
-        if 'url' not in kwargs:
-            kwargs['url'] = self._url
-        self._module.fail_json(msg=msg, **kwargs)
-
-    def _request_builder(self, commands, output, version='1.0', chunk='0', sid=None):
-        """Encodes a NXAPI JSON request message
-        """
-        try:
-            command_type = self.OUTPUT_TO_COMMAND_TYPE[output]
-        except KeyError:
-            msg = 'invalid format, received %s, expected one of %s' % \
-                (output, ','.join(self.OUTPUT_TO_COMMAND_TYPE.keys()))
-            self._error(msg=msg)
-
-        if isinstance(commands, (list, set, tuple)):
-            commands = ' ;'.join(commands)
-
-        # Order should not matter but some versions of NX-OS software fail
-        # to process the payload properly if 'input' gets serialized before
-        # 'type' and the payload of 'input' contains the word 'type'.
-        msg = collections.OrderedDict()
-        msg['version'] = version
-        msg['type'] = command_type
-        msg['chunk'] = chunk
-        msg['sid'] = sid
-        msg['input'] = commands
-        msg['output_format'] = 'json'
-
-        return dict(ins_api=msg)
-
-    def send_request(self, commands, output='text', check_status=True,
-                     return_error=False, opts=None):
-        # only 10 show commands can be encoded in each request
-        # messages sent to the remote device
-        if opts is None:
-            opts = {}
-        if output != 'config':
-            commands = collections.deque(to_list(commands))
-            stack = list()
-            requests = list()
-
-            while commands:
-                stack.append(commands.popleft())
-                if len(stack) == 10:
-                    body = self._request_builder(stack, output)
-                    data = self._module.jsonify(body)
-                    requests.append(data)
-                    stack = list()
-
-            if stack:
-                body = self._request_builder(stack, output)
-                data = self._module.jsonify(body)
-                requests.append(data)
-
-        else:
-            body = self._request_builder(commands, 'config')
-            requests = [self._module.jsonify(body)]
-
-        headers = {'Content-Type': 'application/json'}
-        result = list()
-        timeout = self._module.params['provider']['timeout']
-        use_proxy = self._module.params['provider']['use_proxy']
-
-        for req in requests:
-            if self._nxapi_auth:
-                headers['Cookie'] = self._nxapi_auth
-
-            response, headers = fetch_url(
-                self._module, self._url, data=req, headers=headers,
-                timeout=timeout, method='POST', use_proxy=use_proxy
-            )
-            self._nxapi_auth = headers.get('set-cookie')
-
-            if opts.get('ignore_timeout') and re.search(r'(-1|5\d\d)', str(headers['status'])):
-                result.append(headers['status'])
-                return result
-            elif headers['status'] != 200:
-                self._error(**headers)
-
-            try:
-                response = self._module.from_json(response.read())
-            except ValueError:
-                self._module.fail_json(msg='unable to parse response')
-
-            if response['ins_api'].get('outputs'):
-                output = response['ins_api']['outputs']['output']
-                for item in to_list(output):
-                    if check_status is True and item['code'] != '200':
-                        if return_error:
-                            result.append(item)
-                        else:
-                            self._error(output=output, **item)
-                    elif 'body' in item:
-                        result.append(item['body'])
-                    # else:
-                        # error in command but since check_status is disabled
-                        # silently drop it.
-                        # result.append(item['msg'])
-
-            return result
-
-    def get_config(self, flags=None):
-        """Retrieves the current config from the device or cache
-        """
-        flags = [] if flags is None else flags
-
-        cmd = 'show running-config '
-        cmd += ' '.join(flags)
-        cmd = cmd.strip()
-
-        try:
-            return self._device_configs[cmd]
-        except KeyError:
-            out = self.send_request(cmd)
-            cfg = str(out[0]).strip()
-            self._device_configs[cmd] = cfg
-            return cfg
-
-    def run_commands(self, commands, check_rc=True):
-        """Run list of commands on remote device and return results
-        """
-        output = None
-        queue = list()
-        responses = list()
-
-        def _send(commands, output):
-            return self.send_request(commands, output, check_status=check_rc)
-
-        for item in to_list(commands):
-            if is_json(item['command']):
-                item['command'] = str(item['command']).rsplit('|', 1)[0]
-                item['output'] = 'json'
-
-            if all((output == 'json', item['output'] == 'text')) or all((output == 'text', item['output'] == 'json')):
-                responses.extend(_send(queue, output))
-                queue = list()
-
-            output = item['output'] or 'json'
-            queue.append(item['command'])
-
-        if queue:
-            responses.extend(_send(queue, output))
-
-        return responses
-
-    def load_config(self, commands, return_error=False, opts=None, replace=None):
-        """Sends the ordered set of commands to the device
-        """
-
-        if opts is None:
-            opts = {}
-
-        responses = []
-
-        if replace:
-            device_info = self.get_device_info()
-            if '9K' not in device_info.get('network_os_platform', ''):
-                self._module.fail_json(msg='replace is supported only on Nexus 9K devices')
-            commands = 'config replace {0}'.format(replace)
-
-        commands = to_list(commands)
-        try:
-            resp = self.send_request(commands, output='config', check_status=True,
-                                     return_error=return_error, opts=opts)
-        except ValueError as exc:
-            code = getattr(exc, 'code', 1)
-            message = getattr(exc, 'err', exc)
-            err = to_text(message, errors='surrogate_then_replace')
-            if opts.get('ignore_timeout') and code:
-                responses.append(code)
-                return responses
-            elif code and 'no graceful-restart' in err:
-                if 'ISSU/HA will be affected if Graceful Restart is disabled' in err:
-                    msg = ['']
-                    responses.extend(msg)
-                    return responses
-                else:
-                    self._module.fail_json(msg=err)
-            elif code:
-                self._module.fail_json(msg=err)
-
-        if return_error:
-            return resp
-        else:
-            return responses.extend(resp)
-
-    def get_diff(self, candidate=None, running=None, diff_match='line', diff_ignore_lines=None, path=None, diff_replace='line'):
-        diff = {}
-
-        # prepare candidate configuration
-        candidate_obj = NetworkConfig(indent=2)
-        candidate_obj.load(candidate)
-
-        if running and diff_match != 'none' and diff_replace != 'config':
-            # running configuration
-            running_obj = NetworkConfig(indent=2, contents=running, ignore_lines=diff_ignore_lines)
-            configdiffobjs = candidate_obj.difference(running_obj, path=path, match=diff_match, replace=diff_replace)
-
-        else:
-            configdiffobjs = candidate_obj.items
-
-        diff['config_diff'] = dumps(configdiffobjs, 'commands') if configdiffobjs else ''
-        return diff
-
-    def get_device_info(self):
-        device_info = {}
-
-        device_info['network_os'] = 'nxos'
-        reply = self.run_commands({'command': 'show version', 'output': 'json'})
-        data = reply[0]
-
-        platform_reply = self.run_commands({'command': 'show inventory', 'output': 'json'})
-        platform_info = platform_reply[0]
-
-        device_info['network_os_version'] = data.get('sys_ver_str') or data.get('kickstart_ver_str')
-        device_info['network_os_model'] = data['chassis_id']
-        device_info['network_os_hostname'] = data['host_name']
-        device_info['network_os_image'] = data.get('isan_file_name') or data.get('kick_file_name')
-
-        if platform_info:
-            inventory_table = platform_info['TABLE_inv']['ROW_inv']
-            for info in inventory_table:
-                if 'Chassis' in info['name']:
-                    device_info['network_os_platform'] = info['productid']
-
-        return device_info
-
-    def get_capabilities(self):
-        result = {}
-        result['device_info'] = self.get_device_info()
-        result['network_api'] = 'nxapi'
-        return result
-
-    def read_module_context(self, module_key):
-        if self._module_context.get(module_key):
-            return self._module_context[module_key]
-
-        return None
-
-    def save_module_context(self, module_key, module_context):
-        self._module_context[module_key] = module_context
-
-        return None
-
-
-class HttpApi:
-    def __init__(self, module):
-        self._module = module
-        self._device_configs = {}
-        self._module_context = {}
-        self._connection_obj = None
-
-    @property
-    def _connection(self):
-        if not self._connection_obj:
-            self._connection_obj = Connection(self._module._socket_path)
-
-        return self._connection_obj
-
-    def run_commands(self, commands, check_rc=True):
-        """Runs list of commands on remote device and returns results
-        """
-        try:
-            out = self._connection.send_request(commands)
-        except ConnectionError as exc:
-            if check_rc is True:
-                raise
-            out = to_text(exc)
-
-        out = to_list(out)
-        if not out[0]:
-            return out
-
-        for index, response in enumerate(out):
-            if response[0] == '{':
-                out[index] = json.loads(response)
-
-        return out
-
-    def get_config(self, flags=None):
-        """Retrieves the current config from the device or cache
-        """
-        flags = [] if flags is None else flags
-
-        cmd = 'show running-config '
-        cmd += ' '.join(flags)
-        cmd = cmd.strip()
-
-        try:
-            return self._device_configs[cmd]
-        except KeyError:
-            try:
-                out = self._connection.send_request(cmd)
-            except ConnectionError as exc:
-                self._module.fail_json(msg=to_text(exc, errors='surrogate_then_replace'))
-
-            cfg = to_text(out).strip()
-            self._device_configs[cmd] = cfg
-            return cfg
-
-    def get_diff(self, candidate=None, running=None, diff_match='line', diff_ignore_lines=None, path=None, diff_replace='line'):
-        diff = {}
-
-        # prepare candidate configuration
-        candidate_obj = NetworkConfig(indent=2)
-        candidate_obj.load(candidate)
-
-        if running and diff_match != 'none' and diff_replace != 'config':
-            # running configuration
-            running_obj = NetworkConfig(indent=2, contents=running, ignore_lines=diff_ignore_lines)
-            configdiffobjs = candidate_obj.difference(running_obj, path=path, match=diff_match, replace=diff_replace)
-
-        else:
-            configdiffobjs = candidate_obj.items
-
-        diff['config_diff'] = dumps(configdiffobjs, 'commands') if configdiffobjs else ''
-        return diff
-
-    def load_config(self, commands, return_error=False, opts=None, replace=None):
-        """Sends the ordered set of commands to the device
-        """
-        if opts is None:
-            opts = {}
-
-        responses = []
-        try:
-            resp = self.edit_config(commands, replace=replace)
-        except ConnectionError as exc:
-            code = getattr(exc, 'code', 1)
-            message = getattr(exc, 'err', exc)
-            err = to_text(message, errors='surrogate_then_replace')
-            if opts.get('ignore_timeout') and code:
-                responses.append(code)
-                return responses
-            elif opts.get('catch_clierror') and '400' in code:
-                return [code, err]
-            elif code and 'no graceful-restart' in err:
-                if 'ISSU/HA will be affected if Graceful Restart is disabled' in err:
-                    msg = ['']
-                    responses.extend(msg)
-                    return responses
-                else:
-                    self._module.fail_json(msg=err)
-            elif code:
-                self._module.fail_json(msg=err)
-
-        responses.extend(resp)
-        return responses
-
-    def edit_config(self, candidate=None, commit=True, replace=None, comment=None):
-        resp = list()
-
-        self.check_edit_config_capability(candidate, commit, replace, comment)
-
-        if replace:
-            candidate = 'config replace {0}'.format(replace)
-
-        responses = self._connection.send_request(candidate, output='config')
-        for response in to_list(responses):
-            if response != '{}':
-                resp.append(response)
-        if not resp:
-            resp = ['']
-
-        return resp
-
-    def get_capabilities(self):
-        """Returns platform info of the remove device
-        """
-        try:
-            capabilities = self._connection.get_capabilities()
-        except ConnectionError as exc:
-            self._module.fail_json(msg=to_text(exc, errors='surrogate_then_replace'))
-
-        return json.loads(capabilities)
-
-    def check_edit_config_capability(self, candidate=None, commit=True, replace=None, comment=None):
-        operations = self._connection.get_device_operations()
-
-        if not candidate and not replace:
-            raise ValueError("must provide a candidate or replace to load configuration")
-
-        if commit not in (True, False):
-            raise ValueError("'commit' must be a bool, got %s" % commit)
-
-        if replace and not operations.get('supports_replace'):
-            raise ValueError("configuration replace is not supported")
-
-        if comment and not operations.get('supports_commit_comment', False):
-            raise ValueError("commit comment is not supported")
-
-    def read_module_context(self, module_key):
-        try:
-            module_context = self._connection.read_module_context(module_key)
-        except ConnectionError as exc:
-            self._module.fail_json(msg=to_text(exc, errors='surrogate_then_replace'))
-
-        return module_context
-
-    def save_module_context(self, module_key, module_context):
-        try:
-            self._connection.save_module_context(module_key, module_context)
-        except ConnectionError as exc:
-            self._module.fail_json(msg=to_text(exc, errors='surrogate_then_replace'))
-
-        return None
-
-
-class NxosCmdRef:
-    """NXOS Command Reference utilities.
-    The NxosCmdRef class takes a yaml-formatted string of nxos module commands
-    and converts it into dict-formatted database of getters/setters/defaults
-    and associated common and platform-specific values. The utility methods
-    add additional data such as existing states, playbook states, and proposed cli.
-    The utilities also abstract away platform differences such as different
-    defaults and different command syntax.
-
-    Callers must provide a yaml formatted string that defines each command and
-    its properties; e.g. BFD global:
-    ---
-    _template: # _template holds common settings for all commands
-      # Enable feature bfd if disabled
-      feature: bfd
-      # Common getter syntax for BFD commands
-      get_command: show run bfd all | incl '^(no )*bfd'
-
-    interval:
-      kind: dict
-      getval: bfd interval (?P<tx>\\d+) min_rx (?P<min_rx>\\d+) multiplier (?P<multiplier>\\d+)
-      setval: bfd interval {tx} min_rx {min_rx} multiplier {multiplier}
-      default:
-        tx: 50
-        min_rx: 50
-        multiplier: 3
-      N3K:
-        # Platform overrides
-        default:
-          tx: 250
-          min_rx: 250
-          multiplier: 3
-    """
-
-    def __init__(self, module, cmd_ref_str, ref_only=False):
-        """Initialize cmd_ref from yaml data."""
-
-        self._module = module
-        self._check_imports()
-        self._yaml_load(cmd_ref_str)
-        self.cache_existing = None
-        self.present_states = ['present', 'merged', 'replaced']
-        self.absent_states = ['absent', 'deleted']
-        ref = self._ref
-
-        # Create a list of supported commands based on ref keys
-        ref['commands'] = sorted([k for k in ref if not k.startswith('_')])
-        ref['_proposed'] = []
-        ref['_context'] = []
-        ref['_resource_key'] = None
-
-        if not ref_only:
-            ref['_state'] = module.params.get('state', 'present')
-            self.feature_enable()
-            self.get_platform_defaults()
-            self.normalize_defaults()
-
-    def __getitem__(self, key=None):
-        if key is None:
-            return self._ref
-        return self._ref[key]
-
-    def _check_imports(self):
-        module = self._module
-        msg = nxosCmdRef_import_check()
-        if msg:
-            module.fail_json(msg=msg)
-
-    def _yaml_load(self, cmd_ref_str):
-        if PY2:
-            self._ref = yaml.load(cmd_ref_str)
-        elif PY3:
-            self._ref = yaml.load(cmd_ref_str, Loader=yaml.FullLoader)
-
-    def feature_enable(self):
-        """Add 'feature <foo>' to _proposed if ref includes a 'feature' key. """
-        ref = self._ref
-        feature = ref['_template'].get('feature')
-        if feature:
-            show_cmd = "show run | incl 'feature {0}'".format(feature)
-            output = self.execute_show_command(show_cmd, 'text')
-            if not output or 'CLI command error' in output:
-                msg = "** 'feature {0}' is not enabled. Module will auto-enable feature {0} ** ".format(feature)
-                self._module.warn(msg)
-                ref['_proposed'].append('feature {0}'.format(feature))
-                ref['_cli_is_feature_disabled'] = ref['_proposed']
-
-    def get_platform_shortname(self):
-        """Query device for platform type, normalize to a shortname/nickname.
-        Returns platform shortname (e.g. 'N3K-3058P' returns 'N3K') or None.
-        """
-        # TBD: add this method logic to get_capabilities() after those methods
-        #      are made consistent across transports
-        platform_info = self.execute_show_command('show inventory', 'json')
-        if not platform_info or not isinstance(platform_info, dict):
-            return None
-        inventory_table = platform_info['TABLE_inv']['ROW_inv']
-        for info in inventory_table:
-            if 'Chassis' in info['name']:
-                network_os_platform = info['productid']
-                break
-        else:
-            return None
-
-        # Supported Platforms: N3K,N5K,N6K,N7K,N9K,N3K-F,N9K-F
-        m = re.match('(?P<short>N[35679][K57])-(?P<N35>C35)*', network_os_platform)
-        if not m:
-            return None
-        shortname = m.group('short')
-
-        # Normalize
-        if m.groupdict().get('N35'):
-            shortname = 'N35'
-        elif re.match('N77', shortname):
-            shortname = 'N7K'
-        elif re.match(r'N3K|N9K', shortname):
-            for info in inventory_table:
-                if '-R' in info['productid']:
-                    # Fretta Platform
-                    shortname += '-F'
-                    break
-        return shortname
-
-    def get_platform_defaults(self):
-        """Update ref with platform specific defaults"""
-        plat = self.get_platform_shortname()
-        if not plat:
-            return
-
-        ref = self._ref
-        ref['_platform_shortname'] = plat
-        # Remove excluded commands (no platform support for command)
-        for k in ref['commands']:
-            if plat in ref[k].get('_exclude', ''):
-                ref['commands'].remove(k)
-
-        # Update platform-specific settings for each item in ref
-        plat_spec_cmds = [k for k in ref['commands'] if plat in ref[k]]
-        for k in plat_spec_cmds:
-            for plat_key in ref[k][plat]:
-                ref[k][plat_key] = ref[k][plat][plat_key]
-
-    def normalize_defaults(self):
-        """Update ref defaults with normalized data"""
-        ref = self._ref
-        for k in ref['commands']:
-            if 'default' in ref[k] and ref[k]['default']:
-                kind = ref[k]['kind']
-                if 'int' == kind:
-                    ref[k]['default'] = int(ref[k]['default'])
-                elif 'list' == kind:
-                    ref[k]['default'] = [str(i) for i in ref[k]['default']]
-                elif 'dict' == kind:
-                    for key, v in ref[k]['default'].items():
-                        if v:
-                            v = str(v)
-                        ref[k]['default'][key] = v
-
-    def execute_show_command(self, command, format):
-        """Generic show command helper.
-        Warning: 'CLI command error' exceptions are caught, must be handled by caller.
-        Return device output as a newline-separated string or None.
-        """
-        cmds = [{
-            'command': command,
-            'output': format,
-        }]
-        output = None
-        try:
-            output = run_commands(self._module, cmds)
-            if output:
-                output = output[0]
-        except ConnectionError as exc:
-            if 'CLI command error' in repr(exc):
-                # CLI may be feature disabled
-                output = repr(exc)
-            else:
-                raise
-        return output
-
-    def pattern_match_existing(self, output, k):
-        """Pattern matching helper for `get_existing`.
-        `k` is the command name string. Use the pattern from cmd_ref to
-        find a matching string in the output.
-        Return regex match object or None.
-        """
-        ref = self._ref
-        pattern = re.compile(ref[k]['getval'])
-        multiple = 'multiple' in ref[k].keys()
-        match_lines = [re.search(pattern, line) for line in output]
-        if 'dict' == ref[k]['kind']:
-            match = [m for m in match_lines if m]
-            if not match:
-                return None
-            if len(match) > 1 and not multiple:
-                raise ValueError("get_existing: multiple matches found for property {0}".format(k))
-        else:
-            match = [m.groups() for m in match_lines if m]
-            if not match:
-                return None
-            if len(match) > 1 and not multiple:
-                raise ValueError("get_existing: multiple matches found for property {0}".format(k))
-            for item in match:
-                index = match.index(item)
-                match[index] = list(item)  # tuple to list
-
-                # Handle config strings that nvgen with the 'no' prefix.
-                # Example match behavior:
-                # When pattern is: '(no )*foo *(\S+)*$' AND
-                #  When output is: 'no foo'  -> match: ['no ', None]
-                #  When output is: 'foo 50'  -> match: [None, '50']
-                if None is match[index][0]:
-                    match[index].pop(0)
-                elif 'no' in match[index][0]:
-                    match[index].pop(0)
-                    if not match:
-                        return None
-
-        return match
-
-    def set_context(self, context=None):
-        """Update ref with command context.
-        """
-        if context is None:
-            context = []
-        ref = self._ref
-        # Process any additional context that this propoerty might require.
-        # 1) Global context from NxosCmdRef _template.
-        # 2) Context passed in using context arg.
-        ref['_context'] = ref['_template'].get('context', [])
-        for cmd in context:
-            ref['_context'].append(cmd)
-        # Last key in context is the resource key
-        ref['_resource_key'] = context[-1] if context else ref['_resource_key']
-
-    def get_existing(self, cache_output=None):
-        """Update ref with existing command states from the device.
-        Store these states in each command's 'existing' key.
-        """
-        ref = self._ref
-        if ref.get('_cli_is_feature_disabled'):
-            # Add context to proposed if state is present
-            if ref['_state'] in self.present_states:
-                [ref['_proposed'].append(ctx) for ctx in ref['_context']]
-            return
-
-        show_cmd = ref['_template']['get_command']
-        if cache_output:
-            output = cache_output
-        else:
-            output = self.execute_show_command(show_cmd, 'text') or []
-            self.cache_existing = output
-
-        # Add additional command context if needed.
-        if ref['_context']:
-            output = CustomNetworkConfig(indent=2, contents=output)
-            output = output.get_section(ref['_context'])
-
-        if not output:
-            # Add context to proposed if state is present
-            if ref['_state'] in self.present_states:
-                [ref['_proposed'].append(ctx) for ctx in ref['_context']]
-            return
-
-        # We need to remove the last item in context for state absent case.
-        if ref['_state'] in self.absent_states and ref['_context']:
-            if ref['_resource_key'] and ref['_resource_key'] == ref['_context'][-1]:
-                if ref['_context'][-1] in output:
-                    ref['_context'][-1] = 'no ' + ref['_context'][-1]
-                else:
-                    del ref['_context'][-1]
-                return
-
-        # Walk each cmd in ref, use cmd pattern to discover existing cmds
-        output = output.split('\n')
-        for k in ref['commands']:
-            match = self.pattern_match_existing(output, k)
-            if not match:
-                continue
-            ref[k]['existing'] = {}
-            for item in match:
-                index = match.index(item)
-                kind = ref[k]['kind']
-                if 'int' == kind:
-                    ref[k]['existing'][index] = int(item[0])
-                elif 'list' == kind:
-                    ref[k]['existing'][index] = [str(i) for i in item[0]]
-                elif 'dict' == kind:
-                    # The getval pattern should contain regex named group keys that
-                    # match up with the setval named placeholder keys; e.g.
-                    #   getval: my-cmd (?P<foo>\d+) bar (?P<baz>\d+)
-                    #   setval: my-cmd {foo} bar {baz}
-                    ref[k]['existing'][index] = {}
-                    for key in item.groupdict().keys():
-                        ref[k]['existing'][index][key] = str(item.group(key))
-                elif 'str' == kind:
-                    ref[k]['existing'][index] = item[0]
-                else:
-                    raise ValueError("get_existing: unknown 'kind' value specified for key '{0}'".format(k))
-
-    def get_playvals(self):
-        """Update ref with values from the playbook.
-        Store these values in each command's 'playval' key.
-        """
-        ref = self._ref
-        module = self._module
-        params = {}
-        if module.params.get('config'):
-            # Resource module builder packs playvals under 'config' key
-            param_data = module.params.get('config')
-            params['global'] = param_data
-            for key in param_data.keys():
-                if isinstance(param_data[key], list):
-                    params[key] = param_data[key]
-        else:
-            params['global'] = module.params
-        for k in ref.keys():
-            for level in params.keys():
-                if isinstance(params[level], dict):
-                    params[level] = [params[level]]
-                for item in params[level]:
-                    if k in item and item[k] is not None:
-                        if not ref[k].get('playval'):
-                            ref[k]['playval'] = {}
-                        playval = item[k]
-                        index = params[level].index(item)
-                        # Normalize each value
-                        if 'int' == ref[k]['kind']:
-                            playval = int(playval)
-                        elif 'list' == ref[k]['kind']:
-                            playval = [str(i) for i in playval]
-                        elif 'dict' == ref[k]['kind']:
-                            for key, v in playval.items():
-                                playval[key] = str(v)
-                        ref[k]['playval'][index] = playval
-
-    def build_cmd_set(self, playval, existing, k):
-        """Helper function to create list of commands to configure device
-        Return a list of commands
-        """
-        ref = self._ref
-        proposed = ref['_proposed']
-        cmd = None
-        kind = ref[k]['kind']
-        if 'int' == kind:
-            cmd = ref[k]['setval'].format(playval)
-        elif 'list' == kind:
-            cmd = ref[k]['setval'].format(*(playval))
-        elif 'dict' == kind:
-            # The setval pattern should contain placeholder keys that
-            # match up with the getval regex named group keys; e.g.
-            #   getval: my-cmd (?P<foo>\d+) bar (?P<baz>\d+)
-            #   setval: my-cmd {foo} bar {baz}
-            cmd = ref[k]['setval'].format(**playval)
-        elif 'str' == kind:
-            if 'deleted' in playval:
-                if existing:
-                    cmd = 'no ' + ref[k]['setval'].format(existing)
-            else:
-                cmd = ref[k]['setval'].format(playval)
-        else:
-            raise ValueError("get_proposed: unknown 'kind' value specified for key '{0}'".format(k))
-        if cmd:
-            if ref['_state'] in self.absent_states and not re.search(r'^no', cmd):
-                cmd = 'no ' + cmd
-            # Commands may require parent commands for proper context.
-            # Global _template context is replaced by parameter context
-            [proposed.append(ctx) for ctx in ref['_context']]
-            [proposed.append(ctx) for ctx in ref[k].get('context', [])]
-            proposed.append(cmd)
-
-    def get_proposed(self):
-        """Compare playbook values against existing states and create a list
-        of proposed commands.
-        Return a list of raw cli command strings.
-        """
-        ref = self._ref
-        # '_proposed' may be empty list or contain initializations; e.g. ['feature foo']
-        proposed = ref['_proposed']
-
-        if ref['_context'] and ref['_context'][-1].startswith('no'):
-            [proposed.append(ctx) for ctx in ref['_context']]
-            return proposed
-
-        # Create a list of commands that have playbook values
-        play_keys = [k for k in ref['commands'] if 'playval' in ref[k]]
-
-        def compare(playval, existing):
-            if ref['_state'] in self.present_states:
-                if existing is None:
-                    return False
-                elif playval == existing:
-                    return True
-                elif isinstance(existing, dict) and playval in existing.values():
-                    return True
-
-            if ref['_state'] in self.absent_states:
-                if isinstance(existing, dict) and all(x is None for x in existing.values()):
-                    existing = None
-                if existing is None or playval not in existing.values():
-                    return True
-            return False
-
-        # Compare against current state
-        for k in play_keys:
-            playval = ref[k]['playval']
-            # Create playval copy to avoid RuntimeError
-            #   dictionary changed size during iteration error
-            playval_copy = deepcopy(playval)
-            existing = ref[k].get('existing', ref[k]['default'])
-            multiple = 'multiple' in ref[k].keys()
-
-            # Multiple Instances:
-            if isinstance(existing, dict) and multiple:
-                for ekey, evalue in existing.items():
-                    if isinstance(evalue, dict):
-                        # Remove values set to string 'None' from dvalue
-                        evalue = dict((k, v) for k, v in evalue.items() if v != 'None')
-                    for pkey, pvalue in playval.items():
-                        if compare(pvalue, evalue):
-                            if playval_copy.get(pkey):
-                                del playval_copy[pkey]
-                if not playval_copy:
-                    continue
-            # Single Instance:
-            else:
-                for pkey, pval in playval.items():
-                    if compare(pval, existing):
-                        if playval_copy.get(pkey):
-                            del playval_copy[pkey]
-                if not playval_copy:
-                    continue
-
-            playval = playval_copy
-            # Multiple Instances:
-            if isinstance(existing, dict):
-                for dkey, dvalue in existing.items():
-                    for pval in playval.values():
-                        self.build_cmd_set(pval, dvalue, k)
-            # Single Instance:
-            else:
-                for pval in playval.values():
-                    self.build_cmd_set(pval, existing, k)
-
-        # Remove any duplicate commands before returning.
-        # pylint: disable=unnecessary-lambda
-        cmds = sorted(set(proposed), key=lambda x: proposed.index(x))
-        return cmds
-
-
-def nxosCmdRef_import_check():
-    """Return import error messages or empty string"""
-    msg = ''
-    if PY2:
-        if not HAS_ORDEREDDICT and sys.version_info[:2] < (2, 7):
-            msg += "Mandatory python library 'ordereddict' is not present, try 'pip install ordereddict'\n"
-        if not HAS_YAML:
-            msg += "Mandatory python library 'yaml' is not present, try 'pip install yaml'\n"
-    elif PY3:
-        if not HAS_YAML:
-            msg += "Mandatory python library 'PyYAML' is not present, try 'pip install PyYAML'\n"
-    return msg
-
-
-def is_json(cmd):
-    return to_text(cmd).endswith('| json')
-
-
-def is_text(cmd):
-    return not is_json(cmd)
-
-
-def is_local_nxapi(module):
-    provider = module.params.get('provider')
-    if provider:
-        return provider.get("transport") == 'nxapi'
-    return False
-
-
-def to_command(module, commands):
-    if is_local_nxapi(module):
-        default_output = 'json'
-    else:
-        default_output = 'text'
-
-    transform = ComplexList(dict(
-        command=dict(key=True),
-        output=dict(default=default_output),
-        prompt=dict(type='list'),
-        answer=dict(type='list'),
-        newline=dict(type='bool', default=True),
-        sendonly=dict(type='bool', default=False),
-        check_all=dict(type='bool', default=False),
-    ), module)
-
-    commands = transform(to_list(commands))
-
-    for item in commands:
-        if is_json(item['command']):
-            item['output'] = 'json'
-
-    return commands
-
-
-def get_config(module, flags=None):
-    flags = [] if flags is None else flags
-
-    conn = get_connection(module)
-    return conn.get_config(flags=flags)
-
-
-def run_commands(module, commands, check_rc=True):
-    conn = get_connection(module)
-    return conn.run_commands(to_command(module, commands), check_rc)
-
-
-def load_config(module, config, return_error=False, opts=None, replace=None):
-    conn = get_connection(module)
-    return conn.load_config(config, return_error, opts, replace=replace)
-
-
-def get_capabilities(module):
-    conn = get_connection(module)
-    return conn.get_capabilities()
-
-
-def get_diff(self, candidate=None, running=None, diff_match='line', diff_ignore_lines=None, path=None, diff_replace='line'):
-    conn = self.get_connection()
-    return conn.get_diff(candidate=candidate, running=running, diff_match=diff_match, diff_ignore_lines=diff_ignore_lines, path=path, diff_replace=diff_replace)
-
-
-def normalize_interface(name):
-    """Return the normalized interface name
-    """
-    if not name:
-        return
-
-    def _get_number(name):
-        digits = ''
-        for char in name:
-            if char.isdigit() or char in '/.':
-                digits += char
-        return digits
-
-    if name.lower().startswith('et'):
-        if_type = 'Ethernet'
-    elif name.lower().startswith('vl'):
-        if_type = 'Vlan'
-    elif name.lower().startswith('lo'):
-        if_type = 'loopback'
-    elif name.lower().startswith('po'):
-        if_type = 'port-channel'
-    elif name.lower().startswith('nv'):
-        if_type = 'nve'
-    else:
-        if_type = None
-
-    number_list = name.split(' ')
-    if len(number_list) == 2:
-        number = number_list[-1].strip()
-    else:
-        number = _get_number(name)
-
-    if if_type:
-        proper_interface = if_type + number
-    else:
-        proper_interface = name
-
-    return proper_interface
-
-
-def get_interface_type(interface):
-    """Gets the type of interface
-    """
-    if interface.upper().startswith('ET'):
-        return 'ethernet'
-    elif interface.upper().startswith('VL'):
-        return 'svi'
-    elif interface.upper().startswith('LO'):
-        return 'loopback'
-    elif interface.upper().startswith('MG'):
-        return 'management'
-    elif interface.upper().startswith('MA'):
-        return 'management'
-    elif interface.upper().startswith('PO'):
-        return 'portchannel'
-    elif interface.upper().startswith('NV'):
-        return 'nve'
-    else:
-        return 'unknown'
-
-
-def default_intf_enabled(name='', sysdefs=None, mode=None):
-    """Get device/version/interface-specific default 'enabled' state.
-    L3:
-     - Most L3 intfs default to 'shutdown'. Loopbacks default to 'no shutdown'.
-     - Some legacy platforms default L3 intfs to 'no shutdown'.
-    L2:
-     - User-System-Default 'system default switchport shutdown' defines the
-       enabled state for L2 intf's. USD defaults may be different on some platforms.
-     - An intf may be explicitly defined as L2 with 'switchport' or it may be
-       implicitly defined as L2 when USD 'system default switchport' is defined.
-    """
-    if not name:
-        return None
-    if sysdefs is None:
-        sysdefs = {}
-    default = False
-
-    if re.search('port-channel|loopback', name):
-        default = True
-    else:
-        if mode is None:
-            # intf 'switchport' cli is not present so use the user-system-default
-            mode = sysdefs.get('mode')
-
-        if mode == 'layer3':
-            default = sysdefs.get('L3_enabled')
-        elif mode == 'layer2':
-            default = sysdefs.get('L2_enabled')
-    return default
-
-
-def read_module_context(module):
-    conn = get_connection(module)
-    return conn.read_module_context(module._name)
-
-
-def save_module_context(module, module_context):
-    conn = get_connection(module)
-    return conn.save_module_context(module._name, module_context)
diff --git a/lib/ansible/module_utils/network/nxos/utils/telemetry/telemetry.py b/lib/ansible/module_utils/network/nxos/utils/telemetry/telemetry.py
deleted file mode 100644
index 597adb5674..0000000000
--- a/lib/ansible/module_utils/network/nxos/utils/telemetry/telemetry.py
+++ /dev/null
@@ -1,250 +0,0 @@
-#
-# -*- coding: utf-8 -*-
-# Copyright 2019 Cisco and/or its affiliates.
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-"""
-The nxos telemetry utility library
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-import re
-from copy import deepcopy
-
-
-def get_module_params_subsection(module_params, tms_config, resource_key=None):
-    """
-    Helper method to get a specific module_params subsection
-    """
-    mp = {}
-    if tms_config == 'TMS_GLOBAL':
-        relevant_keys = ['certificate',
-                         'compression',
-                         'source_interface',
-                         'vrf']
-        for key in relevant_keys:
-            mp[key] = module_params[key]
-
-    if tms_config == 'TMS_DESTGROUP':
-        mp['destination_groups'] = []
-        for destgrp in module_params['destination_groups']:
-            if destgrp['id'] == resource_key:
-                mp['destination_groups'].append(destgrp)
-
-    if tms_config == 'TMS_SENSORGROUP':
-        mp['sensor_groups'] = []
-        for sensor in module_params['sensor_groups']:
-            if sensor['id'] == resource_key:
-                mp['sensor_groups'].append(sensor)
-
-    if tms_config == 'TMS_SUBSCRIPTION':
-        mp['subscriptions'] = []
-        for sensor in module_params['subscriptions']:
-            if sensor['id'] == resource_key:
-                mp['subscriptions'].append(sensor)
-
-    return mp
-
-
-def valiate_input(playvals, type, module):
-    """
-    Helper method to validate playbook values for destination groups
-    """
-    if type == 'destination_groups':
-        if not playvals.get('id'):
-            msg = "Invalid playbook value: {0}.".format(playvals)
-            msg += " Parameter <id> under <destination_groups> is required"
-            module.fail_json(msg=msg)
-        if playvals.get('destination') and not isinstance(playvals['destination'], dict):
-            msg = "Invalid playbook value: {0}.".format(playvals)
-            msg += " Parameter <destination> under <destination_groups> must be a dict"
-            module.fail_json(msg=msg)
-        if not playvals.get('destination') and len(playvals) > 1:
-            msg = "Invalid playbook value: {0}.".format(playvals)
-            msg += " Playbook entry contains unrecongnized parameters."
-            msg += " Make sure <destination> keys under <destination_groups> are specified as follows:"
-            msg += " destination: {ip: <ip>, port: <port>, protocol: <prot>, encoding: <enc>}}"
-            module.fail_json(msg=msg)
-
-    if type == 'sensor_groups':
-        if not playvals.get('id'):
-            msg = "Invalid playbook value: {0}.".format(playvals)
-            msg += " Parameter <id> under <sensor_groups> is required"
-            module.fail_json(msg=msg)
-        if playvals.get('path') and 'name' not in playvals['path'].keys():
-            msg = "Invalid playbook value: {0}.".format(playvals)
-            msg += " Parameter <path> under <sensor_groups> requires <name> key"
-            module.fail_json(msg=msg)
-
-
-def get_instance_data(key, cr_key, cr, existing_key):
-    """
-    Helper method to get instance data used to populate list structure in config
-    fact dictionary
-    """
-    data = {}
-    if existing_key is None:
-        instance = None
-    else:
-        instance = cr._ref[cr_key]['existing'][existing_key]
-
-    patterns = {
-        'destination_groups': r"destination-group (\d+)",
-        'sensor_groups': r"sensor-group (\d+)",
-        'subscriptions': r"subscription (\d+)",
-    }
-    if key in patterns.keys():
-        m = re.search(patterns[key], cr._ref['_resource_key'])
-        instance_key = m.group(1)
-        data = {'id': instance_key, cr_key: instance}
-
-    # Remove None values
-    data = dict((k, v) for k, v in data.items() if v is not None)
-    return data
-
-
-def cr_key_lookup(key, mo):
-    """
-    Helper method to get instance key value for Managed Object (mo)
-    """
-    cr_keys = [key]
-    if key == 'destination_groups' and mo == 'TMS_DESTGROUP':
-        cr_keys = ['destination']
-    elif key == 'sensor_groups' and mo == 'TMS_SENSORGROUP':
-        cr_keys = ['data_source', 'path']
-    elif key == 'subscriptions' and mo == 'TMS_SUBSCRIPTION':
-        cr_keys = ['destination_group', 'sensor_group']
-
-    return cr_keys
-
-
-def normalize_data(cmd_ref):
-    ''' Normalize playbook values and get_exisiting data '''
-
-    playval = cmd_ref._ref.get('destination').get('playval')
-    existing = cmd_ref._ref.get('destination').get('existing')
-
-    dest_props = ['protocol', 'encoding']
-    if playval:
-        for prop in dest_props:
-            for key in playval.keys():
-                playval[key][prop] = playval[key][prop].lower()
-    if existing:
-        for key in existing.keys():
-            for prop in dest_props:
-                existing[key][prop] = existing[key][prop].lower()
-
-
-def remove_duplicate_context(cmds):
-    ''' Helper method to remove duplicate telemetry context commands '''
-    if not cmds:
-        return cmds
-    feature_indices = [i for i, x in enumerate(cmds) if x == "feature telemetry"]
-    telemetry_indices = [i for i, x in enumerate(cmds) if x == "telemetry"]
-    if len(feature_indices) == 1 and len(telemetry_indices) == 1:
-        return cmds
-    if len(feature_indices) == 1 and not telemetry_indices:
-        return cmds
-    if len(telemetry_indices) == 1 and not feature_indices:
-        return cmds
-    if feature_indices and feature_indices[-1] > 1:
-        cmds.pop(feature_indices[-1])
-        return remove_duplicate_context(cmds)
-    if telemetry_indices and telemetry_indices[-1] > 1:
-        cmds.pop(telemetry_indices[-1])
-        return remove_duplicate_context(cmds)
-
-
-def get_setval_path(module_or_path_data):
-    ''' Build setval for path parameter based on playbook inputs
-        Full Command:
-          - path {name} depth {depth} query-condition {query_condition} filter-condition {filter_condition}
-        Required:
-          - path {name}
-        Optional:
-          - depth {depth}
-          - query-condition {query_condition},
-          - filter-condition {filter_condition}
-    '''
-    if isinstance(module_or_path_data, dict):
-        path = module_or_path_data
-    else:
-        path = module_or_path_data.params['config']['sensor_groups'][0].get('path')
-    if path is None:
-        return path
-
-    setval = 'path {name}'
-    if 'depth' in path.keys():
-        if path.get('depth') != 'None':
-            setval = setval + ' depth {depth}'
-    if 'query_condition' in path.keys():
-        if path.get('query_condition') != 'None':
-            setval = setval + ' query-condition {query_condition}'
-    if 'filter_condition' in path.keys():
-        if path.get('filter_condition') != 'None':
-            setval = setval + ' filter-condition {filter_condition}'
-
-    return setval
-
-
-def remove_duplicate_commands(commands_list):
-    # Remove any duplicate commands.
-    # pylint: disable=unnecessary-lambda
-    return sorted(set(commands_list), key=lambda x: commands_list.index(x))
-
-
-def massage_data(have_or_want):
-    # Massage non global into a data structure that is indexed by id and
-    # normalized for destination_groups, sensor_groups and subscriptions.
-    data = deepcopy(have_or_want)
-    massaged = {}
-    massaged['destination_groups'] = {}
-    massaged['sensor_groups'] = {}
-    massaged['subscriptions'] = {}
-    from pprint import pprint
-    for subgroup in ['destination_groups', 'sensor_groups', 'subscriptions']:
-        for item in data.get(subgroup, []):
-            id = str(item.get('id'))
-            if id not in massaged[subgroup].keys():
-                massaged[subgroup][id] = []
-            item.pop('id')
-            if not item:
-                item = None
-            else:
-                if item.get('destination'):
-                    if item.get('destination').get('port'):
-                        item['destination']['port'] = str(item['destination']['port'])
-                    if item.get('destination').get('protocol'):
-                        item['destination']['protocol'] = item['destination']['protocol'].lower()
-                    if item.get('destination').get('encoding'):
-                        item['destination']['encoding'] = item['destination']['encoding'].lower()
-                if item.get('path'):
-                    for key in ['filter_condition', 'query_condition', 'depth']:
-                        if item.get('path').get(key) == 'None':
-                            del item['path'][key]
-                    if item.get('path').get('depth') is not None:
-                        item['path']['depth'] = str(item['path']['depth'])
-                if item.get('destination_group'):
-                    item['destination_group'] = str(item['destination_group'])
-                if item.get('sensor_group'):
-                    if item.get('sensor_group').get('id'):
-                        item['sensor_group']['id'] = str(item['sensor_group']['id'])
-                    if item.get('sensor_group').get('sample_interval'):
-                        item['sensor_group']['sample_interval'] = str(item['sensor_group']['sample_interval'])
-                if item.get('destination_group') and item.get('sensor_group'):
-                    item_copy = deepcopy(item)
-                    del item_copy['sensor_group']
-                    del item['destination_group']
-                    massaged[subgroup][id].append(item_copy)
-                    massaged[subgroup][id].append(item)
-                    continue
-                if item.get('path') and item.get('data_source'):
-                    item_copy = deepcopy(item)
-                    del item_copy['data_source']
-                    del item['path']
-                    massaged[subgroup][id].append(item_copy)
-                    massaged[subgroup][id].append(item)
-                    continue
-            massaged[subgroup][id].append(item)
-    return massaged
diff --git a/lib/ansible/module_utils/network/nxos/utils/utils.py b/lib/ansible/module_utils/network/nxos/utils/utils.py
deleted file mode 100644
index 9564758cb7..0000000000
--- a/lib/ansible/module_utils/network/nxos/utils/utils.py
+++ /dev/null
@@ -1,138 +0,0 @@
-import socket
-
-from ansible.module_utils.six import iteritems
-
-
-def search_obj_in_list(name, lst, identifier):
-    for o in lst:
-        if o[identifier] == name:
-            return o
-    return None
-
-
-def flatten_dict(x):
-    result = {}
-    if not isinstance(x, dict):
-        return result
-
-    for key, value in iteritems(x):
-        if isinstance(value, dict):
-            result.update(flatten_dict(value))
-        else:
-            result[key] = value
-
-    return result
-
-
-def validate_ipv4_addr(address):
-    address = address.split('/')[0]
-    try:
-        socket.inet_aton(address)
-    except socket.error:
-        return False
-    return address.count('.') == 3
-
-
-def validate_ipv6_addr(address):
-    address = address.split('/')[0]
-    try:
-        socket.inet_pton(socket.AF_INET6, address)
-    except socket.error:
-        return False
-    return True
-
-
-def normalize_interface(name):
-    """Return the normalized interface name
-    """
-    if not name:
-        return
-
-    def _get_number(name):
-        digits = ''
-        for char in name:
-            if char.isdigit() or char in '/.':
-                digits += char
-        return digits
-
-    if name.lower().startswith('et'):
-        if_type = 'Ethernet'
-    elif name.lower().startswith('vl'):
-        if_type = 'Vlan'
-    elif name.lower().startswith('lo'):
-        if_type = 'loopback'
-    elif name.lower().startswith('po'):
-        if_type = 'port-channel'
-    elif name.lower().startswith('nv'):
-        if_type = 'nve'
-    else:
-        if_type = None
-
-    number_list = name.split(' ')
-    if len(number_list) == 2:
-        number = number_list[-1].strip()
-    else:
-        number = _get_number(name)
-
-    if if_type:
-        proper_interface = if_type + number
-    else:
-        proper_interface = name
-
-    return proper_interface
-
-
-def get_interface_type(interface):
-    """Gets the type of interface
-    """
-    if interface.upper().startswith('ET'):
-        return 'ethernet'
-    elif interface.upper().startswith('VL'):
-        return 'svi'
-    elif interface.upper().startswith('LO'):
-        return 'loopback'
-    elif interface.upper().startswith('MG'):
-        return 'management'
-    elif interface.upper().startswith('MA'):
-        return 'management'
-    elif interface.upper().startswith('PO'):
-        return 'portchannel'
-    elif interface.upper().startswith('NV'):
-        return 'nve'
-    else:
-        return 'unknown'
-
-
-def remove_rsvd_interfaces(interfaces):
-    """Exclude reserved interfaces from user management
-    """
-    return [i for i in interfaces if get_interface_type(i['name']) != 'management']
-
-
-def vlan_range_to_list(vlans):
-    result = []
-    if vlans:
-        for part in vlans.split(','):
-            if part == 'none':
-                break
-            if '-' in part:
-                a, b = part.split('-')
-                a, b = int(a), int(b)
-                result.extend(range(a, b + 1))
-            else:
-                a = int(part)
-                result.append(a)
-        return numerical_sort(result)
-    return result
-
-
-def numerical_sort(string_int_list):
-    """Sorts list of integers that are digits in numerical order.
-    """
-
-    as_int_list = []
-
-    for vlan in string_int_list:
-        as_int_list.append(int(vlan))
-    as_int_list.sort()
-    return as_int_list
diff --git a/lib/ansible/modules/network/nxos/_nxos_interface.py b/lib/ansible/modules/network/nxos/_nxos_interface.py
deleted file mode 100644
index 58fe00f5bc..0000000000
--- a/lib/ansible/modules/network/nxos/_nxos_interface.py
+++ /dev/null
@@ -1,764 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['deprecated'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = """
----
-module: nxos_interface
-extends_documentation_fragment: nxos
-version_added: "2.1"
-short_description: Manages physical attributes of interfaces.
-description:
-  - Manages physical attributes of interfaces of NX-OS switches.
-deprecated:
-  removed_in: '2.13'
-  alternative: nxos_interfaces
-  why: Updated modules released with more functionality
-author:
-  - Jason Edelman (@jedelman8)
-  - Trishna Guha (@trishnaguha)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - This module is also used to create logical interfaces such as
-    svis and loopbacks.
-  - Be cautious of platform specific idiosyncrasies. For example,
-    when you default a loopback interface, the admin state toggles
-    on certain versions of NX-OS.
-  - The M(nxos_overlay_global) C(anycast_gateway_mac) attribute must be
-    set before setting the C(fabric_forwarding_anycast_gateway) property.
-options:
-  name:
-    description:
-      - Full name of interface, i.e. Ethernet1/1, port-channel10.
-    required: true
-    aliases: [interface]
-  interface_type:
-    description:
-      - Interface type to be unconfigured from the device.
-    choices: ['loopback', 'portchannel', 'svi', 'nve']
-    version_added: 2.2
-  speed:
-    description:
-      - Interface link speed. Applicable for ethernet interface only.
-    version_added: 2.5
-  admin_state:
-    description:
-      - Administrative state of the interface.
-    default: up
-    choices: ['up','down']
-  description:
-    description:
-      - Interface description.
-  mode:
-    description:
-      - Manage Layer 2 or Layer 3 state of the interface.
-        This option is supported for ethernet and portchannel interface.
-        Applicable for ethernet and portchannel interface only.
-    choices: ['layer2','layer3']
-  mtu:
-    description:
-      - MTU for a specific interface. Must be an even number between 576 and 9216.
-        Applicable for ethernet interface only.
-    version_added: 2.5
-  ip_forward:
-    description:
-      - Enable/Disable ip forward feature on SVIs.
-    choices: ['enable','disable']
-    version_added: 2.2
-  fabric_forwarding_anycast_gateway:
-    description:
-      - Associate SVI with anycast gateway under VLAN configuration mode.
-        Applicable for SVI interface only.
-    type: bool
-    version_added: 2.2
-  duplex:
-    description:
-      - Interface link status. Applicable for ethernet interface only.
-    default: auto
-    choices: ['full', 'half', 'auto']
-    version_added: 2.5
-  tx_rate:
-    description:
-      - Transmit rate in bits per second (bps).
-      - This is state check parameter only.
-      - Supports conditionals, see L(Conditionals in Networking Modules,../network/user_guide/network_working_with_command_output.html)
-    version_added: 2.5
-  rx_rate:
-    description:
-      - Receiver rate in bits per second (bps).
-      - This is state check parameter only.
-      - Supports conditionals, see L(Conditionals in Networking Modules,../network/user_guide/network_working_with_command_output.html)
-    version_added: 2.5
-  neighbors:
-    description:
-      - Check the operational state of given interface C(name) for LLDP neighbor.
-      - The following suboptions are available. This is state check parameter only.
-    suboptions:
-        host:
-          description:
-            - "LLDP neighbor host for given interface C(name)."
-        port:
-          description:
-            - "LLDP neighbor port to which given interface C(name) is connected."
-    version_added: 2.5
-  aggregate:
-    description: List of Interfaces definitions.
-    version_added: 2.5
-  state:
-    description:
-      - Specify desired state of the resource.
-    default: present
-    choices: ['present','absent','default']
-  delay:
-    description:
-      - Time in seconds to wait before checking for the operational state on remote
-        device. This wait is applicable for operational state arguments.
-    default: 10
-"""
-
-EXAMPLES = """
-- name: Ensure an interface is a Layer 3 port and that it has the proper description
-  nxos_interface:
-    name: Ethernet1/1
-    description: 'Configured by Ansible'
-    mode: layer3
-
-- name: Admin down an interface
-  nxos_interface:
-    name: Ethernet2/1
-    admin_state: down
-
-- name: Remove all loopback interfaces
-  nxos_interface:
-    name: loopback
-    state: absent
-
-- name: Remove all logical interfaces
-  nxos_interface:
-    interface_type: "{{ item }} "
-    state: absent
-  loop:
-    - loopback
-    - portchannel
-    - svi
-    - nve
-
-- name: Admin up all loopback interfaces
-  nxos_interface:
-    name: loopback 0-1023
-    admin_state: up
-
-- name: Admin down all loopback interfaces
-  nxos_interface:
-    name: loopback 0-1023
-    admin_state: down
-
-- name: Check neighbors intent arguments
-  nxos_interface:
-    name: Ethernet2/3
-    neighbors:
-    - port: Ethernet2/3
-      host: abc.mycompany.com
-
-- name: Add interface using aggregate
-  nxos_interface:
-    aggregate:
-    - { name: Ethernet0/1, mtu: 256, description: test-interface-1 }
-    - { name: Ethernet0/2, mtu: 516, description: test-interface-2 }
-    duplex: full
-    speed: 100
-    state: present
-
-- name: Delete interface using aggregate
-  nxos_interface:
-    aggregate:
-    - name: Loopback9
-    - name: Loopback10
-    state: absent
-
-- name: Check intent arguments
-  nxos_interface:
-    name: Ethernet0/2
-    state: up
-    tx_rate: ge(0)
-    rx_rate: le(0)
-"""
-
-RETURN = """
-commands:
-    description: command list sent to the device
-    returned: always
-    type: list
-    sample:
-      - interface Ethernet2/3
-      - mtu 1500
-      - speed 10
-"""
-
-import re
-import time
-
-from copy import deepcopy
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec, normalize_interface
-from ansible.module_utils.network.nxos.nxos import get_interface_type
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.utils import conditional, remove_default_spec
-
-
-def execute_show_command(command, module):
-    if 'show run' not in command:
-        output = 'json'
-    else:
-        output = 'text'
-    cmds = [{
-        'command': command,
-        'output': output,
-    }]
-    body = run_commands(module, cmds, check_rc=False)
-    if body and "Invalid" in body[0]:
-        return []
-    else:
-        return body
-
-
-def search_obj_in_list(name, lst):
-    for o in lst:
-        if o['name'] == name:
-            return o
-
-    return None
-
-
-def get_interfaces_dict(module):
-    """Gets all active interfaces on a given switch
-    """
-    try:
-        body = execute_show_command('show interface', module)[0]
-    except IndexError:
-        return {}
-
-    interfaces = {
-        'ethernet': [],
-        'svi': [],
-        'loopback': [],
-        'management': [],
-        'portchannel': [],
-        'nve': [],
-        'unknown': []
-    }
-
-    if body:
-        interface_list = body['TABLE_interface']['ROW_interface']
-        for index in interface_list:
-            intf = index['interface']
-            intf_type = get_interface_type(intf)
-            interfaces[intf_type].append(intf)
-
-    return interfaces
-
-
-def get_vlan_interface_attributes(name, intf_type, module):
-    """ Returns dictionary that has two k/v pairs:
-        admin_state & description if not an svi, returns None
-    """
-    command = 'show run interface {0} all'.format(name)
-    try:
-        body = execute_show_command(command, module)[0]
-    except (IndexError, TypeError):
-        return None
-    if body:
-        command_list = body.split('\n')
-        desc = None
-        admin_state = 'down'
-        for each in command_list:
-            if 'description' in each:
-                desc = each.lstrip().split("description")[1].lstrip()
-            elif 'no shutdown' in each:
-                admin_state = 'up'
-        return dict(description=desc, admin_state=admin_state)
-    else:
-        return None
-
-
-def get_interface_type_removed_cmds(interfaces):
-    commands = []
-
-    for interface in interfaces:
-        if interface != 'Vlan1':
-            commands.append('no interface {0}'.format(interface))
-
-    return commands
-
-
-def get_admin_state(admin_state):
-    command = ''
-    if admin_state == 'up':
-        command = 'no shutdown'
-    elif admin_state == 'down':
-        command = 'shutdown'
-    return command
-
-
-def is_default_interface(name, module):
-    """Checks to see if interface exists and if it is a default config
-    """
-    command = 'show run interface {0}'.format(name)
-
-    try:
-        body = execute_show_command(command, module)[0]
-    except (IndexError, TypeError):
-        body = ''
-
-    if body:
-        raw_list = body.split('\n')
-        found = False
-        for line in raw_list:
-            if line.startswith('interface'):
-                found = True
-            if found and line and not line.startswith('interface'):
-                return False
-        return True
-
-    else:
-        return 'DNE'
-
-
-def add_command_to_interface(interface, cmd, commands):
-    if interface not in commands:
-        commands.append(interface)
-    commands.append(cmd)
-
-
-def map_obj_to_commands(updates, module):
-    commands = list()
-    commands2 = list()
-    want, have = updates
-
-    args = ('speed', 'description', 'duplex', 'mtu')
-    for w in want:
-        name = w['name']
-        mode = w['mode']
-        ip_forward = w['ip_forward']
-        fabric_forwarding_anycast_gateway = w['fabric_forwarding_anycast_gateway']
-        admin_state = w['admin_state']
-        state = w['state']
-        interface_type = w['interface_type']
-        del w['state']
-        if name:
-            w['interface_type'] = None
-
-        if interface_type:
-            obj_in_have = {}
-            if state in ('present', 'default'):
-                module.fail_json(msg='The interface_type param can be used only with state absent.')
-        else:
-            obj_in_have = search_obj_in_list(name, have)
-            is_default = is_default_interface(name, module)
-
-        if name:
-            interface = 'interface ' + name
-
-        if state == 'absent':
-            if obj_in_have:
-                commands.append('no interface {0}'.format(name))
-            elif interface_type and not obj_in_have:
-                intfs = get_interfaces_dict(module)[interface_type]
-                cmds = get_interface_type_removed_cmds(intfs)
-                commands.extend(cmds)
-
-        elif state == 'present':
-            if obj_in_have:
-                # Don't run switchport command for loopback and svi interfaces
-                if get_interface_type(name) in ('ethernet', 'portchannel'):
-                    if mode == 'layer2' and mode != obj_in_have.get('mode'):
-                        add_command_to_interface(interface, 'switchport', commands)
-                    elif mode == 'layer3' and mode != obj_in_have.get('mode'):
-                        add_command_to_interface(interface, 'no switchport', commands)
-
-                if admin_state == 'up' and admin_state != obj_in_have.get('admin_state'):
-                    add_command_to_interface(interface, 'no shutdown', commands)
-                elif admin_state == 'down' and admin_state != obj_in_have.get('admin_state'):
-                    add_command_to_interface(interface, 'shutdown', commands)
-
-                if ip_forward == 'enable' and ip_forward != obj_in_have.get('ip_forward'):
-                    add_command_to_interface(interface, 'ip forward', commands)
-                elif ip_forward == 'disable' and ip_forward != obj_in_have.get('ip forward'):
-                    add_command_to_interface(interface, 'no ip forward', commands)
-
-                if (fabric_forwarding_anycast_gateway is True and
-                        obj_in_have.get('fabric_forwarding_anycast_gateway') is False):
-                    add_command_to_interface(interface, 'fabric forwarding mode anycast-gateway', commands)
-
-                elif (fabric_forwarding_anycast_gateway is False and
-                        obj_in_have.get('fabric_forwarding_anycast_gateway') is True):
-                    add_command_to_interface(interface, 'no fabric forwarding mode anycast-gateway', commands)
-
-                for item in args:
-                    candidate = w.get(item)
-                    if candidate and candidate != obj_in_have.get(item):
-                        cmd = item + ' ' + str(candidate)
-                        add_command_to_interface(interface, cmd, commands)
-
-                if name and get_interface_type(name) == 'ethernet':
-                    if mode != obj_in_have.get('mode'):
-                        admin_state = w.get('admin_state') or obj_in_have.get('admin_state')
-                        if admin_state:
-                            c1 = 'interface {0}'.format(normalize_interface(w['name']))
-                            c2 = get_admin_state(admin_state)
-                            commands2.append(c1)
-                            commands2.append(c2)
-
-            else:
-                commands.append(interface)
-                # Don't run switchport command for loopback and svi interfaces
-                if get_interface_type(name) in ('ethernet', 'portchannel'):
-                    if mode == 'layer2':
-                        commands.append('switchport')
-                    elif mode == 'layer3':
-                        commands.append('no switchport')
-
-                if admin_state == 'up':
-                    commands.append('no shutdown')
-                elif admin_state == 'down':
-                    commands.append('shutdown')
-
-                if ip_forward == 'enable':
-                    commands.append('ip forward')
-                elif ip_forward == 'disable':
-                    commands.append('no ip forward')
-
-                if fabric_forwarding_anycast_gateway is True:
-                    commands.append('fabric forwarding mode anycast-gateway')
-
-                elif fabric_forwarding_anycast_gateway is False:
-                    commands.append('no fabric forwarding mode anycast-gateway')
-
-                for item in args:
-                    candidate = w.get(item)
-                    if candidate:
-                        commands.append(item + ' ' + str(candidate))
-
-        elif state == 'default':
-            if is_default is False:
-                commands.append('default interface {0}'.format(name))
-            elif is_default == 'DNE':
-                module.exit_json(msg='interface you are trying to default does not exist')
-
-    return commands, commands2
-
-
-def map_params_to_obj(module):
-    obj = []
-    aggregate = module.params.get('aggregate')
-    if aggregate:
-        for item in aggregate:
-            for key in item:
-                if item.get(key) is None:
-                    item[key] = module.params[key]
-
-            d = item.copy()
-            name = d['name']
-            d['name'] = normalize_interface(name)
-            obj.append(d)
-
-    else:
-        obj.append({
-            'name': normalize_interface(module.params['name']),
-            'description': module.params['description'],
-            'speed': module.params['speed'],
-            'mode': module.params['mode'],
-            'mtu': module.params['mtu'],
-            'duplex': module.params['duplex'],
-            'ip_forward': module.params['ip_forward'],
-            'fabric_forwarding_anycast_gateway': module.params['fabric_forwarding_anycast_gateway'],
-            'admin_state': module.params['admin_state'],
-            'state': module.params['state'],
-            'interface_type': module.params['interface_type'],
-            'tx_rate': module.params['tx_rate'],
-            'rx_rate': module.params['rx_rate'],
-            'neighbors': module.params['neighbors']
-        })
-
-    return obj
-
-
-def map_config_to_obj(want, module):
-    objs = list()
-
-    for w in want:
-        obj = dict(name=None, description=None, admin_state=None, speed=None,
-                   mtu=None, mode=None, duplex=None, interface_type=None,
-                   ip_forward=None, fabric_forwarding_anycast_gateway=None)
-
-        if not w['name']:
-            return obj
-
-        command = 'show interface {0}'.format(w['name'])
-        try:
-            body = execute_show_command(command, module)[0]
-        except IndexError:
-            return list()
-        if body:
-            try:
-                interface_table = body['TABLE_interface']['ROW_interface']
-            except (KeyError, TypeError):
-                return list()
-
-            if interface_table:
-                if interface_table.get('eth_mode') == 'fex-fabric':
-                    module.fail_json(msg='nxos_interface does not support interfaces with mode "fex-fabric"')
-
-                intf_type = get_interface_type(w['name'])
-
-                if intf_type in ['portchannel', 'ethernet']:
-                    mode = interface_table.get('eth_mode')
-                    if mode in ('access', 'trunk', 'dot1q-tunnel'):
-                        obj['mode'] = 'layer2'
-                    elif mode in ('routed', 'layer3'):
-                        obj['mode'] = 'layer3'
-                    else:
-                        obj['mode'] = 'layer3'
-
-                if intf_type == 'ethernet':
-                    obj['name'] = normalize_interface(interface_table.get('interface'))
-                    obj['admin_state'] = interface_table.get('admin_state')
-                    obj['description'] = interface_table.get('desc')
-                    obj['mtu'] = interface_table.get('eth_mtu')
-                    obj['duplex'] = interface_table.get('eth_duplex')
-
-                    command = 'show run interface {0}'.format(obj['name'])
-                    body = execute_show_command(command, module)[0]
-
-                    speed_match = re.search(r'speed (\d+)', body)
-                    if speed_match is None:
-                        obj['speed'] = 'auto'
-                    else:
-                        obj['speed'] = speed_match.group(1)
-
-                    duplex_match = re.search(r'duplex (\S+)', body)
-                    if duplex_match is None:
-                        obj['duplex'] = 'auto'
-                    else:
-                        obj['duplex'] = duplex_match.group(1)
-
-                    if 'ip forward' in body:
-                        obj['ip_forward'] = 'enable'
-                    else:
-                        obj['ip_forward'] = 'disable'
-
-                elif intf_type == 'svi':
-                    obj['name'] = normalize_interface(interface_table.get('interface'))
-                    attributes = get_vlan_interface_attributes(obj['name'], intf_type, module)
-                    obj['admin_state'] = str(attributes.get('admin_state',
-                                                            'nxapibug'))
-                    obj['description'] = str(attributes.get('description',
-                                                            'nxapi_bug'))
-                    obj['mtu'] = interface_table.get('svi_mtu')
-
-                    command = 'show run interface {0}'.format(obj['name'])
-                    body = execute_show_command(command, module)[0]
-                    if 'ip forward' in body:
-                        obj['ip_forward'] = 'enable'
-                    else:
-                        obj['ip_forward'] = 'disable'
-                    if 'fabric forwarding mode anycast-gateway' in body:
-                        obj['fabric_forwarding_anycast_gateway'] = True
-                    else:
-                        obj['fabric_forwarding_anycast_gateway'] = False
-
-                elif intf_type in ('loopback', 'management', 'nve'):
-                    obj['name'] = normalize_interface(interface_table.get('interface'))
-                    obj['admin_state'] = interface_table.get('admin_state')
-                    if obj['admin_state'] is None and intf_type == 'loopback':
-                        # Some platforms don't have the 'admin_state' key.
-                        # For loopback interfaces it's safe to use the
-                        # 'state' key instead.
-                        obj['admin_state'] = interface_table.get('state')
-                    obj['description'] = interface_table.get('desc')
-
-                elif intf_type == 'portchannel':
-                    obj['name'] = normalize_interface(interface_table.get('interface'))
-                    obj['admin_state'] = interface_table.get('admin_state')
-                    obj['description'] = interface_table.get('desc')
-                    obj['mtu'] = interface_table.get('eth_mtu')
-
-                if obj['admin_state'] is None:
-                    # Some nxos platforms do not have the 'admin_state' key.
-                    # Use the 'state_rsn_desc' key instead to determine the
-                    # admin state of the interface.
-                    state_description = interface_table.get('state_rsn_desc')
-                    if state_description == 'Administratively down':
-                        obj['admin_state'] = 'down'
-                    elif state_description is not None:
-                        obj['admin_state'] = 'up'
-
-        objs.append(obj)
-
-    return objs
-
-
-def check_declarative_intent_params(module, want):
-    failed_conditions = []
-    have_neighbors = None
-    for w in want:
-        if w['interface_type']:
-            continue
-        want_tx_rate = w.get('tx_rate')
-        want_rx_rate = w.get('rx_rate')
-        want_neighbors = w.get('neighbors')
-        if not (want_tx_rate or want_rx_rate or want_neighbors):
-            continue
-
-        time.sleep(module.params['delay'])
-
-        cmd = [{'command': 'show interface {0}'.format(w['name']), 'output': 'text'}]
-
-        try:
-            out = run_commands(module, cmd, check_rc=False)[0]
-        except (AttributeError, IndexError, TypeError):
-            out = ''
-
-        if want_tx_rate:
-            match = re.search(r'output rate (\d+)', out, re.M)
-            have_tx_rate = None
-
-            if match:
-                have_tx_rate = match.group(1)
-
-            if have_tx_rate is None or not conditional(want_tx_rate, have_tx_rate.strip(), cast=int):
-                failed_conditions.append('tx_rate ' + want_tx_rate)
-
-        if want_rx_rate:
-            match = re.search(r'input rate (\d+)', out, re.M)
-            have_rx_rate = None
-
-            if match:
-                have_rx_rate = match.group(1)
-
-            if have_rx_rate is None or not conditional(want_rx_rate, have_rx_rate.strip(), cast=int):
-                failed_conditions.append('rx_rate ' + want_rx_rate)
-
-        if want_neighbors:
-            have_host = []
-            have_port = []
-            if have_neighbors is None:
-                cmd = [{'command': 'show lldp neighbors interface {0} detail'.format(w['name']), 'output': 'text'}]
-                output = run_commands(module, cmd, check_rc=False)
-                if output:
-                    have_neighbors = output[0]
-                else:
-                    have_neighbors = ''
-                if have_neighbors and 'Total entries displayed: 0' not in have_neighbors:
-                    for line in have_neighbors.strip().split('\n'):
-                        if line.startswith('Port Description'):
-                            have_port.append(line.split(': ')[1])
-                        if line.startswith('System Name'):
-                            have_host.append(line.split(': ')[1])
-
-            for item in want_neighbors:
-                host = item.get('host')
-                port = item.get('port')
-                if host and host not in have_host:
-                    failed_conditions.append('host ' + host)
-                if port and port not in have_port:
-                    failed_conditions.append('port ' + port)
-
-    return failed_conditions
-
-
-def main():
-    """ main entry point for module execution
-    """
-    neighbors_spec = dict(
-        host=dict(),
-        port=dict()
-    )
-
-    element_spec = dict(
-        name=dict(aliases=['interface']),
-        admin_state=dict(default='up', choices=['up', 'down']),
-        description=dict(),
-        speed=dict(),
-        mode=dict(choices=['layer2', 'layer3']),
-        mtu=dict(),
-        duplex=dict(choices=['full', 'half', 'auto']),
-        interface_type=dict(choices=['loopback', 'portchannel', 'svi', 'nve']),
-        ip_forward=dict(choices=['enable', 'disable']),
-        fabric_forwarding_anycast_gateway=dict(type='bool'),
-        tx_rate=dict(),
-        rx_rate=dict(),
-        neighbors=dict(type='list', elements='dict', options=neighbors_spec),
-        delay=dict(default=10, type='int'),
-        state=dict(choices=['absent', 'present', 'default'], default='present')
-    )
-
-    aggregate_spec = deepcopy(element_spec)
-    aggregate_spec['name'] = dict(required=True)
-
-    # remove default in aggregate spec, to handle common arguments
-    remove_default_spec(aggregate_spec)
-
-    argument_spec = dict(
-        aggregate=dict(type='list', elements='dict', options=aggregate_spec,
-                       mutually_exclusive=[['name', 'interface_type']])
-    )
-
-    argument_spec.update(element_spec)
-    argument_spec.update(nxos_argument_spec)
-
-    required_one_of = [['name', 'aggregate', 'interface_type']]
-    mutually_exclusive = [['name', 'aggregate'],
-                          ['name', 'interface_type']]
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           required_one_of=required_one_of,
-                           mutually_exclusive=mutually_exclusive,
-                           supports_check_mode=True)
-    warnings = list()
-
-    result = {'changed': False}
-    if warnings:
-        result['warnings'] = warnings
-
-    want = map_params_to_obj(module)
-    have = map_config_to_obj(want, module)
-
-    commands = []
-    commands1, commands2 = map_obj_to_commands((want, have), module)
-    commands.extend(commands1)
-
-    if commands:
-        if not module.check_mode:
-            load_config(module, commands)
-            result['changed'] = True
-            # if the mode changes from L2 to L3, the admin state
-            # seems to change after the API call, so adding a second API
-            # call to ensure it's in the desired state.
-            if commands2:
-                load_config(module, commands2)
-                commands.extend(commands2)
-            commands = [cmd for cmd in commands if cmd != 'configure']
-    result['commands'] = commands
-
-    if result['changed']:
-        failed_conditions = check_declarative_intent_params(module, want)
-
-        if failed_conditions:
-            msg = 'One or more conditional statements have not been satisfied'
-            module.fail_json(msg=msg, failed_conditions=failed_conditions)
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/_nxos_l2_interface.py b/lib/ansible/modules/network/nxos/_nxos_l2_interface.py
deleted file mode 100644
index 9ff0f8b574..0000000000
--- a/lib/ansible/modules/network/nxos/_nxos_l2_interface.py
+++ /dev/null
@@ -1,578 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-
-# (c) 2017, Ansible by Red Hat, inc
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['deprecated'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = """
----
-module: nxos_l2_interface
-extends_documentation_fragment: nxos
-version_added: "2.5"
-short_description: Manage Layer-2 interface on Cisco NXOS devices.
-description:
-  - This module provides declarative management of Layer-2 interface on
-    Cisco NXOS devices.
-deprecated:
-  removed_in: '2.13'
-  alternative: nxos_l2_interfaces
-  why: Updated modules released with more functionality
-author:
-  - Trishna Guha (@trishnaguha)
-notes:
-  - Tested against NXOSv 7.0(3)I5(1).
-options:
-  name:
-    description:
-      - Full name of the interface excluding any logical
-        unit number, i.e. Ethernet1/1.
-    required: true
-    aliases: ['interface']
-  mode:
-    description:
-      - Mode in which interface needs to be configured.
-    choices: ['access','trunk']
-  access_vlan:
-    description:
-      - Configure given VLAN in access port.
-        If C(mode=access), used as the access VLAN ID.
-  native_vlan:
-    description:
-      - Native VLAN to be configured in trunk port.
-        If C(mode=trunk), used as the trunk native VLAN ID.
-  trunk_vlans:
-    description:
-      - List of VLANs to be configured in trunk port.
-        If C(mode=trunk), used as the VLAN range to ADD or REMOVE
-        from the trunk.
-    aliases: ['trunk_add_vlans']
-  trunk_allowed_vlans:
-    description:
-      - List of allowed VLANs in a given trunk port.
-        If C(mode=trunk), these are the only VLANs that will be
-        configured on the trunk, i.e. "2-10,15".
-  aggregate:
-    description:
-      - List of Layer-2 interface definitions.
-  state:
-    description:
-      - Manage the state of the Layer-2 Interface configuration.
-    default:  present
-    choices: ['present','absent', 'unconfigured']
-"""
-
-EXAMPLES = """
-- name: Ensure Eth1/5 is in its default l2 interface state
-  nxos_l2_interface:
-    name: Ethernet1/5
-    state: unconfigured
-
-- name: Ensure Eth1/5 is configured for access vlan 20
-  nxos_l2_interface:
-    name: Ethernet1/5
-    mode: access
-    access_vlan: 20
-
-- name: Ensure Eth1/5 only has vlans 5-10 as trunk vlans
-  nxos_l2_interface:
-    name: Ethernet1/5
-    mode: trunk
-    native_vlan: 10
-    trunk_vlans: 5-10
-
-- name: Ensure eth1/5 is a trunk port and ensure 2-50 are being tagged (doesn't mean others aren't also being tagged)
-  nxos_l2_interface:
-    name: Ethernet1/5
-    mode: trunk
-    native_vlan: 10
-    trunk_vlans: 2-50
-
-- name: Ensure these VLANs are not being tagged on the trunk
-  nxos_l2_interface:
-    name: Ethernet1/5
-    mode: trunk
-    trunk_vlans: 51-4094
-    state: absent
-
--  name: Aggregate Configure interfaces for access_vlan with aggregate
-   nxos_l2_interface:
-     aggregate:
-       - { name: "Ethernet1/2", access_vlan: 6 }
-       - { name: "Ethernet1/7", access_vlan: 15 }
-     mode: access
-"""
-
-RETURN = """
-commands:
-  description: The list of configuration mode commands to send to the device
-  returned: always, except for the platforms that use Netconf transport to manage the device.
-  type: list
-  sample:
-    - interface eth1/5
-    - switchport access vlan 20
-"""
-
-from copy import deepcopy
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec, get_interface_type
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.utils import remove_default_spec
-
-
-def get_interface_mode(name, module):
-    """Gets current mode of interface: layer2 or layer3
-    Args:
-        device (Device): This is the device object of an NX-API enabled device
-            using the Device class within device.py
-        interface (string): full name of interface, i.e. Ethernet1/1,
-            loopback10, port-channel20, vlan20
-    Returns:
-        str: 'layer2' or 'layer3'
-    """
-    command = 'show interface {0} | json'.format(name)
-    intf_type = get_interface_type(name)
-    mode = 'unknown'
-    interface_table = {}
-
-    try:
-        body = run_commands(module, [command])[0]
-        interface_table = body['TABLE_interface']['ROW_interface']
-    except (KeyError, AttributeError, IndexError):
-        return mode
-
-    if interface_table:
-        # HACK FOR NOW
-        if intf_type in ['ethernet', 'portchannel']:
-            mode = str(interface_table.get('eth_mode', 'layer3'))
-            if mode in ['access', 'trunk']:
-                mode = 'layer2'
-            if mode == 'routed':
-                mode = 'layer3'
-        elif intf_type == 'loopback' or intf_type == 'svi':
-            mode = 'layer3'
-    return mode
-
-
-def interface_is_portchannel(name, module):
-    """Checks to see if an interface is part of portchannel bundle
-    Args:
-        interface (str): full name of interface, i.e. Ethernet1/1
-    Returns:
-        True/False based on if interface is a member of a portchannel bundle
-    """
-    intf_type = get_interface_type(name)
-
-    if intf_type == 'ethernet':
-        command = 'show interface {0} | json'.format(name)
-        try:
-            body = run_commands(module, [command])[0]
-            interface_table = body['TABLE_interface']['ROW_interface']
-        except (KeyError, AttributeError, IndexError):
-            interface_table = None
-
-        if interface_table:
-            state = interface_table.get('eth_bundle')
-            if state:
-                return True
-            else:
-                return False
-
-    return False
-
-
-def get_switchport(port, module):
-    """Gets current config of L2 switchport
-    Args:
-        device (Device): This is the device object of an NX-API enabled device
-            using the Device class within device.py
-        port (str): full name of interface, i.e. Ethernet1/1
-    Returns:
-        dictionary with k/v pairs for L2 vlan config
-    """
-
-    command = 'show interface {0} switchport | json'.format(port)
-
-    try:
-        body = run_commands(module, [command])[0]
-        sp_table = body['TABLE_interface']['ROW_interface']
-    except (KeyError, AttributeError, IndexError):
-        sp_table = None
-
-    if sp_table:
-        key_map = {
-            "interface": "name",
-            "oper_mode": "mode",
-            "switchport": "switchport",
-            "access_vlan": "access_vlan",
-            "access_vlan_name": "access_vlan_name",
-            "native_vlan": "native_vlan",
-            "native_vlan_name": "native_vlan_name",
-            "trunk_vlans": "trunk_vlans"
-        }
-        sp = apply_key_map(key_map, sp_table)
-        return sp
-
-    else:
-        return {}
-
-
-def remove_switchport_config_commands(name, existing, proposed, module):
-    mode = proposed.get('mode')
-    commands = []
-    command = None
-
-    if mode == 'access':
-        av_check = existing.get('access_vlan') == proposed.get('access_vlan')
-        if av_check:
-            command = 'no switchport access vlan {0}'.format(existing.get('access_vlan'))
-            commands.append(command)
-
-    elif mode == 'trunk':
-        existing_vlans = existing.get('trunk_vlans_list')
-        proposed_vlans = proposed.get('trunk_vlans_list')
-        vlans_to_remove = set(proposed_vlans).intersection(existing_vlans)
-
-        if vlans_to_remove:
-            proposed_allowed_vlans = proposed.get('trunk_allowed_vlans')
-            remove_trunk_allowed_vlans = proposed.get('trunk_vlans', proposed_allowed_vlans)
-            command = 'switchport trunk allowed vlan remove {0}'.format(remove_trunk_allowed_vlans)
-            commands.append(command)
-
-        native_check = existing.get('native_vlan') == proposed.get('native_vlan')
-        if native_check and proposed.get('native_vlan'):
-            command = 'no switchport trunk native vlan {0}'.format(existing.get('native_vlan'))
-            commands.append(command)
-
-    if commands:
-        commands.insert(0, 'interface ' + name)
-    return commands
-
-
-def get_switchport_config_commands(name, existing, proposed, module):
-    """Gets commands required to config a given switchport interface
-    """
-
-    proposed_mode = proposed.get('mode')
-    existing_mode = existing.get('mode')
-    commands = []
-    command = None
-
-    if proposed_mode != existing_mode:
-        if proposed_mode == 'trunk':
-            command = 'switchport mode trunk'
-        elif proposed_mode == 'access':
-            command = 'switchport mode access'
-
-    if command:
-        commands.append(command)
-
-    if proposed_mode == 'access':
-        av_check = str(existing.get('access_vlan')) == str(proposed.get('access_vlan'))
-        if not av_check:
-            command = 'switchport access vlan {0}'.format(proposed.get('access_vlan'))
-            commands.append(command)
-
-    elif proposed_mode == 'trunk':
-        tv_check = existing.get('trunk_vlans_list') == proposed.get('trunk_vlans_list')
-
-        if not tv_check:
-            if proposed.get('allowed'):
-                command = 'switchport trunk allowed vlan {0}'.format(proposed.get('trunk_allowed_vlans'))
-                commands.append(command)
-
-            else:
-                existing_vlans = existing.get('trunk_vlans_list')
-                proposed_vlans = proposed.get('trunk_vlans_list')
-                vlans_to_add = set(proposed_vlans).difference(existing_vlans)
-                if vlans_to_add:
-                    command = 'switchport trunk allowed vlan add {0}'.format(proposed.get('trunk_vlans'))
-                    commands.append(command)
-
-        native_check = str(existing.get('native_vlan')) == str(proposed.get('native_vlan'))
-        if not native_check and proposed.get('native_vlan'):
-            command = 'switchport trunk native vlan {0}'.format(proposed.get('native_vlan'))
-            commands.append(command)
-
-    if commands:
-        commands.insert(0, 'interface ' + name)
-    return commands
-
-
-def is_switchport_default(existing):
-    """Determines if switchport has a default config based on mode
-    Args:
-        existing (dict): existing switchport configuration from Ansible mod
-    Returns:
-        boolean: True if switchport has OOB Layer 2 config, i.e.
-           vlan 1 and trunk all and mode is access
-    """
-
-    c1 = str(existing['access_vlan']) == '1'
-    c2 = str(existing['native_vlan']) == '1'
-    c3 = existing['trunk_vlans'] == '1-4094'
-    c4 = existing['mode'] == 'access'
-
-    default = c1 and c2 and c3 and c4
-
-    return default
-
-
-def default_switchport_config(name):
-    commands = []
-    commands.append('interface ' + name)
-    commands.append('switchport mode access')
-    commands.append('switch access vlan 1')
-    commands.append('switchport trunk native vlan 1')
-    commands.append('switchport trunk allowed vlan all')
-    return commands
-
-
-def vlan_range_to_list(vlans):
-    result = []
-    if vlans:
-        for part in vlans.split(','):
-            if part == 'none':
-                break
-            if '-' in part:
-                a, b = part.split('-')
-                a, b = int(a), int(b)
-                result.extend(range(a, b + 1))
-            else:
-                a = int(part)
-                result.append(a)
-        return numerical_sort(result)
-    return result
-
-
-def get_list_of_vlans(module):
-
-    command = 'show vlan | json'
-    vlan_list = []
-
-    try:
-        body = run_commands(module, [command])[0]
-        vlan_table = body['TABLE_vlanbrief']['ROW_vlanbrief']
-    except (KeyError, AttributeError, IndexError):
-        return []
-
-    if isinstance(vlan_table, list):
-        for vlan in vlan_table:
-            vlan_list.append(str(vlan['vlanshowbr-vlanid-utf']))
-    else:
-        vlan_list.append('1')
-
-    return vlan_list
-
-
-def numerical_sort(string_int_list):
-    """Sorts list of strings/integers that are digits in numerical order.
-    """
-
-    as_int_list = []
-    as_str_list = []
-    for vlan in string_int_list:
-        as_int_list.append(int(vlan))
-    as_int_list.sort()
-    for vlan in as_int_list:
-        as_str_list.append(str(vlan))
-    return as_str_list
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key, value in table.items():
-        new_key = key_map.get(key)
-        if new_key:
-            new_dict[new_key] = str(value)
-    return new_dict
-
-
-def apply_value_map(value_map, resource):
-    for key, value in value_map.items():
-        resource[key] = value[resource.get(key)]
-    return resource
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def map_params_to_obj(module):
-    obj = []
-    aggregate = module.params.get('aggregate')
-    if aggregate:
-        for item in aggregate:
-            for key in item:
-                if item.get(key) is None:
-                    item[key] = module.params[key]
-
-            d = item.copy()
-            obj.append(d)
-    else:
-        obj.append({
-            'name': module.params['name'],
-            'mode': module.params['mode'],
-            'access_vlan': module.params['access_vlan'],
-            'native_vlan': module.params['native_vlan'],
-            'trunk_vlans': module.params['trunk_vlans'],
-            'trunk_allowed_vlans': module.params['trunk_allowed_vlans'],
-            'state': module.params['state']
-        })
-
-    return obj
-
-
-def main():
-    """ main entry point for module execution
-    """
-    element_spec = dict(
-        name=dict(type='str', aliases=['interface']),
-        mode=dict(choices=['access', 'trunk']),
-        access_vlan=dict(type='str'),
-        native_vlan=dict(type='str'),
-        trunk_vlans=dict(type='str', aliases=['trunk_add_vlans']),
-        trunk_allowed_vlans=dict(type='str'),
-        state=dict(choices=['absent', 'present', 'unconfigured'], default='present')
-    )
-
-    aggregate_spec = deepcopy(element_spec)
-
-    # remove default in aggregate spec, to handle common arguments
-    remove_default_spec(aggregate_spec)
-
-    argument_spec = dict(
-        aggregate=dict(type='list', elements='dict', options=aggregate_spec),
-    )
-
-    argument_spec.update(element_spec)
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           mutually_exclusive=[['access_vlan', 'trunk_vlans'],
-                                               ['access_vlan', 'native_vlan'],
-                                               ['access_vlan', 'trunk_allowed_vlans']],
-                           supports_check_mode=True)
-
-    warnings = list()
-    commands = []
-    result = {'changed': False}
-    if warnings:
-        result['warnings'] = warnings
-
-    want = map_params_to_obj(module)
-    for w in want:
-        name = w['name']
-        mode = w['mode']
-        access_vlan = w['access_vlan']
-        state = w['state']
-        trunk_vlans = w['trunk_vlans']
-        native_vlan = w['native_vlan']
-        trunk_allowed_vlans = w['trunk_allowed_vlans']
-
-        args = dict(name=name, mode=mode, access_vlan=access_vlan,
-                    native_vlan=native_vlan, trunk_vlans=trunk_vlans,
-                    trunk_allowed_vlans=trunk_allowed_vlans)
-
-        proposed = dict((k, v) for k, v in args.items() if v is not None)
-
-        name = name.lower()
-
-        if mode == 'access' and state == 'present' and not access_vlan:
-            module.fail_json(msg='access_vlan param is required when mode=access && state=present')
-
-        if mode == 'trunk' and access_vlan:
-            module.fail_json(msg='access_vlan param not supported when using mode=trunk')
-
-        current_mode = get_interface_mode(name, module)
-
-        # Current mode will return layer3, layer2, or unknown
-        if current_mode == 'unknown' or current_mode == 'layer3':
-            module.fail_json(msg='Ensure interface is configured to be a L2'
-                             '\nport first before using this module. You can use'
-                             '\nthe nxos_interface module for this.')
-
-        if interface_is_portchannel(name, module):
-            module.fail_json(msg='Cannot change L2 config on physical '
-                             '\nport because it is in a portchannel. '
-                             '\nYou should update the portchannel config.')
-
-        # existing will never be null for Eth intfs as there is always a default
-        existing = get_switchport(name, module)
-
-        # Safeguard check
-        # If there isn't an existing, something is wrong per previous comment
-        if not existing:
-            module.fail_json(msg='Make sure you are using the FULL interface name')
-
-        if trunk_vlans or trunk_allowed_vlans:
-            if trunk_vlans:
-                trunk_vlans_list = vlan_range_to_list(trunk_vlans)
-            elif trunk_allowed_vlans:
-                trunk_vlans_list = vlan_range_to_list(trunk_allowed_vlans)
-                proposed['allowed'] = True
-
-            existing_trunks_list = vlan_range_to_list((existing['trunk_vlans']))
-
-            existing['trunk_vlans_list'] = existing_trunks_list
-            proposed['trunk_vlans_list'] = trunk_vlans_list
-
-        current_vlans = get_list_of_vlans(module)
-
-        if state == 'present':
-            if access_vlan and access_vlan not in current_vlans:
-                module.fail_json(msg='You are trying to configure a VLAN'
-                                 ' on an interface that\ndoes not exist on the '
-                                 ' switch yet!', vlan=access_vlan)
-            elif native_vlan and native_vlan not in current_vlans:
-                module.fail_json(msg='You are trying to configure a VLAN'
-                                 ' on an interface that\ndoes not exist on the '
-                                 ' switch yet!', vlan=native_vlan)
-            else:
-                command = get_switchport_config_commands(name, existing, proposed, module)
-                commands.append(command)
-        elif state == 'unconfigured':
-            is_default = is_switchport_default(existing)
-            if not is_default:
-                command = default_switchport_config(name)
-                commands.append(command)
-        elif state == 'absent':
-            command = remove_switchport_config_commands(name, existing, proposed, module)
-            commands.append(command)
-
-        if trunk_vlans or trunk_allowed_vlans:
-            existing.pop('trunk_vlans_list')
-            proposed.pop('trunk_vlans_list')
-
-    cmds = flatten_list(commands)
-    if cmds:
-        if module.check_mode:
-            module.exit_json(changed=True, commands=cmds)
-        else:
-            result['changed'] = True
-            load_config(module, cmds)
-            if 'configure' in cmds:
-                cmds.pop(0)
-
-    result['commands'] = cmds
-    result['warnings'] = warnings
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/_nxos_l3_interface.py b/lib/ansible/modules/network/nxos/_nxos_l3_interface.py
deleted file mode 100644
index 2422dea0d9..0000000000
--- a/lib/ansible/modules/network/nxos/_nxos_l3_interface.py
+++ /dev/null
@@ -1,251 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-
-# (c) 2017, Ansible by Red Hat, inc
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['deprecated'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = """
----
-module: nxos_l3_interface
-version_added: "2.5"
-author: "Trishna Guha (@trishnaguha)"
-short_description: Manage L3 interfaces on Cisco NXOS network devices
-description:
-  - This module provides declarative management of L3 interfaces
-    on Cisco NXOS network devices.
-deprecated:
-  removed_in: '2.13'
-  alternative: nxos_l3_interfaces
-  why: Updated modules released with more functionality
-notes:
-  - Tested against NXOSv 7.0(3)I5(1).
-options:
-  name:
-    description:
-      - Name of the L3 interface.
-  ipv4:
-    description:
-      - IPv4 of the L3 interface.
-  ipv6:
-    description:
-      - IPv6 of the L3 interface.
-  aggregate:
-    description: List of L3 interfaces definitions.
-  state:
-    description:
-      - State of the L3 interface configuration.
-    default: present
-    choices: ['present', 'absent']
-extends_documentation_fragment: nxos
-"""
-
-EXAMPLES = """
-- name: Set interface IPv4 address
-  nxos_l3_interface:
-    name: Ethernet2/3
-    ipv4: 192.168.0.1/24
-
-- name: Remove interface IPv4 address
-  nxos_l3_interface:
-    name: Ethernet2/3
-    state: absent
-
-- name: Set IP addresses on aggregate
-  nxos_l3_interface:
-    aggregate:
-      - { name: Ethernet2/1, ipv4: 192.168.2.10/24 }
-      - { name: Ethernet2/5, ipv4: 192.168.3.10/24, ipv6: "fd5d:12c9:2201:1::1/64" }
-
-- name: Remove IP addresses on aggregate
-  nxos_l3_interface:
-    aggregate:
-      - { name: Ethernet2/1, ipv4: 192.168.2.10/24 }
-      - { name: Ethernet2/5, ipv4: 192.168.3.10/24, ipv6: "fd5d:12c9:2201:1::1/64" }
-    state: absent
-"""
-
-RETURN = """
-commands:
-  description: The list of configuration mode commands to send to the device
-  returned: always, except for the platforms that use Netconf transport to manage the device.
-  type: list
-  sample:
-    - interface ethernet2/3
-    - no switchport
-    - ip address 192.168.22.1/24
-    - ipv6 address "fd5d:12c9:2201:1::1/64"
-    - no ip address 192.168.22.1/24
-"""
-
-import re
-
-from copy import deepcopy
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-from ansible.module_utils.network.common.utils import remove_default_spec
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec, normalize_interface
-
-
-def search_obj_in_list(name, lst):
-    for o in lst:
-        if o['name'] == name:
-            return o
-
-
-def map_obj_to_commands(updates, module, warnings):
-    commands = list()
-    want, have = updates
-
-    for w in want:
-        name = w['name']
-        ipv4 = w['ipv4']
-        ipv6 = w['ipv6']
-        state = w['state']
-        del w['state']
-
-        obj_in_have = search_obj_in_list(name, have)
-
-        if not obj_in_have:
-            warnings.append('Unknown interface {0}'.format(name))
-        elif state == 'absent':
-            command = []
-            if obj_in_have['name'] == name:
-                if ipv4 and ipv4 == obj_in_have['ipv4']:
-                    command.append('no ip address {0}'.format(ipv4))
-                if ipv6 and ipv6 in obj_in_have['ipv6']:
-                    command.append('no ipv6 address {0}'.format(ipv6))
-                if command:
-                    command.append('exit')
-                    command.insert(0, 'interface {0}'.format(name))
-            commands.extend(command)
-
-        elif state == 'present':
-            command = []
-            if obj_in_have['name'] == name:
-                if ipv4 and ipv4 != obj_in_have['ipv4']:
-                    command.append('ip address {0}'.format(ipv4))
-                if ipv6 and ipv6 not in obj_in_have['ipv6']:
-                    command.append('ipv6 address {0}'.format(ipv6))
-                if command:
-                    command.append('exit')
-                    command.insert(0, 'interface {0}'.format(name))
-                elif not ipv4 and not ipv6:
-                    command.append('interface {0}'.format(name))
-            commands.extend(command)
-
-    return commands
-
-
-def map_params_to_obj(module):
-    obj = []
-
-    aggregate = module.params.get('aggregate')
-    if aggregate:
-        for item in aggregate:
-            for key in item:
-                if item.get(key) is None:
-                    item[key] = module.params[key]
-
-            d = item.copy()
-            name = d['name']
-            d['name'] = normalize_interface(name)
-            obj.append(d)
-
-    else:
-        obj.append({
-            'name': normalize_interface(module.params['name']),
-            'ipv4': module.params['ipv4'],
-            'ipv6': module.params['ipv6'],
-            'state': module.params['state']
-        })
-
-    return obj
-
-
-def map_config_to_obj(want, module):
-    objs = list()
-    netcfg = CustomNetworkConfig(indent=2, contents=get_config(module))
-
-    for w in want:
-        parents = ['interface {0}'.format(w['name'])]
-        config = netcfg.get_section(parents)
-        obj = dict(name=None, ipv4=None, ipv6=[])
-
-        if config:
-            match_name = re.findall(r'interface (\S+)', config, re.M)
-            if match_name:
-                obj['name'] = normalize_interface(match_name[0])
-
-            match_ipv4 = re.findall(r'ip address (\S+)', config, re.M)
-            if match_ipv4:
-                obj['ipv4'] = match_ipv4[0]
-
-            match_ipv6 = re.findall(r'ipv6 address (\S+)', config, re.M)
-            if match_ipv6:
-                obj['ipv6'] = match_ipv6
-
-            objs.append(obj)
-    return objs
-
-
-def main():
-    """ main entry point for module execution
-    """
-    element_spec = dict(
-        name=dict(),
-        ipv4=dict(),
-        ipv6=dict(),
-        state=dict(default='present', choices=['present', 'absent'])
-    )
-
-    aggregate_spec = deepcopy(element_spec)
-
-    # remove default in aggregate spec, to handle common arguments
-    remove_default_spec(aggregate_spec)
-
-    argument_spec = dict(
-        aggregate=dict(type='list', elements='dict', options=aggregate_spec),
-    )
-
-    argument_spec.update(element_spec)
-    argument_spec.update(nxos_argument_spec)
-
-    required_one_of = [['name', 'aggregate']]
-    mutually_exclusive = [['name', 'aggregate']]
-    module = AnsibleModule(argument_spec=argument_spec,
-                           required_one_of=required_one_of,
-                           mutually_exclusive=mutually_exclusive,
-                           supports_check_mode=True)
-
-    warnings = list()
-    result = {'changed': False}
-
-    want = map_params_to_obj(module)
-    have = map_config_to_obj(want, module)
-
-    commands = map_obj_to_commands((want, have), module, warnings)
-    result['commands'] = commands
-
-    if warnings:
-        result['warnings'] = warnings
-    if commands:
-        if not module.check_mode:
-            load_config(module, commands)
-        result['changed'] = True
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/_nxos_linkagg.py b/lib/ansible/modules/network/nxos/_nxos_linkagg.py
deleted file mode 100644
index fc205f8f48..0000000000
--- a/lib/ansible/modules/network/nxos/_nxos_linkagg.py
+++ /dev/null
@@ -1,443 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-
-# (c) 2017, Ansible by Red Hat, inc
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['deprecated'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = """
----
-module: nxos_linkagg
-extends_documentation_fragment: nxos
-version_added: "2.5"
-short_description: Manage link aggregation groups on Cisco NXOS devices.
-description:
-  - This module provides declarative management of link aggregation groups
-    on Cisco NXOS devices.
-deprecated:
-  removed_in: '2.13'
-  alternative: nxos_lag_interfaces
-  why: Updated modules released with more functionality.
-author:
-  - Trishna Guha (@trishnaguha)
-notes:
-  - Tested against NXOSv 7.0(3)I5(1).
-  - C(state=absent) removes the portchannel config and interface if it
-    already exists. If members to be removed are not explicitly
-    passed, all existing members (if any), are removed.
-  - Members must be a list.
-  - LACP needs to be enabled first if active/passive modes are used.
-options:
-  group:
-    description:
-      - Channel-group number for the port-channel
-        Link aggregation group.
-    required: true
-    type: str
-  mode:
-    description:
-      - Mode for the link aggregation group.
-    choices: [ active, 'on', passive ]
-    default: 'on'
-    type: str
-  min_links:
-    description:
-      - Minimum number of ports required up
-        before bringing up the link aggregation group.
-    type: int
-  members:
-    description:
-      - List of interfaces that will be managed in the link aggregation group.
-    type: list
-  force:
-    description:
-      - When true it forces link aggregation group members to match what
-        is declared in the members param. This can be used to remove members.
-    type: bool
-    default: 'no'
-  aggregate:
-    description: List of link aggregation definitions.
-    type: list
-  state:
-    description:
-      - State of the link aggregation group.
-    default: present
-    choices: ['present','absent']
-    type: str
-  purge:
-    description:
-      - Purge links not defined in the I(aggregate) parameter.
-    type: bool
-    default: 'no'
-"""
-
-EXAMPLES = """
-- name: create link aggregation group
-  nxos_linkagg:
-    group: 99
-    state: present
-
-- name: delete link aggregation group
-  nxos_linkagg:
-    group: 99
-    state: absent
-
-- name: set link aggregation group to members
-  nxos_linkagg:
-    group: 10
-    min_links: 3
-    mode: active
-    members:
-      - Ethernet1/2
-      - Ethernet1/4
-
-- name: remove link aggregation group from Ethernet1/2
-  nxos_linkagg:
-    group: 10
-    min_links: 3
-    mode: active
-    members:
-      - Ethernet1/4
-
-- name: Create aggregate of linkagg definitions
-  nxos_linkagg:
-    aggregate:
-      - { group: 3 }
-      - { group: 100, min_links: 3 }
-
-- name: Remove aggregate of linkagg definitions
-  nxos_linkagg:
-    aggregate:
-      - { group: 3 }
-      - { group: 100, min_links: 3 }
-    state: absent
-"""
-
-RETURN = """
-commands:
-  description: The list of configuration mode commands to send to the device
-  returned: always, except for the platforms that use Netconf transport to manage the device.
-  type: list
-  sample:
-    - interface port-channel 30
-    - lacp min-links 5
-    - interface Ethernet2/1
-    - channel-group 30 mode active
-    - no interface port-channel 30
-"""
-
-import re
-from copy import deepcopy
-
-from ansible.module_utils.network.nxos.nxos import get_config, load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.network.nxos.nxos import normalize_interface
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.utils import remove_default_spec
-
-
-def search_obj_in_list(group, lst):
-    for o in lst:
-        if o['group'] == group:
-            return o
-
-
-def get_diff(w, obj):
-    c = deepcopy(w)
-    o = deepcopy(obj)
-
-    if o['group'] == c['group'] and o.get('members') == c.get('members'):
-        if 'members' in o:
-            del o['members']
-        if 'members' in c:
-            del c['members']
-        diff_dict = dict(set(c.items()) - set(o.items()))
-        return diff_dict
-
-
-def map_obj_to_commands(updates, module):
-    commands = list()
-    want, have = updates
-    purge = module.params['purge']
-    force = module.params['force']
-
-    for w in want:
-        group = w['group']
-        mode = w['mode']
-        min_links = w['min_links']
-        members = w.get('members') or []
-        state = w['state']
-        del w['state']
-
-        obj_in_have = search_obj_in_list(group, have)
-
-        if state == 'absent':
-            if obj_in_have:
-                members_to_remove = list(set(obj_in_have['members']) - set(members))
-                if members_to_remove:
-                    for m in members_to_remove:
-                        commands.append('interface {0}'.format(m))
-                        commands.append('no channel-group {0}'.format(obj_in_have['group']))
-                        commands.append('exit')
-                commands.append('no interface port-channel {0}'.format(group))
-
-        elif state == 'present':
-            if not obj_in_have:
-                commands.append('interface port-channel {0}'.format(group))
-                if min_links != 'None':
-                    commands.append('lacp min-links {0}'.format(min_links))
-                commands.append('exit')
-                if members:
-                    for m in members:
-                        commands.append('interface {0}'.format(m))
-                        if force:
-                            commands.append('channel-group {0} force mode {1}'.format(group, mode))
-                        else:
-                            commands.append('channel-group {0} mode {1}'.format(group, mode))
-
-            else:
-                if members:
-                    if not obj_in_have['members']:
-                        for m in members:
-                            commands.append('interface port-channel {0}'.format(group))
-                            commands.append('exit')
-                            commands.append('interface {0}'.format(m))
-                            if force:
-                                commands.append('channel-group {0} force mode {1}'.format(group, mode))
-                            else:
-                                commands.append('channel-group {0} mode {1}'.format(group, mode))
-
-                    elif set(members) != set(obj_in_have['members']):
-                        missing_members = list(set(members) - set(obj_in_have['members']))
-                        for m in missing_members:
-                            commands.append('interface port-channel {0}'.format(group))
-                            commands.append('exit')
-                            commands.append('interface {0}'.format(m))
-                            if force:
-                                commands.append('channel-group {0} force mode {1}'.format(group, mode))
-                            else:
-                                commands.append('channel-group {0} mode {1}'.format(group, mode))
-
-                        superfluous_members = list(set(obj_in_have['members']) - set(members))
-                        for m in superfluous_members:
-                            commands.append('interface port-channel {0}'.format(group))
-                            commands.append('exit')
-                            commands.append('interface {0}'.format(m))
-                            commands.append('no channel-group {0}'.format(group))
-
-                    else:
-                        diff = get_diff(w, obj_in_have)
-                        if diff and 'mode' in diff:
-                            mode = diff['mode']
-                            for i in members:
-                                commands.append('interface {0}'.format(i))
-                                if force:
-                                    commands.append('channel-group {0} force mode {1}'.format(group, mode))
-                                else:
-                                    commands.append('channel-group {0} mode {1}'.format(group, mode))
-
-    if purge:
-        for h in have:
-            obj_in_want = search_obj_in_list(h['group'], want)
-            if not obj_in_want:
-                commands.append('no interface port-channel {0}'.format(h['group']))
-
-    return commands
-
-
-def map_params_to_obj(module):
-    obj = []
-    aggregate = module.params.get('aggregate')
-    if aggregate:
-        for item in aggregate:
-            for key in item:
-                if item.get(key) is None:
-                    item[key] = module.params[key]
-
-            d = item.copy()
-            d['group'] = str(d['group'])
-            d['min_links'] = str(d['min_links'])
-            if d['members']:
-                d['members'] = [normalize_interface(i) for i in d['members']]
-
-            obj.append(d)
-    else:
-        members = None
-        if module.params['members']:
-            members = [normalize_interface(i) for i in module.params['members']]
-
-        obj.append({
-            'group': str(module.params['group']),
-            'mode': module.params['mode'],
-            'min_links': str(module.params['min_links']),
-            'members': members,
-            'state': module.params['state']
-        })
-
-    return obj
-
-
-def parse_min_links(module, group):
-    min_links = None
-
-    flags = ['| section interface.port-channel{0}'.format(group)]
-    config = get_config(module, flags=flags)
-    match = re.search(r'lacp min-links (\S+)', config, re.M)
-    if match:
-        min_links = match.group(1)
-
-    return min_links
-
-
-def parse_mode(module, m):
-    mode = None
-
-    flags = ['| section interface.{0}'.format(m)]
-    config = get_config(module, flags=flags)
-    match = re.search(r'channel-group [0-9]+ (force )?mode (\S+)', config, re.M)
-    if match:
-        mode = match.group(2)
-
-    return mode
-
-
-def get_members(channel):
-    members = []
-    if 'TABLE_member' in channel.keys():
-        interfaces = channel['TABLE_member']['ROW_member']
-    else:
-        return list()
-
-    if isinstance(interfaces, dict):
-        members.append(normalize_interface(interfaces.get('port')))
-    elif isinstance(interfaces, list):
-        for i in interfaces:
-            members.append(normalize_interface(i.get('port')))
-
-    return members
-
-
-def parse_members(output, group):
-    channels = output['TABLE_channel']['ROW_channel']
-
-    if isinstance(channels, list):
-        for channel in channels:
-            if channel['group'] == group:
-                members = get_members(channel)
-    elif isinstance(channels, dict):
-        if channels['group'] == group:
-            members = get_members(channels)
-    else:
-        return list()
-
-    return members
-
-
-def parse_channel_options(module, output, channel):
-    obj = {}
-
-    group = channel['group']
-    obj['group'] = str(group)
-    obj['min_links'] = parse_min_links(module, group)
-    members = parse_members(output, group)
-    obj['members'] = members
-    for m in members:
-        obj['mode'] = parse_mode(module, m)
-
-    return obj
-
-
-def map_config_to_obj(module):
-    objs = list()
-    output = run_commands(module, ['show port-channel summary | json'])[0]
-    if not output:
-        return list()
-
-    try:
-        channels = output['TABLE_channel']['ROW_channel']
-    except (TypeError, KeyError):
-        return objs
-
-    if channels:
-        if isinstance(channels, list):
-            for channel in channels:
-                obj = parse_channel_options(module, output, channel)
-                objs.append(obj)
-
-        elif isinstance(channels, dict):
-            obj = parse_channel_options(module, output, channels)
-            objs.append(obj)
-
-    return objs
-
-
-def main():
-    """ main entry point for module execution
-    """
-    element_spec = dict(
-        group=dict(type='str'),
-        mode=dict(required=False, choices=['on', 'active', 'passive'], default='on', type='str'),
-        min_links=dict(required=False, default=None, type='int'),
-        members=dict(required=False, default=None, type='list'),
-        force=dict(required=False, default=False, type='bool'),
-        state=dict(required=False, choices=['absent', 'present'], default='present')
-    )
-
-    aggregate_spec = deepcopy(element_spec)
-    aggregate_spec['group'] = dict(required=True)
-
-    # remove default in aggregate spec, to handle common arguments
-    remove_default_spec(aggregate_spec)
-
-    argument_spec = dict(
-        aggregate=dict(type='list', elements='dict', options=aggregate_spec),
-        purge=dict(default=False, type='bool')
-    )
-
-    argument_spec.update(element_spec)
-    argument_spec.update(nxos_argument_spec)
-
-    required_one_of = [['group', 'aggregate']]
-    mutually_exclusive = [['group', 'aggregate']]
-    module = AnsibleModule(argument_spec=argument_spec,
-                           required_one_of=required_one_of,
-                           mutually_exclusive=mutually_exclusive,
-                           supports_check_mode=True)
-
-    warnings = list()
-    result = {'changed': False}
-    if warnings:
-        result['warnings'] = warnings
-
-    want = map_params_to_obj(module)
-    have = map_config_to_obj(module)
-
-    commands = map_obj_to_commands((want, have), module)
-    result['commands'] = commands
-
-    if commands:
-        if not module.check_mode:
-            resp = load_config(module, commands, True)
-            if resp:
-                for item in resp:
-                    if item:
-                        if isinstance(item, dict):
-                            err_str = item['clierror']
-                        else:
-                            err_str = item
-                        if 'cannot add' in err_str.lower():
-                            module.fail_json(msg=err_str)
-        result['changed'] = True
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/_nxos_vlan.py b/lib/ansible/modules/network/nxos/_nxos_vlan.py
deleted file mode 100644
index c82ebaf23f..0000000000
--- a/lib/ansible/modules/network/nxos/_nxos_vlan.py
+++ /dev/null
@@ -1,712 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['deprecated'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = '''
----
-module: nxos_vlan
-extends_documentation_fragment: nxos
-version_added: "2.1"
-short_description: Manages VLAN resources and attributes.
-description:
-  - Manages VLAN configurations on NX-OS switches.
-deprecated:
-  removed_in: '2.13'
-  alternative: nxos_vlans
-  why: Updated modules released with more functionality
-author: Jason Edelman (@jedelman8)
-options:
-  vlan_id:
-    description:
-      - Single VLAN ID.
-    type: int
-  vlan_range:
-    description:
-      - Range of VLANs such as 2-10 or 2,5,10-15, etc.
-    type: str
-  name:
-    description:
-      - Name of VLAN or keyword 'default'.
-    type: str
-  interfaces:
-    description:
-      - List of interfaces that should be associated to the VLAN or keyword 'default'.
-    version_added: "2.5"
-    type: list
-  associated_interfaces:
-    description:
-      - This is a intent option and checks the operational state of the for given vlan C(name)
-        for associated interfaces. If the value in the C(associated_interfaces) does not match with
-        the operational state of vlan interfaces on device it will result in failure.
-    version_added: "2.5"
-    type: list
-  vlan_state:
-    description:
-      - Manage the vlan operational state of the VLAN
-    default: active
-    choices: ['active','suspend']
-    type: str
-  admin_state:
-    description:
-      - Manage the VLAN administrative state of the VLAN equivalent
-        to shut/no shut in VLAN config mode.
-    default: up
-    choices: ['up','down']
-    type: str
-  mapped_vni:
-    description:
-      - The Virtual Network Identifier (VNI) ID that is mapped to the
-        VLAN. Valid values are integer and keyword 'default'. Range 4096-16773119.
-    version_added: "2.2"
-    type: str
-  state:
-    description:
-      - Manage the state of the resource.
-    default: present
-    choices: ['present','absent']
-    type: str
-  mode:
-    description:
-      - Set VLAN mode to classical ethernet or fabricpath.
-        This is a valid option for Nexus 5000 and 7000 series.
-    choices: ['ce','fabricpath']
-    default: 'ce'
-    type: str
-    version_added: "2.4"
-  aggregate:
-    description: List of VLANs definitions.
-    version_added: "2.5"
-    type: list
-  purge:
-    description:
-      - Purge VLANs not defined in the I(aggregate) parameter.
-        This parameter can be used without aggregate as well.
-      - Removal of Vlan 1 is not allowed and will be ignored by purge.
-    type: bool
-    default: 'no'
-  delay:
-    description:
-      - Time in seconds to wait before checking for the operational state on remote
-        device. This wait is applicable for operational state arguments.
-    default: 10
-    type: int
-'''
-
-EXAMPLES = '''
-- name: Ensure a range of VLANs are not present on the switch
-  nxos_vlan:
-    vlan_range: "2-10,20,50,55-60,100-150"
-    state: absent
-
-- name: Ensure VLAN 50 exists with the name WEB and is in the shutdown state
-  nxos_vlan:
-    vlan_id: 50
-    admin_state: down
-    name: WEB
-
-- name: Ensure VLAN is NOT on the device
-  nxos_vlan:
-    vlan_id: 50
-    state: absent
-
-- name: Add interfaces to VLAN and check intent (config + intent)
-  nxos_vlan:
-    vlan_id: 100
-    interfaces:
-      - Ethernet2/1
-      - Ethernet2/5
-    associated_interfaces:
-      - Ethernet2/1
-      - Ethernet2/5
-
-- name: Check interfaces assigned to VLAN
-  nxos_vlan:
-    vlan_id: 100
-    associated_interfaces:
-      - Ethernet2/1
-      - Ethernet2/5
-
-- name: Create aggregate of vlans
-  nxos_vlan:
-    aggregate:
-      - { vlan_id: 4000, mode: ce }
-      - { vlan_id: 4001, name: vlan-4001 }
-
-- name: purge vlans - removes all other vlans except the ones mentioned in aggregate)
-  nxos_vlan:
-    aggregate:
-      - vlan_id: 1
-      - vlan_id: 4001
-    purge: yes
-
-'''
-
-RETURN = '''
-commands:
-    description: Set of command strings to send to the remote device
-    returned: always
-    type: list
-    sample: ["vlan 20", "vlan 55", "vn-segment 5000"]
-'''
-
-import re
-import time
-
-from copy import deepcopy
-
-from ansible.module_utils.network.nxos.nxos import get_capabilities
-from ansible.module_utils.network.nxos.nxos import get_config, load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import normalize_interface, nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-from ansible.module_utils.network.common.utils import remove_default_spec
-
-
-def search_obj_in_list(vlan_id, lst):
-    for o in lst:
-        if o['vlan_id'] == vlan_id:
-            return o
-
-
-def get_diff(w, obj):
-    c = deepcopy(w)
-    entries = ('interfaces', 'associated_interfaces', 'delay', 'vlan_range')
-    for key in entries:
-        if key in c:
-            del c[key]
-
-    o = deepcopy(obj)
-    del o['interfaces']
-    if o['vlan_id'] == w['vlan_id']:
-        diff_dict = dict(set(c.items()) - set(o.items()))
-        return diff_dict
-
-
-def is_default_name(obj, vlan_id):
-    cname = obj['name']
-    if ('VLAN' in cname):
-        vid = int(cname[4:])
-        if vid == int(vlan_id):
-            return True
-
-    return False
-
-
-def map_obj_to_commands(updates, module):
-    commands = list()
-    purge = module.params['purge']
-    want, have = updates
-    info = get_capabilities(module).get('device_info')
-    os_platform = info.get('network_os_platform')
-
-    for w in want:
-        vlan_id = w['vlan_id']
-        name = w['name']
-        interfaces = w.get('interfaces') or []
-        mapped_vni = w['mapped_vni']
-        mode = w['mode']
-        vlan_state = w['vlan_state']
-        admin_state = w['admin_state']
-        state = w['state']
-        del w['state']
-
-        obj_in_have = search_obj_in_list(vlan_id, have) or {}
-        if not re.match('N[567]', os_platform) or (not obj_in_have.get('mode') and mode == 'ce'):
-            mode = w['mode'] = None
-
-        if state == 'absent':
-            if obj_in_have:
-                commands.append('no vlan {0}'.format(vlan_id))
-
-        elif state == 'present':
-            if not obj_in_have:
-                commands.append('vlan {0}'.format(vlan_id))
-
-                if name and name != 'default':
-                    commands.append('name {0}'.format(name))
-                if mode:
-                    commands.append('mode {0}'.format(mode))
-                if vlan_state:
-                    commands.append('state {0}'.format(vlan_state))
-                if mapped_vni != 'None' and mapped_vni != 'default':
-                    commands.append('vn-segment {0}'.format(mapped_vni))
-                if admin_state == 'up':
-                    commands.append('no shutdown')
-                if admin_state == 'down':
-                    commands.append('shutdown')
-                commands.append('exit')
-
-                if interfaces and interfaces[0] != 'default':
-                    for i in interfaces:
-                        commands.append('interface {0}'.format(i))
-                        commands.append('switchport')
-                        commands.append('switchport mode access')
-                        commands.append('switchport access vlan {0}'.format(vlan_id))
-
-            else:
-                diff = get_diff(w, obj_in_have)
-                if diff:
-                    commands.append('vlan {0}'.format(vlan_id))
-                    for key, value in diff.items():
-                        if key == 'name':
-                            if name != 'default':
-                                if name is not None:
-                                    commands.append('name {0}'.format(value))
-                            else:
-                                if not is_default_name(obj_in_have, vlan_id):
-                                    commands.append('no name')
-                        if key == 'vlan_state' and value:
-                            commands.append('state {0}'.format(value))
-                        if key == 'mapped_vni':
-                            if value == 'default':
-                                if obj_in_have['mapped_vni'] != 'None':
-                                    commands.append('no vn-segment')
-                            elif value != 'None':
-                                commands.append('vn-segment {0}'.format(value))
-                        if key == 'admin_state':
-                            if value == 'up':
-                                commands.append('no shutdown')
-                            elif value == 'down':
-                                commands.append('shutdown')
-                        if key == 'mode' and value:
-                            commands.append('mode {0}'.format(value))
-                    if len(commands) > 1:
-                        commands.append('exit')
-                    else:
-                        del commands[:]
-
-                if interfaces and interfaces[0] != 'default':
-                    if not obj_in_have['interfaces']:
-                        for i in interfaces:
-                            commands.append('vlan {0}'.format(vlan_id))
-                            commands.append('exit')
-                            commands.append('interface {0}'.format(i))
-                            commands.append('switchport')
-                            commands.append('switchport mode access')
-                            commands.append('switchport access vlan {0}'.format(vlan_id))
-
-                    elif set(interfaces) != set(obj_in_have['interfaces']):
-                        missing_interfaces = list(set(interfaces) - set(obj_in_have['interfaces']))
-                        for i in missing_interfaces:
-                            commands.append('vlan {0}'.format(vlan_id))
-                            commands.append('exit')
-                            commands.append('interface {0}'.format(i))
-                            commands.append('switchport')
-                            commands.append('switchport mode access')
-                            commands.append('switchport access vlan {0}'.format(vlan_id))
-
-                        superfluous_interfaces = list(set(obj_in_have['interfaces']) - set(interfaces))
-                        for i in superfluous_interfaces:
-                            commands.append('vlan {0}'.format(vlan_id))
-                            commands.append('exit')
-                            commands.append('interface {0}'.format(i))
-                            commands.append('switchport')
-                            commands.append('switchport mode access')
-                            commands.append('no switchport access vlan {0}'.format(vlan_id))
-
-                elif interfaces and interfaces[0] == 'default':
-                    if obj_in_have['interfaces']:
-                        for i in obj_in_have['interfaces']:
-                            commands.append('vlan {0}'.format(vlan_id))
-                            commands.append('exit')
-                            commands.append('interface {0}'.format(i))
-                            commands.append('switchport')
-                            commands.append('switchport mode access')
-                            commands.append('no switchport access vlan {0}'.format(vlan_id))
-
-    if purge:
-        for h in have:
-            if h['vlan_id'] == '1':
-                module.warn("Deletion of vlan 1 is not allowed; purge will ignore vlan 1")
-                continue
-            obj_in_want = search_obj_in_list(h['vlan_id'], want)
-            if not obj_in_want:
-                commands.append('no vlan {0}'.format(h['vlan_id']))
-
-    return commands
-
-
-def want_vlan_list(module):
-    result = []
-    vlan_range = module.params['vlan_range']
-    for part in vlan_range.split(','):
-        if part == 'none':
-            break
-        if '-' in part:
-            start, end = part.split('-')
-            start, end = int(start), int(end)
-            result.extend([str(i) for i in range(start, end + 1)])
-        else:
-            result.append(part)
-    return result
-
-
-def have_vlan_list(have):
-    result = []
-    if have:
-        for h in have:
-            result.append(str(h.get('vlan_id')))
-    return result
-
-
-def vlan_range_commands(module, have):
-    commands = list()
-    proposed_vlans_list = want_vlan_list(module)
-    existing_vlans_list = have_vlan_list(have)
-
-    if module.params['state'] == 'absent':
-        vlans = set(proposed_vlans_list).intersection(existing_vlans_list)
-        for vlan in vlans:
-            commands.append('no vlan {0}'.format(vlan))
-
-    elif module.params['state'] == 'present':
-        vlans = set(proposed_vlans_list).difference(existing_vlans_list)
-        for vlan in vlans:
-            commands.append('vlan {0}'.format(vlan))
-
-    return commands
-
-
-def normalize(interfaces):
-    normalized = None
-    if interfaces:
-        normalized = [normalize_interface(i) for i in interfaces]
-    return normalized
-
-
-def map_params_to_obj(module):
-    obj = []
-    if module.params['vlan_range']:
-        return []
-
-    aggregate = module.params.get('aggregate')
-    if aggregate:
-        for item in aggregate:
-            for key in item:
-                if item.get(key) is None:
-                    item[key] = module.params[key]
-
-            d = item.copy()
-            d['vlan_id'] = str(d['vlan_id'])
-            d['mapped_vni'] = str(d['mapped_vni'])
-            d['interfaces'] = normalize(d['interfaces'])
-            d['associated_interfaces'] = normalize(d['associated_interfaces'])
-
-            obj.append(d)
-    else:
-        interfaces = normalize(module.params['interfaces'])
-        associated_interfaces = normalize(module.params['associated_interfaces'])
-
-        obj.append({
-            'vlan_id': str(module.params['vlan_id']),
-            'name': module.params['name'],
-            'interfaces': interfaces,
-            'vlan_state': module.params['vlan_state'],
-            'mapped_vni': str(module.params['mapped_vni']),
-            'state': module.params['state'],
-            'admin_state': module.params['admin_state'],
-            'mode': module.params['mode'],
-            'associated_interfaces': associated_interfaces
-        })
-
-    return obj
-
-
-def parse_admin_state(vlan):
-    shutstate = vlan.get('vlanshowbr-shutstate')
-    if shutstate == 'noshutdown':
-        return 'up'
-    elif shutstate == 'shutdown':
-        return 'down'
-
-
-def parse_mode(config):
-    mode = None
-
-    if config:
-        match = re.search(r'mode (\S+)', config)
-        if match:
-            mode = match.group(1)
-    return mode
-
-
-def parse_vni(config):
-    vni = None
-
-    if config:
-        match = re.search(r'vn-segment (\S+)', config)
-        if match:
-            vni = match.group(1)
-    return str(vni)
-
-
-def get_vlan_int(interfaces):
-    vlan_int = []
-    for i in interfaces.split(','):
-        if 'eth' in i.lower() and '-' in i:
-            int_range = i.split('-')
-            stop = int((int_range)[1])
-            start = int(int_range[0].split('/')[1])
-            eth = int_range[0].split('/')[0]
-            for r in range(start, stop + 1):
-                vlan_int.append(eth + '/' + str(r))
-        else:
-            vlan_int.append(i)
-    return vlan_int
-
-
-def parse_interfaces(module, vlan):
-    vlan_int = []
-    interfaces = vlan.get('vlanshowplist-ifidx')
-    if interfaces:
-        if isinstance(interfaces, list):
-            interfaces_list = [i.strip() for i in interfaces]
-            interfaces_str = ','.join(interfaces_list)
-            vlan_int = get_vlan_int(interfaces_str)
-        else:
-            vlan_int = get_vlan_int(interfaces)
-    return vlan_int
-
-
-def parse_vlan_config(netcfg, vlan_id):
-    parents = ['vlan {0}'.format(vlan_id)]
-    config = netcfg.get_section(parents)
-    return config
-
-
-def parse_vlan_options(module, netcfg, output, vlan):
-    obj = {}
-    vlan_id = vlan['vlanshowbr-vlanid-utf']
-    config = parse_vlan_config(netcfg, vlan_id)
-
-    obj['vlan_id'] = str(vlan_id)
-    obj['name'] = vlan.get('vlanshowbr-vlanname')
-    obj['vlan_state'] = vlan.get('vlanshowbr-vlanstate')
-    obj['admin_state'] = parse_admin_state(vlan)
-    obj['mode'] = parse_mode(config)
-    obj['mapped_vni'] = parse_vni(config)
-    obj['interfaces'] = parse_interfaces(module, vlan)
-    return obj
-
-
-def parse_vlan_non_structured(module, netcfg, vlans):
-    objs = list()
-
-    for vlan in vlans:
-        vlan_match = re.search(r'(\d+)', vlan, re.M)
-        if vlan_match:
-            obj = {}
-            vlan_id = vlan_match.group(1)
-            obj['vlan_id'] = str(vlan_id)
-
-            name_match = re.search(r'{0}\s*(\S+)'.format(vlan_id), vlan, re.M)
-            if name_match:
-                name = name_match.group(1)
-                obj['name'] = name
-                state_match = re.search(r'{0}\s*{1}\s*(\S+)'.format(vlan_id, re.escape(name)), vlan, re.M)
-                if state_match:
-                    vlan_state_match = state_match.group(1)
-                    if vlan_state_match == 'suspended':
-                        vlan_state = 'suspend'
-                        admin_state = 'up'
-                    elif vlan_state_match == 'sus/lshut':
-                        vlan_state = 'suspend'
-                        admin_state = 'down'
-                    if vlan_state_match == 'active':
-                        vlan_state = 'active'
-                        admin_state = 'up'
-                    if vlan_state_match == 'act/lshut':
-                        vlan_state = 'active'
-                        admin_state = 'down'
-
-                    obj['vlan_state'] = vlan_state
-                    obj['admin_state'] = admin_state
-
-                    vlan = ','.join(vlan.splitlines())
-                    interfaces = list()
-                    intfs_match = re.search(r'{0}\s*{1}\s*{2}\s*(.*)'.format(vlan_id, re.escape(name), vlan_state_match),
-                                            vlan, re.M)
-                    if intfs_match:
-                        intfs = intfs_match.group(1)
-                        intfs = intfs.split()
-                        for i in intfs:
-                            intf = normalize_interface(i.strip(','))
-                            interfaces.append(intf)
-
-                    if interfaces:
-                        obj['interfaces'] = interfaces
-                    else:
-                        obj['interfaces'] = None
-
-                    config = parse_vlan_config(netcfg, vlan_id)
-                    obj['mode'] = parse_mode(config)
-                    obj['mapped_vni'] = parse_vni(config)
-
-        objs.append(obj)
-
-    return objs
-
-
-def map_config_to_obj(module):
-    objs = list()
-    output = None
-
-    command = ['show vlan brief | json']
-    output = run_commands(module, command, check_rc='retry_json')[0]
-    if output:
-        netcfg = CustomNetworkConfig(indent=2,
-                                     contents=get_config(module, flags=['all']))
-
-        if isinstance(output, dict):
-            vlans = None
-            try:
-                vlans = output['TABLE_vlanbriefxbrief']['ROW_vlanbriefxbrief']
-            except KeyError:
-                return objs
-
-            if vlans:
-                if isinstance(vlans, list):
-                    for vlan in vlans:
-                        obj = parse_vlan_options(module, netcfg, output, vlan)
-                        objs.append(obj)
-                elif isinstance(vlans, dict):
-                    obj = parse_vlan_options(module, netcfg, output, vlans)
-                    objs.append(obj)
-        else:
-            vlans = list()
-            splitted_line = re.split(r'\n(\d+)|\n{2}', output.strip())
-
-            for line in splitted_line:
-                if not line:
-                    continue
-                if len(line) > 0:
-                    line = line.strip()
-                    if line[0].isdigit():
-                        match = re.search(r'^(\d+)$', line, re.M)
-                        if match:
-                            v = match.group(1)
-                            pos1 = splitted_line.index(v)
-                            pos2 = pos1 + 1
-                            vlaninfo = ''.join(splitted_line[pos1:pos2 + 1])
-                            vlans.append(vlaninfo)
-
-            if vlans:
-                objs = parse_vlan_non_structured(module, netcfg, vlans)
-            else:
-                return objs
-
-    return objs
-
-
-def check_declarative_intent_params(want, module, result):
-
-    have = None
-    is_delay = False
-
-    for w in want:
-        if w.get('associated_interfaces') is None:
-            continue
-
-        if result['changed'] and not is_delay:
-            time.sleep(module.params['delay'])
-            is_delay = True
-
-        if have is None:
-            have = map_config_to_obj(module)
-
-        for i in w['associated_interfaces']:
-            obj_in_have = search_obj_in_list(w['vlan_id'], have)
-            if obj_in_have and 'interfaces' in obj_in_have and i not in obj_in_have['interfaces']:
-                module.fail_json(msg="Interface %s not configured on vlan %s" % (i, w['vlan_id']))
-
-
-def main():
-    """ main entry point for module execution
-    """
-    element_spec = dict(
-        vlan_id=dict(required=False, type='int'),
-        vlan_range=dict(required=False),
-        name=dict(required=False),
-        interfaces=dict(type='list'),
-        associated_interfaces=dict(type='list'),
-        vlan_state=dict(choices=['active', 'suspend'], required=False, default='active'),
-        mapped_vni=dict(required=False),
-        delay=dict(default=10, type='int'),
-        state=dict(choices=['present', 'absent'], default='present', required=False),
-        admin_state=dict(choices=['up', 'down'], required=False, default='up'),
-        mode=dict(default='ce', choices=['ce', 'fabricpath']),
-    )
-
-    aggregate_spec = deepcopy(element_spec)
-    aggregate_spec['vlan_id'] = dict(required=True)
-
-    # remove default in aggregate spec, to handle common arguments
-    remove_default_spec(aggregate_spec)
-
-    argument_spec = dict(
-        aggregate=dict(type='list', elements='dict', options=aggregate_spec),
-        purge=dict(default=False, type='bool')
-    )
-
-    argument_spec.update(element_spec)
-    argument_spec.update(nxos_argument_spec)
-
-    required_one_of = [['vlan_id', 'aggregate', 'vlan_range']]
-    mutually_exclusive = [['vlan_id', 'aggregate'],
-                          ['vlan_range', 'name'],
-                          ['vlan_id', 'vlan_range']]
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           required_one_of=required_one_of,
-                           mutually_exclusive=mutually_exclusive,
-                           supports_check_mode=True)
-
-    warnings = list()
-    result = {'changed': False}
-    if warnings:
-        result['warnings'] = warnings
-
-    have = map_config_to_obj(module)
-    want = map_params_to_obj(module)
-
-    if module.params['vlan_range']:
-        commands = vlan_range_commands(module, have)
-        result['commands'] = commands
-    else:
-        commands = map_obj_to_commands((want, have), module)
-        result['commands'] = commands
-
-    if commands:
-        if not module.check_mode:
-            load_config(module, commands)
-        result['changed'] = True
-
-    if want:
-        check_declarative_intent_params(want, module, result)
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_aaa_server.py b/lib/ansible/modules/network/nxos/nxos_aaa_server.py
deleted file mode 100644
index f78bb204c3..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_aaa_server.py
+++ /dev/null
@@ -1,319 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-
-module: nxos_aaa_server
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages AAA server global configuration.
-description:
-    - Manages AAA server global configuration
-author:
-    - Jason Edelman (@jedelman8)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - The server_type parameter is always required.
-    - If encrypt_type is not supplied, the global AAA server key will be
-      stored as encrypted (type 7).
-    - Changes to the global AAA server key with encrypt_type=0
-      are not idempotent.
-    - state=default will set the supplied parameters to their default values.
-      The parameters that you want to default must also be set to default.
-      If global_key=default, the global key will be removed.
-options:
-    server_type:
-        description:
-            - The server type is either radius or tacacs.
-        required: true
-        choices: ['radius', 'tacacs']
-    global_key:
-        description:
-            - Global AAA shared secret or keyword 'default'.
-    encrypt_type:
-        description:
-            - The state of encryption applied to the entered global key.
-              O clear text, 7 encrypted. Type-6 encryption is not supported.
-        choices: ['0', '7']
-    deadtime:
-        description:
-            - Duration for which a non-reachable AAA server is skipped,
-              in minutes or keyword 'default.
-              Range is 1-1440. Device default is 0.
-    server_timeout:
-        description:
-            - Global AAA server timeout period, in seconds or keyword 'default.
-              Range is 1-60. Device default is 5.
-    directed_request:
-        description:
-            - Enables direct authentication requests to AAA server or keyword 'default'
-              Device default is disabled.
-        choices: ['enabled', 'disabled']
-    state:
-        description:
-            - Manage the state of the resource.
-        default: present
-        choices: ['present','default']
-'''
-
-EXAMPLES = '''
-# Radius Server Basic settings
-  - name: "Radius Server Basic settings"
-    nxos_aaa_server:
-        server_type: radius
-        server_timeout: 9
-        deadtime: 20
-        directed_request: enabled
-
-# Tacacs Server Basic settings
-  - name: "Tacacs Server Basic settings"
-    nxos_aaa_server:
-        server_type: tacacs
-        server_timeout: 8
-        deadtime: 19
-        directed_request: disabled
-
-# Setting Global Key
-  - name: "AAA Server Global Key"
-    nxos_aaa_server:
-        server_type: radius
-        global_key: test_key
-'''
-
-RETURN = '''
-commands:
-    description: command sent to the device
-    returned: always
-    type: list
-    sample: ["radius-server deadtime 22", "radius-server timeout 11",
-             "radius-server directed-request"]
-'''
-import re
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-PARAM_TO_DEFAULT_KEYMAP = {
-    'server_timeout': '5',
-    'deadtime': '0',
-    'directed_request': 'disabled',
-}
-
-
-def execute_show_command(command, module):
-    command = {
-        'command': command,
-        'output': 'text',
-    }
-
-    return run_commands(module, command)
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_aaa_server_info(server_type, module):
-    aaa_server_info = {}
-    server_command = 'show {0}-server'.format(server_type)
-    request_command = 'show {0}-server directed-request'.format(server_type)
-    global_key_command = 'show run | sec {0}'.format(server_type)
-    aaa_regex = r'.*{0}-server\skey\s\d\s+(?P<key>\S+).*'.format(server_type)
-
-    server_body = execute_show_command(server_command, module)[0]
-
-    split_server = server_body.splitlines()
-
-    for line in split_server:
-        if line.startswith('timeout'):
-            aaa_server_info['server_timeout'] = line.split(':')[1]
-
-        elif line.startswith('deadtime'):
-            aaa_server_info['deadtime'] = line.split(':')[1]
-
-    request_body = execute_show_command(request_command, module)[0]
-
-    if bool(request_body):
-        aaa_server_info['directed_request'] = request_body.replace('\n', '')
-    else:
-        aaa_server_info['directed_request'] = 'disabled'
-
-    key_body = execute_show_command(global_key_command, module)[0]
-
-    try:
-        match_global_key = re.match(aaa_regex, key_body, re.DOTALL)
-        group_key = match_global_key.groupdict()
-        aaa_server_info['global_key'] = group_key["key"].replace('\"', '')
-    except (AttributeError, TypeError):
-        aaa_server_info['global_key'] = None
-
-    return aaa_server_info
-
-
-def config_aaa_server(params, server_type):
-    cmds = []
-
-    deadtime = params.get('deadtime')
-    server_timeout = params.get('server_timeout')
-    directed_request = params.get('directed_request')
-    encrypt_type = params.get('encrypt_type', '7')
-    global_key = params.get('global_key')
-
-    if deadtime is not None:
-        cmds.append('{0}-server deadtime {1}'.format(server_type, deadtime))
-
-    if server_timeout is not None:
-        cmds.append('{0}-server timeout {1}'.format(server_type, server_timeout))
-
-    if directed_request is not None:
-        if directed_request == 'enabled':
-            cmds.append('{0}-server directed-request'.format(server_type))
-        elif directed_request == 'disabled':
-            cmds.append('no {0}-server directed-request'.format(server_type))
-
-    if global_key is not None:
-        cmds.append('{0}-server key {1} {2}'.format(server_type, encrypt_type,
-                                                    global_key))
-
-    return cmds
-
-
-def default_aaa_server(existing, params, server_type):
-    cmds = []
-
-    deadtime = params.get('deadtime')
-    server_timeout = params.get('server_timeout')
-    directed_request = params.get('directed_request')
-    global_key = params.get('global_key')
-    existing_key = existing.get('global_key')
-
-    if deadtime is not None and existing.get('deadtime') != PARAM_TO_DEFAULT_KEYMAP['deadtime']:
-        cmds.append('no {0}-server deadtime 1'.format(server_type))
-
-    if server_timeout is not None and existing.get('server_timeout') != PARAM_TO_DEFAULT_KEYMAP['server_timeout']:
-        cmds.append('no {0}-server timeout 1'.format(server_type))
-
-    if directed_request is not None and existing.get('directed_request') != PARAM_TO_DEFAULT_KEYMAP['directed_request']:
-        cmds.append('no {0}-server directed-request'.format(server_type))
-
-    if global_key is not None and existing_key is not None:
-        cmds.append('no {0}-server key 7 {1}'.format(server_type, existing_key))
-
-    return cmds
-
-
-def main():
-    argument_spec = dict(
-        server_type=dict(type='str', choices=['radius', 'tacacs'], required=True),
-        global_key=dict(type='str'),
-        encrypt_type=dict(type='str', choices=['0', '7']),
-        deadtime=dict(type='str'),
-        server_timeout=dict(type='str'),
-        directed_request=dict(type='str', choices=['enabled', 'disabled', 'default']),
-        state=dict(choices=['default', 'present'], default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    warnings = list()
-    results = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    server_type = module.params['server_type']
-    global_key = module.params['global_key']
-    encrypt_type = module.params['encrypt_type']
-    deadtime = module.params['deadtime']
-    server_timeout = module.params['server_timeout']
-    directed_request = module.params['directed_request']
-    state = module.params['state']
-
-    if encrypt_type and not global_key:
-        module.fail_json(msg='encrypt_type must be used with global_key.')
-
-    args = dict(server_type=server_type, global_key=global_key,
-                encrypt_type=encrypt_type, deadtime=deadtime,
-                server_timeout=server_timeout, directed_request=directed_request)
-
-    proposed = dict((k, v) for k, v in args.items() if v is not None)
-
-    existing = get_aaa_server_info(server_type, module)
-
-    commands = []
-    if state == 'present':
-        if deadtime:
-            try:
-                if int(deadtime) < 0 or int(deadtime) > 1440:
-                    raise ValueError
-            except ValueError:
-                module.fail_json(
-                    msg='deadtime must be an integer between 0 and 1440')
-
-        if server_timeout:
-            try:
-                if int(server_timeout) < 1 or int(server_timeout) > 60:
-                    raise ValueError
-            except ValueError:
-                module.fail_json(
-                    msg='server_timeout must be an integer between 1 and 60')
-
-        delta = dict(set(proposed.items()).difference(
-            existing.items()))
-        if delta:
-            command = config_aaa_server(delta, server_type)
-            if command:
-                commands.append(command)
-
-    elif state == 'default':
-        for key, value in proposed.items():
-            if key != 'server_type' and value != 'default':
-                module.fail_json(
-                    msg='Parameters must be set to "default"'
-                        'when state=default')
-        command = default_aaa_server(existing, proposed, server_type)
-        if command:
-            commands.append(command)
-
-    cmds = flatten_list(commands)
-    if cmds:
-        results['changed'] = True
-        if not module.check_mode:
-            load_config(module, cmds)
-        if 'configure' in cmds:
-            cmds.pop(0)
-        results['commands'] = cmds
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_aaa_server_host.py b/lib/ansible/modules/network/nxos/nxos_aaa_server_host.py
deleted file mode 100644
index e9aa8e2a93..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_aaa_server_host.py
+++ /dev/null
@@ -1,343 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_aaa_server_host
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages AAA server host-specific configuration.
-description:
-    - Manages AAA server host-specific configuration.
-author: Jason Edelman (@jedelman8)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - Changes to the host key (shared secret) are not idempotent for type 0.
-    - If C(state=absent) removes the whole host configuration.
-options:
-    server_type:
-        description:
-            - The server type is either radius or tacacs.
-        required: true
-        choices: ['radius', 'tacacs']
-    address:
-        description:
-            - Address or name of the radius or tacacs host.
-        required: true
-    key:
-        description:
-            - Shared secret for the specified host or keyword 'default'.
-    encrypt_type:
-        description:
-            - The state of encryption applied to the entered key.
-              O for clear text, 7 for encrypted. Type-6 encryption is
-              not supported.
-        choices: ['0', '7']
-    host_timeout:
-        description:
-            - Timeout period for specified host, in seconds or keyword 'default.
-              Range is 1-60.
-    auth_port:
-        description:
-            - Alternate UDP port for RADIUS authentication or keyword 'default'.
-    acct_port:
-        description:
-            - Alternate UDP port for RADIUS accounting or keyword 'default'.
-    tacacs_port:
-        description:
-            - Alternate TCP port TACACS Server or keyword 'default'.
-    state:
-        description:
-            - Manage the state of the resource.
-        default: present
-        choices: ['present','absent']
-'''
-EXAMPLES = '''
-# Radius Server Host Basic settings
-  - name: "Radius Server Host Basic settings"
-    nxos_aaa_server_host:
-        state: present
-        server_type: radius
-        address: 1.2.3.4
-        acct_port: 2084
-        host_timeout: 10
-
-# Radius Server Host Key Configuration
-  - name: "Radius Server Host Key Configuration"
-    nxos_aaa_server_host:
-        state: present
-        server_type: radius
-        address: 1.2.3.4
-        key: hello
-        encrypt_type: 7
-
-# TACACS Server Host Configuration
-  - name: "Tacacs Server Host Configuration"
-    nxos_aaa_server_host:
-        state: present
-        server_type: tacacs
-        tacacs_port: 89
-        host_timeout: 10
-        address: 5.6.7.8
-
-'''
-
-RETURN = '''
-proposed:
-    description: k/v pairs of parameters passed into module
-    returned: always
-    type: dict
-    sample: {"address": "1.2.3.4", "auth_port": "2084",
-            "host_timeout": "10", "server_type": "radius"}
-existing:
-    description:
-        - k/v pairs of existing configuration
-    returned: always
-    type: dict
-    sample: {}
-end_state:
-    description: k/v pairs of configuration after module execution
-    returned: always
-    type: dict
-    sample: {"address": "1.2.3.4", "auth_port": "2084",
-            "host_timeout": "10", "server_type": "radius"}
-updates:
-    description: command sent to the device
-    returned: always
-    type: list
-    sample: ["radius-server host 1.2.3.4 auth-port 2084 timeout 10"]
-changed:
-    description: check to see if a change was made on the device
-    returned: always
-    type: bool
-    sample: true
-'''
-import re
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import get_capabilities, nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def execute_show_command(command, module):
-    device_info = get_capabilities(module)
-    network_api = device_info.get('network_api', 'nxapi')
-
-    if network_api == 'cliconf':
-        cmds = [command]
-        body = run_commands(module, cmds)
-    elif network_api == 'nxapi':
-        cmds = {'command': command, 'output': 'text'}
-        body = run_commands(module, cmds)
-
-    return body
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_aaa_host_info(module, server_type, address):
-    aaa_host_info = {}
-    command = 'show run | inc {0}-server.host.{1}'.format(server_type, address)
-
-    body = execute_show_command(command, module)[0]
-    if body:
-        try:
-            if 'radius' in body:
-                pattern = (r'\S+ host \S+(?:\s+key 7\s+(\S+))?(?:\s+auth-port (\d+))?'
-                           r'(?:\s+acct-port (\d+))?(?:\s+authentication)?'
-                           r'(?:\s+accounting)?(?:\s+timeout (\d+))?')
-                match = re.search(pattern, body)
-                aaa_host_info['key'] = match.group(1)
-                if aaa_host_info['key']:
-                    aaa_host_info['key'] = aaa_host_info['key'].replace('"', '')
-                    aaa_host_info['encrypt_type'] = '7'
-                aaa_host_info['auth_port'] = match.group(2)
-                aaa_host_info['acct_port'] = match.group(3)
-                aaa_host_info['host_timeout'] = match.group(4)
-            elif 'tacacs' in body:
-                pattern = (r'\S+ host \S+(?:\s+key 7\s+(\S+))?(?:\s+port (\d+))?'
-                           r'(?:\s+timeout (\d+))?')
-                match = re.search(pattern, body)
-                aaa_host_info['key'] = match.group(1)
-                if aaa_host_info['key']:
-                    aaa_host_info['key'] = aaa_host_info['key'].replace('"', '')
-                    aaa_host_info['encrypt_type'] = '7'
-                aaa_host_info['tacacs_port'] = match.group(2)
-                aaa_host_info['host_timeout'] = match.group(3)
-
-            aaa_host_info['server_type'] = server_type
-            aaa_host_info['address'] = address
-        except TypeError:
-            return {}
-    else:
-        return {}
-
-    return aaa_host_info
-
-
-def config_aaa_host(server_type, address, params, existing):
-    cmds = []
-    cmd_str = '{0}-server host {1}'.format(server_type, address)
-    cmd_no_str = 'no ' + cmd_str
-
-    key = params.get('key')
-    enc_type = params.get('encrypt_type', '')
-
-    defval = False
-    nondef = False
-
-    if key:
-        if key != 'default':
-            cmds.append(cmd_str + ' key {0} {1}'.format(enc_type, key))
-        else:
-            cmds.append(cmd_no_str + ' key 7 {0}'.format(existing.get('key')))
-
-    locdict = {'auth_port': 'auth-port', 'acct_port': 'acct-port',
-               'tacacs_port': 'port', 'host_timeout': 'timeout'}
-
-    # platform CLI needs the keywords in the following order
-    for key in ['auth_port', 'acct_port', 'tacacs_port', 'host_timeout']:
-        item = params.get(key)
-        if item:
-            if item != 'default':
-                cmd_str += ' {0} {1}'.format(locdict.get(key), item)
-                nondef = True
-            else:
-                cmd_no_str += ' {0} 1'.format(locdict.get(key))
-                defval = True
-    if defval:
-        cmds.append(cmd_no_str)
-    if nondef or not existing:
-        cmds.append(cmd_str)
-
-    return cmds
-
-
-def main():
-    argument_spec = dict(
-        server_type=dict(choices=['radius', 'tacacs'], required=True),
-        address=dict(type='str', required=True),
-        key=dict(type='str'),
-        encrypt_type=dict(type='str', choices=['0', '7']),
-        host_timeout=dict(type='str'),
-        auth_port=dict(type='str'),
-        acct_port=dict(type='str'),
-        tacacs_port=dict(type='str'),
-        state=dict(choices=['absent', 'present'], default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    server_type = module.params['server_type']
-    address = module.params['address']
-    key = module.params['key']
-    encrypt_type = module.params['encrypt_type']
-    host_timeout = module.params['host_timeout']
-    auth_port = module.params['auth_port']
-    acct_port = module.params['acct_port']
-    tacacs_port = module.params['tacacs_port']
-    state = module.params['state']
-
-    args = dict(server_type=server_type, address=address, key=key,
-                encrypt_type=encrypt_type, host_timeout=host_timeout,
-                auth_port=auth_port, acct_port=acct_port,
-                tacacs_port=tacacs_port)
-
-    proposed = dict((k, v) for k, v in args.items() if v is not None)
-    changed = False
-
-    if encrypt_type and not key:
-        module.fail_json(msg='encrypt_type must be used with key')
-
-    if tacacs_port and server_type != 'tacacs':
-        module.fail_json(
-            msg='tacacs_port can only be used with server_type=tacacs')
-
-    if (auth_port or acct_port) and server_type != 'radius':
-        module.fail_json(msg='auth_port and acct_port can only be used'
-                             'when server_type=radius')
-
-    existing = get_aaa_host_info(module, server_type, address)
-    end_state = existing
-
-    commands = []
-    delta = {}
-    if state == 'present':
-        if not existing:
-            delta = proposed
-        else:
-            for key, value in proposed.items():
-                if key == 'encrypt_type':
-                    delta[key] = value
-                if value != existing.get(key):
-                    if value != 'default' or existing.get(key):
-                        delta[key] = value
-
-        command = config_aaa_host(server_type, address, delta, existing)
-        if command:
-            commands.append(command)
-
-    elif state == 'absent':
-        intersect = dict(
-            set(proposed.items()).intersection(existing.items()))
-        if intersect.get('address') and intersect.get('server_type'):
-            command = 'no {0}-server host {1}'.format(
-                intersect.get('server_type'), intersect.get('address'))
-            commands.append(command)
-
-    cmds = flatten_list(commands)
-    if cmds:
-        if module.check_mode:
-            module.exit_json(changed=True, commands=cmds)
-        else:
-            changed = True
-            load_config(module, cmds)
-            end_state = get_aaa_host_info(module, server_type, address)
-
-    results = {}
-    results['proposed'] = proposed
-    results['existing'] = existing
-    results['updates'] = cmds
-    results['changed'] = changed
-    results['warnings'] = warnings
-    results['end_state'] = end_state
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_acl.py b/lib/ansible/modules/network/nxos/nxos_acl.py
deleted file mode 100644
index e2e27c3718..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_acl.py
+++ /dev/null
@@ -1,536 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_acl
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages access list entries for ACLs.
-description:
-  - Manages access list entries for ACLs.
-author:
-  - Jason Edelman (@jedelman8)
-  - Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - C(state=absent) removes the ACE if it exists.
-  - C(state=delete_acl) deletes the ACL if it exists.
-  - For idempotency, use port numbers for the src/dest port
-    params like I(src_port1) and names for the well defined protocols
-    for the I(proto) param.
-  - Although this module is idempotent in that if the ace as presented in
-    the task is identical to the one on the switch, no changes will be made.
-    If there is any difference, what is in Ansible will be pushed (configured
-    options will be overridden).  This is to improve security, but at the
-    same time remember an ACE is removed, then re-added, so if there is a
-    change, the new ACE will be exactly what parameters you are sending to
-    the module.
-options:
-  seq:
-    description:
-      - Sequence number of the entry (ACE).
-  name:
-    description:
-      - Case sensitive name of the access list (ACL).
-    required: true
-  action:
-    description:
-      - Action of the ACE.
-    choices: ['permit', 'deny', 'remark']
-  remark:
-    description:
-      - If action is set to remark, this is the description.
-  proto:
-    description:
-      - Port number or protocol (as supported by the switch).
-  src:
-    description:
-      - Source ip and mask using IP/MASK notation and
-        supports keyword 'any'.
-  src_port_op:
-    description:
-      - Source port operands such as eq, neq, gt, lt, range.
-    choices: ['any', 'eq', 'gt', 'lt', 'neq', 'range']
-  src_port1:
-    description:
-      - Port/protocol and also first (lower) port when using range
-        operand.
-  src_port2:
-    description:
-      - Second (end) port when using range operand.
-  dest:
-    description:
-      - Destination ip and mask using IP/MASK notation and supports the
-        keyword 'any'.
-  dest_port_op:
-    description:
-      - Destination port operands such as eq, neq, gt, lt, range.
-    choices: ['any', 'eq', 'gt', 'lt', 'neq', 'range']
-  dest_port1:
-    description:
-      - Port/protocol and also first (lower) port when using range
-        operand.
-  dest_port2:
-    description:
-      - Second (end) port when using range operand.
-  log:
-    description:
-      - Log matches against this entry.
-    choices: ['enable']
-  urg:
-    description:
-      - Match on the URG bit.
-    choices: ['enable']
-  ack:
-    description:
-      - Match on the ACK bit.
-    choices: ['enable']
-  psh:
-    description:
-      - Match on the PSH bit.
-    choices: ['enable']
-  rst:
-    description:
-      - Match on the RST bit.
-    choices: ['enable']
-  syn:
-    description:
-      - Match on the SYN bit.
-    choices: ['enable']
-  fin:
-    description:
-      - Match on the FIN bit.
-    choices: ['enable']
-  established:
-    description:
-      - Match established connections.
-    choices: ['enable']
-  fragments:
-    description:
-      - Check non-initial fragments.
-    choices: ['enable']
-  time_range:
-    description:
-      - Name of time-range to apply.
-  precedence:
-    description:
-      - Match packets with given precedence.
-    choices: ['critical', 'flash', 'flash-override', 'immediate',
-              'internet', 'network', 'priority', 'routine']
-  dscp:
-    description:
-      - Match packets with given dscp value.
-    choices: ['af11', 'af12', 'af13', 'af21', 'af22', 'af23','af31','af32',
-              'af33', 'af41', 'af42', 'af43', 'cs1', 'cs2', 'cs3', 'cs4',
-              'cs5', 'cs6', 'cs7', 'default', 'ef']
-  state:
-    description:
-      - Specify desired state of the resource.
-    default: present
-    choices: ['present','absent','delete_acl']
-'''
-
-EXAMPLES = '''
-# configure ACL ANSIBLE
-- nxos_acl:
-    name: ANSIBLE
-    seq: 10
-    action: permit
-    proto: tcp
-    src: 192.0.2.1/24
-    dest: any
-    state: present
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["ip access-list ANSIBLE", "10 permit tcp 192.0.2.1/24 any"]
-'''
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def execute_show_command(command, module, check_rc=True):
-    command += ' | json'
-    cmds = [command]
-    body = run_commands(module, cmds, check_rc=check_rc)
-    return body
-
-
-def get_acl(module, acl_name, seq_number):
-    command = 'show ip access-list'
-    new_acl = []
-    saveme = {}
-    acl_body = {}
-
-    body = execute_show_command(command, module, check_rc=False)
-    if 'Structured output unsupported' in repr(body):
-        # Some older versions raise 501 and return a string when no ACLs exist
-        return {}, []
-
-    if body and body[0]:
-        all_acl_body = body[0]['TABLE_ip_ipv6_mac']['ROW_ip_ipv6_mac']
-    else:
-        # no access-lists configured on the device
-        return {}, []
-
-    if isinstance(all_acl_body, dict):
-        # Only 1 ACL configured.
-        if all_acl_body.get('acl_name') == acl_name:
-            acl_body = all_acl_body
-    else:
-        for acl in all_acl_body:
-            if acl.get('acl_name') == acl_name:
-                acl_body = acl
-                break
-
-    try:
-        acl_entries = acl_body['TABLE_seqno']['ROW_seqno']
-        acl_name = acl_body.get('acl_name')
-    except KeyError:  # could be raised if no ACEs are configured for an ACL
-        return {}, [{'acl': 'no_entries'}]
-
-    if isinstance(acl_entries, dict):
-        acl_entries = [acl_entries]
-
-    for each in acl_entries:
-        temp = {}
-        options = {}
-        remark = each.get('remark')
-
-        temp['name'] = acl_name
-        temp['seq'] = str(each.get('seqno'))
-
-        if remark:
-            temp['remark'] = remark
-            temp['action'] = 'remark'
-        else:
-            temp['action'] = each.get('permitdeny')
-            temp['proto'] = str(each.get('proto', each.get('proto_str', each.get('ip'))))
-            temp['src'] = each.get('src_any', each.get('src_ip_prefix'))
-            temp['src_port_op'] = each.get('src_port_op')
-            temp['src_port1'] = each.get('src_port1_num')
-            temp['src_port2'] = each.get('src_port2_num')
-            temp['dest'] = each.get('dest_any', each.get('dest_ip_prefix'))
-            temp['dest_port_op'] = each.get('dest_port_op')
-            temp['dest_port1'] = each.get('dest_port1_num')
-            temp['dest_port2'] = each.get('dest_port2_num')
-
-            options['log'] = each.get('log')
-            options['urg'] = each.get('urg')
-            options['ack'] = each.get('ack')
-            options['psh'] = each.get('psh')
-            options['rst'] = each.get('rst')
-            options['syn'] = each.get('syn')
-            options['fin'] = each.get('fin')
-            options['established'] = each.get('established')
-            options['dscp'] = each.get('dscp_str')
-            options['precedence'] = each.get('precedence_str')
-            options['fragments'] = each.get('fragments')
-            options['time_range'] = each.get('timerange')
-
-        keep = {}
-        for key, value in temp.items():
-            if value:
-                keep[key] = value
-
-        options_no_null = {}
-        for key, value in options.items():
-            if value is not None:
-                options_no_null[key] = value
-        keep['options'] = options_no_null
-
-        if keep.get('seq') == seq_number:
-            saveme = dict(keep)
-
-        new_acl.append(keep)
-
-    return saveme, new_acl
-
-
-def _acl_operand(operand, srcp1, sprcp2):
-    sub_entry = ' ' + operand
-
-    if operand == 'range':
-        sub_entry += ' ' + srcp1 + ' ' + sprcp2
-    else:
-        sub_entry += ' ' + srcp1
-
-    return sub_entry
-
-
-def config_core_acl(proposed):
-    seq = proposed.get('seq')
-    action = proposed.get('action')
-    remark = proposed.get('remark')
-    proto = proposed.get('proto')
-    src = proposed.get('src')
-    src_port_op = proposed.get('src_port_op')
-    src_port1 = proposed.get('src_port1')
-    src_port2 = proposed.get('src_port2')
-
-    dest = proposed.get('dest')
-    dest_port_op = proposed.get('dest_port_op')
-    dest_port1 = proposed.get('dest_port1')
-    dest_port2 = proposed.get('dest_port2')
-
-    ace_start_entries = [action, proto, src]
-    if not remark:
-        ace = seq + ' ' + ' '.join(ace_start_entries)
-        if src_port_op:
-            ace += _acl_operand(src_port_op, src_port1, src_port2)
-        ace += ' ' + dest
-        if dest_port_op:
-            ace += _acl_operand(dest_port_op, dest_port1, dest_port2)
-    else:
-        ace = seq + ' remark ' + remark
-
-    return ace
-
-
-def config_acl_options(options):
-    ENABLE_ONLY = ['psh', 'urg', 'log', 'ack', 'syn',
-                   'established', 'rst', 'fin', 'fragments',
-                   'log']
-
-    OTHER = ['dscp', 'precedence', 'time-range']
-    # packet-length is the only option not currently supported
-
-    if options.get('time_range'):
-        options['time-range'] = options.get('time_range')
-        options.pop('time_range')
-
-    command = ''
-    for option, value in options.items():
-        if option in ENABLE_ONLY:
-            if value == 'enable':
-                command += ' ' + option
-        elif option in OTHER:
-            command += ' ' + option + ' ' + value
-    if command:
-        command = command.strip()
-        return command
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def main():
-    argument_spec = dict(
-        seq=dict(required=False, type='str'),
-        name=dict(required=True, type='str'),
-        action=dict(required=False, choices=['remark', 'permit', 'deny']),
-        remark=dict(required=False, type='str'),
-        proto=dict(required=False, type='str'),
-        src=dict(required=False, type='str'),
-        src_port_op=dict(required=False),
-        src_port1=dict(required=False, type='str'),
-        src_port2=dict(required=False, type='str'),
-        dest=dict(required=False, type='str'),
-        dest_port_op=dict(required=False),
-        dest_port1=dict(required=False, type='str'),
-        dest_port2=dict(required=False, type='str'),
-        log=dict(required=False, choices=['enable']),
-        urg=dict(required=False, choices=['enable']),
-        ack=dict(required=False, choices=['enable']),
-        psh=dict(required=False, choices=['enable']),
-        rst=dict(required=False, choices=['enable']),
-        syn=dict(required=False, choices=['enable']),
-        fragments=dict(required=False, choices=['enable']),
-        fin=dict(required=False, choices=['enable']),
-        established=dict(required=False, choices=['enable']),
-        time_range=dict(required=False),
-        precedence=dict(required=False, choices=['critical', 'flash',
-                                                 'flash-override',
-                                                 'immediate', 'internet',
-                                                 'network', 'priority',
-                                                 'routine']),
-        dscp=dict(required=False, choices=['af11', 'af12', 'af13', 'af21',
-                                           'af22', 'af23', 'af31', 'af32',
-                                           'af33', 'af41', 'af42', 'af43',
-                                           'cs1', 'cs2', 'cs3', 'cs4',
-                                           'cs5', 'cs6', 'cs7', 'default',
-                                           'ef']),
-        state=dict(choices=['absent', 'present', 'delete_acl'], default='present')
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    results = dict(changed=False, warnings=warnings)
-
-    state = module.params['state']
-    action = module.params['action']
-    remark = module.params['remark']
-    dscp = module.params['dscp']
-    precedence = module.params['precedence']
-    seq = module.params['seq']
-    name = module.params['name']
-    seq = module.params['seq']
-
-    if action == 'remark' and not remark:
-        module.fail_json(msg='when state is action, remark param is also required')
-
-    REQUIRED = ['seq', 'name', 'action', 'proto', 'src', 'dest']
-    ABSENT = ['name', 'seq']
-    if state == 'present':
-        if action and remark and seq:
-            pass
-        else:
-            for each in REQUIRED:
-                if module.params[each] is None:
-                    module.fail_json(msg="req'd params when state is present:",
-                                     params=REQUIRED)
-    elif state == 'absent':
-        for each in ABSENT:
-            if module.params[each] is None:
-                module.fail_json(msg='require params when state is absent',
-                                 params=ABSENT)
-    elif state == 'delete_acl':
-        if module.params['name'] is None:
-            module.fail_json(msg="param name req'd when state is delete_acl")
-
-    if dscp and precedence:
-        module.fail_json(msg='only one of the params dscp/precedence '
-                             'are allowed')
-
-    OPTIONS_NAMES = ['log', 'urg', 'ack', 'psh', 'rst', 'syn', 'fin',
-                     'established', 'dscp', 'precedence', 'fragments',
-                     'time_range']
-
-    CORE = ['seq', 'name', 'action', 'proto', 'src', 'src_port_op',
-            'src_port1', 'src_port2', 'dest', 'dest_port_op',
-            'dest_port1', 'dest_port2', 'remark']
-
-    proposed_core = dict((param, value) for (param, value) in
-                         module.params.items()
-                         if param in CORE and value is not None)
-
-    proposed_options = dict((param, value) for (param, value) in
-                            module.params.items()
-                            if param in OPTIONS_NAMES and value is not None)
-    proposed = {}
-    proposed.update(proposed_core)
-    proposed.update(proposed_options)
-
-    existing_options = {}
-
-    # getting existing existing_core=dict, acl=list, seq=list
-    existing_core, acl = get_acl(module, name, seq)
-    if existing_core:
-        existing_options = existing_core.get('options')
-        existing_core.pop('options')
-
-    commands = []
-    delta_core = {}
-    delta_options = {}
-
-    if not existing_core.get('remark'):
-        dcore = dict(
-            set(proposed_core.items()).difference(
-                existing_core.items())
-        )
-        if not dcore:
-            # check the diff in the other way just in case
-            dcore = dict(
-                set(existing_core.items()).difference(
-                    proposed_core.items())
-            )
-        delta_core = dcore
-        if delta_core:
-            delta_options = proposed_options
-        else:
-            doptions = dict(
-                set(proposed_options.items()).difference(
-                    existing_options.items())
-            )
-            # check the diff in the other way just in case
-            if not doptions:
-                doptions = dict(
-                    set(existing_options.items()).difference(
-                        proposed_options.items())
-                )
-            delta_options = doptions
-    else:
-        delta_core = dict(
-            set(proposed_core.items()).difference(
-                existing_core.items())
-        )
-
-    if state == 'present':
-        if delta_core or delta_options:
-            if existing_core:  # if the ace exists already
-                commands.append(['no {0}'.format(seq)])
-            if delta_options:
-                myacl_str = config_core_acl(proposed_core)
-                myacl_str += ' ' + config_acl_options(proposed_options)
-            else:
-                myacl_str = config_core_acl(proposed_core)
-            command = [myacl_str]
-            commands.append(command)
-    elif state == 'absent':
-        if existing_core:
-            commands.append(['no {0}'.format(seq)])
-    elif state == 'delete_acl':
-        if acl and acl[0].get('acl') != 'no_entries':
-            commands.append(['no ip access-list {0}'.format(name)])
-
-    cmds = []
-    if commands:
-        preface = []
-        if state in ['present', 'absent']:
-            preface = ['ip access-list {0}'.format(name)]
-            commands.insert(0, preface)
-
-        cmds = flatten_list(commands)
-        if module.check_mode:
-            module.exit_json(changed=True, commands=cmds)
-        else:
-            load_config(module, cmds)
-            results['changed'] = True
-            if 'configure' in cmds:
-                cmds.pop(0)
-
-    results['commands'] = cmds
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_acl_interface.py b/lib/ansible/modules/network/nxos/nxos_acl_interface.py
deleted file mode 100644
index ccc3a12fd9..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_acl_interface.py
+++ /dev/null
@@ -1,201 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_acl_interface
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages applying ACLs to interfaces.
-description:
-  - Manages applying ACLs to interfaces.
-author:
-  - Jason Edelman (@jedelman8)
-  - Gabriele Gerbino (@GGabriele)
-options:
-  name:
-    description:
-      - Case sensitive name of the access list (ACL).
-    required: true
-  interface:
-    description:
-      - Full name of interface, e.g. I(Ethernet1/1).
-    required: true
-  direction:
-    description:
-      - Direction ACL to be applied in on the interface.
-    required: true
-    choices: ['ingress', 'egress']
-  state:
-    description:
-      - Specify desired state of the resource.
-    required: false
-    default: present
-    choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-- name: apply egress acl to ethernet1/41
-  nxos_acl_interface:
-    name: ANSIBLE
-    interface: ethernet1/41
-    direction: egress
-    state: present
-'''
-
-RETURN = '''
-acl_applied_to:
-    description: list of interfaces the ACL is applied to
-    returned: always
-    type: list
-    sample: [{"acl_type": "Router ACL", "direction": "egress",
-            "interface": "Ethernet1/41", "name": "ANSIBLE"}]
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["interface ethernet1/41", "ip access-group ANSIBLE out"]
-'''
-import re
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def check_for_acl_int_present(module, name, intf, direction):
-    # Need to Capitalize the interface name as the nxos
-    # output has capitalization
-    command = [{
-        'command': 'show running-config aclmgr | section {0}'.format(intf.title()),
-        'output': 'text',
-    }]
-    body = run_commands(module, command)
-
-    if direction == 'ingress':
-        mdir = 'in'
-    elif direction == 'egress':
-        mdir = 'out'
-
-    match = re.search('ip access-group {0} {1}'.format(name, mdir), str(body[0]))
-    return bool(match)
-
-
-def apply_acl(proposed):
-    commands = []
-
-    commands.append('interface ' + proposed.get('interface'))
-    direction = proposed.get('direction')
-    if direction == 'egress':
-        cmd = 'ip access-group {0} {1}'.format(proposed.get('name'), 'out')
-    elif direction == 'ingress':
-        cmd = 'ip access-group {0} {1}'.format(proposed.get('name'), 'in')
-    commands.append(cmd)
-
-    return commands
-
-
-def remove_acl(proposed):
-    commands = []
-
-    commands.append('interface ' + proposed.get('interface'))
-    direction = proposed.get('direction')
-    if direction == 'egress':
-        cmd = 'no ip access-group {0} {1}'.format(proposed.get('name'), 'out')
-    elif direction == 'ingress':
-        cmd = 'no ip access-group {0} {1}'.format(proposed.get('name'), 'in')
-    commands.append(cmd)
-
-    return commands
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def main():
-    argument_spec = dict(
-        name=dict(required=False, type='str'),
-        interface=dict(required=True),
-        direction=dict(required=True, choices=['egress', 'ingress']),
-        state=dict(choices=['absent', 'present'], default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    results = dict(changed=False, warnings=warnings)
-
-    state = module.params['state']
-    name = module.params['name']
-    interface = module.params['interface'].lower()
-    direction = module.params['direction'].lower()
-
-    proposed = dict(name=name, interface=interface, direction=direction)
-
-    existing = check_for_acl_int_present(module, name, interface, direction)
-
-    cmds = []
-    commands = []
-    if state == 'present':
-        if not existing:
-            command = apply_acl(proposed)
-            if command:
-                commands.append(command)
-
-    elif state == 'absent':
-        if existing:
-            command = remove_acl(proposed)
-            if command:
-                commands.append(command)
-
-    if commands:
-        cmds = flatten_list(commands)
-        if cmds:
-            if module.check_mode:
-                module.exit_json(changed=True, commands=cmds)
-            else:
-                load_config(module, cmds)
-                results['changed'] = True
-                if 'configure' in cmds:
-                    cmds.pop(0)
-    else:
-        cmds = []
-
-    results['commands'] = cmds
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_acl_interfaces.py b/lib/ansible/modules/network/nxos/nxos_acl_interfaces.py
deleted file mode 100644
index 1b151c63c2..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_acl_interfaces.py
+++ /dev/null
@@ -1,408 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-
-"""
-The module file for nxos_acl_interfaces
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-ANSIBLE_METADATA = {
-    'metadata_version': '1.1',
-    'status': ['preview'],
-    'supported_by': 'network'
-}
-
-DOCUMENTATION = """
----
-module: nxos_acl_interfaces
-version_added: '2.10'
-short_description: Add and remove Access Control Lists on interfaces in NX-OS platform
-description: Add and remove Access Control Lists on interfaces in NX-OS platform
-author: Adharsh Srivats Rangarajan (@adharshsrivatsr)
-notes:
-  - Tested against NX-OS 7.3.(0)D1(1) on VIRL
-options:
-  running_config:
-    description:
-      - Used to parse given commands into structured format, only in parsed state
-    type: str
-  config:
-    description: A list of interfaces to be configured with ACLs
-    type: list
-    elements: dict
-    suboptions:
-      name:
-        description: Name of the interface
-        type: str
-        required: true
-      access_groups:
-        description: List of address family indicators with ACLs to be configured on the interface
-        type: list
-        elements: dict
-        suboptions:
-          afi:
-            description: Address Family Indicator of the ACLs to be configured
-            type: str
-            required: true
-            choices: ['ipv4','ipv6']
-          acls:
-            description: List of Access Control Lists for the interface
-            type: list
-            elements: dict
-            suboptions:
-              name:
-                description: Name of the ACL to be added/removed
-                type: str
-                required: true
-              direction:
-                description: Direction to be applied for the ACL
-                type: str
-                required: true
-                choices: ['in','out']
-              port:
-                description: Use ACL as port policy.
-                type: bool
-  state:
-    description: The state the configuration should be left in
-    type: str
-    choices:
-      - deleted
-      - gathered
-      - merged
-      - overridden
-      - rendered
-      - replaced
-      - parsed
-    default: merged
-"""
-EXAMPLES = """# Using merged
-
-# Before state:
-# ------------
-#
-
-- name: Merge ACL interfaces configuration
-  nxos_acl_interfaces:
-    config:
-      - name: Ethernet1/2
-        access_groups:
-          - afi: ipv6
-            acls:
-              - name: ACL1v6
-                direction: in
-
-      - name: Eth1/5
-        access_groups:
-          - afi: ipv4
-            acls:
-              - name: PortACL
-                direction: in
-                port: true
-
-              - name: ACL1v4
-                direction: out
-
-          - afi: ipv6
-            acls:
-              - name: ACL1v6
-                direction: in
-    state: merged
-
-# After state:
-# ------------
-# interface Ethernet1/2
-#   ipv6 traffic-filter ACL1v6 in
-# interface Ethernet1/5
-#   ip port access-group PortACL in
-#   ip access-group ACL1v4 out
-#   ipv6 traffic-filter ACL1v6 in
-
-# Using replaced
-
-# Before state:
-# ------------
-# interface Ethernet1/2
-#   ipv6 traffic-filter ACL1v6 in
-# interface Ethernet1/5
-#   ip port access-group PortACL in
-#   ip access-group ACL1v4 out
-#   ipv6 traffic-filter ACL1v6 in
-
-- name: Replace interface configuration with given configuration
-  nxos_acl_interfaces:
-    config:
-      - name: Eth1/5
-        access_groups:
-          - afi: ipv4
-            acls:
-              - name: NewACLv4
-                direction: out
-
-      - name: Ethernet1/3
-        access_groups:
-          - afi: ipv6
-            acls:
-              - name: NewACLv6
-                direction: in
-                port: true
-    state: replaced
-
-# After state:
-# ------------
-# interface Ethernet1/2
-#   ipv6 traffic-filter ACL1v6 in
-# interface Ethernet1/3
-#   ipv6 port traffic-filter NewACLv6 in
-# interface Ethernet1/5
-#   ip access-group NewACLv4 out
-
-# Using overridden
-
-# Before state:
-# ------------
-# interface Ethernet1/2
-#   ipv6 traffic-filter ACL1v6 in
-# interface Ethernet1/5
-#   ip port access-group PortACL in
-#   ip access-group ACL1v4 out
-#   ipv6 traffic-filter ACL1v6 in
-
-- name: Override interface configuration with given configuration
-  nxos_acl_interfaces:
-    config:
-      - name: Ethernet1/3
-        access_groups:
-          - afi: ipv4
-            acls:
-              - name: ACL1v4
-                direction: out
-
-              - name: PortACL
-                port: true
-                direction: in
-          - afi: ipv6
-            acls:
-              - name: NewACLv6
-                direction: in
-                port: true
-    state: overridden
-
-# After state:
-# ------------
-# interface Ethernet1/3
-#   ip access-group ACL1v4 out
-#   ip port access-group PortACL in
-#   ipv6 port traffic-filter NewACLv6 in
-
-# Using deleted
-
-# Before state:
-# -------------
-# interface Ethernet1/2
-#   ipv6 traffic-filter ACL1v6 in
-# interface Ethernet1/5
-#   ip port access-group PortACL in
-#   ip access-group ACL1v4 out
-#   ipv6 traffic-filter ACL1v6 in
-
-- name: Delete ACL configuration on interfaces
-  nxos_acl_interfaces:
-    config:
-      - name: Ethernet1/5
-        access_groups:
-          - afi: ipv6
-
-          - afi: ipv4
-            acls:
-              - name: ACL1v4
-                direction: out
-
-      - name: Ethernet1/2
-    state: deleted
-
-# After state:
-# -------------
-# interface Ethernet1/2
-# interface Ethernet1/5
-#   ip port access-group PortACL in
-#   ip access-group ACL1v4 out
-#   ipv6 traffic-filter ACL1v6 in
-
-# Using parsed
-
-- name: Parse given configuration into structured format
-  nxos_acl_interfaces:
-    running_config: |
-      interface Ethernet1/2
-      ipv6 traffic-filter ACL1v6 in
-      interface Ethernet1/5
-      ipv6 traffic-filter ACL1v6 in
-      ip access-group ACL1v4 out
-      ip port access-group PortACL in
-    state: parsed
-
-# returns
-# parsed:
-#   - name: Ethernet1/2
-#     access_groups:
-#       - afi: ipv6
-#         acls:
-#           - name: ACL1v6
-#             direction: in
-#  - name: Ethernet1/5
-#    access_groups:
-#      - afi: ipv4
-#        acls:
-#          - name: PortACL
-#            direction: in
-#            port: True
-#          - name: ACL1v4
-#            direction: out
-#      - afi: ipv6
-#        acls:
-#          - name: ACL1v6
-#             direction: in
-
-
-# Using gathered:
-
-# Before state:
-# ------------
-# interface Ethernet1/2
-#   ipv6 traffic-filter ACL1v6 in
-# interface Ethernet1/5
-#   ipv6 traffic-filter ACL1v6 in
-#   ip access-group ACL1v4 out
-#   ip port access-group PortACL in
-
-- name: Gather existing configuration from device
-  nxos_acl_interfaces:
-    config:
-    state: gathered
-
-# returns
-# gathered:
-#   - name: Ethernet1/2
-#     access_groups:
-#       - afi: ipv6
-#         acls:
-#           - name: ACL1v6
-#             direction: in
-#  - name: Ethernet1/5
-#    access_groups:
-#      - afi: ipv4
-#        acls:
-#          - name: PortACL
-#            direction: in
-#            port: True
-#          - name: ACL1v4
-#            direction: out
-#      - afi: ipv6
-#        acls:
-#          - name: ACL1v6
-#             direction: in
-
-
-# Using rendered
-
-- name: Render required configuration to be pushed to the device
-  nxos_acl_interfaces:
-    config:
-      - name: Ethernet1/2
-        access_groups:
-          - afi: ipv6
-            acls:
-              - name: ACL1v6
-                direction: in
-
-      - name: Ethernet1/5
-        access_groups:
-          - afi: ipv4
-            acls:
-              - name: PortACL
-                direction: in
-                port: true
-              - name: ACL1v4
-                direction: out
-          - afi: ipv6
-            acls:
-              - name: ACL1v6
-                direction: in
-    state: rendered
-
-# returns
-# rendered:
-#   interface Ethernet1/2
-#   ipv6 traffic-filter ACL1v6 in
-#   interface Ethernet1/5
-#   ipv6 traffic-filter ACL1v6 in
-#   ip access-group ACL1v4 out
-#   ip port access-group PortACL in
-
-"""
-RETURN = """
-before:
-  description: The configuration prior to the model invocation.
-  returned: always
-  type: dict
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-after:
-  description: The resulting configuration model invocation.
-  returned: when changed
-  type: dict
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-commands:
-  description: The set of commands pushed to the remote device.
-  returned: always
-  type: list
-  sample: ['interface Ethernet1/2', 'ipv6 traffic-filter ACL1v6 out', 'ip port access-group PortACL in']
-"""
-
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.argspec.acl_interfaces.acl_interfaces import Acl_interfacesArgs
-from ansible.module_utils.network.nxos.config.acl_interfaces.acl_interfaces import Acl_interfaces
-
-
-def main():
-    """
-    Main entry point for module execution
-
-    :returns: the result form module invocation
-    """
-    module = AnsibleModule(argument_spec=Acl_interfacesArgs.argument_spec,
-                           supports_check_mode=True)
-
-    result = Acl_interfaces(module).execute_module()
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_acls.py b/lib/ansible/modules/network/nxos/nxos_acls.py
deleted file mode 100644
index 82d25b96a3..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_acls.py
+++ /dev/null
@@ -1,825 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-"""
-The module file for nxos_acls
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-ANSIBLE_METADATA = {
-    'metadata_version': '1.1',
-    'status': ['preview'],
-    'supported_by': 'network'
-}
-
-DOCUMENTATION = """
----
-module: nxos_acls
-version_added: '2.10'
-short_description: Manage named IP ACLs on the Cisco NX-OS platform
-description: Manage named IP ACLs on the Cisco NX-OS platform
-author: Adharsh Srivats Rangarajan (@adharshsrivatsr)
-notes:
-  - Tested against NX-OS 7.3.(0)D1(1) on VIRL
-  - As NX-OS allows configuring a rule again with different sequence numbers,
-    the user is expected to provide sequence numbers for the access control entries to preserve idempotency.
-    If no sequence number is given, the rule will be added as a new rule by the device.
-  - To parse configuration text, provide the output of show running-config | section access-list or a mocked up config
-options:
-  running_config:
-    description:
-      - Parse given commands into structured format. Required if I(state=parsed).
-    type: str
-  config:
-    description: A dictionary of ACL options.
-    type: list
-    elements: dict
-    suboptions:
-      afi:
-        description: The Address Family Indicator (AFI) for the ACL.
-        type: str
-        required: true
-        choices: ['ipv4', 'ipv6']
-      acls:
-        description: A list of the ACLs.
-        type: list
-        elements: dict
-        suboptions:
-          name:
-            description: Name of the ACL.
-            type: str
-            required: true
-          aces:
-            description: The entries within the ACL.
-            type: list
-            elements: dict
-            suboptions:
-              grant:
-                description: Action to be applied on the rule.
-                type: str
-                choices: ['permit', 'deny']
-              destination:
-                description: Specify the packet destination.
-                type: dict
-                suboptions:
-                  address:
-                    description: Destination network address.
-                    type: str
-                  any:
-                    description: Any destination address.
-                    type: bool
-                  host:
-                    description: Host IP address.
-                    type: str
-                  port_protocol:
-                    description: Specify the destination port or protocol (only for TCP and UDP).
-                    type: dict
-                    suboptions:
-                      eq:
-                        description: Match only packets on a given port number.
-                        type: str
-                      gt:
-                        description: Match only packets with a greater port number.
-                        type: str
-                      lt:
-                        description: Match only packets with a lower port number.
-                        type: str
-                      neq:
-                        description: Match only packets not on a given port number.
-                        type: str
-                      range:
-                        description: Match only packets in the range of port numbers.
-                        type: dict
-                        suboptions:
-                          start:
-                            description: Specify the start of the port range.
-                            type: str
-                          end:
-                            description: Specify the end of the port range.
-                            type: str
-                  prefix:
-                    description: Destination network prefix. Only for prefixes of value less than 31 for ipv4 and 127 for ipv6.
-                                 Prefixes of 32 (ipv4) and 128 (ipv6) should be given in the 'host' key.
-                    type: str
-                  wildcard_bits:
-                    description: Destination wildcard bits.
-                    type: str
-
-              dscp:
-                description: Match packets with given DSCP value.
-                type: str
-
-              fragments:
-                description: Check non-initial fragments.
-                type: bool
-
-              remark:
-                description: Access list entry comment.
-                type: str
-
-              sequence:
-                description: Sequence number.
-                type: int
-
-              source:
-                description: Specify the packet source.
-                type: dict
-                suboptions:
-                  address:
-                    description: Source network address.
-                    type: str
-                  any:
-                    description: Any source address.
-                    type: bool
-                  host:
-                    description: Host IP address.
-                    type: str
-                  port_protocol:
-                    description: Specify the destination port or protocol (only for TCP and UDP).
-                    type: dict
-                    suboptions:
-                      eq:
-                        description: Match only packets on a given port number.
-                        type: str
-                      gt:
-                        description: Match only packets with a greater port number.
-                        type: str
-                      lt:
-                        description: Match only packets with a lower port number.
-                        type: str
-                      neq:
-                        description: Match only packets not on a given port number.
-                        type: str
-                      range:
-                        description: Match only packets in the range of port numbers.
-                        type: dict
-                        suboptions:
-                          start:
-                            description: Specify the start of the port range.
-                            type: str
-                          end:
-                            description: Specify the end of the port range.
-                            type: str
-                  prefix:
-                    description: Source network prefix. Only for prefixes of mask value less than 31 for ipv4 and 127 for ipv6.
-                                 Prefixes of mask 32 (ipv4) and 128 (ipv6) should be given in the 'host' key.
-                    type: str
-                  wildcard_bits:
-                    description: Source wildcard bits.
-                    type: str
-
-              log:
-                description: Log matches against this entry.
-                type: bool
-
-              precedence:
-                description: Match packets with given precedence value.
-                type: str
-
-              protocol:
-                description: Specify the protocol.
-                type: str
-
-              protocol_options:
-                description: All possible suboptions for the protocol chosen.
-                type: dict
-                suboptions:
-                  icmp:
-                    description: ICMP protocol options.
-                    type: dict
-                    suboptions:
-                      administratively_prohibited:
-                        description: Administratively prohibited
-                        type: bool
-                      alternate_address:
-                        description: Alternate address
-                        type: bool
-                      conversion_error:
-                        description: Datagram conversion
-                        type: bool
-                      dod_host_prohibited:
-                        description: Host prohibited
-                        type: bool
-                      dod_net_prohibited:
-                        description: Net prohibited
-                        type: bool
-                      echo:
-                        description: Echo (ping)
-                        type: bool
-                      echo_reply:
-                        description: Echo reply
-                        type: bool
-                      general_parameter_problem:
-                        description: Parameter problem
-                        type: bool
-                      host_isolated:
-                        description: Host isolated
-                        type: bool
-                      host_precedence_unreachable:
-                        description: Host unreachable for precedence
-                        type: bool
-                      host_redirect:
-                        description: Host redirect
-                        type: bool
-                      host_tos_redirect:
-                        description: Host redirect for TOS
-                        type: bool
-                      host_tos_unreachable:
-                        description: Host unreachable for TOS
-                        type: bool
-                      host_unknown:
-                        description: Host unknown
-                        type: bool
-                      host_unreachable:
-                        description: Host unreachable
-                        type: bool
-                      information_reply:
-                        description: Information replies
-                        type: bool
-                      information_request:
-                        description: Information requests
-                        type: bool
-                      mask_reply:
-                        description: Mask replies
-                        type: bool
-                      mask_request:
-                        description: Mask requests
-                        type: bool
-                      message_code:
-                        description: ICMP message code
-                        type: int
-                      message_type:
-                        description: ICMP message type
-                        type: int
-                      mobile_redirect:
-                        description: Mobile host redirect
-                        type: bool
-                      net_redirect:
-                        description: Network redirect
-                        type: bool
-                      net_tos_redirect:
-                        description: Net redirect for TOS
-                        type: bool
-                      net_tos_unreachable:
-                        description: Network unreachable for TOS
-                        type: bool
-                      net_unreachable:
-                        description: Net unreachable
-                        type: bool
-                      network_unknown:
-                        description: Network unknown
-                        type: bool
-                      no_room_for_option:
-                        description: Parameter required but no room
-                        type: bool
-                      option_missing:
-                        description: Parameter required but not present
-                        type: bool
-                      packet_too_big:
-                        description: Fragmentation needed and DF set
-                        type: bool
-                      parameter_problem:
-                        description: All parameter problems
-                        type: bool
-                      port_unreachable:
-                        description: Port unreachable
-                        type: bool
-                      precedence_unreachable:
-                        description: Precedence cutoff
-                        type: bool
-                      protocol_unreachable:
-                        description: Protocol unreachable
-                        type: bool
-                      reassembly_timeout:
-                        description: Reassembly timeout
-                        type: bool
-                      redirect:
-                        description: All redirects
-                        type: bool
-                      router_advertisement:
-                        description: Router discovery advertisements
-                        type: bool
-                      router_solicitation:
-                        description: Router discovery solicitations
-                        type: bool
-                      source_quench:
-                        description: Source quenches
-                        type: bool
-                      source_route_failed:
-                        description: Source route failed
-                        type: bool
-                      time_exceeded:
-                        description: All time exceeded.
-                        type: bool
-                      timestamp_reply:
-                        description: Timestamp replies
-                        type: bool
-                      timestamp_request:
-                        description: Timestamp requests
-                        type: bool
-                      traceroute:
-                        description: Traceroute
-                        type: bool
-                      ttl_exceeded:
-                        description: TTL exceeded
-                        type: bool
-                      unreachable:
-                        description: All unreachables
-                        type: bool
-                  tcp:
-                    description: TCP flags.
-                    type: dict
-                    suboptions:
-                      ack:
-                        description: Match on the ACK bit
-                        type: bool
-                      established:
-                        description: Match established connections
-                        type: bool
-                      fin:
-                        description: Match on the FIN bit
-                        type: bool
-                      psh:
-                        description: Match on the PSH bit
-                        type: bool
-                      rst:
-                        description: Match on the RST bit
-                        type: bool
-                      syn:
-                        description: Match on the SYN bit
-                        type: bool
-                      urg:
-                        description: Match on the URG bit
-                        type: bool
-                  igmp:
-                    description: IGMP protocol options.
-                    type: dict
-                    suboptions:
-                      dvmrp:
-                        description: Distance Vector Multicast Routing Protocol
-                        type: bool
-                      host_query:
-                        description: Host Query
-                        type: bool
-                      host_report:
-                        description: Host Report
-                        type: bool
-
-  state:
-    description:
-      - The state the configuration should be left in
-    type: str
-    choices:
-      - deleted
-      - gathered
-      - merged
-      - overridden
-      - rendered
-      - replaced
-      - parsed
-    default: merged
-"""
-EXAMPLES = """
-# Using merged
-
-# Before state:
-# -------------
-#
-
-- name: Merge new ACLs configuration
-  nxos_acls:
-    config:
-      - afi: ipv4
-        acls:
-          - name: ACL1v4
-            aces:
-              - grant: deny
-                destination:
-                  address: 192.0.2.64
-                  wildcard_bits: 0.0.0.255
-                source:
-                  any: true
-                  port_protocol:
-                    lt: 55
-                protocol: tcp
-                protocol_options:
-                  tcp:
-                    ack: true
-                    fin: true
-                sequence: 50
-
-      - afi: ipv6
-        acls:
-          - name: ACL1v6
-            aces:
-              - grant: permit
-                sequence: 10
-                source:
-                  any: true
-                destination:
-                  prefix: 2001:db8:12::/32
-                protocol: sctp
-    state: merged
-
-# After state:
-# ------------
-#
-# ip access-list ACL1v4
-#  50 deny tcp any lt 55 192.0.2.64 0.0.0.255 ack fin
-# ipv6 access-list ACL1v6
-#  10 permit sctp any any
-
-# Using replaced
-
-# Before state:
-# ----------------
-#
-# ip access-list ACL1v4
-#   10 permit ip any any
-#   20 deny udp any any
-# ip access-list ACL2v4
-#   10 permit ahp 192.0.2.0 0.0.0.255 any
-# ip access-list ACL1v6
-#   10 permit sctp any any
-#   20 remark IPv6 ACL
-# ip access-list ACL2v6
-#  10 deny ipv6 any 2001:db8:3000::/36
-#  20 permit tcp 2001:db8:2000:2::2/128 2001:db8:2000:ab::2/128
-
-- name: Replace existing ACL configuration with provided configuration
-  nxos_acls:
-    config:
-      - afi: ipv4
-      - afi: ipv6
-        acls:
-          - name: ACL1v6
-            aces:
-              - sequence: 20
-                grant: permit
-                source:
-                  any: true
-                destination:
-                  any: true
-                protocol: pip
-
-              - remark: Replaced ACE
-
-          - name: ACL2v6
-    state: replaced
-
-# After state:
-# ---------------
-#
-# ipv6 access-list ACL1v6
-#   20 permit pip any any
-#   30 remark Replaced ACE
-# ipv6 access-list ACL2v6
-
-# Using overridden
-
-# Before state:
-# ----------------
-#
-# ip access-list ACL1v4
-#   10 permit ip any any
-#   20 deny udp any any
-# ip access-list ACL2v4
-#   10 permit ahp 192.0.2.0 0.0.0.255 any
-# ip access-list ACL1v6
-#   10 permit sctp any any
-#   20 remark IPv6 ACL
-# ip access-list ACL2v6
-#  10 deny ipv6 any 2001:db8:3000::/36
-#  20 permit tcp 2001:db8:2000:2::2/128 2001:db8:2000:ab::2/128
-
-- name: Override existing configuration with provided configuration
-  nxos_acls:
-    config:
-      - afi: ipv4
-        acls:
-          - name: NewACL
-            aces:
-              - grant: deny
-                source:
-                  address: 192.0.2.0
-                  wildcard_bits: 0.0.255.255
-                destination:
-                  any: true
-                protocol: eigrp
-              - remark: Example for overridden state
-    state: overridden
-
-# After state:
-# ------------
-#
-# ip access-list NewACL
-#   10 deny eigrp 192.0.2.0 0.0.255.255 any
-#   20 remark Example for overridden state
-
-# Using deleted:
-#
-# Before state:
-# -------------
-#
-# ip access-list ACL1v4
-#   10 permit ip any any
-#   20 deny udp any any
-# ip access-list ACL2v4
-#   10 permit ahp 192.0.2.0 0.0.0.255 any
-# ip access-list ACL1v6
-#   10 permit sctp any any
-#   20 remark IPv6 ACL
-# ip access-list ACL2v6
-#  10 deny ipv6 any 2001:db8:3000::/36
-#  20 permit tcp 2001:db8:2000:2::2/128 2001:db8:2000:ab::2/128
-
-- name: Delete all ACLs
-  nxos_acls:
-    config:
-    state: deleted
-
-# After state:
-# -----------
-#
-
-
-# Before state:
-# -------------
-#
-# ip access-list ACL1v4
-#   10 permit ip any any
-#   20 deny udp any any
-# ip access-list ACL2v4
-#   10 permit ahp 192.0.2.0 0.0.0.255 any
-# ip access-list ACL1v6
-#   10 permit sctp any any
-#   20 remark IPv6 ACL
-# ip access-list ACL2v6
-#  10 deny ipv6 any 2001:db8:3000::/36
-#  20 permit tcp 2001:db8:2000:2::2/128 2001:db8:2000:ab::2/128
-
-- name: Delete all ACLs in given AFI
-  nxos_acls:
-    config:
-      - afi: ipv4
-    state: deleted
-
-# After state:
-# ------------
-#
-# ip access-list ACL1v6
-#   10 permit sctp any any
-#   20 remark IPv6 ACL
-# ip access-list ACL2v6
-#  10 deny ipv6 any 2001:db8:3000::/36
-#  20 permit tcp 2001:db8:2000:2::2/128 2001:db8:2000:ab::2/128
-
-
-
-# Before state:
-# -------------
-#
-# ip access-list ACL1v4
-#   10 permit ip any any
-#   20 deny udp any any
-# ip access-list ACL2v4
-#   10 permit ahp 192.0.2.0 0.0.0.255 any
-# ip access-list ACL1v6
-#   10 permit sctp any any
-#   20 remark IPv6 ACL
-# ip access-list ACL2v6
-#  10 deny ipv6 any 2001:db8:3000::/36
-#  20 permit tcp 2001:db8:2000:2::2/128 2001:db8:2000:ab::2/128
-
-- name: Delete specific ACLs
-  nxos_acls:
-    config:
-      - afi: ipv6
-        acls:
-          - name: ACL1v6
-            aces:
-              - grant: permit
-                sequence: 10
-                source:
-                  any: true
-                destination:
-                  any: true
-                protocol: sctp
-
-              - sequence: 20
-    state: deleted
-
-# After state:
-# ------------
-#
-# ip access-list ACL1v4
-#   10 permit ip any any
-#   20 deny udp any any
-# ip access-list ACL2v4
-#   10 permit ahp 192.0.2.0 0.0.0.255 any
-# ip access-list ACl1v6
-# ip access-list ACL2v6
-#  10 deny ipv6 any 2001:db8:3000::/36
-#  20 permit tcp 2001:db8:2000:2::2/128 2001:db8:2000:ab::2/128
-
-# Using parsed
-
-- name: Parse given config to structured data
-  nxos_acls:
-    running_config: |
-      ip access-list ACL1v4
-        50 deny tcp any lt 55 192.0.2.64 0.0.0.255 ack fin
-      ipv6 access-list ACL1v6
-        10 permit sctp any any
-    state: parsed
-
-# returns:
-# parsed:
-# - afi: ipv4
-#   acls:
-#     - name: ACL1v4
-#       aces:
-#         - grant: deny
-#           destination:
-#             address: 192.0.2.64
-#             wildcard_bits: 0.0.0.255
-#           source:
-#             any: true
-#             port_protocol:
-#               lt: 55
-#           protocol: tcp
-#           protocol_options:
-#             tcp:
-#               ack: true
-#               fin: true
-#           sequence: 50
-#
-# - afi: ipv6
-#   acls:
-#     - name: ACL1v6
-#       aces:
-#         - grant: permit
-#           sequence: 10
-#           source:
-#             any: true
-#           destination:
-#             prefix: 2001:db8:12::/32
-#           protocol: sctp
-
-
-# Using gathered:
-
-# Before state:
-# ------------
-#
-# ip access-list ACL1v4
-#  50 deny tcp any lt 55 192.0.2.64 0.0.0.255 ack fin
-# ipv6 access-list ACL1v6
-#  10 permit sctp any any
-
-- name: Gather existing configuration
-  nxos_acls:
-    state: gathered
-
-# returns:
-# gathered:
-# - afi: ipv4
-#   acls:
-#     - name: ACL1v4
-#       aces:
-#         - grant: deny
-#           destination:
-#             address: 192.0.2.64
-#             wildcard_bits: 0.0.0.255
-#           source:
-#             any: true
-#             port_protocol:
-#               lt: 55
-#           protocol: tcp
-#           protocol_options:
-#             tcp:
-#               ack: true
-#               fin: true
-#           sequence: 50
-
-# - afi: ipv6
-#   acls:
-#     - name: ACL1v6
-#       aces:
-#         - grant: permit
-#           sequence: 10
-#           source:
-#             any: true
-#           destination:
-#             prefix: 2001:db8:12::/32
-#           protocol: sctp
-
-
-# Using rendered
-
-- name: Render required configuration to be pushed to the device
-  nxos_acls:
-    config:
-      - afi: ipv4
-        acls:
-          - name: ACL1v4
-            aces:
-              - grant: deny
-                destination:
-                  address: 192.0.2.64
-                  wildcard_bits: 0.0.0.255
-                source:
-                  any: true
-                  port_protocol:
-                    lt: 55
-                protocol: tcp
-                protocol_options:
-                  tcp:
-                    ack: true
-                    fin: true
-                sequence: 50
-
-      - afi: ipv6
-        acls:
-          - name: ACL1v6
-            aces:
-              - grant: permit
-                sequence: 10
-                source:
-                  any: true
-                destination:
-                  prefix: 2001:db8:12::/32
-                protocol: sctp
-    state: rendered
-
-# returns:
-# rendered:
-#  ip access-list ACL1v4
-#   50 deny tcp any lt 55 192.0.2.64 0.0.0.255 ack fin
-#  ipv6 access-list ACL1v6
-#   10 permit sctp any any
-"""
-RETURN = """
-before:
-  description: The configuration prior to the model invocation.
-  returned: always
-  type: dict
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-after:
-  description: The resulting configuration model invocation.
-  returned: when changed
-  type: dict
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-commands:
-  description: The set of commands pushed to the remote device.
-  returned: always
-  type: list
-  sample: ['ip access-list ACL1v4', '10 permit ip any any precedence critical log', '20 deny tcp any lt smtp host 192.0.2.64 ack fin']
-"""
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.argspec.acls.acls import AclsArgs
-from ansible.module_utils.network.nxos.config.acls.acls import Acls
-
-
-def main():
-    """
-    Main entry point for module execution
-
-    :returns: the result form module invocation
-    """
-    module = AnsibleModule(argument_spec=AclsArgs.argument_spec,
-                           supports_check_mode=True)
-
-    result = Acls(module).execute_module()
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_banner.py b/lib/ansible/modules/network/nxos/nxos_banner.py
deleted file mode 100644
index 6e7b9e13f5..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_banner.py
+++ /dev/null
@@ -1,208 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-
-# (c) 2017, Ansible by Red Hat, inc
-#
-# This file is part of Ansible by Red Hat
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = """
----
-module: nxos_banner
-version_added: "2.4"
-author: "Trishna Guha (@trishnaguha)"
-short_description: Manage multiline banners on Cisco NXOS devices
-description:
-  - This will configure both exec and motd banners on remote devices
-    running Cisco NXOS. It allows playbooks to add or remote
-    banner text from the active running configuration.
-options:
-  banner:
-    description:
-      - Specifies which banner that should be
-        configured on the remote device.
-    required: true
-    choices: ['exec', 'motd']
-  text:
-    description:
-      - The banner text that should be
-        present in the remote device running configuration. This argument
-        accepts a multiline string, with no empty lines. Requires I(state=present).
-  state:
-    description:
-      - Specifies whether or not the configuration is present in the current
-        devices active running configuration.
-    default: present
-    choices: ['present', 'absent']
-extends_documentation_fragment: nxos
-"""
-
-EXAMPLES = """
-- name: configure the exec banner
-  nxos_banner:
-    banner: exec
-    text: |
-      this is my exec banner
-      that contains a multiline
-      string
-    state: present
-- name: remove the motd banner
-  nxos_banner:
-    banner: motd
-    state: absent
-- name: Configure banner from file
-  nxos_banner:
-    banner:  motd
-    text: "{{ lookup('file', './config_partial/raw_banner.cfg') }}"
-    state: present
-"""
-
-RETURN = """
-commands:
-  description: The list of configuration mode commands to send to the device
-  returned: always
-  type: list
-  sample:
-    - banner exec
-    - this is my exec banner
-    - that contains a multiline
-    - string
-"""
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-import re
-
-
-def execute_show_command(module, command):
-    format = 'text'
-    cmds = [{
-        'command': command,
-        'output': format,
-    }]
-    output = run_commands(module, cmds)
-    return output
-
-
-def map_obj_to_commands(want, have, module):
-    commands = list()
-    state = module.params['state']
-    platform_regex = 'Nexus.*Switch'
-
-    if state == 'absent':
-        if (have.get('text') and not ((have.get('text') == 'User Access Verification') or re.match(platform_regex, have.get('text')))):
-            commands.append('no banner %s' % module.params['banner'])
-
-    elif state == 'present' and want.get('text') != have.get('text'):
-        banner_cmd = 'banner %s @\n%s\n@' % (module.params['banner'], want['text'].strip())
-        commands.append(banner_cmd)
-
-    return commands
-
-
-def map_config_to_obj(module):
-    command = 'show banner %s' % module.params['banner']
-    output = execute_show_command(module, command)[0]
-
-    if "Invalid command" in output:
-        module.fail_json(msg="banner: %s may not be supported on this platform.  Possible values are : exec | motd" % module.params['banner'])
-
-    if isinstance(output, dict):
-        output = list(output.values())
-        if output != []:
-            output = output[0]
-        else:
-            output = ''
-        if isinstance(output, dict):
-            output = list(output.values())
-            if output != []:
-                output = output[0]
-            else:
-                output = ''
-    else:
-        output = output.rstrip()
-
-    obj = {'banner': module.params['banner'], 'state': 'absent'}
-    if output:
-        obj['text'] = output
-        obj['state'] = 'present'
-    return obj
-
-
-def map_params_to_obj(module):
-    text = module.params['text']
-    if text:
-        text = str(text).strip()
-
-    return {
-        'banner': module.params['banner'],
-        'text': text,
-        'state': module.params['state']
-    }
-
-
-def main():
-    """ main entry point for module execution
-    """
-    argument_spec = dict(
-        banner=dict(required=True, choices=['exec', 'motd']),
-        text=dict(),
-        state=dict(default='present', choices=['present', 'absent'])
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    required_if = [('state', 'present', ('text',))]
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           required_if=required_if,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    result = {'changed': False}
-    if warnings:
-        result['warnings'] = warnings
-    want = map_params_to_obj(module)
-    have = map_config_to_obj(module)
-    commands = map_obj_to_commands(want, have, module)
-    result['commands'] = commands
-
-    if commands:
-        if not module.check_mode:
-            msgs = load_config(module, commands, True)
-            if msgs:
-                for item in msgs:
-                    if item:
-                        if isinstance(item, dict):
-                            err_str = item['clierror']
-                        else:
-                            err_str = item
-                        if 'more than 40 lines' in err_str or 'buffer overflowed' in err_str:
-                            load_config(module, commands)
-
-        result['changed'] = True
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_bfd_global.py b/lib/ansible/modules/network/nxos/nxos_bfd_global.py
deleted file mode 100644
index d8bbca497d..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_bfd_global.py
+++ /dev/null
@@ -1,330 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_bfd_global
-extends_documentation_fragment: nxos
-version_added: "2.9"
-short_description: Bidirectional Forwarding Detection (BFD) global-level configuration
-description:
-  - Manages Bidirectional Forwarding Detection (BFD) global-level configuration.
-author:
-  - Chris Van Heuveln (@chrisvanheuveln)
-notes:
-    - Tested against NXOSv 9.2(2)
-    - BFD global will automatically enable 'feature bfd' if it is disabled.
-    - BFD global does not have a 'state' parameter. All of the BFD commands are unique and are defined if 'feature bfd' is enabled.
-options:
-  # Top-level commands
-  echo_interface:
-    description:
-      - Loopback interface used for echo frames.
-      - Valid values are loopback interface name or 'deleted'.
-      - Not supported on N5K/N6K
-    required: false
-    type: str
-  echo_rx_interval:
-    description:
-      - BFD Echo receive interval in milliseconds.
-    required: false
-    type: int
-  interval:
-    description:
-      - BFD interval timer values.
-      - Value must be a dict defining values for keys (tx, min_rx, and multiplier)
-    required: false
-    type: dict
-  slow_timer:
-    description:
-      - BFD slow rate timer in milliseconds.
-    required: false
-    type: int
-  startup_timer:
-    description:
-      - BFD delayed startup timer in seconds.
-      - Not supported on N5K/N6K/N7K
-    required: false
-    type: int
-
-  # IPv4/IPv6 specific commands
-  ipv4_echo_rx_interval:
-    description:
-      - BFD IPv4 session echo receive interval in milliseconds.
-    required: false
-    type: int
-  ipv4_interval:
-    description:
-      - BFD IPv4 interval timer values.
-      - Value must be a dict defining values for keys (tx, min_rx, and multiplier).
-    required: false
-    type: dict
-  ipv4_slow_timer:
-    description:
-      - BFD IPv4 slow rate timer in milliseconds.
-    required: false
-    type: int
-  ipv6_echo_rx_interval:
-    description:
-      - BFD IPv6 session echo receive interval in milliseconds.
-    required: false
-    type: int
-  ipv6_interval:
-    description:
-      - BFD IPv6 interval timer values.
-      - Value must be a dict defining values for keys (tx, min_rx, and multiplier).
-    required: false
-    type: dict
-  ipv6_slow_timer:
-    description:
-      - BFD IPv6 slow rate timer in milliseconds.
-    required: false
-    type: int
-
-  # Fabricpath commands
-  fabricpath_interval:
-    description:
-      - BFD fabricpath interval timer values.
-      - Value must be a dict defining values for keys (tx, min_rx, and multiplier).
-    required: false
-    type: dict
-  fabricpath_slow_timer:
-    description:
-      - BFD fabricpath slow rate timer in milliseconds.
-    required: false
-    type: int
-  fabricpath_vlan:
-    description:
-      - BFD fabricpath control vlan.
-    required: false
-    type: int
-
-'''
-EXAMPLES = '''
-- nxos_bfd_global:
-    echo_interface: Ethernet1/2
-    echo_rx_interval: 50
-    interval:
-      tx: 50
-      min_rx: 50
-      multiplier: 4
-'''
-
-RETURN = '''
-cmds:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["bfd echo-interface loopback1", "bfd slow-timer 2000"]
-'''
-
-
-import re
-from ansible.module_utils.network.nxos.nxos import NxosCmdRef
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.network.nxos.nxos import load_config
-from ansible.module_utils.basic import AnsibleModule
-
-BFD_CMD_REF = """
-# The cmd_ref is a yaml formatted list of module commands.
-# A leading underscore denotes a non-command variable; e.g. _template.
-# BFD does not have convenient json data so this cmd_ref uses raw cli configs.
----
-_template: # _template holds common settings for all commands
-  # Enable feature bfd if disabled
-  feature: bfd
-  # Common get syntax for BFD commands
-  get_command: show run bfd all | incl '^(no )*bfd'
-
-echo_interface:
-  kind: str
-  getval: (no )*bfd echo-interface *(\\S+)*$
-  setval: 'bfd echo-interface {0}'
-  default: ~
-
-echo_rx_interval:
-  _exclude: ['N5K', 'N6K']
-  kind: int
-  getval: bfd echo-rx-interval (\\d+)$
-  setval: bfd echo-rx-interval {0}
-  default: 50
-  N3K:
-    default: 250
-
-interval:
-  kind: dict
-  getval: bfd interval (?P<tx>\\d+) min_rx (?P<min_rx>\\d+) multiplier (?P<multiplier>\\d+)
-  setval: bfd interval {tx} min_rx {min_rx} multiplier {multiplier}
-  default: &def_interval
-    tx: 50
-    min_rx: 50
-    multiplier: 3
-  N3K:
-    default: &n3k_def_interval
-      tx: 250
-      min_rx: 250
-      multiplier: 3
-
-slow_timer:
-  kind: int
-  getval: bfd slow-timer (\\d+)$
-  setval: bfd slow-timer {0}
-  default: 2000
-
-startup_timer:
-  _exclude: ['N5K', 'N6K', 'N7K']
-  kind: int
-  getval: bfd startup-timer (\\d+)$
-  setval: bfd startup-timer {0}
-  default: 5
-
-# IPv4/IPv6 specific commands
-ipv4_echo_rx_interval:
-  _exclude: ['N5K', 'N6K']
-  kind: int
-  getval: bfd ipv4 echo-rx-interval (\\d+)$
-  setval: bfd ipv4 echo-rx-interval {0}
-  default: 50
-  N3K:
-    default: 250
-
-ipv4_interval:
-  _exclude: ['N5K', 'N6K']
-  kind: dict
-  getval: bfd ipv4 interval (?P<tx>\\d+) min_rx (?P<min_rx>\\d+) multiplier (?P<multiplier>\\d+)
-  setval: bfd ipv4 interval {tx} min_rx {min_rx} multiplier {multiplier}
-  default: *def_interval
-  N3K:
-    default: *n3k_def_interval
-
-ipv4_slow_timer:
-  _exclude: ['N5K', 'N6K']
-  kind: int
-  getval: bfd ipv4 slow-timer (\\d+)$
-  setval: bfd ipv4 slow-timer {0}
-  default: 2000
-
-ipv6_echo_rx_interval:
-  _exclude: ['N35', 'N5K', 'N6K']
-  kind: int
-  getval: bfd ipv6 echo-rx-interval (\\d+)$
-  setval: bfd ipv6 echo-rx-interval {0}
-  default: 50
-  N3K:
-    default: 250
-
-ipv6_interval:
-  _exclude: ['N35', 'N5K', 'N6K']
-  kind: dict
-  getval: bfd ipv6 interval (?P<tx>\\d+) min_rx (?P<min_rx>\\d+) multiplier (?P<multiplier>\\d+)
-  setval: bfd ipv6 interval {tx} min_rx {min_rx} multiplier {multiplier}
-  default: *def_interval
-  N3K:
-    default: *n3k_def_interval
-
-ipv6_slow_timer:
-  _exclude: ['N35', 'N5K', 'N6K']
-  kind: int
-  getval: bfd ipv6 slow-timer (\\d+)$
-  setval: bfd ipv6 slow-timer {0}
-  default: 2000
-
-# Fabricpath Commands
-fabricpath_interval:
-  _exclude: ['N35', 'N3K', 'N9K']
-  kind: dict
-  getval: bfd fabricpath interval (?P<tx>\\d+) min_rx (?P<min_rx>\\d+) multiplier (?P<multiplier>\\d+)
-  setval: bfd fabricpath interval {tx} min_rx {min_rx} multiplier {multiplier}
-  default: *def_interval
-
-fabricpath_slow_timer:
-  _exclude: ['N35', 'N3K', 'N9K']
-  kind: int
-  getval: bfd fabricpath slow-timer (\\d+)$
-  setval: bfd fabricpath slow-timer {0}
-  default: 2000
-
-fabricpath_vlan:
-  _exclude: ['N35', 'N3K', 'N9K']
-  kind: int
-  getval: bfd fabricpath vlan (\\d+)$
-  setval: bfd fabricpath vlan {0}
-  default: 1
-"""
-
-
-def reorder_cmds(cmds):
-    '''
-    There is a bug in some image versions where bfd echo-interface and
-    bfd echo-rx-interval need to be applied last for them to nvgen properly.
-    '''
-    regex1 = re.compile(r'^bfd echo-interface')
-    regex2 = re.compile(r'^bfd echo-rx-interval')
-    filtered_cmds = [i for i in cmds if not regex1.match(i)]
-    filtered_cmds = [i for i in filtered_cmds if not regex2.match(i)]
-    echo_int_cmd = [i for i in cmds if regex1.match(i)]
-    echo_rx_cmd = [i for i in cmds if regex2.match(i)]
-    filtered_cmds.extend(echo_int_cmd)
-    filtered_cmds.extend(echo_rx_cmd)
-
-    return filtered_cmds
-
-
-def main():
-    argument_spec = dict(
-        echo_interface=dict(required=False, type='str'),
-        echo_rx_interval=dict(required=False, type='int'),
-        interval=dict(required=False, type='dict'),
-        slow_timer=dict(required=False, type='int'),
-        startup_timer=dict(required=False, type='int'),
-        ipv4_echo_rx_interval=dict(required=False, type='int'),
-        ipv4_interval=dict(required=False, type='dict'),
-        ipv4_slow_timer=dict(required=False, type='int'),
-        ipv6_echo_rx_interval=dict(required=False, type='int'),
-        ipv6_interval=dict(required=False, type='dict'),
-        ipv6_slow_timer=dict(required=False, type='int'),
-        fabricpath_interval=dict(required=False, type='dict'),
-        fabricpath_slow_timer=dict(required=False, type='int'),
-        fabricpath_vlan=dict(required=False, type='int'),
-    )
-    argument_spec.update(nxos_argument_spec)
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-    warnings = list()
-
-    cmd_ref = NxosCmdRef(module, BFD_CMD_REF)
-    cmd_ref.get_existing()
-    cmd_ref.get_playvals()
-    cmds = reorder_cmds(cmd_ref.get_proposed())
-
-    result = {'changed': False, 'commands': cmds, 'warnings': warnings,
-              'check_mode': module.check_mode}
-    if cmds:
-        result['changed'] = True
-        if not module.check_mode:
-            load_config(module, cmds)
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_bfd_interfaces.py b/lib/ansible/modules/network/nxos/nxos_bfd_interfaces.py
deleted file mode 100644
index fde343edb6..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_bfd_interfaces.py
+++ /dev/null
@@ -1,173 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright 2019 Cisco and/or its affiliates.
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-
-"""
-The module file for nxos_bfd_interfaces
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-ANSIBLE_METADATA = {
-    'metadata_version': '1.1',
-    'status': ['preview'],
-    'supported_by': 'network'
-}
-
-DOCUMENTATION = """
----
-module: nxos_bfd_interfaces
-version_added: 2.9
-short_description: 'Manages BFD attributes of nxos interfaces.'
-description: 'Manages attributes of Bidirectional Forwarding Detection (BFD) on the interface.'
-author: Chris Van Heuveln (@chrisvanheuveln)
-notes:
-options:
-  config:
-    description: The provided configuration
-    type: list
-    elements: dict
-    suboptions:
-      name:
-        type: str
-        description: The name of the interface.
-      bfd:
-        type: str
-        description:
-        - Enable/Disable Bidirectional Forwarding Detection (BFD) on the interface.
-        choices:
-        - enable
-        - disable
-      echo:
-        type: str
-        description:
-        - Enable/Disable BFD Echo functionality on the interface.
-        choices:
-        - enable
-        - disable
-  state:
-    description:
-    - The state of the configuration after module completion
-    type: str
-    choices:
-    - merged
-    - replaced
-    - overridden
-    - deleted
-    default: merged
-"""
-EXAMPLES = """
-# Using deleted
-
-- name: Configure interfaces
-  nxos_bfd_interfaces:
-    state: deleted
-
-
-# Using merged
-
-- name: Configure interfaces
-  nxos_bfd_interfaces:
-    config:
-      - name: Ethernet1/1
-        bfd: enable
-        echo: enable
-      - name: Ethernet1/2
-        bfd: disable
-        echo: disable
-    state: merged
-
-
-# Using overridden
-
-- name: Configure interfaces
-  nxos_bfd_interfaces:
-    config:
-      - name: Ethernet1/1
-        bfd: enable
-        echo: enable
-      - name: Ethernet1/2
-        bfd: disable
-        echo: disable
-    state: overridden
-
-
-# Using replaced
-
-- name: Configure interfaces
-  nxos_bfd_interfaces:
-    config:
-      - name: Ethernet1/1
-        bfd: enable
-        echo: enable
-      - name: Ethernet1/2
-        bfd: disable
-        echo: disable
-    state: replaced
-
-
-"""
-RETURN = """
-before:
-  description: The configuration as structured data prior to module invocation.
-  returned: always
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-after:
-  description: The configuration as structured data after module completion.
-  returned: when changed
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-commands:
-  description: The set of commands pushed to the remote device.
-  returned: always
-  type: list
-  sample: ['interface Ethernet1/1', 'no bfd', 'no bfd echo']
-"""
-
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.argspec.bfd_interfaces.bfd_interfaces import Bfd_interfacesArgs
-from ansible.module_utils.network.nxos.config.bfd_interfaces.bfd_interfaces import Bfd_interfaces
-
-
-def main():
-    """
-    Main entry point for module execution
-
-    :returns: the result form module invocation
-    """
-    module = AnsibleModule(argument_spec=Bfd_interfacesArgs.argument_spec,
-                           supports_check_mode=True)
-
-    result = Bfd_interfaces(module).execute_module()
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_bgp.py b/lib/ansible/modules/network/nxos/nxos_bgp.py
deleted file mode 100644
index d17e9c36ea..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_bgp.py
+++ /dev/null
@@ -1,663 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_bgp
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages BGP configuration.
-description:
-    - Manages BGP configurations on NX-OS switches.
-author:
-    - Jason Edelman (@jedelman8)
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - C(state=absent) removes the whole BGP ASN configuration when
-      C(vrf=default) or the whole VRF instance within the BGP process when
-      using a different VRF.
-    - Default when supported restores params default value.
-    - Configuring global params is only permitted if C(vrf=default).
-options:
-    asn:
-        description:
-            - BGP autonomous system number. Valid values are String,
-              Integer in ASPLAIN or ASDOT notation.
-        required: true
-    vrf:
-        description:
-            - Name of the VRF. The name 'default' is a valid VRF representing
-              the global BGP.
-    bestpath_always_compare_med:
-        description:
-            - Enable/Disable MED comparison on paths from different
-              autonomous systems.
-        type: bool
-    bestpath_aspath_multipath_relax:
-        description:
-            - Enable/Disable load sharing across the providers with
-              different (but equal-length) AS paths.
-        type: bool
-    bestpath_compare_routerid:
-        description:
-            - Enable/Disable comparison of router IDs for identical eBGP paths.
-        type: bool
-    bestpath_compare_neighborid:
-        description:
-            - Enable/Disable neighborid. Use this when more paths available than max path config.
-        type: bool
-    bestpath_cost_community_ignore:
-        description:
-            - Enable/Disable Ignores the cost community for BGP best-path
-              calculations.
-        type: bool
-    bestpath_med_confed:
-        description:
-            - Enable/Disable enforcement of bestpath to do a MED comparison
-              only between paths originated within a confederation.
-        type: bool
-    bestpath_med_missing_as_worst:
-        description:
-            - Enable/Disable assigns the value of infinity to received
-              routes that do not carry the MED attribute, making these routes
-              the least desirable.
-        type: bool
-    bestpath_med_non_deterministic:
-        description:
-            - Enable/Disable deterministic selection of the best MED pat
-              from among the paths from the same autonomous system.
-        type: bool
-    cluster_id:
-        description:
-            - Route Reflector Cluster-ID.
-    confederation_id:
-        description:
-            - Routing domain confederation AS.
-    confederation_peers:
-        description:
-            - AS confederation parameters.
-    disable_policy_batching:
-        description:
-            - Enable/Disable the batching evaluation of prefix advertisement
-              to all peers.
-        type: bool
-    disable_policy_batching_ipv4_prefix_list:
-        description:
-            - Enable/Disable the batching evaluation of prefix advertisements
-              to all peers with prefix list.
-    disable_policy_batching_ipv6_prefix_list:
-        description:
-            - Enable/Disable the batching evaluation of prefix advertisements
-              to all peers with prefix list.
-    enforce_first_as:
-        description:
-            - Enable/Disable enforces the neighbor autonomous system to be
-              the first AS number listed in the AS path attribute for eBGP.
-              On NX-OS, this property is only supported in the
-              global BGP context.
-        type: bool
-    event_history_cli:
-        description:
-            - Enable/Disable cli event history buffer.
-        choices: ['size_small', 'size_medium', 'size_large', 'size_disable', 'default']
-    event_history_detail:
-        description:
-            - Enable/Disable detail event history buffer.
-        choices: ['size_small', 'size_medium', 'size_large', 'size_disable', 'default']
-    event_history_events:
-        description:
-            - Enable/Disable event history buffer.
-        choices: ['size_small', 'size_medium', 'size_large', 'size_disable', 'default']
-    event_history_periodic:
-        description:
-            - Enable/Disable periodic event history buffer.
-        choices: ['size_small', 'size_medium', 'size_large', 'size_disable', 'default']
-    fast_external_fallover:
-        description:
-            - Enable/Disable immediately reset the session if the link to a
-              directly connected BGP peer goes down.  Only supported in the
-              global BGP context.
-        type: bool
-    flush_routes:
-        description:
-            - Enable/Disable flush routes in RIB upon controlled restart.
-              On NX-OS, this property is only supported in the global
-              BGP context.
-        type: bool
-    graceful_restart:
-        description:
-            - Enable/Disable graceful restart.
-        type: bool
-    graceful_restart_helper:
-        description:
-            - Enable/Disable graceful restart helper mode.
-        type: bool
-    graceful_restart_timers_restart:
-        description:
-            - Set maximum time for a restart sent to the BGP peer.
-    graceful_restart_timers_stalepath_time:
-        description:
-            - Set maximum time that BGP keeps the stale routes from the
-              restarting BGP peer.
-    isolate:
-        description:
-            - Enable/Disable isolate this router from BGP perspective.
-        type: bool
-    local_as:
-        description:
-            - Local AS number to be used within a VRF instance.
-    log_neighbor_changes:
-        description:
-            - Enable/Disable message logging for neighbor up/down event.
-        type: bool
-    maxas_limit:
-        description:
-            - Specify Maximum number of AS numbers allowed in the AS-path
-              attribute. Valid values are between 1 and 512.
-    neighbor_down_fib_accelerate:
-        description:
-            - Enable/Disable handle BGP neighbor down event, due to
-              various reasons.
-        type: bool
-    reconnect_interval:
-        description:
-            - The BGP reconnection interval for dropped sessions.
-              Valid values are between 1 and 60.
-    router_id:
-        description:
-            - Router Identifier (ID) of the BGP router VRF instance.
-    shutdown:
-        description:
-            - Administratively shutdown the BGP protocol.
-        type: bool
-    suppress_fib_pending:
-        description:
-            - Enable/Disable advertise only routes programmed in hardware
-              to peers.
-        type: bool
-    timer_bestpath_limit:
-        description:
-            - Specify timeout for the first best path after a restart,
-              in seconds.
-    timer_bgp_hold:
-        description:
-            - Set BGP hold timer.
-    timer_bgp_keepalive:
-        description:
-            - Set BGP keepalive timer.
-    state:
-        description:
-            - Determines whether the config should be present or not
-              on the device.
-        default: present
-        choices: ['present','absent']
-'''
-
-
-EXAMPLES = '''
-- name: Configure a simple ASN
-  nxos_bgp:
-      asn: 65535
-      vrf: test
-      router_id: 192.0.2.1
-      state: present
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["router bgp 65535", "vrf test", "router-id 192.0.2.1"]
-'''
-
-import re
-
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-
-
-BOOL_PARAMS = [
-    'bestpath_always_compare_med',
-    'bestpath_aspath_multipath_relax',
-    'bestpath_compare_neighborid',
-    'bestpath_compare_routerid',
-    'bestpath_cost_community_ignore',
-    'bestpath_med_confed',
-    'bestpath_med_missing_as_worst',
-    'bestpath_med_non_deterministic',
-    'disable_policy_batching',
-    'enforce_first_as',
-    'fast_external_fallover',
-    'flush_routes',
-    'graceful_restart',
-    'graceful_restart_helper',
-    'isolate',
-    'log_neighbor_changes',
-    'neighbor_down_fib_accelerate',
-    'shutdown',
-    'suppress_fib_pending'
-]
-GLOBAL_PARAMS = [
-    'disable_policy_batching',
-    'disable_policy_batching_ipv4_prefix_list',
-    'disable_policy_batching_ipv6_prefix_list',
-    'enforce_first_as',
-    'event_history_cli',
-    'event_history_detail',
-    'event_history_events',
-    'event_history_periodic',
-    'fast_external_fallover',
-    'flush_routes',
-    'isolate',
-    'suppress_fib_pending',
-    'shutdown'
-]
-PARAM_TO_DEFAULT_KEYMAP = {
-    'timer_bgp_keepalive': '60',
-    'timer_bgp_hold': '180',
-    'timer_bestpath_limit': '300',
-    'graceful_restart': True,
-    'graceful_restart_timers_restart': '120',
-    'graceful_restart_timers_stalepath_time': '300',
-    'reconnect_interval': '60',
-    'suppress_fib_pending': True,
-    'fast_external_fallover': True,
-    'enforce_first_as': True,
-    'event_history_cli': True,
-    'event_history_detail': False,
-    'event_history_events': True,
-    'event_history_periodic': True,
-    'maxas_limit': '',
-    'router_id': '',
-    'cluster_id': '',
-    'disable_policy_batching_ipv4_prefix_list': '',
-    'disable_policy_batching_ipv6_prefix_list': '',
-    'local_as': '',
-    'confederation_id': '',
-}
-PARAM_TO_COMMAND_KEYMAP = {
-    'asn': 'router bgp',
-    'bestpath_always_compare_med': 'bestpath always-compare-med',
-    'bestpath_aspath_multipath_relax': 'bestpath as-path multipath-relax',
-    'bestpath_compare_neighborid': 'bestpath compare-neighborid',
-    'bestpath_compare_routerid': 'bestpath compare-routerid',
-    'bestpath_cost_community_ignore': 'bestpath cost-community ignore',
-    'bestpath_med_confed': 'bestpath med confed',
-    'bestpath_med_missing_as_worst': 'bestpath med missing-as-worst',
-    'bestpath_med_non_deterministic': 'bestpath med non-deterministic',
-    'cluster_id': 'cluster-id',
-    'confederation_id': 'confederation identifier',
-    'confederation_peers': 'confederation peers',
-    'disable_policy_batching': 'disable-policy-batching',
-    'disable_policy_batching_ipv4_prefix_list': 'disable-policy-batching ipv4 prefix-list',
-    'disable_policy_batching_ipv6_prefix_list': 'disable-policy-batching ipv6 prefix-list',
-    'enforce_first_as': 'enforce-first-as',
-    'event_history_cli': 'event-history cli',
-    'event_history_detail': 'event-history detail',
-    'event_history_events': 'event-history events',
-    'event_history_periodic': 'event-history periodic',
-    'fast_external_fallover': 'fast-external-fallover',
-    'flush_routes': 'flush-routes',
-    'graceful_restart': 'graceful-restart',
-    'graceful_restart_helper': 'graceful-restart-helper',
-    'graceful_restart_timers_restart': 'graceful-restart restart-time',
-    'graceful_restart_timers_stalepath_time': 'graceful-restart stalepath-time',
-    'isolate': 'isolate',
-    'local_as': 'local-as',
-    'log_neighbor_changes': 'log-neighbor-changes',
-    'maxas_limit': 'maxas-limit',
-    'neighbor_down_fib_accelerate': 'neighbor-down fib-accelerate',
-    'reconnect_interval': 'reconnect-interval',
-    'router_id': 'router-id',
-    'shutdown': 'shutdown',
-    'suppress_fib_pending': 'suppress-fib-pending',
-    'timer_bestpath_limit': 'timers bestpath-limit',
-    'timer_bgp_hold': 'timers bgp',
-    'timer_bgp_keepalive': 'timers bgp',
-    'vrf': 'vrf'
-}
-
-
-def get_value(arg, config):
-    command = PARAM_TO_COMMAND_KEYMAP.get(arg)
-
-    if command.split()[0] == 'event-history':
-        has_size = re.search(r'^\s+{0} size\s(?P<value>.*)$'.format(command), config, re.M)
-
-        if command == 'event-history detail':
-            value = False
-        else:
-            value = 'size_small'
-
-        if has_size:
-            value = 'size_%s' % has_size.group('value')
-
-    elif arg in ['enforce_first_as', 'fast_external_fallover']:
-        no_command_re = re.compile(r'no\s+{0}\s*'.format(command), re.M)
-        value = True
-
-        if no_command_re.search(config):
-            value = False
-
-    elif arg in BOOL_PARAMS:
-        has_command = re.search(r'^\s+{0}\s*$'.format(command), config, re.M)
-        value = False
-
-        if has_command:
-            value = True
-    else:
-        command_val_re = re.compile(r'(?:{0}\s)(?P<value>.*)'.format(command), re.M)
-        value = ''
-
-        has_command = command_val_re.search(config)
-        if has_command:
-            found_value = has_command.group('value')
-
-            if arg == 'confederation_peers':
-                value = found_value.split()
-            elif arg == 'timer_bgp_keepalive':
-                value = found_value.split()[0]
-            elif arg == 'timer_bgp_hold':
-                split_values = found_value.split()
-                if len(split_values) == 2:
-                    value = split_values[1]
-            elif found_value:
-                value = found_value
-
-    return value
-
-
-def get_existing(module, args, warnings):
-    existing = {}
-    netcfg = CustomNetworkConfig(indent=2, contents=get_config(module, flags=['bgp all']))
-
-    asn_re = re.compile(r'.*router\sbgp\s(?P<existing_asn>\d+(\.\d+)?).*', re.S)
-    asn_match = asn_re.match(str(netcfg))
-
-    if asn_match:
-        existing_asn = asn_match.group('existing_asn')
-        bgp_parent = 'router bgp {0}'.format(existing_asn)
-
-        if module.params['vrf'] != 'default':
-            parents = [bgp_parent, 'vrf {0}'.format(module.params['vrf'])]
-        else:
-            parents = [bgp_parent]
-
-        config = netcfg.get_section(parents)
-        if config:
-            for arg in args:
-                if arg != 'asn' and (module.params['vrf'] == 'default' or
-                                     arg not in GLOBAL_PARAMS):
-                    existing[arg] = get_value(arg, config)
-
-            existing['asn'] = existing_asn
-            if module.params['vrf'] == 'default':
-                existing['vrf'] = 'default'
-
-    if not existing and module.params['vrf'] != 'default' and module.params['state'] == 'present':
-        msg = ("VRF {0} doesn't exist.".format(module.params['vrf']))
-        warnings.append(msg)
-
-    return existing
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key in table:
-        new_key = key_map.get(key)
-        if new_key:
-            new_dict[new_key] = table.get(key)
-
-    return new_dict
-
-
-def state_present(module, existing, proposed, candidate):
-    commands = list()
-    proposed_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, proposed)
-    existing_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, existing)
-
-    for key, value in proposed_commands.items():
-        if value is True:
-            commands.append(key)
-        elif value is False:
-            commands.append('no {0}'.format(key))
-        elif value == 'default':
-            default_value = PARAM_TO_DEFAULT_KEYMAP.get(key)
-            existing_value = existing_commands.get(key)
-
-            if default_value:
-                commands.append('{0} {1}'.format(key, default_value))
-            elif existing_value:
-                if key == 'confederation peers':
-                    existing_value = ' '.join(existing_value)
-                commands.append('no {0} {1}'.format(key, existing_value))
-        elif not value:
-            existing_value = existing_commands.get(key)
-            if existing_value:
-                commands.append('no {0} {1}'.format(key, existing_value))
-        elif key == 'confederation peers':
-            commands.append('{0} {1}'.format(key, value))
-        elif key.startswith('timers bgp'):
-            command = 'timers bgp {0} {1}'.format(
-                proposed['timer_bgp_keepalive'],
-                proposed['timer_bgp_hold'])
-            if command not in commands:
-                commands.append(command)
-        else:
-            if value.startswith('size'):
-                value = value.replace('_', ' ')
-            command = '{0} {1}'.format(key, value)
-            commands.append(command)
-
-    parents = []
-    if commands:
-        commands = fix_commands(commands)
-        parents = ['router bgp {0}'.format(module.params['asn'])]
-        if module.params['vrf'] != 'default':
-            parents.append('vrf {0}'.format(module.params['vrf']))
-    elif proposed:
-        if module.params['vrf'] != 'default':
-            commands.append('vrf {0}'.format(module.params['vrf']))
-            parents = ['router bgp {0}'.format(module.params['asn'])]
-        else:
-            commands.append('router bgp {0}'.format(module.params['asn']))
-
-    candidate.add(commands, parents=parents)
-
-
-def state_absent(module, existing, candidate):
-    commands = []
-    parents = []
-    if module.params['vrf'] == 'default':
-        commands.append('no router bgp {0}'.format(module.params['asn']))
-    elif existing.get('vrf') == module.params['vrf']:
-        commands.append('no vrf {0}'.format(module.params['vrf']))
-        parents = ['router bgp {0}'.format(module.params['asn'])]
-
-    candidate.add(commands, parents=parents)
-
-
-def fix_commands(commands):
-    local_as_command = ''
-    confederation_id_command = ''
-    confederation_peers_command = ''
-
-    for command in commands:
-        if 'local-as' in command:
-            local_as_command = command
-        elif 'confederation identifier' in command:
-            confederation_id_command = command
-        elif 'confederation peers' in command:
-            confederation_peers_command = command
-
-    if local_as_command and confederation_id_command:
-        if 'no' in confederation_id_command:
-            commands.pop(commands.index(local_as_command))
-            commands.pop(commands.index(confederation_id_command))
-            commands.append(confederation_id_command)
-            commands.append(local_as_command)
-        else:
-            commands.pop(commands.index(local_as_command))
-            commands.pop(commands.index(confederation_id_command))
-            commands.append(local_as_command)
-            commands.append(confederation_id_command)
-
-    if confederation_peers_command and confederation_id_command:
-        if local_as_command:
-            if 'no' in local_as_command:
-                commands.pop(commands.index(local_as_command))
-                commands.pop(commands.index(confederation_id_command))
-                commands.pop(commands.index(confederation_peers_command))
-                commands.append(confederation_id_command)
-                commands.append(confederation_peers_command)
-                commands.append(local_as_command)
-            else:
-                commands.pop(commands.index(local_as_command))
-                commands.pop(commands.index(confederation_id_command))
-                commands.pop(commands.index(confederation_peers_command))
-                commands.append(local_as_command)
-                commands.append(confederation_id_command)
-                commands.append(confederation_peers_command)
-        else:
-            commands.pop(commands.index(confederation_peers_command))
-            commands.pop(commands.index(confederation_id_command))
-            commands.append(confederation_id_command)
-            commands.append(confederation_peers_command)
-
-    return commands
-
-
-def main():
-    argument_spec = dict(
-        asn=dict(required=True, type='str'),
-        vrf=dict(required=False, type='str', default='default'),
-        bestpath_always_compare_med=dict(required=False, type='bool'),
-        bestpath_aspath_multipath_relax=dict(required=False, type='bool'),
-        bestpath_compare_neighborid=dict(required=False, type='bool'),
-        bestpath_compare_routerid=dict(required=False, type='bool'),
-        bestpath_cost_community_ignore=dict(required=False, type='bool'),
-        bestpath_med_confed=dict(required=False, type='bool'),
-        bestpath_med_missing_as_worst=dict(required=False, type='bool'),
-        bestpath_med_non_deterministic=dict(required=False, type='bool'),
-        cluster_id=dict(required=False, type='str'),
-        confederation_id=dict(required=False, type='str'),
-        confederation_peers=dict(required=False, type='list'),
-        disable_policy_batching=dict(required=False, type='bool'),
-        disable_policy_batching_ipv4_prefix_list=dict(required=False, type='str'),
-        disable_policy_batching_ipv6_prefix_list=dict(required=False, type='str'),
-        enforce_first_as=dict(required=False, type='bool'),
-        event_history_cli=dict(required=False, choices=['true', 'false', 'default', 'size_small', 'size_medium', 'size_large', 'size_disable']),
-        event_history_detail=dict(required=False, choices=['true', 'false', 'default', 'size_small', 'size_medium', 'size_large', 'size_disable']),
-        event_history_events=dict(required=False, choices=['true', 'false', 'default', 'size_small', 'size_medium', 'size_large', 'size_disable']),
-        event_history_periodic=dict(required=False, choices=['true', 'false', 'default', 'size_small', 'size_medium', 'size_large', 'size_disable']),
-        fast_external_fallover=dict(required=False, type='bool'),
-        flush_routes=dict(required=False, type='bool'),
-        graceful_restart=dict(required=False, type='bool'),
-        graceful_restart_helper=dict(required=False, type='bool'),
-        graceful_restart_timers_restart=dict(required=False, type='str'),
-        graceful_restart_timers_stalepath_time=dict(required=False, type='str'),
-        isolate=dict(required=False, type='bool'),
-        local_as=dict(required=False, type='str'),
-        log_neighbor_changes=dict(required=False, type='bool'),
-        maxas_limit=dict(required=False, type='str'),
-        neighbor_down_fib_accelerate=dict(required=False, type='bool'),
-        reconnect_interval=dict(required=False, type='str'),
-        router_id=dict(required=False, type='str'),
-        shutdown=dict(required=False, type='bool'),
-        suppress_fib_pending=dict(required=False, type='bool'),
-        timer_bestpath_limit=dict(required=False, type='str'),
-        timer_bgp_hold=dict(required=False, type='str'),
-        timer_bgp_keepalive=dict(required=False, type='str'),
-        state=dict(choices=['present', 'absent'], default='present', required=False),
-    )
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           required_together=[['timer_bgp_hold', 'timer_bgp_keepalive']],
-                           supports_check_mode=True)
-
-    warnings = list()
-    result = dict(changed=False, warnings=warnings)
-
-    state = module.params['state']
-
-    if module.params['vrf'] != 'default':
-        for param in GLOBAL_PARAMS:
-            if module.params[param]:
-                module.fail_json(msg='Global params can be modified only under "default" VRF.',
-                                 vrf=module.params['vrf'],
-                                 global_param=param)
-
-    args = PARAM_TO_COMMAND_KEYMAP.keys()
-    existing = get_existing(module, args, warnings)
-
-    if existing.get('asn') and state == 'present':
-        if existing.get('asn') != module.params['asn']:
-            module.fail_json(msg='Another BGP ASN already exists.',
-                             proposed_asn=module.params['asn'],
-                             existing_asn=existing.get('asn'))
-
-    proposed_args = dict((k, v) for k, v in module.params.items()
-                         if v is not None and k in args)
-    proposed = {}
-    for key, value in proposed_args.items():
-        if key not in ['asn', 'vrf']:
-            if str(value).lower() == 'default':
-                value = PARAM_TO_DEFAULT_KEYMAP.get(key, 'default')
-            if key == 'confederation_peers':
-                if value[0] == 'default':
-                    if existing.get(key):
-                        proposed[key] = 'default'
-                else:
-                    v = set([int(i) for i in value])
-                    ex = set([int(i) for i in existing.get(key)])
-                    if v != ex:
-                        proposed[key] = ' '.join(str(s) for s in v)
-            else:
-                if existing.get(key) != value:
-                    proposed[key] = value
-
-    candidate = CustomNetworkConfig(indent=3)
-    if state == 'present':
-        state_present(module, existing, proposed, candidate)
-    elif existing.get('asn') == module.params['asn']:
-        state_absent(module, existing, candidate)
-
-    if candidate:
-        candidate = candidate.items_text()
-        if not module.check_mode:
-            load_config(module, candidate)
-        result['changed'] = True
-        result['commands'] = candidate
-    else:
-        result['commands'] = []
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_bgp_af.py b/lib/ansible/modules/network/nxos/nxos_bgp_af.py
deleted file mode 100644
index 3b34b73ab1..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_bgp_af.py
+++ /dev/null
@@ -1,776 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_bgp_af
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages BGP Address-family configuration.
-description:
-  - Manages BGP Address-family configurations on NX-OS switches.
-author: Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - C(state=absent) removes the whole BGP ASN configuration
-  - Default, where supported, restores params default value.
-options:
-  asn:
-    description:
-      - BGP autonomous system number. Valid values are String,
-        Integer in ASPLAIN or ASDOT notation.
-    required: true
-  vrf:
-    description:
-      - Name of the VRF. The name 'default' is a valid VRF representing
-        the global bgp.
-    required: true
-  afi:
-    description:
-      - Address Family Identifier.
-    required: true
-    choices: ['ipv4','ipv6', 'vpnv4', 'vpnv6', 'l2vpn']
-  safi:
-    description:
-      - Sub Address Family Identifier.
-    required: true
-    choices: ['unicast','multicast', 'evpn']
-  additional_paths_install:
-    description:
-      - Install a backup path into the forwarding table and provide
-        prefix independent convergence (PIC) in case of a PE-CE link
-        failure.
-    type: bool
-  additional_paths_receive:
-    description:
-      - Enables the receive capability of additional paths for all of
-        the neighbors under this address family for which the capability
-        has not been disabled.
-    type: bool
-  additional_paths_selection:
-    description:
-      - Configures the capability of selecting additional paths for
-        a prefix. Valid values are a string defining the name of
-        the route-map.
-  additional_paths_send:
-    description:
-      - Enables the send capability of additional paths for all of
-        the neighbors under this address family for which the capability
-        has not been disabled.
-    type: bool
-  advertise_l2vpn_evpn:
-    description:
-      - Advertise evpn routes.
-    type: bool
-  client_to_client:
-    description:
-      - Configure client-to-client route reflection.
-    type: bool
-  dampen_igp_metric:
-    description:
-      - Specify dampen value for IGP metric-related changes, in seconds.
-        Valid values are integer and keyword 'default'.
-  dampening_state:
-    description:
-      - Enable/disable route-flap dampening.
-    type: bool
-  dampening_half_time:
-    description:
-      - Specify decay half-life in minutes for route-flap dampening.
-        Valid values are integer and keyword 'default'.
-  dampening_max_suppress_time:
-    description:
-      - Specify max suppress time for route-flap dampening stable route.
-        Valid values are integer and keyword 'default'.
-  dampening_reuse_time:
-    description:
-      - Specify route reuse time for route-flap dampening.
-        Valid values are integer and keyword 'default'.
-  dampening_routemap:
-    description:
-      - Specify route-map for route-flap dampening. Valid values are a
-        string defining the name of the route-map.
-  dampening_suppress_time:
-    description:
-      - Specify route suppress time for route-flap dampening.
-        Valid values are integer and keyword 'default'.
-  default_information_originate:
-    description:
-      - Default information originate.
-    type: bool
-  default_metric:
-    description:
-      - Sets default metrics for routes redistributed into BGP.
-        Valid values are Integer or keyword 'default'
-  distance_ebgp:
-    description:
-      - Sets the administrative distance for eBGP routes.
-        Valid values are Integer or keyword 'default'.
-  distance_ibgp:
-    description:
-      - Sets the administrative distance for iBGP routes.
-        Valid values are Integer or keyword 'default'.
-  distance_local:
-    description:
-      - Sets the administrative distance for local BGP routes.
-        Valid values are Integer or keyword 'default'.
-  inject_map:
-    description:
-      - An array of route-map names which will specify prefixes to
-        inject. Each array entry must first specify the inject-map name,
-        secondly an exist-map name, and optionally the copy-attributes
-        keyword which indicates that attributes should be copied from
-        the aggregate. For example [['lax_inject_map', 'lax_exist_map'],
-        ['nyc_inject_map', 'nyc_exist_map', 'copy-attributes'],
-        ['fsd_inject_map', 'fsd_exist_map']].
-  maximum_paths:
-    description:
-      - Configures the maximum number of equal-cost paths for
-        load sharing. Valid value is an integer in the range 1-64.
-  maximum_paths_ibgp:
-    description:
-      - Configures the maximum number of ibgp equal-cost paths for
-        load sharing. Valid value is an integer in the range 1-64.
-  networks:
-    description:
-      - Networks to configure. Valid value is a list of network
-        prefixes to advertise. The list must be in the form of an array.
-        Each entry in the array must include a prefix address and an
-        optional route-map. For example [['10.0.0.0/16', 'routemap_LA'],
-        ['192.168.1.1', 'Chicago'], ['192.168.2.0/24'],
-        ['192.168.3.0/24', 'routemap_NYC']].
-  next_hop_route_map:
-    description:
-      - Configure a route-map for valid nexthops. Valid values are a
-        string defining the name of the route-map.
-  redistribute:
-    description:
-      - A list of redistribute directives. Multiple redistribute entries
-        are allowed. The list must be in the form of a nested array.
-        the first entry of each array defines the source-protocol to
-        redistribute from; the second entry defines a route-map name.
-        A route-map is highly advised but may be optional on some
-        platforms, in which case it may be omitted from the array list.
-        For example [['direct', 'rm_direct'], ['lisp', 'rm_lisp']].
-  suppress_inactive:
-    description:
-      - Advertises only active routes to peers.
-    type: bool
-  table_map:
-    description:
-      - Apply table-map to filter routes downloaded into URIB.
-        Valid values are a string.
-  table_map_filter:
-    description:
-      - Filters routes rejected by the route-map and does not download
-        them to the RIB.
-    type: bool
-  state:
-    description:
-      - Determines whether the config should be present or not
-        on the device.
-    default: present
-    choices: ['present','absent']
-'''
-EXAMPLES = '''
-# configure a simple address-family
-- nxos_bgp_af:
-    asn: 65535
-    vrf: TESTING
-    afi: ipv4
-    safi: unicast
-    advertise_l2vpn_evpn: true
-    state: present
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["router bgp 65535", "vrf TESTING",
-            "address-family ipv4 unicast", "advertise l2vpn evpn"]
-'''
-
-import re
-
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-
-
-BOOL_PARAMS = [
-    'additional_paths_install',
-    'additional_paths_receive',
-    'additional_paths_send',
-    'advertise_l2vpn_evpn',
-    'dampening_state',
-    'default_information_originate',
-    'suppress_inactive',
-]
-PARAM_TO_DEFAULT_KEYMAP = {
-    'maximum_paths': '1',
-    'maximum_paths_ibgp': '1',
-    'client_to_client': True,
-    'distance_ebgp': '20',
-    'distance_ibgp': '200',
-    'distance_local': '220',
-    'dampen_igp_metric': '600'
-}
-PARAM_TO_COMMAND_KEYMAP = {
-    'asn': 'router bgp',
-    'afi': 'address-family',
-    'safi': 'address-family',
-    'additional_paths_install': 'additional-paths install backup',
-    'additional_paths_receive': 'additional-paths receive',
-    'additional_paths_selection': 'additional-paths selection route-map',
-    'additional_paths_send': 'additional-paths send',
-    'advertise_l2vpn_evpn': 'advertise l2vpn evpn',
-    'client_to_client': 'client-to-client reflection',
-    'dampen_igp_metric': 'dampen-igp-metric',
-    'dampening_state': 'dampening',
-    'dampening_half_time': 'dampening',
-    'dampening_max_suppress_time': 'dampening',
-    'dampening_reuse_time': 'dampening',
-    'dampening_routemap': 'dampening route-map',
-    'dampening_suppress_time': 'dampening',
-    'default_information_originate': 'default-information originate',
-    'default_metric': 'default-metric',
-    'distance_ebgp': 'distance',
-    'distance_ibgp': 'distance',
-    'distance_local': 'distance',
-    'inject_map': 'inject-map',
-    'maximum_paths': 'maximum-paths',
-    'maximum_paths_ibgp': 'maximum-paths ibgp',
-    'networks': 'network',
-    'redistribute': 'redistribute',
-    'next_hop_route_map': 'nexthop route-map',
-    'suppress_inactive': 'suppress-inactive',
-    'table_map': 'table-map',
-    'table_map_filter': 'table-map-filter',
-    'vrf': 'vrf'
-}
-DAMPENING_PARAMS = [
-    'dampening_half_time',
-    'dampening_suppress_time',
-    'dampening_reuse_time',
-    'dampening_max_suppress_time'
-]
-
-
-def get_value(arg, config, module):
-    command = PARAM_TO_COMMAND_KEYMAP[arg]
-    command_val_re = re.compile(r'(?:{0}\s)(?P<value>.*)$'.format(command), re.M)
-    has_command_val = command_val_re.search(config)
-
-    if arg in ['networks', 'redistribute', 'inject_map']:
-        value = []
-        for ele in command_val_re.findall(config):
-            tl = ele.split()
-            if 'exist-map' in tl:
-                tl.remove('exist-map')
-            elif 'route-map' in tl:
-                tl.remove('route-map')
-            value.append(tl)
-
-    elif command == 'distance':
-        distance_re = r'.*distance\s(?P<d_ebgp>\w+)\s(?P<d_ibgp>\w+)\s(?P<d_local>\w+)'
-        match_distance = re.match(distance_re, config, re.DOTALL)
-
-        value = ''
-        if match_distance:
-            distance_group = match_distance.groupdict()
-
-            if arg == 'distance_ebgp':
-                value = distance_group['d_ebgp']
-            elif arg == 'distance_ibgp':
-                value = distance_group['d_ibgp']
-            elif arg == 'distance_local':
-                value = distance_group['d_local']
-
-    elif command.split()[0] == 'dampening':
-        value = ''
-        if arg == 'dampen_igp_metric' or arg == 'dampening_routemap':
-            if command in config:
-                value = has_command_val.group('value')
-        else:
-            dampening_re = r'.*dampening\s(?P<half>\w+)\s(?P<reuse>\w+)\s(?P<suppress>\w+)\s(?P<max_suppress>\w+)'
-            match_dampening = re.match(dampening_re, config, re.DOTALL)
-            if match_dampening:
-                dampening_group = match_dampening.groupdict()
-
-                if arg == 'dampening_half_time':
-                    value = dampening_group['half']
-                elif arg == 'dampening_reuse_time':
-                    value = dampening_group['reuse']
-                elif arg == 'dampening_suppress_time':
-                    value = dampening_group['suppress']
-                elif arg == 'dampening_max_suppress_time':
-                    value = dampening_group['max_suppress']
-            else:
-                if arg == 'dampening_state':
-                    value = True if 'dampening' in config else False
-    elif arg == 'table_map_filter':
-        tmf_regex = re.compile(r'\s+table-map.*filter$', re.M)
-        value = False
-        if tmf_regex.search(config):
-            value = True
-
-    elif arg == 'table_map':
-        tm_regex = re.compile(r'(?:table-map\s)(?P<value>\S+)(\sfilter)?$', re.M)
-        has_tablemap = tm_regex.search(config)
-        value = ''
-        if has_tablemap:
-            value = has_tablemap.group('value')
-
-    elif arg == 'client_to_client':
-        no_command_re = re.compile(r'^\s+no\s{0}\s*$'.format(command), re.M)
-        value = True
-
-        if no_command_re.search(config):
-            value = False
-
-    elif arg in BOOL_PARAMS:
-        command_re = re.compile(r'^\s+{0}\s*$'.format(command), re.M)
-        value = False
-
-        if command_re.search(config):
-            value = True
-
-    else:
-        value = ''
-
-        if has_command_val:
-            value = has_command_val.group('value')
-
-    return value
-
-
-def get_existing(module, args, warnings):
-    existing = {}
-    netcfg = CustomNetworkConfig(indent=2, contents=get_config(module))
-
-    asn_regex = re.compile(r'.*router\sbgp\s(?P<existing_asn>\d+(\.\d+)?).*', re.DOTALL)
-    match_asn = asn_regex.match(str(netcfg))
-
-    if match_asn:
-        existing_asn = match_asn.group('existing_asn')
-        parents = ["router bgp {0}".format(existing_asn)]
-        if module.params['vrf'] != 'default':
-            parents.append('vrf {0}'.format(module.params['vrf']))
-
-        parents.append('address-family {0} {1}'.format(module.params['afi'], module.params['safi']))
-        config = netcfg.get_section(parents)
-
-        if config:
-            for arg in args:
-                if arg not in ['asn', 'afi', 'safi', 'vrf']:
-                    gv = get_value(arg, config, module)
-                    if gv:
-                        existing[arg] = gv
-                    else:
-                        if arg != 'client_to_client' and arg in PARAM_TO_DEFAULT_KEYMAP.keys():
-                            existing[arg] = PARAM_TO_DEFAULT_KEYMAP.get(arg)
-                        else:
-                            existing[arg] = gv
-
-            existing['asn'] = existing_asn
-            existing['afi'] = module.params['afi']
-            existing['safi'] = module.params['safi']
-            existing['vrf'] = module.params['vrf']
-    else:
-        warnings.append("The BGP process {0} didn't exist but the task just created it.".format(module.params['asn']))
-
-    return existing
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key, value in table.items():
-        new_key = key_map.get(key)
-        if new_key:
-            new_dict[new_key] = value
-
-    return new_dict
-
-
-def fix_proposed(module, proposed, existing):
-    commands = list()
-    command = ''
-    fixed_proposed = {}
-    for key, value in proposed.items():
-        if key in DAMPENING_PARAMS:
-            if value != 'default':
-                command = 'dampening {0} {1} {2} {3}'.format(
-                    proposed.get('dampening_half_time'),
-                    proposed.get('dampening_reuse_time'),
-                    proposed.get('dampening_suppress_time'),
-                    proposed.get('dampening_max_suppress_time'))
-            else:
-                if existing.get(key):
-                    command = ('no dampening {0} {1} {2} {3}'.format(
-                        existing['dampening_half_time'],
-                        existing['dampening_reuse_time'],
-                        existing['dampening_suppress_time'],
-                        existing['dampening_max_suppress_time']))
-            if 'default' in command:
-                command = ''
-        elif key.startswith('distance'):
-            command = 'distance {0} {1} {2}'.format(
-                proposed.get('distance_ebgp'),
-                proposed.get('distance_ibgp'),
-                proposed.get('distance_local'))
-        else:
-            fixed_proposed[key] = value
-
-        if command:
-            if command not in commands:
-                commands.append(command)
-
-    return fixed_proposed, commands
-
-
-def default_existing(existing_value, key, value):
-    commands = []
-    if key == 'network':
-        for network in existing_value:
-            if len(network) == 2:
-                commands.append('no network {0} route-map {1}'.format(
-                    network[0], network[1]))
-            elif len(network) == 1:
-                commands.append('no network {0}'.format(
-                    network[0]))
-
-    elif key == 'inject-map':
-        for maps in existing_value:
-            if len(maps) == 2:
-                commands.append('no inject-map {0} exist-map {1}'.format(maps[0], maps[1]))
-            elif len(maps) == 3:
-                commands.append('no inject-map {0} exist-map {1} '
-                                'copy-attributes'.format(maps[0], maps[1]))
-
-    elif key == 'redistribute':
-        for maps in existing_value:
-            commands.append('no redistribute {0} route-map {1}'.format(maps[0], maps[1]))
-
-    else:
-        commands.append('no {0} {1}'.format(key, existing_value))
-    return commands
-
-
-def get_network_command(existing, key, value):
-    commands = []
-    existing_networks = existing.get('networks', [])
-    for inet in value:
-        if not isinstance(inet, list):
-            inet = [inet]
-        if inet not in existing_networks:
-            if len(inet) == 1:
-                command = '{0} {1}'.format(key, inet[0])
-            elif len(inet) == 2:
-                command = '{0} {1} route-map {2}'.format(key, inet[0], inet[1])
-            if command:
-                commands.append(command)
-    for enet in existing_networks:
-        if enet not in value:
-            if len(enet) == 1:
-                command = 'no {0} {1}'.format(key, enet[0])
-            elif len(enet) == 2:
-                command = 'no {0} {1} route-map {2}'.format(key, enet[0], enet[1])
-            if command:
-                commands.append(command)
-    return commands
-
-
-def get_inject_map_command(existing, key, value):
-    commands = []
-    existing_maps = existing.get('inject_map', [])
-    for maps in value:
-        if not isinstance(maps, list):
-            maps = [maps]
-        if maps not in existing_maps:
-            if len(maps) == 2:
-                command = ('inject-map {0} exist-map {1}'.format(
-                    maps[0], maps[1]))
-            elif len(maps) == 3:
-                command = ('inject-map {0} exist-map {1} '
-                           'copy-attributes'.format(maps[0],
-                                                    maps[1]))
-            if command:
-                commands.append(command)
-    for emaps in existing_maps:
-        if emaps not in value:
-            if len(emaps) == 2:
-                command = ('no inject-map {0} exist-map {1}'.format(
-                    emaps[0], emaps[1]))
-            elif len(emaps) == 3:
-                command = ('no inject-map {0} exist-map {1} '
-                           'copy-attributes'.format(emaps[0],
-                                                    emaps[1]))
-            if command:
-                commands.append(command)
-    return commands
-
-
-def get_redistribute_command(existing, key, value):
-    commands = []
-    existing_rules = existing.get('redistribute', [])
-    for rule in value:
-        if not isinstance(rule, list):
-            rule = [rule]
-        if rule not in existing_rules:
-            command = ('redistribute {0} route-map {1}'.format(
-                rule[0], rule[1]))
-            commands.append(command)
-    for erule in existing_rules:
-        if erule not in value:
-            command = ('no redistribute {0} route-map {1}'.format(
-                erule[0], erule[1]))
-            commands.append(command)
-    return commands
-
-
-def get_table_map_command(module, existing, key, value):
-    commands = []
-    if key == 'table-map':
-        if value != 'default':
-            command = '{0} {1}'.format(key, module.params['table_map'])
-            if (module.params['table_map_filter'] is not None and
-                    module.params['table_map_filter'] != 'default'):
-                command += ' filter'
-            commands.append(command)
-        else:
-            if existing.get('table_map'):
-                command = 'no {0} {1}'.format(key, existing.get('table_map'))
-                commands.append(command)
-    return commands
-
-
-def get_default_table_map_filter(existing):
-    commands = []
-    existing_table_map_filter = existing.get('table_map_filter')
-    if existing_table_map_filter:
-        existing_table_map = existing.get('table_map')
-        if existing_table_map:
-            command = 'table-map {0}'.format(existing_table_map)
-            commands.append(command)
-    return commands
-
-
-def state_present(module, existing, proposed, candidate):
-    fixed_proposed, commands = fix_proposed(module, proposed, existing)
-    proposed_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, fixed_proposed)
-    existing_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, existing)
-    for key, value in proposed_commands.items():
-        if key == 'address-family':
-            addr_family_command = "address-family {0} {1}".format(
-                module.params['afi'], module.params['safi'])
-            if addr_family_command not in commands:
-                commands.append(addr_family_command)
-
-        elif key.startswith('table-map'):
-            table_map_commands = get_table_map_command(module, existing, key, value)
-            if table_map_commands:
-                commands.extend(table_map_commands)
-
-        elif value is True:
-            commands.append(key)
-
-        elif value is False:
-            commands.append('no {0}'.format(key))
-
-        elif value == 'default':
-            if key in PARAM_TO_DEFAULT_KEYMAP:
-                commands.append('{0} {1}'.format(key, PARAM_TO_DEFAULT_KEYMAP[key]))
-
-            elif existing_commands.get(key):
-                if key == 'table-map-filter':
-                    default_tmf_command = get_default_table_map_filter(existing)
-
-                    if default_tmf_command:
-                        commands.extend(default_tmf_command)
-                else:
-                    existing_value = existing_commands.get(key)
-                    default_command = default_existing(existing_value, key, value)
-                    if default_command:
-                        commands.extend(default_command)
-        else:
-            if key == 'network':
-                network_commands = get_network_command(existing, key, value)
-                if network_commands:
-                    commands.extend(network_commands)
-
-            elif key == 'inject-map':
-                inject_map_commands = get_inject_map_command(existing, key, value)
-                if inject_map_commands:
-                    commands.extend(inject_map_commands)
-
-            elif key == 'redistribute':
-                redistribute_commands = get_redistribute_command(existing, key, value)
-                if redistribute_commands:
-                    commands.extend(redistribute_commands)
-
-            else:
-                command = '{0} {1}'.format(key, value)
-                commands.append(command)
-
-    if commands:
-        parents = ["router bgp {0}".format(module.params['asn'])]
-        if module.params['vrf'] != 'default':
-            parents.append('vrf {0}'.format(module.params['vrf']))
-
-        addr_family_command = "address-family {0} {1}".format(module.params['afi'],
-                                                              module.params['safi'])
-        parents.append(addr_family_command)
-        if addr_family_command in commands:
-            commands.remove(addr_family_command)
-        candidate.add(commands, parents=parents)
-
-
-def state_absent(module, candidate):
-    commands = []
-    parents = ["router bgp {0}".format(module.params['asn'])]
-    if module.params['vrf'] != 'default':
-        parents.append('vrf {0}'.format(module.params['vrf']))
-
-    commands.append('no address-family {0} {1}'.format(
-        module.params['afi'], module.params['safi']))
-    candidate.add(commands, parents=parents)
-
-
-def main():
-    argument_spec = dict(
-        asn=dict(required=True, type='str'),
-        vrf=dict(required=False, type='str', default='default'),
-        safi=dict(required=True, type='str', choices=['unicast', 'multicast', 'evpn']),
-        afi=dict(required=True, type='str', choices=['ipv4', 'ipv6', 'vpnv4', 'vpnv6', 'l2vpn']),
-        additional_paths_install=dict(required=False, type='bool'),
-        additional_paths_receive=dict(required=False, type='bool'),
-        additional_paths_selection=dict(required=False, type='str'),
-        additional_paths_send=dict(required=False, type='bool'),
-        advertise_l2vpn_evpn=dict(required=False, type='bool'),
-        client_to_client=dict(required=False, type='bool'),
-        dampen_igp_metric=dict(required=False, type='str'),
-        dampening_state=dict(required=False, type='bool'),
-        dampening_half_time=dict(required=False, type='str'),
-        dampening_max_suppress_time=dict(required=False, type='str'),
-        dampening_reuse_time=dict(required=False, type='str'),
-        dampening_routemap=dict(required=False, type='str'),
-        dampening_suppress_time=dict(required=False, type='str'),
-        default_information_originate=dict(required=False, type='bool'),
-        default_metric=dict(required=False, type='str'),
-        distance_ebgp=dict(required=False, type='str'),
-        distance_ibgp=dict(required=False, type='str'),
-        distance_local=dict(required=False, type='str'),
-        inject_map=dict(required=False, type='list'),
-        maximum_paths=dict(required=False, type='str'),
-        maximum_paths_ibgp=dict(required=False, type='str'),
-        networks=dict(required=False, type='list'),
-        next_hop_route_map=dict(required=False, type='str'),
-        redistribute=dict(required=False, type='list'),
-        suppress_inactive=dict(required=False, type='bool'),
-        table_map=dict(required=False, type='str'),
-        table_map_filter=dict(required=False, type='bool'),
-        state=dict(choices=['present', 'absent'], default='present', required=False),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    mutually_exclusive = [('dampening_state', 'dampening_routemap'),
-                          ('dampening_state', 'dampening_half_time'),
-                          ('dampening_state', 'dampening_suppress_time'),
-                          ('dampening_state', 'dampening_reuse_time'),
-                          ('dampening_state', 'dampening_max_suppress_time'),
-                          ('dampening_routemap', 'dampening_half_time'),
-                          ('dampening_routemap', 'dampening_suppress_time'),
-                          ('dampening_routemap', 'dampening_reuse_time'),
-                          ('dampening_routemap', 'dampening_max_suppress_time')]
-
-    module = AnsibleModule(
-        argument_spec=argument_spec,
-        mutually_exclusive=mutually_exclusive,
-        required_together=[DAMPENING_PARAMS, ['distance_ibgp', 'distance_ebgp', 'distance_local']],
-        supports_check_mode=True,
-    )
-
-    warnings = list()
-    result = dict(changed=False, warnings=warnings)
-
-    state = module.params['state']
-
-    if module.params['advertise_l2vpn_evpn']:
-        if module.params['vrf'] == 'default':
-            module.fail_json(msg='It is not possible to advertise L2VPN '
-                                 'EVPN in the default VRF. Please specify '
-                                 'another one.', vrf=module.params['vrf'])
-
-    if module.params['table_map_filter'] and not module.params['table_map']:
-        module.fail_json(msg='table_map param is needed when using'
-                             ' table_map_filter filter.')
-
-    args = PARAM_TO_COMMAND_KEYMAP.keys()
-    existing = get_existing(module, args, warnings)
-
-    if existing.get('asn') and state == 'present':
-        if existing.get('asn') != module.params['asn']:
-            module.fail_json(msg='Another BGP ASN already exists.',
-                             proposed_asn=module.params['asn'],
-                             existing_asn=existing.get('asn'))
-
-    proposed_args = dict((k, v) for k, v in module.params.items()
-                         if v is not None and k in args)
-
-    for arg in ['networks', 'inject_map', 'redistribute']:
-        if proposed_args.get(arg):
-            if proposed_args[arg][0] == 'default':
-                proposed_args[arg] = 'default'
-
-    proposed = {}
-    for key, value in proposed_args.items():
-        if key not in ['asn', 'vrf']:
-            if str(value).lower() == 'default':
-                value = PARAM_TO_DEFAULT_KEYMAP.get(key, 'default')
-            if existing.get(key) != value:
-                proposed[key] = value
-
-    candidate = CustomNetworkConfig(indent=3)
-    if state == 'present':
-        state_present(module, existing, proposed, candidate)
-    elif state == 'absent' and existing:
-        state_absent(module, candidate)
-
-    if candidate:
-        candidate = candidate.items_text()
-        if not module.check_mode:
-            load_config(module, candidate)
-        result['changed'] = True
-        result['commands'] = candidate
-    else:
-        result['commands'] = []
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_bgp_neighbor.py b/lib/ansible/modules/network/nxos/nxos_bgp_neighbor.py
deleted file mode 100644
index 1d2ab8bc84..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_bgp_neighbor.py
+++ /dev/null
@@ -1,488 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_bgp_neighbor
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages BGP neighbors configurations.
-description:
-  - Manages BGP neighbors configurations on NX-OS switches.
-author: Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - C(state=absent) removes the whole BGP neighbor configuration.
-  - Default, where supported, restores params default value.
-options:
-  asn:
-    description:
-      - BGP autonomous system number. Valid values are string,
-        Integer in ASPLAIN or ASDOT notation.
-    required: true
-  vrf:
-    description:
-      - Name of the VRF. The name 'default' is a valid VRF representing
-        the global bgp.
-    default: default
-  neighbor:
-    description:
-      - Neighbor Identifier. Valid values are string. Neighbors may use
-        IPv4 or IPv6 notation, with or without prefix length.
-    required: true
-  description:
-    description:
-      - Description of the neighbor.
-  bfd:
-    description:
-      - Enables/Disables BFD for a given neighbor.
-      - "Dependency: 'feature bfd'"
-    version_added: "2.9"
-    type: str
-    choices: ['enable', 'disable']
-  connected_check:
-    description:
-      - Configure whether or not to check for directly connected peer.
-    type: bool
-  capability_negotiation:
-    description:
-      - Configure whether or not to negotiate capability with
-        this neighbor.
-    type: bool
-  dynamic_capability:
-    description:
-      - Configure whether or not to enable dynamic capability.
-    type: bool
-  ebgp_multihop:
-    description:
-      - Specify multihop TTL for a remote peer. Valid values are
-        integers between 2 and 255, or keyword 'default' to disable
-        this property.
-  local_as:
-    description:
-      - Specify the local-as number for the eBGP neighbor.
-        Valid values are String or Integer in ASPLAIN or ASDOT notation,
-        or 'default', which means not to configure it.
-  log_neighbor_changes:
-    description:
-      - Specify whether or not to enable log messages for neighbor
-        up/down event.
-    choices: ['enable', 'disable', 'inherit']
-  low_memory_exempt:
-    description:
-      - Specify whether or not to shut down this neighbor under
-        memory pressure.
-    type: bool
-  maximum_peers:
-    description:
-      - Specify Maximum number of peers for this neighbor prefix
-        Valid values are between 1 and 1000, or 'default', which does
-        not impose the limit. Note that this parameter is accepted
-        only on neighbors with address/prefix.
-  pwd:
-    description:
-      - Specify the password for neighbor. Valid value is string.
-  pwd_type:
-    description:
-      - Specify the encryption type the password will use. Valid values
-        are '3des' or 'cisco_type_7' encryption or keyword 'default'.
-    choices: ['3des', 'cisco_type_7', 'default']
-  remote_as:
-    description:
-      - Specify Autonomous System Number of the neighbor.
-        Valid values are String or Integer in ASPLAIN or ASDOT notation,
-        or 'default', which means not to configure it.
-  remove_private_as:
-    description:
-      - Specify the config to remove private AS number from outbound
-        updates. Valid values are 'enable' to enable this config,
-        'disable' to disable this config, 'all' to remove all
-        private AS number, or 'replace-as', to replace the private
-        AS number.
-    choices: ['enable', 'disable', 'all', 'replace-as']
-  shutdown:
-    description:
-      - Configure to administratively shutdown this neighbor.
-    type: bool
-  suppress_4_byte_as:
-    description:
-      - Configure to suppress 4-byte AS Capability.
-    type: bool
-  timers_keepalive:
-    description:
-      - Specify keepalive timer value. Valid values are integers
-        between 0 and 3600 in terms of seconds, or 'default',
-        which is 60.
-  timers_holdtime:
-    description:
-      - Specify holdtime timer value. Valid values are integers between
-        0 and 3600 in terms of seconds, or 'default', which is 180.
-  transport_passive_only:
-    description:
-      - Specify whether or not to only allow passive connection setup.
-        Valid values are 'true', 'false', and 'default', which defaults
-        to 'false'. This property can only be configured when the
-        neighbor is in 'ip' address format without prefix length.
-    type: bool
-  update_source:
-    description:
-      - Specify source interface of BGP session and updates.
-  state:
-    description:
-      - Determines whether the config should be present or not
-        on the device.
-    default: present
-    choices: ['present','absent']
-'''
-EXAMPLES = '''
-# create a new neighbor
-- nxos_bgp_neighbor:
-    asn: 65535
-    neighbor: 192.0.2.3
-    local_as: 20
-    remote_as: 30
-    bfd: enable
-    description: "just a description"
-    update_source: Ethernet1/3
-    state: present
-'''
-
-RETURN = '''
-commands:
-  description: commands sent to the device
-  returned: always
-  type: list
-  sample: ["router bgp 65535", "neighbor 192.0.2.3",
-           "remote-as 30", "update-source Ethernet1/3",
-           "description just a description", "local-as 20"]
-'''
-
-import re
-
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-
-
-BOOL_PARAMS = [
-    'capability_negotiation',
-    'shutdown',
-    'connected_check',
-    'dynamic_capability',
-    'low_memory_exempt',
-    'suppress_4_byte_as',
-    'transport_passive_only',
-]
-PARAM_TO_COMMAND_KEYMAP = {
-    'asn': 'router bgp',
-    'bfd': 'bfd',
-    'capability_negotiation': 'dont-capability-negotiate',
-    'connected_check': 'disable-connected-check',
-    'description': 'description',
-    'dynamic_capability': 'dynamic-capability',
-    'ebgp_multihop': 'ebgp-multihop',
-    'local_as': 'local-as',
-    'log_neighbor_changes': 'log-neighbor-changes',
-    'low_memory_exempt': 'low-memory exempt',
-    'maximum_peers': 'maximum-peers',
-    'neighbor': 'neighbor',
-    'pwd': 'password',
-    'pwd_type': 'password',
-    'remote_as': 'remote-as',
-    'remove_private_as': 'remove-private-as',
-    'shutdown': 'shutdown',
-    'suppress_4_byte_as': 'capability suppress 4-byte-as',
-    'timers_keepalive': 'timers',
-    'timers_holdtime': 'timers',
-    'transport_passive_only': 'transport connection-mode passive',
-    'update_source': 'update-source',
-    'vrf': 'vrf'
-}
-PARAM_TO_DEFAULT_KEYMAP = {
-    'bfd': 'disable',
-    'shutdown': False,
-    'dynamic_capability': True,
-    'timers_keepalive': 60,
-    'timers_holdtime': 180
-}
-
-
-def get_value(arg, config):
-    command = PARAM_TO_COMMAND_KEYMAP[arg]
-    has_command = re.search(r'^\s+{0}$'.format(command), config, re.M)
-    has_command_val = re.search(r'(?:\s+{0}\s*)(?P<value>.*)$'.format(command), config, re.M)
-
-    if arg == 'dynamic_capability':
-        has_no_command = re.search(r'\s+no\s{0}\s*$'.format(command), config, re.M)
-        value = True
-        if has_no_command:
-            value = False
-    elif arg in BOOL_PARAMS:
-        value = False
-        if has_command:
-            value = True
-    elif arg == 'log_neighbor_changes':
-        value = ''
-        if has_command:
-            value = 'enable'
-        elif has_command_val:
-            value = 'disable'
-
-    elif arg == 'remove_private_as':
-        value = 'disable'
-        if has_command:
-            value = 'enable'
-        elif has_command_val:
-            value = has_command_val.group('value')
-    elif arg == 'bfd':
-        value = 'enable' if has_command else 'disable'
-    else:
-        value = ''
-
-        if has_command_val:
-            value = has_command_val.group('value')
-
-            if command in ['timers', 'password']:
-                split_value = value.split()
-                value = ''
-
-                if arg in ['timers_keepalive', 'pwd_type']:
-                    value = split_value[0]
-                elif arg in ['timers_holdtime', 'pwd'] and len(split_value) == 2:
-                    value = split_value[1]
-
-    return value
-
-
-def get_existing(module, args, warnings):
-    existing = {}
-    netcfg = CustomNetworkConfig(indent=2, contents=get_config(module))
-
-    asn_regex = re.compile(r'.*router\sbgp\s(?P<existing_asn>\d+(\.\d+)?).*', re.S)
-    match_asn = asn_regex.match(str(netcfg))
-
-    if match_asn:
-        existing_asn = match_asn.group('existing_asn')
-        parents = ["router bgp {0}".format(existing_asn)]
-
-        if module.params['vrf'] != 'default':
-            parents.append('vrf {0}'.format(module.params['vrf']))
-
-        parents.append('neighbor {0}'.format(module.params['neighbor']))
-        config = netcfg.get_section(parents)
-        if config:
-            for arg in args:
-                if arg not in ['asn', 'vrf', 'neighbor']:
-                    existing[arg] = get_value(arg, config)
-
-            existing['asn'] = existing_asn
-            existing['neighbor'] = module.params['neighbor']
-            existing['vrf'] = module.params['vrf']
-    else:
-        warnings.append("The BGP process didn't exist but the task"
-                        " just created it.")
-    return existing
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key in table:
-        new_key = key_map.get(key)
-        if new_key:
-            new_dict[new_key] = table.get(key)
-
-    return new_dict
-
-
-def state_present(module, existing, proposed, candidate):
-    commands = list()
-    proposed_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, proposed)
-    existing_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, existing)
-
-    for key, value in proposed_commands.items():
-        if value is True:
-            commands.append(key)
-        elif value is False:
-            commands.append('no {0}'.format(key))
-        elif value == 'default':
-            if existing_commands.get(key):
-                if key == 'password':
-                    commands.append("no password")
-                else:
-                    existing_value = existing_commands.get(key)
-                    commands.append('no {0} {1}'.format(key, existing_value))
-        else:
-            if key == 'log-neighbor-changes':
-                if value == 'enable':
-                    commands.append('{0}'.format(key))
-                elif value == 'disable':
-                    commands.append('{0} {1}'.format(key, value))
-                elif value == 'inherit':
-                    if existing_commands.get(key):
-                        commands.append('no {0}'.format(key))
-            elif key == 'password':
-                pwd_type = module.params['pwd_type']
-                if pwd_type == '3des':
-                    pwd_type = 3
-                else:
-                    pwd_type = 7
-                command = '{0} {1} {2}'.format(key, pwd_type, value)
-                if command not in commands:
-                    commands.append(command)
-            elif key == 'remove-private-as':
-                if value == 'enable':
-                    command = '{0}'.format(key)
-                    commands.append(command)
-                elif value == 'disable':
-                    if existing_commands.get(key) != 'disable':
-                        command = 'no {0}'.format(key)
-                        commands.append(command)
-                else:
-                    command = '{0} {1}'.format(key, value)
-                    commands.append(command)
-            elif key == 'timers':
-                if (proposed['timers_keepalive'] != PARAM_TO_DEFAULT_KEYMAP.get('timers_keepalive') or
-                        proposed['timers_holdtime'] != PARAM_TO_DEFAULT_KEYMAP.get('timers_holdtime')):
-                    command = 'timers {0} {1}'.format(
-                        proposed['timers_keepalive'],
-                        proposed['timers_holdtime'])
-                    if command not in commands:
-                        commands.append(command)
-            elif key == 'bfd':
-                no_cmd = 'no ' if value == 'disable' else ''
-                commands.append(no_cmd + key)
-            else:
-                command = '{0} {1}'.format(key, value)
-                commands.append(command)
-
-    if commands:
-        parents = ['router bgp {0}'.format(module.params['asn'])]
-        if module.params['vrf'] != 'default':
-            parents.append('vrf {0}'.format(module.params['vrf']))
-
-        parents.append('neighbor {0}'.format(module.params['neighbor']))
-
-        # make sure that local-as is the last command in the list.
-        local_as_command = 'local-as {0}'.format(module.params['local_as'])
-        if local_as_command in commands:
-            commands.remove(local_as_command)
-            commands.append(local_as_command)
-        candidate.add(commands, parents=parents)
-
-
-def state_absent(module, existing, proposed, candidate):
-    commands = []
-    parents = ["router bgp {0}".format(module.params['asn'])]
-    if module.params['vrf'] != 'default':
-        parents.append('vrf {0}'.format(module.params['vrf']))
-
-    commands.append('no neighbor {0}'.format(module.params['neighbor']))
-    candidate.add(commands, parents=parents)
-
-
-def main():
-    argument_spec = dict(
-        asn=dict(required=True, type='str'),
-        vrf=dict(required=False, type='str', default='default'),
-        neighbor=dict(required=True, type='str'),
-        description=dict(required=False, type='str'),
-        bfd=dict(required=False, type='str', choices=['enable', 'disable']),
-        capability_negotiation=dict(required=False, type='bool'),
-        connected_check=dict(required=False, type='bool'),
-        dynamic_capability=dict(required=False, type='bool'),
-        ebgp_multihop=dict(required=False, type='str'),
-        local_as=dict(required=False, type='str'),
-        log_neighbor_changes=dict(required=False, type='str', choices=['enable', 'disable', 'inherit']),
-        low_memory_exempt=dict(required=False, type='bool'),
-        maximum_peers=dict(required=False, type='str'),
-        pwd=dict(required=False, type='str'),
-        pwd_type=dict(required=False, type='str', choices=['3des', 'cisco_type_7', 'default']),
-        remote_as=dict(required=False, type='str'),
-        remove_private_as=dict(required=False, type='str', choices=['enable', 'disable', 'all', 'replace-as']),
-        shutdown=dict(required=False, type='bool'),
-        suppress_4_byte_as=dict(required=False, type='bool'),
-        timers_keepalive=dict(required=False, type='str'),
-        timers_holdtime=dict(required=False, type='str'),
-        transport_passive_only=dict(required=False, type='bool'),
-        update_source=dict(required=False, type='str'),
-        state=dict(choices=['present', 'absent'], default='present', required=False)
-    )
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(
-        argument_spec=argument_spec,
-        required_together=[['timers_holdtime', 'timers_keepalive'], ['pwd', 'pwd_type']],
-        supports_check_mode=True,
-    )
-
-    warnings = list()
-    result = dict(changed=False, warnings=warnings)
-
-    state = module.params['state']
-
-    if module.params['pwd_type'] == 'default':
-        module.params['pwd_type'] = '0'
-
-    args = PARAM_TO_COMMAND_KEYMAP.keys()
-    existing = get_existing(module, args, warnings)
-
-    if existing.get('asn') and state == 'present':
-        if existing['asn'] != module.params['asn']:
-            module.fail_json(msg='Another BGP ASN already exists.',
-                             proposed_asn=module.params['asn'],
-                             existing_asn=existing.get('asn'))
-
-    proposed_args = dict((k, v) for k, v in module.params.items()
-                         if v is not None and k in args)
-    proposed = {}
-    for key, value in proposed_args.items():
-        if key not in ['asn', 'vrf', 'neighbor', 'pwd_type']:
-            if str(value).lower() == 'default':
-                value = PARAM_TO_DEFAULT_KEYMAP.get(key, 'default')
-            if key == 'bfd':
-                if existing.get('bfd', 'disable') != value:
-                    proposed[key] = value
-            elif existing.get(key) != value:
-                proposed[key] = value
-
-    candidate = CustomNetworkConfig(indent=3)
-    if state == 'present':
-        state_present(module, existing, proposed, candidate)
-    elif state == 'absent' and existing:
-        state_absent(module, existing, proposed, candidate)
-
-    if candidate:
-        candidate = candidate.items_text()
-        if not module.check_mode:
-            load_config(module, candidate)
-        result['changed'] = True
-        result['commands'] = candidate
-    else:
-        result['commands'] = []
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_bgp_neighbor_af.py b/lib/ansible/modules/network/nxos/nxos_bgp_neighbor_af.py
deleted file mode 100644
index 9c872750ea..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_bgp_neighbor_af.py
+++ /dev/null
@@ -1,691 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_bgp_neighbor_af
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages BGP address-family's neighbors configuration.
-description:
-  - Manages BGP address-family's neighbors configurations on NX-OS switches.
-author: Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - C(state=absent) removes the whole BGP address-family's
-    neighbor configuration.
-  - Default, when supported, removes properties
-  - In order to default maximum-prefix configuration, only
-    C(max_prefix_limit=default) is needed.
-options:
-  asn:
-    description:
-      - BGP autonomous system number. Valid values are String,
-        Integer in ASPLAIN or ASDOT notation.
-    required: true
-  vrf:
-    description:
-      - Name of the VRF. The name 'default' is a valid VRF representing
-        the global bgp.
-    default: default
-  neighbor:
-    description:
-      - Neighbor Identifier. Valid values are string. Neighbors may use
-        IPv4 or IPv6 notation, with or without prefix length.
-    required: true
-  afi:
-    description:
-      - Address Family Identifier.
-    required: true
-    choices: ['ipv4','ipv6', 'vpnv4', 'vpnv6', 'l2vpn']
-  safi:
-    description:
-      - Sub Address Family Identifier.
-    required: true
-    choices: ['unicast','multicast', 'evpn']
-  additional_paths_receive:
-    description:
-      - Valid values are enable for basic command enablement; disable
-        for disabling the command at the neighbor af level
-        (it adds the disable keyword to the basic command); and inherit
-        to remove the command at this level (the command value is
-        inherited from a higher BGP layer).
-    choices: ['enable','disable', 'inherit']
-  additional_paths_send:
-    description:
-      - Valid values are enable for basic command enablement; disable
-        for disabling the command at the neighbor af level
-        (it adds the disable keyword to the basic command); and inherit
-        to remove the command at this level (the command value is
-        inherited from a higher BGP layer).
-    choices: ['enable','disable', 'inherit']
-  advertise_map_exist:
-    description:
-      - Conditional route advertisement. This property requires two
-        route maps, an advertise-map and an exist-map. Valid values are
-        an array specifying both the advertise-map name and the exist-map
-        name, or simply 'default' e.g. ['my_advertise_map',
-        'my_exist_map']. This command is mutually exclusive with the
-        advertise_map_non_exist property.
-  advertise_map_non_exist:
-    description:
-      - Conditional route advertisement. This property requires two
-        route maps, an advertise-map and an exist-map. Valid values are
-        an array specifying both the advertise-map name and the
-        non-exist-map name, or simply 'default' e.g.
-        ['my_advertise_map', 'my_non_exist_map']. This command is mutually
-        exclusive with the advertise_map_exist property.
-  allowas_in:
-    description:
-      - Activate allowas-in property
-    type: bool
-  allowas_in_max:
-    description:
-      - Max-occurrences value for allowas_in. Valid values are
-        an integer value or 'default'. This is mutually exclusive with
-        allowas_in.
-  as_override:
-    description:
-      - Activate the as-override feature.
-    type: bool
-  default_originate:
-    description:
-      - Activate the default-originate feature.
-    type: bool
-  default_originate_route_map:
-    description:
-      - Route-map for the default_originate property.
-        Valid values are a string defining a route-map name,
-        or 'default'. This is mutually exclusive with
-        default_originate.
-  disable_peer_as_check:
-    description:
-      - Disable checking of peer AS-number while advertising
-    type: bool
-    version_added: 2.5
-  filter_list_in:
-    description:
-      - Valid values are a string defining a filter-list name,
-        or 'default'.
-  filter_list_out:
-    description:
-      - Valid values are a string defining a filter-list name,
-        or 'default'.
-  max_prefix_limit:
-    description:
-      - maximum-prefix limit value. Valid values are an integer value
-        or 'default'.
-  max_prefix_interval:
-    description:
-      - Optional restart interval. Valid values are an integer.
-        Requires max_prefix_limit. May not be combined with max_prefix_warning.
-  max_prefix_threshold:
-    description:
-      - Optional threshold percentage at which to generate a warning.
-        Valid values are an integer value.
-        Requires max_prefix_limit.
-  max_prefix_warning:
-    description:
-      - Optional warning-only keyword. Requires max_prefix_limit. May not be
-        combined with max_prefix_interval.
-    type: bool
-  next_hop_self:
-    description:
-      - Activate the next-hop-self feature.
-    type: bool
-  next_hop_third_party:
-    description:
-      - Activate the next-hop-third-party feature.
-    type: bool
-  prefix_list_in:
-    description:
-      - Valid values are a string defining a prefix-list name,
-        or 'default'.
-  prefix_list_out:
-    description:
-      - Valid values are a string defining a prefix-list name,
-        or 'default'.
-  route_map_in:
-    description:
-      - Valid values are a string defining a route-map name,
-        or 'default'.
-  route_map_out:
-    description:
-      - Valid values are a string defining a route-map name,
-        or 'default'.
-  route_reflector_client:
-    description:
-      - Router reflector client.
-    type: bool
-  send_community:
-    description:
-      - send-community attribute.
-    choices: ['none', 'both', 'extended', 'standard', 'default']
-  soft_reconfiguration_in:
-    description:
-      - Valid values are 'enable' for basic command enablement; 'always'
-        to add the always keyword to the basic command; and 'inherit' to
-        remove the command at this level (the command value is inherited
-        from a higher BGP layer).
-    choices: ['enable','always','inherit']
-  soo:
-    description:
-      - Site-of-origin. Valid values are a string defining a VPN
-        extcommunity or 'default'.
-  suppress_inactive:
-    description:
-      - suppress-inactive feature.
-    type: bool
-  unsuppress_map:
-    description:
-      - unsuppress-map. Valid values are a string defining a route-map
-        name or 'default'.
-  weight:
-    description:
-      - Weight value. Valid values are an integer value or 'default'.
-  state:
-    description:
-      - Determines whether the config should be present or not
-        on the device.
-    default: present
-    choices: ['present','absent']
-'''
-EXAMPLES = '''
-- name: configure RR client
-  nxos_bgp_neighbor_af:
-    asn: 65535
-    neighbor: '192.0.2.3'
-    afi: ipv4
-    safi: unicast
-    route_reflector_client: true
-    state: present
-'''
-
-RETURN = '''
-commands:
-  description: commands sent to the device
-  returned: always
-  type: list
-  sample: ["router bgp 65535", "neighbor 192.0.2.3",
-           "address-family ipv4 unicast", "route-reflector-client"]
-'''
-
-import re
-
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-
-
-BOOL_PARAMS = [
-    'allowas_in',
-    'as_override',
-    'default_originate',
-    'disable_peer_as_check',
-    'next_hop_self',
-    'next_hop_third_party',
-    'route_reflector_client',
-    'suppress_inactive'
-]
-PARAM_TO_COMMAND_KEYMAP = {
-    'afi': 'address-family',
-    'asn': 'router bgp',
-    'neighbor': 'neighbor',
-    'additional_paths_receive': 'capability additional-paths receive',
-    'additional_paths_send': 'capability additional-paths send',
-    'advertise_map_exist': 'advertise-map exist-map',
-    'advertise_map_non_exist': 'advertise-map non-exist-map',
-    'allowas_in': 'allowas-in',
-    'allowas_in_max': 'allowas-in',
-    'as_override': 'as-override',
-    'default_originate': 'default-originate',
-    'default_originate_route_map': 'default-originate route-map',
-    'disable_peer_as_check': 'disable-peer-as-check',
-    'filter_list_in': 'filter-list in',
-    'filter_list_out': 'filter-list out',
-    'max_prefix_limit': 'maximum-prefix',
-    'max_prefix_interval': 'maximum-prefix interval',
-    'max_prefix_threshold': 'maximum-prefix threshold',
-    'max_prefix_warning': 'maximum-prefix warning',
-    'next_hop_self': 'next-hop-self',
-    'next_hop_third_party': 'next-hop-third-party',
-    'prefix_list_in': 'prefix-list in',
-    'prefix_list_out': 'prefix-list out',
-    'route_map_in': 'route-map in',
-    'route_map_out': 'route-map out',
-    'route_reflector_client': 'route-reflector-client',
-    'safi': 'address-family',
-    'send_community': 'send-community',
-    'soft_reconfiguration_in': 'soft-reconfiguration inbound',
-    'soo': 'soo',
-    'suppress_inactive': 'suppress-inactive',
-    'unsuppress_map': 'unsuppress-map',
-    'weight': 'weight',
-    'vrf': 'vrf'
-}
-
-
-def get_value(arg, config, module):
-    custom = [
-        'additional_paths_send',
-        'additional_paths_receive',
-        'max_prefix_limit',
-        'max_prefix_interval',
-        'max_prefix_threshold',
-        'max_prefix_warning',
-        'send_community',
-        'soft_reconfiguration_in'
-    ]
-    command = PARAM_TO_COMMAND_KEYMAP[arg]
-    has_command = re.search(r'^\s+{0}\s*'.format(command), config, re.M)
-    has_command_val = re.search(r'(?:{0}\s)(?P<value>.*)$'.format(command), config, re.M)
-    value = ''
-
-    if arg in custom:
-        value = get_custom_value(arg, config, module)
-
-    elif arg == 'next_hop_third_party':
-        has_no_command = re.search(r'^\s+no\s+{0}\s*$'.format(command), config, re.M)
-        value = False
-        if not has_no_command:
-            value = True
-
-    elif arg in BOOL_PARAMS:
-        value = False
-        if has_command:
-            value = True
-
-    elif command.startswith('advertise-map'):
-        value = []
-        has_adv_map = re.search(r'{0}\s(?P<value1>.*)\s{1}\s(?P<value2>.*)$'.format(*command.split()), config, re.M)
-        if has_adv_map:
-            value = list(has_adv_map.groups())
-
-    elif command.split()[0] in ['filter-list', 'prefix-list', 'route-map']:
-        has_cmd_direction_val = re.search(r'{0}\s(?P<value>.*)\s{1}$'.format(*command.split()), config, re.M)
-        if has_cmd_direction_val:
-            value = has_cmd_direction_val.group('value')
-
-    elif has_command_val:
-        value = has_command_val.group('value')
-
-    return value
-
-
-def get_custom_value(arg, config, module):
-    command = PARAM_TO_COMMAND_KEYMAP.get(arg)
-    splitted_config = config.splitlines()
-    value = ''
-
-    if arg.startswith('additional_paths'):
-        value = 'inherit'
-        for line in splitted_config:
-            if command in line:
-                if 'disable' in line:
-                    value = 'disable'
-                else:
-                    value = 'enable'
-    elif arg.startswith('max_prefix'):
-        for line in splitted_config:
-            if 'maximum-prefix' in line:
-                splitted_line = line.split()
-                if arg == 'max_prefix_limit':
-                    value = splitted_line[1]
-                elif arg == 'max_prefix_interval' and 'restart' in line:
-                    value = splitted_line[-1]
-                elif arg == 'max_prefix_threshold' and len(splitted_line) > 2:
-                    try:
-                        int(splitted_line[2])
-                        value = splitted_line[2]
-                    except ValueError:
-                        value = ''
-                elif arg == 'max_prefix_warning':
-                    value = 'warning-only' in line
-    elif arg == 'soft_reconfiguration_in':
-        value = 'inherit'
-        for line in splitted_config:
-            if command in line:
-                if 'always' in line:
-                    value = 'always'
-                else:
-                    value = 'enable'
-
-    elif arg == 'send_community':
-        value = 'none'
-        for line in splitted_config:
-            if command in line:
-                if 'extended' in line:
-                    if value == 'standard':
-                        value = 'both'
-                    else:
-                        value = 'extended'
-                elif 'both' in line:
-                    value = 'both'
-                else:
-                    value = 'standard'
-
-    return value
-
-
-def get_existing(module, args, warnings):
-    existing = {}
-    netcfg = CustomNetworkConfig(indent=2, contents=get_config(module))
-
-    asn_regex = re.compile(r'.*router\sbgp\s(?P<existing_asn>\d+(\.\d+)?).*', re.S)
-    match_asn = asn_regex.match(str(netcfg))
-
-    if match_asn:
-        existing_asn = match_asn.group('existing_asn')
-        parents = ["router bgp {0}".format(existing_asn)]
-
-        if module.params['vrf'] != 'default':
-            parents.append('vrf {0}'.format(module.params['vrf']))
-
-        parents.append('neighbor {0}'.format(module.params['neighbor']))
-        parents.append('address-family {0} {1}'.format(module.params['afi'], module.params['safi']))
-        config = netcfg.get_section(parents)
-
-        if config:
-            for arg in args:
-                if arg not in ['asn', 'vrf', 'neighbor', 'afi', 'safi']:
-                    existing[arg] = get_value(arg, config, module)
-
-            existing['asn'] = existing_asn
-            existing['neighbor'] = module.params['neighbor']
-            existing['vrf'] = module.params['vrf']
-            existing['afi'] = module.params['afi']
-            existing['safi'] = module.params['safi']
-    else:
-        warnings.append("The BGP process didn't exist but the task just created it.")
-
-    return existing
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key in table:
-        new_key = key_map.get(key)
-        if new_key:
-            new_dict[new_key] = table.get(key)
-
-    return new_dict
-
-
-def get_default_command(key, value, existing_commands):
-    command = ''
-    if existing_commands.get(key):
-        existing_value = existing_commands.get(key)
-        if value == 'inherit':
-            if existing_value != 'inherit':
-                command = 'no {0}'.format(key)
-        else:
-            if key == 'advertise-map exist-map':
-                command = 'no advertise-map {0} exist-map {1}'.format(
-                    existing_value[0], existing_value[1])
-            elif key == 'advertise-map non-exist-map':
-                command = 'no advertise-map {0} non-exist-map {1}'.format(
-                    existing_value[0], existing_value[1])
-            elif key == 'filter-list in':
-                command = 'no filter-list {0} in'.format(existing_value)
-            elif key == 'filter-list out':
-                command = 'no filter-list {0} out'.format(existing_value)
-            elif key == 'prefix-list in':
-                command = 'no prefix-list {0} in'.format(existing_value)
-            elif key == 'prefix-list out':
-                command = 'no prefix-list {0} out'.format(existing_value)
-            elif key == 'route-map in':
-                command = 'no route-map {0} in'.format(existing_value)
-            elif key == 'route-map out':
-                command = 'no route-map {0} out'.format(existing_value)
-            elif key.startswith('maximum-prefix'):
-                command = 'no maximum-prefix'
-            elif key == 'allowas-in max':
-                command = ['no allowas-in {0}'.format(existing_value)]
-                command.append('allowas-in')
-            else:
-                command = 'no {0} {1}'.format(key, existing_value)
-    else:
-        if key.replace(' ', '_').replace('-', '_') in BOOL_PARAMS:
-            command = 'no {0}'.format(key)
-    return command
-
-
-def fix_proposed(module, existing, proposed):
-    allowas_in = proposed.get('allowas_in')
-    allowas_in_max = proposed.get('allowas_in_max')
-
-    if allowas_in_max and not allowas_in:
-        proposed.pop('allowas_in_max')
-    elif allowas_in and allowas_in_max:
-        proposed.pop('allowas_in')
-
-    if existing.get('send_community') == 'none' and proposed.get('send_community') == 'default':
-        proposed.pop('send_community')
-    return proposed
-
-
-def state_present(module, existing, proposed, candidate):
-    commands = list()
-    proposed = fix_proposed(module, existing, proposed)
-
-    proposed_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, proposed)
-    existing_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, existing)
-    for key, value in proposed_commands.items():
-        if value in ['inherit', 'default']:
-            command = get_default_command(key, value, existing_commands)
-
-            if isinstance(command, str):
-                if command and command not in commands:
-                    commands.append(command)
-            elif isinstance(command, list):
-                for cmd in command:
-                    if cmd not in commands:
-                        commands.append(cmd)
-
-        elif key.startswith('maximum-prefix'):
-            if module.params['max_prefix_limit'] != 'default':
-                command = 'maximum-prefix {0}'.format(module.params['max_prefix_limit'])
-                if module.params['max_prefix_threshold']:
-                    command += ' {0}'.format(module.params['max_prefix_threshold'])
-                if module.params['max_prefix_interval']:
-                    command += ' restart {0}'.format(module.params['max_prefix_interval'])
-                elif module.params['max_prefix_warning']:
-                    command += ' warning-only'
-                commands.append(command)
-
-        elif value is True:
-            commands.append(key)
-        elif value is False:
-            commands.append('no {0}'.format(key))
-        elif key == 'address-family':
-            commands.append("address-family {0} {1}".format(module.params['afi'], module.params['safi']))
-        elif key.startswith('capability additional-paths'):
-            command = key
-            if value == 'disable':
-                command += ' disable'
-            commands.append(command)
-        elif key.startswith('advertise-map'):
-            direction = key.split()[1]
-            commands.append('advertise-map {1} {0} {2}'.format(direction, *value))
-        elif key.split()[0] in ['filter-list', 'prefix-list', 'route-map']:
-            commands.append('{1} {0} {2}'.format(value, *key.split()))
-
-        elif key == 'soft-reconfiguration inbound':
-            command = ''
-            if value == 'enable':
-                command = key
-            elif value == 'always':
-                command = '{0} {1}'.format(key, value)
-            commands.append(command)
-        elif key == 'send-community':
-            command = key
-            if value in ['standard', 'extended']:
-                commands.append('no ' + key + ' both')
-            command += ' {0}'.format(value)
-            commands.append(command)
-        else:
-            command = '{0} {1}'.format(key, value)
-            commands.append(command)
-
-    if commands:
-        parents = ['router bgp {0}'.format(module.params['asn'])]
-        if module.params['vrf'] != 'default':
-            parents.append('vrf {0}'.format(module.params['vrf']))
-
-        parents.append('neighbor {0}'.format(module.params['neighbor']))
-
-        af_command = 'address-family {0} {1}'.format(
-            module.params['afi'], module.params['safi'])
-        parents.append(af_command)
-        if af_command in commands:
-            commands.remove(af_command)
-        candidate.add(commands, parents=parents)
-
-
-def state_absent(module, existing, candidate):
-    commands = []
-    parents = ["router bgp {0}".format(module.params['asn'])]
-    if module.params['vrf'] != 'default':
-        parents.append('vrf {0}'.format(module.params['vrf']))
-
-    parents.append('neighbor {0}'.format(module.params['neighbor']))
-    commands.append('no address-family {0} {1}'.format(
-        module.params['afi'], module.params['safi']))
-    candidate.add(commands, parents=parents)
-
-
-def main():
-    argument_spec = dict(
-        asn=dict(required=True, type='str'),
-        vrf=dict(required=False, type='str', default='default'),
-        neighbor=dict(required=True, type='str'),
-        afi=dict(required=True, type='str'),
-        safi=dict(required=True, type='str'),
-        additional_paths_receive=dict(required=False, type='str', choices=['enable', 'disable', 'inherit']),
-        additional_paths_send=dict(required=False, type='str', choices=['enable', 'disable', 'inherit']),
-        advertise_map_exist=dict(required=False, type='list'),
-        advertise_map_non_exist=dict(required=False, type='list'),
-        allowas_in=dict(required=False, type='bool'),
-        allowas_in_max=dict(required=False, type='str'),
-        as_override=dict(required=False, type='bool'),
-        default_originate=dict(required=False, type='bool'),
-        default_originate_route_map=dict(required=False, type='str'),
-        disable_peer_as_check=dict(required=False, type='bool'),
-        filter_list_in=dict(required=False, type='str'),
-        filter_list_out=dict(required=False, type='str'),
-        max_prefix_limit=dict(required=False, type='str'),
-        max_prefix_interval=dict(required=False, type='str'),
-        max_prefix_threshold=dict(required=False, type='str'),
-        max_prefix_warning=dict(required=False, type='bool'),
-        next_hop_self=dict(required=False, type='bool'),
-        next_hop_third_party=dict(required=False, type='bool'),
-        prefix_list_in=dict(required=False, type='str'),
-        prefix_list_out=dict(required=False, type='str'),
-        route_map_in=dict(required=False, type='str'),
-        route_map_out=dict(required=False, type='str'),
-        route_reflector_client=dict(required=False, type='bool'),
-        send_community=dict(required=False, choices=['none', 'both', 'extended', 'standard', 'default']),
-        soft_reconfiguration_in=dict(required=False, type='str', choices=['enable', 'always', 'inherit']),
-        soo=dict(required=False, type='str'),
-        suppress_inactive=dict(required=False, type='bool'),
-        unsuppress_map=dict(required=False, type='str'),
-        weight=dict(required=False, type='str'),
-        state=dict(choices=['present', 'absent'], default='present', required=False),
-    )
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(
-        argument_spec=argument_spec,
-        mutually_exclusive=[['advertise_map_exist', 'advertise_map_non_exist'],
-                            ['max_prefix_interval', 'max_prefix_warning'],
-                            ['default_originate', 'default_originate_route_map'],
-                            ['allowas_in', 'allowas_in_max']],
-        supports_check_mode=True,
-    )
-
-    warnings = list()
-    result = dict(changed=False, warnings=warnings)
-
-    state = module.params['state']
-    for key in ['max_prefix_interval', 'max_prefix_warning', 'max_prefix_threshold']:
-        if module.params[key] and not module.params['max_prefix_limit']:
-            module.fail_json(
-                msg='max_prefix_limit is required when using %s' % key
-            )
-    if module.params['vrf'] == 'default' and module.params['soo']:
-        module.fail_json(msg='SOO is only allowed in non-default VRF')
-
-    args = PARAM_TO_COMMAND_KEYMAP.keys()
-    existing = get_existing(module, args, warnings)
-
-    if existing.get('asn') and state == 'present':
-        if existing.get('asn') != module.params['asn']:
-            module.fail_json(msg='Another BGP ASN already exists.',
-                             proposed_asn=module.params['asn'],
-                             existing_asn=existing.get('asn'))
-
-    for param in ['advertise_map_exist', 'advertise_map_non_exist']:
-        if module.params[param] == ['default']:
-            module.params[param] = 'default'
-
-    proposed_args = dict((k, v) for k, v in module.params.items() if v is not None and k in args)
-
-    proposed = {}
-    for key, value in proposed_args.items():
-        if key not in ['asn', 'vrf', 'neighbor']:
-            if not isinstance(value, list):
-                if str(value).lower() == 'true':
-                    value = True
-                elif str(value).lower() == 'false':
-                    value = False
-                elif str(value).lower() == 'default':
-                    if key in BOOL_PARAMS:
-                        value = False
-                    else:
-                        value = 'default'
-                elif key == 'send_community' and str(value).lower() == 'none':
-                    value = 'default'
-            if existing.get(key) != value:
-                proposed[key] = value
-
-    candidate = CustomNetworkConfig(indent=3)
-    if state == 'present':
-        state_present(module, existing, proposed, candidate)
-    elif state == 'absent' and existing:
-        state_absent(module, existing, candidate)
-
-    if candidate:
-        candidate = candidate.items_text()
-        if not module.check_mode:
-            load_config(module, candidate)
-        result['changed'] = True
-        result['commands'] = candidate
-    else:
-        result['commands'] = []
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_command.py b/lib/ansible/modules/network/nxos/nxos_command.py
deleted file mode 100644
index 8a213ea6cc..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_command.py
+++ /dev/null
@@ -1,231 +0,0 @@
-#!/usr/bin/python
-# Copyright: Ansible Project
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = """
----
-module: nxos_command
-extends_documentation_fragment: nxos
-version_added: "2.1"
-author: "Peter Sprygada (@privateip)"
-short_description: Run arbitrary command on Cisco NXOS devices
-description:
-  - Sends an arbitrary command to an NXOS node and returns the results
-    read from the device.  This module includes an
-    argument that will cause the module to wait for a specific condition
-    before returning or timing out if the condition is not met.
-options:
-  commands:
-    description:
-      - The commands to send to the remote NXOS device.  The resulting
-        output from the command is returned.  If the I(wait_for)
-        argument is provided, the module is not returned until the
-        condition is satisfied or the number of retires as expired.
-      - The I(commands) argument also accepts an alternative form
-        that allows for complex values that specify the command
-        to run and the output format to return.   This can be done
-        on a command by command basis.  The complex argument supports
-        the keywords C(command) and C(output) where C(command) is the
-        command to run and C(output) is one of 'text' or 'json'.
-    required: true
-  wait_for:
-    description:
-      - Specifies what to evaluate from the output of the command
-        and what conditionals to apply.  This argument will cause
-        the task to wait for a particular conditional to be true
-        before moving forward.   If the conditional is not true
-        by the configured retries, the task fails.  See examples.
-    aliases: ['waitfor']
-    version_added: "2.2"
-  match:
-    description:
-      - The I(match) argument is used in conjunction with the
-        I(wait_for) argument to specify the match policy.  Valid
-        values are C(all) or C(any).  If the value is set to C(all)
-        then all conditionals in the I(wait_for) must be satisfied.  If
-        the value is set to C(any) then only one of the values must be
-        satisfied.
-    default: all
-    version_added: "2.2"
-  retries:
-    description:
-      - Specifies the number of retries a command should by tried
-        before it is considered failed.  The command is run on the
-        target device every retry and evaluated against the I(wait_for)
-        conditionals.
-    default: 10
-  interval:
-    description:
-      - Configures the interval in seconds to wait between retries
-        of the command.  If the command does not pass the specified
-        conditional, the interval indicates how to long to wait before
-        trying the command again.
-    default: 1
-"""
-
-EXAMPLES = """
----
-- name: run show version on remote devices
-  nxos_command:
-    commands: show version
-
-- name: run show version and check to see if output contains Cisco
-  nxos_command:
-    commands: show version
-    wait_for: result[0] contains Cisco
-
-- name: run multiple commands on remote nodes
-  nxos_command:
-    commands:
-      - show version
-      - show interfaces
-
-- name: run multiple commands and evaluate the output
-  nxos_command:
-    commands:
-      - show version
-      - show interfaces
-    wait_for:
-      - result[0] contains Cisco
-      - result[1] contains loopback0
-
-- name: run commands and specify the output format
-  nxos_command:
-    commands:
-      - command: show version
-        output: json
-
-- name: run commands that require answering a prompt
-  nxos_command:
-    commands:
-      - configure terminal
-      - command: 'no feature npv'
-        prompt: 'Do you want to continue'
-        answer: 'y'
-
-"""
-
-RETURN = """
-stdout:
-  description: The set of responses from the commands
-  returned: always apart from low level errors (such as action plugin)
-  type: list
-  sample: ['...', '...']
-stdout_lines:
-  description: The value of stdout split into a list
-  returned: always apart from low level errors (such as action plugin)
-  type: list
-  sample: [['...', '...'], ['...'], ['...']]
-failed_conditions:
-  description: The list of conditionals that have failed
-  returned: failed
-  type: list
-  sample: ['...', '...']
-"""
-import time
-
-from ansible.module_utils._text import to_text
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.parsing import Conditional, FailedConditionalError
-from ansible.module_utils.network.common.utils import transform_commands, to_lines
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec, run_commands
-
-
-def parse_commands(module, warnings):
-    commands = transform_commands(module)
-
-    if module.check_mode:
-        for item in list(commands):
-            if not item['command'].startswith('show'):
-                warnings.append(
-                    'Only show commands are supported when using check mode, not '
-                    'executing %s' % item['command']
-                )
-                commands.remove(item)
-
-    return commands
-
-
-def to_cli(obj):
-    cmd = obj['command']
-    if obj.get('output') == 'json':
-        cmd += ' | json'
-    return cmd
-
-
-def main():
-    """entry point for module execution
-    """
-    argument_spec = dict(
-        # { command: <str>, output: <str>, prompt: <str>, response: <str> }
-        commands=dict(type='list', required=True),
-
-        wait_for=dict(type='list', aliases=['waitfor']),
-        match=dict(default='all', choices=['any', 'all']),
-
-        retries=dict(default=10, type='int'),
-        interval=dict(default=1, type='int')
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-    result = {'changed': False, 'warnings': warnings}
-    commands = parse_commands(module, warnings)
-    wait_for = module.params['wait_for'] or list()
-
-    try:
-        conditionals = [Conditional(c) for c in wait_for]
-    except AttributeError as exc:
-        module.fail_json(msg=to_text(exc))
-
-    retries = module.params['retries']
-    interval = module.params['interval']
-    match = module.params['match']
-
-    while retries > 0:
-        responses = run_commands(module, commands)
-
-        for item in list(conditionals):
-            try:
-                if item(responses):
-                    if match == 'any':
-                        conditionals = list()
-                        break
-                    conditionals.remove(item)
-            except FailedConditionalError as exc:
-                module.fail_json(msg=to_text(exc))
-
-        if not conditionals:
-            break
-
-        time.sleep(interval)
-        retries -= 1
-
-    if conditionals:
-        failed_conditions = [item.raw for item in conditionals]
-        msg = 'One or more conditional statements have not been satisfied'
-        module.fail_json(msg=msg, failed_conditions=failed_conditions)
-
-    result.update({
-        'stdout': responses,
-        'stdout_lines': list(to_lines(responses)),
-    })
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_config.py b/lib/ansible/modules/network/nxos/nxos_config.py
deleted file mode 100644
index a7ad1c0484..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_config.py
+++ /dev/null
@@ -1,533 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = """
----
-module: nxos_config
-extends_documentation_fragment: nxos
-version_added: "2.1"
-author: "Peter Sprygada (@privateip)"
-short_description: Manage Cisco NXOS configuration sections
-description:
-  - Cisco NXOS configurations use a simple block indent file syntax
-    for segmenting configuration into sections.  This module provides
-    an implementation for working with NXOS configuration sections in
-    a deterministic way.  This module works with either CLI or NXAPI
-    transports.
-options:
-  lines:
-    description:
-      - The ordered set of commands that should be configured in the
-        section.  The commands must be the exact same commands as found
-        in the device running-config.  Be sure to note the configuration
-        command syntax as some commands are automatically modified by the
-        device config parser.
-    aliases: ['commands']
-  parents:
-    description:
-      - The ordered set of parents that uniquely identify the section or hierarchy
-        the commands should be checked against.  If the parents argument
-        is omitted, the commands are checked against the set of top
-        level or global commands.
-  src:
-    description:
-      - The I(src) argument provides a path to the configuration file
-        to load into the remote system.  The path can either be a full
-        system path to the configuration file if the value starts with /
-        or relative to the root of the implemented role or playbook.
-        This argument is mutually exclusive with the I(lines) and
-        I(parents) arguments.
-    version_added: "2.2"
-  replace_src:
-    description:
-      - The I(replace_src) argument provides path to the configuration file
-        to load into the remote system. This argument is used to replace the
-        entire config with a flat-file. This is used with argument I(replace)
-        with value I(config). This is mutually exclusive with the I(lines) and
-        I(src) arguments. This argument is supported on Nexus 9K device.
-        Use I(nxos_file_copy) module to copy the flat file to remote device and
-        then use the path with this argument.
-    version_added: "2.5"
-  before:
-    description:
-      - The ordered set of commands to push on to the command stack if
-        a change needs to be made.  This allows the playbook designer
-        the opportunity to perform configuration commands prior to pushing
-        any changes without affecting how the set of commands are matched
-        against the system.
-  after:
-    description:
-      - The ordered set of commands to append to the end of the command
-        stack if a change needs to be made.  Just like with I(before) this
-        allows the playbook designer to append a set of commands to be
-        executed after the command set.
-  match:
-    description:
-      - Instructs the module on the way to perform the matching of
-        the set of commands against the current device config.  If
-        match is set to I(line), commands are matched line by line.  If
-        match is set to I(strict), command lines are matched with respect
-        to position.  If match is set to I(exact), command lines
-        must be an equal match.  Finally, if match is set to I(none), the
-        module will not attempt to compare the source configuration with
-        the running configuration on the remote device.
-    default: line
-    choices: ['line', 'strict', 'exact', 'none']
-  replace:
-    description:
-      - Instructs the module on the way to perform the configuration
-        on the device.  If the replace argument is set to I(line) then
-        the modified lines are pushed to the device in configuration
-        mode.  If the replace argument is set to I(block) then the entire
-        command block is pushed to the device in configuration mode if any
-        line is not correct. replace I(config) is supported only on Nexus 9K device.
-    default: line
-    choices: ['line', 'block', 'config']
-  backup:
-    description:
-      - This argument will cause the module to create a full backup of
-        the current C(running-config) from the remote device before any
-        changes are made. If the C(backup_options) value is not given,
-        the backup file is written to the C(backup) folder in the playbook
-        root directory or role root directory, if playbook is part of an
-        ansible role. If the directory does not exist, it is created.
-    type: bool
-    default: 'no'
-    version_added: "2.2"
-  running_config:
-    description:
-      - The module, by default, will connect to the remote device and
-        retrieve the current running-config to use as a base for comparing
-        against the contents of source.  There are times when it is not
-        desirable to have the task get the current running-config for
-        every task in a playbook.  The I(running_config) argument allows the
-        implementer to pass in the configuration to use as the base
-        config for comparison.
-    aliases: ['config']
-    version_added: "2.4"
-  defaults:
-    description:
-      - The I(defaults) argument will influence how the running-config
-        is collected from the device.  When the value is set to true,
-        the command used to collect the running-config is append with
-        the all keyword.  When the value is set to false, the command
-        is issued without the all keyword
-    type: bool
-    default: 'no'
-    version_added: "2.2"
-  save_when:
-    description:
-      - When changes are made to the device running-configuration, the
-        changes are not copied to non-volatile storage by default.  Using
-        this argument will change that before.  If the argument is set to
-        I(always), then the running-config will always be copied to the
-        startup-config and the I(modified) flag will always be set to
-        True.  If the argument is set to I(modified), then the running-config
-        will only be copied to the startup-config if it has changed since
-        the last save to startup-config.  If the argument is set to
-        I(never), the running-config will never be copied to the
-        startup-config.  If the argument is set to I(changed), then the running-config
-        will only be copied to the startup-config if the task has made a change.
-        I(changed) was added in Ansible 2.6.
-    default: never
-    choices: ['always', 'never', 'modified', 'changed']
-    version_added: "2.4"
-  diff_against:
-    description:
-      - When using the C(ansible-playbook --diff) command line argument
-        the module can generate diffs against different sources.
-      - When this option is configure as I(startup), the module will return
-        the diff of the running-config against the startup-config.
-      - When this option is configured as I(intended), the module will
-        return the diff of the running-config against the configuration
-        provided in the C(intended_config) argument.
-      - When this option is configured as I(running), the module will
-        return the before and after diff of the running-config with respect
-        to any changes made to the device configuration.
-    default: startup
-    choices: ['startup', 'intended', 'running']
-    version_added: "2.4"
-  diff_ignore_lines:
-    description:
-      - Use this argument to specify one or more lines that should be
-        ignored during the diff.  This is used for lines in the configuration
-        that are automatically updated by the system.  This argument takes
-        a list of regular expressions or exact line matches.
-    version_added: "2.4"
-  intended_config:
-    description:
-      - The C(intended_config) provides the master configuration that
-        the node should conform to and is used to check the final
-        running-config against.   This argument will not modify any settings
-        on the remote device and is strictly used to check the compliance
-        of the current device's configuration against.  When specifying this
-        argument, the task should also modify the C(diff_against) value and
-        set it to I(intended).
-    version_added: "2.4"
-  backup_options:
-    description:
-      - This is a dict object containing configurable options related to backup file path.
-        The value of this option is read only when C(backup) is set to I(True), if C(backup) is set
-        to I(false) this option will be silently ignored.
-    suboptions:
-      filename:
-        description:
-          - The filename to be used to store the backup configuration. If the filename
-            is not given it will be generated based on the hostname, current time and date
-            in format defined by <hostname>_config.<current-date>@<current-time>
-      dir_path:
-        description:
-          - This option provides the path ending with directory name in which the backup
-            configuration file will be stored. If the directory does not exist it will be
-            created and the filename is either the value of C(filename) or default filename
-            as described in C(filename) options description. If the path value is not given
-            in that case a I(backup) directory will be created in the current working directory
-            and backup configuration will be copied in C(filename) within I(backup) directory.
-        type: path
-    type: dict
-    version_added: "2.8"
-notes:
-  - Abbreviated commands are NOT idempotent, see
-    L(Network FAQ,../network/user_guide/faq.html#why-do-the-config-modules-always-return-changed-true-with-abbreviated-commands).
-"""
-
-EXAMPLES = """
----
-- name: configure top level configuration and save it
-  nxos_config:
-    lines: hostname {{ inventory_hostname }}
-    save_when: modified
-
-- name: diff the running-config against a provided config
-  nxos_config:
-    diff_against: intended
-    intended_config: "{{ lookup('file', 'master.cfg') }}"
-
-- nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-      - 50 permit ip 192.0.2.5/32 any log
-    parents: ip access-list test
-    before: no ip access-list test
-    match: exact
-
-- nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-    parents: ip access-list test
-    before: no ip access-list test
-    replace: block
-
-- name: replace config with flat file
-  nxos_config:
-    replace_src: config.txt
-    replace: config
-
-- name: for idempotency, use full-form commands
-  nxos_config:
-    lines:
-      # - shut
-      - shutdown
-    # parents: int eth1/1
-    parents: interface Ethernet1/1
-
-- name: configurable backup path
-  nxos_config:
-    backup: yes
-    backup_options:
-      filename: backup.cfg
-      dir_path: /home/user
-"""
-
-RETURN = """
-commands:
-  description: The set of commands that will be pushed to the remote device
-  returned: always
-  type: list
-  sample: ['hostname foo', 'vlan 1', 'name default']
-updates:
-  description: The set of commands that will be pushed to the remote device
-  returned: always
-  type: list
-  sample: ['hostname foo', 'vlan 1', 'name default']
-backup_path:
-  description: The full path to the backup file
-  returned: when backup is yes
-  type: str
-  sample: /playbooks/ansible/backup/nxos_config.2016-07-16@22:28:34
-filename:
-  description: The name of the backup file
-  returned: when backup is yes and filename is not specified in backup options
-  type: str
-  sample: nxos_config.2016-07-16@22:28:34
-shortname:
-  description: The full path to the backup file excluding the timestamp
-  returned: when backup is yes and filename is not specified in backup options
-  type: str
-  sample: /playbooks/ansible/backup/nxos_config
-date:
-  description: The date extracted from the backup file name
-  returned: when backup is yes
-  type: str
-  sample: "2016-07-16"
-time:
-  description: The time extracted from the backup file name
-  returned: when backup is yes
-  type: str
-  sample: "22:28:34"
-"""
-from ansible.module_utils._text import to_text
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.connection import ConnectionError
-from ansible.module_utils.network.common.config import NetworkConfig, dumps
-from ansible.module_utils.network.nxos.nxos import get_config, load_config, run_commands, get_connection
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.network.common.utils import to_list
-
-
-def get_running_config(module, config=None, flags=None):
-    contents = module.params['running_config']
-    if not contents:
-        if config:
-            contents = config
-        else:
-            contents = get_config(module, flags=flags)
-    return contents
-
-
-def get_candidate(module):
-    candidate = ''
-    if module.params['src']:
-        if module.params['replace'] != 'config':
-            candidate = module.params['src']
-    if module.params['replace'] == 'config':
-        candidate = 'config replace {0}'.format(module.params['replace_src'])
-    elif module.params['lines']:
-        candidate_obj = NetworkConfig(indent=2)
-        parents = module.params['parents'] or list()
-        candidate_obj.add(module.params['lines'], parents=parents)
-        candidate = dumps(candidate_obj, 'raw')
-    return candidate
-
-
-def execute_show_commands(module, commands, output='text'):
-    cmds = []
-    for command in to_list(commands):
-        cmd = {'command': command,
-               'output': output,
-               }
-        cmds.append(cmd)
-    body = run_commands(module, cmds)
-    return body
-
-
-def save_config(module, result):
-    result['changed'] = True
-    if not module.check_mode:
-        cmd = {'command': 'copy running-config startup-config', 'output': 'text'}
-        run_commands(module, [cmd])
-    else:
-        module.warn('Skipping command `copy running-config startup-config` '
-                    'due to check_mode.  Configuration not copied to '
-                    'non-volatile storage')
-
-
-def main():
-    """ main entry point for module execution
-    """
-    backup_spec = dict(
-        filename=dict(),
-        dir_path=dict(type='path')
-    )
-    argument_spec = dict(
-        src=dict(type='path'),
-        replace_src=dict(),
-        lines=dict(aliases=['commands'], type='list'),
-        parents=dict(type='list'),
-
-        before=dict(type='list'),
-        after=dict(type='list'),
-
-        match=dict(default='line', choices=['line', 'strict', 'exact', 'none']),
-        replace=dict(default='line', choices=['line', 'block', 'config']),
-
-        running_config=dict(aliases=['config']),
-        intended_config=dict(),
-
-        defaults=dict(type='bool', default=False),
-        backup=dict(type='bool', default=False),
-        backup_options=dict(type='dict', options=backup_spec),
-
-        save_when=dict(choices=['always', 'never', 'modified', 'changed'], default='never'),
-
-        diff_against=dict(choices=['running', 'startup', 'intended']),
-        diff_ignore_lines=dict(type='list'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    mutually_exclusive = [('lines', 'src', 'replace_src'),
-                          ('parents', 'src')]
-
-    required_if = [('match', 'strict', ['lines']),
-                   ('match', 'exact', ['lines']),
-                   ('replace', 'block', ['lines']),
-                   ('replace', 'config', ['replace_src']),
-                   ('diff_against', 'intended', ['intended_config'])]
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           mutually_exclusive=mutually_exclusive,
-                           required_if=required_if,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    result = {'changed': False, 'warnings': warnings}
-
-    config = None
-
-    diff_ignore_lines = module.params['diff_ignore_lines']
-    path = module.params['parents']
-    connection = get_connection(module)
-    contents = None
-    flags = ['all'] if module.params['defaults'] else []
-    replace_src = module.params['replace_src']
-    if replace_src:
-        if module.params['replace'] != 'config':
-            module.fail_json(msg='replace: config is required with replace_src')
-
-    if module.params['backup'] or (module._diff and module.params['diff_against'] == 'running'):
-        contents = get_config(module, flags=flags)
-        config = NetworkConfig(indent=2, contents=contents)
-        if module.params['backup']:
-            result['__backup__'] = contents
-
-    if any((module.params['src'], module.params['lines'], replace_src)):
-        match = module.params['match']
-        replace = module.params['replace']
-
-        commit = not module.check_mode
-        candidate = get_candidate(module)
-        running = get_running_config(module, contents, flags=flags)
-        if replace_src:
-            commands = candidate.split('\n')
-            result['commands'] = result['updates'] = commands
-            if commit:
-                load_config(module, commands, replace=replace_src)
-
-            result['changed'] = True
-        else:
-            try:
-                response = connection.get_diff(candidate=candidate, running=running, diff_match=match, diff_ignore_lines=diff_ignore_lines, path=path,
-                                               diff_replace=replace)
-            except ConnectionError as exc:
-                module.fail_json(msg=to_text(exc, errors='surrogate_then_replace'))
-
-            config_diff = response['config_diff']
-            if config_diff:
-                commands = config_diff.split('\n')
-
-                if module.params['before']:
-                    commands[:0] = module.params['before']
-
-                if module.params['after']:
-                    commands.extend(module.params['after'])
-
-                result['commands'] = commands
-                result['updates'] = commands
-
-                if commit:
-                    load_config(module, commands, replace=replace_src)
-
-                result['changed'] = True
-
-    running_config = module.params['running_config']
-    startup_config = None
-
-    if module.params['save_when'] == 'always':
-        save_config(module, result)
-    elif module.params['save_when'] == 'modified':
-        output = execute_show_commands(module, ['show running-config', 'show startup-config'])
-
-        running_config = NetworkConfig(indent=2, contents=output[0], ignore_lines=diff_ignore_lines)
-        startup_config = NetworkConfig(indent=2, contents=output[1], ignore_lines=diff_ignore_lines)
-
-        if running_config.sha1 != startup_config.sha1:
-            save_config(module, result)
-    elif module.params['save_when'] == 'changed' and result['changed']:
-        save_config(module, result)
-
-    if module._diff:
-        if not running_config:
-            output = execute_show_commands(module, 'show running-config')
-            contents = output[0]
-        else:
-            contents = running_config
-
-        # recreate the object in order to process diff_ignore_lines
-        running_config = NetworkConfig(indent=2, contents=contents, ignore_lines=diff_ignore_lines)
-
-        if module.params['diff_against'] == 'running':
-            if module.check_mode:
-                module.warn("unable to perform diff against running-config due to check mode")
-                contents = None
-            else:
-                contents = config.config_text
-
-        elif module.params['diff_against'] == 'startup':
-            if not startup_config:
-                output = execute_show_commands(module, 'show startup-config')
-                contents = output[0]
-            else:
-                contents = startup_config.config_text
-
-        elif module.params['diff_against'] == 'intended':
-            contents = module.params['intended_config']
-
-        if contents is not None:
-            base_config = NetworkConfig(indent=2, contents=contents, ignore_lines=diff_ignore_lines)
-
-            if running_config.sha1 != base_config.sha1:
-                if module.params['diff_against'] == 'intended':
-                    before = running_config
-                    after = base_config
-                elif module.params['diff_against'] in ('startup', 'running'):
-                    before = base_config
-                    after = running_config
-
-                result.update({
-                    'changed': True,
-                    'diff': {'before': str(before), 'after': str(after)}
-                })
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_evpn_global.py b/lib/ansible/modules/network/nxos/nxos_evpn_global.py
deleted file mode 100644
index ed5fa8f22d..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_evpn_global.py
+++ /dev/null
@@ -1,101 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = '''
----
-module: nxos_evpn_global
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Handles the EVPN control plane for VXLAN.
-description:
-    - Handles the EVPN control plane for VXLAN.
-author: Gabriele Gerbino (@GGabriele)
-notes:
-  - This module is not supported on Nexus 3000 series of switches.
-options:
-  nv_overlay_evpn:
-    description:
-      - EVPN control plane.
-    required: true
-    type: bool
-'''
-
-EXAMPLES = '''
-- nxos_evpn_global:
-    nv_overlay_evpn: true
-'''
-
-RETURN = '''
-commands:
-    description: The set of commands to be sent to the remote device
-    returned: always
-    type: list
-    sample: ['nv overlay evpn']
-'''
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import get_capabilities, nxos_argument_spec
-
-
-def main():
-    argument_spec = dict(
-        nv_overlay_evpn=dict(required=True, type='bool'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    result = {'changed': False}
-
-    warnings = list()
-    if warnings:
-        result['warnings'] = warnings
-
-    config = get_config(module)
-    commands = list()
-
-    info = get_capabilities(module).get('device_info', {})
-    os_platform = info.get('network_os_platform', '')
-
-    if '3K' in os_platform:
-        module.fail_json(msg='This module is not supported on Nexus 3000 series')
-
-    if module.params['nv_overlay_evpn'] is True:
-        if 'nv overlay evpn' not in config:
-            commands.append('nv overlay evpn')
-    elif 'nv overlay evpn' in config:
-        commands.append('no nv overlay evpn')
-
-    if commands:
-        if not module.check_mode:
-            load_config(module, commands)
-        result['changed'] = True
-
-    result['commands'] = commands
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_evpn_vni.py b/lib/ansible/modules/network/nxos/nxos_evpn_vni.py
deleted file mode 100644
index e3bb7c568c..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_evpn_vni.py
+++ /dev/null
@@ -1,287 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_evpn_vni
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages Cisco EVPN VXLAN Network Identifier (VNI).
-description:
-  - Manages Cisco Ethernet Virtual Private Network (EVPN) VXLAN Network
-    Identifier (VNI) configurations of a Nexus device.
-author: Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - default, where supported, restores params default value.
-  - RD override is not permitted. You should set it to the default values
-    first and then reconfigure it.
-  - C(route_target_both), C(route_target_import) and
-    C(route_target_export valid) values are a list of extended communities,
-    (i.e. ['1.2.3.4:5', '33:55']) or the keywords 'auto' or 'default'.
-  - The C(route_target_both) property is discouraged due to the inconsistent
-    behavior of the property across Nexus platforms and image versions.
-    For this reason it is recommended to use explicit C(route_target_export)
-    and C(route_target_import) properties instead of C(route_target_both).
-  - RD valid values are a string in one of the route-distinguisher formats,
-    the keyword 'auto', or the keyword 'default'.
-options:
-  vni:
-    description:
-      - The EVPN VXLAN Network Identifier.
-    required: true
-  route_distinguisher:
-    description:
-      - The VPN Route Distinguisher (RD). The RD is combined with
-        the IPv4 or IPv6 prefix learned by the PE router to create a
-        globally unique address.
-    required: true
-  route_target_both:
-    description:
-      - Enables/Disables route-target settings for both import and
-        export target communities using a single property.
-  route_target_import:
-    description:
-      - Sets the route-target 'import' extended communities.
-  route_target_export:
-    description:
-      - Sets the route-target 'export' extended communities.
-  state:
-    description:
-      - Determines whether the config should be present or not
-        on the device.
-    default: present
-    choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-- name: vni configuration
-  nxos_evpn_vni:
-    vni: 6000
-    route_distinguisher: "60:10"
-    route_target_import:
-      - "5000:10"
-      - "4100:100"
-    route_target_export: auto
-    route_target_both: default
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["evpn", "vni 6000 l2", "route-target import 5001:10"]
-'''
-
-import re
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-
-
-PARAM_TO_COMMAND_KEYMAP = {
-    'vni': 'vni',
-    'route_distinguisher': 'rd',
-    'route_target_both': 'route-target both',
-    'route_target_import': 'route-target import',
-    'route_target_export': 'route-target export'
-}
-
-
-def get_value(arg, config, module):
-    command = PARAM_TO_COMMAND_KEYMAP.get(arg)
-    command_re = re.compile(r'(?:{0}\s)(?P<value>.*)$'.format(command), re.M)
-    value = ''
-    if command in config:
-        value = command_re.search(config).group('value')
-    return value
-
-
-def get_route_target_value(arg, config, module):
-    splitted_config = config.splitlines()
-    value_list = []
-    command = PARAM_TO_COMMAND_KEYMAP.get(arg)
-    command_re = re.compile(r'(?:{0}\s)(?P<value>.*)$'.format(command), re.M)
-
-    for line in splitted_config:
-        value = ''
-        if command in line.strip():
-            value = command_re.search(line).group('value')
-            value_list.append(value)
-    return value_list
-
-
-def get_existing(module, args):
-    existing = {}
-    netcfg = CustomNetworkConfig(indent=2, contents=get_config(module))
-    parents = ['evpn', 'vni {0} l2'.format(module.params['vni'])]
-    config = netcfg.get_section(parents)
-
-    if config:
-        for arg in args:
-            if arg != 'vni':
-                if arg == 'route_distinguisher':
-                    existing[arg] = get_value(arg, config, module)
-                else:
-                    existing[arg] = get_route_target_value(arg, config, module)
-
-        existing_fix = dict((k, v) for k, v in existing.items() if v)
-        if not existing_fix:
-            existing = existing_fix
-
-        existing['vni'] = module.params['vni']
-
-    return existing
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key in table:
-        new_key = key_map.get(key)
-        if new_key:
-            new_dict[new_key] = table.get(key)
-    return new_dict
-
-
-def fix_proposed(proposed_commands):
-    new_proposed = {}
-    for key, value in proposed_commands.items():
-        if key == 'route-target both':
-            new_proposed['route-target export'] = value
-            new_proposed['route-target import'] = value
-        else:
-            new_proposed[key] = value
-    return new_proposed
-
-
-def state_present(module, existing, proposed):
-    commands = list()
-    parents = list()
-    proposed_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, proposed)
-    existing_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, existing)
-
-    if proposed_commands.get('route-target both'):
-        proposed_commands = fix_proposed(proposed_commands)
-
-    for key, value in proposed_commands.items():
-        if key.startswith('route-target'):
-            if value == ['default']:
-                existing_value = existing_commands.get(key)
-
-                if existing_value:
-                    for target in existing_value:
-                        commands.append('no {0} {1}'.format(key, target))
-            elif not isinstance(value, list):
-                value = [value]
-
-            for target in value:
-                if target == 'default':
-                    continue
-                if existing:
-                    if target not in existing.get(key.replace('-', '_').replace(' ', '_')):
-                        commands.append('{0} {1}'.format(key, target))
-                else:
-                    commands.append('{0} {1}'.format(key, target))
-
-            if existing.get(key.replace('-', '_').replace(' ', '_')):
-                for exi in existing.get(key.replace('-', '_').replace(' ', '_')):
-                    if exi not in value:
-                        commands.append('no {0} {1}'.format(key, exi))
-
-        elif value == 'default':
-            existing_value = existing_commands.get(key)
-            if existing_value:
-                commands.append('no {0} {1}'.format(key, existing_value))
-        else:
-            command = '{0} {1}'.format(key, value)
-            commands.append(command)
-
-    if commands:
-        parents = ['evpn', 'vni {0} l2'.format(module.params['vni'])]
-
-    return commands, parents
-
-
-def state_absent(module, existing, proposed):
-    commands = ['no vni {0} l2'.format(module.params['vni'])]
-    parents = ['evpn']
-    return commands, parents
-
-
-def main():
-    argument_spec = dict(
-        vni=dict(required=True, type='str'),
-        route_distinguisher=dict(required=False, type='str'),
-        route_target_both=dict(required=False, type='list'),
-        route_target_import=dict(required=False, type='list'),
-        route_target_export=dict(required=False, type='list'),
-        state=dict(choices=['present', 'absent'], default='present', required=False)
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    warnings = list()
-    results = dict(changed=False, warnings=warnings)
-
-    state = module.params['state']
-    args = PARAM_TO_COMMAND_KEYMAP.keys()
-    existing = get_existing(module, args)
-    proposed_args = dict((k, v) for k, v in module.params.items()
-                         if v is not None and k in args)
-    commands = []
-    parents = []
-
-    proposed = {}
-    for key, value in proposed_args.items():
-        if key != 'vni':
-            if value == 'true':
-                value = True
-            elif value == 'false':
-                value = False
-            if existing.get(key) != value:
-                proposed[key] = value
-
-    if state == 'present':
-        commands, parents = state_present(module, existing, proposed)
-    elif state == 'absent' and existing:
-        commands, parents = state_absent(module, existing, proposed)
-
-    if commands:
-        candidate = CustomNetworkConfig(indent=3)
-        candidate.add(commands, parents=parents)
-        candidate = candidate.items_text()
-        if not module.check_mode:
-            load_config(module, candidate)
-            results['changed'] = True
-        results['commands'] = candidate
-    else:
-        results['commands'] = []
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_facts.py b/lib/ansible/modules/network/nxos/nxos_facts.py
deleted file mode 100644
index 3bf57caf2c..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_facts.py
+++ /dev/null
@@ -1,243 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = """
----
-module: nxos_facts
-extends_documentation_fragment: nxos
-version_added: "2.1"
-short_description: Gets facts about NX-OS switches
-description:
-  - Collects facts from Cisco Nexus devices running the NX-OS operating
-    system.  Fact collection is supported over both Cli and Nxapi
-    transports.  This module prepends all of the base network fact keys
-    with C(ansible_net_<fact>).  The facts module will always collect a
-    base set of facts from the device and can enable or disable
-    collection of additional facts.
-author:
-  - Jason Edelman (@jedelman8)
-  - Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-options:
-  gather_subset:
-    description:
-      - When supplied, this argument will restrict the facts collected
-        to a given subset.  Possible values for this argument include
-        all, hardware, config, legacy, and interfaces.  Can specify a
-        list of values to include a larger subset.  Values can also be used
-        with an initial C(M(!)) to specify that a specific subset should
-        not be collected.
-    required: false
-    default: '!config'
-    version_added: "2.2"
-  gather_network_resources:
-    description:
-      - When supplied, this argument will restrict the facts collected
-        to a given subset. Possible values for this argument include
-        all and the resources like interfaces, vlans etc. Can specify a
-        list of values to include a larger subset. Values can also be
-        used with an initial C(M(!)) to specify that a specific subset
-        should not be collected.
-        Valid subsets are 'all', 'bfd_interfaces', 'lag_interfaces', 'telemetry',
-        'vlans', 'lacp', 'lacp_interfaces', 'interfaces', 'l3_interfaces',
-        'l2_interfaces', 'lldp_global'.
-    required: false
-    version_added: "2.9"
-"""
-
-EXAMPLES = """
-- name: Gather all legacy facts
-  nxos_facts:
-    gather_subset: all
-- name: Gather only the config and default facts
-  nxos_facts:
-    gather_subset:
-      - config
-- name: Do not gather hardware facts
-  nxos_facts:
-    gather_subset:
-      - "!hardware"
-- name: Gather legacy and resource facts
-  nxos_facts:
-    gather_subset: all
-    gather_network_resources: all
-- name: Gather only the interfaces resource facts and no legacy facts
-  nxos_facts:
-    gather_subset:
-      - '!all'
-      - '!min'
-    gather_network_resources:
-      - interfaces
-- name: Gather interfaces resource and minimal legacy facts
-  nxos_facts:
-    gather_subset: min
-    gather_network_resources: interfaces
-"""
-
-RETURN = """
-ansible_net_gather_subset:
-  description: The list of fact subsets collected from the device
-  returned: always
-  type: list
-ansible_net_gather_network_resources:
-  description: The list of fact for network resource subsets collected from the device
-  returned: when the resource is configured
-  type: list
-# default
-ansible_net_model:
-  description: The model name returned from the device
-  returned: always
-  type: str
-ansible_net_serialnum:
-  description: The serial number of the remote device
-  returned: always
-  type: str
-ansible_net_version:
-  description: The operating system version running on the remote device
-  returned: always
-  type: str
-ansible_net_hostname:
-  description: The configured hostname of the device
-  returned: always
-  type: str
-ansible_net_image:
-  description: The image file the device is running
-  returned: always
-  type: str
-ansible_net_api:
-  description: The name of the transport
-  returned: always
-  type: str
-ansible_net_license_hostid:
-  description: The License host id of the device
-  returned: always
-  type: str
-ansible_net_python_version:
-  description: The Python version Ansible controller is using
-  returned: always
-  type: str
-# hardware
-ansible_net_filesystems:
-  description: All file system names available on the device
-  returned: when hardware is configured
-  type: list
-ansible_net_memfree_mb:
-  description: The available free memory on the remote device in Mb
-  returned: when hardware is configured
-  type: int
-ansible_net_memtotal_mb:
-  description: The total memory on the remote device in Mb
-  returned: when hardware is configured
-  type: int
-# config
-ansible_net_config:
-  description: The current active config from the device
-  returned: when config is configured
-  type: str
-# interfaces
-ansible_net_all_ipv4_addresses:
-  description: All IPv4 addresses configured on the device
-  returned: when interfaces is configured
-  type: list
-ansible_net_all_ipv6_addresses:
-  description: All IPv6 addresses configured on the device
-  returned: when interfaces is configured
-  type: list
-ansible_net_interfaces:
-  description: A hash of all interfaces running on the system
-  returned: when interfaces is configured
-  type: dict
-ansible_net_neighbors:
-  description:
-    - The list of LLDP and CDP neighbors from the device. If both,
-      CDP and LLDP neighbor data is present on one port, CDP is preferred.
-  returned: when interfaces is configured
-  type: dict
-# legacy (pre Ansible 2.2)
-fan_info:
-  description: A hash of facts about fans in the remote device
-  returned: when legacy is configured
-  type: dict
-hostname:
-  description: The configured hostname of the remote device
-  returned: when legacy is configured
-  type: dict
-interfaces_list:
-  description: The list of interface names on the remote device
-  returned: when legacy is configured
-  type: dict
-kickstart:
-  description: The software version used to boot the system
-  returned: when legacy is configured
-  type: str
-module:
-  description: A hash of facts about the modules in a remote device
-  returned: when legacy is configured
-  type: dict
-platform:
-  description: The hardware platform reported by the remote device
-  returned: when legacy is configured
-  type: str
-power_supply_info:
-  description: A hash of facts about the power supplies in the remote device
-  returned: when legacy is configured
-  type: str
-vlan_list:
-  description: The list of VLAN IDs configured on the remote device
-  returned: when legacy is configured
-  type: list
-"""
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.argspec.facts.facts import FactsArgs
-from ansible.module_utils.network.nxos.facts.facts import Facts
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-
-
-def main():
-    """
-    Main entry point for module execution
-
-    :returns: ansible_facts
-    """
-    argument_spec = FactsArgs.argument_spec
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = []
-    if module.params["gather_subset"] == "!config":
-        warnings.append('default value for `gather_subset` will be changed to `min` from `!config` v2.11 onwards')
-
-    result = Facts(module).get_facts()
-
-    ansible_facts, additional_warnings = result
-    warnings.extend(additional_warnings)
-
-    module.exit_json(ansible_facts=ansible_facts, warnings=warnings)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_feature.py b/lib/ansible/modules/network/nxos/nxos_feature.py
deleted file mode 100644
index d355e908f7..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_feature.py
+++ /dev/null
@@ -1,257 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = '''
----
-module: nxos_feature
-extends_documentation_fragment: nxos
-version_added: "2.1"
-short_description: Manage features in NX-OS switches.
-description:
-  - Offers ability to enable and disable features in NX-OS.
-author:
-  - Jason Edelman (@jedelman8)
-  - Gabriele Gerbino (@GGabriele)
-options:
-  feature:
-    description:
-      - Name of feature.
-    required: true
-  state:
-    description:
-      - Desired state of the feature.
-    required: false
-    default: 'enabled'
-    choices: ['enabled','disabled']
-'''
-
-EXAMPLES = '''
-- name: Ensure lacp is enabled
-  nxos_feature:
-    feature: lacp
-    state: enabled
-
-- name: Ensure ospf is disabled
-  nxos_feature:
-    feature: ospf
-    state: disabled
-
-- name: Ensure vpc is enabled
-  nxos_feature:
-    feature: vpc
-    state: enabled
-'''
-
-RETURN = '''
-commands:
-    description: The set of commands to be sent to the remote device
-    returned: always
-    type: list
-    sample: ['nv overlay evpn']
-'''
-
-import re
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.connection import ConnectionError
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import get_capabilities, nxos_argument_spec
-
-
-def get_available_features(feature, module):
-    available_features = {}
-    feature_regex = r'(?P<feature>\S+)\s+\d+\s+(?P<state>.*)'
-    command = {'command': 'show feature', 'output': 'text'}
-
-    try:
-        body = run_commands(module, [command])[0]
-        split_body = body.splitlines()
-    except (KeyError, IndexError):
-        return {}
-
-    for line in split_body:
-        try:
-            match_feature = re.match(feature_regex, line, re.DOTALL)
-            feature_group = match_feature.groupdict()
-            feature = feature_group['feature']
-            state = feature_group['state']
-        except AttributeError:
-            feature = ''
-            state = ''
-
-        if feature and state:
-            if 'enabled' in state:
-                state = 'enabled'
-
-            if feature not in available_features:
-                available_features[feature] = state
-            else:
-                if available_features[feature] == 'disabled' and state == 'enabled':
-                    available_features[feature] = state
-
-    return available_features
-
-
-def get_commands(proposed, existing, state, module):
-    feature = validate_feature(module, mode='config')
-    commands = []
-    feature_check = proposed == existing
-    if not feature_check:
-        if state == 'enabled':
-            command = 'feature {0}'.format(feature)
-            commands.append(command)
-        elif state == 'disabled':
-            command = "no feature {0}".format(feature)
-            commands.append(command)
-    return commands
-
-
-def validate_feature(module, mode='show'):
-    '''Some features may need to be mapped due to inconsistency
-    between how they appear from "show feature" output and
-    how they are configured'''
-
-    feature = module.params['feature']
-
-    try:
-        info = get_capabilities(module)
-        device_info = info.get('device_info', {})
-        os_version = device_info.get('network_os_version', '')
-    except ConnectionError:
-        os_version = ''
-
-    if '8.1' in os_version:
-        feature_to_be_mapped = {
-            'show': {
-                'nv overlay': 'nve',
-                'vn-segment-vlan-based': 'vnseg_vlan',
-                'hsrp': 'hsrp_engine',
-                'fabric multicast': 'fabric_mcast',
-                'scp-server': 'scpServer',
-                'sftp-server': 'sftpServer',
-                'sla responder': 'sla_responder',
-                'sla sender': 'sla_sender',
-                'ssh': 'sshServer',
-                'tacacs+': 'tacacs',
-                'telnet': 'telnetServer',
-                'ethernet-link-oam': 'elo'
-            },
-            'config': {
-                'nve': 'nv overlay',
-                'vnseg_vlan': 'vn-segment-vlan-based',
-                'hsrp_engine': 'hsrp',
-                'fabric_mcast': 'fabric multicast',
-                'scpServer': 'scp-server',
-                'sftpServer': 'sftp-server',
-                'sla_sender': 'sla sender',
-                'sla_responder': 'sla responder',
-                'sshServer': 'ssh',
-                'tacacs': 'tacacs+',
-                'telnetServer': 'telnet',
-                'elo': 'ethernet-link-oam'
-            }
-        }
-    else:
-        feature_to_be_mapped = {
-            'show': {
-                'nv overlay': 'nve',
-                'vn-segment-vlan-based': 'vnseg_vlan',
-                'hsrp': 'hsrp_engine',
-                'fabric multicast': 'fabric_mcast',
-                'scp-server': 'scpServer',
-                'sftp-server': 'sftpServer',
-                'sla responder': 'sla_responder',
-                'sla sender': 'sla_sender',
-                'ssh': 'sshServer',
-                'tacacs+': 'tacacs',
-                'telnet': 'telnetServer',
-                'ethernet-link-oam': 'elo',
-                'port-security': 'eth_port_sec'
-            },
-            'config': {
-                'nve': 'nv overlay',
-                'vnseg_vlan': 'vn-segment-vlan-based',
-                'hsrp_engine': 'hsrp',
-                'fabric_mcast': 'fabric multicast',
-                'scpServer': 'scp-server',
-                'sftpServer': 'sftp-server',
-                'sla_sender': 'sla sender',
-                'sla_responder': 'sla responder',
-                'sshServer': 'ssh',
-                'tacacs': 'tacacs+',
-                'telnetServer': 'telnet',
-                'elo': 'ethernet-link-oam',
-                'eth_port_sec': 'port-security'
-            }
-        }
-
-    if feature in feature_to_be_mapped[mode]:
-        feature = feature_to_be_mapped[mode][feature]
-
-    return feature
-
-
-def main():
-    argument_spec = dict(
-        feature=dict(type='str', required=True),
-        state=dict(choices=['enabled', 'disabled'], default='enabled')
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    warnings = list()
-    results = dict(changed=False, warnings=warnings)
-
-    feature = validate_feature(module)
-    state = module.params['state'].lower()
-
-    available_features = get_available_features(feature, module)
-    if feature not in available_features:
-        module.fail_json(
-            msg='Invalid feature name.',
-            features_currently_supported=available_features,
-            invalid_feature=feature)
-    else:
-        existstate = available_features[feature]
-
-        existing = dict(state=existstate)
-        proposed = dict(state=state)
-        results['changed'] = False
-
-        cmds = get_commands(proposed, existing, state, module)
-
-        if cmds:
-            # On N35 A8 images, some features return a yes/no prompt
-            # on enablement or disablement. Bypass using terminal dont-ask
-            cmds.insert(0, 'terminal dont-ask')
-            if not module.check_mode:
-                load_config(module, cmds)
-            results['changed'] = True
-
-    results['commands'] = cmds
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_file_copy.py b/lib/ansible/modules/network/nxos/nxos_file_copy.py
deleted file mode 100644
index b6d2aa8481..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_file_copy.py
+++ /dev/null
@@ -1,190 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = '''
----
-module: nxos_file_copy
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Copy a file to a remote NXOS device.
-description:
-  - This module supports two different workflows for copying a file
-    to flash (or bootflash) on NXOS devices.  Files can either be (1) pushed
-    from the Ansible controller to the device or (2) pulled from a remote SCP
-    file server to the device.  File copies are initiated from the NXOS
-    device to the remote SCP server.  This module only supports the
-    use of connection C(network_cli) or C(Cli) transport with connection C(local).
-author:
-  - Jason Edelman (@jedelman8)
-  - Gabriele Gerbino (@GGabriele)
-  - Rewritten as a plugin by (@mikewiebe)
-notes:
-  - Tested against NXOS 7.0(3)I2(5), 7.0(3)I4(6), 7.0(3)I5(3),
-    7.0(3)I6(1), 7.0(3)I7(3), 6.0(2)A8(8), 7.0(3)F3(4), 7.3(0)D1(1),
-    8.3(0), 9.2, 9.3
-  - When pushing files (file_pull is False) to the NXOS device,
-    feature scp-server must be enabled.
-  - When pulling files (file_pull is True) to the NXOS device,
-    feature scp-server is not required.
-  - When pulling files (file_pull is True) to the NXOS device,
-    no transfer will take place if the file is already present.
-  - Check mode will tell you if the file would be copied.
-requirements:
-  - paramiko (required when file_pull is False)
-  - SCPClient (required when file_pull is False)
-  - pexpect (required when file_pull is True)
-options:
-  local_file:
-    description:
-      - When (file_pull is False) this is the path to the local file on the Ansible controller.
-        The local directory must exist.
-      - When (file_pull is True) this is the target file name on the NXOS device.
-  remote_file:
-    description:
-      - When (file_pull is False) this is the remote file path on the NXOS device.
-        If omitted, the name of the local file will be used.
-        The remote directory must exist.
-      - When (file_pull is True) this is the full path to the file on the remote SCP
-        server to be copied to the NXOS device.
-  file_system:
-    description:
-      - The remote file system on the nxos device. If omitted,
-        devices that support a I(file_system) parameter will use
-        their default values.
-    default: "bootflash:"
-  connect_ssh_port:
-    description:
-      - SSH server port used for file transfer.
-    default: 22
-    version_added: "2.5"
-  file_pull:
-    description:
-      - When (False) file is copied from the Ansible controller to the NXOS device.
-      - When (True) file is copied from a remote SCP server to the NXOS device.
-        In this mode, the file copy is initiated from the NXOS device.
-      - If the file is already present on the device it will be overwritten and
-        therefore the operation is NOT idempotent.
-    type: bool
-    default: False
-    version_added: "2.7"
-  file_pull_compact:
-    description:
-      - When file_pull is True, this is used to compact nxos image files.
-        This option can only be used with nxos image files.
-      - When (file_pull is False), this is not used.
-    type: bool
-    default: False
-    version_added: "2.9"
-  file_pull_kstack:
-    description:
-      - When file_pull is True, this can be used to speed up file copies when
-        the nxos running image supports the use-kstack option.
-      - When (file_pull is False), this is not used.
-    type: bool
-    default: False
-    version_added: "2.9"
-  local_file_directory:
-    description:
-      - When (file_pull is True) file is copied from a remote SCP server to the NXOS device,
-        and written to this directory on the NXOS device. If the directory does not exist, it
-        will be created under the file_system. This is an optional parameter.
-      - When (file_pull is False), this is not used.
-    version_added: "2.7"
-  file_pull_timeout:
-    description:
-      - Use this parameter to set timeout in seconds, when transferring
-        large files or when the network is slow.
-      - When (file_pull is False), this is not used.
-    default: 300
-    version_added: "2.7"
-  remote_scp_server:
-    description:
-      - The remote scp server address when file_pull is True.
-        This is required if file_pull is True.
-      - When (file_pull is False), this is not used.
-    version_added: "2.7"
-  remote_scp_server_user:
-    description:
-      - The remote scp server username when file_pull is True.
-        This is required if file_pull is True.
-      - When (file_pull is False), this is not used.
-    version_added: "2.7"
-  remote_scp_server_password:
-    description:
-      - The remote scp server password when file_pull is True.
-        This is required if file_pull is True.
-      - When (file_pull is False), this is not used.
-    version_added: "2.7"
-  vrf:
-    description:
-      - The VRF used to pull the file. Useful when no vrf management is defined
-    default: "management"
-    version_added: "2.9"
-'''
-
-EXAMPLES = '''
-# File copy from ansible controller to nxos device
-  - name: "copy from server to device"
-    nxos_file_copy:
-      local_file: "./test_file.txt"
-      remote_file: "test_file.txt"
-
-# Initiate file copy from the nxos device to transfer file from an SCP server back to the nxos device
-  - name: "initiate file copy from device"
-    nxos_file_copy:
-      file_pull: True
-      local_file: "xyz"
-      local_file_directory: "dir1/dir2/dir3"
-      remote_file: "/mydir/abc"
-      remote_scp_server: "192.168.0.1"
-      remote_scp_server_user: "myUser"
-      remote_scp_server_password: "myPassword"
-      vrf: "management"
-'''
-
-RETURN = '''
-transfer_status:
-    description: Whether a file was transferred to the nxos device.
-    returned: success
-    type: str
-    sample: 'Sent'
-local_file:
-    description: The path of the local file.
-    returned: success
-    type: str
-    sample: '/path/to/local/file'
-remote_file:
-    description: The path of the remote file.
-    returned: success
-    type: str
-    sample: '/path/to/remote/file'
-remote_scp_server:
-    description: The name of the scp server when file_pull is True.
-    returned: success
-    type: str
-    sample: 'fileserver.example.com'
-changed:
-    description: Indicates whether or not the file was copied.
-    returned: success
-    type: bool
-    sample: true
-'''
diff --git a/lib/ansible/modules/network/nxos/nxos_gir.py b/lib/ansible/modules/network/nxos/nxos_gir.py
deleted file mode 100644
index 306846ff00..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_gir.py
+++ /dev/null
@@ -1,309 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_gir
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Trigger a graceful removal or insertion (GIR) of the switch.
-description:
-    - Trigger a graceful removal or insertion (GIR) of the switch.
-    - GIR processing may take more than 2 minutes. Timeout settings are automatically extended to 200s when user timeout settings are insufficient.
-author:
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - C(state) has effect only in combination with
-      C(system_mode_maintenance_timeout) or
-      C(system_mode_maintenance_on_reload_reset_reason).
-    - Using C(system_mode_maintenance) and
-      C(system_mode_maintenance_dont_generate_profile) would make the module
-      fail, but the system mode will be triggered anyway.
-options:
-    system_mode_maintenance:
-        description:
-            - When C(system_mode_maintenance=true) it puts all enabled
-              protocols in maintenance mode (using the isolate command).
-              When C(system_mode_maintenance=false) it puts all enabled
-              protocols in normal mode (using the no isolate command).
-        type: bool
-    system_mode_maintenance_dont_generate_profile:
-        description:
-            - When C(system_mode_maintenance_dont_generate_profile=true) it
-              prevents the dynamic searching of enabled protocols and executes
-              commands configured in a maintenance-mode profile.
-              Use this option if you want the system to use a maintenance-mode
-              profile that you have created.
-              When C(system_mode_maintenance_dont_generate_profile=false) it
-              prevents the dynamic searching of enabled protocols and executes
-              commands configured in a normal-mode profile. Use this option if
-              you want the system to use a normal-mode profile that
-              you have created.
-        type: bool
-    system_mode_maintenance_timeout:
-        description:
-            - Keeps the switch in maintenance mode for a specified
-              number of minutes. Range is 5-65535.
-    system_mode_maintenance_shutdown:
-        description:
-            - Shuts down all protocols, vPC domains, and interfaces except
-              the management interface (using the shutdown command).
-              This option is disruptive while C(system_mode_maintenance)
-              (which uses the isolate command) is not.
-        type: bool
-    system_mode_maintenance_on_reload_reset_reason:
-        description:
-            - Boots the switch into maintenance mode automatically in the
-              event of a specified system crash. Note that not all reset
-              reasons are applicable for all platforms. Also if reset
-              reason is set to match_any, it is not idempotent as it turns
-              on all reset reasons. If reset reason is match_any and state
-              is absent, it turns off all the reset reasons.
-        choices: ['hw_error','svc_failure','kern_failure','wdog_timeout',
-                  'fatal_error','lc_failure','match_any','manual_reload',
-                  'any_other', 'maintenance']
-    state:
-        description:
-            - Specify desired state of the resource.
-        required: true
-        default: present
-        choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-# Trigger system maintenance mode
-- nxos_gir:
-    system_mode_maintenance: true
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-# Trigger system normal mode
-- nxos_gir:
-    system_mode_maintenance: false
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-# Configure on-reload reset-reason for maintenance mode
-- nxos_gir:
-    system_mode_maintenance_on_reload_reset_reason: manual_reload
-    state: present
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-# Add on-reload reset-reason for maintenance mode
-- nxos_gir:
-    system_mode_maintenance_on_reload_reset_reason: hw_error
-    state: present
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-# Remove on-reload reset-reason for maintenance mode
-- nxos_gir:
-    system_mode_maintenance_on_reload_reset_reason: manual_reload
-    state: absent
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-# Set timeout for maintenance mode
-- nxos_gir:
-    system_mode_maintenance_timeout: 30
-    state: present
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-# Remove timeout for maintenance mode
-- nxos_gir:
-    system_mode_maintenance_timeout: 30
-    state: absent
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-'''
-
-RETURN = '''
-final_system_mode:
-    description: describe the last system mode
-    returned: verbose mode
-    type: str
-    sample: normal
-updates:
-    description: commands sent to the device
-    returned: verbose mode
-    type: list
-    sample: ["terminal dont-ask", "system mode maintenance timeout 10"]
-changed:
-    description: check to see if a change was made on the device
-    returned: always
-    type: bool
-    sample: true
-'''
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def get_system_mode(module):
-    command = {'command': 'show system mode', 'output': 'text'}
-    body = run_commands(module, [command])[0]
-    if body and 'normal' in body.lower():
-        mode = 'normal'
-    else:
-        mode = 'maintenance'
-    return mode
-
-
-def get_maintenance_timeout(module):
-    command = {'command': 'show maintenance timeout', 'output': 'text'}
-    body = run_commands(module, [command])[0]
-    timeout = body.split()[4]
-    return timeout
-
-
-def get_reset_reasons(module):
-    command = {'command': 'show maintenance on-reload reset-reasons', 'output': 'text'}
-    body = run_commands(module, [command])[0]
-    return body
-
-
-def get_commands(module, state, mode):
-    commands = list()
-    if module.params['system_mode_maintenance'] is True and mode == 'normal':
-        commands.append('system mode maintenance')
-    elif (module.params['system_mode_maintenance'] is False and
-          mode == 'maintenance'):
-        commands.append('no system mode maintenance')
-
-    elif (module.params[
-        'system_mode_maintenance_dont_generate_profile'] is True and
-            mode == 'normal'):
-        commands.append('system mode maintenance dont-generate-profile')
-    elif (module.params[
-          'system_mode_maintenance_dont_generate_profile'] is False and
-          mode == 'maintenance'):
-        commands.append('no system mode maintenance dont-generate-profile')
-
-    elif module.params['system_mode_maintenance_timeout']:
-        timeout = get_maintenance_timeout(module)
-        if (state == 'present' and
-                timeout != module.params['system_mode_maintenance_timeout']):
-            commands.append('system mode maintenance timeout {0}'.format(
-                            module.params['system_mode_maintenance_timeout']))
-        elif (state == 'absent' and
-                timeout == module.params['system_mode_maintenance_timeout']):
-            commands.append('no system mode maintenance timeout {0}'.format(
-                            module.params['system_mode_maintenance_timeout']))
-
-    elif (module.params['system_mode_maintenance_shutdown'] and
-            mode == 'normal'):
-        commands.append('system mode maintenance shutdown')
-    elif (module.params[
-          'system_mode_maintenance_shutdown'] is False and
-          mode == 'maintenance'):
-        commands.append('no system mode maintenance')
-
-    elif module.params['system_mode_maintenance_on_reload_reset_reason']:
-        reset_reasons = get_reset_reasons(module)
-        if (state == 'present' and
-                module.params['system_mode_maintenance_on_reload_reset_reason'].lower() not in reset_reasons.lower()):
-            commands.append('system mode maintenance on-reload '
-                            'reset-reason {0}'.format(
-                                module.params[
-                                    'system_mode_maintenance_on_reload_reset_reason']))
-        elif (state == 'absent' and
-              module.params[
-                  'system_mode_maintenance_on_reload_reset_reason'].lower() in
-              reset_reasons.lower()):
-            commands.append('no system mode maintenance on-reload '
-                            'reset-reason {0}'.format(
-                                module.params[
-                                    'system_mode_maintenance_on_reload_reset_reason']))
-
-    if commands:
-        commands.insert(0, 'terminal dont-ask')
-    return commands
-
-
-def main():
-    argument_spec = dict(
-        system_mode_maintenance=dict(required=False, type='bool'),
-        system_mode_maintenance_dont_generate_profile=dict(required=False,
-                                                           type='bool'),
-        system_mode_maintenance_timeout=dict(required=False, type='str'),
-        system_mode_maintenance_shutdown=dict(required=False, type='bool'),
-        system_mode_maintenance_on_reload_reset_reason=dict(required=False,
-                                                            choices=['hw_error', 'svc_failure', 'kern_failure',
-                                                                     'wdog_timeout', 'fatal_error', 'lc_failure',
-                                                                     'match_any', 'manual_reload', 'any_other',
-                                                                     'maintenance']),
-        state=dict(choices=['absent', 'present', 'default'],
-                   default='present', required=False)
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           mutually_exclusive=[[
-                               'system_mode_maintenance',
-                               'system_mode_maintenance_dont_generate_profile',
-                               'system_mode_maintenance_timeout',
-                               'system_mode_maintenance_shutdown',
-                               'system_mode_maintenance_on_reload_reset_reason'
-                           ]],
-                           required_one_of=[[
-                               'system_mode_maintenance',
-                               'system_mode_maintenance_dont_generate_profile',
-                               'system_mode_maintenance_timeout',
-                               'system_mode_maintenance_shutdown',
-                               'system_mode_maintenance_on_reload_reset_reason'
-                           ]],
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    state = module.params['state']
-    mode = get_system_mode(module)
-    commands = get_commands(module, state, mode)
-    changed = False
-    if commands:
-        if module.check_mode:
-            module.exit_json(changed=True, commands=commands)
-        else:
-            load_config(module, commands)
-            changed = True
-
-    result = {}
-    result['changed'] = changed
-    if module._verbosity > 0:
-        final_system_mode = get_system_mode(module)
-        result['final_system_mode'] = final_system_mode
-        result['updates'] = commands
-
-    result['warnings'] = warnings
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_gir_profile_management.py b/lib/ansible/modules/network/nxos/nxos_gir_profile_management.py
deleted file mode 100644
index 9959985ead..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_gir_profile_management.py
+++ /dev/null
@@ -1,204 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_gir_profile_management
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Create a maintenance-mode or normal-mode profile for GIR.
-description:
-    - Manage a maintenance-mode or normal-mode profile with configuration
-      commands that can be applied during graceful removal
-      or graceful insertion.
-author:
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - C(state=absent) removes the whole profile.
-options:
-    commands:
-        description:
-            - List of commands to be included into the profile.
-    mode:
-        description:
-            - Configure the profile as Maintenance or Normal mode.
-        required: true
-        choices: ['maintenance', 'normal']
-    state:
-        description:
-            - Specify desired state of the resource.
-        default: present
-        choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-# Create a maintenance-mode profile
-- nxos_gir_profile_management:
-    mode: maintenance
-    commands:
-      - router eigrp 11
-      - isolate
-
-# Remove the maintenance-mode profile
-- nxos_gir_profile_management:
-    mode: maintenance
-    state: absent
-'''
-
-RETURN = '''
-proposed:
-    description: list of commands passed into module.
-    returned: verbose mode
-    type: list
-    sample: ["router eigrp 11", "isolate"]
-existing:
-    description: list of existing profile commands.
-    returned: verbose mode
-    type: list
-    sample: ["router bgp 65535","isolate","router eigrp 10","isolate",
-            "diagnostic bootup level complete"]
-end_state:
-    description: list of profile entries after module execution.
-    returned: verbose mode
-    type: list
-    sample: ["router bgp 65535","isolate","router eigrp 10","isolate",
-            "diagnostic bootup level complete","router eigrp 11", "isolate"]
-updates:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["configure maintenance profile maintenance-mode",
-             "router eigrp 11","isolate"]
-changed:
-    description: check to see if a change was made on the device
-    returned: always
-    type: bool
-    sample: true
-'''
-
-
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-
-
-def get_existing(module):
-    existing = []
-    netcfg = CustomNetworkConfig(indent=2, contents=get_config(module))
-
-    if module.params['mode'] == 'maintenance':
-        parents = ['configure maintenance profile maintenance-mode']
-    else:
-        parents = ['configure maintenance profile normal-mode']
-
-    config = netcfg.get_section(parents)
-    if config:
-        existing = config.splitlines()
-        existing = [cmd.strip() for cmd in existing]
-        existing.pop(0)
-
-    return existing
-
-
-def state_present(module, existing, commands):
-    cmds = list()
-    if existing == commands:
-        # Idempotent case
-        return cmds
-    cmds.extend(commands)
-    if module.params['mode'] == 'maintenance':
-        cmds.insert(0, 'configure maintenance profile maintenance-mode')
-    else:
-        cmds.insert(0, 'configure maintenance profile normal-mode')
-
-    return cmds
-
-
-def state_absent(module, existing, commands):
-    if module.params['mode'] == 'maintenance':
-        cmds = ['no configure maintenance profile maintenance-mode']
-    else:
-        cmds = ['no configure maintenance profile normal-mode']
-    return cmds
-
-
-def invoke(name, *args, **kwargs):
-    func = globals().get(name)
-    if func:
-        return func(*args, **kwargs)
-
-
-def main():
-    argument_spec = dict(
-        commands=dict(required=False, type='list'),
-        mode=dict(required=True, choices=['maintenance', 'normal']),
-        state=dict(choices=['absent', 'present'], default='present')
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    state = module.params['state']
-    commands = module.params['commands'] or []
-
-    if state == 'absent' and commands:
-        module.fail_json(msg='when state is absent, no command can be used.')
-
-    existing = invoke('get_existing', module)
-    end_state = existing
-    changed = False
-
-    result = {}
-    cmds = []
-    if state == 'present' or (state == 'absent' and existing):
-        cmds = invoke('state_%s' % state, module, existing, commands)
-
-        if module.check_mode:
-            module.exit_json(changed=True, commands=cmds)
-        else:
-            if cmds:
-                load_config(module, cmds)
-                changed = True
-                end_state = invoke('get_existing', module)
-
-    result['changed'] = changed
-    if module._verbosity > 0:
-        end_state = invoke('get_existing', module)
-        result['end_state'] = end_state
-        result['existing'] = existing
-        result['proposed'] = commands
-        result['updates'] = cmds
-
-    result['warnings'] = warnings
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_hsrp.py b/lib/ansible/modules/network/nxos/nxos_hsrp.py
deleted file mode 100644
index a96e4fc3cd..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_hsrp.py
+++ /dev/null
@@ -1,474 +0,0 @@
-#!/usr/bin/python
-
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = r'''
----
-module: nxos_hsrp
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages HSRP configuration on NX-OS switches.
-description:
-  - Manages HSRP configuration on NX-OS switches.
-author:
-  - Jason Edelman (@jedelman8)
-  - Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - HSRP feature needs to be enabled first on the system.
-  - SVIs must exist before using this module.
-  - Interface must be a L3 port before using this module.
-  - HSRP cannot be configured on loopback interfaces.
-  - MD5 authentication is only possible with HSRPv2 while it is ignored if
-    HSRPv1 is used instead, while it will not raise any error. Here we allow
-    MD5 authentication only with HSRPv2 in order to enforce better practice.
-options:
-  group:
-    description:
-      - HSRP group number.
-    required: true
-  interface:
-    description:
-      - Full name of interface that is being managed for HSRP.
-    required: true
-  version:
-    description:
-      - HSRP version.
-    default: 1
-    choices: ['1','2']
-  priority:
-    description:
-      - HSRP priority or keyword 'default'.
-  preempt:
-    description:
-      - Enable/Disable preempt.
-    choices: ['enabled', 'disabled']
-  vip:
-    description:
-      - HSRP virtual IP address or keyword 'default'
-  auth_string:
-    description:
-      - Authentication string. If this needs to be hidden(for md5 type), the string
-        should be 7 followed by the key string. Otherwise, it can be 0 followed by
-        key string or just key string (for backward compatibility). For text type,
-        this should be just be a key string. if this is 'default', authentication
-        is removed.
-  auth_type:
-    description:
-      - Authentication type.
-    choices: ['text','md5']
-  state:
-    description:
-      - Specify desired state of the resource.
-    choices: ['present','absent']
-    default: 'present'
-'''
-
-EXAMPLES = r'''
-- name: Ensure HSRP is configured with following params on a SVI
-  nxos_hsrp:
-    group: 10
-    vip: 10.1.1.1
-    priority: 150
-    interface: vlan10
-    preempt: enabled
-
-- name: Ensure HSRP is configured with following params on a SVI
-        with clear text authentication
-  nxos_hsrp:
-    group: 10
-    vip: 10.1.1.1
-    priority: 150
-    interface: vlan10
-    preempt: enabled
-    auth_type: text
-    auth_string: CISCO
-
-- name: Ensure HSRP is configured with md5 authentication and clear
-        authentication string
-  nxos_hsrp:
-    group: 10
-    vip: 10.1.1.1
-    priority: 150
-    interface: vlan10
-    preempt: enabled
-    auth_type: md5
-    auth_string: "0 1234"
-
-- name: Ensure HSRP is configured with md5 authentication and hidden
-        authentication string
-  nxos_hsrp:
-    group: 10
-    vip: 10.1.1.1
-    priority: 150
-    interface: vlan10
-    preempt: enabled
-    auth_type: md5
-    auth_string: "7 1234"
-
-- name: Remove HSRP config for given interface, group, and VIP
-  nxos_hsrp:
-    group: 10
-    interface: vlan10
-    vip: 10.1.1.1
-    state: absent
-'''
-
-RETURN = r'''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["interface vlan10", "hsrp version 2", "hsrp 30", "ip 10.30.1.1"]
-'''
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import get_capabilities, nxos_argument_spec
-from ansible.module_utils.network.nxos.nxos import get_interface_type
-from ansible.module_utils.basic import AnsibleModule
-
-
-PARAM_TO_DEFAULT_KEYMAP = {
-    'vip': None,
-    'priority': '100',
-    'auth_type': 'text',
-    'auth_string': 'cisco',
-}
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key in table:
-        new_key = key_map.get(key)
-        if new_key:
-            value = table.get(key)
-            if value:
-                new_dict[new_key] = str(value)
-            else:
-                new_dict[new_key] = value
-    return new_dict
-
-
-def get_interface_mode(interface, intf_type, module):
-    command = 'show interface {0} | json'.format(interface)
-    interface = {}
-    mode = 'unknown'
-    try:
-        body = run_commands(module, [command])[0]
-    except IndexError:
-        return None
-
-    if intf_type in ['ethernet', 'portchannel']:
-        interface_table = body['TABLE_interface']['ROW_interface']
-        mode = str(interface_table.get('eth_mode', 'layer3'))
-        if mode == 'access' or mode == 'trunk':
-            mode = 'layer2'
-    elif intf_type == 'svi':
-        mode = 'layer3'
-    return mode
-
-
-def get_hsrp_group(group, interface, module):
-    command = 'show hsrp group {0} all | json'.format(group)
-    hsrp = {}
-
-    hsrp_key = {
-        'sh_if_index': 'interface',
-        'sh_group_num': 'group',
-        'sh_group_version': 'version',
-        'sh_cfg_prio': 'priority',
-        'sh_preempt': 'preempt',
-        'sh_vip': 'vip',
-        'sh_authentication_type': 'auth_type',
-        'sh_keystring_attr': 'auth_enc',
-        'sh_authentication_data': 'auth_string'
-    }
-
-    try:
-        body = run_commands(module, [command])[0]
-        hsrp_table = body['TABLE_grp_detail']['ROW_grp_detail']
-        if 'sh_keystring_attr' not in hsrp_table:
-            del hsrp_key['sh_keystring_attr']
-        if 'unknown enum:' in str(hsrp_table):
-            hsrp_table = get_hsrp_group_unknown_enum(module, command, hsrp_table)
-    except (AttributeError, IndexError, TypeError, KeyError):
-        return {}
-
-    if isinstance(hsrp_table, dict):
-        hsrp_table = [hsrp_table]
-
-    for hsrp_group in hsrp_table:
-        parsed_hsrp = apply_key_map(hsrp_key, hsrp_group)
-
-        parsed_hsrp['interface'] = parsed_hsrp['interface'].lower()
-
-        if parsed_hsrp['version'] == 'v1':
-            parsed_hsrp['version'] = '1'
-        elif parsed_hsrp['version'] == 'v2':
-            parsed_hsrp['version'] = '2'
-
-        if parsed_hsrp['auth_type'] == 'md5':
-            if parsed_hsrp['auth_enc'] == 'hidden':
-                parsed_hsrp['auth_enc'] = '7'
-            else:
-                parsed_hsrp['auth_enc'] = '0'
-
-        if parsed_hsrp['interface'] == interface:
-            return parsed_hsrp
-
-    return hsrp
-
-
-def get_hsrp_group_unknown_enum(module, command, hsrp_table):
-    '''Some older NXOS images fail to set the attr values when using structured output and
-    instead set the values to <unknown enum>. This fallback method is a workaround that
-    uses an unstructured (text) request to query the device a second time.
-    'sh_preempt' is currently the only attr affected. Add checks for other attrs as needed.
-    '''
-    if 'unknown enum:' in hsrp_table['sh_preempt']:
-        cmd = {'output': 'text', 'command': command.split('|')[0]}
-        out = run_commands(module, cmd)[0]
-        hsrp_table['sh_preempt'] = 'enabled' if ('may preempt' in out) else 'disabled'
-    return hsrp_table
-
-
-def get_commands_remove_hsrp(group, interface):
-    commands = ['interface {0}'.format(interface), 'no hsrp {0}'.format(group)]
-    return commands
-
-
-def get_commands_config_hsrp(delta, interface, args, existing):
-    commands = []
-
-    config_args = {
-        'group': 'hsrp {group}',
-        'priority': '{priority}',
-        'preempt': '{preempt}',
-        'vip': '{vip}'
-    }
-
-    preempt = delta.get('preempt', None)
-    group = delta.get('group', None)
-    vip = delta.get('vip', None)
-    priority = delta.get('priority', None)
-
-    if preempt:
-        if preempt == 'enabled':
-            delta['preempt'] = 'preempt'
-        elif preempt == 'disabled':
-            delta['preempt'] = 'no preempt'
-
-    if priority:
-        if priority == 'default':
-            if existing and existing.get('priority') != PARAM_TO_DEFAULT_KEYMAP.get('priority'):
-                delta['priority'] = 'no priority'
-            else:
-                del(delta['priority'])
-        else:
-            delta['priority'] = 'priority {0}'.format(delta['priority'])
-
-    if vip:
-        if vip == 'default':
-            if existing and existing.get('vip') != PARAM_TO_DEFAULT_KEYMAP.get('vip'):
-                delta['vip'] = 'no ip'
-            else:
-                del(delta['vip'])
-        else:
-            delta['vip'] = 'ip {0}'.format(delta['vip'])
-
-    for key in delta:
-        command = config_args.get(key, 'DNE').format(**delta)
-        if command and command != 'DNE':
-            if key == 'group':
-                commands.insert(0, command)
-            else:
-                commands.append(command)
-        command = None
-
-    auth_type = delta.get('auth_type', None)
-    auth_string = delta.get('auth_string', None)
-    auth_enc = delta.get('auth_enc', None)
-    if auth_type or auth_string:
-        if not auth_type:
-            auth_type = args['auth_type']
-        elif not auth_string:
-            auth_string = args['auth_string']
-        if auth_string != 'default':
-            if auth_type == 'md5':
-                command = 'authentication md5 key-string {0} {1}'.format(auth_enc, auth_string)
-                commands.append(command)
-            elif auth_type == 'text':
-                command = 'authentication text {0}'.format(auth_string)
-                commands.append(command)
-        else:
-            if existing and existing.get('auth_string') != PARAM_TO_DEFAULT_KEYMAP.get('auth_string'):
-                commands.append('no authentication')
-
-    if commands and not group:
-        commands.insert(0, 'hsrp {0}'.format(args['group']))
-
-    version = delta.get('version', None)
-    if version:
-        if version == '2':
-            command = 'hsrp version 2'
-        elif version == '1':
-            command = 'hsrp version 1'
-        commands.insert(0, command)
-        commands.insert(0, 'interface {0}'.format(interface))
-
-    if commands:
-        if not commands[0].startswith('interface'):
-            commands.insert(0, 'interface {0}'.format(interface))
-
-    return commands
-
-
-def is_default(interface, module):
-    command = 'show run interface {0}'.format(interface)
-
-    try:
-        body = run_commands(module, [command], check_rc=False)[0]
-        if 'invalid' in body.lower():
-            return 'DNE'
-        else:
-            raw_list = body.split('\n')
-            if raw_list[-1].startswith('interface'):
-                return True
-            else:
-                return False
-    except (KeyError):
-        return 'DNE'
-
-
-def validate_config(body, vip, module):
-    new_body = ''.join(body)
-    if "invalid ip address" in new_body.lower():
-        module.fail_json(msg="Invalid VIP. Possible duplicate IP address.",
-                         vip=vip)
-
-
-def main():
-    argument_spec = dict(
-        group=dict(required=True, type='str'),
-        interface=dict(required=True),
-        version=dict(choices=['1', '2'], default='1', required=False),
-        priority=dict(type='str', required=False),
-        preempt=dict(type='str', choices=['disabled', 'enabled'], required=False),
-        vip=dict(type='str', required=False),
-        auth_type=dict(choices=['text', 'md5'], required=False),
-        auth_string=dict(type='str', required=False),
-        state=dict(choices=['absent', 'present'], required=False, default='present')
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    warnings = list()
-    results = dict(changed=False, warnings=warnings)
-
-    interface = module.params['interface'].lower()
-    group = module.params['group']
-    version = module.params['version']
-    state = module.params['state']
-    priority = module.params['priority']
-    preempt = module.params['preempt']
-    vip = module.params['vip']
-    auth_type = module.params['auth_type']
-    auth_full_string = module.params['auth_string']
-    auth_enc = '0'
-    auth_string = None
-    if auth_full_string:
-        kstr = auth_full_string.split()
-        if len(kstr) == 2:
-            auth_enc = kstr[0]
-            auth_string = kstr[1]
-        elif len(kstr) == 1:
-            auth_string = kstr[0]
-        else:
-            module.fail_json(msg='Invalid auth_string')
-        if auth_enc != '0' and auth_enc != '7':
-            module.fail_json(msg='Invalid auth_string, only 0 or 7 allowed')
-
-    device_info = get_capabilities(module)
-    network_api = device_info.get('network_api', 'nxapi')
-
-    intf_type = get_interface_type(interface)
-    if (intf_type != 'ethernet' and network_api == 'cliconf'):
-        if is_default(interface, module) == 'DNE':
-            module.fail_json(msg='That interface does not exist yet. Create '
-                                 'it first.', interface=interface)
-        if intf_type == 'loopback':
-            module.fail_json(msg="Loopback interfaces don't support HSRP.",
-                             interface=interface)
-
-    mode = get_interface_mode(interface, intf_type, module)
-    if mode == 'layer2':
-        module.fail_json(msg='That interface is a layer2 port.\nMake it '
-                             'a layer 3 port first.', interface=interface)
-
-    if auth_type or auth_string:
-        if not (auth_type and auth_string):
-            module.fail_json(msg='When using auth parameters, you need BOTH '
-                                 'auth_type AND auth_string.')
-
-    args = dict(group=group, version=version, priority=priority,
-                preempt=preempt, vip=vip, auth_type=auth_type,
-                auth_string=auth_string, auth_enc=auth_enc)
-
-    proposed = dict((k, v) for k, v in args.items() if v is not None)
-
-    existing = get_hsrp_group(group, interface, module)
-
-    # This will enforce better practice with md5 and hsrp version.
-    if proposed.get('auth_type', None) == 'md5':
-        if proposed['version'] == '1':
-            module.fail_json(msg="It's recommended to use HSRP v2 "
-                                 "when auth_type=md5")
-
-    elif not proposed.get('auth_type', None) and existing:
-        if (proposed['version'] == '1' and
-                existing['auth_type'] == 'md5') and state == 'present':
-            module.fail_json(msg="Existing auth_type is md5. It's recommended "
-                                 "to use HSRP v2 when using md5")
-
-    commands = []
-    if state == 'present':
-        delta = dict(
-            set(proposed.items()).difference(existing.items()))
-        if delta:
-            command = get_commands_config_hsrp(delta, interface, args, existing)
-            commands.extend(command)
-
-    elif state == 'absent':
-        if existing:
-            command = get_commands_remove_hsrp(group, interface)
-            commands.extend(command)
-
-    if commands:
-        if module.check_mode:
-            module.exit_json(**results)
-        else:
-            load_config(module, commands)
-
-            # validate IP
-            if network_api == 'cliconf' and state == 'present':
-                commands.insert(0, 'config t')
-                body = run_commands(module, commands)
-                validate_config(body, vip, module)
-
-            results['changed'] = True
-
-            if 'configure' in commands:
-                commands.pop(0)
-
-    results['commands'] = commands
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_hsrp_interfaces.py b/lib/ansible/modules/network/nxos/nxos_hsrp_interfaces.py
deleted file mode 100644
index e6750eba1b..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_hsrp_interfaces.py
+++ /dev/null
@@ -1,163 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright 2019 Cisco and/or its affiliates.
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-
-"""
-The module file for nxos_hsrp_interfaces
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-ANSIBLE_METADATA = {
-    'metadata_version': '1.1',
-    'status': ['preview'],
-    'supported_by': 'network'
-}
-
-DOCUMENTATION = """
----
-module: nxos_hsrp_interfaces
-version_added: "2.10"
-short_description: 'Manages HSRP attributes of NXOS interfaces.'
-description: 'Manages Hot Standby Router Protocol (HSRP) interface attributes.'
-author: Chris Van Heuveln (@chrisvanheuveln)
-notes:
-options:
-  config:
-    description: The provided configuration
-    type: list
-    elements: dict
-    suboptions:
-      name:
-        type: str
-        description: The name of the interface.
-      bfd:
-        type: str
-        description:
-        - Enable/Disable HSRP Bidirectional Forwarding Detection (BFD) on the interface.
-        choices:
-        - enable
-        - disable
-  state:
-    description:
-    - The state the configuration should be left in
-    type: str
-    choices:
-    - merged
-    - replaced
-    - overridden
-    - deleted
-    default: merged
-"""
-EXAMPLES = """
-# Using deleted
-
-- name: Configure hsrp attributes on interfaces
-  nxos_hsrp_interfaces:
-    config:
-      - name: Ethernet1/1
-      - name: Ethernet1/2
-    operation: deleted
-
-
-# Using merged
-
-- name: Configure hsrp attributes on interfaces
-  nxos_hsrp_interfaces:
-    config:
-      - name: Ethernet1/1
-        bfd: enable
-      - name: Ethernet1/2
-        bfd: disable
-    operation: merged
-
-
-# Using overridden
-
-- name: Configure hsrp attributes on interfaces
-  nxos_hsrp_interfaces:
-    config:
-      - name: Ethernet1/1
-        bfd: enable
-      - name: Ethernet1/2
-        bfd: disable
-    operation: overridden
-
-
-# Using replaced
-
-- name: Configure hsrp attributes on interfaces
-  nxos_hsrp_interfaces:
-    config:
-      - name: Ethernet1/1
-        bfd: enable
-      - name: Ethernet1/2
-        bfd: disable
-    operation: replaced
-
-
-"""
-RETURN = """
-before:
-  description: The configuration prior to the model invocation.
-  returned: always
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-after:
-  description: The resulting configuration model invocation.
-  returned: when changed
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-commands:
-  description: The set of commands pushed to the remote device.
-  returned: always
-  type: list
-  sample: ['interface Ethernet1/1', 'hsrp bfd']
-"""
-
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.argspec.hsrp_interfaces.hsrp_interfaces import Hsrp_interfacesArgs
-from ansible.module_utils.network.nxos.config.hsrp_interfaces.hsrp_interfaces import Hsrp_interfaces
-
-
-def main():
-    """
-    Main entry point for module execution
-
-    :returns: the result form module invocation
-    """
-    module = AnsibleModule(argument_spec=Hsrp_interfacesArgs.argument_spec,
-                           supports_check_mode=True)
-
-    result = Hsrp_interfaces(module).execute_module()
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_igmp.py b/lib/ansible/modules/network/nxos/nxos_igmp.py
deleted file mode 100644
index cb645e7a04..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_igmp.py
+++ /dev/null
@@ -1,155 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_igmp
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages IGMP global configuration.
-description:
-    - Manages IGMP global configuration configuration settings.
-author:
-    - Jason Edelman (@jedelman8)
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - When C(state=default), all supported params will be reset to a
-      default state.
-    - If restart is set to true with other params set, the restart will happen
-      last, i.e. after the configuration takes place.
-options:
-    flush_routes:
-        description:
-            - Removes routes when the IGMP process is restarted. By default,
-              routes are not flushed.
-        type: bool
-    enforce_rtr_alert:
-        description:
-            - Enables or disables the enforce router alert option check for
-              IGMPv2 and IGMPv3 packets.
-        type: bool
-    restart:
-        description:
-            - Restarts the igmp process (using an exec config command).
-        type: bool
-    state:
-        description:
-            - Manages desired state of the resource.
-        default: present
-        choices: ['present', 'default']
-'''
-EXAMPLES = '''
-- name: Default igmp global params (all params except restart)
-  nxos_igmp:
-    state: default
-
-- name: Ensure the following igmp global config exists on the device
-  nxos_igmp:
-    flush_routes: true
-    enforce_rtr_alert: true
-
-- name: Restart the igmp process
-  nxos_igmp:
-    restart: true
-'''
-
-RETURN = '''
-updates:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["ip igmp flush-routes"]
-'''
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def get_current(module):
-    output = run_commands(module, {'command': 'show running-config', 'output': 'text'})
-    return {
-        'flush_routes': 'ip igmp flush-routes' in output[0],
-        'enforce_rtr_alert': 'ip igmp enforce-router-alert' in output[0]
-    }
-
-
-def get_desired(module):
-    return {
-        'flush_routes': module.params['flush_routes'],
-        'enforce_rtr_alert': module.params['enforce_rtr_alert']
-    }
-
-
-def main():
-    argument_spec = dict(
-        flush_routes=dict(type='bool'),
-        enforce_rtr_alert=dict(type='bool'),
-        restart=dict(type='bool', default=False),
-        state=dict(choices=['present', 'default'], default='present')
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    current = get_current(module)
-    desired = get_desired(module)
-
-    state = module.params['state']
-
-    commands = list()
-
-    if state == 'default':
-        if current['flush_routes']:
-            commands.append('no ip igmp flush-routes')
-        if current['enforce_rtr_alert']:
-            commands.append('no ip igmp enforce-router-alert')
-
-    elif state == 'present':
-        ldict = {'flush_routes': 'flush-routes', 'enforce_rtr_alert': 'enforce-router-alert'}
-        for arg in ['flush_routes', 'enforce_rtr_alert']:
-            if desired[arg] and not current[arg]:
-                commands.append('ip igmp {0}'.format(ldict.get(arg)))
-            elif current[arg] and not desired[arg]:
-                commands.append('no ip igmp {0}'.format(ldict.get(arg)))
-
-    result = {'changed': False, 'updates': commands, 'warnings': warnings}
-
-    if commands:
-        if not module.check_mode:
-            load_config(module, commands)
-        result['changed'] = True
-
-    if module.params['restart']:
-        cmd = {'command': 'restart igmp', 'output': 'text'}
-        run_commands(module, cmd)
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_igmp_interface.py b/lib/ansible/modules/network/nxos/nxos_igmp_interface.py
deleted file mode 100644
index 9ce6b45d26..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_igmp_interface.py
+++ /dev/null
@@ -1,629 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_igmp_interface
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages IGMP interface configuration.
-description:
-    - Manages IGMP interface configuration settings.
-author:
-    - Jason Edelman (@jedelman8)
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - When C(state=default), supported params will be reset to a default state.
-      These include C(version), C(startup_query_interval),
-      C(startup_query_count), C(robustness), C(querier_timeout), C(query_mrt),
-      C(query_interval), C(last_member_qrt), C(last_member_query_count),
-      C(group_timeout), C(report_llg), and C(immediate_leave).
-    - When C(state=absent), all configs for C(oif_ps), and
-      C(oif_routemap) will be removed.
-    - PIM must be enabled to use this module.
-    - This module is for Layer 3 interfaces.
-    - Route-map check not performed (same as CLI) check when configuring
-      route-map with 'static-oif'
-    - If restart is set to true with other params set, the restart will happen
-      last, i.e. after the configuration takes place. However, 'restart' itself
-      is not idempotent as it is an action and not configuration.
-options:
-    interface:
-        description:
-            - The full interface name for IGMP configuration.
-              e.g. I(Ethernet1/2).
-        required: true
-    version:
-        description:
-            - IGMP version. It can be 2 or 3 or keyword 'default'.
-        choices: ['2', '3', 'default']
-    startup_query_interval:
-        description:
-            - Query interval used when the IGMP process starts up.
-              The range is from 1 to 18000 or keyword 'default'.
-              The default is 31.
-    startup_query_count:
-        description:
-            - Query count used when the IGMP process starts up.
-              The range is from 1 to 10 or keyword 'default'.
-              The default is 2.
-    robustness:
-        description:
-            - Sets the robustness variable. Values can range from 1 to 7 or
-              keyword 'default'. The default is 2.
-    querier_timeout:
-        description:
-            - Sets the querier timeout that the software uses when deciding
-              to take over as the querier. Values can range from 1 to 65535
-              seconds or keyword 'default'. The default is 255 seconds.
-    query_mrt:
-        description:
-            - Sets the response time advertised in IGMP queries.
-              Values can range from 1 to 25 seconds or keyword 'default'.
-              The default is 10 seconds.
-    query_interval:
-        description:
-            - Sets the frequency at which the software sends IGMP host query
-              messages. Values can range from 1 to 18000 seconds or keyword
-              'default'. The default is 125 seconds.
-    last_member_qrt:
-        description:
-            - Sets the query interval waited after sending membership reports
-              before the software deletes the group state. Values can range
-              from 1 to 25 seconds or keyword 'default'. The default is 1 second.
-    last_member_query_count:
-        description:
-            - Sets the number of times that the software sends an IGMP query
-              in response to a host leave message.
-              Values can range from 1 to 5 or keyword 'default'. The default is 2.
-    group_timeout:
-        description:
-            - Sets the group membership timeout for IGMPv2.
-              Values can range from 3 to 65,535 seconds or keyword 'default'.
-              The default is 260 seconds.
-    report_llg:
-        description:
-            - Configures report-link-local-groups.
-              Enables sending reports for groups in 224.0.0.0/24.
-              Reports are always sent for nonlink local groups.
-              By default, reports are not sent for link local groups.
-        type: bool
-    immediate_leave:
-        description:
-            - Enables the device to remove the group entry from the multicast
-              routing table immediately upon receiving a leave message for
-              the group. Use this command to minimize the leave latency of
-              IGMPv2 group memberships on a given IGMP interface because the
-              device does not send group-specific queries.
-              The default is disabled.
-        type: bool
-    oif_routemap:
-        description:
-            - Configure a routemap for static outgoing interface (OIF) or
-              keyword 'default'.
-    oif_ps:
-        description:
-            - Configure prefixes and sources for static outgoing interface (OIF). This
-              is a list of dict where each dict has source and prefix defined or just
-              prefix if source is not needed. The specified values will be configured
-              on the device and if any previous prefix/sources exist, they will be removed.
-              Keyword 'default' is also accepted which removes all existing prefix/sources.
-        version_added: 2.6
-    restart:
-        description:
-            - Restart IGMP. This is NOT idempotent as this is action only.
-        type: bool
-        default: False
-    state:
-        description:
-            - Manages desired state of the resource.
-        default: present
-        choices: ['present', 'absent', 'default']
-'''
-EXAMPLES = '''
-- nxos_igmp_interface:
-    interface: ethernet1/32
-    startup_query_interval: 30
-    oif_ps:
-      - { 'prefix': '238.2.2.6' }
-      - { 'source': '192.168.0.1', 'prefix': '238.2.2.5'}
-    state: present
-'''
-RETURN = '''
-proposed:
-    description: k/v pairs of parameters passed into module
-    returned: always
-    type: dict
-    sample: {"startup_query_count": "30",
-             "oif_ps": [{'prefix': '238.2.2.6'}, {'source': '192.168.0.1', 'prefix': '238.2.2.5'}]}
-existing:
-    description: k/v pairs of existing igmp_interface configuration
-    returned: always
-    type: dict
-    sample: {"startup_query_count": "2", "oif_ps": []}
-end_state:
-    description: k/v pairs of igmp interface configuration after module execution
-    returned: always
-    type: dict
-    sample: {"startup_query_count": "30",
-             "oif_ps": [{'prefix': '238.2.2.6'}, {'source': '192.168.0.1', 'prefix': '238.2.2.5'}]}
-updates:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["interface Ethernet1/32", "ip igmp startup-query-count 30",
-             "ip igmp static-oif 238.2.2.6", "ip igmp static-oif 238.2.2.5 source 192.168.0.1"]
-changed:
-    description: check to see if a change was made on the device
-    returned: always
-    type: bool
-    sample: true
-'''
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.network.nxos.nxos import get_interface_type
-from ansible.module_utils.basic import AnsibleModule
-
-import re
-
-
-def execute_show_command(command, module, command_type='cli_show'):
-    if command_type == 'cli_show_ascii':
-        cmds = [{
-            'command': command,
-            'output': 'text',
-        }]
-    else:
-        cmds = [{
-            'command': command,
-            'output': 'json',
-        }]
-
-    return run_commands(module, cmds)
-
-
-def get_interface_mode(interface, intf_type, module):
-    command = 'show interface {0}'.format(interface)
-    interface = {}
-    mode = 'unknown'
-
-    if intf_type in ['ethernet', 'portchannel']:
-        body = execute_show_command(command, module)[0]
-        interface_table = body['TABLE_interface']['ROW_interface']
-        mode = str(interface_table.get('eth_mode', 'layer3'))
-        if mode == 'access' or mode == 'trunk':
-            mode = 'layer2'
-    elif intf_type == 'loopback' or intf_type == 'svi':
-        mode = 'layer3'
-    return mode
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key, value in table.items():
-        new_key = key_map.get(key)
-        if new_key:
-            value = table.get(key)
-            if value:
-                new_dict[new_key] = value
-            else:
-                new_dict[new_key] = value
-    return new_dict
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_igmp_interface(module, interface):
-    command = 'show ip igmp interface {0}'.format(interface)
-    igmp = {}
-
-    key_map = {
-        'IGMPVersion': 'version',
-        'ConfiguredStartupQueryInterval': 'startup_query_interval',
-        'StartupQueryCount': 'startup_query_count',
-        'RobustnessVariable': 'robustness',
-        'ConfiguredQuerierTimeout': 'querier_timeout',
-        'ConfiguredMaxResponseTime': 'query_mrt',
-        'ConfiguredQueryInterval': 'query_interval',
-        'LastMemberMTR': 'last_member_qrt',
-        'LastMemberQueryCount': 'last_member_query_count',
-        'ConfiguredGroupTimeout': 'group_timeout'
-    }
-
-    body = execute_show_command(command, module)[0]
-
-    if body:
-        if 'not running' in body:
-            return igmp
-        resource = body['TABLE_vrf']['ROW_vrf']['TABLE_if']['ROW_if']
-        igmp = apply_key_map(key_map, resource)
-        report_llg = str(resource['ReportingForLinkLocal']).lower()
-        if report_llg == 'true':
-            igmp['report_llg'] = True
-        elif report_llg == 'false':
-            igmp['report_llg'] = False
-
-        immediate_leave = str(resource['ImmediateLeave']).lower()  # returns en or dis
-        if re.search(r'^en|^true|^enabled', immediate_leave):
-            igmp['immediate_leave'] = True
-        elif re.search(r'^dis|^false|^disabled', immediate_leave):
-            igmp['immediate_leave'] = False
-
-    # the  next block of code is used to retrieve anything with:
-    # ip igmp static-oif *** i.e.. could be route-map ROUTEMAP
-    # or PREFIX source <ip>, etc.
-    command = 'show run interface {0} | inc oif'.format(interface)
-
-    body = execute_show_command(
-        command, module, command_type='cli_show_ascii')[0]
-
-    staticoif = []
-    if body:
-        split_body = body.split('\n')
-        route_map_regex = (r'.*ip igmp static-oif route-map\s+'
-                           r'(?P<route_map>\S+).*')
-        prefix_source_regex = (r'.*ip igmp static-oif\s+(?P<prefix>'
-                               r'((\d+.){3}\d+))(\ssource\s'
-                               r'(?P<source>\S+))?.*')
-
-        for line in split_body:
-            temp = {}
-            try:
-                match_route_map = re.match(route_map_regex, line, re.DOTALL)
-                route_map = match_route_map.groupdict()['route_map']
-            except AttributeError:
-                route_map = ''
-
-            try:
-                match_prefix_source = re.match(
-                    prefix_source_regex, line, re.DOTALL)
-                prefix_source_group = match_prefix_source.groupdict()
-                prefix = prefix_source_group['prefix']
-                source = prefix_source_group['source']
-            except AttributeError:
-                prefix = ''
-                source = ''
-
-            if route_map:
-                temp['route_map'] = route_map
-            if prefix:
-                temp['prefix'] = prefix
-            if source:
-                temp['source'] = source
-            if temp:
-                staticoif.append(temp)
-
-    igmp['oif_routemap'] = None
-    igmp['oif_prefix_source'] = []
-
-    if staticoif:
-        if len(staticoif) == 1 and staticoif[0].get('route_map'):
-            igmp['oif_routemap'] = staticoif[0]['route_map']
-        else:
-            igmp['oif_prefix_source'] = staticoif
-
-    return igmp
-
-
-def config_igmp_interface(delta, existing, existing_oif_prefix_source):
-    CMDS = {
-        'version': 'ip igmp version {0}',
-        'startup_query_interval': 'ip igmp startup-query-interval {0}',
-        'startup_query_count': 'ip igmp startup-query-count {0}',
-        'robustness': 'ip igmp robustness-variable {0}',
-        'querier_timeout': 'ip igmp querier-timeout {0}',
-        'query_mrt': 'ip igmp query-max-response-time {0}',
-        'query_interval': 'ip igmp query-interval {0}',
-        'last_member_qrt': 'ip igmp last-member-query-response-time {0}',
-        'last_member_query_count': 'ip igmp last-member-query-count {0}',
-        'group_timeout': 'ip igmp group-timeout {0}',
-        'report_llg': 'ip igmp report-link-local-groups',
-        'immediate_leave': 'ip igmp immediate-leave',
-        'oif_prefix_source': 'ip igmp static-oif {0} source {1} ',
-        'oif_routemap': 'ip igmp static-oif route-map {0}',
-        'oif_prefix': 'ip igmp static-oif {0}',
-    }
-
-    commands = []
-    command = None
-    def_vals = get_igmp_interface_defaults()
-
-    for key, value in delta.items():
-        if key == 'oif_ps' and value != 'default':
-            for each in value:
-                if each in existing_oif_prefix_source:
-                    existing_oif_prefix_source.remove(each)
-                else:
-                    # add new prefix/sources
-                    pf = each['prefix']
-                    src = ''
-                    if 'source' in each.keys():
-                        src = each['source']
-                    if src:
-                        commands.append(CMDS.get('oif_prefix_source').format(pf, src))
-                    else:
-                        commands.append(CMDS.get('oif_prefix').format(pf))
-            if existing_oif_prefix_source:
-                for each in existing_oif_prefix_source:
-                    # remove stale prefix/sources
-                    pf = each['prefix']
-                    src = ''
-                    if 'source' in each.keys():
-                        src = each['source']
-                    if src:
-                        commands.append('no ' + CMDS.get('oif_prefix_source').format(pf, src))
-                    else:
-                        commands.append('no ' + CMDS.get('oif_prefix').format(pf))
-        elif key == 'oif_routemap':
-            if value == 'default':
-                if existing.get(key):
-                    command = 'no ' + CMDS.get(key).format(existing.get(key))
-            else:
-                command = CMDS.get(key).format(value)
-        elif value:
-            if value == 'default':
-                if def_vals.get(key) != existing.get(key):
-                    command = CMDS.get(key).format(def_vals.get(key))
-            else:
-                command = CMDS.get(key).format(value)
-        elif not value:
-            command = 'no {0}'.format(CMDS.get(key).format(value))
-
-        if command:
-            if command not in commands:
-                commands.append(command)
-        command = None
-
-    return commands
-
-
-def get_igmp_interface_defaults():
-    version = '2'
-    startup_query_interval = '31'
-    startup_query_count = '2'
-    robustness = '2'
-    querier_timeout = '255'
-    query_mrt = '10'
-    query_interval = '125'
-    last_member_qrt = '1'
-    last_member_query_count = '2'
-    group_timeout = '260'
-    report_llg = False
-    immediate_leave = False
-
-    args = dict(version=version, startup_query_interval=startup_query_interval,
-                startup_query_count=startup_query_count, robustness=robustness,
-                querier_timeout=querier_timeout, query_mrt=query_mrt,
-                query_interval=query_interval, last_member_qrt=last_member_qrt,
-                last_member_query_count=last_member_query_count,
-                group_timeout=group_timeout, report_llg=report_llg,
-                immediate_leave=immediate_leave)
-
-    default = dict((param, value) for (param, value) in args.items()
-                   if value is not None)
-
-    return default
-
-
-def config_default_igmp_interface(existing, delta):
-    commands = []
-    proposed = get_igmp_interface_defaults()
-    delta = dict(set(proposed.items()).difference(existing.items()))
-    if delta:
-        command = config_igmp_interface(delta, existing, existing_oif_prefix_source=None)
-
-        if command:
-            for each in command:
-                commands.append(each)
-
-    return commands
-
-
-def config_remove_oif(existing, existing_oif_prefix_source):
-    commands = []
-    command = None
-    if existing.get('oif_routemap'):
-        commands.append('no ip igmp static-oif route-map {0}'.format(existing.get('oif_routemap')))
-    elif existing_oif_prefix_source:
-        for each in existing_oif_prefix_source:
-            if each.get('prefix') and each.get('source'):
-                command = 'no ip igmp static-oif {0} source {1} '.format(
-                    each.get('prefix'), each.get('source')
-                )
-            elif each.get('prefix'):
-                command = 'no ip igmp static-oif {0}'.format(
-                    each.get('prefix')
-                )
-            if command:
-                commands.append(command)
-            command = None
-
-    return commands
-
-
-def main():
-    argument_spec = dict(
-        interface=dict(required=True, type='str'),
-        version=dict(required=False, type='str'),
-        startup_query_interval=dict(required=False, type='str'),
-        startup_query_count=dict(required=False, type='str'),
-        robustness=dict(required=False, type='str'),
-        querier_timeout=dict(required=False, type='str'),
-        query_mrt=dict(required=False, type='str'),
-        query_interval=dict(required=False, type='str'),
-        last_member_qrt=dict(required=False, type='str'),
-        last_member_query_count=dict(required=False, type='str'),
-        group_timeout=dict(required=False, type='str'),
-        report_llg=dict(type='bool'),
-        immediate_leave=dict(type='bool'),
-        oif_routemap=dict(required=False, type='str'),
-        oif_ps=dict(required=False, type='raw'),
-        restart=dict(type='bool', default=False),
-        state=dict(choices=['present', 'absent', 'default'],
-                   default='present')
-    )
-
-    argument_spec.update(nxos_argument_spec)
-    mutually_exclusive = [('oif_ps', 'oif_routemap')]
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           mutually_exclusive=mutually_exclusive,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    state = module.params['state']
-    interface = module.params['interface']
-    oif_routemap = module.params['oif_routemap']
-    oif_ps = module.params['oif_ps']
-
-    intf_type = get_interface_type(interface)
-    if get_interface_mode(interface, intf_type, module) == 'layer2':
-        module.fail_json(msg='this module only works on Layer 3 interfaces')
-
-    existing = get_igmp_interface(module, interface)
-    existing_copy = existing.copy()
-    end_state = existing_copy
-
-    if not existing.get('version'):
-        module.fail_json(msg='pim needs to be enabled on the interface')
-
-    existing_oif_prefix_source = existing.get('oif_prefix_source')
-    # not json serializable
-    existing.pop('oif_prefix_source')
-
-    if oif_routemap and existing_oif_prefix_source:
-        module.fail_json(msg='Delete static-oif configurations on this '
-                             'interface if you want to use a routemap')
-
-    if oif_ps and existing.get('oif_routemap'):
-        module.fail_json(msg='Delete static-oif route-map configuration '
-                             'on this interface if you want to config '
-                             'static entries')
-
-    args = [
-        'version',
-        'startup_query_interval',
-        'startup_query_count',
-        'robustness',
-        'querier_timeout',
-        'query_mrt',
-        'query_interval',
-        'last_member_qrt',
-        'last_member_query_count',
-        'group_timeout',
-        'report_llg',
-        'immediate_leave',
-        'oif_routemap',
-    ]
-
-    changed = False
-    commands = []
-    proposed = dict((k, v) for k, v in module.params.items()
-                    if v is not None and k in args)
-
-    CANNOT_ABSENT = ['version', 'startup_query_interval',
-                     'startup_query_count', 'robustness', 'querier_timeout',
-                     'query_mrt', 'query_interval', 'last_member_qrt',
-                     'last_member_query_count', 'group_timeout', 'report_llg',
-                     'immediate_leave']
-
-    if state == 'absent':
-        for each in CANNOT_ABSENT:
-            if each in proposed:
-                module.fail_json(msg='only params: '
-                                     'oif_ps, oif_routemap can be used when '
-                                     'state=absent')
-
-    # delta check for all params except oif_ps
-    delta = dict(set(proposed.items()).difference(existing.items()))
-
-    if oif_ps:
-        if oif_ps == 'default':
-            delta['oif_ps'] = []
-        else:
-            delta['oif_ps'] = oif_ps
-
-    if state == 'present':
-        if delta:
-            command = config_igmp_interface(delta, existing, existing_oif_prefix_source)
-            if command:
-                commands.append(command)
-
-    elif state == 'default':
-        command = config_default_igmp_interface(existing, delta)
-        if command:
-            commands.append(command)
-    elif state == 'absent':
-        command = None
-        if existing.get('oif_routemap') or existing_oif_prefix_source:
-            command = config_remove_oif(existing, existing_oif_prefix_source)
-
-        if command:
-            commands.append(command)
-
-        command = config_default_igmp_interface(existing, delta)
-        if command:
-            commands.append(command)
-
-    cmds = []
-    results = {}
-    if commands:
-        commands.insert(0, ['interface {0}'.format(interface)])
-        cmds = flatten_list(commands)
-
-        if module.check_mode:
-            module.exit_json(changed=True, commands=cmds)
-        else:
-            load_config(module, cmds)
-            changed = True
-            end_state = get_igmp_interface(module, interface)
-            if 'configure' in cmds:
-                cmds.pop(0)
-
-    if module.params['restart']:
-        cmd = {'command': 'restart igmp', 'output': 'text'}
-        run_commands(module, cmd)
-
-    results['proposed'] = proposed
-    results['existing'] = existing_copy
-    results['updates'] = cmds
-    results['changed'] = changed
-    results['warnings'] = warnings
-    results['end_state'] = end_state
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_igmp_snooping.py b/lib/ansible/modules/network/nxos/nxos_igmp_snooping.py
deleted file mode 100644
index f25aef5fa9..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_igmp_snooping.py
+++ /dev/null
@@ -1,305 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_igmp_snooping
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages IGMP snooping global configuration.
-description:
-    - Manages IGMP snooping global configuration.
-author:
-    - Jason Edelman (@jedelman8)
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - When C(state=default), params will be reset to a default state.
-    - C(group_timeout) also accepts I(never) as an input.
-options:
-    snooping:
-        description:
-            - Enables/disables IGMP snooping on the switch.
-        type: bool
-    group_timeout:
-        description:
-            - Group membership timeout value for all VLANs on the device.
-              Accepted values are integer in range 1-10080, I(never) and
-              I(default).
-    link_local_grp_supp:
-        description:
-            - Global link-local groups suppression.
-        type: bool
-    report_supp:
-        description:
-            - Global IGMPv1/IGMPv2 Report Suppression.
-        type: bool
-    v3_report_supp:
-        description:
-            - Global IGMPv3 Report Suppression and Proxy Reporting.
-        type: bool
-    state:
-        description:
-            - Manage the state of the resource.
-        default: present
-        choices: ['present','default']
-'''
-
-EXAMPLES = '''
-# ensure igmp snooping params supported in this module are in there default state
-- nxos_igmp_snooping:
-    state: default
-
-# ensure following igmp snooping params are in the desired state
-- nxos_igmp_snooping:
-   group_timeout: never
-   snooping: true
-   link_local_grp_supp: false
-   optimize_mcast_flood: false
-   report_supp: true
-   v3_report_supp: true
-'''
-
-RETURN = '''
-commands:
-    description: command sent to the device
-    returned: always
-    type: list
-    sample: ["ip igmp snooping link-local-groups-suppression",
-             "ip igmp snooping group-timeout 50",
-             "no ip igmp snooping report-suppression",
-             "no ip igmp snooping v3-report-suppression",
-             "no ip igmp snooping"]
-'''
-
-
-import re
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def execute_show_command(command, module, output='text'):
-    command = {
-        'command': command,
-        'output': output,
-    }
-
-    return run_commands(module, [command])
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_group_timeout(config):
-    match = re.search(r'  Group timeout configured: (\S+)', config, re.M)
-    if match:
-        value = match.group(1)
-    else:
-        value = ''
-    return value
-
-
-def get_igmp_snooping(module):
-    command = 'show ip igmp snooping'
-    existing = {}
-
-    try:
-        body = execute_show_command(command, module, output='json')[0]
-    except IndexError:
-        body = []
-
-    if body:
-        snooping = str(body.get('enabled')).lower()
-        if snooping == 'true' or snooping == 'enabled':
-            existing['snooping'] = True
-        else:
-            existing['snooping'] = False
-
-        report_supp = str(body.get('grepsup')).lower()
-        if report_supp == 'true' or report_supp == 'enabled':
-            existing['report_supp'] = True
-        else:
-            existing['report_supp'] = False
-
-        link_local_grp_supp = str(body.get('glinklocalgrpsup')).lower()
-        if link_local_grp_supp == 'true' or link_local_grp_supp == 'enabled':
-            existing['link_local_grp_supp'] = True
-        else:
-            existing['link_local_grp_supp'] = False
-
-        v3_report_supp = str(body.get('gv3repsup')).lower()
-        if v3_report_supp == 'true' or v3_report_supp == 'enabled':
-            existing['v3_report_supp'] = True
-        else:
-            existing['v3_report_supp'] = False
-
-    command = 'show ip igmp snooping'
-    body = execute_show_command(command, module)[0]
-    if body:
-        existing['group_timeout'] = get_group_timeout(body)
-
-    return existing
-
-
-def config_igmp_snooping(delta, existing, default=False):
-    CMDS = {
-        'snooping': 'ip igmp snooping',
-        'group_timeout': 'ip igmp snooping group-timeout {}',
-        'link_local_grp_supp': 'ip igmp snooping link-local-groups-suppression',
-        'v3_report_supp': 'ip igmp snooping v3-report-suppression',
-        'report_supp': 'ip igmp snooping report-suppression'
-    }
-
-    commands = []
-    command = None
-    gt_command = None
-    for key, value in delta.items():
-        if value:
-            if default and key == 'group_timeout':
-                if existing.get(key):
-                    gt_command = 'no ' + CMDS.get(key).format(existing.get(key))
-            elif value == 'default' and key == 'group_timeout':
-                if existing.get(key):
-                    command = 'no ' + CMDS.get(key).format(existing.get(key))
-            else:
-                command = CMDS.get(key).format(value)
-        else:
-            command = 'no ' + CMDS.get(key).format(value)
-
-        if command:
-            commands.append(command)
-        command = None
-
-    if gt_command:
-        # ensure that group-timeout command is configured last
-        commands.append(gt_command)
-    return commands
-
-
-def get_igmp_snooping_defaults():
-    group_timeout = 'dummy'
-    report_supp = True
-    link_local_grp_supp = True
-    v3_report_supp = False
-    snooping = True
-
-    args = dict(snooping=snooping, link_local_grp_supp=link_local_grp_supp,
-                report_supp=report_supp, v3_report_supp=v3_report_supp,
-                group_timeout=group_timeout)
-
-    default = dict((param, value) for (param, value) in args.items()
-                   if value is not None)
-
-    return default
-
-
-def igmp_snooping_gt_dependency(command, existing, module):
-    # group-timeout will fail if igmp snooping is disabled
-    gt = [i for i in command if i.startswith('ip igmp snooping group-timeout')]
-    if gt:
-        if 'no ip igmp snooping' in command or (existing['snooping'] is False and 'ip igmp snooping' not in command):
-            msg = "group-timeout cannot be enabled or changed when ip igmp snooping is disabled"
-            module.fail_json(msg=msg)
-        else:
-            # ensure that group-timeout command is configured last
-            command.remove(gt[0])
-            command.append(gt[0])
-
-
-def main():
-    argument_spec = dict(
-        snooping=dict(required=False, type='bool'),
-        group_timeout=dict(required=False, type='str'),
-        link_local_grp_supp=dict(required=False, type='bool'),
-        report_supp=dict(required=False, type='bool'),
-        v3_report_supp=dict(required=False, type='bool'),
-        state=dict(choices=['present', 'default'], default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    warnings = list()
-    results = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    snooping = module.params['snooping']
-    link_local_grp_supp = module.params['link_local_grp_supp']
-    report_supp = module.params['report_supp']
-    v3_report_supp = module.params['v3_report_supp']
-    group_timeout = module.params['group_timeout']
-    state = module.params['state']
-
-    args = dict(snooping=snooping, link_local_grp_supp=link_local_grp_supp,
-                report_supp=report_supp, v3_report_supp=v3_report_supp,
-                group_timeout=group_timeout)
-
-    proposed = dict((param, value) for (param, value) in args.items()
-                    if value is not None)
-
-    existing = get_igmp_snooping(module)
-
-    commands = []
-    if state == 'present':
-        delta = dict(
-            set(proposed.items()).difference(existing.items())
-        )
-        if delta:
-            command = config_igmp_snooping(delta, existing)
-            if command:
-                if group_timeout:
-                    igmp_snooping_gt_dependency(command, existing, module)
-                commands.append(command)
-    elif state == 'default':
-        proposed = get_igmp_snooping_defaults()
-        delta = dict(
-            set(proposed.items()).difference(existing.items())
-        )
-        if delta:
-            command = config_igmp_snooping(delta, existing, default=True)
-            if command:
-                commands.append(command)
-
-    cmds = flatten_list(commands)
-    if cmds:
-        results['changed'] = True
-        if not module.check_mode:
-            load_config(module, cmds)
-        if 'configure' in cmds:
-            cmds.pop(0)
-        results['commands'] = cmds
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_install_os.py b/lib/ansible/modules/network/nxos/nxos_install_os.py
deleted file mode 100644
index 37c2b283d4..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_install_os.py
+++ /dev/null
@@ -1,596 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_install_os
-extends_documentation_fragment: nxos
-short_description: Set boot options like boot, kickstart image and issu.
-description:
-    - Install an operating system by setting the boot options like boot
-      image and kickstart image and optionally select to install using
-      ISSU (In Server Software Upgrade).
-notes:
-    - Tested against the following platforms and images
-      - N9k 7.0(3)I4(6), 7.0(3)I5(3), 7.0(3)I6(1), 7.0(3)I7(1), 7.0(3)F2(2), 7.0(3)F3(2)
-      - N3k 6.0(2)A8(6), 6.0(2)A8(8), 7.0(3)I6(1), 7.0(3)I7(1)
-      - N7k 7.3(0)D1(1), 8.0(1), 8.1(1), 8.2(1)
-    - This module requires both the ANSIBLE_PERSISTENT_CONNECT_TIMEOUT and
-      ANSIBLE_PERSISTENT_COMMAND_TIMEOUT timers to be set to 600 seconds or higher.
-      The module will exit if the timers are not set properly.
-    - When using connection local, ANSIBLE_PERSISTENT_CONNECT_TIMEOUT and
-      ANSIBLE_PERSISTENT_COMMAND_TIMEOUT can only be set using ENV variables or
-      the ansible.cfg file.
-    - Do not include full file paths, just the name of the file(s) stored on
-      the top level flash directory.
-    - This module attempts to install the software immediately,
-      which may trigger a reboot.
-    - In check mode, the module will indicate if an upgrade is needed and
-      whether or not the upgrade is disruptive or non-disruptive(ISSU).
-author:
-    - Jason Edelman (@jedelman8)
-    - Gabriele Gerbibo (@GGabriele)
-version_added: 2.2
-options:
-    system_image_file:
-        description:
-            - Name of the system (or combined) image file on flash.
-        required: true
-    kickstart_image_file:
-        description:
-            - Name of the kickstart image file on flash.
-              (Not required on all Nexus platforms)
-    issu:
-        version_added: "2.5"
-        description:
-            - Upgrade using In Service Software Upgrade (ISSU).
-              (Supported on N5k, N7k, N9k platforms)
-            - Selecting 'required' or 'yes' means that upgrades will only
-              proceed if the switch is capable of ISSU.
-            - Selecting 'desired' means that upgrades will use ISSU if possible
-              but will fall back to disruptive upgrade if needed.
-            - Selecting 'no' means do not use ISSU. Forced disruptive.
-        choices: ['required','desired', 'yes', 'no']
-        default: 'no'
-'''
-
-EXAMPLES = '''
-- name: Install OS on N9k
-  check_mode: no
-  nxos_install_os:
-    system_image_file: nxos.7.0.3.I6.1.bin
-    issu: desired
-
-- name: Wait for device to come back up with new image
-  wait_for:
-    port: 22
-    state: started
-    timeout: 500
-    delay: 60
-    host: "{{ inventory_hostname }}"
-
-- name: Check installed OS for newly installed version
-  nxos_command:
-    commands: ['show version | json']
-    provider: "{{ connection }}"
-  register: output
-- assert:
-    that:
-    - output['stdout'][0]['kickstart_ver_str'] == '7.0(3)I6(1)'
-'''
-
-RETURN = '''
-install_state:
-    description: Boot and install information.
-    returned: always
-    type: dict
-    sample: {
-    "install_state": [
-        "Compatibility check is done:",
-        "Module  bootable          Impact  Install-type  Reason",
-        "------  --------  --------------  ------------  ------",
-        "     1       yes  non-disruptive         reset  ",
-        "Images will be upgraded according to following table:",
-        "Module       Image                  Running-Version(pri:alt)           New-Version  Upg-Required",
-        "------  ----------  ----------------------------------------  --------------------  ------------",
-        "     1        nxos                               7.0(3)I6(1)           7.0(3)I7(1)           yes",
-        "     1        bios                        v4.4.0(07/12/2017)    v4.4.0(07/12/2017)            no"
-    ],
-    }
-'''
-
-
-import re
-from time import sleep
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-# Output options are 'text' or 'json'
-def execute_show_command(module, command, output='text'):
-    cmds = [{
-        'command': command,
-        'output': output,
-    }]
-
-    return run_commands(module, cmds)
-
-
-def get_platform(module):
-    """Determine platform type"""
-    data = execute_show_command(module, 'show inventory', 'json')
-    pid = data[0]['TABLE_inv']['ROW_inv'][0]['productid']
-
-    if re.search(r'N3K', pid):
-        type = 'N3K'
-    elif re.search(r'N5K', pid):
-        type = 'N5K'
-    elif re.search(r'N6K', pid):
-        type = 'N6K'
-    elif re.search(r'N7K', pid):
-        type = 'N7K'
-    elif re.search(r'N9K', pid):
-        type = 'N9K'
-    else:
-        type = 'unknown'
-
-    return type
-
-
-def parse_show_install(data):
-    """Helper method to parse the output of the 'show install all impact' or
-        'install all' commands.
-
-    Sample Output:
-
-    Installer will perform impact only check. Please wait.
-
-    Verifying image bootflash:/nxos.7.0.3.F2.2.bin for boot variable "nxos".
-    [####################] 100% -- SUCCESS
-
-    Verifying image type.
-    [####################] 100% -- SUCCESS
-
-    Preparing "bios" version info using image bootflash:/nxos.7.0.3.F2.2.bin.
-    [####################] 100% -- SUCCESS
-
-    Preparing "nxos" version info using image bootflash:/nxos.7.0.3.F2.2.bin.
-    [####################] 100% -- SUCCESS
-
-    Performing module support checks.
-    [####################] 100% -- SUCCESS
-
-    Notifying services about system upgrade.
-    [####################] 100% -- SUCCESS
-
-
-
-    Compatibility check is done:
-    Module  bootable          Impact  Install-type  Reason
-    ------  --------  --------------  ------------  ------
-         8       yes      disruptive         reset  Incompatible image for ISSU
-        21       yes      disruptive         reset  Incompatible image for ISSU
-
-
-    Images will be upgraded according to following table:
-    Module       Image  Running-Version(pri:alt)    New-Version   Upg-Required
-    ------  ----------  ----------------------------------------  ------------
-         8       lcn9k                7.0(3)F3(2)    7.0(3)F2(2)           yes
-         8        bios                     v01.17         v01.17            no
-        21       lcn9k                7.0(3)F3(2)    7.0(3)F2(2)           yes
-        21        bios                     v01.70         v01.70            no
-    """
-    if len(data) > 0:
-        data = massage_install_data(data)
-    ud = {'raw': data}
-    ud['processed'] = []
-    ud['disruptive'] = False
-    ud['upgrade_needed'] = False
-    ud['error'] = False
-    ud['invalid_command'] = False
-    ud['install_in_progress'] = False
-    ud['server_error'] = False
-    ud['upgrade_succeeded'] = False
-    ud['use_impact_data'] = False
-
-    # Check for server errors
-    if isinstance(data, int):
-        if data == -1:
-            ud['server_error'] = True
-        elif data >= 500:
-            ud['server_error'] = True
-        elif data == -32603:
-            ud['server_error'] = True
-        elif data == 1:
-            ud['server_error'] = True
-        return ud
-    else:
-        ud['list_data'] = data.split('\n')
-
-    for x in ud['list_data']:
-        # Check for errors and exit if found.
-        if re.search(r'Pre-upgrade check failed', x):
-            ud['error'] = True
-            break
-        if re.search(r'[I|i]nvalid command', x):
-            ud['invalid_command'] = True
-            ud['error'] = True
-            break
-        if re.search(r'No install all data found', x):
-            ud['error'] = True
-            break
-
-        # Check for potentially transient conditions
-        if re.search(r'Another install procedure may\s*be in progress', x):
-            ud['install_in_progress'] = True
-            break
-        if re.search(r'Backend processing error', x):
-            ud['server_error'] = True
-            break
-        if re.search(r'timed out', x):
-            ud['server_error'] = True
-            break
-        if re.search(r'^(-1|5\d\d)$', x):
-            ud['server_error'] = True
-            break
-
-        # Check for messages indicating a successful upgrade.
-        if re.search(r'Finishing the upgrade', x):
-            ud['upgrade_succeeded'] = True
-            break
-        if re.search(r'Install has been successful', x):
-            ud['upgrade_succeeded'] = True
-            break
-        if re.search(r'Switching over onto standby', x):
-            ud['upgrade_succeeded'] = True
-            break
-
-        # We get these messages when the upgrade is non-disruptive and
-        # we loose connection with the switchover but far enough along that
-        # we can be confident the upgrade succeeded.
-        if re.search(r'timeout .*trying to send command: install', x):
-            ud['upgrade_succeeded'] = True
-            ud['use_impact_data'] = True
-            break
-        if re.search(r'[C|c]onnection failure: timed out', x):
-            ud['upgrade_succeeded'] = True
-            ud['use_impact_data'] = True
-            break
-
-        # Begin normal parsing.
-        if re.search(r'----|Module|Images will|Compatibility', x):
-            ud['processed'].append(x)
-            continue
-        # Check to see if upgrade will be disruptive or non-disruptive and
-        # build dictionary of individual modules and their status.
-        # Sample Line:
-        #
-        # Module  bootable      Impact  Install-type  Reason
-        # ------  --------  ----------  ------------  ------
-        #     8        yes  disruptive         reset  Incompatible image
-        rd = r'(\d+)\s+(\S+)\s+(disruptive|non-disruptive)\s+(\S+)'
-        mo = re.search(rd, x)
-        if mo:
-            ud['processed'].append(x)
-            key = 'm%s' % mo.group(1)
-            field = 'disruptive'
-            if mo.group(3) == 'non-disruptive':
-                ud[key] = {field: False}
-            else:
-                ud[field] = True
-                ud[key] = {field: True}
-            field = 'bootable'
-            if mo.group(2) == 'yes':
-                ud[key].update({field: True})
-            else:
-                ud[key].update({field: False})
-            continue
-
-        # Check to see if switch needs an upgrade and build a dictionary
-        # of individual modules and their individual upgrade status.
-        # Sample Line:
-        #
-        # Module  Image  Running-Version(pri:alt)    New-Version  Upg-Required
-        # ------  -----  ----------------------------------------  ------------
-        # 8       lcn9k                7.0(3)F3(2)    7.0(3)F2(2)           yes
-        mo = re.search(r'(\d+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(yes|no)', x)
-        if mo:
-            ud['processed'].append(x)
-            key = 'm%s_%s' % (mo.group(1), mo.group(2))
-            field = 'upgrade_needed'
-            if mo.group(5) == 'yes':
-                ud[field] = True
-                ud[key] = {field: True}
-            else:
-                ud[key] = {field: False}
-            continue
-
-    return ud
-
-
-def massage_install_data(data):
-    # Transport cli returns a list containing one result item.
-    # Transport nxapi returns a list containing two items.  The second item
-    # contains the data we are interested in.
-    default_error_msg = 'No install all data found'
-    if len(data) == 1:
-        result_data = data[0]
-    elif len(data) == 2:
-        result_data = data[1]
-    else:
-        result_data = default_error_msg
-
-    # Further processing may be needed for result_data
-    if len(data) == 2 and isinstance(data[1], dict):
-        if 'clierror' in data[1].keys():
-            result_data = data[1]['clierror']
-        elif 'code' in data[1].keys() and data[1]['code'] == '500':
-            # We encountered a backend processing error for nxapi
-            result_data = data[1]['msg']
-        else:
-            result_data = default_error_msg
-    return result_data
-
-
-def build_install_cmd_set(issu, image, kick, type, force=True):
-    commands = ['terminal dont-ask']
-
-    # Different NX-OS platforms behave differently for
-    # disruptive and non-disruptive upgrade paths.
-    #
-    # 1) Combined kickstart/system image:
-    #    * Use option 'non-disruptive' for issu.
-    #    * Omit option 'non-disruptive' for disruptive upgrades.
-    # 2) Separate kickstart + system images.
-    #    * Omit hidden 'force' option for issu.
-    #    * Use hidden 'force' option for disruptive upgrades.
-    #    * Note: Not supported on all platforms
-    if re.search(r'required|desired|yes', issu):
-        if kick is None:
-            issu_cmd = 'non-disruptive'
-        else:
-            issu_cmd = ''
-    else:
-        if kick is None:
-            issu_cmd = ''
-        else:
-            issu_cmd = 'force' if force else ''
-
-    if type == 'impact':
-        rootcmd = 'show install all impact'
-        # The force option is not available for the impact command.
-        if kick:
-            issu_cmd = ''
-    else:
-        rootcmd = 'install all'
-    if kick is None:
-        commands.append(
-            '%s nxos %s %s' % (rootcmd, image, issu_cmd))
-    else:
-        commands.append(
-            '%s %s system %s kickstart %s' % (rootcmd, issu_cmd, image, kick))
-
-    return commands
-
-
-def parse_show_version(data):
-    version_data = {'raw': data[0].split('\n')}
-    version_data['version'] = ''
-    version_data['error'] = False
-    for x in version_data['raw']:
-        mo = re.search(r'(kickstart|system|NXOS):\s+version\s+(\S+)', x)
-        if mo:
-            version_data['version'] = mo.group(2)
-            continue
-
-    if version_data['version'] == '':
-        version_data['error'] = True
-
-    return version_data
-
-
-def check_mode_legacy(module, issu, image, kick=None):
-    """Some platforms/images/transports don't support the 'install all impact'
-        command so we need to use a different method."""
-    current = execute_show_command(module, 'show version', 'json')[0]
-    # Call parse_show_data on empty string to create the default upgrade
-    # data structure dictionary
-    data = parse_show_install('')
-    upgrade_msg = 'No upgrade required'
-
-    # Process System Image
-    data['error'] = False
-    tsver = 'show version image bootflash:%s' % image
-    data['upgrade_cmd'] = [tsver]
-    target_image = parse_show_version(execute_show_command(module, tsver))
-    if target_image['error']:
-        data['error'] = True
-        data['raw'] = target_image['raw']
-    if current['kickstart_ver_str'] != target_image['version'] and not data['error']:
-        data['upgrade_needed'] = True
-        data['disruptive'] = True
-        upgrade_msg = 'Switch upgraded: system: %s' % tsver
-
-    # Process Kickstart Image
-    if kick is not None and not data['error']:
-        tkver = 'show version image bootflash:%s' % kick
-        data['upgrade_cmd'].append(tsver)
-        target_kick = parse_show_version(execute_show_command(module, tkver))
-        if target_kick['error']:
-            data['error'] = True
-            data['raw'] = target_kick['raw']
-        if current['kickstart_ver_str'] != target_kick['version'] and not data['error']:
-            data['upgrade_needed'] = True
-            data['disruptive'] = True
-            upgrade_msg = upgrade_msg + ' kickstart: %s' % tkver
-
-    data['list_data'] = data['raw']
-    data['processed'] = upgrade_msg
-    return data
-
-
-def check_mode_nextgen(module, issu, image, kick=None):
-    """Use the 'install all impact' command for check_mode"""
-    opts = {'ignore_timeout': True}
-    commands = build_install_cmd_set(issu, image, kick, 'impact')
-    data = parse_show_install(load_config(module, commands, True, opts))
-    # If an error is encountered when issu is 'desired' then try again
-    # but set issu to 'no'
-    if data['error'] and issu == 'desired':
-        issu = 'no'
-        commands = build_install_cmd_set(issu, image, kick, 'impact')
-        # The system may be busy from the previous call to check_mode so loop
-        # until it's done.
-        data = check_install_in_progress(module, commands, opts)
-    if data['server_error']:
-        data['error'] = True
-    data['upgrade_cmd'] = commands
-    return data
-
-
-def check_install_in_progress(module, commands, opts):
-    for attempt in range(20):
-        data = parse_show_install(load_config(module, commands, True, opts))
-        if data['install_in_progress']:
-            sleep(1)
-            continue
-        break
-    return data
-
-
-def check_mode(module, issu, image, kick=None):
-    """Check switch upgrade impact using 'show install all impact' command"""
-    data = check_mode_nextgen(module, issu, image, kick)
-    if data['server_error']:
-        # We encountered an unrecoverable error in the attempt to get upgrade
-        # impact data from the 'show install all impact' command.
-        # Fallback to legacy method.
-        data = check_mode_legacy(module, issu, image, kick)
-    if data['invalid_command']:
-        # If we are upgrading from a device running a separate kickstart and
-        # system image the impact command will fail.
-        # Fallback to legacy method.
-        data = check_mode_legacy(module, issu, image, kick)
-    return data
-
-
-def do_install_all(module, issu, image, kick=None):
-    """Perform the switch upgrade using the 'install all' command"""
-    impact_data = check_mode(module, issu, image, kick)
-    if module.check_mode:
-        # Check mode set in the playbook so just return the impact data.
-        msg = '*** SWITCH WAS NOT UPGRADED: IMPACT DATA ONLY ***'
-        impact_data['processed'].append(msg)
-        return impact_data
-    if impact_data['error']:
-        # Check mode discovered an error so return with this info.
-        return impact_data
-    elif not impact_data['upgrade_needed']:
-        # The switch is already upgraded.  Nothing more to do.
-        return impact_data
-    else:
-        # If we get here, check_mode returned no errors and the switch
-        # needs to be upgraded.
-        if impact_data['disruptive']:
-            # Check mode indicated that ISSU is not possible so issue the
-            # upgrade command without the non-disruptive flag unless the
-            # playbook specified issu: yes/required.
-            if issu == 'yes':
-                msg = 'ISSU/ISSD requested but impact data indicates ISSU/ISSD is not possible'
-                module.fail_json(msg=msg, raw_data=impact_data['list_data'])
-            else:
-                issu = 'no'
-
-        commands = build_install_cmd_set(issu, image, kick, 'install')
-        opts = {'ignore_timeout': True}
-        # The system may be busy from the call to check_mode so loop until
-        # it's done.
-        upgrade = check_install_in_progress(module, commands, opts)
-        if upgrade['invalid_command'] and 'force' in commands[1]:
-            # Not all platforms support the 'force' keyword.  Check for this
-            # condition and re-try without the 'force' keyword if needed.
-            commands = build_install_cmd_set(issu, image, kick, 'install', False)
-            upgrade = check_install_in_progress(module, commands, opts)
-        upgrade['upgrade_cmd'] = commands
-
-        # Special case:  If we encounter a server error at this stage
-        # it means the command was sent and the upgrade was started but
-        # we will need to use the impact data instead of the current install
-        # data.
-        if upgrade['server_error']:
-            upgrade['upgrade_succeeded'] = True
-            upgrade['use_impact_data'] = True
-
-        if upgrade['use_impact_data']:
-            if upgrade['upgrade_succeeded']:
-                upgrade = impact_data
-                upgrade['upgrade_succeeded'] = True
-            else:
-                upgrade = impact_data
-                upgrade['upgrade_succeeded'] = False
-
-        if not upgrade['upgrade_succeeded']:
-            upgrade['error'] = True
-    return upgrade
-
-
-def main():
-    argument_spec = dict(
-        system_image_file=dict(required=True),
-        kickstart_image_file=dict(required=False),
-        issu=dict(choices=['required', 'desired', 'no', 'yes'], default='no'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    # Get system_image_file(sif), kickstart_image_file(kif) and
-    # issu settings from module params.
-    sif = module.params['system_image_file']
-    kif = module.params['kickstart_image_file']
-    issu = module.params['issu']
-
-    if re.search(r'(yes|required)', issu):
-        issu = 'yes'
-
-    if kif == 'null' or kif == '':
-        kif = None
-
-    install_result = do_install_all(module, issu, sif, kick=kif)
-    if install_result['error']:
-        cmd = install_result['upgrade_cmd']
-        msg = 'Failed to upgrade device using command: %s' % cmd
-        module.fail_json(msg=msg, raw_data=install_result['list_data'])
-
-    state = install_result['processed']
-    changed = install_result['upgrade_needed']
-    module.exit_json(changed=changed, install_state=state, warnings=warnings)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_interface_ospf.py b/lib/ansible/modules/network/nxos/nxos_interface_ospf.py
deleted file mode 100644
index bb5de390eb..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_interface_ospf.py
+++ /dev/null
@@ -1,512 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_interface_ospf
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages configuration of an OSPF interface instance.
-description:
-  - Manages configuration of an OSPF interface instance.
-author: Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - Default, where supported, restores params default value.
-  - To remove an existing authentication configuration you should use
-    C(message_digest_key_id=default) plus all other options matching their
-    existing values.
-  - Loopback interfaces only support ospf network type 'point-to-point'.
-  - C(state=absent) removes the whole OSPF interface configuration.
-options:
-  interface:
-    description:
-        - Name of this cisco_interface resource. Valid value is a string.
-    required: true
-  ospf:
-    description:
-      - Name of the ospf instance.
-    required: true
-  area:
-    description:
-      - Ospf area associated with this cisco_interface_ospf instance.
-        Valid values are a string, formatted as an IP address
-        (i.e. "0.0.0.0") or as an integer.
-    required: true
-  bfd:
-    description:
-      - Enables bfd at interface level. This overrides the bfd variable set at the ospf router level.
-      - Valid values are 'enable', 'disable' or 'default'.
-      - "Dependency: 'feature bfd'"
-    version_added: "2.9"
-    type: str
-    choices: ['enable', 'disable', 'default']
-  cost:
-    description:
-      - The cost associated with this cisco_interface_ospf instance.
-  hello_interval:
-    description:
-      - Time between sending successive hello packets.
-        Valid values are an integer or the keyword 'default'.
-  dead_interval:
-    description:
-      - Time interval an ospf neighbor waits for a hello
-        packet before tearing down adjacencies. Valid values are an
-        integer or the keyword 'default'.
-  passive_interface:
-    description:
-      - Enable or disable passive-interface state on this interface.
-        true - (enable) Prevent OSPF from establishing an adjacency or
-                       sending routing updates on this interface.
-        false - (disable) Override global 'passive-interface default' for this interface.
-    type: bool
-  network:
-    description:
-      - Specifies interface ospf network type. Valid values are 'point-to-point' or 'broadcast'.
-    choices: ['point-to-point', 'broadcast']
-    version_added: "2.8"
-  message_digest:
-    description:
-      - Enables or disables the usage of message digest authentication.
-    type: bool
-  message_digest_key_id:
-    description:
-      - Md5 authentication key-id associated with the ospf instance.
-        If this is present, message_digest_encryption_type,
-        message_digest_algorithm_type and message_digest_password are
-        mandatory. Valid value is an integer and 'default'.
-  message_digest_algorithm_type:
-    description:
-      - Algorithm used for authentication among neighboring routers
-        within an area. Valid values are 'md5' and 'default'.
-    choices: ['md5', 'default']
-  message_digest_encryption_type:
-    description:
-      - Specifies the scheme used for encrypting message_digest_password.
-        Valid values are '3des' or 'cisco_type_7' encryption or 'default'.
-    choices: ['cisco_type_7','3des', 'default']
-  message_digest_password:
-    description:
-      - Specifies the message_digest password. Valid value is a string.
-  state:
-    description:
-      - Determines whether the config should be present or not
-        on the device.
-    default: present
-    choices: ['present','absent']
-'''
-EXAMPLES = '''
-- nxos_interface_ospf:
-    interface: ethernet1/32
-    ospf: 1
-    area: 1
-    bfd: disable
-    cost: default
-
-- nxos_interface_ospf:
-    interface: loopback0
-    ospf: prod
-    area: 0.0.0.0
-    bfd: enable
-    network: point-to-point
-    state: present
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["interface Ethernet1/32", "ip router ospf 1 area 0.0.0.1", "ip ospf bfd disable"]
-'''
-
-
-import re
-import struct
-import socket
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-
-BOOL_PARAMS = [
-    'passive_interface',
-    'message_digest'
-]
-PARAM_TO_COMMAND_KEYMAP = {
-    'interface': '',
-    'cost': 'ip ospf cost',
-    'ospf': 'ip router ospf',
-    'area': 'ip router ospf',
-    'bfd': 'ip ospf bfd',
-    'hello_interval': 'ip ospf hello-interval',
-    'dead_interval': 'ip ospf dead-interval',
-    'passive_interface': 'ip ospf passive-interface',
-    'message_digest': 'ip ospf authentication message-digest',
-    'message_digest_key_id': 'ip ospf message-digest-key',
-    'message_digest_algorithm_type': 'ip ospf message-digest-key',
-    'message_digest_encryption_type': 'ip ospf message-digest-key',
-    'message_digest_password': 'ip ospf message-digest-key',
-    'network': 'ip ospf network',
-}
-
-
-def get_value(arg, config, module):
-    command = PARAM_TO_COMMAND_KEYMAP[arg]
-    has_command = re.search(r'\s+{0}\s*$'.format(command), config, re.M)
-    has_command_val = re.search(r'(?:{0}\s)(?P<value>.*)$'.format(command), config, re.M)
-
-    if command == 'ip router ospf':
-        value = ''
-        if has_command_val:
-            value_list = has_command_val.group('value').split()
-            if arg == 'ospf':
-                value = value_list[0]
-            elif arg == 'area':
-                value = value_list[2]
-                value = normalize_area(value, module)
-    elif command == 'ip ospf message-digest-key':
-        value = ''
-        if has_command_val:
-            value_list = has_command_val.group('value').split()
-            if arg == 'message_digest_key_id':
-                value = value_list[0]
-            elif arg == 'message_digest_algorithm_type':
-                value = value_list[1]
-            elif arg == 'message_digest_encryption_type':
-                value = value_list[2]
-                if value == '3':
-                    value = '3des'
-                elif value == '7':
-                    value = 'cisco_type_7'
-            elif arg == 'message_digest_password':
-                value = value_list[3]
-    elif arg == 'passive_interface':
-        has_no_command = re.search(r'\s+no\s+{0}\s*$'.format(command), config, re.M)
-        if has_no_command:
-            value = False
-        elif has_command:
-            value = True
-        else:
-            value = None
-    elif arg == 'bfd':
-        m = re.search(r'\s*ip ospf bfd(?P<disable> disable)?', config)
-        if m:
-            value = 'disable' if m.group('disable') else 'enable'
-        else:
-            value = 'default'
-    elif arg in BOOL_PARAMS:
-        value = bool(has_command)
-    else:
-        value = ''
-        if has_command_val:
-            value = has_command_val.group('value')
-    return value
-
-
-def get_existing(module, args):
-    existing = {}
-    netcfg = CustomNetworkConfig(indent=2, contents=get_config(module))
-    if module.params['interface'].startswith('loopback') or module.params['interface'].startswith('port-channel'):
-        parents = ['interface {0}'.format(module.params['interface'])]
-    else:
-        parents = ['interface {0}'.format(module.params['interface'].capitalize())]
-    config = netcfg.get_section(parents)
-    if 'ospf' in config:
-        for arg in args:
-            if arg not in ['interface']:
-                existing[arg] = get_value(arg, config, module)
-        existing['interface'] = module.params['interface']
-    return existing
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key, value in table.items():
-        new_key = key_map.get(key)
-        if new_key:
-            new_dict[new_key] = value
-    return new_dict
-
-
-def get_default_commands(existing, proposed, existing_commands, key, module):
-    commands = list()
-    existing_value = existing_commands.get(key)
-    if key.startswith('ip ospf message-digest-key'):
-        check = False
-        for param in ['message_digest_encryption_type',
-                      'message_digest_algorithm_type',
-                      'message_digest_password']:
-            if existing[param] == proposed[param]:
-                check = True
-        if check:
-            if existing['message_digest_encryption_type'] == '3des':
-                encryption_type = '3'
-            elif existing['message_digest_encryption_type'] == 'cisco_type_7':
-                encryption_type = '7'
-            command = 'no {0} {1} {2} {3} {4}'.format(
-                key,
-                existing['message_digest_key_id'],
-                existing['message_digest_algorithm_type'],
-                encryption_type,
-                existing['message_digest_password'])
-            commands.append(command)
-    elif 'ip ospf bfd' in key:
-        commands.append('no {0}'.format(key))
-    elif 'passive-interface' in key:
-        commands.append('default ip ospf passive-interface')
-    else:
-        commands.append('no {0} {1}'.format(key, existing_value))
-    return commands
-
-
-def get_custom_command(existing_cmd, proposed, key, module):
-    commands = list()
-
-    if key == 'ip router ospf':
-        command = '{0} {1} area {2}'.format(key, proposed['ospf'],
-                                            proposed['area'])
-        if command not in existing_cmd:
-            commands.append(command)
-
-    if key == 'ip ospf network':
-        command = '{0} {1}'.format(key, proposed['network'])
-
-        if command not in existing_cmd:
-            commands.append(command)
-
-    elif key.startswith('ip ospf message-digest-key'):
-        if (proposed['message_digest_key_id'] != 'default' and
-                'options' not in key):
-            if proposed['message_digest_encryption_type'] == '3des':
-                encryption_type = '3'
-            elif proposed['message_digest_encryption_type'] == 'cisco_type_7':
-                encryption_type = '7'
-            command = '{0} {1} {2} {3} {4}'.format(
-                key,
-                proposed['message_digest_key_id'],
-                proposed['message_digest_algorithm_type'],
-                encryption_type,
-                proposed['message_digest_password'])
-            commands.append(command)
-    return commands
-
-
-def state_present(module, existing, proposed, candidate):
-    commands = list()
-    proposed_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, proposed)
-    existing_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, existing)
-
-    for key, value in proposed_commands.items():
-        if existing_commands.get(key):
-            if key == 'ip router ospf':
-                if proposed['area'] == existing['area']:
-                    continue
-            if existing_commands[key] == proposed_commands[key]:
-                continue
-
-        if key == 'ip ospf passive-interface' and module.params.get('interface').upper().startswith('LO'):
-            module.fail_json(msg='loopback interface does not support passive_interface')
-        if key == 'ip ospf network' and value == 'broadcast' and module.params.get('interface').upper().startswith('LO'):
-            module.fail_json(msg='loopback interface does not support ospf network type broadcast')
-
-        if key == 'ip ospf bfd':
-            cmd = key
-            if 'disable' in value:
-                cmd += ' disable'
-            elif 'default' in value and existing.get('bfd') is not None:
-                cmd = 'no ' + cmd
-            commands.append(cmd)
-            continue
-
-        if value is True:
-            commands.append(key)
-        elif value is False:
-            commands.append('no {0}'.format(key))
-        elif value == 'default':
-            if existing_commands.get(key):
-                commands.extend(get_default_commands(existing, proposed,
-                                                     existing_commands, key,
-                                                     module))
-        else:
-            if (key == 'ip router ospf' or
-                    key.startswith('ip ospf message-digest-key')):
-                commands.extend(get_custom_command(commands, proposed,
-                                                   key, module))
-            else:
-                command = '{0} {1}'.format(key, value.lower())
-                commands.append(command)
-
-    if commands:
-        parents = ['interface {0}'.format(module.params['interface'].capitalize())]
-        candidate.add(commands, parents=parents)
-
-
-def state_absent(module, existing, proposed, candidate):
-    commands = []
-    parents = ['interface {0}'.format(module.params['interface'].capitalize())]
-    existing_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, existing)
-
-    for key, value in existing_commands.items():
-        if 'ip ospf bfd' in key:
-            if 'default' not in value:
-                # cli is present when enabled or disabled; this removes either case
-                commands.append('no ip ospf bfd')
-            continue
-        if 'ip ospf passive-interface' in key and value is not None:
-            # cli is present for both enabled or disabled; 'no' will not remove
-            commands.append('default ip ospf passive-interface')
-            continue
-
-        if value:
-            if key.startswith('ip ospf message-digest-key'):
-                if 'options' not in key:
-                    if existing['message_digest_encryption_type'] == '3des':
-                        encryption_type = '3'
-                    elif existing['message_digest_encryption_type'] == 'cisco_type_7':
-                        encryption_type = '7'
-                    command = 'no {0} {1} {2} {3} {4}'.format(
-                        key,
-                        existing['message_digest_key_id'],
-                        existing['message_digest_algorithm_type'],
-                        encryption_type,
-                        existing['message_digest_password'])
-                    commands.append(command)
-            elif key in ['ip ospf authentication message-digest', 'ip ospf network']:
-                if value:
-                    commands.append('no {0}'.format(key))
-            elif key == 'ip router ospf':
-                command = 'no {0} {1} area {2}'.format(key, proposed['ospf'], proposed['area'])
-                if command not in commands:
-                    commands.append(command)
-            else:
-                existing_value = existing_commands.get(key)
-                commands.append('no {0} {1}'.format(key, existing_value))
-
-    candidate.add(commands, parents=parents)
-
-
-def normalize_area(area, module):
-    try:
-        area = int(area)
-        area = socket.inet_ntoa(struct.pack('!L', area))
-    except ValueError:
-        splitted_area = area.split('.')
-        if len(splitted_area) != 4:
-            module.fail_json(msg='Incorrect Area ID format', area=area)
-    return area
-
-
-def main():
-    argument_spec = dict(
-        interface=dict(required=True, type='str'),
-        ospf=dict(required=True, type='str'),
-        area=dict(required=True, type='str'),
-        bfd=dict(choices=['enable', 'disable', 'default'], required=False, type='str'),
-        cost=dict(required=False, type='str'),
-        hello_interval=dict(required=False, type='str'),
-        dead_interval=dict(required=False, type='str'),
-        passive_interface=dict(required=False, type='bool'),
-        network=dict(required=False, type='str', choices=['broadcast', 'point-to-point']),
-        message_digest=dict(required=False, type='bool'),
-        message_digest_key_id=dict(required=False, type='str'),
-        message_digest_algorithm_type=dict(required=False, type='str', choices=['md5', 'default']),
-        message_digest_encryption_type=dict(required=False, type='str', choices=['cisco_type_7', '3des', 'default']),
-        message_digest_password=dict(required=False, type='str', no_log=True),
-        state=dict(choices=['present', 'absent'], default='present', required=False)
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           required_together=[['message_digest_key_id',
-                                               'message_digest_algorithm_type',
-                                               'message_digest_encryption_type',
-                                               'message_digest_password']],
-                           supports_check_mode=True)
-
-    # Normalize interface input data.
-    #
-    # * For port-channel and loopback interfaces expection is all lower case names.
-    # * All other interfaces the expectation is an uppercase leading character
-    #   followed by lower case characters.
-    #
-    if re.match(r'(port-channel|loopback)', module.params['interface'], re.I):
-        module.params['interface'] = module.params['interface'].lower()
-    else:
-        module.params['interface'] = module.params['interface'].capitalize()
-
-    warnings = list()
-    result = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    for param in ['message_digest_encryption_type',
-                  'message_digest_algorithm_type',
-                  'message_digest_password']:
-        if module.params[param] == 'default' and module.params['message_digest_key_id'] != 'default':
-            module.exit_json(msg='Use message_digest_key_id=default to remove an existing authentication configuration')
-
-    state = module.params['state']
-    args = PARAM_TO_COMMAND_KEYMAP.keys()
-
-    existing = get_existing(module, args)
-    proposed_args = dict((k, v) for k, v in module.params.items()
-                         if v is not None and k in args)
-
-    proposed = {}
-    for key, value in proposed_args.items():
-        if key != 'interface':
-            if str(value).lower() == 'true':
-                value = True
-            elif str(value).lower() == 'false':
-                value = False
-            elif str(value).lower() == 'default':
-                value = 'default'
-            elif key == 'bfd':
-                value = str(value).lower()
-            if existing.get(key) or (not existing.get(key) and value):
-                proposed[key] = value
-            elif 'passive_interface' in key and existing.get(key) is None and value is False:
-                proposed[key] = value
-
-    proposed['area'] = normalize_area(proposed['area'], module)
-    if 'hello_interval' in proposed and proposed['hello_interval'] == '10':
-        proposed['hello_interval'] = 'default'
-
-    candidate = CustomNetworkConfig(indent=3)
-    if state == 'present':
-        state_present(module, existing, proposed, candidate)
-    elif state == 'absent' and existing.get('ospf') == proposed['ospf'] and existing.get('area') == proposed['area']:
-        state_absent(module, existing, proposed, candidate)
-
-    if candidate:
-        candidate = candidate.items_text()
-        if not module.check_mode:
-            load_config(module, candidate)
-        result['changed'] = True
-        result['commands'] = candidate
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_interfaces.py b/lib/ansible/modules/network/nxos/nxos_interfaces.py
deleted file mode 100644
index 022d53fd4f..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_interfaces.py
+++ /dev/null
@@ -1,280 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-
-"""
-The module file for nxos_interfaces
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = """
----
-module: nxos_interfaces
-version_added: 2.9
-short_description: 'Manages interface attributes of NX-OS Interfaces'
-description: This module manages the interface attributes of NX-OS interfaces.
-author: Trishna Guha (@trishnaguha)
-notes:
-  - Tested against NXOS 7.3.(0)D1(1) on VIRL
-options:
-  config:
-    description: A dictionary of interface options
-    type: list
-    elements: dict
-    suboptions:
-      name:
-        description:
-          - Full name of interface, e.g. Ethernet1/1, port-channel10.
-        type: str
-        required: true
-      description:
-        description:
-          - Interface description.
-        type: str
-      enabled:
-        description:
-          - Administrative state of the interface.
-            Set the value to C(true) to administratively enable the interface
-            or C(false) to disable it
-        type: bool
-      speed:
-        description:
-          - Interface link speed. Applicable for Ethernet interfaces only.
-        type: str
-      mode:
-        description:
-          - Manage Layer2 or Layer3 state of the interface.
-            Applicable for Ethernet and port channel interfaces only.
-        choices: ['layer2','layer3']
-        type: str
-      mtu:
-        description:
-          - MTU for a specific interface. Must be an even number between 576 and 9216.
-            Applicable for Ethernet interfaces only.
-        type: str
-      duplex:
-        description:
-          - Interface link status. Applicable for Ethernet interfaces only.
-        type: str
-        choices: ['full', 'half', 'auto']
-      ip_forward:
-        description:
-          - Enable or disable IP forward feature on SVIs.
-            Set the value to C(true) to enable  or C(false) to disable.
-        type: bool
-      fabric_forwarding_anycast_gateway:
-        description:
-          - Associate SVI with anycast gateway under VLAN configuration mode.
-            Applicable for SVI interfaces only.
-        type: bool
-
-  state:
-    description:
-      - The state of the configuration after module completion
-    type: str
-    choices:
-      - merged
-      - replaced
-      - overridden
-      - deleted
-    default: merged
-"""
-EXAMPLES = """
-# Using merged
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/1
-#   description testing
-#   mtu 1800
-
-- name: Merge provided configuration with device configuration
-  nxos_interfaces:
-    config:
-      - name: Ethernet1/1
-        description: 'Configured by Ansible'
-        enabled: True
-      - name: Ethernet1/2
-        description: 'Configured by Ansible Network'
-        enabled: False
-    state: merged
-
-# After state:
-# ------------
-#
-# interface Ethernet1/1
-#    description Configured by Ansible
-#    no shutdown
-#    mtu 1800
-# interface Ethernet2
-#    description Configured by Ansible Network
-#    shutdown
-
-
-# Using replaced
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/1
-#    description Interface 1/1
-# interface Ethernet1/2
-
-- name: Replaces device configuration of listed interfaces with provided configuration
-  nxos_interfaces:
-    config:
-      - name: Ethernet1/1
-        description: 'Configured by Ansible'
-        enabled: True
-        mtu: 2000
-      - name: Ethernet1/2
-        description: 'Configured by Ansible Network'
-        enabled: False
-        mode: layer2
-    state: replaced
-
-# After state:
-# ------------
-#
-# interface Ethernet1/1
-#   description Configured by Ansible
-#   no shutdown
-#   mtu 1500
-# interface Ethernet2/2
-#    description Configured by Ansible Network
-#    shutdown
-#    switchport
-
-
-# Using overridden
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/1
-#    description Interface Ethernet1/1
-# interface Ethernet1/2
-# interface mgmt0
-#    description Management interface
-#    ip address dhcp
-
-- name: Override device configuration of all interfaces with provided configuration
-  nxos_interfaces:
-    config:
-      - name: Ethernet1/1
-        enabled: True
-      - name: Ethernet1/2
-        description: 'Configured by Ansible Network'
-        enabled: False
-    state: overridden
-
-# After state:
-# ------------
-#
-# interface Ethernet1/1
-# interface Ethernet1/2
-#    description Configured by Ansible Network
-#    shutdown
-# interface mgmt0
-#    ip address dhcp
-
-
-# Using deleted
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/1
-#    description Interface Ethernet1/1
-# interface Ethernet1/2
-# interface mgmt0
-#    description Management interface
-#    ip address dhcp
-
-- name: Delete or return interface parameters to default settings
-  nxos_interfaces:
-    config:
-      - name: Ethernet1/1
-    state: deleted
-
-# After state:
-# ------------
-#
-# interface Ethernet1/1
-# interface Ethernet1/2
-# interface mgmt0
-#    description Management interface
-#    ip address dhcp
-
-
-"""
-RETURN = """
-before:
-  description: The configuration as structured data prior to module invocation.
-  returned: always
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-after:
-  description: The configuration as structured data after module completion.
-  returned: when changed
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-commands:
-  description: The set of commands pushed to the remote device.
-  returned: always
-  type: list
-  sample: ['interface Ethernet1/1', 'mtu 1800']
-"""
-
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.argspec.interfaces.interfaces import InterfacesArgs
-from ansible.module_utils.network.nxos.config.interfaces.interfaces import Interfaces
-
-
-def main():
-    """
-    Main entry point for module execution
-
-    :returns: the result form module invocation
-    """
-    module = AnsibleModule(argument_spec=InterfacesArgs.argument_spec,
-                           supports_check_mode=True)
-
-    result = Interfaces(module).execute_module()
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_l2_interfaces.py b/lib/ansible/modules/network/nxos/nxos_l2_interfaces.py
deleted file mode 100644
index 78cedba30d..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_l2_interfaces.py
+++ /dev/null
@@ -1,284 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-
-"""
-The module file for nxos_l2_interfaces
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = """
----
-module: nxos_l2_interfaces
-version_added: 2.9
-short_description: Manages Layer-2 Interfaces attributes of NX-OS Interfaces
-description: This module manages Layer-2 interfaces attributes of NX-OS Interfaces.
-author: Trishna Guha (@trishnaguha)
-notes:
-  - Tested against NXOS 7.3.(0)D1(1) on VIRL
-options:
-  config:
-    description: A dictionary of Layer-2 interface options
-    type: list
-    elements: dict
-    suboptions:
-      name:
-        description:
-          - Full name of interface, i.e. Ethernet1/1.
-        type: str
-        required: true
-      access:
-        description:
-          - Switchport mode access command to configure the interface as a
-            Layer-2 access.
-        type: dict
-        suboptions:
-          vlan:
-            description:
-            - Configure given VLAN in access port. It's used as the access
-              VLAN ID.
-            type: int
-      trunk:
-        description:
-          - Switchport mode trunk command to configure the interface as a
-            Layer-2 trunk.
-        type: dict
-        suboptions:
-          native_vlan:
-            description:
-              - Native VLAN to be configured in trunk port. It is used as the
-                trunk native VLAN ID.
-            type: int
-          allowed_vlans:
-            description:
-              - List of allowed VLANs in a given trunk port. These are the only
-                VLANs that will be configured on the trunk.
-            type: str
-      mode:
-        description:
-        - Mode in which interface needs to be configured.
-        - Access mode is not shown in interface facts, so idempotency will not be
-          maintained for switchport mode access and every time the output will come
-          as changed=True.
-        version_added: '2.10'
-        type: str
-        choices: ['access', 'trunk']
-
-  state:
-    description:
-      - The state of the configuration after module completion.
-    type: str
-    choices:
-      - merged
-      - replaced
-      - overridden
-      - deleted
-    default: merged
-"""
-EXAMPLES = """
-# Using merged
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/1
-#   switchport access vlan 20
-# interface Ethernet1/2
-#   switchport trunk native vlan 20
-# interface mgmt0
-#   ip address dhcp
-#   ipv6 address auto-config
-
-- name: Merge provided configuration with device configuration.
-  nxos_l2_interfaces:
-    config:
-      - name: Ethernet1/1
-        trunk:
-          native_vlan: 10
-          allowed_vlans: 2,4,15
-      - name: Ethernet1/2
-        access:
-          vlan: 30
-    state: merged
-
-# After state:
-# ------------
-#
-# interface Ethernet1/1
-#   switchport trunk native vlan 10
-#   switchport trunk allowed vlans 2,4,15
-# interface Ethernet1/2
-#   switchport access vlan 30
-# interface mgmt0
-#   ip address dhcp
-#   ipv6 address auto-config
-
-
-# Using replaced
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/1
-#   switchport access vlan 20
-# interface Ethernet1/2
-#   switchport trunk native vlan 20
-# interface mgmt0
-#   ip address dhcp
-#   ipv6 address auto-config
-
-- name: Replace device configuration of specified L2 interfaces with provided configuration.
-  nxos_l2_interfaces:
-    config:
-      - name: Ethernet1/1
-        trunk:
-          native_vlan: 20
-          trunk_vlans: 5-10, 15
-    state: replaced
-
-# After state:
-# ------------
-#
-# interface Ethernet1/1
-#   switchport trunk native vlan 20
-#   switchport trunk allowed vlan 5-10,15
-# interface Ethernet1/2
-#   switchport trunk native vlan 20
-#   switchport mode trunk
-# interface mgmt0
-#   ip address dhcp
-#   ipv6 address auto-config
-
-
-# Using overridden
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/1
-#   switchport access vlan 20
-# interface Ethernet1/2
-#   switchport trunk native vlan 20
-# interface mgmt0
-#   ip address dhcp
-#   ipv6 address auto-config
-
-- name: Override device configuration of all L2 interfaces on device with provided configuration.
-  nxos_l2_interfaces:
-    config:
-      - name: Ethernet1/2
-        access:
-          vlan: 30
-    state: overridden
-
-# After state:
-# ------------
-#
-# interface Ethernet1/1
-# interface Ethernet1/2
-#   switchport access vlan 30
-# interface mgmt0
-#   ip address dhcp
-#   ipv6 address auto-config
-
-
-# Using deleted
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/1
-#   switchport access vlan 20
-# interface Ethernet1/2
-#   switchport trunk native vlan 20
-# interface mgmt0
-#   ip address dhcp
-#   ipv6 address auto-config
-
-- name: Delete L2 attributes of given interfaces (Note This won't delete the interface itself).
-  nxos_l2_interfaces:
-    config:
-      - name: Ethernet1/1
-      - name: Ethernet1/2
-    state: deleted
-
-# After state:
-# ------------
-#
-# interface Ethernet1/1
-# interface Ethernet1/2
-# interface mgmt0
-#   ip address dhcp
-#   ipv6 address auto-config
-
-
-"""
-RETURN = """
-before:
-  description: The configuration as structured data prior to module invocation.
-  returned: always
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-after:
-  description: The configuration as structured data after module completion.
-  returned: when changed
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-commands:
-  description: The set of commands pushed to the remote device.
-  returned: always
-  type: list
-  sample: ['command 1', 'command 2', 'command 3']
-"""
-
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.argspec.l2_interfaces.l2_interfaces import L2_interfacesArgs
-from ansible.module_utils.network.nxos.config.l2_interfaces.l2_interfaces import L2_interfaces
-
-
-def main():
-    """
-    Main entry point for module execution
-
-    :returns: the result form module invocation
-    """
-    module = AnsibleModule(argument_spec=L2_interfacesArgs.argument_spec,
-                           supports_check_mode=True)
-
-    result = L2_interfaces(module).execute_module()
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_l3_interfaces.py b/lib/ansible/modules/network/nxos/nxos_l3_interfaces.py
deleted file mode 100644
index 0c4ddc35cc..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_l3_interfaces.py
+++ /dev/null
@@ -1,272 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-
-"""
-The module file for nxos_l3_interfaces
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = """
----
-module: nxos_l3_interfaces
-version_added: 2.9
-short_description: Manages Layer-3 Interfaces attributes of NX-OS Interfaces
-description: This module manages Layer-3 interfaces attributes of NX-OS Interfaces.
-author: Trishna Guha (@trishnaguha)
-notes:
-  - Tested against NXOS 7.3.(0)D1(1) on VIRL
-options:
-  config:
-    description: A dictionary of Layer-3 interface options
-    type: list
-    elements: dict
-    suboptions:
-      name:
-        description:
-          - Full name of L3 interface, i.e. Ethernet1/1.
-        type: str
-        required: true
-      dot1q:
-        description:
-          - Configures IEEE 802.1Q VLAN encapsulation on a subinterface.
-        type: int
-        version_added: 2.10
-      ipv4:
-        description:
-          - IPv4 address and attributes of the L3 interface.
-        type: list
-        elements: dict
-        suboptions:
-          address:
-            description:
-              - IPV4 address of the L3 interface.
-            type: str
-          tag:
-            description:
-              - URIB route tag value for local/direct routes.
-            type: int
-          secondary:
-            description:
-              - A boolean attribute to manage addition of secondary IP address.
-            type: bool
-            default: False
-      ipv6:
-        description:
-          - IPv6 address and attributes of the L3 interface.
-        type: list
-        elements: dict
-        suboptions:
-          address:
-            description:
-              - IPV6 address of the L3 interface.
-            type: str
-          tag:
-            description:
-              - URIB route tag value for local/direct routes.
-            type: int
-      redirects:
-        description:
-          - Enables/disables ip redirects
-        type: bool
-        version_added: 2.10
-      unreachables:
-        description:
-          - Enables/disables ip redirects
-        type: bool
-        version_added: 2.10
-
-  state:
-    description:
-      - The state of the configuration after module completion.
-    type: str
-    choices:
-      - merged
-      - replaced
-      - overridden
-      - deleted
-    default: merged
-"""
-EXAMPLES = """
-# Using merged
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/6
-
-- name: Merge provided configuration with device configuration.
-  nxos_l3_interfaces:
-    config:
-      - name: Ethernet1/6
-        ipv4:
-          - address: 192.168.1.1/24
-            tag: 5
-          - address: 10.1.1.1/24
-            secondary: True
-            tag: 10
-        ipv6:
-          - address: fd5d:12c9:2201:2::1/64
-            tag: 6
-      - name: Ethernet1/7.42
-        dot1q: 42
-        redirects: False
-        unreachables: False
-    state: merged
-
-# After state:
-# ------------
-#
-# interface Ethernet1/6
-#   ip address 192.168.22.1/24 tag 5
-#   ip address 10.1.1.1/24 secondary tag 10
-# interface Ethernet1/6
-#   ipv6 address fd5d:12c9:2201:2::1/64 tag 6
-# interface Ethernet1/7.42
-#   encapsulation dot1q 42
-#   no ip redirects
-#   no ip unreachables
-
-
-# Using replaced
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/6
-#   ip address 192.168.22.1/24
-#   ipv6 address "fd5d:12c9:2201:1::1/64"
-
-- name: Replace device configuration of specified L3 interfaces with provided configuration.
-  nxos_l3_interfaces:
-    config:
-      - name: Ethernet1/6
-        ipv4: 192.168.22.3/24
-    state: replaced
-
-# After state:
-# ------------
-#
-# interface Ethernet1/6
-#   ip address 192.168.22.3/24
-
-
-# Using overridden
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/2
-#   ip address 192.168.22.1/24
-# interface Ethernet1/6
-#   ipv6 address "fd5d:12c9:2201:1::1/64"
-
-- name: Override device configuration of all L3 interfaces on device with provided configuration.
-  nxos_l3_interfaces:
-    config:
-      - name: Ethernet1/2
-        ipv4: 192.168.22.3/4
-    state: overridden
-
-# After state:
-# ------------
-#
-# interface Ethernet1/2
-#   ipv4 address 192.168.22.3/24
-# interface Ethernet1/6
-
-
-# Using deleted
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/6
-#   ip address 192.168.22.1/24
-# interface Ethernet1/2
-#   ipv6 address "fd5d:12c9:2201:1::1/64"
-
-- name: Delete L3 attributes of given interfaces (This won't delete the interface itself).
-  nxos_l3_interfaces:
-    config:
-      - name: Ethernet1/6
-      - name: Ethernet1/2
-    state: deleted
-
-# After state:
-# ------------
-#
-# interface Ethernet1/6
-# interface Ethernet1/2
-
-
-"""
-RETURN = """
-before:
-  description: The configuration as structured data prior to module invocation.
-  returned: always
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-after:
-  description: The configuration as structured data after module completion.
-  returned: when changed
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-commands:
-  description: The set of commands pushed to the remote device.
-  returned: always
-  type: list
-  sample: ['interface Ethernet1/2', 'ip address 192.168.0.1/2']
-"""
-
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.argspec.l3_interfaces.l3_interfaces import L3_interfacesArgs
-from ansible.module_utils.network.nxos.config.l3_interfaces.l3_interfaces import L3_interfaces
-
-
-def main():
-    """
-    Main entry point for module execution
-
-    :returns: the result form module invocation
-    """
-    module = AnsibleModule(argument_spec=L3_interfacesArgs.argument_spec,
-                           supports_check_mode=True)
-
-    result = L3_interfaces(module).execute_module()
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_lacp.py b/lib/ansible/modules/network/nxos/nxos_lacp.py
deleted file mode 100644
index da2a3bf446..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_lacp.py
+++ /dev/null
@@ -1,188 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-
-"""
-The module file for nxos_lacp
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'
-                    }
-
-DOCUMENTATION = """
----
-module: nxos_lacp
-version_added: 2.9
-short_description: Manage Global Link Aggregation Control Protocol (LACP) on Cisco NX-OS devices.
-description: This module manages Global Link Aggregation Control Protocol (LACP) on NX-OS devices.
-author: Trishna Guha (@trishnaguha)
-notes:
-  - Tested against NXOS 7.3.(0)D1(1) on VIRL.
-  - Feature lacp should be enabled for this module.
-options:
-  config:
-    description: LACP global options.
-    type: dict
-    suboptions:
-      system:
-        description:
-          - LACP system options
-        type: dict
-        suboptions:
-          priority:
-            description:
-              - The system priority to use in LACP negotiations.
-            type: int
-          mac:
-            description:
-              - MAC address to be used for the LACP Protocol exchanges
-            type: dict
-            suboptions:
-              address:
-                description:
-                  - MAC-address (FORMAT :xxxx.xxxx.xxxx).
-                type: str
-              role:
-                description:
-                  - The role for the Switch.
-                type: str
-                choices: ['primary', 'secondary']
-  state:
-    description:
-      - The state of the configuration after module completion.
-    type: str
-    choices:
-      - merged
-      - replaced
-      - deleted
-    default: merged
-"""
-EXAMPLES = """
-# Using merged
-
-# Before state:
-# -------------
-#
-
-- name: Merge provided configuration with device configuration.
-  nxos_lacp:
-    config:
-      system:
-        priority: 10
-        mac:
-          address: 00c1.4c00.bd15
-    state: merged
-
-# After state:
-# ------------
-#
-# lacp system-priority 10
-# lacp system-mac 00c1.4c00.bd15
-
-
-# Using replaced
-
-# Before state:
-# -------------
-#
-# lacp system-priority 10
-
-- name: Replace device global lacp configuration with the given configuration.
-  nxos_lacp:
-    config:
-      system:
-        mac:
-          address: 00c1.4c00.bd15
-    state: replaced
-
-# After state:
-# ------------
-#
-# lacp system-mac 00c1.4c00.bd15
-
-
-# Using deleted
-
-# Before state:
-# -------------
-#
-# lacp system-priority 10
-
-- name: Delete global LACP configurations.
-  nxos_lacp:
-    state: deleted
-
-# After state:
-# ------------
-#
-
-
-"""
-RETURN = """
-before:
-  description: The configuration as structured data prior to module invocation.
-  returned: always
-  type: dict
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-after:
-  description: The configuration as structured data after module completion.
-  returned: when changed
-  type: dict
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-commands:
-  description: The set of commands pushed to the remote device.
-  returned: always
-  type: list
-  sample: ['lacp system-priority 15', 'lacp system-mac 00c1.4c00.bd15 role primary']
-"""
-
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.argspec.lacp.lacp import LacpArgs
-from ansible.module_utils.network.nxos.config.lacp.lacp import Lacp
-
-
-def main():
-    """
-    Main entry point for module execution
-
-    :returns: the result form module invocation
-    """
-    module = AnsibleModule(argument_spec=LacpArgs.argument_spec,
-                           supports_check_mode=True)
-
-    result = Lacp(module).execute_module()
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_lacp_interfaces.py b/lib/ansible/modules/network/nxos/nxos_lacp_interfaces.py
deleted file mode 100644
index 0ac13b3d9f..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_lacp_interfaces.py
+++ /dev/null
@@ -1,258 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-
-"""
-The module file for nxos_lacp_interfaces
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = """
----
-module: nxos_lacp_interfaces
-version_added: 2.9
-short_description: Manage Link Aggregation Control Protocol (LACP) attributes of interfaces on Cisco NX-OS devices.
-description: This module manages Link Aggregation Control Protocol (LACP) attributes of NX-OS Interfaces.
-author: Trishna Guha (@trishnaguha)
-notes:
-  - Tested against NXOS 7.3.(0)D1(1) on VIRL
-options:
-  config:
-    description: A dictionary of LACP interfaces options.
-    type: list
-    elements: dict
-    suboptions:
-      name:
-        description:
-          - Name of the interface.
-        required: true
-        type: str
-      port_priority:
-        description:
-          - LACP port priority for the interface. Range 1-65535.
-            Applicable only for Ethernet.
-        type: int
-      rate:
-        description:
-          - Rate at which PDUs are sent by LACP. Applicable only for Ethernet.
-            At fast rate LACP is transmitted once every 1 second.
-            At normal rate LACP is transmitted every 30 seconds after the link is bundled.
-        type: str
-        choices: ['fast', 'normal']
-      links:
-        description:
-          - This dict contains configurable options related to max and min port-channel links.
-            Applicable only for Port-channel.
-        type: dict
-        suboptions:
-          max:
-            description:
-              - Port-channel max bundle.
-            type: int
-          min:
-            description:
-              - Port-channel min links.
-            type: int
-      mode:
-        description:
-          - LACP mode. Applicable only for Port-channel.
-        type: str
-        choices: ['delay']
-      suspend_individual:
-        description:
-          - port-channel lacp state. Disabling this will cause lacp to put the
-            port to individual state and not suspend the port in case it does not get
-            LACP BPDU from the peer ports in the port-channel.
-        type: bool
-      convergence:
-        description:
-          - This dict contains configurable options related to convergence.
-            Applicable only for Port-channel.
-        type: dict
-        suboptions:
-          graceful:
-            description:
-              - port-channel lacp graceful convergence. Disable this only with lacp ports
-                connected to Non-Nexus peer. Disabling this with Nexus peer can lead
-                to port suspension.
-            type: bool
-          vpc:
-            description:
-              - Enable lacp convergence for vPC port channels.
-            type: bool
-  state:
-    description:
-      - The state of the configuration after module completion.
-    type: str
-    choices:
-      - merged
-      - replaced
-      - overridden
-      - deleted
-    default: merged
-"""
-EXAMPLES = """
-# Using merged
-
-# Before state:
-# -------------
-#
-
-- name: Merge provided configuration with device configuration.
-  nxos_lacp_interfaces:
-    config:
-      - name: Ethernet1/3
-        port_priority: 5
-        rate: fast
-    state: merged
-
-# After state:
-# ------------
-#
-# interface Ethernet1/3
-# lacp port-priority 5
-# lacp rate fast
-
-
-# Using replaced
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/3
-#   lacp port-priority 5
-# interface port-channel11
-#   lacp mode delay
-
-- name: Replace device lacp interfaces configuration with the given configuration.
-  nxos_lacp_interfaces:
-    config:
-      - name: port-channel11
-        links:
-          min: 4
-    state: replaced
-
-# After state:
-# ------------
-#
-# interface Ethernet1/3
-#   lacp port-priority 5
-# interface port-channel11
-#   lacp min-links 4
-
-
-# Using overridden
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/3
-#   lacp port-priority 5
-# interface port-channel11
-#   lacp mode delay
-
-- name: Override device configuration of all LACP interfaces attributes of given interfaces on device with provided configuration.
-  nxos_lacp_interfaces:
-    config:
-      - name: port-channel11
-        links:
-          min: 4
-    state: overridden
-
-# After state:
-# ------------
-#
-# interface port-channel11
-# lacp min-links 4
-
-
-# Using deleted
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/3
-#   lacp port-priority 5
-# interface port-channel11
-#   lacp mode delay
-
-- name: Delete LACP interfaces configurations.
-  nxos_lacp_interfaces:
-    state: deleted
-
-# After state:
-# ------------
-#
-
-
-"""
-RETURN = """
-before:
-  description: The configuration as structured data prior to module invocation.
-  returned: always
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-after:
-  description: The configuration as structured data after module completion.
-  returned: when changed
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-commands:
-  description: The set of commands pushed to the remote device.
-  returned: always
-  type: list
-  sample: ['interface port-channel10', 'lacp min-links 5', 'lacp mode delay']
-"""
-
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.argspec.lacp_interfaces.lacp_interfaces import Lacp_interfacesArgs
-from ansible.module_utils.network.nxos.config.lacp_interfaces.lacp_interfaces import Lacp_interfaces
-
-
-def main():
-    """
-    Main entry point for module execution
-
-    :returns: the result form module invocation
-    """
-    module = AnsibleModule(argument_spec=Lacp_interfacesArgs.argument_spec,
-                           supports_check_mode=True)
-
-    result = Lacp_interfaces(module).execute_module()
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_lag_interfaces.py b/lib/ansible/modules/network/nxos/nxos_lag_interfaces.py
deleted file mode 100644
index 7b07c016b7..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_lag_interfaces.py
+++ /dev/null
@@ -1,231 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-
-"""
-The module file for nxos_lag_interfaces
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = """
----
-module: nxos_lag_interfaces
-version_added: 2.9
-short_description: Manages link aggregation groups of NX-OS Interfaces
-description: This module manages attributes of link aggregation groups of NX-OS Interfaces.
-author: Trishna Guha (@trishnaguha)
-options:
-  config:
-    description: A list of link aggregation group configurations.
-    type: list
-    suboptions:
-      name:
-        description:
-          - Name of the link aggregation group (LAG).
-        type: str
-        required: true
-      members:
-        description:
-          - The list of interfaces that are part of the group.
-        type: list
-        suboptions:
-          member:
-            description:
-              - The interface name.
-            type: str
-          mode:
-            description:
-              - Link aggregation group (LAG).
-            type: str
-            choices:
-              - active
-              - on
-              - passive
-          force:
-            description:
-              - When true it forces link aggregation group members to match what
-                is declared in the members param. This can be used to remove members.
-            type: bool
-  state:
-    description:
-      - The state of the configuration after module completion.
-    type: str
-    choices:
-      - merged
-      - replaced
-      - overridden
-      - deleted
-    default: merged
-notes:
-  - Tested against NXOS 7.3.(0)D1(1) on VIRL.
-  - This module works with connection C(network_cli).
-"""
-EXAMPLES = """
-# Using merged
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/4
-
-- name: Merge provided configuration with device configuration.
-  nxos_lag_interfaces:
-    config:
-      - name: port-channel99
-        members:
-          - member: Ethernet1/4
-    state: merged
-
-# After state:
-# ------------
-#
-# interface Ethernet1/4
-#   channel-group 99
-
-
-# Using replaced
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/4
-#   channel-group 99 mode active
-
-- name: Replace device configuration of specified LAG attributes of given interfaces with provided configuration.
-  nxos_lag_interfaces:
-    config:
-      - name: port-channel10
-        members:
-          - member: Ethernet1/4
-    state: replaced
-
-# After state:
-# ------------
-#
-# interface Ethernet1/4
-#   channel-group 10
-
-
-# Using overridden
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/4
-#   channel-group 10
-# interface Ethernet1/2
-#   channel-group 99 mode passive
-
-- name: Override device configuration of all LAG attributes of given interfaces on device with provided configuration.
-  nxos_lag_interfaces:
-    config:
-      - name: port-channel20
-        members:
-          - member: Ethernet1/6
-            force: True
-    state: overridden
-
-# After state:
-# ------------
-# interface Ethernet1/2
-# interface Ethernet1/4
-# interface Ethernet1/6
-#   channel-group 20 force
-
-
-# Using deleted
-
-# Before state:
-# -------------
-#
-# interface Ethernet1/4
-#   channel-group 99 mode active
-
-- name: Delete LAG attributes of given interface (This won't delete the port-channel itself).
-  nxos_lag_interfaces:
-    config:
-      - port-channel: port-channel99
-    state: deleted
-
-- name: Delete LAG attributes of all the interfaces
-  nxos_lag_interfaces:
-    state: deleted
-
-# After state:
-# ------------
-#
-# interface Ethernet1/4
-#   no channel-group 99
-
-
-"""
-RETURN = """
-before:
-  description: The configuration as structured data prior to module invocation.
-  returned: always
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-after:
-  description: The configuration as structured data after module completion.
-  returned: when changed
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-commands:
-  description: The set of commands pushed to the remote device.
-  returned: always
-  type: list
-  sample: ['command 1', 'command 2', 'command 3']
-"""
-
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.argspec.lag_interfaces.lag_interfaces import Lag_interfacesArgs
-from ansible.module_utils.network.nxos.config.lag_interfaces.lag_interfaces import Lag_interfaces
-
-
-def main():
-    """
-    Main entry point for module execution
-
-    :returns: the result form module invocation
-    """
-    module = AnsibleModule(argument_spec=Lag_interfacesArgs.argument_spec,
-                           supports_check_mode=True)
-
-    result = Lag_interfaces(module).execute_module()
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_lldp.py b/lib/ansible/modules/network/nxos/nxos_lldp.py
deleted file mode 100644
index a81c956c5e..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_lldp.py
+++ /dev/null
@@ -1,114 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-
-# (c) 2017, Ansible by Red Hat, inc
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = """
----
-module: nxos_lldp
-version_added: "2.5"
-author: "Ganesh Nalawade (@ganeshrn)"
-short_description: Manage LLDP configuration on Cisco NXOS network devices.
-description:
-  - This module provides declarative management of LLDP service
-    on Cisco NXOS network devices.
-notes:
-  - Tested against NXOSv 7.0(3)I5(1).
-options:
-  state:
-    description:
-      - State of the LLDP configuration. If value is I(present) lldp will be enabled
-        else if it is I(absent) it will be disabled.
-    default: present
-    choices: ['present', 'absent']
-extends_documentation_fragment: nxos
-"""
-
-EXAMPLES = """
-- name: Enable LLDP service
-  nxos_lldp:
-    state: present
-
-- name: Disable LLDP service
-  nxos_lldp:
-    state: absent
-"""
-
-RETURN = """
-commands:
-  description: The list of configuration mode commands to send to the device
-  returned: always, except for the platforms that use Netconf transport to manage the device.
-  type: list
-  sample:
-    - feature lldp
-"""
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-
-
-def has_lldp(module):
-    output = get_config(module, ['| section lldp'])
-    is_lldp_enable = False
-    if output and "feature lldp" in output:
-        is_lldp_enable = True
-
-    return is_lldp_enable
-
-
-def main():
-    """ main entry point for module execution
-    """
-    argument_spec = dict(
-        state=dict(default='present',
-                   choices=['present', 'absent',
-                            'enabled', 'disabled'])
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    result = {'changed': False}
-
-    if warnings:
-        result['warnings'] = warnings
-
-    HAS_LLDP = has_lldp(module)
-
-    commands = []
-
-    if module.params['state'] == 'absent' and HAS_LLDP:
-        commands.append('no feature lldp')
-    elif module.params['state'] == 'present' and not HAS_LLDP:
-        commands.append('feature lldp')
-
-    result['commands'] = commands
-
-    if commands:
-        # On N35 A8 images, some features return a yes/no prompt
-        # on enablement or disablement. Bypass using terminal dont-ask
-        commands.insert(0, 'terminal dont-ask')
-        if not module.check_mode:
-            load_config(module, commands)
-
-        result['changed'] = True
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_lldp_global.py b/lib/ansible/modules/network/nxos/nxos_lldp_global.py
deleted file mode 100644
index e5c0ff4bfe..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_lldp_global.py
+++ /dev/null
@@ -1,250 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-"""
-The module file for nxos_lldp_global
-"""
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-ANSIBLE_METADATA = {
-    'metadata_version': '1.1',
-    'status': ['preview'],
-    'supported_by': 'network'
-}
-
-DOCUMENTATION = """
----
-module: nxos_lldp_global
-version_added: 2.9
-short_description: Configure and manage Link Layer Discovery Protocol(LLDP) attributes on NX-OS platforms.
-description: This module configures and manages the Link Layer Discovery Protocol(LLDP) attributes on NX-OS platforms.
-author: Adharsh Srivats Rangarajan (@adharshsrivatsr)
-notes:
-  - Tested against NxOS 7.3.(0)D1(1) on VIRL
-  - The LLDP feature needs to be enabled before using this module
-options:
-  config:
-    description:
-      - A list of link layer discovery configurations
-    type: dict
-    suboptions:
-      holdtime:
-        description:
-          - Amount of time the receiving device should hold the information (in seconds)
-        type: int
-      port_id:
-        description:
-          - This attribute defines if the interface names should be advertised in the long(0) or short(1) form.
-        type: int
-        choices: [0, 1]
-      reinit:
-        description:
-          - Amount of time to delay the initialization of LLDP on any interface (in seconds)
-        type: int
-      timer:
-        description:
-          - Frequency at which LLDP updates need to be transmitted (in seconds)
-        type: int
-      tlv_select:
-        description:
-          - This attribute can be used to specify the TLVs that need to be sent and received in the LLDP packets. By default, all TLVs are advertised
-        type: dict
-        suboptions:
-          dcbxp:
-            description:
-              - Used to specify the Data Center Bridging Exchange Protocol TLV
-            type: bool
-          management_address:
-            description:
-              - Used to specify the management address in TLV messages
-            type: dict
-            suboptions:
-              v4:
-                description: Management address with TLV v4
-                type: bool
-              v6:
-                description: Management address with TLV v6
-                type: bool
-          port:
-            description:
-              - Used to manage port based attributes in TLV messages
-            type: dict
-            suboptions:
-              description:
-                description:
-                  - Used to specify the port description TLV
-                type: bool
-              vlan:
-                description:
-                  - Used to specify the port VLAN ID TLV
-                type: bool
-          power_management:
-            description:
-              - Used to specify IEEE 802.3 DTE Power via MDI TLV
-            type: bool
-          system:
-            description:
-              - Used to manage system based attributes in TLV messages
-            type: dict
-            suboptions:
-              capabilities:
-                description:
-                  - Used to specify the system capabilities TLV
-                type: bool
-              description:
-                description:
-                  - Used to specify the system description TLV
-                type: bool
-              name:
-                description:
-                  - Used to specify the system name TLV
-                type: bool
-  state:
-    description:
-      - The state of the configuration after module completion
-    type: str
-    choices:
-      - merged
-      - replaced
-      - deleted
-    default: merged
-"""
-EXAMPLES = """
-# Using merged
-# Before state:
-# -------------
-#
-# user(config)# show running-config | include lldp
-# feature lldp
-
-- name: Merge provided configuration with device configuration
-  nxos_lldp_global:
-    config:
-      timer: 35
-      holdtime: 100
-    state: merged
-
-# After state:
-# ------------
-#
-# user(config)# show running-config | include lldp
-# feature lldp
-# lldp timer 35
-# lldp holdtime 100
-
-
-# Using replaced
-# Before state:
-# -------------
-#
-# user(config)# show running-config | include lldp
-# feature lldp
-# lldp holdtime 100
-# lldp reinit 5
-# lldp timer 35
-
-- name: Replace device configuration of specific LLDP attributes with provided configuration
-  nxos_lldp_global:
-    config:
-      timer: 40
-      tlv_select:
-        system:
-          description: true
-          name: false
-        management_address:
-          v4: true
-    state: replaced
-
-# After state:
-# ------------
-#
-# user(config)# show running-config | include lldp
-# feature lldp
-# lldp timer 40
-# no lldp tlv-select system-name
-
-
-# Using deleted
-# Before state:
-# -------------
-#
-# user(config)# show running-config | include lldp
-# feature lldp
-# lldp holdtime 5
-# lldp reinit 3
-
-- name: Delete LLDP configuration (this will by default remove all lldp configuration)
-  nxos_lldp_global:
-    state: deleted
-
-# After state:
-# ------------
-#
-# user(config)# show running-config | include lldp
-# feature lldp
-
-
-"""
-RETURN = """
-before:
-  description: The configuration as structured data prior to module invocation.
-  returned: always
-  type: dict
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-after:
-  description: The configuration as structured data after module completion.
-  returned: when changed
-  type: dict
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-commands:
-  description: The set of commands pushed to the remote device.
-  returned: always
-  type: list
-  sample: ['lldp holdtime 125', 'lldp reinit 4', 'no lldp tlv-select system-name']
-"""
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.argspec.lldp_global.lldp_global import Lldp_globalArgs
-from ansible.module_utils.network.nxos.config.lldp_global.lldp_global import Lldp_global
-
-
-def main():
-    """
-    Main entry point for module execution
-
-    :returns: the result form module invocation
-    """
-    module = AnsibleModule(argument_spec=Lldp_globalArgs.argument_spec,
-                           supports_check_mode=True)
-
-    result = Lldp_global(module).execute_module()
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_lldp_interfaces.py b/lib/ansible/modules/network/nxos/nxos_lldp_interfaces.py
deleted file mode 100644
index 5c31015d57..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_lldp_interfaces.py
+++ /dev/null
@@ -1,250 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-"""
-The module file for nxos_lldp_interfaces
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-ANSIBLE_METADATA = {
-    'metadata_version': '1.1',
-    'status': ['preview'],
-    'supported_by': 'network'
-}
-
-DOCUMENTATION = """
----
-module: nxos_lldp_interfaces
-version_added: "2.10"
-short_description: Manages interfaces' configuration for Link Layer Discovery Protocol (LLDP) on NX-OS platforms.
-description: This module manages interfaces' configuration for Link Layer Discovery Protocol (LLDP) on NX-OS platforms.
-author: Adharsh Srivats Rangarajan (@adharshsrivatsr)
-notes:
-  - Tested against NXOS 7.3.(0)D1(1) on VIRL
-  - The LLDP feature needs to be enabled before using this module
-options:
-  running_config:
-    description:
-      - Used to parse given commands into structured format, only in parsed state
-    type: str
-  config:
-    description:
-      - A list of link layer discovery configurations for interfaces.
-    type: list
-    elements: dict
-    suboptions:
-      name:
-        description:
-          - Name of the interface
-        required: true
-        type: str
-      receive:
-        description:
-          - Used to enable or disable the reception of LLDP packets on that interface. By default, this is enabled after LLDP is enabled globally.
-        type: bool
-      transmit:
-        description:
-          - Used to enable or disable the transmission of LLDP packets on that interface. By default, this is enabled after LLDP is enabled globally.
-        type: bool
-      tlv_set:
-        description:
-          - Used to configure TLV parameters on the interface
-        type: dict
-        suboptions:
-          management_address:
-            description:
-              - Used to mention the IPv4 or IPv6 management address for the interface
-            type: str
-          vlan:
-            description:
-              - Used to mention the VLAN for the interface
-            type: int
-  state:
-    description:
-      - The state the configuration should be left in
-    type: str
-    choices:
-      - merged
-      - replaced
-      - overridden
-      - deleted
-      - gathered
-      - rendered
-      - parsed
-    default: merged
-"""
-EXAMPLES = """
-# Using merged
-
-# Before state:
-# -------------
-#
-
-- name : Merge provided configuration with device configuration
-  nxos_lldp_interfaces:
-    config:
-        - name : Ethernet1/4
-          receive: false
-          transmit: true
-          tlv_set:
-            management_address: 192.168.122.64
-          vlan: 12
-    state: merged
-
-# After state:
-# -------------
-#
-# interface Ethernet1/4
-#   no lldp receive
-#   lldp tlv-set management-address 192.168.122.64
-#   lldp tlv-set vlan 12
-
-
-# Using replaced
-
-# Before state:
-# ------------
-#
-# interface Ethernet1/4
-#   no lldp receive
-#   lldp tlv-set management-address 192.168.122.64
-# interface Ethernet1/5
-#   no lldp transmit
-#   lldp tlv-set vlan 10
-
-- name: Replace LLDP configuration on interfaces with given configuration
-  nxos_lldp_interfaces:
-    config:
-        - name: Ethernet1/4
-          transmit: no
-          tlv_set:
-            vlan: 2
-    state: replaced
-
-
-# After state:
-# -----------
-#
-# interface Ethernet1/4
-#   no lldp transmit
-#   lldp tlv_set vlan 2
-# interface Ethernet1/5
-#   no lldp transmit
-#   lldp tlv-set vlan 10
-
-
-# Using overridden
-
-# Before state:
-# ------------
-#
-# interface Ethernet1/4
-#   no lldp receive
-#   lldp tlv-set management-address 192.168.122.64
-# interface Ethernet1/5
-#   no lldp transmit
-#   lldp tlv-set vlan 10
-
-- name: Override LLDP configuration on all interfaces with given configuration
-  nxos_lldp_interfaces:
-    config:
-        - name: Ethernet1/7
-          receive: no
-          tlv_set:
-            vlan: 12
-    state: overridden
-
-
-# After state:
-# -----------
-#
-# interface Ethernet1/7
-#   no lldp receive
-#   lldp tlv_set vlan 12
-
-
-# Using deleted
-
-# Before state:
-# ------------
-#
-# interface Ethernet1/4
-#   lldp tlv-set management vlan 24
-#   no lldp transmit
-# interface mgmt0
-#   no lldp receive
-
-- name: Delete LLDP interfaces configuration
-  nxos_lldp_interfaces:
-    state: deleted
-
-# After state:
-# ------------
-#
-
-
-"""
-RETURN = """
-before:
-  description: The configuration prior to the model invocation.
-  returned: always
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-after:
-  description: The resulting configuration model invocation.
-  returned: when changed
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-commands:
-  description: The set of commands pushed to the remote device.
-  returned: always
-  type: list
-  sample: ['interface Ethernet1/2', 'lldp receive', 'lldp tlv-set vlan 12']
-"""
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.argspec.lldp_interfaces.lldp_interfaces import Lldp_interfacesArgs
-from ansible.module_utils.network.nxos.config.lldp_interfaces.lldp_interfaces import Lldp_interfaces
-
-
-def main():
-    """
-    Main entry point for module execution
-
-    :returns: the result form module invocation
-    """
-    module = AnsibleModule(argument_spec=Lldp_interfacesArgs.argument_spec,
-                           supports_check_mode=True)
-
-    result = Lldp_interfaces(module).execute_module()
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_logging.py b/lib/ansible/modules/network/nxos/nxos_logging.py
deleted file mode 100644
index 41fd13b128..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_logging.py
+++ /dev/null
@@ -1,795 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-
-# Copyright: (c) 2017, Ansible by Red Hat, inc
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = """
----
-module: nxos_logging
-version_added: "2.4"
-author: "Trishna Guha (@trishnaguha)"
-short_description: Manage logging on network devices
-description:
-  - This module provides declarative management of logging
-    on Cisco NX-OS devices.
-options:
-  dest:
-    description:
-      - Destination of the logs.
-    choices: ['console', 'logfile', 'module', 'monitor', 'server']
-  remote_server:
-    description:
-      - Hostname or IP Address for remote logging (when dest is 'server').
-    version_added: '2.7'
-  use_vrf:
-    description:
-      - VRF to be used while configuring remote logging (when dest is 'server').
-    version_added: '2.7'
-  interface:
-    description:
-      - Interface to be used while configuring source-interface for logging (e.g., 'Ethernet1/2', 'mgmt0')
-    version_added: '2.7'
-  name:
-    description:
-      - If value of C(dest) is I(logfile) it indicates file-name.
-  facility:
-    description:
-      - Facility name for logging.
-  dest_level:
-    description:
-      - Set logging severity levels.
-    aliases: ['level']
-  facility_level:
-    description:
-      - Set logging severity levels for facility based log messages.
-  aggregate:
-    description: List of logging definitions.
-  state:
-    description:
-      - State of the logging configuration.
-    default: present
-    choices: ['present', 'absent']
-  event:
-    description:
-      - Link/trunk enable/default interface configuration logging
-    choices: ['link-enable', 'link-default', 'trunk-enable', 'trunk-default']
-    version_added: '2.8'
-  interface_message:
-    description:
-      - Add interface description to interface syslogs.
-        Does not work with version 6.0 images using nxapi as a transport.
-    choices: ['add-interface-description']
-    version_added: '2.8'
-  file_size:
-    description:
-      - Set logfile size
-    version_added: '2.8'
-  facility_link_status:
-    description:
-      - Set logging facility ethpm link status.
-        Not idempotent with version 6.0 images.
-    choices: ['link-down-notif', 'link-down-error', 'link-up-notif', 'link-up-error']
-    version_added: '2.8'
-  timestamp:
-    description:
-      - Set logging timestamp format
-    choices: ['microseconds', 'milliseconds', 'seconds']
-    version_added: '2.8'
-  purge:
-    description:
-      - Remove any switch logging configuration that does not match what has been configured
-        Not supported for ansible_connection local.
-        All nxos_logging tasks must use the same ansible_connection type.
-
-    type: bool
-    default: no
-    version_added: '2.8'
-extends_documentation_fragment: nxos
-"""
-
-EXAMPLES = """
-- name: configure console logging with level
-  nxos_logging:
-    dest: console
-    level: 2
-    state: present
-- name: remove console logging configuration
-  nxos_logging:
-    dest: console
-    level: 2
-    state: absent
-- name: configure file logging with level
-  nxos_logging:
-    dest: logfile
-    name: testfile
-    dest_level: 3
-    state: present
-- name: Configure logging logfile with size
-  nxos_logging:
-    dest: logfile
-    name: testfile
-    dest_level: 3
-    file_size: 16384
-- name: configure facility level logging
-  nxos_logging:
-    facility: daemon
-    facility_level: 0
-    state: present
-- name: remove facility level logging
-  nxos_logging:
-    facility: daemon
-    facility_level: 0
-    state: absent
-- name: Configure Remote Logging
-  nxos_logging:
-    dest: server
-    remote_server: test-syslogserver.com
-    facility: auth
-    facility_level: 1
-    use_vrf: management
-    state: present
-- name: Configure Source Interface for Logging
-  nxos_logging:
-    interface: mgmt0
-    state: present
-- name: Purge nxos_logging configuration not managed by this playbook
-  nxos_logging:
-    purge: true
-- name: Configure logging timestamp
-  nxos_logging:
-    timestamp: milliseconds
-    state: present
-- name: Configure logging facility ethpm link status
-  nxos_logging:
-    facility: ethpm
-    facility_link_status: link-up-notif
-    state: present
-- name: Configure logging message ethernet description
-  nxos_logging:
-    interface_message: add-interface-description
-    state: present
-- name: Configure logging event link enable
-  nxos_logging:
-    event: link-enable
-    state: present
-- name: Configure logging using aggregate
-  nxos_logging:
-    aggregate:
-      - { dest: console, dest_level: 2 }
-      - { dest: logfile, dest_level: 2, name: testfile }
-      - { facility: daemon, facility_level: 0 }
-    state: present
-"""
-
-RETURN = """
-commands:
-  description: The list of configuration mode commands to send to the device
-  returned: always
-  type: list
-  sample:
-    - logging console 2
-    - logging logfile testfile 3
-    - logging level daemon 0
-"""
-
-import re
-import copy
-
-from ansible.module_utils.network.nxos.nxos import get_config, load_config, run_commands, save_module_context, read_module_context
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec, normalize_interface
-from ansible.module_utils.basic import AnsibleModule
-
-
-STATIC_CLI = {'link-enable': 'logging event link-status enable',
-              'link-default': 'logging event link-status default',
-              'trunk-enable': 'logging event trunk-status enable',
-              'trunk-default': 'logging event trunk-status default',
-              'microseconds': 'logging timestamp microseconds',
-              'milliseconds': 'logging timestamp milliseconds',
-              'seconds': 'logging timestamp seconds',
-              'link-up-error': 'link-up error',
-              'link-up-notif': 'link-up notif',
-              'link-down-error': 'link-down error',
-              'link-down-notif': 'link-down notif',
-              'add-interface-description': 'logging message interface type ethernet description'}
-
-DEFAULT_LOGGING_LEVEL = {0: [],
-                         1: [],
-                         2: ['pktmgr'],
-                         3: ['adjmgr', 'arp', 'icmpv6', 'l2rib', 'netstack'],
-                         4: [],
-                         5: ['mrib', 'm6rib'],
-                         6: [],
-                         7: []}
-
-DEST_GROUP = ['console', 'logfile', 'module', 'monitor', 'server']
-
-
-def map_obj_to_commands(module, updates):
-    commands = list()
-    want, have = updates
-
-    for w in want:
-        state = w['state']
-        del w['state']
-
-        if state == 'absent' and w in have:
-            if w['facility'] is not None:
-                if not w['dest'] and not w['facility_link_status'] and w['facility'] not in DEFAULT_LOGGING_LEVEL[int(w['facility_level'])]:
-                    commands.append('no logging level {0} {1}'.format(w['facility'], w['facility_level']))
-
-                if w['facility_link_status'] and w['facility'] in ('ethpm'):
-                    commands.append('no logging level {0} {1}'.format(w['facility'], STATIC_CLI[w['facility_link_status']]))
-
-            if w['name'] is not None:
-                commands.append('no logging logfile')
-
-            if w['dest'] in ('console', 'module', 'monitor'):
-                commands.append('no logging {0}'.format(w['dest']))
-
-            if w['dest'] == 'server':
-                commands.append('no logging server {0}'.format(w['remote_server']))
-
-            if w['interface']:
-                commands.append('no logging source-interface')
-
-            if w['event'] and w['event'] in STATIC_CLI:
-                commands.append('no ' + STATIC_CLI[w['event']])
-
-            if w['message'] and w['message'] in STATIC_CLI:
-                commands.append('no ' + STATIC_CLI[w['message']])
-
-            if w['timestamp'] and w['timestamp'] in STATIC_CLI:
-                commands.append('no ' + STATIC_CLI[w['timestamp']])
-
-        if state == 'present' and w not in have:
-            if w['facility'] is None:
-                if w['dest']:
-                    if w['dest'] not in ('logfile', 'server'):
-                        commands.append('logging {0} {1}'.format(w['dest'], w['dest_level']))
-
-                    elif w['dest'] == 'logfile':
-                        if w['file_size']:
-                            commands.append('logging logfile {0} {1} size {2}'.format(
-                                w['name'], w['dest_level'], w['file_size']))
-                        else:
-                            commands.append('logging logfile {0} {1}'.format(
-                                w['name'], w['dest_level']))
-
-                    elif w['dest'] == 'server':
-                        if w['facility_level']:
-                            if w['use_vrf']:
-                                commands.append('logging server {0} {1} use-vrf {2}'.format(
-                                    w['remote_server'], w['facility_level'], w['use_vrf']))
-                            else:
-                                commands.append('logging server {0} {1}'.format(
-                                    w['remote_server'], w['facility_level']))
-
-                        else:
-                            if w['use_vrf']:
-                                commands.append('logging server {0} use-vrf {1}'.format(
-                                    w['remote_server'], w['use_vrf']))
-                            else:
-                                commands.append('logging server {0}'.format(w['remote_server']))
-
-            if w['facility']:
-                if w['dest'] == 'server':
-                    if w['facility_level']:
-                        if w['use_vrf']:
-                            commands.append('logging server {0} {1} facility {2} use-vrf {3}'.format(
-                                w['remote_server'], w['facility_level'], w['facility'], w['use_vrf']))
-                        else:
-                            commands.append('logging server {0} {1} facility {2}'.format(
-                                w['remote_server'], w['facility_level'], w['facility']))
-                    else:
-                        if w['use_vrf']:
-                            commands.append('logging server {0} facility {1} use-vrf {2}'.format(
-                                w['remote_server'], w['facility'], w['use_vrf']))
-                        else:
-                            commands.append('logging server {0} facility {1}'.format(w['remote_server'],
-                                                                                     w['facility']))
-                else:
-                    if w['facility_link_status']:
-                        commands.append('logging level {0} {1}'.format(
-                            w['facility'], STATIC_CLI[w['facility_link_status']]))
-                    else:
-                        if not match_facility_default(module, w['facility'], w['facility_level']):
-                            commands.append('logging level {0} {1}'.format(w['facility'],
-                                                                           w['facility_level']))
-
-            if w['interface']:
-                commands.append('logging source-interface {0} {1}'.format(*split_interface(w['interface'])))
-
-            if w['event'] and w['event'] in STATIC_CLI:
-                commands.append(STATIC_CLI[w['event']])
-
-            if w['message'] and w['message'] in STATIC_CLI:
-                commands.append(STATIC_CLI[w['message']])
-
-            if w['timestamp'] and w['timestamp'] in STATIC_CLI:
-                commands.append(STATIC_CLI[w['timestamp']])
-
-    return commands
-
-
-def match_facility_default(module, facility, want_level):
-    ''' Check wanted facility to see if it matches current device default '''
-
-    matches_default = False
-    # Sample output from show logging level command
-    # Facility        Default Severity        Current Session Severity
-    # --------        ----------------        ------------------------
-    # bfd                     5                       5
-    #
-    # 0(emergencies)          1(alerts)       2(critical)
-    # 3(errors)               4(warnings)     5(notifications)
-    # 6(information)          7(debugging)
-
-    regexl = r'\S+\s+(\d+)\s+(\d+)'
-    cmd = {'command': 'show logging level {0}'.format(facility), 'output': 'text'}
-    facility_data = run_commands(module, cmd)
-    for line in facility_data[0].split('\n'):
-        mo = re.search(regexl, line)
-        if mo and int(mo.group(1)) == int(want_level) and int(mo.group(2)) == int(want_level):
-            matches_default = True
-
-    return matches_default
-
-
-def split_interface(interface):
-    match = re.search(r'(\D+)(\S*)', interface, re.M)
-    if match:
-        return match.group(1), match.group(2)
-
-
-def parse_facility_link_status(line, facility, status):
-    facility_link_status = None
-
-    if facility is not None:
-        match = re.search(r'logging level {0} {1} (\S+)'.format(facility, status), line, re.M)
-        if match:
-            facility_link_status = status + "-" + match.group(1)
-
-    return facility_link_status
-
-
-def parse_event_status(line, event):
-    status = None
-
-    match = re.search(r'logging event {0} (\S+)'.format(event + '-status'), line, re.M)
-    if match:
-        state = match.group(1)
-        if state:
-            status = state
-
-    return status
-
-
-def parse_event(line):
-    event = None
-
-    match = re.search(r'logging event (\S+)', line, re.M)
-    if match:
-        state = match.group(1)
-        if state == 'link-status':
-            event = 'link'
-        elif state == 'trunk-status':
-            event = 'trunk'
-
-    return event
-
-
-def parse_message(line):
-    message = None
-
-    match = re.search(r'logging message interface type ethernet description', line, re.M)
-    if match:
-        message = 'add-interface-description'
-
-    return message
-
-
-def parse_file_size(line, name, level):
-    file_size = None
-
-    match = re.search(r'logging logfile {0} {1} size (\S+)'.format(name, level), line, re.M)
-    if match:
-        file_size = match.group(1)
-        if file_size == '8192':
-            file_size = None
-
-    return file_size
-
-
-def parse_timestamp(line):
-    timestamp = None
-
-    match = re.search(r'logging timestamp (\S+)', line, re.M)
-    if match:
-        timestamp = match.group(1)
-
-    return timestamp
-
-
-def parse_name(line, dest):
-    name = None
-
-    if dest is not None:
-        if dest == 'logfile':
-            match = re.search(r'logging logfile (\S+)', line, re.M)
-            if match:
-                name = match.group(1)
-            else:
-                pass
-
-    return name
-
-
-def parse_remote_server(line, dest):
-    remote_server = None
-
-    if dest and dest == 'server':
-        match = re.search(r'logging server (\S+)', line, re.M)
-        if match:
-            remote_server = match.group(1)
-
-    return remote_server
-
-
-def parse_dest_level(line, dest, name):
-    dest_level = None
-
-    def parse_match(match):
-        level = None
-        if match:
-            if int(match.group(1)) in range(0, 8):
-                level = match.group(1)
-            else:
-                pass
-        return level
-
-    if dest and dest != 'server':
-        if dest == 'logfile':
-            match = re.search(r'logging logfile {0} (\S+)'.format(name), line, re.M)
-            if match:
-                dest_level = parse_match(match)
-
-        elif dest == 'server':
-            match = re.search(r'logging server (?:\S+) (\d+)', line, re.M)
-            if match:
-                dest_level = parse_match(match)
-        else:
-            match = re.search(r'logging {0} (\S+)'.format(dest), line, re.M)
-            if match:
-                dest_level = parse_match(match)
-
-    return dest_level
-
-
-def parse_facility_level(line, facility, dest):
-    facility_level = None
-
-    if dest == 'server':
-        match = re.search(r'logging server (?:\S+) (\d+)', line, re.M)
-        if match:
-            facility_level = match.group(1)
-
-    elif facility is not None:
-        match = re.search(r'logging level {0} (\S+)'.format(facility), line, re.M)
-        if match:
-            facility_level = match.group(1)
-
-    return facility_level
-
-
-def parse_facility(line):
-    facility = None
-
-    match = re.search(r'logging server (?:\S+) (?:\d+) (?:\S+) (?:\S+) (?:\S+) (\S+)', line, re.M)
-    if match:
-        facility = match.group(1)
-
-    return facility
-
-
-def parse_use_vrf(line, dest):
-    use_vrf = None
-
-    if dest and dest == 'server':
-        match = re.search(r'logging server (?:\S+) (?:\d+) use-vrf (\S+)', line, re.M)
-        if match:
-            use_vrf = match.group(1)
-
-    return use_vrf
-
-
-def parse_interface(line):
-    interface = None
-
-    match = re.search(r'logging source-interface (\S*)', line, re.M)
-    if match:
-        interface = match.group(1)
-
-    return interface
-
-
-def map_config_to_obj(module):
-    obj = []
-
-    data = get_config(module, flags=[' all | section logging'])
-
-    for line in data.split('\n'):
-        if re.search(r'no (\S+)', line, re.M):
-            state = 'absent'
-        else:
-            state = 'present'
-
-        match = re.search(r'logging (\S+)', line, re.M)
-        if state == 'present' and match:
-            event_status = None
-            name = None
-            dest_level = None
-            dest = None
-            facility = None
-            remote_server = None
-            facility_link_status = None
-            file_size = None
-            facility_level = None
-
-            if match.group(1) in DEST_GROUP:
-                dest = match.group(1)
-
-                name = parse_name(line, dest)
-                remote_server = parse_remote_server(line, dest)
-                dest_level = parse_dest_level(line, dest, name)
-
-                if dest == 'server':
-                    facility = parse_facility(line)
-
-                facility_level = parse_facility_level(line, facility, dest)
-
-                if dest == 'logfile':
-                    file_size = parse_file_size(line, name, dest_level)
-
-            elif match.group(1) == 'level':
-                match_facility = re.search(r'logging level (\S+)', line, re.M)
-                facility = match_facility.group(1)
-
-                level = parse_facility_level(line, facility, dest)
-                if level.isdigit():
-                    facility_level = level
-                else:
-                    facility_link_status = parse_facility_link_status(line, facility, level)
-
-            elif match.group(1) == 'event' and state == 'present':
-                event = parse_event(line)
-                if event:
-                    status = parse_event_status(line, event)
-                    if status:
-                        event_status = event + '-' + status
-                else:
-                    continue
-
-            else:
-                pass
-
-            obj.append({'dest': dest,
-                        'remote_server': remote_server,
-                        'use_vrf': parse_use_vrf(line, dest),
-                        'name': name,
-                        'facility': facility,
-                        'dest_level': dest_level,
-                        'facility_level': facility_level,
-                        'interface': parse_interface(line),
-                        'facility_link_status': facility_link_status,
-                        'event': event_status,
-                        'file_size': file_size,
-                        'message': parse_message(line),
-                        'timestamp': parse_timestamp(line)})
-
-    cmd = [{'command': 'show logging | section enabled | section console', 'output': 'text'},
-           {'command': 'show logging | section enabled | section monitor', 'output': 'text'}]
-
-    default_data = run_commands(module, cmd)
-
-    for line in default_data:
-        flag = False
-        match = re.search(r'Logging (\w+):(?:\s+) (?:\w+) (?:\W)Severity: (\w+)', str(line), re.M)
-        if match:
-            if match.group(1) == 'console' and match.group(2) == 'critical':
-                dest_level = '2'
-                flag = True
-            elif match.group(1) == 'monitor' and match.group(2) == 'notifications':
-                dest_level = '5'
-                flag = True
-        if flag:
-            obj.append({'dest': match.group(1),
-                        'remote_server': None,
-                        'name': None,
-                        'facility': None,
-                        'dest_level': dest_level,
-                        'facility_level': None,
-                        'use_vrf': None,
-                        'interface': None,
-                        'facility_link_status': None,
-                        'event': None,
-                        'file_size': None,
-                        'message': None,
-                        'timestamp': None})
-
-    return obj
-
-
-def map_params_to_obj(module):
-    obj = []
-
-    if 'aggregate' in module.params and module.params['aggregate']:
-        args = {'dest': '',
-                'remote_server': '',
-                'use_vrf': '',
-                'name': '',
-                'facility': '',
-                'dest_level': '',
-                'facility_level': '',
-                'interface': '',
-                'facility_link_status': None,
-                'event': None,
-                'file_size': None,
-                'message': None,
-                'timestamp': None}
-
-        for c in module.params['aggregate']:
-            d = c.copy()
-
-            for key in args:
-                if key not in d:
-                    d[key] = None
-
-            if d['dest_level'] is not None:
-                d['dest_level'] = str(d['dest_level'])
-
-            if d['facility_level'] is not None:
-                d['facility_level'] = str(d['facility_level'])
-
-            if d['interface']:
-                d['interface'] = normalize_interface(d['interface'])
-
-            if 'state' not in d:
-                d['state'] = module.params['state']
-
-            if d['file_size']:
-                d['file_size'] = str(d['file_size'])
-
-            obj.append(d)
-
-    else:
-        dest_level = None
-        facility_level = None
-        file_size = None
-
-        if module.params['dest_level'] is not None:
-            dest_level = str(module.params['dest_level'])
-
-        if module.params['facility_level'] is not None:
-            facility_level = str(module.params['facility_level'])
-
-        if module.params['file_size'] is not None:
-            file_size = str(module.params['file_size'])
-
-        obj.append({
-            'dest': module.params['dest'],
-            'remote_server': module.params['remote_server'],
-            'use_vrf': module.params['use_vrf'],
-            'name': module.params['name'],
-            'facility': module.params['facility'],
-            'dest_level': dest_level,
-            'facility_level': facility_level,
-            'interface': normalize_interface(module.params['interface']),
-            'state': module.params['state'],
-            'facility_link_status': module.params['facility_link_status'],
-            'event': module.params['event'],
-            'message': module.params['interface_message'],
-            'file_size': file_size,
-            'timestamp': module.params['timestamp']
-        })
-    return obj
-
-
-def merge_wants(wants, want):
-    if not wants:
-        wants = list()
-
-    for w in want:
-        w = copy.copy(w)
-        state = w['state']
-        del w['state']
-
-        if state == 'absent':
-            if w in wants:
-                wants.remove(w)
-        elif w not in wants:
-            wants.append(w)
-
-    return wants
-
-
-def absent(h):
-    h['state'] = 'absent'
-    return h
-
-
-def outliers(haves, wants):
-    wants = list(wants)
-    return [absent(h) for h in haves if not (h in wants or wants.append(h))]
-
-
-def main():
-    """ main entry point for module execution
-    """
-    argument_spec = dict(
-        dest=dict(choices=DEST_GROUP),
-        name=dict(),
-        facility=dict(),
-        remote_server=dict(),
-        use_vrf=dict(),
-        dest_level=dict(type='int', aliases=['level']),
-        facility_level=dict(type='int'),
-        interface=dict(),
-        facility_link_status=dict(choices=['link-down-notif', 'link-down-error', 'link-up-notif', 'link-up-error']),
-        event=dict(choices=['link-enable', 'link-default', 'trunk-enable', 'trunk-default']),
-        interface_message=dict(choices=['add-interface-description']),
-        file_size=dict(type='int'),
-        timestamp=dict(choices=['microseconds', 'milliseconds', 'seconds']),
-        state=dict(default='present', choices=['present', 'absent']),
-        aggregate=dict(type='list'),
-        purge=dict(default=False, type='bool'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    required_if = [('dest', 'logfile', ['name']),
-                   ('dest', 'server', ['remote_server'])]
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           required_if=required_if,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    result = {'changed': False}
-    if warnings:
-        result['warnings'] = warnings
-
-    want = map_params_to_obj(module)
-    merged_wants = merge_wants(read_module_context(module), want)
-    have = map_config_to_obj(module)
-
-    commands = map_obj_to_commands(module, (want, have))
-    result['commands'] = commands
-
-    if commands:
-        if not module.check_mode:
-            load_config(module, commands)
-        result['changed'] = True
-
-    save_module_context(module, merged_wants)
-
-    if module.params.get('purge'):
-        pcommands = map_obj_to_commands(module, (outliers(have, merged_wants), have))
-        if pcommands:
-            if not module.check_mode:
-                load_config(module, pcommands)
-            result['changed'] = True
-        result['commands'] += pcommands
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_ntp.py b/lib/ansible/modules/network/nxos/nxos_ntp.py
deleted file mode 100644
index 51f3b45140..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_ntp.py
+++ /dev/null
@@ -1,423 +0,0 @@
-#!/usr/bin/python
-# Copyright: Ansible Project
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_ntp
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages core NTP configuration.
-description:
-    - Manages core NTP configuration.
-author:
-    - Jason Edelman (@jedelman8)
-options:
-    server:
-        description:
-            - Network address of NTP server.
-    peer:
-        description:
-            - Network address of NTP peer.
-    key_id:
-        description:
-            - Authentication key identifier to use with
-              given NTP server or peer or keyword 'default'.
-    prefer:
-        description:
-            - Makes given NTP server or peer the preferred
-              NTP server or peer for the device.
-        choices: ['enabled', 'disabled']
-    vrf_name:
-        description:
-            - Makes the device communicate with the given
-              NTP server or peer over a specific VRF or
-              keyword 'default'.
-    source_addr:
-        description:
-            - Local source address from which NTP messages are sent
-              or keyword 'default'
-    source_int:
-        description:
-            - Local source interface from which NTP messages are sent.
-              Must be fully qualified interface name or keyword 'default'
-    state:
-        description:
-            - Manage the state of the resource.
-        default: present
-        choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-# Set NTP Server with parameters
-- nxos_ntp:
-    server: 1.2.3.4
-    key_id: 32
-    prefer: enabled
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-'''
-
-RETURN = '''
-proposed:
-    description: k/v pairs of parameters passed into module
-    returned: always
-    type: dict
-    sample: {"address": "192.0.2.2", "key_id": "48",
-            "peer_type": "server", "prefer": "enabled",
-            "source": "192.0.2.3", "source_type": "source"}
-existing:
-    description:
-        - k/v pairs of existing ntp server/peer
-    returned: always
-    type: dict
-    sample: {"address": "192.0.2.2", "key_id": "32",
-            "peer_type": "server", "prefer": "enabled",
-            "source": "ethernet2/1", "source_type": "source-interface"}
-end_state:
-    description: k/v pairs of ntp info after module execution
-    returned: always
-    type: dict
-    sample: {"address": "192.0.2.2", "key_id": "48",
-            "peer_type": "server", "prefer": "enabled",
-            "source": "192.0.2.3", "source_type": "source"}
-updates:
-    description: command sent to the device
-    returned: always
-    type: list
-    sample: ["ntp server 192.0.2.2 prefer key 48",
-             "no ntp source-interface ethernet2/1", "ntp source 192.0.2.3"]
-changed:
-    description: check to see if a change was made on the device
-    returned: always
-    type: bool
-    sample: true
-'''
-
-import re
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.nxos import load_config, nxos_argument_spec, run_commands
-
-
-def execute_show_command(command, module, command_type='cli_show'):
-    if 'show run' not in command:
-        output = 'json'
-    else:
-        output = 'text'
-
-    commands = [{
-        'command': command,
-        'output': output,
-    }]
-    return run_commands(module, commands)
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_ntp_source(module):
-    source_type = None
-    source = None
-    command = 'show run | inc ntp.source'
-    output = execute_show_command(command, module, command_type='cli_show_ascii')
-
-    if output:
-        try:
-            if 'interface' in output[0]:
-                source_type = 'source-interface'
-            else:
-                source_type = 'source'
-            source = output[0].split()[2].lower()
-        except (AttributeError, IndexError):
-            source_type = None
-            source = None
-
-    return source_type, source
-
-
-def get_ntp_peer(module):
-    command = 'show run | inc ntp.(server|peer)'
-    ntp_peer_list = []
-    response = execute_show_command(
-        command, module, command_type='cli_show_ascii')
-
-    if response:
-        if isinstance(response, list):
-            ntp = response[0]
-        else:
-            ntp = response
-        if ntp:
-            ntp_regex = (
-                r".*ntp\s(server\s(?P<address>\S+)|peer\s(?P<peer_address>\S+))"
-                r"\s*((?P<prefer>prefer)\s*)?(use-vrf\s(?P<vrf_name>\S+)\s*)?"
-                r"(key\s(?P<key_id>\d+))?.*"
-            )
-
-            split_ntp = ntp.splitlines()
-            for peer_line in split_ntp:
-                if 'access-group' in peer_line:
-                    continue
-                ntp_peer = {}
-                try:
-                    peer_address = None
-                    vrf_name = 'default'
-                    prefer = None
-                    key_id = None
-                    match_ntp = re.match(ntp_regex, peer_line, re.DOTALL)
-                    group_ntp = match_ntp.groupdict()
-
-                    address = group_ntp["address"]
-                    peer_address = group_ntp['peer_address']
-                    prefer = group_ntp['prefer']
-                    vrf_name = group_ntp['vrf_name']
-                    key_id = group_ntp['key_id']
-
-                    if prefer is not None:
-                        prefer = 'enabled'
-                    else:
-                        prefer = 'disabled'
-
-                    if address is not None:
-                        peer_type = 'server'
-                    elif peer_address is not None:
-                        peer_type = 'peer'
-                        address = peer_address
-
-                    args = dict(peer_type=peer_type, address=address, prefer=prefer,
-                                vrf_name=vrf_name, key_id=key_id)
-
-                    ntp_peer = dict((k, v) for k, v in args.items())
-                    ntp_peer_list.append(ntp_peer)
-                except AttributeError:
-                    ntp_peer_list = []
-
-    return ntp_peer_list
-
-
-def get_ntp_existing(address, peer_type, module):
-    peer_dict = {}
-    peer_server_list = []
-
-    peer_list = get_ntp_peer(module)
-    for peer in peer_list:
-        if peer['address'] == address:
-            peer_dict.update(peer)
-        else:
-            peer_server_list.append(peer)
-
-    source_type, source = get_ntp_source(module)
-
-    if (source_type is not None and source is not None):
-        peer_dict['source_type'] = source_type
-        peer_dict['source'] = source
-
-    return (peer_dict, peer_server_list)
-
-
-def set_ntp_server_peer(peer_type, address, prefer, key_id, vrf_name):
-    command_strings = []
-
-    if prefer:
-        command_strings.append(' prefer')
-    if key_id:
-        command_strings.append(' key {0}'.format(key_id))
-    if vrf_name:
-        command_strings.append(' use-vrf {0}'.format(vrf_name))
-
-    command_strings.insert(0, 'ntp {0} {1}'.format(peer_type, address))
-
-    command = ''.join(command_strings)
-
-    return command
-
-
-def config_ntp(delta, existing):
-    if (delta.get('address') or delta.get('peer_type') or delta.get('vrf_name') or
-            delta.get('key_id') or delta.get('prefer')):
-        address = delta.get('address', existing.get('address'))
-        peer_type = delta.get('peer_type', existing.get('peer_type'))
-        key_id = delta.get('key_id', existing.get('key_id'))
-        prefer = delta.get('prefer', existing.get('prefer'))
-        vrf_name = delta.get('vrf_name', existing.get('vrf_name'))
-        if delta.get('key_id') == 'default':
-            key_id = None
-    else:
-        peer_type = None
-        prefer = None
-
-    source_type = delta.get('source_type')
-    source = delta.get('source')
-
-    if prefer:
-        if prefer == 'enabled':
-            prefer = True
-        elif prefer == 'disabled':
-            prefer = False
-
-    if source:
-        source_type = delta.get('source_type', existing.get('source_type'))
-
-    ntp_cmds = []
-    if peer_type:
-        if existing.get('peer_type') and existing.get('address'):
-            ntp_cmds.append('no ntp {0} {1}'.format(existing.get('peer_type'),
-                                                    existing.get('address')))
-        ntp_cmds.append(set_ntp_server_peer(
-            peer_type, address, prefer, key_id, vrf_name))
-    if source:
-        existing_source_type = existing.get('source_type')
-        existing_source = existing.get('source')
-        if existing_source_type and source_type != existing_source_type:
-            ntp_cmds.append('no ntp {0} {1}'.format(existing_source_type, existing_source))
-        if source == 'default':
-            if existing_source_type and existing_source:
-                ntp_cmds.append('no ntp {0} {1}'.format(existing_source_type, existing_source))
-        else:
-            ntp_cmds.append('ntp {0} {1}'.format(source_type, source))
-
-    return ntp_cmds
-
-
-def main():
-    argument_spec = dict(
-        server=dict(type='str'),
-        peer=dict(type='str'),
-        key_id=dict(type='str'),
-        prefer=dict(type='str', choices=['enabled', 'disabled']),
-        vrf_name=dict(type='str'),
-        source_addr=dict(type='str'),
-        source_int=dict(type='str'),
-        state=dict(choices=['absent', 'present'], default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           mutually_exclusive=[
-                               ['server', 'peer'],
-                               ['source_addr', 'source_int']],
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    server = module.params['server'] or None
-    peer = module.params['peer'] or None
-    key_id = module.params['key_id']
-    prefer = module.params['prefer']
-    vrf_name = module.params['vrf_name']
-    source_addr = module.params['source_addr']
-    source_int = module.params['source_int']
-    state = module.params['state']
-
-    if source_int is not None:
-        source_int = source_int.lower()
-
-    if server:
-        peer_type = 'server'
-        address = server
-    elif peer:
-        peer_type = 'peer'
-        address = peer
-    else:
-        peer_type = None
-        address = None
-
-    source_type = None
-    source = None
-    if source_addr:
-        source_type = 'source'
-        source = source_addr
-    elif source_int:
-        source_type = 'source-interface'
-        source = source_int
-
-    if key_id or vrf_name or prefer:
-        if not server and not peer:
-            module.fail_json(
-                msg='Please supply the server or peer parameter')
-
-    args = dict(peer_type=peer_type, address=address, key_id=key_id,
-                prefer=prefer, vrf_name=vrf_name, source_type=source_type,
-                source=source)
-
-    proposed = dict((k, v) for k, v in args.items() if v is not None)
-
-    existing, peer_server_list = get_ntp_existing(address, peer_type, module)
-
-    end_state = existing
-    changed = False
-    commands = []
-
-    if state == 'present':
-        delta = dict(set(proposed.items()).difference(existing.items()))
-        if delta.get('key_id') and delta.get('key_id') == 'default':
-            if not existing.get('key_id'):
-                delta.pop('key_id')
-        if delta:
-            command = config_ntp(delta, existing)
-            if command:
-                commands.append(command)
-
-    elif state == 'absent':
-        if existing.get('peer_type') and existing.get('address'):
-            command = 'no ntp {0} {1}'.format(
-                existing['peer_type'], existing['address'])
-            if command:
-                commands.append([command])
-
-        existing_source_type = existing.get('source_type')
-        existing_source = existing.get('source')
-        proposed_source_type = proposed.get('source_type')
-        proposed_source = proposed.get('source')
-
-        if proposed_source_type:
-            if proposed_source_type == existing_source_type:
-                if proposed_source == existing_source:
-                    command = 'no ntp {0} {1}'.format(
-                        existing_source_type, existing_source)
-                    if command:
-                        commands.append([command])
-
-    cmds = flatten_list(commands)
-    if cmds:
-        if module.check_mode:
-            module.exit_json(changed=True, commands=cmds)
-        else:
-            changed = True
-            load_config(module, cmds)
-            end_state = get_ntp_existing(address, peer_type, module)[0]
-            if 'configure' in cmds:
-                cmds.pop(0)
-
-    results = {}
-    results['proposed'] = proposed
-    results['existing'] = existing
-    results['updates'] = cmds
-    results['changed'] = changed
-    results['warnings'] = warnings
-    results['end_state'] = end_state
-    results['peer_server_list'] = peer_server_list
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_ntp_auth.py b/lib/ansible/modules/network/nxos/nxos_ntp_auth.py
deleted file mode 100644
index 10fef0b492..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_ntp_auth.py
+++ /dev/null
@@ -1,322 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-
-module: nxos_ntp_auth
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages NTP authentication.
-description:
-    - Manages NTP authentication.
-author:
-    - Jason Edelman (@jedelman8)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - If C(state=absent), the module will remove the given key configuration if it exists.
-    - If C(state=absent) and C(authentication=on), authentication will be turned off.
-options:
-    key_id:
-        description:
-            - Authentication key identifier (numeric).
-    md5string:
-        description:
-            - MD5 String.
-    auth_type:
-        description:
-            - Whether the given md5string is in cleartext or
-              has been encrypted. If in cleartext, the device
-              will encrypt it before storing it.
-        default: text
-        choices: ['text', 'encrypt']
-    trusted_key:
-        description:
-            - Whether the given key is required to be supplied by a time source
-              for the device to synchronize to the time source.
-        choices: [ 'false', 'true' ]
-        default: 'false'
-    authentication:
-        description:
-            - Turns NTP authentication on or off.
-        choices: ['on', 'off']
-    state:
-        description:
-            - Manage the state of the resource.
-        default: present
-        choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-# Basic NTP authentication configuration
-- nxos_ntp_auth:
-    key_id: 32
-    md5string: hello
-    auth_type: text
-'''
-
-RETURN = '''
-commands:
-    description: command sent to the device
-    returned: always
-    type: list
-    sample: ["ntp authentication-key 32 md5 helloWorld 0", "ntp trusted-key 32"]
-'''
-
-
-import re
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def execute_show_command(command, module):
-    if 'show run' not in command:
-        command = {
-            'command': command,
-            'output': 'json',
-        }
-    else:
-        command = {
-            'command': command,
-            'output': 'text',
-        }
-
-    return run_commands(module, [command])
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_ntp_auth(module):
-    command = 'show ntp authentication-status'
-
-    body = execute_show_command(command, module)[0]
-    ntp_auth_str = body['authentication']
-
-    if 'enabled' in ntp_auth_str:
-        ntp_auth = True
-    else:
-        ntp_auth = False
-
-    return ntp_auth
-
-
-def get_ntp_trusted_key(module):
-    trusted_key_list = []
-    command = 'show run | inc ntp.trusted-key'
-
-    trusted_key_str = execute_show_command(command, module)[0]
-    if trusted_key_str:
-        trusted_keys = trusted_key_str.splitlines()
-
-    else:
-        trusted_keys = []
-
-    for line in trusted_keys:
-        if line:
-            trusted_key_list.append(str(line.split()[2]))
-
-    return trusted_key_list
-
-
-def get_ntp_auth_key(key_id, module):
-    authentication_key = {}
-    command = 'show run | inc ntp.authentication-key.{0}'.format(key_id)
-    auth_regex = (r".*ntp\sauthentication-key\s(?P<key_id>\d+)\s"
-                  r"md5\s(?P<md5string>\S+)\s(?P<atype>\S+).*")
-
-    body = execute_show_command(command, module)[0]
-
-    try:
-        match_authentication = re.match(auth_regex, body, re.DOTALL)
-        group_authentication = match_authentication.groupdict()
-        authentication_key['key_id'] = group_authentication['key_id']
-        authentication_key['md5string'] = group_authentication['md5string']
-        if group_authentication['atype'] == '7':
-            authentication_key['auth_type'] = 'encrypt'
-        else:
-            authentication_key['auth_type'] = 'text'
-    except (AttributeError, TypeError):
-        authentication_key = {}
-
-    return authentication_key
-
-
-def get_ntp_auth_info(key_id, module):
-    auth_info = get_ntp_auth_key(key_id, module)
-    trusted_key_list = get_ntp_trusted_key(module)
-    auth_power = get_ntp_auth(module)
-
-    if key_id in trusted_key_list:
-        auth_info['trusted_key'] = 'true'
-    else:
-        auth_info['trusted_key'] = 'false'
-
-    if auth_power:
-        auth_info['authentication'] = 'on'
-    else:
-        auth_info['authentication'] = 'off'
-
-    return auth_info
-
-
-def auth_type_to_num(auth_type):
-    if auth_type == 'encrypt':
-        return '7'
-    else:
-        return '0'
-
-
-def set_ntp_auth_key(key_id, md5string, auth_type, trusted_key, authentication):
-    ntp_auth_cmds = []
-    if key_id and md5string:
-        auth_type_num = auth_type_to_num(auth_type)
-        ntp_auth_cmds.append(
-            'ntp authentication-key {0} md5 {1} {2}'.format(
-                key_id, md5string, auth_type_num))
-
-    if trusted_key == 'true':
-        ntp_auth_cmds.append(
-            'ntp trusted-key {0}'.format(key_id))
-    elif trusted_key == 'false':
-        ntp_auth_cmds.append(
-            'no ntp trusted-key {0}'.format(key_id))
-
-    if authentication == 'on':
-        ntp_auth_cmds.append(
-            'ntp authenticate')
-    elif authentication == 'off':
-        ntp_auth_cmds.append(
-            'no ntp authenticate')
-
-    return ntp_auth_cmds
-
-
-def remove_ntp_auth_key(key_id, md5string, auth_type, trusted_key, authentication):
-    auth_remove_cmds = []
-    if key_id:
-        auth_type_num = auth_type_to_num(auth_type)
-        auth_remove_cmds.append(
-            'no ntp authentication-key {0} md5 {1} {2}'.format(
-                key_id, md5string, auth_type_num))
-
-    if authentication:
-        auth_remove_cmds.append(
-            'no ntp authenticate')
-    return auth_remove_cmds
-
-
-def main():
-    argument_spec = dict(
-        key_id=dict(type='str'),
-        md5string=dict(type='str'),
-        auth_type=dict(choices=['text', 'encrypt'], default='text'),
-        trusted_key=dict(choices=['true', 'false'], default='false'),
-        authentication=dict(choices=['on', 'off']),
-        state=dict(choices=['absent', 'present'], default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    key_id = module.params['key_id']
-    md5string = module.params['md5string']
-    auth_type = module.params['auth_type']
-    trusted_key = module.params['trusted_key']
-    authentication = module.params['authentication']
-    state = module.params['state']
-
-    if key_id:
-        if not trusted_key and not md5string:
-            module.fail_json(msg='trusted_key or md5string MUST be specified')
-
-    args = dict(key_id=key_id, md5string=md5string,
-                auth_type=auth_type, trusted_key=trusted_key,
-                authentication=authentication)
-
-    changed = False
-    proposed = dict((k, v) for k, v in args.items() if v is not None)
-
-    existing = get_ntp_auth_info(key_id, module)
-    end_state = existing
-
-    delta = dict(set(proposed.items()).difference(existing.items()))
-
-    commands = []
-    if state == 'present':
-        if delta:
-            command = set_ntp_auth_key(
-                key_id, md5string, delta.get('auth_type'),
-                delta.get('trusted_key'), delta.get('authentication'))
-            if command:
-                commands.append(command)
-    elif state == 'absent':
-        auth_toggle = None
-        if existing.get('authentication') == 'on':
-            auth_toggle = True
-        if not existing.get('key_id'):
-            key_id = None
-        command = remove_ntp_auth_key(
-            key_id, md5string, auth_type, trusted_key, auth_toggle)
-        if command:
-            commands.append(command)
-
-    cmds = flatten_list(commands)
-    if cmds:
-        if module.check_mode:
-            module.exit_json(changed=True, commands=cmds)
-        else:
-            load_config(module, cmds)
-            end_state = get_ntp_auth_info(key_id, module)
-            delta = dict(set(end_state.items()).difference(existing.items()))
-            if delta or (len(existing) != len(end_state)):
-                changed = True
-            if 'configure' in cmds:
-                cmds.pop(0)
-
-    results = {}
-    results['proposed'] = proposed
-    results['existing'] = existing
-    results['updates'] = cmds
-    results['changed'] = changed
-    results['warnings'] = warnings
-    results['end_state'] = end_state
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_ntp_options.py b/lib/ansible/modules/network/nxos/nxos_ntp_options.py
deleted file mode 100644
index 719c16224d..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_ntp_options.py
+++ /dev/null
@@ -1,165 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-
-module: nxos_ntp_options
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages NTP options.
-description:
-    - Manages NTP options, e.g. authoritative server and logging.
-author:
-    - Jason Edelman (@jedelman8)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - When C(state=absent), master and logging will be set to False and
-      stratum will be removed as well
-options:
-    master:
-        description:
-            - Sets whether the device is an authoritative NTP server.
-        type: bool
-    stratum:
-        description:
-            - If C(master=true), an optional stratum can be supplied (1-15).
-              The device default is 8.
-    logging:
-        description:
-            - Sets whether NTP logging is enabled on the device.
-        type: bool
-    state:
-        description:
-            - Manage the state of the resource.
-        default: present
-        choices: ['present','absent']
-'''
-EXAMPLES = '''
-# Basic NTP options configuration
-- nxos_ntp_options:
-    master: true
-    stratum: 12
-    logging: false
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-'''
-
-RETURN = '''
-updates:
-    description: command sent to the device
-    returned: always
-    type: list
-    sample: ["no ntp logging", "ntp master 12"]
-'''
-import re
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def get_current(module):
-    cmd = ('show running-config | inc ntp')
-
-    master = False
-    logging = False
-    stratum = None
-
-    output = run_commands(module, ({'command': cmd, 'output': 'text'}))[0]
-
-    if output:
-        match = re.search(r"^ntp master(?: (\d+))", output, re.M)
-        if match:
-            master = True
-            stratum = match.group(1)
-        logging = 'ntp logging' in output.lower()
-
-    return {'master': master, 'stratum': stratum, 'logging': logging}
-
-
-def main():
-    argument_spec = dict(
-        master=dict(required=False, type='bool'),
-        stratum=dict(required=False, type='str'),
-        logging=dict(required=False, type='bool'),
-        state=dict(choices=['absent', 'present'], default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    master = module.params['master']
-    stratum = module.params['stratum']
-    logging = module.params['logging']
-    state = module.params['state']
-
-    if stratum and master is False:
-        if stratum != 8:
-            module.fail_json(msg='master MUST be True when stratum is changed')
-
-    current = get_current(module)
-
-    result = {'changed': False}
-
-    commands = list()
-
-    if state == 'absent':
-        if current['master']:
-            commands.append('no ntp master')
-        if current['logging']:
-            commands.append('no ntp logging')
-
-    elif state == 'present':
-        if master and not current['master']:
-            commands.append('ntp master')
-        elif master is False and current['master']:
-            commands.append('no ntp master')
-        if stratum and stratum != current['stratum']:
-            commands.append('ntp master %s' % stratum)
-
-        if logging and not current['logging']:
-            commands.append('ntp logging')
-        elif logging is False and current['logging']:
-            commands.append('no ntp logging')
-
-    result['commands'] = commands
-    result['updates'] = commands
-
-    if commands:
-        if not module.check_mode:
-            load_config(module, commands)
-        result['changed'] = True
-
-    result['warnings'] = warnings
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_nxapi.py b/lib/ansible/modules/network/nxos/nxos_nxapi.py
deleted file mode 100644
index 3eac89e37c..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_nxapi.py
+++ /dev/null
@@ -1,408 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = """
----
-module: nxos_nxapi
-extends_documentation_fragment: nxos
-version_added: "2.1"
-author: "Peter Sprygada (@privateip)"
-short_description: Manage NXAPI configuration on an NXOS device.
-description:
-  - Configures the NXAPI feature on devices running Cisco NXOS.  The
-    NXAPI feature is absent from the configuration by default.  Since
-    this module manages the NXAPI feature it only supports the use
-    of the C(Cli) transport.
-options:
-  http_port:
-    description:
-      - Configure the port with which the HTTP server will listen on
-        for requests.  By default, NXAPI will bind the HTTP service
-        to the standard HTTP port 80.  This argument accepts valid
-        port values in the range of 1 to 65535.
-    required: false
-    default: 80
-  http:
-    description:
-      - Controls the operating state of the HTTP protocol as one of the
-        underlying transports for NXAPI.  By default, NXAPI will enable
-        the HTTP transport when the feature is first configured.  To
-        disable the use of the HTTP transport, set the value of this
-        argument to False.
-    required: false
-    default: yes
-    type: bool
-    aliases: ['enable_http']
-  https_port:
-    description:
-      - Configure the port with which the HTTPS server will listen on
-        for requests.  By default, NXAPI will bind the HTTPS service
-        to the standard HTTPS port 443.  This argument accepts valid
-        port values in the range of 1 to 65535.
-    required: false
-    default: 443
-  https:
-    description:
-      - Controls the operating state of the HTTPS protocol as one of the
-        underlying transports for NXAPI.  By default, NXAPI will disable
-        the HTTPS transport when the feature is first configured.  To
-        enable the use of the HTTPS transport, set the value of this
-        argument to True.
-    required: false
-    default: no
-    type: bool
-    aliases: ['enable_https']
-  sandbox:
-    description:
-      - The NXAPI feature provides a web base UI for developers for
-        entering commands.  This feature is initially disabled when
-        the NXAPI feature is configured for the first time.  When the
-        C(sandbox) argument is set to True, the developer sandbox URL
-        will accept requests and when the value is set to False, the
-        sandbox URL is unavailable. This is supported on NX-OS 7K series.
-    required: false
-    default: no
-    type: bool
-    aliases: ['enable_sandbox']
-  state:
-    description:
-      - The C(state) argument controls whether or not the NXAPI
-        feature is configured on the remote device.  When the value
-        is C(present) the NXAPI feature configuration is present in
-        the device running-config.  When the values is C(absent) the
-        feature configuration is removed from the running-config.
-    choices: ['present', 'absent']
-    required: false
-    default: present
-  ssl_strong_ciphers:
-    description:
-      - Controls the use of whether strong or weak ciphers are configured.
-        By default, this feature is disabled and weak ciphers are
-        configured.  To enable the use of strong ciphers, set the value of
-        this argument to True.
-    required: false
-    default: no
-    type: bool
-    version_added: "2.7"
-  tlsv1_0:
-    description:
-      - Controls the use of the Transport Layer Security version 1.0 is
-        configured.  By default, this feature is enabled.  To disable the
-        use of TLSV1.0, set the value of this argument to True.
-    required: false
-    default: yes
-    type: bool
-    version_added: "2.7"
-  tlsv1_1:
-    description:
-      - Controls the use of the Transport Layer Security version 1.1 is
-        configured.  By default, this feature is disabled.  To enable the
-        use of TLSV1.1, set the value of this argument to True.
-    required: false
-    default: no
-    type: bool
-    version_added: "2.7"
-  tlsv1_2:
-    description:
-      - Controls the use of the Transport Layer Security version 1.2 is
-        configured.  By default, this feature is disabled.  To enable the
-        use of TLSV1.2, set the value of this argument to True.
-    required: false
-    default: no
-    type: bool
-    version_added: "2.7"
-"""
-
-EXAMPLES = """
-- name: Enable NXAPI access with default configuration
-  nxos_nxapi:
-    state: present
-
-- name: Enable NXAPI with no HTTP, HTTPS at port 9443 and sandbox disabled
-  nxos_nxapi:
-    enable_http: false
-    https_port: 9443
-    https: yes
-    enable_sandbox: no
-
-- name: remove NXAPI configuration
-  nxos_nxapi:
-    state: absent
-"""
-
-RETURN = """
-updates:
-  description:
-    - Returns the list of commands that need to be pushed into the remote
-      device to satisfy the arguments
-  returned: always
-  type: list
-  sample: ['no feature nxapi']
-"""
-import re
-
-from distutils.version import LooseVersion
-from ansible.module_utils.network.nxos.nxos import run_commands, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.network.nxos.nxos import get_capabilities
-from ansible.module_utils.basic import AnsibleModule
-
-
-def check_args(module, warnings, capabilities):
-    network_api = capabilities.get('network_api', 'nxapi')
-    if network_api == 'nxapi':
-        module.fail_json(msg='module not supported over nxapi transport')
-
-    os_platform = capabilities['device_info']['network_os_platform']
-    if '7K' not in os_platform and module.params['sandbox']:
-        module.fail_json(msg='sandbox or enable_sandbox is supported on NX-OS 7K series of switches')
-
-    state = module.params['state']
-
-    if state == 'started':
-        module.params['state'] = 'present'
-        warnings.append('state=started is deprecated and will be removed in a '
-                        'a future release.  Please use state=present instead')
-    elif state == 'stopped':
-        module.params['state'] = 'absent'
-        warnings.append('state=stopped is deprecated and will be removed in a '
-                        'a future release.  Please use state=absent instead')
-
-    for key in ['http_port', 'https_port']:
-        if module.params[key] is not None:
-            if not 1 <= module.params[key] <= 65535:
-                module.fail_json(msg='%s must be between 1 and 65535' % key)
-
-    return warnings
-
-
-def map_obj_to_commands(want, have, module, warnings, capabilities):
-    send_commands = list()
-    commands = dict()
-    os_platform = None
-    os_version = None
-
-    device_info = capabilities.get('device_info')
-    if device_info:
-        os_version = device_info.get('network_os_version')
-        if os_version:
-            os_version = os_version[:3]
-        os_platform = device_info.get('network_os_platform')
-        if os_platform:
-            os_platform = os_platform[:3]
-
-    def needs_update(x):
-        return want.get(x) is not None and (want.get(x) != have.get(x))
-
-    if needs_update('state'):
-        if want['state'] == 'absent':
-            return ['no feature nxapi']
-        send_commands.append('feature nxapi')
-    elif want['state'] == 'absent':
-        return send_commands
-
-    for parameter in ['http', 'https']:
-        port_param = parameter + '_port'
-        if needs_update(parameter):
-            if want.get(parameter) is False:
-                commands[parameter] = 'no nxapi %s' % parameter
-            else:
-                commands[parameter] = 'nxapi %s port %s' % (parameter, want.get(port_param))
-
-        if needs_update(port_param) and want.get(parameter) is True:
-            commands[parameter] = 'nxapi %s port %s' % (parameter, want.get(port_param))
-
-    if needs_update('sandbox'):
-        commands['sandbox'] = 'nxapi sandbox'
-        if not want['sandbox']:
-            commands['sandbox'] = 'no %s' % commands['sandbox']
-
-    if os_platform and os_version:
-        if (os_platform == 'N9K' or os_platform == 'N3K') and LooseVersion(os_version) >= "9.2":
-            if needs_update('ssl_strong_ciphers'):
-                commands['ssl_strong_ciphers'] = 'nxapi ssl ciphers weak'
-                if want['ssl_strong_ciphers'] is True:
-                    commands['ssl_strong_ciphers'] = 'no nxapi ssl ciphers weak'
-
-            have_ssl_protocols = ''
-            want_ssl_protocols = ''
-            for key, value in {'tlsv1_2': 'TLSv1.2', 'tlsv1_1': 'TLSv1.1', 'tlsv1_0': 'TLSv1'}.items():
-                if needs_update(key):
-                    if want.get(key) is True:
-                        want_ssl_protocols = " ".join([want_ssl_protocols, value])
-                elif have.get(key) is True:
-                    have_ssl_protocols = " ".join([have_ssl_protocols, value])
-
-            if len(want_ssl_protocols) > 0:
-                commands['ssl_protocols'] = 'nxapi ssl protocols%s' % (" ".join([want_ssl_protocols, have_ssl_protocols]))
-    else:
-        warnings.append('os_version and/or os_platform keys from '
-                        'platform capabilities are not available.  '
-                        'Any NXAPI SSL optional arguments will be ignored')
-
-    send_commands.extend(commands.values())
-
-    return send_commands
-
-
-def parse_http(data):
-    http_res = [r'nxapi http port (\d+)']
-    http_port = None
-
-    for regex in http_res:
-        match = re.search(regex, data, re.M)
-        if match:
-            http_port = int(match.group(1))
-            break
-
-    return {'http': http_port is not None, 'http_port': http_port}
-
-
-def parse_https(data):
-    https_res = [r'nxapi https port (\d+)']
-    https_port = None
-
-    for regex in https_res:
-        match = re.search(regex, data, re.M)
-        if match:
-            https_port = int(match.group(1))
-            break
-
-    return {'https': https_port is not None, 'https_port': https_port}
-
-
-def parse_sandbox(data):
-    sandbox = [item for item in data.split('\n') if re.search(r'.*sandbox.*', item)]
-    value = False
-    if sandbox and sandbox[0] == 'nxapi sandbox':
-        value = True
-    return {'sandbox': value}
-
-
-def parse_ssl_strong_ciphers(data):
-    ciphers_res = [r'(\w+) nxapi ssl ciphers weak']
-    value = None
-
-    for regex in ciphers_res:
-        match = re.search(regex, data, re.M)
-        if match:
-            value = match.group(1)
-            break
-
-    return {'ssl_strong_ciphers': value == 'no'}
-
-
-def parse_ssl_protocols(data):
-    tlsv1_0 = re.search(r'(?<!\S)TLSv1(?!\S)', data, re.M) is not None
-    tlsv1_1 = re.search(r'(?<!\S)TLSv1.1(?!\S)', data, re.M) is not None
-    tlsv1_2 = re.search(r'(?<!\S)TLSv1.2(?!\S)', data, re.M) is not None
-
-    return {'tlsv1_0': tlsv1_0, 'tlsv1_1': tlsv1_1, 'tlsv1_2': tlsv1_2}
-
-
-def map_config_to_obj(module):
-    out = run_commands(module, ['show run all | inc nxapi'], check_rc=False)[0]
-    match = re.search(r'no feature nxapi', out, re.M)
-    # There are two possible outcomes when nxapi is disabled on nxos platforms.
-    # 1. Nothing is displayed in the running config.
-    # 2. The 'no feature nxapi' command is displayed in the running config.
-    if match or out == '':
-        return {'state': 'absent'}
-
-    out = str(out).strip()
-
-    obj = {'state': 'present'}
-    obj.update(parse_http(out))
-    obj.update(parse_https(out))
-    obj.update(parse_sandbox(out))
-    obj.update(parse_ssl_strong_ciphers(out))
-    obj.update(parse_ssl_protocols(out))
-
-    return obj
-
-
-def map_params_to_obj(module):
-    obj = {
-        'http': module.params['http'],
-        'http_port': module.params['http_port'],
-        'https': module.params['https'],
-        'https_port': module.params['https_port'],
-        'sandbox': module.params['sandbox'],
-        'state': module.params['state'],
-        'ssl_strong_ciphers': module.params['ssl_strong_ciphers'],
-        'tlsv1_0': module.params['tlsv1_0'],
-        'tlsv1_1': module.params['tlsv1_1'],
-        'tlsv1_2': module.params['tlsv1_2']
-    }
-
-    return obj
-
-
-def main():
-    """ main entry point for module execution
-    """
-    argument_spec = dict(
-        http=dict(aliases=['enable_http'], type='bool', default=True),
-        http_port=dict(type='int', default=80),
-        https=dict(aliases=['enable_https'], type='bool', default=False),
-        https_port=dict(type='int', default=443),
-        sandbox=dict(aliases=['enable_sandbox'], type='bool'),
-        state=dict(default='present', choices=['started', 'stopped', 'present', 'absent']),
-        ssl_strong_ciphers=dict(type='bool', default=False),
-        tlsv1_0=dict(type='bool', default=True),
-        tlsv1_1=dict(type='bool', default=False),
-        tlsv1_2=dict(type='bool', default=False)
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-    warning_msg = "Module nxos_nxapi currently defaults to configure 'http port 80'. "
-    warning_msg += "Default behavior is changing to configure 'https port 443'"
-    warning_msg += " when params 'http, http_port, https, https_port' are not set in the playbook"
-    module.deprecate(msg=warning_msg, version="2.11")
-
-    capabilities = get_capabilities(module)
-
-    check_args(module, warnings, capabilities)
-
-    want = map_params_to_obj(module)
-    have = map_config_to_obj(module)
-
-    commands = map_obj_to_commands(want, have, module, warnings, capabilities)
-
-    result = {'changed': False, 'warnings': warnings, 'commands': commands}
-
-    if commands:
-        if not module.check_mode:
-            load_config(module, commands)
-        result['changed'] = True
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_ospf.py b/lib/ansible/modules/network/nxos/nxos_ospf.py
deleted file mode 100644
index 74205b3531..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_ospf.py
+++ /dev/null
@@ -1,153 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = '''
----
-module: nxos_ospf
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages configuration of an ospf instance.
-description:
-  - Manages configuration of an ospf instance.
-author: Gabriele Gerbino (@GGabriele)
-options:
-  ospf:
-    description:
-      - Name of the ospf instance.
-    required: true
-  state:
-    description:
-      - Determines whether the config should be present or not
-        on the device.
-    required: false
-    default: present
-    choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-- nxos_ospf:
-    ospf: 1
-    state: present
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["router ospf 1"]
-'''
-
-import re
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-
-
-PARAM_TO_COMMAND_KEYMAP = {
-    'ospf': 'router ospf'
-}
-
-
-def get_value(config, module):
-    splitted_config = config.splitlines()
-    value_list = []
-    REGEX = r'^router ospf\s(?P<ospf>\S+).*'
-    for line in splitted_config:
-        value = ''
-        if 'router ospf' in line:
-            try:
-                match_ospf = re.match(REGEX, line, re.DOTALL)
-                ospf_group = match_ospf.groupdict()
-                value = ospf_group['ospf']
-            except AttributeError:
-                value = ''
-            if value:
-                value_list.append(value)
-
-    return value_list
-
-
-def get_existing(module):
-    existing = {}
-    config = str(get_config(module))
-
-    value = get_value(config, module)
-    if value:
-        existing['ospf'] = value
-    return existing
-
-
-def state_present(module, proposed, candidate):
-    commands = ['router ospf {0}'.format(proposed['ospf'])]
-    candidate.add(commands, parents=[])
-
-
-def state_absent(module, proposed, candidate):
-    commands = ['no router ospf {0}'.format(proposed['ospf'])]
-    candidate.add(commands, parents=[])
-
-
-def main():
-    argument_spec = dict(
-        ospf=dict(required=True, type='str'),
-        state=dict(choices=['present', 'absent'], default='present', required=False)
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    warnings = list()
-    result = dict(changed=False, warnings=warnings)
-
-    state = module.params['state']
-    ospf = str(module.params['ospf'])
-
-    existing = get_existing(module)
-    proposed = dict(ospf=ospf)
-
-    if not existing:
-        existing_list = []
-    else:
-        existing_list = existing['ospf']
-
-    candidate = CustomNetworkConfig(indent=3)
-    if state == 'present' and ospf not in existing_list:
-        state_present(module, proposed, candidate)
-    if state == 'absent' and ospf in existing_list:
-        state_absent(module, proposed, candidate)
-
-    if candidate:
-        candidate = candidate.items_text()
-        load_config(module, candidate)
-        result['changed'] = True
-        result['commands'] = candidate
-
-    else:
-        result['commands'] = []
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_ospf_vrf.py b/lib/ansible/modules/network/nxos/nxos_ospf_vrf.py
deleted file mode 100644
index 4d37442d4f..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_ospf_vrf.py
+++ /dev/null
@@ -1,441 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = '''
----
-module: nxos_ospf_vrf
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages a VRF for an OSPF router.
-description:
-  - Manages a VRF for an OSPF router.
-author: Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - Value I(default) restores params default value, if any.
-    Otherwise it removes the existing param configuration.
-options:
-  vrf:
-    description:
-      - Name of the resource instance. Valid value is a string.
-        The name 'default' is a valid VRF representing the global OSPF.
-    default: default
-  ospf:
-    description:
-      - Name of the OSPF instance.
-    required: true
-  router_id:
-    description:
-      - Router Identifier (ID) of the OSPF router VRF instance.
-  default_metric:
-    description:
-      - Specify the default Metric value. Valid values are an integer
-        or the keyword 'default'.
-  log_adjacency:
-    description:
-      - Controls the level of log messages generated whenever a
-        neighbor changes state. Valid values are 'log', 'detail',
-        and 'default'.
-    choices: ['log','detail','default']
-  timer_throttle_lsa_start:
-    description:
-      - Specify the start interval for rate-limiting Link-State
-        Advertisement (LSA) generation. Valid values are an integer,
-        in milliseconds, or the keyword 'default'.
-  timer_throttle_lsa_hold:
-    description:
-      - Specify the hold interval for rate-limiting Link-State
-        Advertisement (LSA) generation. Valid values are an integer,
-        in milliseconds, or the keyword 'default'.
-  timer_throttle_lsa_max:
-    description:
-      - Specify the max interval for rate-limiting Link-State
-        Advertisement (LSA) generation. Valid values are an integer,
-        in milliseconds, or the keyword 'default'.
-  timer_throttle_spf_start:
-    description:
-      - Specify initial Shortest Path First (SPF) schedule delay.
-        Valid values are an integer, in milliseconds, or
-        the keyword 'default'.
-  timer_throttle_spf_hold:
-    description:
-      - Specify minimum hold time between Shortest Path First (SPF)
-        calculations. Valid values are an integer, in milliseconds,
-        or the keyword 'default'.
-  timer_throttle_spf_max:
-    description:
-      - Specify the maximum wait time between Shortest Path First (SPF)
-        calculations. Valid values are an integer, in milliseconds,
-        or the keyword 'default'.
-  auto_cost:
-    description:
-      - Specifies the reference bandwidth used to assign OSPF cost.
-        Valid values are an integer, in Mbps, or the keyword 'default'.
-  bfd:
-    description:
-      - Enables BFD on all OSPF interfaces.
-      - "Dependency: 'feature bfd'"
-    version_added: "2.9"
-    type: str
-    choices: ['enable', 'disable']
-  passive_interface:
-    description:
-      - Setting to C(yes) will suppress routing update on interface.
-    version_added: "2.4"
-    type: bool
-  state:
-    description:
-      - State of ospf vrf configuration.
-    default: present
-    choices: ['present', 'absent']
-'''
-
-EXAMPLES = '''
-- nxos_ospf_vrf:
-    ospf: 1
-    timer_throttle_spf_start: 50
-    timer_throttle_spf_hold: 1000
-    timer_throttle_spf_max: 2000
-    timer_throttle_lsa_start: 60
-    timer_throttle_lsa_hold: 1100
-    timer_throttle_lsa_max: 3000
-    vrf: test
-    bfd: enable
-    state: present
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample:
-      - router ospf 1
-      - vrf test
-      - bfd
-      - timers throttle lsa 60 1100 3000
-'''
-
-import re
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-
-
-BOOL_PARAMS = [
-    'passive_interface'
-]
-PARAM_TO_COMMAND_KEYMAP = {
-    'vrf': 'vrf',
-    'router_id': 'router-id',
-    'default_metric': 'default-metric',
-    'log_adjacency': 'log-adjacency-changes',
-    'timer_throttle_lsa_start': 'timers throttle lsa',
-    'timer_throttle_lsa_max': 'timers throttle lsa',
-    'timer_throttle_lsa_hold': 'timers throttle lsa',
-    'timer_throttle_spf_max': 'timers throttle spf',
-    'timer_throttle_spf_start': 'timers throttle spf',
-    'timer_throttle_spf_hold': 'timers throttle spf',
-    'auto_cost': 'auto-cost reference-bandwidth',
-    'bfd': 'bfd',
-    'passive_interface': 'passive-interface default'
-}
-PARAM_TO_DEFAULT_KEYMAP = {
-    'timer_throttle_lsa_start': '0',
-    'timer_throttle_lsa_max': '5000',
-    'timer_throttle_lsa_hold': '5000',
-    'timer_throttle_spf_start': '200',
-    'timer_throttle_spf_max': '5000',
-    'timer_throttle_spf_hold': '1000',
-    'auto_cost': '40000',
-    'bfd': 'disable',
-    'default_metric': '',
-    'passive_interface': False,
-    'router_id': '',
-    'log_adjacency': '',
-}
-
-
-def get_existing(module, args):
-    existing = {}
-    netcfg = CustomNetworkConfig(indent=2, contents=get_config(module))
-    parents = ['router ospf {0}'.format(module.params['ospf'])]
-
-    if module.params['vrf'] != 'default':
-        parents.append('vrf {0}'.format(module.params['vrf']))
-
-    config = netcfg.get_section(parents)
-    for arg in args:
-        if arg not in ['ospf', 'vrf']:
-            existing[arg] = PARAM_TO_DEFAULT_KEYMAP.get(arg)
-
-    if config:
-        if module.params['vrf'] == 'default':
-            splitted_config = config.splitlines()
-            vrf_index = False
-            for index in range(0, len(splitted_config) - 1):
-                if 'vrf' in splitted_config[index].strip():
-                    vrf_index = index
-                    break
-            if vrf_index:
-                config = '\n'.join(splitted_config[0:vrf_index])
-
-        splitted_config = config.splitlines()
-        for line in splitted_config:
-            if 'passive' in line:
-                existing['passive_interface'] = True
-            elif 'router-id' in line:
-                existing['router_id'] = re.search(r'router-id (\S+)', line).group(1)
-            elif 'metric' in line:
-                existing['default_metric'] = re.search(r'default-metric (\S+)', line).group(1)
-            elif 'adjacency' in line:
-                log = re.search(r'log-adjacency-changes(?: (\S+))?', line).group(1)
-                if log:
-                    existing['log_adjacency'] = log
-                else:
-                    existing['log_adjacency'] = 'log'
-            elif 'auto' in line:
-                cost = re.search(r'auto-cost reference-bandwidth (\d+) (\S+)', line).group(1)
-                if 'Gbps' in line:
-                    cost = int(cost) * 1000
-                existing['auto_cost'] = str(cost)
-            elif 'bfd' in line:
-                existing['bfd'] = 'enable'
-            elif 'timers throttle lsa' in line:
-                tmp = re.search(r'timers throttle lsa (\S+) (\S+) (\S+)', line)
-                existing['timer_throttle_lsa_start'] = tmp.group(1)
-                existing['timer_throttle_lsa_hold'] = tmp.group(2)
-                existing['timer_throttle_lsa_max'] = tmp.group(3)
-            elif 'timers throttle spf' in line:
-                tmp = re.search(r'timers throttle spf (\S+) (\S+) (\S+)', line)
-                existing['timer_throttle_spf_start'] = tmp.group(1)
-                existing['timer_throttle_spf_hold'] = tmp.group(2)
-                existing['timer_throttle_spf_max'] = tmp.group(3)
-        existing['vrf'] = module.params['vrf']
-        existing['ospf'] = module.params['ospf']
-
-    return existing
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key in table:
-        new_key = key_map.get(key)
-        if new_key:
-            new_dict[new_key] = table.get(key)
-    return new_dict
-
-
-def get_timer_prd(key, proposed):
-    if proposed.get(key):
-        return proposed.get(key)
-    else:
-        return PARAM_TO_DEFAULT_KEYMAP.get(key)
-
-
-def state_present(module, existing, proposed, candidate):
-    commands = list()
-    proposed_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, proposed)
-    existing_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, existing)
-
-    for key, value in proposed_commands.items():
-        if key == 'vrf':
-            continue
-        if value is True:
-            commands.append(key)
-
-        elif value is False:
-            if key == 'passive-interface default':
-                if existing_commands.get(key):
-                    commands.append('no {0}'.format(key))
-            else:
-                commands.append('no {0}'.format(key))
-
-        elif value == 'default' or value == '':
-            if key == 'log-adjacency-changes':
-                commands.append('no {0}'.format(key))
-            elif existing_commands.get(key):
-                existing_value = existing_commands.get(key)
-                commands.append('no {0} {1}'.format(key, existing_value))
-        else:
-            if key == 'timers throttle lsa':
-                command = '{0} {1} {2} {3}'.format(
-                    key,
-                    get_timer_prd('timer_throttle_lsa_start', proposed),
-                    get_timer_prd('timer_throttle_lsa_hold', proposed),
-                    get_timer_prd('timer_throttle_lsa_max', proposed))
-            elif key == 'timers throttle spf':
-                command = '{0} {1} {2} {3}'.format(
-                    key,
-                    get_timer_prd('timer_throttle_spf_start', proposed),
-                    get_timer_prd('timer_throttle_spf_hold', proposed),
-                    get_timer_prd('timer_throttle_spf_max', proposed))
-            elif key == 'log-adjacency-changes':
-                if value == 'log':
-                    command = key
-                elif value == 'detail':
-                    command = '{0} {1}'.format(key, value)
-            elif key == 'auto-cost reference-bandwidth':
-                if len(value) < 5:
-                    command = '{0} {1} Mbps'.format(key, value)
-                else:
-                    value = str(int(value) // 1000)
-                    command = '{0} {1} Gbps'.format(key, value)
-            elif key == 'bfd':
-                command = 'no bfd' if value == 'disable' else 'bfd'
-            else:
-                command = '{0} {1}'.format(key, value.lower())
-
-            if command not in commands:
-                commands.append(command)
-
-    if commands:
-        parents = ['router ospf {0}'.format(module.params['ospf'])]
-        if module.params['vrf'] != 'default':
-            parents.append('vrf {0}'.format(module.params['vrf']))
-        candidate.add(commands, parents=parents)
-
-
-def state_absent(module, existing, proposed, candidate):
-    commands = []
-    parents = ['router ospf {0}'.format(module.params['ospf'])]
-    if module.params['vrf'] == 'default':
-        existing_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, existing)
-        for key, value in existing_commands.items():
-            if value and key != 'vrf':
-                command = None
-                if key == 'passive-interface default':
-                    command = 'no {0}'.format(key)
-                elif key == 'timers throttle lsa':
-                    if (existing['timer_throttle_lsa_start'] !=
-                        PARAM_TO_DEFAULT_KEYMAP.get('timer_throttle_lsa_start') or
-                        existing['timer_throttle_lsa_hold'] !=
-                        PARAM_TO_DEFAULT_KEYMAP.get('timer_throttle_lsa_hold') or
-                        existing['timer_throttle_lsa_max'] !=
-                            PARAM_TO_DEFAULT_KEYMAP.get('timer_throttle_lsa_max')):
-                        command = 'no {0} {1} {2} {3}'.format(
-                            key,
-                            existing['timer_throttle_lsa_start'],
-                            existing['timer_throttle_lsa_hold'],
-                            existing['timer_throttle_lsa_max'])
-                elif key == 'timers throttle spf':
-                    if (existing['timer_throttle_spf_start'] !=
-                        PARAM_TO_DEFAULT_KEYMAP.get('timer_throttle_spf_start') or
-                        existing['timer_throttle_spf_hold'] !=
-                        PARAM_TO_DEFAULT_KEYMAP.get('timer_throttle_spf_hold') or
-                        existing['timer_throttle_spf_max'] !=
-                            PARAM_TO_DEFAULT_KEYMAP.get('timer_throttle_spf_max')):
-                        command = 'no {0} {1} {2} {3}'.format(
-                            key,
-                            existing['timer_throttle_spf_start'],
-                            existing['timer_throttle_spf_hold'],
-                            existing['timer_throttle_spf_max'])
-                elif key == 'log-adjacency-changes':
-                    command = 'no {0}'.format(key)
-                elif key == 'auto-cost reference-bandwidth':
-                    if value != PARAM_TO_DEFAULT_KEYMAP.get('auto_cost'):
-                        command = 'no {0}'.format(key)
-                    else:
-                        command = None
-                elif key == 'bfd':
-                    if value == 'enable':
-                        command = 'no bfd'
-                else:
-                    existing_value = existing_commands.get(key)
-                    command = 'no {0} {1}'.format(key, existing_value)
-
-                if command:
-                    if command not in commands:
-                        commands.append(command)
-    else:
-        if (existing.get('vrf') and
-                existing.get('vrf') == module.params['vrf']):
-            commands = ['no vrf {0}'.format(module.params['vrf'])]
-
-    if commands:
-        candidate.add(commands, parents=parents)
-
-
-def main():
-    argument_spec = dict(
-        vrf=dict(required=False, type='str', default='default'),
-        ospf=dict(required=True, type='str'),
-        router_id=dict(required=False, type='str'),
-        default_metric=dict(required=False, type='str'),
-        log_adjacency=dict(required=False, type='str', choices=['log', 'detail', 'default']),
-        timer_throttle_lsa_start=dict(required=False, type='str'),
-        timer_throttle_lsa_hold=dict(required=False, type='str'),
-        timer_throttle_lsa_max=dict(required=False, type='str'),
-        timer_throttle_spf_start=dict(required=False, type='str'),
-        timer_throttle_spf_hold=dict(required=False, type='str'),
-        timer_throttle_spf_max=dict(required=False, type='str'),
-        auto_cost=dict(required=False, type='str'),
-        bfd=dict(required=False, type='str', choices=['enable', 'disable']),
-        passive_interface=dict(required=False, type='bool'),
-        state=dict(choices=['present', 'absent'], default='present', required=False)
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    warnings = list()
-    result = dict(changed=False, commands=[], warnings=warnings)
-
-    state = module.params['state']
-    args = PARAM_TO_COMMAND_KEYMAP.keys()
-    existing = get_existing(module, args)
-    proposed_args = dict((k, v) for k, v in module.params.items()
-                         if v is not None and k in args)
-
-    proposed = {}
-    for key, value in proposed_args.items():
-        if key != 'interface':
-            if str(value).lower() == 'true':
-                value = True
-            elif str(value).lower() == 'false':
-                value = False
-            elif str(value).lower() == 'default':
-                value = PARAM_TO_DEFAULT_KEYMAP.get(key)
-                if value is None:
-                    value = 'default'
-            if existing.get(key) != value:
-                proposed[key] = value
-
-    candidate = CustomNetworkConfig(indent=3)
-    if state == 'present':
-        state_present(module, existing, proposed, candidate)
-    if state == 'absent' and existing:
-        state_absent(module, existing, proposed, candidate)
-
-    if candidate:
-        candidate = candidate.items_text()
-        result['commands'] = candidate
-        if not module.check_mode:
-            load_config(module, candidate)
-            result['changed'] = True
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_overlay_global.py b/lib/ansible/modules/network/nxos/nxos_overlay_global.py
deleted file mode 100644
index 2f79bcdb94..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_overlay_global.py
+++ /dev/null
@@ -1,190 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = '''
----
-module: nxos_overlay_global
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Configures anycast gateway MAC of the switch.
-description:
-  - Configures anycast gateway MAC of the switch.
-author: Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - Default restores params default value
-  - Supported MAC address format are "E.E.E", "EE-EE-EE-EE-EE-EE",
-    "EE:EE:EE:EE:EE:EE" and "EEEE.EEEE.EEEE"
-options:
-  anycast_gateway_mac:
-    description:
-      - Anycast gateway mac of the switch.
-    required: true
-'''
-
-EXAMPLES = '''
-- nxos_overlay_global:
-    anycast_gateway_mac: "b.b.b"
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["fabric forwarding anycast-gateway-mac 000B.000B.000B"]
-'''
-
-import re
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-
-PARAM_TO_COMMAND_KEYMAP = {
-    'anycast_gateway_mac': 'fabric forwarding anycast-gateway-mac',
-}
-
-
-def get_existing(module, args):
-    existing = {}
-    config = str(get_config(module))
-
-    for arg in args:
-        command = PARAM_TO_COMMAND_KEYMAP[arg]
-        has_command = re.findall(r'(?:{0}\s)(?P<value>.*)$'.format(command), config, re.M)
-        value = ''
-        if has_command:
-            value = has_command[0]
-        existing[arg] = value
-
-    return existing
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key, value in table.items():
-        new_key = key_map.get(key)
-        if value:
-            new_dict[new_key] = value
-    return new_dict
-
-
-def get_commands(module, existing, proposed, candidate):
-    commands = list()
-    proposed_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, proposed)
-    existing_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, existing)
-
-    for key, proposed in proposed_commands.items():
-        existing_value = existing_commands.get(key)
-        if proposed == 'default' and existing_value:
-            commands.append('no {0} {1}'.format(key, existing_value))
-        elif 'anycast-gateway-mac' in key and proposed != 'default':
-            proposed = normalize_mac(proposed, module)
-            existing_value = normalize_mac(existing_value, module)
-            if proposed != existing_value:
-                command = '{0} {1}'.format(key, proposed)
-                commands.append(command)
-    if commands:
-        candidate.add(commands, parents=[])
-
-
-def normalize_mac(proposed_mac, module):
-    if proposed_mac is None:
-        return ''
-    try:
-        if '-' in proposed_mac:
-            splitted_mac = proposed_mac.split('-')
-            if len(splitted_mac) != 6:
-                raise ValueError
-
-            for octect in splitted_mac:
-                if len(octect) != 2:
-                    raise ValueError
-
-        elif '.' in proposed_mac:
-            splitted_mac = []
-            splitted_dot_mac = proposed_mac.split('.')
-            if len(splitted_dot_mac) != 3:
-                raise ValueError
-
-            for octect in splitted_dot_mac:
-                if len(octect) > 4:
-                    raise ValueError
-                else:
-                    octect_len = len(octect)
-                    padding = 4 - octect_len
-                    splitted_mac.append(octect.zfill(padding + 1))
-
-        elif ':' in proposed_mac:
-            splitted_mac = proposed_mac.split(':')
-            if len(splitted_mac) != 6:
-                raise ValueError
-
-            for octect in splitted_mac:
-                if len(octect) != 2:
-                    raise ValueError
-        else:
-            raise ValueError
-    except ValueError:
-        module.fail_json(msg='Invalid MAC address format', proposed_mac=proposed_mac)
-
-    joined_mac = ''.join(splitted_mac)
-    mac = [joined_mac[i:i + 4] for i in range(0, len(joined_mac), 4)]
-    return '.'.join(mac).upper()
-
-
-def main():
-    argument_spec = dict(
-        anycast_gateway_mac=dict(required=True, type='str'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-    result = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    args = PARAM_TO_COMMAND_KEYMAP.keys()
-
-    existing = get_existing(module, args)
-    proposed = dict((k, v) for k, v in module.params.items()
-                    if v is not None and k in args)
-
-    candidate = CustomNetworkConfig(indent=3)
-    get_commands(module, existing, proposed, candidate)
-
-    if candidate:
-        candidate = candidate.items_text()
-        result['commands'] = candidate
-
-        if not module.check_mode:
-            load_config(module, candidate)
-            result['changed'] = True
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_pim.py b/lib/ansible/modules/network/nxos/nxos_pim.py
deleted file mode 100644
index af7cf39ead..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_pim.py
+++ /dev/null
@@ -1,205 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_pim
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages configuration of a PIM instance.
-description:
-    - Manages configuration of a Protocol Independent Multicast (PIM) instance.
-author: Gabriele Gerbino (@GGabriele)
-options:
-  bfd:
-    description:
-      - Enables BFD on all PIM interfaces.
-      - "Dependency: 'feature bfd'"
-    version_added: "2.9"
-    type: str
-    choices: ['enable', 'disable']
-
-  ssm_range:
-    description:
-      - Configure group ranges for Source Specific Multicast (SSM).
-        Valid values are multicast addresses or the keyword C(none)
-        or keyword C(default). C(none) removes all SSM group ranges.
-        C(default) will set ssm_range to the default multicast address.
-        If you set multicast address, please ensure that it is not the
-        same as the C(default), otherwise use the C(default) option.
-    required: true
-'''
-EXAMPLES = '''
-- name: Configure ssm_range, enable bfd
-  nxos_pim:
-    bfd: enable
-    ssm_range: "224.0.0.0/8"
-
-- name: Set to default
-  nxos_pim:
-    ssm_range: default
-
-- name: Remove all ssm group ranges
-  nxos_pim:
-    ssm_range: none
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample:
-      - ip pim bfd
-      - ip pim ssm range 224.0.0.0/8
-'''
-
-
-import re
-
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-
-
-PARAM_TO_COMMAND_KEYMAP = {
-    'bfd': 'ip pim bfd',
-    'ssm_range': 'ip pim ssm range',
-}
-
-
-def get_existing(module, args):
-    existing = {}
-    config = str(get_config(module))
-
-    for arg in args:
-        if 'ssm_range' in arg:
-            # <value> may be 'n.n.n.n/s', 'none', or 'default'
-            m = re.search(r'ssm range (?P<value>(?:[\s\d.\/]+|none|default))?$', config, re.M)
-            if m:
-                # Remove rsvd SSM range
-                value = m.group('value').replace('232.0.0.0/8', '')
-                existing[arg] = value.split()
-
-        elif 'bfd' in arg and 'ip pim bfd' in config:
-            existing[arg] = 'enable'
-
-    return existing
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key, value in table.items():
-        new_key = key_map.get(key)
-        if value is not None:
-            new_dict[new_key] = value
-    return new_dict
-
-
-def get_commands(module, existing, proposed, candidate):
-    commands = list()
-    proposed_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, proposed)
-
-    for key, value in proposed_commands.items():
-        command = ''
-        if key == 'ip pim ssm range':
-            if value == 'default':
-                # no cmd needs a value but the actual value does not matter
-                command = 'no ip pim ssm range none'
-            elif value == 'none':
-                command = 'ip pim ssm range none'
-            elif value:
-                command = 'ip pim ssm range {0}'.format(value)
-        elif key == 'ip pim bfd':
-            no_cmd = 'no ' if value == 'disable' else ''
-            command = no_cmd + key
-
-        if command:
-            commands.append(command)
-
-    if commands:
-        candidate.add(commands, parents=[])
-
-
-def main():
-    argument_spec = dict(
-        bfd=dict(required=False, type='str', choices=['enable', 'disable']),
-        ssm_range=dict(required=False, type='list', default=[]),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-    warnings = list()
-    result = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    params = module.params
-    args = [k for k in PARAM_TO_COMMAND_KEYMAP.keys() if params[k] is not None]
-
-    # SSM syntax check
-    if 'ssm_range' in args:
-        for item in params['ssm_range']:
-            if re.search('none|default', item):
-                break
-            if len(item.split('.')) != 4:
-                module.fail_json(msg="Valid ssm_range values are multicast addresses "
-                                     "or the keyword 'none' or the keyword 'default'.")
-
-    existing = get_existing(module, args)
-    proposed_args = dict((k, v) for k, v in params.items() if k in args)
-
-    proposed = {}
-    for key, value in proposed_args.items():
-        if key == 'ssm_range':
-            if value and value[0] == 'default':
-                if existing.get(key):
-                    proposed[key] = 'default'
-            else:
-                v = sorted(set([str(i) for i in value]))
-                ex = sorted(set([str(i) for i in existing.get(key, [])]))
-                if v != ex:
-                    proposed[key] = ' '.join(str(s) for s in v)
-
-        elif key == 'bfd':
-            if value != existing.get('bfd', 'disable'):
-                proposed[key] = value
-
-        elif value != existing.get(key):
-            proposed[key] = value
-
-    candidate = CustomNetworkConfig(indent=3)
-    get_commands(module, existing, proposed, candidate)
-
-    if candidate:
-        candidate = candidate.items_text()
-        result['commands'] = candidate
-        result['changed'] = True
-        load_config(module, candidate)
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_pim_interface.py b/lib/ansible/modules/network/nxos/nxos_pim_interface.py
deleted file mode 100644
index 44c42e2670..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_pim_interface.py
+++ /dev/null
@@ -1,563 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = r'''
----
-module: nxos_pim_interface
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages PIM interface configuration.
-description:
-  - Manages PIM interface configuration settings.
-author:
-  - Jason Edelman (@jedelman8)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - When C(state=default), supported params will be reset to a default state.
-    These include C(dr_prio), C(hello_auth_key), C(hello_interval), C(jp_policy_out),
-    C(jp_policy_in), C(jp_type_in), C(jp_type_out), C(border), C(neighbor_policy),
-    C(neighbor_type).
-  - The C(hello_auth_key) param is not idempotent.
-  - C(hello_auth_key) only supports clear text passwords.
-  - When C(state=absent), pim interface configuration will be set to defaults and pim-sm
-    will be disabled on the interface.
-  - PIM must be enabled on the device to use this module.
-  - This module is for Layer 3 interfaces.
-options:
-  interface:
-    description:
-      - Full name of the interface such as Ethernet1/33.
-    type: str
-    required: true
-  sparse:
-    description:
-      - Enable/disable sparse-mode on the interface.
-    type: bool
-    default: no
-  bfd:
-    description:
-      - Enables BFD for PIM at the interface level. This overrides the bfd variable set at the pim global level.
-      - Valid values are 'enable', 'disable' or 'default'.
-      - "Dependency: 'feature bfd'"
-    version_added: "2.9"
-    type: str
-    choices: ['enable', 'disable', 'default']
-  dr_prio:
-    description:
-      - Configures priority for PIM DR election on interface.
-    type: str
-  hello_auth_key:
-    description:
-      - Authentication for hellos on this interface.
-    type: str
-  hello_interval:
-    description:
-      - Hello interval in milliseconds for this interface.
-    type: int
-  jp_policy_out:
-    description:
-      - Policy for join-prune messages (outbound).
-    type: str
-  jp_policy_in:
-    description:
-      - Policy for join-prune messages (inbound).
-    type: str
-  jp_type_out:
-    description:
-      - Type of policy mapped to C(jp_policy_out).
-    type: str
-    choices: [ prefix, routemap ]
-  jp_type_in:
-    description:
-      - Type of policy mapped to C(jp_policy_in).
-    type: str
-    choices: [ prefix, routemap ]
-  border:
-    description:
-      - Configures interface to be a boundary of a PIM domain.
-    type: bool
-    default: no
-  neighbor_policy:
-    description:
-      - Configures a neighbor policy for filtering adjacencies.
-    type: str
-  neighbor_type:
-    description:
-      - Type of policy mapped to neighbor_policy.
-    type: str
-    choices: [ prefix, routemap ]
-  state:
-    description:
-      - Manages desired state of the resource.
-    type: str
-    choices: [ present, default ]
-    default: present
-'''
-EXAMPLES = r'''
-- name: Ensure PIM is not running on the interface
-  nxos_pim_interface:
-    interface: eth1/33
-    state: absent
-
-- name: Ensure the interface has pim-sm enabled with the appropriate priority and hello interval
-  nxos_pim_interface:
-    interface: eth1/33
-    dr_prio: 10
-    hello_interval: 40
-    state: present
-
-- name: Ensure join-prune policies exist
-  nxos_pim_interface:
-    interface: eth1/33
-    jp_policy_in: JPIN
-    jp_policy_out: JPOUT
-    jp_type_in: routemap
-    jp_type_out: routemap
-
-- name: disable bfd on the interface
-  nxos_pim_interface:
-    interface: eth1/33
-    bfd: disable
-
-- name: Ensure defaults are in place
-  nxos_pim_interface:
-    interface: eth1/33
-    state: default
-'''
-
-RETURN = r'''
-commands:
-    description: command sent to the device
-    returned: always
-    type: list
-    sample: ["interface eth1/33",
-             "ip pim neighbor-policy test",
-             "ip pim bfd-instance disable",
-             "ip pim neighbor-policy test"
-            ]
-'''
-
-import re
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.nxos import get_config, load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.network.nxos.nxos import get_interface_type
-
-
-PARAM_TO_COMMAND_KEYMAP = {
-    'interface': '',
-    'bfd': 'ip pim bfd-instance',
-    'sparse': 'ip pim sparse-mode',
-    'dr_prio': 'ip pim dr-priority {0}',
-    'hello_interval': 'ip pim hello-interval {0}',
-    'hello_auth_key': 'ip pim hello-authentication ah-md5 {0}',
-    'border': 'ip pim border',
-    'jp_policy_out': 'ip pim jp-policy prefix-list {0} out',
-    'jp_policy_in': 'ip pim jp-policy prefix-list {0} in',
-    'jp_type_in': '',
-    'jp_type_out': '',
-    'neighbor_policy': 'ip pim neighbor-policy prefix-list {0}',
-    'neighbor_type': '',
-}
-
-PARAM_TO_DEFAULT_KEYMAP = {
-    'bfd': 'default',
-    'dr_prio': '1',
-    'hello_interval': '30000',
-    'sparse': False,
-    'border': False,
-    'hello_auth_key': False,
-}
-
-BFD_KEYMAP = {
-    None: None,
-    'default': 'no ip pim bfd-instance',
-    'disable': 'ip pim bfd-instance disable',
-    'enable': 'ip pim bfd-instance',
-}
-
-
-def execute_show_command(command, module, text=False):
-    if text:
-        cmds = [{
-            'command': command,
-            'output': 'text'
-        }]
-    else:
-        cmds = [{
-            'command': command,
-            'output': 'json'
-        }]
-
-    return run_commands(module, cmds)
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def local_existing(gexisting):
-    jp_bidir = False
-    isauth = False
-    if gexisting:
-        jp_bidir = gexisting.get('jp_bidir')
-        isauth = gexisting.get('isauth')
-        if jp_bidir and isauth:
-            gexisting.pop('jp_bidir')
-            gexisting.pop('isauth')
-
-    return gexisting, jp_bidir, isauth
-
-
-def get_interface_mode(interface, intf_type, module):
-    mode = 'unknown'
-    command = 'show interface {0}'.format(interface)
-    body = execute_show_command(command, module)
-
-    try:
-        interface_table = body[0]['TABLE_interface']['ROW_interface']
-    except (KeyError, AttributeError, IndexError):
-        return mode
-
-    if intf_type in ['ethernet', 'portchannel']:
-        mode = str(interface_table.get('eth_mode', 'layer3'))
-        if mode in ['access', 'trunk']:
-            mode = 'layer2'
-        elif mode == 'routed':
-            mode = 'layer3'
-    elif intf_type in ['loopback', 'svi']:
-        mode = 'layer3'
-    return mode
-
-
-def get_pim_interface(module, interface):
-    pim_interface = {}
-    body = get_config(module, flags=['interface {0}'.format(interface)])
-
-    pim_interface['bfd'] = 'default'
-    pim_interface['neighbor_type'] = None
-    pim_interface['neighbor_policy'] = None
-    pim_interface['jp_policy_in'] = None
-    pim_interface['jp_policy_out'] = None
-    pim_interface['jp_type_in'] = None
-    pim_interface['jp_type_out'] = None
-    pim_interface['jp_bidir'] = False
-    pim_interface['isauth'] = False
-
-    if body:
-        all_lines = body.splitlines()
-
-        for each in all_lines:
-            if 'jp-policy' in each:
-                policy_name = \
-                    re.search(r'ip pim jp-policy(?: prefix-list)? (\S+)(?: \S+)?', each).group(1)
-                if 'prefix-list' in each:
-                    ptype = 'prefix'
-                else:
-                    ptype = 'routemap'
-                if 'out' in each:
-                    pim_interface['jp_policy_out'] = policy_name
-                    pim_interface['jp_type_out'] = ptype
-                elif 'in' in each:
-                    pim_interface['jp_policy_in'] = policy_name
-                    pim_interface['jp_type_in'] = ptype
-                else:
-                    pim_interface['jp_policy_in'] = policy_name
-                    pim_interface['jp_policy_out'] = policy_name
-                    pim_interface['jp_bidir'] = True
-            elif 'neighbor-policy' in each:
-                pim_interface['neighbor_policy'] = \
-                    re.search(r'ip pim neighbor-policy(?: prefix-list)? (\S+)', each).group(1)
-                if 'prefix-list' in each:
-                    pim_interface['neighbor_type'] = 'prefix'
-                else:
-                    pim_interface['neighbor_type'] = 'routemap'
-            elif 'ah-md5' in each:
-                pim_interface['isauth'] = True
-            elif 'sparse-mode' in each:
-                pim_interface['sparse'] = True
-            elif 'bfd-instance' in each:
-                m = re.search(r'ip pim bfd-instance(?P<disable> disable)?', each)
-                if m:
-                    pim_interface['bfd'] = 'disable' if m.group('disable') else 'enable'
-            elif 'border' in each:
-                pim_interface['border'] = True
-            elif 'hello-interval' in each:
-                pim_interface['hello_interval'] = \
-                    re.search(r'ip pim hello-interval (\d+)', body).group(1)
-            elif 'dr-priority' in each:
-                pim_interface['dr_prio'] = \
-                    re.search(r'ip pim dr-priority (\d+)', body).group(1)
-
-    return pim_interface
-
-
-def fix_delta(delta, existing):
-    for key in list(delta):
-        if key in ['dr_prio', 'hello_interval', 'sparse', 'border']:
-            if delta.get(key) == PARAM_TO_DEFAULT_KEYMAP.get(key) and existing.get(key) is None:
-                delta.pop(key)
-    return delta
-
-
-def config_pim_interface(delta, existing, jp_bidir, isauth):
-    command = None
-    commands = []
-
-    delta = fix_delta(delta, existing)
-
-    if jp_bidir:
-        if delta.get('jp_policy_in') or delta.get('jp_policy_out'):
-            if existing.get('jp_type_in') == 'prefix':
-                command = 'no ip pim jp-policy prefix-list {0}'.format(existing.get('jp_policy_in'))
-            else:
-                command = 'no ip pim jp-policy {0}'.format(existing.get('jp_policy_in'))
-            if command:
-                commands.append(command)
-
-    for k, v in delta.items():
-        if k in ['bfd', 'dr_prio', 'hello_interval', 'hello_auth_key', 'border',
-                 'sparse']:
-            if k == 'bfd':
-                command = BFD_KEYMAP[v]
-            elif v:
-                command = PARAM_TO_COMMAND_KEYMAP.get(k).format(v)
-            elif k == 'hello_auth_key':
-                if isauth:
-                    command = 'no ip pim hello-authentication ah-md5'
-            else:
-                command = 'no ' + PARAM_TO_COMMAND_KEYMAP.get(k).format(v)
-
-            if command:
-                commands.append(command)
-        elif k in ['neighbor_policy', 'jp_policy_in', 'jp_policy_out',
-                   'neighbor_type']:
-            if k in ['neighbor_policy', 'neighbor_type']:
-                temp = delta.get('neighbor_policy') or existing.get(
-                    'neighbor_policy')
-                if delta.get('neighbor_type') == 'prefix':
-                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)
-                elif delta.get('neighbor_type') == 'routemap':
-                    command = 'ip pim neighbor-policy {0}'.format(temp)
-                elif existing.get('neighbor_type') == 'prefix':
-                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)
-                elif existing.get('neighbor_type') == 'routemap':
-                    command = 'ip pim neighbor-policy {0}'.format(temp)
-            elif k in ['jp_policy_in', 'jp_type_in']:
-                temp = delta.get('jp_policy_in') or existing.get(
-                    'jp_policy_in')
-                if delta.get('jp_type_in') == 'prefix':
-                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)
-                elif delta.get('jp_type_in') == 'routemap':
-                    command = 'ip pim jp-policy {0} in'.format(temp)
-                elif existing.get('jp_type_in') == 'prefix':
-                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)
-                elif existing.get('jp_type_in') == 'routemap':
-                    command = 'ip pim jp-policy {0} in'.format(temp)
-            elif k in ['jp_policy_out', 'jp_type_out']:
-                temp = delta.get('jp_policy_out') or existing.get(
-                    'jp_policy_out')
-                if delta.get('jp_type_out') == 'prefix':
-                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)
-                elif delta.get('jp_type_out') == 'routemap':
-                    command = 'ip pim jp-policy {0} out'.format(temp)
-                elif existing.get('jp_type_out') == 'prefix':
-                    command = PARAM_TO_COMMAND_KEYMAP.get(k).format(temp)
-                elif existing.get('jp_type_out') == 'routemap':
-                    command = 'ip pim jp-policy {0} out'.format(temp)
-            if command:
-                commands.append(command)
-        command = None
-
-    if 'no ip pim sparse-mode' in commands:
-        # sparse is long-running on some platforms, process it last
-        commands.remove('no ip pim sparse-mode')
-        commands.append('no ip pim sparse-mode')
-    return commands
-
-
-def get_pim_interface_defaults():
-
-    args = dict(dr_prio=PARAM_TO_DEFAULT_KEYMAP.get('dr_prio'),
-                bfd=PARAM_TO_DEFAULT_KEYMAP.get('bfd'),
-                border=PARAM_TO_DEFAULT_KEYMAP.get('border'),
-                sparse=PARAM_TO_DEFAULT_KEYMAP.get('sparse'),
-                hello_interval=PARAM_TO_DEFAULT_KEYMAP.get('hello_interval'),
-                hello_auth_key=PARAM_TO_DEFAULT_KEYMAP.get('hello_auth_key'))
-
-    default = dict((param, value) for (param, value) in args.items()
-                   if value is not None)
-
-    return default
-
-
-def default_pim_interface_policies(existing, jp_bidir):
-    commands = []
-
-    if jp_bidir:
-        if existing.get('jp_policy_in') or existing.get('jp_policy_out'):
-            if existing.get('jp_type_in') == 'prefix':
-                command = 'no ip pim jp-policy prefix-list {0}'.format(existing.get('jp_policy_in'))
-        if command:
-            commands.append(command)
-
-    elif not jp_bidir:
-        command = None
-        for k in existing:
-            if k == 'jp_policy_in':
-                if existing.get('jp_policy_in'):
-                    if existing.get('jp_type_in') == 'prefix':
-                        command = 'no ip pim jp-policy prefix-list {0} in'.format(
-                            existing.get('jp_policy_in')
-                        )
-                    else:
-                        command = 'no ip pim jp-policy {0} in'.format(
-                            existing.get('jp_policy_in')
-                        )
-            elif k == 'jp_policy_out':
-                if existing.get('jp_policy_out'):
-                    if existing.get('jp_type_out') == 'prefix':
-                        command = 'no ip pim jp-policy prefix-list {0} out'.format(
-                            existing.get('jp_policy_out')
-                        )
-                    else:
-                        command = 'no ip pim jp-policy {0} out'.format(
-                            existing.get('jp_policy_out')
-                        )
-            if command:
-                commands.append(command)
-            command = None
-
-    if existing.get('neighbor_policy'):
-        command = 'no ip pim neighbor-policy'
-        commands.append(command)
-
-    return commands
-
-
-def config_pim_interface_defaults(existing, jp_bidir, isauth):
-    command = []
-
-    # returns a dict
-    defaults = get_pim_interface_defaults()
-    delta = dict(set(defaults.items()).difference(
-        existing.items()))
-    if delta:
-        # returns a list
-        command = config_pim_interface(delta, existing,
-                                       jp_bidir, isauth)
-    comm = default_pim_interface_policies(existing, jp_bidir)
-    if comm:
-        for each in comm:
-            command.append(each)
-
-    return command
-
-
-def normalize_proposed_values(proposed):
-    keys = proposed.keys()
-    if 'bfd' in keys:
-        # bfd is a tri-state string: enable, disable, default
-        proposed['bfd'] = proposed['bfd'].lower()
-    if 'hello_interval' in keys:
-        proposed['hello_interval'] = str(proposed['hello_interval'] * 1000)
-
-
-def main():
-    argument_spec = dict(
-        interface=dict(type='str', required=True),
-        sparse=dict(type='bool', default=False),
-        dr_prio=dict(type='str'),
-        hello_auth_key=dict(type='str'),
-        hello_interval=dict(type='int'),
-        jp_policy_out=dict(type='str'),
-        jp_policy_in=dict(type='str'),
-        jp_type_out=dict(type='str', choices=['prefix', 'routemap']),
-        jp_type_in=dict(type='str', choices=['prefix', 'routemap']),
-        bfd=dict(type='str', choices=['enable', 'disable', 'default']),
-        border=dict(type='bool', default=False),
-        neighbor_policy=dict(type='str'),
-        neighbor_type=dict(type='str', choices=['prefix', 'routemap']),
-        state=dict(type='str', default='present', choices=['absent', 'default', 'present']),
-    )
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    warnings = list()
-    results = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    state = module.params['state']
-    interface = module.params['interface']
-    jp_type_in = module.params['jp_type_in']
-    jp_type_out = module.params['jp_type_out']
-    jp_policy_in = module.params['jp_policy_in']
-    jp_policy_out = module.params['jp_policy_out']
-    neighbor_policy = module.params['neighbor_policy']
-    neighbor_type = module.params['neighbor_type']
-
-    intf_type = get_interface_type(interface)
-    if get_interface_mode(interface, intf_type, module) == 'layer2':
-        module.fail_json(msg='this module only works on Layer 3 interfaces.')
-
-    if jp_policy_in:
-        if not jp_type_in:
-            module.fail_json(msg='jp_type_in required when using jp_policy_in.')
-    if jp_policy_out:
-        if not jp_type_out:
-            module.fail_json(msg='jp_type_out required when using jp_policy_out.')
-    if neighbor_policy:
-        if not neighbor_type:
-            module.fail_json(msg='neighbor_type required when using neighbor_policy.')
-
-    get_existing = get_pim_interface(module, interface)
-    existing, jp_bidir, isauth = local_existing(get_existing)
-
-    args = PARAM_TO_COMMAND_KEYMAP.keys()
-    proposed = dict((k, v) for k, v in module.params.items()
-                    if v is not None and k in args)
-    normalize_proposed_values(proposed)
-
-    delta = dict(set(proposed.items()).difference(existing.items()))
-
-    commands = []
-    if state == 'present':
-        if delta:
-            command = config_pim_interface(delta, existing, jp_bidir, isauth)
-            if command:
-                commands.append(command)
-    elif state == 'default' or state == 'absent':
-        defaults = config_pim_interface_defaults(existing, jp_bidir, isauth)
-        if defaults:
-            commands.append(defaults)
-
-    if commands:
-        commands.insert(0, ['interface {0}'.format(interface)])
-
-    cmds = flatten_list(commands)
-    if cmds:
-        results['changed'] = True
-        if not module.check_mode:
-            load_config(module, cmds)
-        if 'configure' in cmds:
-            cmds.pop(0)
-
-    results['commands'] = cmds
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_pim_rp_address.py b/lib/ansible/modules/network/nxos/nxos_pim_rp_address.py
deleted file mode 100644
index 03c8813eb4..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_pim_rp_address.py
+++ /dev/null
@@ -1,245 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_pim_rp_address
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages configuration of an PIM static RP address instance.
-description:
-  - Manages configuration of an Protocol Independent Multicast (PIM) static
-    rendezvous point (RP) address instance.
-author: Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - C(state=absent) is currently not supported on all platforms.
-options:
-  rp_address:
-    description:
-      - Configures a Protocol Independent Multicast (PIM) static
-        rendezvous point (RP) address. Valid values are
-        unicast addresses.
-    required: true
-  group_list:
-    description:
-      - Group range for static RP. Valid values are multicast addresses.
-  prefix_list:
-    description:
-      - Prefix list policy for static RP. Valid values are prefix-list
-        policy names.
-  route_map:
-    description:
-      - Route map policy for static RP. Valid values are route-map
-        policy names.
-  bidir:
-    description:
-      - Group range is treated in PIM bidirectional mode.
-    type: bool
-  state:
-    description:
-      - Specify desired state of the resource.
-    required: true
-    default: present
-    choices: ['present','absent','default']
-'''
-EXAMPLES = '''
-- nxos_pim_rp_address:
-    rp_address: "10.1.1.20"
-    state: present
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["router bgp 65535", "vrf test", "router-id 192.0.2.1"]
-'''
-
-
-import re
-
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-
-
-def get_existing(module, args, gl):
-    existing = {}
-    config = str(get_config(module))
-    address = module.params['rp_address']
-
-    pim_address_re = r'ip pim rp-address (?P<value>.*)$'
-    for line in re.findall(pim_address_re, config, re.M):
-
-        values = line.split()
-        if values[0] != address:
-            continue
-        if gl and 'group-list' not in line:
-            continue
-        elif not gl and 'group-list' in line:
-            if '224.0.0.0/4' not in line:  # ignore default group-list
-                continue
-
-        existing['bidir'] = existing.get('bidir') or 'bidir' in line
-        if len(values) > 2:
-            value = values[2]
-            if values[1] == 'route-map':
-                existing['route_map'] = value
-            elif values[1] == 'prefix-list':
-                existing['prefix_list'] = value
-            elif values[1] == 'group-list':
-                if value != '224.0.0.0/4':  # ignore default group-list
-                    existing['group_list'] = value
-
-    return existing
-
-
-def state_present(module, existing, proposed, candidate):
-    address = module.params['rp_address']
-    command = 'ip pim rp-address {0}'.format(address)
-    if module.params['group_list'] and not proposed.get('group_list'):
-        command += ' group-list ' + module.params['group_list']
-    if module.params['prefix_list']:
-        if not proposed.get('prefix_list'):
-            command += ' prefix-list ' + module.params['prefix_list']
-    if module.params['route_map']:
-        if not proposed.get('route_map'):
-            command += ' route-map ' + module.params['route_map']
-    commands = build_command(proposed, command)
-    if commands:
-        candidate.add(commands, parents=[])
-
-
-def build_command(param_dict, command):
-    for param in ['group_list', 'prefix_list', 'route_map']:
-        if param_dict.get(param):
-            command += ' {0} {1}'.format(
-                param.replace('_', '-'), param_dict.get(param))
-    if param_dict.get('bidir'):
-        command += ' bidir'
-    return [command]
-
-
-def state_absent(module, existing, candidate):
-    address = module.params['rp_address']
-
-    commands = []
-    command = 'no ip pim rp-address {0}'.format(address)
-    if module.params['group_list'] == existing.get('group_list'):
-        commands = build_command(existing, command)
-    elif not module.params['group_list']:
-        commands = [command]
-
-    if commands:
-        candidate.add(commands, parents=[])
-
-
-def get_proposed(pargs, existing):
-    proposed = {}
-
-    for key, value in pargs.items():
-        if key != 'rp_address':
-            if str(value).lower() == 'true':
-                value = True
-            elif str(value).lower() == 'false':
-                value = False
-
-            if existing.get(key) != value:
-                proposed[key] = value
-
-    return proposed
-
-
-def main():
-    argument_spec = dict(
-        rp_address=dict(required=True, type='str'),
-        group_list=dict(required=False, type='str'),
-        prefix_list=dict(required=False, type='str'),
-        route_map=dict(required=False, type='str'),
-        bidir=dict(required=False, type='bool'),
-        state=dict(choices=['present', 'absent'], default='present', required=False),
-    )
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           mutually_exclusive=[['group_list', 'route_map'],
-                                               ['group_list', 'prefix_list'],
-                                               ['route_map', 'prefix_list']],
-                           supports_check_mode=True)
-
-    warnings = list()
-    result = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    state = module.params['state']
-
-    args = [
-        'rp_address',
-        'group_list',
-        'prefix_list',
-        'route_map',
-        'bidir'
-    ]
-
-    proposed_args = dict((k, v) for k, v in module.params.items()
-                         if v is not None and k in args)
-
-    if module.params['group_list']:
-        existing = get_existing(module, args, True)
-        proposed = get_proposed(proposed_args, existing)
-
-    else:
-        existing = get_existing(module, args, False)
-        proposed = get_proposed(proposed_args, existing)
-
-    candidate = CustomNetworkConfig(indent=3)
-    if state == 'present' and (proposed or not existing):
-        state_present(module, existing, proposed, candidate)
-    elif state == 'absent' and existing:
-        state_absent(module, existing, candidate)
-
-    if candidate:
-        candidate = candidate.items_text()
-        result['commands'] = candidate
-        result['changed'] = True
-        msgs = load_config(module, candidate, True)
-        if msgs:
-            for item in msgs:
-                if item:
-                    if isinstance(item, dict):
-                        err_str = item['clierror']
-                    else:
-                        err_str = item
-                    if 'No policy was configured' in err_str:
-                        if state == 'absent':
-                            addr = module.params['rp_address']
-                            new_cmd = 'no ip pim rp-address {0}'.format(addr)
-                            load_config(module, new_cmd)
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_ping.py b/lib/ansible/modules/network/nxos/nxos_ping.py
deleted file mode 100644
index 7091b7a9f1..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_ping.py
+++ /dev/null
@@ -1,215 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'community'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_ping
-extends_documentation_fragment: nxos
-version_added: "2.1"
-short_description: Tests reachability using ping from Nexus switch.
-description:
-    - Tests reachability using ping from switch to a remote destination.
-    - For a general purpose network module, see the M(net_ping) module.
-    - For Windows targets, use the M(win_ping) module instead.
-    - For targets running Python, use the M(ping) module instead.
-author:
-    - Jason Edelman (@jedelman8)
-    - Gabriele Gerbino (@GGabriele)
-options:
-    dest:
-        description:
-            - IP address or hostname (resolvable by switch) of remote node.
-        required: true
-    count:
-        description:
-            - Number of packets to send.
-        default: 5
-    source:
-        description:
-            - Source IP Address or hostname (resolvable by switch)
-    vrf:
-        description:
-            - Outgoing VRF.
-    state:
-        description:
-            - Determines if the expected result is success or fail.
-        choices: [ absent, present ]
-        default: present
-notes:
-    - For a general purpose network module, see the M(net_ping) module.
-    - For Windows targets, use the M(win_ping) module instead.
-    - For targets running Python, use the M(ping) module instead.
-'''
-
-EXAMPLES = '''
-- name: Test reachability to 8.8.8.8 using mgmt vrf
-  nxos_ping:
-    dest: 8.8.8.8
-    vrf: management
-    host: 68.170.147.165
-
-- name: Test reachability to a few different public IPs using mgmt vrf
-  nxos_ping:
-    dest: nxos_ping
-    vrf: management
-    host: 68.170.147.165
-  with_items:
-    - 8.8.8.8
-    - 4.4.4.4
-    - 198.6.1.4
-'''
-
-RETURN = '''
-commands:
-    description: Show the command sent
-    returned: always
-    type: list
-    sample: ["ping 8.8.8.8 count 2 vrf management"]
-rtt:
-    description: Show RTT stats
-    returned: always
-    type: dict
-    sample: {"avg": 6.264, "max": 6.564, "min": 5.978}
-packets_rx:
-    description: Packets successfully received
-    returned: always
-    type: int
-    sample: 2
-packets_tx:
-    description: Packets successfully transmitted
-    returned: always
-    type: int
-    sample: 2
-packet_loss:
-    description: Percentage of packets lost
-    returned: always
-    type: str
-    sample: "0.00%"
-'''
-from ansible.module_utils.network.nxos.nxos import run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def get_summary(results_list, reference_point):
-    summary_string = results_list[reference_point + 1]
-    summary_list = summary_string.split(',')
-
-    summary = dict(
-        packets_tx=int(summary_list[0].split('packets')[0].strip()),
-        packets_rx=int(summary_list[1].split('packets')[0].strip()),
-        packet_loss=summary_list[2].split('packet')[0].strip(),
-    )
-
-    if 'bytes from' not in results_list[reference_point - 2]:
-        ping_pass = False
-    else:
-        ping_pass = True
-
-    return summary, ping_pass
-
-
-def get_rtt(results_list, packet_loss, location):
-    rtt = dict(min=None, avg=None, max=None)
-
-    if packet_loss != '100.00%':
-        rtt_string = results_list[location]
-        base = rtt_string.split('=')[1]
-        rtt_list = base.split('/')
-
-        rtt['min'] = float(rtt_list[0].lstrip())
-        rtt['avg'] = float(rtt_list[1])
-        rtt['max'] = float(rtt_list[2][:-3])
-
-    return rtt
-
-
-def get_statistics_summary_line(response_as_list):
-    for each in response_as_list:
-        if '---' in each:
-            index = response_as_list.index(each)
-    return index
-
-
-def get_ping_results(command, module):
-    cmd = {'command': command, 'output': 'text'}
-    ping = run_commands(module, [cmd])[0]
-
-    if not ping:
-        module.fail_json(msg="An unexpected error occurred. Check all params.",
-                         command=command, destination=module.params['dest'],
-                         vrf=module.params['vrf'],
-                         source=module.params['source'])
-
-    elif "can't bind to address" in ping:
-        module.fail_json(msg="Can't bind to source address.", command=command)
-    elif "bad context" in ping:
-        module.fail_json(msg="Wrong VRF name inserted.", command=command,
-                         vrf=module.params['vrf'])
-    else:
-        splitted_ping = ping.split('\n')
-        reference_point = get_statistics_summary_line(splitted_ping)
-        summary, ping_pass = get_summary(splitted_ping, reference_point)
-        rtt = get_rtt(splitted_ping, summary['packet_loss'], reference_point + 2)
-
-    return (summary, rtt, ping_pass)
-
-
-def main():
-    argument_spec = dict(
-        dest=dict(required=True),
-        count=dict(required=False, default=5, type='int'),
-        vrf=dict(required=False),
-        source=dict(required=False),
-        state=dict(required=False, choices=['present', 'absent'], default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    destination = module.params['dest']
-    state = module.params['state']
-
-    ping_command = 'ping {0}'.format(destination)
-    for command in ['count', 'source', 'vrf']:
-        arg = module.params[command]
-        if arg:
-            ping_command += ' {0} {1}'.format(command, arg)
-
-    summary, rtt, ping_pass = get_ping_results(ping_command, module)
-
-    results = summary
-    results['rtt'] = rtt
-    results['commands'] = [ping_command]
-
-    if ping_pass and state == 'absent':
-        module.fail_json(msg="Ping succeeded unexpectedly")
-    elif not ping_pass and state == 'present':
-        module.fail_json(msg="Ping failed unexpectedly")
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_reboot.py b/lib/ansible/modules/network/nxos/nxos_reboot.py
deleted file mode 100644
index 05803c735a..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_reboot.py
+++ /dev/null
@@ -1,92 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_reboot
-extends_documentation_fragment: nxos
-version_added: 2.2
-short_description: Reboot a network device.
-description:
-    - Reboot a network device.
-author:
-    - Jason Edelman (@jedelman8)
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - The module will fail due to timeout issues, but the reboot will be
-      performed anyway.
-options:
-    confirm:
-        description:
-            - Safeguard boolean. Set to true if you're sure you want to reboot.
-        required: false
-        default: false
-        type: bool
-'''
-
-EXAMPLES = '''
-- nxos_reboot:
-    confirm: true
-'''
-
-RETURN = '''
-rebooted:
-    description: Whether the device was instructed to reboot.
-    returned: success
-    type: bool
-    sample: true
-'''
-
-from ansible.module_utils.network.nxos.nxos import load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def reboot(module):
-    cmds = 'terminal dont-ask ; reload'
-    opts = {'ignore_timeout': True}
-    load_config(module, cmds, False, opts)
-
-
-def main():
-    argument_spec = dict(
-        confirm=dict(default=False, type='bool')
-    )
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    warnings = list()
-    results = dict(changed=False, warnings=warnings)
-
-    if module.params['confirm']:
-        if not module.check_mode:
-            reboot(module)
-        results['changed'] = True
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_rollback.py b/lib/ansible/modules/network/nxos/nxos_rollback.py
deleted file mode 100644
index 31db1bde62..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_rollback.py
+++ /dev/null
@@ -1,133 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_rollback
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Set a checkpoint or rollback to a checkpoint.
-description:
-    - This module offers the ability to set a configuration checkpoint
-      file or rollback to a configuration checkpoint file on Cisco NXOS
-      switches.
-author:
-    - Jason Edelman (@jedelman8)
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - Sometimes C(transport=nxapi) may cause a timeout error.
-options:
-    checkpoint_file:
-        description:
-            - Name of checkpoint file to create. Mutually exclusive
-              with rollback_to.
-    rollback_to:
-        description:
-            - Name of checkpoint file to rollback to. Mutually exclusive
-              with checkpoint_file.
-'''
-
-EXAMPLES = '''
-- nxos_rollback:
-    checkpoint_file: backup.cfg
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-    host: "{{ inventory_hostname }}"
-- nxos_rollback:
-    rollback_to: backup.cfg
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-    host: "{{ inventory_hostname }}"
-'''
-
-RETURN = '''
-filename:
-    description: The filename of the checkpoint/rollback file.
-    returned: success
-    type: str
-    sample: 'backup.cfg'
-status:
-    description: Which operation took place and whether it was successful.
-    returned: success
-    type: str
-    sample: 'rollback executed'
-'''
-
-
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec, run_commands
-from ansible.module_utils.basic import AnsibleModule
-
-
-def checkpoint(filename, module):
-    commands = [{
-        'command': 'terminal dont-ask',
-        'output': 'text', }, {
-        'command': 'checkpoint file %s' % filename,
-        'output': 'text',
-    }]
-    run_commands(module, commands)
-
-
-def rollback(filename, module):
-    commands = [{
-        'command': 'rollback running-config file %s' % filename,
-        'output': 'text',
-    }]
-    run_commands(module, commands)
-
-
-def main():
-    argument_spec = dict(
-        checkpoint_file=dict(required=False),
-        rollback_to=dict(required=False)
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           mutually_exclusive=[['checkpoint_file',
-                                                'rollback_to']],
-                           supports_check_mode=False)
-
-    checkpoint_file = module.params['checkpoint_file']
-    rollback_to = module.params['rollback_to']
-
-    status = None
-    filename = None
-    changed = False
-
-    if checkpoint_file:
-        checkpoint(checkpoint_file, module)
-        status = 'checkpoint file created'
-    elif rollback_to:
-        rollback(rollback_to, module)
-        status = 'rollback executed'
-    changed = True
-    filename = rollback_to or checkpoint_file
-
-    module.exit_json(changed=changed, status=status, filename=filename)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_rpm.py b/lib/ansible/modules/network/nxos/nxos_rpm.py
deleted file mode 100644
index a33a8ca612..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_rpm.py
+++ /dev/null
@@ -1,351 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_rpm
-extends_documentation_fragment: nxos
-version_added: "2.7"
-short_description: Install patch or feature rpms on Cisco NX-OS devices.
-description:
-    - Install software maintenance upgrade (smu) RPMS and
-      3rd party RPMS on Cisco NX-OS devices.
-author: Sai Chintalapudi (@saichint)
-notes:
-    - Tested against NXOSv 7.0(3)I2(5), 7.0(3)I4(6), 7.0(3)I5(3),
-      7.0(3)I6(1), 7.0(3)I7(3)
-    - For patches, the minimum platform version needed is 7.0(3)I2(5)
-    - For feature rpms, the minimum platform version needed is 7.0(3)I6(1)
-    - The module manages the entire RPM lifecycle (Add, activate, commit, deactivate, remove)
-    - For reload patches, this module is NOT idempotent until the patch is
-      committed.
-options:
-    pkg:
-        description:
-            - Name of the RPM package.
-        required: true
-    file_system:
-        description:
-            - The remote file system of the device. If omitted,
-              devices that support a file_system parameter will use
-              their default values.
-        default: bootflash
-    aggregate:
-        description:
-            - List of RPM/patch definitions.
-    state:
-        description:
-            - If the state is present, the rpm will be installed,
-              If the state is absent, it will be removed.
-        default: present
-        choices: ['present', 'absent']
-'''
-
-EXAMPLES = '''
-- nxos_rpm:
-    pkg: "nxos.sample-n9k_ALL-1.0.0-7.0.3.I7.3.lib32_n9000.rpm"
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["install add bootflash:nxos.sample-n9k_ALL-1.0.0-7.0.3.I7.3.lib32_n9000.rpm forced",
-             "install activate nxos.sample-n9k_ALL-1.0.0-7.0.3.I7.3.lib32_n9000 forced",
-             "install commit nxos.sample-n9k_ALL-1.0.0-7.0.3.I7.3.lib32_n9000"]
-'''
-
-
-import time
-
-from copy import deepcopy
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.utils import remove_default_spec
-
-
-def execute_show_command(command, module):
-    iteration = 0
-    cmds = [{
-        'command': command,
-        'output': 'text',
-    }]
-
-    while iteration < 10:
-        body = run_commands(module, cmds)[0]
-        if body:
-            return body
-        else:
-            time.sleep(2)
-            iteration += 1
-
-
-def remote_file_exists(module, dst, file_system):
-    command = 'dir {0}:/{1}'.format(file_system, dst)
-    body = execute_show_command(command, module)
-    if 'No such file' in body:
-        return False
-    return True
-
-
-def config_cmd_operation(module, cmd):
-    iteration = 0
-    while iteration < 10:
-        msg = load_config(module, [cmd], True)
-        if msg:
-            if 'another install operation is in progress' in msg[0].lower() or 'failed' in msg[0].lower():
-                time.sleep(2)
-                iteration += 1
-            else:
-                return
-        else:
-            return
-
-
-def validate_operation(module, show_cmd, cfg_cmd, pkg, pkg_not_present):
-    iteration = 0
-    while iteration < 10:
-        body = execute_show_command(show_cmd, module)
-        if pkg_not_present:
-            if pkg not in body:
-                return
-        else:
-            if pkg in body:
-                return
-        time.sleep(2)
-        iteration += 1
-
-    err = 'Operation "{0}" Failed'.format(cfg_cmd)
-    module.fail_json(msg=err)
-
-
-def add_operation(module, show_cmd, file_system, full_pkg, pkg):
-    cmd = 'install add {0}:{1}'.format(file_system, full_pkg)
-    config_cmd_operation(module, cmd)
-    validate_operation(module, show_cmd, cmd, pkg, False)
-    return cmd
-
-
-def activate_operation(module, show_cmd, pkg):
-    cmd = 'install activate {0} forced'.format(pkg)
-    config_cmd_operation(module, cmd)
-    validate_operation(module, show_cmd, cmd, pkg, False)
-    return cmd
-
-
-def activate_reload(module, pkg, flag):
-    iteration = 0
-    if flag:
-        cmd = 'install activate {0} forced'.format(pkg)
-    else:
-        cmd = 'install deactivate {0} forced'.format(pkg)
-    opts = {'ignore_timeout': True}
-    while iteration < 10:
-        msg = load_config(module, [cmd], True, opts)
-        if msg:
-            if isinstance(msg[0], int):
-                if msg[0] == -32603:
-                    return cmd
-            elif isinstance(msg[0], str):
-                if 'another install operation is in progress' in msg[0].lower() or 'failed' in msg[0].lower():
-                    time.sleep(2)
-                    iteration += 1
-
-
-def commit_operation(module, show_cmd, pkg):
-    cmd = 'install commit {0}'.format(pkg)
-    config_cmd_operation(module, cmd)
-    validate_operation(module, show_cmd, cmd, pkg, False)
-    return cmd
-
-
-def deactivate_operation(module, show_cmd, pkg, flag):
-    cmd = 'install deactivate {0} forced'.format(pkg)
-    config_cmd_operation(module, cmd)
-    validate_operation(module, show_cmd, cmd, pkg, flag)
-    return cmd
-
-
-def remove_operation(module, show_cmd, pkg):
-    cmd = 'install remove {0} forced'.format(pkg)
-    config_cmd_operation(module, cmd)
-    validate_operation(module, show_cmd, cmd, pkg, True)
-    return cmd
-
-
-def install_remove_rpm(module, full_pkg, file_system, state):
-    commands = []
-    reload_patch = False
-
-    splitted_pkg = full_pkg.split('.')
-    pkg = '.'.join(splitted_pkg[0:-1])
-
-    show_inactive = 'show install inactive'
-    show_active = 'show install active'
-    show_commit = 'show install committed'
-    show_patches = 'show install patches'
-    show_pkg_info = 'show install pkg-info {0}'.format(pkg)
-
-    if state == 'present':
-        inactive_body = execute_show_command(show_inactive, module)
-        active_body = execute_show_command(show_active, module)
-
-        if pkg not in inactive_body and pkg not in active_body:
-            commands.append(add_operation(module, show_inactive, file_system, full_pkg, pkg))
-
-        patch_type_body = execute_show_command(show_pkg_info, module)
-        if patch_type_body and 'Patch Type    :  reload' in patch_type_body:
-            # This is reload smu/patch rpm
-            reload_patch = True
-
-        if pkg not in active_body:
-            if reload_patch:
-                commands.append(activate_reload(module, pkg, True))
-                return commands
-            else:
-                commands.append(activate_operation(module, show_active, pkg))
-
-        commit_body = execute_show_command(show_commit, module)
-        if pkg not in commit_body:
-            patch_body = execute_show_command(show_patches, module)
-            if pkg in patch_body:
-                # This is smu/patch rpm
-                commands.append(commit_operation(module, show_active, pkg))
-            else:
-                err = 'Operation "install activate {0} forced" Failed'.format(pkg)
-                module.fail_json(msg=err)
-
-    else:
-        commit_body = execute_show_command(show_commit, module)
-        active_body = execute_show_command(show_active, module)
-
-        patch_type_body = execute_show_command(show_pkg_info, module)
-        if patch_type_body and 'Patch Type    :  reload' in patch_type_body:
-            # This is reload smu/patch rpm
-            reload_patch = True
-
-        if pkg in commit_body and pkg in active_body:
-            if reload_patch:
-                commands.append(activate_reload(module, pkg, False))
-                return commands
-            else:
-                commands.append(deactivate_operation(module, show_active, pkg, True))
-                commit_body = execute_show_command(show_commit, module)
-                if pkg in commit_body:
-                    # This is smu/patch rpm
-                    commands.append(commit_operation(module, show_inactive, pkg))
-                commands.append(remove_operation(module, show_inactive, pkg))
-
-        elif pkg in commit_body:
-            # This is smu/patch rpm
-            commands.append(commit_operation(module, show_inactive, pkg))
-            commands.append(remove_operation(module, show_inactive, pkg))
-
-        elif pkg in active_body:
-            # This is smu/patch rpm
-            if reload_patch:
-                commands.append(activate_reload(module, pkg, False))
-                return commands
-            else:
-                commands.append(deactivate_operation(module, show_inactive, pkg, False))
-                commands.append(remove_operation(module, show_inactive, pkg))
-
-        else:
-            inactive_body = execute_show_command(show_inactive, module)
-            if pkg in inactive_body:
-                commands.append(remove_operation(module, show_inactive, pkg))
-
-    return commands
-
-
-def main():
-    element_spec = dict(
-        pkg=dict(type='str'),
-        file_system=dict(type='str', default='bootflash'),
-        state=dict(choices=['absent', 'present'], default='present')
-    )
-
-    aggregate_spec = deepcopy(element_spec)
-    aggregate_spec['pkg'] = dict(required=True)
-
-    # remove default in aggregate spec, to handle common arguments
-    remove_default_spec(aggregate_spec)
-
-    argument_spec = dict(
-        aggregate=dict(type='list', elements='dict', options=aggregate_spec)
-    )
-
-    argument_spec.update(element_spec)
-    argument_spec.update(nxos_argument_spec)
-
-    required_one_of = [['pkg', 'aggregate']]
-    mutually_exclusive = [['pkg', 'aggregate']]
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           required_one_of=required_one_of,
-                           mutually_exclusive=mutually_exclusive,
-                           supports_check_mode=False)
-
-    warnings = list()
-    results = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    aggregate = module.params.get('aggregate')
-    objects = []
-    if aggregate:
-        for item in aggregate:
-            for key in item:
-                if item.get(key) is None:
-                    item[key] = module.params[key]
-
-            d = item.copy()
-            objects.append(d)
-    else:
-        objects.append({
-            'pkg': module.params['pkg'],
-            'file_system': module.params['file_system'],
-            'state': module.params['state']
-        })
-
-    for obj in objects:
-        if obj['state'] == 'present':
-            remote_exists = remote_file_exists(module, obj['pkg'], file_system=obj['file_system'])
-
-            if not remote_exists:
-                module.fail_json(
-                    msg="The requested package doesn't exist on the device"
-                )
-
-        cmds = install_remove_rpm(module, obj['pkg'], obj['file_system'], obj['state'])
-
-        if cmds:
-            results['changed'] = True
-            results['commands'].extend(cmds)
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_smu.py b/lib/ansible/modules/network/nxos/nxos_smu.py
deleted file mode 100644
index 7859a6c194..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_smu.py
+++ /dev/null
@@ -1,157 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_smu
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Perform SMUs on Cisco NX-OS devices.
-description:
-    - Perform software maintenance upgrades (SMUs) on Cisco NX-OS devices.
-author: Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - The module can only activate and commit a package,
-      not remove or deactivate it.
-    - Use C(transport=nxapi) to avoid connection timeout
-options:
-    pkg:
-        description:
-            - Name of the remote package.
-        required: true
-    file_system:
-        description:
-            - The remote file system of the device. If omitted,
-              devices that support a file_system parameter will use
-              their default values.
-'''
-
-EXAMPLES = '''
-- nxos_smu:
-    pkg: "nxos.CSCuz65185-n9k_EOR-1.0.0-7.0.3.I2.2d.lib32_n9000.rpm"
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["install add bootflash:nxos.CSCuz65185-n9k_EOR-1.0.0-7.0.3.I2.2d.lib32_n9000.rpm",
-             "install activate bootflash:nxos.CSCuz65185-n9k_EOR-1.0.0-7.0.3.I2.2d.lib32_n9000.rpm force",
-             "install commit bootflash:nxos.CSCuz65185-n9k_EOR-1.0.0-7.0.3.I2.2d.lib32_n9000.rpm"]
-'''
-
-
-import time
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def execute_show_command(command, module):
-    cmds = [{
-        'command': command,
-        'output': 'text',
-    }]
-
-    return run_commands(module, cmds)
-
-
-def remote_file_exists(module, dst, file_system='bootflash:'):
-    command = 'dir {0}/{1}'.format(file_system, dst)
-    body = execute_show_command(command, module)
-    if 'No such file' in body[0]:
-        return False
-    return True
-
-
-def apply_patch(module, commands):
-    for command in commands:
-        load_config(module, [command])
-        time.sleep(5)
-
-
-def get_commands(module, pkg, file_system):
-    commands = []
-    splitted_pkg = pkg.split('.')
-    fixed_pkg = '.'.join(splitted_pkg[0:-1])
-
-    command = 'show install inactive'
-    inactive_body = execute_show_command(command, module)
-
-    command = 'show install active'
-    active_body = execute_show_command(command, module)
-
-    if fixed_pkg not in inactive_body[0] and fixed_pkg not in active_body[0]:
-        commands.append('install add {0}{1}'.format(file_system, pkg))
-
-    if fixed_pkg not in active_body[0]:
-        commands.append('install activate {0}{1} force'.format(
-            file_system, pkg))
-    command = 'show install committed'
-    install_body = execute_show_command(command, module)
-    if fixed_pkg not in install_body[0]:
-        commands.append('install commit {0}{1}'.format(file_system, pkg))
-
-    return commands
-
-
-def main():
-    argument_spec = dict(
-        pkg=dict(required=True),
-        file_system=dict(required=False, default='bootflash:'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-    results = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    pkg = module.params['pkg']
-    file_system = module.params['file_system']
-    remote_exists = remote_file_exists(module, pkg, file_system=file_system)
-
-    if not remote_exists:
-        module.fail_json(
-            msg="The requested package doesn't exist on the device"
-        )
-
-    commands = get_commands(module, pkg, file_system)
-    if commands:
-        results['changed'] = True
-        if not module.check_mode:
-            apply_patch(module, commands)
-        if 'configure' in commands:
-            commands.pop(0)
-        results['commands'] = commands
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_snapshot.py b/lib/ansible/modules/network/nxos/nxos_snapshot.py
deleted file mode 100644
index e1ca5ad75d..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_snapshot.py
+++ /dev/null
@@ -1,366 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_snapshot
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manage snapshots of the running states of selected features.
-description:
-    - Create snapshots of the running states of selected features, add
-      new show commands for snapshot creation, delete and compare
-      existing snapshots.
-author:
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - C(transport=cli) may cause timeout errors.
-    - The C(element_key1) and C(element_key2) parameter specify the tags used
-      to distinguish among row entries. In most cases, only the element_key1
-      parameter needs to specified to be able to distinguish among row entries.
-    - C(action=compare) will always store a comparison report on a local file.
-options:
-    action:
-        description:
-            - Define what snapshot action the module would perform.
-        required: true
-        choices: [ add, compare, create, delete, delete_all ]
-    snapshot_name:
-        description:
-            - Snapshot name, to be used when C(action=create)
-              or C(action=delete).
-    description:
-        description:
-            - Snapshot description to be used when C(action=create).
-    snapshot1:
-        description:
-            - First snapshot to be used when C(action=compare).
-    snapshot2:
-        description:
-            - Second snapshot to be used when C(action=compare).
-    comparison_results_file:
-        description:
-            - Name of the file where snapshots comparison will be stored when C(action=compare).
-    compare_option:
-        description:
-            - Snapshot options to be used when C(action=compare).
-        choices: ['summary','ipv4routes','ipv6routes']
-    section:
-        description:
-            - Used to name the show command output, to be used
-              when C(action=add).
-    show_command:
-        description:
-            - Specify a new show command, to be used when C(action=add).
-    row_id:
-        description:
-            - Specifies the tag of each row entry of the show command's
-              XML output, to be used when C(action=add).
-    element_key1:
-        description:
-            - Specify the tags used to distinguish among row entries,
-              to be used when C(action=add).
-    element_key2:
-        description:
-            - Specify the tags used to distinguish among row entries,
-              to be used when C(action=add).
-    save_snapshot_locally:
-        description:
-            - Specify to locally store a new created snapshot,
-              to be used when C(action=create).
-        type: bool
-        default: 'no'
-    path:
-        description:
-            - Specify the path of the file where new created snapshot or
-              snapshots comparison will be stored, to be used when
-              C(action=create) and C(save_snapshot_locally=true) or
-              C(action=compare).
-        default: './'
-'''
-
-EXAMPLES = '''
-# Create a snapshot and store it locally
-- nxos_snapshot:
-    action: create
-    snapshot_name: test_snapshot
-    description: Done with Ansible
-    save_snapshot_locally: true
-    path: /home/user/snapshots/
-
-# Delete a snapshot
-- nxos_snapshot:
-    action: delete
-    snapshot_name: test_snapshot
-
-# Delete all existing snapshots
-- nxos_snapshot:
-    action: delete_all
-
-# Add a show command for snapshots creation
-- nxos_snapshot:
-    section: myshow
-    show_command: show ip interface brief
-    row_id: ROW_intf
-    element_key1: intf-name
-
-# Compare two snapshots
-- nxos_snapshot:
-    action: compare
-    snapshot1: pre_snapshot
-    snapshot2: post_snapshot
-    comparison_results_file: compare_snapshots.txt
-    compare_option: summary
-    path: '../snapshot_reports/'
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: verbose mode
-    type: list
-    sample: ["snapshot create post_snapshot Post-snapshot"]
-'''
-
-import os
-import re
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-
-
-def execute_show_command(command, module):
-    command = [{
-        'command': command,
-        'output': 'text',
-    }]
-
-    return run_commands(module, command)
-
-
-def get_existing(module):
-    existing = []
-    command = 'show snapshots'
-
-    body = execute_show_command(command, module)[0]
-    if body:
-        split_body = body.splitlines()
-        snapshot_regex = (r'(?P<name>\S+)\s+(?P<date>\w+\s+\w+\s+\d+\s+\d+'
-                          r':\d+:\d+\s+\d+)\s+(?P<description>.*)')
-        for snapshot in split_body:
-            temp = {}
-            try:
-                match_snapshot = re.match(snapshot_regex, snapshot, re.DOTALL)
-                snapshot_group = match_snapshot.groupdict()
-                temp['name'] = snapshot_group['name']
-                temp['date'] = snapshot_group['date']
-                temp['description'] = snapshot_group['description']
-                existing.append(temp)
-            except AttributeError:
-                pass
-
-    return existing
-
-
-def action_create(module, existing_snapshots):
-    commands = list()
-    exist = False
-    for snapshot in existing_snapshots:
-        if module.params['snapshot_name'] == snapshot['name']:
-            exist = True
-
-    if exist is False:
-        commands.append('snapshot create {0} {1}'.format(
-            module.params['snapshot_name'], module.params['description']))
-
-    return commands
-
-
-def action_add(module, existing_snapshots):
-    commands = list()
-    command = 'show snapshot sections'
-    sections = []
-    body = execute_show_command(command, module)[0]
-
-    if body:
-        section_regex = r'.*\[(?P<section>\S+)\].*'
-        split_body = body.split('\n\n')
-        for section in split_body:
-            temp = {}
-            for line in section.splitlines():
-                try:
-                    match_section = re.match(section_regex, section, re.DOTALL)
-                    temp['section'] = match_section.groupdict()['section']
-                except (AttributeError, KeyError):
-                    pass
-
-                if 'show command' in line:
-                    temp['show_command'] = line.split('show command: ')[1]
-                elif 'row id' in line:
-                    temp['row_id'] = line.split('row id: ')[1]
-                elif 'key1' in line:
-                    temp['element_key1'] = line.split('key1: ')[1]
-                elif 'key2' in line:
-                    temp['element_key2'] = line.split('key2: ')[1]
-
-            if temp:
-                sections.append(temp)
-
-    proposed = {
-        'section': module.params['section'],
-        'show_command': module.params['show_command'],
-        'row_id': module.params['row_id'],
-        'element_key1': module.params['element_key1'],
-        'element_key2': module.params['element_key2'] or '-',
-    }
-
-    if proposed not in sections:
-        if module.params['element_key2']:
-            commands.append('snapshot section add {0} "{1}" {2} {3} {4}'.format(
-                module.params['section'], module.params['show_command'],
-                module.params['row_id'], module.params['element_key1'],
-                module.params['element_key2']))
-        else:
-            commands.append('snapshot section add {0} "{1}" {2} {3}'.format(
-                module.params['section'], module.params['show_command'],
-                module.params['row_id'], module.params['element_key1']))
-
-    return commands
-
-
-def action_compare(module, existing_snapshots):
-    command = 'show snapshot compare {0} {1}'.format(
-        module.params['snapshot1'], module.params['snapshot2'])
-
-    if module.params['compare_option']:
-        command += ' {0}'.format(module.params['compare_option'])
-
-    body = execute_show_command(command, module)[0]
-    return body
-
-
-def action_delete(module, existing_snapshots):
-    commands = list()
-
-    exist = False
-    for snapshot in existing_snapshots:
-        if module.params['snapshot_name'] == snapshot['name']:
-            exist = True
-
-    if exist:
-        commands.append('snapshot delete {0}'.format(
-            module.params['snapshot_name']))
-
-    return commands
-
-
-def action_delete_all(module, existing_snapshots):
-    commands = list()
-    if existing_snapshots:
-        commands.append('snapshot delete all')
-    return commands
-
-
-def invoke(name, *args, **kwargs):
-    func = globals().get(name)
-    if func:
-        return func(*args, **kwargs)
-
-
-def write_on_file(content, filename, module):
-    path = module.params['path']
-    if path[-1] != '/':
-        path += '/'
-    filepath = '{0}{1}'.format(path, filename)
-    try:
-        report = open(filepath, 'w')
-        report.write(content)
-        report.close()
-    except Exception:
-        module.fail_json(msg="Error while writing on file.")
-
-    return filepath
-
-
-def main():
-    argument_spec = dict(
-        action=dict(required=True, choices=['create', 'add', 'compare', 'delete', 'delete_all']),
-        snapshot_name=dict(type='str'),
-        description=dict(type='str'),
-        snapshot1=dict(type='str'),
-        snapshot2=dict(type='str'),
-        compare_option=dict(choices=['summary', 'ipv4routes', 'ipv6routes']),
-        comparison_results_file=dict(type='str'),
-        section=dict(type='str'),
-        show_command=dict(type='str'),
-        row_id=dict(type='str'),
-        element_key1=dict(type='str'),
-        element_key2=dict(type='str'),
-        save_snapshot_locally=dict(type='bool', default=False),
-        path=dict(type='str', default='./')
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    required_if = [("action", "compare", ["snapshot1", "snapshot2", "comparison_results_file"]),
-                   ("action", "create", ["snapshot_name", "description"]),
-                   ("action", "add", ["section", "show_command", "row_id", "element_key1"]),
-                   ("action", "delete", ["snapshot_name"])]
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           required_if=required_if,
-                           supports_check_mode=True)
-
-    action = module.params['action']
-    comparison_results_file = module.params['comparison_results_file']
-
-    if not os.path.isdir(module.params['path']):
-        module.fail_json(msg='{0} is not a valid directory name.'.format(
-            module.params['path']))
-
-    existing_snapshots = invoke('get_existing', module)
-    action_results = invoke('action_%s' % action, module, existing_snapshots)
-
-    result = {'changed': False, 'commands': []}
-
-    if not module.check_mode:
-        if action == 'compare':
-            result['commands'] = []
-
-            if module.params['path'] and comparison_results_file:
-                snapshot1 = module.params['snapshot1']
-                snapshot2 = module.params['snapshot2']
-                compare_option = module.params['compare_option']
-                command = 'show snapshot compare {0} {1}'.format(snapshot1, snapshot2)
-                if compare_option:
-                    command += ' {0}'.format(compare_option)
-                content = execute_show_command(command, module)[0]
-                if content:
-                    write_on_file(content, comparison_results_file, module)
-        else:
-            if action_results:
-                load_config(module, action_results)
-                result['commands'] = action_results
-                result['changed'] = True
-
-            if action == 'create' and module.params['path'] and module.params['save_snapshot_locally']:
-                command = 'show snapshot dump {0} | json'.format(module.params['snapshot_name'])
-                content = execute_show_command(command, module)[0]
-                if content:
-                    write_on_file(str(content), module.params['snapshot_name'], module)
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_snmp_community.py b/lib/ansible/modules/network/nxos/nxos_snmp_community.py
deleted file mode 100644
index 37ea59ce91..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_snmp_community.py
+++ /dev/null
@@ -1,239 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_snmp_community
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages SNMP community configs.
-description:
-    - Manages SNMP community configuration.
-author:
-    - Jason Edelman (@jedelman8)
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-options:
-    community:
-        description:
-            - Case-sensitive community string.
-        required: true
-    access:
-        description:
-            - Access type for community.
-        choices: ['ro','rw']
-    group:
-        description:
-            - Group to which the community belongs.
-    acl:
-        description:
-            - ACL name to filter snmp requests or keyword 'default'.
-    state:
-        description:
-            - Manage the state of the resource.
-        default: present
-        choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-# ensure snmp community is configured
-- nxos_snmp_community:
-    community: TESTING7
-    group: network-operator
-    state: present
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["snmp-server community TESTING7 group network-operator"]
-'''
-
-import re
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def execute_show_command(command, module):
-    if 'show run' not in command:
-        output = 'json'
-    else:
-        output = 'text'
-    cmds = [{
-        'command': command,
-        'output': output,
-    }]
-
-    body = run_commands(module, cmds)
-    return body
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_snmp_groups(module):
-    data = execute_show_command('show snmp group', module)[0]
-    group_list = []
-
-    try:
-        group_table = data['TABLE_role']['ROW_role']
-        for group in group_table:
-            group_list.append(group['role_name'])
-    except (KeyError, AttributeError):
-        pass
-
-    return group_list
-
-
-def get_snmp_community(module, name):
-    command = 'show run snmp all | grep {0}'.format(name)
-    data = execute_show_command(command, module)[0]
-    community_dict = {}
-
-    if not data:
-        return community_dict
-
-    community_re = r'snmp-server community (\S+)'
-    mo = re.search(community_re, data)
-    if mo:
-        community_name = mo.group(1)
-    else:
-        return community_dict
-
-    community_dict['group'] = None
-    group_re = r'snmp-server community {0} group (\S+)'.format(community_name)
-    mo = re.search(group_re, data)
-    if mo:
-        community_dict['group'] = mo.group(1)
-
-    community_dict['acl'] = None
-    acl_re = r'snmp-server community {0} use-acl (\S+)'.format(community_name)
-    mo = re.search(acl_re, data)
-    if mo:
-        community_dict['acl'] = mo.group(1)
-
-    return community_dict
-
-
-def config_snmp_community(delta, community):
-    CMDS = {
-        'group': 'snmp-server community {0} group {group}',
-        'acl': 'snmp-server community {0} use-acl {acl}',
-        'no_acl': 'no snmp-server community {0} use-acl {no_acl}'
-    }
-    commands = []
-    for k in delta.keys():
-        cmd = CMDS.get(k).format(community, **delta)
-        if cmd:
-            if 'group' in cmd:
-                commands.insert(0, cmd)
-            else:
-                commands.append(cmd)
-            cmd = None
-    return commands
-
-
-def main():
-    argument_spec = dict(
-        community=dict(required=True, type='str'),
-        access=dict(choices=['ro', 'rw']),
-        group=dict(type='str'),
-        acl=dict(type='str'),
-        state=dict(choices=['absent', 'present'], default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           required_one_of=[['access', 'group']],
-                           mutually_exclusive=[['access', 'group']],
-                           supports_check_mode=True)
-
-    warnings = list()
-    results = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    access = module.params['access']
-    group = module.params['group']
-    community = module.params['community']
-    acl = module.params['acl']
-    state = module.params['state']
-
-    if access:
-        if access == 'ro':
-            group = 'network-operator'
-        elif access == 'rw':
-            group = 'network-admin'
-
-    # group check - ensure group being configured exists on the device
-    configured_groups = get_snmp_groups(module)
-
-    if group not in configured_groups:
-        module.fail_json(msg="Group not on switch. Please add before moving forward")
-
-    existing = get_snmp_community(module, community)
-    args = dict(group=group, acl=acl)
-    proposed = dict((k, v) for k, v in args.items() if v is not None)
-    delta = dict(set(proposed.items()).difference(existing.items()))
-    if delta.get('acl') == 'default':
-        delta.pop('acl')
-        if existing.get('acl'):
-            delta['no_acl'] = existing.get('acl')
-
-    commands = []
-
-    if state == 'absent':
-        if existing:
-            command = "no snmp-server community {0}".format(community)
-            commands.append(command)
-    elif state == 'present':
-        if delta:
-            command = config_snmp_community(dict(delta), community)
-            commands.append(command)
-
-    cmds = flatten_list(commands)
-
-    if cmds:
-        results['changed'] = True
-        if not module.check_mode:
-            load_config(module, cmds)
-
-        if 'configure' in cmds:
-            cmds.pop(0)
-        results['commands'] = cmds
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_snmp_contact.py b/lib/ansible/modules/network/nxos/nxos_snmp_contact.py
deleted file mode 100644
index 409d8cb9ce..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_snmp_contact.py
+++ /dev/null
@@ -1,145 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_snmp_contact
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages SNMP contact info.
-description:
-    - Manages SNMP contact information.
-author:
-    - Jason Edelman (@jedelman8)
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - C(state=absent) removes the contact configuration if it is configured.
-options:
-    contact:
-        description:
-            - Contact information.
-        required: true
-    state:
-        description:
-            - Manage the state of the resource.
-        required: true
-        default: present
-        choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-# ensure snmp contact is configured
-- nxos_snmp_contact:
-    contact: Test
-    state: present
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["snmp-server contact New_Test"]
-'''
-
-
-import re
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def execute_show_command(command, module):
-    command = {
-        'command': command,
-        'output': 'text',
-    }
-
-    return run_commands(module, command)
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_snmp_contact(module):
-    contact = {}
-    contact_regex = r'^\s*snmp-server\scontact\s(?P<contact>.+)$'
-
-    body = execute_show_command('show run snmp', module)[0]
-    match_contact = re.search(contact_regex, body, re.M)
-    if match_contact:
-        contact['contact'] = match_contact.group("contact")
-
-    return contact
-
-
-def main():
-    argument_spec = dict(
-        contact=dict(required=True, type='str'),
-        state=dict(choices=['absent', 'present'], default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    warnings = list()
-    results = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    contact = module.params['contact']
-    state = module.params['state']
-
-    existing = get_snmp_contact(module)
-    commands = []
-
-    if state == 'absent':
-        if existing and existing['contact'] == contact:
-            commands.append('no snmp-server contact')
-    elif state == 'present':
-        if not existing or existing['contact'] != contact:
-            commands.append('snmp-server contact {0}'.format(contact))
-
-    cmds = flatten_list(commands)
-    if cmds:
-        results['changed'] = True
-        if not module.check_mode:
-            load_config(module, cmds)
-
-        if 'configure' in cmds:
-            cmds.pop(0)
-        results['commands'] = cmds
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_snmp_host.py b/lib/ansible/modules/network/nxos/nxos_snmp_host.py
deleted file mode 100644
index 06c1ac250c..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_snmp_host.py
+++ /dev/null
@@ -1,466 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_snmp_host
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages SNMP host configuration.
-description:
-    - Manages SNMP host configuration parameters.
-author:
-    - Jason Edelman (@jedelman8)
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - C(state=absent) removes the host configuration if it is configured.
-options:
-    snmp_host:
-        description:
-            - IP address of hostname of target host.
-        required: true
-    version:
-        description:
-            - SNMP version. If this is not specified, v1 is used.
-        choices: ['v1', 'v2c', 'v3']
-    v3:
-        description:
-            - Use this when verion is v3. SNMPv3 Security level.
-        choices: ['noauth', 'auth', 'priv']
-    community:
-        description:
-            - Community string or v3 username.
-    udp:
-        description:
-            - UDP port number (0-65535).
-        default: 162
-    snmp_type:
-        description:
-            - type of message to send to host. If this is not
-              specified, trap type is used.
-        choices: ['trap', 'inform']
-    vrf:
-        description:
-            - VRF to use to source traffic to source.
-              If state = absent, the vrf is removed.
-    vrf_filter:
-        description:
-            - Name of VRF to filter.
-              If state = absent, the vrf is removed from the filter.
-    src_intf:
-        description:
-            - Source interface. Must be fully qualified interface name.
-              If state = absent, the interface is removed.
-    state:
-        description:
-            - Manage the state of the resource. If state = present, the
-              host is added to the configuration. If only vrf and/or
-              vrf_filter and/or src_intf are given, they will be added to
-              the existing host configuration. If state = absent, the
-              host is removed if community parameter is given. It is possible
-              to remove only vrf and/or src_int and/or vrf_filter
-              by providing only those parameters and no community parameter.
-        default: present
-        choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-# ensure snmp host is configured
-- nxos_snmp_host:
-    snmp_host: 192.0.2.3
-    community: TESTING
-    state: present
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["snmp-server host 192.0.2.3 filter-vrf another_test_vrf"]
-'''
-
-
-import re
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def execute_show_command(command, module):
-    command = {
-        'command': command,
-        'output': 'json',
-    }
-
-    return run_commands(module, command)
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key, value in table.items():
-        new_key = key_map.get(key)
-        if new_key:
-            value = table.get(key)
-            if value:
-                new_dict[new_key] = str(value)
-            else:
-                new_dict[new_key] = value
-    return new_dict
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_snmp_host(host, udp, module):
-    body = execute_show_command('show snmp host', module)
-
-    host_map = {
-        'port': 'udp',
-        'version': 'version',
-        'level': 'v3',
-        'type': 'snmp_type',
-        'secname': 'community'
-    }
-
-    host_map_5k = {
-        'port': 'udp',
-        'version': 'version',
-        'sec_level': 'v3',
-        'notif_type': 'snmp_type',
-        'commun_or_user': 'community'
-    }
-
-    resource = {}
-
-    if body:
-        try:
-            resource_table = body[0]['TABLE_host']['ROW_host']
-
-            if isinstance(resource_table, dict):
-                resource_table = [resource_table]
-
-            for each in resource_table:
-                key = str(each['host']) + '_' + str(each['port']).strip()
-                src = each.get('src_intf')
-                host_resource = apply_key_map(host_map, each)
-
-                if src:
-                    host_resource['src_intf'] = src
-                    if re.search(r'interface:', src):
-                        host_resource['src_intf'] = src.split(':')[1].strip()
-
-                vrf_filt = each.get('TABLE_vrf_filters')
-                if vrf_filt:
-                    vrf_filter = vrf_filt['ROW_vrf_filters']['vrf_filter'].split(':')[1].split(',')
-                    filters = [vrf.strip() for vrf in vrf_filter]
-                    host_resource['vrf_filter'] = filters
-
-                vrf = each.get('vrf')
-                if vrf:
-                    host_resource['vrf'] = vrf.split(':')[1].strip()
-                resource[key] = host_resource
-        except KeyError:
-            # Handle the 5K case
-            try:
-                resource_table = body[0]['TABLE_hosts']['ROW_hosts']
-
-                if isinstance(resource_table, dict):
-                    resource_table = [resource_table]
-
-                for each in resource_table:
-                    key = str(each['address']) + '_' + str(each['port']).strip()
-                    src = each.get('src_intf')
-                    host_resource = apply_key_map(host_map_5k, each)
-
-                    if src:
-                        host_resource['src_intf'] = src
-                        if re.search(r'interface:', src):
-                            host_resource['src_intf'] = src.split(':')[1].strip()
-
-                    vrf = each.get('use_vrf_name')
-                    if vrf:
-                        host_resource['vrf'] = vrf.strip()
-
-                    vrf_filt = each.get('TABLE_filter_vrf')
-                    if vrf_filt:
-                        vrf_filter = vrf_filt['ROW_filter_vrf']['filter_vrf_name'].split(',')
-                        filters = [vrf.strip() for vrf in vrf_filter]
-                        host_resource['vrf_filter'] = filters
-
-                    resource[key] = host_resource
-            except (KeyError, AttributeError, TypeError):
-                return resource
-        except (AttributeError, TypeError):
-            return resource
-
-        find = resource.get(host + '_' + udp)
-
-        if find:
-            fix_find = {}
-            for (key, value) in find.items():
-                if isinstance(value, str):
-                    fix_find[key] = value.strip()
-                else:
-                    fix_find[key] = value
-            return fix_find
-
-    return {}
-
-
-def remove_snmp_host(host, udp, existing):
-    commands = []
-    if existing['version'] == 'v3':
-        existing['version'] = '3'
-        command = 'no snmp-server host {0} {snmp_type} version \
-                    {version} {v3} {community} udp-port {1}'.format(host, udp, **existing)
-
-    elif existing['version'] == 'v2c':
-        existing['version'] = '2c'
-        command = 'no snmp-server host {0} {snmp_type} version \
-                    {version} {community} udp-port {1}'.format(host, udp, **existing)
-
-    elif existing['version'] == 'v1':
-        existing['version'] = '1'
-        command = 'no snmp-server host {0} {snmp_type} version \
-                    {version} {community} udp-port {1}'.format(host, udp, **existing)
-
-    if command:
-        commands.append(command)
-    return commands
-
-
-def remove_vrf(host, udp, proposed, existing):
-    commands = []
-    if existing.get('vrf'):
-        commands.append('no snmp-server host {0} use-vrf \
-                    {1} udp-port {2}'.format(host, proposed.get('vrf'), udp))
-    return commands
-
-
-def remove_filter(host, udp, proposed, existing):
-    commands = []
-    if existing.get('vrf_filter'):
-        if proposed.get('vrf_filter') in existing.get('vrf_filter'):
-            commands.append('no snmp-server host {0} filter-vrf \
-                    {1} udp-port {2}'.format(host, proposed.get('vrf_filter'), udp))
-    return commands
-
-
-def remove_src(host, udp, proposed, existing):
-    commands = []
-    if existing.get('src_intf'):
-        commands.append('no snmp-server host {0} source-interface \
-                    {1} udp-port {2}'.format(host, proposed.get('src_intf'), udp))
-    return commands
-
-
-def config_snmp_host(delta, udp, proposed, existing, module):
-    commands = []
-    command_builder = []
-    host = proposed['snmp_host']
-    cmd = 'snmp-server host {0}'.format(proposed['snmp_host'])
-
-    snmp_type = delta.get('snmp_type')
-    version = delta.get('version')
-    ver = delta.get('v3')
-    community = delta.get('community')
-
-    command_builder.append(cmd)
-    if any([snmp_type, version, ver, community]):
-        type_string = snmp_type or existing.get('type')
-        if type_string:
-            command_builder.append(type_string)
-
-        version = version or existing.get('version')
-        if version:
-            if version == 'v1':
-                vn = '1'
-            elif version == 'v2c':
-                vn = '2c'
-            elif version == 'v3':
-                vn = '3'
-
-            version_string = 'version {0}'.format(vn)
-            command_builder.append(version_string)
-
-        if ver:
-            ver_string = ver or existing.get('v3')
-            command_builder.append(ver_string)
-
-        if community:
-            community_string = community or existing.get('community')
-            command_builder.append(community_string)
-
-        udp_string = ' udp-port {0}'.format(udp)
-        command_builder.append(udp_string)
-
-        cmd = ' '.join(command_builder)
-
-        commands.append(cmd)
-
-    CMDS = {
-        'vrf_filter': 'snmp-server host {0} filter-vrf {vrf_filter} udp-port {1}',
-        'vrf': 'snmp-server host {0} use-vrf {vrf} udp-port {1}',
-        'src_intf': 'snmp-server host {0} source-interface {src_intf} udp-port {1}'
-    }
-
-    for key in delta:
-        command = CMDS.get(key)
-        if command:
-            cmd = command.format(host, udp, **delta)
-            commands.append(cmd)
-    return commands
-
-
-def main():
-    argument_spec = dict(
-        snmp_host=dict(required=True, type='str'),
-        community=dict(type='str'),
-        udp=dict(type='str', default='162'),
-        version=dict(choices=['v1', 'v2c', 'v3']),
-        src_intf=dict(type='str'),
-        v3=dict(choices=['noauth', 'auth', 'priv']),
-        vrf_filter=dict(type='str'),
-        vrf=dict(type='str'),
-        snmp_type=dict(choices=['trap', 'inform']),
-        state=dict(choices=['absent', 'present'], default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    warnings = list()
-    results = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    snmp_host = module.params['snmp_host']
-    community = module.params['community']
-    udp = module.params['udp']
-    version = module.params['version']
-    src_intf = module.params['src_intf']
-    v3 = module.params['v3']
-    vrf_filter = module.params['vrf_filter']
-    vrf = module.params['vrf']
-    snmp_type = module.params['snmp_type']
-    state = module.params['state']
-
-    existing = get_snmp_host(snmp_host, udp, module)
-
-    if version is None:
-        if existing:
-            version = existing.get('version')
-        else:
-            version = 'v1'
-
-    if snmp_type is None:
-        if existing:
-            snmp_type = existing.get('snmp_type')
-        else:
-            snmp_type = 'trap'
-
-    if v3 is None:
-        if version == 'v3' and existing:
-            v3 = existing.get('v3')
-
-    if snmp_type == 'inform' and version == 'v1':
-        module.fail_json(msg='inform requires snmp v2c or v3')
-
-    if (version == 'v1' or version == 'v2c') and v3:
-        module.fail_json(msg='param: "v3" should not be used when '
-                             'using version v1 or v2c')
-
-    if not any([vrf_filter, vrf, src_intf]):
-        if not all([snmp_type, version, community, udp]):
-            module.fail_json(msg='when not configuring options like '
-                                 'vrf_filter, vrf, and src_intf,'
-                                 'the following params are required: '
-                                 'type, version, community')
-
-    if version == 'v3' and v3 is None:
-        module.fail_json(msg='when using version=v3, the param v3 '
-                             '(options: auth, noauth, priv) is also required')
-
-    # existing returns the list of vrfs configured for a given host
-    # checking to see if the proposed is in the list
-    store = existing.get('vrf_filter')
-    if existing and store:
-        if vrf_filter not in existing['vrf_filter']:
-            existing['vrf_filter'] = None
-        else:
-            existing['vrf_filter'] = vrf_filter
-    commands = []
-
-    args = dict(
-        community=community,
-        snmp_host=snmp_host,
-        udp=udp,
-        version=version,
-        src_intf=src_intf,
-        vrf_filter=vrf_filter,
-        v3=v3,
-        vrf=vrf,
-        snmp_type=snmp_type
-    )
-    proposed = dict((k, v) for k, v in args.items() if v is not None)
-
-    if state == 'absent' and existing:
-        if proposed.get('community'):
-            commands.append(remove_snmp_host(snmp_host, udp, existing))
-        else:
-            if proposed.get('src_intf'):
-                commands.append(remove_src(snmp_host, udp, proposed, existing))
-            if proposed.get('vrf'):
-                commands.append(remove_vrf(snmp_host, udp, proposed, existing))
-            if proposed.get('vrf_filter'):
-                commands.append(remove_filter(snmp_host, udp, proposed, existing))
-
-    elif state == 'present':
-        delta = dict(set(proposed.items()).difference(existing.items()))
-        if delta:
-            command = config_snmp_host(delta, udp, proposed, existing, module)
-            commands.append(command)
-
-    cmds = flatten_list(commands)
-    if cmds:
-        results['changed'] = True
-        if not module.check_mode:
-            load_config(module, cmds)
-
-        if 'configure' in cmds:
-            cmds.pop(0)
-        results['commands'] = cmds
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_snmp_location.py b/lib/ansible/modules/network/nxos/nxos_snmp_location.py
deleted file mode 100644
index aa8ce688b3..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_snmp_location.py
+++ /dev/null
@@ -1,149 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_snmp_location
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages SNMP location information.
-description:
-    - Manages SNMP location configuration.
-author:
-    - Jason Edelman (@jedelman8)
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-options:
-    location:
-        description:
-            - Location information.
-        required: true
-    state:
-        description:
-            - Manage the state of the resource.
-        required: false
-        default: present
-        choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-# ensure snmp location is configured
-- nxos_snmp_location:
-    location: Test
-    state: present
-
-# ensure snmp location is not configured
-- nxos_snmp_location:
-    location: Test
-    state: absent
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["snmp-server location New_Test"]
-'''
-
-
-import re
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def execute_show_command(command, module):
-    command = {
-        'command': command,
-        'output': 'text',
-    }
-
-    return run_commands(module, command)
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_snmp_location(module):
-    location = {}
-    location_regex = r'^\s*snmp-server\s+location\s+(?P<location>.+)$'
-
-    body = execute_show_command('show run snmp', module)[0]
-    match_location = re.search(location_regex, body, re.M)
-    if match_location:
-        location['location'] = match_location.group("location")
-
-    return location
-
-
-def main():
-    argument_spec = dict(
-        location=dict(required=True, type='str'),
-        state=dict(choices=['absent', 'present'], default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    warnings = list()
-    results = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    location = module.params['location']
-    state = module.params['state']
-
-    existing = get_snmp_location(module)
-    commands = []
-
-    if state == 'absent':
-        if existing and existing['location'] == location:
-            commands.append('no snmp-server location')
-    elif state == 'present':
-        if not existing or existing['location'] != location:
-            commands.append('snmp-server location {0}'.format(location))
-
-    cmds = flatten_list(commands)
-    if cmds:
-        results['changed'] = True
-        if not module.check_mode:
-            load_config(module, cmds)
-
-        if 'configure' in cmds:
-            cmds.pop(0)
-        results['commands'] = cmds
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_snmp_traps.py b/lib/ansible/modules/network/nxos/nxos_snmp_traps.py
deleted file mode 100644
index 2161092c75..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_snmp_traps.py
+++ /dev/null
@@ -1,235 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_snmp_traps
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages SNMP traps.
-description:
-    - Manages SNMP traps configurations.
-author:
-    - Jason Edelman (@jedelman8)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - This module works at the group level for traps.  If you need to only
-      enable/disable 1 specific trap within a group, use the M(nxos_command)
-      module.
-    - Be aware that you can set a trap only for an enabled feature.
-options:
-    group:
-        description:
-            - Case sensitive group.
-        required: true
-        choices: ['aaa', 'bfd', 'bgp', 'bridge', 'callhome', 'cfs', 'config',
-          'eigrp', 'entity', 'feature-control', 'generic', 'hsrp', 'license',
-          'link', 'lldp', 'mmode', 'ospf', 'pim', 'rf', 'rmon', 'snmp',
-          'storm-control', 'stpx', 'switchfabric', 'syslog', 'sysmgr', 'system',
-          'upgrade', 'vtp', 'all']
-    state:
-        description:
-            - Manage the state of the resource.
-        required: false
-        default: enabled
-        choices: ['enabled','disabled']
-'''
-
-EXAMPLES = '''
-# ensure lldp trap configured
-- nxos_snmp_traps:
-    group: lldp
-    state: enabled
-
-# ensure lldp trap is not configured
-- nxos_snmp_traps:
-    group: lldp
-    state: disabled
-'''
-
-RETURN = '''
-commands:
-    description: command sent to the device
-    returned: always
-    type: list
-    sample: "snmp-server enable traps lldp ;"
-'''
-
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.network.nxos.nxos import get_capabilities
-from ansible.module_utils.basic import AnsibleModule
-
-
-def get_platform_id(module):
-    info = get_capabilities(module).get('device_info', {})
-    return (info.get('network_os_platform', ''))
-
-
-def execute_show_command(command, module):
-    command = {
-        'command': command,
-        'output': 'text',
-    }
-
-    return run_commands(module, command)
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_snmp_traps(group, module):
-    body = execute_show_command('show run snmp all', module)[0].split('\n')
-
-    resource = {}
-    feature_list = ['aaa', 'bfd', 'bgp', 'bridge', 'callhome', 'cfs', 'config',
-                    'eigrp', 'entity', 'feature-control', 'generic', 'hsrp',
-                    'license', 'link', 'lldp', 'mmode', 'ospf', 'pim',
-                    'rf', 'rmon', 'snmp', 'storm-control', 'stpx',
-                    'switchfabric', 'syslog', 'sysmgr', 'system', 'upgrade',
-                    'vtp']
-
-    if 'all' in group and 'N3K-C35' in get_platform_id(module):
-        module.warn("Platform does not support bfd traps; bfd ignored for 'group: all' request")
-        feature_list.remove('bfd')
-
-    for each in feature_list:
-        for line in body:
-            if each == 'ospf':
-                # ospf behaves differently when routers are present
-                if 'snmp-server enable traps ospf' == line:
-                    resource[each] = True
-                    break
-            else:
-                if 'enable traps {0}'.format(each) in line:
-                    if 'no ' in line:
-                        resource[each] = False
-                        break
-                    else:
-                        resource[each] = True
-
-    for each in feature_list:
-        if resource.get(each) is None:
-            # on some platforms, the 'no' cmd does not
-            # show up and so check if the feature is enabled
-            body = execute_show_command('show run | inc feature', module)[0]
-            if 'feature {0}'.format(each) in body:
-                resource[each] = False
-
-    find = resource.get(group, None)
-
-    if group == 'all'.lower():
-        return resource
-    elif find is not None:
-        trap_resource = {group: find}
-        return trap_resource
-    else:
-        # if 'find' is None, it means that 'group' is a
-        # currently disabled feature.
-        return {}
-
-
-def get_trap_commands(group, state, existing, module):
-    commands = []
-    enabled = False
-    disabled = False
-
-    if group == 'all':
-        if state == 'disabled':
-            for feature in existing:
-                if existing[feature]:
-                    trap_command = 'no snmp-server enable traps {0}'.format(feature)
-                    commands.append(trap_command)
-
-        elif state == 'enabled':
-            for feature in existing:
-                if existing[feature] is False:
-                    trap_command = 'snmp-server enable traps {0}'.format(feature)
-                    commands.append(trap_command)
-
-    else:
-        if group in existing:
-            if existing[group]:
-                enabled = True
-            else:
-                disabled = True
-
-            if state == 'disabled' and enabled:
-                commands.append(['no snmp-server enable traps {0}'.format(group)])
-            elif state == 'enabled' and disabled:
-                commands.append(['snmp-server enable traps {0}'.format(group)])
-        else:
-            module.fail_json(msg='{0} is not a currently '
-                                 'enabled feature.'.format(group))
-
-    return commands
-
-
-def main():
-    argument_spec = dict(
-        state=dict(choices=['enabled', 'disabled'], default='enabled'),
-        group=dict(choices=['aaa', 'bfd', 'bgp', 'bridge', 'callhome', 'cfs', 'config',
-                            'eigrp', 'entity', 'feature-control', 'generic', 'hsrp',
-                            'license', 'link', 'lldp', 'mmode', 'ospf', 'pim',
-                            'rf', 'rmon', 'snmp', 'storm-control', 'stpx',
-                            'switchfabric', 'syslog', 'sysmgr', 'system', 'upgrade',
-                            'vtp', 'all'],
-                   required=True),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    warnings = list()
-    results = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    group = module.params['group'].lower()
-    state = module.params['state']
-
-    existing = get_snmp_traps(group, module)
-
-    commands = get_trap_commands(group, state, existing, module)
-    cmds = flatten_list(commands)
-    if cmds:
-        results['changed'] = True
-        if not module.check_mode:
-            load_config(module, cmds)
-
-        if 'configure' in cmds:
-            cmds.pop(0)
-        results['commands'] = cmds
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_snmp_user.py b/lib/ansible/modules/network/nxos/nxos_snmp_user.py
deleted file mode 100644
index bd23a4ce64..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_snmp_user.py
+++ /dev/null
@@ -1,395 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_snmp_user
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages SNMP users for monitoring.
-description:
-    - Manages SNMP user configuration.
-author:
-    - Jason Edelman (@jedelman8)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - Authentication parameters not idempotent.
-options:
-    user:
-        description:
-            - Name of the user.
-        required: true
-    group:
-        description:
-            - Group to which the user will belong to.
-              If state = present, and the user is existing,
-              the group is added to the user. If the user
-              is not existing, user entry is created with this
-              group argument.
-              If state = absent, only the group is removed from the
-              user entry. However, to maintain backward compatibility,
-              if the existing user belongs to only one group, and if
-              group argument is same as the existing user's group,
-              then the user entry also is deleted.
-    authentication:
-        description:
-            - Authentication parameters for the user.
-        choices: ['md5', 'sha']
-    pwd:
-        description:
-            - Authentication password when using md5 or sha.
-              This is not idempotent
-    privacy:
-        description:
-            - Privacy password for the user.
-              This is not idempotent
-    encrypt:
-        description:
-            - Enables AES-128 bit encryption when using privacy password.
-        type: bool
-    state:
-        description:
-            - Manage the state of the resource.
-        default: present
-        choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-- nxos_snmp_user:
-    user: ntc
-    group: network-operator
-    authentication: md5
-    pwd: test_password
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["snmp-server user ntc network-operator auth md5 test_password"]
-'''
-
-import re
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def execute_show_command(command, module, text=False):
-    command = {
-        'command': command,
-        'output': 'json',
-    }
-    if text:
-        command['output'] = 'text'
-
-    return run_commands(module, command)
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_snmp_groups(module):
-    data = execute_show_command('show snmp group', module)[0]
-    group_list = []
-
-    try:
-        group_table = data['TABLE_role']['ROW_role']
-        for group in group_table:
-            group_list.append(group['role_name'])
-    except (KeyError, AttributeError):
-        return group_list
-
-    return group_list
-
-
-def get_snmp_user(user, module):
-    command = 'show snmp user {0}'.format(user)
-    body = execute_show_command(command, module, text=True)
-    body_text = body[0]
-
-    if 'No such entry' not in body[0]:
-        body = execute_show_command(command, module)
-
-    resource = {}
-    try:
-        # The TABLE and ROW keys differ between NXOS platforms.
-        if body[0].get('TABLE_snmp_user'):
-            tablekey = 'TABLE_snmp_user'
-            rowkey = 'ROW_snmp_user'
-            tablegrpkey = 'TABLE_snmp_group_names'
-            rowgrpkey = 'ROW_snmp_group_names'
-            authkey = 'auth_protocol'
-            privkey = 'priv_protocol'
-            grpkey = 'group_names'
-        elif body[0].get('TABLE_snmp_users'):
-            tablekey = 'TABLE_snmp_users'
-            rowkey = 'ROW_snmp_users'
-            tablegrpkey = 'TABLE_groups'
-            rowgrpkey = 'ROW_groups'
-            authkey = 'auth'
-            privkey = 'priv'
-            grpkey = 'group'
-
-        rt = body[0][tablekey][rowkey]
-        # on some older platforms, all groups except the 1st one
-        # are in list elements by themselves and they are
-        # indexed by 'user'. This is due to a platform bug.
-        # Get first element if rt is a list due to the bug
-        # or if there is no bug, parse rt directly
-        if isinstance(rt, list):
-            resource_table = rt[0]
-        else:
-            resource_table = rt
-
-        resource['user'] = user
-        resource['authentication'] = str(resource_table[authkey]).strip()
-        encrypt = str(resource_table[privkey]).strip()
-        if encrypt.startswith('aes'):
-            resource['encrypt'] = 'aes-128'
-        else:
-            resource['encrypt'] = 'none'
-
-        groups = []
-        if tablegrpkey in resource_table:
-            group_table = resource_table[tablegrpkey][rowgrpkey]
-            try:
-                for group in group_table:
-                    groups.append(str(group[grpkey]).strip())
-            except TypeError:
-                groups.append(str(group_table[grpkey]).strip())
-
-            # Now for the platform bug case, get the groups
-            if isinstance(rt, list):
-                # remove 1st element from the list as this is parsed already
-                rt.pop(0)
-                # iterate through other elements indexed by
-                # 'user' and add it to groups.
-                for each in rt:
-                    groups.append(each['user'].strip())
-
-        # Some 'F' platforms use 'group' key instead
-        elif 'group' in resource_table:
-            # single group is a string, multiple groups in a list
-            groups = resource_table['group']
-            if isinstance(groups, str):
-                groups = [groups]
-
-        resource['group'] = groups
-
-    except (KeyError, AttributeError, IndexError, TypeError):
-        if not resource and body_text and 'No such entry' not in body_text:
-            # 6K and other platforms may not return structured output;
-            # attempt to get state from text output
-            resource = get_non_structured_snmp_user(body_text)
-
-    return resource
-
-
-def get_non_structured_snmp_user(body_text):
-    # This method is a workaround for platforms that don't support structured
-    # output for 'show snmp user <foo>'. This workaround may not work on all
-    # platforms. Sample non-struct output:
-    #
-    # User                Auth  Priv(enforce) Groups              acl_filter
-    # ____                ____  _____________ ______              __________
-    # sample1             no    no            network-admin       ipv4:my_acl
-    #                                         network-operator
-    #                                         priv-11
-    #         -OR-
-    # sample2             md5   des(no)       priv-15
-    #         -OR-
-    # sample3             md5   aes-128(no)   network-admin
-    resource = {}
-    output = body_text.rsplit('__________')[-1]
-    pat = re.compile(r'^(?P<user>\S+)\s+'
-                     r'(?P<auth>\S+)\s+'
-                     r'(?P<priv>[\w\d-]+)(?P<enforce>\([\w\d-]+\))*\s+'
-                     r'(?P<group>\S+)',
-                     re.M)
-    m = re.search(pat, output)
-    if not m:
-        return resource
-    resource['user'] = m.group('user')
-    resource['auth'] = m.group('auth')
-    resource['encrypt'] = 'aes-128' if 'aes' in str(m.group('priv')) else 'none'
-
-    resource['group'] = [m.group('group')]
-    more_groups = re.findall(r'^\s+([\w\d-]+)\s*$', output, re.M)
-    if more_groups:
-        resource['group'] += more_groups
-
-    return resource
-
-
-def remove_snmp_user(user, group=None):
-    if group:
-        return ['no snmp-server user {0} {1}'.format(user, group)]
-    else:
-        return ['no snmp-server user {0}'.format(user)]
-
-
-def config_snmp_user(proposed, user, reset):
-    if reset:
-        commands = remove_snmp_user(user)
-    else:
-        commands = []
-
-    if proposed.get('group'):
-        cmd = 'snmp-server user {0} {group}'.format(user, **proposed)
-    else:
-        cmd = 'snmp-server user {0}'.format(user)
-
-    auth = proposed.get('authentication', None)
-    pwd = proposed.get('pwd', None)
-
-    if auth and pwd:
-        cmd += ' auth {authentication} {pwd}'.format(**proposed)
-
-    encrypt = proposed.get('encrypt', None)
-    privacy = proposed.get('privacy', None)
-
-    if encrypt and privacy:
-        cmd += ' priv {encrypt} {privacy}'.format(**proposed)
-    elif privacy:
-        cmd += ' priv {privacy}'.format(**proposed)
-
-    if cmd:
-        commands.append(cmd)
-
-    return commands
-
-
-def main():
-    argument_spec = dict(
-        user=dict(required=True, type='str'),
-        group=dict(type='str'),
-        pwd=dict(type='str'),
-        privacy=dict(type='str'),
-        authentication=dict(choices=['md5', 'sha']),
-        encrypt=dict(type='bool'),
-        state=dict(choices=['absent', 'present'], default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           required_together=[['authentication', 'pwd'],
-                                              ['encrypt', 'privacy']],
-                           supports_check_mode=True)
-
-    warnings = list()
-    results = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    user = module.params['user']
-    group = module.params['group']
-    pwd = module.params['pwd']
-    privacy = module.params['privacy']
-    encrypt = module.params['encrypt']
-    authentication = module.params['authentication']
-    state = module.params['state']
-
-    if privacy and encrypt:
-        if not pwd and authentication:
-            module.fail_json(msg='pwd and authentication must be provided '
-                                 'when using privacy and encrypt')
-
-    if group and group not in get_snmp_groups(module):
-        module.fail_json(msg='group not configured yet on switch.')
-
-    existing = get_snmp_user(user, module)
-
-    if state == 'present' and existing:
-        if group:
-            if group not in existing['group']:
-                existing['group'] = None
-            else:
-                existing['group'] = group
-        else:
-            existing['group'] = None
-
-    commands = []
-
-    if state == 'absent' and existing:
-        if group:
-            if group in existing['group']:
-                if len(existing['group']) == 1:
-                    commands.append(remove_snmp_user(user))
-                else:
-                    commands.append(remove_snmp_user(user, group))
-        else:
-            commands.append(remove_snmp_user(user))
-
-    elif state == 'present':
-        reset = False
-
-        args = dict(user=user, pwd=pwd, group=group, privacy=privacy,
-                    encrypt=encrypt, authentication=authentication)
-        proposed = dict((k, v) for k, v in args.items() if v is not None)
-
-        if not existing:
-            if encrypt:
-                proposed['encrypt'] = 'aes-128'
-            commands.append(config_snmp_user(proposed, user, reset))
-
-        elif existing:
-            if encrypt and not existing['encrypt'].startswith('aes'):
-                reset = True
-                proposed['encrypt'] = 'aes-128'
-
-            delta = dict(set(proposed.items()).difference(existing.items()))
-
-            if delta.get('pwd'):
-                delta['authentication'] = authentication
-
-            if delta and encrypt:
-                delta['encrypt'] = 'aes-128'
-
-            if delta:
-                command = config_snmp_user(delta, user, reset)
-                commands.append(command)
-
-    cmds = flatten_list(commands)
-    if cmds:
-        results['changed'] = True
-        if not module.check_mode:
-            load_config(module, cmds)
-
-        if 'configure' in cmds:
-            cmds.pop(0)
-        results['commands'] = cmds
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_static_route.py b/lib/ansible/modules/network/nxos/nxos_static_route.py
deleted file mode 100644
index 2fab19c9c5..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_static_route.py
+++ /dev/null
@@ -1,304 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_static_route
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages static route configuration
-description:
-  - Manages static route configuration
-author: Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - If no vrf is supplied, vrf is set to default.
-  - If C(state=absent), the route will be removed, regardless of the
-    non-required parameters.
-options:
-  prefix:
-    description:
-      - Destination prefix of static route.
-    required: true
-    aliases:
-      - address
-  next_hop:
-    description:
-      - Next hop address or interface of static route.
-        If interface, it must be the fully-qualified interface name.
-    required: true
-  vrf:
-    description:
-      - VRF for static route.
-    default: default
-  tag:
-    description:
-      - Route tag value (numeric) or keyword 'default'.
-  route_name:
-    description:
-      - Name of the route or keyword 'default'. Used with the name parameter on the CLI.
-  pref:
-    description:
-      - Preference or administrative difference of route (range 1-255) or keyword 'default'.
-    aliases:
-      - admin_distance
-  aggregate:
-    description: List of static route definitions
-    version_added: 2.5
-  track:
-    description:
-      - Track value (range 1 - 512). Track must already be configured on the device before adding the route.
-    version_added: "2.8"
-  state:
-    description:
-      - Manage the state of the resource.
-    choices: ['present','absent']
-    default: 'present'
-'''
-
-EXAMPLES = '''
-- nxos_static_route:
-    prefix: "192.168.20.64/24"
-    next_hop: "192.0.2.3"
-    route_name: testing
-    pref: 100
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["ip route 192.168.20.0/24 192.0.2.3 name testing 100"]
-'''
-import re
-from copy import deepcopy
-
-from ansible.module_utils.network.nxos.nxos import get_config, load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-from ansible.module_utils.network.common.utils import remove_default_spec
-
-
-def reconcile_candidate(module, candidate, prefix, want):
-    state, vrf = want['state'], want['vrf']
-    if vrf == 'default':
-        parents = []
-        flags = " | include '^ip route'"
-    else:
-        parents = ['vrf context {0}'.format(vrf)]
-        flags = " | section '{0}' | include '^  ip route'".format(parents[0])
-
-    # Find existing routes in this vrf/default
-    netcfg = CustomNetworkConfig(indent=2, contents=get_config(module, flags=[flags]))
-    routes = str(netcfg).split('\n')
-    # strip whitespace from route strings
-    routes = [i.strip() for i in routes]
-
-    prefix_and_nh = 'ip route {0} {1}'.format(prefix, want['next_hop'])
-    existing = [i for i in routes if i.startswith(prefix_and_nh)]
-    proposed = set_route_command(prefix, want, module)
-
-    commands = []
-    if state == 'absent' and existing:
-        commands = ['no ' + existing[0]]
-    elif state == 'present' and proposed not in routes:
-        if existing:
-            commands = ['no ' + existing[0]]
-        commands.append(proposed)
-
-    if commands:
-        candidate.add(commands, parents=parents)
-
-
-def get_configured_track(module, ctrack):
-    check_track = '{0}'.format(ctrack)
-    track_exists = False
-    command = 'show track'
-    try:
-        body = run_commands(module, {'command': command, 'output': 'text'})
-        match = re.findall(r'Track\s+(\d+)', body[0])
-    except IndexError:
-        return None
-    if check_track in match:
-        track_exists = True
-    return track_exists
-
-
-def set_route_command(prefix, w, module):
-    route_cmd = 'ip route {0} {1}'.format(prefix, w['next_hop'])
-
-    if w['track']:
-        if w['track'] in range(1, 512):
-            if get_configured_track(module, w['track']):
-                route_cmd += ' track {0}'.format(w['track'])
-            else:
-                module.fail_json(msg='Track {0} not configured on device'.format(w['track']))
-        else:
-            module.fail_json(msg='Invalid track number, valid range is 1-512.')
-    if w['route_name'] and w['route_name'] != 'default':
-        route_cmd += ' name {0}'.format(w['route_name'])
-    if w['tag']:
-        if w['tag'] != 'default' and w['tag'] != '0':
-            route_cmd += ' tag {0}'.format(w['tag'])
-    if w['pref'] and w['pref'] != 'default':
-        route_cmd += ' {0}'.format(w['pref'])
-
-    return route_cmd
-
-
-def get_dotted_mask(mask):
-    bits = 0
-    for i in range(32 - mask, 32):
-        bits |= (1 << i)
-    mask = ("%d.%d.%d.%d" % ((bits & 0xff000000) >> 24, (bits & 0xff0000) >> 16, (bits & 0xff00) >> 8, (bits & 0xff)))
-    return mask
-
-
-def get_network_start(address, netmask):
-    address = address.split('.')
-    netmask = netmask.split('.')
-    return [str(int(address[x]) & int(netmask[x])) for x in range(0, 4)]
-
-
-def network_from_string(address, mask, module):
-    octects = address.split('.')
-
-    if len(octects) > 4:
-        module.fail_json(msg='Incorrect address format.', address=address)
-
-    for octect in octects:
-        try:
-            if int(octect) < 0 or int(octect) > 255:
-                module.fail_json(msg='Address may contain invalid values.',
-                                 address=address)
-        except ValueError:
-            module.fail_json(msg='Address may contain non-integer values.',
-                             address=address)
-
-    try:
-        if int(mask) < 0 or int(mask) > 32:
-            module.fail_json(msg='Incorrect mask value.', mask=mask)
-    except ValueError:
-        module.fail_json(msg='Mask may contain non-integer values.', mask=mask)
-
-    netmask = get_dotted_mask(int(mask))
-    return '.'.join(get_network_start(address, netmask))
-
-
-def normalize_prefix(module, prefix):
-    splitted_prefix = prefix.split('/')
-
-    address = splitted_prefix[0]
-    if len(splitted_prefix) > 2:
-        module.fail_json(msg='Incorrect address format.', address=address)
-    elif len(splitted_prefix) == 2:
-        mask = splitted_prefix[1]
-        network = network_from_string(address, mask, module)
-
-        normalized_prefix = str(network) + '/' + str(mask)
-    else:
-        normalized_prefix = prefix + '/' + str(32)
-
-    return normalized_prefix
-
-
-def map_params_to_obj(module):
-    obj = []
-    aggregate = module.params.get('aggregate')
-    if aggregate:
-        for item in aggregate:
-            for key in item:
-                if item.get(key) is None:
-                    item[key] = module.params[key]
-
-            d = item.copy()
-            obj.append(d)
-    else:
-        obj.append({
-            'prefix': module.params['prefix'],
-            'next_hop': module.params['next_hop'],
-            'vrf': module.params['vrf'],
-            'tag': module.params['tag'],
-            'route_name': module.params['route_name'],
-            'pref': module.params['pref'],
-            'state': module.params['state'],
-            'track': module.params['track']
-        })
-
-    return obj
-
-
-def main():
-    element_spec = dict(
-        prefix=dict(type='str', aliases=['address']),
-        next_hop=dict(type='str'),
-        vrf=dict(type='str', default='default'),
-        tag=dict(type='str'),
-        route_name=dict(type='str'),
-        pref=dict(type='str', aliases=['admin_distance']),
-        state=dict(choices=['absent', 'present'], default='present'),
-        track=dict(type='int'),
-    )
-
-    aggregate_spec = deepcopy(element_spec)
-    aggregate_spec['prefix'] = dict(required=True)
-    aggregate_spec['next_hop'] = dict(required=True)
-
-    # remove default in aggregate spec, to handle common arguments
-    remove_default_spec(aggregate_spec)
-
-    argument_spec = dict(
-        aggregate=dict(type='list', elements='dict', options=aggregate_spec)
-    )
-
-    argument_spec.update(element_spec)
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(
-        argument_spec=argument_spec,
-        supports_check_mode=True,
-    )
-
-    warnings = list()
-    result = {'changed': False, 'commands': []}
-    if warnings:
-        result['warnings'] = warnings
-
-    want = map_params_to_obj(module)
-    for w in want:
-        prefix = normalize_prefix(module, w['prefix'])
-        candidate = CustomNetworkConfig(indent=3)
-        reconcile_candidate(module, candidate, prefix, w)
-
-        if not module.check_mode and candidate:
-            candidate = candidate.items_text()
-            load_config(module, candidate)
-            result['commands'].extend(candidate)
-            result['changed'] = True
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_system.py b/lib/ansible/modules/network/nxos/nxos_system.py
deleted file mode 100644
index fb7dc2e9e3..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_system.py
+++ /dev/null
@@ -1,401 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = """
----
-module: nxos_system
-extends_documentation_fragment: nxos
-version_added: "2.3"
-author: "Peter Sprygada (@privateip)"
-short_description: Manage the system attributes on Cisco NXOS devices
-description:
-  - This module provides declarative management of node system attributes
-    on Cisco NXOS devices.  It provides an option to configure host system
-    parameters or remove those parameters from the device active
-    configuration.
-options:
-  hostname:
-    description:
-      - Configure the device hostname parameter. This option takes an ASCII string value
-        or keyword 'default'
-  domain_name:
-    description:
-      - Configures the default domain
-        name suffix to be used when referencing this node by its
-        FQDN.  This argument accepts either a list of domain names or
-        a list of dicts that configure the domain name and VRF name or
-        keyword 'default'. See examples.
-  domain_lookup:
-    description:
-      - Enables or disables the DNS
-        lookup feature in Cisco NXOS.  This argument accepts boolean
-        values.  When enabled, the system will try to resolve hostnames
-        using DNS and when disabled, hostnames will not be resolved.
-    type: bool
-  domain_search:
-    description:
-      - Configures a list of domain
-        name suffixes to search when performing DNS name resolution.
-        This argument accepts either a list of domain names or
-        a list of dicts that configure the domain name and VRF name or
-        keyword 'default'. See examples.
-  name_servers:
-    description:
-      - List of DNS name servers by IP address to use to perform name resolution
-        lookups.  This argument accepts either a list of DNS servers or
-        a list of hashes that configure the name server and VRF name or
-        keyword 'default'. See examples.
-  system_mtu:
-    description:
-      - Specifies the mtu, must be an integer or keyword 'default'.
-  state:
-    description:
-      - State of the configuration
-        values in the device's current active configuration.  When set
-        to I(present), the values should be configured in the device active
-        configuration and when set to I(absent) the values should not be
-        in the device active configuration
-    default: present
-    choices: ['present', 'absent']
-"""
-
-EXAMPLES = """
-- name: configure hostname and domain-name
-  nxos_system:
-    hostname: nxos01
-    domain_name: test.example.com
-
-- name: remove configuration
-  nxos_system:
-    state: absent
-
-- name: configure name servers
-  nxos_system:
-    name_servers:
-      - 8.8.8.8
-      - 8.8.4.4
-
-- name: configure name servers with VRF support
-  nxos_system:
-    name_servers:
-      - { server: 8.8.8.8, vrf: mgmt }
-      - { server: 8.8.4.4, vrf: mgmt }
-"""
-
-RETURN = """
-commands:
-  description: The list of configuration mode commands to send to the device
-  returned: always
-  type: list
-  sample:
-    - hostname nxos01
-    - ip domain-name test.example.com
-"""
-import re
-
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.six import iteritems
-from ansible.module_utils.network.common.config import NetworkConfig
-from ansible.module_utils.network.common.utils import ComplexList
-
-_CONFIGURED_VRFS = None
-
-
-def has_vrf(module, vrf):
-    global _CONFIGURED_VRFS
-    if _CONFIGURED_VRFS is not None:
-        return vrf in _CONFIGURED_VRFS
-    config = get_config(module)
-    _CONFIGURED_VRFS = re.findall(r'vrf context (\S+)', config)
-    return vrf in _CONFIGURED_VRFS
-
-
-def map_obj_to_commands(want, have, module):
-    commands = list()
-    state = module.params['state']
-
-    def needs_update(x):
-        return want.get(x) and (want.get(x) != have.get(x))
-
-    def difference(x, y, z):
-        return [item for item in x[z] if item not in y[z]]
-
-    def remove(cmd, commands, vrf=None):
-        if vrf:
-            commands.append('vrf context %s' % vrf)
-        commands.append(cmd)
-        if vrf:
-            commands.append('exit')
-
-    def add(cmd, commands, vrf=None):
-        if vrf:
-            if not has_vrf(module, vrf):
-                module.fail_json(msg='invalid vrf name %s' % vrf)
-        return remove(cmd, commands, vrf)
-
-    if state == 'absent':
-        if have['hostname']:
-            commands.append('no hostname')
-
-        for item in have['domain_name']:
-            cmd = 'no ip domain-name %s' % item['name']
-            remove(cmd, commands, item['vrf'])
-
-        for item in have['domain_search']:
-            cmd = 'no ip domain-list %s' % item['name']
-            remove(cmd, commands, item['vrf'])
-
-        for item in have['name_servers']:
-            cmd = 'no ip name-server %s' % item['server']
-            remove(cmd, commands, item['vrf'])
-
-        if have['system_mtu']:
-            commands.append('no system jumbomtu')
-
-    if state == 'present':
-        if needs_update('hostname'):
-            if want['hostname'] == 'default':
-                if have['hostname']:
-                    commands.append('no hostname')
-            else:
-                commands.append('hostname %s' % want['hostname'])
-
-        if want.get('domain_lookup') is not None:
-            if have.get('domain_lookup') != want.get('domain_lookup'):
-                cmd = 'ip domain-lookup'
-                if want['domain_lookup'] is False:
-                    cmd = 'no %s' % cmd
-                commands.append(cmd)
-
-        if want['domain_name']:
-            if want.get('domain_name')[0]['name'] == 'default':
-                if have['domain_name']:
-                    for item in have['domain_name']:
-                        cmd = 'no ip domain-name %s' % item['name']
-                        remove(cmd, commands, item['vrf'])
-            else:
-                for item in difference(have, want, 'domain_name'):
-                    cmd = 'no ip domain-name %s' % item['name']
-                    remove(cmd, commands, item['vrf'])
-                for item in difference(want, have, 'domain_name'):
-                    cmd = 'ip domain-name %s' % item['name']
-                    add(cmd, commands, item['vrf'])
-
-        if want['domain_search']:
-            if want.get('domain_search')[0]['name'] == 'default':
-                if have['domain_search']:
-                    for item in have['domain_search']:
-                        cmd = 'no ip domain-list %s' % item['name']
-                        remove(cmd, commands, item['vrf'])
-            else:
-                for item in difference(have, want, 'domain_search'):
-                    cmd = 'no ip domain-list %s' % item['name']
-                    remove(cmd, commands, item['vrf'])
-                for item in difference(want, have, 'domain_search'):
-                    cmd = 'ip domain-list %s' % item['name']
-                    add(cmd, commands, item['vrf'])
-
-        if want['name_servers']:
-            if want.get('name_servers')[0]['server'] == 'default':
-                if have['name_servers']:
-                    for item in have['name_servers']:
-                        cmd = 'no ip name-server %s' % item['server']
-                        remove(cmd, commands, item['vrf'])
-            else:
-                for item in difference(have, want, 'name_servers'):
-                    cmd = 'no ip name-server %s' % item['server']
-                    remove(cmd, commands, item['vrf'])
-                for item in difference(want, have, 'name_servers'):
-                    cmd = 'ip name-server %s' % item['server']
-                    add(cmd, commands, item['vrf'])
-
-        if needs_update('system_mtu'):
-            if want['system_mtu'] == 'default':
-                if have['system_mtu']:
-                    commands.append('no system jumbomtu')
-            else:
-                commands.append('system jumbomtu %s' % want['system_mtu'])
-
-    return commands
-
-
-def parse_hostname(config):
-    match = re.search(r'^hostname (\S+)', config, re.M)
-    if match:
-        return match.group(1)
-
-
-def parse_domain_name(config, vrf_config):
-    objects = list()
-    regex = re.compile(r'ip domain-name (\S+)')
-
-    match = regex.search(config, re.M)
-    if match:
-        objects.append({'name': match.group(1), 'vrf': None})
-
-    for vrf, cfg in iteritems(vrf_config):
-        match = regex.search(cfg, re.M)
-        if match:
-            objects.append({'name': match.group(1), 'vrf': vrf})
-
-    return objects
-
-
-def parse_domain_search(config, vrf_config):
-    objects = list()
-
-    for item in re.findall(r'^ip domain-list (\S+)', config, re.M):
-        objects.append({'name': item, 'vrf': None})
-
-    for vrf, cfg in iteritems(vrf_config):
-        for item in re.findall(r'ip domain-list (\S+)', cfg, re.M):
-            objects.append({'name': item, 'vrf': vrf})
-
-    return objects
-
-
-def parse_name_servers(config, vrf_config, vrfs):
-    objects = list()
-
-    match = re.search('^ip name-server (.+)$', config, re.M)
-    if match and 'use-vrf' not in match.group(1):
-        for addr in match.group(1).split(' '):
-            objects.append({'server': addr, 'vrf': None})
-
-    for vrf, cfg in iteritems(vrf_config):
-        vrf_match = re.search('ip name-server (.+)', cfg, re.M)
-        if vrf_match:
-            for addr in vrf_match.group(1).split(' '):
-                objects.append({'server': addr, 'vrf': vrf})
-
-    return objects
-
-
-def parse_system_mtu(config):
-    match = re.search(r'^system jumbomtu (\d+)', config, re.M)
-    if match:
-        return match.group(1)
-
-
-def map_config_to_obj(module):
-    config = get_config(module)
-    configobj = NetworkConfig(indent=2, contents=config)
-
-    vrf_config = {}
-
-    vrfs = re.findall(r'^vrf context (\S+)$', config, re.M)
-    for vrf in vrfs:
-        config_data = configobj.get_block_config(path=['vrf context %s' % vrf])
-        vrf_config[vrf] = config_data
-
-    return {
-        'hostname': parse_hostname(config),
-        'domain_lookup': 'no ip domain-lookup' not in config,
-        'domain_name': parse_domain_name(config, vrf_config),
-        'domain_search': parse_domain_search(config, vrf_config),
-        'name_servers': parse_name_servers(config, vrf_config, vrfs),
-        'system_mtu': parse_system_mtu(config)
-    }
-
-
-def map_params_to_obj(module):
-    obj = {
-        'hostname': module.params['hostname'],
-        'domain_lookup': module.params['domain_lookup'],
-        'system_mtu': module.params['system_mtu']
-    }
-
-    domain_name = ComplexList(dict(
-        name=dict(key=True),
-        vrf=dict()
-    ), module)
-
-    domain_search = ComplexList(dict(
-        name=dict(key=True),
-        vrf=dict()
-    ), module)
-
-    name_servers = ComplexList(dict(
-        server=dict(key=True),
-        vrf=dict()
-    ), module)
-
-    for arg, cast in [('domain_name', domain_name), ('domain_search', domain_search),
-                      ('name_servers', name_servers)]:
-        if module.params[arg] is not None:
-            obj[arg] = cast(module.params[arg])
-        else:
-            obj[arg] = None
-
-    return obj
-
-
-def main():
-    """ main entry point for module execution
-    """
-    argument_spec = dict(
-        hostname=dict(),
-        domain_lookup=dict(type='bool'),
-
-        # { name: <str>, vrf: <str> }
-        domain_name=dict(type='list'),
-
-        # {name: <str>, vrf: <str> }
-        domain_search=dict(type='list'),
-
-        # { server: <str>; vrf: <str> }
-        name_servers=dict(type='list'),
-
-        system_mtu=dict(type='str'),
-        state=dict(default='present', choices=['present', 'absent'])
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    result = {'changed': False}
-    if warnings:
-        result['warnings'] = warnings
-
-    want = map_params_to_obj(module)
-    have = map_config_to_obj(module)
-
-    commands = map_obj_to_commands(want, have, module)
-    result['commands'] = commands
-
-    if commands:
-        if not module.check_mode:
-            load_config(module, commands)
-        result['changed'] = True
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_telemetry.py b/lib/ansible/modules/network/nxos/nxos_telemetry.py
deleted file mode 100644
index 6ef81560fd..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_telemetry.py
+++ /dev/null
@@ -1,333 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright 2019 Cisco and/or its affiliates.
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-
-"""
-The module file for nxos_telemetry
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-ANSIBLE_METADATA = {
-    'metadata_version': '1.1',
-    'status': ['preview'],
-    'supported_by': 'network'
-}
-
-DOCUMENTATION = """
----
-module: nxos_telemetry
-version_added: 2.9
-short_description: 'Telemetry Monitoring Service (TMS) configuration'
-description: 'Manages Telemetry Monitoring Service (TMS) configuration'
-author: Mike Wiebe (@mikewiebe)
-notes:
-  - 'Supported on N9k Version 7.0(3)I7(5) and later.'
-options:
-  config:
-    description: The provided configuration
-    type: dict
-    suboptions:
-      certificate:
-        type: dict
-        description:
-          - Certificate SSL/TLS and hostname values.
-          - Value must be a dict defining values for keys (key and hostname).
-        suboptions:
-          key:
-            description:
-              - Certificate key
-            type: str
-          hostname:
-            description:
-              - Certificate hostname
-            type: str
-      compression:
-        type: str
-        description:
-          - Destination profile compression method.
-        choices:
-          - gzip
-      source_interface:
-        type: str
-        description:
-          - Destination profile source interface.
-          - Valid value is a str representing the source interface name.
-      vrf:
-        type: str
-        description:
-          - Destination profile vrf.
-          - Valid value is a str representing the vrf name.
-      destination_groups:
-        type: list
-        description:
-          - List of telemetry destination groups.
-        suboptions:
-          id:
-            type: int
-            description:
-              - Destination group identifier.
-              - Value must be a int representing the destination group identifier.
-          destination:
-            type: dict
-            description:
-              - Group destination ipv4, port, protocol and encoding values.
-              - Value must be a dict defining values for keys (ip, port, protocol, encoding).
-            suboptions:
-              ip:
-                type: str
-                description:
-                  - Destination group IP address.
-              port:
-                type: int
-                description:
-                  - Destination group port number.
-              protocol:
-                type: str
-                description:
-                  - Destination group protocol.
-                choices:
-                  - HTTP
-                  - TCP
-                  - UDP
-                  - gRPC
-              encoding:
-                type: str
-                description:
-                  - Destination group encoding.
-                choices:
-                  - GPB
-                  - JSON
-      sensor_groups:
-        type: list
-        description:
-          - List of telemetry sensor groups.
-        suboptions:
-          id:
-            type: int
-            description:
-              - Sensor group identifier.
-              - Value must be a int representing the sensor group identifier.
-          data_source:
-            type: str
-            description:
-              - Telemetry data source.
-            choices:
-              - NX-API
-              - DME
-              - YANG
-          path:
-            type: dict
-            description:
-              - Telemetry sensor path.
-              - Value must be a dict defining values for keys (name, depth, filter_condition, query_condition).
-              - Mandatory Keys (name)
-              - Optional Keys  (depth, filter_condition, query_condition)
-            suboptions:
-              name:
-                type: str
-                description:
-                  - Sensor group path name.
-              depth:
-                type: str
-                description:
-                  - Sensor group depth.
-              filter_condition:
-                type: str
-                description:
-                  - Sensor group filter condition.
-              query_condition:
-                type: str
-                description:
-                  - Sensor group query condition.
-      subscriptions:
-        type: list
-        description:
-          - List of telemetry subscriptions.
-        suboptions:
-          id:
-            type: int
-            description:
-              - Subscription identifier.
-              - Value must be a int representing the subscription identifier.
-          destination_group:
-            type: int
-            description:
-              - Associated destination group.
-          sensor_group:
-            type: dict
-            description:
-              - Associated sensor group.
-              - Value must be a dict defining values for keys (id, sample_interval).
-            suboptions:
-              id:
-                type: int
-                description:
-                  - Associated sensor group id.
-              sample_interval:
-                type: int
-                description:
-                  - Associated sensor group id sample interval.
-
-  state:
-    description:
-    - Final configuration state
-    type: str
-    choices:
-    - merged
-    - replaced
-    - deleted
-    default: merged
-"""
-EXAMPLES = """
-# Using deleted
-# This action will delete all telemetry configuration on the device
-
-- name: Delete Telemetry Configuration
-  nxos_telemetry:
-    state: deleted
-
-
-# Using merged
-# This action will merge telemetry configuration defined in the playbook with
-# telemetry configuration that is already on the device.
-
-- name: Merge Telemetry Configuration
-  nxos_telemetry:
-    config:
-      certificate:
-        key: /bootflash/server.key
-        hostname: localhost
-      compression: gzip
-      source_interface: Ethernet1/1
-      vrf: management
-      destination_groups:
-        - id: 2
-          destination:
-            ip: 192.168.0.2
-            port: 50001
-            protocol: gPRC
-            encoding: GPB
-        - id: 55
-          destination:
-            ip: 192.168.0.55
-            port: 60001
-            protocol: gPRC
-            encoding: GPB
-      sensor_groups:
-        - id: 1
-          data_source: NX-API
-          path:
-            name: '"show lldp neighbors detail"'
-            depth: 0
-        - id: 55
-          data_source: DME
-          path:
-            name: 'sys/ch'
-            depth: unbounded
-            filter_condition: 'ne(eqptFt.operSt,"ok")'
-      subscriptions:
-        - id: 5
-          destination_group: 55
-          sensor_group:
-            id: 1
-            sample_interval: 1000
-        - id: 6
-          destination_group: 2
-          sensor_group:
-            id: 55
-            sample_interval: 2000
-    state: merged
-
-
-# Using replaced
-# This action will replace telemetry configuration on the device with the
-# telemetry configuration defined in the playbook.
-
-- name: Override Telemetry Configuration
-  nxos_telemetry:
-    config:
-      certificate:
-        key: /bootflash/server.key
-        hostname: localhost
-      compression: gzip
-      source_interface: Ethernet1/1
-      vrf: management
-      destination_groups:
-        - id: 2
-          destination:
-            ip: 192.168.0.2
-            port: 50001
-            protocol: gPRC
-            encoding: GPB
-      subscriptions:
-        - id: 5
-          destination_group: 55
-    state: replaced
-
-
-"""
-RETURN = """
-before:
-  description: The configuration as structured data prior to module invocation.
-  returned: always
-  type: dict
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-after:
-  description: The configuration as structured data after module completion.
-  returned: when changed
-  type: dict
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-commands:
-  description: The set of commands pushed to the remote device.
-  returned: always
-  type: list
-  sample: ['command 1', 'command 2', 'command 3']
-"""
-
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.argspec.telemetry.telemetry import TelemetryArgs
-from ansible.module_utils.network.nxos.config.telemetry.telemetry import Telemetry
-
-
-def main():
-    """
-    Main entry point for module execution
-
-    :returns: the result form module invocation
-    """
-    module = AnsibleModule(argument_spec=TelemetryArgs.argument_spec,
-                           supports_check_mode=True)
-
-    result = Telemetry(module).execute_module()
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_udld.py b/lib/ansible/modules/network/nxos/nxos_udld.py
deleted file mode 100644
index 4b54574c5f..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_udld.py
+++ /dev/null
@@ -1,250 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_udld
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages UDLD global configuration params.
-description:
-    - Manages UDLD global configuration params.
-author:
-    - Jason Edelman (@jedelman8)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - Module will fail if the udld feature has not been previously enabled.
-options:
-    aggressive:
-        description:
-            - Toggles aggressive mode.
-        choices: ['enabled','disabled']
-    msg_time:
-        description:
-            - Message time in seconds for UDLD packets or keyword 'default'.
-    reset:
-        description:
-            - Ability to reset all ports shut down by UDLD. 'state' parameter
-              cannot be 'absent' when this is present.
-        type: bool
-        default: 'no'
-    state:
-        description:
-            - Manage the state of the resource. When set to 'absent',
-              aggressive and msg_time are set to their default values.
-        default: present
-        choices: ['present','absent']
-
-'''
-EXAMPLES = '''
-# ensure udld aggressive mode is globally disabled and se global message interval is 20
-- nxos_udld:
-    aggressive: disabled
-    msg_time: 20
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-
-# Ensure agg mode is globally enabled and msg time is 15
-- nxos_udld:
-    aggressive: enabled
-    msg_time: 15
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-'''
-
-RETURN = '''
-proposed:
-    description: k/v pairs of parameters passed into module
-    returned: always
-    type: dict
-    sample: {"aggressive": "enabled", "msg_time": "40"}
-existing:
-    description:
-        - k/v pairs of existing udld configuration
-    returned: always
-    type: dict
-    sample: {"aggressive": "disabled", "msg_time": "15"}
-end_state:
-    description: k/v pairs of udld configuration after module execution
-    returned: always
-    type: dict
-    sample: {"aggressive": "enabled", "msg_time": "40"}
-updates:
-    description: command sent to the device
-    returned: always
-    type: list
-    sample: ["udld message-time 40", "udld aggressive"]
-changed:
-    description: check to see if a change was made on the device
-    returned: always
-    type: bool
-    sample: true
-'''
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-PARAM_TO_DEFAULT_KEYMAP = {
-    'msg_time': '15',
-}
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key, value in table.items():
-        new_key = key_map.get(key)
-        if new_key:
-            value = table.get(key)
-            if value:
-                new_dict[new_key] = str(value)
-            else:
-                new_dict[new_key] = value
-    return new_dict
-
-
-def get_commands_config_udld_global(delta, reset, existing):
-    commands = []
-    for param, value in delta.items():
-        if param == 'aggressive':
-            command = 'udld aggressive' if value == 'enabled' else 'no udld aggressive'
-            commands.append(command)
-        elif param == 'msg_time':
-            if value == 'default':
-                if existing.get('msg_time') != PARAM_TO_DEFAULT_KEYMAP.get('msg_time'):
-                    commands.append('no udld message-time')
-            else:
-                commands.append('udld message-time ' + value)
-    if reset:
-        command = 'udld reset'
-        commands.append(command)
-    return commands
-
-
-def get_commands_remove_udld_global(existing):
-    commands = []
-    if existing.get('aggressive') == 'enabled':
-        command = 'no udld aggressive'
-        commands.append(command)
-    if existing.get('msg_time') != PARAM_TO_DEFAULT_KEYMAP.get('msg_time'):
-        command = 'no udld message-time'
-        commands.append(command)
-    return commands
-
-
-def get_udld_global(module):
-    command = 'show udld global | json'
-    udld_table = run_commands(module, [command])[0]
-
-    status = str(udld_table.get('udld-global-mode', None))
-    if status == 'enabled-aggressive':
-        aggressive = 'enabled'
-    else:
-        aggressive = 'disabled'
-
-    interval = str(udld_table.get('message-interval', None))
-    udld = dict(msg_time=interval, aggressive=aggressive)
-
-    return udld
-
-
-def main():
-    argument_spec = dict(
-        aggressive=dict(required=False, choices=['enabled', 'disabled']),
-        msg_time=dict(required=False, type='str'),
-        reset=dict(required=False, type='bool'),
-        state=dict(choices=['absent', 'present'], default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    aggressive = module.params['aggressive']
-    msg_time = module.params['msg_time']
-    reset = module.params['reset']
-    state = module.params['state']
-
-    if reset and state == 'absent':
-        module.fail_json(msg="state must be present when using reset flag.")
-
-    args = dict(aggressive=aggressive, msg_time=msg_time, reset=reset)
-    proposed = dict((k, v) for k, v in args.items() if v is not None)
-
-    existing = get_udld_global(module)
-    end_state = existing
-
-    delta = set(proposed.items()).difference(existing.items())
-    changed = False
-
-    commands = []
-    if state == 'present':
-        if delta:
-            command = get_commands_config_udld_global(dict(delta), reset, existing)
-            commands.append(command)
-
-    elif state == 'absent':
-        command = get_commands_remove_udld_global(existing)
-        if command:
-            commands.append(command)
-
-    cmds = flatten_list(commands)
-    if cmds:
-        if module.check_mode:
-            module.exit_json(changed=True, commands=cmds)
-        else:
-            changed = True
-            load_config(module, cmds)
-            end_state = get_udld_global(module)
-            if 'configure' in cmds:
-                cmds.pop(0)
-
-    results = {}
-    results['proposed'] = proposed
-    results['existing'] = existing
-    results['end_state'] = end_state
-    results['updates'] = cmds
-    results['changed'] = changed
-    results['warnings'] = warnings
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_udld_interface.py b/lib/ansible/modules/network/nxos/nxos_udld_interface.py
deleted file mode 100644
index d0d861ae44..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_udld_interface.py
+++ /dev/null
@@ -1,297 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_udld_interface
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages UDLD interface configuration params.
-description:
-    - Manages UDLD interface configuration params.
-author:
-    - Jason Edelman (@jedelman8)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - Feature UDLD must be enabled on the device to use this module.
-options:
-    mode:
-        description:
-            - Manages UDLD mode for an interface.
-        required: true
-        choices: ['enabled','disabled','aggressive']
-    interface:
-        description:
-            - FULL name of the interface, i.e. Ethernet1/1-
-        required: true
-    state:
-        description:
-            - Manage the state of the resource.
-        required: false
-        default: present
-        choices: ['present','absent']
-'''
-EXAMPLES = '''
-# ensure Ethernet1/1 is configured to be in aggressive mode
-- nxos_udld_interface:
-    interface: Ethernet1/1
-    mode: aggressive
-    state: present
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-
-# Remove the aggressive config only if it's currently in aggressive mode and then disable udld (switch default)
-- nxos_udld_interface:
-    interface: Ethernet1/1
-    mode: aggressive
-    state: absent
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-
-# ensure Ethernet1/1 has aggressive mode enabled
-- nxos_udld_interface:
-    interface: Ethernet1/1
-    mode: enabled
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-'''
-
-RETURN = '''
-proposed:
-    description: k/v pairs of parameters passed into module
-    returned: always
-    type: dict
-    sample: {"mode": "enabled"}
-existing:
-    description:
-        - k/v pairs of existing configuration
-    returned: always
-    type: dict
-    sample: {"mode": "aggressive"}
-end_state:
-    description: k/v pairs of configuration after module execution
-    returned: always
-    type: dict
-    sample: {"mode": "enabled"}
-updates:
-    description: command sent to the device
-    returned: always
-    type: list
-    sample: ["interface ethernet1/33",
-            "no udld aggressive ; no udld disable"]
-changed:
-    description: check to see if a change was made on the device
-    returned: always
-    type: bool
-    sample: true
-'''
-
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_udld_interface(module, interface):
-    command = 'show run udld all | section ' + interface.title() + '$'
-    interface_udld = {}
-    mode = None
-    mode_str = None
-    try:
-        body = run_commands(module, [{'command': command, 'output': 'text'}])[0]
-        if 'aggressive' in body:
-            mode = 'aggressive'
-            mode_str = 'aggressive'
-        elif 'no udld enable' in body:
-            mode = 'disabled'
-            mode_str = 'no udld enable'
-        elif 'no udld disable' in body:
-            mode = 'enabled'
-            mode_str = 'no udld disable'
-        elif 'udld disable' in body:
-            mode = 'disabled'
-            mode_str = 'udld disable'
-        elif 'udld enable' in body:
-            mode = 'enabled'
-            mode_str = 'udld enable'
-        interface_udld['mode'] = mode
-
-    except (KeyError, AttributeError, IndexError):
-        interface_udld = {}
-
-    return interface_udld, mode_str
-
-
-def get_commands_config_udld_interface1(delta, interface, module, existing):
-    commands = []
-    mode = delta['mode']
-    if mode == 'aggressive':
-        commands.append('udld aggressive')
-    else:
-        commands.append('no udld aggressive')
-    commands.insert(0, 'interface {0}'.format(interface))
-
-    return commands
-
-
-def get_commands_config_udld_interface2(delta, interface, module, existing):
-    commands = []
-    existing, mode_str = get_udld_interface(module, interface)
-    mode = delta['mode']
-    if mode == 'enabled':
-        if mode_str == 'no udld enable':
-            command = 'udld enable'
-        else:
-            command = 'no udld disable'
-    else:
-        if mode_str == 'no udld disable':
-            command = 'udld disable'
-        else:
-            command = 'no udld enable'
-    if command:
-        commands.append(command)
-        commands.insert(0, 'interface {0}'.format(interface))
-
-    return commands
-
-
-def get_commands_remove_udld_interface(delta, interface, module, existing):
-    commands = []
-    existing, mode_str = get_udld_interface(module, interface)
-
-    mode = delta['mode']
-    if mode == 'aggressive':
-        command = 'no udld aggressive'
-    else:
-        if mode == 'enabled':
-            if mode_str == 'udld enable':
-                command = 'no udld enable'
-            else:
-                command = 'udld disable'
-        elif mode == 'disabled':
-            if mode_str == 'no udld disable':
-                command = 'udld disable'
-            else:
-                command = 'no udld enable'
-    if command:
-        commands.append(command)
-        commands.insert(0, 'interface {0}'.format(interface))
-
-    return commands
-
-
-def main():
-    argument_spec = dict(
-        mode=dict(choices=['enabled', 'disabled', 'aggressive'],
-                  required=True),
-        interface=dict(type='str', required=True),
-        state=dict(choices=['absent', 'present'], default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    interface = module.params['interface'].lower()
-    mode = module.params['mode']
-    state = module.params['state']
-
-    proposed = dict(mode=mode)
-    existing, mode_str = get_udld_interface(module, interface)
-    end_state = existing
-
-    delta = dict(set(proposed.items()).difference(existing.items()))
-
-    changed = False
-    commands = []
-    cmds = []
-    if state == 'present':
-        if delta:
-            command = get_commands_config_udld_interface1(delta, interface,
-                                                          module, existing)
-            commands.append(command)
-            cmds = flatten_list(commands)
-            if module.check_mode:
-                module.exit_json(changed=True, commands=cmds)
-            else:
-                changed = True
-                load_config(module, cmds)
-
-            if delta['mode'] == 'enabled' or delta['mode'] == 'disabled':
-                commands = []
-                command = get_commands_config_udld_interface2(delta, interface,
-                                                              module, existing)
-                commands.append(command)
-                cmds = flatten_list(commands)
-                if module.check_mode:
-                    module.exit_json(changed=True, commands=cmds)
-                else:
-                    load_config(module, cmds)
-
-    else:
-        common = set(proposed.items()).intersection(existing.items())
-        if common:
-            command = get_commands_remove_udld_interface(
-                dict(common), interface, module, existing
-            )
-            cmds = flatten_list(commands)
-            if module.check_mode:
-                module.exit_json(changed=True, commands=cmds)
-            else:
-                changed = True
-                load_config(module, cmds)
-
-    if not module.check_mode:
-        end_state, mode_str = get_udld_interface(module, interface)
-        if 'configure' in cmds:
-            cmds.pop(0)
-
-    results = {}
-    results['proposed'] = proposed
-    results['existing'] = existing
-    results['end_state'] = end_state
-    results['updates'] = cmds
-    results['changed'] = changed
-    results['warnings'] = warnings
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_user.py b/lib/ansible/modules/network/nxos/nxos_user.py
deleted file mode 100644
index 0ac4ddb3e6..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_user.py
+++ /dev/null
@@ -1,381 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = """
----
-module: nxos_user
-extends_documentation_fragment: nxos
-version_added: "2.3"
-author: "Peter Sprygada (@privateip)"
-short_description: Manage the collection of local users on Nexus devices
-description:
-  - This module provides declarative management of the local usernames
-    configured on Cisco Nexus devices.  It allows playbooks to manage
-    either individual usernames or the collection of usernames in the
-    current running config.  It also supports purging usernames from the
-    configuration that are not explicitly defined.
-options:
-  aggregate:
-    description:
-      - The set of username objects to be configured on the remote
-        Cisco Nexus device.  The list entries can either be the username
-        or a hash of username and properties.  This argument is mutually
-        exclusive with the C(name) argument.
-    aliases: ['users', 'collection']
-    version_added: "2.4"
-  name:
-    description:
-      - The username to be configured on the remote Cisco Nexus
-        device.  This argument accepts a string value and is mutually
-        exclusive with the C(aggregate) argument.
-  configured_password:
-    description:
-      - The password to be configured on the network device. The
-        password needs to be provided in cleartext and it will be encrypted
-        on the device.
-        Please note that this option is not same as C(provider password).
-    version_added: "2.4"
-  update_password:
-    description:
-      - Since passwords are encrypted in the device running config, this
-        argument will instruct the module when to change the password.  When
-        set to C(always), the password will always be updated in the device
-        and when set to C(on_create) the password will be updated only if
-        the username is created.
-    default: always
-    choices: ['on_create', 'always']
-  role:
-    description:
-      - The C(role) argument configures the role for the username in the
-        device running configuration.  The argument accepts a string value
-        defining the role name.  This argument does not check if the role
-        has been configured on the device.
-    aliases: ['roles']
-  sshkey:
-    description:
-      - The C(sshkey) argument defines the SSH public key to configure
-        for the username.  This argument accepts a valid SSH key value.
-  purge:
-    description:
-      - The C(purge) argument instructs the module to consider the
-        resource definition absolute.  It will remove any previously
-        configured usernames on the device with the exception of the
-        `admin` user which cannot be deleted per nxos constraints.
-    type: bool
-    default: 'no'
-  state:
-    description:
-      - The C(state) argument configures the state of the username definition
-        as it relates to the device operational configuration.  When set
-        to I(present), the username(s) should be configured in the device active
-        configuration and when set to I(absent) the username(s) should not be
-        in the device active configuration
-    default: present
-    choices: ['present', 'absent']
-"""
-
-EXAMPLES = """
-- name: create a new user
-  nxos_user:
-    name: ansible
-    sshkey: "{{ lookup('file', '~/.ssh/id_rsa.pub') }}"
-    state: present
-
-- name: remove all users except admin
-  nxos_user:
-    purge: yes
-
-- name: set multiple users role
-  aggregate:
-    - name: netop
-    - name: netend
-  role: network-operator
-  state: present
-"""
-
-RETURN = """
-commands:
-  description: The list of configuration mode commands to send to the device
-  returned: always
-  type: list
-  sample:
-    - name ansible
-    - name ansible password password
-start:
-  description: The time the job started
-  returned: always
-  type: str
-  sample: "2016-11-16 10:38:15.126146"
-end:
-  description: The time the job ended
-  returned: always
-  type: str
-  sample: "2016-11-16 10:38:25.595612"
-delta:
-  description: The time elapsed to perform all operations
-  returned: always
-  type: str
-  sample: "0:00:10.469466"
-"""
-from copy import deepcopy
-from functools import partial
-
-from ansible.module_utils.network.nxos.nxos import run_commands, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.six import iteritems
-from ansible.module_utils.network.common.utils import remove_default_spec, to_list
-
-VALID_ROLES = ['network-admin', 'network-operator', 'vdc-admin', 'vdc-operator',
-               'priv-15', 'priv-14', 'priv-13', 'priv-12', 'priv-11', 'priv-10',
-               'priv-9', 'priv-8', 'priv-7', 'priv-6', 'priv-5', 'priv-4',
-               'priv-3', 'priv-2', 'priv-1', 'priv-0']
-
-
-def validate_roles(value, module):
-    for item in value:
-        if item not in VALID_ROLES:
-            module.fail_json(msg='invalid role specified')
-
-
-def map_obj_to_commands(updates, module):
-    commands = list()
-    update_password = module.params['update_password']
-
-    for update in updates:
-        want, have = update
-
-        def needs_update(x):
-            return want.get(x) and (want.get(x) != have.get(x))
-
-        def add(x):
-            return commands.append('username %s %s' % (want['name'], x))
-
-        def remove(x):
-            return commands.append('no username %s %s' % (want['name'], x))
-
-        def configure_roles():
-            if want['roles']:
-                if have:
-                    for item in set(have['roles']).difference(want['roles']):
-                        remove('role %s' % item)
-
-                    for item in set(want['roles']).difference(have['roles']):
-                        add('role %s' % item)
-                else:
-                    for item in want['roles']:
-                        add('role %s' % item)
-
-                return True
-            return False
-
-        if want['state'] == 'absent':
-            commands.append('no username %s' % want['name'])
-            continue
-
-        roles_configured = False
-        if want['state'] == 'present' and not have:
-            roles_configured = configure_roles()
-            if not roles_configured:
-                commands.append('username %s' % want['name'])
-
-        if needs_update('configured_password'):
-            if update_password == 'always' or not have:
-                add('password %s' % want['configured_password'])
-
-        if needs_update('sshkey'):
-            add('sshkey %s' % want['sshkey'])
-
-        if not roles_configured:
-            configure_roles()
-
-    return commands
-
-
-def parse_password(data):
-    if not data.get('remote_login'):
-        return '<PASSWORD>'
-
-
-def parse_roles(data):
-    configured_roles = None
-    if 'TABLE_role' in data:
-        configured_roles = data.get('TABLE_role')['ROW_role']
-
-    roles = list()
-    if configured_roles:
-        for item in to_list(configured_roles):
-            roles.append(item['role'])
-    return roles
-
-
-def map_config_to_obj(module):
-    out = run_commands(module, ['show user-account | json'])
-    data = out[0]
-
-    objects = list()
-
-    for item in to_list(data['TABLE_template']['ROW_template']):
-        objects.append({
-            'name': item['usr_name'],
-            'configured_password': parse_password(item),
-            'sshkey': item.get('sshkey_info'),
-            'roles': parse_roles(item),
-            'state': 'present'
-        })
-    return objects
-
-
-def get_param_value(key, item, module):
-    # if key doesn't exist in the item, get it from module.params
-    if not item.get(key):
-        value = module.params[key]
-
-    # if key does exist, do a type check on it to validate it
-    else:
-        value_type = module.argument_spec[key].get('type', 'str')
-        type_checker = module._CHECK_ARGUMENT_TYPES_DISPATCHER[value_type]
-        type_checker(item[key])
-        value = item[key]
-
-    return value
-
-
-def map_params_to_obj(module):
-    aggregate = module.params['aggregate']
-    if not aggregate:
-        if not module.params['name'] and module.params['purge']:
-            return list()
-        elif not module.params['name']:
-            module.fail_json(msg='username is required')
-        else:
-            collection = [{'name': module.params['name']}]
-    else:
-        collection = list()
-        for item in aggregate:
-            if not isinstance(item, dict):
-                collection.append({'name': item})
-            elif 'name' not in item:
-                module.fail_json(msg='name is required')
-            else:
-                collection.append(item)
-
-    objects = list()
-
-    for item in collection:
-        get_value = partial(get_param_value, item=item, module=module)
-        item.update({
-            'configured_password': get_value('configured_password'),
-            'sshkey': get_value('sshkey'),
-            'roles': get_value('roles'),
-            'state': get_value('state')
-        })
-
-        for key, value in iteritems(item):
-            if value:
-                # validate the param value (if validator func exists)
-                validator = globals().get('validate_%s' % key)
-                if all((value, validator)):
-                    validator(value, module)
-
-        objects.append(item)
-
-    return objects
-
-
-def update_objects(want, have):
-    updates = list()
-    for entry in want:
-        item = next((i for i in have if i['name'] == entry['name']), None)
-        if all((item is None, entry['state'] == 'present')):
-            updates.append((entry, {}))
-        elif item:
-            for key, value in iteritems(entry):
-                if value and value != item[key]:
-                    updates.append((entry, item))
-    return updates
-
-
-def main():
-    """ main entry point for module execution
-    """
-    element_spec = dict(
-        name=dict(),
-        configured_password=dict(no_log=True),
-        update_password=dict(default='always', choices=['on_create', 'always']),
-        roles=dict(type='list', aliases=['role']),
-        sshkey=dict(),
-        state=dict(default='present', choices=['present', 'absent'])
-    )
-
-    aggregate_spec = deepcopy(element_spec)
-
-    # remove default in aggregate spec, to handle common arguments
-    remove_default_spec(aggregate_spec)
-
-    argument_spec = dict(
-        aggregate=dict(type='list', elements='dict', options=aggregate_spec, aliases=['collection', 'users']),
-        purge=dict(type='bool', default=False)
-    )
-
-    argument_spec.update(element_spec)
-    argument_spec.update(nxos_argument_spec)
-
-    mutually_exclusive = [('name', 'aggregate')]
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           mutually_exclusive=mutually_exclusive,
-                           supports_check_mode=True)
-
-    result = {'changed': False}
-
-    want = map_params_to_obj(module)
-    have = map_config_to_obj(module)
-
-    commands = map_obj_to_commands(update_objects(want, have), module)
-
-    if module.params['purge']:
-        want_users = [x['name'] for x in want]
-        have_users = [x['name'] for x in have]
-        for item in set(have_users).difference(want_users):
-            if item != 'admin':
-                item = item.replace("\\", "\\\\")
-                commands.append('no username %s' % item)
-
-    result['commands'] = commands
-
-    # the nxos cli prevents this by rule so capture it and display
-    # a nice failure message
-    if 'no username admin' in commands:
-        module.fail_json(msg='cannot delete the `admin` account')
-
-    if commands:
-        if not module.check_mode:
-            load_config(module, commands)
-        result['changed'] = True
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_vlans.py b/lib/ansible/modules/network/nxos/nxos_vlans.py
deleted file mode 100644
index d1f2ef4da0..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_vlans.py
+++ /dev/null
@@ -1,247 +0,0 @@
-#!/usr/bin/python
-# -*- coding: utf-8 -*-
-# Copyright 2019 Red Hat
-# GNU General Public License v3.0+
-# (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-#############################################
-#                WARNING                    #
-#############################################
-#
-# This file is auto generated by the resource
-#   module builder playbook.
-#
-# Do not edit this file manually.
-#
-# Changes to this file will be over written
-#   by the resource module builder.
-#
-# Changes should be made in the model used to
-#   generate this file or in the resource module
-#   builder template.
-#
-#############################################
-
-"""
-The module file for nxos_vlans
-"""
-
-from __future__ import absolute_import, division, print_function
-__metaclass__ = type
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = """
----
-module: nxos_vlans
-version_added: 2.9
-short_description: Create VLAN and manage VLAN configurations on NX-OS Interfaces
-description: This module creates and manages VLAN configurations on Cisco NX-OS Interfaces.
-author: Trishna Guha (@trishnaguha)
-notes:
-  - Tested against NXOS 7.3.(0)D1(1) on VIRL
-options:
-  config:
-    description: A dictionary of Vlan options
-    type: list
-    suboptions:
-      vlan_id:
-        description:
-          - Vlan ID.
-        type: int
-        required: true
-      name:
-        description:
-          - Name of VLAN.
-        type: str
-      state:
-        description:
-          - Manage operational state of the vlan.
-        type: str
-        choices: ['active', 'suspend']
-      enabled:
-        description:
-          - Manage administrative state of the vlan.
-        type: bool
-      mode:
-        description:
-          - Set vlan mode to classical ethernet or fabricpath.
-            This is a valid option for Nexus 5000, 6000 and 7000 series.
-        type: str
-        choices: ['ce','fabricpath']
-      mapped_vni:
-        description:
-          - The Virtual Network Identifier (VNI) ID that is mapped to the
-            VLAN.
-        type: int
-  state:
-    description:
-      - The state of the configuration after module completion.
-    type: str
-    choices:
-      - merged
-      - replaced
-      - overridden
-      - deleted
-    default: merged
-"""
-EXAMPLES = """
-# Using merged
-
-# Before state:
-# -------------
-# vlan 1
-
-- name: Merge provided configuration with device configuration.
-  nxos_vlans:
-    config:
-      - vlan_id: 5
-        name: test-vlan5
-      - vlan_id: 10
-        enabled: False
-    state: merged
-
-# After state:
-# ------------
-# vlan 5
-#   name test-vlan5
-#   state active
-#   no shutdown
-# vlan 10
-#   state active
-#   shutdown
-
-
-# Using replaced
-
-# Before state:
-# -------------
-# vlan 1
-# vlan 5
-#   name test-vlan5
-# vlan 10
-#   shutdown
-
-- name: Replace device configuration of specified vlan with provided configuration.
-  nxos_vlans:
-    config:
-      - vlan_id: 5
-        name: test-vlan
-        enabled: False
-      - vlan_id: 10
-        enabled: False
-    state: replaced
-
-# After state:
-# ------------
-# vlan 1
-# vlan 5
-#   name test-vlan
-#   state active
-#   shutdown
-# vlan 10
-#   state active
-#   shutdown
-
-
-# Using overridden
-
-# Before state:
-# -------------
-# vlan 1
-# vlan 3
-#   name testing
-# vlan 5
-#   name test-vlan5
-#   shutdown
-# vlan 10
-#   shutdown
-
-- name: Override device configuration of all vlans with provided configuration.
-  nxos_vlans:
-    config:
-      - vlan_id: 5
-        name: test-vlan
-      - vlan_id: 10
-        state: active
-    state: overridden
-
-# After state:
-# ------------
-# vlan 1
-# vlan 5
-#   name test-vlan
-#   state active
-#   no shutdown
-# vlan 10
-#   state active
-#   no shutdown
-
-
-# Using deleted
-
-# Before state:
-# -------------
-# vlan 1
-# vlan 5
-# vlan 10
-
-- name: Delete vlans.
-  nxos_vlans:
-    config:
-      - vlan_id: 5
-      - vlan_id: 10
-    state: deleted
-
-# After state:
-# ------------
-# vlan 1
-
-
-"""
-RETURN = """
-before:
-  description: The configuration as structured data prior to module invocation.
-  returned: always
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-after:
-  description: The configuration as structured data after module completion.
-  returned: when changed
-  type: list
-  sample: >
-    The configuration returned will always be in the same format
-     of the parameters above.
-commands:
-  description: The set of commands pushed to the remote device.
-  returned: always
-  type: list
-  sample: ['vlan 5', 'name test-vlan5', 'state suspend']
-"""
-
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.argspec.vlans.vlans import VlansArgs
-from ansible.module_utils.network.nxos.config.vlans.vlans import Vlans
-
-
-def main():
-    """
-    Main entry point for module execution
-
-    :returns: the result form module invocation
-    """
-    module = AnsibleModule(argument_spec=VlansArgs.argument_spec,
-                           supports_check_mode=True)
-
-    result = Vlans(module).execute_module()
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_vpc.py b/lib/ansible/modules/network/nxos/nxos_vpc.py
deleted file mode 100644
index 518fdbcbf4..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_vpc.py
+++ /dev/null
@@ -1,454 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_vpc
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages global VPC configuration
-description:
-  - Manages global VPC configuration
-author:
-  - Jason Edelman (@jedelman8)
-  - Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - The feature vpc must be enabled before this module can be used
-  - If not using management vrf, vrf must be globally on the device
-    before using in the pkl config
-  - Although source IP isn't required on the command line it is
-    required when using this module.  The PKL VRF must also be configured
-    prior to using this module.
-  - Both pkl_src and pkl_dest are needed when changing PKL VRF.
-options:
-  domain:
-    description:
-      - VPC domain
-    required: true
-  role_priority:
-    description:
-      - Role priority for device. Remember lower is better.
-  system_priority:
-    description:
-      - System priority device.  Remember they must match between peers.
-  pkl_src:
-    description:
-      - Source IP address used for peer keepalive link
-  pkl_dest:
-    description:
-      - Destination (remote) IP address used for peer keepalive link
-      - pkl_dest is required whenever pkl options are used.
-  pkl_vrf:
-    description:
-      - VRF used for peer keepalive link
-      - The VRF must exist on the device before using pkl_vrf.
-      - "(Note) 'default' is an overloaded term: Default vrf context for pkl_vrf is 'management'; 'pkl_vrf: default' refers to the literal 'default' rib."
-    default: management
-  peer_gw:
-    description:
-      - Enables/Disables peer gateway
-    type: bool
-  # TBD: no support for peer_gw_exclude_gw
-  # peer_gw_exclude_gw:
-  #   description:
-  #     - Range of VLANs to be excluded from peer-gateway
-  #   type: str
-  auto_recovery:
-    description:
-      - Enables/Disables auto recovery on platforms that support disable
-      - timers are not modifiable with this attribute
-      - mutually exclusive with auto_recovery_reload_delay
-    type: bool
-  auto_recovery_reload_delay:
-    description:
-      - Manages auto-recovery reload-delay timer in seconds
-      - mutually exclusive with auto_recovery
-    type: str
-    version_added: "2.9"
-  delay_restore:
-    description:
-      - manages delay restore command and config value in seconds
-    type: str
-  delay_restore_interface_vlan:
-    description:
-      - manages delay restore interface-vlan command and config value in seconds
-      - not supported on all platforms
-    type: str
-    version_added: "2.9"
-  delay_restore_orphan_port:
-    description:
-      - manages delay restore orphan-port command and config value in seconds
-      - not supported on all platforms
-    type: str
-    version_added: "2.9"
-  state:
-    description:
-      - Manages desired state of the resource
-    required: true
-    choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-- name: configure a simple asn
-  nxos_vpc:
-    domain: 100
-    role_priority: 1000
-    system_priority: 2000
-    pkl_dest: 192.168.100.4
-    pkl_src: 10.1.100.20
-    peer_gw: true
-    auto_recovery: true
-
-- name: configure
-  nxos_vpc:
-    domain: 100
-    role_priority: 32667
-    system_priority: 2000
-    peer_gw: true
-    pkl_src: 10.1.100.2
-    pkl_dest: 192.168.100.4
-    auto_recovery: true
-
-- name: Configure VPC with delay restore and existing keepalive VRF
-  nxos_vpc:
-    domain: 10
-    role_priority: 28672
-    system_priority: 2000
-    delay_restore: 180
-    peer_gw: true
-    pkl_src: 1.1.1.2
-    pkl_dest: 1.1.1.1
-    pkl_vrf: vpckeepalive
-    auto_recovery: true
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["vpc domain 100",
-            "peer-keepalive destination 192.168.100.4 source 10.1.100.20 vrf management",
-            "auto-recovery", "peer-gateway"]
-'''
-
-import re
-from ansible.module_utils.network.nxos.nxos import get_config, load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-CONFIG_ARGS = {
-    'role_priority': 'role priority {role_priority}',
-    'system_priority': 'system-priority {system_priority}',
-    'delay_restore': 'delay restore {delay_restore}',
-    'delay_restore_interface_vlan': 'delay restore interface-vlan {delay_restore_interface_vlan}',
-    'delay_restore_orphan_port': 'delay restore orphan-port {delay_restore_orphan_port}',
-    'peer_gw': '{peer_gw} peer-gateway',
-    'auto_recovery': '{auto_recovery} auto-recovery',
-    'auto_recovery_reload_delay': 'auto-recovery reload-delay {auto_recovery_reload_delay}',
-}
-
-PARAM_TO_DEFAULT_KEYMAP = {
-    'delay_restore': '60',
-    'delay_restore_interface_vlan': '10',
-    'delay_restore_orphan_port': '0',
-    'role_priority': '32667',
-    'system_priority': '32667',
-    'peer_gw': False,
-    'auto_recovery_reload_delay': 240,
-}
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_vrf_list(module):
-
-    try:
-        body = run_commands(module, ['show vrf all | json'])[0]
-        vrf_table = body['TABLE_vrf']['ROW_vrf']
-    except (KeyError, AttributeError):
-        return []
-
-    vrf_list = []
-    if vrf_table:
-        for each in vrf_table:
-            vrf_list.append(str(each['vrf_name'].lower()))
-
-    return vrf_list
-
-
-def get_auto_recovery_default(module):
-    auto = False
-    data = run_commands(module, ['show inventory | json'])[0]
-    pid = data['TABLE_inv']['ROW_inv'][0]['productid']
-    if re.search(r'N7K', pid):
-        auto = True
-    elif re.search(r'N9K', pid):
-        data = run_commands(module, ['show hardware | json'])[0]
-        ver = data['kickstart_ver_str']
-        if re.search(r'7.0\(3\)F', ver):
-            auto = True
-
-    return auto
-
-
-def get_vpc(module):
-    body = run_commands(module, ['show vpc | json'])[0]
-    if body:
-        domain = str(body['vpc-domain-id'])
-    else:
-        body = run_commands(module, ['show run vpc | inc domain'])[0]
-        if body:
-            domain = body.split()[2]
-        else:
-            domain = 'not configured'
-
-    vpc = {}
-    if domain != 'not configured':
-        run = get_config(module, flags=['vpc all'])
-        if run:
-            vpc['domain'] = domain
-            for key in PARAM_TO_DEFAULT_KEYMAP.keys():
-                vpc[key] = PARAM_TO_DEFAULT_KEYMAP.get(key)
-            vpc['auto_recovery'] = get_auto_recovery_default(module)
-            vpc_list = run.split('\n')
-            for each in vpc_list:
-                if 'role priority' in each:
-                    line = each.split()
-                    vpc['role_priority'] = line[-1]
-                if 'system-priority' in each:
-                    line = each.split()
-                    vpc['system_priority'] = line[-1]
-                if re.search(r'delay restore \d+', each):
-                    line = each.split()
-                    vpc['delay_restore'] = line[-1]
-                if 'delay restore interface-vlan' in each:
-                    line = each.split()
-                    vpc['delay_restore_interface_vlan'] = line[-1]
-                if 'delay restore orphan-port' in each:
-                    line = each.split()
-                    vpc['delay_restore_orphan_port'] = line[-1]
-                if 'auto-recovery' in each:
-                    vpc['auto_recovery'] = False if 'no ' in each else True
-                    line = each.split()
-                    vpc['auto_recovery_reload_delay'] = line[-1]
-                if 'peer-gateway' in each:
-                    vpc['peer_gw'] = False if 'no ' in each else True
-                if 'peer-keepalive destination' in each:
-                    # destination is reqd; src & vrf are optional
-                    m = re.search(r'destination (?P<pkl_dest>[\d.]+)'
-                                  r'(?:.* source (?P<pkl_src>[\d.]+))*'
-                                  r'(?:.* vrf (?P<pkl_vrf>\S+))*',
-                                  each)
-                    if m:
-                        for pkl in m.groupdict().keys():
-                            if m.group(pkl):
-                                vpc[pkl] = m.group(pkl)
-    return vpc
-
-
-def pkl_dependencies(module, delta, existing):
-    """peer-keepalive dependency checking.
-    1. 'destination' is required with all pkl configs.
-    2. If delta has optional pkl keywords present, then all optional pkl
-       keywords in existing must be added to delta, otherwise the device cli
-       will remove those values when the new config string is issued.
-    3. The desired behavior for this set of properties is to merge changes;
-       therefore if an optional pkl property exists on the device but not
-       in the playbook, then that existing property should be retained.
-    Example:
-      CLI:       peer-keepalive dest 10.1.1.1 source 10.1.1.2 vrf orange
-      Playbook:  {pkl_dest: 10.1.1.1, pkl_vrf: blue}
-      Result:    peer-keepalive dest 10.1.1.1 source 10.1.1.2 vrf blue
-    """
-    pkl_existing = [i for i in existing.keys() if i.startswith('pkl')]
-    for pkl in pkl_existing:
-        param = module.params.get(pkl)
-        if not delta.get(pkl):
-            if param and param == existing[pkl]:
-                # delta is missing this param because it's idempotent;
-                # however another pkl command has changed; therefore
-                # explicitly add it to delta so that the cli retains it.
-                delta[pkl] = existing[pkl]
-            elif param is None and existing[pkl]:
-                # retain existing pkl commands even if not in playbook
-                delta[pkl] = existing[pkl]
-
-
-def get_commands_to_config_vpc(module, vpc, domain, existing):
-    vpc = dict(vpc)
-
-    domain_only = vpc.get('domain')
-
-    commands = []
-    if 'pkl_dest' in vpc:
-        pkl_command = 'peer-keepalive destination {pkl_dest}'.format(**vpc)
-        if 'pkl_src' in vpc:
-            pkl_command += ' source {pkl_src}'.format(**vpc)
-        if 'pkl_vrf' in vpc:
-            pkl_command += ' vrf {pkl_vrf}'.format(**vpc)
-        commands.append(pkl_command)
-
-    if 'auto_recovery' in vpc:
-        if not vpc.get('auto_recovery'):
-            vpc['auto_recovery'] = 'no'
-        else:
-            vpc['auto_recovery'] = ''
-
-    if 'peer_gw' in vpc:
-        if not vpc.get('peer_gw'):
-            vpc['peer_gw'] = 'no'
-        else:
-            vpc['peer_gw'] = ''
-
-    for param in vpc:
-        command = CONFIG_ARGS.get(param)
-        if command is not None:
-            command = command.format(**vpc).strip()
-            if 'peer-gateway' in command:
-                commands.append('terminal dont-ask')
-            commands.append(command)
-
-    if commands or domain_only:
-        commands.insert(0, 'vpc domain {0}'.format(domain))
-    return commands
-
-
-def main():
-    argument_spec = dict(
-        domain=dict(required=True, type='str'),
-        role_priority=dict(required=False, type='str'),
-        system_priority=dict(required=False, type='str'),
-        pkl_src=dict(required=False),
-        pkl_dest=dict(required=False),
-        pkl_vrf=dict(required=False),
-        peer_gw=dict(required=False, type='bool'),
-        auto_recovery=dict(required=False, type='bool'),
-        auto_recovery_reload_delay=dict(required=False, type='str'),
-        delay_restore=dict(required=False, type='str'),
-        delay_restore_interface_vlan=dict(required=False, type='str'),
-        delay_restore_orphan_port=dict(required=False, type='str'),
-        state=dict(choices=['absent', 'present'], default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    mutually_exclusive = [('auto_recovery', 'auto_recovery_reload_delay')]
-    module = AnsibleModule(argument_spec=argument_spec,
-                           mutually_exclusive=mutually_exclusive,
-                           supports_check_mode=True)
-
-    warnings = list()
-    results = {'changed': False, 'warnings': warnings}
-
-    domain = module.params['domain']
-    role_priority = module.params['role_priority']
-    system_priority = module.params['system_priority']
-    pkl_src = module.params['pkl_src']
-    pkl_dest = module.params['pkl_dest']
-    pkl_vrf = module.params['pkl_vrf']
-    peer_gw = module.params['peer_gw']
-    auto_recovery = module.params['auto_recovery']
-    auto_recovery_reload_delay = module.params['auto_recovery_reload_delay']
-    delay_restore = module.params['delay_restore']
-    delay_restore_interface_vlan = module.params['delay_restore_interface_vlan']
-    delay_restore_orphan_port = module.params['delay_restore_orphan_port']
-    state = module.params['state']
-
-    args = dict(domain=domain, role_priority=role_priority,
-                system_priority=system_priority, pkl_src=pkl_src,
-                pkl_dest=pkl_dest, pkl_vrf=pkl_vrf, peer_gw=peer_gw,
-                auto_recovery=auto_recovery,
-                auto_recovery_reload_delay=auto_recovery_reload_delay,
-                delay_restore=delay_restore,
-                delay_restore_interface_vlan=delay_restore_interface_vlan,
-                delay_restore_orphan_port=delay_restore_orphan_port,
-                )
-
-    if not pkl_dest:
-        if pkl_src:
-            module.fail_json(msg='dest IP for peer-keepalive is required'
-                                 ' when src IP is present')
-        elif pkl_vrf:
-            if pkl_vrf != 'management':
-                module.fail_json(msg='dest and src IP for peer-keepalive are required'
-                                     ' when vrf is present')
-            else:
-                module.fail_json(msg='dest IP for peer-keepalive is required'
-                                     ' when vrf is present')
-    if pkl_vrf:
-        if pkl_vrf.lower() not in get_vrf_list(module):
-            module.fail_json(msg='The VRF you are trying to use for the peer '
-                                 'keepalive link is not on device yet. Add it'
-                                 ' first, please.')
-    proposed = dict((k, v) for k, v in args.items() if v is not None)
-    existing = get_vpc(module)
-
-    commands = []
-    if state == 'present':
-        delta = {}
-        for key, value in proposed.items():
-            if str(value).lower() == 'default' and key != 'pkl_vrf':
-                # 'default' is a reserved word for vrf
-                value = PARAM_TO_DEFAULT_KEYMAP.get(key)
-            if existing.get(key) != value:
-                delta[key] = value
-
-        if delta:
-            pkl_dependencies(module, delta, existing)
-            command = get_commands_to_config_vpc(module, delta, domain, existing)
-            commands.append(command)
-    elif state == 'absent':
-        if existing:
-            if domain != existing['domain']:
-                module.fail_json(msg="You are trying to remove a domain that "
-                                     "does not exist on the device")
-            else:
-                commands.append('terminal dont-ask')
-                commands.append('no vpc domain {0}'.format(domain))
-
-    cmds = flatten_list(commands)
-    results['commands'] = cmds
-
-    if cmds:
-        results['changed'] = True
-        if not module.check_mode:
-            load_config(module, cmds)
-            if 'configure' in cmds:
-                cmds.pop(0)
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_vpc_interface.py b/lib/ansible/modules/network/nxos/nxos_vpc_interface.py
deleted file mode 100644
index 01eac1cf2c..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_vpc_interface.py
+++ /dev/null
@@ -1,329 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = '''
----
-module: nxos_vpc_interface
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages interface VPC configuration
-description:
-  - Manages interface VPC configuration
-author:
-  - Jason Edelman (@jedelman8)
-  - Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - Either vpc or peer_link param is required, but not both.
-  - C(state=absent) removes whatever VPC config is on a port-channel
-    if one exists.
-  - Re-assigning a vpc or peerlink from one portchannel to another is not
-    supported.  The module will force the user to unconfigure an existing
-    vpc/pl before configuring the same value on a new portchannel
-options:
-  portchannel:
-    description:
-      - Group number of the portchannel that will be configured.
-    required: true
-  vpc:
-    description:
-      - VPC group/id that will be configured on associated portchannel.
-  peer_link:
-    description:
-      - Set to true/false for peer link config on associated portchannel.
-    type: bool
-  state:
-    description:
-      - Manages desired state of the resource.
-    required: true
-    choices: ['present','absent']
-    default: present
-'''
-
-EXAMPLES = '''
-- nxos_vpc_interface:
-    portchannel: 10
-    vpc: 100
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["interface port-channel100", "vpc 10"]
-'''
-
-from ansible.module_utils.network.nxos.nxos import get_config, load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_portchannel_list(module):
-    portchannels = []
-    pc_list = []
-
-    try:
-        body = run_commands(module, ['show port-channel summary | json'])[0]
-        pc_list = body['TABLE_channel']['ROW_channel']
-    except (KeyError, AttributeError, TypeError):
-        return portchannels
-
-    if pc_list:
-        if isinstance(pc_list, dict):
-            pc_list = [pc_list]
-
-        for pc in pc_list:
-            portchannels.append(pc['group'])
-
-    return portchannels
-
-
-def get_existing_portchannel_to_vpc_mappings(module):
-    pc_vpc_mapping = {}
-
-    try:
-        body = run_commands(module, ['show vpc brief | json'])[0]
-        vpc_table = body['TABLE_vpc']['ROW_vpc']
-    except (KeyError, AttributeError, TypeError):
-        vpc_table = None
-
-    if vpc_table:
-        if isinstance(vpc_table, dict):
-            vpc_table = [vpc_table]
-
-        for vpc in vpc_table:
-            pc_vpc_mapping[str(vpc['vpc-id'])] = str(vpc['vpc-ifindex'])
-
-    return pc_vpc_mapping
-
-
-def peer_link_exists(module):
-    found = False
-    run = get_config(module, flags=['vpc'])
-
-    vpc_list = run.split('\n')
-    for each in vpc_list:
-        if 'peer-link' in each:
-            found = True
-    return found
-
-
-def get_active_vpc_peer_link(module):
-    peer_link = None
-
-    try:
-        body = run_commands(module, ['show vpc brief | json'])[0]
-        peer_link = body['TABLE_peerlink']['ROW_peerlink']['peerlink-ifindex']
-    except (KeyError, AttributeError, TypeError):
-        return peer_link
-
-    return peer_link
-
-
-def get_portchannel_vpc_config(module, portchannel):
-    peer_link_pc = None
-    peer_link = False
-    vpc = ""
-    pc = ""
-    config = {}
-
-    try:
-        body = run_commands(module, ['show vpc brief | json'])[0]
-        table = body['TABLE_peerlink']['ROW_peerlink']
-    except (KeyError, AttributeError, TypeError):
-        table = {}
-
-    if table:
-        peer_link_pc = table.get('peerlink-ifindex', None)
-
-    if peer_link_pc:
-        plpc = str(peer_link_pc[2:])
-        if portchannel == plpc:
-            config['portchannel'] = portchannel
-            config['peer-link'] = True
-            config['vpc'] = vpc
-
-    mapping = get_existing_portchannel_to_vpc_mappings(module)
-
-    for existing_vpc, port_channel in mapping.items():
-        port_ch = str(port_channel[2:])
-        if port_ch == portchannel:
-            pc = port_ch
-            vpc = str(existing_vpc)
-
-            config['portchannel'] = pc
-            config['peer-link'] = peer_link
-            config['vpc'] = vpc
-
-    return config
-
-
-def get_commands_to_config_vpc_interface(portchannel, delta, config_value, existing):
-    commands = []
-
-    if not delta.get('peer-link') and existing.get('peer-link'):
-        commands.append('no vpc peer-link')
-        commands.insert(0, 'interface port-channel{0}'.format(portchannel))
-
-    elif delta.get('peer-link') and not existing.get('peer-link'):
-        commands.append('vpc peer-link')
-        commands.insert(0, 'interface port-channel{0}'.format(portchannel))
-
-    elif delta.get('vpc') and not existing.get('vpc'):
-        command = 'vpc {0}'.format(config_value)
-        commands.append(command)
-        commands.insert(0, 'interface port-channel{0}'.format(portchannel))
-
-    return commands
-
-
-def state_present(portchannel, delta, config_value, existing):
-    commands = []
-
-    command = get_commands_to_config_vpc_interface(
-        portchannel,
-        delta,
-        config_value,
-        existing
-    )
-    commands.append(command)
-
-    return commands
-
-
-def state_absent(portchannel, existing):
-    commands = []
-    if existing.get('vpc'):
-        command = 'no vpc'
-        commands.append(command)
-    elif existing.get('peer-link'):
-        command = 'no vpc peer-link'
-        commands.append(command)
-    if commands:
-        commands.insert(0, 'interface port-channel{0}'.format(portchannel))
-
-    return commands
-
-
-def main():
-    argument_spec = dict(
-        portchannel=dict(required=True, type='str'),
-        vpc=dict(required=False, type='str'),
-        peer_link=dict(required=False, type='bool'),
-        state=dict(choices=['absent', 'present'], default='present')
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           mutually_exclusive=[['vpc', 'peer_link']],
-                           supports_check_mode=True)
-
-    warnings = list()
-    commands = []
-    results = {'changed': False, 'warnings': warnings}
-
-    portchannel = module.params['portchannel']
-    vpc = module.params['vpc']
-    peer_link = module.params['peer_link']
-    state = module.params['state']
-
-    args = {'portchannel': portchannel, 'vpc': vpc, 'peer-link': peer_link}
-    active_peer_link = None
-
-    if portchannel not in get_portchannel_list(module):
-        if not portchannel.isdigit() or int(portchannel) not in get_portchannel_list(module):
-            module.fail_json(msg="The portchannel you are trying to make a"
-                                 " VPC or PL is not created yet. "
-                                 "Create it first!")
-    if vpc:
-        mapping = get_existing_portchannel_to_vpc_mappings(module)
-
-        if vpc in mapping and portchannel != mapping[vpc].strip('Po'):
-            module.fail_json(msg="This vpc is already configured on "
-                                 "another portchannel. Remove it first "
-                                 "before trying to assign it here. ",
-                             existing_portchannel=mapping[vpc])
-
-        for vpcid, existing_pc in mapping.items():
-            if portchannel == existing_pc.strip('Po') and vpcid != vpc:
-                module.fail_json(msg="This portchannel already has another"
-                                     " VPC configured. Remove it first "
-                                     "before assigning this one",
-                                 existing_vpc=vpcid)
-
-        if peer_link_exists(module):
-            active_peer_link = get_active_vpc_peer_link(module)
-            if active_peer_link[-2:] == portchannel:
-                module.fail_json(msg="That port channel is the current "
-                                     "PEER LINK. Remove it if you want it"
-                                     " to be a VPC")
-        config_value = vpc
-
-    elif peer_link is not None:
-        if peer_link_exists(module):
-            active_peer_link = get_active_vpc_peer_link(module)[2::]
-            if active_peer_link != portchannel:
-                if peer_link:
-                    module.fail_json(msg="A peer link already exists on"
-                                         " the device. Remove it first",
-                                     current_peer_link='Po{0}'.format(active_peer_link))
-        config_value = 'peer-link'
-
-    proposed = dict((k, v) for k, v in args.items() if v is not None)
-    existing = get_portchannel_vpc_config(module, portchannel)
-
-    if state == 'present':
-        delta = dict(set(proposed.items()).difference(existing.items()))
-        if delta:
-            commands = state_present(portchannel, delta, config_value, existing)
-
-    elif state == 'absent' and existing:
-        commands = state_absent(portchannel, existing)
-
-    cmds = flatten_list(commands)
-    if cmds:
-        if module.check_mode:
-            module.exit_json(changed=True, commands=cmds)
-        else:
-            load_config(module, cmds)
-            results['changed'] = True
-            if 'configure' in cmds:
-                cmds.pop(0)
-
-    results['commands'] = cmds
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_vrf.py b/lib/ansible/modules/network/nxos/nxos_vrf.py
deleted file mode 100644
index fc2f1877ae..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_vrf.py
+++ /dev/null
@@ -1,534 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_vrf
-extends_documentation_fragment: nxos
-version_added: "2.1"
-short_description: Manages global VRF configuration.
-description:
-  - This module provides declarative management of VRFs
-    on CISCO NXOS network devices.
-author:
-  - Jason Edelman (@jedelman8)
-  - Gabriele Gerbino (@GGabriele)
-  - Trishna Guha (@trishnaguha)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - Cisco NX-OS creates the default VRF by itself. Therefore,
-    you're not allowed to use default as I(vrf) name in this module.
-  - C(vrf) name must be shorter than 32 chars.
-  - VRF names are not case sensible in NX-OS. Anyway, the name is stored
-    just like it's inserted by the user and it'll not be changed again
-    unless the VRF is removed and re-created. i.e. C(vrf=NTC) will create
-    a VRF named NTC, but running it again with C(vrf=ntc) will not cause
-    a configuration change.
-options:
-  name:
-    description:
-      - Name of VRF to be managed.
-    required: true
-    aliases: [vrf]
-  admin_state:
-    description:
-      - Administrative state of the VRF.
-    default: up
-    choices: ['up','down']
-  vni:
-    description:
-      - Specify virtual network identifier. Valid values are Integer
-        or keyword 'default'.
-    version_added: "2.2"
-  rd:
-    description:
-      - VPN Route Distinguisher (RD). Valid values are a string in
-        one of the route-distinguisher formats (ASN2:NN, ASN4:NN, or
-        IPV4:NN); the keyword 'auto', or the keyword 'default'.
-    version_added: "2.2"
-  interfaces:
-    description:
-      - List of interfaces to check the VRF has been
-        configured correctly or keyword 'default'.
-    version_added: 2.5
-  associated_interfaces:
-    description:
-      - This is a intent option and checks the operational state of the for given vrf C(name)
-        for associated interfaces. If the value in the C(associated_interfaces) does not match with
-        the operational state of vrf interfaces on device it will result in failure.
-    version_added: "2.5"
-  aggregate:
-    description: List of VRFs definitions.
-    version_added: 2.5
-  purge:
-    description:
-      - Purge VRFs not defined in the I(aggregate) parameter.
-    type: bool
-    default: 'no'
-    version_added: 2.5
-  state:
-    description:
-      - Manages desired state of the resource.
-    default: present
-    choices: ['present','absent']
-  description:
-    description:
-      - Description of the VRF or keyword 'default'.
-  delay:
-    description:
-      - Time in seconds to wait before checking for the operational state on remote
-        device. This wait is applicable for operational state arguments.
-    default: 10
-'''
-
-EXAMPLES = '''
-- name: Ensure ntc VRF exists on switch
-  nxos_vrf:
-    name: ntc
-    description: testing
-    state: present
-
-- name: Aggregate definition of VRFs
-  nxos_vrf:
-    aggregate:
-      - { name: test1, description: Testing, admin_state: down }
-      - { name: test2, interfaces: Ethernet1/2 }
-
-- name: Aggregate definitions of VRFs with Purge
-  nxos_vrf:
-    aggregate:
-      - { name: ntc1, description: purge test1 }
-      - { name: ntc2, description: purge test2 }
-    state: present
-    purge: yes
-
-- name: Delete VRFs exist on switch
-  nxos_vrf:
-    aggregate:
-      - { name: ntc1 }
-      - { name: ntc2 }
-    state: absent
-
-- name: Assign interfaces to VRF declaratively
-  nxos_vrf:
-    name: test1
-    interfaces:
-      - Ethernet2/3
-      - Ethernet2/5
-
-- name: Check interfaces assigned to VRF
-  nxos_vrf:
-    name: test1
-    associated_interfaces:
-      - Ethernet2/3
-      - Ethernet2/5
-
-- name: Ensure VRF is tagged with interface Ethernet2/5 only (Removes from Ethernet2/3)
-  nxos_vrf:
-    name: test1
-    interfaces:
-      - Ethernet2/5
-
-- name: Delete VRF
-  nxos_vrf:
-    name: ntc
-    state: absent
-'''
-
-RETURN = '''
-commands:
-  description: commands sent to the device
-  returned: always
-  type: list
-  sample:
-    - vrf context ntc
-    - no shutdown
-    - interface Ethernet1/2
-    - no switchport
-    - vrf member test2
-'''
-
-import re
-import time
-
-from copy import deepcopy
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec, get_interface_type
-from ansible.module_utils.network.common.utils import remove_default_spec
-
-
-def search_obj_in_list(name, lst):
-    for o in lst:
-        if o['name'] == name:
-            return o
-
-
-def execute_show_command(command, module):
-    if 'show run' not in command:
-        output = 'json'
-    else:
-        output = 'text'
-    cmds = [{
-        'command': command,
-        'output': output,
-    }]
-    body = run_commands(module, cmds)
-    return body
-
-
-def get_existing_vrfs(module):
-    objs = list()
-    command = "show vrf all"
-    try:
-        body = execute_show_command(command, module)[0]
-    except IndexError:
-        return list()
-    try:
-        vrf_table = body['TABLE_vrf']['ROW_vrf']
-    except (TypeError, IndexError, KeyError):
-        return list()
-
-    if isinstance(vrf_table, list):
-        for vrf in vrf_table:
-            obj = {}
-            obj['name'] = vrf['vrf_name']
-            objs.append(obj)
-
-    elif isinstance(vrf_table, dict):
-        obj = {}
-        obj['name'] = vrf_table['vrf_name']
-        objs.append(obj)
-
-    return objs
-
-
-def map_obj_to_commands(updates, module):
-    commands = list()
-    want, have = updates
-    state = module.params['state']
-    purge = module.params['purge']
-
-    args = ('rd', 'description', 'vni')
-
-    for w in want:
-        name = w['name']
-        admin_state = w['admin_state']
-        vni = w['vni']
-        interfaces = w.get('interfaces') or []
-        if purge:
-            state = "absent"
-        else:
-            state = w['state']
-        del w['state']
-
-        obj_in_have = search_obj_in_list(name, have)
-        if state == 'absent' and obj_in_have:
-            commands.append('no vrf context {0}'.format(name))
-
-        elif state == 'present':
-            if not obj_in_have:
-                commands.append('vrf context {0}'.format(name))
-                for item in args:
-                    candidate = w.get(item)
-                    if candidate and candidate != 'default':
-                        cmd = item + ' ' + str(candidate)
-                        commands.append(cmd)
-                if admin_state == 'up':
-                    commands.append('no shutdown')
-                elif admin_state == 'down':
-                    commands.append('shutdown')
-                commands.append('exit')
-
-                if interfaces and interfaces[0] != 'default':
-                    for i in interfaces:
-                        commands.append('interface {0}'.format(i))
-                        if get_interface_type(i) in ('ethernet', 'portchannel'):
-                            commands.append('no switchport')
-                        commands.append('vrf member {0}'.format(name))
-
-            else:
-                # If vni is already configured on vrf, unconfigure it first.
-                if vni:
-                    if obj_in_have.get('vni') and vni != obj_in_have.get('vni'):
-                        commands.append('no vni {0}'.format(obj_in_have.get('vni')))
-
-                for item in args:
-                    candidate = w.get(item)
-                    if candidate == 'default':
-                        if obj_in_have.get(item):
-                            cmd = 'no ' + item + ' ' + obj_in_have.get(item)
-                            commands.append(cmd)
-                    elif candidate and candidate != obj_in_have.get(item):
-                        cmd = item + ' ' + str(candidate)
-                        commands.append(cmd)
-                if admin_state and admin_state != obj_in_have.get('admin_state'):
-                    if admin_state == 'up':
-                        commands.append('no shutdown')
-                    elif admin_state == 'down':
-                        commands.append('shutdown')
-
-                if commands:
-                    commands.insert(0, 'vrf context {0}'.format(name))
-                    commands.append('exit')
-
-                if interfaces and interfaces[0] != 'default':
-                    if not obj_in_have['interfaces']:
-                        for i in interfaces:
-                            commands.append('vrf context {0}'.format(name))
-                            commands.append('exit')
-                            commands.append('interface {0}'.format(i))
-                            if get_interface_type(i) in ('ethernet', 'portchannel'):
-                                commands.append('no switchport')
-                            commands.append('vrf member {0}'.format(name))
-
-                    elif set(interfaces) != set(obj_in_have['interfaces']):
-                        missing_interfaces = list(set(interfaces) - set(obj_in_have['interfaces']))
-                        for i in missing_interfaces:
-                            commands.append('vrf context {0}'.format(name))
-                            commands.append('exit')
-                            commands.append('interface {0}'.format(i))
-                            if get_interface_type(i) in ('ethernet', 'portchannel'):
-                                commands.append('no switchport')
-                            commands.append('vrf member {0}'.format(name))
-
-                        superfluous_interfaces = list(set(obj_in_have['interfaces']) - set(interfaces))
-                        for i in superfluous_interfaces:
-                            commands.append('vrf context {0}'.format(name))
-                            commands.append('exit')
-                            commands.append('interface {0}'.format(i))
-                            if get_interface_type(i) in ('ethernet', 'portchannel'):
-                                commands.append('no switchport')
-                            commands.append('no vrf member {0}'.format(name))
-                elif interfaces and interfaces[0] == 'default':
-                    if obj_in_have['interfaces']:
-                        for i in obj_in_have['interfaces']:
-                            commands.append('vrf context {0}'.format(name))
-                            commands.append('exit')
-                            commands.append('interface {0}'.format(i))
-                            if get_interface_type(i) in ('ethernet', 'portchannel'):
-                                commands.append('no switchport')
-                            commands.append('no vrf member {0}'.format(name))
-
-    if purge:
-        existing = get_existing_vrfs(module)
-        if existing:
-            for h in existing:
-                if h['name'] in ('default', 'management'):
-                    pass
-                else:
-                    obj_in_want = search_obj_in_list(h['name'], want)
-                    if not obj_in_want:
-                        commands.append('no vrf context {0}'.format(h['name']))
-
-    return commands
-
-
-def validate_vrf(name, module):
-    if name:
-        name = name.strip()
-        if name == 'default':
-            module.fail_json(msg='cannot use default as name of a VRF')
-        elif len(name) > 32:
-            module.fail_json(msg='VRF name exceeded max length of 32', name=name)
-        else:
-            return name
-
-
-def map_params_to_obj(module):
-    obj = []
-    aggregate = module.params.get('aggregate')
-    if aggregate:
-        for item in aggregate:
-            for key in item:
-                if item.get(key) is None:
-                    item[key] = module.params[key]
-
-            d = item.copy()
-            d['name'] = validate_vrf(d['name'], module)
-            obj.append(d)
-    else:
-        obj.append({
-            'name': validate_vrf(module.params['name'], module),
-            'description': module.params['description'],
-            'vni': module.params['vni'],
-            'rd': module.params['rd'],
-            'admin_state': module.params['admin_state'],
-            'state': module.params['state'],
-            'interfaces': module.params['interfaces'],
-            'associated_interfaces': module.params['associated_interfaces']
-        })
-    return obj
-
-
-def get_value(arg, config, module):
-    extra_arg_regex = re.compile(r'(?:{0}\s)(?P<value>.*)$'.format(arg), re.M)
-    value = ''
-    if arg in config:
-        value = extra_arg_regex.search(config).group('value')
-    return value
-
-
-def map_config_to_obj(want, element_spec, module):
-    objs = list()
-
-    for w in want:
-        obj = deepcopy(element_spec)
-        del obj['delay']
-        del obj['state']
-
-        command = 'show vrf {0}'.format(w['name'])
-        try:
-            body = execute_show_command(command, module)[0]
-            vrf_table = body['TABLE_vrf']['ROW_vrf']
-        except (TypeError, IndexError):
-            return list()
-
-        name = vrf_table['vrf_name']
-        obj['name'] = name
-        obj['admin_state'] = vrf_table['vrf_state'].lower()
-
-        command = 'show run all | section vrf.context.{0}'.format(name)
-        body = execute_show_command(command, module)[0]
-        extra_params = ['vni', 'rd', 'description']
-        for param in extra_params:
-            obj[param] = get_value(param, body, module)
-
-        obj['interfaces'] = []
-        command = 'show vrf {0} interface'.format(name)
-        try:
-            body = execute_show_command(command, module)[0]
-            vrf_int = body['TABLE_if']['ROW_if']
-        except (TypeError, IndexError):
-            vrf_int = None
-
-        if vrf_int:
-            if isinstance(vrf_int, list):
-                for i in vrf_int:
-                    intf = i['if_name']
-                    obj['interfaces'].append(intf)
-            elif isinstance(vrf_int, dict):
-                intf = vrf_int['if_name']
-                obj['interfaces'].append(intf)
-
-        objs.append(obj)
-    return objs
-
-
-def check_declarative_intent_params(want, module, element_spec, result):
-
-    have = None
-    is_delay = False
-
-    for w in want:
-        if w.get('associated_interfaces') is None:
-            continue
-
-        if result['changed'] and not is_delay:
-            time.sleep(module.params['delay'])
-            is_delay = True
-
-        if have is None:
-            have = map_config_to_obj(want, element_spec, module)
-
-        for i in w['associated_interfaces']:
-            obj_in_have = search_obj_in_list(w['name'], have)
-
-            if obj_in_have:
-                interfaces = obj_in_have.get('interfaces')
-                if interfaces is not None and i not in interfaces:
-                    module.fail_json(msg="Interface %s not configured on vrf %s" % (i, w['name']))
-
-
-def vrf_error_check(module, commands, responses):
-    """Checks for VRF config errors and executes a retry in some circumstances.
-    """
-    pattern = 'ERROR: Deletion of VRF .* in progress'
-    if re.search(pattern, str(responses)):
-        # Allow delay/retry for VRF changes
-        time.sleep(15)
-        responses = load_config(module, commands, opts={'catch_clierror': True})
-        if re.search(pattern, str(responses)):
-            module.fail_json(msg='VRF config (and retry) failure: %s ' % responses)
-        module.warn('VRF config delayed by VRF deletion - passed on retry')
-
-
-def main():
-    """ main entry point for module execution
-    """
-    element_spec = dict(
-        name=dict(type='str', aliases=['vrf']),
-        description=dict(type='str'),
-        vni=dict(type='str'),
-        rd=dict(type='str'),
-        admin_state=dict(type='str', default='up', choices=['up', 'down']),
-        interfaces=dict(type='list'),
-        associated_interfaces=dict(type='list'),
-        delay=dict(type='int', default=10),
-        state=dict(type='str', default='present', choices=['present', 'absent']),
-    )
-
-    aggregate_spec = deepcopy(element_spec)
-
-    # remove default in aggregate spec, to handle common arguments
-    remove_default_spec(aggregate_spec)
-
-    argument_spec = dict(
-        aggregate=dict(type='list', elements='dict', options=aggregate_spec),
-        purge=dict(type='bool', default=False),
-    )
-
-    argument_spec.update(element_spec)
-    argument_spec.update(nxos_argument_spec)
-
-    required_one_of = [['name', 'aggregate']]
-    mutually_exclusive = [['name', 'aggregate']]
-    module = AnsibleModule(argument_spec=argument_spec,
-                           required_one_of=required_one_of,
-                           mutually_exclusive=mutually_exclusive,
-                           supports_check_mode=True)
-
-    warnings = list()
-    result = {'changed': False}
-    if warnings:
-        result['warnings'] = warnings
-
-    want = map_params_to_obj(module)
-    have = map_config_to_obj(want, element_spec, module)
-
-    commands = map_obj_to_commands((want, have), module)
-    result['commands'] = commands
-
-    if commands and not module.check_mode:
-        responses = load_config(module, commands, opts={'catch_clierror': True})
-        vrf_error_check(module, commands, responses)
-        result['changed'] = True
-
-    check_declarative_intent_params(want, module, element_spec, result)
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_vrf_af.py b/lib/ansible/modules/network/nxos/nxos_vrf_af.py
deleted file mode 100644
index f1916557cd..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_vrf_af.py
+++ /dev/null
@@ -1,262 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-DOCUMENTATION = '''
----
-module: nxos_vrf_af
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages VRF AF.
-description:
-  - Manages VRF AF
-author: Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - Default, where supported, restores params default value.
-  - In case of C(state=absent) the address-family configuration will be absent.
-    Therefore the options C(route_target_both_auto_evpn) and C(route_targets)
-    are ignored.
-options:
-  vrf:
-    description:
-      - Name of the VRF.
-    required: true
-  afi:
-    description:
-      - Address-Family Identifier (AFI).
-    required: true
-    choices: ['ipv4', 'ipv6']
-  route_target_both_auto_evpn:
-    description:
-      - Enable/Disable the EVPN route-target 'auto' setting for both
-        import and export target communities.
-    type: bool
-  route_targets:
-    description:
-      - Specify the route-targets which should be imported and/or exported under
-        the AF. This argument accepts a list of dicts that specify the
-        route-target, the direction (import|export|both) and state of each
-        route-target. Default direction is C(direction=both). See examples.
-    suboptions:
-      rt:
-        description:
-          - Defindes the route-target itself
-        required: true
-        type: str
-      direction:
-        description:
-          - Indicates the direction of the route-target (import|export|both)
-        choices:
-          - import
-          - export
-          - both
-        default: both
-      state:
-        description:
-          - Determines whether the route-target with the given direction
-            should be present or not on the device.
-        choices:
-          - present
-          - absent
-        default: present
-    elements: dict
-    type: list
-    version_added: "2.10"
-  state:
-    description:
-      - Determines whether the config should be present or
-        not on the device.
-    default: present
-    choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-- nxos_vrf_af:
-    vrf: ntc
-    afi: ipv4
-    route_target_both_auto_evpn: True
-    state: present
-
-- nxos_vrf_af:
-    vrf: ntc
-    afi: ipv4
-    route_targets:
-      - rt: '65000:1000'
-        direction: import
-      - rt: '65001:1000'
-        direction: import
-
-- nxos_vrf_af:
-    vrf: ntc
-    afi: ipv4
-    route_targets:
-      - rt: '65000:1000'
-        direction: import
-      - rt: '65001:1000'
-        state: absent
-
-- nxos_vrf_af:
-    vrf: ntc
-    afi: ipv4
-    route_targets:
-      - rt: '65000:1000'
-        direction: export
-      - rt: '65001:1000'
-        direction: export
-
-- nxos_vrf_af:
-    vrf: ntc
-    afi: ipv4
-    route_targets:
-      - rt: '65000:1000'
-        direction: export
-        state: absent
-
-- nxos_vrf_af:
-    vrf: ntc
-    afi: ipv4
-    route_targets:
-      - rt: '65000:1000'
-        direction: both
-        state: present
-      - rt: '65001:1000'
-        direction: import
-        state: present
-      - rt: '65002:1000'
-        direction: both
-        state: absent
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["vrf context ntc", "address-family ipv4 unicast"]
-'''
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import NetworkConfig
-
-import re
-
-
-def match_current_rt(rt, direction, current, rt_commands):
-    command = 'route-target %s %s' % (direction, rt.get('rt'))
-    match = re.findall(command, current, re.M)
-    want = bool(rt.get('state') != 'absent')
-    if not match and want:
-        rt_commands.append(command)
-    elif match and not want:
-        rt_commands.append('no %s' % command)
-    return rt_commands
-
-
-def main():
-    argument_spec = dict(
-        vrf=dict(required=True),
-        afi=dict(required=True, choices=['ipv4', 'ipv6']),
-        route_target_both_auto_evpn=dict(required=False, type='bool'),
-        state=dict(choices=['present', 'absent'], default='present'),
-        route_targets=dict(
-            type='list',
-            elements='dict',
-            options=dict(
-                rt=dict(type='str'),
-                direction=dict(
-                    choices=['import', 'export', 'both'],
-                    default='both'
-                ),
-                state=dict(
-                    choices=['present', 'absent'],
-                    default='present'
-                ),
-            )
-        ),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    warnings = list()
-
-    result = {'changed': False, 'warnings': warnings}
-
-    config_text = get_config(module)
-    config = NetworkConfig(indent=2, contents=config_text)
-
-    path = ['vrf context %s' % module.params['vrf'],
-            'address-family %s unicast' % module.params['afi']]
-
-    try:
-        current = config.get_block_config(path)
-    except ValueError:
-        current = None
-
-    commands = list()
-    if current and module.params['state'] == 'absent':
-        commands.append('no address-family %s unicast' % module.params['afi'])
-
-    elif module.params['state'] == 'present':
-        rt_commands = list()
-
-        if not current:
-            commands.append('address-family %s unicast' % module.params['afi'])
-            current = ''
-
-        have_auto_evpn = 'route-target both auto evpn' in current
-        if module.params['route_target_both_auto_evpn'] is not None:
-            want_auto_evpn = bool(module.params['route_target_both_auto_evpn'])
-            if want_auto_evpn and not have_auto_evpn:
-                commands.append('route-target both auto evpn')
-            elif have_auto_evpn and not want_auto_evpn:
-                commands.append('no route-target both auto evpn')
-
-        if module.params['route_targets'] is not None:
-            for rt in module.params['route_targets']:
-                if rt.get('direction') == 'both' or not rt.get('direction'):
-                    rt_commands = match_current_rt(rt, 'import', current, rt_commands)
-                    rt_commands = match_current_rt(rt, 'export', current, rt_commands)
-                else:
-                    rt_commands = match_current_rt(rt, rt.get('direction'), current, rt_commands)
-
-        if rt_commands:
-            commands.extend(rt_commands)
-
-        if commands and current:
-            commands.insert(0, 'address-family %s unicast' % module.params['afi'])
-
-    if commands:
-        commands.insert(0, 'vrf context %s' % module.params['vrf'])
-        if not module.check_mode:
-            load_config(module, commands)
-        result['changed'] = True
-
-    result['commands'] = commands
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_vrf_interface.py b/lib/ansible/modules/network/nxos/nxos_vrf_interface.py
deleted file mode 100644
index 4dcb3bc71b..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_vrf_interface.py
+++ /dev/null
@@ -1,257 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_vrf_interface
-extends_documentation_fragment: nxos
-version_added: "2.1"
-short_description: Manages interface specific VRF configuration.
-description:
-    - Manages interface specific VRF configuration.
-author:
-    - Jason Edelman (@jedelman8)
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - VRF needs to be added globally with M(nxos_vrf) before
-      adding a VRF to an interface.
-    - Remove a VRF from an interface will still remove
-      all L3 attributes just as it does from CLI.
-    - VRF is not read from an interface until IP address is
-      configured on that interface.
-options:
-    vrf:
-        description:
-            - Name of VRF to be managed.
-        required: true
-    interface:
-        description:
-            - Full name of interface to be managed, i.e. Ethernet1/1.
-        required: true
-    state:
-        description:
-            - Manages desired state of the resource.
-        required: false
-        default: present
-        choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-- name: Ensure vrf ntc exists on Eth1/1
-  nxos_vrf_interface:
-    vrf: ntc
-    interface: Ethernet1/1
-    state: present
-
-- name: Ensure ntc VRF does not exist on Eth1/1
-  nxos_vrf_interface:
-    vrf: ntc
-    interface: Ethernet1/1
-    state: absent
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["interface loopback16", "vrf member ntc"]
-'''
-import re
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import get_capabilities, nxos_argument_spec
-from ansible.module_utils.network.nxos.nxos import get_interface_type
-from ansible.module_utils.basic import AnsibleModule
-
-
-def execute_show_command(command, module):
-    if 'show run' not in command:
-        output = 'json'
-    else:
-        output = 'text'
-    cmds = [{
-        'command': command,
-        'output': output,
-    }]
-    return run_commands(module, cmds)[0]
-
-
-def get_interface_mode(interface, intf_type, module):
-    command = 'show interface {0}'.format(interface)
-    interface = {}
-    mode = 'unknown'
-
-    if intf_type in ['ethernet', 'portchannel']:
-        body = execute_show_command(command, module)
-        try:
-            interface_table = body['TABLE_interface']['ROW_interface']
-        except KeyError:
-            return mode
-
-        if interface_table and isinstance(interface_table, dict):
-            mode = str(interface_table.get('eth_mode', 'layer3'))
-            if mode == 'access' or mode == 'trunk':
-                mode = 'layer2'
-        else:
-            return mode
-
-    elif intf_type == 'loopback' or intf_type == 'svi':
-        mode = 'layer3'
-    return mode
-
-
-def get_vrf_list(module):
-    command = 'show vrf all'
-    vrf_list = []
-    body = execute_show_command(command, module)
-
-    try:
-        vrf_table = body['TABLE_vrf']['ROW_vrf']
-    except (KeyError, AttributeError):
-        return vrf_list
-
-    for each in vrf_table:
-        vrf_list.append(str(each['vrf_name']))
-
-    return vrf_list
-
-
-def get_interface_info(interface, module):
-    if not interface.startswith('loopback'):
-        interface = interface.capitalize()
-
-    command = 'show run interface {0}'.format(interface)
-    vrf_regex = r".*vrf\s+member\s+(?P<vrf>\S+).*"
-
-    try:
-        body = execute_show_command(command, module)
-        match_vrf = re.match(vrf_regex, body, re.DOTALL)
-        group_vrf = match_vrf.groupdict()
-        vrf = group_vrf["vrf"]
-    except (AttributeError, TypeError):
-        return ""
-
-    return vrf
-
-
-def is_default(interface, module):
-    command = 'show run interface {0}'.format(interface)
-
-    try:
-        body = execute_show_command(command, module)
-        raw_list = body.split('\n')
-        if raw_list[-1].startswith('interface'):
-            return True
-        else:
-            return False
-
-    except (KeyError, IndexError):
-        return 'DNE'
-
-
-def main():
-    argument_spec = dict(
-        vrf=dict(required=True),
-        interface=dict(type='str', required=True),
-        state=dict(default='present', choices=['present', 'absent'], required=False),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    warnings = list()
-    results = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    vrf = module.params['vrf']
-    interface = module.params['interface'].lower()
-    state = module.params['state']
-
-    device_info = get_capabilities(module)
-    network_api = device_info.get('network_api', 'nxapi')
-
-    current_vrfs = get_vrf_list(module)
-    if vrf not in current_vrfs:
-        warnings.append("The VRF is not present/active on the device. "
-                        "Use nxos_vrf to fix this.")
-
-    intf_type = get_interface_type(interface)
-    if (intf_type != 'ethernet' and network_api == 'cliconf'):
-        if is_default(interface, module) == 'DNE':
-            module.fail_json(msg="interface does not exist on switch. Verify "
-                                 "switch platform or create it first with "
-                                 "nxos_interface if it's a logical interface")
-
-    mode = get_interface_mode(interface, intf_type, module)
-    if mode == 'layer2':
-        module.fail_json(msg='Ensure interface is a Layer 3 port before '
-                             'configuring a VRF on an interface. You can '
-                             'use nxos_interface')
-
-    current_vrf = get_interface_info(interface, module)
-    existing = dict(interface=interface, vrf=current_vrf)
-    changed = False
-
-    if not existing['vrf']:
-        pass
-    elif vrf != existing['vrf'] and state == 'absent':
-        module.fail_json(msg='The VRF you are trying to remove '
-                             'from the interface does not exist '
-                             'on that interface.',
-                         interface=interface, proposed_vrf=vrf,
-                         existing_vrf=existing['vrf'])
-
-    commands = []
-    if existing:
-        if state == 'absent':
-            if existing and vrf == existing['vrf']:
-                command = 'no vrf member {0}'.format(vrf)
-                commands.append(command)
-
-        elif state == 'present':
-            if existing['vrf'] != vrf:
-                command = 'vrf member {0}'.format(vrf)
-                commands.append(command)
-
-    if commands:
-        commands.insert(0, 'interface {0}'.format(interface))
-
-    if commands:
-        if module.check_mode:
-            module.exit_json(changed=True, commands=commands)
-        else:
-            load_config(module, commands)
-            changed = True
-            if 'configure' in commands:
-                commands.pop(0)
-
-    results['commands'] = commands
-    results['changed'] = changed
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_vrrp.py b/lib/ansible/modules/network/nxos/nxos_vrrp.py
deleted file mode 100644
index 4e7b9ac142..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_vrrp.py
+++ /dev/null
@@ -1,407 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_vrrp
-extends_documentation_fragment: nxos
-version_added: "2.1"
-short_description: Manages VRRP configuration on NX-OS switches.
-description:
-    - Manages VRRP configuration on NX-OS switches.
-author:
-    - Jason Edelman (@jedelman8)
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - VRRP feature needs to be enabled first on the system.
-    - SVIs must exist before using this module.
-    - Interface must be a L3 port before using this module.
-    - C(state=absent) removes the VRRP group if it exists on the device.
-    - VRRP cannot be configured on loopback interfaces.
-options:
-    group:
-        description:
-            - VRRP group number.
-        required: true
-    interface:
-        description:
-            - Full name of interface that is being managed for VRRP.
-        required: true
-    interval:
-        description:
-            - Time interval between advertisement or 'default' keyword
-        required: false
-        default: 1
-        version_added: 2.6
-    priority:
-        description:
-            - VRRP priority or 'default' keyword
-        default: 100
-    preempt:
-        description:
-            - Enable/Disable preempt.
-        type: bool
-        default: 'yes'
-    vip:
-        description:
-            - VRRP virtual IP address or 'default' keyword
-    authentication:
-        description:
-            - Clear text authentication string or 'default' keyword
-    admin_state:
-        description:
-            - Used to enable or disable the VRRP process.
-        choices: ['shutdown', 'no shutdown', 'default']
-        default: shutdown
-    state:
-        description:
-            - Specify desired state of the resource.
-        default: present
-        choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-- name: Ensure vrrp group 100 and vip 10.1.100.1 is on vlan10
-  nxos_vrrp:
-    interface: vlan10
-    group: 100
-    vip: 10.1.100.1
-
-- name: Ensure removal of the vrrp group config
-  # vip is required to ensure the user knows what they are removing
-  nxos_vrrp:
-    interface: vlan10
-    group: 100
-    vip: 10.1.100.1
-    state: absent
-
-- name: Re-config with more params
-  nxos_vrrp:
-    interface: vlan10
-    group: 100
-    vip: 10.1.100.1
-    preempt: false
-    priority: 130
-    authentication: AUTHKEY
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["interface vlan10", "vrrp 150", "address 10.1.15.1",
-            "authentication text testing", "no shutdown"]
-'''
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import get_capabilities, nxos_argument_spec
-from ansible.module_utils.network.nxos.nxos import get_interface_type
-from ansible.module_utils.basic import AnsibleModule
-
-
-PARAM_TO_DEFAULT_KEYMAP = {
-    'priority': '100',
-    'interval': '1',
-    'vip': '0.0.0.0',
-    'admin_state': 'shutdown',
-}
-
-
-def execute_show_command(command, module):
-    if 'show run' not in command:
-        output = 'json'
-    else:
-        output = 'text'
-
-    commands = [{
-        'command': command,
-        'output': output,
-    }]
-    return run_commands(module, commands)[0]
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key, value in table.items():
-        new_key = key_map.get(key)
-        if new_key:
-            if value:
-                new_dict[new_key] = str(value)
-            else:
-                new_dict[new_key] = value
-    return new_dict
-
-
-def is_default(interface, module):
-    command = 'show run interface {0}'.format(interface)
-
-    try:
-        body = execute_show_command(command, module)
-        if 'invalid' in body.lower():
-            return 'DNE'
-        else:
-            raw_list = body.split('\n')
-            if raw_list[-1].startswith('interface'):
-                return True
-            else:
-                return False
-    except (KeyError):
-        return 'DNE'
-
-
-def get_interface_mode(interface, intf_type, module):
-    command = 'show interface {0}'.format(interface)
-    interface = {}
-    mode = 'unknown'
-    body = execute_show_command(command, module)
-    interface_table = body['TABLE_interface']['ROW_interface']
-    name = interface_table.get('interface')
-
-    if intf_type in ['ethernet', 'portchannel']:
-        mode = str(interface_table.get('eth_mode', 'layer3'))
-
-        if mode == 'access' or mode == 'trunk':
-            mode = 'layer2'
-    elif intf_type == 'svi':
-        mode = 'layer3'
-
-    return mode, name
-
-
-def get_vrr_status(group, module, interface):
-    command = 'show run all | section interface.{0}$'.format(interface)
-    body = execute_show_command(command, module)
-    vrf_index = None
-    admin_state = 'shutdown'
-
-    if body:
-        splitted_body = body.splitlines()
-        for index in range(0, len(splitted_body) - 1):
-            if splitted_body[index].strip() == 'vrrp {0}'.format(group):
-                vrf_index = index
-        vrf_section = splitted_body[vrf_index::]
-
-        for line in vrf_section:
-            if line.strip() == 'no shutdown':
-                admin_state = 'no shutdown'
-                break
-
-    return admin_state
-
-
-def get_existing_vrrp(interface, group, module, name):
-    command = 'show vrrp detail interface {0}'.format(interface)
-    body = execute_show_command(command, module)
-    vrrp = {}
-
-    vrrp_key = {
-        'sh_group_id': 'group',
-        'sh_vip_addr': 'vip',
-        'sh_priority': 'priority',
-        'sh_group_preempt': 'preempt',
-        'sh_auth_text': 'authentication',
-        'sh_adv_interval': 'interval'
-    }
-
-    try:
-        vrrp_table = body['TABLE_vrrp_group']
-    except (AttributeError, IndexError, TypeError):
-        return {}
-
-    if isinstance(vrrp_table, dict):
-        vrrp_table = [vrrp_table]
-
-    for each_vrrp in vrrp_table:
-        vrrp_row = each_vrrp['ROW_vrrp_group']
-        parsed_vrrp = apply_key_map(vrrp_key, vrrp_row)
-
-        if parsed_vrrp['preempt'] == 'Disable':
-            parsed_vrrp['preempt'] = False
-        elif parsed_vrrp['preempt'] == 'Enable':
-            parsed_vrrp['preempt'] = True
-
-        if parsed_vrrp['group'] == group:
-            parsed_vrrp['admin_state'] = get_vrr_status(group, module, name)
-            return parsed_vrrp
-
-    return vrrp
-
-
-def get_commands_config_vrrp(delta, existing, group):
-    commands = []
-
-    CMDS = {
-        'priority': 'priority {0}',
-        'preempt': 'preempt',
-        'vip': 'address {0}',
-        'interval': 'advertisement-interval {0}',
-        'auth': 'authentication text {0}',
-        'admin_state': '{0}',
-    }
-
-    for arg in ['vip', 'priority', 'interval', 'admin_state']:
-        val = delta.get(arg)
-        if val == 'default':
-            val = PARAM_TO_DEFAULT_KEYMAP.get(arg)
-            if val != existing.get(arg):
-                commands.append((CMDS.get(arg)).format(val))
-        elif val:
-            commands.append((CMDS.get(arg)).format(val))
-
-    preempt = delta.get('preempt')
-    auth = delta.get('authentication')
-
-    if preempt:
-        commands.append(CMDS.get('preempt'))
-    elif preempt is False:
-        commands.append('no ' + CMDS.get('preempt'))
-    if auth:
-        if auth != 'default':
-            commands.append((CMDS.get('auth')).format(auth))
-        elif existing.get('authentication'):
-            commands.append('no authentication')
-
-    if commands:
-        commands.insert(0, 'vrrp {0}'.format(group))
-
-    return commands
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def validate_params(param, module):
-    value = module.params[param]
-
-    if param == 'group':
-        try:
-            if (int(value) < 1 or int(value) > 255):
-                raise ValueError
-        except ValueError:
-            module.fail_json(msg="Warning! 'group' must be an integer between"
-                                 " 1 and 255", group=value)
-    elif param == 'priority':
-        try:
-            if (int(value) < 1 or int(value) > 254):
-                raise ValueError
-        except ValueError:
-            module.fail_json(msg="Warning! 'priority' must be an integer "
-                                 "between 1 and 254", priority=value)
-
-
-def main():
-    argument_spec = dict(
-        group=dict(required=True, type='str'),
-        interface=dict(required=True),
-        interval=dict(required=False, type='str'),
-        priority=dict(required=False, type='str'),
-        preempt=dict(required=False, type='bool'),
-        vip=dict(required=False, type='str'),
-        admin_state=dict(required=False, type='str',
-                         choices=['shutdown', 'no shutdown', 'default'],
-                         default='shutdown'),
-        authentication=dict(required=False, type='str'),
-        state=dict(choices=['absent', 'present'], required=False, default='present')
-    )
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
-
-    warnings = list()
-    results = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    state = module.params['state']
-    interface = module.params['interface'].lower()
-    group = module.params['group']
-    priority = module.params['priority']
-    interval = module.params['interval']
-    preempt = module.params['preempt']
-    vip = module.params['vip']
-    authentication = module.params['authentication']
-    admin_state = module.params['admin_state']
-
-    device_info = get_capabilities(module)
-    network_api = device_info.get('network_api', 'nxapi')
-
-    if state == 'present' and not vip:
-        module.fail_json(msg='the "vip" param is required when state=present')
-
-    intf_type = get_interface_type(interface)
-    if (intf_type != 'ethernet' and network_api == 'cliconf'):
-        if is_default(interface, module) == 'DNE':
-            module.fail_json(msg='That interface does not exist yet. Create '
-                                 'it first.', interface=interface)
-        if intf_type == 'loopback':
-            module.fail_json(msg="Loopback interfaces don't support VRRP.",
-                             interface=interface)
-
-    mode, name = get_interface_mode(interface, intf_type, module)
-    if mode == 'layer2':
-        module.fail_json(msg='That interface is a layer2 port.\nMake it '
-                             'a layer 3 port first.', interface=interface)
-
-    args = dict(group=group, priority=priority, preempt=preempt,
-                vip=vip, authentication=authentication, interval=interval,
-                admin_state=admin_state)
-
-    proposed = dict((k, v) for k, v in args.items() if v is not None)
-    existing = get_existing_vrrp(interface, group, module, name)
-
-    commands = []
-
-    if state == 'present':
-        delta = dict(
-            set(proposed.items()).difference(existing.items()))
-        if delta:
-            command = get_commands_config_vrrp(delta, existing, group)
-            if command:
-                commands.append(command)
-    elif state == 'absent':
-        if existing:
-            commands.append(['no vrrp {0}'.format(group)])
-
-    if commands:
-        commands.insert(0, ['interface {0}'.format(interface)])
-        commands = flatten_list(commands)
-        results['commands'] = commands
-        results['changed'] = True
-        if not module.check_mode:
-            load_config(module, commands)
-            if 'configure' in commands:
-                commands.pop(0)
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_vtp_domain.py b/lib/ansible/modules/network/nxos/nxos_vtp_domain.py
deleted file mode 100644
index 87f844696c..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_vtp_domain.py
+++ /dev/null
@@ -1,217 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_vtp_domain
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages VTP domain configuration.
-description:
-    - Manages VTP domain configuration.
-author:
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - VTP feature must be active on the device to use this module.
-    - This module is used to manage only VTP domain names.
-    - VTP domain names are case-sensible.
-    - If it's never been configured before, VTP version is set to 1 by default.
-      Otherwise, it leaves the previous configured version untouched.
-      Use M(nxos_vtp_version) to change it.
-    - Use this in combination with M(nxos_vtp_password) and M(nxos_vtp_version)
-      to fully manage VTP operations.
-options:
-    domain:
-        description:
-            - VTP domain name.
-        required: true
-'''
-
-EXAMPLES = '''
-# ENSURE VTP DOMAIN IS CONFIGURED
-- nxos_vtp_domain:
-    domain: ntc
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-'''
-
-
-RETURN = '''
-proposed:
-    description: k/v pairs of parameters passed into module
-    returned: always
-    type: dict
-    sample: {"domain": "ntc"}
-existing:
-    description:
-        - k/v pairs of existing vtp domain
-    returned: always
-    type: dict
-    sample: {"domain": "testing", "version": "2", "vtp_password": "\"}
-end_state:
-    description: k/v pairs of vtp domain after module execution
-    returned: always
-    type: dict
-    sample: {"domain": "ntc", "version": "2", "vtp_password": "\"}
-updates:
-    description: command sent to the device
-    returned: always
-    type: list
-    sample: ["vtp domain ntc"]
-changed:
-    description: check to see if a change was made on the device
-    returned: always
-    type: bool
-    sample: true
-'''
-
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.network.nxos.nxos import get_capabilities
-from ansible.module_utils.basic import AnsibleModule
-import re
-
-
-def execute_show_command(command, module, output='json'):
-    cmds = [{
-        'command': command,
-        'output': output,
-    }]
-    body = run_commands(module, cmds)
-    return body
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_vtp_config(module):
-    command = 'show vtp status'
-    body = execute_show_command(
-        command, module, 'text')[0]
-    vtp_parsed = {}
-
-    if body:
-        version_regex = r'.*VTP version running\s+:\s+(?P<version>\d).*'
-        domain_regex = r'.*VTP Domain Name\s+:\s+(?P<domain>\S+).*'
-
-        try:
-            match_version = re.match(version_regex, body, re.DOTALL)
-            version = match_version.groupdict()['version']
-        except AttributeError:
-            version = ''
-
-        try:
-            match_domain = re.match(domain_regex, body, re.DOTALL)
-            domain = match_domain.groupdict()['domain']
-        except AttributeError:
-            domain = ''
-
-        if domain and version:
-            vtp_parsed['domain'] = domain
-            vtp_parsed['version'] = version
-            vtp_parsed['vtp_password'] = get_vtp_password(module)
-
-    return vtp_parsed
-
-
-def get_vtp_password(module):
-    command = 'show vtp password'
-    output = 'json'
-    cap = get_capabilities(module)['device_info']['network_os_model']
-    if re.search(r'Nexus 6', cap):
-        output = 'text'
-
-    body = execute_show_command(command, module, output)[0]
-
-    if output == 'json':
-        password = body.get('passwd', '')
-    else:
-        password = ''
-        rp = r'VTP Password: (\S+)'
-        mo = re.search(rp, body)
-        if mo:
-            password = mo.group(1)
-
-    return str(password)
-
-
-def main():
-    argument_spec = dict(
-        domain=dict(type='str', required=True),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    domain = module.params['domain']
-
-    existing = get_vtp_config(module)
-    end_state = existing
-
-    args = dict(domain=domain)
-
-    changed = False
-    proposed = dict((k, v) for k, v in args.items() if v is not None)
-    delta = dict(set(proposed.items()).difference(existing.items()))
-
-    commands = []
-    if delta:
-        commands.append(['vtp domain {0}'.format(domain)])
-
-    cmds = flatten_list(commands)
-    if cmds:
-        if module.check_mode:
-            module.exit_json(changed=True, commands=cmds)
-        else:
-            changed = True
-            load_config(module, cmds)
-            end_state = get_vtp_config(module)
-            if 'configure' in cmds:
-                cmds.pop(0)
-
-    results = {}
-    results['proposed'] = proposed
-    results['existing'] = existing
-    results['end_state'] = end_state
-    results['updates'] = cmds
-    results['changed'] = changed
-    results['warnings'] = warnings
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_vtp_password.py b/lib/ansible/modules/network/nxos/nxos_vtp_password.py
deleted file mode 100644
index 301a8b67df..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_vtp_password.py
+++ /dev/null
@@ -1,273 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-
-module: nxos_vtp_password
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages VTP password configuration.
-description:
-    - Manages VTP password configuration.
-author:
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - VTP feature must be active on the device to use this module.
-    - This module is used to manage only VTP passwords.
-    - Use this in combination with M(nxos_vtp_domain) and M(nxos_vtp_version)
-      to fully manage VTP operations.
-    - You can set/remove password only if a VTP domain already exist.
-    - If C(state=absent) and no C(vtp_password) is provided, it remove the current
-      VTP password.
-    - If C(state=absent) and C(vtp_password) is provided, the proposed C(vtp_password)
-      has to match the existing one in order to remove it.
-options:
-    vtp_password:
-        description:
-            - VTP password
-    state:
-        description:
-            - Manage the state of the resource
-        default: present
-        choices: ['present','absent']
-'''
-
-EXAMPLES = '''
-# ENSURE VTP PASSWORD IS SET
-- nxos_vtp_password:
-    state: present
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-
-# ENSURE VTP PASSWORD IS REMOVED
-- nxos_vtp_password:
-    state: absent
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-'''
-
-RETURN = '''
-proposed:
-    description: k/v pairs of parameters passed into module
-    returned: always
-    type: dict
-    sample: {"vtp_password": "new_ntc"}
-existing:
-    description:
-        - k/v pairs of existing vtp
-    returned: always
-    type: dict
-    sample: {"domain": "ntc", "version": "1", "vtp_password": "ntc"}
-end_state:
-    description: k/v pairs of vtp after module execution
-    returned: always
-    type: dict
-    sample: {"domain": "ntc", "version": "1", "vtp_password": "new_ntc"}
-updates:
-    description: command sent to the device
-    returned: always
-    type: list
-    sample: ["vtp password new_ntc"]
-changed:
-    description: check to see if a change was made on the device
-    returned: always
-    type: bool
-    sample: true
-'''
-
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.network.nxos.nxos import get_capabilities
-from ansible.module_utils.basic import AnsibleModule
-import re
-
-
-def execute_show_command(command, module, output='json'):
-    cmds = [{
-        'command': command,
-        'output': output,
-    }]
-    body = run_commands(module, cmds)
-    return body
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key, value in table.items():
-        new_key = key_map.get(key)
-        if new_key:
-            value = table.get(key)
-            if value:
-                new_dict[new_key] = str(value)
-            else:
-                new_dict[new_key] = value
-    return new_dict
-
-
-def get_vtp_config(module):
-    command = 'show vtp status'
-
-    body = execute_show_command(
-        command, module, 'text')[0]
-    vtp_parsed = {}
-
-    if body:
-        version_regex = r'.*VTP version running\s+:\s+(?P<version>\d).*'
-        domain_regex = r'.*VTP Domain Name\s+:\s+(?P<domain>\S+).*'
-
-        try:
-            match_version = re.match(version_regex, body, re.DOTALL)
-            version = match_version.groupdict()['version']
-        except AttributeError:
-            version = ''
-
-        try:
-            match_domain = re.match(domain_regex, body, re.DOTALL)
-            domain = match_domain.groupdict()['domain']
-        except AttributeError:
-            domain = ''
-
-        if domain and version:
-            vtp_parsed['domain'] = domain
-            vtp_parsed['version'] = version
-            vtp_parsed['vtp_password'] = get_vtp_password(module)
-
-    return vtp_parsed
-
-
-def get_vtp_password(module):
-    command = 'show vtp password'
-    output = 'json'
-    cap = get_capabilities(module)['device_info']['network_os_model']
-    if re.search(r'Nexus 6', cap):
-        output = 'text'
-
-    body = execute_show_command(command, module, output)[0]
-
-    if output == 'json':
-        password = body.get('passwd', '')
-    else:
-        password = ''
-        rp = r'VTP Password: (\S+)'
-        mo = re.search(rp, body)
-        if mo:
-            password = mo.group(1)
-
-    return str(password)
-
-
-def main():
-    argument_spec = dict(
-        vtp_password=dict(type='str', no_log=True),
-        state=dict(choices=['absent', 'present'],
-                   default='present'),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    vtp_password = module.params['vtp_password'] or None
-    state = module.params['state']
-
-    existing = get_vtp_config(module)
-    end_state = existing
-
-    args = dict(vtp_password=vtp_password)
-
-    changed = False
-    proposed = dict((k, v) for k, v in args.items() if v is not None)
-    delta = dict(set(proposed.items()).difference(existing.items()))
-
-    commands = []
-    if state == 'absent':
-        # if vtp_password is not set, some devices returns '\\' or the string 'None'
-        if not existing['vtp_password'] or existing['vtp_password'] == '\\' or existing['vtp_password'] == 'None':
-            pass
-        elif vtp_password is not None:
-            if existing['vtp_password'] == proposed['vtp_password']:
-                commands.append(['no vtp password'])
-            else:
-                module.fail_json(msg="Proposed vtp password doesn't match "
-                                     "current vtp password. It cannot be "
-                                     "removed when state=absent. If you are "
-                                     "trying to change the vtp password, use "
-                                     "state=present.")
-        else:
-            if not existing.get('domain'):
-                module.fail_json(msg='Cannot remove a vtp password '
-                                     'before vtp domain is set.')
-
-            elif existing['vtp_password'] != ('\\'):
-                commands.append(['no vtp password'])
-
-    elif state == 'present':
-        if delta:
-            if not existing.get('domain'):
-                module.fail_json(msg='Cannot set vtp password '
-                                     'before vtp domain is set.')
-
-            else:
-                commands.append(['vtp password {0}'.format(vtp_password)])
-
-    cmds = flatten_list(commands)
-    if cmds:
-        if module.check_mode:
-            module.exit_json(changed=True, commands=cmds)
-        else:
-            changed = True
-            load_config(module, cmds)
-            end_state = get_vtp_config(module)
-            if 'configure' in cmds:
-                cmds.pop(0)
-
-    results = {}
-    results['proposed'] = proposed
-    results['existing'] = existing
-    results['end_state'] = end_state
-    results['updates'] = cmds
-    results['changed'] = changed
-    results['warnings'] = warnings
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_vtp_version.py b/lib/ansible/modules/network/nxos/nxos_vtp_version.py
deleted file mode 100644
index 0526e65872..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_vtp_version.py
+++ /dev/null
@@ -1,212 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-
-module: nxos_vtp_version
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages VTP version configuration.
-description:
-    - Manages VTP version configuration.
-author:
-    - Gabriele Gerbino (@GGabriele)
-notes:
-    - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-    - VTP feature must be active on the device to use this module.
-    - This module is used to manage only VTP version.
-    - Use this in combination with M(nxos_vtp_password) and M(nxos_vtp_version)
-      to fully manage VTP operations.
-options:
-    version:
-        description:
-            - VTP version number.
-        required: true
-        choices: ['1', '2']
-'''
-EXAMPLES = '''
-# ENSURE VTP VERSION IS 2
-- nxos_vtp_version:
-    version: 2
-    host: "{{ inventory_hostname }}"
-    username: "{{ un }}"
-    password: "{{ pwd }}"
-'''
-
-RETURN = '''
-proposed:
-    description: k/v pairs of parameters passed into module
-    returned: always
-    type: dict
-    sample: {"version": "2"}
-existing:
-    description:
-        - k/v pairs of existing vtp
-    returned: always
-    type: dict
-    sample: {"domain": "testing", "version": "1", "vtp_password": "\"}
-end_state:
-    description: k/v pairs of vtp after module execution
-    returned: always
-    type: dict
-    sample: {"domain": "testing", "version": "2", "vtp_password": "\"}
-updates:
-    description: command sent to the device
-    returned: always
-    type: list
-    sample: ["vtp version 2"]
-changed:
-    description: check to see if a change was made on the device
-    returned: always
-    type: bool
-    sample: true
-'''
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.network.nxos.nxos import get_capabilities
-from ansible.module_utils.basic import AnsibleModule
-import re
-
-
-def execute_show_command(command, module, output='json'):
-    cmds = [{
-        'command': command,
-        'output': output,
-    }]
-    body = run_commands(module, cmds)
-    return body
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def get_vtp_config(module):
-    command = 'show vtp status'
-    body = execute_show_command(
-        command, module, 'text')[0]
-    vtp_parsed = {}
-
-    if body:
-        version_regex = r'.*VTP version running\s+:\s+(?P<version>\d).*'
-        domain_regex = r'.*VTP Domain Name\s+:\s+(?P<domain>\S+).*'
-
-        try:
-            match_version = re.match(version_regex, body, re.DOTALL)
-            version = match_version.groupdict()['version']
-        except AttributeError:
-            version = ''
-
-        try:
-            match_domain = re.match(domain_regex, body, re.DOTALL)
-            domain = match_domain.groupdict()['domain']
-        except AttributeError:
-            domain = ''
-
-        if domain and version:
-            vtp_parsed['domain'] = domain
-            vtp_parsed['version'] = version
-            vtp_parsed['vtp_password'] = get_vtp_password(module)
-
-    return vtp_parsed
-
-
-def get_vtp_password(module):
-    command = 'show vtp password'
-    output = 'json'
-    cap = get_capabilities(module)['device_info']['network_os_model']
-    if re.search(r'Nexus 6', cap):
-        output = 'text'
-
-    body = execute_show_command(command, module, output)[0]
-
-    if output == 'json':
-        password = body.get('passwd', '')
-    else:
-        password = ''
-        rp = r'VTP Password: (\S+)'
-        mo = re.search(rp, body)
-        if mo:
-            password = mo.group(1)
-
-    return str(password)
-
-
-def main():
-    argument_spec = dict(
-        version=dict(type='str', choices=['1', '2'], required=True),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-
-    version = module.params['version']
-
-    existing = get_vtp_config(module)
-    end_state = existing
-
-    args = dict(version=version)
-
-    changed = False
-    proposed = dict((k, v) for k, v in args.items() if v is not None)
-    delta = dict(set(proposed.items()).difference(existing.items()))
-
-    commands = []
-    if delta:
-        commands.append(['vtp version {0}'.format(version)])
-
-    cmds = flatten_list(commands)
-    if cmds:
-        if module.check_mode:
-            module.exit_json(changed=True, commands=cmds)
-        else:
-            changed = True
-            load_config(module, cmds)
-            end_state = get_vtp_config(module)
-            if 'configure' in cmds:
-                cmds.pop(0)
-
-    results = {}
-    results['proposed'] = proposed
-    results['existing'] = existing
-    results['end_state'] = end_state
-    results['updates'] = cmds
-    results['changed'] = changed
-    results['warnings'] = warnings
-
-    module.exit_json(**results)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_vxlan_vtep.py b/lib/ansible/modules/network/nxos/nxos_vxlan_vtep.py
deleted file mode 100644
index 1c51fdc6f7..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_vxlan_vtep.py
+++ /dev/null
@@ -1,412 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_vxlan_vtep
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Manages VXLAN Network Virtualization Endpoint (NVE).
-description:
-  - Manages VXLAN Network Virtualization Endpoint (NVE) overlay interface
-    that terminates VXLAN tunnels.
-author: Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - The module is used to manage NVE properties, not to create NVE
-    interfaces. Use M(nxos_interface) if you wish to do so.
-  - C(state=absent) removes the interface.
-  - Default, where supported, restores params default value.
-options:
-  interface:
-    description:
-      - Interface name for the VXLAN Network Virtualization Endpoint.
-    required: true
-  description:
-    description:
-      - Description of the NVE interface.
-  host_reachability:
-    description:
-      - Specify mechanism for host reachability advertisement.
-    type: bool
-  shutdown:
-    description:
-      - Administratively shutdown the NVE interface.
-    type: bool
-  source_interface:
-    description:
-      - Specify the loopback interface whose IP address should be
-        used for the NVE interface.
-  source_interface_hold_down_time:
-    description:
-      - Suppresses advertisement of the NVE loopback address until
-        the overlay has converged.
-  global_mcast_group_L3:
-    description:
-      - Global multicast ip prefix for L3 VNIs or the keyword 'default'
-        This is available on NX-OS 9K series running 9.2.x or higher.
-    version_added: "2.8"
-  global_mcast_group_L2:
-    description:
-      - Global multicast ip prefix for L2 VNIs or the keyword 'default'
-        This is available on NX-OS 9K series running 9.2.x or higher.
-    version_added: "2.8"
-  global_suppress_arp:
-    description:
-      - Enables ARP suppression for all VNIs
-        This is available on NX-OS 9K series running 9.2.x or higher.
-    type: bool
-    version_added: "2.8"
-  global_ingress_replication_bgp:
-    description:
-      - Configures ingress replication protocol as bgp for all VNIs
-        This is available on NX-OS 9K series running 9.2.x or higher.
-    type: bool
-    version_added: "2.8"
-  state:
-    description:
-      - Determines whether the config should be present or not
-        on the device.
-    default: present
-    choices: ['present','absent']
-'''
-EXAMPLES = '''
-- nxos_vxlan_vtep:
-    interface: nve1
-    description: default
-    host_reachability: default
-    source_interface: Loopback0
-    source_interface_hold_down_time: 30
-    shutdown: default
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["interface nve1", "source-interface loopback0",
-        "source-interface hold-down-time 30", "description simple description",
-        "shutdown", "host-reachability protocol bgp"]
-'''
-
-import re
-
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.network.nxos.nxos import run_commands
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-
-BOOL_PARAMS = [
-    'shutdown',
-    'host_reachability',
-    'global_ingress_replication_bgp',
-    'global_suppress_arp',
-]
-PARAM_TO_COMMAND_KEYMAP = {
-    'description': 'description',
-    'global_suppress_arp': 'global suppress-arp',
-    'global_ingress_replication_bgp': 'global ingress-replication protocol bgp',
-    'global_mcast_group_L3': 'global mcast-group L3',
-    'global_mcast_group_L2': 'global mcast-group L2',
-    'host_reachability': 'host-reachability protocol bgp',
-    'interface': 'interface',
-    'shutdown': 'shutdown',
-    'source_interface': 'source-interface',
-    'source_interface_hold_down_time': 'source-interface hold-down-time'
-}
-PARAM_TO_DEFAULT_KEYMAP = {
-    'description': False,
-    'shutdown': True,
-    'source_interface_hold_down_time': '180',
-}
-
-
-def get_value(arg, config, module):
-    if arg in BOOL_PARAMS:
-        REGEX = re.compile(r'\s+{0}\s*$'.format(PARAM_TO_COMMAND_KEYMAP[arg]), re.M)
-        NO_SHUT_REGEX = re.compile(r'\s+no shutdown\s*$', re.M)
-        value = False
-        if arg == 'shutdown':
-            try:
-                if NO_SHUT_REGEX.search(config):
-                    value = False
-                elif REGEX.search(config):
-                    value = True
-            except TypeError:
-                value = False
-        else:
-            try:
-                if REGEX.search(config):
-                    value = True
-            except TypeError:
-                value = False
-    else:
-        REGEX = re.compile(r'(?:{0}\s)(?P<value>.*)$'.format(PARAM_TO_COMMAND_KEYMAP[arg]), re.M)
-        NO_DESC_REGEX = re.compile(r'\s+{0}\s*$'.format('no description'), re.M)
-        SOURCE_INTF_REGEX = re.compile(r'(?:{0}\s)(?P<value>\S+)$'.format(PARAM_TO_COMMAND_KEYMAP[arg]), re.M)
-        value = ''
-        if arg == 'description':
-            if NO_DESC_REGEX.search(config):
-                value = False
-            elif PARAM_TO_COMMAND_KEYMAP[arg] in config:
-                value = REGEX.search(config).group('value').strip()
-        elif arg == 'source_interface':
-            for line in config.splitlines():
-                try:
-                    if PARAM_TO_COMMAND_KEYMAP[arg] in config:
-                        value = SOURCE_INTF_REGEX.search(config).group('value').strip()
-                        break
-                except AttributeError:
-                    value = ''
-        elif arg == 'global_mcast_group_L2':
-            for line in config.splitlines():
-                try:
-                    if 'global mcast-group' in line and 'L2' in line:
-                        value = line.split()[2].strip()
-                        break
-                except AttributeError:
-                    value = ''
-        elif arg == 'global_mcast_group_L3':
-            for line in config.splitlines():
-                try:
-                    if 'global mcast-group' in line and 'L3' in line:
-                        value = line.split()[2].strip()
-                        break
-                except AttributeError:
-                    value = ''
-        else:
-            if PARAM_TO_COMMAND_KEYMAP[arg] in config:
-                value = REGEX.search(config).group('value').strip()
-    return value
-
-
-def get_existing(module, args):
-    existing = {}
-    netcfg = CustomNetworkConfig(indent=2, contents=get_config(module, flags=['all']))
-
-    interface_string = 'interface {0}'.format(module.params['interface'].lower())
-    parents = [interface_string]
-    config = netcfg.get_section(parents)
-
-    if config:
-        for arg in args:
-            existing[arg] = get_value(arg, config, module)
-
-        existing['interface'] = module.params['interface'].lower()
-    else:
-        if interface_string in str(netcfg):
-            existing['interface'] = module.params['interface'].lower()
-            for arg in args:
-                existing[arg] = ''
-    return existing
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key, value in table.items():
-        new_key = key_map.get(key)
-        if new_key:
-            value = table.get(key)
-            if value:
-                new_dict[new_key] = value
-            else:
-                new_dict[new_key] = value
-    return new_dict
-
-
-def fix_commands(commands, module):
-    source_interface_command = ''
-    no_source_interface_command = ''
-    no_host_reachability_command = ''
-    host_reachability_command = ''
-
-    for command in commands:
-        if 'no source-interface hold-down-time' in command:
-            pass
-        elif 'source-interface hold-down-time' in command:
-            pass
-        elif 'no source-interface' in command:
-            no_source_interface_command = command
-        elif 'source-interface' in command:
-            source_interface_command = command
-        elif 'no host-reachability' in command:
-            no_host_reachability_command = command
-        elif 'host-reachability' in command:
-            host_reachability_command = command
-
-    if host_reachability_command:
-        commands.pop(commands.index(host_reachability_command))
-        commands.insert(0, host_reachability_command)
-
-    if source_interface_command:
-        commands.pop(commands.index(source_interface_command))
-        commands.insert(0, source_interface_command)
-
-    if no_host_reachability_command:
-        commands.pop(commands.index(no_host_reachability_command))
-        commands.append(no_host_reachability_command)
-
-    if no_source_interface_command:
-        commands.pop(commands.index(no_source_interface_command))
-        commands.append(no_source_interface_command)
-
-    commands.insert(0, 'terminal dont-ask')
-    return commands
-
-
-def gsa_tcam_check(module):
-    '''
-    global_suppress_arp is an N9k-only command that requires TCAM resources.
-    This method checks the current TCAM allocation.
-    Note that changing tcam_size requires a switch reboot to take effect.
-    '''
-    cmds = [{'command': 'show hardware access-list tcam region', 'output': 'json'}]
-    body = run_commands(module, cmds)
-    if body:
-        tcam_region = body[0]['TCAM_Region']['TABLE_Sizes']['ROW_Sizes']
-        if bool([i for i in tcam_region if i['type'].startswith('Ingress ARP-Ether ACL') and i['tcam_size'] == '0']):
-            msg = "'show hardware access-list tcam region' indicates 'ARP-Ether' tcam size is 0 (no allocated resources). " +\
-                  "'global_suppress_arp' will be rejected by device."
-            module.fail_json(msg=msg)
-
-
-def state_present(module, existing, proposed, candidate):
-    commands = list()
-    proposed_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, proposed)
-    existing_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, existing)
-    for key, value in proposed_commands.items():
-        if value is True:
-            commands.append(key)
-
-        elif value is False:
-            commands.append('no {0}'.format(key))
-
-        elif value == 'default':
-            if existing_commands.get(key):
-                existing_value = existing_commands.get(key)
-                if 'global mcast-group' in key:
-                    commands.append('no {0}'.format(key))
-                else:
-                    commands.append('no {0} {1}'.format(key, existing_value))
-            else:
-                if key.replace(' ', '_').replace('-', '_') in BOOL_PARAMS:
-                    commands.append('no {0}'.format(key.lower()))
-                    module.exit_json(commands=commands)
-        else:
-            if 'L2' in key:
-                commands.append('global mcast-group ' + value + ' L2')
-            elif 'L3' in key:
-                commands.append('global mcast-group ' + value + ' L3')
-            else:
-                command = '{0} {1}'.format(key, value.lower())
-                commands.append(command)
-
-    if commands:
-        commands = fix_commands(commands, module)
-        parents = ['interface {0}'.format(module.params['interface'].lower())]
-        candidate.add(commands, parents=parents)
-    else:
-        if not existing and module.params['interface']:
-            commands = ['interface {0}'.format(module.params['interface'].lower())]
-            candidate.add(commands, parents=[])
-
-
-def state_absent(module, existing, proposed, candidate):
-    commands = ['no interface {0}'.format(module.params['interface'].lower())]
-    candidate.add(commands, parents=[])
-
-
-def main():
-    argument_spec = dict(
-        interface=dict(required=True, type='str'),
-        description=dict(required=False, type='str'),
-        host_reachability=dict(required=False, type='bool'),
-        global_ingress_replication_bgp=dict(required=False, type='bool'),
-        global_suppress_arp=dict(required=False, type='bool'),
-        global_mcast_group_L2=dict(required=False, type='str'),
-        global_mcast_group_L3=dict(required=False, type='str'),
-        shutdown=dict(required=False, type='bool'),
-        source_interface=dict(required=False, type='str'),
-        source_interface_hold_down_time=dict(required=False, type='str'),
-        state=dict(choices=['present', 'absent'], default='present', required=False),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    mutually_exclusive = [('global_ingress_replication_bgp', 'global_mcast_group_L2')]
-
-    module = AnsibleModule(
-        argument_spec=argument_spec,
-        mutually_exclusive=mutually_exclusive,
-        supports_check_mode=True,
-    )
-
-    warnings = list()
-    result = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    state = module.params['state']
-
-    args = PARAM_TO_COMMAND_KEYMAP.keys()
-
-    existing = get_existing(module, args)
-    proposed_args = dict((k, v) for k, v in module.params.items()
-                         if v is not None and k in args)
-    proposed = {}
-    for key, value in proposed_args.items():
-        if key != 'interface':
-            if str(value).lower() == 'default':
-                value = PARAM_TO_DEFAULT_KEYMAP.get(key)
-                if value is None:
-                    if key in BOOL_PARAMS:
-                        value = False
-                    else:
-                        value = 'default'
-            if str(existing.get(key)).lower() != str(value).lower():
-                proposed[key] = value
-
-    candidate = CustomNetworkConfig(indent=3)
-
-    if proposed.get('global_suppress_arp'):
-        gsa_tcam_check(module)
-    if state == 'present':
-        if not existing:
-            warnings.append("The proposed NVE interface did not exist. "
-                            "It's recommended to use nxos_interface to create "
-                            "all logical interfaces.")
-        state_present(module, existing, proposed, candidate)
-    elif state == 'absent' and existing:
-        state_absent(module, existing, proposed, candidate)
-
-    if candidate:
-        candidate = candidate.items_text()
-        result['commands'] = candidate
-        result['changed'] = True
-        load_config(module, candidate)
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/nxos_vxlan_vtep_vni.py b/lib/ansible/modules/network/nxos/nxos_vxlan_vtep_vni.py
deleted file mode 100644
index de4937e25a..0000000000
--- a/lib/ansible/modules/network/nxos/nxos_vxlan_vtep_vni.py
+++ /dev/null
@@ -1,377 +0,0 @@
-#!/usr/bin/python
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_vxlan_vtep_vni
-extends_documentation_fragment: nxos
-version_added: "2.2"
-short_description: Creates a Virtual Network Identifier member (VNI)
-description:
-  - Creates a Virtual Network Identifier member (VNI) for an NVE
-    overlay interface.
-author: Gabriele Gerbino (@GGabriele)
-notes:
-  - Tested against NXOSv 7.3.(0)D1(1) on VIRL
-  - default, where supported, restores params default value.
-options:
-  interface:
-    description:
-      - Interface name for the VXLAN Network Virtualization Endpoint.
-    required: true
-  vni:
-    description:
-      - ID of the Virtual Network Identifier.
-    required: true
-  assoc_vrf:
-    description:
-      - This attribute is used to identify and separate processing VNIs
-        that are associated with a VRF and used for routing. The VRF
-        and VNI specified with this command must match the configuration
-        of the VNI under the VRF.
-    type: bool
-  ingress_replication:
-    description:
-      - Specifies mechanism for host reachability advertisement.
-    choices: ['bgp','static', 'default']
-  multicast_group:
-    description:
-      - The multicast group (range) of the VNI. Valid values are
-        string and keyword 'default'.
-  peer_list:
-    description:
-      - Set the ingress-replication static peer list. Valid values
-        are an array, a space-separated string of ip addresses,
-        or the keyword 'default'.
-  suppress_arp:
-    description:
-      - Suppress arp under layer 2 VNI.
-    type: bool
-  suppress_arp_disable:
-    description:
-      - Overrides the global ARP suppression config.
-        This is available on NX-OS 9K series running 9.2.x or higher.
-    type: bool
-    version_added: "2.8"
-  state:
-    description:
-      - Determines whether the config should be present or not
-        on the device.
-    default: present
-    choices: ['present','absent']
-'''
-EXAMPLES = '''
-- nxos_vxlan_vtep_vni:
-    interface: nve1
-    vni: 6000
-    ingress_replication: default
-'''
-
-RETURN = '''
-commands:
-    description: commands sent to the device
-    returned: always
-    type: list
-    sample: ["interface nve1", "member vni 6000"]
-'''
-
-import re
-from ansible.module_utils.network.nxos.nxos import get_config, load_config
-from ansible.module_utils.network.nxos.nxos import nxos_argument_spec
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.common.config import CustomNetworkConfig
-
-BOOL_PARAMS = [
-    'assoc_vrf',
-    'suppress_arp',
-    'suppress_arp_disable',
-]
-PARAM_TO_DEFAULT_KEYMAP = {
-    'multicast_group': '',
-    'peer_list': [],
-    'ingress_replication': '',
-}
-PARAM_TO_COMMAND_KEYMAP = {
-    'assoc_vrf': 'associate-vrf',
-    'interface': 'interface',
-    'vni': 'member vni',
-    'ingress_replication': 'ingress-replication protocol',
-    'multicast_group': 'mcast-group',
-    'peer_list': 'peer-ip',
-    'suppress_arp': 'suppress-arp',
-    'suppress_arp_disable': 'suppress-arp disable',
-}
-
-
-def get_value(arg, config, module):
-    command = PARAM_TO_COMMAND_KEYMAP[arg]
-    command_val_re = re.compile(r'(?:{0}\s)(?P<value>.*)$'.format(command), re.M)
-
-    if arg in BOOL_PARAMS:
-        command_re = re.compile(r'\s+{0}\s*$'.format(command), re.M)
-        value = False
-        if command_re.search(config):
-            value = True
-    elif arg == 'peer_list':
-        has_command_val = command_val_re.findall(config, re.M)
-        value = []
-        if has_command_val:
-            value = has_command_val
-    else:
-        value = ''
-        has_command_val = command_val_re.search(config, re.M)
-        if has_command_val:
-            value = has_command_val.group('value')
-    return value
-
-
-def check_interface(module, netcfg):
-    config = str(netcfg)
-
-    has_interface = re.search(r'(?:interface nve)(?P<value>.*)$', config, re.M)
-    value = ''
-    if has_interface:
-        value = 'nve{0}'.format(has_interface.group('value'))
-
-    return value
-
-
-def get_existing(module, args):
-    existing = {}
-    netcfg = CustomNetworkConfig(indent=2, contents=get_config(module))
-
-    interface_exist = check_interface(module, netcfg)
-    if interface_exist:
-        parents = ['interface {0}'.format(interface_exist)]
-        temp_config = netcfg.get_section(parents)
-
-        if 'member vni {0} associate-vrf'.format(module.params['vni']) in temp_config:
-            parents.append('member vni {0} associate-vrf'.format(module.params['vni']))
-            config = netcfg.get_section(parents)
-        elif "member vni {0}".format(module.params['vni']) in temp_config:
-            parents.append('member vni {0}'.format(module.params['vni']))
-            config = netcfg.get_section(parents)
-        else:
-            config = {}
-
-        if config:
-            for arg in args:
-                if arg not in ['interface', 'vni']:
-                    existing[arg] = get_value(arg, config, module)
-            existing['interface'] = interface_exist
-            existing['vni'] = module.params['vni']
-
-    return existing, interface_exist
-
-
-def apply_key_map(key_map, table):
-    new_dict = {}
-    for key, value in table.items():
-        new_key = key_map.get(key)
-        if new_key:
-            new_dict[new_key] = value
-    return new_dict
-
-
-def state_present(module, existing, proposed, candidate):
-    commands = list()
-    proposed_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, proposed)
-    existing_commands = apply_key_map(PARAM_TO_COMMAND_KEYMAP, existing)
-
-    for key, value in proposed_commands.items():
-        if key == 'associate-vrf':
-            command = 'member vni {0} {1}'.format(module.params['vni'], key)
-            if not value:
-                command = 'no {0}'.format(command)
-            commands.append(command)
-
-        elif key == 'peer-ip' and value != []:
-            for peer in value:
-                commands.append('{0} {1}'.format(key, peer))
-
-        elif key == 'mcast-group' and value != existing_commands.get(key):
-            commands.append('no {0}'.format(key))
-            vni_command = 'member vni {0}'.format(module.params['vni'])
-            if vni_command not in commands:
-                commands.append('member vni {0}'.format(module.params['vni']))
-            if value != PARAM_TO_DEFAULT_KEYMAP.get('multicast_group', 'default'):
-                commands.append('{0} {1}'.format(key, value))
-
-        elif key == 'ingress-replication protocol' and value != existing_commands.get(key):
-            evalue = existing_commands.get(key)
-            dvalue = PARAM_TO_DEFAULT_KEYMAP.get('ingress_replication', 'default')
-            if value != dvalue:
-                if evalue and evalue != dvalue:
-                    commands.append('no {0} {1}'.format(key, evalue))
-                commands.append('{0} {1}'.format(key, value))
-            else:
-                if evalue:
-                    commands.append('no {0} {1}'.format(key, evalue))
-
-        elif value is True:
-            commands.append(key)
-        elif value is False:
-            commands.append('no {0}'.format(key))
-        elif value == 'default' or value == []:
-            if existing_commands.get(key):
-                existing_value = existing_commands.get(key)
-                if key == 'peer-ip':
-                    for peer in existing_value:
-                        commands.append('no {0} {1}'.format(key, peer))
-                else:
-                    commands.append('no {0} {1}'.format(key, existing_value))
-            else:
-                if key.replace(' ', '_').replace('-', '_') in BOOL_PARAMS:
-                    commands.append('no {0}'.format(key.lower()))
-        else:
-            command = '{0} {1}'.format(key, value.lower())
-            commands.append(command)
-
-    if commands:
-        vni_command = 'member vni {0}'.format(module.params['vni'])
-        ingress_replications_command = 'ingress-replication protocol static'
-        ingress_replicationb_command = 'ingress-replication protocol bgp'
-        ingress_replicationns_command = 'no ingress-replication protocol static'
-        ingress_replicationnb_command = 'no ingress-replication protocol bgp'
-        interface_command = 'interface {0}'.format(module.params['interface'])
-
-        if any(c in commands for c in (ingress_replications_command, ingress_replicationb_command,
-               ingress_replicationnb_command, ingress_replicationns_command)):
-            static_level_cmds = [cmd for cmd in commands if 'peer' in cmd]
-            parents = [interface_command, vni_command]
-            commands = [cmd for cmd in commands if 'peer' not in cmd]
-            for cmd in commands:
-                parents.append(cmd)
-            candidate.add(static_level_cmds, parents=parents)
-
-        elif 'peer-ip' in commands[0]:
-            static_level_cmds = [cmd for cmd in commands]
-            parents = [interface_command, vni_command, ingress_replications_command]
-            candidate.add(static_level_cmds, parents=parents)
-
-        if vni_command in commands:
-            parents = [interface_command]
-            commands.remove(vni_command)
-            if module.params['assoc_vrf'] is None:
-                parents.append(vni_command)
-            candidate.add(commands, parents=parents)
-
-
-def state_absent(module, existing, proposed, candidate):
-    if existing['assoc_vrf']:
-        commands = ['no member vni {0} associate-vrf'.format(
-            module.params['vni'])]
-    else:
-        commands = ['no member vni {0}'.format(module.params['vni'])]
-    parents = ['interface {0}'.format(module.params['interface'])]
-    candidate.add(commands, parents=parents)
-
-
-def main():
-    argument_spec = dict(
-        interface=dict(required=True, type='str'),
-        vni=dict(required=True, type='str'),
-        assoc_vrf=dict(required=False, type='bool'),
-        multicast_group=dict(required=False, type='str'),
-        peer_list=dict(required=False, type='list'),
-        suppress_arp=dict(required=False, type='bool'),
-        suppress_arp_disable=dict(required=False, type='bool'),
-        ingress_replication=dict(required=False, type='str', choices=['bgp', 'static', 'default']),
-        state=dict(choices=['present', 'absent'], default='present', required=False),
-    )
-
-    argument_spec.update(nxos_argument_spec)
-
-    mutually_exclusive = [('suppress_arp', 'suppress_arp_disable'),
-                          ('assoc_vrf', 'multicast_group'),
-                          ('assoc_vrf', 'suppress_arp'),
-                          ('assoc_vrf', 'suppress_arp_disable'),
-                          ('assoc_vrf', 'ingress_replication')]
-    module = AnsibleModule(
-        argument_spec=argument_spec,
-        mutually_exclusive=mutually_exclusive,
-        supports_check_mode=True,
-    )
-
-    warnings = list()
-    result = {'changed': False, 'commands': [], 'warnings': warnings}
-
-    if module.params['peer_list']:
-        if module.params['peer_list'][0] != 'default' and module.params['ingress_replication'] != 'static':
-            module.fail_json(msg='ingress_replication=static is required '
-                                 'when using peer_list param')
-        else:
-            peer_list = module.params['peer_list']
-            if peer_list[0] == 'default':
-                module.params['peer_list'] = 'default'
-            else:
-                stripped_peer_list = list(map(str.strip, peer_list))
-                module.params['peer_list'] = stripped_peer_list
-
-    state = module.params['state']
-    args = PARAM_TO_COMMAND_KEYMAP.keys()
-    existing, interface_exist = get_existing(module, args)
-
-    if state == 'present':
-        if not interface_exist:
-            module.fail_json(msg="The proposed NVE interface does not exist. Use nxos_interface to create it first.")
-        elif interface_exist != module.params['interface']:
-            module.fail_json(msg='Only 1 NVE interface is allowed on the switch.')
-    elif state == 'absent':
-        if interface_exist != module.params['interface']:
-            module.exit_json(**result)
-        elif existing and existing['vni'] != module.params['vni']:
-            module.fail_json(
-                msg="ERROR: VNI delete failed: Could not find vni node for {0}".format(module.params['vni']),
-                existing_vni=existing['vni']
-            )
-
-    proposed_args = dict((k, v) for k, v in module.params.items()
-                         if v is not None and k in args)
-
-    proposed = {}
-    for key, value in proposed_args.items():
-        if key in ['multicast_group', 'peer_list', 'ingress_replication']:
-            if str(value).lower() == 'default':
-                value = PARAM_TO_DEFAULT_KEYMAP.get(key, 'default')
-        if key != 'interface' and existing.get(key) != value:
-            proposed[key] = value
-
-    candidate = CustomNetworkConfig(indent=3)
-    if state == 'present':
-        state_present(module, existing, proposed, candidate)
-    elif existing and state == 'absent':
-        state_absent(module, existing, proposed, candidate)
-
-    if candidate:
-        candidate = candidate.items_text()
-        result['changed'] = True
-        result['commands'] = candidate
-        if not module.check_mode:
-            load_config(module, candidate)
-
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/storage/nxos_devicealias.py b/lib/ansible/modules/network/nxos/storage/nxos_devicealias.py
deleted file mode 100644
index b76aa9f883..0000000000
--- a/lib/ansible/modules/network/nxos/storage/nxos_devicealias.py
+++ /dev/null
@@ -1,499 +0,0 @@
-#!/usr/bin/python
-# Copyright: Ansible Project
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import (absolute_import, division, print_function)
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
-module: nxos_devicealias
-version_added: "2.10"
-short_description: Configuration of device alias.
-description:
-    - Configuration of device alias for Cisco MDS NXOS.
-author:
-    - Suhas Bharadwaj (@srbharadwaj) (subharad@cisco.com)
-notes:
-  - Tested against NX-OS 8.4(1)
-options:
-    distribute:
-        description:
-            - Enable/Disable device-alias distribution
-        type: bool
-        default: False
-    mode:
-        description:
-            - Mode of devices-alias, basic or enhanced
-        choices: ['basic', 'enhanced']
-        type: str
-    da:
-        description:
-            - List of device-alias to be added or removed
-        type: list
-        suboptions:
-            name:
-                description:
-                    - Name of the device-alias to be added or removed
-                required:
-                    True
-                type: str
-            pwwn:
-                description:
-                    - pwwn to which the name needs to be associated with
-                type: str
-            remove:
-                description:
-                    - Removes the device-alias if set to True
-                type: bool
-                default: False
-    rename:
-        description:
-            - List of device-alias to be renamed
-        type: list
-        suboptions:
-            old_name:
-                description:
-                    - Old name of the device-alias that needs to be renamed
-                required:
-                    True
-                type: str
-            new_name:
-                description:
-                    - New name of the device-alias
-                required:
-                    True
-                type: str
-'''
-
-EXAMPLES = '''
----
-- name: 'Test that device alias module works'
-  nxos_devicealias:
-    da:
-      - name: test1_add
-        pwwn: '56:2:22:11:22:88:11:67'
-      - name: test2_add
-        pwwn: '65:22:22:11:22:22:11:d'
-      - name: dev1
-        remove: true
-      - name: dev2
-        remove: true
-    distribute: true
-    mode: enhanced
-    rename:
-      - new_name: bcd
-        old_name: abc
-      - new_name: bcd1
-        old_name: abc1
-
-
-'''
-
-RETURN = '''
-commands:
-  description: commands sent to the device
-  returned: always
-  type: list
-  sample:
-    - terminal dont-ask
-    - device-alias database
-    - device-alias name somename pwwn 10:00:00:00:89:a1:01:03
-    - device-alias name somename1 pwwn 10:00:00:00:89:a1:02:03
-    - device-alias commit
-    - no terminal dont-ask
-'''
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-import string
-
-__metaclass__ = type
-
-
-class showDeviceAliasStatus(object):
-    """docstring for showDeviceAliasStatus"""
-
-    def __init__(self, module):
-        self.module = module
-        self.distribute = ""
-        self.mode = ""
-        self.locked = False
-        self.update()
-
-    def execute_show_cmd(self, cmd):
-        output = execute_show_command(cmd, self.module)[0]
-        return output
-
-    def update(self):
-        command = 'show device-alias status'
-        output = self.execute_show_cmd(command).split("\n")
-        for o in output:
-            if "Fabric Distribution" in o:
-                self.distribute = o.split(":")[1].strip().lower()
-            if "Mode" in o:
-                self.mode = o.split("Mode:")[1].strip().lower()
-            if "Locked" in o:
-                self.locked = True
-
-    def isLocked(self):
-        return self.locked
-
-    def getDistribute(self):
-        return self.distribute
-
-    def getMode(self):
-        return self.mode
-
-
-class showDeviceAliasDatabase(object):
-    """docstring for showDeviceAliasDatabase"""
-
-    def __init__(self, module):
-        self.module = module
-        self.da_dict = {}
-        self.update()
-
-    def execute_show_cmd(self, cmd):
-        output = execute_show_command(cmd, self.module)[0]
-        return output
-
-    def update(self):
-        command = 'show device-alias database'
-        # output = execute_show_command(command, self.module)[0].split("\n")
-        output = self.execute_show_cmd(command)
-        self.da_list = output.split("\n")
-        for eachline in self.da_list:
-            if 'device-alias' in eachline:
-                sv = eachline.strip().split()
-                self.da_dict[sv[2]] = sv[4]
-
-    def isNameInDaDatabase(self, name):
-        return name in self.da_dict.keys()
-
-    def isPwwnInDaDatabase(self, pwwn):
-        newpwwn = ':'.join(["0" + str(ep) if len(ep) == 1 else ep for ep in pwwn.split(":")])
-        return newpwwn in self.da_dict.values()
-
-    def isNamePwwnPresentInDatabase(self, name, pwwn):
-        newpwwn = ':'.join(["0" + str(ep) if len(ep) == 1 else ep for ep in pwwn.split(":")])
-        if name in self.da_dict.keys():
-            if newpwwn == self.da_dict[name]:
-                return True
-        return False
-
-    def getPwwnByName(self, name):
-        if name in self.da_dict.keys():
-            return self.da_dict[name]
-        else:
-            return None
-
-    def getNameByPwwn(self, pwwn):
-        newpwwn = ':'.join(["0" + str(ep) if len(ep) == 1 else ep for ep in pwwn.split(":")])
-        for n, p in self.da_dict.items():
-            if p == newpwwn:
-                return n
-        return None
-
-
-def isPwwnValid(pwwn):
-    pwwnsplit = pwwn.split(":")
-    if len(pwwnsplit) != 8:
-        return False
-    for eachpwwnsplit in pwwnsplit:
-        if len(eachpwwnsplit) > 2 or len(eachpwwnsplit) < 1:
-            return False
-        if not all(c in string.hexdigits for c in eachpwwnsplit):
-            return False
-    return True
-
-
-def isNameValid(name):
-    if not name[0].isalpha():
-        # Illegal first character. Name must start with a letter
-        return False
-    if len(name) > 64:
-        return False
-    return True
-
-
-def execute_show_command(command, module, command_type='cli_show'):
-    output = 'text'
-    commands = [{
-        'command': command,
-        'output': output,
-    }]
-    out = run_commands(module, commands)
-    return out
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def main():
-    element_spec = dict(
-        name=dict(required=True, type='str'),
-        pwwn=dict(type='str'),
-        remove=dict(type='bool', default=False)
-    )
-
-    element_spec_rename = dict(
-        old_name=dict(required=True, type='str'),
-        new_name=dict(required=True, type='str'),
-    )
-
-    argument_spec = dict(
-        distribute=dict(type='bool'),
-        mode=dict(type='str', choices=['enhanced', 'basic']),
-        da=dict(type='list', elements='dict', options=element_spec),
-        rename=dict(type='list', elements='dict', options=element_spec_rename)
-    )
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-    messages = list()
-    commands_to_execute = list()
-    result = {'changed': False}
-
-    distribute = module.params['distribute']
-    mode = module.params['mode']
-    da = module.params['da']
-    rename = module.params['rename']
-
-    # Step 0.0: Validate syntax of name and pwwn
-    #       Also validate syntax of rename arguments
-    if da is not None:
-        for eachdict in da:
-            name = eachdict['name']
-            pwwn = eachdict['pwwn']
-            remove = eachdict['remove']
-            if pwwn is not None:
-                pwwn = pwwn.lower()
-            if not remove:
-                if pwwn is None:
-                    module.fail_json(
-                        msg='This device alias name ' +
-                        str(name) +
-                        ' which needs to be added, doenst have pwwn specified . Please specify a valid pwwn')
-                if not isNameValid(name):
-                    module.fail_json(msg='This pwwn name is invalid : ' + str(name) +
-                                     '. Note that name cannot be more than 64 chars and it should start with a letter')
-                if not isPwwnValid(pwwn):
-                    module.fail_json(msg='This pwwn is invalid : ' + str(pwwn) + '. Please check that its a valid pwwn')
-    if rename is not None:
-        for eachdict in rename:
-            oldname = eachdict['old_name']
-            newname = eachdict['new_name']
-            if not isNameValid(oldname):
-                module.fail_json(msg='This pwwn name is invalid : ' + str(oldname) +
-                                 '. Note that name cannot be more than 64 chars and it should start with a letter')
-            if not isNameValid(newname):
-                module.fail_json(msg='This pwwn name is invalid : ' + str(newname) +
-                                 '. Note that name cannot be more than 64 chars and it should start with a letter')
-
-    # Step 0.1: Check DA status
-    shDAStausObj = showDeviceAliasStatus(module)
-    d = shDAStausObj.getDistribute()
-    m = shDAStausObj.getMode()
-    if shDAStausObj.isLocked():
-        module.fail_json(msg='device-alias has acquired lock on the switch. Hence cannot procced.')
-
-    # Step 1: Process distribute
-    commands = []
-    if distribute is not None:
-        if distribute:
-            # playbook has distribute as True(enabled)
-            if d == "disabled":
-                # but switch distribute is disabled(false), so set it to true(enabled)
-                commands.append("device-alias distribute")
-                messages.append('device-alias distribute changed from disabled to enabled')
-            else:
-                messages.append('device-alias distribute remains unchanged. current distribution mode is enabled')
-        else:
-            # playbook has distribute as False(disabled)
-            if d == "enabled":
-                # but switch distribute is enabled(true), so set it to false(disabled)
-                commands.append("no device-alias distribute")
-                messages.append('device-alias distribute changed from enabled to disabled')
-            else:
-                messages.append('device-alias distribute remains unchanged. current distribution mode is disabled')
-
-    cmds = flatten_list(commands)
-    if cmds:
-        commands_to_execute = commands_to_execute + cmds
-        if module.check_mode:
-            # Check mode implemented at the da_add/da_remove stage
-            pass
-        else:
-            result['changed'] = True
-            load_config(module, cmds)
-
-    # Step 2: Process mode
-    commands = []
-    if mode is not None:
-        if mode == 'basic':
-            # playbook has mode as basic
-            if m == 'enhanced':
-                # but switch mode is enhanced, so set it to basic
-                commands.append("no device-alias mode enhanced")
-                messages.append('device-alias mode changed from enhanced to basic')
-            else:
-                messages.append('device-alias mode remains unchanged. current mode is basic')
-
-        else:
-            # playbook has mode as enhanced
-            if m == 'basic':
-                # but switch mode is basic, so set it to enhanced
-                commands.append("device-alias mode enhanced")
-                messages.append('device-alias mode changed from basic to enhanced')
-            else:
-                messages.append('device-alias mode remains unchanged. current mode is enhanced')
-
-    if commands:
-        if distribute:
-            commands.append("device-alias commit")
-            commands = ["terminal dont-ask"] + commands + ["no terminal dont-ask"]
-        else:
-            if distribute is None and d == 'enabled':
-                commands.append("device-alias commit")
-                commands = ["terminal dont-ask"] + commands + ["no terminal dont-ask"]
-
-    cmds = flatten_list(commands)
-
-    if cmds:
-        commands_to_execute = commands_to_execute + cmds
-        if module.check_mode:
-            # Check mode implemented at the end
-            pass
-        else:
-            result['changed'] = True
-            load_config(module, cmds)
-
-    # Step 3: Process da
-    commands = []
-    shDADatabaseObj = showDeviceAliasDatabase(module)
-    if da is not None:
-        da_remove_list = []
-        da_add_list = []
-        for eachdict in da:
-            name = eachdict['name']
-            pwwn = eachdict['pwwn']
-            remove = eachdict['remove']
-            if pwwn is not None:
-                pwwn = pwwn.lower()
-            if remove:
-                if shDADatabaseObj.isNameInDaDatabase(name):
-                    commands.append("no device-alias name " + name)
-                    da_remove_list.append(name)
-                else:
-                    messages.append(name + ' - This device alias name is not in switch device-alias database, hence cannot be removed.')
-            else:
-                if shDADatabaseObj.isNamePwwnPresentInDatabase(name, pwwn):
-                    messages.append(name + ' : ' + pwwn + ' - This device alias name,pwwn is already in switch device-alias database, \
-                        hence nothing to configure')
-                else:
-                    if shDADatabaseObj.isNameInDaDatabase(name):
-                        module.fail_json(
-                            msg=name +
-                            ' - This device alias name is already present in switch device-alias database but assigned to another pwwn (' +
-                            shDADatabaseObj.getPwwnByName(name) +
-                            ') hence cannot be added')
-
-                    elif shDADatabaseObj.isPwwnInDaDatabase(pwwn):
-                        module.fail_json(
-                            msg=pwwn +
-                            ' - This device alias pwwn is already present in switch device-alias database but assigned to another name (' +
-                            shDADatabaseObj.getNameByPwwn(pwwn) +
-                            ') hence cannot be added')
-
-                    else:
-                        commands.append("device-alias name " + name + " pwwn " + pwwn)
-                        da_add_list.append(name)
-
-        if len(da_add_list) != 0 or len(da_remove_list) != 0:
-            commands = ["device-alias database"] + commands
-            if distribute:
-                commands.append("device-alias commit")
-                commands = ["terminal dont-ask"] + commands + ["no terminal dont-ask"]
-            else:
-                if distribute is None and d == 'enabled':
-                    commands.append("device-alias commit")
-                    commands = ["terminal dont-ask"] + commands + ["no terminal dont-ask"]
-
-        cmds = flatten_list(commands)
-        if cmds:
-            commands_to_execute = commands_to_execute + cmds
-            if module.check_mode:
-                # Check mode implemented at the end
-                pass
-            else:
-                result['changed'] = True
-                load_config(module, cmds)
-                if len(da_remove_list) != 0:
-                    messages.append('the required device-alias were removed. ' + ','.join(da_remove_list))
-                if len(da_add_list) != 0:
-                    messages.append('the required device-alias were added. ' + ','.join(da_add_list))
-
-    # Step 5: Process rename
-    commands = []
-    if rename is not None:
-        for eachdict in rename:
-            oldname = eachdict['old_name']
-            newname = eachdict['new_name']
-            if shDADatabaseObj.isNameInDaDatabase(newname):
-                module.fail_json(
-                    changed=False,
-                    commands=cmds,
-                    msg=newname +
-                    " - this name is already present in the device-alias database, hence we cannot rename " +
-                    oldname +
-                    " with this one")
-            if shDADatabaseObj.isNameInDaDatabase(oldname):
-                commands.append('device-alias rename ' + oldname + ' ' + newname)
-            else:
-                module.fail_json(changed=False, commands=cmds, msg=oldname +
-                                 " - this name is not present in the device-alias database, hence we cannot rename.")
-
-        if len(commands) != 0:
-            commands = ["device-alias database"] + commands
-            if distribute:
-                commands.append("device-alias commit")
-                commands = ["terminal dont-ask"] + commands + ["no terminal dont-ask"]
-            else:
-                if distribute is None and d == 'enabled':
-                    commands.append("device-alias commit")
-                    commands = ["terminal dont-ask"] + commands + ["no terminal dont-ask"]
-        cmds = flatten_list(commands)
-        if cmds:
-            commands_to_execute = commands_to_execute + cmds
-            if module.check_mode:
-                # Check mode implemented at the end
-                pass
-            else:
-                result['changed'] = True
-                load_config(module, cmds)
-
-    # Step END: check for 'check' mode
-    if module.check_mode:
-        module.exit_json(changed=False, commands=commands_to_execute, msg="Check Mode: No cmds issued to the hosts")
-
-    result['messages'] = messages
-    result['commands'] = commands_to_execute
-    result['warnings'] = warnings
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/storage/nxos_vsan.py b/lib/ansible/modules/network/nxos/storage/nxos_vsan.py
deleted file mode 100644
index 92dd9cd3e8..0000000000
--- a/lib/ansible/modules/network/nxos/storage/nxos_vsan.py
+++ /dev/null
@@ -1,326 +0,0 @@
-#!/usr/bin/python
-# Copyright: Ansible Project
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import (absolute_import, division, print_function)
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
-module: nxos_vsan
-version_added: "2.10"
-short_description: Configuration of vsan.
-description:
-    - Configuration of vsan for Cisco MDS NXOS.
-author:
-    - Suhas Bharadwaj (@srbharadwaj) (subharad@cisco.com)
-notes:
-  - Tested against NX-OS 8.4(1)
-options:
-    vsan:
-        description:
-            - List of vsan details to be added or removed
-        type: list
-        suboptions:
-            id:
-                description:
-                    - Vsan id
-                required: True
-                type: int
-            name:
-                description:
-                    - Name of the vsan
-                type: str
-            suspend:
-                description:
-                    - suspend the vsan if True
-                type: bool
-                default: False
-            remove:
-                description:
-                    - Removes the vsan if True
-                type: bool
-                default: False
-            interface:
-                description:
-                    - List of vsan's interfaces to be added
-                type: list
-'''
-
-EXAMPLES = '''
----
--
-  name: "Test that vsan module works"
-  nxos_vsan:
-    vsan:
-      - id: 922
-        interface:
-          - fc1/1
-          - fc1/2
-          - "port-channel 1"
-        name: vsan-SAN-A
-        remove: false
-        suspend: false
-      - id: 923
-        interface:
-          - fc1/11
-          - fc1/21
-          - "port-channel 2"
-        name: vsan-SAN-B
-        remove: false
-        suspend: true
-      - id: 1923
-        name: vsan-SAN-Old
-        remove: true
-'''
-
-RETURN = '''
-commands:
-  description: commands sent to the device
-  returned: always
-  type: list
-  sample:
-    - terminal dont-ask
-    - vsan database
-    - vsan 922 interface fc1/40
-    - vsan 922 interface port-channel 155
-    - no terminal dont-ask
-'''
-
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-import re
-
-__metaclass__ = type
-
-
-class Vsan(object):
-    def __init__(self, vsanid):
-        self.vsanid = vsanid
-        self.vsanname = None
-        self.vsanstate = None
-        self.vsanoperstate = None
-        self.vsaninterfaces = []
-
-
-class GetVsanInfoFromSwitch(object):
-    """docstring for GetVsanInfoFromSwitch"""
-
-    def __init__(self, module):
-        self.module = module
-        self.vsaninfo = {}
-        self.processShowVsan()
-        self.processShowVsanMembership()
-
-    def execute_show_vsan_cmd(self):
-        output = execute_show_command('show vsan', self.module)[0]
-        return output
-
-    def execute_show_vsan_mem_cmd(self):
-        output = execute_show_command('show vsan membership', self.module)[0]
-        return output
-
-    def processShowVsan(self):
-        patv = r"^vsan\s+(\d+)\s+information"
-        patnamestate = "name:(.*)state:(.*)"
-        patoperstate = "operational state:(.*)"
-
-        output = self.execute_show_vsan_cmd().split("\n")
-        for o in output:
-            z = re.match(patv, o.strip())
-            if z:
-                v = z.group(1).strip()
-                self.vsaninfo[v] = Vsan(v)
-
-            z1 = re.match(patnamestate, o.strip())
-            if z1:
-                n = z1.group(1).strip()
-                s = z1.group(2).strip()
-                self.vsaninfo[v].vsanname = n
-                self.vsaninfo[v].vsanstate = s
-
-            z2 = re.match(patoperstate, o.strip())
-            if z2:
-                oper = z2.group(1).strip()
-                self.vsaninfo[v].vsanoperstate = oper
-
-        # 4094/4079 vsan is always present
-        self.vsaninfo['4079'] = Vsan('4079')
-        self.vsaninfo['4094'] = Vsan('4094')
-
-    def processShowVsanMembership(self):
-        patv = r"^vsan\s+(\d+).*"
-        output = self.execute_show_vsan_mem_cmd().split("\n")
-        memlist = []
-        v = None
-        for o in output:
-            z = re.match(patv, o.strip())
-            if z:
-                if v is not None:
-                    self.vsaninfo[v].vsaninterfaces = memlist
-                    memlist = []
-                v = z.group(1)
-            if 'interfaces' not in o:
-                llist = o.strip().split()
-                memlist = memlist + llist
-        self.vsaninfo[v].vsaninterfaces = memlist
-
-    def getVsanInfoObjects(self):
-        return self.vsaninfo
-
-
-def execute_show_command(command, module, command_type='cli_show'):
-    output = 'text'
-    commands = [{
-        'command': command,
-        'output': output,
-    }]
-    return run_commands(module, commands)
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def main():
-    vsan_element_spec = dict(
-        id=dict(required=True, type='int'),
-        name=dict(type='str'),
-        remove=dict(type='bool'),
-        suspend=dict(type='bool'),
-        interface=dict(type='list', elements='str')
-    )
-
-    argument_spec = dict(
-        vsan=dict(type='list', elements='dict', options=vsan_element_spec)
-    )
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-    warnings = list()
-    messages = list()
-    commands_executed = list()
-    result = {'changed': False}
-
-    obj = GetVsanInfoFromSwitch(module)
-    dictSwVsanObjs = obj.getVsanInfoObjects()
-
-    commands = []
-    vsan_list = module.params['vsan']
-
-    for eachvsan in vsan_list:
-        vsanid = str(eachvsan['id'])
-        vsanname = eachvsan['name']
-        vsanremove = eachvsan['remove']
-        vsansuspend = eachvsan['suspend']
-        vsaninterface_list = eachvsan['interface']
-
-        if int(vsanid) < 1 or int(vsanid) >= 4095:
-            module.fail_json(msg=vsanid + " - This is an invalid vsan. Supported vsan range is 1-4094")
-
-        if vsanid in dictSwVsanObjs.keys():
-            sw_vsanid = vsanid
-            sw_vsanname = dictSwVsanObjs[vsanid].vsanname
-            sw_vsanstate = dictSwVsanObjs[vsanid].vsanstate
-            sw_vsaninterfaces = dictSwVsanObjs[vsanid].vsaninterfaces
-        else:
-            sw_vsanid = None
-            sw_vsanname = None
-            sw_vsanstate = None
-            sw_vsaninterfaces = []
-
-        if vsanremove:
-            # Negative case:
-            if vsanid == '4079' or vsanid == '4094':
-                messages.append(str(vsanid) + " is a reserved vsan, hence cannot be removed")
-                continue
-            if vsanid == sw_vsanid:
-                commands.append("no vsan " + str(vsanid))
-                messages.append("deleting the vsan " + str(vsanid))
-            else:
-                messages.append("There is no vsan " + str(vsanid) + " present in the switch. Hence there is nothing to delete")
-            continue
-        else:
-            # Negative case:
-            if vsanid == '4079' or vsanid == '4094':
-                messages.append(str(vsanid) + " is a reserved vsan, and always present on the switch")
-            else:
-                if vsanid == sw_vsanid:
-                    messages.append("There is already a vsan " + str(vsanid) + " present in the switch. Hence there is nothing to configure")
-                else:
-                    commands.append("vsan " + str(vsanid))
-                    messages.append("creating vsan " + str(vsanid))
-
-        if vsanname is not None:
-            # Negative case:
-            if vsanid == '4079' or vsanid == '4094':
-                messages.append(str(vsanid) + " is a reserved vsan, and cannot be renamed")
-            else:
-                if vsanname == sw_vsanname:
-                    messages.append(
-                        "There is already a vsan " +
-                        str(vsanid) +
-                        " present in the switch, which has the name " +
-                        vsanname +
-                        " Hence there is nothing to configure")
-                else:
-                    commands.append("vsan " + str(vsanid) + " name " + vsanname)
-                    messages.append("setting vsan name to " + vsanname + " for vsan " + str(vsanid))
-
-        if vsansuspend:
-            # Negative case:
-            if vsanid == '4079' or vsanid == '4094':
-                messages.append(str(vsanid) + " is a reserved vsan, and cannot be suspended")
-            else:
-                if sw_vsanstate == 'suspended':
-                    messages.append("There is already a vsan " + str(vsanid) + " present in the switch, which is in suspended state ")
-                else:
-                    commands.append("vsan " + str(vsanid) + " suspend")
-                    messages.append("suspending the vsan " + str(vsanid))
-        else:
-            if sw_vsanstate == 'active':
-                messages.append("There is already a vsan " + str(vsanid) + " present in the switch, which is in active state ")
-            else:
-                commands.append("no vsan " + str(vsanid) + " suspend")
-                messages.append("no suspending the vsan " + str(vsanid))
-
-        if vsaninterface_list is not None:
-            for each_interface_name in vsaninterface_list:
-                # For fcip,port-channel,vfc-port-channel need to remove the extra space to compare
-                temp = re.sub(' +', '', each_interface_name)
-                if temp in sw_vsaninterfaces:
-                    messages.append(each_interface_name + " is already present in the vsan " + str(vsanid) + " interface list")
-                else:
-                    commands.append("vsan " + str(vsanid) + " interface " + each_interface_name)
-                    messages.append("adding interface " + each_interface_name + " to vsan " + str(vsanid))
-
-    if len(commands) != 0:
-        commands = ["terminal dont-ask"] + ["vsan database"] + commands + ["no terminal dont-ask"]
-
-    cmds = flatten_list(commands)
-    commands_executed = cmds
-
-    if commands_executed:
-        if module.check_mode:
-            module.exit_json(changed=False, commands=commands_executed, msg="Check Mode: No cmds issued to the hosts")
-        else:
-            result['changed'] = True
-            load_config(module, commands_executed)
-
-    result['messages'] = messages
-    result['commands'] = commands_executed
-    result['warnings'] = warnings
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/modules/network/nxos/storage/nxos_zone_zoneset.py b/lib/ansible/modules/network/nxos/storage/nxos_zone_zoneset.py
deleted file mode 100644
index 49ddd77f39..0000000000
--- a/lib/ansible/modules/network/nxos/storage/nxos_zone_zoneset.py
+++ /dev/null
@@ -1,722 +0,0 @@
-#!/usr/bin/python
-# Copyright: Ansible Project
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import (absolute_import, division, print_function)
-
-ANSIBLE_METADATA = {'metadata_version': '1.1',
-                    'status': ['preview'],
-                    'supported_by': 'network'}
-
-
-DOCUMENTATION = '''
----
-module: nxos_zone_zoneset
-version_added: "2.10"
-short_description: Configuration of zone/zoneset.
-description:
-    - Configuration of zone/zoneset for Cisco MDS NXOS.
-author:
-    - Suhas Bharadwaj (@srbharadwaj) (subharad@cisco.com)
-notes:
-  - Tested against NX-OS 8.4(1)
-options:
-    zone_zoneset_details:
-        description:
-            - List of zone/zoneset details to be added or removed
-        type: list
-        suboptions:
-            vsan:
-                description:
-                    - vsan id
-                required:
-                    True
-                type: int
-            mode:
-                description:
-                    - mode of the zone for the vsan
-                choices: ['enhanced', 'basic']
-                type: str
-            default_zone:
-                description:
-                    - default zone behaviour for the vsan
-                choices: ['permit', 'deny']
-                type: str
-            smart_zoning:
-                description:
-                    - Removes the vsan if True
-                type: bool
-                default: False
-            zone:
-                description:
-                    - List of zone options for that vsan
-                type: list
-                suboptions:
-                    name:
-                        description:
-                            - name of the zone
-                        required:
-                            True
-                        type: str
-                    remove:
-                        description:
-                            - Deletes the zone if True
-                        type: bool
-                        default: False
-                    members:
-                        description:
-                            - Members of the zone that needs to be removed or added
-                        type: list
-                        suboptions:
-                            pwwn:
-                                description:
-                                   - pwwn member of the zone, use alias 'device_alias' as option for device_alias member
-                                aliases: [device_alias]
-                                required: true
-                                type: str
-                            remove:
-                                description:
-                                    - Removes member from the zone if True
-                                type: bool
-                                default: false
-                            devtype:
-                                description:
-                                    - devtype of the zone member used along with Smart zoning config
-                                choices: ['initiator', 'target', 'both']
-                                type: str
-            zoneset:
-                description:
-                    - List of zoneset options for the vsan
-                type: list
-                suboptions:
-                    name:
-                        description:
-                            - name of the zoneset
-                        required:
-                            True
-                        type: str
-                    remove:
-                        description:
-                            - Removes zoneset if True
-                        type: bool
-                        default: False
-                    action:
-                        description:
-                            - activates/de-activates the zoneset
-                        choices: ['activate', 'deactivate']
-                        type: str
-                    members:
-                        description:
-                            - Members of the zoneset that needs to be removed or added
-                        type: list
-                        suboptions:
-                            name:
-                                description:
-                                    - name of the zone that needs to be added to the zoneset or removed from the zoneset
-                                required: True
-                                type: str
-                            remove:
-                                description:
-                                    - Removes zone member from the zoneset
-                                type: bool
-                                default: False
-'''
-
-EXAMPLES = '''
----
--
-  name: 'Test that zone/zoneset module works'
-  nxos_zone_zoneset:
-    zone_zoneset_details:
-      - mode: enhanced
-        vsan: 22
-        zone:
-          - members:
-              - pwwn: '11:11:11:11:11:11:11:11'
-              - device_alias: test123
-              - pwwn: '61:61:62:62:12:12:12:12'
-                remove: true
-            name: zoneA
-          - members:
-              - pwwn: '10:11:11:11:11:11:11:11'
-              - pwwn: '62:62:62:62:21:21:21:21'
-            name: zoneB
-          - name: zoneC
-            remove: true
-        zoneset:
-          - action: activate
-            members:
-              - name: zoneA
-              - name: zoneB
-              - name: zoneC
-                remove: true
-            name: zsetname1
-          - action: deactivate
-            name: zsetTestExtra
-            remove: true
-      - mode: basic
-        smart_zoning: true
-        vsan: 21
-        zone:
-          - members:
-              - devtype: both
-                pwwn: '11:11:11:11:11:11:11:11'
-              - pwwn: '62:62:62:62:12:12:12:12'
-              - devtype: both
-                pwwn: '92:62:62:62:12:12:1a:1a'
-                remove: true
-            name: zone21A
-          - members:
-              - pwwn: '10:11:11:11:11:11:11:11'
-              - pwwn: '62:62:62:62:21:21:21:21'
-            name: zone21B
-        zoneset:
-          - action: activate
-            members:
-              - name: zone21A
-              - name: zone21B
-            name: zsetname212
-
-'''
-
-RETURN = '''
-commands:
-  description: commands sent to the device
-  returned: always
-  type: list
-  sample:
-    - terminal dont-ask
-    - zone name zoneA vsan 923
-    - member pwwn 11:11:11:11:11:11:11:11
-    - no member device-alias test123
-    - zone commit vsan 923
-    - no terminal dont-ask
-'''
-
-
-import re
-from ansible.module_utils.basic import AnsibleModule
-from ansible.module_utils.network.nxos.nxos import load_config, run_commands
-
-
-__metaclass__ = type
-
-
-class ShowZonesetActive(object):
-    """docstring for ShowZonesetActive"""
-
-    def __init__(self, module, vsan):
-        self.vsan = vsan
-        self.module = module
-        self.activeZSName = None
-        self.parseCmdOutput()
-
-    def execute_show_zoneset_active_cmd(self):
-        command = 'show zoneset active vsan ' + str(self.vsan) + ' | grep zoneset'
-        output = execute_show_command(command, self.module)[0]
-        return output
-
-    def parseCmdOutput(self):
-        patZoneset = r"zoneset name (\S+) vsan " + str(self.vsan)
-        output = self.execute_show_zoneset_active_cmd().split("\n")
-        if len(output) == 0:
-            return
-        else:
-            for line in output:
-                line = line.strip()
-                mzs = re.match(patZoneset, line.strip())
-                if mzs:
-                    self.activeZSName = mzs.group(1).strip()
-                    return
-
-    def isZonesetActive(self, zsname):
-        if zsname == self.activeZSName:
-            return True
-        return False
-
-
-class ShowZoneset(object):
-    """docstring for ShowZoneset"""
-
-    def __init__(self, module, vsan):
-        self.vsan = vsan
-        self.module = module
-        self.zsDetails = {}
-        self.parseCmdOutput()
-
-    def execute_show_zoneset_cmd(self):
-        command = 'show zoneset vsan ' + str(self.vsan)
-        output = execute_show_command(command, self.module)[0]
-        return output
-
-    def parseCmdOutput(self):
-        patZoneset = r"zoneset name (\S+) vsan " + str(self.vsan)
-        patZone = r"zone name (\S+) vsan " + str(self.vsan)
-        output = self.execute_show_zoneset_cmd().split("\n")
-        for line in output:
-            line = line.strip()
-            mzs = re.match(patZoneset, line.strip())
-            mz = re.match(patZone, line.strip())
-            if mzs:
-                zonesetname = mzs.group(1).strip()
-                self.zsDetails[zonesetname] = []
-                continue
-            elif mz:
-                zonename = mz.group(1).strip()
-                v = self.zsDetails[zonesetname]
-                v.append(zonename)
-                self.zsDetails[zonesetname] = v
-
-    def isZonesetPresent(self, zsname):
-        return zsname in self.zsDetails.keys()
-
-    def isZonePresentInZoneset(self, zsname, zname):
-        if zsname in self.zsDetails.keys():
-            return zname in self.zsDetails[zsname]
-        return False
-
-
-class ShowZone(object):
-    """docstring for ShowZone"""
-
-    def __init__(self, module, vsan):
-        self.vsan = vsan
-        self.module = module
-        self.zDetails = {}
-        self.parseCmdOutput()
-
-    def execute_show_zone_vsan_cmd(self):
-        command = 'show zone vsan ' + str(self.vsan)
-        output = execute_show_command(command, self.module)[0]
-        return output
-
-    def parseCmdOutput(self):
-        patZone = r"zone name (\S+) vsan " + str(self.vsan)
-        output = self.execute_show_zone_vsan_cmd().split("\n")
-        for line in output:
-            line = ' '.join(line.strip().split())
-            m = re.match(patZone, line)
-            if m:
-                zonename = m.group(1).strip()
-                self.zDetails[zonename] = []
-                continue
-            else:
-                # For now we support only pwwn and device-alias under zone
-                # Ideally should use 'supported_choices'....but maybe next time.
-                if "pwwn" in line or "device-alias" in line:
-                    v = self.zDetails[zonename]
-                    v.append(line)
-                    self.zDetails[zonename] = v
-
-    def isZonePresent(self, zname):
-        return zname in self.zDetails.keys()
-
-    def isZoneMemberPresent(self, zname, cmd):
-        if zname in self.zDetails.keys():
-            return cmd in self.zDetails[zname]
-        return False
-
-
-class ShowZoneStatus(object):
-    """docstring for ShowZoneStatus"""
-
-    def __init__(self, module, vsan):
-        self.vsan = vsan
-        self.vsanAbsent = False
-        self.module = module
-        self.default_zone = ""
-        self.mode = ""
-        self.session = ""
-        self.sz = ""
-        self.locked = False
-        self.update()
-
-    def execute_show_zone_status_cmd(self):
-        command = 'show zone status vsan ' + str(self.vsan)
-        output = execute_show_command(command, self.module)[0]
-        return output
-
-    def update(self):
-
-        output = self.execute_show_zone_status_cmd().split("\n")
-
-        patfordefzone = "VSAN: " + str(self.vsan) + r" default-zone:\s+(\S+).*"
-        patformode = r".*mode:\s+(\S+).*"
-        patforsession = r".*session:\s+(\S+).*"
-        patforsz = r".*smart-zoning:\s+(\S+).*"
-        for line in output:
-            if "is not configured" in line:
-                self.vsanAbsent = True
-                break
-            mdefz = re.match(patfordefzone, line.strip())
-            mmode = re.match(patformode, line.strip())
-            msession = re.match(patforsession, line.strip())
-            msz = re.match(patforsz, line.strip())
-
-            if mdefz:
-                self.default_zone = mdefz.group(1)
-            if mmode:
-                self.mode = mmode.group(1)
-            if msession:
-                self.session = msession.group(1)
-                if self.session != "none":
-                    self.locked = True
-            if msz:
-                self.sz = msz.group(1)
-
-    def isLocked(self):
-        return self.locked
-
-    def getDefaultZone(self):
-        return self.default_zone
-
-    def getMode(self):
-        return self.mode
-
-    def getSmartZoningStatus(self):
-        return self.sz
-
-    def isVsanAbsent(self):
-        return self.vsanAbsent
-
-
-def execute_show_command(command, module, command_type='cli_show'):
-    output = 'text'
-    commands = [{
-        'command': command,
-        'output': output,
-    }]
-    return run_commands(module, commands)
-
-
-def flatten_list(command_lists):
-    flat_command_list = []
-    for command in command_lists:
-        if isinstance(command, list):
-            flat_command_list.extend(command)
-        else:
-            flat_command_list.append(command)
-    return flat_command_list
-
-
-def getMemType(supported_choices, allmemkeys, default='pwwn'):
-    for eachchoice in supported_choices:
-        if eachchoice in allmemkeys:
-            return eachchoice
-    return default
-
-
-def main():
-
-    supported_choices = ['device_alias']
-    zone_member_spec = dict(
-        pwwn=dict(required=True, type='str', aliases=['device_alias']),
-        devtype=dict(type='str', choices=['initiator', 'target', 'both']),
-        remove=dict(type='bool', default=False)
-    )
-
-    zone_spec = dict(
-        name=dict(required=True, type='str'),
-        members=dict(type='list', elements='dict', options=zone_member_spec),
-        remove=dict(type='bool', default=False)
-    )
-
-    zoneset_member_spec = dict(
-        name=dict(required=True, type='str'),
-        remove=dict(type='bool', default=False)
-    )
-
-    zoneset_spec = dict(
-        name=dict(type='str', required=True),
-        members=dict(type='list', elements='dict', options=zoneset_member_spec),
-        remove=dict(type='bool', default=False),
-        action=dict(type='str', choices=['activate', 'deactivate'])
-    )
-
-    zonedetails_spec = dict(
-        vsan=dict(required=True, type='int'),
-        mode=dict(type='str', choices=['enhanced', 'basic']),
-        default_zone=dict(type='str', choices=['permit', 'deny']),
-        smart_zoning=dict(type='bool'),
-        zone=dict(type='list', elements='dict', options=zone_spec),
-        zoneset=dict(type='list', elements='dict', options=zoneset_spec),
-    )
-
-    argument_spec = dict(
-        zone_zoneset_details=dict(type='list', elements='dict', options=zonedetails_spec)
-    )
-
-    module = AnsibleModule(argument_spec=argument_spec,
-                           supports_check_mode=True)
-
-    warnings = list()
-    messages = list()
-    commands = list()
-    result = {'changed': False}
-
-    commands_executed = []
-    listOfZoneDetails = module.params['zone_zoneset_details']
-    for eachZoneZonesetDetail in listOfZoneDetails:
-        vsan = eachZoneZonesetDetail['vsan']
-        op_mode = eachZoneZonesetDetail['mode']
-        op_default_zone = eachZoneZonesetDetail['default_zone']
-        op_smart_zoning = eachZoneZonesetDetail['smart_zoning']
-        op_zone = eachZoneZonesetDetail['zone']
-        op_zoneset = eachZoneZonesetDetail['zoneset']
-
-        # Step1: execute show zone status and get
-        shZoneStatusObj = ShowZoneStatus(module, vsan)
-        sw_default_zone = shZoneStatusObj.getDefaultZone()
-        sw_mode = shZoneStatusObj.getMode()
-        sw_smart_zoning = shZoneStatusObj.getSmartZoningStatus()
-
-        if sw_smart_zoning.lower() == "Enabled".lower():
-            sw_smart_zoning_bool = True
-        else:
-            sw_smart_zoning_bool = False
-
-        if shZoneStatusObj.isVsanAbsent():
-            module.fail_json(msg='Vsan ' + str(vsan) + ' is not present in the switch. Hence cannot procced.')
-
-        if shZoneStatusObj.isLocked():
-            module.fail_json(msg='zone has acquired lock on the switch for vsan ' + str(vsan) + '. Hence cannot procced.')
-
-        # Process zone default zone options
-        if op_default_zone is not None:
-            if op_default_zone != sw_default_zone:
-                if op_default_zone == "permit":
-                    commands_executed.append("zone default-zone permit vsan " + str(vsan))
-                    messages.append("default zone configuration changed from deny to permit for vsan " + str(vsan))
-                else:
-                    commands_executed.append("no zone default-zone permit vsan " + str(vsan))
-                    messages.append("default zone configuration changed from permit to deny for vsan " + str(vsan))
-            else:
-                messages.append("default zone is already " + op_default_zone + " ,no change in default zone configuration for vsan " + str(vsan))
-
-        # Process zone mode options
-        if op_mode is not None:
-            if op_mode != sw_mode:
-                if op_mode == "enhanced":
-                    commands_executed.append("zone mode enhanced vsan " + str(vsan))
-                    messages.append("zone mode configuration changed from basic to enhanced for vsan " + str(vsan))
-                else:
-                    commands_executed.append("no zone mode enhanced vsan " + str(vsan))
-                    messages.append("zone mode configuration changed from enhanced to basic for vsan " + str(vsan))
-            else:
-                messages.append("zone mode is already " + op_mode + " ,no change in zone mode configuration for vsan " + str(vsan))
-
-        # Process zone smart-zone options
-        if op_smart_zoning is not None:
-            if op_smart_zoning != sw_smart_zoning_bool:
-                if op_smart_zoning:
-                    commands_executed.append("zone smart-zoning enable vsan " + str(vsan))
-                    messages.append("smart-zoning enabled for vsan " + str(vsan))
-                else:
-                    commands_executed.append("no zone smart-zoning enable vsan " + str(vsan))
-                    messages.append("smart-zoning disabled for vsan " + str(vsan))
-            else:
-                messages.append("smart-zoning is already set to " + sw_smart_zoning + " , no change in smart-zoning configuration for vsan " + str(vsan))
-
-        # Process zone member options
-        # TODO: Obviously this needs to be cleaned up properly, as there are a lot of ifelse statements which is bad
-        # Will take it up later becoz of time constraints
-        if op_zone is not None:
-            shZoneObj = ShowZone(module, vsan)
-            for eachzone in op_zone:
-                zname = eachzone['name']
-                zmembers = eachzone['members']
-                removeflag = eachzone['remove']
-                if removeflag:
-                    if shZoneObj.isZonePresent(zname):
-                        messages.append("zone '" + zname + "' is removed from vsan " + str(vsan))
-                        commands_executed.append("no zone name " + zname + " vsan " + str(vsan))
-                    else:
-                        messages.append("zone '" + zname + "' is not present in vsan " + str(vsan) + " , so nothing to remove")
-                else:
-                    if zmembers is None:
-                        if shZoneObj.isZonePresent(zname):
-                            messages.append("zone '" + zname + "' is already present in vsan " + str(vsan))
-                        else:
-                            commands_executed.append("zone name " + zname + " vsan " + str(vsan))
-                            messages.append("zone '" + zname + "' is created in vsan " + str(vsan))
-                    else:
-                        cmdmemlist = []
-                        for eachmem in zmembers:
-                            memtype = getMemType(supported_choices, eachmem.keys())
-                            cmd = memtype.replace('_', '-') + " " + eachmem[memtype]
-                            if op_smart_zoning or sw_smart_zoning_bool:
-                                if eachmem['devtype'] is not None:
-                                    cmd = cmd + " " + eachmem['devtype']
-                            if eachmem["remove"]:
-                                if shZoneObj.isZonePresent(zname):
-                                    if shZoneObj.isZoneMemberPresent(zname, cmd):
-                                        cmd = "no member " + cmd
-                                        cmdmemlist.append(cmd)
-                                        if op_smart_zoning and eachmem['devtype'] is not None:
-                                            messages.append(
-                                                "removing zone member '" +
-                                                eachmem[memtype] +
-                                                " of device type '" +
-                                                eachmem['devtype'] +
-                                                "' from zone '" +
-                                                zname +
-                                                "' in vsan " +
-                                                str(vsan))
-                                        else:
-                                            messages.append("removing zone member '" + eachmem[memtype] + "' from zone '" + zname + "' in vsan " + str(vsan))
-                                    else:
-                                        if op_smart_zoning and eachmem['devtype'] is not None:
-                                            messages.append(
-                                                "zone member '" +
-                                                eachmem[memtype] +
-                                                "' of device type '" +
-                                                eachmem['devtype'] +
-                                                "' is not present in zone '" +
-                                                zname +
-                                                "' in vsan " +
-                                                str(vsan) +
-                                                " hence nothing to remove")
-                                        else:
-                                            messages.append(
-                                                "zone member '" +
-                                                eachmem[memtype] +
-                                                "' is not present in zone '" +
-                                                zname +
-                                                "' in vsan " +
-                                                str(vsan) +
-                                                " hence nothing to remove")
-                                else:
-                                    messages.append("zone '" + zname + "' is not present in vsan " + str(vsan) + " , hence cannot remove the members")
-
-                            else:
-                                if shZoneObj.isZoneMemberPresent(zname, cmd):
-                                    if op_smart_zoning and eachmem['devtype'] is not None:
-                                        messages.append(
-                                            "zone member '" +
-                                            eachmem[memtype] +
-                                            "' of device type '" +
-                                            eachmem['devtype'] +
-                                            "' is already present in zone '" +
-                                            zname +
-                                            "' in vsan " +
-                                            str(vsan) +
-                                            " hence nothing to add")
-                                    else:
-                                        messages.append(
-                                            "zone member '" +
-                                            eachmem[memtype] +
-                                            "' is already present in zone '" +
-                                            zname +
-                                            "' in vsan " +
-                                            str(vsan) +
-                                            " hence nothing to add")
-                                else:
-                                    cmd = "member " + cmd
-                                    cmdmemlist.append(cmd)
-                                    if op_smart_zoning and eachmem['devtype'] is not None:
-                                        messages.append(
-                                            "adding zone member '" +
-                                            eachmem[memtype] +
-                                            "' of device type '" +
-                                            eachmem['devtype'] +
-                                            "' to zone '" +
-                                            zname +
-                                            "' in vsan " +
-                                            str(vsan))
-                                    else:
-                                        messages.append("adding zone member '" + eachmem[memtype] + "' to zone '" + zname + "' in vsan " + str(vsan))
-                        if len(cmdmemlist) != 0:
-                            commands_executed.append("zone name " + zname + " vsan " + str(vsan))
-                            commands_executed = commands_executed + cmdmemlist
-
-        # Process zoneset member options
-        if op_zoneset is not None:
-            dactcmd = []
-            actcmd = []
-            shZonesetObj = ShowZoneset(module, vsan)
-            shZonesetActiveObj = ShowZonesetActive(module, vsan)
-            for eachzoneset in op_zoneset:
-                zsetname = eachzoneset['name']
-                zsetmembers = eachzoneset['members']
-                removeflag = eachzoneset['remove']
-                actionflag = eachzoneset['action']
-                if removeflag:
-                    if shZonesetObj.isZonesetPresent(zsetname):
-                        messages.append("zoneset '" + zsetname + "' is removed from vsan " + str(vsan))
-                        commands_executed.append("no zoneset name " + zsetname + " vsan " + str(vsan))
-                    else:
-                        messages.append("zoneset '" + zsetname + "' is not present in vsan " + str(vsan) + " ,hence there is nothing to remove")
-                else:
-                    if zsetmembers is not None:
-                        cmdmemlist = []
-                        for eachzsmem in zsetmembers:
-                            zsetmem_name = eachzsmem['name']
-                            zsetmem_removeflag = eachzsmem['remove']
-                            if zsetmem_removeflag:
-                                if shZonesetObj.isZonePresentInZoneset(zsetname, zsetmem_name):
-                                    cmd = "no member " + zsetmem_name
-                                    cmdmemlist.append(cmd)
-                                    messages.append("removing zoneset member '" + zsetmem_name + "' from zoneset '" + zsetname + "' in vsan " + str(vsan))
-                                else:
-                                    messages.append("zoneset member '" + zsetmem_name + "' is not present in zoneset '" +
-                                                    zsetname + "' in vsan " + str(vsan) + " ,hence there is nothing to remove")
-                            else:
-                                if shZonesetObj.isZonePresentInZoneset(zsetname, zsetmem_name):
-                                    messages.append("zoneset member '" + zsetmem_name + "' is already present in zoneset '" +
-                                                    zsetname + "' in vsan " + str(vsan) + " ,hence there is nothing to add")
-                                else:
-                                    cmd = "member " + zsetmem_name
-                                    cmdmemlist.append(cmd)
-                                    messages.append("adding zoneset member '" + zsetmem_name + "' to zoneset '" + zsetname + "' in vsan " + str(vsan))
-                        if len(cmdmemlist) != 0:
-                            commands_executed.append("zoneset name " + zsetname + " vsan " + str(vsan))
-                            commands_executed = commands_executed + cmdmemlist
-                    else:
-                        if shZonesetObj.isZonesetPresent(zsetname):
-                            messages.append("zoneset '" + zsetname + "' is already present in vsan " + str(vsan))
-                        else:
-                            commands_executed.append("zoneset name " + zsetname + " vsan " + str(vsan))
-                            messages.append("zoneset '" + zsetname + "' is created in vsan " + str(vsan))
-
-                # Process zoneset activate options
-                if actionflag == 'deactivate':
-                    if shZonesetActiveObj.isZonesetActive(zsetname):
-                        messages.append("deactivating zoneset '" + zsetname + "' in vsan " + str(vsan))
-                        dactcmd.append("no zoneset activate name " + zsetname + " vsan " + str(vsan))
-                    else:
-                        messages.append("zoneset '" + zsetname + "' in vsan " + str(vsan) + " is not activated, hence cannot deactivate")
-                elif actionflag == 'activate':
-                    if shZonesetActiveObj.isZonesetActive(zsetname):
-                        messages.append("zoneset '" + zsetname + "' in vsan " + str(vsan) + " is already activated")
-                    else:
-                        messages.append("activating zoneset '" + zsetname + "' in vsan " + str(vsan))
-                        actcmd.append("zoneset activate name " + zsetname + " vsan " + str(vsan))
-            commands_executed = commands_executed + dactcmd + actcmd
-
-        if commands_executed:
-            if op_mode == "enhanced":
-                commands_executed.append("zone commit vsan " + str(vsan))
-            elif op_mode is None:
-                if sw_mode == "enhanced":
-                    commands_executed.append("zone commit vsan " + str(vsan))
-
-    if commands_executed:
-        commands_executed = ["terminal dont-ask"] + commands_executed + ["no terminal dont-ask"]
-
-    cmds = flatten_list(commands_executed)
-    if cmds:
-        if module.check_mode:
-            module.exit_json(changed=False, commands=cmds, msg="Check Mode: No cmds issued to the hosts")
-        else:
-            result['changed'] = True
-            commands = commands + cmds
-            load_config(module, cmds)
-
-    result['messages'] = messages
-    result['commands'] = commands_executed
-    result['warnings'] = warnings
-    module.exit_json(**result)
-
-
-if __name__ == '__main__':
-    main()
diff --git a/lib/ansible/plugins/action/nxos.py b/lib/ansible/plugins/action/nxos.py
deleted file mode 100644
index 6a6db0bf83..0000000000
--- a/lib/ansible/plugins/action/nxos.py
+++ /dev/null
@@ -1,179 +0,0 @@
-#
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-import copy
-import re
-import sys
-
-from ansible import constants as C
-from ansible.plugins.action.network import ActionModule as ActionNetworkModule
-from ansible.module_utils.connection import Connection
-from ansible.module_utils.network.common.utils import load_provider
-from ansible.module_utils.network.nxos.nxos import nxos_provider_spec
-from ansible.utils.display import Display
-
-display = Display()
-
-
-class ActionModule(ActionNetworkModule):
-
-    def run(self, tmp=None, task_vars=None):
-        del tmp  # tmp no longer has any effect
-
-        module_name = self._task.action.split('.')[-1]
-        self._config_module = True if module_name == 'nxos_config' else False
-        persistent_connection = self._play_context.connection.split('.')[-1]
-        warnings = []
-
-        if (self._play_context.connection in ('httpapi', 'local') or self._task.args.get('provider', {}).get('transport') == 'nxapi') \
-                and module_name in ('nxos_file_copy', 'nxos_nxapi'):
-            return {'failed': True, 'msg': "Transport type 'nxapi' is not valid for '%s' module." % (module_name)}
-
-        if module_name == 'nxos_file_copy':
-            self._task.args['host'] = self._play_context.remote_addr
-            self._task.args['password'] = self._play_context.password
-            if self._play_context.connection == 'network_cli':
-                self._task.args['username'] = self._play_context.remote_user
-            elif self._play_context.connection == 'local':
-                self._task.args['username'] = self._play_context.connection_user
-
-        if module_name == 'nxos_install_os':
-            connection = self._connection
-            if connection.transport == 'local':
-                persistent_command_timeout = C.PERSISTENT_COMMAND_TIMEOUT
-                persistent_connect_timeout = C.PERSISTENT_CONNECT_TIMEOUT
-            else:
-                persistent_command_timeout = connection.get_option('persistent_command_timeout')
-                persistent_connect_timeout = connection.get_option('persistent_connect_timeout')
-
-            display.vvvv('PERSISTENT_COMMAND_TIMEOUT is %s' % str(persistent_command_timeout), self._play_context.remote_addr)
-            display.vvvv('PERSISTENT_CONNECT_TIMEOUT is %s' % str(persistent_connect_timeout), self._play_context.remote_addr)
-            if persistent_command_timeout < 600 or persistent_connect_timeout < 600:
-                msg = 'PERSISTENT_COMMAND_TIMEOUT and PERSISTENT_CONNECT_TIMEOUT'
-                msg += ' must be set to 600 seconds or higher when using nxos_install_os module.'
-                msg += ' Current persistent_command_timeout setting:' + str(persistent_command_timeout)
-                msg += ' Current persistent_connect_timeout setting:' + str(persistent_connect_timeout)
-                return {'failed': True, 'msg': msg}
-
-        if persistent_connection in ('network_cli', 'httpapi'):
-            provider = self._task.args.get('provider', {})
-            if any(provider.values()):
-                display.warning('provider is unnecessary when using %s and will be ignored' % self._play_context.connection)
-                del self._task.args['provider']
-            if self._task.args.get('transport'):
-                display.warning('transport is unnecessary when using %s and will be ignored' % self._play_context.connection)
-                del self._task.args['transport']
-
-            if module_name == 'nxos_gir':
-                conn = Connection(self._connection.socket_path)
-                persistent_command_timeout = conn.get_option('persistent_command_timeout')
-                gir_timeout = 200
-                if persistent_command_timeout < gir_timeout:
-                    conn.set_option('persistent_command_timeout', gir_timeout)
-                    msg = "timeout value extended to %ss for nxos_gir" % gir_timeout
-                    display.warning(msg)
-
-        elif self._play_context.connection == 'local':
-            provider = load_provider(nxos_provider_spec, self._task.args)
-            transport = provider['transport'] or 'cli'
-
-            display.vvvv('connection transport is %s' % transport, self._play_context.remote_addr)
-
-            if transport == 'cli':
-                pc = copy.deepcopy(self._play_context)
-                pc.connection = 'ansible.netcommon.network_cli'
-                pc.network_os = 'cisco.nxos.nxos'
-                pc.remote_addr = provider['host'] or self._play_context.remote_addr
-                pc.port = int(provider['port'] or self._play_context.port or 22)
-                pc.remote_user = provider['username'] or self._play_context.connection_user
-                pc.password = provider['password'] or self._play_context.password
-                pc.private_key_file = provider['ssh_keyfile'] or self._play_context.private_key_file
-                pc.become = provider['authorize'] or False
-                if pc.become:
-                    pc.become_method = 'enable'
-                pc.become_pass = provider['auth_pass']
-
-                connection = self._shared_loader_obj.connection_loader.get('ansible.netcommon.persistent', pc, sys.stdin,
-                                                                           task_uuid=self._task._uuid)
-
-                # TODO: Remove below code after ansible minimal is cut out
-                if connection is None:
-                    pc.connection = 'network_cli'
-                    pc.network_os = 'nxos'
-                    connection = self._shared_loader_obj.connection_loader.get('persistent', pc, sys.stdin, task_uuid=self._task._uuid)
-
-                display.vvv('using connection plugin %s (was local)' % pc.connection, pc.remote_addr)
-
-                command_timeout = int(provider['timeout']) if provider['timeout'] else connection.get_option('persistent_command_timeout')
-                connection.set_options(direct={'persistent_command_timeout': command_timeout})
-
-                socket_path = connection.run()
-                display.vvvv('socket_path: %s' % socket_path, pc.remote_addr)
-                if not socket_path:
-                    return {'failed': True,
-                            'msg': 'unable to open shell. Please see: ' +
-                                   'https://docs.ansible.com/ansible/network_debug_troubleshooting.html#unable-to-open-shell'}
-
-                task_vars['ansible_socket'] = socket_path
-
-            else:
-                self._task.args['provider'] = ActionModule.nxapi_implementation(provider, self._play_context)
-                warnings.append(['connection local support for this module is deprecated and will be removed in version 2.14,'
-                                 ' use connection either httpapi or ansible.netcommon.httpapi (whichever is applicable)'])
-        else:
-            return {'failed': True, 'msg': 'Connection type %s is not valid for this module' % self._play_context.connection}
-
-        result = super(ActionModule, self).run(task_vars=task_vars)
-        if warnings:
-            if 'warnings' in result:
-                result['warnings'].extend(warnings)
-            else:
-                result['warnings'] = warnings
-        return result
-
-    @staticmethod
-    def nxapi_implementation(provider, play_context):
-        provider['transport'] = 'nxapi'
-        if provider.get('host') is None:
-            provider['host'] = play_context.remote_addr
-
-        if provider.get('port') is None:
-            if provider.get('use_ssl'):
-                provider['port'] = 443
-            else:
-                provider['port'] = 80
-
-        if provider.get('timeout') is None:
-            provider['timeout'] = C.PERSISTENT_COMMAND_TIMEOUT
-
-        if provider.get('username') is None:
-            provider['username'] = play_context.connection_user
-
-        if provider.get('password') is None:
-            provider['password'] = play_context.password
-
-        if provider.get('use_ssl') is None:
-            provider['use_ssl'] = False
-
-        if provider.get('validate_certs') is None:
-            provider['validate_certs'] = True
-
-        return provider
diff --git a/lib/ansible/plugins/action/nxos_file_copy.py b/lib/ansible/plugins/action/nxos_file_copy.py
deleted file mode 100644
index 4b49df24a7..0000000000
--- a/lib/ansible/plugins/action/nxos_file_copy.py
+++ /dev/null
@@ -1,500 +0,0 @@
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-import copy
-import hashlib
-import os
-import re
-import time
-
-from ansible.errors import AnsibleError
-from ansible.module_utils._text import to_text, to_bytes, to_native
-from ansible.module_utils.common import validation
-from ansible.module_utils.connection import Connection
-from ansible.plugins.action import ActionBase
-from ansible.utils.display import Display
-from ansible.module_utils.compat.paramiko import paramiko
-from ansible.module_utils import six
-
-try:
-    from scp import SCPClient
-    HAS_SCP = True
-except ImportError:
-    HAS_SCP = False
-
-try:
-    import pexpect
-    HAS_PEXPECT = True
-except ImportError:
-    HAS_PEXPECT = False
-
-display = Display()
-
-
-class ActionModule(ActionBase):
-
-    def process_playbook_values(self):
-        ''' Get playbook values and perform input validation '''
-        argument_spec = dict(
-            vrf=dict(type='str', default='management'),
-            connect_ssh_port=dict(type='int', default=22),
-            file_system=dict(type='str', default='bootflash:'),
-            file_pull=dict(type='bool', default=False),
-            file_pull_timeout=dict(type='int', default=300),
-            file_pull_compact=dict(type='bool', default=False),
-            file_pull_kstack=dict(type='bool', default=False),
-            local_file=dict(type='path'),
-            local_file_directory=dict(type='path'),
-            remote_file=dict(type='path'),
-            remote_scp_server=dict(type='str'),
-            remote_scp_server_user=dict(type='str'),
-            remote_scp_server_password=dict(no_log=True),
-        )
-
-        playvals = {}
-        # Process key value pairs from playbook task
-        for key in argument_spec.keys():
-            playvals[key] = self._task.args.get(key, argument_spec[key].get('default'))
-            if playvals[key] is None:
-                continue
-
-            option_type = argument_spec[key].get('type', 'str')
-            try:
-                if option_type == 'str':
-                    playvals[key] = validation.check_type_str(playvals[key])
-                elif option_type == 'int':
-                    playvals[key] = validation.check_type_int(playvals[key])
-                elif option_type == 'bool':
-                    playvals[key] = validation.check_type_bool(playvals[key])
-                elif option_type == 'path':
-                    playvals[key] = validation.check_type_path(playvals[key])
-                else:
-                    raise AnsibleError('Unrecognized type <{0}> for playbook parameter <{1}>'.format(option_type, key))
-
-            except (TypeError, ValueError) as e:
-                raise AnsibleError("argument %s is of type %s and we were unable to convert to %s: %s"
-                                   % (key, type(playvals[key]), option_type, to_native(e)))
-
-        # Validate playbook dependencies
-        if playvals['file_pull']:
-            if playvals.get('remote_file') is None:
-                raise AnsibleError('Playbook parameter <remote_file> required when <file_pull> is True')
-            if playvals.get('remote_scp_server') is None:
-                raise AnsibleError('Playbook parameter <remote_scp_server> required when <file_pull> is True')
-
-        if playvals['remote_scp_server'] or \
-           playvals['remote_scp_server_user']:
-
-            if None in (playvals['remote_scp_server'],
-                        playvals['remote_scp_server_user']):
-                params = '<remote_scp_server>, <remote_scp_server_user>'
-                raise AnsibleError('Playbook parameters {0} must be set together'.format(params))
-
-        return playvals
-
-    def check_library_dependencies(self, file_pull):
-        if file_pull:
-            if not HAS_PEXPECT:
-                msg = 'library pexpect is required when file_pull is True but does not appear to be '
-                msg += 'installed. It can be installed using `pip install pexpect`'
-                raise AnsibleError(msg)
-        else:
-            if paramiko is None:
-                msg = 'library paramiko is required when file_pull is False but does not appear to be '
-                msg += 'installed. It can be installed using `pip install paramiko`'
-                raise AnsibleError(msg)
-
-            if not HAS_SCP:
-                msg = 'library scp is required when file_pull is False but does not appear to be '
-                msg += 'installed. It can be installed using `pip install scp`'
-                raise AnsibleError(msg)
-
-    def md5sum_check(self, dst, file_system):
-        command = 'show file {0}{1} md5sum'.format(file_system, dst)
-        remote_filehash = self.conn.exec_command(command)
-        remote_filehash = to_bytes(remote_filehash, errors='surrogate_or_strict')
-
-        local_file = self.playvals['local_file']
-        try:
-            with open(local_file, 'rb') as f:
-                filecontent = f.read()
-        except (OSError, IOError) as exc:
-            raise AnsibleError('Error reading the file: {0}'.format(to_text(exc)))
-
-        filecontent = to_bytes(filecontent, errors='surrogate_or_strict')
-        local_filehash = hashlib.md5(filecontent).hexdigest()
-
-        if local_filehash == remote_filehash:
-            return True
-        else:
-            return False
-
-    def remote_file_exists(self, remote_file, file_system):
-        command = 'dir {0}/{1}'.format(file_system, remote_file)
-        body = self.conn.exec_command(command)
-        if 'No such file' in body:
-            return False
-        else:
-            return self.md5sum_check(remote_file, file_system)
-
-    def verify_remote_file_exists(self, dst, file_system):
-        command = 'dir {0}/{1}'.format(file_system, dst)
-        body = self.conn.exec_command(command)
-        if 'No such file' in body:
-            return 0
-        return body.split()[0].strip()
-
-    def local_file_exists(self, file):
-        return os.path.isfile(file)
-
-    def get_flash_size(self, file_system):
-        command = 'dir {0}'.format(file_system)
-        body = self.conn.exec_command(command)
-
-        match = re.search(r'(\d+) bytes free', body)
-        if match:
-            bytes_free = match.group(1)
-            return int(bytes_free)
-
-        match = re.search(r'No such file or directory', body)
-        if match:
-            raise AnsibleError('Invalid nxos filesystem {0}'.format(file_system))
-        else:
-            raise AnsibleError('Unable to determine size of filesystem {0}'.format(file_system))
-
-    def enough_space(self, file, file_system):
-        flash_size = self.get_flash_size(file_system)
-        file_size = os.path.getsize(file)
-        if file_size > flash_size:
-            return False
-
-        return True
-
-    def transfer_file_to_device(self, remote_file):
-        timeout = self.socket_timeout
-        local_file = self.playvals['local_file']
-        file_system = self.playvals['file_system']
-
-        if not self.enough_space(local_file, file_system):
-            raise AnsibleError('Could not transfer file. Not enough space on device.')
-
-        # frp = full_remote_path, flp = full_local_path
-        frp = '{0}{1}'.format(file_system, remote_file)
-        flp = os.path.join(os.path.abspath(local_file))
-        try:
-            self.conn.copy_file(source=flp, destination=frp, proto='scp', timeout=timeout)
-        except Exception as exc:
-            self.results['failed'] = True
-            self.results['msg'] = ('Exception received : %s' % exc)
-
-    def file_push(self):
-        local_file = self.playvals['local_file']
-        remote_file = self.playvals['remote_file'] or os.path.basename(local_file)
-        file_system = self.playvals['file_system']
-
-        if not self.local_file_exists(local_file):
-            raise AnsibleError('Local file {0} not found'.format(local_file))
-
-        remote_file = remote_file or os.path.basename(local_file)
-        remote_exists = self.remote_file_exists(remote_file, file_system)
-
-        if not remote_exists:
-            self.results['changed'] = True
-            file_exists = False
-        else:
-            self.results['transfer_status'] = 'No Transfer: File already copied to remote device.'
-            file_exists = True
-
-        if not self.play_context.check_mode and not file_exists:
-            self.transfer_file_to_device(remote_file)
-            self.results['transfer_status'] = 'Sent: File copied to remote device.'
-
-        self.results['local_file'] = local_file
-        if remote_file is None:
-            remote_file = os.path.basename(local_file)
-        self.results['remote_file'] = remote_file
-
-    def copy_file_from_remote(self, local, local_file_directory, file_system):
-        self.results['failed'] = False
-        nxos_hostname = self.play_context.remote_addr
-        nxos_username = self.play_context.remote_user
-        nxos_password = self.play_context.password
-        port = self.playvals['connect_ssh_port']
-
-        # Build copy command components that will be used to initiate copy from the nxos device.
-        cmdroot = 'copy scp://'
-        ruser = self.playvals['remote_scp_server_user'] + '@'
-        rserver = self.playvals['remote_scp_server']
-        rfile = self.playvals['remote_file'] + ' '
-        vrf = ' vrf ' + self.playvals['vrf']
-        local_dir_root = '/'
-        if self.playvals['file_pull_compact']:
-            compact = ' compact '
-        else:
-            compact = ''
-        if self.playvals['file_pull_kstack']:
-            kstack = ' use-kstack '
-        else:
-            kstack = ''
-
-        def process_outcomes(session, timeout=None):
-            if timeout is None:
-                timeout = 10
-            outcome = {}
-            outcome['user_response_required'] = False
-            outcome['password_prompt_detected'] = False
-            outcome['existing_file_with_same_name'] = False
-            outcome['final_prompt_detected'] = False
-            outcome['copy_complete'] = False
-            outcome['expect_timeout'] = False
-            outcome['error'] = False
-            outcome['error_data'] = None
-
-            # Possible outcomes key:
-            # 0) - Are you sure you want to continue connecting (yes/no)
-            # 1) - Password: or @servers's password:
-            # 2) - Warning: There is already a file existing with this name. Do you want to overwrite (y/n)?[n]
-            # 3) - Timeout conditions
-            # 4) - No space on nxos device file_system
-            # 5) - Username/Password or file permission issues
-            # 6) - File does not exist on remote scp server
-            # 7) - invalid nxos command
-            # 8) - compact option not supported
-            # 9) - compaction attempt failed
-            # 10) - other failures like attempting to compact non image file
-            # 11) - failure to resolve hostname
-            # 12) - Too many authentication failures
-            # 13) - Copy to / from this server not permitted
-            # 14) - Copy completed without issues
-            # 15) - nxos_router_prompt#
-            # 16) - pexpect timeout
-            possible_outcomes = [r'sure you want to continue connecting \(yes/no\)\? ',
-                                 '(?i)Password: ',
-                                 'file existing with this name',
-                                 'timed out',
-                                 '(?i)No space.*#',
-                                 '(?i)Permission denied.*#',
-                                 '(?i)No such file.*#',
-                                 '.*Invalid command.*#',
-                                 'Compaction is not supported on this platform.*#',
-                                 'Compact of.*failed.*#',
-                                 '(?i)Failed.*#',
-                                 '(?i)Could not resolve hostname',
-                                 '(?i)Too many authentication failures',
-                                 r'(?i)Copying to\/from this server name is not permitted',
-                                 '(?i)Copy complete',
-                                 r'#\s',
-                                 pexpect.TIMEOUT]
-            index = session.expect(possible_outcomes, timeout=timeout)
-            # Each index maps to items in possible_outcomes
-            if index == 0:
-                outcome['user_response_required'] = True
-                return outcome
-            elif index == 1:
-                outcome['password_prompt_detected'] = True
-                return outcome
-            elif index == 2:
-                outcome['existing_file_with_same_name'] = True
-                return outcome
-            elif index in [3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]:
-                before = session.before.strip().replace(' \x08', '')
-                after = session.after.strip().replace(' \x08', '')
-                outcome['error'] = True
-                outcome['error_data'] = 'COMMAND {0} ERROR {1}'.format(before, after)
-                return outcome
-            elif index == 14:
-                outcome['copy_complete'] = True
-                return outcome
-            elif index == 15:
-                outcome['final_prompt_detected'] = True
-                return outcome
-            elif index == 16:
-                # The before property will contain all text up to the expected string pattern.
-                # The after string will contain the text that was matched by the expected pattern.
-                outcome['expect_timeout'] = True
-                outcome['error_data'] = 'Expect Timeout error occurred: BEFORE {0} AFTER {1}'.format(session.before, session.after)
-                return outcome
-            else:
-                outcome['error'] = True
-                outcome['error_data'] = 'Unrecognized error occurred: BEFORE {0} AFTER {1}'.format(session.before, session.after)
-                return outcome
-
-            return outcome
-
-        # Spawn pexpect connection to NX-OS device.
-        nxos_session = pexpect.spawn('ssh ' + nxos_username + '@' + nxos_hostname + ' -p' + str(port))
-        # There might be multiple user_response_required prompts or intermittent timeouts
-        # spawning the expect session so loop up to 24 times during the spawn process.
-        max_attempts = 24
-        for connect_attempt in range(max_attempts):
-            outcome = process_outcomes(nxos_session)
-            if outcome['user_response_required']:
-                nxos_session.sendline('yes')
-                continue
-            if outcome['password_prompt_detected']:
-                time.sleep(3)
-                nxos_session.sendline(nxos_password)
-                continue
-            if outcome['final_prompt_detected']:
-                break
-            if outcome['error'] or outcome['expect_timeout']:
-                # Error encountered, try to spawn expect session n more times up to max_attempts - 1
-                if connect_attempt < max_attempts:
-                    outcome['error'] = False
-                    outcome['expect_timeout'] = False
-                    nxos_session.close()
-                    nxos_session = pexpect.spawn('ssh ' + nxos_username + '@' + nxos_hostname + ' -p' + str(port))
-                    continue
-                self.results['failed'] = True
-                outcome['error_data'] = re.sub(nxos_password, '', outcome['error_data'])
-                self.results['error_data'] = 'Failed to spawn expect session! ' + outcome['error_data']
-                nxos_session.close()
-                return
-        else:
-            # The before property will contain all text up to the expected string pattern.
-            # The after string will contain the text that was matched by the expected pattern.
-            msg = 'After {0} attempts, failed to spawn pexpect session to {1}'
-            msg += 'BEFORE: {2}, AFTER: {3}'
-            error_msg = msg.format(connect_attempt, nxos_hostname, nxos_session.before, nxos_session.after)
-            re.sub(nxos_password, '', error_msg)
-            nxos_session.close()
-            raise AnsibleError(error_msg)
-
-        # Create local file directory under NX-OS filesystem if
-        # local_file_directory playbook parameter is set.
-        if local_file_directory:
-            dir_array = local_file_directory.split('/')
-            for each in dir_array:
-                if each:
-                    mkdir_cmd = 'mkdir ' + local_dir_root + each
-                    nxos_session.sendline(mkdir_cmd)
-                    outcome = process_outcomes(nxos_session)
-                    if outcome['error'] or outcome['expect_timeout']:
-                        self.results['mkdir_cmd'] = mkdir_cmd
-                        self.results['failed'] = True
-                        outcome['error_data'] = re.sub(nxos_password, '', outcome['error_data'])
-                        self.results['error_data'] = outcome['error_data']
-                        return
-                    local_dir_root += each + '/'
-
-        # Initiate file copy
-        copy_cmd = (cmdroot + ruser + rserver + rfile + file_system + local_dir_root + local + compact + vrf + kstack)
-        self.results['copy_cmd'] = copy_cmd
-        nxos_session.sendline(copy_cmd)
-        for copy_attempt in range(6):
-            outcome = process_outcomes(nxos_session, self.playvals['file_pull_timeout'])
-            if outcome['user_response_required']:
-                nxos_session.sendline('yes')
-                continue
-            if outcome['password_prompt_detected']:
-                if self.playvals.get('remote_scp_server_password'):
-                    nxos_session.sendline(self.playvals['remote_scp_server_password'])
-                else:
-                    err_msg = 'Remote scp server {0} requires a password.'.format(rserver)
-                    err_msg += ' Set the <remote_scp_server_password> playbook parameter or configure nxos device for passwordless scp'
-                    raise AnsibleError(err_msg)
-                continue
-            if outcome['existing_file_with_same_name']:
-                nxos_session.sendline('y')
-                continue
-            if outcome['copy_complete']:
-                self.results['transfer_status'] = 'Received: File copied/pulled to nxos device from remote scp server.'
-                break
-            if outcome['error'] or outcome['expect_timeout']:
-                self.results['failed'] = True
-                outcome['error_data'] = re.sub(nxos_password, '', outcome['error_data'])
-                if self.playvals.get('remote_scp_server_password'):
-                    outcome['error_data'] = re.sub(self.playvals['remote_scp_server_password'], '', outcome['error_data'])
-                self.results['error_data'] = outcome['error_data']
-                nxos_session.close()
-                return
-        else:
-            # The before property will contain all text up to the expected string pattern.
-            # The after string will contain the text that was matched by the expected pattern.
-            msg = 'After {0} attempts, failed to copy file to {1}'
-            msg += 'BEFORE: {2}, AFTER: {3}, CMD: {4}'
-            error_msg = msg.format(copy_attempt, nxos_hostname, nxos_session.before, nxos_session.before, copy_cmd)
-            re.sub(nxos_password, '', error_msg)
-            if self.playvals.get('remote_scp_server_password'):
-                re.sub(self.playvals['remote_scp_server_password'], '', error_msg)
-            nxos_session.close()
-            raise AnsibleError(error_msg)
-
-        nxos_session.close()
-
-    def file_pull(self):
-        local_file = self.playvals['local_file']
-        remote_file = self.playvals['remote_file']
-        file_system = self.playvals['file_system']
-        # Note: This is the local file directory on the remote nxos device.
-        local_file_dir = self.playvals['local_file_directory']
-
-        local_file = local_file or self.playvals['remote_file'].split('/')[-1]
-
-        if not self.play_context.check_mode:
-            self.copy_file_from_remote(local_file, local_file_dir, file_system)
-
-        if not self.results['failed']:
-            self.results['changed'] = True
-            self.results['remote_file'] = remote_file
-            if local_file_dir:
-                dir = local_file_dir
-            else:
-                dir = ''
-            self.results['local_file'] = file_system + dir + '/' + local_file
-            self.results['remote_scp_server'] = self.playvals['remote_scp_server']
-
-    # This is the main run method for the action plugin to copy files
-    def run(self, tmp=None, task_vars=None):
-        socket_path = None
-        self.play_context = copy.deepcopy(self._play_context)
-        self.results = super(ActionModule, self).run(task_vars=task_vars)
-
-        if self.play_context.connection.split('.')[-1] != 'network_cli':
-            # Plugin is supported only with network_cli
-            self.results['failed'] = True
-            self.results['msg'] = 'Connection type must be fully qualified name for network_cli connection type, got %s' % self.play_context.connection
-            return self.results
-
-        # Get playbook values
-        self.playvals = self.process_playbook_values()
-
-        file_pull = self.playvals['file_pull']
-        self.check_library_dependencies(file_pull)
-
-        if socket_path is None:
-            socket_path = self._connection.socket_path
-        self.conn = Connection(socket_path)
-
-        # Call get_capabilities() to start the connection to the device.
-        self.conn.get_capabilities()
-
-        self.socket_timeout = self.conn.get_option('persistent_command_timeout')
-
-        # This action plugin support two modes of operation.
-        # - file_pull is False - Push files from the ansible controller to nxos switch.
-        # - file_pull is True - Initiate copy from the device to pull files to the nxos switch.
-        self.results['transfer_status'] = 'No Transfer'
-        self.results['file_system'] = self.playvals['file_system']
-        if file_pull:
-            self.file_pull()
-        else:
-            self.file_push()
-
-        return self.results
diff --git a/lib/ansible/plugins/cliconf/nxos.py b/lib/ansible/plugins/cliconf/nxos.py
deleted file mode 100644
index 207b824f8d..0000000000
--- a/lib/ansible/plugins/cliconf/nxos.py
+++ /dev/null
@@ -1,290 +0,0 @@
-#
-# (c) 2017 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-DOCUMENTATION = """
----
-author: Ansible Networking Team
-cliconf: nxos
-short_description: Use nxos cliconf to run command on Cisco NX-OS platform
-description:
-  - This nxos plugin provides low level abstraction apis for
-    sending and receiving CLI commands from Cicso NX-OS network devices.
-version_added: "2.4"
-"""
-
-import json
-import re
-
-from ansible.errors import AnsibleConnectionFailure
-from ansible.module_utils._text import to_bytes, to_text
-from ansible.module_utils.common._collections_compat import Mapping
-from ansible.module_utils.connection import ConnectionError
-from ansible.module_utils.network.common.config import NetworkConfig, dumps
-from ansible.module_utils.network.common.utils import to_list
-from ansible.plugins.cliconf import CliconfBase, enable_mode
-
-
-class Cliconf(CliconfBase):
-
-    def __init__(self, *args, **kwargs):
-        self._module_context = {}
-        super(Cliconf, self).__init__(*args, **kwargs)
-
-    def read_module_context(self, module_key):
-        if self._module_context.get(module_key):
-            return self._module_context[module_key]
-
-        return None
-
-    def save_module_context(self, module_key, module_context):
-        self._module_context[module_key] = module_context
-
-        return None
-
-    def get_device_info(self):
-        device_info = {}
-
-        device_info['network_os'] = 'nxos'
-        reply = self.get('show version')
-        platform_reply = self.get('show inventory')
-
-        match_sys_ver = re.search(r'\s+system:\s+version\s*(\S+)', reply, re.M)
-        if match_sys_ver:
-            device_info['network_os_version'] = match_sys_ver.group(1)
-        else:
-            match_kick_ver = re.search(r'\s+kickstart:\s+version\s*(\S+)', reply, re.M)
-            if match_kick_ver:
-                device_info['network_os_version'] = match_kick_ver.group(1)
-
-        if 'network_os_version' not in device_info:
-            match_sys_ver = re.search(r'\s+NXOS:\s+version\s*(\S+)', reply, re.M)
-            if match_sys_ver:
-                device_info['network_os_version'] = match_sys_ver.group(1)
-
-        match_chassis_id = re.search(r'Hardware\n\s+cisco(.+)$', reply, re.M)
-        if match_chassis_id:
-            device_info['network_os_model'] = match_chassis_id.group(1).strip()
-
-        match_host_name = re.search(r'\s+Device name:\s*(\S+)', reply, re.M)
-        if match_host_name:
-            device_info['network_os_hostname'] = match_host_name.group(1)
-
-        match_isan_file_name = re.search(r'\s+system image file is:\s*(\S+)', reply, re.M)
-        if match_isan_file_name:
-            device_info['network_os_image'] = match_isan_file_name.group(1)
-        else:
-            match_kick_file_name = re.search(r'\s+kickstart image file is:\s*(\S+)', reply, re.M)
-            if match_kick_file_name:
-                device_info['network_os_image'] = match_kick_file_name.group(1)
-
-        if 'network_os_image' not in device_info:
-            match_isan_file_name = re.search(r'\s+NXOS image file is:\s*(\S+)', reply, re.M)
-            if match_isan_file_name:
-                device_info['network_os_image'] = match_isan_file_name.group(1)
-
-        match_os_platform = re.search(r'NAME: "Chassis",\s*DESCR:.*\n'
-                                      r'PID:\s*(\S+)', platform_reply, re.M)
-        if match_os_platform:
-            device_info['network_os_platform'] = match_os_platform.group(1)
-
-        return device_info
-
-    def get_diff(self, candidate=None, running=None, diff_match='line', diff_ignore_lines=None, path=None, diff_replace='line'):
-        diff = {}
-        device_operations = self.get_device_operations()
-        option_values = self.get_option_values()
-
-        if candidate is None and device_operations['supports_generate_diff']:
-            raise ValueError("candidate configuration is required to generate diff")
-
-        if diff_match not in option_values['diff_match']:
-            raise ValueError("'match' value %s in invalid, valid values are %s" % (diff_match, ', '.join(option_values['diff_match'])))
-
-        if diff_replace not in option_values['diff_replace']:
-            raise ValueError("'replace' value %s in invalid, valid values are %s" % (diff_replace, ', '.join(option_values['diff_replace'])))
-
-        # prepare candidate configuration
-        candidate_obj = NetworkConfig(indent=2)
-        candidate_obj.load(candidate)
-
-        if running and diff_match != 'none' and diff_replace != 'config':
-            # running configuration
-            running_obj = NetworkConfig(indent=2, contents=running, ignore_lines=diff_ignore_lines)
-            configdiffobjs = candidate_obj.difference(running_obj, path=path, match=diff_match, replace=diff_replace)
-
-        else:
-            configdiffobjs = candidate_obj.items
-
-        diff['config_diff'] = dumps(configdiffobjs, 'commands') if configdiffobjs else ''
-        return diff
-
-    def get_config(self, source='running', format='text', flags=None):
-        options_values = self.get_option_values()
-        if format not in options_values['format']:
-            raise ValueError("'format' value %s is invalid. Valid values are %s" % (format, ','.join(options_values['format'])))
-
-        lookup = {'running': 'running-config', 'startup': 'startup-config'}
-        if source not in lookup:
-            raise ValueError("fetching configuration from %s is not supported" % source)
-
-        cmd = 'show {0} '.format(lookup[source])
-        if format and format != 'text':
-            cmd += '| %s ' % format
-
-        if flags:
-            cmd += ' '.join(to_list(flags))
-        cmd = cmd.strip()
-
-        return self.send_command(cmd)
-
-    def edit_config(self, candidate=None, commit=True, replace=None, comment=None):
-        resp = {}
-        operations = self.get_device_operations()
-        self.check_edit_config_capability(operations, candidate, commit, replace, comment)
-        results = []
-        requests = []
-
-        if replace:
-            device_info = self.get_device_info()
-            if '9K' not in device_info.get('network_os_platform', ''):
-                raise ConnectionError(message=u'replace is supported only on Nexus 9K devices')
-            candidate = 'config replace {0}'.format(replace)
-
-        if commit:
-            self.send_command('configure terminal')
-
-            for line in to_list(candidate):
-                if not isinstance(line, Mapping):
-                    line = {'command': line}
-
-                cmd = line['command']
-                if cmd != 'end':
-                    results.append(self.send_command(**line))
-                    requests.append(cmd)
-
-            self.send_command('end')
-        else:
-            raise ValueError('check mode is not supported')
-
-        resp['request'] = requests
-        resp['response'] = results
-        return resp
-
-    def get(self, command, prompt=None, answer=None, sendonly=False, output=None, newline=True, check_all=False):
-        if output:
-            command = self._get_command_with_output(command, output)
-        return self.send_command(command=command, prompt=prompt, answer=answer, sendonly=sendonly, newline=newline, check_all=check_all)
-
-    def run_commands(self, commands=None, check_rc=True):
-        if commands is None:
-            raise ValueError("'commands' value is required")
-
-        responses = list()
-        for cmd in to_list(commands):
-            if not isinstance(cmd, Mapping):
-                cmd = {'command': cmd}
-
-            output = cmd.pop('output', None)
-            if output:
-                cmd['command'] = self._get_command_with_output(cmd['command'], output)
-
-            try:
-                out = self.send_command(**cmd)
-            except AnsibleConnectionFailure as e:
-                if check_rc is True:
-                    raise
-                out = getattr(e, 'err', e)
-
-            if out is not None:
-                try:
-                    out = to_text(out, errors='surrogate_or_strict').strip()
-                except UnicodeError:
-                    raise ConnectionError(message=u'Failed to decode output from %s: %s' % (cmd, to_text(out)))
-
-                try:
-                    out = json.loads(out)
-                except ValueError:
-                    pass
-
-                responses.append(out)
-        return responses
-
-    def get_device_operations(self):
-        return {
-            'supports_diff_replace': True,
-            'supports_commit': False,
-            'supports_rollback': False,
-            'supports_defaults': True,
-            'supports_onbox_diff': False,
-            'supports_commit_comment': False,
-            'supports_multiline_delimiter': False,
-            'supports_diff_match': True,
-            'supports_diff_ignore_lines': True,
-            'supports_generate_diff': True,
-            'supports_replace': True
-        }
-
-    def get_option_values(self):
-        return {
-            'format': ['text', 'json'],
-            'diff_match': ['line', 'strict', 'exact', 'none'],
-            'diff_replace': ['line', 'block', 'config'],
-            'output': ['text', 'json']
-        }
-
-    def get_capabilities(self):
-        result = super(Cliconf, self).get_capabilities()
-        result['rpc'] += ['get_diff', 'run_commands']
-        result['device_operations'] = self.get_device_operations()
-        result.update(self.get_option_values())
-
-        return json.dumps(result)
-
-    def set_cli_prompt_context(self):
-        """
-        Make sure we are in the operational cli context
-        :return: None
-        """
-        if self._connection.connected:
-            out = self._connection.get_prompt()
-            if out is None:
-                raise AnsibleConnectionFailure(message=u'cli prompt is not identified from the last received'
-                                                       u' response window: %s' % self._connection._last_recv_window)
-            # Match prompts ending in )# except those with (maint-mode)#
-            config_prompt = re.compile(r'^.*\((?!maint-mode).*\)#$')
-
-            while config_prompt.match(to_text(out, errors='surrogate_then_replace').strip()):
-                self._connection.queue_message('vvvv', 'wrong context, sending exit to device')
-                self._connection.send_command('exit')
-                out = self._connection.get_prompt()
-
-    def _get_command_with_output(self, command, output):
-        options_values = self.get_option_values()
-        if output not in options_values['output']:
-            raise ValueError("'output' value %s is invalid. Valid values are %s" % (output, ','.join(options_values['output'])))
-
-        if output == 'json' and not command.endswith('| json'):
-            cmd = '%s | json' % command
-        elif output == 'text' and command.endswith('| json'):
-            cmd = command.rsplit('|', 1)[0]
-        else:
-            cmd = command
-        return cmd
diff --git a/lib/ansible/plugins/doc_fragments/nxos.py b/lib/ansible/plugins/doc_fragments/nxos.py
deleted file mode 100644
index c6b747d718..0000000000
--- a/lib/ansible/plugins/doc_fragments/nxos.py
+++ /dev/null
@@ -1,119 +0,0 @@
-# -*- coding: utf-8 -*-
-
-# Copyright: (c) 2015, Peter Sprygada <psprygada@ansible.com>
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-
-class ModuleDocFragment(object):
-
-    # Standard files documentation fragment
-    DOCUMENTATION = r'''
-options:
-  provider:
-    description:
-      - B(Deprecated)
-      - "Starting with Ansible 2.5 we recommend using C(connection: network_cli)."
-      - This option is only required if you are using NX-API.
-      - For more information please see the L(NXOS Platform Options guide, ../network/user_guide/platform_nxos.html).
-      - HORIZONTALLINE
-      - A dict object containing connection details.
-    type: dict
-    suboptions:
-      host:
-        description:
-          - Specifies the DNS host name or address for connecting to the remote
-            device over the specified transport.  The value of host is used as
-            the destination address for the transport.
-        type: str
-        required: true
-      port:
-        description:
-          - Specifies the port to use when building the connection to the remote
-            device.  This value applies to either I(cli) or I(nxapi).  The port
-            value will default to the appropriate transport common port if
-            none is provided in the task.  (cli=22, http=80, https=443).
-        type: int
-        default: 0 (use common port)
-      username:
-        description:
-          - Configures the username to use to authenticate the connection to
-            the remote device.  This value is used to authenticate
-            either the CLI login or the nxapi authentication depending on which
-            transport is used. If the value is not specified in the task, the
-            value of environment variable C(ANSIBLE_NET_USERNAME) will be used instead.
-        type: str
-      password:
-        description:
-          - Specifies the password to use to authenticate the connection to
-            the remote device.  This is a common argument used for either I(cli)
-            or I(nxapi) transports. If the value is not specified in the task, the
-            value of environment variable C(ANSIBLE_NET_PASSWORD) will be used instead.
-        type: str
-      authorize:
-        description:
-          - Instructs the module to enter privileged mode on the remote device
-            before sending any commands.  If not specified, the device will
-            attempt to execute all commands in non-privileged mode. If the value
-            is not specified in the task, the value of environment variable
-            C(ANSIBLE_NET_AUTHORIZE) will be used instead.
-        type: bool
-        default: no
-        version_added: '2.5.3'
-      auth_pass:
-        description:
-          - Specifies the password to use if required to enter privileged mode
-            on the remote device.  If I(authorize) is false, then this argument
-            does nothing. If the value is not specified in the task, the value of
-            environment variable C(ANSIBLE_NET_AUTH_PASS) will be used instead.
-        type: str
-        version_added: '2.5.3'
-      timeout:
-        description:
-          - Specifies the timeout in seconds for communicating with the network device
-            for either connecting or sending commands.  If the timeout is
-            exceeded before the operation is completed, the module will error.
-            NX-API can be slow to return on long-running commands (sh mac, sh bgp, etc).
-        type: int
-        default: 10
-        version_added: '2.3'
-      ssh_keyfile:
-        description:
-          - Specifies the SSH key to use to authenticate the connection to
-            the remote device.  This argument is only used for the I(cli)
-            transport. If the value is not specified in the task, the
-            value of environment variable C(ANSIBLE_NET_SSH_KEYFILE) will be used instead.
-        type: str
-      transport:
-        description:
-          - Configures the transport connection to use when connecting to the
-            remote device.  The transport argument supports connectivity to the
-            device over cli (ssh) or nxapi.
-        type: str
-        required: true
-        choices: [ cli, nxapi ]
-        default: cli
-      use_ssl:
-        description:
-          - Configures the I(transport) to use SSL if set to C(yes) only when the
-            C(transport=nxapi), otherwise this value is ignored.
-        type: bool
-        default: no
-      validate_certs:
-        description:
-          - If C(no), SSL certificates will not be validated. This should only be used
-            on personally controlled sites using self-signed certificates.  If the transport
-            argument is not nxapi, this value is ignored.
-        type: bool
-        default: yes
-      use_proxy:
-        description:
-          - If C(no), the environment variables C(http_proxy) and C(https_proxy) will be ignored.
-        type: bool
-        default: yes
-        version_added: "2.5"
-
-notes:
-  - For information on using CLI and NX-API see the :ref:`NXOS Platform Options guide <nxos_platform_options>`
-  - For more information on using Ansible to manage network devices see the :ref:`Ansible Network Guide <network_guide>`
-  - For more information on using Ansible to manage Cisco devices see the `Cisco integration page <https://www.ansible.com/integrations/networks/cisco>`_.
-'''
diff --git a/lib/ansible/plugins/httpapi/nxos.py b/lib/ansible/plugins/httpapi/nxos.py
deleted file mode 100644
index 949c34eec8..0000000000
--- a/lib/ansible/plugins/httpapi/nxos.py
+++ /dev/null
@@ -1,232 +0,0 @@
-# (c) 2018 Red Hat Inc.
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-DOCUMENTATION = """
----
-author: Ansible Networking Team
-httpapi: nxos
-short_description: Use NX-API to run command on nxos platform
-description:
-  - This eos plugin provides low level abstraction api's for
-    sending and receiving CLI commands with nxos network devices.
-version_added: "2.6"
-"""
-
-import json
-import re
-import collections
-
-from ansible.module_utils._text import to_text
-from ansible.module_utils.connection import ConnectionError
-from ansible.module_utils.network.common.utils import to_list
-from ansible.plugins.httpapi import HttpApiBase
-
-
-OPTIONS = {
-    'format': ['text', 'json'],
-    'diff_match': ['line', 'strict', 'exact', 'none'],
-    'diff_replace': ['line', 'block', 'config'],
-    'output': ['text', 'json']
-}
-
-
-class HttpApi(HttpApiBase):
-    def __init__(self, *args, **kwargs):
-        super(HttpApi, self).__init__(*args, **kwargs)
-        self._device_info = None
-        self._module_context = {}
-
-    def read_module_context(self, module_key):
-        if self._module_context.get(module_key):
-            return self._module_context[module_key]
-
-        return None
-
-    def save_module_context(self, module_key, module_context):
-        self._module_context[module_key] = module_context
-
-        return None
-
-    def send_request(self, data, **message_kwargs):
-        output = None
-        queue = list()
-        responses = list()
-
-        for item in to_list(data):
-            cmd_output = message_kwargs.get('output', 'text')
-            if isinstance(item, dict):
-                command = item['command']
-                if 'output' in item:
-                    cmd_output = item['output']
-            else:
-                command = item
-
-            # Emulate '| json' from CLI
-            if command.endswith('| json'):
-                command = command.rsplit('|', 1)[0]
-                cmd_output = 'json'
-
-            if output and output != cmd_output:
-                responses.extend(self._run_queue(queue, output))
-                queue = list()
-
-            output = cmd_output
-            queue.append(command)
-
-        if queue:
-            responses.extend(self._run_queue(queue, output))
-
-        if len(responses) == 1:
-            return responses[0]
-        return responses
-
-    def _run_queue(self, queue, output):
-        if self._become:
-            self.connection.queue_message('vvvv', 'firing event: on_become')
-            queue.insert(0, 'enable')
-
-        request = request_builder(queue, output)
-        headers = {'Content-Type': 'application/json'}
-
-        response, response_data = self.connection.send('/ins', request, headers=headers, method='POST')
-
-        try:
-            response_data = json.loads(to_text(response_data.getvalue()))
-        except ValueError:
-            raise ConnectionError('Response was not valid JSON, got {0}'.format(
-                to_text(response_data.getvalue())
-            ))
-
-        results = handle_response(response_data)
-
-        if self._become:
-            results = results[1:]
-        return results
-
-    def get_device_info(self):
-        if self._device_info:
-            return self._device_info
-
-        device_info = {}
-
-        device_info['network_os'] = 'nxos'
-        reply = self.send_request('show version')
-        platform_reply = self.send_request('show inventory')
-
-        find_os_version = [r'\s+system:\s+version\s*(\S+)', r'\s+kickstart:\s+version\s*(\S+)', r'\s+NXOS:\s+version\s*(\S+)']
-        for regex in find_os_version:
-            match_ver = re.search(regex, reply, re.M)
-            if match_ver:
-                device_info['network_os_version'] = match_ver.group(1)
-                break
-
-        match_chassis_id = re.search(r'Hardware\n\s+cisco\s*(\S+\s+\S+)', reply, re.M)
-        if match_chassis_id:
-            device_info['network_os_model'] = match_chassis_id.group(1)
-
-        match_host_name = re.search(r'\s+Device name:\s*(\S+)', reply, re.M)
-        if match_host_name:
-            device_info['network_os_hostname'] = match_host_name.group(1)
-
-        find_os_image = [r'\s+system image file is:\s*(\S+)', r'\s+kickstart image file is:\s*(\S+)', r'\s+NXOS image file is:\s*(\S+)']
-        for regex in find_os_image:
-            match_file_name = re.search(regex, reply, re.M)
-            if match_file_name:
-                device_info['network_os_image'] = match_file_name.group(1)
-                break
-
-        match_os_platform = re.search(r'NAME: (?:"Chassis"| Chassis ),\s*DESCR:.*\nPID:\s*(\S+)', platform_reply, re.M)
-        if match_os_platform:
-            device_info['network_os_platform'] = match_os_platform.group(1)
-
-        self._device_info = device_info
-        return self._device_info
-
-    def get_device_operations(self):
-        platform = self.get_device_info().get('network_os_platform', '')
-        return {
-            'supports_diff_replace': True,
-            'supports_commit': False,
-            'supports_rollback': False,
-            'supports_defaults': True,
-            'supports_onbox_diff': False,
-            'supports_commit_comment': False,
-            'supports_multiline_delimiter': False,
-            'supports_diff_match': True,
-            'supports_diff_ignore_lines': True,
-            'supports_generate_diff': True,
-            'supports_replace': True if '9K' in platform else False,
-        }
-
-    def get_capabilities(self):
-        result = {}
-        result['rpc'] = []
-        result['device_info'] = self.get_device_info()
-        result['device_operations'] = self.get_device_operations()
-        result.update(OPTIONS)
-        result['network_api'] = 'nxapi'
-
-        return json.dumps(result)
-
-
-def handle_response(response):
-    results = []
-
-    if response['ins_api'].get('outputs'):
-        for output in to_list(response['ins_api']['outputs']['output']):
-            if output['code'] != '200':
-                # Best effort messages: some API output keys may not exist on some platforms
-                input_data = output.get('input', '')
-                msg = output.get('msg', '')
-                clierror = output.get('clierror', '')
-                raise ConnectionError('%s: %s: %s' % (input_data, msg, clierror), code=output['code'])
-            elif 'body' in output:
-                result = output['body']
-                if isinstance(result, dict):
-                    result = json.dumps(result)
-
-                results.append(result.strip())
-
-    return results
-
-
-def request_builder(commands, output, version='1.0', chunk='0', sid=None):
-    """Encodes a NXAPI JSON request message
-    """
-    output_to_command_type = {
-        'text': 'cli_show_ascii',
-        'json': 'cli_show',
-        'bash': 'bash',
-        'config': 'cli_conf'
-    }
-
-    maybe_output = commands[0].split('|')[-1].strip()
-    if maybe_output in output_to_command_type:
-        command_type = output_to_command_type[maybe_output]
-        commands = [command.split('|')[0].strip() for command in commands]
-    else:
-        try:
-            command_type = output_to_command_type[output]
-        except KeyError:
-            msg = 'invalid format, received %s, expected one of %s' % \
-                (output, ','.join(output_to_command_type.keys()))
-            raise ConnectionError(msg)
-
-    if isinstance(commands, (list, set, tuple)):
-        commands = ' ;'.join(commands)
-
-    # Order should not matter but some versions of NX-OS software fail
-    # to process the payload properly if 'input' gets serialized before
-    # 'type' and the payload of 'input' contains the word 'type'.
-    msg = collections.OrderedDict()
-    msg['version'] = version
-    msg['type'] = command_type
-    msg['chunk'] = chunk
-    msg['sid'] = sid
-    msg['input'] = commands
-    msg['output_format'] = 'json'
-
-    return json.dumps(dict(ins_api=msg))
diff --git a/lib/ansible/plugins/terminal/nxos.py b/lib/ansible/plugins/terminal/nxos.py
deleted file mode 100644
index 42437c9e62..0000000000
--- a/lib/ansible/plugins/terminal/nxos.py
+++ /dev/null
@@ -1,127 +0,0 @@
-#
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-import re
-import json
-
-from ansible.plugins.terminal import TerminalBase
-from ansible.errors import AnsibleConnectionFailure
-from ansible.module_utils._text import to_bytes, to_text
-
-
-class TerminalModule(TerminalBase):
-
-    terminal_stdout_re = [
-        re.compile(
-            br'[\r\n](?!\s*<)?(\x1b\S+)*[a-zA-Z_0-9]{1}[a-zA-Z0-9-_.]*[>|#](?:\s*)(\x1b\S+)*$'),
-        re.compile(br'[\r\n]?[a-zA-Z0-9]{1}[a-zA-Z0-9-_.]*\(.+\)#(?:\s*)$')
-    ]
-
-    terminal_stderr_re = [
-        re.compile(br"% ?Error"),
-        re.compile(br"^error:(.*)", re.I),
-        re.compile(br"^% \w+", re.M),
-        re.compile(br"% ?Bad secret"),
-        re.compile(br"invalid input", re.I),
-        re.compile(br"(?:incomplete|ambiguous) command", re.I),
-        re.compile(br"connection timed out", re.I),
-        re.compile(br"[^\r\n]+ not found", re.I),
-        re.compile(br"'[^']' +returned error code: ?\d+"),
-        re.compile(br"syntax error"),
-        re.compile(br"unknown command"),
-        re.compile(br"user not present"),
-        re.compile(br"invalid (.+?)at '\^' marker", re.I),
-        re.compile(br"configuration not allowed .+ at '\^' marker"),
-        re.compile(
-            br"[B|b]aud rate of console should be.* (\d*) to increase [a-z]* level", re.I),
-        re.compile(br"cannot apply non-existing acl policy to interface", re.I),
-        re.compile(br"Duplicate sequence number", re.I),
-        re.compile(
-            br"Cannot apply ACL to an interface that is a port-channel member", re.I)
-    ]
-
-    def on_become(self, passwd=None):
-        if self._get_prompt().endswith(b'enable#'):
-            return
-
-        out = self._exec_cli_command('show privilege')
-        out = to_text(out, errors='surrogate_then_replace').strip()
-        if 'Disabled' in out:
-            raise AnsibleConnectionFailure('Feature privilege is not enabled')
-
-        # if already at privilege level 15 return
-        if '15' in out:
-            return
-
-        if self.validate_user_role():
-            return
-
-        cmd = {u'command': u'enable'}
-        if passwd:
-            cmd[u'prompt'] = to_text(
-                r"(?i)[\r\n]?Password: $", errors='surrogate_or_strict')
-            cmd[u'answer'] = passwd
-            cmd[u'prompt_retry_check'] = True
-
-        try:
-            self._exec_cli_command(
-                to_bytes(json.dumps(cmd), errors='surrogate_or_strict'))
-            prompt = self._get_prompt()
-            if prompt is None or not prompt.strip().endswith(b'enable#'):
-                raise AnsibleConnectionFailure(
-                    'failed to elevate privilege to enable mode still at prompt [%s]' % prompt)
-        except AnsibleConnectionFailure as e:
-            prompt = self._get_prompt()
-            raise AnsibleConnectionFailure(
-                'unable to elevate privilege to enable mode, at prompt [%s] with error: %s' % (prompt, e.message))
-
-    def on_unbecome(self):
-        prompt = self._get_prompt()
-        if prompt is None:
-            # if prompt is None most likely the terminal is hung up at a prompt
-            return
-
-        if b'(config' in prompt:
-            self._exec_cli_command('end')
-            self._exec_cli_command('exit')
-
-        elif prompt.endswith(b'enable#'):
-            self._exec_cli_command('exit')
-
-    def on_open_shell(self):
-        try:
-            for cmd in ('terminal length 0', 'terminal width 511'):
-                self._exec_cli_command(cmd)
-        except AnsibleConnectionFailure:
-            raise AnsibleConnectionFailure('unable to set terminal parameters')
-
-    def validate_user_role(self):
-        user = self._connection._play_context.remote_user
-
-        out = self._exec_cli_command('show user-account %s' % user)
-        out = to_text(out, errors='surrogate_then_replace').strip()
-
-        match = re.search(r'roles:(.+)$', out, re.M)
-        if match:
-            roles = match.group(1).split()
-            if 'network-admin' in roles:
-                return True
-            return False
diff --git a/test/integration/targets/nxos_aaa_server/defaults/main.yaml b/test/integration/targets/nxos_aaa_server/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_aaa_server/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_aaa_server/meta/main.yml b/test/integration/targets/nxos_aaa_server/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_aaa_server/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_aaa_server/tasks/cli.yaml b/test/integration/targets/nxos_aaa_server/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_aaa_server/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_aaa_server/tasks/main.yaml b/test/integration/targets/nxos_aaa_server/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_aaa_server/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_aaa_server/tasks/nxapi.yaml b/test/integration/targets/nxos_aaa_server/tasks/nxapi.yaml
deleted file mode 100644
index a37ed6d358..0000000000
--- a/test/integration/targets/nxos_aaa_server/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
\ No newline at end of file
diff --git a/test/integration/targets/nxos_aaa_server/tests/common/radius.yaml b/test/integration/targets/nxos_aaa_server/tests/common/radius.yaml
deleted file mode 100644
index da54b0847e..0000000000
--- a/test/integration/targets/nxos_aaa_server/tests/common/radius.yaml
+++ /dev/null
@@ -1,96 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_aaa_server radius.yaml sanity test"
-
-- name: "Setup"
-  nxos_aaa_server: &remove
-    server_type: radius
-    deadtime: default
-    server_timeout: default
-    directed_request: default
-    state: default
-  ignore_errors: yes
-
-- block:
-  - name: "Configure radius server defaults"
-    nxos_aaa_server: &configure_default_radius
-      server_type: radius
-      state: present
-    register: result
-
-  - name: "Check Idempotence"
-    nxos_aaa_server: *configure_default_radius
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "Configure radius server non defaults"
-    nxos_aaa_server: &configure_radius_non_default
-      server_type: radius
-      server_timeout: 9
-      deadtime: 20
-      directed_request: enabled
-      state: present
-    register: result
-  
-  - assert: &true
-     that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_aaa_server: *configure_radius_non_default
-    register: result
-
-  - assert: *false
-
-  - name: "Remove radius server configuration"
-    nxos_aaa_server: *remove
-    register: result
-
-  - assert: *true
-
-  - name: "Configure radius server with global key"
-    nxos_aaa_server: &configure_radius_global_key
-      server_type: radius
-      encrypt_type: 7
-      global_key: test_key
-      state: present
-    register: result
-   
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_aaa_server: *configure_radius_global_key
-    register: result
-
-  - assert: *false
-
-  - name: "Remove radius server configuration"
-    nxos_aaa_server: &rad_def
-      server_type: radius
-      deadtime: default
-      server_timeout: default
-      global_key: default
-      directed_request: default
-      state: default
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_aaa_server: *rad_def
-    register: result
-
-  - assert: *false
-
-  rescue:
-
-  - debug: msg="connection={{ ansible_connection }} nxos_aaa_server failure detected"
-
-  always:
-  - name: "Remove radius server configuration"
-    nxos_aaa_server: *remove
-    register: result
-
-- debug: msg="END connection={{ ansible_connection }} nxos_aaa_server radius.yaml sanity test"
diff --git a/test/integration/targets/nxos_aaa_server/tests/common/tacacs.yaml b/test/integration/targets/nxos_aaa_server/tests/common/tacacs.yaml
deleted file mode 100644
index 9b540fc385..0000000000
--- a/test/integration/targets/nxos_aaa_server/tests/common/tacacs.yaml
+++ /dev/null
@@ -1,107 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_aaa_server tacacs.yaml sanity test"
-
-- name: "Enable feature tacacs+"
-  nxos_feature:
-    feature: tacacs+
-    state: enabled
-
-- name: "Setup"
-  nxos_aaa_server: &remove
-    server_type: tacacs
-    deadtime: default
-    server_timeout: default
-    directed_request: default
-    state: default
-  ignore_errors: yes
-
-- block:
-  - name: "Configure tacacs server defaults"
-    nxos_aaa_server: &configure_default_tacacs
-      server_type: tacacs
-      state: present
-    register: result
-
-  - name: "Check Idempotence"
-    nxos_aaa_server: *configure_default_tacacs
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "Configure tacacs server non defaults"
-    nxos_aaa_server: &configure_tacacs_non_default
-      server_type: tacacs
-      server_timeout: 9
-      deadtime: 20
-      directed_request: enabled
-      state: present
-    register: result
-  
-  - assert: &true
-     that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_aaa_server: *configure_tacacs_non_default
-    register: result
-
-  - assert: *false
-
-  - name: "Remove tacacs server configuration"
-    nxos_aaa_server: *remove
-    register: result
-
-  - assert: *true
-
-  - name: "Configure tacacs server with global key"
-    nxos_aaa_server: &configure_tacacs_global_key
-      server_type: tacacs
-      encrypt_type: 7
-      global_key: test_key
-      state: present
-    register: result
-   
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_aaa_server: *configure_tacacs_global_key
-    register: result
-
-  - assert: *false
-
-  - name: "Remove tacacs server configuration"
-    nxos_aaa_server: &tac_def
-      server_type: tacacs
-      deadtime: default
-      server_timeout: default
-      global_key: default
-      directed_request: default
-      state: default
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_aaa_server: *tac_def
-    register: result
-
-  - assert: *false
-
-  rescue:
-
-  - debug: msg="connection={{ ansible_connection }} nxos_aaa_server failure detected"
-
-  always:
-
-  - name: "Remove tacacs server configuration"
-    nxos_aaa_server: *remove
-    register: result
-
-  - name: "Disable feature tacacs+"
-    nxos_feature:
-      feature: tacacs+
-      state: disabled
-
-- debug: msg="END connection={{ ansible_connection }} nxos_aaa_server tacacs.yaml sanity test"
diff --git a/test/integration/targets/nxos_aaa_server_host/defaults/main.yaml b/test/integration/targets/nxos_aaa_server_host/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_aaa_server_host/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_aaa_server_host/meta/main.yml b/test/integration/targets/nxos_aaa_server_host/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_aaa_server_host/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_aaa_server_host/tasks/cli.yaml b/test/integration/targets/nxos_aaa_server_host/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_aaa_server_host/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_aaa_server_host/tasks/main.yaml b/test/integration/targets/nxos_aaa_server_host/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_aaa_server_host/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_aaa_server_host/tasks/nxapi.yaml b/test/integration/targets/nxos_aaa_server_host/tasks/nxapi.yaml
deleted file mode 100644
index a37ed6d358..0000000000
--- a/test/integration/targets/nxos_aaa_server_host/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
\ No newline at end of file
diff --git a/test/integration/targets/nxos_aaa_server_host/tests/common/radius.yaml b/test/integration/targets/nxos_aaa_server_host/tests/common/radius.yaml
deleted file mode 100644
index 53fa42a262..0000000000
--- a/test/integration/targets/nxos_aaa_server_host/tests/common/radius.yaml
+++ /dev/null
@@ -1,197 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_aaa_server_host radius.yaml sanity test"
-
-- name: "Setup"
-  nxos_aaa_server_host: &remove
-    server_type: radius
-    address: 8.8.8.8
-    state: absent
-  ignore_errors: yes
-
-- block:
-  - name: "Configure radius server defaults"
-    nxos_aaa_server_host: &configure_default_radius
-      server_type: radius
-      address: 8.8.8.8
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_aaa_server_host: *configure_default_radius
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "Remove radius server configuration"
-    nxos_aaa_server_host: *remove
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_aaa_server_host: *remove
-    register: result
-
-  - assert: *false
- 
-  - name: "Configure radius server non defaults"
-    nxos_aaa_server_host: &configure_radius_non_default
-      server_type: radius
-      address: 8.8.8.8
-      host_timeout: 25
-      auth_port: 2083
-      acct_port: 2084
-      state: present
-    register: result
- 
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_aaa_server_host: *configure_radius_non_default
-    register: result
-
-  - assert: *false
-
-  - name: "Configure some defaults on radius server"
-    nxos_aaa_server_host: &configure_some_radius_default
-      server_type: radius
-      address: 8.8.8.8
-      host_timeout: default
-      auth_port: 1000
-      acct_port: default
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_aaa_server_host: *configure_some_radius_default
-    register: result
-
-  - assert: *false
-
-  - name: "Configure radius server with clear text pwd"
-    nxos_aaa_server_host: &configure_radius_clear_text
-      server_type: radius
-      address: 8.8.8.8
-      host_timeout: 25
-      auth_port: default
-      acct_port: 2084
-      encrypt_type: 0
-      key: hello
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check NOT Idempotent"
-    nxos_aaa_server_host: *configure_radius_clear_text
-    register: result
-
-  - assert: *true
-
-  - name: "Remove radius server configuration"
-    nxos_aaa_server_host: *remove
-    register: result
-
-  - assert: *true
-
-  - name: "Configure radius server with type 7 encryption"
-    nxos_aaa_server_host: &configure_radius_type7
-      server_type: radius
-      address: 8.8.8.8
-      host_timeout: 25
-      auth_port: 2083
-      acct_port: 2084
-      encrypt_type: 7
-      key: hello
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_aaa_server_host: *configure_radius_type7
-    register: result
-
-  - assert: *false
-
-  - name: "Configure radius server with new type 7 encryption key"
-    nxos_aaa_server_host: &configure_radius_new_type7
-      server_type: radius
-      address: 8.8.8.8
-      host_timeout: 25
-      auth_port: 2083
-      acct_port: 2084
-      encrypt_type: 7
-      key: helloback
-      state: present
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'key 7' in result.updates[0]"
-
-  - name: "Check Idempotence"
-    nxos_aaa_server_host: *configure_radius_new_type7
-    register: result
-
-  - assert: *false
-
-  - name: "Configure radius server with default key"
-    nxos_aaa_server_host: &configure_radius_defkey
-      server_type: radius
-      address: 8.8.8.8
-      host_timeout: default
-      auth_port: 1000
-      acct_port: default
-      encrypt_type: 7
-      key: default
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_aaa_server_host: *configure_radius_defkey
-    register: result
-
-  - assert: *false
-
-  - name: "Configure radius server with all def"
-    nxos_aaa_server_host: &configure_radius_alldef
-      server_type: radius
-      address: 8.8.8.8
-      host_timeout: default
-      auth_port: default
-      acct_port: default
-      key: default
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_aaa_server_host: *configure_radius_alldef
-    register: result
-
-  - assert: *false
-
-  rescue:
-
-  - debug: msg="connection={{ ansible_connection }} nxos_aaa_server_host failure detected"
-
-  always:
-
-  - name: "Remove radius server configuration"
-    nxos_aaa_server_host: *remove
-    register: result
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_aaa_server_host radius.yaml sanity test"
diff --git a/test/integration/targets/nxos_aaa_server_host/tests/common/tacacs.yaml b/test/integration/targets/nxos_aaa_server_host/tests/common/tacacs.yaml
deleted file mode 100644
index 1e67197871..0000000000
--- a/test/integration/targets/nxos_aaa_server_host/tests/common/tacacs.yaml
+++ /dev/null
@@ -1,201 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_aaa_server_host tacacs.yaml sanity test"
-
-- name: "Enable feature tacacs+"
-  nxos_feature:
-    feature: tacacs+
-    state: enabled
-
-- name: "Setup"
-  nxos_aaa_server_host: &remove
-    server_type: tacacs
-    address: 8.8.8.8
-    state: absent
-  ignore_errors: yes
-
-- block:
-
-  - name: "Configure tacacs server defaults"
-    nxos_aaa_server_host: &configure_default_tacacs
-      server_type: tacacs
-      address: 8.8.8.8
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_aaa_server_host: *configure_default_tacacs
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "Remove tacacs server configuration"
-    nxos_aaa_server_host: *remove
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_aaa_server_host: *remove
-    register: result
-
-  - assert: *false
-  
-  - name: "Configure tacacs server non defaults"
-    nxos_aaa_server_host: &configure_tacacs_non_default
-      server_type: tacacs
-      address: 8.8.8.8
-      host_timeout: 25
-      tacacs_port: 89
-      state: present
-    register: result
- 
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_aaa_server_host: *configure_tacacs_non_default
-    register: result
-
-  - assert: *false
-
-  - name: "Configure some defaults on tacacs server"
-    nxos_aaa_server_host: &configure_some_tacacs_default
-      server_type: tacacs
-      address: 8.8.8.8
-      host_timeout: default
-      tacacs_port: 100
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_aaa_server_host: *configure_some_tacacs_default
-    register: result
-
-  - assert: *false
-
-  - name: "Configure tacacs server with clear text pwd"
-    nxos_aaa_server_host: &configure_tacacs_clear_text
-      server_type: tacacs
-      address: 8.8.8.8
-      host_timeout: 25
-      tacacs_port: default
-      encrypt_type: 0
-      key: hello
-      state: present
-    register: result
-   
-  - assert: *true
-
-  - name: "Check NOT Idempotent"
-    nxos_aaa_server_host: *configure_tacacs_clear_text
-    register: result
-
-  - assert: *true
-
-  - name: "Remove tacacs server configuration"
-    nxos_aaa_server_host: *remove
-    register: result
-
-  - assert: *true
-
-  - name: "Configure tacacs server with type 7 encryption"
-    nxos_aaa_server_host: &configure_tacacs_type7
-      server_type: tacacs
-      address: 8.8.8.8
-      host_timeout: 25
-      tacacs_port: 89
-      encrypt_type: 7
-      key: hello
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_aaa_server_host: *configure_tacacs_type7
-    register: result
-
-  - assert: *false
-
-  - name: "Configure tacacs server with new type 7 encryption key"
-    nxos_aaa_server_host: &configure_tacacs_new_type7
-      server_type: tacacs
-      address: 8.8.8.8
-      host_timeout: 25
-      tacacs_port: 89
-      encrypt_type: 7
-      key: helloback
-      state: present
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'key 7' in result.updates[0]"
-
-  - name: "Check Idempotence"
-    nxos_aaa_server_host: *configure_tacacs_new_type7
-    register: result
-
-  - assert: *false
-
-  - name: "Configure tacacs server with default key"
-    nxos_aaa_server_host: &configure_tacacs_defkey
-      server_type: tacacs
-      address: 8.8.8.8
-      host_timeout: default
-      tacacs_port: 89
-      encrypt_type: 7
-      key: default
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_aaa_server_host: *configure_tacacs_defkey
-    register: result
-
-  - assert: *false
-
-  - name: "Configure tacacs server with all def"
-    nxos_aaa_server_host: &configure_tacacs_alldef
-      server_type: tacacs
-      address: 8.8.8.8
-      host_timeout: default
-      tacacs_port: default
-      key: default
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_aaa_server_host: *configure_tacacs_alldef
-    register: result
-
-  - assert: *false
-
-  rescue:
-
-  - debug: msg="connection={{ ansible_connection }} nxos_aaa_server_host failure detected"
-
-  always:
-
-  - name: "Remove tacacs server configuration"
-    nxos_aaa_server_host: *remove
-    register: result
-
-  - name: "Disable feature tacacs+"
-    nxos_feature:
-      feature: tacacs+
-      state: disabled
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_aaa_server_host tacacs.yaml sanity test"  
diff --git a/test/integration/targets/nxos_acl/defaults/main.yaml b/test/integration/targets/nxos_acl/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_acl/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_acl/meta/main.yml b/test/integration/targets/nxos_acl/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_acl/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_acl/tasks/cli.yaml b/test/integration/targets/nxos_acl/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_acl/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_acl/tasks/main.yaml b/test/integration/targets/nxos_acl/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_acl/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_acl/tasks/nxapi.yaml b/test/integration/targets/nxos_acl/tasks/nxapi.yaml
deleted file mode 100644
index a37ed6d358..0000000000
--- a/test/integration/targets/nxos_acl/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
\ No newline at end of file
diff --git a/test/integration/targets/nxos_acl/tests/common/sanity.yaml b/test/integration/targets/nxos_acl/tests/common/sanity.yaml
deleted file mode 100644
index 2313f5d1f5..0000000000
--- a/test/integration/targets/nxos_acl/tests/common/sanity.yaml
+++ /dev/null
@@ -1,230 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_acl sanity test"
-
-- set_fact: time_range="ans-range"
-  when: platform is not search('N35|N5K|N6K')
-
-- name: "Setup: Cleanup possibly existing acl."
-  nxos_acl: &remove
-    name: TEST_ACL
-    seq: 10
-    state: delete_acl
-  ignore_errors: yes
-
-- name: "Configure ACE10"
-  nxos_acl: &conf10
-    name: TEST_ACL
-    seq: 10
-    action: permit
-    proto: tcp
-    src: 192.0.2.1/24
-    src_port_op: range
-    src_port1: 1900
-    src_port2: 1910
-    ack: 'enable'
-    dscp: 'af43'
-    dest: any
-    dest_port_op: neq
-    dest_port1: 1899
-    urg: 'enable'
-    psh: 'enable'
-    established: 'enable'
-    log: 'enable'
-    fin: 'enable'
-    rst: 'enable'
-    syn: 'enable'
-    time_range: "{{time_range|default(omit)}}"
-    state: present
-  register: result
-
-- assert: &true
-    that:
-      - "result.changed == true"
-
-- name: "Check Idempotence"
-  nxos_acl: *conf10
-  register: result
-
-- assert: &false
-    that:
-      - "result.changed == false"
-
-- name: "Change ACE10"
-  nxos_acl: &chg10
-    name: TEST_ACL
-    seq: 10
-    action: deny
-    proto: tcp
-    src: 192.0.2.1/24
-    src_port_op: range
-    src_port1: 1900
-    src_port2: 1910
-    ack: 'enable'
-    dscp: 'af43'
-    dest: any
-    dest_port_op: neq
-    dest_port1: 1899
-    urg: 'enable'
-    psh: 'enable'
-    established: 'enable'
-    log: 'enable'
-    fin: 'enable'
-    rst: 'enable'
-    syn: 'enable'
-    time_range: "{{time_range|default(omit)}}"
-    state: present
-  register: result
-
-- assert: *true
-
-- name: "Check Idempotence"
-  nxos_acl: *chg10
-  register: result
-
-- assert: *false
-
-- name: "ace remark"
-  nxos_acl: &remark
-    name: TEST_ACL
-    seq: 20
-    action: remark
-    remark: test_remark
-    state: present
-  register: result
-
-- assert: *true
-
-- name: "Check Idempotence"
-  nxos_acl: *remark
-  register: result
-
-- assert: *false
-
-- name: "change remark"
-  nxos_acl: &chgremark
-    name: TEST_ACL
-    seq: 20
-    action: remark
-    remark: changed_remark
-    state: present
-  register: result
-
-- assert: *true
-
-- name: "Check Idempotence"
-  nxos_acl: *chgremark
-  register: result
-
-- assert: *false
-
-- name: "ace 30"
-  nxos_acl: &ace30
-    name: TEST_ACL
-    seq: 30
-    action: deny
-    proto: 24
-    src: any
-    dest: any
-    fragments: enable
-    precedence: network
-    state: present
-  register: result
-
-- assert: *true
-
-- name: "Check Idempotence"
-  nxos_acl: *ace30
-  register: result
-
-- assert: *false
-
-- name: "change ace 30 options"
-  nxos_acl: &chgace30opt
-    name: TEST_ACL
-    seq: 30
-    action: deny
-    proto: 24
-    src: any
-    dest: any
-    precedence: network
-    state: present
-  register: result
-
-- assert: *true
-
-- name: "Check Idempotence"
-  nxos_acl: *chgace30opt
-  register: result
-
-- assert: *false
-
-- name: "ace 40"
-  nxos_acl: &ace40
-    name: TEST_ACL
-    seq: 40
-    action: permit
-    proto: udp
-    src: any
-    src_port_op: neq
-    src_port1: 1200
-    dest: any
-    precedence: network
-    state: present
-  register: result
-
-- assert: *true
-
-- name: "Check Idempotence"
-  nxos_acl: *ace40
-  register: result
-
-- assert: *false
-
-- name: "change ace 40"
-  nxos_acl: &chgace40
-    name: TEST_ACL
-    seq: 40
-    action: permit
-    proto: udp
-    src: any
-    dest: any
-    precedence: network
-    state: present
-  register: result
-
-- assert: *true
-
-- name: "Check Idempotence"
-  nxos_acl: *chgace40
-  register: result
-
-- assert: *false
-
-- name: "remove ace 30"
-  nxos_acl: &remace30
-    name: TEST_ACL
-    seq: 30
-    state: absent
-  register: result
-
-- assert: *true
-
-- name: "Check Idempotence"
-  nxos_acl: *remace30
-  register: result
-
-- assert: *false
-
-- name: "Remove ACL"
-  nxos_acl: *remove
-  register: result
-
-- assert: *true
-
-- name: "Check Idempotence"
-  nxos_acl: *remove
-  register: result
-
-- assert: *false
-
-- debug: msg="END connection={{ ansible_connection }} nxos_acl sanity test"
diff --git a/test/integration/targets/nxos_acl_interface/defaults/main.yaml b/test/integration/targets/nxos_acl_interface/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_acl_interface/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_acl_interface/meta/main.yml b/test/integration/targets/nxos_acl_interface/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_acl_interface/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_acl_interface/tasks/cli.yaml b/test/integration/targets/nxos_acl_interface/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_acl_interface/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_acl_interface/tasks/main.yaml b/test/integration/targets/nxos_acl_interface/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_acl_interface/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_acl_interface/tasks/nxapi.yaml b/test/integration/targets/nxos_acl_interface/tasks/nxapi.yaml
deleted file mode 100644
index a37ed6d358..0000000000
--- a/test/integration/targets/nxos_acl_interface/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
\ No newline at end of file
diff --git a/test/integration/targets/nxos_acl_interface/tests/common/sanity.yaml b/test/integration/targets/nxos_acl_interface/tests/common/sanity.yaml
deleted file mode 100644
index dc76978c27..0000000000
--- a/test/integration/targets/nxos_acl_interface/tests/common/sanity.yaml
+++ /dev/null
@@ -1,120 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_acl_interface sanity test"
-
-# Select interface for test
-- set_fact: intname="{{ nxos_int1 }}"
-
-- name: "Interface selected for this test"
-  debug: msg="{{ intname }}"
-
-- name: "Setup: Put interface into a default state"
-  nxos_config: &default
-    lines:
-      - "default interface {{ intname }}"
-  ignore_errors: yes
-
-- name: "Setup: Put interface into no switch port mode"
-  nxos_config:
-    commands:
-      - "no switchport"
-    parents:
-      - "interface {{ intname }}"
-    match: none
-  ignore_errors: yes
-
-- name: "Setup: Cleanup possibly existing acl"
-  nxos_acl: &remove
-    name: ANSIBLE_ACL
-    seq: 10
-    state: delete_acl
-  ignore_errors: yes
-
-- name: Configure Supporting ACL
-  nxos_acl:
-    name: ANSIBLE_ACL
-    seq: 10
-    action: permit
-    proto: tcp
-    src: 192.0.2.1/24
-    dest: any
-
-- block:
-  - name: Configure acl interface egress
-    nxos_acl_interface: &configure_egr
-      name: ANSIBLE_ACL
-      interface: "{{ intname }}"
-      direction: egress
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence egress"
-    nxos_acl_interface: *configure_egr
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Configure acl interface ingress
-    nxos_acl_interface: &configure_ingr
-      name: ANSIBLE_ACL
-      interface: "{{ intname }}"
-      direction: ingress
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence ingress"
-    nxos_acl_interface: *configure_ingr
-    register: result
-
-  - assert: *false
-
-  - name: Cleanup acl interface egress
-    nxos_acl_interface: &cleanup_egr
-      name: ANSIBLE_ACL
-      interface: "{{ intname }}"
-      direction: egress
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence egress cleanup"
-    nxos_acl_interface: *cleanup_egr
-    register: result
-
-  - assert: *false
-
-  - name: Cleanup acl interface ingress
-    nxos_acl_interface: &cleanup_ingr
-      name: ANSIBLE_ACL
-      interface: "{{ intname }}"
-      direction: ingress
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence ingress cleanup"
-    nxos_acl_interface: *cleanup_ingr
-    register: result
-
-  - assert: *false
-
-  rescue:
-  - name: Put test interface into default state.
-    nxos_config: *default
-    ignore_errors: yes
-
-  always:
-  - name: Remove possible configured ACL
-    nxos_acl: *remove
-    ignore_errors: yes
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_acl_interface sanity test"
diff --git a/test/integration/targets/nxos_acl_interfaces/defaults/main.yaml b/test/integration/targets/nxos_acl_interfaces/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_acl_interfaces/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_acl_interfaces/meta/main.yml b/test/integration/targets/nxos_acl_interfaces/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_acl_interfaces/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_acl_interfaces/tasks/cli.yaml b/test/integration/targets/nxos_acl_interfaces/tasks/cli.yaml
deleted file mode 100644
index f1c20c1b78..0000000000
--- a/test/integration/targets/nxos_acl_interfaces/tasks/cli.yaml
+++ /dev/null
@@ -1,20 +0,0 @@
----
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yml"
-  connection: local
-  register: test_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_acl_interfaces/tasks/main.yaml b/test/integration/targets/nxos_acl_interfaces/tasks/main.yaml
deleted file mode 100644
index 415c99d8b1..0000000000
--- a/test/integration/targets/nxos_acl_interfaces/tasks/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
diff --git a/test/integration/targets/nxos_acl_interfaces/tests/cli/deleted.yml b/test/integration/targets/nxos_acl_interfaces/tests/cli/deleted.yml
deleted file mode 100644
index b935df541e..0000000000
--- a/test/integration/targets/nxos_acl_interfaces/tests/cli/deleted.yml
+++ /dev/null
@@ -1,90 +0,0 @@
----
-- debug:
-    msg: "Start nxos_acl_interfaces deleted integration tests connection = {{ansible_connection}}"
-
-- include_tasks: populate_config.yaml
-
-- block:
-    - name: Delete single ACL from an interface
-      nxos_acl_interfaces:
-        config:
-          - name: Ethernet1/5
-            access_groups:
-              - afi: ipv6
-                acls:
-                  - name: ACL1v6
-                    direction: in
-        state: deleted
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == true"
-          - "'interface Ethernet1/5' in result.commands"
-          - "'no ipv6 traffic-filter ACL1v6 in' in result.commands"
-          - "result.commands | length ==2"
-
-    - name: Delete all ACLs of given AFI from an interface
-      nxos_acl_interfaces:
-        config:
-          - name: Ethernet1/5
-            access_groups:
-              - afi: ipv4
-        state: deleted
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == true"
-          - "'interface Ethernet1/5' in result.commands"
-          - "'no ip port access-group PortACL in' in result.commands"
-          - "'no ip access-group ACL1v4 out' in result.commands"
-          - "result.commands | length ==3"
-
-    - name: Delete all ACLs configuration from given interface
-      nxos_acl_interfaces: &deleted
-        config:
-          - name: Ethernet1/2
-        state: deleted
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == True"
-          - "'interface Ethernet1/2' in result.commands"
-          - "'no ipv6 traffic-filter ACL1v6 in' in result.commands"
-          - "result.commands | length == 2"
-
-    - include_tasks: populate_config.yaml
-
-    - name: Delete all ACLs from all interfaces (from all interfaces)
-      nxos_acl_interfaces:
-        config:
-        state: deleted
-      register: result
-
-    - name: Gather acl interfaces facts
-      nxos_facts: &facts
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources: acl_interfaces
-
-    - assert:
-        that:
-          - "result.changed == True"
-          - "ansible_facts.network_resources.acl_interfaces == result.after"
-
-    - name: Gather acls facts
-      nxos_facts: *facts
-
-    - name: Idempotence - deleted
-      nxos_acl_interfaces: *deleted
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-
-  always:
-    - include_tasks: remove_config.yaml
diff --git a/test/integration/targets/nxos_acl_interfaces/tests/cli/gathered.yml b/test/integration/targets/nxos_acl_interfaces/tests/cli/gathered.yml
deleted file mode 100644
index b3ae8b36c8..0000000000
--- a/test/integration/targets/nxos_acl_interfaces/tests/cli/gathered.yml
+++ /dev/null
@@ -1,34 +0,0 @@
----
-- debug:
-    msg: Start nxos_acl_interfaces gathered integration tests connection={{ansible_connection}}"
-
-- include_tasks: populate_config.yaml
-
-- block:
-    - name: Gather acl interfaces facts
-      nxos_facts: &facts
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources: acl_interfaces
-
-    - name: Gathered
-      nxos_acl_interfaces: &gathered
-        state: gathered
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-          - "ansible_facts.network_resources.acl_interfaces == result.gathered"
-
-    - name: Idempotence - Gathered
-      nxos_acl_interfaces: *gathered
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-
-  always:
-    - include_tasks: remove_config.yaml
diff --git a/test/integration/targets/nxos_acl_interfaces/tests/cli/merged.yml b/test/integration/targets/nxos_acl_interfaces/tests/cli/merged.yml
deleted file mode 100644
index b468e47d7c..0000000000
--- a/test/integration/targets/nxos_acl_interfaces/tests/cli/merged.yml
+++ /dev/null
@@ -1,63 +0,0 @@
----
-- debug:
-    msg: "Start nxos_acl_interfaces merged integration tests connection = {{ansible_connection}}"
-
-- include_tasks: populate_acl.yaml
-
-- block:
-    - name: Gather acl interfaces facts
-      nxos_facts:
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources: acl_interfaces
-
-    - name: Merged
-      nxos_acl_interfaces: &merged
-        config:
-          - name: Ethernet1/2
-            access_groups:
-              - afi: ipv6
-                acls:
-                  - name: ACL1v6
-                    direction: in
-
-          - name: Eth1/5
-            access_groups:
-              - afi: ipv4
-                acls:
-                  - name: PortACL
-                    direction: in
-                    port: True
-
-                  - name: ACL1v4
-                    direction: out
-
-              - afi: ipv6
-                acls:
-                  - name: ACL1v6
-                    direction: in
-        state: merged
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == True"
-          - "'interface Ethernet1/2' in result.commands"
-          - "'ipv6 traffic-filter ACL1v6 in' in result.commands"
-          - "'interface Ethernet1/5' in result.commands"
-          - "'ip port access-group PortACL in' in result.commands"
-          - "'ip access-group ACL1v4 out' in result.commands"
-          - "'ipv6 traffic-filter ACL1v6 in' in result.commands"
-          - "result.commands | length == 6 "
-
-    - name: Idempotence - Merged
-      nxos_acl_interfaces: *merged
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-
-  always:
-    - include_tasks: remove_config.yaml
diff --git a/test/integration/targets/nxos_acl_interfaces/tests/cli/overridden.yml b/test/integration/targets/nxos_acl_interfaces/tests/cli/overridden.yml
deleted file mode 100644
index d990c2a098..0000000000
--- a/test/integration/targets/nxos_acl_interfaces/tests/cli/overridden.yml
+++ /dev/null
@@ -1,68 +0,0 @@
----
-- debug:
-    msg: "Start nxos_acl_interfaces overridden integration tests connection = {{ansible_connection}}"
-
-- include_tasks: populate_config.yaml
-
-- block:
-    - name: Overridden
-      nxos_acl_interfaces: &overridden
-        config:
-          - name: Ethernet1/3
-            access_groups:
-              - afi: ipv4
-                acls:
-                  - name: ACL1v4
-                    direction: out
-
-                  - name: PortACL
-                    port: true
-                    direction: in
-
-              - afi: ipv6
-                acls:
-                  - name: NewACLv6
-                    direction: in
-                    port: true
-        state: overridden
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == True"
-          - "'interface Ethernet1/2' in result.commands"
-          - "'no ipv6 traffic-filter ACL1v6 in' in result.commands"
-          - "'interface Ethernet1/5' in result.commands"
-          - "'no ip access-group ACL1v4 out' in result.commands"
-          - "'no ip port access-group PortACL in' in result.commands"
-          - "'no ipv6 traffic-filter ACL1v6 in' in result.commands"
-          - "'interface Ethernet1/3' in result.commands"
-          - "'ip access-group ACL1v4 out' in result.commands"
-          - "'ip port access-group PortACL in' in result.commands"
-          - "'ipv6 port traffic-filter NewACLv6 in' in result.commands"
-          - "result.commands | length == 10"
-
-    - name: Gather acl_interfaces post facts
-      nxos_facts: &facts
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources: acl_interfaces
-
-    - name: Gather acls post facts
-      nxos_facts: *facts
-
-    - assert:
-        that:
-          - "ansible_facts.network_resources.acl_interfaces == result.after"
-
-    - name: Idempotence - overridden
-      nxos_acl_interfaces: *overridden
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-
-  always:
-    - include_tasks: remove_config.yaml
diff --git a/test/integration/targets/nxos_acl_interfaces/tests/cli/parsed.yml b/test/integration/targets/nxos_acl_interfaces/tests/cli/parsed.yml
deleted file mode 100644
index a54fc83ab0..0000000000
--- a/test/integration/targets/nxos_acl_interfaces/tests/cli/parsed.yml
+++ /dev/null
@@ -1,40 +0,0 @@
----
-- debug:
-    msg: Start nxos_acl_interfaces parsed integration tests connection={{ansible_connection}}"
-
-- include_tasks: populate_config.yaml
-
-- block:
-    - name: Gather acl interfaces facts
-      nxos_facts: &facts
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources: acl_interfaces
-
-    - name: Parsed
-      nxos_acl_interfaces: &parsed
-        running_config: |
-          interface Ethernet1/2
-          ipv6 traffic-filter ACL1v6 in
-          interface Ethernet1/5
-          ipv6 traffic-filter ACL1v6 in
-          ip access-group ACL1v4 out
-          ip port access-group PortACL in
-        state: parsed
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-          - "result.parsed == parsed"
-
-    - name: Idempotence - Parsed
-      nxos_acl_interfaces: *parsed
-      register: result
-
-    - assert:
-        that: "result.changed == false"
-
-  always:
-    - include_tasks: remove_config.yaml
diff --git a/test/integration/targets/nxos_acl_interfaces/tests/cli/populate_acl.yaml b/test/integration/targets/nxos_acl_interfaces/tests/cli/populate_acl.yaml
deleted file mode 100644
index 157781558b..0000000000
--- a/test/integration/targets/nxos_acl_interfaces/tests/cli/populate_acl.yaml
+++ /dev/null
@@ -1,9 +0,0 @@
----
-- name: Adding base configuration
-  cli_config:
-    config: |
-      ip access-list ACL1v4
-      ip access-list NewACLv4
-      ipv6 access-list ACL1v6
-      ipv6 access-list NewACLv6
-      ip access-list PortACL
diff --git a/test/integration/targets/nxos_acl_interfaces/tests/cli/populate_config.yaml b/test/integration/targets/nxos_acl_interfaces/tests/cli/populate_config.yaml
deleted file mode 100644
index 9ce0295eeb..0000000000
--- a/test/integration/targets/nxos_acl_interfaces/tests/cli/populate_config.yaml
+++ /dev/null
@@ -1,15 +0,0 @@
----
-- name: Adding base configuration
-  cli_config:
-    config: |
-      ip access-list ACL1v4
-      ip access-list NewACLv4
-      ipv6 access-list ACL1v6
-      ipv6 access-list NewACLv6
-      ip access-list PortACL
-      interface Ethernet1/2
-        ipv6 traffic-filter ACL1v6 in
-      interface Ethernet1/5
-        ip port access-group PortACL in
-        ip access-group ACL1v4 out
-        ipv6 traffic-filter ACL1v6 in
diff --git a/test/integration/targets/nxos_acl_interfaces/tests/cli/remove_config.yaml b/test/integration/targets/nxos_acl_interfaces/tests/cli/remove_config.yaml
deleted file mode 100644
index d0a9f9f9bb..0000000000
--- a/test/integration/targets/nxos_acl_interfaces/tests/cli/remove_config.yaml
+++ /dev/null
@@ -1,21 +0,0 @@
----
-- name: Remove config
-  cli_config:
-    config: |
-      no ip access-list ACL1v4
-      no ip access-list NewACLv4
-      no ip access-list PortACL
-      no ipv6 access-list ACL1v6
-      no ipv6 access-list ACL1v6
-      interface Ethernet1/2
-        no ipv6 traffic-filter ACL1v6 in
-      interface Ethernet1/5
-        no ip access-group ACL1v4 out
-        no ip port access-group PortACL in
-        no ipv6 traffic-filter ACL1v6 in
-      interface Ethernet1/3
-        no ipv6 port traffic-filter NewACLv6 in
-        no ip access-group ACL1v4 out
-        no ip port access-group PortACL in
-      interface Ethernet1/4
-        no ip access-group NewACLv4 out
diff --git a/test/integration/targets/nxos_acl_interfaces/tests/cli/rendered.yml b/test/integration/targets/nxos_acl_interfaces/tests/cli/rendered.yml
deleted file mode 100644
index 125cc60192..0000000000
--- a/test/integration/targets/nxos_acl_interfaces/tests/cli/rendered.yml
+++ /dev/null
@@ -1,48 +0,0 @@
----
-- debug:
-    msg: "Start nxos_acl_interfaces rendered tests connection={{ ansible_connection }}"
-
-- name: Rendered
-  nxos_acl_interfaces: &rendered
-    config:
-      - name: Ethernet1/2
-        access_groups:
-          - afi: ipv6
-            acls:
-              - name: ACL1v6
-                direction: in
-
-      - name: Ethernet1/5
-        access_groups:
-          - afi: ipv4
-            acls:
-              - name: PortACL
-                direction: in
-                port: True
-              - name: ACL1v4
-                direction: out
-          - afi: ipv6
-            acls:
-              - name: ACL1v6
-                direction: in
-    state: rendered
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-      - "'interface Ethernet1/2' in result.rendered"
-      - "'ipv6 traffic-filter ACL1v6 in' in result.rendered"
-      - "'interface Ethernet1/5' in result.rendered"
-      - "'ipv6 traffic-filter ACL1v6 in' in result.rendered"
-      - "'ip access-group ACL1v4 out' in result.rendered"
-      - "'ip port access-group PortACL in' in result.rendered"
-      - "result.rendered | length == 6"
-
-- name: Idempotence - Rendered
-  nxos_acl_interfaces: *rendered
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
diff --git a/test/integration/targets/nxos_acl_interfaces/tests/cli/replaced.yml b/test/integration/targets/nxos_acl_interfaces/tests/cli/replaced.yml
deleted file mode 100644
index b2844e119d..0000000000
--- a/test/integration/targets/nxos_acl_interfaces/tests/cli/replaced.yml
+++ /dev/null
@@ -1,60 +0,0 @@
----
-- debug:
-    msg: "Start nxos_acl_interfaces replaced integration tests connection = {{ansible_connection}}"
-
-- include_tasks: populate_config.yaml
-
-- block:
-    - name: Replaced
-      nxos_acl_interfaces: &replaced
-        config:
-          - name: Eth1/5
-            access_groups:
-              - afi: ipv4
-                acls:
-                  - name: NewACLv4
-                    direction: out
-
-          - name: Ethernet1/3
-            access_groups:
-              - afi: ipv6
-                acls:
-                  - name: NewACLv6
-                    direction: in
-                    port: true
-        state: replaced
-      register: result
-
-    - assert:
-        that:
-          - "result.changed==True"
-          - "'interface Ethernet1/5' in result.commands"
-          - "'no ip access-group ACL1v4 out' in result.commands"
-          - "'no ip port access-group PortACL in' in result.commands"
-          - "'no ipv6 traffic-filter ACL1v6 in' in result.commands"
-          - "'ip access-group NewACLv4 out' in result.commands"
-          - "'interface Ethernet1/3' in result.commands"
-          - "'ipv6 port traffic-filter NewACLv6 in' in result.commands"
-          - "result.commands|length==7"
-
-    - name: Gather acl_interfaces post facts
-      nxos_facts:
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources: acl_interfaces
-
-    - assert:
-        that:
-          - "ansible_facts.network_resources.acl_interfaces == result.after"
-
-    - name: Idempotence - Replaced
-      nxos_acl_interfaces: *replaced
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-
-  always:
-    - include_tasks: remove_config.yaml
diff --git a/test/integration/targets/nxos_acl_interfaces/tests/cli/rtt.yml b/test/integration/targets/nxos_acl_interfaces/tests/cli/rtt.yml
deleted file mode 100644
index 0cd7a1c236..0000000000
--- a/test/integration/targets/nxos_acl_interfaces/tests/cli/rtt.yml
+++ /dev/null
@@ -1,99 +0,0 @@
----
-- debug:
-    msg: "Start nxos_acl_interfaces round trip integration tests connection = {{ansible_connection}}"
-
-- include_tasks: populate_config.yaml
-
-- block:
-    - name: RTT- Apply provided configuration
-      nxos_acl_interfaces:
-        config:
-          - name: Ethernet1/2
-            access_groups:
-              - afi: ipv6
-                acls:
-                  - name: ACL1v6
-                    direction: in
-
-          - name: Eth1/5
-            access_groups:
-              - afi: ipv4
-                acls:
-                  - name: PortACL
-                    direction: in
-                    port: True
-
-                  - name: ACL1v4
-                    direction: out
-
-              - afi: ipv6
-                acls:
-                  - name: ACL1v6
-                    direction: in
-        state: merged
-
-    - name: Gather interfaces facts
-      nxos_facts:
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources:
-          - acl_interfaces
-
-    - name: Apply configuration to be reverted
-      nxos_acl_interfaces:
-        config:
-          - name: Eth1/4
-            access_groups:
-              - afi: ipv4
-                acls:
-                  - name: NewACLv4
-                    direction: out
-
-          - name: Ethernet1/3
-            access_groups:
-              - afi: ipv6
-                acls:
-                  - name: NewACLv6
-                    direction: in
-                    port: true
-        state: overridden
-      register: result
-
-    - name: Assert that changes were applied
-      assert:
-        that:
-          - "result.changed==True"
-          - "'interface Ethernet1/2' in result.commands"
-          - "'no ipv6 traffic-filter ACL1v6 in' in result.commands"
-          - "'interface Ethernet1/5' in result.commands"
-          - "'no ip access-group ACL1v4 out' in result.commands"
-          - "'no ip port access-group PortACL in' in result.commands"
-          - "'no ipv6 traffic-filter ACL1v6 in' in result.commands"
-          - "'interface Ethernet1/4' in result.commands"
-          - "'ip access-group NewACLv4 out' in result.commands"
-          - "'interface Ethernet1/3' in result.commands"
-          - "'ipv6 port traffic-filter NewACLv6 in' in result.commands"
-
-    - name: Revert back to base configuration using facts round trip
-      nxos_acl_interfaces:
-        config: "{{ ansible_facts['network_resources']['acl_interfaces'] }}"
-        state: overridden
-      register: result
-
-    - name: Assert that config was reverted
-      assert:
-        that:
-          - "result.changed==True"
-          - "'interface Ethernet1/2' in result.commands"
-          - "'ipv6 traffic-filter ACL1v6 in' in result.commands"
-          - "'interface Ethernet1/3' in result.commands"
-          - "'no ipv6 port traffic-filter NewACLv6 in' in result.commands"
-          - "'interface Ethernet1/4' in result.commands"
-          - "'no ip access-group NewACLv4 out' in result.commands"
-          - "'interface Ethernet1/5' in result.commands"
-          - "'ip access-group ACL1v4 out' in result.commands"
-          - "'ip port access-group PortACL in' in result.commands"
-          - "'ipv6 traffic-filter ACL1v6 in' in result.commands"
-  always:
-    - include_tasks: remove_config.yaml
diff --git a/test/integration/targets/nxos_acl_interfaces/vars/main.yml b/test/integration/targets/nxos_acl_interfaces/vars/main.yml
deleted file mode 100644
index 0d9ed68e9f..0000000000
--- a/test/integration/targets/nxos_acl_interfaces/vars/main.yml
+++ /dev/null
@@ -1,21 +0,0 @@
----
-parsed:
-    - access_groups:
-      - acls:
-        - direction: in
-          name: ACL1v6
-        afi: ipv6
-      name: Ethernet1/2
-    - access_groups:
-      - acls:
-        - direction: out
-          name: ACL1v4
-        - direction: in
-          name: PortACL
-          port: true
-        afi: ipv4
-      - acls:
-        - direction: in
-          name: ACL1v6
-        afi: ipv6
-      name: Ethernet1/5 
\ No newline at end of file
diff --git a/test/integration/targets/nxos_acls/defaults/main.yaml b/test/integration/targets/nxos_acls/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_acls/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_acls/meta/main.yml b/test/integration/targets/nxos_acls/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_acls/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_acls/tasks/cli.yaml b/test/integration/targets/nxos_acls/tasks/cli.yaml
deleted file mode 100644
index f1c20c1b78..0000000000
--- a/test/integration/targets/nxos_acls/tasks/cli.yaml
+++ /dev/null
@@ -1,20 +0,0 @@
----
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yml"
-  connection: local
-  register: test_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_acls/tasks/main.yaml b/test/integration/targets/nxos_acls/tasks/main.yaml
deleted file mode 100644
index 415c99d8b1..0000000000
--- a/test/integration/targets/nxos_acls/tasks/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
diff --git a/test/integration/targets/nxos_acls/tests/cli/deleted.yml b/test/integration/targets/nxos_acls/tests/cli/deleted.yml
deleted file mode 100644
index d85b125034..0000000000
--- a/test/integration/targets/nxos_acls/tests/cli/deleted.yml
+++ /dev/null
@@ -1,69 +0,0 @@
----
-- debug:
-    msg: Start nxos_acls deleted integration tests connection={{ansible_connection}}"
-
-- include_tasks: populate_config.yaml
-
-- block:
-    - name: Deleted (All ACLs)
-      nxos_acls:
-        config:
-        state: deleted
-
-    - name: Gather acls facts
-      nxos_facts: &facts
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources: acls
-
-    - assert:
-        that:
-          - "ansible_facts.network_resources == {}"
-
-    - include_tasks: populate_config.yaml
-
-    - name: Deleted
-      nxos_acls: &deleted
-        config:
-          - afi: ipv4
-
-          - afi: ipv6
-            acls:
-              - name: ACL1v6
-                aces:
-                  - grant: permit
-                    sequence: 10
-                    source:
-                      any: true
-                    destination:
-                      any: true
-                    protocol: sctp
-
-                  - sequence: 20
-        state: deleted
-      register: result
-
-    - assert:
-        that:
-          - "result.changed==True"
-          - "'no ip access-list ACL1v4' in result.commands"
-          - "'no ip access-list ACL2v4' in result.commands"
-          - "'ipv6 access-list ACL1v6' in result.commands"
-          - "'no 10 permit sctp any any' in result.commands"
-          - "'no 20' in result.commands"
-          - "result.commands | length == 5"
-
-    - name: Gather acls facts
-      nxos_facts: *facts
-
-    - name: Idempotence - deleted
-      nxos_acls: *deleted
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-
-  always:
-    - include_tasks: remove_config.yaml
diff --git a/test/integration/targets/nxos_acls/tests/cli/gathered.yml b/test/integration/targets/nxos_acls/tests/cli/gathered.yml
deleted file mode 100644
index c2ff83c9c5..0000000000
--- a/test/integration/targets/nxos_acls/tests/cli/gathered.yml
+++ /dev/null
@@ -1,34 +0,0 @@
----
-- debug:
-    msg: Start nxos_acls gathered integration tests connection={{ansible_connection}}"
-
-- include_tasks: populate_config.yaml
-
-- block:
-    - name: Gather acls facts
-      nxos_facts: &facts
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources: acls
-
-    - name: Gathered
-      nxos_acls: &gathered
-        state: gathered
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-          - "ansible_facts.network_resources.acls == result.gathered"
-
-    - name: Idempotence - Gathered
-      nxos_acls: *gathered
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-
-  always:
-    - include_tasks: remove_config.yaml
diff --git a/test/integration/targets/nxos_acls/tests/cli/merged.yml b/test/integration/targets/nxos_acls/tests/cli/merged.yml
deleted file mode 100644
index b22b568adf..0000000000
--- a/test/integration/targets/nxos_acls/tests/cli/merged.yml
+++ /dev/null
@@ -1,108 +0,0 @@
----
-- debug:
-    msg: Start nxos_acls merged integration tests connection={{ansible_connection}}"
-
-- include_tasks: remove_config.yaml
-
-- block:
-    - name: Merged
-      nxos_acls: &merged
-        config:
-          - afi: ipv4
-            acls:
-              - name: ACL1v4
-                aces:
-                  - grant: deny
-                    destination:
-                      address: 192.0.2.64
-                      wildcard_bits: 0.0.0.255
-                    source:
-                      any: true
-                      port_protocol:
-                        lt: 25
-                    protocol: tcp
-                    protocol_options:
-                      tcp:
-                        ack: true
-                        fin: true
-                    sequence: 50
-                  - grant: permit
-                    protocol: ip
-                    source:
-                      any: true
-                    destination:
-                      any: true
-                    fragments: true
-                    log: true
-                    sequence: 20
-
-          - afi: ipv6
-            acls:
-              - name: ACL1v6
-                aces:
-                  - grant: permit
-                    sequence: 10
-                    source:
-                      any: true
-                    destination:
-                      host: 2001:db8:12::128
-                    protocol: sctp
-        state: merged
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == True"
-          - "'ip access-list ACL1v4' in result.commands"
-          - "'20 permit ip any any fragments log' in result.commands"
-          - "'50 deny tcp any lt smtp 192.0.2.64 0.0.0.255 ack fin' in result.commands"
-          - "'ipv6 access-list ACL1v6' in result.commands"
-          - "'10 permit sctp any host 2001:db8:12::128' in result.commands"
-          - "result.commands | length == 5 "
-
-    - name: Gather acls facts
-      nxos_facts:
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources: acls
-
-    - assert:
-        that:
-          - "ansible_facts.network_resources.acls == result.after"
-
-    - name: Idempotence - Merged
-      nxos_acls: *merged
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-
-    - name: Update one parameter of an ACE
-      nxos_acls:
-        config:
-          - afi: ipv4
-            acls:
-              - name: ACL1v4
-                aces:
-                  - grant: permit
-                    protocol: tcp
-                    source:
-                      any: true
-                    destination:
-                      any: true
-                    sequence: 20
-                    precedence: 5
-        state: merged
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == True"
-          - "'ip access-list ACL1v4' in result.commands"
-          - "'no 20' in result.commands"
-          - "'20 permit tcp any any fragments precedence critical log' in result.commands"
-
-  always:
-    - include_tasks: remove_config.yaml
diff --git a/test/integration/targets/nxos_acls/tests/cli/overridden.yml b/test/integration/targets/nxos_acls/tests/cli/overridden.yml
deleted file mode 100644
index 27cca65d8b..0000000000
--- a/test/integration/targets/nxos_acls/tests/cli/overridden.yml
+++ /dev/null
@@ -1,99 +0,0 @@
----
-- debug:
-    msg: Start nxos_acls overridden integration tests connection={{ansible_connection}}"
-
-- include_tasks: populate_config.yaml
-
-- block:
-    - name: Overridden (first test)
-      nxos_acls:
-        config:
-          - afi: ipv4
-            acls:
-              - name: NewACL
-                aces:
-                  - grant: deny
-                    source:
-                      address: 192.0.2.0
-                      wildcard_bits: 0.0.255.255
-                    destination:
-                      any: true
-                    protocol: eigrp
-                  - remark: Example for overridden state
-        state: overridden
-      register: result
-
-    - assert:
-        that:
-          - "result.changed==True"
-          - "'no ip access-list ACL1v4' in result.commands"
-          - "'no ip access-list ACL2v4' in result.commands"
-          - "'no ipv6 access-list ACL1v6' in result.commands"
-          - "'no ipv6 access-list ACL2v6' in result.commands"
-          - "'ip access-list NewACL' in result.commands"
-          - "'deny eigrp 192.0.2.0 0.0.255.255 any' in result.commands"
-          - "'remark Example for overridden state' in result.commands"
-          - "result.commands|length==7"
-
-    - name: Gather acls post facts
-      nxos_facts: &facts
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources: acls
-
-    - assert:
-        that:
-          - "ansible_facts.network_resources.acls == result.after"
-
-    - include_tasks: populate_config.yaml
-
-    - name: Overridden (second test)
-      nxos_acls: &overridden
-        config:
-          - afi: ipv6
-            acls:
-              - name: ACL1v6
-                aces:
-                  - grant: deny
-                    protocol: udp
-                    destination:
-                      any: true
-                    source:
-                      host: 2001:db8:3431::12
-                      port_protocol:
-                        lt: 35
-                    sequence: 10
-        state: overridden
-      register: result
-
-    - assert:
-        that:
-          - "result.changed==True"
-          - "'no ip access-list ACL1v4' in result.commands"
-          - "'no ip access-list ACL2v4' in result.commands"
-          - "'no ipv6 access-list ACL2v6' in result.commands"
-          - "'no ip access-list NewACL' in result.commands"
-          - "'ipv6 access-list ACL1v6' in result.commands"
-          - "'no 10 permit sctp any any' in result.commands"
-          - "'no 20 remark IPv6 ACL' in result.commands"
-          - "'10 deny udp host 2001:db8:3431::12 lt 35 any' in result.commands"
-          - "result.commands|length==8"
-
-    - name: Gather acls post facts
-      nxos_facts: *facts
-
-    - assert:
-        that:
-          - "ansible_facts.network_resources.acls == result.after"
-
-    - name: Idempotence - overridden
-      nxos_acls: *overridden
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-
-  always:
-    - include_tasks: remove_config.yaml
diff --git a/test/integration/targets/nxos_acls/tests/cli/parsed.yml b/test/integration/targets/nxos_acls/tests/cli/parsed.yml
deleted file mode 100644
index 8a2efd5270..0000000000
--- a/test/integration/targets/nxos_acls/tests/cli/parsed.yml
+++ /dev/null
@@ -1,45 +0,0 @@
----
-- debug:
-    msg: Start nxos_acls gathered integration tests connection={{ansible_connection}}"
-
-- include_tasks: populate_config.yaml
-
-- block:
-    - name: Gather acls facts
-      nxos_facts: &facts
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources: acls
-
-    - name: Parsed
-      nxos_acls: &parsed
-        running_config: |
-          ip access-list ACL1v4
-          10 permit ip any any
-          20 deny udp any any
-          ip access-list ACL2v4
-          10 permit ahp 192.0.2.0 0.0.0.255 any
-          ipv6 access-list ACL1v6
-          10 permit sctp any any
-          20 remark IPv6 ACL
-          ipv6 access-list ACL2v6
-          10 deny ipv6 any 2001:db8:3000::36/128
-          20 permit tcp 2001:db8:2000:2::2/128 2001:db8:2000:ab::2/128
-        state: parsed
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-          - "ansible_facts.network_resources.acls == result.parsed"
-
-    - name: Idempotence - Parsed
-      nxos_acls: *parsed
-      register: result
-
-    - assert:
-        that: "result.changed == false"
-
-  always:
-    - include_tasks: remove_config.yaml
diff --git a/test/integration/targets/nxos_acls/tests/cli/populate_config.yaml b/test/integration/targets/nxos_acls/tests/cli/populate_config.yaml
deleted file mode 100644
index 81b72e11c0..0000000000
--- a/test/integration/targets/nxos_acls/tests/cli/populate_config.yaml
+++ /dev/null
@@ -1,15 +0,0 @@
----
-- name: Add configuration
-  cli_config:
-    config: |
-      ip access-list ACL1v4
-        10 permit ip any any
-        20 deny udp any any
-      ip access-list ACL2v4
-        10 permit ahp 192.0.2.0 0.0.0.255 any
-      ipv6 access-list ACL1v6
-        10 permit sctp any any
-        20 remark IPv6 ACL
-      ipv6 access-list ACL2v6
-        10 deny ipv6 any host 2001:db8:3000::36
-        20 permit tcp host 2001:db8:2000:2::2 host 2001:db8:2000:ab::2
diff --git a/test/integration/targets/nxos_acls/tests/cli/remove_config.yaml b/test/integration/targets/nxos_acls/tests/cli/remove_config.yaml
deleted file mode 100644
index a6f3320051..0000000000
--- a/test/integration/targets/nxos_acls/tests/cli/remove_config.yaml
+++ /dev/null
@@ -1,9 +0,0 @@
----
-- name: Remove config
-  cli_config:
-    config: |
-      no ip access-list ACL1v4
-      no ip access-list ACL2v4
-      no ipv6 access-list ACL1v6
-      no ipv6 access-list ACL2v6
-      no ip access-list NewACL
diff --git a/test/integration/targets/nxos_acls/tests/cli/rendered.yml b/test/integration/targets/nxos_acls/tests/cli/rendered.yml
deleted file mode 100644
index 5419a7086b..0000000000
--- a/test/integration/targets/nxos_acls/tests/cli/rendered.yml
+++ /dev/null
@@ -1,56 +0,0 @@
----
-- debug:
-    msg: "Start nxos_acls rendered tests connection={{ ansible_connection }}"
-
-- name: Rendered
-  nxos_acls: &rendered
-    config:
-      - afi: ipv4
-        acls:
-          - name: ACL1v4
-            aces:
-              - grant: deny
-                destination:
-                  address: 192.0.2.64
-                  wildcard_bits: 0.0.0.255
-                source:
-                  any: true
-                  port_protocol:
-                    eq: 43
-                protocol: tcp
-                protocol_options:
-                  tcp:
-                    ack: true
-                    fin: true
-                sequence: 50
-
-      - afi: ipv6
-        acls:
-          - name: ACL1v6
-            aces:
-              - grant: permit
-                sequence: 10
-                source:
-                  any: true
-                destination:
-                  prefix: 2001:db8:12::/32
-                protocol: sctp
-    state: rendered
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-      - "'ip access-list ACL1v4' in result.rendered"
-      - "'50 deny tcp any eq whois 192.0.2.64 0.0.0.255 ack fin' in result.rendered"
-      - "'ipv6 access-list ACL1v6' in result.rendered"
-      - "'10 permit sctp any 2001:db8:12::/32' in result.rendered"
-      - "result.rendered | length == 4"
-
-- name: Idempotence - Rendered
-  nxos_acls: *rendered
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
diff --git a/test/integration/targets/nxos_acls/tests/cli/replaced.yml b/test/integration/targets/nxos_acls/tests/cli/replaced.yml
deleted file mode 100644
index 2451347491..0000000000
--- a/test/integration/targets/nxos_acls/tests/cli/replaced.yml
+++ /dev/null
@@ -1,65 +0,0 @@
----
-- debug:
-    msg: Start nxos_acls replaced integration tests connection={{ansible_connection}}"
-
-- include_tasks: populate_config.yaml
-
-- block:
-    - name: Replaced
-      nxos_acls: &replaced
-        config:
-          - afi: ipv4
-
-          - afi: ipv6
-            acls:
-              - name: ACL1v6
-                aces:
-                  - sequence: 30
-                    grant: permit
-                    source:
-                      any: true
-                    destination:
-                      any: true
-                    protocol: pim
-
-                  - sequence: 40
-                    remark: Replaced ACE
-              - name: ACL2v6
-        state: replaced
-      register: result
-
-    - assert:
-        that:
-          - "'no ip access-list ACL1v4' in result.commands"
-          - "'no ip access-list ACL2v4' in result.commands"
-          - "'ipv6 access-list ACL1v6' in result.commands"
-          - "'no 10 permit sctp any any' in result.commands"
-          - "'no 20 remark IPv6 ACL' in result.commands"
-          - "'30 permit pim any any' in result.commands"
-          - "'40 remark Replaced ACE' in result.commands"
-          - "'ipv6 access-list ACL2v6' in result.commands"
-          - "'no 10 deny ipv6 any host 2001:db8:3000::36' in result.commands"
-          - "'no 20 permit tcp host 2001:db8:2000:2::2 host 2001:db8:2000:ab::2' in result.commands"
-          - "result.commands|length == 10"
-
-    - name: Gather static_routes post facts
-      nxos_facts:
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources: acls
-
-    - assert:
-        that:
-          - "ansible_facts.network_resources.acls == result.after"
-
-    - name: Idempotence - Replaced
-      nxos_acls: *replaced
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-
-  always:
-    - include_tasks: remove_config.yaml
diff --git a/test/integration/targets/nxos_acls/tests/cli/rtt.yml b/test/integration/targets/nxos_acls/tests/cli/rtt.yml
deleted file mode 100644
index d3878ec149..0000000000
--- a/test/integration/targets/nxos_acls/tests/cli/rtt.yml
+++ /dev/null
@@ -1,87 +0,0 @@
----
-- debug:
-    msg: "Start nxos_acls round trip integration tests connection = {{ansible_connection}}"
-
-- block:
-    - name: RTT - Apply provided configuration
-      nxos_acls:
-        config:
-          - afi: ipv4
-            acls:
-              - name: ACL1v4
-                aces:
-                  - grant: deny
-                    destination:
-                      address: 192.0.2.64
-                      wildcard_bits: 0.0.0.255
-                    source:
-                      any: true
-                      port_protocol:
-                        lt: 25
-                    protocol: tcp
-                    protocol_options:
-                      tcp:
-                        ack: true
-                        fin: true
-                    sequence: 50
-
-                  - grant: permit
-                    protocol: ip
-                    source:
-                      any: true
-                    destination:
-                      any: true
-                    fragments: true
-                    log: true
-                    sequence: 20
-        state: merged
-
-    - name: Gather interfaces facts
-      nxos_facts:
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources:
-          - acls
-
-    - name: Apply configuration to be reverted
-      nxos_acls:
-        config:
-          - afi: ipv6
-            acls:
-              - name: ACL1v6
-                aces:
-                  - grant: permit
-                    sequence: 10
-                    source:
-                      any: true
-                    destination:
-                      host: 2001:db8:12::128
-                    protocol: sctp
-        state: overridden
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == True"
-          - "'no ip access-list ACL1v4' in result.commands"
-          - "'ipv6 access-list ACL1v6' in result.commands"
-          - "'10 permit sctp any host 2001:db8:12::128' in result.commands"
-          - "result.commands | length == 3 "
-
-    - name: Revert back to base configuration using facts round trip
-      nxos_acls:
-        config: "{{ ansible_facts['network_resources']['acls'] }}"
-        state: overridden
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == True"
-          - "'ip access-list ACL1v4' in result.commands"
-          - "'20 permit ip any any fragments log' in result.commands"
-          - "'50 deny tcp any lt smtp 192.0.2.64 0.0.0.255 fin ack' in result.commands"
-          - "'no ipv6 access-list ACL1v6' in result.commands"
-          - "result.commands | length == 4 "
-  always:
-    - include_tasks: remove_config.yaml
diff --git a/test/integration/targets/nxos_banner/defaults/main.yaml b/test/integration/targets/nxos_banner/defaults/main.yaml
deleted file mode 100644
index 9ef5ba5165..0000000000
--- a/test/integration/targets/nxos_banner/defaults/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-testcase: "*"
-test_items: []
diff --git a/test/integration/targets/nxos_banner/meta/main.yaml b/test/integration/targets/nxos_banner/meta/main.yaml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_banner/meta/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_banner/tasks/cli.yaml b/test/integration/targets/nxos_banner/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_banner/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_banner/tasks/main.yaml b/test/integration/targets/nxos_banner/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_banner/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_banner/tasks/nxapi.yaml b/test/integration/targets/nxos_banner/tasks/nxapi.yaml
deleted file mode 100644
index a37ed6d358..0000000000
--- a/test/integration/targets/nxos_banner/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
\ No newline at end of file
diff --git a/test/integration/targets/nxos_banner/tests/common/sanity.yaml b/test/integration/targets/nxos_banner/tests/common/sanity.yaml
deleted file mode 100644
index ab1eef835b..0000000000
--- a/test/integration/targets/nxos_banner/tests/common/sanity.yaml
+++ /dev/null
@@ -1,84 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_banner sanity test"
-
-- set_fact: banner_exec_image_ok
-  # N5K/N6K/N9K-F support banner exec but have image defects
-  when: platform is search("N7K|N3K-F")
-
-- set_fact: banner_motd_image_ok
-  # multiline banner issues
-  when: imagetag is not search("I7") and ansible_connection != "httpapi"
-
-
-# banner exec tests
-- block:
-  - debug: msg="START nxos_banner exec tests"
-  - name: setup exec
-    nxos_banner: &remove_exec
-      banner: exec
-      state: absent
-
-  - name: Set exec
-    nxos_banner: &exec
-      banner: exec
-      text: |
-        this is my exec banner
-        that has a multiline
-        string
-      state: present
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'banner exec @\nthis is my exec banner\nthat has a multiline\nstring\n@' in result.commands"
-
-  - name: Set exec again (idempotent)
-    nxos_banner: *exec
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands | length == 0"
-
-  - name: teardown exec
-    nxos_banner: *remove_exec
-
-  when: banner_exec_image_ok is defined
-
-# banner motd tests
-- block:
-  - name: setup motd
-    nxos_banner: &remove_motd
-      banner: motd
-      state: absent
-
-  - name: Set motd
-    nxos_banner: &motd
-      banner: motd
-      text: |
-        Junk motd banner
-        over multiple lines
-      state: present
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'banner motd @\nJunk motd banner\nover multiple lines\n@' in result.commands"
-
-  - name: Set motd again (idempotent)
-    nxos_banner: *motd
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-
-  - name: teardown motd
-    nxos_banner: *remove_motd
-
-  when: banner_motd_image_ok is defined
-
-- debug: msg="END connection={{ ansible_connection }} nxos_banner sanity test"
diff --git a/test/integration/targets/nxos_become/defaults/main.yaml b/test/integration/targets/nxos_become/defaults/main.yaml
deleted file mode 100644
index 9ef5ba5165..0000000000
--- a/test/integration/targets/nxos_become/defaults/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-testcase: "*"
-test_items: []
diff --git a/test/integration/targets/nxos_become/meta/main.yml b/test/integration/targets/nxos_become/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_become/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_become/tasks/cli.yaml b/test/integration/targets/nxos_become/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_become/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_become/tasks/main.yaml b/test/integration/targets/nxos_become/tasks/main.yaml
deleted file mode 100644
index f9482f77cf..0000000000
--- a/test/integration/targets/nxos_become/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-#- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_become/tasks/nxapi.yaml b/test/integration/targets/nxos_become/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_become/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_become/tests/cli/sanity.yaml b/test/integration/targets/nxos_become/tests/cli/sanity.yaml
deleted file mode 100644
index bee0584563..0000000000
--- a/test/integration/targets/nxos_become/tests/cli/sanity.yaml
+++ /dev/null
@@ -1,34 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }}/sanity.yaml"
-
-- block:
-  - name: update role to priv-14
-    nxos_config:
-      lines:
-        - username admin role priv-14
-        - no username admin role priv-15
-        - enable secret 0 cisco
-
-  - name: reset_connection
-    meta: reset_connection
-
-  - name: run commands with become
-    nxos_command:
-      commands: 'show privilege'
-    become: yes
-    register: result
-  
-  - assert:
-      that:
-        - "'Current privilege level: 15' in result['stdout'][0]"
-
-  always:
-  - name: teardown
-    nxos_config:
-      lines:
-        - username admin role priv-15
-        - no username admin role priv-14
-        - no enable secret
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }}/sanity.yaml" 
diff --git a/test/integration/targets/nxos_bfd_global/defaults/main.yaml b/test/integration/targets/nxos_bfd_global/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_bfd_global/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_bfd_global/meta/main.yml b/test/integration/targets/nxos_bfd_global/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_bfd_global/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_bfd_global/tasks/cli.yaml b/test/integration/targets/nxos_bfd_global/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_bfd_global/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_bfd_global/tasks/main.yaml b/test/integration/targets/nxos_bfd_global/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_bfd_global/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_bfd_global/tasks/nxapi.yaml b/test/integration/targets/nxos_bfd_global/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_bfd_global/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_bfd_global/tests/common/sanity.yaml b/test/integration/targets/nxos_bfd_global/tests/common/sanity.yaml
deleted file mode 100644
index 0aaf86e471..0000000000
--- a/test/integration/targets/nxos_bfd_global/tests/common/sanity.yaml
+++ /dev/null
@@ -1,168 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_bfd_global sanity test"
-
-- name: set facts common
-  # nd_* vars are "non-default" values
-  set_fact:
-    echo: deleted
-    nd_echo: loopback1
-    interval: &def_interval
-      tx: 50
-      min_rx: 50
-      multiplier: 3
-    nd_interval:
-      tx: 51
-      min_rx: 52
-      multiplier: 4
-    slow: 2000
-    nd_slow: 2001
-
-- name: set facts (exclude 5K/6K)
-  set_fact:
-    echo_rx: 50
-    nd_echo_rx: 51
-    ipv4_echo_rx: 50
-    nd_ipv4_echo_rx: 54
-    ipv4_interval: *def_interval
-    nd_ipv4_interval: &nd_afi_interval
-      tx: 54
-      min_rx: 56
-      multiplier: 8
-    ipv4_slow: 2000
-    nd_ipv4_slow: 2044
-  when: platform is not search('N5K|N6K')
-
-- name: set facts (exclude 35/5K/6K)
-  set_fact:
-    ipv6_echo_rx: 50
-    nd_ipv6_echo_rx: 56
-    ipv6_interval: *def_interval
-    nd_ipv6_interval: *nd_afi_interval
-    ipv6_slow: 2000
-    nd_ipv6_slow: 2046
-  when: platform is not search('N35|N5K|N6K')
-
-- name: set facts (exclude 5K/6K/7K)
-  set_fact:
-    startup: 5
-    nd_startup: 6
-  when: platform is not search('N35|N5K|N6K|N7K')
-
-- name: set facts 3k defaults (resets some values above)
-  set_fact:
-    echo_rx: 250
-    interval: &n3k_def_interval
-      tx: 250
-      min_rx: 250
-      multiplier: 3
-    ipv4_echo_rx: 250
-    ipv6_echo_rx: 250
-    ipv4_interval: *n3k_def_interval
-    ipv6_interval: *n3k_def_interval
-    ipv4_slow: 2000
-    ipv6_slow: 2000
-  when: platform is search('N3K')
-
-- name: set facts fabricpath
-  set_fact:
-    fab_interval: *def_interval
-    nd_fab_interval:
-      tx: 57
-      min_rx: 57
-      multiplier: 7
-    fab_slow_timer: 2000
-    nd_fab_slow_timer: 2007
-    fab_vlan: 1
-    nd_fab_vlan: 47
-  when: platform is not search('N35|N3K|N9K')
-
-- name: Setup
-  nxos_feature: &setup_teardown
-    feature: bfd
-    state: disabled
-  ignore_errors: yes
-
-- name: Setup supporting loopback interface
-  nxos_config:
-    lines: interface loopback1
-    match: none
-
-- name: feature bfd init
-  # 'feature bfd' init is slow on some platforms, retry on fail
-  nxos_bfd_global:
-    slow_timer:            "{{ nd_slow }}"
-  delay: 3
-  retries: 1
-  register: result
-  until: result is not failed
-  ignore_errors: yes
-
-- block:
-  - name: BFD non defaults
-    nxos_bfd_global: &bfd_non_def
-      echo_interface:        "{{ nd_echo }}"
-      echo_rx_interval:      "{{ nd_echo_rx | default(omit) }}"
-      interval:              "{{ nd_interval }}"
-      slow_timer:            "{{ nd_slow }}"
-      startup_timer:         "{{ nd_startup | default(omit) }}"
-      ipv4_echo_rx_interval: "{{ nd_ipv4_echo_rx | default(omit) }}"
-      ipv6_echo_rx_interval: "{{ nd_ipv6_echo_rx | default(omit) }}"
-      ipv4_interval:         "{{ nd_ipv4_interval | default(omit) }}"
-      ipv6_interval:         "{{ nd_ipv6_interval | default(omit) }}"
-      ipv4_slow_timer:       "{{ nd_ipv4_slow | default(omit) }}"
-      ipv6_slow_timer:       "{{ nd_ipv6_slow | default(omit) }}"
-      fabricpath_interval:   "{{ nd_fab_interval | default(omit) }}"
-      fabricpath_slow_timer: "{{ nd_fab_slow | default(omit) }}"
-      fabricpath_vlan:       "{{ nd_fab_vlan | default(omit) }}"
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: bfd_non_def idempotence
-    nxos_bfd_global: *bfd_non_def
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: BFD defaults
-    nxos_bfd_global: &bfd_def
-      echo_interface:        "{{ echo }}"
-      echo_rx_interval:      "{{ echo_rx | default(omit) }}"
-      interval:              "{{ interval }}"
-      slow_timer:            "{{ slow }}"
-      startup_timer:         "{{ startup | default(omit) }}"
-      ipv4_echo_rx_interval: "{{ ipv4_echo_rx | default(omit) }}"
-      ipv6_echo_rx_interval: "{{ ipv6_echo_rx | default(omit) }}"
-      ipv4_interval:         "{{ ipv4_interval | default(omit) }}"
-      ipv6_interval:         "{{ ipv6_interval | default(omit) }}"
-      ipv4_slow_timer:       "{{ ipv4_slow | default(omit) }}"
-      ipv6_slow_timer:       "{{ ipv6_slow | default(omit) }}"
-      fabricpath_interval:   "{{ fab_interval | default(omit) }}"
-      fabricpath_slow_timer: "{{ fab_slow | default(omit) }}"
-      fabricpath_vlan:       "{{ fab_vlan | default(omit) }}"
-    register: result
-
-  - assert: *true
-
-  - name: bfd_def idempotence
-    nxos_bfd_global: *bfd_def
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: Teardown
-    nxos_feature: *setup_teardown
-    ignore_errors: yes
-
-  - name: Teardown supporting loopback interface
-    nxos_config:
-      lines: no interface loopback1
-      match: none
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_bfd_global sanity test"
diff --git a/test/integration/targets/nxos_bfd_interfaces/defaults/main.yaml b/test/integration/targets/nxos_bfd_interfaces/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_bfd_interfaces/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_bfd_interfaces/meta/main.yml b/test/integration/targets/nxos_bfd_interfaces/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_bfd_interfaces/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_bfd_interfaces/tasks/cli.yaml b/test/integration/targets/nxos_bfd_interfaces/tasks/cli.yaml
deleted file mode 100644
index 6c7ea4a7f9..0000000000
--- a/test/integration/targets/nxos_bfd_interfaces/tasks/cli.yaml
+++ /dev/null
@@ -1,20 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_bfd_interfaces/tasks/main.yaml b/test/integration/targets/nxos_bfd_interfaces/tasks/main.yaml
deleted file mode 100644
index 415c99d8b1..0000000000
--- a/test/integration/targets/nxos_bfd_interfaces/tasks/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
diff --git a/test/integration/targets/nxos_bfd_interfaces/tasks/nxapi.yaml b/test/integration/targets/nxos_bfd_interfaces/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_bfd_interfaces/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_bfd_interfaces/tests/cli/deleted.yaml b/test/integration/targets/nxos_bfd_interfaces/tests/cli/deleted.yaml
deleted file mode 100644
index 1db9a217f9..0000000000
--- a/test/integration/targets/nxos_bfd_interfaces/tests/cli/deleted.yaml
+++ /dev/null
@@ -1,71 +0,0 @@
----
-- debug:
-    msg: "Start nxos_bfd_interfaces deleted integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact:
-    bfd_enable: enable
-    bfd_disable: disable
-  when: platform is not search('N5K|N6K')
-
-- name: setup1
-  cli_config: &setup_teardown
-    config: |
-      no feature bfd
-      default interface {{ test_int1 }}
-
-- block:
-  - name: setup2
-    cli_config:
-      config: |
-        feature bfd
-        interface {{ test_int1 }}
-          no switchport
-
-  - name: setup initial bfd state
-    nxos_bfd_interfaces:
-      config:
-        - name: "{{ test_int1 }}"
-          bfd: "{{ bfd_disable|default(omit)}}"
-          echo: disable
-      state: merged
-
-  - name: Gather bfd_interfaces facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: bfd_interfaces
-
-  - name: deleted
-    nxos_bfd_interfaces: &deleted
-      config:
-        - name: "{{ test_int1 }}"
-      state: deleted
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'bfd echo' in result.commands"
-      msg: "Assert failed. 'result.commands': {{ result.commands }}"
-
-  - assert:
-      that:
-        - "{{ 'bfd' in result.commands }}"
-      msg: "Assert failed. 'result.commands': {{ result.commands }}"
-    when: bfd_enable is defined
-
-
-  - name: Idempotence - deleted
-    nxos_bfd_interfaces: *deleted
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *setup_teardown
diff --git a/test/integration/targets/nxos_bfd_interfaces/tests/cli/merged.yaml b/test/integration/targets/nxos_bfd_interfaces/tests/cli/merged.yaml
deleted file mode 100644
index 730a9498f4..0000000000
--- a/test/integration/targets/nxos_bfd_interfaces/tests/cli/merged.yaml
+++ /dev/null
@@ -1,68 +0,0 @@
----
-- debug:
-    msg: "Start nxos_bfd_interfaces merged integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact:
-    bfd_enable: enable
-    bfd_disable: disable
-  when: platform is not search('N5K|N6K')
-
-- name: setup1
-  cli_config: &setup_teardown
-    config: |
-      no feature bfd
-      default interface {{ test_int1 }}
-
-- block:
-  - name: setup2
-    cli_config:
-      config: |
-        feature bfd
-        interface {{ test_int1 }}
-          no switchport
-
-  - name: Merged
-    nxos_bfd_interfaces: &merged
-      config:
-        - name: "{{ test_int1 }}"
-          bfd: "{{ bfd_disable|default(omit)}}"
-          echo: disable
-      state:  merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'no bfd echo' in result.commands"
-      msg: "Assert failed. 'result.commands': {{ result.commands }}"
-
-  - assert:
-      that:
-        - "{{ 'no bfd' in result.commands }}"
-      msg: "Assert failed. 'result.commands': {{ result.commands }}"
-    when: bfd_enable is defined
-
-  - name: Gather bfd_interfaces facts
-    nxos_facts:
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: bfd_interfaces
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.bfd_interfaces|symmetric_difference(result.after)|length == 0"
-
-  - name: Idempotence - Merged
-    nxos_bfd_interfaces: *merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *setup_teardown
diff --git a/test/integration/targets/nxos_bfd_interfaces/tests/cli/overridden.yaml b/test/integration/targets/nxos_bfd_interfaces/tests/cli/overridden.yaml
deleted file mode 100644
index c4f5e95b1c..0000000000
--- a/test/integration/targets/nxos_bfd_interfaces/tests/cli/overridden.yaml
+++ /dev/null
@@ -1,67 +0,0 @@
----
-- debug:
-    msg: "Start nxos_bfd_interfaces overridden integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact: test_int2="{{ nxos_int2 }}"
-- set_fact:
-    bfd_enable: enable
-    bfd_disable: disable
-  when: platform is not search('N5K|N6K')
-
-- name: setup1
-  cli_config: &setup_teardown
-    config: |
-      no feature bfd
-      default interface {{ test_int1 }}
-      default interface {{ test_int2 }}
-
-- block:
-  - name: setup2
-    cli_config:
-      config: |
-        feature bfd
-        interface {{ test_int1 }}
-          no switchport
-        interface {{ test_int2 }}
-          no switchport
-
-  - name: setup initial bfd state
-    nxos_bfd_interfaces:
-      config:
-        - name: "{{ test_int1 }}"
-          bfd: "{{ bfd_disable|default(omit)}}"
-          echo: enable
-        - name: "{{ test_int2 }}"
-          bfd: "{{ bfd_enable|default(omit)}}"
-          echo: disable
-      state: merged
-
-  - name: Overridden
-    nxos_bfd_interfaces: &overridden
-      config:
-        - name: "{{ test_int1 }}"
-          bfd: "{{ bfd_disable|default(omit)}}"
-          echo: disable
-      state: overridden
-    register: result
-
-  - assert:
-      that:
-        - result.changed == true
-        - result.commands[1] == 'bfd echo'     # test_int2 reset to defaults
-        - result.commands[3] == 'no bfd echo'  # test_int1 set to playval
-      msg: "Assert failed. 'result.commands': {{ result.commands }}"
-
-  - name: Idempotence - Overridden
-    nxos_bfd_interfaces: *overridden
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *setup_teardown
diff --git a/test/integration/targets/nxos_bfd_interfaces/tests/cli/replaced.yaml b/test/integration/targets/nxos_bfd_interfaces/tests/cli/replaced.yaml
deleted file mode 100644
index fc48c2d3f7..0000000000
--- a/test/integration/targets/nxos_bfd_interfaces/tests/cli/replaced.yaml
+++ /dev/null
@@ -1,65 +0,0 @@
----
-- debug:
-    msg: "Start nxos_bfd_interfaces replaced integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact:
-    bfd_enable: enable
-    bfd_disable: disable
-  when: platform is not search('N5K|N6K')
-
-- name: setup1
-  cli_config: &setup_teardown
-    config: |
-      no feature bfd
-      default interface {{ test_int1 }}
-
-- block:
-  - name: setup2
-    cli_config:
-      config: |
-        feature bfd
-        interface {{ test_int1 }}
-          no switchport
-
-  - name: setup initial bfd state
-    nxos_bfd_interfaces:
-      config:
-        - name: "{{ test_int1 }}"
-          bfd: "{{ bfd_disable|default(omit)}}"
-          echo: enable
-      state: merged
-
-  - name: Replaced
-    nxos_bfd_interfaces: &replaced
-      config:
-        - name: "{{ test_int1 }}"
-          bfd: "{{ bfd_enable|default(omit)}}"
-          echo: disable
-      state: replaced
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'no bfd echo' in result.commands"
-      msg: "Assert failed. 'result.commands': {{ result.commands }}"
-
-  - assert:
-      that:
-        - "{{ 'bfd' in result.commands }}"
-      msg: "Assert failed. 'result.commands': {{ result.commands }}"
-    when: bfd_enable is defined
-
-  - name: Idempotence - Replaced
-    nxos_bfd_interfaces: *replaced
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *setup_teardown
diff --git a/test/integration/targets/nxos_bgp/defaults/main.yaml b/test/integration/targets/nxos_bgp/defaults/main.yaml
deleted file mode 100644
index 525b7aab90..0000000000
--- a/test/integration/targets/nxos_bgp/defaults/main.yaml
+++ /dev/null
@@ -1,5 +0,0 @@
----
-testcase: "*"
-vrfs:
-  - default
-  - myvrf
diff --git a/test/integration/targets/nxos_bgp/meta/main.yml b/test/integration/targets/nxos_bgp/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_bgp/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_bgp/tasks/cli.yaml b/test/integration/targets/nxos_bgp/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_bgp/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_bgp/tasks/main.yaml b/test/integration/targets/nxos_bgp/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_bgp/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_bgp/tasks/nxapi.yaml b/test/integration/targets/nxos_bgp/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_bgp/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_bgp/tests/common/dis_policy.yaml b/test/integration/targets/nxos_bgp/tests/common/dis_policy.yaml
deleted file mode 100644
index dfb1864697..0000000000
--- a/test/integration/targets/nxos_bgp/tests/common/dis_policy.yaml
+++ /dev/null
@@ -1,77 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_bgp parameter test"
-
-- debug: msg="This bgp_disable_policy is not supported on {{ image_version }}"
-  when: imagetag is search("A8|D1")
-- set_fact: bgp_disable_policy="false"
-- set_fact: bgp_disable_policy="true"
-  when: imagetag is not search("A8|D1")
-
-- name: "Disable feature BGP"
-  nxos_feature:
-    feature: bgp
-    state: disabled
-  ignore_errors: yes
-
-- name: "Enable feature BGP"
-  nxos_feature:
-    feature: bgp
-    state: enabled
-  ignore_errors: yes
-
-- block:
-  - name: "set disable policy"
-    nxos_bgp: &set1
-      asn: 65535
-      disable_policy_batching: true
-      disable_policy_batching_ipv4_prefix_list: v4_p
-      disable_policy_batching_ipv6_prefix_list: v6_p
-    register: result
-    when: bgp_disable_policy
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-    when: bgp_disable_policy
-
-  - name: "Check Idempotence"
-    nxos_bgp: *set1
-    register: result
-    when: bgp_disable_policy
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-    when: bgp_disable_policy
-
-  - name: "reset disable policy"
-    nxos_bgp: &reset1
-      asn: 65535
-      disable_policy_batching: false
-      disable_policy_batching_ipv4_prefix_list: default
-      disable_policy_batching_ipv6_prefix_list: default
-    register: result
-    when: bgp_disable_policy
-
-  - assert: *true
-    when: bgp_disable_policy
-
-  - name: "Check Idempotence"
-    nxos_bgp: *reset1
-    register: result
-    when: bgp_disable_policy
-
-  - assert: *false
-    when: bgp_disable_policy
-
-  rescue:
-  - debug: msg="Tests can fail on A8 or helsinki images"
-
-  always:
-  - name: "Disable feature bgp"
-    nxos_feature:
-      feature: bgp
-      state: disabled
-    ignore_errors: yes
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_bgp parameter test"
diff --git a/test/integration/targets/nxos_bgp/tests/common/hels.yaml b/test/integration/targets/nxos_bgp/tests/common/hels.yaml
deleted file mode 100644
index db4f547769..0000000000
--- a/test/integration/targets/nxos_bgp/tests/common/hels.yaml
+++ /dev/null
@@ -1,95 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_bgp parameter test"
-
-- debug: msg="This test is not supported on {{ image_version }}"
-  when: imagetag is search("D1")
-- set_fact: test_helsinki="false"
-- set_fact: test_helsinki="true"
-  when: imagetag is not search("D1")
-
-- name: "Disable feature BGP"
-  nxos_feature:
-    feature: bgp
-    state: disabled
-  ignore_errors: yes
-  when: test_helsinki
-
-- name: "Enable feature BGP"
-  nxos_feature:
-    feature: bgp
-    state: enabled
-  ignore_errors: yes
-  when: test_helsinki
-
-- block:
-  # these tasks will fail on n7k running helsinki
-  # due to no support
-  - name: "set helsinki"
-    nxos_bgp: &set1
-      asn: 65535
-      vrf: "{{ item }}"
-      graceful_restart_timers_restart: 130
-      graceful_restart_timers_stalepath_time: 310
-      neighbor_down_fib_accelerate: true
-      reconnect_interval: 55
-      timer_bgp_hold: 110
-      timer_bgp_keepalive: 45
-    with_items: "{{ vrfs }}"
-    register: result
-    when: test_helsinki
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-    when: test_helsinki
-
-  - name: "Check Idempotence"
-    nxos_bgp: *set1
-    with_items: "{{ vrfs }}"
-    register: result
-    when: test_helsinki
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-    when: test_helsinki
-
-  - name: "reset helsinki"
-    nxos_bgp: &reset1
-      asn: 65535
-      vrf: "{{ item }}"
-      graceful_restart: true
-      graceful_restart_timers_restart: default
-      graceful_restart_timers_stalepath_time: default
-      neighbor_down_fib_accelerate: false
-      reconnect_interval: default
-      timer_bgp_hold: default
-      timer_bgp_keepalive: default
-    with_items: "{{ vrfs }}"
-    register: result
-    when: test_helsinki
-
-  - assert: *true
-    when: test_helsinki
-
-  - name: "Check Idempotence"
-    nxos_bgp: *reset1
-    with_items: "{{ vrfs }}"
-    register: result
-    when: test_helsinki
-
-  - assert: *false
-    when: test_helsinki
-
-  rescue:
-  - debug: msg="Tests can fail on helsinki images"
-
-  always:
-  - name: "Disable feature bgp"
-    nxos_feature:
-      feature: bgp
-      state: disabled
-    ignore_errors: yes
-    when: test_helsinki
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_bgp parameter test"
diff --git a/test/integration/targets/nxos_bgp/tests/common/isolate.yaml b/test/integration/targets/nxos_bgp/tests/common/isolate.yaml
deleted file mode 100644
index 0d507f6eea..0000000000
--- a/test/integration/targets/nxos_bgp/tests/common/isolate.yaml
+++ /dev/null
@@ -1,76 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_bgp parameter test"
-
-
-- debug: msg="This bgp_isolate is not supported on {{ image_version }}"
-  when: imagetag is search("A8")
-- set_fact: bgp_isolate="false"
-- set_fact: bgp_isolate="true"
-  when: imagetag is not search("A8")
-
-- name: "Disable feature BGP"
-  nxos_feature:
-    feature: bgp
-    state: disabled
-  ignore_errors: yes
-
-- name: "Enable feature BGP"
-  nxos_feature:
-    feature: bgp
-    state: enabled
-  ignore_errors: yes
-
-- block:
-  # these tasks will fail on n3k running A8
-  # due to no support
-  - name: "set isolate"
-    nxos_bgp: &set1
-      asn: 65535
-      isolate: false
-    register: result
-    when: bgp_isolate
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-    when: bgp_isolate
-
-  - name: "Check Idempotence"
-    nxos_bgp: *set1
-    register: result
-    when: bgp_isolate
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-    when: bgp_isolate
-
-  - name: "reset isolate"
-    nxos_bgp: &reset1
-      asn: 65535
-      isolate: true
-    register: result
-    when: bgp_isolate
-
-  - assert: *true
-    when: bgp_isolate
-
-  - name: "Check Idempotence"
-    nxos_bgp: *reset1
-    register: result
-    when: bgp_isolate
-
-  - assert: *false
-    when: bgp_isolate
-
-  rescue:
-  - debug: msg="Tests can fail on A8 images"
-
-  always:
-  - name: "Disable feature bgp"
-    nxos_feature:
-      feature: bgp
-      state: disabled
-    ignore_errors: yes
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_bgp parameter test"
diff --git a/test/integration/targets/nxos_bgp/tests/common/param.yaml b/test/integration/targets/nxos_bgp/tests/common/param.yaml
deleted file mode 100644
index fdcd33c5ce..0000000000
--- a/test/integration/targets/nxos_bgp/tests/common/param.yaml
+++ /dev/null
@@ -1,259 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_bgp parameter test"
-
-- name: "Disable feature BGP"
-  nxos_feature:
-    feature: bgp
-    state: disabled
-  ignore_errors: yes
-
-- name: "Enable feature BGP"
-  nxos_feature:
-    feature: bgp
-    state: enabled
-  ignore_errors: yes
-
-- block:
-  - name: "set multi vrf params"
-    nxos_bgp: &set_multi_vrf
-      asn: 65535
-      vrf: "{{ item }}"
-      router_id: 192.0.2.1
-      bestpath_always_compare_med: true
-      bestpath_aspath_multipath_relax: true
-      bestpath_compare_routerid: true
-      bestpath_cost_community_ignore: true
-      bestpath_med_confed: true
-      bestpath_med_missing_as_worst: true
-      bestpath_med_non_deterministic: true
-# grace_restart is failing with error code -32603 only on CLI transport, nxapi ok 
-#      graceful_restart: false
-      graceful_restart_helper: true
-      log_neighbor_changes: true
-      maxas_limit: 50
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_bgp: *set_multi_vrf
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "reset multi vrf params"
-    nxos_bgp: &reset_multi_vrf
-      asn: 65535
-      vrf: "{{ item }}"
-      bestpath_always_compare_med: false
-      bestpath_aspath_multipath_relax: false
-      bestpath_compare_routerid: false
-      bestpath_cost_community_ignore: false
-      bestpath_med_confed: false
-      bestpath_med_missing_as_worst: false
-      bestpath_med_non_deterministic: false
-      graceful_restart_helper: false
-      log_neighbor_changes: false
-      maxas_limit: default
-      router_id: default
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp: *reset_multi_vrf
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "set clusterid"
-    nxos_bgp: &set_cluster_id
-      asn: 65535
-      vrf: "{{ item }}"
-      cluster_id: 10.0.0.1
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp: *set_cluster_id
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "reset cluster_id"
-    nxos_bgp: &reset_cluster_id
-      asn: 65535
-      vrf: "{{ item }}"
-      cluster_id: default
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp: *reset_cluster_id
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "set confederation"
-    nxos_bgp: &set_confederation
-      asn: 65535
-      confederation_id: 99
-      confederation_peers:
-        - 16
-        - 22
-        - 18
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp: *set_confederation
-    register: result
-
-  - assert: *false
-
-  - name: "reset confederation"
-    nxos_bgp: &reset_confederation
-      asn: 65535
-      confederation_id: default
-      confederation_peers: default
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp: *reset_confederation
-    register: result
-
-  - assert: *false
-
-  - name: "set confederation_local_as"
-    nxos_bgp: &set_confederation_la
-      asn: 65535
-      vrf: myvrf
-      local_as: 33
-      confederation_id: 99
-      confederation_peers:
-        - 16
-        - 22
-        - 18
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp: *set_confederation_la
-    register: result
-
-  - assert: *false
-
-  - name: "reset confederation local_as"
-    nxos_bgp: &reset_confederation_la
-      asn: 65535
-      vrf: myvrf
-      local_as: default
-      confederation_id: default
-      confederation_peers: default
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp: *reset_confederation_la
-    register: result
-
-  - assert: *false
-
-  - name: "set local_as"
-    nxos_bgp: &set_local_as
-      asn: 65535
-      vrf: myvrf
-      local_as: 33
-      confederation_id: 99
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp: *set_local_as
-    register: result
-
-  - assert: *false
-
-  - name: "reset local_as"
-    nxos_bgp: &reset_local_as
-      asn: 65535
-      vrf: myvrf
-      confederation_id: default
-      local_as: default
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp: *reset_local_as
-    register: result
-
-  - assert: *false
-
-  - name: "set default vrf params"
-    nxos_bgp: &set_def_vrf
-      asn: 65535
-      event_history_cli: size_medium
-      event_history_detail: size_large
-      event_history_events: size_medium
-      event_history_periodic: size_small
-      enforce_first_as: false
-      fast_external_fallover: false
-      flush_routes: true
-      shutdown: true
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp: *set_def_vrf
-    register: result
-
-  - assert: *false
-
-  - name: "reset default vrf params"
-    nxos_bgp: &reset_def_vrf
-      asn: 65535
-      event_history_detail: default
-      enforce_first_as: true
-      fast_external_fallover: true
-      flush_routes: false
-      shutdown: false
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp: *reset_def_vrf
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: "Disable feature bgp"
-    nxos_feature:
-      feature: bgp
-      state: disabled
-    ignore_errors: yes
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_bgp parameter test"
diff --git a/test/integration/targets/nxos_bgp/tests/common/sanity.yaml b/test/integration/targets/nxos_bgp/tests/common/sanity.yaml
deleted file mode 100644
index 580588144d..0000000000
--- a/test/integration/targets/nxos_bgp/tests/common/sanity.yaml
+++ /dev/null
@@ -1,132 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_bgp sanity test"
-
-- set_fact: neighbor_down_fib_accelerate="true"
-  when: (not titanium) and ((imagetag != 'N1') and (imagetag != 'D1'))
-
-- set_fact: reconnect_interval="55"
-  when: (not titanium) and ((imagetag != 'N1') and (imagetag != 'D1'))
-
-- set_fact: isolate="false"
-  when: platform is not match("N35")
-
-- name: "Enable feature BGP"
-  nxos_feature:
-    feature: bgp
-    state: enabled
-  ignore_errors: yes
-
-- name: "Setup"
-  nxos_bgp: &remove
-    asn: 65535
-    state: absent
-  ignore_errors: yes
-  register: result
-
-- block:
-  - name: "Configure BGP defaults"
-    nxos_bgp: &configure_default
-      asn: 65535
-      router_id: 192.0.2.1
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_bgp: *configure_default
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "Remove BGP"
-    nxos_bgp: *remove
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp: *remove
-    register: result
-
-  - assert: *false
-
-  - name: "Configure BGP non defaults"
-    nxos_bgp: &configure_non_default
-      asn: 65535
-      router_id: 192.0.2.1
-      bestpath_always_compare_med: true
-      bestpath_aspath_multipath_relax: true
-      bestpath_compare_routerid: true
-      bestpath_cost_community_ignore: true
-      bestpath_med_confed: true
-      bestpath_med_missing_as_worst: true
-      bestpath_med_non_deterministic: true
-      cluster_id: 10.0.0.1
-      confederation_id: 99
-      disable_policy_batching: true
-      enforce_first_as: false
-      fast_external_fallover: false
-      flush_routes: true
-      graceful_restart_helper: true
-      graceful_restart_timers_restart: 130
-      graceful_restart_timers_stalepath_time: 310
-      isolate: "{{isolate|default(omit)}}"
-      log_neighbor_changes: true
-      maxas_limit: 50
-      neighbor_down_fib_accelerate: "{{neighbor_down_fib_accelerate|default(omit)}}"
-      reconnect_interval: "{{reconnect_interval|default(omit)}}"
-      shutdown: true
-      timer_bestpath_limit: 255
-      timer_bgp_hold: 110
-      timer_bgp_keepalive: 45
-      event_history_cli: size_medium
-      event_history_detail: size_large
-      event_history_events: size_medium
-      event_history_periodic: size_small
-      suppress_fib_pending: true
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp: *configure_non_default
-    register: result
-
-  - assert: *false
-
-  - name: "Remove BGP"
-    nxos_bgp: *remove
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp: *remove
-    register: result
-
-  - assert: *false
-
-  - name: "Disable feature bgp"
-    nxos_feature:
-      feature: bgp
-      state: disabled
-
-  rescue:
-  - name: "Cleanup BGP"
-    nxos_bgp: *remove
-    ignore_errors: yes
-
-  - name: "Disable feature bgp"
-    nxos_feature:
-      feature: bgp
-      state: disabled
-    ignore_errors: yes
-
-  always:
-  - debug: msg="END connection={{ ansible_connection }} nxos_bgp sanity test"
diff --git a/test/integration/targets/nxos_bgp/tests/common/supp_fib.yaml b/test/integration/targets/nxos_bgp/tests/common/supp_fib.yaml
deleted file mode 100644
index d9fdbdb3ef..0000000000
--- a/test/integration/targets/nxos_bgp/tests/common/supp_fib.yaml
+++ /dev/null
@@ -1,113 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_bgp parameter test"
-
-- set_fact: bgp_best_path_limit="false"
-- set_fact: bgp_best_path_limit="true"
-  when: imagetag is not search("I2")
-
-- set_fact: bgp_suppress_fib_supported="false"
-- set_fact: bgp_suppress_fib_supported="true"
-  when: imagetag is not search("A8|D1|I2|I4")
-
-- name: "Disable feature BGP"
-  nxos_feature:
-    feature: bgp
-    state: disabled
-  ignore_errors: yes
-
-- name: "Enable feature BGP"
-  nxos_feature:
-    feature: bgp
-    state: enabled
-  ignore_errors: yes
-
-- block:
-  # this task will fail on n9k running I2
-  # due to no support
-  - name: "set bestpath limit"
-    nxos_bgp: &set1
-      asn: 65535
-      vrf: "{{ item }}"
-      timer_bestpath_limit: 255
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_bgp: *set1
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "reset bestpath limit"
-    nxos_bgp: &reset1
-      asn: 65535
-      vrf: "{{ item }}"
-      timer_bestpath_limit: default
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp: *reset1
-    with_items: "{{ vrfs }}"
-    register: result
-    when: bgp_best_path_limit
-
-  - assert: *false
-    when: bgp_best_path_limit
-
-  # Property does not nvgen on some images
-  # still try and set it but don't check idempotence
-  - name: "set suppress fib"
-    nxos_bgp: &set2
-      asn: 65535
-      suppress_fib_pending: false
-    register: result
-
-  - assert: *true
-    when: bgp_suppress_fib_supported
-
-  - name: "Check Idempotence"
-    nxos_bgp: *set2
-    register: result
-    when: bgp_suppress_fib_supported
-
-  - assert: *false
-    when: bgp_suppress_fib_supported
-
-  - name: "reset suppress fib"
-    nxos_bgp: &reset2
-      asn: 65535
-      suppress_fib_pending: true
-    register: result
-
-  - assert: *true
-    when: bgp_suppress_fib_supported
-
-  - name: "Check Idempotence"
-    nxos_bgp: *reset2
-    register: result
-    when: bgp_suppress_fib_supported
-
-  - assert: *false
-    when: bgp_suppress_fib_supported
-
-  rescue:
-  - debug: msg="Tests can fail on I2/I4/A8/Fretta or helsinki images"
-
-  always:
-  - name: "Disable feature bgp"
-    nxos_feature:
-      feature: bgp
-      state: disabled
-    ignore_errors: yes
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_bgp parameter test"
diff --git a/test/integration/targets/nxos_bgp_af/defaults/main.yaml b/test/integration/targets/nxos_bgp_af/defaults/main.yaml
deleted file mode 100644
index 525b7aab90..0000000000
--- a/test/integration/targets/nxos_bgp_af/defaults/main.yaml
+++ /dev/null
@@ -1,5 +0,0 @@
----
-testcase: "*"
-vrfs:
-  - default
-  - myvrf
diff --git a/test/integration/targets/nxos_bgp_af/meta/main.yml b/test/integration/targets/nxos_bgp_af/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_bgp_af/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_bgp_af/tasks/cli.yaml b/test/integration/targets/nxos_bgp_af/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_bgp_af/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_bgp_af/tasks/main.yaml b/test/integration/targets/nxos_bgp_af/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_bgp_af/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_bgp_af/tasks/nxapi.yaml b/test/integration/targets/nxos_bgp_af/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_bgp_af/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_bgp_af/tests/common/sanity.yaml b/test/integration/targets/nxos_bgp_af/tests/common/sanity.yaml
deleted file mode 100644
index 00af4422e5..0000000000
--- a/test/integration/targets/nxos_bgp_af/tests/common/sanity.yaml
+++ /dev/null
@@ -1,320 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_bgp_af sanity test"
-
-- set_fact: advertise_l2vpn_evpn="true"
-  when: platform is search('N9K')
-
-- name: "Enable feature BGP"
-  nxos_feature:
-    feature: bgp
-    state: enabled
-  ignore_errors: yes
-
-- name: "Enable feature nv overlay"
-  nxos_feature:
-    feature: nv overlay
-    state: enabled
-  ignore_errors: yes
-
-- name: "Setup"
-  nxos_bgp: &remove
-    asn: 65535
-    state: absent
-  ignore_errors: yes
-
-- block:
-  - name: "Enable nv overlay evpn"
-    nxos_config:
-      lines:
-        - nv overlay evpn
-    when: platform is search('N9K')
-
-  - name: "Configure BGP_AF 1"
-    nxos_bgp_af: &configure1
-      asn: 65535
-      vrf: testing
-      afi: ipv4
-      safi: unicast
-      advertise_l2vpn_evpn: "{{advertise_l2vpn_evpn|default(omit)}}"
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_bgp_af: *configure1
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "Remove BGP"
-    nxos_bgp_af: &remove_af
-      asn: 65535
-      vrf: testing
-      afi: ipv4
-      safi: unicast
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Configure BGP_AF 2"
-    nxos_bgp_af: &configure2
-      asn: 65535
-      vrf: "{{ item }}"
-      afi: ipv4
-      safi: unicast
-      dampening_state: True
-      additional_paths_install: true
-      additional_paths_receive: true
-      additional_paths_selection: RouteMap
-      additional_paths_send: true
-      client_to_client: False
-      default_information_originate: true
-      state: present
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_af: *configure2
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Configure BGP_AF def2"
-    nxos_bgp_af: &configuredef2
-      asn: 65535
-      vrf: "{{ item }}"
-      afi: ipv4
-      safi: unicast
-      dampening_state: False
-      additional_paths_install: False
-      additional_paths_receive: False
-      additional_paths_selection: default
-      additional_paths_send: False
-      client_to_client: True
-      default_information_originate: False
-      state: present
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_af: *configuredef2
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Remove BGP"
-    nxos_bgp_af: &remove_af_vrf
-      asn: 65535
-      vrf: "{{ item }}"
-      afi: ipv4
-      safi: unicast
-      state: absent
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Configure BGP_AF 3"
-    nxos_bgp_af: &configure3
-      asn: 65535
-      vrf: "{{ item }}"
-      afi: ipv4
-      safi: unicast
-      dampening_routemap: 'abcd'
-      default_metric: 50
-      distance_ebgp: 30
-      distance_ibgp: 60
-      distance_local: 90
-      maximum_paths: 9
-      maximum_paths_ibgp: 9
-      next_hop_route_map: RouteMap
-      suppress_inactive: true
-      table_map: RouteMap
-      table_map_filter: true
-      state: present
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_af: *configure3
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Configure BGP_AF def3"
-    nxos_bgp_af: &configuredef3
-      asn: 65535
-      vrf: "{{ item }}"
-      afi: ipv4
-      safi: unicast
-      dampening_routemap: default
-      default_metric: default
-      distance_ebgp: default
-      distance_ibgp: default
-      distance_local: default
-      maximum_paths: default
-      maximum_paths_ibgp: default
-      next_hop_route_map: default
-      suppress_inactive: False
-      table_map: default
-      table_map_filter: False
-      state: present
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_af: *configuredef3
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Remove BGP"
-    nxos_bgp_af: *remove_af_vrf
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Configure BGP_AF 4"
-    nxos_bgp_af: &configure4
-      asn: 65535
-      vrf: "{{ item }}"
-      afi: ipv4
-      safi: unicast
-      dampen_igp_metric: 200
-      dampening_half_time: 1
-      dampening_max_suppress_time: 4
-      dampening_reuse_time: 2
-      dampening_suppress_time: 3
-      inject_map: [['lax_inject_map', 'lax_exist_map'], ['nyc_inject_map', 'nyc_exist_map', 'copy-attributes'], ['fsd_inject_map', 'fsd_exist_map']]
-      networks: [['10.0.0.0/16', 'routemap_LA'], ['192.168.1.1/32', 'Chicago'], ['192.168.2.0/24'], ['192.168.3.0/24', 'routemap_NYC']]
-      redistribute: [['direct', 'rm_direct'], ['lisp', 'rm_lisp']]
-      state: present
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_af: *configure4
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Configure BGP_AF 5"
-    nxos_bgp_af: &configure5
-      asn: 65535
-      vrf: "{{ item }}"
-      afi: ipv4
-      safi: unicast
-      dampen_igp_metric: 300
-      dampening_half_time: 10
-      dampening_max_suppress_time: 40
-      dampening_reuse_time: 20
-      dampening_suppress_time: 30
-      inject_map: [['fsd_inject_map', 'fsd_exist_map']]
-      networks: [['192.168.2.0/24']]
-      redistribute: [['lisp', 'rm_lisp']]
-      state: present
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_af: *configure5
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Configure BGP_AF def5"
-    nxos_bgp_af: &configuredef5
-      asn: 65535
-      vrf: "{{ item }}"
-      afi: ipv4
-      safi: unicast
-      dampen_igp_metric: default
-      dampening_half_time: default
-      dampening_max_suppress_time: default
-      dampening_reuse_time: default
-      dampening_suppress_time: default
-      inject_map: default
-      networks: default
-      redistribute: default
-      state: present
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_af: *configuredef5
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Remove BGP"
-    nxos_bgp_af: *remove_af_vrf
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_af: *remove_af_vrf
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  rescue:
-  - name: "Cleanup BGP"
-    nxos_bgp: *remove
-    ignore_errors: yes
-
-  always:
-  - name: "Disable feature bgp"
-    nxos_feature: &disable_bgp
-      feature: bgp
-      state: disabled
-
-  - name: "Disable feature nv overlay"
-    nxos_feature: &disable_nvoverlay
-      feature: nv overlay
-      state: disabled
-    ignore_errors: yes
-
-  # Some platforms will timeout if the
-  # 'no nv overlay evpn' command is sent
-  # too quickly following bgp disablement.
-  - pause:
-      seconds: 5
-
-  - name: "Remove nv overlay evpn"
-    nxos_config:
-      lines:
-        - no nv overlay evpn
-    when: platform is search('N9K')
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_bgp_af sanity test"
diff --git a/test/integration/targets/nxos_bgp_neighbor/defaults/main.yaml b/test/integration/targets/nxos_bgp_neighbor/defaults/main.yaml
deleted file mode 100644
index 525b7aab90..0000000000
--- a/test/integration/targets/nxos_bgp_neighbor/defaults/main.yaml
+++ /dev/null
@@ -1,5 +0,0 @@
----
-testcase: "*"
-vrfs:
-  - default
-  - myvrf
diff --git a/test/integration/targets/nxos_bgp_neighbor/meta/main.yml b/test/integration/targets/nxos_bgp_neighbor/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_bgp_neighbor/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_bgp_neighbor/tasks/cli.yaml b/test/integration/targets/nxos_bgp_neighbor/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_bgp_neighbor/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_bgp_neighbor/tasks/main.yaml b/test/integration/targets/nxos_bgp_neighbor/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_bgp_neighbor/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_bgp_neighbor/tasks/nxapi.yaml b/test/integration/targets/nxos_bgp_neighbor/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_bgp_neighbor/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_bgp_neighbor/tests/common/sanity.yaml b/test/integration/targets/nxos_bgp_neighbor/tests/common/sanity.yaml
deleted file mode 100644
index c8960ca95d..0000000000
--- a/test/integration/targets/nxos_bgp_neighbor/tests/common/sanity.yaml
+++ /dev/null
@@ -1,338 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_bgp_neighbor sanity test"
-
-- set_fact: intname="{{ nxos_int1 }}"
-
-- set_fact: log_neighbor_changese="enable"
-  when: (imagetag and (imagetag is version_compare('D1', 'ne')) and (imagetag is version_compare('N1', 'ne')))
-- set_fact: log_neighbor_changesd="disable"
-  when: (imagetag and (imagetag is version_compare('D1', 'ne')) and (imagetag is version_compare('N1', 'ne')))
-
-- debug:
-    var: titanium
-
-- set_fact: remove_private_asa="all"
-  when: not titanium
-- set_fact: remove_private_asr="replace-as"
-  when: not titanium
-
-- name: "Setup: Disable features"
-  nxos_feature:
-    feature: "{{ item }}"
-    state: disabled
-  loop: ['bgp', 'bfd']
-  ignore_errors: yes
-
-- name: "Setup: Enable features"
-  nxos_feature:
-    feature: "{{ item }}"
-    state: enabled
-  loop: ['bgp', 'bfd']
-
-- block:
-  - name: "Configure BGP neighbor1"
-    nxos_bgp_neighbor: &configure1
-      asn: 65535
-      neighbor: 192.0.2.3/32
-      vrf: "{{ item }}"
-      connected_check: true
-      capability_negotiation: true
-      dynamic_capability: true
-      ebgp_multihop: 2
-      low_memory_exempt: true
-      maximum_peers: 10
-      suppress_4_byte_as: true
-      timers_keepalive: 90
-      timers_holdtime: 270
-      log_neighbor_changes: "{{log_neighbor_changese|default(omit)}}"
-      local_as: 22.33
-      remote_as: 33.22
-      description: "just a description"
-      update_source: "{{ intname.capitalize() }}"
-      shutdown: true
-      state: present
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor: *configure1
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "Configure BGP neighbor2"
-    nxos_bgp_neighbor: &configure2
-      asn: 65535
-      neighbor: 192.0.2.3/32
-      vrf: "{{ item }}"
-      connected_check: False
-      capability_negotiation: False
-      dynamic_capability: False
-      ebgp_multihop: default
-      low_memory_exempt: False
-      maximum_peers: default
-      suppress_4_byte_as: False
-      timers_keepalive: default
-      timers_holdtime: default
-      log_neighbor_changes: "{{log_neighbor_changesd|default(omit)}}"
-      local_as: default
-      remote_as: default
-      description: default
-      update_source: default
-      shutdown: False
-      state: present
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor: *configure2
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Remove BGP"
-    nxos_bgp_neighbor: &remove
-      asn: 65535
-      neighbor: 192.0.2.3/32
-      vrf: "{{ item }}"
-      state: absent
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor: *remove
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Configure BGP neighbor3"
-    nxos_bgp_neighbor: &configure3
-      asn: 65535
-      neighbor: 192.0.2.3/32
-      vrf: "{{ item }}"
-      description: "tested by ansible"
-      remove_private_as: "{{remove_private_asa|default(omit)}}"
-      state: present
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor: *configure3
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Configure BGP neighbor4"
-    nxos_bgp_neighbor: &configure4
-      asn: 65535
-      neighbor: 192.0.2.3/32
-      vrf: "{{ item }}"
-      description: "tested by ansible"
-      remove_private_as: "{{remove_private_asr|default(omit)}}"
-      state: present
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor: *configure4
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Remove BGP"
-    nxos_bgp_neighbor: *remove
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Configure BGP neighbor 3des password"
-    nxos_bgp_neighbor: &configure_3des_password
-      asn: 65535
-      neighbor: 192.0.2.3/32
-      vrf: "{{ item }}"
-      remote_as: 30
-      pwd: '386c0565965f89de'
-      pwd_type: 3des
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor: *configure_3des_password
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Remove BGP"
-    nxos_bgp_neighbor: *remove
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Configure BGP neighbor type 7 password"
-    nxos_bgp_neighbor: &configure_type7_password
-      asn: 65535
-      neighbor: 192.0.2.3/32
-      vrf: "{{ item }}"
-      remote_as: 30
-      pwd: '386c0565965f89de'
-      pwd_type: cisco_type_7
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor: *configure_type7_password
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Remove BGP neighbor password"
-    nxos_bgp_neighbor: &remove_password
-      asn: 65535
-      neighbor: 192.0.2.3/32
-      vrf: "{{ item }}"
-      remote_as: 30
-      pwd: default
-      pwd_type: default
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor: *remove_password
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Remove BGP"
-    nxos_bgp_neighbor: *remove
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Configure BGP neighbor transport type passive"
-    nxos_bgp_neighbor: &configure_transport_passive
-      asn: 65535
-      neighbor: 192.0.2.3
-      vrf: "{{ item }}"
-      remote_as: 30
-      transport_passive_only: true
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor: *configure_transport_passive
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Configure BGP neighbor transport type default"
-    nxos_bgp_neighbor: &configure_transport_default
-      asn: 65535
-      neighbor: 192.0.2.3
-      vrf: "{{ item }}"
-      remote_as: 30
-      transport_passive_only: false
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor: *configure_transport_default
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Remove BGP"
-    nxos_bgp_neighbor: &removenp
-      asn: 65535
-      neighbor: 192.0.2.3
-      vrf: "{{ item }}"
-      state: absent
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor: *removenp
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: "Configure BFD enable"
-    nxos_bgp_neighbor: &bfd_enable
-      asn: 65535
-      neighbor: 192.168.1.1
-      bfd: enable
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: Check BFD enable Idempotence
-    nxos_bgp_neighbor: *bfd_enable
-    register: result
-
-  - assert: *false
-
-  - name: Configure BFD disable Idempotence
-    nxos_bgp_neighbor: &bfd_disable
-      asn: 65535
-      neighbor: 192.168.1.1
-      bfd: disable
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: Check BFD disable Idempotence
-    nxos_bgp_neighbor: *bfd_disable
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: "Teardown: Disable features"
-    nxos_feature:
-      feature: "{{ item }}"
-      state: disabled
-    loop: ['bgp', 'bfd']
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_bgp_neighbor sanity test"
diff --git a/test/integration/targets/nxos_bgp_neighbor_af/defaults/main.yaml b/test/integration/targets/nxos_bgp_neighbor_af/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_bgp_neighbor_af/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_bgp_neighbor_af/meta/main.yml b/test/integration/targets/nxos_bgp_neighbor_af/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_bgp_neighbor_af/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_bgp_neighbor_af/tasks/cli.yaml b/test/integration/targets/nxos_bgp_neighbor_af/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_bgp_neighbor_af/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_bgp_neighbor_af/tasks/main.yaml b/test/integration/targets/nxos_bgp_neighbor_af/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_bgp_neighbor_af/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_bgp_neighbor_af/tasks/nxapi.yaml b/test/integration/targets/nxos_bgp_neighbor_af/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_bgp_neighbor_af/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_bgp_neighbor_af/tests/common/sanity.yaml b/test/integration/targets/nxos_bgp_neighbor_af/tests/common/sanity.yaml
deleted file mode 100644
index 19594e7321..0000000000
--- a/test/integration/targets/nxos_bgp_neighbor_af/tests/common/sanity.yaml
+++ /dev/null
@@ -1,288 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_bgp_neighbor_af sanity test"
-
-- set_fact: soft_reconfiguration_ina="always"
-  when: imagetag is not search("D1|N1")
-
-- name: "Disable feature BGP"
-  nxos_feature: &disable_bgp
-    feature: bgp
-    state: disabled
-  ignore_errors: yes
-
-- name: "Enable feature BGP"
-  nxos_feature:
-    feature: bgp
-    state: enabled
-  ignore_errors: yes
-
-- block:
-  - name: "Configure BGP neighbor address-family"
-    nxos_bgp_neighbor_af: &configure1
-      asn: 65535
-      neighbor: '192.0.2.3'
-      afi: ipv4
-      safi: unicast
-      additional_paths_receive: 'enable'
-      additional_paths_send: 'enable'
-      advertise_map_exist: ['ansible_rm', 'my_exist_map']
-      allowas_in: True
-      default_originate: True
-      disable_peer_as_check: True
-      filter_list_in: 'my_filter_list_in'
-      filter_list_out: 'my_filter_list_out'
-      max_prefix_limit: 100
-      max_prefix_threshold: 50
-      max_prefix_warning: 'true'
-      next_hop_self: True
-      next_hop_third_party: False
-      prefix_list_in: 'pfx_in'
-      prefix_list_out: 'pfx_out'
-      send_community: 'both'
-      soft_reconfiguration_in: 'enable'
-      suppress_inactive: True
-      unsuppress_map: 'unsup_map'
-      weight: '30'
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor_af: *configure1
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "Configure BGP neighbor address-family def1"
-    nxos_bgp_neighbor_af: &configure_def1
-      asn: 65535
-      neighbor: '192.0.2.3'
-      afi: ipv4
-      safi: unicast
-      additional_paths_receive: 'inherit'
-      additional_paths_send: 'inherit'
-      advertise_map_exist: default
-      allowas_in: False
-      default_originate: False
-      disable_peer_as_check: False
-      filter_list_in: default
-      filter_list_out: default
-      max_prefix_limit: default
-      max_prefix_threshold: default
-      max_prefix_warning: False
-      next_hop_self: False
-      next_hop_third_party: False
-      prefix_list_in: default
-      prefix_list_out: default
-      send_community: 'none'
-      soft_reconfiguration_in: 'inherit'
-      suppress_inactive: False
-      unsuppress_map: default
-      weight: default
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor_af: *configure_def1
-    register: result
-
-  - assert: *false
-
-  - name: "Setup: Remove BGP config"
-    nxos_bgp_neighbor_af: &removenaf
-      asn: 65535
-      neighbor: '192.0.2.3'
-      afi: ipv4
-      safi: unicast
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor_af: *removenaf
-    register: result
-
-  - assert: *false
-
-  - name: "Configure BGP neighbor address-family"
-    nxos_bgp_neighbor_af: &configure2
-      asn: 65535
-      neighbor: '192.0.2.3'
-      afi: ipv4
-      safi: unicast
-      allowas_in_max: '5'
-      advertise_map_non_exist: ['ansible_rm', 'my_non_exist_map']
-      default_originate_route_map: 'my_route_map'
-      max_prefix_limit: 100
-      max_prefix_interval: 30
-      max_prefix_threshold: 50
-      route_map_in: 'rm_in'
-      route_map_out: 'rm_out'
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor_af: *configure2
-    register: result
-
-  - assert: *false
-
-  - name: "Configure BGP neighbor address-family def2"
-    nxos_bgp_neighbor_af: &configure_def2
-      asn: 65535
-      neighbor: '192.0.2.3'
-      afi: ipv4
-      safi: unicast
-      allowas_in_max: default
-      advertise_map_non_exist: default
-      default_originate_route_map: default
-      max_prefix_limit: default
-      max_prefix_interval: default
-      max_prefix_threshold: default
-      route_map_in: default
-      route_map_out: default
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor_af: *configure_def2
-    register: result
-
-  - assert: *false
-
-  - name: "Setup: Remove BGP config"
-    nxos_bgp_neighbor_af: *removenaf
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor_af: *removenaf
-    register: result
-
-  - assert: *false
-
-  - name: "Configure eBGP"
-    nxos_bgp_neighbor:
-      asn: 65535
-      vrf: 'blue'
-      neighbor: '192.0.2.3'
-      remote_as: 2
-
-  - name: "Configure BGP neighbor 3"
-    nxos_bgp_neighbor_af: &configure3
-      asn: 65535
-      vrf: 'blue'
-      neighbor: '192.0.2.3'
-      afi: ipv4
-      safi: unicast
-      additional_paths_receive: 'disable'
-      additional_paths_send: 'disable'
-      as_override: 'true'
-      send_community: 'standard'
-      soft_reconfiguration_in: "{{soft_reconfiguration_ina|default(omit)}}"
-      soo: '3:3'
-      next_hop_third_party: True
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor_af: *configure3
-    register: result
-
-  - assert: *false
-
-  - name: "Configure BGP neighbor def3"
-    nxos_bgp_neighbor_af: &configure_def3
-      asn: 65535
-      vrf: 'blue'
-      neighbor: '192.0.2.3'
-      afi: ipv4
-      safi: unicast
-      additional_paths_receive: 'inherit'
-      additional_paths_send: 'inherit'
-      as_override: False
-      send_community: default
-      soo: default
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor_af: *configure_def3
-    register: result
-
-  - assert: *false
-
-  - name: "Setup: Remove BGP config"
-    nxos_bgp: &remove
-      asn: 65535
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Configure BGP neighbor af route_reflector_client"
-    nxos_bgp_neighbor:
-      asn: 65535
-      neighbor: '192.0.2.2'
-      remote_as: 65535
-
-  - name: "Configure BGP neighbor 4"
-    nxos_bgp_neighbor_af: &configure4
-      asn: 65535
-      neighbor: '192.0.2.2'
-      afi: ipv4
-      safi: unicast
-      route_reflector_client: 'true'
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor_af: *configure4
-    register: result
-
-  - assert: *false
-
-  - name: "Configure BGP neighbor def4"
-    nxos_bgp_neighbor_af: &configure_def4
-      asn: 65535
-      neighbor: '192.0.2.2'
-      afi: ipv4
-      safi: unicast
-      route_reflector_client: False
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_bgp_neighbor_af: *configure_def4
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: "Cleanup BGP"
-    nxos_bgp: *remove
-    ignore_errors: yes
-
-  - name: "Disable feature bgp"
-    nxos_feature: *disable_bgp
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_bgp_neighbor_af sanity test"
diff --git a/test/integration/targets/nxos_command/defaults/main.yaml b/test/integration/targets/nxos_command/defaults/main.yaml
deleted file mode 100644
index 9ef5ba5165..0000000000
--- a/test/integration/targets/nxos_command/defaults/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-testcase: "*"
-test_items: []
diff --git a/test/integration/targets/nxos_command/meta/main.yml b/test/integration/targets/nxos_command/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_command/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_command/tasks/cli.yaml b/test/integration/targets/nxos_command/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_command/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_command/tasks/main.yaml b/test/integration/targets/nxos_command/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_command/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_command/tasks/nxapi.yaml b/test/integration/targets/nxos_command/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_command/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_command/tests/cli/cli_command.yaml b/test/integration/targets/nxos_command/tests/cli/cli_command.yaml
deleted file mode 100644
index 3fd3807e13..0000000000
--- a/test/integration/targets/nxos_command/tests/cli/cli_command.yaml
+++ /dev/null
@@ -1,26 +0,0 @@
----
-- debug:
-    msg: "START cli/cli_command.yaml on connection={{ ansible_connection }}"
-
-- name: get output for single command
-  cli_command:
-    command: show version
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-      - "result.stdout is defined"
-
-- name: send invalid command
-  cli_command:
-    command: 'show foo'
-  register: result
-  ignore_errors: yes
-
-- assert:
-    that:
-      - "result.failed == true"
-      - "result.msg is defined"
-
-- debug: msg="END cli/cli_command.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_command/tests/cli/contains.yaml b/test/integration/targets/nxos_command/tests/cli/contains.yaml
deleted file mode 100644
index bb6868af30..0000000000
--- a/test/integration/targets/nxos_command/tests/cli/contains.yaml
+++ /dev/null
@@ -1,18 +0,0 @@
----
-- debug: msg="START common/contains.yaml on connection={{ ansible_connection }}"
-
-- name: test contains operator
-  nxos_command:
-    commands:
-      - show version
-      - show interface mgmt0 | json
-    wait_for:
-      - "result[0] contains NX-OS"
-      - "result[1].TABLE_interface.ROW_interface.interface contains mgmt"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- debug: msg="END common/contains.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_command/tests/cli/sanity.yaml b/test/integration/targets/nxos_command/tests/cli/sanity.yaml
deleted file mode 100644
index 8bc723d687..0000000000
--- a/test/integration/targets/nxos_command/tests/cli/sanity.yaml
+++ /dev/null
@@ -1,66 +0,0 @@
----
-- debug: msg="START cli/sanity.yaml on connection={{ ansible_connection }}"
-
-- name: "Disable feature BGP"
-  nxos_feature:
-    feature: bgp
-    state: disabled
-
-- block:
-  - name: "Run show running-config bgp - should fail"
-    nxos_command:
-      commands:
-        - sh running-config bgp
-    ignore_errors: yes
-    register: result
-
-  - assert: &fail
-      that:
-        - "result.failed == true"
-
-  - name: "Enable feature BGP"
-    nxos_feature:
-      feature: bgp
-      state: enabled
-
-  - name: "Configure BGP defaults"
-    nxos_bgp: &configure_default
-      asn: 65535
-      router_id: 192.0.2.1
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Run show running-config bgp - should pass"
-    nxos_command:
-      commands:
-        - sh running-config bgp
-    register: result
-
-  - assert:
-      that:
-        - "result.failed == false"
-        - "'65535' in result.stdout[0]"
-
-  - name: "Run an invalid command - should fail"
-    nxos_command:
-      commands:
-        - show interface bief
-    ignore_errors: yes
-    register: result
-
-  - assert: *fail
-
-  rescue:
-  - debug: msg="nxos_command sanity test failure detected"
-
-  always:
-  - name: "Disable feature bgp"
-    nxos_feature:
-      feature: bgp
-      state: disabled
-
-- debug: msg="END cli/sanity.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_command/tests/common/bad_operator.yaml b/test/integration/targets/nxos_command/tests/common/bad_operator.yaml
deleted file mode 100644
index 6a3659093f..0000000000
--- a/test/integration/targets/nxos_command/tests/common/bad_operator.yaml
+++ /dev/null
@@ -1,19 +0,0 @@
----
-- debug: msg="START common/bad_operator.yaml on connection={{ ansible_connection }}"
-
-- name: test bad operator
-  nxos_command:
-    commands:
-      - show version
-      - show interface mgmt0 | json
-    wait_for:
-      - "result[1].TABLE_interface.ROW_interface.state foo up"
-  register: result
-  ignore_errors: yes
-
-- assert:
-    that:
-      - "result.failed == true"
-      - "result.msg is defined"
-
-- debug: msg="END common/bad_operator.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_command/tests/common/equal.yaml b/test/integration/targets/nxos_command/tests/common/equal.yaml
deleted file mode 100644
index a81eb3c5c7..0000000000
--- a/test/integration/targets/nxos_command/tests/common/equal.yaml
+++ /dev/null
@@ -1,30 +0,0 @@
----
-- debug: msg="START common/equal.yaml on connection={{ ansible_connection }}"
-
-- name: test eq operator
-  nxos_command:
-    commands:
-      - show version
-      - show interface mgmt0 | json
-    wait_for:
-      - "result[1].TABLE_interface.ROW_interface.state eq up"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: test == operator
-  nxos_command:
-    commands:
-      - show version
-      - show interface mgmt0 | json
-    wait_for:
-      - "result[1].TABLE_interface.ROW_interface.state == up"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- debug: msg="END common/equal.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_command/tests/common/greaterthan.yaml b/test/integration/targets/nxos_command/tests/common/greaterthan.yaml
deleted file mode 100644
index 0b8db6a90b..0000000000
--- a/test/integration/targets/nxos_command/tests/common/greaterthan.yaml
+++ /dev/null
@@ -1,30 +0,0 @@
----
-- debug: msg="START common/greaterthan.yaml on connection={{ ansible_connection }}"
-
-- name: test gt operator
-  nxos_command:
-    commands:
-      - show version
-      - show interface mgmt0 | json
-    wait_for:
-      - "result[1].TABLE_interface.ROW_interface.eth_ip_mask gt 0"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: test > operator
-  nxos_command:
-    commands:
-      - show version
-      - show interface mgmt0 | json
-    wait_for:
-      - "result[1].TABLE_interface.ROW_interface.eth_ip_mask > 0"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- debug: msg="END common/greaterthan.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_command/tests/common/greaterthanorequal.yaml b/test/integration/targets/nxos_command/tests/common/greaterthanorequal.yaml
deleted file mode 100644
index 3e0c27ca73..0000000000
--- a/test/integration/targets/nxos_command/tests/common/greaterthanorequal.yaml
+++ /dev/null
@@ -1,30 +0,0 @@
----
-- debug: msg="START common/greaterthanorequal.yaml on connection={{ ansible_connection }}"
-
-- name: test ge operator
-  nxos_command:
-    commands:
-      - show version
-      - show interface mgmt0 | json
-    wait_for:
-      - "result[1].TABLE_interface.ROW_interface.eth_ip_mask ge 0"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: test >= operator
-  nxos_command:
-    commands:
-      - show version
-      - show interface mgmt0 | json
-    wait_for:
-      - "result[1].TABLE_interface.ROW_interface.eth_ip_mask >= 0"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- debug: msg="END common/greaterthanorequal.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_command/tests/common/invalid.yaml b/test/integration/targets/nxos_command/tests/common/invalid.yaml
deleted file mode 100644
index 6532a5eae0..0000000000
--- a/test/integration/targets/nxos_command/tests/common/invalid.yaml
+++ /dev/null
@@ -1,26 +0,0 @@
----
-- debug: msg="START common/invalid.yaml on connection={{ ansible_connection }}"
-
-- name: run invalid command
-  nxos_command:
-    commands: ['show foo']
-  register: result
-  ignore_errors: yes
-
-- assert:
-    that:
-      - "result.failed == true"
-
-- name: run commands that include invalid command
-  nxos_command:
-    commands:
-      - show version
-      - show foo
-  register: result
-  ignore_errors: yes
-
-- assert:
-    that:
-      - "result.failed == true"
-
-- debug: msg="END common/invalid.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_command/tests/common/lessthan.yaml b/test/integration/targets/nxos_command/tests/common/lessthan.yaml
deleted file mode 100644
index 7d9509b649..0000000000
--- a/test/integration/targets/nxos_command/tests/common/lessthan.yaml
+++ /dev/null
@@ -1,30 +0,0 @@
----
-- debug: msg="START common/lessthan.yaml on connection={{ ansible_connection }}"
-
-- name: test lt operator
-  nxos_command:
-    commands:
-      - show version
-      - show interface mgmt0 | json
-    wait_for:
-      - "result[1].TABLE_interface.ROW_interface.eth_ip_mask lt 33"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: test < operator
-  nxos_command:
-    commands:
-      - show version
-      - show interface mgmt0 | json
-    wait_for:
-      - "result[1].TABLE_interface.ROW_interface.eth_ip_mask lt 33"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- debug: msg="END common/lessthan.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_command/tests/common/lessthanorequal.yaml b/test/integration/targets/nxos_command/tests/common/lessthanorequal.yaml
deleted file mode 100644
index 70d0f63662..0000000000
--- a/test/integration/targets/nxos_command/tests/common/lessthanorequal.yaml
+++ /dev/null
@@ -1,30 +0,0 @@
----
-- debug: msg="START common/lessthanorequal.yaml on connection={{ ansible_connection }}"
-
-- name: test le operator
-  nxos_command:
-    commands:
-      - show version
-      - show interface mgmt0 | json
-    wait_for:
-      - "result[1].TABLE_interface.ROW_interface.eth_ip_mask le 32"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: test <= operator
-  nxos_command:
-    commands:
-      - show version
-      - show interface mgmt0 | json
-    wait_for:
-      - "result[1].TABLE_interface.ROW_interface.eth_ip_mask <= 32"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- debug: msg="END common/lessthanorequal.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_command/tests/common/not_comparison_operator.yaml b/test/integration/targets/nxos_command/tests/common/not_comparison_operator.yaml
deleted file mode 100644
index b24ffb1c65..0000000000
--- a/test/integration/targets/nxos_command/tests/common/not_comparison_operator.yaml
+++ /dev/null
@@ -1,18 +0,0 @@
----
-- debug: msg="START common/not_comparison_operator.yaml on connection={{ ansible_connection }}"
-
-- name: test 'not' keyword in wait_for
-  nxos_command:
-    commands:
-      - show version
-    wait_for:
-      - "result[0] not contains QWERTYQWERTYQWERTY"
-      - "result[0] == not QWERTYQWERTYQWERTY"
-      - "result[0] matches not QWERTYQWERTYQWERTY"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- debug: msg="END common/not_comparison_operator.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_command/tests/common/notequal.yaml b/test/integration/targets/nxos_command/tests/common/notequal.yaml
deleted file mode 100644
index 14f38431b2..0000000000
--- a/test/integration/targets/nxos_command/tests/common/notequal.yaml
+++ /dev/null
@@ -1,32 +0,0 @@
----
-- debug: msg="START common/notequal.yaml on connection={{ ansible_connection }}"
-
-- name: test neq operator
-  nxos_command:
-    commands:
-      - show version
-      - show interface mgmt0 | json
-    wait_for:
-      - "result[1].TABLE_interface.ROW_interface.state neq down"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-      - "result.stdout is defined"
-
-- name: test != operator
-  nxos_command:
-    commands:
-      - show version
-      - show interface mgmt0 | json
-    wait_for:
-      - "result[1].TABLE_interface.ROW_interface.state != down"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-      - "result.stdout is defined"
-
-- debug: msg="END common/notequal.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_command/tests/common/output.yaml b/test/integration/targets/nxos_command/tests/common/output.yaml
deleted file mode 100644
index e8ee7ed9bb..0000000000
--- a/test/integration/targets/nxos_command/tests/common/output.yaml
+++ /dev/null
@@ -1,24 +0,0 @@
----
-- debug: msg="START common/output.yaml on connection={{ ansible_connection }}"
-
-- name: get output for single command
-  nxos_command:
-    commands: ['show version']
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: get output for multiple commands
-  nxos_command:
-    commands:
-      - show version
-      - show interface
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- debug: msg="END common/output.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_command/tests/common/timeout.yaml b/test/integration/targets/nxos_command/tests/common/timeout.yaml
deleted file mode 100644
index a190b27be2..0000000000
--- a/test/integration/targets/nxos_command/tests/common/timeout.yaml
+++ /dev/null
@@ -1,18 +0,0 @@
----
-- debug: msg="START common/timeout.yaml on connection={{ ansible_connection }}"
-
-- name: test bad condition
-  nxos_command:
-    commands:
-      - show version
-    wait_for:
-      - "result[0] contains bad_value_string"
-  register: result
-  ignore_errors: yes
-
-- assert:
-    that:
-      - "result.failed == true"
-      - "result.msg is defined"
-
-- debug: msg="END common/timeout.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_command/tests/nxapi/contains.yaml b/test/integration/targets/nxos_command/tests/nxapi/contains.yaml
deleted file mode 100644
index 2737af1bfa..0000000000
--- a/test/integration/targets/nxos_command/tests/nxapi/contains.yaml
+++ /dev/null
@@ -1,18 +0,0 @@
----
-- debug: msg="START common/contains.yaml on connection={{ ansible_connection }}"
-
-- name: test contains operator
-  nxos_command:
-    commands:
-      - { command: 'show version', output: 'text' }
-      - { command: 'show interface mgmt0', output: 'json' }
-    wait_for:
-      - "result[0] contains NX-OS"
-      - "result[1].TABLE_interface.ROW_interface.interface contains mgmt"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- debug: msg="END common/contains.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_command/tests/nxapi/sanity.yaml b/test/integration/targets/nxos_command/tests/nxapi/sanity.yaml
deleted file mode 100644
index bff006a4c1..0000000000
--- a/test/integration/targets/nxos_command/tests/nxapi/sanity.yaml
+++ /dev/null
@@ -1,66 +0,0 @@
----
-- debug: msg="START nxapi/sanity.yaml on connection={{ ansible_connection }}"
-
-- name: "Disable feature BGP"
-  nxos_feature:
-    feature: bgp
-    state: disabled
-
-- block:
-  - name: "Run show running-config bgp - should fail"
-    nxos_command:
-      commands:
-        - sh running-config bgp
-    ignore_errors: yes
-    register: result
-
-  - assert: &fail
-      that:
-        - "result.failed == true"
-
-  - name: "Enable feature BGP"
-    nxos_feature:
-      feature: bgp
-      state: enabled
-
-  - name: "Configure BGP defaults"
-    nxos_bgp: &configure_default
-      asn: 65535
-      router_id: 192.0.2.1
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Run show running-config bgp - should pass"
-    nxos_command:
-      commands: 
-        - sh running-config bgp
-    register: result
-
-  - assert:
-      that:
-        - "result.failed == false"
-        - "'65535' in result.stdout[0]|to_json"
-
-  - name: "Run an invalid command - should fail"
-    nxos_command:
-      commands:
-        - show interface bief
-    ignore_errors: yes
-    register: result
-
-  - assert: *fail
-
-  rescue:
-  - debug: msg="nxos_command sanity test failure detected"
-
-  always:
-  - name: "Disable feature bgp"
-    nxos_feature:
-      feature: bgp
-      state: disabled
-
-- debug: msg="END nxapi/sanity.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_config/defaults/main.yaml b/test/integration/targets/nxos_config/defaults/main.yaml
deleted file mode 100644
index 9ef5ba5165..0000000000
--- a/test/integration/targets/nxos_config/defaults/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-testcase: "*"
-test_items: []
diff --git a/test/integration/targets/nxos_config/meta/main.yml b/test/integration/targets/nxos_config/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_config/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_config/tasks/cli.yaml b/test/integration/targets/nxos_config/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_config/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_config/tasks/cli_config.yaml b/test/integration/targets/nxos_config/tasks/cli_config.yaml
deleted file mode 100644
index f5d5b551fb..0000000000
--- a/test/integration/targets/nxos_config/tasks/cli_config.yaml
+++ /dev/null
@@ -1,16 +0,0 @@
----
-- name: collect all cli_config test cases
-  find:
-    paths: "{{ role_path }}/tests/cli_config"
-    patterns: "{{ testcase }}.yaml"
-  register: test_cases
-  delegate_to: localhost
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test case (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_config/tasks/main.yaml b/test/integration/targets/nxos_config/tasks/main.yaml
deleted file mode 100644
index f882511828..0000000000
--- a/test/integration/targets/nxos_config/tasks/main.yaml
+++ /dev/null
@@ -1,15 +0,0 @@
----
-# Some of the tests in this suite change the hostname to switch.
-# This block/always ensures the hostname gets changed back to
-# the correct name.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  - { include: nxapi.yaml, tags: ['nxapi'] }
-  - { include: cli_config.yaml, tags: ['cli_config'] }
-
-  always:
-  - name: "Change hostname back to {{ inventory_hostname_short }}"
-    nxos_config:
-      lines:
-        - "hostname {{ inventory_hostname_short }}"
-      match: none
diff --git a/test/integration/targets/nxos_config/tasks/nxapi.yaml b/test/integration/targets/nxos_config/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_config/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_config/templates/basic/base_running_config b/test/integration/targets/nxos_config/templates/basic/base_running_config
deleted file mode 100644
index 563371d9d0..0000000000
--- a/test/integration/targets/nxos_config/templates/basic/base_running_config
+++ /dev/null
@@ -1,10 +0,0 @@
-version 7.0(3)I6(1)
-hostname an-nxos9k-02.ansible.com
-vdc an-nxos9k-02 id 1
-  limit-resource vlan minimum 16 maximum 4094
-  limit-resource vrf minimum 2 maximum 4096
-  limit-resource port-channel minimum 0 maximum 511
-  limit-resource u4route-mem minimum 96 maximum 96
-  limit-resource u6route-mem minimum 24 maximum 24
-  limit-resource m4route-mem minimum 58 maximum 58
-  limit-resource m6route-mem minimum 8 maximum 8
diff --git a/test/integration/targets/nxos_config/templates/basic/config.j2 b/test/integration/targets/nxos_config/templates/basic/config.j2
deleted file mode 100644
index 5c79ec8c24..0000000000
--- a/test/integration/targets/nxos_config/templates/basic/config.j2
+++ /dev/null
@@ -1,4 +0,0 @@
-interface loopback1
-  description this is a test
-  shutdown
-
diff --git a/test/integration/targets/nxos_config/templates/basic/configblock.j2 b/test/integration/targets/nxos_config/templates/basic/configblock.j2
deleted file mode 100644
index ec03c24a22..0000000000
--- a/test/integration/targets/nxos_config/templates/basic/configblock.j2
+++ /dev/null
@@ -1,5 +0,0 @@
-ip access-list test
-  10 permit ip 192.0.2.1/32 any log
-  20 permit ip 192.0.2.2/32 any log
-  30 permit ip 192.0.2.3/32 any log
-  40 permit ip 192.0.2.4/32 any log
diff --git a/test/integration/targets/nxos_config/templates/basic/configexact1.j2 b/test/integration/targets/nxos_config/templates/basic/configexact1.j2
deleted file mode 100644
index ec03c24a22..0000000000
--- a/test/integration/targets/nxos_config/templates/basic/configexact1.j2
+++ /dev/null
@@ -1,5 +0,0 @@
-ip access-list test
-  10 permit ip 192.0.2.1/32 any log
-  20 permit ip 192.0.2.2/32 any log
-  30 permit ip 192.0.2.3/32 any log
-  40 permit ip 192.0.2.4/32 any log
diff --git a/test/integration/targets/nxos_config/templates/basic/configexact2.j2 b/test/integration/targets/nxos_config/templates/basic/configexact2.j2
deleted file mode 100644
index 3fc6800d42..0000000000
--- a/test/integration/targets/nxos_config/templates/basic/configexact2.j2
+++ /dev/null
@@ -1,6 +0,0 @@
-ip access-list test
-  10 permit ip 192.0.2.1/32 any log
-  20 permit ip 192.0.2.2/32 any log
-  30 permit ip 192.0.2.3/32 any log
-  40 permit ip 192.0.2.4/32 any log
-  50 permit ip 192.0.2.5/32 any log
diff --git a/test/integration/targets/nxos_config/templates/basic/configstrict1.j2 b/test/integration/targets/nxos_config/templates/basic/configstrict1.j2
deleted file mode 100644
index 1e7e6f4445..0000000000
--- a/test/integration/targets/nxos_config/templates/basic/configstrict1.j2
+++ /dev/null
@@ -1,6 +0,0 @@
-no ip access-list test
-ip access-list test
-  10 permit ip 192.0.2.1/32 any log
-  20 permit ip 192.0.2.2/32 any log
-  30 permit ip 192.0.2.3/32 any log
-  40 permit ip 192.0.2.4/32 any log
diff --git a/test/integration/targets/nxos_config/templates/basic/intended_running_config b/test/integration/targets/nxos_config/templates/basic/intended_running_config
deleted file mode 100644
index ab96584bf3..0000000000
--- a/test/integration/targets/nxos_config/templates/basic/intended_running_config
+++ /dev/null
@@ -1,10 +0,0 @@
-version 7.0(3)I6(1)
-hostname an-nxos9k-01.ansible.com
-vdc an-nxos9k-01 id 1
-  limit-resource vlan minimum 16 maximum 4094
-  limit-resource vrf minimum 2 maximum 4096
-  limit-resource port-channel minimum 0 maximum 511
-  limit-resource u4route-mem minimum 96 maximum 96
-  limit-resource u6route-mem minimum 24 maximum 24
-  limit-resource m4route-mem minimum 58 maximum 58
-  limit-resource m6route-mem minimum 8 maximum 8
diff --git a/test/integration/targets/nxos_config/templates/basic/setupexact.j2 b/test/integration/targets/nxos_config/templates/basic/setupexact.j2
deleted file mode 100644
index 815e003cc6..0000000000
--- a/test/integration/targets/nxos_config/templates/basic/setupexact.j2
+++ /dev/null
@@ -1,7 +0,0 @@
-no ip access-list test
-ip access-list test
-  10 permit ip 192.0.2.1/32 any log
-  20 permit ip 192.0.2.2/32 any log
-  30 permit ip 192.0.2.3/32 any log
-  40 permit ip 192.0.2.4/32 any log
-  50 permit ip 192.0.2.5/32 any log
diff --git a/test/integration/targets/nxos_config/templates/basic/setupstrict.j2 b/test/integration/targets/nxos_config/templates/basic/setupstrict.j2
deleted file mode 100644
index 815e003cc6..0000000000
--- a/test/integration/targets/nxos_config/templates/basic/setupstrict.j2
+++ /dev/null
@@ -1,7 +0,0 @@
-no ip access-list test
-ip access-list test
-  10 permit ip 192.0.2.1/32 any log
-  20 permit ip 192.0.2.2/32 any log
-  30 permit ip 192.0.2.3/32 any log
-  40 permit ip 192.0.2.4/32 any log
-  50 permit ip 192.0.2.5/32 any log
diff --git a/test/integration/targets/nxos_config/templates/config.js b/test/integration/targets/nxos_config/templates/config.js
deleted file mode 100644
index d2ec0c0c71..0000000000
--- a/test/integration/targets/nxos_config/templates/config.js
+++ /dev/null
@@ -1,4 +0,0 @@
-interface Ethernet2/5
-   description test description from ansible
-   shutdown
-
diff --git a/test/integration/targets/nxos_config/templates/defaults/config.j2 b/test/integration/targets/nxos_config/templates/defaults/config.j2
deleted file mode 100644
index df0cac701c..0000000000
--- a/test/integration/targets/nxos_config/templates/defaults/config.j2
+++ /dev/null
@@ -1,4 +0,0 @@
-interface Ethernet2/5
-   description this is a test
-   no shutdown
-
diff --git a/test/integration/targets/nxos_config/templates/defaults/test.j2 b/test/integration/targets/nxos_config/templates/defaults/test.j2
deleted file mode 100644
index 9705ee1494..0000000000
--- a/test/integration/targets/nxos_config/templates/defaults/test.j2
+++ /dev/null
@@ -1,4 +0,0 @@
-interface Ethernet2/5
-   description this is a test
-   shutdown
-
diff --git a/test/integration/targets/nxos_config/tests/cli/diff.yaml b/test/integration/targets/nxos_config/tests/cli/diff.yaml
deleted file mode 100644
index 21c164bd73..0000000000
--- a/test/integration/targets/nxos_config/tests/cli/diff.yaml
+++ /dev/null
@@ -1,33 +0,0 @@
----
-- debug: msg="START cli/diff.yaml on connection={{ ansible_connection }}"
-
-- name: setup hostname
-  nxos_config:
-    lines: hostname switch
-
-- name: nxos_config diff against retrieved config
-  nxos_config:
-    diff_against: intended
-    intended_config: "{{ lookup('file', '{{ role_path }}/templates/basic/intended_running_config') }}"
-  diff: true
-  register: result
-
-- assert:
-    that:
-      - "'hostname an-nxos9k-01.ansible.com' in result['diff']['after']"
-      - "'hostname switch' in result['diff']['before']"
-
-- name: nxos_config diff against provided running_config
-  nxos_config:
-    diff_against: intended
-    intended_config: "{{ lookup('file', '{{ role_path }}/templates/basic/intended_running_config') }}"
-    running_config: "{{ lookup('file', '{{ role_path }}/templates/basic/base_running_config') }}"
-  diff: true
-  register: result
-
-- assert:
-    that:
-      - "'hostname an-nxos9k-01.ansible.com' in result['diff']['after']"
-      - "'hostname an-nxos9k-02.ansible.com' in result['diff']['before']"
-
-- debug: msg="END cli/diff.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_config/tests/cli/multilevel.yaml b/test/integration/targets/nxos_config/tests/cli/multilevel.yaml
deleted file mode 100644
index c40624be79..0000000000
--- a/test/integration/targets/nxos_config/tests/cli/multilevel.yaml
+++ /dev/null
@@ -1,52 +0,0 @@
----
-- debug: msg="START cli/mulitlevel.yaml"
-
-- name: get config
-  nxos_command:
-    commands: show running-config
-  register: config
-
-- name: enable feature bgp
-  nxos_config:
-    lines: feature bgp
-  when: "'feature bgp' not in config.stdout[0]"
-
-- name: remove bgp
-  nxos_config:
-    lines: no router bgp 1
-  when: "'router bgp 1' in config.stdout[0]"
-
-- name: configure multi level command
-  nxos_config:
-    lines: maximum-paths 14
-    parents:
-      - router bgp 1
-      - address-family ipv4 unicast
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'router bgp 1' in result.updates"
-      - "'address-family ipv4 unicast' in result.updates"
-      - "'maximum-paths 14' in result.updates"
-
-- name: check multi level command
-  nxos_config:
-    lines: maximum-paths 14
-    parents:
-      - router bgp 1
-      - address-family ipv4 unicast
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config:
-    lines:
-      - no feature bgp
-    match: none
-
-- debug: msg="END cli/mulitlevel.yaml"
diff --git a/test/integration/targets/nxos_config/tests/cli/sublevel.yaml b/test/integration/targets/nxos_config/tests/cli/sublevel.yaml
deleted file mode 100644
index 9e186d514c..0000000000
--- a/test/integration/targets/nxos_config/tests/cli/sublevel.yaml
+++ /dev/null
@@ -1,36 +0,0 @@
----
-- debug: msg='START cli/sublevel.yaml'
-
-- name: setup
-  nxos_config:
-    lines: no ip access-list test
-    match: none
-
-- name: configure sub level command
-  nxos_config:
-    lines: 10 permit ip any any log
-    parents: ip access-list test
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'ip access-list test' in result.updates"
-      - "'10 permit ip any any log' in result.updates"
-
-- name: configure sub level command idempotent check
-  nxos_config:
-    lines: 10 permit ip any any log
-    parents: ip access-list test
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config:
-    lines: no ip access-list test
-    match: none
-
-- debug: msg='END cli/sublevel.yaml'
diff --git a/test/integration/targets/nxos_config/tests/cli/sublevel_exact.yaml b/test/integration/targets/nxos_config/tests/cli/sublevel_exact.yaml
deleted file mode 100644
index 820d9ab926..0000000000
--- a/test/integration/targets/nxos_config/tests/cli/sublevel_exact.yaml
+++ /dev/null
@@ -1,58 +0,0 @@
----
-- debug: msg='START cli/sublevel_exact.yaml'
-
-- name: setup
-  nxos_config:
-    commands:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-      - 50 permit ip 192.0.2.5/32 any log
-    parents: ip access-list test
-    before: no ip access-list test
-    match: none
-
-- name: configure sub level command using exact match
-  nxos_config:
-    commands:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-    parents: ip access-list test
-    match: exact
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'ip access-list test' in result.updates"
-      - "'10 permit ip 192.0.2.1/32 any log' in result.updates"
-      - "'20 permit ip 192.0.2.2/32 any log' in result.updates"
-      - "'30 permit ip 192.0.2.3/32 any log' in result.updates"
-      - "'40 permit ip 192.0.2.4/32 any log' in result.updates"
-      - "'50 permit ip 192.0.2.5/32 any log' not in result.updates"
-
-- name: check sub level command using exact match
-  nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-      - 50 permit ip 192.0.2.5/32 any log
-    parents: ip access-list test
-    match: exact
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config:
-    lines: no ip access-list test
-    match: none
-
-- debug: msg='END cli/sublevel_exact.yaml'
diff --git a/test/integration/targets/nxos_config/tests/cli/sublevel_strict.yaml b/test/integration/targets/nxos_config/tests/cli/sublevel_strict.yaml
deleted file mode 100644
index a50bd107ab..0000000000
--- a/test/integration/targets/nxos_config/tests/cli/sublevel_strict.yaml
+++ /dev/null
@@ -1,59 +0,0 @@
----
-- debug: msg='START cli/sublevel_strict.yaml'
-
-- name: setup
-  nxos_config:
-    commands:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-      - 50 permit ip 192.0.2.5/32 any log
-    parents: ip access-list test
-    before: no ip access-list test
-    match: none
-
-- name: configure sub level command using strict match
-  nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-    parents: ip access-list test
-    before: no ip access-list test
-    match: strict
-    replace: block
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'ip access-list test' in result.updates"
-      - "'10 permit ip 192.0.2.1/32 any log' in result.updates"
-      - "'20 permit ip 192.0.2.2/32 any log' in result.updates"
-      - "'30 permit ip 192.0.2.3/32 any log' in result.updates"
-      - "'40 permit ip 192.0.2.4/32 any log' in result.updates"
-      - "'50 permit ip 192.0.2.5/32 any log' not in result.updates"
-
-- name: check sub level command using strict match
-  nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-    parents: ip access-list test
-    match: strict
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config:
-    commands: no ip access-list test
-    match: none
-
-- debug: msg='END cli/sublevel_strict.yaml'
diff --git a/test/integration/targets/nxos_config/tests/cli/toplevel_after.yaml b/test/integration/targets/nxos_config/tests/cli/toplevel_after.yaml
deleted file mode 100644
index 45bdc66cd3..0000000000
--- a/test/integration/targets/nxos_config/tests/cli/toplevel_after.yaml
+++ /dev/null
@@ -1,40 +0,0 @@
----
-- debug: msg='START cli/toplevel_after.yaml'
-
-- name: setup
-  nxos_config:
-    lines:
-      - "snmp-server contact ansible"
-      - "hostname switch"
-    match: none
-
-- name: configure top level command with before
-  nxos_config:
-    lines: hostname foo
-    after: snmp-server contact bar
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'hostname foo' in result.updates"
-      - "'snmp-server contact bar' in result.updates"
-
-- name: configure top level command with before idempotent check
-  nxos_config:
-    lines: hostname foo
-    after: snmp-server contact foo
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config:
-    lines:
-      - "no snmp-server contact"
-      - "hostname switch"
-    match: none
-
-- debug: msg='END cli/toplevel_after.yaml'
diff --git a/test/integration/targets/nxos_config/tests/cli/toplevel_before.yaml b/test/integration/targets/nxos_config/tests/cli/toplevel_before.yaml
deleted file mode 100644
index f60c43f089..0000000000
--- a/test/integration/targets/nxos_config/tests/cli/toplevel_before.yaml
+++ /dev/null
@@ -1,40 +0,0 @@
----
-- debug: msg='START cli/toplevel_before.yaml'
-
-- name: setup
-  nxos_config:
-    lines:
-      - "snmp-server contact ansible"
-      - "hostname switch"
-    match: none
-
-- name: configure top level command with before
-  nxos_config:
-    lines: hostname foo
-    before: snmp-server contact bar
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'hostname foo' in result.updates"
-      - "'snmp-server contact bar' in result.updates"
-
-- name: configure top level command with before idempotent check
-  nxos_config:
-    lines: hostname foo
-    before: snmp-server contact foo
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config:
-    lines:
-      - "no snmp-server contact"
-      - "hostname switch"
-    match: none
-
-- debug: msg='END cli/toplevel_before.yaml'
diff --git a/test/integration/targets/nxos_config/tests/cli_config/cli_backup.yaml b/test/integration/targets/nxos_config/tests/cli_config/cli_backup.yaml
deleted file mode 100644
index a431c01fde..0000000000
--- a/test/integration/targets/nxos_config/tests/cli_config/cli_backup.yaml
+++ /dev/null
@@ -1,113 +0,0 @@
-- debug: msg="END cli_config/backup.yaml on connection={{ ansible_connection }}"
-
-- name: delete configurable backup file path
-  file:
-    path: "{{ item }}"
-    state: absent
-  with_items:
-    - "{{ role_path }}/backup_test_dir/"
-    - "{{ role_path }}/backup/backup.cfg"
-
-- name: collect any backup files
-  find:
-    paths: "{{ role_path }}/backup"
-    pattern: "{{ inventory_hostname_short }}_config*"
-  register: backup_files
-  connection: local
-
-- name: delete backup files
-  file:
-    path: "{{ item.path }}"
-    state: absent
-  with_items: "{{backup_files.files|default([])}}"
-
-- name: take config backup
-  cli_config:
-    backup: yes
-  become: yes
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: collect any backup files
-  find:
-    paths: "{{ role_path }}/backup"
-    pattern: "{{ inventory_hostname_short }}_config*"
-  register: backup_files
-  connection: local
-
-- assert:
-    that:
-      - "backup_files.files is defined"
-
-- name: take configuration backup in custom filename and directory path
-  cli_config:
-    backup: yes
-    backup_options:
-      filename: backup.cfg
-      dir_path: "{{ role_path }}/backup_test_dir/{{ inventory_hostname_short }}"
-  become: yes
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: check if the backup file-1 exist
-  find:
-    paths: "{{ role_path }}/backup_test_dir/{{ inventory_hostname_short }}/backup.cfg"
-  register: backup_file
-  connection: local
-
-- assert:
-    that:
-      - "backup_file.files is defined"
-
-- name: take configuration backup in custom filename
-  cli_config:
-    backup: yes
-    backup_options:
-      filename: backup.cfg
-  become: yes
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: check if the backup file-2 exist
-  find:
-    paths: "{{ role_path }}/backup/backup.cfg"
-  register: backup_file
-  connection: local
-
-- assert:
-    that:
-      - "backup_file.files is defined"
-
-- name: take configuration backup in custom path and default filename
-  cli_config:
-    backup: yes
-    backup_options:
-      dir_path: "{{ role_path }}/backup_test_dir/{{ inventory_hostname_short }}"
-  become: yes
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: check if the backup file-3 exist
-  find:
-    paths: "{{ role_path }}/backup_test_dir/{{ inventory_hostname_short }}"
-    pattern: "{{ inventory_hostname_short }}_config*"
-  register: backup_file
-  connection: local
-
-- assert:
-    that:
-      - "backup_file.files is defined"
-
-- debug: msg="END cli_config/backup.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_config/tests/cli_config/cli_basic.yaml b/test/integration/targets/nxos_config/tests/cli_config/cli_basic.yaml
deleted file mode 100644
index 57111467ae..0000000000
--- a/test/integration/targets/nxos_config/tests/cli_config/cli_basic.yaml
+++ /dev/null
@@ -1,45 +0,0 @@
----
-- debug: msg="START cli_config/cli_basic.yaml on connection={{ ansible_connection }}"
-
-- name: setup
-  cli_config: &rm
-    config: |
-      interface loopback1
-      no description
-      no shutdown
-    diff_match: none
-
-- name: configure device with config
-  cli_config: &conf
-    config: "{{ lookup('template', 'basic/config.j2') }}"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: Idempotence
-  cli_config: *conf
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: remove config
-  cli_config: *rm
-
-- name: configure device with config
-  cli_config:
-    config: "{{ lookup('template', 'basic/config.j2') }}"
-    defaults: yes
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: teardown
-  cli_config: *rm
-
-- debug: msg="END cli_config/cli_basic.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_config/tests/cli_config/cli_block_replace.yaml b/test/integration/targets/nxos_config/tests/cli_config/cli_block_replace.yaml
deleted file mode 100644
index 5cd710048c..0000000000
--- a/test/integration/targets/nxos_config/tests/cli_config/cli_block_replace.yaml
+++ /dev/null
@@ -1,30 +0,0 @@
----
-- debug: msg="START cli_config/cli_block_replace.yaml on connection={{ ansible_connection }}"
-
-- name: setup - remove configuration
-  cli_config: &rm
-    config: "no ip access-list test"
-    diff_match: none
-
-- name: block replace
-  cli_config: &block
-    config: "{{ lookup('template', 'basic/configblock.j2') }}"
-    diff_replace: block
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: block replace (Idempotence)
-  cli_config: *block
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  cli_config: *rm
-
-- debug: msg="END cli_config/cli_block_replace.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_config/tests/cli_config/cli_exact_match.yaml b/test/integration/targets/nxos_config/tests/cli_config/cli_exact_match.yaml
deleted file mode 100644
index 4eb2ee52a9..0000000000
--- a/test/integration/targets/nxos_config/tests/cli_config/cli_exact_match.yaml
+++ /dev/null
@@ -1,33 +0,0 @@
----
-- debug: msg="START cli_config/cli_exact_match.yaml on connection={{ ansible_connection }}"
-
-- name: setup - remove configuration
-  cli_config:
-    config: "{{ lookup('template', 'basic/setupexact.j2') }}"
-    diff_match: none
-
-- name: configure using exact match
-  cli_config:
-    config: "{{ lookup('template', 'basic/configexact1.j2') }}"
-    diff_match: exact
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: check using exact match
-  cli_config:
-    config: "{{ lookup('template', 'basic/configexact2.j2') }}"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  cli_config:
-    config: no ip access-list test
-    diff_match: none
-
-- debug: msg="END cli_config/cli_exact_match.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_config/tests/cli_config/cli_strict_match.yaml b/test/integration/targets/nxos_config/tests/cli_config/cli_strict_match.yaml
deleted file mode 100644
index c43b093500..0000000000
--- a/test/integration/targets/nxos_config/tests/cli_config/cli_strict_match.yaml
+++ /dev/null
@@ -1,25 +0,0 @@
----
-- debug: msg="START cli_config/cli_strict_match.yaml on connection={{ ansible_connection }}"
-
-- name: setup - remove configuration
-  cli_config:
-    config: "{{ lookup('template', 'basic/setupstrict.j2') }}"
-    diff_match: none
-
-- name: configure using strict match
-  cli_config:
-    config: "{{ lookup('template', 'basic/configstrict1.j2') }}"
-    diff_match: strict
-    diff_replace: block
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: teardown
-  cli_config:
-    config: no ip access-list test
-    diff_match: none
-
-- debug: msg="END cli_config/cli_strict_match.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_config/tests/common/backup.yaml b/test/integration/targets/nxos_config/tests/common/backup.yaml
deleted file mode 100644
index d7cea3c432..0000000000
--- a/test/integration/targets/nxos_config/tests/common/backup.yaml
+++ /dev/null
@@ -1,126 +0,0 @@
----
-- debug: msg="START common/backup.yaml on connection={{ ansible_connection }}"
-
-# Select interface for test
-- set_fact: intname="{{ nxos_int1 }}"
-
-- name: setup
-  nxos_config:
-    commands:
-      - no description
-      - no shutdown
-    parents:
-      - "interface {{ intname }}"
-    match: none
-
-- name: collect any backup files
-  find: &backups
-    paths: "{{ role_path }}/backup"
-    pattern: "{{ inventory_hostname_short }}_config*"
-  connection: local
-  register: backup_files
-
-- name: delete backup files
-  file:
-    path: "{{ item.path }}"
-    state: absent
-  with_items: "{{backup_files.files|default([])}}"
-
-- name: configure device with config
-  nxos_config:
-    commands:
-      - description this is a test
-      - shutdown
-    parents:
-      - "interface {{ intname }}"
-    backup: yes
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "result.updates is defined"
-
-- name: collect any backup files
-  find: *backups
-  connection: local
-  register: backup_files
-
-- assert:
-    that:
-      - "backup_files.files is defined"
-
-- name: delete configurable backup file path
-  file:
-    path: "{{ item }}"
-    state: absent
-  with_items:
-    - "{{ role_path }}/backup_test_dir/"
-    - "{{ role_path }}/backup/backup.cfg"
-
-- name: take configuration backup in custom filename and directory path
-  nxos_config:
-    backup: yes
-    backup_options:
-      filename: backup.cfg
-      dir_path: "{{ role_path }}/backup_test_dir/{{ inventory_hostname_short }}"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: check if the backup file-1 exist
-  find:
-    paths: "{{ role_path }}/backup_test_dir/{{ inventory_hostname_short }}/backup.cfg"
-  register: backup_file
-  connection: local
-
-- assert:
-    that:
-      - "backup_file.files is defined"
-
-- name: take configuration backup in custom filename
-  nxos_config:
-    backup: yes
-    backup_options:
-      filename: backup.cfg
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: check if the backup file-2 exist
-  find:
-    paths: "{{ role_path }}/backup/backup.cfg"
-  register: backup_file
-  connection: local
-
-- assert:
-    that:
-      - "backup_file.files is defined"
-
-- name: take configuration backup in custom path and default filename
-  nxos_config:
-    backup: yes
-    backup_options:
-      dir_path: "{{ role_path }}/backup_test_dir/{{ inventory_hostname_short }}"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: check if the backup file-3 exist
-  find:
-    paths: "{{ role_path }}/backup_test_dir/{{ inventory_hostname_short }}"
-    pattern: "{{ inventory_hostname_short }}_config*"
-  register: backup_file
-  connection: local
-
-- assert:
-    that:
-      - "backup_file.files is defined"
-
-- debug: msg="END common/backup.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_config/tests/common/defaults.yaml b/test/integration/targets/nxos_config/tests/common/defaults.yaml
deleted file mode 100644
index c0a17c2011..0000000000
--- a/test/integration/targets/nxos_config/tests/common/defaults.yaml
+++ /dev/null
@@ -1,50 +0,0 @@
----
-- debug: msg="START common/defaults.yaml on connection={{ ansible_connection }}"
-
-# Select interface for test
-- set_fact: intname="{{ nxos_int1 }}"
-
-- name: setup
-  nxos_config:
-    commands:
-      - no description
-      - shutdown
-    parents:
-      - "interface {{ intname }}"
-    match: none
-
-- name: configure device with defaults included
-  nxos_config:
-    commands:
-      - description this is a test
-      - no shutdown
-    parents:
-      - "interface {{ intname }}"
-    defaults: yes
-  register: result
-
-- debug: var=result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "result.updates is defined"
-
-- name: check device with defaults included
-  nxos_config:
-    commands:
-      - description this is a test
-      - no shutdown
-    parents:
-      - "interface {{ intname }}"
-    defaults: yes
-  register: result
-
-- debug: var=result
-
-- assert:
-    that:
-      - "result.changed == false"
-      - "result.updates is not defined"
-
-- debug: msg="END common/defaults.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_config/tests/common/sanity.yaml b/test/integration/targets/nxos_config/tests/common/sanity.yaml
deleted file mode 100644
index 58206d1cf7..0000000000
--- a/test/integration/targets/nxos_config/tests/common/sanity.yaml
+++ /dev/null
@@ -1,71 +0,0 @@
----
-- debug: msg="START common/sanity.yaml on connection={{ ansible_connection }}"
-
-- name: setup
-  nxos_config:
-    lines: ip access-list test
-    match: none
-
-- name: "nxos_config sanity test"
-  nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-      - 50 permit ip 192.0.2.5/32 any log
-    parents: ip access-list test
-    before: no ip access-list test
-    match: exact
-
-- name: "nxos_config sanity test - replace block"
-  nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-    parents: ip access-list test
-    before: no ip access-list test
-    replace: block
-
-- name: teardown
-  nxos_config:
-    lines: no ip access-list test
-    match: none
-
-- debug: msg='Verify https://github.com/ansible/ansible/issues/50635'
-
-- name: PUT INTERFACE INTO DEFAULT STATE
-  nxos_config:
-    lines:
-      - "default interface {{ nxos_int1 }}"
-
-- name: MAKE INTERFACE A SWITCHPORT
-  nxos_config:
-    lines:
-      - switchport
-    parents: "interface {{ nxos_int1 }}"
-
-- name: CONFIGURE EDGE TRUNK TYPE
-  nxos_config: &config
-    lines:
-      - description foo
-      - switchport access vlan 3333
-      - spanning-tree port type edge
-    parents: "interface {{ nxos_int1 }}"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: IDEMPOTENCE CHECK
-  nxos_config: *config
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- debug: msg="END common/sanity.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_config/tests/common/save.yaml b/test/integration/targets/nxos_config/tests/common/save.yaml
deleted file mode 100644
index 19e6b7c127..0000000000
--- a/test/integration/targets/nxos_config/tests/common/save.yaml
+++ /dev/null
@@ -1,34 +0,0 @@
----
-- debug: msg="START common/save.yaml on connection={{ ansible_connection }}"
-
-# Select interface for test
-- set_fact: intname="{{ nxos_int1 }}"
-
-- name: setup
-  nxos_config:
-    commands:
-      - no description
-      - no shutdown
-    parents:
-      - "interface {{ intname }}"
-    match: none
-
-- name: save config
-  nxos_config:
-    save_when: always
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: save should always run
-  nxos_config:
-    save_when: always
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- debug: msg="END common/save.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_config/tests/common/src_basic.yaml b/test/integration/targets/nxos_config/tests/common/src_basic.yaml
deleted file mode 100644
index c8bc469fb9..0000000000
--- a/test/integration/targets/nxos_config/tests/common/src_basic.yaml
+++ /dev/null
@@ -1,38 +0,0 @@
----
-- debug: msg="START common/src_basic.yaml on connection={{ ansible_connection }}"
-
-- set_fact: intname="loopback1"
-
-- name: setup
-  nxos_config:
-    commands:
-      - no description
-      - no shutdown
-    parents:
-      - "interface {{ intname }}"
-    match: none
-
-- name: configure device with config
-  nxos_config:
-    src: basic/config.j2
-    defaults: yes
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-# https://github.com/ansible/ansible-modules-core/issues/4807
-      - "result.updates is defined"
-
-- name: check device with config
-  nxos_config:
-    src: basic/config.j2
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-# https://github.com/ansible/ansible-modules-core/issues/4807
-      - "result.updates is not defined"
-
-- debug: msg="END common/src_basic.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_config/tests/common/src_invalid.yaml b/test/integration/targets/nxos_config/tests/common/src_invalid.yaml
deleted file mode 100644
index f0e721fc31..0000000000
--- a/test/integration/targets/nxos_config/tests/common/src_invalid.yaml
+++ /dev/null
@@ -1,17 +0,0 @@
----
-- debug: msg="START common/src_invalid.yaml on connection={{ ansible_connection }}"
-
-
-# Defend https://github.com/ansible/ansible-modules-core/issues/4797
-- name: configure with invalid src
-  nxos_config:
-    src: basic/foobar.j2
-  register: result
-  ignore_errors: yes
-
-- assert:
-    that:
-      - "result.failed == true"
-      - "result.msg == 'path specified in src not found'"
-
-- debug: msg="END common/src_invalid.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_config/tests/common/src_match_none.yaml b/test/integration/targets/nxos_config/tests/common/src_match_none.yaml
deleted file mode 100644
index fd2c2d2644..0000000000
--- a/test/integration/targets/nxos_config/tests/common/src_match_none.yaml
+++ /dev/null
@@ -1,50 +0,0 @@
----
-- debug: msg="START common/src_match_none.yaml on connection={{ ansible_connection }}"
-
-# Select interface for test
-- set_fact: intname="{{ nxos_int1 }}"
-
-- name: setup
-  nxos_config:
-    commands:
-      - no description
-      - no shutdown
-    parents:
-      - "interface {{ intname }}"
-    match: none
-
-- name: configure device with config
-  nxos_config:
-    commands:
-      - description this is a test
-      - shutdown
-    parents:
-      - "interface {{ intname }}"
-    match: none
-    defaults: yes
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-# Defend https://github.com/ansible/ansible-modules-core/issues/4807
-      - "result.updates is defined"
-
-- name: check device with config
-  nxos_config:
-    commands:
-      - description this is a test
-      - shutdown
-    parents:
-      - "interface {{ intname }}"
-    defaults: yes
-  register: result
-
-- assert:
-    that:
-      # Idempotent test
-# Defend https://github.com/ansible/ansible-modules-core/issues/4807
-      - "result.changed == false"
-      - "result.updates is not defined"
-
-- debug: msg="END common/src_match_none.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_config/tests/common/sublevel_block.yaml b/test/integration/targets/nxos_config/tests/common/sublevel_block.yaml
deleted file mode 100644
index 3e6c4c2ab2..0000000000
--- a/test/integration/targets/nxos_config/tests/common/sublevel_block.yaml
+++ /dev/null
@@ -1,48 +0,0 @@
----
-- debug: msg='START common/sublevel_block.yaml on connection={{ ansible_connection }}'
-
-- name: setup
-  nxos_config: &clear
-    lines: no ip access-list test
-    match: none
-  ignore_errors: yes
-
-- name: configure sub level command using block replace
-  nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-    parents: ip access-list test
-    replace: block
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'ip access-list test' in result.updates"
-      - "'10 permit ip 192.0.2.1/32 any log' in result.updates"
-      - "'20 permit ip 192.0.2.2/32 any log' in result.updates"
-      - "'30 permit ip 192.0.2.3/32 any log' in result.updates"
-      - "'40 permit ip 192.0.2.4/32 any log' in result.updates"
-
-- name: check sub level command using block replace
-  nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-    parents: ip access-list test
-    replace: block
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config: *clear
-
-- debug: msg='END common/sublevel_block.yaml on connection={{ ansible_connection }}'
diff --git a/test/integration/targets/nxos_config/tests/common/toplevel.yaml b/test/integration/targets/nxos_config/tests/common/toplevel.yaml
deleted file mode 100644
index 3589ea7fdb..0000000000
--- a/test/integration/targets/nxos_config/tests/common/toplevel.yaml
+++ /dev/null
@@ -1,33 +0,0 @@
----
-- debug: msg='START common/toplevel.yaml on connection={{ ansible_connection }}'
-
-- name: setup
-  nxos_config:
-    lines: hostname switch
-    match: none
-
-- name: configure top level command
-  nxos_config:
-    lines: hostname foo
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'hostname foo' in result.updates"
-
-- name: configure top level command idempotent check
-  nxos_config:
-    lines: hostname foo
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config:
-    lines: hostname switch
-    match: none
-
-- debug: msg='END common/toplevel.yaml on connection={{ ansible_connection }}'
diff --git a/test/integration/targets/nxos_config/tests/common/toplevel_nonidempotent.yaml b/test/integration/targets/nxos_config/tests/common/toplevel_nonidempotent.yaml
deleted file mode 100644
index c619a7650a..0000000000
--- a/test/integration/targets/nxos_config/tests/common/toplevel_nonidempotent.yaml
+++ /dev/null
@@ -1,35 +0,0 @@
----
-- debug: msg="START common/nonidempotent.yaml on connection={{ ansible_connection }}"
-
-- name: setup
-  nxos_config:
-    lines: hostname switch
-    match: none
-
-- name: configure top level command
-  nxos_config:
-    lines: hostname foo
-    match: strict
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'hostname foo' in result.updates"
-
-- name: configure top level command idempotent check
-  nxos_config:
-    lines: hostname foo
-    match: strict
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: teardown
-  nxos_config:
-    lines: hostname switch
-    match: none
-
-- debug: msg="END common/nonidempotent.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_config/tests/nxapi/multilevel.yaml b/test/integration/targets/nxos_config/tests/nxapi/multilevel.yaml
deleted file mode 100644
index 892582559a..0000000000
--- a/test/integration/targets/nxos_config/tests/nxapi/multilevel.yaml
+++ /dev/null
@@ -1,41 +0,0 @@
----
-- debug: msg="START nxapi/mulitlevel.yaml"
-
-- name: setup
-  nxos_config:
-    lines: feature bgp
-    match: none
-
-- name: configure multi level command
-  nxos_config:
-    lines: maximum-paths 14
-    parents:
-      - router bgp 1
-      - address-family ipv4 unicast
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'router bgp 1' in result.updates"
-      - "'address-family ipv4 unicast' in result.updates"
-      - "'maximum-paths 14' in result.updates"
-
-- name: test multi level command
-  nxos_config:
-    lines: maximum-paths 14
-    parents:
-      - router bgp 1
-      - address-family ipv4 unicast
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config:
-    lines: no feature bgp
-    match: none
-
-- debug: msg="END nxapi/mulitlevel.yaml"
diff --git a/test/integration/targets/nxos_config/tests/nxapi/sublevel.yaml b/test/integration/targets/nxos_config/tests/nxapi/sublevel.yaml
deleted file mode 100644
index 05d97670f0..0000000000
--- a/test/integration/targets/nxos_config/tests/nxapi/sublevel.yaml
+++ /dev/null
@@ -1,37 +0,0 @@
----
-- debug: msg="START nxapi/sublevel.yaml"
-
-- name: setup
-  nxos_config:
-    lines: no ip access-list test
-    match: none
-  ignore_errors: yes
-
-- name: configure sub level command
-  nxos_config:
-    lines: 10 permit ip any any log
-    parents: ip access-list test
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'ip access-list test' in result.updates"
-      - "'10 permit ip any any log' in result.updates"
-
-- name: configure sub level command idempotent check
-  nxos_config:
-    lines: 10 permit ip any any log
-    parents: ip access-list test
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config:
-    lines: no ip access-list test
-    match: none
-
-- debug: msg="END nxapi/sublevel.yaml"
diff --git a/test/integration/targets/nxos_config/tests/nxapi/sublevel_exact.yaml b/test/integration/targets/nxos_config/tests/nxapi/sublevel_exact.yaml
deleted file mode 100644
index c3e4382d99..0000000000
--- a/test/integration/targets/nxos_config/tests/nxapi/sublevel_exact.yaml
+++ /dev/null
@@ -1,59 +0,0 @@
----
-- debug: msg="START nxapi/sublevel_exact.yaml"
-
-- name: setup
-  nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-      - 50 permit ip 192.0.2.5/32 any log
-    parents: ip access-list test
-    match: none
-  ignore_errors: yes
-
-- name: configure sub level command using exact match
-  nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-    parents: ip access-list test
-    before: no ip access-list test
-    match: exact
-    replace: block
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'ip access-list test' in result.updates"
-      - "'10 permit ip 192.0.2.1/32 any log' in result.updates"
-      - "'20 permit ip 192.0.2.2/32 any log' in result.updates"
-      - "'30 permit ip 192.0.2.3/32 any log' in result.updates"
-      - "'40 permit ip 192.0.2.4/32 any log' in result.updates"
-      - "'50 permit ip 192.0.2.5/32 any log' not in result.updates"
-
-- name: check sub level command using exact match
-  nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-    parents: ip access-list test
-    match: exact
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config:
-    lines: no ip access-list test
-    match: none
-
-- debug: msg="END nxapi/sublevel_exact.yaml"
diff --git a/test/integration/targets/nxos_config/tests/nxapi/sublevel_strict.yaml b/test/integration/targets/nxos_config/tests/nxapi/sublevel_strict.yaml
deleted file mode 100644
index 3b0bc378aa..0000000000
--- a/test/integration/targets/nxos_config/tests/nxapi/sublevel_strict.yaml
+++ /dev/null
@@ -1,58 +0,0 @@
----
-- debug: msg="START nxapi/sublevel_strict.yaml"
-
-- name: setup
-  nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-      - 50 permit ip 192.0.2.5/32 any log
-    parents: ip access-list test
-    match: none
-
-- name: configure sub level command using strict match
-  nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 30 permit ip 192.0.2.2/32 any log
-      - 20 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-    parents: ip access-list test
-    before: no ip access-list test
-    match: strict
-    replace: block
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'ip access-list test' in result.updates"
-      - "'10 permit ip 192.0.2.1/32 any log' in result.updates"
-      - "'30 permit ip 192.0.2.2/32 any log' in result.updates"
-      - "'20 permit ip 192.0.2.3/32 any log' in result.updates"
-      - "'40 permit ip 192.0.2.4/32 any log' in result.updates"
-      - "'50 permit ip 192.0.2.5/32 any log' not in result.updates"
-
-- name: check sub level command using strict match
-  nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.3/32 any log
-      - 30 permit ip 192.0.2.2/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-    parents: ip access-list test
-    match: strict
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config:
-    lines: no ip access-list test
-    match: none
-
-- debug: msg="END nxapi/sublevel_strict.yaml"
diff --git a/test/integration/targets/nxos_config/tests/nxapi/toplevel_after.yaml b/test/integration/targets/nxos_config/tests/nxapi/toplevel_after.yaml
deleted file mode 100644
index 8749be5fd5..0000000000
--- a/test/integration/targets/nxos_config/tests/nxapi/toplevel_after.yaml
+++ /dev/null
@@ -1,40 +0,0 @@
----
-- debug: msg="START nxapi/toplevel_after.yaml"
-
-- name: setup
-  nxos_config:
-    lines:
-      - "snmp-server contact ansible"
-      - "hostname switch"
-    match: none
-
-- name: configure top level command with before
-  nxos_config:
-    lines: hostname foo
-    after: snmp-server contact bar
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'hostname foo' in result.updates"
-      - "'snmp-server contact bar' in result.updates"
-
-- name: configure top level command with before idempotent check
-  nxos_config:
-    lines: hostname foo
-    after: snmp-server contact foo
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config:
-    lines:
-      - "no snmp-server contact ansible"
-      - "hostname switch"
-    match: none
-
-- debug: msg="END nxapi/toplevel_after.yaml"
diff --git a/test/integration/targets/nxos_config/tests/nxapi/toplevel_before.yaml b/test/integration/targets/nxos_config/tests/nxapi/toplevel_before.yaml
deleted file mode 100644
index a67530773b..0000000000
--- a/test/integration/targets/nxos_config/tests/nxapi/toplevel_before.yaml
+++ /dev/null
@@ -1,40 +0,0 @@
----
-- debug: msg="START nxapi/toplevel_before.yaml"
-
-- name: setup
-  nxos_config:
-    lines:
-      - "snmp-server contact ansible"
-      - "hostname switch"
-    match: none
-
-- name: configure top level command with before
-  nxos_config:
-    lines: hostname foo
-    before: snmp-server contact bar
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'hostname foo' in result.updates"
-      - "'snmp-server contact bar' in result.updates"
-
-- name: configure top level command with before idempotent check
-  nxos_config:
-    lines: hostname foo
-    before: snmp-server contact foo
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config:
-    lines:
-      - "no snmp-server contact ansible"
-      - "hostname switch"
-    match: none
-
-- debug: msg="END nxapi/toplevel_before.yaml"
diff --git a/test/integration/targets/nxos_devicealias/defaults/main.yaml b/test/integration/targets/nxos_devicealias/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_devicealias/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_devicealias/meta/main.yml b/test/integration/targets/nxos_devicealias/meta/main.yml
deleted file mode 100644
index 42c635d6d2..0000000000
--- a/test/integration/targets/nxos_devicealias/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-# dependencies:
-#   - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_devicealias/tasks/cli.yaml b/test/integration/targets/nxos_devicealias/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_devicealias/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_devicealias/tasks/main.yaml b/test/integration/targets/nxos_devicealias/tasks/main.yaml
deleted file mode 100644
index eb3f9ca07c..0000000000
--- a/test/integration/targets/nxos_devicealias/tasks/main.yaml
+++ /dev/null
@@ -1,16 +0,0 @@
-#---
-# Check platform type and skip if not MDS
----
-- name: Check platform type and skip if not MDS
-  nxos_command:
-    commands: show version | grep MDS
-  register: result
- 
-- set_fact: skip_test=False
-- set_fact: skip_test=True
-  when: result.stdout[0] is not search('MDS')
- 
-- include: cli.yaml
-  tags: 'cli'
-  when: not skip_test
- 
\ No newline at end of file
diff --git a/test/integration/targets/nxos_devicealias/tests/common/sanity.yaml b/test/integration/targets/nxos_devicealias/tests/common/sanity.yaml
deleted file mode 100644
index 26d7f68198..0000000000
--- a/test/integration/targets/nxos_devicealias/tests/common/sanity.yaml
+++ /dev/null
@@ -1,42 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_devicealias sanity test"
-
-- name: Setup - Remove device alias if configured
-  nxos_devicealias: &remove
-    da:
-      - { name: 'ansible_test1_add', remove: True}
-      - { name: 'ansible_test2_add', remove: True}
-  ignore_errors: yes
-
-- block:
-
-    - name: Configure device alias
-      nxos_devicealias: &config
-        da:
-          - { name: 'ansible_test1_add', pwwn: '57:bb:cc:dd:ee:ff:11:67'}
-          - { name: 'ansible_test2_add', pwwn: '65:22:21:20:19:18:1a:0d'}
-      register: result
-
-    - assert: &true
-        that:
-          - result.changed == true
-    - assert:
-        that: 
-          - result.commands == ["terminal dont-ask", "device-alias database", "device-alias name ansible_test1_add pwwn 57:bb:cc:dd:ee:ff:11:67", "device-alias name ansible_test2_add pwwn 65:22:21:20:19:18:1a:0d", "device-alias commit", "no terminal dont-ask"]
-    
-    - name: Idempotence Check
-      nxos_devicealias: *config
-      register: result
-
-    - assert: &false
-        that:
-          - result.changed == false
-    - assert:
-        that: 
-          - result.commands == []
-
-  always:
-    - name: Remove device alias config
-      nxos_devicealias: *remove
-
-    - debug: msg="END connection={{ ansible_connection }} nxos_devicealias sanity test"
diff --git a/test/integration/targets/nxos_evpn_global/defaults/main.yaml b/test/integration/targets/nxos_evpn_global/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_evpn_global/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_evpn_global/meta/main.yml b/test/integration/targets/nxos_evpn_global/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_evpn_global/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_evpn_global/tasks/cli.yaml b/test/integration/targets/nxos_evpn_global/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_evpn_global/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_evpn_global/tasks/main.yaml b/test/integration/targets/nxos_evpn_global/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_evpn_global/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_evpn_global/tasks/nxapi.yaml b/test/integration/targets/nxos_evpn_global/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_evpn_global/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_evpn_global/tests/common/sanity.yaml b/test/integration/targets/nxos_evpn_global/tests/common/sanity.yaml
deleted file mode 100644
index 523c2aa776..0000000000
--- a/test/integration/targets/nxos_evpn_global/tests/common/sanity.yaml
+++ /dev/null
@@ -1,68 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_evpn_global sanity test"
-
-- name: "Setup"
-  nxos_config: &remove_evpn_config
-    lines: no nv overlay evpn
-    match: none
-  ignore_errors: yes
-
-- name: "Disable feature nv overlay"
-  nxos_feature: &disable_feature_nv_overlay
-    feature: nv overlay
-    state: disabled
-  ignore_errors: yes
-
-- block:
-  - name: "Enable feature nv overlay"
-    nxos_feature: &enable_feature_nv_overlay
-      feature: nv overlay
-      state: enabled
-    ignore_errors: yes
-
-  - name: "Enable nv overlay evpn"
-    nxos_evpn_global: &enable_evpn
-      nv_overlay_evpn: true
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "CHECK IDEMPOTENCE - enable nv overlay evpn"
-    nxos_evpn_global: *enable_evpn
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "Disable nv overlay evpn"
-    nxos_evpn_global: &disable_evpn
-      nv_overlay_evpn: false
-    register: result
-
-  - assert: *true
-
-  - name: "CHECK DEMPOTENCE - Disable nv overlay evpn"
-    nxos_evpn_global: *disable_evpn
-    register: result
-
-  - assert: *false
-
-  when: not ( platform is search('N3K|N35|N3L'))
-
-  rescue:
-  - debug: msg="connection={{ ansible_connection }} nxos_evpn_global sanity test - FALURE ENCOUNTERED"
-
-  always:
-
-  - name: "Cleanup - Disable nv overlay evpn"
-    nxos_config: *remove_evpn_config
-    ignore_errors: yes
-
-  - name: "Cleanup - Disable feature nv overlay"
-    nxos_feature: *disable_feature_nv_overlay
-    ignore_errors: yes
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_evpn_global sanity test"
diff --git a/test/integration/targets/nxos_evpn_vni/defaults/main.yaml b/test/integration/targets/nxos_evpn_vni/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_evpn_vni/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_evpn_vni/meta/main.yml b/test/integration/targets/nxos_evpn_vni/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_evpn_vni/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_evpn_vni/tasks/cli.yaml b/test/integration/targets/nxos_evpn_vni/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_evpn_vni/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_evpn_vni/tasks/main.yaml b/test/integration/targets/nxos_evpn_vni/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_evpn_vni/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_evpn_vni/tasks/nxapi.yaml b/test/integration/targets/nxos_evpn_vni/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_evpn_vni/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_evpn_vni/tests/common/sanity.yaml b/test/integration/targets/nxos_evpn_vni/tests/common/sanity.yaml
deleted file mode 100644
index ee6c73cf97..0000000000
--- a/test/integration/targets/nxos_evpn_vni/tests/common/sanity.yaml
+++ /dev/null
@@ -1,112 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_evpn_vni sanity test"
-
-- set_fact: nvoe_supported="{{ platform is not search('N3K|N3L|N35')}}"
-
-- name: "Setup"
-  nxos_config: &remove_evpn
-    lines: no nv overlay evpn
-    match: none
-  ignore_errors: yes
-  when: nvoe_supported
-
-- block:
-  - name: "Enable feature BGP"
-    nxos_feature:
-      feature: bgp
-      state: enabled
-
-  - name: "Enable nv overlay evpn"
-    nxos_config:
-      lines: nv overlay evpn
-      match: none
-
-  - name: "Configure nxos_evpn_vni"
-    nxos_evpn_vni: &evpn_vni
-      vni: 6000
-      route_distinguisher: "60:10"
-      route_target_import:
-          - auto
-          - "5000:10"
-          - "4100:100"
-      route_target_export:
-          - auto
-          - "5000:10"
-          - "192.0.2.1:43"
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_evpn_vni: *evpn_vni
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "Configure nxos_evpn_vni"
-    nxos_evpn_vni: &evpn_vni1
-      vni: 6000
-      route_distinguisher: "50:20"
-      route_target_import: auto
-      route_target_export: auto
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_evpn_vni: *evpn_vni1
-    register: result
-
-  - assert: *false
-
-  - name: "Configure nxos_evpn_vni"
-    nxos_evpn_vni: &evpn_vni_def
-      vni: 6000
-      route_distinguisher: default
-      route_target_import: default
-      route_target_export: default
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_evpn_vni: *evpn_vni_def
-    register: result
-
-  - assert: *false
-
-  - name: "remove nxos_evpn_vni"
-    nxos_evpn_vni: &rvni
-      vni: 6000
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_evpn_vni: *rvni
-    register: result
-
-  - assert: *false
-
-  when: nvoe_supported
-
-
-  always:
-  - block:
-    - name: "Remove nv overlay evpn"
-      nxos_config: *remove_evpn
-      ignore_errors: yes
-
-    - name: "Disable feature bgp"
-      nxos_feature:
-        feature: bgp
-        state: disabled
-      ignore_errors: yes
-    when: nvoe_supported
-
-- debug: msg="END connection={{ ansible_connection }} nxos_evpn_vni sanity test"
diff --git a/test/integration/targets/nxos_facts/defaults/main.yaml b/test/integration/targets/nxos_facts/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_facts/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_facts/meta/main.yml b/test/integration/targets/nxos_facts/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_facts/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_facts/tasks/cli.yaml b/test/integration/targets/nxos_facts/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_facts/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_facts/tasks/main.yaml b/test/integration/targets/nxos_facts/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_facts/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_facts/tasks/nxapi.yaml b/test/integration/targets/nxos_facts/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_facts/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_facts/tests/common/all_facts.yaml b/test/integration/targets/nxos_facts/tests/common/all_facts.yaml
deleted file mode 100644
index 530ccca1ca..0000000000
--- a/test/integration/targets/nxos_facts/tests/common/all_facts.yaml
+++ /dev/null
@@ -1,31 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }}/all_facts.yaml"
-
-- name: test getting all facts
-  nxos_facts:
-    gather_subset:
-      - all
-  register: result
-
-- assert:
-    that:
-      # _facts modules should never report a change
-      - "result.changed == false"
-
-      # Correct subsets are present
-      - "'config' in result.ansible_facts.ansible_net_gather_subset"
-      - "'hardware' in result.ansible_facts.ansible_net_gather_subset"
-      - "'default' in result.ansible_facts.ansible_net_gather_subset"
-      - "'interfaces' in result.ansible_facts.ansible_net_gather_subset"
-
-      # Items from those subsets are present
-      - "result.ansible_facts.ansible_net_filesystems is defined"
-      - "result.ansible_facts.ansible_net_interfaces is defined"
-      - "result.ansible_facts.ansible_net_config is defined"
-      - "result.ansible_facts.ansible_net_model is defined"
-
-      # Check that these facts not only are present, but are valid (positive integers)
-      - "result.ansible_facts.ansible_net_memfree_mb > 1"
-      - "result.ansible_facts.ansible_net_memtotal_mb > 1"
-
-- debug: msg="END connection={{ ansible_connection }}/all_facts.yaml"
diff --git a/test/integration/targets/nxos_facts/tests/common/default_facts.yaml b/test/integration/targets/nxos_facts/tests/common/default_facts.yaml
deleted file mode 100644
index 1a3c4cb33f..0000000000
--- a/test/integration/targets/nxos_facts/tests/common/default_facts.yaml
+++ /dev/null
@@ -1,32 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }}/default_facts.yaml"
-
-- name: test getting default facts
-  nxos_facts:
-  register: result
-
-- assert:
-    that:
-      # _facts modules should never report a change
-      - "result.changed == false"
-
-      # Correct subsets are present
-      - "'hardware' in result.ansible_facts.ansible_net_gather_subset"
-      - "'default' in result.ansible_facts.ansible_net_gather_subset"
-      - "'interfaces' in result.ansible_facts.ansible_net_gather_subset"
-      - "result.ansible_facts.ansible_net_filesystems is defined"
-      # ... and not present
-      - "'config' not in result.ansible_facts.ansible_net_gather_subset"
-
-      # Items from those subsets are present
-      - "result.ansible_facts.ansible_net_filesystems is defined" #hw
-      - "result.ansible_facts.ansible_net_memtotal_mb > 10" #hw
-      - "result.ansible_facts.ansible_net_model is defined" #default
-      - "result.ansible_facts.ansible_net_interfaces is defined" #interfaces
-      # FIXME
-#      - "result.ansible_facts.ansible_net_interfaces.Ethernet1.ipv4.masklen > 1" # interfaces
-
-      # ... and not present
-      - "result.ansible_facts.ansible_net_config is not defined" # config
-
-- debug: msg="END cli/default.yaml"
diff --git a/test/integration/targets/nxos_facts/tests/common/invalid_subset.yaml b/test/integration/targets/nxos_facts/tests/common/invalid_subset.yaml
deleted file mode 100644
index 048d2c54a2..0000000000
--- a/test/integration/targets/nxos_facts/tests/common/invalid_subset.yaml
+++ /dev/null
@@ -1,20 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }}/invalid_subset.yaml"
-
-- name: test invalid subset (foobar)
-  nxos_facts:
-    gather_subset:
-      - "foobar"
-  register: result
-  ignore_errors: true
-
-- assert:
-    that:
-      # Failures shouldn't return changes
-      - "result.changed == false"
-      # It's a failure
-      - "result.failed == true"
-      # Sensible Failure message
-      - "'Subset must be one of' in result.msg"
-
-- debug: msg="END connection={{ ansible_connection }}/invalid_subset.yaml"
diff --git a/test/integration/targets/nxos_facts/tests/common/not_hardware.yaml b/test/integration/targets/nxos_facts/tests/common/not_hardware.yaml
deleted file mode 100644
index 0e54e51950..0000000000
--- a/test/integration/targets/nxos_facts/tests/common/not_hardware.yaml
+++ /dev/null
@@ -1,28 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }}/not_hardware_facts.yaml"
-
-- name: test not hardware
-  nxos_facts:
-    gather_subset:
-      - "!hardware"
-  register: result
-
-- assert:
-    that:
-      # _facts modules should never report a change
-      - "result.changed == false"
-
-      # Correct subsets are present
-      - "'config' in result.ansible_facts.ansible_net_gather_subset"
-      - "'default' in result.ansible_facts.ansible_net_gather_subset"
-      - "'interfaces' in result.ansible_facts.ansible_net_gather_subset"
-      # ... and not present
-      - "'hardware' not in result.ansible_facts.ansible_net_gather_subset"
-
-      # Items from those subsets are present
-      # FIXME
-#      - "result.ansible_facts.ansible_net_interfaces.['Ethernet2/15'].mtu > 1" # interfaces
-      # ... and not present
-      - "result.ansible_facts.ansible_net_filesystems is not defined"
-
-- debug: msg="END connection={{ ansible_connection }}/not_hardware_facts.yaml"
diff --git a/test/integration/targets/nxos_facts/tests/common/sanity.yaml b/test/integration/targets/nxos_facts/tests/common/sanity.yaml
deleted file mode 100644
index 728852b881..0000000000
--- a/test/integration/targets/nxos_facts/tests/common/sanity.yaml
+++ /dev/null
@@ -1,91 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_facts sanity test"
-
-- name: "nxos_facts gather hardware facts"
-  nxos_facts:
-    gather_subset: hardware
-  register: result
-
-- assert:
-    that:
-      # _facts modules should never report a change
-      - "result.changed == false"
-
-      # Correct subsets are present
-      - "'hardware' in result.ansible_facts.ansible_net_gather_subset"
-
-      # Other facts are not present
-      - "'config' not in result.ansible_facts.ansible_net_gather_subset"
-      - "'interfaces' not in result.ansible_facts.ansible_net_gather_subset"
-
-      # Items from those subsets are present
-      - "result.ansible_facts.ansible_net_filesystems is defined"
-
-      # Check that these facts not only are present, but are valid (positive integers)
-      - "result.ansible_facts.ansible_net_memfree_mb > 1"
-      - "result.ansible_facts.ansible_net_memtotal_mb > 1"
-
-- name: "nxos_facts gather config facts"
-  nxos_facts:
-    gather_subset: config
-  register: result
-
-- assert:
-    that:
-      # _facts modules should never report a change
-      - "result.changed == false"
-
-      # Correct subsets are present
-      - "'config' in result.ansible_facts.ansible_net_gather_subset"
-
-      # Other facts are not present
-      - "'hardware' not in result.ansible_facts.ansible_net_gather_subset"
-      - "'interfaces' not in result.ansible_facts.ansible_net_gather_subset"
-
-      # Items from those subsets are present
-      - "result.ansible_facts.ansible_net_config is defined"
-
-- name: "nxos_facts gather config and hardware facts"
-  nxos_facts:
-    gather_subset:
-      - hardware
-      - config
-  register: result
-
-- assert:
-    that:
-      # _facts modules should never report a change
-      - "result.changed == false"
-
-      # Correct subsets are present
-      - "'hardware' in result.ansible_facts.ansible_net_gather_subset"
-      - "'config' in result.ansible_facts.ansible_net_gather_subset"
-
-      # Other facts are not present
-      - "'interfaces' not in result.ansible_facts.ansible_net_gather_subset"
-
-      # Items from those subsets are present
-      - "result.ansible_facts.ansible_net_filesystems is defined"
-      - "result.ansible_facts.ansible_net_config is defined"
-
-      # Check that these facts not only are present, but are valid (positive integers)
-      - "result.ansible_facts.ansible_net_memfree_mb > 1"
-      - "result.ansible_facts.ansible_net_memtotal_mb > 1"
-
-- name: "nxos_facts gather features facts"
-  nxos_facts:
-    gather_subset: features
-  register: result
-
-- assert:
-    that:
-      # _facts modules should never report a change
-      - "result.changed == false"
-
-      # Correct subsets are present
-      - "'features' in result.ansible_facts.ansible_net_gather_subset"
-
-      # Items from the subset is present
-      - "result.ansible_facts.ansible_net_features_enabled is defined"
-
-- debug: msg="END connection={{ ansible_connection }} nxos_facts sanity test"
diff --git a/test/integration/targets/nxos_feature/defaults/main.yaml b/test/integration/targets/nxos_feature/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_feature/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_feature/meta/main.yml b/test/integration/targets/nxos_feature/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_feature/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_feature/tasks/cli.yaml b/test/integration/targets/nxos_feature/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_feature/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_feature/tasks/main.yaml b/test/integration/targets/nxos_feature/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_feature/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_feature/tasks/nxapi.yaml b/test/integration/targets/nxos_feature/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_feature/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_feature/tests/common/configure.yaml b/test/integration/targets/nxos_feature/tests/common/configure.yaml
deleted file mode 100644
index 2c02bea4c8..0000000000
--- a/test/integration/targets/nxos_feature/tests/common/configure.yaml
+++ /dev/null
@@ -1,54 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }}/configure.yaml"
-
-- name: setup
-  nxos_config:
-    lines: no feature bgp
-    match: none
-
-- name: enable bgp
-  nxos_feature:
-    feature: bgp
-    state: enabled
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: verify bgp
-  nxos_feature:
-    feature: bgp
-    state: enabled
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: disable bgp
-  nxos_feature:
-    feature: bgp
-    state: disabled
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: verify bgp
-  nxos_feature:
-    feature: bgp
-    state: disabled
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config:
-    lines: no feature bgp
-    match: none
-
-- debug: msg="END connection={{ ansible_connection }}/configure.yaml"
diff --git a/test/integration/targets/nxos_feature/tests/common/invalid.yaml b/test/integration/targets/nxos_feature/tests/common/invalid.yaml
deleted file mode 100644
index 477eaf6416..0000000000
--- a/test/integration/targets/nxos_feature/tests/common/invalid.yaml
+++ /dev/null
@@ -1,14 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }}/invalid.yaml"
-
-- name: configure invalid feature name
-  nxos_feature:
-    feature: invalid
-  register: result
-  ignore_errors: yes
-
-- assert:
-    that:
-      - result.failed == true
-
-- debug: msg="END connection={{ ansible_connection }}/invalid.yaml"
diff --git a/test/integration/targets/nxos_file_copy/defaults/main.yaml b/test/integration/targets/nxos_file_copy/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_file_copy/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_file_copy/meta/main.yml b/test/integration/targets/nxos_file_copy/meta/main.yml
deleted file mode 100644
index 1530e79eed..0000000000
--- a/test/integration/targets/nxos_file_copy/meta/main.yml
+++ /dev/null
@@ -1,5 +0,0 @@
-dependencies:
-  # prepare_nxos_tests is not needed for this test and simply adds overhead.
-  # This can be uncommented in the future if needed.
-  #
-  # - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_file_copy/tasks/cli.yaml b/test/integration/targets/nxos_file_copy/tasks/cli.yaml
deleted file mode 100644
index 9243812668..0000000000
--- a/test/integration/targets/nxos_file_copy/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_file_copy/tasks/main.yaml b/test/integration/targets/nxos_file_copy/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_file_copy/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_file_copy/tasks/nxapi.yaml b/test/integration/targets/nxos_file_copy/tasks/nxapi.yaml
deleted file mode 100644
index 653bcfefe9..0000000000
--- a/test/integration/targets/nxos_file_copy/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_file_copy/tests/cli/input_validation.yaml b/test/integration/targets/nxos_file_copy/tests/cli/input_validation.yaml
deleted file mode 100644
index 7f747a02f4..0000000000
--- a/test/integration/targets/nxos_file_copy/tests/cli/input_validation.yaml
+++ /dev/null
@@ -1,66 +0,0 @@
----
-- debug: msg="START nxos_file_copy input_validation test"
-
-- name: "Input Validation - param should be type <path>"
-  nxos_file_copy:
-    remote_file: 500
-    file_pull: True
-  register: result
-  ignore_errors: true
-
-- assert:
-    that:
-      - not result is search('argument remote_file is of type')
-
-- name: "Input Validation - param should be type <int>"
-  nxos_file_copy:
-    file_pull_timeout: 'foobar'
-  register: result
-  ignore_errors: true
-
-- assert:
-    that:
-      - result is search("argument file_pull_timeout is of type <class 'ansible.parsing.yaml.objects.AnsibleUnicode'> and we were unable to convert to int")
-
-- name: "Input Validation - param should be type <bool>"
-  nxos_file_copy:
-    file_pull: 'foobar'
-  register: result
-  ignore_errors: true
-
-- assert:
-    that:
-      - result is search("argument file_pull is of type <class 'ansible.parsing.yaml.objects.AnsibleUnicode'> and we were unable to convert to bool")
-
-- name: "Input Validation - param <file_pull> <remote_file> dependency"
-  nxos_file_copy:
-    file_pull: True
-  register: result
-  ignore_errors: true
-
-- assert:
-    that:
-      - result is search("Playbook parameter <remote_file> required when <file_pull> is True")
-
-- name: "Input Validation - param <file_pull> <remote_scp_server> dependency"
-  nxos_file_copy:
-    file_pull: True
-    remote_file: "/network-integration.cfg"
-  register: result
-  ignore_errors: true
-
-- assert:
-    that:
-      - result is search('Playbook parameter <remote_scp_server> required when <file_pull> is True')
-
-- name: "Input Validation - remote_scp_server params together"
-  nxos_file_copy:
-    remote_scp_server: "{{ inventory_hostname_short }}"
-  register: result
-  ignore_errors: true
-
-- assert:
-    that:
-      - result is search('Playbook parameters <remote_scp_server>, <remote_scp_server_user> must be set together')
-
-- debug: msg="END nxos_file_copy input_validation test"
diff --git a/test/integration/targets/nxos_file_copy/tests/cli/negative.yaml b/test/integration/targets/nxos_file_copy/tests/cli/negative.yaml
deleted file mode 100644
index 58d091663c..0000000000
--- a/test/integration/targets/nxos_file_copy/tests/cli/negative.yaml
+++ /dev/null
@@ -1,133 +0,0 @@
----
-- debug: msg="START nxos_file_copy negative test"
-
-# This test uses a file that is committed to the Ansible core repository.
-# The file name and relative path is test/integration/targets/network-integration.cfg
-- set_fact: test_source_file="network-integration.cfg"
-- set_fact: test_destination_file="test_destination_file"
-
-# -------------------------
-# Tests for file_pull False
-# -------------------------
-- name: "Attempt to copy file to invalid file_system"
-  nxos_file_copy:
-    file_pull: False
-    local_file: "./{{ test_source_file }}"
-    file_system: "invalid_media_type:"
-    connect_ssh_port: "{{ ansible_ssh_port }}"
-  register: result
-  ignore_errors: true
-
-- assert:
-    that:
-      - result is search('Invalid nxos filesystem invalid_media_type:')
-
-- name: "Attempt to copy source file that does not exist on Ansible controller"
-  nxos_file_copy:
-    file_pull: False
-    local_file: "./{{ test_source_file }}_does_not_exist"
-    file_system: "bootflash:"
-    connect_ssh_port: "{{ ansible_ssh_port }}"
-  register: result
-  ignore_errors: true
-
-- assert:
-    that:
-      - result is search('Local file ./network-integration.cfg_does_not_exist not found')
-
-# -------------------------
-# Tests for file_pull True
-# -------------------------
-- name: "Try and copy file using an invalid remote scp server name"
-  nxos_file_copy:
-    file_pull: True
-    file_pull_timeout: 10
-    remote_file: "/{{ test_destination_file }}"
-    local_file: "{{ test_destination_file }}_copy"
-    local_file_directory: "dir1/dir2/dir3"
-    remote_scp_server: "scp_server_gone.example.com"
-    remote_scp_server_user: "{{ ansible_ssh_user }}"
-    remote_scp_server_password: "{{ ansible_ssh_pass }}"
-  register: result
-  ignore_errors: true
-
-- assert:
-    that:
-        - "result.changed == false"
-        - "'copy scp:' in result.copy_cmd"
-        - "'bootflash:' in result.file_system"
-        - "'No Transfer' in result.transfer_status"
-
-- assert:
-    that:
-        - result.error_data is search("ERROR Could not resolve hostname|Copying to.*from this server name is not permitted")
-
-- name: "Try and copy file using an invalid remote scp server ip address"
-  nxos_file_copy:
-    file_pull: True
-    file_pull_timeout: 300
-    remote_file: "/{{ test_destination_file }}"
-    local_file: "{{ test_destination_file }}_copy"
-    local_file_directory: "dir1/dir2/dir3"
-    remote_scp_server: "192.168.55.55"
-    remote_scp_server_user: "{{ ansible_ssh_user }}"
-    remote_scp_server_password: "{{ ansible_ssh_pass }}"
-  register: result
-  ignore_errors: true
-
-- assert:
-    that:
-        - "result.changed == false"
-        - "'copy scp:' in result.copy_cmd"
-        - "'timed out' in result.error_data"
-        - "'bootflash:' in result.file_system"
-        - "'No Transfer' in result.transfer_status"
-
-# Sometimes the previous negative test needs a few seconds after the timeout
-# failure before the next negative test is executed.
-- pause:
-    seconds: 10
-
-- name: "Try and copy file using an invalid username"
-  nxos_file_copy:
-    file_pull: True
-    file_pull_timeout: 10
-    remote_file: "/{{ test_destination_file }}"
-    local_file: "{{ test_destination_file }}_copy"
-    local_file_directory: "dir1/dir2/dir3"
-    remote_scp_server: "{{ inventory_hostname_short }}"
-    remote_scp_server_user: "invalid_user_name"
-    remote_scp_server_password: "{{ ansible_ssh_pass }}"
-  register: result
-  ignore_errors: true
-
-- assert:
-    that:
-        - "result.changed == false"
-        - "'copy scp:' in result.copy_cmd"
-        - "'Too many authentication failures' in result.error_data"
-        - "'bootflash:' in result.file_system"
-        - "'No Transfer' in result.transfer_status"
-
-- name: "Try and copy file using an invalid password"
-  nxos_file_copy:
-    file_pull: True
-    file_pull_timeout: 10
-    remote_file: "/{{ test_destination_file }}"
-    local_file: "{{ test_destination_file }}_copy"
-    local_file_directory: "dir1/dir2/dir3"
-    remote_scp_server: "{{ inventory_hostname_short }}"
-    remote_scp_server_user: "{{ ansible_ssh_user }}"
-    remote_scp_server_password: "invalid_password"
-  register: result
-  ignore_errors: true
-
-- assert:
-    that:
-        - "result.changed == false"
-        - "'copy scp:' in result.copy_cmd"
-        - "'Too many authentication failures' in result.error_data"
-        - "'bootflash:' in result.file_system"
-        - "'No Transfer' in result.transfer_status"
-
-- debug: msg="END nxos_file_copy negative test"
diff --git a/test/integration/targets/nxos_file_copy/tests/cli/sanity.yaml b/test/integration/targets/nxos_file_copy/tests/cli/sanity.yaml
deleted file mode 100644
index 3fa3ea84f3..0000000000
--- a/test/integration/targets/nxos_file_copy/tests/cli/sanity.yaml
+++ /dev/null
@@ -1,137 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_file_copy sanity test"
-
-# This test uses a file that is committed to the Ansible core repository.
-# The file name and relative path is test/integration/targets/network-integration.cfg
-- set_fact: test_source_file="network-integration.cfg"
-- set_fact: test_destination_file="test_destination_file"
-
-- name: "Setup - Remove existing file"
-  nxos_command: &remove_file
-    commands:
-      - terminal dont-ask
-      - "delete {{ test_source_file }}"
-      - "delete {{ test_destination_file }}"
-      - "delete bootflash:/dir1/dir2/dir3/*"
-      - rmdir dir1/dir2/dir3
-      - rmdir dir1/dir2
-      - rmdir dir1
-  ignore_errors: yes
-
-- name: "Setup - Turn on feature scp-server"
-  nxos_feature:
-    feature: scp-server
-    state: enabled
-
-- block:
-  - name: "Copy {{ test_source_file }} file from Ansible controller to bootflash"
-    nxos_file_copy: &copy_file_same_name
-      local_file: "./{{ test_source_file }}"
-      file_system: "bootflash:"
-      connect_ssh_port: "{{ ansible_ssh_port }}"
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'bootflash:' in result.file_system"
-        - "'./{{ test_source_file }}' in result.local_file"
-        - "'network-integration.cfg' in result.remote_file"
-        - "'Sent: File copied to remote device.' in result.transfer_status"
-
-  - name: "Idempotence - Copy {{ test_source_file }} file from Ansible controller to bootflash"
-    nxos_file_copy: *copy_file_same_name
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "Setup - Remove existing file"
-    nxos_command: *remove_file
-    register: result
-
-  - name: "Copy {{ test_source_file }} file from Ansible controller to bootflash renamed as {{ test_destination_file }}"
-    nxos_file_copy: &copy_file_different_name
-      local_file: "./{{ test_source_file }}"
-      remote_file: "{{ test_destination_file }}"
-      file_system: "bootflash:"
-      connect_ssh_port: "{{ ansible_ssh_port }}"
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'bootflash:' in result.file_system"
-        - "'./{{ test_source_file }}' in result.local_file"
-        - "'{{ test_destination_file }}' in result.remote_file"
-        - "'Sent: File copied to remote device.' in result.transfer_status"
-
-  - name: "Idempotence - Copy {{ test_source_file }} file from Ansible controller to bootflash renamed as {{ test_destination_file }}"
-    nxos_file_copy: *copy_file_different_name
-    register: result
-
-  - name: "Verify file_pull true options have no impact when file_true is false"
-    nxos_file_copy:
-      file_pull: False
-      file_pull_timeout: 1200
-      file_pull_compact: True
-      file_pull_kstack: True
-      local_file_directory: "dir1/dir2/dir3"
-      remote_scp_server: "{{ inventory_hostname_short }}"
-      remote_scp_server_user: "{{ ansible_ssh_user }}"
-      remote_scp_server_password: "{{ ansible_ssh_pass }}"
-      # Parameters above are only used when file_pull is True
-      local_file: "./{{ test_source_file }}"
-      remote_file: "{{ test_destination_file }}"
-      file_system: "bootflash:"
-      connect_ssh_port: "{{ ansible_ssh_port }}"
-    register: result
-
-  - assert: *false
-
-  # This step validates the ability to initiate the copy from the nxos device
-  # to pull a file from a remote file server to the nxos bootflash device.
-  #
-  # In this case we are using the nxos device as the remote file server so we
-  # copy a file from bootflash: to bootflash:dir1/dir2/dir3
-  - name: "Initiate copy from nxos device to copy {{ test_destination_file }} to bootflash:dir1/dir2/dir3/{{ test_destination_file }}_copy"
-    nxos_file_copy: &copy_pull
-      file_pull: True
-      file_pull_timeout: 30
-      remote_file: "/{{ test_destination_file }}"
-      local_file: "{{ test_destination_file }}_copy"
-      local_file_directory: "dir1/dir2/dir3"
-      remote_scp_server: "{{ inventory_hostname_short }}"
-      remote_scp_server_user: "{{ ansible_ssh_user }}"
-      remote_scp_server_password: "{{ ansible_ssh_pass }}"
-    register: result
-
-  - assert: &overwrite
-      that:
-        - "result.changed == true"
-        - "'copy scp:' in result.copy_cmd"
-        - "'bootflash:' in result.file_system"
-        - "'bootflash:dir1/dir2/dir3/{{ test_destination_file }}_copy' in result.local_file"
-        - "'/{{ test_destination_file }}' in result.remote_file"
-        - "'Received: File copied/pulled to nxos device from remote scp server.' in result.transfer_status"
-        - "'{{ inventory_hostname_short }}' in result.remote_scp_server"
-
-  - name: "Overwrite the file"
-    nxos_file_copy: *copy_pull
-    register: result
-
-  - assert: *overwrite
-
-  always:
-
-  - name: "Remove file"
-    nxos_command: *remove_file
-    ignore_errors: yes
-
-  - name: "Turn off feature scp-server"
-    nxos_feature:
-      feature: scp-server
-      state: disabled
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_file_copy sanity test"
diff --git a/test/integration/targets/nxos_file_copy/tests/nxapi/badtransport.yaml b/test/integration/targets/nxos_file_copy/tests/nxapi/badtransport.yaml
deleted file mode 100644
index d6f629af35..0000000000
--- a/test/integration/targets/nxos_file_copy/tests/nxapi/badtransport.yaml
+++ /dev/null
@@ -1,16 +0,0 @@
----
-- debug: msg="START nxapi/badtransport.yaml"
-
-- name: Sending transport other than cli should fail
-  nxos_file_copy:
-    local_file: "./network-integration.cfg"
-    file_system: "bootflash:"
-    connect_ssh_port: "{{ ansible_ssh_port }}"
-  register: result
-  ignore_errors: yes
-
-- assert:
-     that:
-        - result.failed and result.msg is search('Connection type must be <network_cli>')
-
-- debug: msg="END nxapi/badtransport.yaml"
diff --git a/test/integration/targets/nxos_gir/defaults/main.yaml b/test/integration/targets/nxos_gir/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_gir/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_gir/meta/main.yml b/test/integration/targets/nxos_gir/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_gir/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_gir/tasks/cli.yaml b/test/integration/targets/nxos_gir/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_gir/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_gir/tasks/main.yaml b/test/integration/targets/nxos_gir/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_gir/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_gir/tasks/nxapi.yaml b/test/integration/targets/nxos_gir/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_gir/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_gir/tests/common/sanity.yaml b/test/integration/targets/nxos_gir/tests/common/sanity.yaml
deleted file mode 100644
index 99e3292dc7..0000000000
--- a/test/integration/targets/nxos_gir/tests/common/sanity.yaml
+++ /dev/null
@@ -1,112 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_gir sanity test"
-- set_fact: gir_run='{{ true if (platform is not search("N35")) else false }}'
-
-- name: Setup0
-  nxos_config: &cleanup0
-    lines:
-      - no system mode maintenance timeout 30
-      - no configure maintenance profile normal-mode
-      - no configure maintenance profile maintenance-mode
-    match: none
-  ignore_errors: yes
-
-- name: Setup1
-  nxos_gir:
-    system_mode_maintenance: false
-  ignore_errors: yes
-
-- block:
-  - name: "Put system in maintenance mode with reload reset reason"
-    nxos_gir: &reset_reason
-      system_mode_maintenance_on_reload_reset_reason: manual_reload
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_gir: *reset_reason
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "Remove reload reason"
-    nxos_gir: &remove_reason
-      system_mode_maintenance_on_reload_reset_reason: manual_reload
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_gir: *remove_reason
-    register: result
-
-  - assert: *false
-
-  - name: "Put system in maintenance mode with timeout"
-    nxos_gir: &mtime
-      system_mode_maintenance_timeout: 30
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_gir: *mtime
-    register: result
-
-  - assert: *false
-
-  - name: "Remove maintenance mode timeout"
-    nxos_gir: &remove_timeout
-      system_mode_maintenance_timeout: 30
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_gir: *remove_timeout
-    register: result
-
-  - assert: *false
-
-  - name: "Put system in maintenance mode"
-    nxos_gir: &configure_system_mode_maintenance
-      system_mode_maintenance: true
-    register: result
-
-  - assert: *true
-
-  when: gir_run
-
-  rescue:
-
-  - debug: msg="connection={{ ansible_connection }} nxos_gir failure detected"
-
-  always:
-
-  - name: "Remove snapshots"
-    nxos_snapshot:
-      action: delete_all
-    ignore_errors: yes
-
-  - name: Teardown0
-    nxos_config: *cleanup0
-    ignore_errors: yes
-
-  - name: "Put system back in normal mode"
-    nxos_gir:
-      system_mode_maintenance: false
-    # Try again if cli is blocking while changing modes
-    retries: 3
-    delay: 30
-    register: result
-    until: result is not failed
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_gir sanity test"
diff --git a/test/integration/targets/nxos_gir_profile_management/defaults/main.yaml b/test/integration/targets/nxos_gir_profile_management/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_gir_profile_management/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_gir_profile_management/meta/main.yml b/test/integration/targets/nxos_gir_profile_management/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_gir_profile_management/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_gir_profile_management/tasks/cli.yaml b/test/integration/targets/nxos_gir_profile_management/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_gir_profile_management/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_gir_profile_management/tasks/main.yaml b/test/integration/targets/nxos_gir_profile_management/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_gir_profile_management/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_gir_profile_management/tasks/nxapi.yaml b/test/integration/targets/nxos_gir_profile_management/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_gir_profile_management/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_gir_profile_management/tests/common/sanity.yaml b/test/integration/targets/nxos_gir_profile_management/tests/common/sanity.yaml
deleted file mode 100644
index 5911da91bb..0000000000
--- a/test/integration/targets/nxos_gir_profile_management/tests/common/sanity.yaml
+++ /dev/null
@@ -1,104 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_gir_profile_management sanity test"
-
-- name: "Setup - Remove maintenace mode profiles"
-  nxos_gir_profile_management: &remove_maintenance
-    mode: maintenance
-    state: absent    
-  ignore_errors: yes
-
-- name: "Setup - Remove normal mode profiles"
-  nxos_gir_profile_management: &remove_normal
-    mode: normal
-    state: absent
-  ignore_errors: yes
-
-- name: "Setup - Turn on feature eigrp"
-  nxos_feature: 
-    feature: eigrp
-    state: enabled
-  ignore_errors: yes
-
-- block:
-  - name: "Create maintenace mode profile"
-    nxos_gir_profile_management: &create_maintenance_profile
-      mode: maintenance
-      commands:
-        - router eigrp 11
-        - isolate
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence - Create maintenace mode profile"
-    nxos_gir_profile_management: *create_maintenance_profile
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "Create normal mode profile"
-    nxos_gir_profile_management: &create_normal_profile
-      mode: normal
-      commands:
-        - router eigrp 11
-        - isolate
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Create normal mode profile"
-    nxos_gir_profile_management: *create_normal_profile
-    register: result
-
-  - assert: *false
-
-  - name: "Remove maintenance mode profile"
-    nxos_gir_profile_management: *remove_maintenance
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Remove maintenance mode profile"
-    nxos_gir_profile_management: *remove_maintenance
-    register: result
-
-  - assert: *false
-
-  - name: "Remove normal mode profile"
-    nxos_gir_profile_management: *remove_normal
-    register: result 
-
-  - assert: *true
-
-  - name: "Check Idempotence - Remove normal mode profile"
-    nxos_gir_profile_management: *remove_normal
-    register: result
-
-  - assert: *false
-
-  when: not ( platform is match('N35')) and not titanium
-
-  rescue:
-
-  - debug: msg="connection={{ ansible_connection }} nxos_gir_profile_management failure detected"
-
-  always:
-
-  - name: "Remove normal mode profile"
-    nxos_gir_profile_management: *remove_normal
-
-  - name: "Remove maintenance mode profile"
-    nxos_gir_profile_management: *remove_maintenance
-
-  - name: "Turn off feature eigrp"
-    nxos_feature:
-      feature: eigrp
-      state: disabled
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_gir_profile_management sanity test"  
diff --git a/test/integration/targets/nxos_hsrp/defaults/main.yaml b/test/integration/targets/nxos_hsrp/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_hsrp/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_hsrp/meta/main.yml b/test/integration/targets/nxos_hsrp/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_hsrp/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_hsrp/tasks/cli.yaml b/test/integration/targets/nxos_hsrp/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_hsrp/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_hsrp/tasks/main.yaml b/test/integration/targets/nxos_hsrp/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_hsrp/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_hsrp/tasks/nxapi.yaml b/test/integration/targets/nxos_hsrp/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_hsrp/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_hsrp/tests/common/sanity.yaml b/test/integration/targets/nxos_hsrp/tests/common/sanity.yaml
deleted file mode 100644
index 9e09820a9f..0000000000
--- a/test/integration/targets/nxos_hsrp/tests/common/sanity.yaml
+++ /dev/null
@@ -1,152 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_hsrp sanity test"
-
-# Select interface for test
-- set_fact: intname1="{{ nxos_int1 }}"
-- set_fact: intname2="{{ nxos_int2 }}"
-
-- block:
-  - name: "Enable feature hsrp"
-    nxos_feature:
-      feature: hsrp
-      state: enabled
-
-  - name: "change int1 mode"
-    nxos_config:
-      commands:
-        - no switchport
-      parents:
-        - "interface {{ intname1 }}"
-      match: none
-
-  - name: "change int2 mode"
-    nxos_config:
-      commands:
-        - no switchport
-      parents:
-        - "interface {{ intname2 }}"
-      match: none
-
-  - name: "configure nxos_hsrp"
-    nxos_hsrp: &conf1000
-      group: 1000
-      version: 2
-      vip: 10.1.1.1
-      priority: 150
-      interface: "{{ intname1 }}"
-      preempt: enabled
-      auth_type: md5
-      auth_string: "7 1234"
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Conf Idempotence"
-    nxos_hsrp: *conf1000
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "configure group 100"
-    nxos_hsrp: &conf100
-      group: 100
-      version: 2
-      vip: 192.0.2.2
-      priority: 25
-      interface: "{{ intname1 }}"
-      preempt: enabled
-      auth_type: md5
-      auth_string: "0 1234"
-    register: result
-
-  - assert: *true
-
-  - name: "Conf Idempotence"
-    nxos_hsrp: *conf100
-    register: result
-
-  - assert: *false
-
-  - name: "change group 100"
-    nxos_hsrp: &chg100
-      group: 100
-      version: 2
-      vip: default
-      priority: default
-      interface: "{{ intname1 }}"
-      preempt: disabled
-      auth_type: md5
-      auth_string: "0 1234"
-    register: result
-
-  - assert: *true
-
-  - name: "Conf Idempotence"
-    nxos_hsrp: *chg100
-    register: result
-
-  - assert: *false
-
-  - name: "configure group 200"
-    nxos_hsrp: &conf200
-      group: 200
-      vip: 192.0.2.3
-      version: 1
-      interface: "{{ intname2 }}"
-      auth_type: text
-      auth_string: "1234"
-    register: result
-
-  - assert: *true
-
-  - name: "Conf Idempotence"
-    nxos_hsrp: *conf200
-    register: result
-
-  - assert: *false
-
-  - name: "change group 200"
-    nxos_hsrp: &chg200
-      group: 200
-      vip: 192.0.2.3
-      version: 2
-      interface: "{{ intname2 }}"
-      auth_type: text
-      auth_string: default
-    register: result
-
-  - assert: *true
-
-  - name: "Conf Idempotence"
-    nxos_hsrp: *chg200
-    register: result
-
-  - assert: *false
-
-  - name: "remove nxos_hsrp"
-    nxos_hsrp: &remove
-      group: 1000
-      interface: "{{ intname1 }}"
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Remove Idempotence"
-    nxos_hsrp: *remove
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: "Disable feature hsrp"
-    nxos_feature:
-      feature: hsrp
-      state: disabled
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_hsrp sanity test"
diff --git a/test/integration/targets/nxos_hsrp_interfaces/defaults/main.yaml b/test/integration/targets/nxos_hsrp_interfaces/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_hsrp_interfaces/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_hsrp_interfaces/meta/main.yml b/test/integration/targets/nxos_hsrp_interfaces/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_hsrp_interfaces/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_hsrp_interfaces/tasks/cli.yaml b/test/integration/targets/nxos_hsrp_interfaces/tasks/cli.yaml
deleted file mode 100644
index 6c7ea4a7f9..0000000000
--- a/test/integration/targets/nxos_hsrp_interfaces/tasks/cli.yaml
+++ /dev/null
@@ -1,20 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_hsrp_interfaces/tasks/main.yaml b/test/integration/targets/nxos_hsrp_interfaces/tasks/main.yaml
deleted file mode 100644
index 415c99d8b1..0000000000
--- a/test/integration/targets/nxos_hsrp_interfaces/tasks/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
diff --git a/test/integration/targets/nxos_hsrp_interfaces/tasks/nxapi.yaml b/test/integration/targets/nxos_hsrp_interfaces/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_hsrp_interfaces/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_hsrp_interfaces/tests/cli/deleted.yaml b/test/integration/targets/nxos_hsrp_interfaces/tests/cli/deleted.yaml
deleted file mode 100644
index 01331dfd2d..0000000000
--- a/test/integration/targets/nxos_hsrp_interfaces/tests/cli/deleted.yaml
+++ /dev/null
@@ -1,57 +0,0 @@
----
-- debug:
-    msg: "Start nxos_hsrp_interfaces deleted integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact: test_int2="{{ nxos_int2 }}"
-- set_fact:
-    bfd_enable: enable
-    bfd_disable: disable
-  when: platform is not search('N35')
-
-- block:
-  - name: setup1
-    cli_config: &setup_teardown
-      config: |
-        no feature bfd
-        no feature hsrp
-        default interface {{ test_int1 }}
-        default interface {{ test_int2 }}
-
-  - name: setup2
-    cli_config:
-      config: |
-        feature bfd
-        feature hsrp
-        interface {{ test_int1 }}
-          no switchport
-          hsrp bfd
-        interface {{ test_int2 }}
-          no switchport
-
-  - name: deleted
-    nxos_hsrp_interfaces: &deleted
-      config:
-        - name: "{{ test_int1 }}"
-          bfd: "{{ bfd_disable|default(omit)}}"
-      state: deleted
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'no hsrp bfd' in result.commands"
-      msg: "Assert failed. 'result.commands': {{ result.commands }}"
-
-  - name: Idempotence - deleted
-    nxos_hsrp_interfaces: *deleted
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *setup_teardown
diff --git a/test/integration/targets/nxos_hsrp_interfaces/tests/cli/merged.yaml b/test/integration/targets/nxos_hsrp_interfaces/tests/cli/merged.yaml
deleted file mode 100644
index baf56458fc..0000000000
--- a/test/integration/targets/nxos_hsrp_interfaces/tests/cli/merged.yaml
+++ /dev/null
@@ -1,65 +0,0 @@
----
-- debug:
-    msg: "Start nxos_hsrp_interfaces merged integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact: test_int2="{{ nxos_int2 }}"
-- set_fact:
-    bfd_enable: enable
-    bfd_disable: disable
-  when: platform is not search('N35')
-
-- block:
-  - name: setup1
-    cli_config: &setup_teardown
-      config: |
-        no feature bfd
-        no feature hsrp
-        default interface {{ test_int1 }}
-        default interface {{ test_int2 }}
-
-  - name: setup2
-    cli_config:
-      config: |
-        feature bfd
-        feature hsrp
-        interface {{ test_int1 }}
-          no switchport
-          hsrp bfd
-        interface {{ test_int2 }}
-          no switchport
-
-  - name: Merged
-    nxos_hsrp_interfaces: &merged
-      config:
-        - name: "{{ test_int1 }}"
-          bfd: "{{ bfd_disable|default(omit)}}"
-      state:  merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'no hsrp bfd' in result.commands"
-      msg: "Assert failed. 'result.commands': {{ result.commands }}"
-
-  - name: Gather hsrp_interfaces facts
-    nxos_facts:
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: hsrp_interfaces
-
-  - name: Idempotence - Merged
-    nxos_hsrp_interfaces: *merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-  when: bfd_enable is defined
-
-  always:
-  - name: teardown
-    cli_config: *setup_teardown
diff --git a/test/integration/targets/nxos_hsrp_interfaces/tests/cli/overridden.yaml b/test/integration/targets/nxos_hsrp_interfaces/tests/cli/overridden.yaml
deleted file mode 100644
index 5d2aa44139..0000000000
--- a/test/integration/targets/nxos_hsrp_interfaces/tests/cli/overridden.yaml
+++ /dev/null
@@ -1,58 +0,0 @@
----
-- debug:
-    msg: "Start nxos_hsrp_interfaces overridden integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact: test_int2="{{ nxos_int2 }}"
-- set_fact:
-    bfd_enable: enable
-    bfd_disable: disable
-  when: platform is not search('N35')
-
-- block:
-  - name: setup1
-    cli_config: &setup_teardown
-      config: |
-        no feature bfd
-        no feature hsrp
-        default interface {{ test_int1 }}
-        default interface {{ test_int2 }}
-
-  - name: setup2
-    cli_config:
-      config: |
-        feature bfd
-        feature hsrp
-        interface {{ test_int1 }}
-          no switchport
-        interface {{ test_int2 }}
-          no switchport
-          hsrp bfd
-
-  - name: Overridden
-    nxos_hsrp_interfaces: &overridden
-      config:
-        - name: "{{ test_int1 }}"
-          bfd: "{{ bfd_enable|default(omit)}}"
-      state: overridden
-    register: result
-
-  - assert:
-      that:
-        - result.changed == true
-        - result.commands[1] == 'no hsrp bfd'   # test_int2 reset to defaults
-        - result.commands[3] == 'hsrp bfd'      # test_int1 set to playval
-      msg: "Assert failed. 'result.commands': {{ result.commands }}"
-
-  - name: Idempotence - Overridden
-    nxos_hsrp_interfaces: *overridden
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *setup_teardown
diff --git a/test/integration/targets/nxos_hsrp_interfaces/tests/cli/replaced.yaml b/test/integration/targets/nxos_hsrp_interfaces/tests/cli/replaced.yaml
deleted file mode 100644
index 6eed615368..0000000000
--- a/test/integration/targets/nxos_hsrp_interfaces/tests/cli/replaced.yaml
+++ /dev/null
@@ -1,57 +0,0 @@
----
-- debug:
-    msg: "Start nxos_hsrp_interfaces replaced integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact: test_int2="{{ nxos_int2 }}"
-- set_fact:
-    bfd_enable: enable
-    bfd_disable: disable
-  when: platform is not search('N35')
-
-- block:
-  - name: setup1
-    cli_config: &setup_teardown
-      config: |
-        no feature bfd
-        no feature hsrp
-        default interface {{ test_int1 }}
-        default interface {{ test_int2 }}
-
-  - name: setup2
-    cli_config:
-      config: |
-        feature bfd
-        feature hsrp
-        interface {{ test_int1 }}
-          no switchport
-          hsrp bfd
-        interface {{ test_int2 }}
-          no switchport
-
-  - name: Replaced
-    nxos_hsrp_interfaces: &replaced
-      config:
-        - name: "{{ test_int1 }}"
-          bfd: "{{ bfd_disable|default(omit)}}"
-      state: replaced
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'no hsrp bfd' in result.commands"
-      msg: "Assert failed. 'result.commands': {{ result.commands }}"
-
-  - name: Idempotence - Replaced
-    nxos_hsrp_interfaces: *replaced
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *setup_teardown
diff --git a/test/integration/targets/nxos_igmp/defaults/main.yaml b/test/integration/targets/nxos_igmp/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_igmp/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_igmp/meta/main.yml b/test/integration/targets/nxos_igmp/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_igmp/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_igmp/tasks/cli.yaml b/test/integration/targets/nxos_igmp/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_igmp/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_igmp/tasks/main.yaml b/test/integration/targets/nxos_igmp/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_igmp/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_igmp/tasks/nxapi.yaml b/test/integration/targets/nxos_igmp/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_igmp/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_igmp/tests/common/sanity.yaml b/test/integration/targets/nxos_igmp/tests/common/sanity.yaml
deleted file mode 100644
index 62b2e12950..0000000000
--- a/test/integration/targets/nxos_igmp/tests/common/sanity.yaml
+++ /dev/null
@@ -1,68 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_igmp sanity test"
-
-- set_fact: restart="true"
-  when: platform is not match("N35")
-
-- block:
-
-  - name: Configure igmp with non-default values
-    nxos_igmp: &non-default
-      flush_routes: true
-      enforce_rtr_alert: true
-      restart: false
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence - Configure igmp interface with non-default values"
-    nxos_igmp: *non-default
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Configure igmp defaults
-    nxos_igmp: &default
-      flush_routes: false
-      enforce_rtr_alert: false
-      restart: "{{restart|default(omit)}}"
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Configure igmp with defaults"
-    nxos_igmp: *default
-    register: result
-
-  - assert: *false
-
-  - name: Configure igmp non-defaults again
-    nxos_igmp: *non-default
-    register: result
-
-  - name: Configure igmp state as values
-    nxos_igmp: &sdefault
-      state: default
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Configure igmp with state default"
-    nxos_igmp: *sdefault
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: Configure igmp with default values
-    nxos_igmp: *sdefault
-    register: result
-    ignore_errors: yes
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_igmp sanity test"
diff --git a/test/integration/targets/nxos_igmp_interface/defaults/main.yaml b/test/integration/targets/nxos_igmp_interface/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_igmp_interface/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_igmp_interface/meta/main.yml b/test/integration/targets/nxos_igmp_interface/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_igmp_interface/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_igmp_interface/tasks/cli.yaml b/test/integration/targets/nxos_igmp_interface/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_igmp_interface/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_igmp_interface/tasks/main.yaml b/test/integration/targets/nxos_igmp_interface/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_igmp_interface/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_igmp_interface/tasks/nxapi.yaml b/test/integration/targets/nxos_igmp_interface/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_igmp_interface/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_igmp_interface/tests/common/sanity.yaml b/test/integration/targets/nxos_igmp_interface/tests/common/sanity.yaml
deleted file mode 100644
index c3df0bb2ba..0000000000
--- a/test/integration/targets/nxos_igmp_interface/tests/common/sanity.yaml
+++ /dev/null
@@ -1,179 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_igmp_interface sanity test"
-
-# Select interface for test
-- set_fact: intname="{{ nxos_int1 }}"
-
-- set_fact: restart="true"
-  when: platform is not match("N35")
-
-- name: "Enable feature PIM"
-  nxos_feature:
-    feature: pim
-    state: enabled
-  ignore_errors: yes
-
-- name: Put interface in default mode
-  nxos_config:
-    commands:
-    - "default interface {{ intname }}"
-    match: none
-  ignore_errors: yes
-
-- block:
-
-  - name: put interface in L3 and enable PIM
-    nxos_config:
-      commands:
-        - no switchport
-        - ip pim sparse-mode
-      parents:
-        - "interface {{ intname }}"
-      match: none
-
-  - name: Configure igmp interface with non-default values
-    nxos_igmp_interface: &non-default
-      interface: "{{ intname }}"
-      version: 3
-      startup_query_interval: 60
-      startup_query_count: 5
-      robustness: 6
-      querier_timeout: 2000
-      query_mrt: 12
-      query_interval: 200
-      last_member_qrt: 2
-      last_member_query_count: 4
-      report_llg: true
-      immediate_leave: true
-      group_timeout: 300
-      oif_ps:
-        - source: 192.0.2.1
-          prefix: 239.255.255.2
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence - Configure igmp interface with non-default values"
-    nxos_igmp_interface: *non-default
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Configure igmp interface with some default values
-    nxos_igmp_interface: &sdef
-      interface: "{{ intname }}"
-      version: default
-      startup_query_interval: default
-      startup_query_count: default
-      robustness: default
-      querier_timeout: default
-      query_mrt: default
-      query_interval: default
-      last_member_qrt: default
-      last_member_query_count: default
-      group_timeout: default
-      oif_ps:
-        - {'prefix': '238.2.2.6'}
-        - {'prefix': '238.2.2.5'}
-        - {'source': '192.0.2.1', 'prefix': '238.2.2.5'}
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Configure igmp interface with some default values"
-    nxos_igmp_interface: *sdef
-    register: result
-
-  - assert: *false
-
-  - name: restart igmp
-    nxos_igmp_interface: &restart
-      interface: "{{ intname }}"
-      restart: "{{restart|default(omit)}}"
-
-  - name: Configure igmp interface with default oif_ps
-    nxos_igmp_interface: &defoif
-      interface: "{{ intname }}"
-      oif_ps: default
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Configure igmp interface with default oif_ps"
-    nxos_igmp_interface: *defoif
-    register: result
-
-  - assert: *false
-
-  - name: Configure igmp interface with oif_routemap
-    nxos_igmp_interface: &orm
-      interface: "{{ intname }}"
-      version: 3
-      startup_query_interval: 60
-      startup_query_count: 5
-      robustness: 6
-      oif_routemap: abcd
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Configure igmp interface with oif_routemap"
-    nxos_igmp_interface: *orm
-    register: result
-
-  - assert: *false
-
-  - name: Configure igmp interface with default state
-    nxos_igmp_interface: &default
-      interface: "{{ intname }}"
-      state: default
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Configure igmp interface with default state"
-    nxos_igmp_interface: *default
-    register: result
-
-  - assert: *false
-
-  - name: Configure igmp interface with absent state
-    nxos_igmp_interface: &absent
-      interface: "{{ intname }}"
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Configure igmp interface with absent state"
-    nxos_igmp_interface: *absent
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: Configure igmp interface with absent state
-    nxos_igmp_interface: *absent
-    register: result
-
-  - name: Put interface in default mode
-    nxos_config:
-      commands:
-      - "default interface {{ intname }}"
-      match: none
-
-  - name: "Disable feature PIM"
-    nxos_feature:
-      feature: pim
-      state: disabled
-    ignore_errors: yes
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_igmp_interface sanity test"
diff --git a/test/integration/targets/nxos_igmp_snooping/defaults/main.yaml b/test/integration/targets/nxos_igmp_snooping/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_igmp_snooping/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_igmp_snooping/meta/main.yml b/test/integration/targets/nxos_igmp_snooping/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_igmp_snooping/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_igmp_snooping/tasks/cli.yaml b/test/integration/targets/nxos_igmp_snooping/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_igmp_snooping/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_igmp_snooping/tasks/main.yaml b/test/integration/targets/nxos_igmp_snooping/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_igmp_snooping/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_igmp_snooping/tasks/nxapi.yaml b/test/integration/targets/nxos_igmp_snooping/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_igmp_snooping/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_igmp_snooping/tests/common/sanity.yaml b/test/integration/targets/nxos_igmp_snooping/tests/common/sanity.yaml
deleted file mode 100644
index 25e55b3872..0000000000
--- a/test/integration/targets/nxos_igmp_snooping/tests/common/sanity.yaml
+++ /dev/null
@@ -1,109 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_igmp_snooping sanity test"
-
-- meta: end_host
-  # show ip igmp snooping | json does not work on some platforms
-  when: platform is search('N6K')
-
-- set_fact: gt_run="false"
-- block:
-  - set_fact: gt_run="true"
-  - set_fact: group_timeout="never"
-  - set_fact: def_group_timeout="default"
-  when: platform is not search('N35|N5K|N6K')
-
-- name: Setup
-  nxos_igmp_snooping: &default
-    state: default
-
-- block:
-  - name: Configure igmp snooping with non-default values
-    nxos_igmp_snooping: &non-default
-      snooping: false
-      # group_timeout: n/a when snooping:false
-      link_local_grp_supp: false
-      report_supp: false
-      v3_report_supp: true
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-  - block:
-    - name: "Check Idempotence - Configure igmp snooping with non-default values"
-      nxos_igmp_snooping: *non-default
-      register: result
-
-    - assert: &false
-        that:
-          - "result.changed == false"
-    when: (imagetag and (imagetag is version_compare('D1', 'ne')))
-
-  - block:
-    - name: Negative Test config group-timeout when igmp snooping disabled
-      nxos_igmp_snooping:
-        snooping: false
-        group_timeout: "{{group_timeout|default(omit)}}"
-        state: present
-      ignore_errors: yes
-      register: result
-
-    - assert:
-        that:
-          - "result.failed == true"
-          - "result.msg == 'group-timeout cannot be enabled or changed when ip igmp snooping is disabled'"
-
-    - name: Configure group-timeout non-default
-      nxos_igmp_snooping: &non-defgt
-        snooping: true
-        group_timeout: "{{group_timeout|default(omit)}}"
-        state: present
-      register: result
-
-    - assert: *true
-
-    - name: "Check Idempotence"
-      nxos_igmp_snooping: *non-defgt
-      register: result
-
-    - assert: *false
-    when: gt_run
-
-  - name: Configure igmp snooping with default group timeout
-    nxos_igmp_snooping: &defgt
-      group_timeout: "{{def_group_timeout|default(omit)}}"
-      state: present
-    register: result
-
-  - assert: *true
-    when: gt_run
-
-  - block:
-    - name: "Check Idempotence"
-      nxos_igmp_snooping: *defgt
-      register: result
-
-    - assert: *false
-    when: gt_run or (imagetag and (imagetag is version_compare('D1', 'ne')))
-
-  - name: Configure igmp snooping with default values
-    nxos_igmp_snooping: *default
-    register: result
-
-  - assert: *true
-
-  - block:
-    - name: "Check Idempotence - Configure igmp snooping with default values"
-      nxos_igmp_snooping: *default
-      register: result
-
-    - assert: *false
-    when: (imagetag and (imagetag is version_compare('D1', 'ne')))
-
-  always:
-  - name: Configure igmp snooping with default values
-    nxos_igmp_snooping: *default
-    register: result
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_igmp_snooping sanity test"
diff --git a/test/integration/targets/nxos_install_os/defaults/main.yaml b/test/integration/targets/nxos_install_os/defaults/main.yaml
deleted file mode 100644
index a5a0790123..0000000000
--- a/test/integration/targets/nxos_install_os/defaults/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-testcase: ""
-test_items: []
diff --git a/test/integration/targets/nxos_install_os/meta/main.yml b/test/integration/targets/nxos_install_os/meta/main.yml
deleted file mode 100644
index 58de46745f..0000000000
--- a/test/integration/targets/nxos_install_os/meta/main.yml
+++ /dev/null
@@ -1,3 +0,0 @@
-dependencies:
-  # Prepare nxos tests is not required for this test.
-  #- prepare_nxos_tests
diff --git a/test/integration/targets/nxos_install_os/tasks/httpapi.yaml b/test/integration/targets/nxos_install_os/tasks/httpapi.yaml
deleted file mode 100644
index 34516c8eb0..0000000000
--- a/test/integration/targets/nxos_install_os/tasks/httpapi.yaml
+++ /dev/null
@@ -1,16 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (ansible_connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_install_os/tasks/main.yaml b/test/integration/targets/nxos_install_os/tasks/main.yaml
deleted file mode 100644
index 0530efb6b3..0000000000
--- a/test/integration/targets/nxos_install_os/tasks/main.yaml
+++ /dev/null
@@ -1,8 +0,0 @@
----
-# Upgrade using SSH
-- include: network_cli.yaml
-  when: ansible_connection == 'network_cli'
-
-# Upgrade using NX-API
-- include: httpapi.yaml
-  when: ansible_connection == 'httpapi'
\ No newline at end of file
diff --git a/test/integration/targets/nxos_install_os/tasks/network_cli.yaml b/test/integration/targets/nxos_install_os/tasks/network_cli.yaml
deleted file mode 100644
index 497a535b24..0000000000
--- a/test/integration/targets/nxos_install_os/tasks/network_cli.yaml
+++ /dev/null
@@ -1,16 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (ansible_connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_install_os/tasks/upgrade/clear_persistent_sockets.yaml b/test/integration/targets/nxos_install_os/tasks/upgrade/clear_persistent_sockets.yaml
deleted file mode 100644
index 1e62116e7c..0000000000
--- a/test/integration/targets/nxos_install_os/tasks/upgrade/clear_persistent_sockets.yaml
+++ /dev/null
@@ -1,19 +0,0 @@
----
-# This playbook is only provided for reference as a brute force way to
-# clear persistent connections on an Ansible server.  This was a workaround
-# for a problem with meta: reset_connection but should not be used in
-# ansible release 2.6 or later.
-- name: Clean up sockets with file module
-  file:
-    state: absent
-    path: "{{ home }}/.ansible/pc/"
-  delegate_to: 127.0.0.1
-
-- name: "Display socket info after delete"
-  shell: "/bin/ls {{ home }}/.ansible"
-  args:
-    executable: /bin/bash
-  delegate_to: 127.0.0.1
-  register: output
-
-- debug: msg="Local Socket Info {{ output['stdout_lines'] }}"
diff --git a/test/integration/targets/nxos_install_os/tasks/upgrade/copy_kick_system_images.yaml b/test/integration/targets/nxos_install_os/tasks/upgrade/copy_kick_system_images.yaml
deleted file mode 100644
index 9e117835c7..0000000000
--- a/test/integration/targets/nxos_install_os/tasks/upgrade/copy_kick_system_images.yaml
+++ /dev/null
@@ -1,60 +0,0 @@
----
-- set_fact: ignore_errors_httpapi='no'
-- set_fact: ignore_errors_httpapi='yes'
-  when: ansible_connection == 'httpapi'
-
-- include: targets/nxos_install_os/tasks/upgrade/enable_scp_server.yaml
-
-- name: 'Remove SSH known_hosts file before scp of image file'
-  nxos_command:
-    commands: 'run bash rm /var/home/admin/.ssh/known_hosts'
-  ignore_errors: yes
-
-- name: "Copy {{ si }} to bootflash"
-  nxos_file_copy:
-    file_pull: True
-    file_pull_timeout: 1200
-    remote_file: "{{image_dir}}{{ si }}"
-    remote_scp_server: "{{ remote_scp_server }}"
-    remote_scp_server_user: "{{ remote_scp_user }}"
-    remote_scp_server_password: "{{ remote_scp_password }}"
-  register: result
-
-#- name: "Copy {{ si }} to bootflash"
-#  expect:
-#    command: "scp {{image_dir}}{{ si }} {{ ansible_ssh_user }}@{{ ansible_ssh_host }}:"
-#    responses:
-#      (?i)Are you sure you want to continue connecting.*: yes
-#      (?i)password: "{{ ansible_ssh_pass }}"
-#    timeout: 1800
-#  register: result
-
-- debug:
-    msg: "{{ item.key }} {{ item.value }}"
-  with_dict: "{{ result }}"
-
-- name: "Copy {{ ki }} to bootflash"
-  nxos_file_copy:
-    file_pull: True
-    file_pull_timeout: 1200
-    remote_file: "{{image_dir}}{{ ki }}"
-    remote_scp_server: "{{ remote_scp_server }}"
-    remote_scp_server_user: "{{ remote_scp_user }}"
-    remote_scp_server_password: "{{ remote_scp_password }}"
-  when: ki is defined
-  register: result
-
-#- name: "Copy {{ ki }} to bootflash"
-#  expect:
-#    command: "scp {{image_dir}}{{ ki }} {{ ansible_ssh_user }}@{{ ansible_ssh_host }}:"
-#    responses:
-#      (?i)Are you sure you want to continue connecting.*: yes
-#      (?i)password: "{{ ansible_ssh_pass }}"
-#    timeout: 1800
-#  when: ki is defined
-#  register: result
-
-- debug:
-    msg: "{{ item.key }} {{ item.value }}"
-  with_dict: "{{ result }}"
-  when: ki is defined
diff --git a/test/integration/targets/nxos_install_os/tasks/upgrade/delete_files.yaml b/test/integration/targets/nxos_install_os/tasks/upgrade/delete_files.yaml
deleted file mode 100644
index 27157b690b..0000000000
--- a/test/integration/targets/nxos_install_os/tasks/upgrade/delete_files.yaml
+++ /dev/null
@@ -1,10 +0,0 @@
----
-- name: "Delete Files To Make Room On Bootflash"
-  nxos_config: &remove_file
-    lines:
-      - terminal dont-ask
-      - allow delete boot-image
-      - "delete {{ item }}"
-    match: none
-  ignore_errors: yes
-  with_items: "{{ delete_image_list }}"
diff --git a/test/integration/targets/nxos_install_os/tasks/upgrade/enable_scp_server.yaml b/test/integration/targets/nxos_install_os/tasks/upgrade/enable_scp_server.yaml
deleted file mode 100644
index f8a4e54e34..0000000000
--- a/test/integration/targets/nxos_install_os/tasks/upgrade/enable_scp_server.yaml
+++ /dev/null
@@ -1,5 +0,0 @@
----
-- name: "Setup - Turn on feature scp-server"
-  nxos_feature:
-    feature: scp-server
-    state: enabled
diff --git a/test/integration/targets/nxos_install_os/tasks/upgrade/install_os.yaml b/test/integration/targets/nxos_install_os/tasks/upgrade/install_os.yaml
deleted file mode 100644
index a7d21a5117..0000000000
--- a/test/integration/targets/nxos_install_os/tasks/upgrade/install_os.yaml
+++ /dev/null
@@ -1,24 +0,0 @@
----
-- include: targets/nxos_install_os/tasks/upgrade/delete_files.yaml
-  when: delete_files
-
-- include: "targets/nxos_install_os/tasks/upgrade/copy_kick_system_images.yaml ansible_connection=network_cli connection={{ cli }}"
-  when: copy_images
-
-- include: targets/nxos_install_os/tasks/upgrade/install_with_kick.yaml
-  when: ki is defined
-
-- include: targets/nxos_install_os/tasks/upgrade/install_system.yaml
-  when: ki is undefined
-
-# Only needed when - meta: reset_connection does not work. Fixed in 2.6
-#- include: targets/nxos_install_os/tasks/upgrade/clear_persistent_sockets.yaml
-
-- meta: reset_connection
-
-- name: "Check installed OS for newly installed version {{ tv }}"
-  nxos_command:
-    commands: ['show version | json']
-  register: output
-
-- debug: msg="Version detected {{ output['stdout_lines'][0]['kickstart_ver_str'] }}"
diff --git a/test/integration/targets/nxos_install_os/tasks/upgrade/install_system.yaml b/test/integration/targets/nxos_install_os/tasks/upgrade/install_system.yaml
deleted file mode 100644
index 09ed721649..0000000000
--- a/test/integration/targets/nxos_install_os/tasks/upgrade/install_system.yaml
+++ /dev/null
@@ -1,52 +0,0 @@
----
-- name: "Install OS image {{ si }}"
-  check_mode: "{{ checkmode }}"
-  nxos_install_os:
-    system_image_file: "{{ si }}"
-    issu: "{{ issu }}"
-  register: result
-  when: not force
-
-- name: "Remove old boot pointers if any"
-  nxos_config:
-    lines:
-      - no boot nxos
-      - no boot kickstart
-      - no boot system
-    match: line
-  ignore_errors: yes
-  when: force
-
-- name: "Set OS image {{ si }} boot pointers"
-  nxos_config:
-    lines:
-      - "boot nxos bootflash:{{ si }}"
-      - copy run start
-    match: line
-  when: force
-
-- name: "Boot image {{ si }} using reload"
-  nxos_config:
-    lines:
-      - 'terminal dont-ask'
-      - 'reload'
-  ignore_errors: yes
-  when: force
-
-- debug: msg=" {{ result['install_state'] }}"
-  when: not force
-
-- name: Wait for device to come back up with new image
-  wait_for:
-    port: 22
-    state: started
-    timeout: 500
-    delay: 60
-    host: "{{ inventory_hostname }}"
-  when: result.changed and not checkmode
-
-- debug: msg='Wait 5 mins to allow system to stabilize'
-  when: result.changed and not checkmode
-- pause:
-    seconds: 300
-  when: result.changed and not checkmode
diff --git a/test/integration/targets/nxos_install_os/tasks/upgrade/install_with_kick.yaml b/test/integration/targets/nxos_install_os/tasks/upgrade/install_with_kick.yaml
deleted file mode 100644
index 8d02cb9a78..0000000000
--- a/test/integration/targets/nxos_install_os/tasks/upgrade/install_with_kick.yaml
+++ /dev/null
@@ -1,44 +0,0 @@
----
-- name: "Install OS image {{ si }}"
-  check_mode: "{{ checkmode }}"
-  nxos_install_os:
-    system_image_file: "{{ si }}"
-    kickstart_image_file: "{{ ki }}"
-    issu: "{{ issu }}"
-  register: result
-  when: not force
-
-- name: "Set OS image {{ si }} boot pointers"
-  nxos_config:
-    lines:
-      - no boot kickstart
-      - no boot system
-      - "boot kickstart bootflash:{{ ki }}"
-      - "boot system bootflash:{{ si }}"
-      - copy run start
-    match: line
-  when: force
-
-- name: "Boot image {{ si }} using reload"
-  nxos_command:
-    commands: 'terminal dont-ask ; reload'
-  ignore_errors: yes
-  when: force
-
-- debug: msg=" {{ result['install_state'] }}"
-  when: not force
-
-- name: Wait for device to come back up with new image
-  wait_for:
-    port: 22
-    state: started
-    timeout: 500
-    delay: 60
-    host: "{{ inventory_hostname }}"
-  when: result.changed and not checkmode
-
-- debug: msg='Wait 5 mins to allow system to stabilize'
-  when: result.changed and not checkmode
-- pause:
-    seconds: 300
-  when: result.changed and not checkmode
diff --git a/test/integration/targets/nxos_install_os/tasks/upgrade/main_os_install.yaml b/test/integration/targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
deleted file mode 100644
index 5af834dc18..0000000000
--- a/test/integration/targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
+++ /dev/null
@@ -1,6 +0,0 @@
----
-- debug: msg="***WARNING*** Remove meta end_play to verify this module ***WARNING***"
-
-- meta: end_play
-
-- include: targets/nxos_install_os/tasks/upgrade/install_os.yaml
diff --git a/test/integration/targets/nxos_install_os/tests/common/upgrade.yaml b/test/integration/targets/nxos_install_os/tests/common/upgrade.yaml
deleted file mode 100644
index 5211c51fc1..0000000000
--- a/test/integration/targets/nxos_install_os/tests/common/upgrade.yaml
+++ /dev/null
@@ -1,59 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_os_install upgrade"
-  when: connection is defined
-
-- set_fact: image_dir='/Users/mwiebe/Projects/nxos_ansible/images/'
-
-- set_fact: checkmode='no'
-- set_fact: issu='desired'
-- set_fact: copy_images=True
-
-# Set boot pointers and reload
-- set_fact: force=False
-
-- set_fact: delete_files=True
-- set_fact:
-    delete_image_list:
-      - nxos.7.0.3.I7.2.bin
-      - nxos.7.0.3.I7.3.bin
-
-#---------------------------------------------------------#
-# Upgrade to 6.0(2)U6(1a)                                 #
-#---------------------------------------------------------#
-
-- set_fact: si='n3000-uk9.6.0.2.U6.1a.bin'
-- set_fact: ki='n3000-uk9-kickstart.6.0.2.U6.1a.bin'
-
-- name: Upgrade to U6.1a
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
-
-#---------------------------------------------------------#
-# Upgrade to 6.0(2)U6(2a)                                 #
-#---------------------------------------------------------#
-
-- set_fact: si='n3000-uk9.6.0.2.U6.2a.bin'
-- set_fact: ki='n3000-uk9-kickstart.6.0.2.U6.2a.bin'
-
-- name: Upgrade to U6.2a
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
-
-#---------------------------------------------------------#
-# Upgrade to 6.0(2)U6(3a)                                 #
-#---------------------------------------------------------#
-
-- set_fact: si='n3000-s2-dk9.8.0.1.bin'
-- set_fact: ki='n3000-s2-kickstart.8.0.1.bin'
-
-- name: Upgrade to U6.3a
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
-
-#---------------------------------------------------------#
-# Upgrade to 7.0(3)I7(2)                                  #
-#---------------------------------------------------------#
-
-- set_fact: si='nxos.7.0.3.I7.2.bin'
-
-- name: Upgrade to 7.0.3.I7.2
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
-
-- debug: msg="END connection={{ ansible_connection }} nxos_os_install upgrade"
diff --git a/test/integration/targets/nxos_install_os/tests/common/upgrade_n3172_greensboro.yaml b/test/integration/targets/nxos_install_os/tests/common/upgrade_n3172_greensboro.yaml
deleted file mode 100644
index 4c4086bd99..0000000000
--- a/test/integration/targets/nxos_install_os/tests/common/upgrade_n3172_greensboro.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_os_install upgrade"
-  when: connection is defined
-
-# Set directory pointer to software images
-- set_fact: image_dir='/auto/fe_ssr/agents-ci/agents_images/release_images/greensboro/REL_7_0_3_I7_4/'
-
-- set_fact: checkmode='no'
-- set_fact: issu='no'
-- set_fact: copy_images=True
-
-# Set boot pointers and reload
-- set_fact: force=False
-
-- set_fact: delete_files=True
-- set_fact:
-    delete_image_list:
-      - nxos*.bin
-      - n3000*.bin
-
-#---------------------------------------------------------#
-# Upgrade Device                                          #
-#---------------------------------------------------------#
-- set_fact: si='nxos.7.0.3.I7.4.bin'
-
-- name: Upgrade N3172 Device to Greensboro Release Image
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
diff --git a/test/integration/targets/nxos_install_os/tests/common/upgrade_n3172_u61a.yaml b/test/integration/targets/nxos_install_os/tests/common/upgrade_n3172_u61a.yaml
deleted file mode 100644
index 3d72792c6f..0000000000
--- a/test/integration/targets/nxos_install_os/tests/common/upgrade_n3172_u61a.yaml
+++ /dev/null
@@ -1,28 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_os_install upgrade"
-  when: connection is defined
-
-# Set directory pointer to software images
-- set_fact: image_dir='/auto/fe_ssr/agents-ci/agents_images/release_images/602U6_1/'
-
-- set_fact: checkmode='no'
-- set_fact: issu='desired'
-- set_fact: copy_images=True
-
-# Set boot pointers and reload
-- set_fact: force=False
-
-- set_fact: delete_files=True
-- set_fact:
-    delete_image_list:
-      - n3000*.bin
-      - nxos*.bin
-
-#---------------------------------------------------------#
-# Upgrade Device                                          #
-#---------------------------------------------------------#
-- set_fact: si='n3000-uk9.6.0.2.U6.1a.bin'
-- set_fact: ki='n3000-uk9-kickstart.6.0.2.U6.1a.bin'
-
-- name: Upgrade N3500 Device to U61a Release Image
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
diff --git a/test/integration/targets/nxos_install_os/tests/common/upgrade_n3172_u62a.yaml b/test/integration/targets/nxos_install_os/tests/common/upgrade_n3172_u62a.yaml
deleted file mode 100644
index 35de71810b..0000000000
--- a/test/integration/targets/nxos_install_os/tests/common/upgrade_n3172_u62a.yaml
+++ /dev/null
@@ -1,28 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_os_install upgrade"
-  when: connection is defined
-
-# Set directory pointer to software images
-- set_fact: image_dir='/auto/fe_ssr/agents-ci/agents_images/release_images/602U6_2/'
-
-- set_fact: checkmode='no'
-- set_fact: issu='no'
-- set_fact: copy_images=True
-
-# Set boot pointers and reload
-- set_fact: force=False
-
-- set_fact: delete_files=True
-- set_fact:
-    delete_image_list:
-      - n3000*.bin
-      - nxos*.bin
-
-#---------------------------------------------------------#
-# Upgrade Device                                          #
-#---------------------------------------------------------#
-- set_fact: si='n3000-uk9.6.0.2.U6.2a.bin'
-- set_fact: ki='n3000-uk9-kickstart.6.0.2.U6.2a.bin'
-
-- name: Upgrade N3500 Device to U62a Release Image
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
diff --git a/test/integration/targets/nxos_install_os/tests/common/upgrade_n3172_u63a.yaml b/test/integration/targets/nxos_install_os/tests/common/upgrade_n3172_u63a.yaml
deleted file mode 100644
index e9b02b3684..0000000000
--- a/test/integration/targets/nxos_install_os/tests/common/upgrade_n3172_u63a.yaml
+++ /dev/null
@@ -1,28 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_os_install upgrade"
-  when: connection is defined
-
-# Set directory pointer to software images
-- set_fact: image_dir='/auto/fe_ssr/agents-ci/agents_images/release_images/602U6_3/'
-
-- set_fact: checkmode='no'
-- set_fact: issu='desired'
-- set_fact: copy_images=True
-
-# Set boot pointers and reload
-- set_fact: force=False
-
-- set_fact: delete_files=True
-- set_fact:
-    delete_image_list:
-      - n3000*.bin
-      - nxos*.bin
-
-#---------------------------------------------------------#
-# Upgrade Device                                          #
-#---------------------------------------------------------#
-- set_fact: si='n3000-uk9.6.0.2.U6.3a.bin'
-- set_fact: ki='n3000-uk9-kickstart.6.0.2.U6.3a.bin'
-
-- name: Upgrade N3500 Device to U63a Release Image
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
diff --git a/test/integration/targets/nxos_install_os/tests/common/upgrade_n35_62a88.yaml b/test/integration/targets/nxos_install_os/tests/common/upgrade_n35_62a88.yaml
deleted file mode 100644
index 2a87ff4b58..0000000000
--- a/test/integration/targets/nxos_install_os/tests/common/upgrade_n35_62a88.yaml
+++ /dev/null
@@ -1,28 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_os_install upgrade"
-  when: connection is defined
-
-# Set directory pointer to software images
-- set_fact: image_dir='/auto/fe_ssr/agents-ci/agents_images/release_images/602A8_8/'
-
-- set_fact: checkmode='no'
-- set_fact: issu='desired'
-- set_fact: copy_images=True
-
-# Set boot pointers and reload
-- set_fact: force=False
-
-- set_fact: delete_files=True
-- set_fact:
-    delete_image_list:
-      - n3000*.bin
-      - n3500*.bin
-
-#---------------------------------------------------------#
-# Upgrade Device                                          #
-#---------------------------------------------------------#
-- set_fact: si='n3500-uk9.6.0.2.A8.8.bin'
-- set_fact: ki='n3500-uk9-kickstart.6.0.2.A8.8.bin'
-
-- name: Upgrade N3500 Device to A8_8 Release Image
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
diff --git a/test/integration/targets/nxos_install_os/tests/common/upgrade_n35_greensboro.yaml b/test/integration/targets/nxos_install_os/tests/common/upgrade_n35_greensboro.yaml
deleted file mode 100644
index 1ac5cb409d..0000000000
--- a/test/integration/targets/nxos_install_os/tests/common/upgrade_n35_greensboro.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_os_install upgrade"
-  when: connection is defined
-
-# Set directory pointer to software images
-- set_fact: image_dir='/auto/fe_ssr/agents-ci/agents_images/release_images/greensboro/REL_7_0_3_I7_4/'
-
-- set_fact: checkmode='no'
-- set_fact: issu='desired'
-- set_fact: copy_images=False
-
-# Set boot pointers and reload
-- set_fact: force=False
-
-- set_fact: delete_files=False
-- set_fact:
-    delete_image_list:
-      - nxos*.bin
-      - n3500*.bin
-
-#---------------------------------------------------------#
-# Upgrade Device                                          #
-#---------------------------------------------------------#
-- set_fact: si='nxos.7.0.3.I7.4.bin'
-
-- name: Upgrade N3500 Device to Greensboro Release Image
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
diff --git a/test/integration/targets/nxos_install_os/tests/common/upgrade_n5k_730_N11.yaml b/test/integration/targets/nxos_install_os/tests/common/upgrade_n5k_730_N11.yaml
deleted file mode 100644
index 4d119133f2..0000000000
--- a/test/integration/targets/nxos_install_os/tests/common/upgrade_n5k_730_N11.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_os_install upgrade"
-  when: connection is defined
-
-# Set directory pointer to software images
-- set_fact: image_dir='/auto/fe_ssr/agents-ci/agents_images/release_images/730_N11/'
-
-- set_fact: checkmode='no'
-- set_fact: issu='no'
-- set_fact: copy_images=True
-
-# Set boot pointers and reload
-- set_fact: force=False
-
-- set_fact: delete_files=True
-- set_fact:
-    delete_image_list:
-      - n6000*.bin
-
-#---------------------------------------------------------#
-# Upgrade Device                                          #
-#---------------------------------------------------------#
-- set_fact: si='n6000-uk9.7.3.0.N1.1.bin'
-- set_fact: ki='n6000-uk9-kickstart.7.3.0.N1.1.bin'
-
-- name: Upgrade N5k Device to 7.3(0)N1(1) Release Image
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
diff --git a/test/integration/targets/nxos_install_os/tests/common/upgrade_n5k_733_N11.yaml b/test/integration/targets/nxos_install_os/tests/common/upgrade_n5k_733_N11.yaml
deleted file mode 100644
index 1e585567ad..0000000000
--- a/test/integration/targets/nxos_install_os/tests/common/upgrade_n5k_733_N11.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_os_install upgrade"
-  when: connection is defined
-
-# Set directory pointer to software images
-- set_fact: image_dir='/auto/fe_ssr/agents-ci/agents_images/release_images/733_N11/'
-
-- set_fact: checkmode='no'
-- set_fact: issu='no'
-- set_fact: copy_images=False
-
-# Set boot pointers and reload
-- set_fact: force=False
-
-- set_fact: delete_files=False
-- set_fact:
-    delete_image_list:
-      - n6000*.bin
-
-#---------------------------------------------------------#
-# Upgrade Device                                          #
-#---------------------------------------------------------#
-- set_fact: si='n6000-uk9.7.3.3.N1.1.bin'
-- set_fact: ki='n6000-uk9-kickstart.7.3.3.N1.1.bin'
-
-- name: Upgrade N5k Device to 7.3(3)N1(1) Release Image
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
diff --git a/test/integration/targets/nxos_install_os/tests/common/upgrade_n7k_atherton.yaml b/test/integration/targets/nxos_install_os/tests/common/upgrade_n7k_atherton.yaml
deleted file mode 100644
index 31e0620fb2..0000000000
--- a/test/integration/targets/nxos_install_os/tests/common/upgrade_n7k_atherton.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_os_install upgrade"
-  when: connection is defined
-
-# Set directory pointer to software images
-- set_fact: image_dir='/auto/fe_ssr/agents-ci/agents_images/release_images/atherton/REL_8_0_1/'
-
-- set_fact: checkmode='no'
-- set_fact: issu='no'
-- set_fact: copy_images=True
-
-# Set boot pointers and reload
-- set_fact: force=False
-
-- set_fact: delete_files=True
-- set_fact:
-    delete_image_list:
-      - n7000*.bin
-
-#---------------------------------------------------------#
-# Upgrade Device                                          #
-#---------------------------------------------------------#
-- set_fact: si='n7000-s2-dk9.8.0.1.bin'
-- set_fact: ki='n7000-s2-kickstart.8.0.1.bin'
-
-- name: Upgrade N7k Device to Atherton Release Image
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
diff --git a/test/integration/targets/nxos_install_os/tests/common/upgrade_n7k_helsinki.yaml b/test/integration/targets/nxos_install_os/tests/common/upgrade_n7k_helsinki.yaml
deleted file mode 100644
index ba6122e85b..0000000000
--- a/test/integration/targets/nxos_install_os/tests/common/upgrade_n7k_helsinki.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_os_install upgrade"
-  when: connection is defined
-
-# Set directory pointer to software images
-- set_fact: image_dir='/auto/fe_ssr/agents-ci/agents_images/release_images/helsinki/REL_7_3_0_D1_1/'
-
-- set_fact: checkmode='no'
-- set_fact: issu='no'
-- set_fact: copy_images=True
-
-# Set boot pointers and reload
-- set_fact: force=True
-
-- set_fact: delete_files=True
-- set_fact:
-    delete_image_list:
-      - n7000*.bin
-
-#---------------------------------------------------------#
-# Upgrade Device                                          #
-#---------------------------------------------------------#
-- set_fact: si='n7000-s2-dk9.7.3.0.D1.1.bin'
-- set_fact: ki='n7000-s2-kickstart.7.3.0.D1.1.bin'
-
-- name: Upgrade N7k Device to Helsinki Release Image
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
diff --git a/test/integration/targets/nxos_install_os/tests/common/upgrade_n9k_greensboro.yaml b/test/integration/targets/nxos_install_os/tests/common/upgrade_n9k_greensboro.yaml
deleted file mode 100644
index b95cc27b1e..0000000000
--- a/test/integration/targets/nxos_install_os/tests/common/upgrade_n9k_greensboro.yaml
+++ /dev/null
@@ -1,39 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_os_install upgrade"
-  when: connection is defined
-
-# Set directory pointer to software images
-- set_fact: image_dir='/auto/fe_ssr/agents-ci/agents_images/release_images/greensboro/REL_7_0_3_I7_4/'
-
-- set_fact: checkmode='no'
-- set_fact: issu='desired'
-- set_fact: copy_images=True
-
-# Set boot pointers and reload
-- set_fact: force=False
-
-- set_fact: delete_files=True
-- set_fact:
-    delete_image_list:
-      - nxos*.bin
-
-#---------------------------------------------------------#
-# Remove incompatible features                            #
-#---------------------------------------------------------#
-- name: Unconfigure features that will conflict with upgrade
-  nxos_config:
-    lines:
-      - terminal dont-ask
-      - no feature nv overlay
-      - no nxapi ssl protocols
-      - no nxapi ssl ciphers weak
-    match: none
-  ignore_errors: yes
-
-#---------------------------------------------------------#
-# Upgrade Device                                          #
-#---------------------------------------------------------#
-- set_fact: si='nxos.7.0.3.I7.4.bin'
-
-- name: Upgrade N9k Device to Greensboro Release Image
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
diff --git a/test/integration/targets/nxos_install_os/tests/common/upgrade_n9k_greensboro_force.yaml b/test/integration/targets/nxos_install_os/tests/common/upgrade_n9k_greensboro_force.yaml
deleted file mode 100644
index 9f6a148145..0000000000
--- a/test/integration/targets/nxos_install_os/tests/common/upgrade_n9k_greensboro_force.yaml
+++ /dev/null
@@ -1,39 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_os_install upgrade"
-  when: connection is defined
-
-# Set directory pointer to software images
-- set_fact: image_dir='/auto/fe_ssr/agents-ci/agents_images/release_images/greensboro/REL_7_0_3_I7_4/'
-
-- set_fact: checkmode='no'
-- set_fact: issu='desired'
-- set_fact: copy_images=True
-
-# Set boot pointers and reload
-- set_fact: force=True
-
-- set_fact: delete_files=True
-- set_fact:
-    delete_image_list:
-      - nxos*.bin
-
-#---------------------------------------------------------#
-# Remove incompatible features                            #
-#---------------------------------------------------------#
-- name: Unconfigure features that will conflict with upgrade
-  nxos_config:
-    lines:
-      - terminal dont-ask
-      - no feature nv overlay
-      - no nxapi ssl protocols
-      - no nxapi ssl ciphers weak
-    match: none
-  ignore_errors: yes
-
-#---------------------------------------------------------#
-# Upgrade Device                                          #
-#---------------------------------------------------------#
-- set_fact: si='nxos.7.0.3.I7.4.bin'
-
-- name: Upgrade N9k Device to Greensboro Release Image
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
diff --git a/test/integration/targets/nxos_install_os/tests/common/upgrade_n9k_hamilton.yaml b/test/integration/targets/nxos_install_os/tests/common/upgrade_n9k_hamilton.yaml
deleted file mode 100644
index b52e2044b5..0000000000
--- a/test/integration/targets/nxos_install_os/tests/common/upgrade_n9k_hamilton.yaml
+++ /dev/null
@@ -1,37 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_os_install upgrade"
-  when: connection is defined
-
-# Set directory pointer to software images
-- set_fact: image_dir='/auto/fe_ssr/agents-ci/agents_images/release_images/hamilton/REL_9_2_1/'
-
-- set_fact: checkmode='no'
-- set_fact: issu='desired'
-- set_fact: copy_images=True
-
-# Set boot pointers and reload
-- set_fact: force=False
-
-- set_fact: delete_files=True
-- set_fact:
-    delete_image_list:
-      - nxos*.bin
-
-#---------------------------------------------------------#
-# Remove incompatible features                            #
-#---------------------------------------------------------#
-- name: Unconfigure features that will conflict with upgrade
-  nxos_config:
-    lines:
-      - terminal dont-ask
-      - no feature ngmvpn
-    match: none
-  ignore_errors: yes
-
-#---------------------------------------------------------#
-# Upgrade Device                                          #
-#---------------------------------------------------------#
-- set_fact: si='nxos.9.2.1.bin'
-
-- name: Upgrade N9k Device to Hamilton Release Image
-  include: targets/nxos_install_os/tasks/upgrade/main_os_install.yaml
diff --git a/test/integration/targets/nxos_interface/defaults/main.yaml b/test/integration/targets/nxos_interface/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_interface/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_interface/meta/main.yml b/test/integration/targets/nxos_interface/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_interface/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_interface/tasks/cli.yaml b/test/integration/targets/nxos_interface/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_interface/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_interface/tasks/main.yaml b/test/integration/targets/nxos_interface/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_interface/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_interface/tasks/nxapi.yaml b/test/integration/targets/nxos_interface/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_interface/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_interface/tests/common/intent.yaml b/test/integration/targets/nxos_interface/tests/common/intent.yaml
deleted file mode 100644
index b3c0f42fb3..0000000000
--- a/test/integration/targets/nxos_interface/tests/common/intent.yaml
+++ /dev/null
@@ -1,63 +0,0 @@
-- debug: msg="START connection={{ ansible_connection }} nxos_interface intent test"
-
-- set_fact: testint1="{{ nxos_int1 }}"
-- set_fact: testint2="{{ nxos_int2 }}"
-
-- name: "Setup: Put interfaces into a default state"
-  nxos_config:
-    lines:
-      - "default interface {{ testint1 }}"
-      - "default interface {{ testint2 }}"
-  ignore_errors: yes
-
-- name: Check intent arguments
-  nxos_interface:
-    name: "{{ testint2 }}"
-    admin_state: up
-    tx_rate: ge(0)
-    rx_rate: ge(0)
-  register: result
-
-- assert:
-    that:
-      - "result.failed == false"
-
-- name: "Clear interface {{ testint2 }} counters before next task"
-  nxos_command:
-    commands: "clear counters interface {{ testint2 }}"
-  ignore_errors: yes
-
-- name: Check intent arguments (failed condition)
-  nxos_interface:
-    name: "{{ testint2 }}"
-    admin_state: down
-    tx_rate: gt(10000)
-    rx_rate: lt(0)
-  ignore_errors: yes
-  register: result
-
-- assert:
-    that:
-      - "result.failed == true"
-      - "'tx_rate gt(10000)' in result.failed_conditions"
-      - "'rx_rate lt(0)' in result.failed_conditions"
-
-- name: aggregate definition of interface
-  nxos_interface:
-    aggregate:
-      - { name: "{{ testint1 }}", description: "Test aggregation on first interface" }
-      - { name: "{{ testint2 }}", mode: layer3 }
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: "TearDown: Put interfaces into a default state"
-  nxos_config:
-    lines:
-      - "default interface {{ testint1 }}"
-      - "default interface {{ testint2 }}"
-  ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_interface intent test"
diff --git a/test/integration/targets/nxos_interface/tests/common/sanity.yaml b/test/integration/targets/nxos_interface/tests/common/sanity.yaml
deleted file mode 100644
index 3151152eb0..0000000000
--- a/test/integration/targets/nxos_interface/tests/common/sanity.yaml
+++ /dev/null
@@ -1,117 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_interface sanity test"
-
-- set_fact: testint="{{ nxos_int1 }}"
-
-- name: "Setup: Enable feature interface-vlan"
-  nxos_feature:
-    feature: interface-vlan
-    state: enabled
-  ignore_errors: yes
-
-- name: "Setup: Put interface {{ testint }} into a default state"
-  nxos_config: &intcleanup
-    lines:
-      - "default interface {{ testint }}"
-  ignore_errors: yes
-
-- name: "Setup: Remove possibly existing vlan interfaces"
-  nxos_config: &vlanintcleanup
-    lines:
-      - "no interface vlan 2"
-      - "no interface vlan 710"
-      - "no interface vlan 711"
-      - "no interface vlan 712"
-  ignore_errors: yes
-
-- block:
-  - name: "Configure layer3 params"
-    nxos_interface: &l3config
-      interface: "{{ testint }}"
-      mode: layer3
-      description: 'Configured by Ansible - Layer3'
-      admin_state: up
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_interface: *l3config
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: "Configure layer2 params"
-    nxos_interface: &l2config
-      interface: "{{ testint }}"
-      mode: layer2
-      description: 'Configured by Ansible - Layer2'
-      admin_state: down
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_interface: *l2config
-    register: result
-
-  - assert: *false
-
-  - name: Create VLAN Interfaces
-    nxos_interface: &createvlans
-      interface: "{{ item.os_svi_int }}"
-      description: "{{ item.os_svi_desc }}"
-    with_items: &vlanitems
-      - {os_svi_int: vlan2, os_svi_desc: SVI_VLAN2}
-      - {os_svi_int: vlan710, os_svi_desc: SVI_VLAN710}
-      - {os_svi_int: vlan711, os_svi_desc: SVI_VLAN711}
-      - {os_svi_int: vlan712, os_svi_desc: SVI_VLAN712}
-    register: result
-
-  - assert: *true
-
-  - name: Configure Required SVI
-    nxos_l3_interface: &addips
-      aggregate:
-        - {name: vlan2, ipv4: 192.168.2.1/24}
-        - {name: vlan710, ipv4: 192.168.3.1/24}
-        - {name: vlan711, ipv4: 192.168.4.1/24}
-        - {name: vlan712, ipv4: 192.168.5.1/24}
-    register: result
-
-  - assert: *true
-
-  - name: Create VLAN Interfaces Idempotence Check
-    nxos_interface: *createvlans
-    with_items: *vlanitems
-    register: result
-
-  - assert: *false
-
-  - name: Configure Required SVI Idempotence Check
-    nxos_l3_interface: *addips
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: "Set interface back to default"
-    nxos_config: *intcleanup
-    ignore_errors: yes
-
-  - name: "Remove vlan interfaces"
-    nxos_config: *vlanintcleanup
-
-  - name: "Setup: Disable feature interface-vlan"
-    nxos_feature:
-      feature: interface-vlan
-      state: disabled
-    ignore_errors: yes
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_interface sanity test"
diff --git a/test/integration/targets/nxos_interface/tests/common/set_state_absent.yaml b/test/integration/targets/nxos_interface/tests/common/set_state_absent.yaml
deleted file mode 100644
index 06b06671ea..0000000000
--- a/test/integration/targets/nxos_interface/tests/common/set_state_absent.yaml
+++ /dev/null
@@ -1,29 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }}/set_state_absent.yaml"
-
-- name: setup
-  nxos_config:
-    lines:
-      - interface Loopback1
-
-- name: set state=absent
-  nxos_interface:
-    interface: Loopback1
-    state: absent
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: verify state=absent
-  nxos_interface:
-    interface: Loopback1
-    state: absent
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- debug: msg="END connection={{ ansible_connection }}/set_state_absent.yaml"
diff --git a/test/integration/targets/nxos_interface/tests/common/set_state_present.yaml b/test/integration/targets/nxos_interface/tests/common/set_state_present.yaml
deleted file mode 100644
index ff2bf8c232..0000000000
--- a/test/integration/targets/nxos_interface/tests/common/set_state_present.yaml
+++ /dev/null
@@ -1,32 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }}/set_state_present.yaml"
-
-- name: setup
-  nxos_config:
-    lines:
-      - no interface Loopback1
-  ignore_errors: yes # Fails if the interface is already absent
-
-- name: set state=present
-  nxos_interface:
-    interface: Loopback1
-    state: present
-    description: 'Configured by Ansible - Layer3'
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: verify state=present
-  nxos_interface:
-    interface: Loopback1
-    state: present
-    description: 'Configured by Ansible - Layer3'
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- debug: msg="END connection={{ ansible_connection }}/set_state_present.yaml"
diff --git a/test/integration/targets/nxos_interface/tests/common/sub_int.yaml b/test/integration/targets/nxos_interface/tests/common/sub_int.yaml
deleted file mode 100644
index 16d7fa6028..0000000000
--- a/test/integration/targets/nxos_interface/tests/common/sub_int.yaml
+++ /dev/null
@@ -1,73 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_interface sub-interface test"
-
-- set_fact: testint="{{ nxos_int1 }}"
-
-- name: Setup - delete sub-interface
-  nxos_interface: &rm
-    name: "{{ testint }}.20"
-    state: absent
-  ignore_errors: yes
-
-- name: Setup - Ensure the interface is layer3
-  nxos_interface:
-    name: "{{ testint }}"
-    mode: layer3
-
-- name: Create sub-interface
-  nxos_interface: &sub_int
-    name: "{{ testint }}.20"
-    description: "sub-interface Configured by Ansible"
-    admin_state: up
-    mtu: 800
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: Create sub-interface (Idempotence)
-  nxos_interface: *sub_int
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: Make admin_state down
-  nxos_interface: &state_down
-    name: "{{ testint }}.20"
-    description: "sub-interface Configured by Ansible"
-    admin_state: down
-    mtu: 800
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: Create sub-interface (Idempotence)
-  nxos_interface: *state_down
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: Remove sub-interface
-  nxos_interface: *rm
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: Remove sub-interface (Idempotence)
-  nxos_interface: *rm
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- debug: msg="END connection={{ ansible_connection }} nxos_interface sub-interface test"
diff --git a/test/integration/targets/nxos_interface_ospf/defaults/main.yaml b/test/integration/targets/nxos_interface_ospf/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_interface_ospf/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_interface_ospf/meta/main.yml b/test/integration/targets/nxos_interface_ospf/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_interface_ospf/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_interface_ospf/tasks/cli.yaml b/test/integration/targets/nxos_interface_ospf/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_interface_ospf/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_interface_ospf/tasks/main.yaml b/test/integration/targets/nxos_interface_ospf/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_interface_ospf/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_interface_ospf/tasks/nxapi.yaml b/test/integration/targets/nxos_interface_ospf/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_interface_ospf/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_interface_ospf/tests/common/sanity.yaml b/test/integration/targets/nxos_interface_ospf/tests/common/sanity.yaml
deleted file mode 100644
index de9f7209f9..0000000000
--- a/test/integration/targets/nxos_interface_ospf/tests/common/sanity.yaml
+++ /dev/null
@@ -1,286 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_interface_ospf sanity test"
-
-- set_fact: testint="{{ nxos_int1 }}"
-
-- name: Setup - Disable features
-  nxos_feature:
-    feature: "{{ item }}"
-    state: disabled
-  loop: ['ospf', 'bfd']
-  ignore_errors: yes
-
-- name: Setup - Enable features
-  nxos_feature:
-    feature: "{{ item }}"
-    state: enabled
-  loop: ['ospf', 'bfd']
-
-- name: "Put interface into default state"
-  nxos_config: &intdefault
-    lines:
-      - "default interface {{ testint }}"
-  ignore_errors: yes
-
-- name: "Remove switchport config"
-  nxos_config: &removeswitchport
-    commands:
-      - no switchport
-    parents:
-      - "interface {{ testint }}"
-  ignore_errors: yes
-
-- name: "Remove possibly existing port-channel and loopback ints"
-  nxos_config: &removepcandlb
-    commands:
-      - no interface port-channel10
-      - no interface port-channel11
-      - no interface loopback55
-      - no interface loopback77
-  ignore_errors: yes
-
-- block:
-  - name: configure ospf interface
-    nxos_interface_ospf: &configure
-      interface: "{{ nxos_int1|upper }}"
-      ospf: 1
-      area: 12345678
-      bfd: enable
-      cost: 55
-      passive_interface: true
-      hello_interval: 15
-      dead_interval: 75
-      network: point-to-point
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_interface_ospf: *configure
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Modify properties
-    nxos_interface_ospf: &modify
-      interface: "{{ testint }}"
-      ospf: 1
-      area: 12345678
-      cost: 66
-      passive_interface: false
-      hello_interval: 17
-      dead_interval: 70
-      network: broadcast
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_interface_ospf: *modify
-    register: result
-
-  - assert: *false
-
-  - name: default properties
-    nxos_interface_ospf: &def
-      interface: "{{ testint }}"
-      ospf: 1
-      area: 12345678
-      bfd: default
-      cost: default
-      hello_interval: 10
-      dead_interval: default
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_interface_ospf: *def
-    register: result
-
-  - assert: *false
-
-  - name: Message_digest properties
-    nxos_interface_ospf: &md
-      interface: "{{ testint }}"
-      ospf: 1
-      area: 12345678
-      message_digest: True
-      message_digest_key_id: 10
-      message_digest_algorithm_type: md5
-      message_digest_encryption_type: 3des
-      message_digest_password: b69f7bc54725b1bfd1ea93afa7b09400
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_interface_ospf: *md
-    register: result
-
-  - assert: *false
-
-  - name: Message_digest defaults
-    nxos_interface_ospf: &mdd
-      interface: "{{ testint }}"
-      ospf: 1
-      area: 12345678
-      message_digest: False
-      message_digest_key_id: default
-      message_digest_algorithm_type: default
-      message_digest_encryption_type: default
-      message_digest_password: default
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_interface_ospf: *mdd
-    register: result
-
-  - assert: *false
-
-  - name: create port-channel and loopback interfaces
-    nxos_config:
-      commands:
-        - interface port-channel10
-        - interface port-channel11
-        - interface loopback55
-        - interface loopback77
-      match: none
-
-  - name: "Ensure port-channels are layer3"
-    nxos_config:
-      commands:
-        - no switchport
-      parents:
-        - "interface {{ item }}"
-    with_items:
-      - port-channel10
-      - port-channel11
-
-  - name: configure ospf interface port-channel10
-    nxos_interface_ospf: &configurepc
-      interface: Port-channel10
-      ospf: 1
-      area: 429496729
-      cost: 55
-      passive_interface: true
-      hello_interval: 15
-      dead_interval: 75
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence for port-channel10"
-    nxos_interface_ospf: *configurepc
-    register: result
-
-  - assert: *false
-
-  - name: configure ospf interface port-channel11 using lower case name
-    nxos_interface_ospf: &configurepclower
-      interface: port-channel11
-      ospf: 1
-      area: 42949672
-      cost: 55
-      passive_interface: true
-      hello_interval: 15
-      dead_interval: 75
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence for port-channel11"
-    nxos_interface_ospf: *configurepclower
-    register: result
-
-  - assert: *false
-
-  - name: configure ospf interface loopback55
-    nxos_interface_ospf: &configurelb
-      interface: LOOPBACK55
-      ospf: 1
-      area: 192.0.2.4
-      cost: 55
-      hello_interval: 15
-      dead_interval: 75
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence for loopback55"
-    nxos_interface_ospf: *configurelb
-    register: result
-
-  - assert: *false
-
-  - name: configure ospf interface loopback77 using lower case name
-    nxos_interface_ospf: &configurelblower
-      interface: loopback77
-      ospf: 1
-      area: 429496
-      cost: 77
-      hello_interval: 45
-      dead_interval: 75
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence for loopback77"
-    nxos_interface_ospf: *configurelblower
-    register: result
-
-  - assert: *false
-
-  - name: remove ospf interface config
-    nxos_interface_ospf: &removeconfig
-      interface: "{{ testint }}"
-      ospf: 1
-      area: 12345678
-      bfd: disable
-      cost: 55
-      passive_interface: true
-      hello_interval: 15
-      dead_interval: 75
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_interface_ospf: *removeconfig
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: Disable features
-    nxos_feature:
-      feature: "{{ item }}"
-      state: disabled
-    loop: ['ospf', 'bfd']
-    ignore_errors: yes
-
-  - name: "Interface cleanup"
-    nxos_config: *intdefault
-    ignore_errors: yes
-
-  - name: "Remove port-channel and loopback ints"
-    nxos_config: *removepcandlb
-    ignore_errors: yes
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_interface_ospf sanity test"
diff --git a/test/integration/targets/nxos_interfaces/defaults/main.yaml b/test/integration/targets/nxos_interfaces/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_interfaces/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_interfaces/meta/main.yml b/test/integration/targets/nxos_interfaces/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_interfaces/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_interfaces/tasks/cli.yaml b/test/integration/targets/nxos_interfaces/tasks/cli.yaml
deleted file mode 100644
index 6c7ea4a7f9..0000000000
--- a/test/integration/targets/nxos_interfaces/tasks/cli.yaml
+++ /dev/null
@@ -1,20 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_interfaces/tasks/main.yaml b/test/integration/targets/nxos_interfaces/tasks/main.yaml
deleted file mode 100644
index afdb973e96..0000000000
--- a/test/integration/targets/nxos_interfaces/tasks/main.yaml
+++ /dev/null
@@ -1,9 +0,0 @@
----
-
-- name: Set system defaults for switchports
-  nxos_config:
-    lines: |
-      no system default switchport
-      system default switchport shutdown
-
-- { include: cli.yaml, tags: ['cli'] }
diff --git a/test/integration/targets/nxos_interfaces/tasks/nxapi.yaml b/test/integration/targets/nxos_interfaces/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_interfaces/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_interfaces/tests/cli/deleted.yaml b/test/integration/targets/nxos_interfaces/tests/cli/deleted.yaml
deleted file mode 100644
index 5c3067d292..0000000000
--- a/test/integration/targets/nxos_interfaces/tests/cli/deleted.yaml
+++ /dev/null
@@ -1,64 +0,0 @@
----
-- debug:
-    msg: "Start nxos_interfaces deleted integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact: test_int2="{{ nxos_int2 }}"
-- set_fact: test_shutdown
-  when: platform is not search('N3[5KL]|N[56]K|titanium')
-
-- name: "setup0: clean up (interfaces) attributes on all interfaces"
-  nxos_interfaces:
-    state: deleted
-
-- name: setup1
-  cli_config: &cleanup
-    config: |
-      default interface {{ test_int1 }}
-
-- block:
-  - name: setup2
-    cli_config:
-      config: |
-        interface {{ test_int1 }}
-          description Test-interface1
-          no shutdown
-
-  - name: Gather interfaces facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: interfaces
-
-  - name: deleted
-    nxos_interfaces: &deleted
-      state: deleted
-    register: result
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.interfaces|symmetric_difference(result.before)|length == 0"
-        - "result.changed == true"
-        - "'interface {{ test_int1 }}' in result.commands"
-        - "'no description' in result.commands"
-
-  - assert:
-      that:
-        - "result.after|length == 0"
-        - "'shutdown' in result.commands"
-    when: test_shutdown is defined
-
-  - name: Idempotence - deleted
-    nxos_interfaces: *deleted
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-    when: test_shutdown is defined
-
-  always:
-  - name: teardown
-    cli_config: *cleanup
diff --git a/test/integration/targets/nxos_interfaces/tests/cli/merged.yaml b/test/integration/targets/nxos_interfaces/tests/cli/merged.yaml
deleted file mode 100644
index 3ed2d74978..0000000000
--- a/test/integration/targets/nxos_interfaces/tests/cli/merged.yaml
+++ /dev/null
@@ -1,57 +0,0 @@
----
-- debug:
-    msg: "Start nxos_interfaces merged integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact: enabled=true
-  when: platform is not search('N3[5KL]|N[56]K|titanium')
-
-- name: setup
-  cli_config: &cleanup
-    config: |
-      default interface {{ test_int1 }}
-
-- block:
-  - name: Merged
-    nxos_interfaces: &merged
-      config:
-        - name: "{{ test_int1 }}"
-          description: Configured by Ansible
-          enabled: "{{ enabled|default(omit)}}"
-      state:  merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'interface {{ test_int1 }}' in result.commands"
-        - "'description Configured by Ansible' in result.commands"
-
-  - assert:
-      that:
-        - "'no shutdown' in result.commands"
-    when: enabled is defined
-
-  - name: Gather interfaces facts
-    nxos_facts:
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: interfaces
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.interfaces|symmetric_difference(result.after)|length == 0"
-
-  - name: Idempotence - Merged
-    nxos_interfaces: *merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *cleanup
diff --git a/test/integration/targets/nxos_interfaces/tests/cli/overridden.yaml b/test/integration/targets/nxos_interfaces/tests/cli/overridden.yaml
deleted file mode 100644
index 25c037487c..0000000000
--- a/test/integration/targets/nxos_interfaces/tests/cli/overridden.yaml
+++ /dev/null
@@ -1,67 +0,0 @@
----
-- debug:
-    msg: "Start nxos_interfaces overridden integration tests connection={{ ansible_connection }}"
-
-- block:
-  - set_fact: test_int1="{{ nxos_int1 }}"
-  - set_fact: test_int2="{{ nxos_int2 }}"
-
-  - name: setup1
-    cli_config: &cleanup
-      config: |
-        default interface {{ test_int1 }}
-        default interface {{ test_int2 }}
-
-  - block:
-    - name: setup2
-      cli_config:
-        config: |
-          interface {{ test_int1 }}
-            description Ansible setup
-            no shutdown
-
-    - name: Gather interfaces facts
-      nxos_facts: &facts
-        gather_subset:
-          - '!all'
-          - '!min'
-        gather_network_resources: interfaces
-
-    - name: Overridden
-      nxos_interfaces: &overridden
-        config:
-          - name: "{{ test_int2 }}"
-            description: Configured by Ansible
-        state: overridden
-      register: result
-
-    - assert:
-        that:
-          # int1 becomes default state, int2 becomes non-default
-          - "ansible_facts.network_resources.interfaces|symmetric_difference(result.before)|length == 0"
-          - "result.changed == true"
-          - "'interface {{ test_int1 }}' in result.commands"
-          - "'shutdown' in result.commands"
-          - "'interface {{ test_int2 }}' in result.commands"
-          - "'description Configured by Ansible' in result.commands"
-
-    - name: Gather interfaces post facts
-      nxos_facts: *facts
-
-    - assert:
-        that:
-          - "ansible_facts.network_resources.interfaces|symmetric_difference(result.after)|length == 0"
-
-    - name: Idempotence - Overridden
-      nxos_interfaces: *overridden
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-          - "result.commands|length == 0"
-
-    always:
-    - name: teardown
-      cli_config: *cleanup
-  when: platform is not search('N3[5KL]|N[56]K|titanium')
diff --git a/test/integration/targets/nxos_interfaces/tests/cli/replaced.yaml b/test/integration/targets/nxos_interfaces/tests/cli/replaced.yaml
deleted file mode 100644
index 96233bfaf8..0000000000
--- a/test/integration/targets/nxos_interfaces/tests/cli/replaced.yaml
+++ /dev/null
@@ -1,63 +0,0 @@
----
-- debug:
-    msg: "Start nxos_interfaces replaced integration tests connection={{ ansible_connection }}"
-
-- block:
-  - set_fact: test_int1="{{ nxos_int1 }}"
-  - name: setup1
-    cli_config: &cleanup
-      config: |
-        default interface {{ test_int1 }}
-
-  - block:
-    - name: setup2
-      cli_config:
-        config: |
-          interface {{ test_int1 }}
-            description Ansible setup
-
-    - name: Gather interfaces facts
-      nxos_facts: &facts
-        gather_subset:
-          - '!all'
-          - '!min'
-        gather_network_resources: interfaces
-
-    - name: Replaced
-      nxos_interfaces: &replaced
-        config:
-          - name: "{{ test_int1 }}"
-            description: 'Configured by Ansible'
-            enabled: True
-        state: replaced
-      register: result
-
-    - assert:
-        that:
-          - "ansible_facts.network_resources.interfaces|symmetric_difference(result.before)|length == 0"
-          - "result.changed == true"
-          - "'interface {{ test_int1 }}' in result.commands"
-          - "'description Configured by Ansible' in result.commands"
-          - "'no shutdown' in result.commands"
-
-    - name: Gather interfaces post facts
-      nxos_facts: *facts
-
-    - assert:
-        that:
-          - "ansible_facts.network_resources.interfaces|symmetric_difference(result.after)|length == 0"
-
-    - name: Idempotence - Replaced
-      nxos_interfaces: *replaced
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-          - "result.commands|length == 0"
-
-    always:
-    - name: teardown
-      cli_config: *cleanup
-
-  when: platform is not search('N3[5KL]|N[56]K|titanium')
diff --git a/test/integration/targets/nxos_l2_interface/defaults/main.yaml b/test/integration/targets/nxos_l2_interface/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_l2_interface/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_l2_interface/meta/main.yml b/test/integration/targets/nxos_l2_interface/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_l2_interface/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_l2_interface/tasks/cli.yaml b/test/integration/targets/nxos_l2_interface/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_l2_interface/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_l2_interface/tasks/main.yaml b/test/integration/targets/nxos_l2_interface/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_l2_interface/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_l2_interface/tasks/nxapi.yaml b/test/integration/targets/nxos_l2_interface/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_l2_interface/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_l2_interface/tests/common/agg.yaml b/test/integration/targets/nxos_l2_interface/tests/common/agg.yaml
deleted file mode 100644
index 25b4183daa..0000000000
--- a/test/integration/targets/nxos_l2_interface/tests/common/agg.yaml
+++ /dev/null
@@ -1,93 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_l2_interface aggregate test"
-
-# Select interface for test
-- set_fact: intname1="{{ nxos_int1 }}"
-- set_fact: intname2="{{ nxos_int2 }}"
-
-- name: "Setup vlans"
-  nxos_vlan:
-    vlan_range: "6,15"
-
-- name: Setup - Ensure interfaces are layer2
-  nxos_interface:
-    aggregate:
-      - { name: "{{ intname1 }}" }
-      - { name: "{{ intname2 }}" }
-    mode: layer2
-
-- name: Setup - Remove interface aggregate before testing
-  nxos_l2_interface:
-    aggregate:
-      - { name: "{{ intname1 }}", mode: access, access_vlan: 6 }
-      - { name: "{{ intname2 }}", mode: access, access_vlan: 15 }
-    state: absent
-
-- name: Sleep for 2 seconds on Fretta Platform
-  wait_for: timeout=2
-  when: platform is match("N9K-F")
-
-- block:
-  - name: Configure interface for access_vlan aggregate
-    nxos_l2_interface: &conf_agg
-      aggregate:
-        - { name: "{{ intname1 }}", mode: access, access_vlan: 6 }
-        - { name: "{{ intname2 }}", mode: access, access_vlan: 15 }
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-
-  - name: Sleep for 2 seconds on Fretta Platform
-    wait_for: timeout=2
-    when: platform is match("N9K-F")
-
-  - name: Configure interface for access_vlan aggregate(Idempotence)
-    nxos_l2_interface: *conf_agg
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-
-  - name: Remove interface aggregate
-    nxos_l2_interface: &rm_agg
-      aggregate:
-        - { name: "{{ intname1 }}", mode: access, access_vlan: 6 }
-        - { name: "{{ intname2 }}", mode: access, access_vlan: 15 }
-      state: absent
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-
-  - name: Sleep for 2 seconds on Fretta Platform
-    wait_for: timeout=2
-    when: platform is match("N9K-F")
-
-  - name: Remove interface aggregate(Idempotence)
-    nxos_l2_interface: *rm_agg
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-
-  always:
-  - name: "remove vlans"
-    nxos_vlan:
-      vlan_range: "6,15"
-      state: absent
-    ignore_errors: yes
-
-  - name: "Remove interface aggregate after testing"
-    nxos_l2_interface:
-      aggregate:
-        - { name: "{{ intname1 }}", mode: access, access_vlan: 6 }
-        - { name: "{{ intname2 }}", mode: access, access_vlan: 15 }
-      state: absent
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_l2_interface aggregate test"
diff --git a/test/integration/targets/nxos_l2_interface/tests/common/sanity.yaml b/test/integration/targets/nxos_l2_interface/tests/common/sanity.yaml
deleted file mode 100644
index e21bf2d46a..0000000000
--- a/test/integration/targets/nxos_l2_interface/tests/common/sanity.yaml
+++ /dev/null
@@ -1,153 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_l2_interface sanity test"
-
-# Select interface for test
-- set_fact: intname="{{ nxos_int1 }}"
-
-- name: "Interface selected for this test"
-  debug: msg="{{ intname }}"
-
-- name: "Setup interface"
-  nxos_config: &default
-    lines:
-      - "default interface {{ intname }}"
-  ignore_errors: yes
-
-- name: Setup - Ensure interface is layer2
-  nxos_interface:
-    interface: "{{ intname }}"
-    mode: layer2
-
-- name: "Setup vlans"
-  nxos_vlan:
-    vlan_range: "5-10,20"
-
-- block:
-  - name: Ensure interface is in its default switchport state
-    nxos_l2_interface: &def_swi
-      name: "{{ intname }}"
-      state: unconfigured
-
-  - name: Ensure interface is configured for access vlan 20
-    nxos_l2_interface: &acc_vl
-      name: "{{ intname }}"
-      mode: access
-      access_vlan: 20
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: Sleep for 2 seconds on Fretta Platform
-    wait_for: timeout=2
-    when: platform is match("N9K-F")
-
-  - name: "access vlan Idempotence"
-    nxos_l2_interface: *acc_vl
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Ensure interface only has vlans 5-10 as trunk vlans
-    nxos_l2_interface: &tr_vl
-      name: "{{ intname }}"
-      mode: trunk
-      native_vlan: 10
-      trunk_allowed_vlans: 5-10
-    register: result
-
-  - assert: *true
-
-  - name: "trunk vlan Idempotence"
-    nxos_l2_interface: *tr_vl
-    register: result
-
-  - assert: *false
-
-  - name: Ensure interface is a trunk port and ensure 2-50 are being tagged (doesn't mean others aren't also being tagged)
-    nxos_l2_interface: &tag
-      name: "{{ intname }}"
-      mode: trunk
-      native_vlan: 10
-      trunk_vlans: 2-50
-    register: result
-
-  - assert: *true
-
-  - name: "tag vlan Idempotence"
-    nxos_l2_interface: *tag
-    register: result
-
-  - assert: *false
-
-  - name: Remove full trunk vlan range 2-50
-    nxos_l2_interface: &no_tag
-      name: "{{ intname }}"
-      mode: trunk
-      trunk_vlans: 2-50
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: Check Idempotence Remove full trunk vlan range 2-50
-    nxos_l2_interface: *no_tag
-    register: result
-
-  - assert: *false
-
-  - name: Reconfigure interface trunk port and ensure 2-50 are being tagged
-    nxos_l2_interface: *tag
-    register: result
-
-  - assert: *true
-
-  - name: Check Idempotence Reconfigure interface trunk port and ensure 2-50 are being tagged
-    nxos_l2_interface: *tag
-    register: result
-
-  - assert: *false
-
-  - name: Remove partial trunk vlan range 30-4094 are removed
-    nxos_l2_interface: &partial
-      name: "{{ intname }}"
-      mode: trunk
-      trunk_vlans: 30-4094
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: Check Idempotence Remove partial trunk vlan range 30-4094 are removed
-    nxos_l2_interface: *partial
-    register: result
-
-  - assert: *false
-
-  - name: put interface default state
-    nxos_l2_interface: *def_swi
-    register: result
-
-  - assert: *true
-
-  - name: "default state idempotence"
-    nxos_l2_interface: *def_swi
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: "remove vlans"
-    nxos_vlan:
-      vlan_range: "5-10,20"
-      state: absent
-    ignore_errors: yes
-
-  - name: "default interface"
-    nxos_config: *default
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_l2_interface sanity test"
diff --git a/test/integration/targets/nxos_l2_interfaces/defaults/main.yaml b/test/integration/targets/nxos_l2_interfaces/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_l2_interfaces/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_l2_interfaces/meta/main.yml b/test/integration/targets/nxos_l2_interfaces/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_l2_interfaces/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_l2_interfaces/tasks/cli.yaml b/test/integration/targets/nxos_l2_interfaces/tasks/cli.yaml
deleted file mode 100644
index 6c7ea4a7f9..0000000000
--- a/test/integration/targets/nxos_l2_interfaces/tasks/cli.yaml
+++ /dev/null
@@ -1,20 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_l2_interfaces/tasks/main.yaml b/test/integration/targets/nxos_l2_interfaces/tasks/main.yaml
deleted file mode 100644
index 415c99d8b1..0000000000
--- a/test/integration/targets/nxos_l2_interfaces/tasks/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
diff --git a/test/integration/targets/nxos_l2_interfaces/tasks/nxapi.yaml b/test/integration/targets/nxos_l2_interfaces/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_l2_interfaces/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_l2_interfaces/tests/cli/deleted.yaml b/test/integration/targets/nxos_l2_interfaces/tests/cli/deleted.yaml
deleted file mode 100644
index 4d04aae861..0000000000
--- a/test/integration/targets/nxos_l2_interfaces/tests/cli/deleted.yaml
+++ /dev/null
@@ -1,63 +0,0 @@
----
-- debug:
-    msg: "Start nxos_l2_interfaces deleted integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact: test_int2="{{ nxos_int2 }}"
-
-- name: setup1
-  cli_config: &cleanup
-    config: |
-      default interface {{ test_int1 }}
-      default interface {{ test_int2 }}
-  ignore_errors: yes
-
-- block:
-  - name: setup2
-    cli_config:
-      config: |
-        interface {{ test_int1 }}
-          switchport
-          switchport trunk native vlan 10
-        interface {{ test_int2 }}
-          switchport
-          switchport mode trunk
-          switchport trunk allowed vlan 20
-
-  - name: Gather l2_interfaces facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: l2_interfaces
-
-  - name: deleted
-    nxos_l2_interfaces: &deleted
-      state: deleted
-    register: result
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.l2_interfaces|symmetric_difference(result.before)|length == 0"
-        - "result.after|length == 0"
-        - "result.changed == true"
-        - "'interface {{ test_int1 }}' in result.commands"
-        - "'no switchport trunk native vlan' in result.commands"
-        - "'interface {{ test_int2 }}' in result.commands"
-        - "'no switchport mode' in result.commands"
-        - "'no switchport trunk allowed vlan' in result.commands"
-        - "result.commands|length == 5"
-
-  - name: Idempotence - deleted
-    nxos_l2_interfaces: *deleted
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *cleanup
-    ignore_errors: yes
diff --git a/test/integration/targets/nxos_l2_interfaces/tests/cli/merged.yaml b/test/integration/targets/nxos_l2_interfaces/tests/cli/merged.yaml
deleted file mode 100644
index f72f5b5039..0000000000
--- a/test/integration/targets/nxos_l2_interfaces/tests/cli/merged.yaml
+++ /dev/null
@@ -1,102 +0,0 @@
----
-- debug:
-    msg: "Start nxos_l2_interfaces merged integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-
-- name: setup
-  cli_config: &cleanup
-    config: |
-      default interface {{ test_int1 }}
-  ignore_errors: yes
-
-- block:
-  - name: setup2
-    cli_config:
-      config: |
-        interface {{ test_int1 }}
-          switchport
-
-  - name: Merged
-    nxos_l2_interfaces: &merged
-      config:
-        - name: "{{ test_int1 }}"
-          access:
-            vlan: 6
-          trunk:
-            allowed_vlans: 200
-      state:  merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "result.before|length == 0"
-        - "'interface {{ test_int1 }}' in result.commands"
-        - "'switchport access vlan 6' in result.commands"
-        - "'switchport trunk allowed vlan 200' in result.commands"
-        - "result.commands|length == 3"
-
-  - name: Gather l2_interfaces facts
-    nxos_facts:
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: l2_interfaces
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.l2_interfaces|symmetric_difference(result.after)|length == 0"
-
-  - name: Idempotence - Merged
-    nxos_l2_interfaces: *merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  - name: Merge with existing vlans
-    nxos_l2_interfaces: &vlanadd
-      config:
-        - name: "{{ test_int1 }}"
-          mode: trunk
-          trunk:
-            allowed_vlans: "10-12"
-      state:  merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'interface {{ test_int1 }}' in result.commands"
-        - "'switchport mode trunk' in result.commands"
-        - "'switchport trunk allowed vlan add 10,11,12' in result.commands"
-        - "result.commands|length == 3"
-
-  - name: Gather l2_interfaces facts
-    nxos_facts:
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: l2_interfaces
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.l2_interfaces|symmetric_difference(result.after)|length == 0"
-
-  - name: Idempotence - with newly added vlans
-    nxos_l2_interfaces: *vlanadd
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-
-  always:
-  - name: teardown
-    cli_config: *cleanup
-    ignore_errors: yes
diff --git a/test/integration/targets/nxos_l2_interfaces/tests/cli/overridden.yaml b/test/integration/targets/nxos_l2_interfaces/tests/cli/overridden.yaml
deleted file mode 100644
index af8a18ec45..0000000000
--- a/test/integration/targets/nxos_l2_interfaces/tests/cli/overridden.yaml
+++ /dev/null
@@ -1,72 +0,0 @@
----
-- debug:
-    msg: "Start nxos_l2_interfaces overridden integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact: test_int2="{{ nxos_int2 }}"
-
-- name: setup1
-  cli_config: &cleanup
-    config: |
-      default interface {{ test_int1 }}
-      default interface {{ test_int2 }}
-  ignore_errors: yes
-
-- block:
-  - name: setup2
-    cli_config:
-      config: |
-        interface {{ test_int1 }}
-          switchport
-          switchport trunk allowed vlan 11
-        interface {{ test_int2 }}
-          switchport
-
-  - name: Gather l2_interfaces facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: l2_interfaces
-
-  - name: Overridden
-    nxos_l2_interfaces: &overridden
-      config:
-        - name: "{{ test_int2 }}"
-          access:
-            vlan: 6
-          trunk:
-            allowed_vlans: "10-12"
-      state: overridden
-    register: result
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.l2_interfaces|symmetric_difference(result.before)|length == 0"
-        - "result.changed == true"
-        - "'interface {{ test_int1 }}' in result.commands"
-        - "'no switchport trunk allowed vlan' in result.commands"
-        - "'interface {{ test_int2 }}' in result.commands"
-        - "'switchport access vlan 6' in result.commands"
-        - "'switchport trunk allowed vlan 10,11,12' in result.commands"
-
-  - name: Gather l2_interfaces post facts
-    nxos_facts: *facts
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.l2_interfaces|symmetric_difference(result.after)|length == 0"
-
-  - name: Idempotence - Overridden
-    nxos_l2_interfaces: *overridden
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *cleanup
-    ignore_errors: yes
diff --git a/test/integration/targets/nxos_l2_interfaces/tests/cli/replaced.yaml b/test/integration/targets/nxos_l2_interfaces/tests/cli/replaced.yaml
deleted file mode 100644
index 275ce8b6e7..0000000000
--- a/test/integration/targets/nxos_l2_interfaces/tests/cli/replaced.yaml
+++ /dev/null
@@ -1,72 +0,0 @@
----
-- debug:
-    msg: "Start nxos_l2_interfaces replaced integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact: test_int2="{{ nxos_int2 }}"
-
-- name: setup1
-  cli_config: &cleanup
-    config: |
-      default interface {{ test_int1 }}
-      default interface {{ test_int2 }}
-  ignore_errors: yes
-
-- block:
-  - name: setup2
-    cli_config:
-      config: |
-        interface {{ test_int1 }}
-          switchport
-          switchport access vlan 5
-        interface {{ test_int2 }}
-          switchport
-          switchport trunk native vlan 15
-          switchport trunk allowed vlan 25-27
-
-  - name: Gather l2_interfaces facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: l2_interfaces
-
-  - name: Replaced
-    nxos_l2_interfaces: &replaced
-      config:
-        - name: "{{ test_int1 }}"
-          access:
-            vlan: 8
-          trunk:
-            allowed_vlans: "10-12"
-      state: replaced
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'interface {{ test_int1 }}' in result.commands"
-        - "'switchport access vlan 8' in result.commands"
-        - "'switchport trunk allowed vlan 10,11,12' in result.commands"
-        - "result.commands|length == 3"
-
-  - name: Gather l2_interfaces post facts
-    nxos_facts: *facts
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.l2_interfaces|symmetric_difference(result.after)|length == 0"
-
-  - name: Idempotence - Replaced
-    nxos_l2_interfaces: *replaced
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *cleanup
-    ignore_errors: yes
diff --git a/test/integration/targets/nxos_l3_interface/defaults/main.yaml b/test/integration/targets/nxos_l3_interface/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_l3_interface/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_l3_interface/meta/main.yml b/test/integration/targets/nxos_l3_interface/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_l3_interface/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_l3_interface/tasks/cli.yaml b/test/integration/targets/nxos_l3_interface/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_l3_interface/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_l3_interface/tasks/main.yaml b/test/integration/targets/nxos_l3_interface/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_l3_interface/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_l3_interface/tasks/nxapi.yaml b/test/integration/targets/nxos_l3_interface/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_l3_interface/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_l3_interface/tests/cli/sanity.yaml b/test/integration/targets/nxos_l3_interface/tests/cli/sanity.yaml
deleted file mode 100644
index 6a0e48e124..0000000000
--- a/test/integration/targets/nxos_l3_interface/tests/cli/sanity.yaml
+++ /dev/null
@@ -1,112 +0,0 @@
----
-- debug: msg="START TRANSPORT:CLI nxos_l3_interface sanity test"
-
-# Select interface for test
-- set_fact: testint2="{{ nxos_int2 }}"
-- set_fact: testint3="{{ nxos_int3 }}"
-
-- set_fact: ipv6_address=""
-- set_fact: ipv6_address="33:db::2/8"
-  when: ipv6_supported
-
-- name: Setup - remove address from interface prior to testing(Part1)
-  nxos_config:
-    lines:
-      - no ip address 192.168.22.1/24
-    parents: no switchport
-    before: "interface {{ testint2 }}"
-  ignore_errors: yes
-
-- name: Setup - remove address from interface prior to testing(Part2)
-  nxos_config:
-    lines:
-      - no ip address 192.168.20.1/24
-      - no ipv6 address 33:db::2/8
-    parents: no switchport
-    before: "interface {{ testint3 }}"
-  ignore_errors: yes
-
-- name: Setup - Ensure interfaces are layer3
-  nxos_interface:
-    aggregate:
-      - name: "{{ testint2 }}"
-      - name: "{{ testint3 }}"
-    mode: layer3
-
-- name: Configure ipv4 address to interface
-  nxos_l3_interface: &conf
-    name: "{{ testint2 }}"
-    ipv4: 192.168.22.1/24
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: Configure ipv4 address to interface(Idempotence)
-  nxos_l3_interface: *conf
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: Remove ipv4 address from interface
-  nxos_l3_interface: &rm
-    name: "{{ testint2 }}"
-    ipv4: 192.168.22.1/24
-    state: absent
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: Remove ipv4 address from interface(Idempotence)
-  nxos_l3_interface: *rm
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: Configure address to interfaces aggregate
-  nxos_l3_interface: &conf_agg
-    aggregate:
-      - { name: "{{ testint2 }}", ipv4: 192.168.22.1/24 }
-      - { name: "{{ testint3 }}", ipv4: 192.168.20.1/24, ipv6: "{{ ipv6_address }}" }
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: Configure address to interfaces aggregate(Idempotence)
-  nxos_l3_interface: *conf_agg
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: Remove address from interfaces aggregate
-  nxos_l3_interface: &rm_agg
-    aggregate:
-      - { name: "{{ testint2 }}", ipv4: 192.168.22.1/24 }
-      - { name: "{{ testint3 }}", ipv4: 192.168.20.1/24, ipv6: "{{ ipv6_address }}" }
-    state: absent
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: Remove address from interfaces aggregate(Idempotence)
-  nxos_l3_interface: *rm_agg
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- debug: msg="END TRANSPORT:CLI nxos_l3_interface sanity test"
diff --git a/test/integration/targets/nxos_l3_interface/tests/nxapi/sanity.yaml b/test/integration/targets/nxos_l3_interface/tests/nxapi/sanity.yaml
deleted file mode 100644
index 054a356c4b..0000000000
--- a/test/integration/targets/nxos_l3_interface/tests/nxapi/sanity.yaml
+++ /dev/null
@@ -1,103 +0,0 @@
----
-- debug: msg="START TRANSPORT:NXAPI nxos_l3_interface sanity test"
-
-# Select interface for test
-- set_fact: testint2="{{ nxos_int2 }}"
-- set_fact: testint3="{{ nxos_int3 }}"
-
-- set_fact: ipv6_address=""
-- set_fact: ipv6_address="33:db::2/8"
-  when: ipv6_supported
-
-- name: Setup - Remove address from interfaces aggregate
-  nxos_l3_interface:
-    aggregate:
-      - { name: "{{ testint2 }}", ipv4: 192.168.22.1/24 }
-      - { name: "{{ testint3 }}", ipv4: 192.168.20.1/24, ipv6: "{{ ipv6_address }}" }
-    state: absent
-  ignore_errors: yes
-
-- name: Setup - Ensure interfaces are layer3
-  nxos_interface:
-    aggregate:
-      - name: "{{ testint2 }}"
-      - name: "{{ testint3 }}"
-    mode: layer3
-
-- name: Configure ipv4 address to interface
-  nxos_l3_interface: &conf
-    name: "{{ testint2 }}"
-    ipv4: 192.168.22.1/24
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: Configure ipv4 address to interface(Idempotence)
-  nxos_l3_interface: *conf
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: Remove ipv4 address from interface
-  nxos_l3_interface: &rm
-    name: "{{ testint2 }}"
-    ipv4: 192.168.22.1/24
-    state: absent
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: Remove ipv4 address from interface(Idempotence)
-  nxos_l3_interface: *rm
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: Configure address to interfaces aggregate
-  nxos_l3_interface: &conf_agg
-    aggregate:
-      - { name: "{{ testint2 }}", ipv4: 192.168.22.1/24 }
-      - { name: "{{ testint3 }}", ipv4: 192.168.20.1/24, ipv6: "{{ ipv6_address }}" }
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: Configure address to interfaces aggregate(Idempotence)
-  nxos_l3_interface: *conf_agg
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: Remove address from interfaces aggregate
-  nxos_l3_interface: &rm_agg
-    aggregate:
-      - { name: "{{ testint2 }}", ipv4: 192.168.22.1/24 }
-      - { name: "{{ testint3 }}", ipv4: 192.168.20.1/24, ipv6: "{{ ipv6_address }}" }
-    state: absent
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: Remove address from interfaces aggregate(Idempotence)
-  nxos_l3_interface: *rm_agg
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- debug: msg="END TRANSPORT:NXAPI nxos_l3_interface sanity test"
diff --git a/test/integration/targets/nxos_l3_interfaces/defaults/main.yaml b/test/integration/targets/nxos_l3_interfaces/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_l3_interfaces/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_l3_interfaces/meta/main.yml b/test/integration/targets/nxos_l3_interfaces/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_l3_interfaces/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_l3_interfaces/tasks/cli.yaml b/test/integration/targets/nxos_l3_interfaces/tasks/cli.yaml
deleted file mode 100644
index 6c7ea4a7f9..0000000000
--- a/test/integration/targets/nxos_l3_interfaces/tasks/cli.yaml
+++ /dev/null
@@ -1,20 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_l3_interfaces/tasks/main.yaml b/test/integration/targets/nxos_l3_interfaces/tasks/main.yaml
deleted file mode 100644
index 44edf82581..0000000000
--- a/test/integration/targets/nxos_l3_interfaces/tasks/main.yaml
+++ /dev/null
@@ -1,18 +0,0 @@
----
-# The interface-count asserts need to also account for mgmt0 which is a reserved
-# interface; i.e. it will be included in L3 facts when it has non-default values
-# but excluded from result.before/after because it's not allowed to be managed.
-- set_fact:
-    # Zuul CI skips prepare_nxos but will have dhcp configured on mgmt0
-    rsvd_intf_len: 1
-
-- block:
-  - set_fact:
-      mgmt:
-        "{{ intdataraw|selectattr('interface', 'equalto', 'mgmt0')|list}}"
-  - set_fact:
-      rsvd_intf_len:
-        "{{ 1 if (mgmt and 'ip_addr' in mgmt[0]) else 0}}"
-  when: prepare_nxos_tests_task | default(True) | bool
-
-- { include: cli.yaml, tags: ['cli'] }
diff --git a/test/integration/targets/nxos_l3_interfaces/tasks/nxapi.yaml b/test/integration/targets/nxos_l3_interfaces/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_l3_interfaces/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_l3_interfaces/tests/cli/deleted.yaml b/test/integration/targets/nxos_l3_interfaces/tests/cli/deleted.yaml
deleted file mode 100644
index 51bf75350b..0000000000
--- a/test/integration/targets/nxos_l3_interfaces/tests/cli/deleted.yaml
+++ /dev/null
@@ -1,70 +0,0 @@
----
-- debug:
-    msg: "Start nxos_l3_interfaces deleted integration tests connection={{ ansible_connection }}"
-
-- set_fact:
-    test_int3: "{{ nxos_int3 }}"
-    subint3: "{{ nxos_int3 }}.42"
-
-- name: setup1
-  cli_config: &cleanup
-    config: |
-      no system default switchport
-      default interface {{ test_int3 }}
-      interface {{ test_int3 }}
-        no switchport
-  ignore_errors: yes
-
-- name: setup2 cleanup all L3 interfaces on device
-  nxos_l3_interfaces:
-    state: deleted
-
-- block:
-  - name: setup3
-    cli_config:
-      config: |
-        interface {{ subint3 }}
-          encapsulation dot1q 42
-          ip address 192.168.10.2/24
-          no ip redirects
-          ip unreachables
-
-  - name: Gather l3_interfaces facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: l3_interfaces
-
-  - name: deleted
-    nxos_l3_interfaces: &deleted
-      state: deleted
-    register: result
-
-  - assert:
-      that:
-        - "result.before|length == (ansible_facts.network_resources.l3_interfaces|length|int - rsvd_intf_len|int)"
-        - "result.after|length == 0"
-        - "result.changed == true"
-        - "'interface {{ subint3 }}' in result.commands"
-        - "'no encapsulation dot1q' in result.commands"
-        - "'ip redirects' in result.commands"
-        - "'no ip unreachables' in result.commands"
-        - "'no ip address' in result.commands"
-        - "result.commands|length == 5"
-
-  - name: Idempotence - deleted
-    nxos_l3_interfaces: *deleted
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config:
-      config: |
-        no interface {{ subint3 }}
-    ignore_errors: yes
diff --git a/test/integration/targets/nxos_l3_interfaces/tests/cli/merged.yaml b/test/integration/targets/nxos_l3_interfaces/tests/cli/merged.yaml
deleted file mode 100644
index 80404ef18e..0000000000
--- a/test/integration/targets/nxos_l3_interfaces/tests/cli/merged.yaml
+++ /dev/null
@@ -1,71 +0,0 @@
----
-- debug:
-    msg: "Start nxos_l3_interfaces merged integration tests connection={{ ansible_connection }}"
-
-- set_fact:
-    test_int3: "{{ nxos_int3 }}"
-    subint3: "{{ nxos_int3 }}.42"
-
-- name: setup1
-  cli_config: &cleanup
-    config: |
-      no system default switchport
-      default interface {{ test_int3 }}
-      interface {{ test_int3 }}
-        no switchport
-  ignore_errors: yes
-
-- name: setup2 cleanup all L3 states on all interfaces
-  nxos_l3_interfaces:
-    state: deleted
-
-- block:
-  - name: Merged
-    nxos_l3_interfaces: &merged
-      config:
-        - name: "{{ subint3 }}"
-          dot1q: 42
-          redirects: false
-          unreachables: true
-          ipv4:
-            - address: 192.168.10.2/24
-      state:  merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "result.before|length == 0"
-        - "'interface {{ subint3 }}' in result.commands"
-        - "'encapsulation dot1q 42' in result.commands"
-        - "'no ip redirects' in result.commands"
-        - "'ip unreachables' in result.commands"
-        - "'ip address 192.168.10.2/24' in result.commands"
-        - "result.commands|length == 5"
-
-  - name: Gather l3_interfaces facts
-    nxos_facts:
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: l3_interfaces
-
-  - assert:
-      that:
-        - "result.after|length == (ansible_facts.network_resources.l3_interfaces|length|int - rsvd_intf_len|int)"
-
-  - name: Idempotence - Merged
-    nxos_l3_interfaces: *merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config:
-      config: |
-        no interface {{ subint3 }}
-    ignore_errors: yes
diff --git a/test/integration/targets/nxos_l3_interfaces/tests/cli/overridden.yaml b/test/integration/targets/nxos_l3_interfaces/tests/cli/overridden.yaml
deleted file mode 100644
index f3d6e5cf21..0000000000
--- a/test/integration/targets/nxos_l3_interfaces/tests/cli/overridden.yaml
+++ /dev/null
@@ -1,84 +0,0 @@
----
-- debug:
-    msg: "Start nxos_l3_interfaces overridden integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact: test_int2="{{ nxos_int2 }}"
-- set_fact: test_int3="{{ nxos_int3 }}"
-
-- name: setup1
-  cli_config: &cleanup
-    config: |
-      no system default switchport
-      default interface {{ test_int1 }}
-      default interface {{ test_int2 }}
-      default interface {{ test_int3 }}
-      interface {{ test_int1 }}
-        no switchport
-      interface {{ test_int2 }}
-        no switchport
-      interface {{ test_int3 }}
-        no switchport
-  ignore_errors: yes
-
-- name: setup2 cleanup all L3 states on all interfaces
-  nxos_l3_interfaces:
-    state: deleted
-
-- block:
-  - name: setup3
-    cli_config:
-      config: |
-        interface {{ test_int1 }}
-          ip address 192.168.10.2/24 tag 5
-        interface {{ test_int2 }}
-          ip address 10.1.1.1/24
-
-  - name: Gather l3_interfaces facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: l3_interfaces
-
-  - name: Overridden
-    nxos_l3_interfaces: &overridden
-      config:
-        - name: "{{ test_int3 }}"
-          ipv4:
-            - address: 10.1.1.3/24
-      state: overridden
-    register: result
-
-  - assert:
-      that:
-        - "result.before|length == (ansible_facts.network_resources.l3_interfaces|length|int - rsvd_intf_len|int)"
-        - "result.changed == true"
-        - "'interface {{ test_int1 }}' in result.commands"
-        - "'no ip address' in result.commands"
-        - "'interface {{ test_int2 }}' in result.commands"
-        - "'no ip address' in result.commands"
-        - "'interface {{ test_int3 }}' in result.commands"
-        - "'ip address 10.1.1.3/24' in result.commands"
-        - "result.commands|length == 6"
-
-  - name: Gather l3_interfaces post facts
-    nxos_facts: *facts
-
-  - assert:
-      that:
-        - "result.after|length == (ansible_facts.network_resources.l3_interfaces|length|int - rsvd_intf_len|int)"
-
-  - name: Idempotence - Overridden
-    nxos_l3_interfaces: *overridden
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *cleanup
-    ignore_errors: yes
diff --git a/test/integration/targets/nxos_l3_interfaces/tests/cli/replaced.yaml b/test/integration/targets/nxos_l3_interfaces/tests/cli/replaced.yaml
deleted file mode 100644
index 2841a7e35e..0000000000
--- a/test/integration/targets/nxos_l3_interfaces/tests/cli/replaced.yaml
+++ /dev/null
@@ -1,117 +0,0 @@
----
-- debug:
-    msg: "Start nxos_l3_interfaces replaced integration tests connection={{ ansible_connection }}"
-
-- set_fact:
-    test_int3: "{{ nxos_int3 }}"
-    subint3: "{{ nxos_int3 }}.42"
-
-- name: setup1
-  cli_config: &cleanup
-    config: |
-      no system default switchport
-      default interface {{ test_int3 }}
-      interface {{ test_int3 }}
-        no switchport
-  ignore_errors: yes
-
-- name: setup2 cleanup all L3 states on all interfaces
-  nxos_l3_interfaces:
-    state: deleted
-
-- block:
-  - name: setup3
-    cli_config:
-      config: |
-        interface {{ subint3 }}
-          encapsulation dot1q 42
-          ip address 192.168.10.2/24
-          no ip redirects
-          ip unreachables
-
-  - name: Gather l3_interfaces facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: l3_interfaces
-
-  - name: Replaced
-    nxos_l3_interfaces: &replaced
-      config:
-        - name: "{{ subint3 }}"
-          dot1q: 442
-          # Note: device auto-disables redirects when secondaries are present
-          redirects: false
-          unreachables: false
-          ipv4:
-            - address: 192.168.20.2/24
-              tag: 5
-            - address: 192.168.200.2/24
-              secondary: True
-      state: replaced
-    register: result
-
-  - assert:
-      that:
-        - "result.before|length == (ansible_facts.network_resources.l3_interfaces|length|int - rsvd_intf_len|int)"
-        - "result.changed == true"
-        - "'interface {{ subint3 }}' in result.commands"
-        - "'encapsulation dot1q 442' in result.commands"
-        - "'no ip unreachables' in result.commands"
-        - "'ip address 192.168.20.2/24 tag 5' in result.commands"
-        - "'ip address 192.168.200.2/24 secondary' in result.commands"
-        - "result.commands|length == 5"
-
-  - name: Gather l3_interfaces post facts
-    nxos_facts: *facts
-
-  - assert:
-      that:
-        - "result.after|length == (ansible_facts.network_resources.l3_interfaces|length|int - rsvd_intf_len|int)"
-
-  - name: Idempotence - Replaced
-    nxos_l3_interfaces: *replaced
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  - name: Replaced with no optional attrs specified
-    nxos_l3_interfaces: &replaced_no_attrs
-      config:
-        - name: "{{ subint3 }}"
-      state: replaced
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'interface {{ subint3 }}' in result.commands"
-        - "'no encapsulation dot1q' in result.commands"
-        - "'no ip address' in result.commands"
-
-  - assert:
-      that:
-        # 'ip redirects' normally auto-enables due to rmv'ing the secondaries;
-        # this behavior is unreliable on legacy platforms thus command is explicit.
-        - "'ip redirects' in result.commands"
-    when: platform is match('N[3567]')
-
-  - name: Idempotence - Replaced with no attrs specified
-    nxos_l3_interfaces: *replaced_no_attrs
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config:
-      config: |
-        no interface {{ subint3 }}
-    ignore_errors: yes
diff --git a/test/integration/targets/nxos_lacp/defaults/main.yaml b/test/integration/targets/nxos_lacp/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_lacp/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_lacp/meta/main.yml b/test/integration/targets/nxos_lacp/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_lacp/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_lacp/tasks/cli.yaml b/test/integration/targets/nxos_lacp/tasks/cli.yaml
deleted file mode 100644
index 76743023ce..0000000000
--- a/test/integration/targets/nxos_lacp/tasks/cli.yaml
+++ /dev/null
@@ -1,20 +0,0 @@
----
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_lacp/tasks/main.yaml b/test/integration/targets/nxos_lacp/tasks/main.yaml
deleted file mode 100644
index 415c99d8b1..0000000000
--- a/test/integration/targets/nxos_lacp/tasks/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
diff --git a/test/integration/targets/nxos_lacp/tests/cli/deleted.yaml b/test/integration/targets/nxos_lacp/tests/cli/deleted.yaml
deleted file mode 100644
index a9e158e69d..0000000000
--- a/test/integration/targets/nxos_lacp/tests/cli/deleted.yaml
+++ /dev/null
@@ -1,71 +0,0 @@
----
-- debug:
-    msg: "Start nxos_lacp deleted integration tests connection={{ ansible_connection }}"
-
-- name: Enable lacp feature
-  nxos_feature:
-    feature: lacp
-
-- set_fact:
-    mac: "lacp system-mac 00c1.4c00.bd15 role primary"
-  when: platform is search('N9K') and imagetag is not search('I[2-6]')
-
-- block:
-  - name: Setup
-    cli_config:
-      config: lacp system-priority 11
-
-  - name: Setup
-    cli_config:
-      config: "{{ mac|default(omit) }}"
-
-  - name: Gather lacp facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: lacp
-
-  - name: deleted
-    nxos_lacp: &deleted
-      state: deleted
-    register: result
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lacp == result.before"
-        - "'no lacp system-priority' in result.commands"
-        - "result.changed == true"
-        - "result.commands|length == 1"
-    when: platform is not search('N9K')
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lacp == result.before"
-        - "'no lacp system-priority' in result.commands"
-        - "'no lacp system-mac' in result.commands"
-        - "result.changed == true"
-        - "result.commands|length == 2"
-    when: platform is search('N9K') and imagetag is not search('I[2-6]')
-
-  - name: Gather lacp post facts
-    nxos_facts: *facts
-
-  - assert:
-      that:
-        - "result.after|length == 0"
-
-  - name: Idempotence - deleted
-    nxos_lacp: *deleted
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    nxos_feature:
-      feature: lacp
-      state: disabled
diff --git a/test/integration/targets/nxos_lacp/tests/cli/merged.yaml b/test/integration/targets/nxos_lacp/tests/cli/merged.yaml
deleted file mode 100644
index 45a5bed1db..0000000000
--- a/test/integration/targets/nxos_lacp/tests/cli/merged.yaml
+++ /dev/null
@@ -1,66 +0,0 @@
----
-- debug:
-    msg: "Start nxos_lacp merged integration tests connection={{ ansible_connection }}"
-
-- name: Enable lacp
-  nxos_feature:
-    feature: lacp
-
-- set_fact:
-    mac:
-      address: 00c1.4c00.bd15
-      role: primary
-  when: platform is search('N9K') and imagetag is not search('I[2-6]')
-
-- block:
-  - name: Merged
-    nxos_lacp: &merged
-      config:
-        system:
-          priority: 11
-          mac: "{{ mac|default(omit) }}"
-      state: merged
-    register: result
-
-  - assert:
-      that:
-        - "result.before|length == 0"
-        - "result.changed == true"
-        - "'lacp system-priority 11' in result.commands"
-        - "'lacp system-mac 00c1.4c00.bd15 role primary' in result.commands"
-        - "result.commands|length == 2"
-    when: platform is search('N9K') and imagetag is not search('I[2-6]')
-
-  - assert:
-      that:
-        - "result.before|length == 0"
-        - "result.changed == true"
-        - "'lacp system-priority 11' in result.commands"
-        - "result.commands|length == 1"
-    when: platform is not search('N9K')
-
-  - name: Gather lacp facts
-    nxos_facts:
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: lacp
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lacp == result.after"
-
-  - name: Idempotence - Merged
-    nxos_lacp: *merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    nxos_feature:
-      feature: lacp
-      state: disabled
diff --git a/test/integration/targets/nxos_lacp/tests/cli/replaced.yaml b/test/integration/targets/nxos_lacp/tests/cli/replaced.yaml
deleted file mode 100644
index 7b367a7958..0000000000
--- a/test/integration/targets/nxos_lacp/tests/cli/replaced.yaml
+++ /dev/null
@@ -1,104 +0,0 @@
----
-
-- debug:
-    msg: "Start nxos_lacp replaced integration tests connection={{ ansible_connection }}"
-
-- name: Enable lacp feature
-  nxos_feature:
-    feature: lacp
-
-- set_fact:
-    mac1: "lacp system-mac 00c1.4c00.bd20 role primary"
-  when: platform is search('N9K') and imagetag is not search('I[2-6]')
-
-- set_fact:
-    mac2:
-      address: 00c1.4c00.bd15
-      role: secondary
-  when: platform is search('N9K') and imagetag is not search('I[2-6]')
-
-- block:
-  - name: Setup1
-    cli_config:
-      config: lacp system-priority 11
-
-  - name: Setup2
-    cli_config:
-      config: "{{ mac1|default(omit) }}"
-
-  - name: Gather lacp facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: lacp
-
-  - name: Replaced
-    nxos_lacp: &replaced
-      config:
-        system:
-          priority: 12
-          mac: "{{ mac2|default(omit) }}"
-      state: replaced
-    register: result
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lacp == result.before"
-        - "result.changed == true"
-        - "result.commands|length == 2"
-        - "'no lacp system-priority' in result.commands"
-        - "'lacp system-priority 12' in result.commands"
-    when: platform is not search('N9K')
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lacp == result.before"
-        - "result.changed == true"
-        - "'no lacp system-priority' in result.commands"
-        - "'no lacp system-mac' in result.commands"
-        - "'lacp system-priority 12' in result.commands"
-        - "'lacp system-mac 00c1.4c00.bd15 role secondary' in result.commands"
-        - "result.commands|length == 4"
-    when: platform is search('N9K') and imagetag is not search('I[2-6]')
-
-  - name: Gather lacp interfaces post facts
-    nxos_facts: *facts
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lacp == result.after"
-    when: platform is search('N9K') and imagetag is not search('I[2-6]')
-
-  - name: Idempotence - Replaced
-    nxos_lacp: *replaced
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  - name: Setup3
-    cli_config:
-      config: "{{ mac1|default(omit) }}"
-
-  - name: Replaced
-    nxos_lacp:
-      state: replaced
-    register: result
-    when: platform is search('N9K') and imagetag is not search('I[2-6]')
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "result.commands|length == 2"
-        - "'no lacp system-mac' in result.commands"
-        - "'no lacp system-priority' in result.commands"
-    when: platform is search('N9K') and imagetag is not search('I[2-6]')
-
-  always:
-  - name: teardown
-    nxos_feature:
-      feature: lacp
-      state: disabled
diff --git a/test/integration/targets/nxos_lacp_interfaces/defaults/main.yaml b/test/integration/targets/nxos_lacp_interfaces/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_lacp_interfaces/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_lacp_interfaces/meta/main.yml b/test/integration/targets/nxos_lacp_interfaces/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_lacp_interfaces/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_lacp_interfaces/tasks/cli.yaml b/test/integration/targets/nxos_lacp_interfaces/tasks/cli.yaml
deleted file mode 100644
index 6c7ea4a7f9..0000000000
--- a/test/integration/targets/nxos_lacp_interfaces/tasks/cli.yaml
+++ /dev/null
@@ -1,20 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_lacp_interfaces/tasks/main.yaml b/test/integration/targets/nxos_lacp_interfaces/tasks/main.yaml
deleted file mode 100644
index 415c99d8b1..0000000000
--- a/test/integration/targets/nxos_lacp_interfaces/tasks/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
diff --git a/test/integration/targets/nxos_lacp_interfaces/tasks/nxapi.yaml b/test/integration/targets/nxos_lacp_interfaces/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_lacp_interfaces/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_lacp_interfaces/tests/cli/deleted.yaml b/test/integration/targets/nxos_lacp_interfaces/tests/cli/deleted.yaml
deleted file mode 100644
index 51cc33a31e..0000000000
--- a/test/integration/targets/nxos_lacp_interfaces/tests/cli/deleted.yaml
+++ /dev/null
@@ -1,79 +0,0 @@
----
-- debug:
-    msg: "Start nxos_lacp_interfaces deleted integration tests connection={{ ansible_connection }}"
-
-#
-# "lacp mode delay" is not supported on Nexus 9500 series switches.
-# Three models of Nexus 9500 switches have chassis types C9504, C9508 and C9516.
-#
-
-- set_fact:
-    mode: delay
-  when: platform is not search('N3K|N5K|N6K|N7K') and imagetag is not search('A8|I2') and
-    image_version is not search ('9.2') and chassis_type is not search('C95')
-
-- name: setup1
-  cli_config: &cleanup
-    config: |
-      no interface port-channel5
-      no interface port-channel10
-      no feature lacp
-
-- block:
-  - name: setup2
-    cli_config:
-      config: |
-        feature lacp
-        interface port-channel5
-          lacp min-links 5
-        interface port-channel10
-          lacp max-bundle 10
-
-  - name: setup3 - L2 for mode command
-    cli_config:
-      config: |
-        interface port-channel10
-          switchport
-          lacp mode delay
-    when: mode is defined
-
-  - name: Gather lacp_interfaces facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: lacp_interfaces
-
-  - name: deleted
-    nxos_lacp_interfaces: &deleted
-      state: deleted
-    register: result
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lacp_interfaces|symmetric_difference(result.before)|length == 0"
-        - "result.after|length == 0"
-        - "result.changed == true"
-        - "'interface port-channel5' in result.commands"
-        - "'no lacp min-links' in result.commands"
-        - "'interface port-channel10' in result.commands"
-        - "'no lacp max-bundle' in result.commands"
-
-  - assert:
-      that:
-        - "'no lacp mode delay' in result.commands"
-        - "result.commands|length == 5"
-    when: mode is defined
-
-  - name: Idempotence - deleted
-    nxos_lacp_interfaces: *deleted
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *cleanup
diff --git a/test/integration/targets/nxos_lacp_interfaces/tests/cli/merged.yaml b/test/integration/targets/nxos_lacp_interfaces/tests/cli/merged.yaml
deleted file mode 100644
index 0d3562fd02..0000000000
--- a/test/integration/targets/nxos_lacp_interfaces/tests/cli/merged.yaml
+++ /dev/null
@@ -1,85 +0,0 @@
----
-- debug:
-    msg: "Start nxos_lacp_interfaces merged integration tests connection={{ ansible_connection }}"
-
-#
-# "lacp mode delay" is not supported on Nexus 9500 series switches.
-# Three models of Nexus 9500 switches have chassis types C9504, C9508 and C9516.
-#
-
-- set_fact:
-    mode: delay
-  when: platform is not search('N3K|N5K|N6K|N7K') and imagetag is not search('A8|I2') and
-    image_version is not search ('9.2') and chassis_type is not search('C95')
-
-- name: setup1
-  cli_config: &cleanup
-    config: |
-      no interface port-channel5
-      no interface port-channel10
-      no feature lacp
-
-- block:
-  - name: setup2
-    cli_config:
-      config: |
-        feature lacp
-
-  - name: setup3 - L2 for mode command
-    cli_config:
-      config: |
-        interface port-channel5
-          switchport
-    when: mode is defined
-
-  - name: Merged
-    nxos_lacp_interfaces: &merged
-      config:
-        - name: port-channel10
-          links:
-            min: 5
-        - name: port-channel5
-          mode: "{{ mode | default(omit) }}"
-          links:
-            max: 10
-      state:  merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "result.before|length == 0"
-        - "'interface port-channel10' in result.commands"
-        - "'lacp min-links 5' in result.commands"
-        - "'interface port-channel5' in result.commands"
-        - "'lacp max-bundle 10' in result.commands"
-
-  - assert:
-      that:
-        - "'lacp mode delay' in result.commands"
-        - "result.commands|length == 5"
-    when: mode is defined
-
-  - name: Gather lacp_interfaces facts
-    nxos_facts:
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: lacp_interfaces
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lacp_interfaces|symmetric_difference(result.after)|length == 0"
-
-  - name: Idempotence - Merged
-    nxos_lacp_interfaces: *merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *cleanup
diff --git a/test/integration/targets/nxos_lacp_interfaces/tests/cli/overridden.yaml b/test/integration/targets/nxos_lacp_interfaces/tests/cli/overridden.yaml
deleted file mode 100644
index 27bdbaa175..0000000000
--- a/test/integration/targets/nxos_lacp_interfaces/tests/cli/overridden.yaml
+++ /dev/null
@@ -1,91 +0,0 @@
----
-- debug:
-    msg: "Start nxos_lacp_interfaces overridden integration tests connection={{ ansible_connection }}"
-
-#
-# "lacp mode delay" is not supported on Nexus 9500 series switches.
-# Three models of Nexus 9500 switches have chassis types C9504, C9508 and C9516.
-#
-
-- set_fact:
-    mode: delay
-  when: platform is not search('N3K|N5K|N6K|N7K') and imagetag is not search('A8|I2') and
-    image_version is not search ('9.2') and chassis_type is not search('C95')
-
-- name: setup1
-  cli_config: &cleanup
-    config: |
-      no interface port-channel5
-      no interface port-channel10
-      no interface port-channel11
-      no feature lacp
-
-- block:
-  - name: setup2
-    cli_config:
-      config: |
-        feature lacp
-        interface port-channel10
-          lacp min-links 5
-        interface port-channel5
-          lacp max-bundle 10
-
-  - name: setup3 - L2 for mode command
-    cli_config:
-      config: |
-        interface port-channel11
-          switchport
-    when: mode is defined
-
-  - name: Gather lacp_interfaces facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: lacp_interfaces
-
-  - name: Overridden
-    nxos_lacp_interfaces: &overridden
-      config:
-        - name: port-channel11
-          links:
-            min: 4
-          mode: "{{ mode | default(omit) }}"
-      state: overridden
-    register: result
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lacp_interfaces|symmetric_difference(result.before)|length == 0"
-        - "result.changed == true"
-        - "'interface port-channel10' in result.commands"
-        - "'no lacp min-links' in result.commands"
-        - "'interface port-channel5' in result.commands"
-        - "'no lacp max-bundle' in result.commands"
-        - "'interface port-channel11' in result.commands"
-
-  - assert:
-      that:
-        - "'lacp mode delay' in result.commands"
-        - "result.commands|length == 7"
-    when: mode is defined
-
-  - name: Gather lacp_interfaces post facts
-    nxos_facts: *facts
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lacp_interfaces|symmetric_difference(result.after)|length == 0"
-
-  - name: Idempotence - Overridden
-    nxos_lacp_interfaces: *overridden
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *cleanup
diff --git a/test/integration/targets/nxos_lacp_interfaces/tests/cli/replaced.yaml b/test/integration/targets/nxos_lacp_interfaces/tests/cli/replaced.yaml
deleted file mode 100644
index ca15ef7c4a..0000000000
--- a/test/integration/targets/nxos_lacp_interfaces/tests/cli/replaced.yaml
+++ /dev/null
@@ -1,79 +0,0 @@
----
-- debug:
-    msg: "Start nxos_lacp_interfaces replaced integration tests connection={{ ansible_connection }}"
-
-#
-# "lacp mode delay" is not supported on Nexus 9500 series switches.
-# Three models of Nexus 9500 switches have chassis types C9504, C9508 and C9516.
-#
-
-- set_fact:
-    mode: delay
-  when: platform is not search('N3K|N5K|N6K|N7K') and imagetag is not search('A8|I2') and
-    image_version is not search ('9.2') and chassis_type is not search('C95')
-
-- name: setup1
-  cli_config: &cleanup
-    config: |
-      no interface port-channel10
-      no feature lacp
-
-- block:
-  - name: setup2
-    cli_config:
-      config: |
-        feature lacp
-        interface port-channel10
-          switchport
-          lacp min-links 5
-
-  - name: Gather lacp_interfaces facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: lacp_interfaces
-
-  - name: Replaced
-    nxos_lacp_interfaces: &replaced
-      config:
-        - name: port-channel10
-          links:
-            max: 10
-          mode: "{{ mode | default(omit) }}"
-      state: replaced
-    register: result
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lacp_interfaces|symmetric_difference(result.before)|length == 0"
-        - "result.changed == true"
-        - "'interface port-channel10' in result.commands"
-        - "'no lacp min-links' in result.commands"
-        - "'lacp max-bundle 10' in result.commands"
-
-  - assert:
-      that:
-        - "'lacp mode delay' in result.commands"
-        - "result.commands|length == 4"
-    when: mode is defined
-
-  - name: Gather lacp_interfaces post facts
-    nxos_facts: *facts
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lacp_interfaces|symmetric_difference(result.after)|length == 0"
-
-  - name: Idempotence - Replaced
-    nxos_lacp_interfaces: *replaced
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *cleanup
diff --git a/test/integration/targets/nxos_lag_interfaces/defaults/main.yaml b/test/integration/targets/nxos_lag_interfaces/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_lag_interfaces/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_lag_interfaces/meta/main.yml b/test/integration/targets/nxos_lag_interfaces/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_lag_interfaces/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_lag_interfaces/tasks/cli.yaml b/test/integration/targets/nxos_lag_interfaces/tasks/cli.yaml
deleted file mode 100644
index 76743023ce..0000000000
--- a/test/integration/targets/nxos_lag_interfaces/tasks/cli.yaml
+++ /dev/null
@@ -1,20 +0,0 @@
----
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_lag_interfaces/tasks/main.yaml b/test/integration/targets/nxos_lag_interfaces/tasks/main.yaml
deleted file mode 100644
index 415c99d8b1..0000000000
--- a/test/integration/targets/nxos_lag_interfaces/tasks/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
diff --git a/test/integration/targets/nxos_lag_interfaces/tests/cli/deleted.yaml b/test/integration/targets/nxos_lag_interfaces/tests/cli/deleted.yaml
deleted file mode 100644
index 265e5184bf..0000000000
--- a/test/integration/targets/nxos_lag_interfaces/tests/cli/deleted.yaml
+++ /dev/null
@@ -1,66 +0,0 @@
----
-- debug:
-    msg: "Start nxos_lag_interfaces deleted integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact: test_int2="{{ nxos_int2 }}"
-
-- name: enable feature lacp
-  nxos_feature:
-    feature: lacp
-
-- name: Setup1
-  nxos_lag_interfaces: &remove_lags
-    state: deleted
-
-- block:
-  - name: Setup2
-    nxos_config:
-      lines:
-        - "channel-group 10"
-      parents: "{{ item }}"
-    loop:
-      - "interface {{ test_int1 }}"
-      - "interface {{ test_int2 }}"
-
-  - name: Gather LAG interfaces facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: lag_interfaces
-
-  - name: deleted
-    nxos_lag_interfaces: &deleted
-      state: deleted
-    register: result
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lag_interfaces|symmetric_difference(result.before)|length == 0"
-
-  - name: Gather LAG interfaces post facts
-    nxos_facts: *facts
-
-  - assert:
-      that:
-        - "result.after|length == 0"
-        - "result.changed == true"
-
-  - name: Idempotence - deleted
-    nxos_lag_interfaces: *deleted
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-
-  always:
-  - name: Teardown
-    nxos_lag_interfaces: *remove_lags
-    ignore_errors: yes
-
-  - name: disable feature lacp
-    nxos_feature:
-      feature: lacp
-      state: disabled
diff --git a/test/integration/targets/nxos_lag_interfaces/tests/cli/merged.yaml b/test/integration/targets/nxos_lag_interfaces/tests/cli/merged.yaml
deleted file mode 100644
index 49af104674..0000000000
--- a/test/integration/targets/nxos_lag_interfaces/tests/cli/merged.yaml
+++ /dev/null
@@ -1,66 +0,0 @@
----
-- debug:
-    msg: "Start nxos_lag_interfaces merged integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact: test_int2="{{ nxos_int2 }}"
-
-- name: Enable feature lacp
-  nxos_feature:
-    feature: lacp
-
-- name: Setup
-  nxos_config:
-    lines:
-      - no interface port-channel 10
-  ignore_errors: yes
-
-- name: setup2
-  nxos_lag_interfaces: &remove_lags
-    state: deleted
-
-- block:
-  - name: Merged
-    nxos_lag_interfaces: &merged
-      config:
-        - name: port-channel10
-          members:
-            - member: "{{ test_int1 }}"
-            - member: "{{ test_int2 }}"
-              mode: yes
-      state: merged
-    register: result
-
-  - assert:
-      that:
-        - "result.before|length == 0"
-        - "result.changed == true"
-
-  - name: Gather LAG interfaces facts
-    nxos_facts:
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: lag_interfaces
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lag_interfaces|symmetric_difference(result.after)|length == 0"
-
-  - name: Idempotence - Merged
-    nxos_lag_interfaces: *merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-
-  always:
-  - name: Teardown
-    nxos_lag_interfaces: *remove_lags
-    ignore_errors: yes
-
-  - name: Disable feature lacp
-    nxos_feature:
-      feature: lacp
-      state: disabled
diff --git a/test/integration/targets/nxos_lag_interfaces/tests/cli/overridden.yaml b/test/integration/targets/nxos_lag_interfaces/tests/cli/overridden.yaml
deleted file mode 100644
index f8aa1ca8c4..0000000000
--- a/test/integration/targets/nxos_lag_interfaces/tests/cli/overridden.yaml
+++ /dev/null
@@ -1,78 +0,0 @@
----
-- debug:
-    msg: "Start nxos_lag_interfaces overridden integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact: test_int2="{{ nxos_int2 }}"
-- set_fact: test_int3="{{ nxos_int3 }}"
-
-- name: enable feature lacp
-  nxos_feature:
-    feature: lacp
-
-- name: setup1
-  nxos_config:
-    lines:
-      - no interface port-channel 10
-      - no interface port-channel 19
-  ignore_errors: yes
-
-- name: setup2
-  nxos_lag_interfaces: &remove_lags
-    state: deleted
-
-- block:
-  - name: setup3
-    nxos_config:
-      lines:
-        - "channel-group 10"
-      parents: "{{ item }}"
-    ignore_errors: yes
-    loop:
-      - "interface {{ test_int1 }}"
-      - "interface {{ test_int2 }}"
-
-  - name: Gather LAG interfaces facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: lag_interfaces
-
-  - name: Overridden
-    nxos_lag_interfaces: &overridden
-      config:
-        - name: port-channel19
-          members:
-            - member: "{{ test_int3 }}"
-      state: overridden
-    register: result
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lag_interfaces|symmetric_difference(result.before)|length == 0"
-        - "result.changed == true"
-
-  - name: Gather LAG interfaces post facts
-    nxos_facts: *facts
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lag_interfaces|symmetric_difference(result.after)|length == 0"
-
-  - name: Idempotence - Overridden
-    nxos_lag_interfaces: *overridden
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-  always:
-  - name: Teardown
-    nxos_lag_interfaces: *remove_lags
-    ignore_errors: yes
-
-  - name: disable feature lacp
-    nxos_feature:
-      feature: lacp
-      state: disabled
diff --git a/test/integration/targets/nxos_lag_interfaces/tests/cli/replaced.yaml b/test/integration/targets/nxos_lag_interfaces/tests/cli/replaced.yaml
deleted file mode 100644
index 51032d9fb9..0000000000
--- a/test/integration/targets/nxos_lag_interfaces/tests/cli/replaced.yaml
+++ /dev/null
@@ -1,78 +0,0 @@
----
-- debug:
-    msg: "Start nxos_lag_interfaces replaced integration tests connection={{ ansible_connection }}"
-
-- set_fact: test_int1="{{ nxos_int1 }}"
-- set_fact: test_int2="{{ nxos_int2 }}"
-
-- name: enable feature lacp
-  nxos_feature:
-    feature: lacp
-
-- name: setup1
-  nxos_config:
-    lines:
-      - no interface port-channel 10
-      - no interface port-channel 11
-  ignore_errors: yes
-
-- name: setup2
-  nxos_lag_interfaces: &remove_lags
-    state: deleted
-
-- block:
-  - name: setup3
-    nxos_config:
-      lines:
-        - "channel-group 10"
-      parents: "{{ item }}"
-    ignore_errors: yes
-    loop:
-      - "interface {{ test_int1 }}"
-      - "interface {{ test_int2 }}"
-
-  - name: Gather LAG interfaces facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: lag_interfaces
-
-  - name: Replaced
-    nxos_lag_interfaces: &replaced
-      config:
-        - name: port-channel11
-          members:
-            - member: "{{ test_int2 }}"
-              mode: active
-      state: replaced
-    register: result
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lag_interfaces|symmetric_difference(result.before)|length == 0"
-
-  - name: Gather LAG interfaces post facts
-    nxos_facts: *facts
-
-  - assert:
-      that:
-        - "ansible_facts.network_resources.lag_interfaces|symmetric_difference(result.after)|length == 0"
-
-  - name: Idempotence - Replaced
-    nxos_lag_interfaces: *replaced
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-
-  always:
-  - name: teardown1
-    nxos_lag_interfaces: *remove_lags
-    ignore_errors: yes
-
-  - name: disable feature lacp
-    nxos_feature:
-      feature: lacp
-      state: disabled
diff --git a/test/integration/targets/nxos_linkagg/defaults/main.yaml b/test/integration/targets/nxos_linkagg/defaults/main.yaml
deleted file mode 100644
index 9ef5ba5165..0000000000
--- a/test/integration/targets/nxos_linkagg/defaults/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-testcase: "*"
-test_items: []
diff --git a/test/integration/targets/nxos_linkagg/meta/main.yml b/test/integration/targets/nxos_linkagg/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_linkagg/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_linkagg/tasks/cli.yaml b/test/integration/targets/nxos_linkagg/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_linkagg/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_linkagg/tasks/main.yaml b/test/integration/targets/nxos_linkagg/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_linkagg/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_linkagg/tasks/nxapi.yaml b/test/integration/targets/nxos_linkagg/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_linkagg/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_linkagg/tests/common/sanity.yaml b/test/integration/targets/nxos_linkagg/tests/common/sanity.yaml
deleted file mode 100644
index a25c705719..0000000000
--- a/test/integration/targets/nxos_linkagg/tests/common/sanity.yaml
+++ /dev/null
@@ -1,190 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_linkagg sanity test"
-
-- set_fact: testint1="{{ nxos_int1 }}"
-- set_fact: testint2="{{ nxos_int2 }}"
-
-- name: "Enable feature LACP"
-  nxos_feature:
-    feature: lacp
-    state: enabled
-  ignore_errors: yes
-
-- name: setup - remove config used in test(part1)
-  nxos_config:
-    lines:
-      - no interface port-channel 20
-      - no interface port-channel 100
-
-- name: setup - remove config used in test(part2)
-  nxos_config:
-    lines:
-      - no channel-group 20
-    parents: "{{ item }}"
-  ignore_errors: yes
-  loop:
-    - "interface {{ testint1 }}"
-    - "interface {{ testint2 }}"
-
-- name: Put interface in L2 mode
-  nxos_interface:
-    aggregate:
-    - { name: "{{testint1}}" }
-    - { name: "{{testint2}}" }
-    mode: layer2
-  when: platform is match("N35")
-
-- name: create linkagg
-  nxos_linkagg: &create
-    group: 20
-    state: present
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"interface port-channel 20" in result.commands'
-
-- name: create linkagg(Idempotence)
-  nxos_linkagg: *create
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- name: set link aggregation group to members declaratively
-  nxos_linkagg: &configure_member
-    group: 20
-    mode: active
-    force: True
-    members:
-      - "{{ testint1 }}"
-      - "{{ testint2 }}"
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"interface {{ testint1 }}" in result.commands'
-      - '"channel-group 20 force mode active" in result.commands'
-      - '"interface {{ testint2 }}" in result.commands'
-      - '"channel-group 20 force mode active" in result.commands'
-
-- name: set link aggregation group to members(Idempotence)
-  nxos_linkagg: *configure_member
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- name: remove link aggregation group from member declaratively
-  nxos_linkagg: &remove_member
-    group: 20
-    mode: active
-    force: True
-    members:
-      - "{{ testint2 }}"
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"interface {{ testint1 }}" in result.commands'
-      - '"no channel-group 20" in result.commands'
-
-- name: remove link aggregation group from member(Idempotence)
-  nxos_linkagg: *remove_member
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- name: remove linkagg
-  nxos_linkagg: &remove
-    group: 20
-    state: absent
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"no interface port-channel 20" in result.commands'
-
-- name: remove linkagg(Idempotence)
-  nxos_linkagg: *remove
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- name: create aggregate of linkagg definitions
-  nxos_linkagg: &create_agg
-    aggregate:
-      - { group: 20, min_links: 3 }
-      - { group: 100, min_links: 4 }
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"interface port-channel 20" in result.commands'
-      - '"lacp min-links 3" in result.commands'
-      - '"interface port-channel 100" in result.commands'
-      - '"lacp min-links 4" in result.commands'
-
-- name: create aggregate of linkagg definitions(Idempotence)
-  nxos_linkagg: *create_agg
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- name: remove aggregate of linkagg definitions
-  nxos_linkagg: &remove_agg
-    aggregate:
-      - { group: 20, min_links: 3 }
-      - { group: 100, min_links: 4 }
-    state: absent
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"no interface port-channel 20" in result.commands'
-      - '"no interface port-channel 100" in result.commands'
-
-- name: remove aggregate of linkagg definitions(Idempotence)
-  nxos_linkagg: *remove_agg
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
- 
-- name: teardown - remove config used in test(part1)
-  nxos_config:
-    lines:
-      - no interface port-channel 20
-      - no interface port-channel 100
-
-- name: teardown - remove config used in test(part2)
-  nxos_config:
-    lines:
-      - no channel-group 20
-    parents: "{{ item }}"
-  ignore_errors: yes
-  loop:
-    - "interface {{ testint1 }}"
-    - "interface {{ testint2 }}"
-
-- name: "Disable feature LACP"
-  nxos_feature:
-    feature: lacp
-    state: disabled
-
-- debug: msg="END connection={{ ansible_connection }} nxos_linkagg sanity test"
diff --git a/test/integration/targets/nxos_lldp/defaults/main.yaml b/test/integration/targets/nxos_lldp/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_lldp/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_lldp/meta/main.yml b/test/integration/targets/nxos_lldp/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_lldp/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_lldp/tasks/cli.yaml b/test/integration/targets/nxos_lldp/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_lldp/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_lldp/tasks/main.yaml b/test/integration/targets/nxos_lldp/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_lldp/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_lldp/tasks/nxapi.yaml b/test/integration/targets/nxos_lldp/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_lldp/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_lldp/tests/cli/sanity.yaml b/test/integration/targets/nxos_lldp/tests/cli/sanity.yaml
deleted file mode 100644
index 5871928c52..0000000000
--- a/test/integration/targets/nxos_lldp/tests/cli/sanity.yaml
+++ /dev/null
@@ -1,47 +0,0 @@
----
-- debug: msg="START TRANSPORT:CLI nxos_lldp sanity test"
-
-- name: Make sure LLDP is not running before tests
-  nxos_feature:
-    feature: lldp
-    state: disabled
-
-- name: Enable LLDP service
-  nxos_lldp:
-    state: present
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"feature lldp" in result.commands'
-
-- name: Enable LLDP service again (idempotent)
-  nxos_lldp:
-    state: present
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- name: Disable LLDP service
-  nxos_lldp:
-    state: absent
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"no feature lldp" in result.commands'
-
-- name: Disable LLDP service (idempotent)
-  nxos_lldp:
-    state: absent
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- debug: msg="END TRANSPORT:CLI nxos_lldp sanity test"
diff --git a/test/integration/targets/nxos_lldp/tests/nxapi/sanity.yaml b/test/integration/targets/nxos_lldp/tests/nxapi/sanity.yaml
deleted file mode 100644
index d8abc1caa8..0000000000
--- a/test/integration/targets/nxos_lldp/tests/nxapi/sanity.yaml
+++ /dev/null
@@ -1,47 +0,0 @@
----
-- debug: msg="START TRANSPORT:NXAPI nxos_lldp sanity test"
-
-- name: Make sure LLDP is not running before tests
-  nxos_feature:
-    feature: lldp
-    state: disabled
-
-- name: Enable LLDP service
-  nxos_lldp:
-    state: present
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"feature lldp" in result.commands'
-
-- name: Enable LLDP service again (idempotent)
-  nxos_lldp:
-    state: present
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- name: Disable LLDP service
-  nxos_lldp:
-    state: absent
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"no feature lldp" in result.commands'
-
-- name: Disable LLDP service (idempotent)
-  nxos_lldp:
-    state: absent
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- debug: msg="END TRANSPORT:NXAPI nxos_lldp sanity test"
diff --git a/test/integration/targets/nxos_lldp_global/defaults/main.yaml b/test/integration/targets/nxos_lldp_global/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_lldp_global/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_lldp_global/meta/main.yml b/test/integration/targets/nxos_lldp_global/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_lldp_global/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_lldp_global/tasks/cli.yaml b/test/integration/targets/nxos_lldp_global/tasks/cli.yaml
deleted file mode 100644
index f1c20c1b78..0000000000
--- a/test/integration/targets/nxos_lldp_global/tasks/cli.yaml
+++ /dev/null
@@ -1,20 +0,0 @@
----
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yml"
-  connection: local
-  register: test_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_lldp_global/tasks/main.yaml b/test/integration/targets/nxos_lldp_global/tasks/main.yaml
deleted file mode 100644
index 415c99d8b1..0000000000
--- a/test/integration/targets/nxos_lldp_global/tasks/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
diff --git a/test/integration/targets/nxos_lldp_global/tests/cli/deleted.yml b/test/integration/targets/nxos_lldp_global/tests/cli/deleted.yml
deleted file mode 100644
index 76be479a47..0000000000
--- a/test/integration/targets/nxos_lldp_global/tests/cli/deleted.yml
+++ /dev/null
@@ -1,83 +0,0 @@
----
-  - debug:
-      msg: "Start nxos_lldp_global deleted integration tests connection = {{ ansible_connection }}"
-
-  # N35 skips all tests, image issues.
-  - block:
-    - set_fact: cfg_port_id=True
-      when: platform is not search('N[567]K') and imagetag is not search("I[2345]")
-
-    - name: feature off to cleanup lldp
-      nxos_feature: &feature_off
-        feature: lldp
-        state: disabled
-
-    - name: Enable LLDP feature
-      nxos_feature:
-        feature: lldp
-        state: enabled
-
-    - name: Setup
-      cli_config:
-        config: |
-          lldp holdtime 125
-          lldp timer 32
-          no lldp tlv-select dcbxp
-          lldp tlv-select system-name
-          no lldp tlv-select system-description
-
-    - name: Setup2
-      cli_config:
-        config: |
-          lldp portid-subtype 1
-          no lldp tlv-select power-management
-      when: cfg_port_id is defined
-
-    - name: Gather lldp_global facts
-      nxos_facts: &facts
-        gather_subset:
-          - '!all'
-          - '!min'
-        gather_network_resources: lldp_global
-
-    - name: Deleted
-      nxos_lldp_global: &deleted
-        state: deleted
-      register: result
-
-    - assert:
-        that:
-          - "ansible_facts.network_resources.lldp_global == result.before"
-          - "'no lldp holdtime 125' in result.commands"
-          - "'no lldp timer 32' in result.commands"
-          - "'lldp tlv-select dcbxp' in result.commands"
-          - "'lldp tlv-select system-description' in result.commands"
-          - "result.changed == true "
-          - "result.after | length == 0"
-
-    - assert:
-        that:
-          - "'no lldp portid-subtype 1' in result.commands"
-          - "'lldp tlv-select power-management' in result.commands"
-      when: cfg_port_id is defined
-
-    - name: Gather lldp_global post facts
-      nxos_facts: *facts
-
-    - assert:
-        that:
-          - "ansible_facts.network_resources == {} "
-
-    - name: Idempotence - deleted
-      nxos_lldp_global: *deleted
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-          - "result.commands|length == 0"
-    always:
-      - name: teardown
-        nxos_feature: *feature_off
-
-    when: platform is not search('N35')
diff --git a/test/integration/targets/nxos_lldp_global/tests/cli/merged.yml b/test/integration/targets/nxos_lldp_global/tests/cli/merged.yml
deleted file mode 100644
index fce877e4b1..0000000000
--- a/test/integration/targets/nxos_lldp_global/tests/cli/merged.yml
+++ /dev/null
@@ -1,72 +0,0 @@
----
-  - debug:
-      msg: "Start nxos_lldp_global merged integration tests connection={{ansible_connection}}"
-
-  # N35 skips all tests, image issues.
-  - block:
-    - set_fact:
-        port_id: 1
-        tlv_power_mgmt:
-          power_management: false
-      when: platform is not search('N5K|N6K|N7K') and imagetag is not search("I[2345]")
-
-    - name: feature off to cleanup lldp
-      nxos_feature: &feature_off
-        feature: lldp
-        state: disabled
-
-    - name: Enable lldp
-      nxos_feature:
-        feature: lldp
-
-    - name: Merged
-      nxos_lldp_global: &merged
-        config:
-          reinit: 5
-          timer: 40
-          port_id: "{{port_id|default(omit)}}"
-          tlv_select: "{{tlv_power_mgmt|default(omit)}}"
-        state: merged
-      register: result
-
-    - assert:
-        that:
-          - "result.before|length == 0"
-          - "result.changed == true"
-          - "'lldp reinit 5' in result.commands"
-          - "'lldp timer 40' in result.commands"
-
-    - assert:
-        that:
-          - "'lldp portid-subtype 1' in result.commands"
-      when: port_id is defined
-
-    - assert:
-        that:
-          - "'no lldp tlv-select power-management' in result.commands"
-      when: tlv_power_mgmt is defined
-
-    - name: Gather lldp_global facts
-      nxos_facts:
-        gather_subset:
-          - '!all'
-          - '!min'
-        gather_network_resources: lldp_global
-
-    - assert:
-        that:
-          - "ansible_facts.network_resources.lldp_global == result.after"
-
-    - name: Idempotence - Merged
-      nxos_lldp_global: *merged
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-          - "result.commands | length == 0"
-    always:
-    - name: teardown
-      nxos_feature: *feature_off
-
-    when: platform is not search('N35')
diff --git a/test/integration/targets/nxos_lldp_global/tests/cli/replaced.yml b/test/integration/targets/nxos_lldp_global/tests/cli/replaced.yml
deleted file mode 100644
index 56cf9f6693..0000000000
--- a/test/integration/targets/nxos_lldp_global/tests/cli/replaced.yml
+++ /dev/null
@@ -1,93 +0,0 @@
----
-  - debug:
-      msg: "Start nxos_lldp_global replaced integration tests connection = {{ansible_connection}}"
-
-  # N35 skips all tests, image issues.
-  - block:
-    - set_fact:
-        port_id: 1
-        tlv_power_mgmt:
-          power_management: false
-      when: platform is not search('N[567]K') and imagetag is not search("I[2345]")
-
-    - name: feature off to cleanup lldp
-      nxos_feature: &feature_off
-        feature: lldp
-        state: disabled
-
-    - name: Enable lldp feature
-      nxos_feature:
-        feature: lldp
-        state: enabled
-
-    - name: Setup
-      cli_config:
-        config: |
-          lldp holdtime 125
-          lldp tlv-select system-name
-          no lldp tlv-select port-vlan
-
-    - name: Setup2
-      cli_config:
-        config: |
-          lldp portid-subtype 1
-          no lldp tlv-select power-management
-      when: port_id is defined
-
-    - name: Replaced
-      nxos_lldp_global: &replaced
-        config:
-          holdtime: 125
-          timer: 35
-          tlv_select:
-            system:
-               name: false
-               description: false
-            port:
-              vlan: false
-            dcbxp: false
-        state: replaced
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == true"
-          - "'lldp timer 35' in result.commands"
-          - "'no lldp tlv-select system-name' in result.commands"
-          - "'no lldp tlv-select system-description' in result.commands"
-          - "'no lldp tlv-select dcbxp' in result.commands"
-
-    - assert:
-        that:
-          - "'no lldp portid-subtype 1' in result.commands"
-      when: port_id is defined
-
-    - assert:
-        that:
-          - "'lldp tlv-select power-management' in result.commands"
-      when: tlv_power_mgmt is defined
-
-    - name: Gather lldp_global post facts
-      nxos_facts:
-        gather_subset:
-          - '!all'
-          - '!min'
-        gather_network_resources: lldp_global
-
-    - assert:
-        that:
-          - "ansible_facts.network_resources.lldp_global == result.after"
-
-    - name: Idempotence - Replaced
-      nxos_lldp_global: *replaced
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-          - "result.commands|length == 0"
-    always:
-    - name: teardown
-      nxos_feature: *feature_off
-
-    when: platform is not search('N35')
diff --git a/test/integration/targets/nxos_lldp_interfaces/defaults/main.yaml b/test/integration/targets/nxos_lldp_interfaces/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_lldp_interfaces/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_lldp_interfaces/meta/main.yml b/test/integration/targets/nxos_lldp_interfaces/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_lldp_interfaces/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_lldp_interfaces/tasks/cli.yaml b/test/integration/targets/nxos_lldp_interfaces/tasks/cli.yaml
deleted file mode 100644
index b1d3f35f7b..0000000000
--- a/test/integration/targets/nxos_lldp_interfaces/tasks/cli.yaml
+++ /dev/null
@@ -1,20 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yml"
-  connection: local
-  register: test_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_lldp_interfaces/tasks/main.yaml b/test/integration/targets/nxos_lldp_interfaces/tasks/main.yaml
deleted file mode 100644
index 415c99d8b1..0000000000
--- a/test/integration/targets/nxos_lldp_interfaces/tasks/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
diff --git a/test/integration/targets/nxos_lldp_interfaces/tasks/nxapi.yaml b/test/integration/targets/nxos_lldp_interfaces/tasks/nxapi.yaml
deleted file mode 100644
index 04c99602e6..0000000000
--- a/test/integration/targets/nxos_lldp_interfaces/tasks/nxapi.yaml
+++ /dev/null
@@ -1,33 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
-
-- name: run test cases (connection=local)
-  include: "{{ test_case_to_run }} ansible_connection=local connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_lldp_interfaces/tests/cli/deleted.yml b/test/integration/targets/nxos_lldp_interfaces/tests/cli/deleted.yml
deleted file mode 100644
index 4fb88558bd..0000000000
--- a/test/integration/targets/nxos_lldp_interfaces/tests/cli/deleted.yml
+++ /dev/null
@@ -1,73 +0,0 @@
----
-- debug:
-    msg: "Start nxos_lldp_interfaces deleted integration tests connection = {{ ansible_connection }}"
-
-- name: Enable LLDP feature
-  nxos_feature:
-    feature: lldp
-    state: enabled
-
-- block:
-    - name: Setup
-      cli_config:
-        config: |
-          interface Ethernet1/1
-            lldp receive
-            no lldp transmit
-          interface Ethernet1/2
-            no lldp receive
-            lldp tlv-set vlan 12
-          interface Ethernet1/3
-            lldp tlv-set management-address 192.0.2.12
-
-    - name: Delete on single interface
-      nxos_lldp_interfaces:
-        config:
-          - name: Ethernet1/2
-        state: deleted
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == true"
-          - "'interface Ethernet1/2' in result.commands"
-          - "'lldp receive' in result.commands"
-          - "'no lldp tlv-set vlan 12' in result.commands"
-          - "result.commands | length == 3"
-
-    - name: Gather lldp_interfaces facts
-      nxos_facts: &facts
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources: lldp_interfaces
-
-    - name: Deleted
-      nxos_lldp_interfaces: &deleted
-        state: deleted
-      register: result
-
-    - assert:
-        that:
-          - "ansible_facts.network_resources.lldp_interfaces == result.before"
-          - "'interface Ethernet1/1' in result.commands"
-          - "'lldp transmit' in result.commands"
-          - "'interface Ethernet1/3' in result.commands"
-          - "'no lldp tlv-set management-address 192.0.2.12' in result.commands"
-          - "result.changed == true "
-          - "result.commands | length == 4"
-
-    - name: Idempotence - deleted
-      nxos_lldp_interfaces: *deleted
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-          - "result.commands|length == 0"
-
-  always:
-    - name: teardown
-      nxos_feature:
-        feature: lldp
-        state: disabled
diff --git a/test/integration/targets/nxos_lldp_interfaces/tests/cli/gathered.yml b/test/integration/targets/nxos_lldp_interfaces/tests/cli/gathered.yml
deleted file mode 100644
index 032084ead5..0000000000
--- a/test/integration/targets/nxos_lldp_interfaces/tests/cli/gathered.yml
+++ /dev/null
@@ -1,52 +0,0 @@
----
-- debug:
-    msg: Start nxos_lldp_interfaces gathered integration tests connection={{ansible_connection}}"
-
-- name: Enable LLDP feature
-  nxos_feature:
-    feature: lldp
-    state: enabled
-
-- block:
-    - name: Setup
-      cli_config:
-        config: |
-          interface Ethernet1/1
-            lldp receive
-            no lldp transmit
-          interface Ethernet1/2
-            no lldp receive
-            lldp tlv-set vlan 12
-          interface Ethernet1/3
-            lldp tlv-set management-address 192.0.2.12
-
-    - name: Gather lldp interfaces facts
-      nxos_facts: &facts
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources: lldp_interfaces
-
-    - name: Gathered
-      nxos_lldp_interfaces: &gathered
-        state: gathered
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-          - "ansible_facts.network_resources.lldp_interfaces == result.gathered"
-
-    - name: Idempotence - Gathered
-      nxos_lldp_interfaces: *gathered
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-
-  always:
-    - name: teardown
-      nxos_feature:
-        feature: lldp
-        state: disabled
diff --git a/test/integration/targets/nxos_lldp_interfaces/tests/cli/merged.yml b/test/integration/targets/nxos_lldp_interfaces/tests/cli/merged.yml
deleted file mode 100644
index 38bf374ee5..0000000000
--- a/test/integration/targets/nxos_lldp_interfaces/tests/cli/merged.yml
+++ /dev/null
@@ -1,60 +0,0 @@
----
-  - debug:
-      msg: "Start nxos_lldp_interfaces merged integration tests connection={{ansible_connection}}"
-
-  - name: Enable lldp
-    nxos_feature:
-      feature: lldp
-    
-  - block:
-    - name: Merged
-      nxos_lldp_interfaces: &merged
-        config:
-          - name: Ethernet 1/1
-            receive: false
-            tlv_set:
-              vlan: 123
-          
-          - name: Ethernet1/2
-            transmit: false
-            tlv_set:
-              management_address: 10.0.0.1
-        state: merged
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == true"
-          - "'interface Ethernet1/1' in result.commands"
-          - "'no lldp receive' in result.commands"
-          - "'lldp tlv-set vlan 123' in result.commands"
-          - "'interface Ethernet1/2' in result.commands"
-          - "'no lldp transmit' in result.commands"
-          - "'lldp tlv-set management-address 10.0.0.1' in result.commands"
-          - "result.commands | length == 6"
-
-    - name: Gather lldp_interfaces facts
-      nxos_facts:
-        gather_subset:
-          - '!all'
-          - '!min'
-        gather_network_resources: lldp_interfaces
-
-    - assert:
-        that:
-          - "ansible_facts.network_resources.lldp_interfaces == result.after"
- 
-    - name: Idempotence - Merged
-      nxos_lldp_interfaces: *merged
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-          - "result.commands | length == 0"
-
-    always:
-    - name: teardown
-      nxos_feature: 
-        feature: lldp
-        state: disabled
\ No newline at end of file
diff --git a/test/integration/targets/nxos_lldp_interfaces/tests/cli/overridden.yml b/test/integration/targets/nxos_lldp_interfaces/tests/cli/overridden.yml
deleted file mode 100644
index f3b231ccb3..0000000000
--- a/test/integration/targets/nxos_lldp_interfaces/tests/cli/overridden.yml
+++ /dev/null
@@ -1,66 +0,0 @@
----
-  - debug:
-      msg: "Start nxos_lldp_interfaces overridden tests connection={{ ansible_connection }}"
-
-  - name: Enable LLDP feature
-    nxos_feature:
-      feature: lldp
-      state: enabled
-
-  - block:
-      - name: Setup
-        cli_config: 
-          config: |
-            interface Ethernet1/1
-              no lldp receive
-              lldp tlv-set management-address 12.12.12.12
-
-      - name: Gather lldp_interfaces facts
-        nxos_facts: &facts
-          gather_subset:
-            - '!all'
-            - '!min'
-          gather_network_resources: lldp_interfaces
-
-      - name: Overridden
-        nxos_lldp_interfaces: &overridden
-          config:
-              - name: Ethernet1/2
-                receive: no
-                tlv_set:
-                  vlan: 12
-          state: overridden
-        register: result    
-
-      - assert:
-          that:
-            - "ansible_facts.network_resources.lldp_interfaces == result.before"
-            - "'interface Ethernet1/1' in result.commands"
-            - "'lldp receive' in result.commands"
-            - "'no lldp tlv-set management-address 12.12.12.12' in result.commands"
-            - "'interface Ethernet1/2' in result.commands"
-            - "'no lldp receive' in result.commands"
-            - "'lldp tlv-set vlan 12' in result.commands"
-            - "result.commands | length == 6"
-              
-      - name: Gather lldp_interfaces post facts
-        nxos_facts: *facts
-
-      - assert:
-          that:
-            - "ansible_facts.network_resources.lldp_interfaces == result.after"
-
-      - name: Idempotence - overridden
-        nxos_lldp_interfaces: *overridden
-        register: result
-
-      - assert:
-          that:
-            - "result.changed == false"
-            - "result.commands|length == 0"
-
-    always:
-    - name: teardown
-      nxos_feature:
-        feature: lldp
-        state: disabled
diff --git a/test/integration/targets/nxos_lldp_interfaces/tests/cli/parsed.yml b/test/integration/targets/nxos_lldp_interfaces/tests/cli/parsed.yml
deleted file mode 100644
index bbb9609291..0000000000
--- a/test/integration/targets/nxos_lldp_interfaces/tests/cli/parsed.yml
+++ /dev/null
@@ -1,47 +0,0 @@
----
-- debug:
-    msg: Start nxos_lldp_interfaces parsed integration tests connection={{ansible_connection}}"
-
-- name: Enable lldp
-  nxos_feature:
-    feature: lldp
-
-- block:
-    - name: Gather lldp interfaces facts
-      nxos_facts: &facts
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources: lldp_interfaces
-
-    - name: Parsed
-      nxos_lldp_interfaces: &parsed
-        running_config: |
-          interface Ethernet1/1
-            lldp receive
-            no lldp transmit
-          interface Ethernet1/2
-            no lldp receive
-            lldp tlv-set vlan 12
-          interface Ethernet1/3
-            lldp tlv-set management-address 192.0.2.12
-        state: parsed
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-          - "result.parsed == parsed"
-
-    - name: Idempotence - Parsed
-      nxos_lldp_interfaces: *parsed
-      register: result
-
-    - assert:
-        that: "result.changed == false"
-
-  always:
-    - name: teardown
-      nxos_feature:
-        feature: lldp
-        state: disabled
diff --git a/test/integration/targets/nxos_lldp_interfaces/tests/cli/remove_config.yaml b/test/integration/targets/nxos_lldp_interfaces/tests/cli/remove_config.yaml
deleted file mode 100644
index 955325eac2..0000000000
--- a/test/integration/targets/nxos_lldp_interfaces/tests/cli/remove_config.yaml
+++ /dev/null
@@ -1,8 +0,0 @@
----
-- cli_config:
-    config: |
-      no interface port-channel1
-      no interface port-channel2
-      no interface port-channel12
-  ignore_errors: yes
-#this is just for RTT to remove spill overs from other modules and pass in ZUUL
diff --git a/test/integration/targets/nxos_lldp_interfaces/tests/cli/rendered.yml b/test/integration/targets/nxos_lldp_interfaces/tests/cli/rendered.yml
deleted file mode 100644
index 2105b07383..0000000000
--- a/test/integration/targets/nxos_lldp_interfaces/tests/cli/rendered.yml
+++ /dev/null
@@ -1,42 +0,0 @@
----
-- debug:
-    msg: "Start nxos_lldp_interfaces rendered tests connection={{ ansible_connection }}"
-
-- name: Rendered
-  nxos_lldp_interfaces: &rendered
-    config:
-      - name: Ethernet1/1
-        receive: true
-        transmit: false
-
-      - name: Ethernet1/2
-        receive: false
-        tlv_set:
-          vlan: 12
-
-      - name: Ethernet1/3
-        tlv_set:
-          management_address: 192.0.2.12
-    state: rendered
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-      - "'interface Ethernet1/1' in result.rendered"
-      - "'lldp receive' in result.rendered"
-      - "'no lldp transmit' in result.rendered"
-      - "'interface Ethernet1/2' in result.rendered"
-      - "'no lldp receive' in result.rendered"
-      - "'lldp tlv-set vlan 12' in result.rendered"
-      - "'interface Ethernet1/3' in result.rendered"
-      - "'lldp tlv-set management-address 192.0.2.12' in result.rendered"
-      - "result.rendered | length == 8"
-
-- name: Idempotence - Rendered
-  nxos_lldp_interfaces: *rendered
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
diff --git a/test/integration/targets/nxos_lldp_interfaces/tests/cli/replaced.yml b/test/integration/targets/nxos_lldp_interfaces/tests/cli/replaced.yml
deleted file mode 100644
index f3866bf19a..0000000000
--- a/test/integration/targets/nxos_lldp_interfaces/tests/cli/replaced.yml
+++ /dev/null
@@ -1,62 +0,0 @@
----
-  - debug:
-      msg: "Start nxos_lldp_interfaces replaced integration tests connection = {{ansible_connection}}"
-
-  - name: Enable lldp feature
-    nxos_feature:
-      feature: lldp
-      state: enabled
-
-  - block:
-    - name: Setup
-      cli_config:
-        config: |
-          interface Ethernet1/2
-            no lldp receive
-            lldp tlv-set management-address 192.168.122.64
-
-    - name: Replaced
-      nxos_lldp_interfaces: &replaced
-        config:
-          - name: Ethernet1/2
-            transmit: false
-            tlv_set:
-              vlan: 2
-        state: replaced
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == true"
-          - "'interface Ethernet1/2' in result.commands"
-          - "'lldp receive' in result.commands"
-          - "'no lldp tlv-set management-address 192.168.122.64' in result.commands"
-          - "'no lldp transmit' in result.commands"
-          - "'lldp tlv-set vlan 2' in result.commands"
-          - "result.commands|length == 5"
-
-    - name: Gather lldp_interfaces post facts
-      nxos_facts: 
-        gather_subset:
-          - '!all'
-          - '!min'
-        gather_network_resources: lldp_interfaces
-
-    - assert: 
-        that:
-          - "ansible_facts.network_resources.lldp_interfaces == result.after"
-
-    - name: Idempotence - Replaced
-      nxos_lldp_interfaces: *replaced
-      register: result
- 
-    - assert:
-        that:
-          - "result.changed == false"
-          - "result.commands|length == 0"
-
-    always:
-    - name: teardown
-      nxos_feature:
-        feature: lldp
-        state: disabled
diff --git a/test/integration/targets/nxos_lldp_interfaces/tests/cli/rtt.yml b/test/integration/targets/nxos_lldp_interfaces/tests/cli/rtt.yml
deleted file mode 100644
index ed8e976587..0000000000
--- a/test/integration/targets/nxos_lldp_interfaces/tests/cli/rtt.yml
+++ /dev/null
@@ -1,70 +0,0 @@
----
-- debug:
-    msg: "Start nxos_lldp_interfaces round trip integration tests on connection={{ ansible_connection }}"
-
-- name: Enable lldp
-  nxos_feature:
-    feature: lldp
-
-- include_tasks: remove_config.yaml
-
-- block:
-    - name: RTT - Apply the provided configuration (base config)
-      nxos_lldp_interfaces:
-        config:
-          - name: Ethernet1/1
-            transmit: false
-            tlv_set:
-              vlan: 5
-        state: merged
-      register: base_config
-
-    - name: Gather interfaces facts
-      nxos_facts:
-        gather_subset:
-          - "!all"
-          - "!min"
-        gather_network_resources:
-          - lldp_interfaces
-
-    - name: Apply provided configuration (this will be reverted)
-      nxos_lldp_interfaces:
-        config:
-          - name: Ethernet1/1
-            transmit: false
-
-          - name: Ethernet1/2
-            transmit: true
-            tlv_set:
-              vlan: 12
-              management_address: 10.1.1.2
-        state: overridden
-      register: result
-
-    - name: Assert that changes were applied
-      assert:
-        that:
-          - "result.changed == true"
-          - "'interface Ethernet1/1' in result.commands"
-          - "'no lldp tlv-set vlan 5' in result.commands"
-          - "'interface Ethernet1/2' in result.commands"
-          - "'lldp transmit' in result.commands"
-          - "'lldp tlv-set vlan 12' in result.commands"
-          - "'lldp tlv-set management-address 10.1.1.2' in result.commands"
-          - "result.commands | length == 6"
-
-    - name: Revert back to base configuration
-      nxos_lldp_interfaces:
-        config: "{{ ansible_facts['network_resources']['lldp_interfaces'] }}"
-        state: overridden
-      register: revert
-
-    - name: Assert that config was reverted
-      assert:
-        that: "{{ base_config['after'] | symmetric_difference(revert['after']) |length == 0 }}"
-
-  always:
-    - name: teardown
-      nxos_feature:
-        feature: lldp
-        state: disabled
diff --git a/test/integration/targets/nxos_lldp_interfaces/vars/main.yml b/test/integration/targets/nxos_lldp_interfaces/vars/main.yml
deleted file mode 100644
index 123ef31cf2..0000000000
--- a/test/integration/targets/nxos_lldp_interfaces/vars/main.yml
+++ /dev/null
@@ -1,14 +0,0 @@
----
-parsed:
-  - name: Ethernet1/1
-    receive: true
-    transmit: false
-
-  - name: Ethernet1/2
-    receive: false
-    tlv_set:
-      vlan: 12
-
-  - name: Ethernet1/3
-    tlv_set:
-      management_address: 192.0.2.12
diff --git a/test/integration/targets/nxos_logging/defaults/main.yaml b/test/integration/targets/nxos_logging/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_logging/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_logging/meta/main.yaml b/test/integration/targets/nxos_logging/meta/main.yaml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_logging/meta/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_logging/tasks/cli.yaml b/test/integration/targets/nxos_logging/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_logging/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_logging/tasks/main.yaml b/test/integration/targets/nxos_logging/tasks/main.yaml
deleted file mode 100644
index f6c7fec17e..0000000000
--- a/test/integration/targets/nxos_logging/tasks/main.yaml
+++ /dev/null
@@ -1,13 +0,0 @@
----
-# Use block to ensure that the baude rate gets set
-# back to 9600 even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  - { include: nxapi.yaml, tags: ['nxapi'] }
-  always:
-  - name: Set Baud Rate Back to 9600 so our tests don't break
-    nxos_config:
-      lines:
-        - speed 9600
-      parents: line console
-    connection: network_cli
diff --git a/test/integration/targets/nxos_logging/tasks/nxapi.yaml b/test/integration/targets/nxos_logging/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_logging/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_logging/tests/common/basic.yaml b/test/integration/targets/nxos_logging/tests/common/basic.yaml
deleted file mode 100644
index 4dd11efac7..0000000000
--- a/test/integration/targets/nxos_logging/tests/common/basic.yaml
+++ /dev/null
@@ -1,505 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_logging basic test"
-
-# This task is needed to clear out any previous logfile
-# size settings.
-- name: Workaround to clear logging logfile size
-  nxos_config:
-    lines:
-      - logging logfile test 1 size 4194304
-  ignore_errors: yes
-
-- name: Purge logging configuration first
-  nxos_logging:
-    purge: true
-
-- name: Set up console logging
-  nxos_logging: &clog
-    dest: console
-    dest_level: 0
-    state: present
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"logging console 0" in result.commands'
-
-- name: Set up console logging again (idempotent)
-  nxos_logging: *clog
-  register: result
-
-- assert: &false
-    that:
-      - 'result.changed == false'
-
-- name: Set up console logging with level 2 (edge case)
-  nxos_logging: &clog2
-    dest: console
-    dest_level: 2
-    state: present
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"logging console 2" in result.commands'
-
-- name: Set up console logging with level 2 (edge case) (idempotent)
-  nxos_logging: *clog2
-  register: result
-
-- assert: *false
-
-- name: Set Baud Rate to less than 38400
-  nxos_config:
-    lines:
-      - speed 19200
-    parents: line console
-
-- name: Enable console logging with level 3 (will fail)
-  nxos_logging: &con3
-    dest: console
-    dest_level: 3
-  register: result
-  ignore_errors: yes
-
-- assert:
-    that:
-      - 'result.failed == true'
-
-- name: Set Baud Rate to 38400
-  nxos_config:
-    lines:
-      - speed 38400
-    parents: line console
-
-- name: Enable console logging with level 3 (will pass)
-  nxos_logging: *con3
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"logging console 3" in result.commands'
-
-- block:
-  - name: Logfile logging with level
-    nxos_logging: &llog
-      dest: logfile
-      name: test
-      dest_level: 1
-      state: present
-    register: result
-
-  - assert:
-      that:
-        - 'result.changed == true'
-        - '"logging logfile test 1" in result.commands'
-  
-
-  - name: Logfile logging with level (idempotent)
-    nxos_logging: *llog
-    register: result
-
-  - assert: *false
-
-  when: platform is not search('N5K|N7K') and imagetag is not search("A8")
-
-- name: Configure module with level
-  nxos_logging: &molog
-    dest: module
-    dest_level: 2
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"logging module 2" in result.commands'
-
-- name: Configure module with level (idempotent)
-  nxos_logging: *molog
-  register: result
-
-- assert: *false
-
-- name: Configure monitor with level
-  nxos_logging: &mlog
-    dest: monitor
-    dest_level: 3
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"logging monitor 3" in result.commands'
-
-- name: Configure monitor with level (idempotent)
-  nxos_logging: *mlog
-  register: result
-
-- assert: *false
-
-- name: Configure monitor with level 5 (edge case)
-  nxos_logging: &mlog5
-    dest: monitor
-    dest_level: 5
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"logging monitor 5" in result.commands'
-
-- name: Configure monitor with level 5 (edge case) (idempotent)
-  nxos_logging: *mlog5
-  register: result
-
-- assert: *false
-
-- name: Configure facility with level
-  nxos_logging: &flog
-    facility: daemon
-    facility_level: 4
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"logging level daemon 4" in result.commands'
-
-- name: Configure facility with level (idempotent)
-  nxos_logging: *flog
-  register: result
-
-- assert: *false
-
-- name: Configure Remote Logging
-  nxos_logging: &rlog
-    dest: server
-    remote_server: test-syslogserver.com
-    facility: auth
-    facility_level: 1
-    use_vrf: management
-    state: present
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"logging server test-syslogserver.com 1 facility auth use-vrf management" in result.commands'
-
-- name: Configure Remote Logging (idempotent)
-  nxos_logging: *rlog
-  register: result
-
-- assert: *false
-
-- name: Configure Source Interface for Logging
-  nxos_logging: &srcint
-    interface: mgmt0
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"logging source-interface mgmt 0" in result.commands'
-
-- name: Configure Source Interface for Logging (idempotent)
-  nxos_logging: *srcint
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- name: remove logging as collection tearDown
-  nxos_logging: &agg
-    aggregate:
-      - { dest: console, dest_level: 3 }
-      - { dest: module, dest_level: 2 }
-      - { dest: monitor, dest_level: 5 }
-      - { dest: logfile, dest_level: 1, name: test }
-      - { facility: daemon, facility_level: 4 }
-      - { dest: server, remote_server: test-syslogserver.com, facility: auth, facility_level: 1, use_vrf: management }
-      - { interface: mgmt0 }
-    state: absent
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"no logging logfile" in result.commands'
-      - '"no logging level daemon 4" in result.commands'
-      - '"no logging monitor" in result.commands'
-      - '"no logging module" in result.commands'
-      - '"no logging server test-syslogserver.com" in result.commands'
-      - '"no logging source-interface" in result.commands'
-  when: platform is not search('N5K|N7K') and imagetag is not search("A8")
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"no logging level daemon 4" in result.commands'
-      - '"no logging monitor" in result.commands'
-      - '"no logging module" in result.commands'
-      - '"no logging server test-syslogserver.com" in result.commands'
-      - '"no logging source-interface" in result.commands'
-  when: platform is search('N5K|N7K') or imagetag is search("A8")
-
-- name: remove aggregate logging (idempotent)
-  nxos_logging: *agg
-  register: result
-
-- assert: *false
-
-- block:
-  - name: Configure Logging message
-    nxos_logging: &logm
-      interface_message: add-interface-description
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - 'result.changed == true'
-
-  - name: Configure Logging message (idempotent)
-    nxos_logging: *logm
-    register: result
-
-  - assert: *false
-
-  - name: Remove Logging message
-    nxos_logging:
-      interface_message: add-interface-description
-      state: absent
-    register: result
-
-  - assert: *true
-  when: platform is not search('N5K') and imagetag is not search("A8")
-
-
-- name: Logfile logging with level and size
-  nxos_logging: &llogs
-    dest: logfile
-    name: test
-    dest_level: 1
-    file_size: 16384
-    state: present
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"logging logfile test 1 size 16384" in result.commands'
-
-- name: Logfile logging with level and size (idempotent)
-  nxos_logging: *llogs
-  register: result
-
-- assert: *false
-
-- name: Remove logfile logging with level and size
-  nxos_logging:
-    dest: logfile
-    name: test
-    dest_level: 1
-    file_size: 16384
-    state: absent
-  register: result
-
-- assert: *true
-
-- name: Set up logging event link enable
-  nxos_logging: &logle
-    event: link-enable
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"logging event link-status enable" in result.commands'
-
-- name: Set up logging event link enable again (idempotent)
-  nxos_logging: *logle
-  register: result
-
-- assert: *false
-
-- name: Remove logging event link enable
-  nxos_logging: &rlogle
-    event: link-enable
-    state: absent
-  register: result
-
-- assert: *true
-
-- name: Remove logging event link enable again (idempotent)
-  nxos_logging: *rlogle
-  register: result
-
-- assert: *false
-
-- name: Set up logging event link default
-  nxos_logging: &logld
-    event: link-default
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"logging event link-status default" in result.commands'
-
-- name: Set up logging event link default again (idempotent)
-  nxos_logging: *logld
-  register: result
-
-- assert: *false
-
-- name: Remove logging event link default
-  nxos_logging: &rlogld
-    event: link-default
-    state: absent
-  register: result
-
-- assert: *true
-
-- name: Remove logging event link default again (idempotent)
-  nxos_logging: *rlogld
-  register: result
-
-- assert: *false
-
-- name: Set up logging event trunk enable
-  nxos_logging: &logte
-    event: trunk-enable
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"logging event trunk-status enable" in result.commands'
-
-- name: Set up logging event trunk enable again (idempotent)
-  nxos_logging: *logte
-  register: result
-
-- assert: *false
-
-- name: Remove logging event trunk enable
-  nxos_logging: &rlogte
-    event: trunk-enable
-    state: absent
-  register: result
-
-- assert: *true
-
-- name: Remove logging event trunk enable again (idempotent)
-  nxos_logging: *rlogte
-  register: result
-
-- assert: *false
-- name: Set up logging event trunk default
-  nxos_logging: &logtd
-    event: trunk-default
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"logging event trunk-status default" in result.commands'
-
-- name: Set up logging event trunk default again (idempotent)
-  nxos_logging: *logtd
-  register: result
-
-- assert: *false
-
-- name: Remove logging event trunk default
-  nxos_logging: &rlogtd
-    event: trunk-default
-    state: absent
-  register: result
-
-- assert: *true
-
-- name: Remove logging event trunk default again (idempotent)
-  nxos_logging: *rlogtd
-  register: result
-
-- assert: *false
-
-- name: Set up Logging Timestamp
-  nxos_logging: &ltms
-    timestamp: microseconds
-    state: present
-  register: result
-
-- assert: *true
-
-- name: Set up Logging Timestamp (idempotent)
-  nxos_logging: *ltms
-  register: result
-
-- assert: *false
-
-- name: Remove Logging Timestamp
-  nxos_logging:
-    timestamp: microseconds
-    state: absent
-  register: result
-
-- assert: *true
-
-- name: Set up Facility ethpm Link UP Error
-
-  nxos_logging: &felue
-    facility: ethpm
-    facility_link_status: link-up-error
-    state: present
-  register: result
-
-- assert: *true
-
-- name: Set up Facility ethpm Link UP Error (idempotent)
-  nxos_logging: *felue
-  register: result
-
-- assert: *false
-
-- name: Remove Facility ethpm Link UP Error
-  nxos_logging:
-    facility: ethpm
-    facility_link_status: link-up-error
-    state: absent
-  register: result
-
-- assert: *true
-
-- name: Set up Facility ethpm Link DOWN Error
-
-  nxos_logging: &felde
-    facility: ethpm
-    facility_link_status: link-down-error
-    state: present
-  register: result
-
-- assert: *true
-
-- name: Set up Facility ethpm Link DOWN Error (idempotent)
-  nxos_logging: *felde
-  register: result
-
-- assert: *false
-
-- name: Remove Facility ethpm Link DOWN Error
-  nxos_logging:
-    facility: ethpm
-    facility_link_status: link-down-error
-    state: absent
-  register: result
-
-- assert: *true
-
-- debug: msg="END connection={{ ansible_connection }} nxos_logging basic test"
diff --git a/test/integration/targets/nxos_logging/tests/common/net_logging.yaml b/test/integration/targets/nxos_logging/tests/common/net_logging.yaml
deleted file mode 100644
index f19eb9e7d1..0000000000
--- a/test/integration/targets/nxos_logging/tests/common/net_logging.yaml
+++ /dev/null
@@ -1,34 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos common/net_logging.yaml"
-
-# Add minimal testcase to check args are passed correctly to
-# implementation module and module run is successful.
-
-- name: Delete/disable console logging - setup
-  net_logging:
-    dest: console
-    dest_level: 0
-    state: absent
-  register: result
-
-- name: Set up console logging using platform agnostic module
-  net_logging:
-    dest: console
-    dest_level: 0
-    state: present
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"logging console 0" in result.commands'
-
-- name: Delete/disable console logging - teardown
-  net_logging:
-    dest: console
-    dest_level: 0
-    state: absent
-  register: result
-
-
-- debug: msg="END connection={{ ansible_connection }} nxos common/net_logging.yaml"
diff --git a/test/integration/targets/nxos_logging/tests/common/purge.yaml b/test/integration/targets/nxos_logging/tests/common/purge.yaml
deleted file mode 100644
index 61a99050ce..0000000000
--- a/test/integration/targets/nxos_logging/tests/common/purge.yaml
+++ /dev/null
@@ -1,105 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_logging purge test"
-
-- name: Purge logging configuration first
-  nxos_logging:
-    purge: true
-
-- block:
-
-    - name: Set up console logging
-      nxos_logging: &clog
-        dest: console
-        dest_level: 0
-        state: present
-      register: result
-
-    - assert:
-        that:
-          - 'result.changed == true'
-          - '"logging console 0" in result.commands'
-
-    - name: Set up Logging Timestamp
-      nxos_logging: &ltms
-        timestamp: microseconds
-        state: present
-      register: result
-
-    - assert:
-        that:
-          - 'result.changed == true'
-          - '"logging timestamp microseconds" in result.commands'
-
-    - name: Configure monitor with level
-      nxos_logging: &mlog
-        dest: monitor
-        dest_level: 3
-      register: result
-
-    - assert:
-        that:
-          - 'result.changed == true'
-          - '"logging monitor 3" in result.commands'
-
-    - name: Configure facility with level
-      nxos_logging: &flog
-        facility: daemon
-        facility_level: 4
-      register: result
-
-    - assert:
-        that:
-          - 'result.changed == true'
-          - '"logging level daemon 4" in result.commands'
-
-    - name: Configure logging level virtual-service 7 using nxos_config
-      nxos_config:
-        lines: logging level virtual-service 7
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == true"
-
-    - name: Purge the outliers
-      nxos_logging:
-        purge: yes
-      register: result
-
-    - assert:
-        that:
-          - 'result.changed == true'
-          - '"no logging level virtual-service 7" in result.commands'
-
-    - block:
-      - name: Purge the outliers (idempotent)
-        nxos_logging:
-          purge: yes
-        register: result
-
-      - assert:
-          that:
-            - 'result.changed == false'
-      when: imagetag is not search("A8")
-
-    - name: remove logging as collection tearDown
-      nxos_logging: &agg
-        aggregate:
-          - { dest: console, dest_level: 0 }
-          - { dest: monitor, dest_level: 3 }
-          - { timestamp: microseconds }
-          - { facility: daemon, facility_level: 4 }
-        state: absent
-      register: result
-
-    - assert:
-        that:
-          - 'result.changed == true'
-          - '"no logging console" in result.commands'
-          - '"no logging timestamp microseconds" in result.commands'
-          - '"no logging level daemon 4" in result.commands'
-          - '"no logging monitor" in result.commands'
-
-  when: ansible_connection != "local"
-
-- debug: msg="END connection={{ ansible_connection }} nxos_logging purge test"
diff --git a/test/integration/targets/nxos_netconf/defaults/main.yaml b/test/integration/targets/nxos_netconf/defaults/main.yaml
deleted file mode 100644
index 9ef5ba5165..0000000000
--- a/test/integration/targets/nxos_netconf/defaults/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-testcase: "*"
-test_items: []
diff --git a/test/integration/targets/nxos_netconf/meta/main.yaml b/test/integration/targets/nxos_netconf/meta/main.yaml
deleted file mode 100644
index 6a8fed7644..0000000000
--- a/test/integration/targets/nxos_netconf/meta/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
-dependencies:
-  # Not needed for this test
-  # - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_netconf/tasks/main.yaml b/test/integration/targets/nxos_netconf/tasks/main.yaml
deleted file mode 100644
index 07e872c945..0000000000
--- a/test/integration/targets/nxos_netconf/tasks/main.yaml
+++ /dev/null
@@ -1,41 +0,0 @@
----
-- name: Setup - Enable feature netconf
-  nxos_feature:
-    feature: netconf
-    state: enabled
-  vars: &ssh_credentials
-    ansible_connection: network_cli
-    ansible_ssh_port: 22
-  register: result
-  ignore_errors: yes
-
-- debug: msg='Netconf feature is not supported on this platform!'
-  when: result.failed
-
-- name: Setup - Remove Vlan
-  nxos_config:
-    lines:
-      - no vlan 42
-  ignore_errors: yes
-  when: not result.failed
-
-- block:
-  - name: Run netconf tests
-    include: netconf.yaml
-    when: not result.failed
-
-  always:
-  - name: Disable feature netconf
-    nxos_feature:
-      feature: netconf
-      state: disabled
-    vars: *ssh_credentials
-    when: not result.failed
-
-  - name: Cleanup - Remove vlan
-    nxos_config:
-      lines:
-        - no vlan 42
-    vars: *ssh_credentials
-    ignore_errors: yes
-    when: not result.failed
diff --git a/test/integration/targets/nxos_netconf/tasks/netconf.yaml b/test/integration/targets/nxos_netconf/tasks/netconf.yaml
deleted file mode 100644
index d8d042114f..0000000000
--- a/test/integration/targets/nxos_netconf/tasks/netconf.yaml
+++ /dev/null
@@ -1,16 +0,0 @@
----
-- name: collect all cli test cases
-  find:
-    paths: "{{ role_path }}/tests/netconf"
-    patterns: "{{ testcase }}.yaml"
-  register: test_cases
-  delegate_to: localhost
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test case (connection=netconf)
-  include: "{{ test_case_to_run }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_netconf/tests/fixtures/config.yaml b/test/integration/targets/nxos_netconf/tests/fixtures/config.yaml
deleted file mode 100644
index de3c340263..0000000000
--- a/test/integration/targets/nxos_netconf/tests/fixtures/config.yaml
+++ /dev/null
@@ -1,14 +0,0 @@
----
-vlan_config: |
-          <config>
-          <System xmlns="http://cisco.com/ns/yang/cisco-nx-os-device">
-            <bd-items>
-              <bd-items>
-                <BD-list>
-                  <fabEncap>vlan-42</fabEncap>
-                  <name>vlan-42</name>
-                </BD-list>
-              </bd-items>
-            </bd-items>
-          </System>
-          </config>
diff --git a/test/integration/targets/nxos_netconf/tests/netconf/basic.yaml b/test/integration/targets/nxos_netconf/tests/netconf/basic.yaml
deleted file mode 100644
index b9d79ab9af..0000000000
--- a/test/integration/targets/nxos_netconf/tests/netconf/basic.yaml
+++ /dev/null
@@ -1,44 +0,0 @@
----
-- debug: msg="START nxos_netconf cli/basic.yaml"
-
-- include_vars: "{{playbook_dir }}/targets/nxos_netconf/tests/fixtures/config.yaml"
-
-- debug: msg=" {{ playbook_dir }}"
-
-- block:
-  - name: Configure vlan
-    netconf_config: &config_vlan
-      datastore: running
-      commit: false
-      get_filter: <System xmlns="http://cisco.com/ns/yang/cisco-nx-os-device"><bd-items><bd-items><BD-list></BD-list></bd-items></bd-items></System>
-      content: "{{ vlan_config }}"
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: Configure vlan - idempotence check
-    netconf_config: *config_vlan
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Query Running Config
-    netconf_get:
-      source: running
-      filter: <System xmlns="http://cisco.com/ns/yang/cisco-nx-os-device"><bd-items><bd-items><BD-list></BD-list></bd-items></bd-items></System>
-    register: result
-
-  - assert:
-      that:
-        - "'vlan-42' in result.stdout"
-
-  vars:
-    ansible_connection: netconf
-    ansible_port: 830
-
-  always:
-  - debug: msg="END nxos_netconf cli/basic.yaml"
diff --git a/test/integration/targets/nxos_ntp/defaults/main.yaml b/test/integration/targets/nxos_ntp/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_ntp/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_ntp/meta/main.yml b/test/integration/targets/nxos_ntp/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_ntp/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_ntp/tasks/cli.yaml b/test/integration/targets/nxos_ntp/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_ntp/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_ntp/tasks/main.yaml b/test/integration/targets/nxos_ntp/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_ntp/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_ntp/tasks/nxapi.yaml b/test/integration/targets/nxos_ntp/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_ntp/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_ntp/tests/common/sanity.yaml b/test/integration/targets/nxos_ntp/tests/common/sanity.yaml
deleted file mode 100644
index 54ee34411a..0000000000
--- a/test/integration/targets/nxos_ntp/tests/common/sanity.yaml
+++ /dev/null
@@ -1,114 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_ntp sanity test"
-
-- name: Setup - Remove ntp if configured
-  nxos_ntp: &remove
-    server: 1.2.3.4
-    key_id: 32
-    prefer: disabled
-    vrf_name: management
-    source_addr: 192.0.2.5
-    state: absent
-  ignore_errors: yes
-
-- block:
-
-  - name: Configure ntp
-    nxos_ntp: &config
-      server: 1.2.3.4
-      key_id: 32
-      prefer: enabled
-      vrf_name: management
-      source_addr: 192.0.2.5
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: Idempotence Check
-    nxos_ntp: *config
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Configure ntp with some defaults
-    nxos_ntp: &config1
-      peer: 1.2.3.4
-      key_id: default
-      prefer: enabled
-      vrf_name: default
-      source_addr: default
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_ntp: *config1
-    register: result
-
-  - assert: *false
-
-  - name: Remove ntp config
-    nxos_ntp: *remove
-    register: result
-
-  - assert: *true
-
-  - name: Remove Idempotence Check
-    nxos_ntp: *remove
-    register: result
-
-  - assert: *false
-
-  - name: Configure ntp again
-    nxos_ntp: &config2
-      source_int: Ethernet1/3
-      peer: 1.2.3.4
-      prefer: enabled
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_ntp: *config2
-    register: result
-
-  - assert: *false
-
-  - name: Remove source interface
-    nxos_ntp: &config3
-      source_int: default
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_ntp: *config3
-    register: result
-
-  - assert: *false
-
-  - name: Remove ntp
-    nxos_ntp: *remove
-    register: result
-
-  - assert: *true
-
-  - name: Remove Idempotence Check
-    nxos_ntp: *remove
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: Remove ntp config
-    nxos_ntp: *remove
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_ntp sanity test"
diff --git a/test/integration/targets/nxos_ntp_auth/defaults/main.yaml b/test/integration/targets/nxos_ntp_auth/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_ntp_auth/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_ntp_auth/meta/main.yml b/test/integration/targets/nxos_ntp_auth/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_ntp_auth/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_ntp_auth/tasks/cli.yaml b/test/integration/targets/nxos_ntp_auth/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_ntp_auth/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_ntp_auth/tasks/main.yaml b/test/integration/targets/nxos_ntp_auth/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_ntp_auth/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_ntp_auth/tasks/nxapi.yaml b/test/integration/targets/nxos_ntp_auth/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_ntp_auth/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_ntp_auth/tests/common/sanity.yaml b/test/integration/targets/nxos_ntp_auth/tests/common/sanity.yaml
deleted file mode 100644
index e4db5e979b..0000000000
--- a/test/integration/targets/nxos_ntp_auth/tests/common/sanity.yaml
+++ /dev/null
@@ -1,133 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_ntp_auth sanity test"
-
-- name: Configure text ntp authentication
-  nxos_ntp_auth: &setup
-    key_id: 32
-    md5string: hello
-    state: absent
-  ignore_errors: yes
-
-- block:
-
-  - name: Configure text ntp authentication
-    nxos_ntp_auth: &configure_text
-      key_id: 32
-      md5string: hello
-      authentication: off
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: Remove text ntp authentication
-    nxos_ntp_auth: &remove_text
-      key_id: 32
-      md5string: hello
-      authentication: off
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: Configure encrypt ntp authentication
-    nxos_ntp_auth: &configure_encrypt
-      key_id: 32
-      md5string: hello
-      auth_type: encrypt
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Configure encrypt ntp authentication"
-    nxos_ntp_auth: *configure_encrypt
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Turn on authentication
-    nxos_ntp_auth: &authon
-      authentication: on
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Turn on authentication"
-    nxos_ntp_auth: *authon
-    register: result
-
-  - assert: *false
-
-  - name: Turn off authentication
-    nxos_ntp_auth: &authoff
-      authentication: off
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Turn off authentication"
-    nxos_ntp_auth: *authoff
-    register: result
-
-  - assert: *false
-
-  - name: Add trusted key
-    nxos_ntp_auth: &tkey
-      key_id: 32
-      trusted_key: true
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Add trusted key"
-    nxos_ntp_auth: *tkey
-    register: result
-
-  - assert: *false
-
-  - name: Remove trusted key
-    nxos_ntp_auth: &rtkey
-      key_id: 32
-      trusted_key: false
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Remove trusted key"
-    nxos_ntp_auth: *rtkey
-    register: result
-
-  - assert: *false
-
-  - name: Remove encrypt ntp authentication
-    nxos_ntp_auth: &remove_encrypt
-      key_id: 32
-      md5string: hello
-      auth_type: encrypt
-      authentication: on
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Remove encrypt ntp authentication"
-    nxos_ntp_auth: *remove_encrypt
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: Cleanup ntp auth config
-    nxos_ntp_auth: *setup
-    ignore_errors: yes
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_ntp_auth sanity test"
diff --git a/test/integration/targets/nxos_ntp_options/defaults/main.yaml b/test/integration/targets/nxos_ntp_options/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_ntp_options/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_ntp_options/meta/main.yml b/test/integration/targets/nxos_ntp_options/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_ntp_options/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_ntp_options/tasks/cli.yaml b/test/integration/targets/nxos_ntp_options/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_ntp_options/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_ntp_options/tasks/main.yaml b/test/integration/targets/nxos_ntp_options/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_ntp_options/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_ntp_options/tasks/nxapi.yaml b/test/integration/targets/nxos_ntp_options/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_ntp_options/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_ntp_options/tests/common/sanity.yaml b/test/integration/targets/nxos_ntp_options/tests/common/sanity.yaml
deleted file mode 100644
index 721765463c..0000000000
--- a/test/integration/targets/nxos_ntp_options/tests/common/sanity.yaml
+++ /dev/null
@@ -1,99 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_ntp_options sanity test"
-
-- name: "Apply default ntp config" 
-  nxos_ntp_options: &default
-    state: absent
-  ignore_errors: yes
-
-- block:
-
-  - name: Configure ntp with master and default stratum
-    nxos_ntp_options: &configure_master_default_stratum
-      master: true
-      logging: true
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence - Configure ntp with master and default stratum"
-    nxos_ntp_options: *configure_master_default_stratum
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Configure ntp with master and non-default stratum
-    nxos_ntp_options: &configure_master_non_default_stratum
-      master: true
-      stratum: 10
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Configure ntp with master and non-default stratum"
-    nxos_ntp_options: *configure_master_non_default_stratum
-    register: result
-
-  - assert: *false
-
-  - name: Configure ntp with master and no logging
-    nxos_ntp_options: &configure_no_log
-      master: true
-      stratum: 10
-      logging: false
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Configure ntp with master and no logging"
-    nxos_ntp_options: *configure_no_log
-    register: result
-
-  - assert: *false
-
-  - name: Configure ntp with logging and no master
-    nxos_ntp_options: &configure_no_master
-      master: false
-      logging: true
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Configure ntp with logging and no master"
-    nxos_ntp_options: *configure_no_master
-    register: result
-
-  - assert: *false
-
-  - name: "Configure ntp with master and non-default stratum again"
-    nxos_ntp_options: *configure_master_non_default_stratum
-    register: result
-
-  - assert: *true
-
-  - name: Remove ntp options
-    nxos_ntp_options: *default
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence - Remove"
-    nxos_ntp_options: *default
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: Cleanup ntp config
-    nxos_ntp_options: *default
-    register: result
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_ntp_options sanity test"
diff --git a/test/integration/targets/nxos_nxapi/defaults/main.yaml b/test/integration/targets/nxos_nxapi/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_nxapi/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_nxapi/meta/main.yml b/test/integration/targets/nxos_nxapi/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_nxapi/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_nxapi/tasks/cli.yaml b/test/integration/targets/nxos_nxapi/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_nxapi/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_nxapi/tasks/main.yaml b/test/integration/targets/nxos_nxapi/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_nxapi/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_nxapi/tasks/nxapi.yaml b/test/integration/targets/nxos_nxapi/tasks/nxapi.yaml
deleted file mode 100644
index 04c99602e6..0000000000
--- a/test/integration/targets/nxos_nxapi/tasks/nxapi.yaml
+++ /dev/null
@@ -1,33 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
-
-- name: run test cases (connection=local)
-  include: "{{ test_case_to_run }} ansible_connection=local connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_nxapi/tasks/platform/default/assert_changes_http.yaml b/test/integration/targets/nxos_nxapi/tasks/platform/default/assert_changes_http.yaml
deleted file mode 100644
index 0d13136aaa..0000000000
--- a/test/integration/targets/nxos_nxapi/tasks/platform/default/assert_changes_http.yaml
+++ /dev/null
@@ -1,16 +0,0 @@
----
-- name: Assert HTTP configuration changes
-  assert:
-    that:
-      - result.stdout[0]['TABLE_listen_on_port']['ROW_listen_on_port'].l_port
-      - result.stdout[0]['TABLE_listen_on_port']['ROW_listen_on_port'].l_port|string is search("80")
-      - result.stdout[0]['operation_status'].o_status == 'nxapi enabled'
-  when: result.stdout[0].TABLE_listen_on_port is defined
-
-- name: Assert HTTP configuration changes 9.2 or greater
-  assert:
-    that:
-      - result.stdout[0]['http_port']
-      - result.stdout[0]['http_port']|string is search("80")
-      - result.stdout[0]['nxapi_status'] == 'nxapi enabled'
-  when: result.stdout[0].http_port is defined
diff --git a/test/integration/targets/nxos_nxapi/tasks/platform/default/assert_changes_https.yaml b/test/integration/targets/nxos_nxapi/tasks/platform/default/assert_changes_https.yaml
deleted file mode 100644
index 629698ac98..0000000000
--- a/test/integration/targets/nxos_nxapi/tasks/platform/default/assert_changes_https.yaml
+++ /dev/null
@@ -1,16 +0,0 @@
----
-- name: Assert HTTPS configuration changes
-  assert:
-    that:
-      - result.stdout[0]['TABLE_listen_on_port']['ROW_listen_on_port'].l_port
-      - result.stdout[0]['TABLE_listen_on_port']['ROW_listen_on_port'].l_port|string is search("9443")
-      - result.stdout[0]['operation_status'].o_status == 'nxapi enabled'
-  when: result.stdout[0].TABLE_listen_on_port is defined
-
-- name: Assert HTTPS configuration changes 9.2 or greater
-  assert:
-    that:
-      - result.stdout[0]['https_port']
-      - result.stdout[0]['https_port']|string is search("9443")
-      - result.stdout[0]['nxapi_status'] == 'nxapi enabled'
-  when: result.stdout[0].https_port is defined
diff --git a/test/integration/targets/nxos_nxapi/tasks/platform/default/assert_changes_https_http.yaml b/test/integration/targets/nxos_nxapi/tasks/platform/default/assert_changes_https_http.yaml
deleted file mode 100644
index 89c30757d2..0000000000
--- a/test/integration/targets/nxos_nxapi/tasks/platform/default/assert_changes_https_http.yaml
+++ /dev/null
@@ -1,20 +0,0 @@
----
-- name: Assert HTTPS & HTTP configuration changes
-  assert:
-    that:
-      - result.stdout[0]['TABLE_listen_on_port']['ROW_listen_on_port'][1].l_port
-      - result.stdout[0]['TABLE_listen_on_port']['ROW_listen_on_port'][1].l_port|string is search("9443")
-      - result.stdout[0]['TABLE_listen_on_port']['ROW_listen_on_port'][0].l_port
-      - result.stdout[0]['TABLE_listen_on_port']['ROW_listen_on_port'][0].l_port|string is search("80")
-      - result.stdout[0]['operation_status'].o_status == 'nxapi enabled'
-  when: result.stdout[0].TABLE_listen_on_port is defined
-
-- name: Assert HTTPS & HTTP configuration changes 9.2 or greater
-  assert:
-    that:
-      - result.stdout[0]['https_port']
-      - result.stdout[0]['https_port']|string is search("9443")
-      - result.stdout[0]['http_port']
-      - result.stdout[0]['http_port']|string is search("80")
-      - result.stdout[0]['nxapi_status'] == 'nxapi enabled'
-  when: result.stdout[0].https_port is defined or result.stdout[0].http_port is defined
diff --git a/test/integration/targets/nxos_nxapi/tasks/platform/default/assert_changes_https_http_ports.yaml b/test/integration/targets/nxos_nxapi/tasks/platform/default/assert_changes_https_http_ports.yaml
deleted file mode 100644
index 6838d0d6fa..0000000000
--- a/test/integration/targets/nxos_nxapi/tasks/platform/default/assert_changes_https_http_ports.yaml
+++ /dev/null
@@ -1,20 +0,0 @@
----
-- name: Assert HTTPS & HTTP configuration changes
-  assert:
-    that:
-      - result.stdout[0]['TABLE_listen_on_port']['ROW_listen_on_port'][1].l_port
-      - result.stdout[0]['TABLE_listen_on_port']['ROW_listen_on_port'][1].l_port|string is search("500")
-      - result.stdout[0]['TABLE_listen_on_port']['ROW_listen_on_port'][0].l_port
-      - result.stdout[0]['TABLE_listen_on_port']['ROW_listen_on_port'][0].l_port|string is search("99")
-      - result.stdout[0]['operation_status'].o_status == 'nxapi enabled'
-  when: result.stdout[0].TABLE_listen_on_port is defined
-
-- name: Assert HTTPS & HTTP configuration changes 9.2 or greater
-  assert:
-    that:
-      - result.stdout[0]['https_port']
-      - result.stdout[0]['https_port']|string is search("500")
-      - result.stdout[0]['http_port']
-      - result.stdout[0]['http_port']|string is search("99")
-      - result.stdout[0]['nxapi_status'] == 'nxapi enabled'
-  when: result.stdout[0].https_port is defined or result.stdout[0].http_port is defined
diff --git a/test/integration/targets/nxos_nxapi/tasks/platform/n5k/assert_changes_http.yaml b/test/integration/targets/nxos_nxapi/tasks/platform/n5k/assert_changes_http.yaml
deleted file mode 100644
index 2f79127f1e..0000000000
--- a/test/integration/targets/nxos_nxapi/tasks/platform/n5k/assert_changes_http.yaml
+++ /dev/null
@@ -1,6 +0,0 @@
----
-- name: Assert HTTP configuration changes
-  assert:
-    that:
-      - result.stdout[0].https_port is not defined
-      - result.stdout[0].http_port|string is search("80")
diff --git a/test/integration/targets/nxos_nxapi/tasks/platform/n5k/assert_changes_https.yaml b/test/integration/targets/nxos_nxapi/tasks/platform/n5k/assert_changes_https.yaml
deleted file mode 100644
index a934a1fa81..0000000000
--- a/test/integration/targets/nxos_nxapi/tasks/platform/n5k/assert_changes_https.yaml
+++ /dev/null
@@ -1,6 +0,0 @@
----
-- name: Assert HTTPS configuration changes
-  assert:
-    that:
-      - result.stdout[0].http_port is not defined
-      - result.stdout[0].https_port|string is search("9443")
diff --git a/test/integration/targets/nxos_nxapi/tasks/platform/n5k/assert_changes_https_http.yaml b/test/integration/targets/nxos_nxapi/tasks/platform/n5k/assert_changes_https_http.yaml
deleted file mode 100644
index 4dded98cf2..0000000000
--- a/test/integration/targets/nxos_nxapi/tasks/platform/n5k/assert_changes_https_http.yaml
+++ /dev/null
@@ -1,8 +0,0 @@
----
-- name: Assert HTTPS && HTTP configuration changes
-  assert:
-    that:
-      - result.stdout[0].https_port is defined
-      - result.stdout[0].http_port is defined
-      - result.stdout[0].https_port|string is search("9443")
-      - result.stdout[0].http_port|string is search("80")
diff --git a/test/integration/targets/nxos_nxapi/tasks/platform/n5k/assert_changes_https_http_ports.yaml b/test/integration/targets/nxos_nxapi/tasks/platform/n5k/assert_changes_https_http_ports.yaml
deleted file mode 100644
index 09c69d677b..0000000000
--- a/test/integration/targets/nxos_nxapi/tasks/platform/n5k/assert_changes_https_http_ports.yaml
+++ /dev/null
@@ -1,8 +0,0 @@
----
-- name: Assert HTTPS && HTTP configuration changes
-  assert:
-    that:
-      - result.stdout[0].https_port is defined
-      - result.stdout[0].http_port is defined
-      - result.stdout[0].https_port|string is search("500")
-      - result.stdout[0].http_port|string is search("99")
diff --git a/test/integration/targets/nxos_nxapi/tasks/platform/n7k/assert_changes_http.yaml b/test/integration/targets/nxos_nxapi/tasks/platform/n7k/assert_changes_http.yaml
deleted file mode 100644
index fbfba2fd45..0000000000
--- a/test/integration/targets/nxos_nxapi/tasks/platform/n7k/assert_changes_http.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-- name: Assert HTTP configuration changes
-  assert:
-    that:
-      - result.stdout[0].https_port is not defined
-      - result.stdout[0].http_port|string is search("80")
-      - result.stdout[0].sandbox_status == 'Enabled'
diff --git a/test/integration/targets/nxos_nxapi/tasks/platform/n7k/assert_changes_https.yaml b/test/integration/targets/nxos_nxapi/tasks/platform/n7k/assert_changes_https.yaml
deleted file mode 100644
index 83d954aac9..0000000000
--- a/test/integration/targets/nxos_nxapi/tasks/platform/n7k/assert_changes_https.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-- name: Assert HTTPS configuration changes
-  assert:
-    that:
-      - result.stdout[0].http_port is not defined
-      - result.stdout[0].https_port|string is search("9443")
-      - result.stdout[0].sandbox_status == 'Enabled'
diff --git a/test/integration/targets/nxos_nxapi/tasks/platform/n7k/assert_changes_https_http.yaml b/test/integration/targets/nxos_nxapi/tasks/platform/n7k/assert_changes_https_http.yaml
deleted file mode 100644
index 1db6d488dd..0000000000
--- a/test/integration/targets/nxos_nxapi/tasks/platform/n7k/assert_changes_https_http.yaml
+++ /dev/null
@@ -1,9 +0,0 @@
----
-- name: Assert HTTPS & HTTP configuration changes
-  assert:
-    that:
-      - result.stdout[0].https_port is defined
-      - result.stdout[0].http_port is defined
-      - result.stdout[0].https_port|string is search("9443")
-      - result.stdout[0].http_port|string is search("80")
-      - result.stdout[0].sandbox_status == 'Enabled'
diff --git a/test/integration/targets/nxos_nxapi/tasks/platform/n7k/assert_changes_https_http_ports.yaml b/test/integration/targets/nxos_nxapi/tasks/platform/n7k/assert_changes_https_http_ports.yaml
deleted file mode 100644
index 48611ef814..0000000000
--- a/test/integration/targets/nxos_nxapi/tasks/platform/n7k/assert_changes_https_http_ports.yaml
+++ /dev/null
@@ -1,9 +0,0 @@
----
-- name: Assert HTTPS & HTTP configuration changes
-  assert:
-    that:
-      - result.stdout[0].https_port is defined
-      - result.stdout[0].http_port is defined
-      - result.stdout[0].https_port|string is search("500")
-      - result.stdout[0].http_port|string is search("99")
-      - result.stdout[0].sandbox_status == 'Enabled'
diff --git a/test/integration/targets/nxos_nxapi/tests/cli/configure.yaml b/test/integration/targets/nxos_nxapi/tests/cli/configure.yaml
deleted file mode 100644
index d5bac17d49..0000000000
--- a/test/integration/targets/nxos_nxapi/tests/cli/configure.yaml
+++ /dev/null
@@ -1,141 +0,0 @@
----
-- debug: msg="START cli/configure.yaml"
-
-- set_fact: nxapi_sandbox_option="yes"
-  when: platform is search('N7K')
-
-- name: Setup - put NXAPI in stopped state
-  nxos_nxapi:
-    state: absent
-
-- block:
-  - name: Configure NXAPI HTTPS
-    nxos_nxapi: &configure_https
-      enable_http: no
-      enable_sandbox: "{{nxapi_sandbox_option|default(omit)}}"
-      enable_https: yes
-      https_port: 9443
-    register: result
-
-  - nxos_command:
-      commands:
-        - show nxapi | json
-    register: result
-
-  - include: tasks/platform/n7k/assert_changes_https.yaml
-    when: platform is match('N7K')
-
-  - include: tasks/platform/n5k/assert_changes_https.yaml
-    when: platform is search('N5K|N6K')
-
-  - include: tasks/platform/default/assert_changes_https.yaml
-    when: platform is not search('N35|N5K|N6K|N7K')
-
-  - name: Configure NXAPI HTTPS again
-    nxos_nxapi: *configure_https
-    register: result
-
-  - name: Assert configuration is idempotent
-    assert: &assert_false
-      that:
-        - result.changed == false
-
-  - name: Configure NXAPI HTTPS & HTTP
-    nxos_nxapi: &configure_https_http
-      enable_http: yes
-      enable_sandbox: "{{nxapi_sandbox_option|default(omit)}}"
-      enable_https: yes
-      https_port: 9443
-    register: result
-
-  - nxos_command:
-      commands:
-        - show nxapi | json
-    register: result
-
-  - include: tasks/platform/n7k/assert_changes_https_http.yaml
-    when: platform is match('N7K')
-
-  - include: tasks/platform/n5k/assert_changes_https_http.yaml
-    when: platform is match('N5K')
-
-  - include: tasks/platform/default/assert_changes_https_http.yaml
-    when: platform is not search('N35|N5K|N6K|N7K')
-
-  - name: Configure NXAPI HTTPS & HTTP again
-    nxos_nxapi: *configure_https_http
-    register: result
-
-  - name: Assert configuration is idempotent
-    assert: *assert_false
-
-  - name: Configure different NXAPI HTTPS & HTTP ports
-    nxos_nxapi: &configure_https_http_ports
-      enable_http: yes
-      enable_sandbox: "{{nxapi_sandbox_option|default(omit)}}"
-      enable_https: yes
-      http_port: 99
-      https_port: 500
-    register: result
-
-  - nxos_command:
-      commands:
-        - show nxapi | json
-    register: result
-
-  - include: tasks/platform/n7k/assert_changes_https_http_ports.yaml
-    when: platform is match('N7K')
-
-  - include: tasks/platform/n5k/assert_changes_https_http_ports.yaml
-    when: platform is match('N5K')
-
-  - include: tasks/platform/default/assert_changes_https_http_ports.yaml
-    when: platform is not search('N35|N5K|N6K|N7K')
-
-  - name: Configure different NXAPI HTTPS & HTTP ports again
-    nxos_nxapi: *configure_https_http_ports
-    register: result
-
-  - name: Assert configuration is idempotent
-    assert: *assert_false
-
-  - name: Configure NXAPI HTTP
-    nxos_nxapi: &configure_http
-      enable_http: yes
-      enable_sandbox: "{{nxapi_sandbox_option|default(omit)}}"
-      enable_https: no
-    register: result
-
-  - nxos_command:
-      commands:
-        - show nxapi | json
-    register: result
-
-  - include: tasks/platform/n7k/assert_changes_http.yaml
-    when: platform is match('N7K')
-
-  - include: tasks/platform/n5k/assert_changes_http.yaml
-    when: platform is match('N5K')
-
-  - include: tasks/platform/default/assert_changes_http.yaml
-    when: platform is not search('N35|N5K|N6K|N7K')
-
-  - name: Configure NXAPI HTTP again
-    nxos_nxapi: *configure_http
-    register: result
-
-  - name: Assert configuration is idempotent
-    assert: *assert_false
-
-  always:
-  - name: Cleanup - Disable NXAPI
-    nxos_nxapi:
-      state: absent
-    register: result
-
-  - name: Cleanup - Re-enable NXAPI
-    nxos_nxapi:
-      state: present
-    register: result
-
-  - debug: msg="END cli/configure.yaml"
diff --git a/test/integration/targets/nxos_nxapi/tests/cli/disable.yaml b/test/integration/targets/nxos_nxapi/tests/cli/disable.yaml
deleted file mode 100644
index 58ce878bed..0000000000
--- a/test/integration/targets/nxos_nxapi/tests/cli/disable.yaml
+++ /dev/null
@@ -1,31 +0,0 @@
----
-- debug: msg="START cli/disable.yaml"
-
-- name: Disable NXAPI
-  nxos_nxapi:
-    state: absent
-  register: result
-
-- name: Check NXAPI state
-  nxos_command:
-    commands:
-      - show feature | grep nxapi
-  register: result
-
-- name: Assert NXAPI is disabled
-  assert:
-    that:
-      result.stdout[0]  is search('disabled')
-
-- name: Disable NXAPI again
-  nxos_nxapi:
-    state:
-      absent
-  register: result
-
-- name: Assert idempotence
-  assert:
-    that:
-      result.changed == false
-
-- debug: msg="END cli/disable.yaml"
diff --git a/test/integration/targets/nxos_nxapi/tests/cli/enable.yaml b/test/integration/targets/nxos_nxapi/tests/cli/enable.yaml
deleted file mode 100644
index f15bfe9c3f..0000000000
--- a/test/integration/targets/nxos_nxapi/tests/cli/enable.yaml
+++ /dev/null
@@ -1,34 +0,0 @@
----
-- debug: msg="START cli/enable.yaml"
-
-- name: Setup - put NXAPI in stopped state
-  nxos_nxapi:
-      state: absent
-  register: result
-
-- name: Enable NXAPI
-  nxos_nxapi:
-      state: present
-  register: result
-
-- name: Check NXAPI state
-  nxos_command:
-      commands:
-          - show feature | grep nxapi
-  register: result
-
-- name: Assert NXAPI is enabled
-  assert:
-      that: result.stdout[0]  is search('enabled')
-
-- name: Enable NXAPI again
-  nxos_nxapi:
-  register: result
-
-- name: Assert idempotence
-  assert:
-    that:
-      result.changed == false
-
-
-- debug: msg="END cli/enable.yaml"
diff --git a/test/integration/targets/nxos_nxapi/tests/cli/nxapi_ssl.yaml b/test/integration/targets/nxos_nxapi/tests/cli/nxapi_ssl.yaml
deleted file mode 100644
index eeace84f95..0000000000
--- a/test/integration/targets/nxos_nxapi/tests/cli/nxapi_ssl.yaml
+++ /dev/null
@@ -1,246 +0,0 @@
----
-- block:
-  - debug: msg="START cli/nxapi_ssl.yaml"
-
-  - name: Configure NXAPI HTTPs w/weak ciphers
-    nxos_nxapi: &configure_https_weak_ciphers
-      enable_https: yes 
-      enable_sandbox: "{{nxapi_sandbox_option|default(omit)}}"
-      ssl_strong_ciphers: no
-    register: result
-
-  - nxos_command:
-      commands:
-        - show run all | inc nxapi | inc ciphers
-    register: result
-
-  - name: Assert weak ciphers configuration
-    assert: &weak_ciphers
-      that:
-         - result.stdout_lines[0][0] == 'nxapi ssl ciphers weak'
-
-  - name: Configure NXAPI HTTP w/weak ciphers again
-    nxos_nxapi: *configure_https_weak_ciphers
-    register: result
-
-  - name: Assert configuration is idempotent
-    assert: &assert_false
-      that:
-        - result.changed == false
-
-  - name: Configure NXAPI HTTPs w/strong ciphers
-    nxos_nxapi: &configure_https_strong_ciphers
-      enable_https: yes 
-      enable_sandbox: "{{nxapi_sandbox_option|default(omit)}}"
-      ssl_strong_ciphers: yes
-    register: result
-
-  - nxos_command:
-      commands:
-        - show run all | inc nxapi | inc ciphers
-    register: result
-
-  - name: Assert strong ciphers configuration
-    assert: &strong_ciphers
-      that:
-         - result.stdout_lines[0][0] == 'no nxapi ssl ciphers weak'
-
-  - name: Configure NXAPI HTTPs w/strong ciphers again
-    nxos_nxapi: *configure_https_strong_ciphers
-    register: result
-
-  - name: Assert configuration is idempotent
-    assert: *assert_false
-
-  - name: Configure NXAPI HTTPs w/default TLSv1
-    nxos_nxapi: &configure_https_default
-      enable_https: yes
-      enable_sandbox: "{{nxapi_sandbox_option|default(omit)}}"
-    register: result
-
-  - nxos_command:
-      commands:
-        - show run all | inc nxapi | inc protocols
-    register: result
-
-  - name: Assert NXAPI HTTPs w/default TLSv1 configuration
-    assert: &default_configuration
-      that:
-         - result.stdout_lines[0][0] == 'nxapi ssl protocols TLSv1'
-
-  - name: Configure NXAPI HTTPs w/default again
-    nxos_nxapi: *configure_https_default
-    register: result
-
-  - name: Assert configuration is idempotent
-    assert: *assert_false
-
-  - name: Configure NXAPI HTTPs TLSv1.1 -default TLSv1
-    nxos_nxapi: &configure_https_tlsv1_1
-      enable_https: yes
-      enable_sandbox: "{{nxapi_sandbox_option|default(omit)}}"
-      tlsv1_1: yes
-      tlsv1_0: no
-    register: result
-
-  - nxos_command:
-      commands:
-        - show run all | inc nxapi | inc protocols
-    register: result
-
-  - name: Assert NXAPI HTTPs w/TLSv1.1 configuration
-    assert: &tlsv1_1_configuration
-      that:
-         - result.stdout_lines[0][0] == 'nxapi ssl protocols TLSv1.1'
-
-  - name: Configure NXAPI HTTPs w/TLSv1.1 -default TLSv1 again
-    nxos_nxapi: *configure_https_tlsv1_1
-    register: result
-
-  - name: Assert configuration is idempotent
-    assert: *assert_false
-
-  - name: Configure NXAPI HTTPs TLSv1.2 -default TLSv1
-    nxos_nxapi: &configure_https_tlsv1_2
-      enable_https: yes
-      enable_sandbox: "{{nxapi_sandbox_option|default(omit)}}"
-      tlsv1_2: yes
-      tlsv1_0: no
-    register: result
-  
-  - nxos_command:
-      commands:
-        - show run all | inc nxapi | inc protocols
-    register: result
-
-  - name: Assert NXAPI HTTPs w/TLSv1.2 configuration
-    assert: &tlsv1_2_configuration
-      that:
-         - result.stdout_lines[0][0] == 'nxapi ssl protocols TLSv1.2'
-
-  - name: Configure NXAPI HTTPs w/TLSv1.2 -default TLSv1 again
-    nxos_nxapi: *configure_https_tlsv1_2
-    register: result
-
-  - name: Assert configuration is idempotent
-    assert: *assert_false
-
-  - name: Configure NXAPI HTTPs w/TLS1.2 +default TLSv1
-    nxos_nxapi: &configure_https_tlsv1_2_default
-      enable_https: yes
-      enable_sandbox: "{{nxapi_sandbox_option|default(omit)}}"
-      ssl_strong_ciphers: yes
-      tlsv1_2: yes
-    register: result
-
-  - nxos_command:
-      commands:
-        - show run all | inc nxapi | inc protocols
-    register: result
-
-  - name: Assert NXAPI HTTPs w/TLS1.2 +default TLSv1 configuration
-    assert: &tlsv1_2_default_configuration
-      that:
-         - result.stdout_lines[0][0] == 'nxapi ssl protocols TLSv1 TLSv1.2'
-
-  - name: Configure NXAPI HTTPs w/TLS1.2 again
-    nxos_nxapi: *configure_https_tlsv1_2_default
-    register: result
-
-  - name: Assert configuration is idempotent
-    assert: *assert_false
-
-  - name: Configure NXAPI HTTPs w/TLS1.2 TLS1.1 -default TLSv1
-    nxos_nxapi: &configure_https_tlsv1_2_tlsv1_1
-      enable_https: yes
-      enable_sandbox: "{{nxapi_sandbox_option|default(omit)}}"
-      ssl_strong_ciphers: yes
-      tlsv1_0: no
-      tlsv1_1: yes
-      tlsv1_2: yes
-    register: result
-
-  - nxos_command:
-      commands:
-        - show run all | inc nxapi | inc protocols
-    register: result
-
-  - name: Assert NXAPI HTTPs w/TLS1.2 TLS1.2 -default TLSv1 configuration
-    assert: &tlsv1_2_tlsv1_1_configuration
-      that:
-         - result.stdout_lines[0][0] == 'nxapi ssl protocols TLSv1.1 TLSv1.2'
-
-  - name: Configure NXAPI HTTPs w/TLS1.2 TLS1.1 -default TLSv1 again
-    nxos_nxapi: *configure_https_tlsv1_2_tlsv1_1
-    register: result
-
-  - name: Assert configuration is idempotent
-    assert: *assert_false
-
-  - name: Configure NXAPI HTTPs w/TLS1.2 TLS1.1 +default TLSv1
-    nxos_nxapi: &configure_https_tlsv1_2_tlsv1_1_default
-      enable_https: yes
-      enable_sandbox: "{{nxapi_sandbox_option|default(omit)}}"
-      ssl_strong_ciphers: yes
-      tlsv1_1: yes
-      tlsv1_2: yes
-    register: result
-
-  - nxos_command:
-      commands:
-        - show run all | inc nxapi | inc protocols
-    register: result
-
-  - name: Assert NXAPI HTTPs w/TLS1.2 TLS1.1 +default TLSv1 configuration
-    assert: &tlsv1_2_tlsv1_1_default_configuration
-      that:
-         - result.stdout_lines[0][0] == 'nxapi ssl protocols TLSv1 TLSv1.1 TLSv1.2'
-
-  - name: Configure NXAPI HTTPs w/TLS1.2 TLS1.1 +default TLSv1 again
-    nxos_nxapi: *configure_https_tlsv1_2_tlsv1_1_default
-    register: result
-
-  - name: Assert configuration is idempotent
-    assert: *assert_false
-
-  - name: Configure NXAPI HTTPs with explicit TLS1.2 TLS1.1 TLSv1
-    nxos_nxapi: &configure_https_tlsv1_2_tlsv1_1_tlsv1_0
-      enable_https: yes
-      enable_sandbox: "{{nxapi_sandbox_option|default(omit)}}"
-      ssl_strong_ciphers: yes
-      tlsv1_0: yes
-      tlsv1_1: yes
-      tlsv1_2: yes
-    register: result
-
-  - nxos_command:
-      commands:
-        - show run all | inc nxapi | inc protocols
-    register: result
-
-  - name: Assert NXAPI HTTPs w/TLS1.2 TLS1.2 TLSv1 configuration
-    assert: &tlsv1_2_tlsv1_1_tlsv1_0_configuration
-      that:
-         - result.stdout_lines[0][0] == 'nxapi ssl protocols TLSv1 TLSv1.1 TLSv1.2'
-
-  - name: Configure NXAPI HTTPs w/TLS1.2 TLS1.1 TLSv1 again
-    nxos_nxapi: *configure_https_tlsv1_2_tlsv1_1_tlsv1_0
-    register: result
-
-  - name: Assert configuration is idempotent
-    assert: *assert_false
-
-  always:
-  - name: Cleanup - Disable NXAPI
-    nxos_nxapi:
-      state: absent
-    register: result
-
-  - name: Cleanup - Re-enable NXAPI
-    nxos_nxapi:
-      state: present
-    register: result
-
-  - debug: msg="END cli/nxapi_ssl.yaml"
-
-  when: (platform is match("N9K") or platform is match("N3K") or platform is match("N9K-F") or platform is match("N35") or platform is match("N3L")) and major_version is version('9.2', '>=')
diff --git a/test/integration/targets/nxos_nxapi/tests/nxapi/badtransport.yaml b/test/integration/targets/nxos_nxapi/tests/nxapi/badtransport.yaml
deleted file mode 100644
index ebd5bf462c..0000000000
--- a/test/integration/targets/nxos_nxapi/tests/nxapi/badtransport.yaml
+++ /dev/null
@@ -1,17 +0,0 @@
----
-- debug: msg="START nxapi/badtransport.yaml"
-
-- name: Sending transport other than cli should fail
-  nxos_nxapi:
-    enable_http: no
-    enable_sandbox: no
-    https_port: 9443
-    provider: "{{ nxapi }}"
-  register: result
-  ignore_errors: yes
-
-- assert:
-     that:
-        - result.failed and result.msg is search('Transport')
-
-- debug: msg="END nxapi/badtransport.yaml"
diff --git a/test/integration/targets/nxos_nxapi_transports/defaults/main.yaml b/test/integration/targets/nxos_nxapi_transports/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_nxapi_transports/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_nxapi_transports/meta/main.yml b/test/integration/targets/nxos_nxapi_transports/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_nxapi_transports/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_nxapi_transports/tasks/main.yaml b/test/integration/targets/nxos_nxapi_transports/tasks/main.yaml
deleted file mode 100644
index 7b3640c35e..0000000000
--- a/test/integration/targets/nxos_nxapi_transports/tasks/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_nxapi_transports/tasks/nxapi.yaml b/test/integration/targets/nxos_nxapi_transports/tasks/nxapi.yaml
deleted file mode 100644
index 1d4dc15723..0000000000
--- a/test/integration/targets/nxos_nxapi_transports/tasks/nxapi.yaml
+++ /dev/null
@@ -1,24 +0,0 @@
----
-
-- block:
-
-  - set_fact:
-      tls:
-        - [ yes, no, no ]
-        - [ no, yes, no ]
-        - [ no, no, yes ]
-  - set_fact:
-      ciphers:
-        - yes
-        - no
-
-  - name: NXAPI various transport tests with different TLS and ciphers 
-    vars:
-      tlsv1_2: "{{ item[0][0] }}"
-      tlsv1_1: "{{ item[0][1] }}"
-      tlsv1_0: "{{ item[0][2] }}"
-      ssl_strong_ciphers: "{{ item[1] }}"
-    include: targets/nxos_nxapi_transports/tests/nxapi/assert_test.yaml
-    loop: "{{ tls | product(ciphers) | list }}"
-
-  when: (platform is match("N9K") or platform is match("N3K") or platform is match("N9K-F") or platform is match("N35") or platform is match("N3L")) and major_version is version('9.2', '>=')
diff --git a/test/integration/targets/nxos_nxapi_transports/tests/nxapi/assert_test.yaml b/test/integration/targets/nxos_nxapi_transports/tests/nxapi/assert_test.yaml
deleted file mode 100644
index d1a09cb92d..0000000000
--- a/test/integration/targets/nxos_nxapi_transports/tests/nxapi/assert_test.yaml
+++ /dev/null
@@ -1,38 +0,0 @@
-- block:
-
-  - debug: msg="START nxapi/setup_test.yaml"
-
-  - name: "Configure NXAPI tlsv1_2={{ tlsv1_2 }}, tlsv1_1={{ tlsv1_1 }}, tlsv1_0={{ tlsv1_0 }}, ssl_strong_ciphers={{ ssl_strong_ciphers }}"
-    nxos_nxapi:
-      enable_http: no
-      enable_https: yes
-      https_port: 443
-      tlsv1_2: "{{ tlsv1_2 }}"
-      tlsv1_1: "{{ tlsv1_1 }}"
-      tlsv1_0: "{{ tlsv1_0 }}"
-      ssl_strong_ciphers: "{{ ssl_strong_ciphers }}"
-    connection: network_cli
-    register: result
-
-  - name: Assert NXAPI setup test  was successful
-    assert: &assert_false
-       that:
-          - "result.failed == false"
-
-  - name: Assert transports
-    include: targets/nxos_nxapi_transports/tests/nxapi/assert_transports.yaml
-
-  - debug: msg="END nxapi/setup_test.yaml"
-
-  always:
-  - name: Cleanup - Disable NXAPI
-    nxos_nxapi:
-      state: absent
-    connection: network_cli
-    register: result
-
-  - name: Cleanup - Re-enable NXAPI
-    nxos_nxapi:
-      state: present
-    connection: network_cli
-    register: result
diff --git a/test/integration/targets/nxos_nxapi_transports/tests/nxapi/assert_transports.yaml b/test/integration/targets/nxos_nxapi_transports/tests/nxapi/assert_transports.yaml
deleted file mode 100644
index 35c7ed2af4..0000000000
--- a/test/integration/targets/nxos_nxapi_transports/tests/nxapi/assert_transports.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-
-- nxos_command:
-    commands:
-      - show hostname
-  connection: httpapi
-  vars:
-    ansible_httpapi_use_ssl: yes
-    ansible_httpapi_validate_certs: no
-    ansible_httpapi_port: 443
-  register: result
-
-- name: Assert command over connection httpapi was successful
-  assert:
-     that:
-        - "result.failed == false"
-
-- nxos_command:
-    commands:
-      - show hostname
-    provider: "{{ nxapi_ssl }}"
-  register: result
-
-- name: Assert command over nxapi_ssl provider was successful
-  assert:
-     that:
-        - "result.failed == false"
diff --git a/test/integration/targets/nxos_ospf/defaults/main.yaml b/test/integration/targets/nxos_ospf/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_ospf/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_ospf/meta/main.yml b/test/integration/targets/nxos_ospf/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_ospf/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_ospf/tasks/cli.yaml b/test/integration/targets/nxos_ospf/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_ospf/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_ospf/tasks/main.yaml b/test/integration/targets/nxos_ospf/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_ospf/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_ospf/tasks/nxapi.yaml b/test/integration/targets/nxos_ospf/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_ospf/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_ospf/tests/common/sanity.yaml b/test/integration/targets/nxos_ospf/tests/common/sanity.yaml
deleted file mode 100644
index c6bcdfbc60..0000000000
--- a/test/integration/targets/nxos_ospf/tests/common/sanity.yaml
+++ /dev/null
@@ -1,51 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_ospf sanity test"
-
-- name: "Enable feature OSPF"
-  nxos_feature:
-    feature: ospf
-    state: enabled
-  ignore_errors: yes
-
-- block:
-  - name: Configure ospf
-    nxos_ospf: &config
-      ospf: 1
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_ospf: *config
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  rescue:
-  - name: "Disable feature OSPF"
-    nxos_feature:
-      feature: ospf
-      state: disabled
-    ignore_errors: yes
-
-  always:
-  - name: Unconfigure ospf
-    nxos_ospf: &unconfig
-      ospf: 1
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_ospf: *unconfig
-    register: result
-
-  - assert: *false
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_ospf sanity test"
diff --git a/test/integration/targets/nxos_ospf_vrf/defaults/main.yaml b/test/integration/targets/nxos_ospf_vrf/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_ospf_vrf/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_ospf_vrf/meta/main.yml b/test/integration/targets/nxos_ospf_vrf/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_ospf_vrf/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_ospf_vrf/tasks/cli.yaml b/test/integration/targets/nxos_ospf_vrf/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_ospf_vrf/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_ospf_vrf/tasks/main.yaml b/test/integration/targets/nxos_ospf_vrf/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_ospf_vrf/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_ospf_vrf/tasks/nxapi.yaml b/test/integration/targets/nxos_ospf_vrf/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_ospf_vrf/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_ospf_vrf/tests/common/sanity.yaml b/test/integration/targets/nxos_ospf_vrf/tests/common/sanity.yaml
deleted file mode 100644
index 00f8b7a02a..0000000000
--- a/test/integration/targets/nxos_ospf_vrf/tests/common/sanity.yaml
+++ /dev/null
@@ -1,133 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_ospf_vrf sanity test"
-
-- set_fact: def_met_default="default"
-  # CSCvi74876 Cannot remove default-metric
-  when: imagetag is not search("I7")
-
-- name: "Setup: disable features for initial cleanup"
-  nxos_feature:
-    feature: "{{ item }}"
-    state: disabled
-  loop: ['ospf', 'bfd']
-  ignore_errors: yes
-
-- name: "Enable features"
-  nxos_feature:
-    feature: "{{ item }}"
-    state: enabled
-  loop: ['ospf', 'bfd']
-
-- block:
-  - name: Configure ospf vrf
-    nxos_ospf_vrf: &config
-      ospf: 1
-      router_id: 192.0.2.1
-      timer_throttle_spf_start: 50
-      timer_throttle_spf_hold: 1000
-      timer_throttle_spf_max: 2000
-      timer_throttle_lsa_start: 60
-      timer_throttle_lsa_hold: 1100
-      timer_throttle_lsa_max: 3000
-      vrf: test
-      bfd: enable
-      passive_interface: true
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_ospf_vrf: *config
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Configure ospf vrf
-    nxos_ospf_vrf: &config1
-      ospf: 2
-      auto_cost: 5000
-      timer_throttle_spf_hold: 1100
-      timer_throttle_lsa_hold: 2220
-      timer_throttle_lsa_max: 2222
-      default_metric: 1000
-      log_adjacency: log
-      vrf: default
-      bfd: disable
-      passive_interface: true
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_ospf_vrf: *config1
-    register: result
-
-  - assert: *false
-
-  - name: Configure ospf vrf
-    nxos_ospf_vrf: &config2
-      ospf: 2
-      auto_cost: default
-      default_metric: "{{def_met_default|default(omit)}}"
-      log_adjacency: default
-      timer_throttle_spf_hold: default
-      passive_interface: false
-      vrf: default
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_ospf_vrf: *config2
-    register: result
-
-  - assert: *false
-
-  - name: Unconfigure ospf vrf
-    nxos_ospf_vrf: &unconfig1
-      ospf: 2
-      vrf: default
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_ospf_vrf: *unconfig1
-    register: result
-
-  - assert: *false
-    when: def_met_default is defined
-
-  - name: Unconfigure ospf vrf
-    nxos_ospf_vrf: &unconfig
-      ospf: 1
-      vrf: test
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_ospf_vrf: *unconfig
-    register: result
-
-  - assert: *false
-    when: def_met_default is defined
-
-  always:
-  - name: "Disable features"
-    nxos_feature:
-      feature: "{{ item }}"
-      state: disabled
-    loop: ['ospf', 'bfd']
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_ospf_vrf sanity test"
diff --git a/test/integration/targets/nxos_overlay_global/defaults/main.yaml b/test/integration/targets/nxos_overlay_global/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_overlay_global/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_overlay_global/meta/main.yml b/test/integration/targets/nxos_overlay_global/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_overlay_global/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_overlay_global/tasks/cli.yaml b/test/integration/targets/nxos_overlay_global/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_overlay_global/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_overlay_global/tasks/main.yaml b/test/integration/targets/nxos_overlay_global/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_overlay_global/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_overlay_global/tasks/nxapi.yaml b/test/integration/targets/nxos_overlay_global/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_overlay_global/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_overlay_global/tasks/platform/n7k/cleanup.yaml b/test/integration/targets/nxos_overlay_global/tasks/platform/n7k/cleanup.yaml
deleted file mode 100644
index 5f0fe44949..0000000000
--- a/test/integration/targets/nxos_overlay_global/tasks/platform/n7k/cleanup.yaml
+++ /dev/null
@@ -1,22 +0,0 @@
----
-- name: "Unconfigure VDC setting limit-resource module-type f3"
-  nxos_config:
-    commands:
-      - 'terminal dont-ask ; vdc {{ vdcid }} ;  no limit-resource module-type f3'
-    match: none
-  ignore_errors: yes
-
-- name: Previous command is asynchronous and can take a while.  Allow time for it to complete
-  pause:
-    seconds: 45
-
-- name: "Configure VDC setting allocate interface unallocated-interfaces"
-  nxos_config: &allocate
-    commands:
-      - 'terminal dont-ask ; vdc {{ vdcid }} ; allocate interface unallocated-interfaces'
-    match: none
-  ignore_errors: yes
-
-- name: Previous command is asynchronous can take a while.  Allow time for it to complete
-  pause:
-    seconds: 45
diff --git a/test/integration/targets/nxos_overlay_global/tasks/platform/n7k/setup.yaml b/test/integration/targets/nxos_overlay_global/tasks/platform/n7k/setup.yaml
deleted file mode 100644
index 886ab7b396..0000000000
--- a/test/integration/targets/nxos_overlay_global/tasks/platform/n7k/setup.yaml
+++ /dev/null
@@ -1,36 +0,0 @@
----
-- name: "Get default vdc id"
-  nxos_command:
-    commands: ['show vdc current-vdc | json']
-  register: vdcout
-
-- set_fact: vdcid="{{ vdcout.stdout_lines[0].name }}"
-
-- name: "Configure VDC setting limit-resource module-type f3"
-  nxos_config:
-    commands:
-      - "terminal dont-ask ; vdc {{ vdcid }} ;  limit-resource module-type f3"
-    match: none
-  ignore_errors: yes
-
-- name: Previous command is asynchronous and can take a while.  Allow time for it to complete
-  pause:
-    seconds: 45
-
-- name: "Configure VDC setting allocate interface unallocated-interfaces"
-  nxos_config: &allocate
-    commands:
-      - "terminal dont-ask ; vdc {{ vdcid }} ; allocate interface unallocated-interfaces"
-    match: none
-  ignore_errors: yes
-
-- name: Previous command is asynchronous and can take a while.  Allow time for it to complete
-  pause:
-    seconds: 45
-
-- name: "Configure Additional N7K requiste features"
-  nxos_config:
-    commands:
-      - feature-set fabric
-      - feature fabric forwarding
-    match: none
diff --git a/test/integration/targets/nxos_overlay_global/tests/common/sanity.yaml b/test/integration/targets/nxos_overlay_global/tests/common/sanity.yaml
deleted file mode 100644
index fe41bde90e..0000000000
--- a/test/integration/targets/nxos_overlay_global/tests/common/sanity.yaml
+++ /dev/null
@@ -1,97 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_overlay_global sanity test"
-
-- set_fact: overlay_global_supported="false"
-- set_fact: overlay_global_supported="true"
-  when: platform is search("N35NG|N7K|^N9K$") or
-        ( platform is match("N9k-F") and imagetag is version('F3', 'ne'))
-
-- debug: msg="Platform {{ platform }} running Image version {{ image_version }} supports nxos_overlay_global"
-  when: overlay_global_supported
-
-# Setup Block
-- block:
-  - name: "Enable nv overlay evpn"
-    nxos_evpn_global: &enable_evpn
-      nv_overlay_evpn: true
-
-  - name: "Apply N7K specific setup config"
-    include: tasks/platform/n7k/setup.yaml
-    when: platform is match('N7K')
-
-  - name: "Configure Additional N7K requiste features"
-    nxos_config:
-      commands:
-        - feature-set fabric
-        - feature fabric forwarding
-      match: none
-    when: platform is match('N7K')
-
-  - name: "Remove possibly existing mac"
-    nxos_overlay_global:
-      anycast_gateway_mac: "default"
-    ignore_errors: yes
-
-  when: overlay_global_supported
-
-# Test execution block
-- block:
-
-  - name: Configure overlay global
-    nxos_overlay_global: &configure
-      anycast_gateway_mac: "b.b.b"
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_overlay_global: *configure
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Update anycast gateway mac
-    nxos_overlay_global: &update
-      anycast_gateway_mac: "a.a.a"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_overlay_global: *update
-    register: result
-
-  - assert: *false
-
-
-  - name: Remove anycast gateway mac
-    nxos_overlay_global: &remove
-      anycast_gateway_mac: "default"
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_overlay_global: *remove
-    register: result
-
-  - assert: *false
-
-  when: overlay_global_supported
-
-  always:
-  - name: "Apply N7K specific cleanup config"
-    include: tasks/platform/n7k/cleanup.yaml
-    when: platform is match('N7K')
-
-  - name: "Disable nv overlay evpn"
-    nxos_evpn_global: &disable_evpn
-      nv_overlay_evpn: false
-    ignore_errors: yes
-    when: overlay_global_supported
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_overlay_global sanity test"
diff --git a/test/integration/targets/nxos_pim/defaults/main.yaml b/test/integration/targets/nxos_pim/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_pim/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_pim/meta/main.yml b/test/integration/targets/nxos_pim/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_pim/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_pim/tasks/cli.yaml b/test/integration/targets/nxos_pim/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_pim/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_pim/tasks/main.yaml b/test/integration/targets/nxos_pim/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_pim/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_pim/tasks/nxapi.yaml b/test/integration/targets/nxos_pim/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_pim/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_pim/tests/common/sanity.yaml b/test/integration/targets/nxos_pim/tests/common/sanity.yaml
deleted file mode 100644
index 7cf12b5eca..0000000000
--- a/test/integration/targets/nxos_pim/tests/common/sanity.yaml
+++ /dev/null
@@ -1,83 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_pim sanity test"
-
-- name: "Setup: Disable features"
-  nxos_feature: &disable_feature
-    feature: "{{ item }}"
-    state: disabled
-  ignore_errors: yes
-  loop:
-    - pim
-    - bfd
-
-- name: "Setup: Enable features"
-  nxos_feature:
-    feature: "{{ item }}"
-    state: enabled
-  loop:
-    - pim
-    - bfd
-
-- name: "Setup: Configure ssm_range none"
-  nxos_pim: &none
-    ssm_range: "none"
-
-- block:
-  - name: Initial config from none
-    nxos_pim: &configure
-      bfd: enable
-      ssm_range:
-        - "239.128.1.0/24"
-        - "224.0.0.0/8"
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: Initial config idempotence
-    nxos_pim: *configure
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Configure ssm_range default
-    nxos_pim: &conf_default
-      bfd: disable
-      ssm_range: "default"
-    register: result
-
-  - assert: *true
-
-  - name: ssm_range default idempotence
-    nxos_pim: *conf_default
-    register: result
-
-  - assert: *false
-
-  - name: Configure ssm_range none
-    nxos_pim: *none
-    register: result
-
-  - assert: *true
-
-  - meta: end_play
-  - name: ssm_range none idempotence
-    nxos_pim: *none
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: "Teardown: Disable features"
-    nxos_feature:
-      feature: "{{ item }}"
-      state: disabled
-    ignore_errors: yes
-    loop:
-      - pim
-      - bfd
-
-- debug: msg="END connection={{ ansible_connection }} nxos_pim sanity test"
diff --git a/test/integration/targets/nxos_pim_interface/defaults/main.yaml b/test/integration/targets/nxos_pim_interface/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_pim_interface/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_pim_interface/meta/main.yml b/test/integration/targets/nxos_pim_interface/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_pim_interface/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_pim_interface/tasks/cli.yaml b/test/integration/targets/nxos_pim_interface/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_pim_interface/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_pim_interface/tasks/main.yaml b/test/integration/targets/nxos_pim_interface/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_pim_interface/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_pim_interface/tasks/nxapi.yaml b/test/integration/targets/nxos_pim_interface/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_pim_interface/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_pim_interface/tests/common/sanity.yaml b/test/integration/targets/nxos_pim_interface/tests/common/sanity.yaml
deleted file mode 100644
index 90d8a6d2fb..0000000000
--- a/test/integration/targets/nxos_pim_interface/tests/common/sanity.yaml
+++ /dev/null
@@ -1,188 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_pim_interface sanity test"
-
-- name: "Setup: Disable features"
-  nxos_feature: &disable_feature
-    feature: "{{ item }}"
-    state: disabled
-  loop: ['pim', 'bfd']
-  ignore_errors: yes
-
-- name: "Setup: Enable features"
-  nxos_feature:
-    feature: "{{ item }}"
-    state: enabled
-  loop: ['pim', 'bfd']
-
-- set_fact: testint="{{ nxos_int1 }}"
-
-- name: "Setup: Put interface {{ testint }} into a default state"
-  nxos_config:
-    lines:
-      - "default interface {{ testint }}"
-  ignore_errors: yes
-
-- name: "Ensure {{testint}} is layer3"
-  nxos_interface:
-    interface: "{{ testint }}"
-    mode: layer3
-    description: 'Configured by Ansible - Layer3'
-    admin_state: 'up'
-    state: present
-
-- block:
-  - name: Configure nxos_pim_interface state absent
-    nxos_pim_interface: &pimabsent
-      interface: "{{ testint }}"
-      state: absent
-
-  - name: configure jp policy and type
-    nxos_pim_interface: &configjp
-      interface: "{{ testint }}"
-      jp_policy_in: JPIN
-      jp_policy_out: JPOUT
-      jp_type_in: routemap
-      jp_type_out: routemap
-      sparse: True
-      border: True
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: Check idempotence
-    nxos_pim_interface: *configjp
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: configure neighbor policy and rm
-    nxos_pim_interface: &confignpr
-      interface: "{{ testint }}"
-      neighbor_policy: NPR
-      neighbor_type: routemap
-    register: result
-
-  - assert: *true
-
-  - name: Check idempotence
-    nxos_pim_interface: *confignpr
-    register: result
-
-  - assert: *false
-
-  - pause:
-      seconds: 5
-
-  - name: configure neighbor policy and prefix
-    nxos_pim_interface: &confignpp
-      interface: "{{ testint }}"
-      neighbor_policy: NPPF
-      neighbor_type: prefix
-    register: result
-
-  - assert: *true
-
-  - name: Check idempotence
-    nxos_pim_interface: *confignpp
-    register: result
-
-  - assert: *false
-
-  - name: configure hello_auth_key
-    nxos_pim_interface: &confighak1
-      interface: "{{ testint }}"
-      hello_auth_key: password1
-    register: result
-
-  - assert: *true
-
-  - name: configure pim other params
-    nxos_pim_interface: &configo
-      interface: "{{ testint }}"
-      dr_prio: 10
-      hello_interval: 40
-      sparse: True
-      border: True
-      bfd: enable
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: Check idempotence
-    nxos_pim_interface: *configo
-    register: result
-
-  - assert: *false
-
-  - name: configure negative
-    nxos_pim_interface: &configno
-      interface: "{{ testint }}"
-      sparse: False
-      border: False
-      bfd: disable
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: Check idempotence
-    nxos_pim_interface: *configno
-    register: result
-
-  - assert: *false
-
-  - pause:
-      seconds: 5
-
-  - name: configure state default
-    nxos_pim_interface: &configdefault
-      interface: "{{ testint }}"
-      state: default
-    register: result
-
-  - assert: *true
-
-  - name: Check idempotence
-    nxos_pim_interface: *configdefault
-    register: result
-
-  - assert: *false
-
-  - name: configure border
-    nxos_pim_interface: &configb
-      interface: "{{ testint }}"
-      border: True
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: Check idempotence
-    nxos_pim_interface: *configb
-    register: result
-
-  - assert: *false
-
-  - name: configure state absent
-    nxos_pim_interface: *pimabsent
-    register: result
-
-  - assert: *true
-
-  - name: Check idempotence
-    nxos_pim_interface: *pimabsent
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: "Disable feature PIM"
-    nxos_feature: *disable_feature
-    loop: ['pim', 'bfd']
-
-- debug: msg="END connection={{ ansible_connection }} nxos_pim_interface sanity test"
diff --git a/test/integration/targets/nxos_pim_rp_address/defaults/main.yaml b/test/integration/targets/nxos_pim_rp_address/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_pim_rp_address/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_pim_rp_address/meta/main.yml b/test/integration/targets/nxos_pim_rp_address/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_pim_rp_address/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_pim_rp_address/tasks/cli.yaml b/test/integration/targets/nxos_pim_rp_address/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_pim_rp_address/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_pim_rp_address/tasks/main.yaml b/test/integration/targets/nxos_pim_rp_address/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_pim_rp_address/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_pim_rp_address/tasks/nxapi.yaml b/test/integration/targets/nxos_pim_rp_address/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_pim_rp_address/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_pim_rp_address/tests/common/configure.yaml b/test/integration/targets/nxos_pim_rp_address/tests/common/configure.yaml
deleted file mode 100644
index d5f5898dc6..0000000000
--- a/test/integration/targets/nxos_pim_rp_address/tests/common/configure.yaml
+++ /dev/null
@@ -1,215 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_pim_rp_address sanity"
-
-- block:
-  # platforms do not support bidir
-  - set_fact: bidir_true="true"
-  - set_fact: bidir_false="false"
-  when: platform is not search('N3L')
-
-- block:
-  # platforms can only remove rpa, cannot remove rpa+prefixlist or rpa+routemap
-  - set_fact: pim_prefix_list="pim_prefix_list"
-  - set_fact: pim_route_map="pim_route_map"
-  when: platform is not search('N3L|N7K')
-
-- block:
-  - name: "Disable feature PIM"
-    nxos_feature: &disable_feature
-      feature: pim
-      state: disabled
-
-  - name: "Enable feature PIM"
-    nxos_feature: &enable_feature
-      feature: pim
-      state: enabled
-
-  - name: 1.0 Configure rp_address + group_list
-    # This test should always run regardless of bidir support
-    nxos_pim_rp_address: &configgl
-      rp_address: "10.1.1.1"
-      group_list: "224.0.0.0/8"
-      bidir: "{{ bidir_true|default(omit) }}"
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: 1.0 Idempotence rp_address + group_list
-    nxos_pim_rp_address: *configgl
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - block: # bidir test
-    - name: 1.1 Configure rp_address + group_list (bidir_false)
-      nxos_pim_rp_address: &config11
-        rp_address: "10.1.1.1"
-        group_list: "224.0.0.0/8"
-        bidir: false
-        state: present
-      register: result
-
-    - assert: *true
-
-    - name: 1.1 Idempotence rp_address + group_list (bidir_false)
-      nxos_pim_rp_address: *config11
-      register: result
-
-    - assert: *false
-
-    - name: 1.2 Configure rp_address (bidir_true)
-      nxos_pim_rp_address: &config12
-        rp_address: "10.1.1.1"
-        bidir: true
-        state: present
-      register: result
-
-    - assert: *true
-
-    - name: 1.2 Idempotence rp_address (bidir_true)
-      nxos_pim_rp_address: *config12
-      register: result
-
-    - assert: *false
-
-    - name: 1.3 Configure rp_address (bidir_false)
-      nxos_pim_rp_address: &config13
-        rp_address: "10.1.1.1"
-        bidir: false
-        state: present
-      register: result
-
-    - assert: *true
-
-    - name: 1.3 Idempotence rp_address (bidir_false)
-      nxos_pim_rp_address: *config13
-      register: result
-
-    - assert: *false
-    when: bidir_true is defined
-
-  - name: 1.4 Remove rp_address + group_list
-    nxos_pim_rp_address: &config14
-      rp_address: "10.1.1.1"
-      group_list: "224.0.0.0/8"
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: 1.4 Idempotence remove rp_address + group_list
-    nxos_pim_rp_address: *config14
-    register: result
-
-  - assert: *false
-
-  - name: 2.0 Configure rp_address + prefix_list (bidir_true)
-    nxos_pim_rp_address: &config20
-      rp_address: "10.1.1.2"
-      prefix_list: "{{ pim_prefix_list|default(omit) }}"
-      bidir: "{{ bidir_true|default(omit) }}"
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: 2.0 Idempotence rp_address + prefix_list (bidir_true)
-    nxos_pim_rp_address: *config20
-    register: result
-
-  - assert: *false
-
-  - block: # bidir test
-    - name: 2.1 Configure rp_address + prefix_list (bidir_false)
-      nxos_pim_rp_address: &config21
-        rp_address: "10.1.1.2"
-        prefix_list: "{{ pim_prefix_list|default(omit) }}"
-        bidir: "{{ bidir_false|default(omit) }}"
-        state: present
-      register: result
-
-    - assert: *true
-
-    - name: 2.1 Idempotence rp_address + prefix_list (bidir_false)
-      nxos_pim_rp_address: *config21
-      register: result
-
-    - assert: *false
-    when: bidir_false is defined
-
-  - name: 2.2 Remove rp_address + prefix_list (bidir_false)
-    nxos_pim_rp_address: &config22
-      rp_address: "10.1.1.2"
-      prefix_list: "{{ pim_prefix_list|default(omit)}}"
-      bidir: "{{ bidir_false|default(omit)}}"
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: 2.2 Idempotence remove rp_address + prefix_list (bidir_false)
-    nxos_pim_rp_address: *config22
-    register: result
-
-  - assert: *false
-
-  - name: 3.0 Configure rp_address + route_map + (bidir_true)
-    nxos_pim_rp_address: &config30
-      rp_address: "10.1.1.3"
-      route_map: "{{ pim_route_map|default(omit)}}"
-      bidir: "{{ bidir_true|default(omit) }}"
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: 3.0 Idempotence rp_address + route_map + (bidir_true)
-    nxos_pim_rp_address: *config30
-    register: result
-
-  - assert: *false
-
-  - block: # bidir test
-    - name: 3.1 Configure rp_address + route_map (bidir_false)
-      nxos_pim_rp_address: &config31
-        rp_address: "10.1.1.3"
-        route_map: "{{ pim_route_map|default(omit)}}"
-        bidir: "{{ bidir_false|default(omit)}}"
-        state: present
-      register: result
-
-    - assert: *true
-
-    - name: 3.1 Idempotence rp_address + route_map
-      nxos_pim_rp_address: *config31
-      register: result
-
-    - assert: *false
-    when: bidir_false is defined
-
-  - name: 3.2 Remove rp_address + route_map (bidir_false)
-    nxos_pim_rp_address: &config32
-      rp_address: "10.1.1.3"
-      route_map: "{{ pim_route_map|default(omit)}}"
-      bidir: "{{ bidir_false|default(omit)}}"
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: 3.2 Idempotence remove rp_address + route_map (bidir_false)
-    nxos_pim_rp_address: *config32
-    register: result
-
-  - assert: *false
-
-  always:
-    - name: "Disable feature PIM"
-      nxos_feature: *disable_feature
-
-- debug: msg="END connection={{ ansible_connection }} nxos_pim_rp_address sanity"
diff --git a/test/integration/targets/nxos_reboot/defaults/main.yaml b/test/integration/targets/nxos_reboot/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_reboot/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_reboot/meta/main.yml b/test/integration/targets/nxos_reboot/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_reboot/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_reboot/tasks/cli.yaml b/test/integration/targets/nxos_reboot/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_reboot/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_reboot/tasks/main.yaml b/test/integration/targets/nxos_reboot/tasks/main.yaml
deleted file mode 100644
index 066027891a..0000000000
--- a/test/integration/targets/nxos_reboot/tasks/main.yaml
+++ /dev/null
@@ -1,5 +0,0 @@
----
-- include: cli.yaml
-  tags: cli
-- include: nxapi.yaml
-  tags: nxapi
diff --git a/test/integration/targets/nxos_reboot/tasks/nxapi.yaml b/test/integration/targets/nxos_reboot/tasks/nxapi.yaml
deleted file mode 100644
index 0014c8a485..0000000000
--- a/test/integration/targets/nxos_reboot/tasks/nxapi.yaml
+++ /dev/null
@@ -1,28 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
-  tags: nxapi_httpapi
diff --git a/test/integration/targets/nxos_reboot/tests/common/sanity.yaml b/test/integration/targets/nxos_reboot/tests/common/sanity.yaml
deleted file mode 100644
index 839026d534..0000000000
--- a/test/integration/targets/nxos_reboot/tests/common/sanity.yaml
+++ /dev/null
@@ -1,23 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_reboot sanity test"
-
-- debug: msg="***WARNING*** Remove meta end_play to verify this module ***WARNING***"
-
-- meta: end_play
-
-- block:
-  - name: Reboot Switch
-    nxos_reboot:
-      confirm: True
-    ignore_errors: yes
-
-  always:
-  - name: Wait for device to come back up
-    wait_for:
-      port: 22
-      state: started
-      timeout: 600
-      delay: 60
-      host: "{{ inventory_hostname }}"
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_reboot sanity test"
diff --git a/test/integration/targets/nxos_rollback/defaults/main.yaml b/test/integration/targets/nxos_rollback/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_rollback/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_rollback/meta/main.yml b/test/integration/targets/nxos_rollback/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_rollback/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_rollback/tasks/cli.yaml b/test/integration/targets/nxos_rollback/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_rollback/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_rollback/tasks/main.yaml b/test/integration/targets/nxos_rollback/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_rollback/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_rollback/tasks/nxapi.yaml b/test/integration/targets/nxos_rollback/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_rollback/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_rollback/tests/common/sanity.yaml b/test/integration/targets/nxos_rollback/tests/common/sanity.yaml
deleted file mode 100644
index fab64b5daf..0000000000
--- a/test/integration/targets/nxos_rollback/tests/common/sanity.yaml
+++ /dev/null
@@ -1,24 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_rollback sanity test"
-
-- name: delete existing checkpoint file
-  nxos_config: &delete
-    commands:
-      - terminal dont-ask
-      - delete backup.cfg
-    match: none
-  ignore_errors: yes
-
-- name: Create checkpoint file
-  nxos_rollback:
-    checkpoint_file: backup.cfg
-
-- name: rollback to the previously created checkpoint file
-  nxos_rollback:
-    rollback_to: backup.cfg
-
-- name: cleanup checkpoint file
-  nxos_config: *delete
-  ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_rollback sanity test"
diff --git a/test/integration/targets/nxos_rpm/defaults/main.yaml b/test/integration/targets/nxos_rpm/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_rpm/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_rpm/meta/main.yml b/test/integration/targets/nxos_rpm/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_rpm/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_rpm/tasks/cli.yaml b/test/integration/targets/nxos_rpm/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_rpm/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_rpm/tasks/main.yaml b/test/integration/targets/nxos_rpm/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_rpm/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_rpm/tasks/nxapi.yaml b/test/integration/targets/nxos_rpm/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_rpm/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_rpm/tests/common/sanity.yaml b/test/integration/targets/nxos_rpm/tests/common/sanity.yaml
deleted file mode 100644
index 971757452b..0000000000
--- a/test/integration/targets/nxos_rpm/tests/common/sanity.yaml
+++ /dev/null
@@ -1,151 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_rpm sanity test"
-
-- set_fact: smu_run="false"
-- set_fact: smu_run="true"
-  when: ((platform is search('N9K')) and (imagetag and (imagetag is version_compare('I2', 'ge'))))
-
-- set_fact: sdk_run="false"
-- set_fact: sdk_run="true"
-  when: ((platform is search('N9K')) and (imagetag and (imagetag is version_compare('I6', 'ge'))))
-
-# The smu and nxsdk packages MUST be present on the device before the tests are run.
-# The smu patch must be built to match the image version under test
-# Only run this test after replacing the pkg with proper rpm files
-
-- debug: msg="***WARNING*** Remove meta end_play to verify this module ***WARNING***"
-
-- meta: end_play
-
-- block:
-  - name: Install smu RPM
-    nxos_rpm: &tsmurpm
-      pkg: "nxos.sample-n9k_ALL-1.0.0-7.0.3.I6.1.lib32_n9000.rpm"
-    register: result
-
-  - assert: &true1
-      that:
-        - "result.changed == true"
-
-  - name: Check Idempotence
-    nxos_rpm: *tsmurpm
-    register: result
-
-  - assert: &false1
-      that:
-        - "result.changed == false"
-
-  - name: Remove smu RPM
-    nxos_rpm: &rsmurpm
-      pkg: "nxos.sample-n9k_ALL-1.0.0-7.0.3.I6.1.lib32_n9000.rpm"
-      state: absent
-    register: result
-
-  - assert: *true1
-
-  - name: Check Idempotence
-    nxos_rpm: *rsmurpm
-    register: result
-
-  - assert: *false1
-
-  when: smu_run
-
-# healthMonitor-1.0-1.5.0.x86_64.rpm is avaibale at https://github.com/CiscoDevNet/NX-SDK/tree/master/rpm/RPMS
-- block:
-  - name: Install nxsdk RPM(aggregate)
-    nxos_rpm: &tsdkrpm
-      aggregate:
-          - { pkg: "healthMonitor-1.0-1.5.0.x86_64.rpm", file_system: "bootflash" }
-          - { pkg: "customCliApp-1.0-1.0.0.x86_64.rpm" }
-    register: result
-
-  - assert: &true2
-      that:
-        - "result.changed == true"
-
-  - name: Check Idempotence
-    nxos_rpm: *tsdkrpm
-    register: result
-
-  - assert: &false2
-      that:
-        - "result.changed == false"
-
-  - name: Remove nxsdk RPM(aggregate)
-    nxos_rpm: &rsdkrpm
-      aggregate:
-          - { pkg: "healthMonitor-1.0-1.5.0.x86_64.rpm" }
-          - { pkg: "customCliApp-1.0-1.0.0.x86_64.rpm" }
-      state: absent
-    register: result
-
-  - assert: *true2
-
-  - name: Check Idempotence
-    nxos_rpm: *rsdkrpm
-    register: result
-
-  - assert: *false2
-
-  when: sdk_run
-
-- block:
-  - name: Install reload smu RPM
-    nxos_rpm: &trsmurpm
-      pkg: "nxos.CSCve91311-n9k_ALL-1.0.0-7.0.3.I6.1.lib32_n9000.rpm"
-    register: result
-
-  - assert: *true1
-
-  - name: Wait for device to come back up
-    wait_for:
-      port: 22
-      state: started
-      timeout: 600
-      delay: 60
-      host: "{{ inventory_hostname_short }}"
-
-  - name: Continue with install reload smu RPM
-    nxos_rpm: *trsmurpm
-    register: result
-
-  - assert: *true1
-
-  - name: Check Idempotence
-    nxos_rpm: *trsmurpm
-    register: result
-
-  - assert: *false1
-
-  - name: Remove reload smu RPM
-    nxos_rpm: &rrsmurpm
-      pkg: "nxos.CSCve91311-n9k_ALL-1.0.0-7.0.3.I6.1.lib32_n9000.rpm"
-      state: absent
-    register: result
-
-  - assert: *true1
-
-  - name: Wait for device to come back up
-    wait_for:
-      port: 22
-      state: started
-      timeout: 600
-      delay: 60
-      host: "{{ inventory_hostname_short }}"
-
-  - name: Continue with remove reload smu RPM
-    nxos_rpm: *rrsmurpm
-    register: result
-
-  - assert: *true1
-
-  - name: Check Idempotence
-    nxos_rpm: *rrsmurpm
-    register: result
-
-  - assert: *false1
-
-  when: smu_run
-
-- debug: msg="END connection={{ ansible_connection }} nxos_rpm sanity test"
diff --git a/test/integration/targets/nxos_smoke/defaults/main.yaml b/test/integration/targets/nxos_smoke/defaults/main.yaml
deleted file mode 100644
index 9ef5ba5165..0000000000
--- a/test/integration/targets/nxos_smoke/defaults/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-testcase: "*"
-test_items: []
diff --git a/test/integration/targets/nxos_smoke/meta/main.yml b/test/integration/targets/nxos_smoke/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_smoke/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_smoke/tasks/cli.yaml b/test/integration/targets/nxos_smoke/tasks/cli.yaml
deleted file mode 100644
index e0f563729a..0000000000
--- a/test/integration/targets/nxos_smoke/tasks/cli.yaml
+++ /dev/null
@@ -1,33 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
-
-- name: run test cases (connection=local)
-  include: "{{ test_case_to_run }} ansible_connection=local connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_smoke/tasks/main.yaml b/test/integration/targets/nxos_smoke/tasks/main.yaml
deleted file mode 100644
index b165a5f6e1..0000000000
--- a/test/integration/targets/nxos_smoke/tasks/main.yaml
+++ /dev/null
@@ -1,14 +0,0 @@
----
-# Some of the tests in this suite change the hostname to switch.
-# This block/always ensures the hostname gets changed back to
-# the correct name.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  - { include: nxapi.yaml, tags: ['nxapi'] }
-
-  always:
-  - name: "Change hostname back to {{ inventory_hostname_short }}"
-    nxos_config:
-      lines:
-        - "hostname {{ inventory_hostname_short }}"
-      match: none
diff --git a/test/integration/targets/nxos_smoke/tasks/nxapi.yaml b/test/integration/targets/nxos_smoke/tasks/nxapi.yaml
deleted file mode 100644
index 04c99602e6..0000000000
--- a/test/integration/targets/nxos_smoke/tasks/nxapi.yaml
+++ /dev/null
@@ -1,33 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
-
-- name: run test cases (connection=local)
-  include: "{{ test_case_to_run }} ansible_connection=local connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_smoke/tests/cli/misc_tests.yaml b/test/integration/targets/nxos_smoke/tests/cli/misc_tests.yaml
deleted file mode 100644
index 9bb1435e61..0000000000
--- a/test/integration/targets/nxos_smoke/tests/cli/misc_tests.yaml
+++ /dev/null
@@ -1,17 +0,0 @@
----
-- debug: msg="START cli/misc_tests.yaml on connection={{ ansible_connection }}"
-
-
-- block:
-    # Test that transport values are properly ignored
-    - name: wrong transport specified
-      eos_command:
-          commands: show version
-          transport: nxapi
-
-    - name: wrong transport specified in provider
-      eos_command:
-          commands: show version
-          provider: "{{ nxapi }}"
-
-  when: "ansible_connection != 'local'"
diff --git a/test/integration/targets/nxos_smoke/tests/common/common_config.yaml b/test/integration/targets/nxos_smoke/tests/common/common_config.yaml
deleted file mode 100644
index c551f12cc3..0000000000
--- a/test/integration/targets/nxos_smoke/tests/common/common_config.yaml
+++ /dev/null
@@ -1,160 +0,0 @@
----
-# nxos_config -> NetworkConfig, dumps
-# nxos_static_route -> CustomNetworkConfig
-
-# hit NetworkConfig
-# Select interface for test
-- debug: msg="START connection={{ ansible_connection }} common/common_config.yaml"
-- debug: msg="Using provider={{ connection.transport }}"
-  when: ansible_connection == "local"
-
-- set_fact: intname="{{ nxos_int1 }}"
-
-- name: setup
-  nxos_config:
-    commands:
-      - no description
-      - no shutdown
-    parents:
-      - "interface {{ intname }}"
-    match: none
-    provider: "{{ connection }}"
-
-- name: collect any backup files
-  find: &backups
-    paths: "{{ role_path }}/backup"
-    pattern: "{{ inventory_hostname_short }}_config*"
-  connection: local
-  register: backup_files
-
-- name: delete backup files
-  file:
-    path: "{{ item.path }}"
-    state: absent
-  with_items: "{{backup_files.files|default([])}}"
-
-- name: configure device with config
-  nxos_config:
-    commands:
-      - description this is a test
-      - shutdown
-    parents:
-      - "interface {{ intname }}"
-    backup: yes
-    provider: "{{ connection }}"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "result.updates is defined"
-
-- name: collect any backup files
-  find: *backups
-  connection: local
-  register: backup_files
-
-- assert:
-    that:
-      - "backup_files.files is defined"
-
-# hit block/sublevel sections
-- name: setup
-  nxos_config: &clear
-    lines: no ip access-list test
-    provider: "{{ connection }}"
-    match: none
-  ignore_errors: yes
-
-# hit NetworkConfig._diff_exact
-- name: configure sub level command using block replace - exact
-  nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-    parents: ip access-list test
-    replace: block
-    provider: "{{ connection }}"
-    match: exact
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'ip access-list test' in result.updates"
-      - "'10 permit ip 192.0.2.1/32 any log' in result.updates"
-      - "'20 permit ip 192.0.2.2/32 any log' in result.updates"
-      - "'30 permit ip 192.0.2.3/32 any log' in result.updates"
-      - "'40 permit ip 192.0.2.4/32 any log' in result.updates"
-
-# hit NetworkConfig._diff_strict
-- name: configure sub level command using block replace strict
-  nxos_config:
-    lines:
-      - 10 permit ip 192.0.2.1/32 any log
-      - 20 permit ip 192.0.2.2/32 any log
-      - 30 permit ip 192.0.2.3/32 any log
-      - 40 permit ip 192.0.2.4/32 any log
-    parents: ip access-list test
-    replace: block
-    provider: "{{ connection }}"
-    match: strict
-  register: result
-
-- name: teardown
-  nxos_config: *clear
-
-# hit CustomNetworkConfig
-- block:
-  - name: create static route
-    nxos_static_route: &configure
-      prefix: "192.168.20.64/24"
-      next_hop: "192.0.2.3"
-      route_name: testing
-      pref: 100
-      tag: 5500
-      vrf: testing
-      provider: "{{ connection }}"
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: remove static route
-    nxos_static_route: &remove
-      prefix: "192.168.20.64/24"
-      next_hop: "192.0.2.3"
-      route_name: testing
-      pref: 100
-      tag: 5500
-      vrf: testing
-      state: absent
-      provider: "{{ connection }}"
-    register: result
-
-  - assert: *true
-
-  always:
-  - name: remove static route
-    nxos_static_route:
-      prefix: "192.168.20.64/24"
-      next_hop: "192.0.2.3"
-      route_name: testing
-      pref: 100
-      tag: 5500
-      vrf: testing
-      state: absent
-      provider: "{{ connection }}"
-    ignore_errors: yes
-
-  - name: remove static route aggregate
-    nxos_static_route:
-      aggregate:
-        - { prefix: "192.168.22.64/24", next_hop: "192.0.2.3" }
-        - { prefix: "192.168.24.64/24", next_hop: "192.0.2.3" }
-      state: absent
-      provider: "{{ connection }}"
-    ignore_errors: yes
diff --git a/test/integration/targets/nxos_smoke/tests/common/common_utils.yaml b/test/integration/targets/nxos_smoke/tests/common/common_utils.yaml
deleted file mode 100644
index db088061e4..0000000000
--- a/test/integration/targets/nxos_smoke/tests/common/common_utils.yaml
+++ /dev/null
@@ -1,102 +0,0 @@
----
-# nxos_command -> ComplexList
-# nxos_config -> to_list
-# nxos_interface -> conditional, remove_default_spec
-
-- debug: msg="START connection={{ ansible_connection }} common/common_utils.yaml"
-- debug: msg="Using provider={{ connection.transport }}"
-  when: ansible_connection == "local"
-
-# hit ComplexList
-- name: test contains operator
-  nxos_command:
-    commands:
-      - show version
-    provider: "{{ connection }}"
-
-# hit to_list()
-- name: setup
-  nxos_config:
-    lines: hostname switch
-    provider: "{{ connection }}"
-    match: none
-
-- name: configure top level command
-  nxos_config:
-    lines: hostname foo
-    provider: "{{ connection }}"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-      - "'hostname foo' in result.updates"
-
-- name: setup
-  nxos_config:
-    lines: hostname switch
-    provider: "{{ connection }}"
-    match: none
-
-# hit conditional()
-- set_fact: testint1="{{ nxos_int1 }}"
-- set_fact: testint2="{{ nxos_int2 }}"
-
-- name: "Setup: Put interfaces into a default state"
-  nxos_config:
-    lines:
-      - "default interface {{ testint1 }}"
-      - "default interface {{ testint2 }}"
-    provider: "{{ connection }}"
-  ignore_errors: yes
-
-  register: result
-
-- name: Check intent arguments
-  nxos_interface:
-    name: "{{ testint2 }}"
-    admin_state: up
-    tx_rate: ge(0)
-    rx_rate: ge(0)
-    provider: "{{ connection }}"
-  register: result
-
-- assert:
-    that:
-      - "result.failed == false"
-
-- name: Check intent arguments (failed condition)
-  nxos_interface:
-    name: "{{ testint2 }}"
-    admin_state: down
-    tx_rate: gt(0)
-    rx_rate: lt(0)
-    provider: "{{ connection }}"
-  ignore_errors: yes
-  register: result
-
-- assert:
-    that:
-      - "result.failed == true"
-      - "'tx_rate gt(0)' in result.failed_conditions"
-      - "'rx_rate lt(0)' in result.failed_conditions"
-
-- name: aggregate definition of interface
-  nxos_interface:
-    aggregate:
-      - { name: "{{ testint1 }}", description: "Test aggregation on first interface" }
-      - { name: "{{ testint2 }}", mode: layer3 }
-    provider: "{{ connection }}"
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: "TearDown: Put interfaces into a default state"
-  nxos_config:
-    lines:
-      - "default interface {{ testint1 }}"
-      - "default interface {{ testint2 }}"
-    provider: "{{ connection }}"
-  ignore_errors: yes
diff --git a/test/integration/targets/nxos_smoke/tests/common/misc_tests.yaml b/test/integration/targets/nxos_smoke/tests/common/misc_tests.yaml
deleted file mode 100644
index 6ae0b003ea..0000000000
--- a/test/integration/targets/nxos_smoke/tests/common/misc_tests.yaml
+++ /dev/null
@@ -1,30 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} common/misc_tests.yaml"
-- debug: msg="Using provider={{ connection.transport }}"
-  when: ansible_connection == "local"
-
-- name: hit conditional for lists of 10 or more commands
-  nxos_command:
-    commands:
-      - show hostname
-      - show hostname
-      - show hostname
-      - show hostname
-      - show hostname
-      - show hostname
-      - show hostname
-      - show hostname
-      - show hostname
-      - show hostname
-    provider: "{{ connection }}"
-  register: result
-
-- assert:
-    that:
-      - result.stdout|length == 10
-
-- name: combine with provider
-  nxos_command:
-    commands:
-      - show hostname
-    provider: "{{ connection | combine({'timeout': 500}) }}"
diff --git a/test/integration/targets/nxos_snapshot/defaults/main.yaml b/test/integration/targets/nxos_snapshot/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_snapshot/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_snapshot/meta/main.yml b/test/integration/targets/nxos_snapshot/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_snapshot/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_snapshot/tasks/cli.yaml b/test/integration/targets/nxos_snapshot/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_snapshot/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_snapshot/tasks/main.yaml b/test/integration/targets/nxos_snapshot/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_snapshot/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_snapshot/tasks/nxapi.yaml b/test/integration/targets/nxos_snapshot/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_snapshot/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_snapshot/tests/common/sanity.yaml b/test/integration/targets/nxos_snapshot/tests/common/sanity.yaml
deleted file mode 100644
index 025039dc55..0000000000
--- a/test/integration/targets/nxos_snapshot/tests/common/sanity.yaml
+++ /dev/null
@@ -1,128 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_snapshot sanity test"
-
-- set_fact: snapshot_run="true"
-
-- set_fact: snapshot_run="false"
-  when: titanium and (ansible_connection is match('nxapi'))
-
-- set_fact: snapshot_run="false"
-  when: platform is match('N35')
-
-- set_fact: add_sec="true"
-- set_fact: add_sec="false"
-  when: imagetag is search("D1")
-
-- block:
-  - name: create snapshot
-    nxos_snapshot: &crss1
-      action: create
-      snapshot_name: test_snapshot1
-      description: Ansible
-      save_snapshot_locally: True
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Conf Idempotence"
-    nxos_snapshot: *crss1
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - block:
-    - name: Add section
-      nxos_snapshot: &add
-        action: add
-        section: myshow
-        show_command: show ip interface brief
-        row_id: ROW_intf
-        element_key1: intf-name
-        element_key2: intf-name
-      register: result
-
-    - assert: *true
-  
-    - name: "Conf Idempotence"
-      nxos_snapshot: *add
-      register: result
-
-    - assert: *false
-
-    when: add_sec
-
-  - name: create another snapshot
-    nxos_snapshot: &crss2
-      action: create
-      snapshot_name: test_snapshot2
-      description: row
-      section: myshow
-      show_command: show ip interface brief
-      row_id: ROW_intf
-      element_key1: intf-name
-    register: result
-
-  - assert: *true
-  
-  - name: "Conf Idempotence"
-    nxos_snapshot: *crss2
-    register: result
-
-  - assert: *false
-
-  - name: compare snapshots
-    nxos_snapshot:
-      action: compare
-      snapshot1: test_snapshot1
-      snapshot2: test_snapshot2
-      comparison_results_file: compare_snapshots.txt
-      compare_option: summary
-      path: '.'
-
-  - name: delete snapshot
-    nxos_snapshot: &del
-      snapshot_name: test_snapshot2
-      action: delete
-    register: result
-
-  - assert: *true
-  
-  - name: "Conf Idempotence"
-    nxos_snapshot: *del
-    register: result
-
-  - assert: *false
-
-  - name: delete all snapshots
-    nxos_snapshot: &delall
-      action: delete_all
-    register: result
-
-  - assert: *true
-  
-  - name: "Conf Idempotence"
-    nxos_snapshot: *delall
-    register: result
-
-  - assert: *false
-
-  when: snapshot_run
-
-  always:
-  - name: delete all sections
-    nxos_config:
-      commands:
-        - snapshot section delete myshow
-      match: none
-    ignore_errors: yes
-
-  - name: delete all snapshots
-    nxos_snapshot:
-      action: delete_all
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_snapshot sanity test"
diff --git a/test/integration/targets/nxos_snmp_community/defaults/main.yaml b/test/integration/targets/nxos_snmp_community/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_snmp_community/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_snmp_community/meta/main.yml b/test/integration/targets/nxos_snmp_community/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_snmp_community/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_snmp_community/tasks/cli.yaml b/test/integration/targets/nxos_snmp_community/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_snmp_community/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_snmp_community/tasks/main.yaml b/test/integration/targets/nxos_snmp_community/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_snmp_community/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_snmp_community/tasks/nxapi.yaml b/test/integration/targets/nxos_snmp_community/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_snmp_community/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_snmp_community/tests/common/sanity.yaml b/test/integration/targets/nxos_snmp_community/tests/common/sanity.yaml
deleted file mode 100644
index 468fd40809..0000000000
--- a/test/integration/targets/nxos_snmp_community/tests/common/sanity.yaml
+++ /dev/null
@@ -1,138 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_snmp_community sanity test"
-
-- name: Setup - Remove snmp_community if configured
-  nxos_snmp_community: &remove
-    community: TESTING7
-    group: network-operator
-    state: absent 
-  ignore_errors: yes
-
-- block:
-
-  - name: Configure snmp_community group
-    nxos_snmp_community: &config
-      community: TESTING7
-      group: network-operator
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: Idempotence Check
-    nxos_snmp_community: *config
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Change snmp_community group
-    nxos_snmp_community: &chg
-      community: TESTING7
-      group: network-admin
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_snmp_community: *chg
-    register: result
-
-  - assert: *false
-
-  - name: Remove snmp_community
-    nxos_snmp_community: *remove
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_snmp_community: *remove
-    register: result
-
-  - assert: *false
-
-  - name: Configure snmp_community access read-only
-    nxos_snmp_community: &configaccess
-      community: TESTING7
-      access: ro
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_snmp_community: *configaccess
-    register: result
-
-  - assert: *false
-
-  - name: Remove snmp_community
-    nxos_snmp_community: *remove
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_snmp_community: *remove
-    register: result
-
-  - assert: *false
-
-  - name: Configure snmp_community access read-write
-    nxos_snmp_community: &configaccessrw
-      community: TESTING7
-      access: rw
-      acl: ansible_acl
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_snmp_community: *configaccessrw
-    register: result
-
-  - assert: *false
-
-  - name: Change acl
-    nxos_snmp_community: &chgacl
-      community: TESTING7
-      access: rw
-      acl: new_acl
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_snmp_community: *chgacl
-    register: result
-
-  - assert: *false
-
-  - name: Remove acl
-    nxos_snmp_community: &removeacl
-      community: TESTING7
-      access: rw
-      acl: default
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_snmp_community: *removeacl
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: Cleanup
-    nxos_snmp_community: *remove
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_snmp_community sanity test"
diff --git a/test/integration/targets/nxos_snmp_contact/defaults/main.yaml b/test/integration/targets/nxos_snmp_contact/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_snmp_contact/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_snmp_contact/meta/main.yml b/test/integration/targets/nxos_snmp_contact/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_snmp_contact/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_snmp_contact/tasks/cli.yaml b/test/integration/targets/nxos_snmp_contact/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_snmp_contact/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_snmp_contact/tasks/main.yaml b/test/integration/targets/nxos_snmp_contact/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_snmp_contact/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_snmp_contact/tasks/nxapi.yaml b/test/integration/targets/nxos_snmp_contact/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_snmp_contact/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_snmp_contact/tests/common/sanity.yaml b/test/integration/targets/nxos_snmp_contact/tests/common/sanity.yaml
deleted file mode 100644
index d43e60c2a4..0000000000
--- a/test/integration/targets/nxos_snmp_contact/tests/common/sanity.yaml
+++ /dev/null
@@ -1,59 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_snmp_community sanity test"
-
-- name: Setup - Remove snmp_contact if configured
-  nxos_snmp_contact: &remove
-    contact: Test
-    state: absent 
-
-- block:
-
-  - name: Configure snmp contact
-    nxos_snmp_contact: &config
-      contact: Testing
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: Idempotence Check
-    nxos_snmp_contact: *config
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Change snmp contact
-    nxos_snmp_contact: &config1
-      contact: Test
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_snmp_contact: *config1
-    register: result
-
-  - assert: *false
-
-  - name: Remove snmp contact
-    nxos_snmp_contact: *remove
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_snmp_contact: *remove
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: Cleanup 
-    nxos_snmp_contact: *remove
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_snmp_community sanity test"
diff --git a/test/integration/targets/nxos_snmp_host/defaults/main.yaml b/test/integration/targets/nxos_snmp_host/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_snmp_host/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_snmp_host/meta/main.yml b/test/integration/targets/nxos_snmp_host/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_snmp_host/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_snmp_host/tasks/cli.yaml b/test/integration/targets/nxos_snmp_host/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_snmp_host/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_snmp_host/tasks/main.yaml b/test/integration/targets/nxos_snmp_host/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_snmp_host/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_snmp_host/tasks/nxapi.yaml b/test/integration/targets/nxos_snmp_host/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_snmp_host/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_snmp_host/tests/common/sanity_snmp_v1_trap.yaml b/test/integration/targets/nxos_snmp_host/tests/common/sanity_snmp_v1_trap.yaml
deleted file mode 100644
index dd50e0719d..0000000000
--- a/test/integration/targets/nxos_snmp_host/tests/common/sanity_snmp_v1_trap.yaml
+++ /dev/null
@@ -1,123 +0,0 @@
----
-- set_fact: snmp_type="trap"
-- set_fact: snmp_version="v1"
-
-- debug: msg="START connection={{ ansible_connection }} nxos_snmp_host {{ snmp_type }} {{ snmp_version }} sanity test"
-
-# Select interface for test
-- set_fact: intname="{{ nxos_int1 }}"
-  when: platform is not search('N5K|N6K')
-
-
-- name: Setup - Remove snmp_host if configured
-  nxos_snmp_host: &remove
-    snmp_host: 192.0.2.3
-    community: TESTING
-    version: "{{ snmp_version }}"
-    snmp_type: "{{ snmp_type }}"
-    vrf: management
-    vrf_filter: management
-    src_intf: "{{ intname|default(omit) }}"
-    udp: 222
-    state: absent
-  ignore_errors: yes
-
-- block:
-
-  - name: Configure snmp host
-    nxos_snmp_host: &config
-      snmp_host: 192.0.2.3
-      community: TESTING
-      version: "{{ snmp_version }}"
-      snmp_type: "{{ snmp_type }}"
-      vrf: management
-      vrf_filter: management
-      src_intf: "{{ intname|default(omit) }}"
-      udp: 222
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: Idempotence Check
-    nxos_snmp_host: *config
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - block:
-    - name: Add another vrf to filter
-      nxos_snmp_host: &config1
-        snmp_host: 192.0.2.3
-        vrf_filter: default
-        udp: 222
-        state: present
-      register: result
-
-    - assert: *true
-
-    - name: Idempotence Check
-      nxos_snmp_host: *config1
-      register: result
-
-    - assert: *false
-    when: platform is not search('N35|N5K|N6K')
-
-  - name: remove some configuration
-    nxos_snmp_host: &rem1
-      snmp_host: 192.0.2.3
-      udp: 222
-      src_intf: "{{ intname|default(omit) }}"
-      vrf: management
-      vrf_filter: management
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_snmp_host: *rem1
-    register: result
-
-  - assert: *false
-
-  - block:
-    - name: remove some more configuration
-      nxos_snmp_host: &rem2
-        snmp_host: 192.0.2.3
-        udp: 222
-        vrf_filter: default
-        state: absent
-      register: result
-
-    - assert: *true
-
-    - name: Idempotence Check
-      nxos_snmp_host: *rem2
-      register: result
-
-    - assert: *false
-    when: platform is not search('N35|N5K|N6K')
-
-
-  - name: Cleanup
-    nxos_snmp_host: *remove
-    register: result
-
-  - assert: *true
-
-  - name: Cleanup Idempotence
-    nxos_snmp_host: *remove
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: Cleanup
-    nxos_snmp_host: *remove
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_snmp_host {{ snmp_type }} {{ snmp_version }} sanity test"
diff --git a/test/integration/targets/nxos_snmp_host/tests/common/sanity_snmp_v2_inform.yaml b/test/integration/targets/nxos_snmp_host/tests/common/sanity_snmp_v2_inform.yaml
deleted file mode 100644
index e3b9fa7faf..0000000000
--- a/test/integration/targets/nxos_snmp_host/tests/common/sanity_snmp_v2_inform.yaml
+++ /dev/null
@@ -1,121 +0,0 @@
----
-- set_fact: snmp_type="inform"
-- set_fact: snmp_version="v2c"
-
-- debug: msg="START connection={{ ansible_connection }} nxos_snmp_host {{ snmp_type }} {{ snmp_version }} sanity test"
-
-# Select interface for test
-- set_fact: intname="{{ nxos_int1 }}"
-  when: platform is not search('N5K|N6K')
-
-- name: Setup - Remove snmp_host if configured
-  nxos_snmp_host: &remove
-    snmp_host: 192.0.2.3
-    community: TESTING
-    version: "{{ snmp_version }}"
-    snmp_type: "{{ snmp_type }}"
-    vrf: management
-    vrf_filter: management
-    src_intf: "{{ intname|default(omit) }}"
-    udp: 222
-    state: absent
-  ignore_errors: yes
-
-- block:
-
-  - name: Configure snmp host
-    nxos_snmp_host: &config
-      snmp_host: 192.0.2.3
-      community: TESTING
-      version: "{{ snmp_version }}"
-      snmp_type: "{{ snmp_type }}"
-      vrf: management
-      vrf_filter: management
-      src_intf: "{{ intname|default(omit) }}"
-      udp: 222
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: Idempotence Check
-    nxos_snmp_host: *config
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - block:
-    - name: Add another vrf to filter
-      nxos_snmp_host: &config1
-        snmp_host: 192.0.2.3
-        vrf_filter: default
-        udp: 222
-        state: present
-      register: result
-
-    - assert: *true
-
-    - name: Idempotence Check
-      nxos_snmp_host: *config1
-      register: result
-
-    - assert: *false
-    when: platform is not search('N35|N5K|N6K')
-
-  - name: remove some configuration
-    nxos_snmp_host: &rem1
-      snmp_host: 192.0.2.3
-      udp: 222
-      src_intf: "{{ intname|default(omit) }}"
-      vrf: management
-      vrf_filter: management
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_snmp_host: *rem1
-    register: result
-
-  - assert: *false
-
-  - block:
-    - name: remove some more configuration
-      nxos_snmp_host: &rem2
-        snmp_host: 192.0.2.3
-        udp: 222
-        vrf_filter: default
-        state: absent
-      register: result
-
-    - assert: *true
-
-    - name: Idempotence Check
-      nxos_snmp_host: *rem2
-      register: result
-
-    - assert: *false
-    when: platform is not search('N35|N5K|N6K')
-
-  - name: Cleanup
-    nxos_snmp_host: *remove
-    register: result
-
-  - assert: *true
-
-  - name: Cleanup Idempotence
-    nxos_snmp_host: *remove
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: Cleanup
-    nxos_snmp_host: *remove
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_snmp_host {{ snmp_type }} {{ snmp_version }} sanity test"
diff --git a/test/integration/targets/nxos_snmp_host/tests/common/sanity_snmp_v3_inform.yaml b/test/integration/targets/nxos_snmp_host/tests/common/sanity_snmp_v3_inform.yaml
deleted file mode 100644
index f41b0176a6..0000000000
--- a/test/integration/targets/nxos_snmp_host/tests/common/sanity_snmp_v3_inform.yaml
+++ /dev/null
@@ -1,127 +0,0 @@
----
-- set_fact: snmp_type="inform"
-- set_fact: snmp_version="v3"
-- set_fact: snmp_auth="priv"
-
-- debug: msg="START connection={{ ansible_connection }} nxos_snmp_host {{ snmp_type }} {{ snmp_version }} sanity test"
-
-# Select interface for test
-- set_fact: intname="{{ nxos_int1 }}"
-  when: platform is not search('N5K|N6K')
-
-
-- set_fact: run="true"
-- set_fact: run="false"
-  when: platform is match('N35')
-
-- name: Setup - Remove snmp_host if configured
-  nxos_snmp_host: &remove
-    snmp_host: 192.0.2.3
-    community: TESTING
-    version: "{{ snmp_version }}"
-    snmp_type: "{{ snmp_type }}"
-    v3: "{{ snmp_auth }}"
-    vrf: management
-    vrf_filter: management
-    src_intf: "{{ intname|default(omit) }}"
-    state: absent
-  ignore_errors: yes
-
-- block:
-
-  - name: Configure snmp host
-    nxos_snmp_host: &config
-      snmp_host: 192.0.2.3
-      community: TESTING
-      v3: "{{ snmp_auth|default(omit) }}"
-      version: "{{ snmp_version }}"
-      snmp_type: "{{ snmp_type }}"
-      vrf: management
-      vrf_filter: management
-      src_intf: "{{ intname|default(omit) }}"
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: Idempotence Check
-    nxos_snmp_host: *config
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - block:
-    - name: Add another vrf to filter
-      nxos_snmp_host: &config1
-        snmp_host: 192.0.2.3
-        vrf_filter: default
-        state: present
-      register: result
-
-    - assert: *true
-
-    - name: Idempotence Check
-      nxos_snmp_host: *config1
-      register: result
-
-    - assert: *false
-    when: platform is not search('N35|N5K|N6K')
-
-  - name: remove some configuration
-    nxos_snmp_host: &rem1
-      snmp_host: 192.0.2.3
-      src_intf: "{{ intname|default(omit) }}"
-      vrf: management
-      vrf_filter: management
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_snmp_host: *rem1
-    register: result
-
-  - assert: *false
-
-  - block:
-    - name: remove some more configuration
-      nxos_snmp_host: &rem2
-        snmp_host: 192.0.2.3
-        vrf_filter: default
-        state: absent
-      register: result
-
-    - assert: *true
-
-    - name: Idempotence Check
-      nxos_snmp_host: *rem2
-      register: result
-
-    - assert: *false
-    when: platform is not search('N35|N5K|N6K')
-
-  - name: Cleanup
-    nxos_snmp_host: *remove
-    register: result
-
-  - assert: *true
-
-  - name: Cleanup Idempotence
-    nxos_snmp_host: *remove
-    register: result
-
-  - assert: *false
-
-  when: run
-
-  always:
-  - name: Cleanup
-    nxos_snmp_host: *remove
-    register: result
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_snmp_host {{ snmp_type }} {{ snmp_version }} sanity test"
diff --git a/test/integration/targets/nxos_snmp_host/tests/common/sanity_snmp_v3_trap.yaml b/test/integration/targets/nxos_snmp_host/tests/common/sanity_snmp_v3_trap.yaml
deleted file mode 100644
index 86895ff2ea..0000000000
--- a/test/integration/targets/nxos_snmp_host/tests/common/sanity_snmp_v3_trap.yaml
+++ /dev/null
@@ -1,125 +0,0 @@
----
-- set_fact: snmp_type="trap"
-- set_fact: snmp_version="v3"
-- set_fact: snmp_auth="priv"
-
-- debug: msg="START connection={{ ansible_connection }} nxos_snmp_host {{ snmp_type }} {{ snmp_version }} sanity test"
-
-# Select interface for test
-- set_fact: intname="{{ nxos_int1 }}"
-  when: platform is not search('N5K|N6K')
-
-- name: Setup - Remove snmp_host if configured
-  nxos_snmp_host: &remove
-    snmp_host: 192.0.2.3
-    community: TESTING
-    udp: 222
-    v3: "{{ snmp_auth|default(omit) }}"
-    version: "{{ snmp_version }}"
-    snmp_type: "{{ snmp_type }}"
-    vrf: management
-    vrf_filter: management
-    src_intf: "{{ intname|default(omit) }}"
-    state: absent
-  ignore_errors: yes
-
-- block:
-
-  - name: Configure snmp host
-    nxos_snmp_host: &config
-      snmp_host: 192.0.2.3
-      community: TESTING
-      udp: 222
-      v3: "{{ snmp_auth|default(omit) }}"
-      version: "{{ snmp_version }}"
-      snmp_type: "{{ snmp_type }}"
-      vrf: management
-      vrf_filter: management
-      src_intf: "{{ intname|default(omit) }}"
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: Idempotence Check
-    nxos_snmp_host: *config
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - block:
-    - name: Add another vrf to filter
-      nxos_snmp_host: &config1
-        snmp_host: 192.0.2.3
-        udp: 222
-        vrf_filter: default
-        state: present
-      register: result
-
-    - assert: *true
-
-    - name: Idempotence Check
-      nxos_snmp_host: *config1
-      register: result
-
-    - assert: *false
-    when: platform is not search('N35|N5K|N6K')
-
-  - name: remove some configuration
-    nxos_snmp_host: &rem1
-      snmp_host: 192.0.2.3
-      udp: 222
-      src_intf: "{{ intname|default(omit) }}"
-      vrf: management
-      vrf_filter: management
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_snmp_host: *rem1
-    register: result
-
-  - assert: *false
-
-  - block:
-    - name: remove some more configuration
-      nxos_snmp_host: &rem2
-        snmp_host: 192.0.2.3
-        udp: 222
-        vrf_filter: default
-        state: absent
-      register: result
-
-    - assert: *true
-
-    - name: Idempotence Check
-      nxos_snmp_host: *rem2
-      register: result
-
-    - assert: *false
-    when: platform is not search('N35|N5K|N6K')
-
-  - name: Cleanup
-    nxos_snmp_host: *remove
-    register: result
-
-  - assert: *true
-
-  - name: Cleanup Idempotence
-    nxos_snmp_host: *remove
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: Cleanup
-    nxos_snmp_host: *remove
-    register: result
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_snmp_host {{ snmp_type }} {{ snmp_version }} sanity test"
diff --git a/test/integration/targets/nxos_snmp_location/defaults/main.yaml b/test/integration/targets/nxos_snmp_location/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_snmp_location/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_snmp_location/meta/main.yml b/test/integration/targets/nxos_snmp_location/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_snmp_location/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_snmp_location/tasks/cli.yaml b/test/integration/targets/nxos_snmp_location/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_snmp_location/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_snmp_location/tasks/main.yaml b/test/integration/targets/nxos_snmp_location/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_snmp_location/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_snmp_location/tasks/nxapi.yaml b/test/integration/targets/nxos_snmp_location/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_snmp_location/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_snmp_location/tests/common/sanity.yaml b/test/integration/targets/nxos_snmp_location/tests/common/sanity.yaml
deleted file mode 100644
index e1be07aebf..0000000000
--- a/test/integration/targets/nxos_snmp_location/tests/common/sanity.yaml
+++ /dev/null
@@ -1,59 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_snmp_location sanity test"
-
-- name: Setup - Remove snmp_location if configured
-  nxos_snmp_location: &remove
-    location: Test 
-    state: absent
-
-- block:
-  - name: Configure snmp location 
-    nxos_snmp_location: &config
-      location: Testing
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: Idempotence Check
-    nxos_snmp_location: *config
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Change snmp location 
-    nxos_snmp_location: &config1
-      location: Test
-      state: present
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_snmp_location: *config1
-    register: result
-
-  - assert: *false
-
-  - name: remove snmp location
-    nxos_snmp_location: *remove
-    register: result
-
-  - assert: *true
-
-  - name: Remove Idempotence
-    nxos_snmp_location: *remove
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: Cleanup
-    nxos_snmp_location: *remove
-    register: result
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_snmp_location sanity test"
diff --git a/test/integration/targets/nxos_snmp_traps/defaults/main.yaml b/test/integration/targets/nxos_snmp_traps/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_snmp_traps/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_snmp_traps/meta/main.yml b/test/integration/targets/nxos_snmp_traps/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_snmp_traps/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_snmp_traps/tasks/cli.yaml b/test/integration/targets/nxos_snmp_traps/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_snmp_traps/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_snmp_traps/tasks/main.yaml b/test/integration/targets/nxos_snmp_traps/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_snmp_traps/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_snmp_traps/tasks/nxapi.yaml b/test/integration/targets/nxos_snmp_traps/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_snmp_traps/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_snmp_traps/tests/common/sanity.yaml b/test/integration/targets/nxos_snmp_traps/tests/common/sanity.yaml
deleted file mode 100644
index c035e2992c..0000000000
--- a/test/integration/targets/nxos_snmp_traps/tests/common/sanity.yaml
+++ /dev/null
@@ -1,77 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_snmp_traps sanity test"
-
-- name: Setup - Remove snmp_traps if configured
-  nxos_snmp_traps: &remove
-    group: all
-    state: disabled
-
-- block:
-  - name: Configure one snmp trap group
-    nxos_snmp_traps: &config
-      group: bridge
-      state: enabled
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: Idempotence Check
-    nxos_snmp_traps: *config
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Remove snmp trap group
-    nxos_snmp_traps: &rem1
-      group: bridge
-      state: disabled
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence Check
-    nxos_snmp_traps: *rem1
-    register: result
-
-  - assert: *false
-
-  - name: Configure all snmp trap groups
-    nxos_snmp_traps: &config1
-      group: all
-      state: enabled
-    register: result
-
-  - assert: *true
-
-  - block:
-    # On I2/I7, link command does not work properly
-    # On D1, callhome command does not work properly
-    # skip for these older platforms
-    - name: Idempotence Check
-      nxos_snmp_traps: *config1
-      register: result
-
-    - assert: *false
-    when: imagetag is not search("I2|I7|D1")
-
-  - name: Cleanup
-    nxos_snmp_traps: *remove
-    register: result
-
-  - assert: *true
-
-  - name: Cleanup Idempotence
-    nxos_snmp_traps: *remove
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: Cleanup
-    nxos_snmp_traps: *remove
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_snmp_traps sanity test"
diff --git a/test/integration/targets/nxos_snmp_user/defaults/main.yaml b/test/integration/targets/nxos_snmp_user/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_snmp_user/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_snmp_user/meta/main.yml b/test/integration/targets/nxos_snmp_user/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_snmp_user/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_snmp_user/tasks/cli.yaml b/test/integration/targets/nxos_snmp_user/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_snmp_user/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_snmp_user/tasks/main.yaml b/test/integration/targets/nxos_snmp_user/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_snmp_user/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_snmp_user/tasks/nxapi.yaml b/test/integration/targets/nxos_snmp_user/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_snmp_user/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_snmp_user/tests/common/sanity.yaml b/test/integration/targets/nxos_snmp_user/tests/common/sanity.yaml
deleted file mode 100644
index ae09a4d071..0000000000
--- a/test/integration/targets/nxos_snmp_user/tests/common/sanity.yaml
+++ /dev/null
@@ -1,107 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_snmp_user sanity test"
-
-- set_fact: delete_last_user_allowed='true'
-- set_fact: delete_last_user_allowed='false'
-  when: imagetag and (major_version is version_compare('9.1', 'ge'))
-- set_fact: delete_last_user_allowed='false'
-  when: platform is search('N5K|N6K|N9K-F')
-
-- name: Remove snmp user
-  nxos_snmp_user: &remove_snmp_user
-    user: ntc
-    state: absent
-  ignore_errors: yes
-  when: platform is not search('N5K|N6K|N9K-F')
-
-- name: Remove user workaround
-  # Some platforms will not allow snmp_user to remove the last role
-  nxos_user: &workaround_remove_user
-    name: ntc
-    state: absent
-  ignore_errors: yes
-  when: platform is search('N5K|N6K|N9K-F')
-
-- pause:
-    seconds: 5
-
-- block:
-  - name: Create snmp user
-    nxos_snmp_user: &create
-      user: ntc
-      group: network-operator
-      authentication: md5
-      pwd: N$tOpe%1
-      privacy: HelloU$er1
-      encrypt: true
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: Add another group to user
-    nxos_snmp_user: &chg
-      user: ntc
-      group: network-admin
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_snmp_user: *chg
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Remove group from user
-    nxos_snmp_user: &remg
-      user: ntc
-      group: network-admin
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - pause:
-      seconds: 5
-
-  - name: "Check Idempotence"
-    nxos_snmp_user: *remg
-    register: result
-
-  - assert: *false
-
-  - block:
-    # Some platforms will not allow snmp_user to remove the last role
-    - name: delete snmp user
-      nxos_snmp_user: &remove1
-        user: ntc
-        group: network-operator
-        state: absent
-      register: result
-
-    - assert: *true
-
-    - pause:
-        seconds: 5
-
-    - name: "Remove Idempotence"
-      nxos_snmp_user: *remove1
-      register: result
-
-    - assert: *false
-    when: delete_last_user_allowed
-
-  always:
-    - name: delete snmp user
-      nxos_snmp_user: *remove_snmp_user
-      when: platform is not search('N5K|N6K|N9K-F')
-
-    - name: remove user workaround
-      nxos_user: *workaround_remove_user
-      when: platform is search('N5K|N6K|N9K-F')
-
-- debug: msg="END connection={{ ansible_connection }} nxos_snmp_user sanity test"
diff --git a/test/integration/targets/nxos_static_route/defaults/main.yaml b/test/integration/targets/nxos_static_route/defaults/main.yaml
deleted file mode 100644
index 525b7aab90..0000000000
--- a/test/integration/targets/nxos_static_route/defaults/main.yaml
+++ /dev/null
@@ -1,5 +0,0 @@
----
-testcase: "*"
-vrfs:
-  - default
-  - myvrf
diff --git a/test/integration/targets/nxos_static_route/meta/main.yml b/test/integration/targets/nxos_static_route/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_static_route/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_static_route/tasks/cli.yaml b/test/integration/targets/nxos_static_route/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_static_route/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_static_route/tasks/main.yaml b/test/integration/targets/nxos_static_route/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_static_route/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_static_route/tasks/nxapi.yaml b/test/integration/targets/nxos_static_route/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_static_route/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_static_route/tests/common/sanity.yaml b/test/integration/targets/nxos_static_route/tests/common/sanity.yaml
deleted file mode 100644
index f07fefb40a..0000000000
--- a/test/integration/targets/nxos_static_route/tests/common/sanity.yaml
+++ /dev/null
@@ -1,195 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_static_route sanity test"
-
-# Flag used to test the track feature.  Some platforms
-# don't support it so this flag will be toggled accordingly.
-- set_fact: test_track_feature="true"
-
-- name: configure track
-  nxos_config:
-    lines:
-      - track 1 ip sla 1
-  register: cmd_result
-  ignore_errors: yes
-
-- debug: msg="cmd result {{ cmd_result }}"
-
-- set_fact: test_track_feature="false"
-  when: cmd_result.failed
-
-- debug: msg="Test Track Feature {{ test_track_feature }}"
-
-- name: Setup and teardown, remove test routes if present
-  nxos_static_route: &setup_teardown
-    aggregate:
-      - { prefix: "192.168.1.164/32", next_hop: "192.0.2.3" }
-      - { prefix: "192.168.20.64/24", next_hop: "192.0.2.3" }
-      - { prefix: "192.168.22.64/24", next_hop: "192.0.2.3" }
-      - { prefix: "192.168.24.64/24", next_hop: "192.0.2.3" }
-    vrf: "{{ item }}"
-    state: absent
-  with_items: "{{ vrfs }}"
-  ignore_errors: yes
-
-- name: Setup noise routes to ensure testing while non-test routes present
-  nxos_static_route:
-    prefix: "192.168.1.164/32"
-    next_hop: "192.0.2.3"
-    vrf: "{{ item }}"
-    state: present
-  with_items: "{{ vrfs }}"
-
-- block:
-  - name: create static route
-    nxos_static_route: &configure_static
-      prefix: "192.168.20.64/24"
-      next_hop: "192.0.2.3"
-      route_name: testing
-      pref: 100
-      tag: 5500
-      vrf: "{{ item }}"
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Conf static Idempotence"
-    nxos_static_route: *configure_static
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: change static route
-    nxos_static_route: &change_static
-      prefix: "192.168.20.64/24"
-      next_hop: "192.0.2.3"
-      route_name: default
-      pref: 10
-      tag: default
-      vrf: "{{ item }}"
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Change Idempotence"
-    nxos_static_route: *change_static
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: configure static route with track
-    nxos_static_route: &config_static_track
-      prefix: "192.168.20.64/24"
-      next_hop: "192.0.2.3"
-      route_name: default
-      pref: 10
-      tag: default
-      track: 1
-      vrf: "{{ item }}"
-    with_items: "{{ vrfs }}"
-    register: result
-    when: test_track_feature
-
-  - assert: *true
-    when: test_track_feature
-
-  - name: "Config track Idempotence"
-    nxos_static_route: *config_static_track
-    with_items: "{{ vrfs }}"
-    register: result
-    when: test_track_feature
-
-  - assert: *false
-    when: test_track_feature
-
-  - name: configure static route with not configured track
-    nxos_static_route:
-      prefix: "192.168.20.64/24"
-      next_hop: "192.0.2.3"
-      route_name: default
-      pref: 10
-      tag: default
-      track: 2
-      vrf: "{{ item }}"
-    with_items: "{{ vrfs }}"
-    register: result
-    ignore_errors: yes
-    when: test_track_feature
-
-  - assert:
-      that:
-        - "result.failed == True"
-    when: test_track_feature
-
-  - name: remove static route
-    nxos_static_route: &remove_static
-      prefix: "192.168.20.64/24"
-      next_hop: "192.0.2.3"
-      route_name: testing
-      pref: 100
-      vrf: "{{ item }}"
-      state: absent
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Remove Idempotence"
-    nxos_static_route: *remove_static
-    with_items: "{{ vrfs }}"
-    register: result
-
-  - assert: *false
-
-  - name: configure static route(aggregate)
-    nxos_static_route: &conf_agg
-      aggregate:
-        - { prefix: "192.168.22.64/24", next_hop: "192.0.2.3" }
-        - { prefix: "192.168.24.64/24", next_hop: "192.0.2.3" }
-    register: result
-
-  - assert: *true
-
-  - name: configure static route aggregate(Idempotence)
-    nxos_static_route: *conf_agg
-    register: result
-
-  - assert: *false
-
-  - name: remove static route aggregate
-    nxos_static_route: &remove_agg
-      aggregate:
-        - { prefix: "192.168.22.64/24", next_hop: "192.0.2.3" }
-        - { prefix: "192.168.24.64/24", next_hop: "192.0.2.3" }
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: remove static route aggregate(Idempotence)
-    nxos_static_route: *remove_agg
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: remove track
-    nxos_config:
-      lines:
-        - no track 1
-    ignore_errors: yes
-    when: test_track_feature
-
-  - name: teardown test routes
-    nxos_static_route: *setup_teardown
-    with_items: "{{ vrfs }}"
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_static_route sanity test"
diff --git a/test/integration/targets/nxos_system/defaults/main.yaml b/test/integration/targets/nxos_system/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_system/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_system/meta/main.yml b/test/integration/targets/nxos_system/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_system/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_system/tasks/cli.yaml b/test/integration/targets/nxos_system/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_system/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_system/tasks/main.yaml b/test/integration/targets/nxos_system/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_system/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_system/tasks/nxapi.yaml b/test/integration/targets/nxos_system/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_system/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_system/tests/cli/net_system.yaml b/test/integration/targets/nxos_system/tests/cli/net_system.yaml
deleted file mode 100644
index 483bcfdaec..0000000000
--- a/test/integration/targets/nxos_system/tests/cli/net_system.yaml
+++ /dev/null
@@ -1,34 +0,0 @@
----
-- debug: msg="START nxos cli/net_system.yaml on connection={{ ansible_connection }}"
-
-# Add minimal testcase to check args are passed correctly to
-# implementation module and module run is successful.
-
-- name: setup
-  nxos_config:
-    lines:
-      - no ip domain-list ansible.com
-      - no ip domain-list redhat.com
-    match: none
-
-- name: configure domain_list using platform agnostic module
-  net_system:
-    domain_search:
-      - ansible.com
-      - redhat.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == true
-      - "'ip domain-list ansible.com' in result.commands"
-      - "'ip domain-list redhat.com' in result.commands"
-
-- name: setup
-  nxos_config:
-    lines:
-      - no ip domain-list ansible.com
-      - no ip domain-list redhat.com
-    match: none
-
-- debug: msg="END nxos cli/net_system.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_system/tests/cli/set_domain_list.yaml b/test/integration/targets/nxos_system/tests/cli/set_domain_list.yaml
deleted file mode 100644
index 6884b79f8b..0000000000
--- a/test/integration/targets/nxos_system/tests/cli/set_domain_list.yaml
+++ /dev/null
@@ -1,112 +0,0 @@
----
-- debug: msg="START cli/set_domain_list.yaml"
-
-- name: setup
-  nxos_config:
-    lines:
-      - no ip domain-list ansible.com
-      - no ip domain-list redhat.com
-    match: none
-
-- name: configure domain_list
-  nxos_system:
-    domain_search:
-      - ansible.com
-      - redhat.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == true
-      - "'ip domain-list ansible.com' in result.commands"
-      - "'ip domain-list redhat.com' in result.commands"
-
-- name: verify domain_list
-  nxos_system:
-    domain_search:
-      - ansible.com
-      - redhat.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == false
-
-- name: remove one entry
-  nxos_system:
-    domain_search:
-      - ansible.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == true
-      - "'no ip domain-list redhat.com' in result.commands"
-
-- name: verify remove one entry
-  nxos_system:
-    domain_search:
-      - ansible.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == false
-
-- name: add one entry
-  nxos_system:
-    domain_search:
-      - ansible.com
-      - redhat.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == true
-      - "'ip domain-list redhat.com' in result.commands"
-
-- name: verify add one entry
-  nxos_system:
-    domain_search:
-      - ansible.com
-      - redhat.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == false
-
-- name: add and remove one entry
-  nxos_system:
-    domain_search:
-      - ansible.com
-      - eng.ansible.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == true
-      - "'no ip domain-list redhat.com' in result.commands"
-      - "'ip domain-list eng.ansible.com' in result.commands"
-      - result.commands|length == 2
-
-- name: verify add and remove one entry
-  nxos_system:
-    domain_search:
-      - ansible.com
-      - eng.ansible.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == false
-
-- name: teardown
-  nxos_config:
-    lines:
-      - no ip domain-list ansible.com
-      - no ip domain-list redhat.com
-      - no ip domain-list eng.ansible.com
-    match: none
-
-- debug: msg="END cli/set_domain_search.yaml"
diff --git a/test/integration/targets/nxos_system/tests/cli/set_domain_name.yaml b/test/integration/targets/nxos_system/tests/cli/set_domain_name.yaml
deleted file mode 100644
index 3c64cd5b31..0000000000
--- a/test/integration/targets/nxos_system/tests/cli/set_domain_name.yaml
+++ /dev/null
@@ -1,32 +0,0 @@
----
-- debug: msg="START cli/set_domain_name.yaml"
-
-- name: setup
-  nxos_config:
-    lines: no ip domain-name eng.ansible.com
-    match: none
-
-- name: configure domain_name
-  nxos_system:
-    domain_name: eng.ansible.com
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: verify domain_name
-  nxos_system:
-    domain_name: eng.ansible.com
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config:
-    lines: no ip domain-name eng.ansible.com
-    match: none
-
-- debug: msg="END cli/set_domain_name.yaml"
diff --git a/test/integration/targets/nxos_system/tests/cli/set_name_servers.yaml b/test/integration/targets/nxos_system/tests/cli/set_name_servers.yaml
deleted file mode 100644
index a6bd35ab90..0000000000
--- a/test/integration/targets/nxos_system/tests/cli/set_name_servers.yaml
+++ /dev/null
@@ -1,100 +0,0 @@
----
-- debug: msg="START cli/set_name_servers.yaml"
-
-- name: setup
-  nxos_config: &reset
-    lines:
-      - no ip name-server 192.0.2.1
-      - no ip name-server 192.0.2.2
-      - no ip name-server 192.0.2.3
-    match: none
-
-- name: configure name_servers
-  nxos_system:
-    name_servers:
-      - 192.0.2.1
-      - 192.0.2.2
-      - 192.0.2.3
-  register: result
-
-- assert:
-    that:
-      - result.changed == true
-      - "'ip name-server 192.0.2.1' in result.commands"
-      - "'ip name-server 192.0.2.2' in result.commands"
-      - "'ip name-server 192.0.2.3' in result.commands"
-
-- name: verify name_servers
-  nxos_system:
-    name_servers:
-      - 192.0.2.1
-      - 192.0.2.2
-      - 192.0.2.3
-  register: result
-
-- assert:
-    that:
-      - result.changed == false
-
-#- name: change to vrf
-#  nxos_system:
-#    name_servers:
-#      - 192.0.2.1
-#      - { server: 192.0.2.2, vrf: ansible }
-#      - 192.0.2.3
-#  register: result
-
-#- assert:
-#    that:
-#      - result.changed == true
-#      - result.commands|length == 2
-#      - "'no ip name-server 192.0.2.2' in result.commands"
-#      - "'ip name-server 192.0.2.2 vrf ansible' in result.commands"
-
-#- name: verify change to vrf
-#  nxos_system:
-#    name_servers:
-#      - 192.0.2.1
-#      - { server: 192.0.2.2, vrf: ansible }
-#      - 192.0.2.3
-#  register: result
-#
-#- assert:
-#    that:
-#      - result.changed == false
-
-- name: remove one
-  nxos_system:
-    name_servers:
-      - 192.0.2.1
-      - 192.0.2.2
-  register: result
-
-- assert:
-    that:
-      - result.changed == true
-      - result.commands|length == 1
-      - "'no ip name-server 192.0.2.3' in result.commands"
-
-- name: default name server
-  nxos_system: &defns
-    name_servers: default
-  register: result
-
-- assert:
-    that:
-      - result.changed == true
-
-- name: Idempotent check
-  nxos_system: *defns
-  register: result
-
-- assert:
-    that:
-      - result.changed == false
-
-- name: teardown
-  nxos_config: *reset
-  ignore_errors: yes
-
-- debug: msg="END cli/set_name_servers.yaml"
diff --git a/test/integration/targets/nxos_system/tests/common/sanity.yaml b/test/integration/targets/nxos_system/tests/common/sanity.yaml
deleted file mode 100644
index 74d8843226..0000000000
--- a/test/integration/targets/nxos_system/tests/common/sanity.yaml
+++ /dev/null
@@ -1,126 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }}/sanity.yaml"
-
-- block:
-  - name: remove configuration
-    nxos_system: &remove
-      state: absent
-    register: result
-    ignore_errors: yes
-
-  - name: configure domain lookup
-    nxos_system: &dlo
-      domain_lookup: true
-      state: present
-    register: result
-
-  - name: configure hostname and domain-name
-    nxos_system: &hostname
-      hostname: switch
-      domain_name: test.example.com
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: Idempotence check
-    nxos_system: *hostname
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: configure name servers
-    nxos_system: &ns
-      name_servers:
-        - 8.8.8.8
-        - 8.8.4.4
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence check
-    nxos_system: *ns
-    register: result
-
-  - assert: *false
-
-  - name: configure name servers with VRF support
-    nxos_system: &nsv
-      name_servers:
-        - { server: 8.8.8.8, vrf: management }
-        - { server: 8.8.4.4, vrf: management }
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence check
-    nxos_system: *nsv
-    register: result
-
-  - assert: *false
-
-  - name: configure domain lookup1
-    nxos_system: &ndlo
-      domain_lookup: false
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence check
-    nxos_system: *ndlo
-    register: result
-
-  - assert: *false
-
-  - name: configure domain lookup2
-    nxos_system: *dlo
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence check
-    nxos_system: *dlo
-    register: result
-
-  - assert: *false
-
-  - name: configure system mtu
-    nxos_system: &sysmtu
-      system_mtu: 3000
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence check
-    nxos_system: *sysmtu
-    register: result
-
-  - assert: *false
-
-  - name: default configuration
-    nxos_system: &default
-      hostname: default
-      domain_name: default
-      name_servers: default
-      system_mtu: default
-    register: result
-
-  - assert: *true
-
-  - name: Idempotence check
-    nxos_system: *default
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: remove configuration
-    nxos_system: *remove
-
-  - name: Re-configure hostname
-    nxos_system: *hostname
-
-  - debug: msg="END connection={{ ansible_connection }}/sanity.yaml" 
diff --git a/test/integration/targets/nxos_system/tests/common/set_hostname.yaml b/test/integration/targets/nxos_system/tests/common/set_hostname.yaml
deleted file mode 100644
index da9090a7a8..0000000000
--- a/test/integration/targets/nxos_system/tests/common/set_hostname.yaml
+++ /dev/null
@@ -1,35 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }}/set_hostname.yaml"
-
-- block:
-  - name: setup
-    nxos_config:
-      lines: "hostname switch"
-      match: none
-
-  - name: configure hostname
-    nxos_system:
-      hostname: foo
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-
-  - name: verify hostname
-    nxos_system:
-      hostname: foo
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-
-  always:
-  - name: teardown
-    nxos_config:
-      lines: "hostname switch"
-      match: none
-
-
-  - debug: msg="END connection={{ ansible_connection }}/set_hostname.yaml"
diff --git a/test/integration/targets/nxos_system/tests/nxapi/net_system.yaml b/test/integration/targets/nxos_system/tests/nxapi/net_system.yaml
deleted file mode 100644
index e7810f7fc5..0000000000
--- a/test/integration/targets/nxos_system/tests/nxapi/net_system.yaml
+++ /dev/null
@@ -1,35 +0,0 @@
----
-- debug: msg="START nxos nxapi/net_system.yaml on connection={{ ansible_connection }}"
-
-# Add minimal testcase to check args are passed correctly to
-# implementation module and module run is successful.
-
-- name: setup
-  nxos_config:
-    lines:
-      - no ip domain-list ansible.com
-      - no ip domain-list redhat.com
-    match: none
-  ignore_errors: yes
-
-- name: configure domain_list using platform agnostic module
-  net_system:
-    domain_search:
-      - ansible.com
-      - redhat.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == true
-      - "'ip domain-list ansible.com' in result.commands"
-      - "'ip domain-list redhat.com' in result.commands"
-
-- name: setup
-  nxos_config:
-    lines:
-      - no ip domain-list ansible.com
-      - no ip domain-list redhat.com
-    match: none
-
-- debug: msg="END nxos nxapi/net_system.yaml on connection={{ ansible_connection }}"
diff --git a/test/integration/targets/nxos_system/tests/nxapi/set_domain_list.yaml b/test/integration/targets/nxos_system/tests/nxapi/set_domain_list.yaml
deleted file mode 100644
index d22736c2e6..0000000000
--- a/test/integration/targets/nxos_system/tests/nxapi/set_domain_list.yaml
+++ /dev/null
@@ -1,121 +0,0 @@
----
-- debug: msg="START nxapi/set_domain_list.yaml"
-
-
-# nxapi will error if you try and remove a non-existent entry,
-# Therefore we do this as a with_items loop with ignore_errors
-- name: setup
-  nxos_config:
-    lines:
-      - no ip domain-list {{ item }}
-    match: none
-  ignore_errors: yes
-  with_items:
-      - ansible.com
-      - redhat.com
-
-- name: configure domain_list
-  nxos_system:
-    domain_search:
-      - ansible.com
-      - redhat.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == true
-      - "'ip domain-list ansible.com' in result.commands"
-      - "'ip domain-list redhat.com' in result.commands"
-
-- name: verify domain_list
-  nxos_system:
-    domain_search:
-      - ansible.com
-      - redhat.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == false
-
-- name: remove one entry
-  nxos_system:
-    domain_search:
-      - ansible.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == true
-      - "'no ip domain-list redhat.com' in result.commands"
-
-- name: verify remove one entry
-  nxos_system:
-    domain_search:
-      - ansible.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == false
-
-- name: add one entry
-  nxos_system:
-    domain_search:
-      - ansible.com
-      - redhat.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == true
-      - "'ip domain-list redhat.com' in result.commands"
-
-- name: verify add one entry
-  nxos_system:
-    domain_search:
-      - ansible.com
-      - redhat.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == false
-
-- name: add and remove one entry
-  nxos_system:
-    domain_search:
-      - ansible.com
-      - eng.ansible.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == true
-      - "'no ip domain-list redhat.com' in result.commands"
-      - "'ip domain-list eng.ansible.com' in result.commands"
-      - result.commands|length == 2
-
-- name: verify add and remove one entry
-  nxos_system:
-    domain_search:
-      - ansible.com
-      - eng.ansible.com
-  register: result
-
-- assert:
-    that:
-      - result.changed == false
-
-- name: teardown
-  nxos_config:
-    lines:
-      - no ip domain-list {{ item }}
-    match: none
-  ignore_errors: yes
-  with_items:
-      - ansible.com
-      - redhat.com
-      - eng.ansible.com
-
-- debug: msg="END nxapi/set_domain_search.yaml"
diff --git a/test/integration/targets/nxos_system/tests/nxapi/set_domain_name.yaml b/test/integration/targets/nxos_system/tests/nxapi/set_domain_name.yaml
deleted file mode 100644
index 13adfcbf4b..0000000000
--- a/test/integration/targets/nxos_system/tests/nxapi/set_domain_name.yaml
+++ /dev/null
@@ -1,34 +0,0 @@
----
-- debug: msg="START nxapi/set_domain_name.yaml"
-
-- name: setup
-  nxos_config:
-    lines: no ip domain-name eng.ansible.com
-    match: none
-# NXAPI errors if you try to remove something that doesn't exist
-  ignore_errors: yes
-
-- name: configure domain_name
-  nxos_system:
-    domain_name: eng.ansible.com
-  register: result
-
-- assert:
-    that:
-      - "result.changed == true"
-
-- name: verify domain_name
-  nxos_system:
-    domain_name: eng.ansible.com
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: teardown
-  nxos_config:
-    lines: no ip domain-name eng.ansible.com
-    match: none
-
-- debug: msg="END nxapi/set_domain_name.yaml"
diff --git a/test/integration/targets/nxos_system/tests/nxapi/set_name_servers.yaml b/test/integration/targets/nxos_system/tests/nxapi/set_name_servers.yaml
deleted file mode 100644
index 7baaa7e9f5..0000000000
--- a/test/integration/targets/nxos_system/tests/nxapi/set_name_servers.yaml
+++ /dev/null
@@ -1,110 +0,0 @@
----
-- debug: msg="START nxapi/set_name_servers.yaml"
-
-
-# nxapi will error if you try and remove a non-existent entry,
-# Therefore we do this as a with_items loop with ignore_errors
-- name: setup
-  nxos_config: &reset
-    lines:
-      - no ip name-server {{ item }}
-    match: none
-  ignore_errors: yes
-  with_items:
-      - 192.0.2.1
-      - 192.0.2.2
-      - 192.0.2.3
-
-- name: configure name_servers
-  nxos_system:
-    name_servers:
-      - 192.0.2.1
-      - 192.0.2.2
-      - 192.0.2.3
-  register: result
-
-- assert:
-    that:
-      - result.changed == true
-      - "'ip name-server 192.0.2.1' in result.commands"
-      - "'ip name-server 192.0.2.2' in result.commands"
-      - "'ip name-server 192.0.2.3' in result.commands"
-
-- name: verify name_servers
-  nxos_system:
-    name_servers:
-      - 192.0.2.1
-      - 192.0.2.2
-      - 192.0.2.3
-  register: result
-
-- assert:
-    that:
-      - result.changed == false
-
-#- name: change to vrf
-#  nxos_system:
-#    name_servers:
-#      - 192.0.2.1
-#      - { server: 192.0.2.2, vrf: ansible }
-#      - 192.0.2.3
-#  register: result
-
-#- assert:
-#    that:
-#      - result.changed == true
-#      - result.commands|length == 2
-#      - "'no ip name-server 192.0.2.2' in result.commands"
-#      - "'ip name-server 192.0.2.2 vrf ansible' in result.commands"
-
-#- name: verify change to vrf
-#  nxos_system:
-#    name_servers:
-#      - 192.0.2.1
-#      - { server: 192.0.2.2, vrf: ansible }
-#      - 192.0.2.3
-#  register: result
-#
-#- assert:
-#    that:
-#      - result.changed == false
-
-- name: remove one
-  nxos_system:
-    name_servers:
-      - 192.0.2.1
-      - 192.0.2.2
-  register: result
-
-- assert:
-    that:
-      - result.changed == true
-      - result.commands|length == 1
-      - "'no ip name-server 192.0.2.3' in result.commands"
-
-- name: default name server
-  nxos_system: &defns
-    name_servers: default
-  register: result
-
-- assert:
-    that:
-      - result.changed == true
-
-- name: Idempotent check
-  nxos_system: *defns
-  register: result
-
-- assert:
-    that:
-      - result.changed == false
-
-- name: teardown
-  nxos_config: *reset
-  with_items:
-      - 192.0.2.1
-      - 192.0.2.2
-      - 192.0.2.3
-  ignore_errors: yes
-
-- debug: msg="END nxapi/set_name_servers.yaml"
diff --git a/test/integration/targets/nxos_telemetry/defaults/main.yaml b/test/integration/targets/nxos_telemetry/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_telemetry/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_telemetry/meta/main.yml b/test/integration/targets/nxos_telemetry/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_telemetry/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_telemetry/tasks/cli.yaml b/test/integration/targets/nxos_telemetry/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_telemetry/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_telemetry/tasks/main.yaml b/test/integration/targets/nxos_telemetry/tasks/main.yaml
deleted file mode 100644
index c070015619..0000000000
--- a/test/integration/targets/nxos_telemetry/tasks/main.yaml
+++ /dev/null
@@ -1,18 +0,0 @@
----
-- set_fact: run_test="true"
-
-# Telemetry module only supported on N9k
-- set_fact: run_test="false"
-  when: platform is not search("N9K")
-
-# Telemetry module not supported on versions earlier then 7.0(3)I7(x)
-- set_fact: run_test="false"
-  when: imagetag is search("I2|I3|I4|I5|I6")
-
-- include: cli.yaml
-  tags: 'cli'
-  when: run_test
-# Uncomment below when nxapi is supported for resource module builder modules
-# - include: nxapi.yaml
-#   tags: 'nxapi'
-#   when: run_test
diff --git a/test/integration/targets/nxos_telemetry/tasks/nxapi.yaml b/test/integration/targets/nxos_telemetry/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_telemetry/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_telemetry/tests/common/deleted.yaml b/test/integration/targets/nxos_telemetry/tests/common/deleted.yaml
deleted file mode 100644
index 6e6875f644..0000000000
--- a/test/integration/targets/nxos_telemetry/tests/common/deleted.yaml
+++ /dev/null
@@ -1,93 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_telemetry deleted sanity test"
-
-- set_fact: source_interface="Loopback55"
-  when: imagetag and (major_version is version_compare('9.1', 'ge'))
-
-- set_fact: before_keys_length=6
-- set_fact: before_keys_length=7
-  when: imagetag and (major_version is version_compare('9.1', 'ge'))
-
-- name: Setup
-  nxos_feature: &setup_teardown
-    feature: telemetry
-    state: disabled
-  ignore_errors: yes
-
-- name: Setup - Configure Telemetry
-  nxos_telemetry:
-    state: 'merged'
-    config:
-      certificate:
-        key: /bootflash/server.key
-        hostname: localhost
-      compression: gzip
-      source_interface: "{{source_interface|default(omit)}}"
-      vrf: management
-      destination_groups:
-        - id: 2
-          destination:
-            ip: 192.168.0.1
-            port: 50001
-            protocol: grpc
-            encoding: gpb
-        - { id: 2, destination: {ip: 192.168.0.2, port: 60001, protocol: gRPC, encoding: GPB}}
-        - { id: 10, destination: {ip: 192.168.0.1, port: 50001, protocol: Grpc, encoding: gPB}}
-        - { id: 10, destination: {ip: 192.168.0.2, port: 60001, protocol: gRPC, encoding: gpb}}
-      sensor_groups:
-        - { id: 8, data_source: NX-API, path: {name: '"show bgp l2vpn evpn summary"', depth: 0, query_condition: foo, filter_condition: foo}}
-        - { id: 2, data_source: NX-API, path: {name: '"show ip bgp neighbors"', depth: unbounded, query_condition: foo, filter_condition: foo}}
-        - { id: 55, data_source: DME, path: {name: 'sys/bgp/inst/dom-default/peer-[10.10.10.11]/ent-[10.10.10.11]', depth: 0, query_condition: foo, filter_condition: foo}}
-        - { id: 55, data_source: DME, path: {name: sys/ospf, depth: 0, query_condition: foo, filter_condition: 'or(eq(ethpmPhysIf.operSt,"down"),eq(ethpmPhysIf.operSt,"up"))'}}
-      subscriptions:
-        - { id: 44, destination_group: 10, sensor_group: {id: 8, sample_interval: 2000}}
-        - { id: 44, destination_group: 2, sensor_group: {id: 2, sample_interval: 2000}}
-        - { id: 55, destination_group: 10, sensor_group: {id: 55, sample_interval: 2000}}
-
-- block:
-  - name: Gather Telemetry Facts Before Changes
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources:
-        - telemetry
-
-  - name: Telemetry - deleted
-    nxos_telemetry: &deleted
-      state: 'deleted'
-    register: result
-
-  # result.before|dict2items|length checks the number of dictionary keys.
-  - assert:
-      that:
-        - "result.changed == true"
-        - "'no telemetry' in result.commands"
-        - "result.before|dict2items|length == {{ before_keys_length }}"
-
-  - assert:
-      that:
-        - "(ansible_facts.network_resources.telemetry|dict2items)|symmetric_difference(result.before|dict2items)|length == 0"
-
-  - name: Gather Telemetry Facts After Changes
-    nxos_facts: *facts
-
-  - assert:
-      that:
-        - "(ansible_facts.network_resources.telemetry|dict2items)|symmetric_difference(result.after|dict2items)|length == 0"
-
-  - name: Telemetry - deleted - idempotence
-    nxos_telemetry: *deleted
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: Teardown
-    nxos_feature: *setup_teardown
-    ignore_errors: yes
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_telemetry deleted sanity test"
diff --git a/test/integration/targets/nxos_telemetry/tests/common/merged.yaml b/test/integration/targets/nxos_telemetry/tests/common/merged.yaml
deleted file mode 100644
index 6b280e3fa3..0000000000
--- a/test/integration/targets/nxos_telemetry/tests/common/merged.yaml
+++ /dev/null
@@ -1,184 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_telemetry merged sanity test"
-
-- set_fact: source_interface="Loopback55"
-  when: imagetag and (major_version is version_compare('9.1', 'ge'))
-
-- set_fact: command_list_length=30
-- set_fact: command_list_length=31
-  when: imagetag and (major_version is version_compare('9.1', 'ge'))
-
-- name: Setup
-  nxos_feature: &setup_teardown
-    feature: telemetry
-    state: disabled
-  ignore_errors: yes
-
-- block:
-  - name: Gather Telemetry Facts Before Changes
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources:
-        - telemetry
-
-  - name: Telemetry - merged
-    nxos_telemetry: &merged
-      state: 'merged'
-      config:
-        certificate:
-          key: /bootflash/server.key
-          hostname: localhost
-        compression: gzip
-        source_interface: "{{source_interface|default(omit)}}"
-        vrf: management
-        destination_groups:
-          - id: 2
-            destination:
-              ip: 192.168.0.1
-              port: 50001
-              protocol: grpc
-              encoding: gpb
-          - { id: 2, destination: {ip: 192.168.0.2, port: 60001, protocol: gRPC, encoding: GPB}}
-          - { id: 10, destination: {ip: 192.168.0.1, port: 50001, protocol: Grpc, encoding: gPB}}
-          - { id: 10, destination: {ip: 192.168.0.2, port: 60001, protocol: gRPC, encoding: gpb}}
-        sensor_groups:
-          - { id: 8, data_source: NX-API, path: {name: '"show bgp l2vpn evpn summary"', depth: 0, query_condition: foo, filter_condition: foo}}
-          - { id: 2, data_source: NX-API, path: {name: '"show ip bgp neighbors"', depth: unbounded, query_condition: foo, filter_condition: foo}}
-          - { id: 55, data_source: DME, path: {name: 'sys/bgp/inst/dom-default/peer-[10.10.10.11]/ent-[10.10.10.11]', depth: 0, query_condition: foo, filter_condition: foo}}
-          - { id: 55, data_source: DME, path: {name: sys/ospf, depth: 0, query_condition: foo, filter_condition: 'or(eq(ethpmPhysIf.operSt,"down"),eq(ethpmPhysIf.operSt,"up"))'}}
-        subscriptions:
-          - { id: 44, destination_group: 10, sensor_group: {id: 8, sample_interval: 2000}}
-          - { id: 44, destination_group: 2, sensor_group: {id: 2, sample_interval: 2000}}
-          - { id: 55, destination_group: 10, sensor_group: {id: 55, sample_interval: 2000}}
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "result.before|length == 0"
-        - "'feature telemetry' in result.commands"
-        - "'telemetry' in result.commands"
-        - "'certificate /bootflash/server.key localhost' in result.commands"
-        - "'destination-profile' in result.commands"
-        - "'use-compression gzip' in result.commands"
-        - "'use-vrf management' in result.commands"
-        - "'destination-group 2' in result.commands"
-        - "'ip address 192.168.0.1 port 50001 protocol grpc encoding gpb' in result.commands"
-        - "'ip address 192.168.0.2 port 60001 protocol grpc encoding gpb' in result.commands"
-        - "'destination-group 10' in result.commands"
-        - "'ip address 192.168.0.1 port 50001 protocol grpc encoding gpb' in result.commands"
-        - "'ip address 192.168.0.2 port 60001 protocol grpc encoding gpb' in result.commands"
-        - "'sensor-group 8' in result.commands"
-        - "'data-source NX-API' in result.commands"
-        - result.commands is search("path .*show bgp l2vpn evpn summary.* depth 0 query-condition foo filter-condition foo")
-        - "'sensor-group 2' in result.commands"
-        - "'data-source NX-API' in result.commands"
-        - result.commands is search("path .*show ip bgp neighbors.* depth unbounded query-condition foo filter-condition foo")
-        - "'sensor-group 55' in result.commands"
-        - "'data-source DME' in result.commands"
-        - "'path sys/bgp/inst/dom-default/peer-[10.10.10.11]/ent-[10.10.10.11] depth 0 query-condition foo filter-condition foo' in result.commands"
-        - "'path sys/ospf depth 0 query-condition foo filter-condition or(eq(ethpmPhysIf.operSt,\"down\"),eq(ethpmPhysIf.operSt,\"up\"))' in result.commands"
-        - "'subscription 44' in result.commands"
-        - "'dst-grp 10' in result.commands"
-        - "'dst-grp 2' in result.commands"
-        - "'snsr-grp 8 sample-interval 2000' in result.commands"
-        - "'snsr-grp 2 sample-interval 2000' in result.commands"
-        - "'subscription 55' in result.commands"
-        - "'dst-grp 10' in result.commands"
-        - "'snsr-grp 55 sample-interval 2000' in result.commands"
-        - "result.commands|length == {{ command_list_length }}"
-
-  # Source interface may or may not be included based on the image version.
-  - assert:
-      that:
-        - "'source-interface loopback55' in result.commands"
-    when: imagetag and (major_version is version_compare('9.1', 'ge'))
-
-  - assert:
-      that:
-        - "(ansible_facts.network_resources.telemetry|dict2items)|symmetric_difference(result.before|dict2items)|length == 0"
-
-  - name: Gather Telemetry Facts After Changes
-    nxos_facts: *facts
-
-  - assert:
-      that:
-        - "(ansible_facts.network_resources.telemetry|dict2items)|symmetric_difference(result.after|dict2items)|length == 0"
-
-  - name: Telemetry - merged - idempotence
-    nxos_telemetry: *merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  - name: Telemetry - change values
-    nxos_telemetry: &merged_change
-      state: 'merged'
-      config:
-        certificate:
-          key: /bootflash/local_server.key
-          hostname: localhost
-        compression: gzip
-        source_interface: "{{source_interface|default(omit)}}"
-        vrf: management
-        destination_groups:
-          - id: 2
-            destination:
-              ip: 192.168.0.1
-              port: 50001
-              protocol: grpc
-              encoding: gpb
-          - { id: 2, destination: {ip: 192.168.0.2, port: 60001, protocol: gRPC, encoding: GPB}}
-          - { id: 10, destination: {ip: 192.168.0.1, port: 50001, protocol: Grpc, encoding: gPB}}
-          - { id: 10, destination: {ip: 192.168.0.2, port: 60001, protocol: gRPC, encoding: gpb}}
-        sensor_groups:
-          - { id: 8, data_source: NX-API, path: {name: '"show bgp l2vpn evpn summary"', depth: 0, query_condition: foo, filter_condition: foo}}
-          - { id: 2, data_source: NX-API, path: {name: '"show ip bgp neighbors"', depth: unbounded, query_condition: foo, filter_condition: foo}}
-          - { id: 55, data_source: DME, path: {name: 'sys/bgp/inst/dom-default/peer-[10.10.10.11]/ent-[10.10.10.11]', depth: 0, query_condition: foo, filter_condition: foo}}
-          - { id: 55, data_source: DME, path: {name: sys/ospf, depth: 0, query_condition: foo, filter_condition: 'or(eq(ethpmPhysIf.operSt,"down"),eq(ethpmPhysIf.operSt,"up"))'}}
-        subscriptions:
-          - { id: 44, destination_group: 10, sensor_group: {id: 8, sample_interval: 1000}}
-          - { id: 44, destination_group: 2, sensor_group: {id: 2, sample_interval: 2000}}
-          - { id: 55, destination_group: 10, sensor_group: {id: 55, sample_interval: 2000}}
-    register: result
-
-    # The step above should result in only the following changes:
-    # "commands": [
-    #     "telemetry",
-    #     "certificate /bootflash/local_server.key localhost",
-    #     "subscription 44",
-    #     "snsr-grp 8 sample-interval 1000"
-    # ],
-
-  - set_fact:
-      test_list:
-        - "telemetry"
-        - "certificate /bootflash/local_server.key localhost"
-        - "subscription 44"
-        - "snsr-grp 8 sample-interval 1000"
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "test_list|symmetric_difference(result.commands)|length == 0"
-
-  - name: Telemetry - change values - idempotent
-    nxos_telemetry: *merged_change
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: Teardown
-    nxos_feature: *setup_teardown
-    ignore_errors: yes
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_telemetry merged sanity test"
diff --git a/test/integration/targets/nxos_telemetry/tests/common/replaced.yaml b/test/integration/targets/nxos_telemetry/tests/common/replaced.yaml
deleted file mode 100644
index 6ddcaaad8d..0000000000
--- a/test/integration/targets/nxos_telemetry/tests/common/replaced.yaml
+++ /dev/null
@@ -1,190 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_telemetry replaced sanity test"
-
-- set_fact: source_interface="Loopback55"
-  when: imagetag and (major_version is version_compare('9.1', 'ge'))
-
-- set_fact: command_list_length=27
-- set_fact: command_list_length=28
-  when: imagetag and (major_version is version_compare('9.1', 'ge'))
-
-- set_fact: dict_facts_length=6
-- set_fact: dict_facts_length=7
-  when: imagetag and (major_version is version_compare('9.1', 'ge'))
-
-- name: Setup - disable feature telemetry
-  nxos_feature: &setup_teardown
-    feature: telemetry
-    state: disabled
-  ignore_errors: yes
-
-- name: Setup - enable feature telemetry
-  nxos_feature:
-    feature: telemetry
-    state: enabled
-
-- name: Setup - add initial telemetry config
-  cli_config:
-    config: |
-      telemetry
-        certificate test_cert host.example.com
-        destination-profile
-          use-vrf blue
-          use-compression gzip
-        destination-group 2
-          ip address 192.168.0.1 port 50001 protocol gRPC encoding GPB
-          ip address 192.168.0.2 port 60001 protocol gRPC encoding GPB
-        destination-group 10
-          ip address 192.168.0.1 port 50001 protocol gRPC encoding GPB
-          ip address 192.168.0.2 port 60001 protocol gRPC encoding GPB
-          ip address 192.168.1.1 port 55 protocol HTTP encoding JSON
-          ip address 192.168.1.2 port 100 protocol gRPC encoding GPB
-        destination-group 99
-        sensor-group 2
-          data-source NX-API
-          path "show bgp l2vpn evpn summary" depth unbounded query-condition foo filter-condition foo
-        sensor-group 8
-          data-source NX-API
-          path "show ip bgp neighbors" depth 0 query-condition foo filter-condition foo
-        sensor-group 55
-          data-source DME
-          path sys/bgp/inst/dom-default/peer-[10.10.10.11]/ent-[10.10.10.11] depth 0 query-condition foo filter-condition foo
-          path sys/ospf depth 0 query-condition foo filter-condition or(eq(ethpmPhysIf.operSt,"down"),eq(ethpmPhysIf.operSt,"up"))
-        sensor-group 77
-        subscription 44
-          dst-grp 2
-          dst-grp 10
-          snsr-grp 2 sample-interval 2000
-          snsr-grp 8 sample-interval 2000
-        subscription 55
-          dst-grp 10
-          snsr-grp 55 sample-interval 2000
-        subscription 99
-          dst-grp 2
-          dst-grp 99
-          snsr-grp 8 sample-interval 90000
-          snsr-grp 77 sample-interval 2000
-- name: Setup - add initial source-interface telemetry config
-  cli_config:
-    config: |
-      telemetry
-        destination-profile
-          source-interface loopback55
-  when: imagetag and (major_version is version_compare('9.1', 'ge'))
-
-- block:
-  - name: Gather Telemetry Facts Before Changes
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources:
-        - telemetry
-
-  - name: Telemetry - replaced
-    nxos_telemetry: &replace
-      state: 'replaced'
-      config:
-        certificate:
-          key: /file_dir/new_server.key
-          hostname: newhost.example.com
-        vrf: management
-        compression: gzip
-        destination_groups:
-          - id: 2
-            destination:
-              ip: 192.168.0.1
-              port: 65001
-              protocol: grpc
-              encoding: gpb
-          - id: 2
-            destination:
-              ip: 192.168.0.3
-              port: 55001
-              protocol: grpc
-              encoding: gpb
-        sensor_groups:
-          - id: 100
-            data_source: NX-API
-            path:
-              name: '"show bgp l2vpn evpn summary"'
-              depth: unbounded
-              query_condition: foo
-              filter_condition: foo
-        subscriptions:
-          - id: 99
-            destination_group: 2
-            sensor_group:
-              id: 100
-              sample_interval: 2000
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "result.before|length == {{ dict_facts_length }}"
-        - "result.before.certificate|length == 2"
-        - "result.before.destination_groups|length == 7"
-        - "result.before.sensor_groups|length == 8"
-        - "result.before.subscriptions|length == 10"
-        - "'telemetry' in result.commands"
-        - "'no subscription 55' in result.commands"
-        - "'subscription 99' in result.commands"
-        - "'no dst-grp 99' in result.commands"
-        - "'no snsr-grp 8 sample-interval 90000' in result.commands"
-        - "'no snsr-grp 77 sample-interval 2000' in result.commands"
-        - "'no subscription 44' in result.commands"
-        - "'no sensor-group 55' in result.commands"
-        - "'no sensor-group 8' in result.commands"
-        - "'no sensor-group 2' in result.commands"
-        - "'no sensor-group 77' in result.commands"
-        - "'no destination-group 99' in result.commands"
-        - "'no destination-group 10' in result.commands"
-        - "'destination-group 2' in result.commands"
-        - "'no ip address 192.168.0.1 port 50001 protocol grpc encoding gpb' in result.commands"
-        - "'no ip address 192.168.0.2 port 60001 protocol grpc encoding gpb' in result.commands"
-        - "'destination-group 2' in result.commands"
-        - "'ip address 192.168.0.1 port 65001 protocol grpc encoding gpb' in result.commands"
-        - "'ip address 192.168.0.3 port 55001 protocol grpc encoding gpb' in result.commands"
-        - "'sensor-group 100' in result.commands"
-        - result.commands is search("path .*show bgp l2vpn evpn summary.* depth unbounded query-condition foo filter-condition foo")
-        - "'data-source NX-API' in result.commands"
-        - "'subscription 99' in result.commands"
-        - "'snsr-grp 100 sample-interval 2000' in result.commands"
-        - "'certificate /file_dir/new_server.key newhost.example.com' in result.commands"
-        - "'destination-profile' in result.commands"
-        - "'use-vrf management' in result.commands"
-        - "result.commands|length == {{ command_list_length }}"
-
-  # Source interface may or may not be included based on the image version.
-  - assert:
-      that:
-        - "'no source-interface loopback55' in result.commands"
-    when: imagetag and (major_version is version_compare('9.1', 'ge'))
-
-  - assert:
-      that:
-        - "(ansible_facts.network_resources.telemetry|dict2items)|symmetric_difference(result.before|dict2items)|length == 0"
-
-  - name: Gather Telemetry Facts After Changes
-    nxos_facts: *facts
-
-  - assert:
-      that:
-        - "(ansible_facts.network_resources.telemetry|dict2items)|symmetric_difference(result.after|dict2items)|length == 0"
-
-  - name: Telemetry - replaced - idempotence
-    nxos_telemetry: *replace
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: Teardown
-    nxos_feature: *setup_teardown
-    ignore_errors: yes
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_telemetry replaced sanity test"
diff --git a/test/integration/targets/nxos_udld/defaults/main.yaml b/test/integration/targets/nxos_udld/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_udld/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_udld/meta/main.yml b/test/integration/targets/nxos_udld/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_udld/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_udld/tasks/cli.yaml b/test/integration/targets/nxos_udld/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_udld/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_udld/tasks/main.yaml b/test/integration/targets/nxos_udld/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_udld/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_udld/tasks/nxapi.yaml b/test/integration/targets/nxos_udld/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_udld/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_udld/tests/common/sanity.yaml b/test/integration/targets/nxos_udld/tests/common/sanity.yaml
deleted file mode 100644
index 7430381137..0000000000
--- a/test/integration/targets/nxos_udld/tests/common/sanity.yaml
+++ /dev/null
@@ -1,92 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_udld sanity test"
-
-- set_fact: udld_run="true"
-- set_fact: udld_run="false"
-  when: ((platform is search('N9K-F')) and (imagetag and (imagetag is version_compare('F3', 'lt'))))
-- set_fact: udld_run="false"
-  when: titanium
-
-- block:
-  - name: "Enable feature udld"
-    nxos_feature: 
-      feature: udld
-      state: enabled
-
-  - name: Configure udld
-    nxos_udld: &conf1
-      aggressive: enabled
-      msg_time: 20
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Check Idempotence"
-    nxos_udld: *conf1
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Reset udld
-    nxos_udld:
-      reset: True
-
-  - name: Configure udld2
-    nxos_udld: &conf2
-      aggressive: disabled
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_udld: *conf2
-    register: result
-
-  - assert: *false
-
-  - name: Configure udld3
-    nxos_udld: &conf3
-      msg_time: default
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_udld: *conf3
-    register: result
-
-  - assert: *false
-
-  - name: Configure udld again
-    nxos_udld: *conf1
-    register: result
-
-  - assert: *true
-
-  - name: Remove udld config
-    nxos_udld: &conf4
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Check Idempotence"
-    nxos_udld: *conf4
-    register: result
-
-  - assert: *false
-
-  when: udld_run
-
-  always:
-  - name: "Disable udld"
-    nxos_feature: 
-      feature: udld
-      state: disabled
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_udld sanity test"
diff --git a/test/integration/targets/nxos_udld_interface/defaults/main.yaml b/test/integration/targets/nxos_udld_interface/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_udld_interface/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_udld_interface/meta/main.yml b/test/integration/targets/nxos_udld_interface/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_udld_interface/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_udld_interface/tasks/cli.yaml b/test/integration/targets/nxos_udld_interface/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_udld_interface/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_udld_interface/tasks/main.yaml b/test/integration/targets/nxos_udld_interface/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_udld_interface/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_udld_interface/tasks/nxapi.yaml b/test/integration/targets/nxos_udld_interface/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_udld_interface/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_udld_interface/tests/common/sanity.yaml b/test/integration/targets/nxos_udld_interface/tests/common/sanity.yaml
deleted file mode 100644
index 18893cba8a..0000000000
--- a/test/integration/targets/nxos_udld_interface/tests/common/sanity.yaml
+++ /dev/null
@@ -1,108 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_udld_interface sanity test"
-
-- set_fact: udld_run="true"
-- set_fact: udld_enable="true"
-- set_fact: udld_run="false"
-  when: ((platform is search('N9K-F')) and (imagetag and (imagetag is version_compare('F3', 'lt'))))
-- set_fact: udld_run="false"
-  when: titanium
-- set_fact: udld_enable="false"
-  when: imagetag and (imagetag is version_compare('N1', 'eq'))
-
-# Select interface for test
-- set_fact: intname="{{ nxos_int1 }}"
-
-- block:
-  - name: "Enable feature udld"
-    nxos_feature: 
-      feature: udld
-      state: enabled
-
-  - name: "put the interface into default state"
-    nxos_config: 
-      commands:
-        - "default interface {{intname}}"
-      match: none
-
-  - name: ensure interface is configured to be in aggressive mode
-    nxos_udld_interface: &conf1
-      interface: "{{ intname }}"
-      mode: aggressive
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Conf1 Idempotence"
-    nxos_udld_interface: *conf1
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - block:
-
-    - name: ensure interface has mode enabled
-      nxos_udld_interface: &conf2
-        interface: "{{ intname }}"
-        mode: enabled
-        state: present
-      register: result
-
-    - assert: *true
-
-    - name: "Conf2 Idempotence"
-      nxos_udld_interface: *conf2
-      register: result
-
-    - assert: *false
-
-    - name: ensure interface has mode aggressive
-      nxos_udld_interface: *conf1
-      register: result
-
-    - assert: *true
-
-    - name: "Conf1 Idempotence"
-      nxos_udld_interface: *conf1
-      register: result
-
-    - assert: *false
-
-    - name: ensure interface has mode disabled
-      nxos_udld_interface: &conf3
-        interface: "{{ intname }}"
-        mode: disabled
-        state: present
-      register: result
-
-    - assert: *true
-
-    - name: "Conf3 Idempotence"
-      nxos_udld_interface: *conf3
-      register: result
-
-    - assert: *false
-
-    when: udld_enable
-
-  - name: Remove the config
-    nxos_udld_interface: &remove
-      interface: "{{ intname }}"
-      mode: enabled
-      state: absent
-
-  when: udld_run
-
-  always:
-  - name: "Disable udld"
-    nxos_feature: 
-      feature: udld
-      state: disabled
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_udld_interface sanity test"
diff --git a/test/integration/targets/nxos_user/defaults/main.yaml b/test/integration/targets/nxos_user/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_user/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_user/meta/main.yaml b/test/integration/targets/nxos_user/meta/main.yaml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_user/meta/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_user/tasks/cli.yaml b/test/integration/targets/nxos_user/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_user/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_user/tasks/main.yaml b/test/integration/targets/nxos_user/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_user/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_user/tasks/nxapi.yaml b/test/integration/targets/nxos_user/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_user/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_user/tests/common/auth.yaml b/test/integration/targets/nxos_user/tests/common/auth.yaml
deleted file mode 100644
index a05b1aa5ff..0000000000
--- a/test/integration/targets/nxos_user/tests/common/auth.yaml
+++ /dev/null
@@ -1,34 +0,0 @@
----
-- block:
-  - name: Create user with password
-    nxos_user:
-      name: auth_user
-      role: network-operator
-      state: present
-      configured_password: pasS!123
-
-  - name: test login
-    expect:
-      command: "ssh auth_user@{{ ansible_ssh_host }} -p {{ ansible_ssh_port|default(22) }} -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o PubkeyAuthentication=no show version"
-      responses:
-        (?i)password: "pasS!123"
-
-  - name: test login with invalid password (should fail)
-    expect:
-      command: "ssh auth_user@{{ ansible_ssh_host }} -p {{ ansible_ssh_port|default(22) }} -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o PubkeyAuthentication=no show version"
-      responses:
-        (?i)password: "badpass"
-    ignore_errors: yes
-    register: results
-
-  - name: check that attempt failed
-    assert:
-      that:
-        - results.failed
-
-  always:
-  - name: delete user
-    nxos_user:
-      name: auth_user
-      state: absent
-    register: result
diff --git a/test/integration/targets/nxos_user/tests/common/basic.yaml b/test/integration/targets/nxos_user/tests/common/basic.yaml
deleted file mode 100644
index cf77ed3870..0000000000
--- a/test/integration/targets/nxos_user/tests/common/basic.yaml
+++ /dev/null
@@ -1,55 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_user basic test"
-
-- name: Remove old entries of user
-  nxos_user:
-    aggregate:
-      - { name: ansibletest1 }
-      - { name: ansibletest2 }
-      - { name: ansibletest3 }
-    state: absent
-
-# Start tests
-- name: Create user
-  nxos_user:
-    name: ansibletest1
-    roles: network-operator
-    state: present
-  register: result
-
-- debug: msg="{{result}}"
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"username" in result.commands[0]'
-      - '"role network-operator" in result.commands[0]'
-
-- name: Collection of users
-  nxos_user:
-    aggregate:
-      - { name: ansibletest2 }
-      - { name: ansibletest3 }
-    state: present
-    roles: network-admin
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-
-- name: tearDown
-  nxos_user:
-    aggregate:
-      - { name: ansibletest1 }
-      - { name: ansibletest2 }
-      - { name: ansibletest3 }
-    state: absent
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"no username" in result.commands[0]'
-
-- debug: msg="END connection={{ ansible_connection }} nxos_user basic test"
diff --git a/test/integration/targets/nxos_user/tests/common/net_user.yaml b/test/integration/targets/nxos_user/tests/common/net_user.yaml
deleted file mode 100644
index 4676577d29..0000000000
--- a/test/integration/targets/nxos_user/tests/common/net_user.yaml
+++ /dev/null
@@ -1,31 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos common/net_user.yaml"
-
-# Add minimal testcase to check args are passed correctly to
-# implementation module and module run is successful.
-
-- name: "Remove old entries of user - setup"
-  net_user:
-    name: ansibletest1
-    state: absent
-
-# Start tests
-- name: Create user with platform agnostic module
-  net_user:
-    name: ansibletest1
-    roles: network-operator
-    state: present
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"username" in result.commands[0]'
-      - '"role network-operator" in result.commands[0]'
-
-- name: teardown
-  net_user:
-    name: ansibletest1
-    state: absent
-
-- debug: msg="END connection={{ ansible_connection }} nxos common/net_user.yaml"
diff --git a/test/integration/targets/nxos_user/tests/common/sanity.yaml b/test/integration/targets/nxos_user/tests/common/sanity.yaml
deleted file mode 100644
index 86b7e4e7fb..0000000000
--- a/test/integration/targets/nxos_user/tests/common/sanity.yaml
+++ /dev/null
@@ -1,110 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_user parameter test"
-
-- set_fact: idem="true"
-- set_fact: idem="false"
-  when: ((platform is search('N7K')) and (imagetag and (imagetag is version_compare('D1', 'eq'))))
-
-- block:
-  - name: Create user
-    nxos_user: &configure
-      name: netend
-      configured_password: Hello!23$
-      update_password: on_create
-      roles: network-operator
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - 'result.changed == true'
-
-  - block:
-    - name: conf idempotency
-      nxos_user: *configure
-      register: result
-
-    - assert: &false
-        that:
-          - 'result.changed == false'
-    when: idem
-
-  - name: Remove user
-    nxos_user: &remove
-      name: netend
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: remove idempotency
-    nxos_user: *remove
-    register: result
-
-  - assert: *false
-
-  - debug: msg="skipping sshkey test as the key needs to be created on the server first"
-
-#  - name: create a new user
-#    nxos_user: &conf1
-#      name: ansible
-#      sshkey: "{{ lookup('file', '~/.ssh/id_rsa.pub') }}"
-#      state: present
-#    register: result
-#
-#  - assert: *true
-
-#  - block:
-#    - name: user idempotency
-#      nxos_user: *conf1
-#      register: result
-#
-#    - assert: *false
-#
-#    when: idem
-
-  - name: Collection of users
-    nxos_user: &coll
-      users:
-        - name: test1
-        - name: test2
-      configured_password: Hello!23$
-      update_password: on_create
-      state: present
-      roles: 
-        - network-admin
-        - network-operator
-    register: result
-
-  - assert: *true
-
-  - block:
-    - name: users idempotency
-      nxos_user: *coll
-      register: result
-
-    - assert: *false
-
-    when: idem
-
-  - name: tearDown
-    nxos_user: &tear
-      name: "{{ ansible_user }}"
-      purge: yes
-    register: result
-
-  - assert: *true
-
-  - name: teardown idempotency
-    nxos_user: *tear
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: tearDown
-    nxos_user: *tear
-    register: result
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_user parameter test"
diff --git a/test/integration/targets/nxos_vlan/defaults/main.yaml b/test/integration/targets/nxos_vlan/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_vlan/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_vlan/meta/main.yml b/test/integration/targets/nxos_vlan/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_vlan/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_vlan/tasks/cli.yaml b/test/integration/targets/nxos_vlan/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_vlan/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vlan/tasks/main.yaml b/test/integration/targets/nxos_vlan/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_vlan/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_vlan/tasks/nxapi.yaml b/test/integration/targets/nxos_vlan/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_vlan/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vlan/tests/common/agg.yaml b/test/integration/targets/nxos_vlan/tests/common/agg.yaml
deleted file mode 100644
index 690e89c80d..0000000000
--- a/test/integration/targets/nxos_vlan/tests/common/agg.yaml
+++ /dev/null
@@ -1,114 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }}/agg.yaml"
-
-- name: setup - remove vlan used in test
-  nxos_config: &rm
-    lines:
-      - no vlan 102
-      - no vlan 103
-      - no vlan 104
-  ignore_errors: yes
-
-
-- name: configure vlan with aggregate
-  nxos_vlan: &conf1
-    aggregate:
-      - { name: app02, vlan_id: 102 }
-      - { name: app03, vlan_id: 103 }
-    vlan_state: active
-    admin_state: up
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"vlan 102" in result.commands'
-      - '"vlan 103" in result.commands'
-      - '"no shutdown" in result.commands'
-      - '"state active" in result.commands'
-
-- name: conf1 - Idempotence
-  nxos_vlan: *conf1
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- name: change property of existing vlan - admin_state down
-  nxos_vlan: &conf2
-    aggregate:
-      - { name: app02, vlan_id: 102 }
-      - { name: app03, vlan_id: 103 }
-    vlan_state: active
-    admin_state: down
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"vlan 102" in result.commands'
-      - '"vlan 103" in result.commands'
-      - '"shutdown" in result.commands'
-
-- name: conf2 - Idempotence
-  nxos_vlan: *conf2
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- name: purge
-  nxos_vlan: &purge
-    vlan_id: 1
-    purge: yes
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"no vlan 102" in result.commands'
-      - '"no vlan 103" in result.commands'
-
-- name: purge - Idempotence
-  nxos_vlan: *purge
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- name: "setup for purge test with aggregate add"
-  nxos_vlan:
-    vlan_id: 104
-    purge: true
-
-- name: purge 104 with aggregate add 102-103
-  nxos_vlan: &purge_add
-    aggregate:
-      - { vlan_id: 102 }
-      - { vlan_id: 103 }
-    purge: true
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"vlan 102" in result.commands'
-      - '"vlan 103" in result.commands'
-      - '"no vlan 104" in result.commands'
-
-- name: purge_add - Idempotence
-  nxos_vlan: *purge_add
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- name: teardown
-  nxos_config: *rm
-  ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }}/agg.yaml"
diff --git a/test/integration/targets/nxos_vlan/tests/common/interface.yaml b/test/integration/targets/nxos_vlan/tests/common/interface.yaml
deleted file mode 100644
index 580feadaa9..0000000000
--- a/test/integration/targets/nxos_vlan/tests/common/interface.yaml
+++ /dev/null
@@ -1,124 +0,0 @@
----
-- set_fact: testint1="{{ nxos_int1 }}"
-- set_fact: testint2="{{ nxos_int2 }}"
-
-- name: setup - remove vlan used in test
-  nxos_config:
-    lines:
-      - no vlan 100
-  ignore_errors: yes
-
-- name: setup - remove vlan from interfaces used in test(part1)
-  nxos_config:
-    lines:
-      - no switchport access vlan 100
-    parents: switchport
-    before: "interface {{ testint1 }}"
-
-- name: setup - remove vlan from interfaces used in test(part2)
-  nxos_config:
-    lines:
-      - no switchport access vlan 100
-    parents: switchport
-    before: "interface {{ testint2 }}"
-
-- name: create vlan
-  nxos_vlan:
-    vlan_id: 100
-
-- name: Add interfaces to vlan and check intent (config + intent)
-  nxos_vlan: &interfaces
-    vlan_id: 100
-    interfaces:
-      - "{{ testint1 }}"
-      - "{{ testint2 }}"
-    associated_interfaces:
-      - "{{ testint1 }}"
-      - "{{ testint2 }}"
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"interface {{ testint1 }}" in result.commands'
-      - '"switchport" in result.commands'
-      - '"switchport mode access" in result.commands'
-      - '"switchport access vlan 100" in result.commands'
-      - '"interface {{ testint2 }}" in result.commands'
-      - '"switchport" in result.commands'
-      - '"switchport mode access" in result.commands'
-      - '"switchport access vlan 100" in result.commands'
-
-- name: Add interfaces to vlan(idempotence)
-  nxos_vlan: *interfaces
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- name: Check interfaces intent
-  nxos_vlan:
-    vlan_id: 100
-    associated_interfaces:
-      - "{{ testint1 }}"
-      - "{{ testint2 }}"
-  register: result
-
-- assert:
-    that:
-      - "result.failed == false"
-
-- name: Check interfaces intent fail
-  nxos_vlan:
-    vlan_id: 100
-    associated_interfaces:
-      - test
-  register: result
-  ignore_errors: yes
-
-- assert:
-    that:
-      - "result.failed == True"
-
-- name: Remove interface from vlan
-  nxos_vlan: &single_int
-    vlan_id: 100
-    interfaces:
-      - "{{ testint2 }}"
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"interface {{ testint1 }}" in result.commands'
-      - '"switchport" in result.commands'
-      - '"switchport mode access" in result.commands'
-      - '"no switchport access vlan 100" in result.commands'
-
-- name: Remove interface from vlan(idempotence)
-  nxos_vlan: *single_int
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- name: teardown(part1)
-  nxos_config:
-    lines:
-      - no vlan 100
-
-- name: teardown - remove vlan from interfaces used in test(part1)
-  nxos_config:
-    lines:
-      - no switchport access vlan 100
-    parents: switchport
-    before: "interface {{ testint1 }}"
-
-- name: teardown - remove vlan from interfaces used in test(part2)
-  nxos_config:
-    lines:
-      - no switchport access vlan 100
-    parents: switchport
-    before: "interface {{ testint2 }}"
diff --git a/test/integration/targets/nxos_vlan/tests/common/sanity.yaml b/test/integration/targets/nxos_vlan/tests/common/sanity.yaml
deleted file mode 100644
index 5204f3c419..0000000000
--- a/test/integration/targets/nxos_vlan/tests/common/sanity.yaml
+++ /dev/null
@@ -1,224 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_vlan sanity test"
-
-- set_fact: testint1="{{ nxos_int1 }}"
-- set_fact: testint2="{{ nxos_int2 }}"
-
-- block:
-  - name: Install and Enable FabricPath feature set
-    nxos_config:
-      lines:
-        - install feature-set fabricpath
-        - feature-set fabricpath
-    when: platform is search('N5K|N7K')
-
-  - name: "Enable feature vn segment"
-    nxos_config:
-      commands:
-        - feature vn-segment-vlan-based
-      match: none
-    when: platform is search('N9K')
-
-  - name: vlan teardown
-    nxos_vlan: &vlan_teardown
-      vlan_range: "2-200"
-      state: absent
-    ignore_errors: yes
-
-  - name: Ensure a range of VLANs are present on the switch
-    nxos_vlan: &conf_vlan
-      vlan_range: "2-10,20,50,55-60,100-150"
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Vlan Idempotence"
-    nxos_vlan: *conf_vlan
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Ensure VLAN 50 exists with the name WEB and is in the shutdown state
-    nxos_vlan: &web1
-      vlan_id: 50
-      vlan_state: suspend
-      admin_state: down
-      name: WEB
-      mapped_vni: 5555
-    register: result
-    when: platform is search('N9K')
-
-  - assert: *true
-    when: platform is search('N9K')
-
-  - name: "web1 Idempotence"
-    nxos_vlan: *web1
-    register: result
-    when: platform is search('N9K')
-
-  - assert: *false
-    when: platform is search('N9K')
-
-  - name: change name and vni to default
-    nxos_vlan: &web2
-      vlan_id: 50
-      vlan_state: active
-      admin_state: up
-      name: default
-      mapped_vni: default
-    register: result
-    when: platform is search('N9K')
-
-  - assert: *true
-    when: platform is search('N9K')
-
-  - name: "web2 Idempotence"
-    nxos_vlan: *web2
-    register: result
-    when: platform is search('N9K')
-
-  - assert: *false
-    when: platform is search('N9K')
-
-  - name: Ensure VLAN 50 exists with the name WEB and is in the shutdown state
-    nxos_vlan: &web3
-      vlan_id: 50
-      vlan_state: suspend
-      admin_state: down
-      name: WEB
-    register: result
-    when: platform is search('N3K|N7K')
-
-  - assert: *true
-    when: platform is search('N3K|N7K')
-
-  - name: "web3 Idempotence"
-    nxos_vlan: *web3
-    register: result
-    when: platform is search('N3K|N7K')
-
-  - assert: *false
-    when: platform is search('N3K|N7K')
-
-  - name: Change name to default
-    nxos_vlan: &web4
-      vlan_id: 50
-      vlan_state: active
-      admin_state: up
-      name: default
-    register: result
-    when: platform is search('N3K|N7K')
-
-  - assert: *true
-    when: platform is search('N3K|N7K')
-
-  - name: "web4 Idempotence"
-    nxos_vlan: *web4
-    register: result
-    when: platform is search('N3K|N7K')
-
-  - assert: *false
-    when: platform is search('N3K|N7K')
-
-  - name: Change mode
-    nxos_vlan: &mode1
-      vlan_id: 50
-      mode: fabricpath
-    register: result
-    when: platform is search('N5K|N7K')
-
-  - assert: *true
-    when: platform is search('N5K|N7K')
-
-  - name: "mode1 Idempotence"
-    nxos_vlan: *mode1
-    register: result
-    when: platform is search('N5K|N7K')
-
-  - assert: *false
-    when: platform is search('N5K|N7K')
-
-  - name: Change mode again
-    nxos_vlan: &mode2
-      vlan_id: 50
-      mode: ce
-    register: result
-    when: platform is search('N5K|N7K')
-
-  - assert: *true
-    when: platform is search('N5K|N7K')
-
-  - name: "mode2 Idempotence"
-    nxos_vlan: *mode2
-    register: result
-    when: platform is search('N5K|N7K')
-
-  - assert: *false
-    when: platform is search('N5K|N7K')
-
-  - name: Ensure VLAN is NOT on the device
-    nxos_vlan: &no_vlan
-      vlan_id: 50
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "no vlan Idempotence"
-    nxos_vlan: *no_vlan
-    register: result
-
-  - assert: *false
-
-  - name: Add interfaces to vlan
-    nxos_vlan: &addint
-      vlan_id: 101
-      vlan_state: suspend
-      interfaces:
-        - "{{ testint1 }}"
-        - "{{ testint2 }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Addint idempotence"
-    nxos_vlan: *addint
-    register: result
-
-  - assert: *false
-
-  - name: Remove interfaces from vlan
-    nxos_vlan: &remint
-      vlan_id: 101
-      interfaces: default
-    register: result
-
-  - assert: *true
-
-  - name: "Remint idempotence"
-    nxos_vlan: *remint
-    register: result
-
-  - assert: *false
-
-  always:
-    - name: Remove int from vlan
-      nxos_vlan: *remint
-      ignore_errors: yes
-
-    - name: vlan teardown final
-      nxos_vlan: *vlan_teardown
-      ignore_errors: yes
-
-    - name: "Disable feature vn segement"
-      nxos_feature:
-        feature: vn-segment-vlan-based
-        state: disabled
-      ignore_errors: yes
-      when: platform is search('N9K')
-
-- debug: msg="END connection={{ ansible_connection }} nxos_vlan sanity test"
diff --git a/test/integration/targets/nxos_vlans/defaults/main.yaml b/test/integration/targets/nxos_vlans/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_vlans/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_vlans/meta/main.yml b/test/integration/targets/nxos_vlans/meta/main.yml
deleted file mode 100644
index 32cf5dda7e..0000000000
--- a/test/integration/targets/nxos_vlans/meta/main.yml
+++ /dev/null
@@ -1 +0,0 @@
-dependencies: []
diff --git a/test/integration/targets/nxos_vlans/tasks/cli.yaml b/test/integration/targets/nxos_vlans/tasks/cli.yaml
deleted file mode 100644
index 6c7ea4a7f9..0000000000
--- a/test/integration/targets/nxos_vlans/tasks/cli.yaml
+++ /dev/null
@@ -1,20 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vlans/tasks/main.yaml b/test/integration/targets/nxos_vlans/tasks/main.yaml
deleted file mode 100644
index 415c99d8b1..0000000000
--- a/test/integration/targets/nxos_vlans/tasks/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
diff --git a/test/integration/targets/nxos_vlans/tasks/nxapi.yaml b/test/integration/targets/nxos_vlans/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_vlans/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vlans/tests/cli/deleted.yaml b/test/integration/targets/nxos_vlans/tests/cli/deleted.yaml
deleted file mode 100644
index e3e8de7d06..0000000000
--- a/test/integration/targets/nxos_vlans/tests/cli/deleted.yaml
+++ /dev/null
@@ -1,48 +0,0 @@
----
-- debug:
-    msg: "Start nxos_vlans deleted integration tests connection={{ ansible_connection }}"
-
-- name: setup
-  cli_config:
-    config: |
-      no vlan 2-100
-      vlan 5
-      vlan 6
-
-- block:
-  - name: Gather vlans facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: vlans
-
-  - name: deleted
-    nxos_vlans: &deleted
-      state: deleted
-    register: result
-
-  - assert:
-      that:
-        - "result.before|length == (ansible_facts.network_resources.vlans|length - 1)"
-        - "result.after|length == 0"
-        - "result.changed == true"
-        - "'no vlan 5' in result.commands"
-        - "'no vlan 6' in result.commands"
-        - "result.commands|length == 2"
-
-  - name: Idempotence - deleted
-    nxos_vlans: *deleted
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config:
-      config: |
-        no vlan 5
-        no vlan 6
diff --git a/test/integration/targets/nxos_vlans/tests/cli/merged.yaml b/test/integration/targets/nxos_vlans/tests/cli/merged.yaml
deleted file mode 100644
index 88000fbca7..0000000000
--- a/test/integration/targets/nxos_vlans/tests/cli/merged.yaml
+++ /dev/null
@@ -1,55 +0,0 @@
----
-- debug:
-    msg: "Start nxos_vlans merged integration tests connection={{ ansible_connection }}"
-
-- name: setup
-  cli_config: &cleanup
-    config: |
-      no vlan 2-100
-
-- block:
-  - name: Merged
-    nxos_vlans: &merged
-      config:
-        - vlan_id: 5
-          name: vlan5
-        - vlan_id: 6
-          name: vlan6
-          state: suspend
-      state:  merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-        - "result.before|length == 0"
-        - "'vlan 5' in result.commands"
-        - "'name vlan5' in result.commands"
-        - "'vlan 6' in result.commands"
-        - "'name vlan6' in result.commands"
-        - "'state suspend' in result.commands"
-        - "result.commands|length == 5"
-
-  - name: Gather vlans facts
-    nxos_facts:
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: vlans
-
-  - assert:
-      that:
-        - "result.after|length == (ansible_facts.network_resources.vlans|length - 1)"
-
-  - name: Idempotence - Merged
-    nxos_vlans: *merged
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *cleanup
diff --git a/test/integration/targets/nxos_vlans/tests/cli/overridden.yaml b/test/integration/targets/nxos_vlans/tests/cli/overridden.yaml
deleted file mode 100644
index ad0760ea4a..0000000000
--- a/test/integration/targets/nxos_vlans/tests/cli/overridden.yaml
+++ /dev/null
@@ -1,65 +0,0 @@
----
-- debug:
-    msg: "Start nxos_vlans overridden integration tests connection={{ ansible_connection }}"
-
-- name: setup1
-  cli_config: &cleanup
-    config: |
-      no vlan 2-100
-
-- block:
-  - name: setup
-    cli_config:
-      config: |
-        vlan 5
-          name test-vlan5
-        state suspend
-          vlan 6
-          exit
-
-  - name: Gather vlans facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: vlans
-
-  - name: Overridden
-    nxos_vlans: &overridden
-      config:
-        - vlan_id: 9
-          name: test-vlan9
-          enabled: false
-      state: overridden
-    register: result
-
-  - assert:
-      that:
-        - "result.before|length == (ansible_facts.network_resources.vlans|length - 1)"
-        - "result.changed == true"
-        - "'no vlan 5' in result.commands"
-        - "'no vlan 6' in result.commands"
-        - "'vlan 9' in result.commands"
-        - "'name test-vlan9' in result.commands"
-        - "'shutdown' in result.commands"
-        - "result.commands|length == 5"
-
-  - name: Gather vlans post facts
-    nxos_facts: *facts
-
-  - assert:
-      that:
-        - "result.after|length == (ansible_facts.network_resources.vlans|length - 1)"
-
-  - name: Idempotence - Overridden
-    nxos_vlans: *overridden
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *cleanup
diff --git a/test/integration/targets/nxos_vlans/tests/cli/replaced.yaml b/test/integration/targets/nxos_vlans/tests/cli/replaced.yaml
deleted file mode 100644
index e55c1dd2e1..0000000000
--- a/test/integration/targets/nxos_vlans/tests/cli/replaced.yaml
+++ /dev/null
@@ -1,62 +0,0 @@
----
-- debug:
-    msg: "Start nxos_vlans replaced integration tests connection={{ ansible_connection }}"
-
-- name: setup1
-  cli_config: &cleanup
-    config: |
-      no vlan 2-100
-
-- block:
-  - name: setup2
-    cli_config:
-      config: |
-        vlan 5
-          name test-vlan5
-        vlan 6
-          name test-vlan6
-          exit
-
-  - name: Gather vlans facts
-    nxos_facts: &facts
-      gather_subset:
-        - '!all'
-        - '!min'
-      gather_network_resources: vlans
-
-  - name: Replaced
-    nxos_vlans: &replaced
-      config:
-        - vlan_id: 6
-          state: suspend
-      state: replaced
-    register: result
-
-  - assert:
-      that:
-        - "result.before|length == (ansible_facts.network_resources.vlans|length - 1)"
-        - "result.changed == true"
-        - "'vlan 6' in result.commands"
-        - "'no name' in result.commands"
-        - "'state suspend' in result.commands"
-        - "result.commands|length == 3"
-
-  - name: Gather vlans post facts
-    nxos_facts: *facts
-
-  - assert:
-      that:
-        - "result.after|length == (ansible_facts.network_resources.vlans|length - 1)"
-
-  - name: Idempotence - Replaced
-    nxos_vlans: *replaced
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-        - "result.commands|length == 0"
-
-  always:
-  - name: teardown
-    cli_config: *cleanup
diff --git a/test/integration/targets/nxos_vpc/defaults/main.yaml b/test/integration/targets/nxos_vpc/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_vpc/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_vpc/meta/main.yml b/test/integration/targets/nxos_vpc/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_vpc/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_vpc/tasks/cli.yaml b/test/integration/targets/nxos_vpc/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_vpc/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vpc/tasks/main.yaml b/test/integration/targets/nxos_vpc/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_vpc/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_vpc/tasks/nxapi.yaml b/test/integration/targets/nxos_vpc/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_vpc/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vpc/tests/common/sanity.yaml b/test/integration/targets/nxos_vpc/tests/common/sanity.yaml
deleted file mode 100644
index 2073223a06..0000000000
--- a/test/integration/targets/nxos_vpc/tests/common/sanity.yaml
+++ /dev/null
@@ -1,178 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_vpc sanity test"
-
-- block:
-  - set_fact: delay_restore_orphan_port=25
-  - set_fact: def_delay_restore_orphan_port=default
-  when: platform is not search("N35|N5K|N6K")
-
-- block:
-  - name: disable vpc for initial vpc config cleanup
-    nxos_feature:
-      feature: vpc
-      state: disabled
-
-  - name: enable feature vpc
-    nxos_feature:
-      feature: vpc
-      state: enabled
-
-  - name: Ensure ntc VRF exists on switch
-    nxos_vrf:
-      vrf: ntc
-
-  - name: Configure vpc
-    nxos_vpc: &conf_vpc
-      state: present
-      domain: 100
-      pkl_dest: 192.168.100.4
-      pkl_src: 10.1.100.20
-      pkl_vrf: ntc
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Conf Idempotence"
-    nxos_vpc: *conf_vpc
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Configure vpc1
-    nxos_vpc: &conf_vpc1
-      state: present
-      domain: 100
-      role_priority: 500
-      system_priority: 2000
-      peer_gw: True
-      delay_restore: 5
-      delay_restore_interface_vlan: 15
-      delay_restore_orphan_port: "{{ delay_restore_orphan_port|default(omit) }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Conf Idempotence"
-    nxos_vpc: *conf_vpc1
-    register: result
-
-  - assert: *false
-
-  - block:
-    # This block is only useful on platforms that nvgen 'no auto-recovery'.
-    # Note: auto_recovery is mutually_exclusive with auto_recovery_reload_delay.
-    - set_fact: def_auto_recovery=False
-    - set_fact: def_auto_recovery=True
-      when: platform is search("N7K")
-
-    - name: auto-recovery from default to non-default
-      nxos_vpc: &auto_recovery_1
-        domain: 100
-        auto_recovery: "{{ not def_auto_recovery }}"
-      register: result
-
-    - assert: *true
-
-    - name: "Conf Idempotence auto-recovery def-to-non-def"
-      nxos_vpc: *auto_recovery_1
-      register: result
-
-    - assert: *false
-
-    - name: auto-recovery from non-default to default
-      nxos_vpc: &auto_recovery_2
-        domain: 100
-        auto_recovery: "{{ def_auto_recovery }}"
-      register: result
-
-    - assert: *true
-
-    - name: "Conf Idempotence auto-recovery non-def-to-def"
-      nxos_vpc: *auto_recovery_2
-      register: result
-
-    - assert: *false
-
-    when: platform is search("N35|N7K|N3K-F|N9K-F")
-
-  - name: Configure auto-recovery reload-delay
-    nxos_vpc: &auto_reload
-      domain: 100
-      auto_recovery_reload_delay: 242
-    register: result
-
-  - assert: *true
-
-  - name: "Conf Idempotence auto-recovery reload-delay"
-    nxos_vpc: *auto_reload
-    register: result
-
-  - assert: *false
-
-  - name: Configure vpc2
-    nxos_vpc: &conf_vpc2
-      state: present
-      domain: 100
-      role_priority: default
-      system_priority: default
-      peer_gw: True
-      delay_restore: default
-      delay_restore_interface_vlan: default
-      delay_restore_orphan_port: "{{ def_delay_restore_orphan_port|default(omit) }}"
-    register: result
-
-  - assert: *true
-
-  - name: "Conf Idempotence"
-    nxos_vpc: *conf_vpc2
-    register: result
-
-  - assert: *false
-
-  - name: Configure vpc3
-    nxos_vpc: &conf_vpc3
-      state: present
-      domain: 100
-      peer_gw: False
-    register: result
-
-  - assert: *true
-
-  - name: "Conf Idempotence"
-    nxos_vpc: *conf_vpc3
-    register: result
-
-  - assert: *false
-
-  - name: remove vpc
-    nxos_vpc: &rem_vpc
-      state: absent
-      domain: 100
-    register: result
-
-  - assert: *true
-
-  - name: "Remove Idempotence"
-    nxos_vpc: *rem_vpc
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: remove vrf
-    nxos_vrf:
-      vrf: ntc
-      state: absent
-    ignore_errors: yes
-
-  - name: disable feature vpc
-    nxos_feature:
-      feature: vpc
-      state: disabled
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_vpc sanity test"
diff --git a/test/integration/targets/nxos_vpc_interface/defaults/main.yaml b/test/integration/targets/nxos_vpc_interface/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_vpc_interface/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_vpc_interface/meta/main.yml b/test/integration/targets/nxos_vpc_interface/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_vpc_interface/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_vpc_interface/tasks/cli.yaml b/test/integration/targets/nxos_vpc_interface/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_vpc_interface/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vpc_interface/tasks/main.yaml b/test/integration/targets/nxos_vpc_interface/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_vpc_interface/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_vpc_interface/tasks/nxapi.yaml b/test/integration/targets/nxos_vpc_interface/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_vpc_interface/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vpc_interface/tests/common/sanity.yaml b/test/integration/targets/nxos_vpc_interface/tests/common/sanity.yaml
deleted file mode 100644
index f29feb08b8..0000000000
--- a/test/integration/targets/nxos_vpc_interface/tests/common/sanity.yaml
+++ /dev/null
@@ -1,140 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_vpc_interface sanity test"
-
-- block:
-  - name: enable feature vpc
-    nxos_feature:
-      feature: vpc
-      state: enabled
-
-  - name: create port-channel10
-    nxos_config:
-      commands:
-        - interface port-channel10
-        - switchport
-      match: none
-
-  - name: create port-channel11
-    nxos_config:
-      commands:
-        - interface port-channel11
-        - switchport
-      match: none
-
-  - name: configure vpc
-    nxos_vpc:
-      state: present
-      domain: 100
-      role_priority: 32667
-      system_priority: 2000
-      pkl_dest: 192.168.100.4
-      pkl_src: 10.1.100.20
-      peer_gw: true
-      auto_recovery: false
-
-  - name: Configure vpc port channel
-    nxos_vpc_interface: &conf
-      portchannel: 10
-      vpc: 10
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Conf Idempotence"
-    nxos_vpc_interface: *conf
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-# The vpc peer-link command seems to be invalid for the NXOSv we have in Zuul CI
-# Hence, we're temporarily skipping the tests that have `peer_link` key
-
-  - name: Configure vpc port channel
-    nxos_vpc_interface: &conf1
-      portchannel: 11
-      peer_link: True
-    register: result
-    when: image_version != "7.0(3)I5(1)"
-
-  - assert: *true
-    when: image_version != "7.0(3)I5(1)"
-
-  - name: "Conf Idempotence"
-    nxos_vpc_interface: *conf1
-    register: result
-    when: image_version != "7.0(3)I5(1)"
-
-  - assert: *false
-    when: image_version != "7.0(3)I5(1)"
-
-  - name: Configure vpc port channel
-    nxos_vpc_interface: &conf2
-      portchannel: 11
-      peer_link: False
-    register: result
-    when: image_version != "7.0(3)I5(1)"
-
-  - assert: *true
-    when: image_version != "7.0(3)I5(1)"
-
-  - name: "Conf Idempotence"
-    nxos_vpc_interface: *conf2
-    register: result
-    when: image_version != "7.0(3)I5(1)"
-
-  - assert: *false
-    when: image_version != "7.0(3)I5(1)"
-
-  - name: remove vpc port channel
-    nxos_vpc_interface: &remove
-      portchannel: 10
-      vpc: 10
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Remove Idempotence"
-    nxos_vpc_interface: *remove
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: remove vpc
-    nxos_vpc:
-      state: absent
-      domain: 100
-      role_priority: 32667
-      system_priority: 2000
-      pkl_dest: 192.168.100.4
-      pkl_src: 10.1.100.20
-      peer_gw: true
-      auto_recovery: false
-    ignore_errors: yes
-
-  - name: remove vpc port channel
-    nxos_vpc_interface:
-      portchannel: 10
-      vpc: 10
-      state: absent
-    ignore_errors: yes
-
-  - name: remove port channel
-    nxos_config:
-      commands:
-        - no interface port-channel10
-        - no interface port-channel11
-      match: none
-    ignore_errors: yes
-
-  - name: disable feature vpc
-    nxos_feature:
-      feature: vpc
-      state: disabled
-
-- debug: msg="END connection={{ ansible_connection }} nxos_vpc_interface sanity test"
diff --git a/test/integration/targets/nxos_vrf/defaults/main.yaml b/test/integration/targets/nxos_vrf/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_vrf/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_vrf/meta/main.yml b/test/integration/targets/nxos_vrf/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_vrf/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_vrf/tasks/cli.yaml b/test/integration/targets/nxos_vrf/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_vrf/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vrf/tasks/main.yaml b/test/integration/targets/nxos_vrf/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_vrf/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_vrf/tasks/nxapi.yaml b/test/integration/targets/nxos_vrf/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_vrf/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vrf/tests/common/intent.yaml b/test/integration/targets/nxos_vrf/tests/common/intent.yaml
deleted file mode 100644
index f98162bc0a..0000000000
--- a/test/integration/targets/nxos_vrf/tests/common/intent.yaml
+++ /dev/null
@@ -1,183 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_vrf intent & aggregate test"
-
-- set_fact: testint1="{{ nxos_int1 }}"
-- set_fact: testint2="{{ nxos_int2 }}"
-
-- name: setup - remove vrf from interfaces used in test(part1)
-  nxos_config:
-    lines:
-      - no vrf member test1
-    parents: no switchport
-    before: "interface {{ testint1 }}"
-  ignore_errors: yes
-
-- name: setup - remove vrf from interfaces used in test(part2)
-  nxos_config:
-    lines:
-      - no vrf member test1
-    parents: no switchport
-    before: "interface {{ testint2 }}"
-  ignore_errors: yes
-
-- name: setup - delete VRF test1 used in test
-  nxos_config:
-    lines:
-      - no vrf context test1
-  ignore_errors: yes
-
-- name: setup - remove VRF test2 used in test
-  nxos_config:
-    lines:
-      - no vrf context test2
-  ignore_errors: yes
-
-- name: aggregate definitions of VRFs
-  nxos_vrf: &create
-    aggregate:
-      - { name: test1, description: Configured by Ansible }
-      - { name: test2, description: Testing, admin_state: down }
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"vrf context test1" in result.commands'
-      - '"description Configured by Ansible" in result.commands'
-      - '"no shutdown" in result.commands' 
-      - '"vrf context test2" in result.commands'
-      - '"description Testing" in result.commands'
-      - '"shutdown" in result.commands'
-
-- name: aggregate definitions of VRFs(Idempotence)
-  nxos_vrf: *create
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: Assign interfaces to VRF (Config + intent)
-  nxos_vrf: &interfaces
-    name: test1
-    interfaces:
-      - "{{ testint1 }}"
-      - "{{ testint2 }}"
-    associated_interfaces:
-      - "{{ testint1 }}"
-      - "{{ testint2 }}"
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - "result.failed == false"
-      - '"interface {{ testint1 }}" in result.commands'
-      - '"vrf member test1" in result.commands'
-      - '"interface {{ testint2 }}" in result.commands'
-      - '"vrf member test1" in result.commands'
-
-- name: Assign interfaces to vrf(Idempotence)
-  nxos_vrf: *interfaces
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- name: Check interfaces assigned to VRF (intent)
-  nxos_vrf:
-    name: test1
-    associated_interfaces:
-      - "{{ testint1 }}"
-      - "{{ testint2 }}"
-  register: result
-
-- assert:
-    that:
-      - "result.failed == false"
-
-- name: Assign interfaces to VRF (intent fail)
-  nxos_vrf:
-    name: test1
-    associated_interfaces:
-      - test
-  register: result
-  ignore_errors: yes
-
-- assert:
-    that:
-      - "result.failed == True"
-
-- name: Remove interface from vrf
-  nxos_vrf: &single_int
-    name: test1
-    interfaces:
-      - "{{ testint2 }}"
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"interface {{ testint1 }}" in result.commands'
-      - '"no vrf member test1" in result.commands'
-
-- name: Remove interface from vrf(idempotence)
-  nxos_vrf: *single_int
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == false'
-
-- name: Delete VRFs
-  nxos_vrf: &delete
-    aggregate:
-      - { name: test1, description: Configured by Ansible }
-      - { name: test2, description: Testing, admin_state: down }
-    state: absent
-  register: result
-
-- assert:
-    that:
-      - 'result.changed == true'
-      - '"no vrf context test1" in result.commands'
-      - '"no vrf context test2" in result.commands'
-
-- name: Delete VRFs(Idempotence)
-  nxos_vrf: *delete
-  register: result
-
-- assert:
-    that:
-      - "result.changed == false"
-
-- name: setup - remove vrf from interfaces used in test(part1)
-  nxos_config:
-    lines:
-      - no vrf member test1
-    parents: no switchport
-    before: "interface {{ testint1 }}"
-  ignore_errors: yes
-
-- name: setup - remove vrf from interfaces used in test(part2)
-  nxos_config:
-    lines:
-      - no vrf member test1
-    parents: no switchport
-    before: "interface {{ testint2 }}"
-  ignore_errors: yes
-
-- name: setup - delete VRF test1 used in test
-  nxos_config:
-    lines:
-      - no vrf context test1
-  ignore_errors: yes
-
-- name: setup - remove VRF test2 used in test
-  nxos_config:
-    lines:
-      - no vrf context test2
-  ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_vrf intent & aggregate test"
diff --git a/test/integration/targets/nxos_vrf/tests/common/sanity.yaml b/test/integration/targets/nxos_vrf/tests/common/sanity.yaml
deleted file mode 100644
index 25f778dc62..0000000000
--- a/test/integration/targets/nxos_vrf/tests/common/sanity.yaml
+++ /dev/null
@@ -1,110 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_vrf sanity test"
-
-- set_fact: intname1="{{ nxos_int1 }}"
-- set_fact: intname2="{{ nxos_int2 }}"
-
-- set_fact: rdnd="1:2"
-  when: (platform is not match("N35|N7K")) and ((imagetag != 'I2'))
-
-- set_fact: rdd="default"
-  when: (platform is not match("N35|N7K")) and ((imagetag != 'I2'))
-
-- set_fact: vnind="5000"
-  when: platform is not match("N35|N7K|N3L")
-
-- set_fact: vnid="default"
-  when: platform is not match("N35|N7K|N3L")
-
-- name: "Enable feature BGP"
-  nxos_feature:
-    feature: bgp
-    state: enabled
-  ignore_errors: yes
-
-- name: "Setup: Enable nv overlay evpn"
-  nxos_config:
-    commands:
-      - nv overlay evpn
-    provider: "{{ connection }}"
-  ignore_errors: yes
-  when: platform is match("N5K|N6K")
-
-- block:
-  - name: Ensure ntc VRF exists on switch
-    nxos_vrf: &configure
-      vrf: ntc
-      admin_state: down
-      description: testing
-      vni: "{{vnind|default(omit)}}"
-      rd: "{{rdnd|default(omit)}}"
-      interfaces:
-        - "{{ intname1 }}"
-        - "{{ intname2 }}"
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Conf Idempotence"
-    nxos_vrf: *configure
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - pause:
-      seconds: 30
-
-  - name: Remove config
-    nxos_vrf: &remconf
-      vrf: ntc
-      admin_state: up
-      vni: "{{vnid|default(omit)}}"
-      rd: "{{rdd|default(omit)}}"
-      interfaces: default
-    register: result
-
-  - assert: *true
-
-  - name: "Conf Idempotence"
-    nxos_vrf: *remconf
-    register: result
-
-  - assert: *false
-
-  - name: Ensure ntc VRF does not exist on switch
-    nxos_vrf: &remove
-      vrf: ntc
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - pause:
-      seconds: 30
-
-  - name: "Remove Idempotence"
-    nxos_vrf: *remove
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: "Setup: Disable nv overlay evpn"
-    nxos_config:
-      commands:
-        - no nv overlay evpn
-      provider: "{{ connection }}"
-    ignore_errors: yes
-    when: platform is match("N5K|N6K")
-
-  - name: "Disable feature BGP"
-    nxos_feature:
-      feature: bgp
-      state: disabled
-    ignore_errors: yes
-
-  - debug: msg="END connection={{ ansible_connection }} nxos_vrf sanity test"
diff --git a/test/integration/targets/nxos_vrf_af/defaults/main.yaml b/test/integration/targets/nxos_vrf_af/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_vrf_af/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_vrf_af/meta/main.yml b/test/integration/targets/nxos_vrf_af/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_vrf_af/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_vrf_af/tasks/cli.yaml b/test/integration/targets/nxos_vrf_af/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_vrf_af/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vrf_af/tasks/main.yaml b/test/integration/targets/nxos_vrf_af/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_vrf_af/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_vrf_af/tasks/nxapi.yaml b/test/integration/targets/nxos_vrf_af/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_vrf_af/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vrf_af/tests/common/sanity.yaml b/test/integration/targets/nxos_vrf_af/tests/common/sanity.yaml
deleted file mode 100644
index cd321d6fca..0000000000
--- a/test/integration/targets/nxos_vrf_af/tests/common/sanity.yaml
+++ /dev/null
@@ -1,146 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_vrf_af sanity test"
-
-- name: Configure feature bgp
-  nxos_feature:
-    feature: bgp
-    state: enabled
-
-- name: Configure feature nv overlay
-  nxos_config:
-    commands: "feature nv overlay"
-  ignore_errors: yes
-
-- name: Configure nv overlay evpn
-  nxos_config:
-    commands: "nv overlay evpn"
-  ignore_errors: yes
-
-- block:
-  - name: Configure vrf af ipv4
-    nxos_vrf_af: &configure4
-      vrf: ansible
-      afi: ipv4
-      route_target_both_auto_evpn: True
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Conf Idempotence"
-    nxos_vrf_af: *configure4
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Configure vrf af ipv6
-    nxos_vrf_af: &configure6
-      vrf: ansible
-      afi: ipv6
-      route_target_both_auto_evpn: True
-    register: result
-
-  - assert: *true
-
-  - name: "Conf Idempotence"
-    nxos_vrf_af: *configure6
-    register: result
-
-  - assert: *false
-
-  - name: Remove router target4
-    nxos_vrf_af: &rrt4
-      vrf: ansible
-      afi: ipv4
-      route_target_both_auto_evpn: False
-    register: result
-
-  - assert: *true
-
-  - name: "Conf Idempotence"
-    nxos_vrf_af: *rrt4
-    register: result
-
-  - assert: *false
-
-  - name: Remove router target6
-    nxos_vrf_af: &rrt6
-      vrf: ansible
-      afi: ipv6
-      route_target_both_auto_evpn: False
-    register: result
-
-  - assert: *true
-
-  - name: "Conf Idempotence"
-    nxos_vrf_af: *rrt6
-    register: result
-
-  - assert: *false
-
-  - name: Remove vrf af v6
-    nxos_vrf_af: &remove6
-      vrf: ansible
-      afi: ipv6
-      route_target_both_auto_evpn: True
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - pause:
-      seconds: 30
-
-  - name: "Remove Idempotence"
-    nxos_vrf_af: *remove6
-    register: result
-
-  - assert: *false
-
-  - name: Remove vrf af v4
-    nxos_vrf_af: &remove4
-      vrf: ansible
-      afi: ipv4
-      route_target_both_auto_evpn: True
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - pause:
-      seconds: 30
-
-  - name: "Remove Idempotence"
-    nxos_vrf_af: *remove4
-    register: result
-
-  - assert: *false
-
-  when: not platform is search("N35|N3L")
-
-  always:
-  - name: Remove vrf
-    nxos_config:
-      commands: "no vrf context ansible"
-    ignore_errors: yes
-
-  - name: Remove nv overlay evpn
-    nxos_config:
-      commands: "no nv overlay evpn"
-    ignore_errors: yes
-
-  - name: Remove feature nv overlay
-    nxos_config:
-      commands: "no feature nv overlay"
-    ignore_errors: yes
-
-  - name: Remove feature bgp
-    nxos_feature:
-      feature: bgp
-      state: disabled
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_vrf_af sanity test"
diff --git a/test/integration/targets/nxos_vrf_interface/defaults/main.yaml b/test/integration/targets/nxos_vrf_interface/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_vrf_interface/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_vrf_interface/meta/main.yml b/test/integration/targets/nxos_vrf_interface/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_vrf_interface/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_vrf_interface/tasks/cli.yaml b/test/integration/targets/nxos_vrf_interface/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_vrf_interface/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vrf_interface/tasks/main.yaml b/test/integration/targets/nxos_vrf_interface/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_vrf_interface/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_vrf_interface/tasks/nxapi.yaml b/test/integration/targets/nxos_vrf_interface/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_vrf_interface/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vrf_interface/tests/common/sanity.yaml b/test/integration/targets/nxos_vrf_interface/tests/common/sanity.yaml
deleted file mode 100644
index ef7828cdab..0000000000
--- a/test/integration/targets/nxos_vrf_interface/tests/common/sanity.yaml
+++ /dev/null
@@ -1,57 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_vrf_interface sanity test"
-
-# Select interface for test
-- set_fact: intname="{{ nxos_int1 }}"
-
-- block:
-  - name: put interface in L3
-    nxos_config:
-      commands:
-        - no switchport
-      parents:
-        - "interface {{ intname }}"
-      match: none
-
-  - name: Ensure vrf ntc exists on interface
-    nxos_vrf_interface: &configure
-      vrf: ntc
-      interface: "{{ intname }}"
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Conf Idempotence"
-    nxos_vrf_interface: *configure
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Ensure ntc VRF does not exist on interface
-    nxos_vrf_interface: &remove
-      vrf: ntc
-      interface: "{{ intname }}"
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Remove Idempotence"
-    nxos_vrf_interface: *remove
-    register: result
-
-  - assert: *false
-
-  always:
-  - name: put interface in default mode
-    nxos_config:
-      lines: "default interface {{ intname }}"
-      match: none
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_vrf_interface sanity test"
diff --git a/test/integration/targets/nxos_vrrp/defaults/main.yaml b/test/integration/targets/nxos_vrrp/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_vrrp/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_vrrp/meta/main.yml b/test/integration/targets/nxos_vrrp/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_vrrp/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_vrrp/tasks/cli.yaml b/test/integration/targets/nxos_vrrp/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_vrrp/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vrrp/tasks/main.yaml b/test/integration/targets/nxos_vrrp/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_vrrp/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_vrrp/tasks/nxapi.yaml b/test/integration/targets/nxos_vrrp/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_vrrp/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vrrp/tests/common/sanity.yaml b/test/integration/targets/nxos_vrrp/tests/common/sanity.yaml
deleted file mode 100644
index 1ff951c8ad..0000000000
--- a/test/integration/targets/nxos_vrrp/tests/common/sanity.yaml
+++ /dev/null
@@ -1,132 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_vrrp sanity test"
-
-- block:
-  - name: "Enable interface-vlan"
-    nxos_feature: 
-      feature: interface-vlan
-      state: enabled
-
-  - name: "Enable vrrp"
-    nxos_feature: 
-      feature: vrrp
-      state: enabled
-
-  - name: "create int vlan 10"
-    nxos_config: 
-      commands: "int vlan 10"
-
-  - name: Ensure vrrp group 100 and vip 10.1.100.1 is on vlan10
-    nxos_vrrp: &configure
-      interface: vlan10
-      group: 100
-      vip: 10.1.100.1
-      admin_state: 'no shutdown'
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Conf Idempotence"
-    nxos_vrrp: *configure
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: Ensure vrrp group 100 is default
-    nxos_vrrp: &configure_def
-      interface: vlan10
-      group: 100
-      vip: default
-      admin_state: default
-    register: result
-
-  - assert: *true
-
-  - name: "Conf Idempotence"
-    nxos_vrrp: *configure_def
-    register: result
-
-  - assert: *false
-
-  - name: Ensure removal of the vrrp group config
-    nxos_vrrp: &remove
-      interface: vlan10
-      group: 100
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - pause:
-      seconds: 30
-
-  - name: "Remove Idempotence"
-    nxos_vrrp: *remove
-    register: result
-
-  - assert: *false
-
-  - pause:
-      seconds: 30
-
-  - name: Re-config with more params
-    nxos_vrrp: &reconfig
-      interface: vlan10
-      group: 100
-      vip: 10.1.100.1
-      preempt: False
-      interval: 10
-      priority: 130
-      authentication: AUTHKEY
-    register: result
-
-  - assert: *true
-
-  - name: "Reconfig Idempotence"
-    nxos_vrrp: *reconfig
-    register: result
-
-  - assert: *false
-
-  - name: Re-config with defaults
-    nxos_vrrp: &reconfig_def
-      interface: vlan10
-      group: 100
-      vip: default
-      preempt: True
-      interval: default
-      priority: default
-      authentication: default
-    register: result
-
-  - assert: *true
-
-  - name: "Reconfig Idempotence"
-    nxos_vrrp: *reconfig_def
-    register: result
-
-  - assert: *false
-
-  always:
-    - name: remove vrrp
-      nxos_vrrp: *remove
-      ignore_errors: yes
-  
-    - name: "Disable interface-vlan"
-      nxos_config: 
-        commands:
-          - no feature interface-vlan
-        match: none
-      ignore_errors: yes
-
-    - name: "Disable vrrp"
-      nxos_feature: 
-        feature: vrrp
-        state: disabled
-      ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_vrrp sanity test"
diff --git a/test/integration/targets/nxos_vsan/defaults/main.yaml b/test/integration/targets/nxos_vsan/defaults/main.yaml
deleted file mode 100644
index 55a93fc23d..0000000000
--- a/test/integration/targets/nxos_vsan/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
\ No newline at end of file
diff --git a/test/integration/targets/nxos_vsan/meta/main.yml b/test/integration/targets/nxos_vsan/meta/main.yml
deleted file mode 100644
index 42c635d6d2..0000000000
--- a/test/integration/targets/nxos_vsan/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-# dependencies:
-#   - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_vsan/tasks/cli.yaml b/test/integration/targets/nxos_vsan/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_vsan/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vsan/tasks/main.yaml b/test/integration/targets/nxos_vsan/tasks/main.yaml
deleted file mode 100644
index eb3f9ca07c..0000000000
--- a/test/integration/targets/nxos_vsan/tasks/main.yaml
+++ /dev/null
@@ -1,16 +0,0 @@
-#---
-# Check platform type and skip if not MDS
----
-- name: Check platform type and skip if not MDS
-  nxos_command:
-    commands: show version | grep MDS
-  register: result
- 
-- set_fact: skip_test=False
-- set_fact: skip_test=True
-  when: result.stdout[0] is not search('MDS')
- 
-- include: cli.yaml
-  tags: 'cli'
-  when: not skip_test
- 
\ No newline at end of file
diff --git a/test/integration/targets/nxos_vsan/tests/common/sanity.yaml b/test/integration/targets/nxos_vsan/tests/common/sanity.yaml
deleted file mode 100644
index a4bd5e2df0..0000000000
--- a/test/integration/targets/nxos_vsan/tests/common/sanity.yaml
+++ /dev/null
@@ -1,50 +0,0 @@
----
-- debug: msg="START nxos_vsan sanity test with connection={{ ansible_connection }} "
-- debug: msg="Using vsans {{ vsan1 }}, {{ vsan2 }} for running this sanity test, please make sure these are not used in the setup, these will be deleted after the tests"
-
-
-- block:
-    - name: Setup - Remove vsan if configured
-      nxos_vsan: &remove
-        vsan:
-          - { id: "{{ vsan1 | int }}", remove: True}
-          - { id: "{{ vsan2 | int }}", remove: True}
-      ignore_errors: yes
-
-    - name: Configure vsan
-      nxos_vsan: &config
-        vsan:
-          - id: "{{ vsan1 | int }}"
-            name: vsan-SAN-A
-            suspend: True
-            interface:
-              - "{{intA1}}"
-            remove: False
-          - id: "{{ vsan2 | int }}"
-            name: vsan-SAN-B
-            interface:
-              - "{{intB1}}"
-            remove: False
-      register: result
-
-    - assert: &true
-        that:
-          - result.changed == true
-    - assert:
-        that: 
-          - result.commands == ["terminal dont-ask", "vsan database", "vsan 922", "vsan 922 name vsan-SAN-A", "vsan 922 suspend", "vsan 922 interface fc1/1", "vsan 923", "vsan 923 name vsan-SAN-B", "no vsan 923 suspend", "vsan 923 interface fc1/2", "no terminal dont-ask"]
-    
-    - name: Idempotence Check
-      nxos_vsan: *config
-      register: result
-
-    - assert: &false
-        that:
-          - result.changed == false
-    - assert:
-        that: 
-          - result.commands == []
-
-  always:
-    - name: Remove vsan config
-      nxos_vsan: *remove
diff --git a/test/integration/targets/nxos_vsan/vars/main.yml b/test/integration/targets/nxos_vsan/vars/main.yml
deleted file mode 100644
index 2e3bcbadef..0000000000
--- a/test/integration/targets/nxos_vsan/vars/main.yml
+++ /dev/null
@@ -1,4 +0,0 @@
-vsan1: 922
-vsan2: 923
-intA1: fc1/1
-intB1: fc1/2
diff --git a/test/integration/targets/nxos_vtp_domain/defaults/main.yaml b/test/integration/targets/nxos_vtp_domain/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_vtp_domain/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_vtp_domain/meta/main.yml b/test/integration/targets/nxos_vtp_domain/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_vtp_domain/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_vtp_domain/tasks/cli.yaml b/test/integration/targets/nxos_vtp_domain/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_vtp_domain/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vtp_domain/tasks/main.yaml b/test/integration/targets/nxos_vtp_domain/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_vtp_domain/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_vtp_domain/tasks/nxapi.yaml b/test/integration/targets/nxos_vtp_domain/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_vtp_domain/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vtp_domain/tests/common/sanity.yaml b/test/integration/targets/nxos_vtp_domain/tests/common/sanity.yaml
deleted file mode 100644
index ebd821aa37..0000000000
--- a/test/integration/targets/nxos_vtp_domain/tests/common/sanity.yaml
+++ /dev/null
@@ -1,45 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_vtp_domain sanity test"
-
-- set_fact: vtp_run="true"
-- set_fact: vtp_run="false"
-  when: platform is search('N3K-F|N9K-F')
-
-- block:
-  - name: disable feature vtp
-    nxos_feature:
-      feature: vtp
-      state: disabled
-    ignore_errors: yes
-
-  - name: enable feature vtp
-    nxos_feature:
-      feature: vtp
-      state: enabled
-
-  - name: configure vtp domain
-    nxos_vtp_domain: &configure
-      domain: ntc
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-  
-  - name: "Conf Idempotence"
-    nxos_vtp_domain: *configure
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  when: vtp_run
-
-  always:
-  - name: disable feature vtp
-    nxos_feature:
-      feature: vtp
-      state: disabled
-
-- debug: msg="END connection={{ ansible_connection }} nxos_vtp_domain sanity test"
diff --git a/test/integration/targets/nxos_vtp_password/defaults/main.yaml b/test/integration/targets/nxos_vtp_password/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_vtp_password/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_vtp_password/meta/main.yml b/test/integration/targets/nxos_vtp_password/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_vtp_password/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_vtp_password/tasks/cli.yaml b/test/integration/targets/nxos_vtp_password/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_vtp_password/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vtp_password/tasks/main.yaml b/test/integration/targets/nxos_vtp_password/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_vtp_password/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_vtp_password/tasks/nxapi.yaml b/test/integration/targets/nxos_vtp_password/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_vtp_password/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vtp_password/tests/common/sanity.yaml b/test/integration/targets/nxos_vtp_password/tests/common/sanity.yaml
deleted file mode 100644
index dacc586c19..0000000000
--- a/test/integration/targets/nxos_vtp_password/tests/common/sanity.yaml
+++ /dev/null
@@ -1,64 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_vtp_password sanity test"
-
-- set_fact: vtp_run="true"
-- set_fact: vtp_run="false"
-  when: platform is search('N3K-F|N9K-F')
-
-- block:
-  - name: disable feature vtp
-    nxos_feature:
-      feature: vtp
-      state: disabled
-    ignore_errors: yes
-
-  - name: enable feature vtp
-    nxos_feature:
-      feature: vtp
-      state: enabled
-
-  - name: configure vtp domain
-    nxos_vtp_domain:
-      domain: testing
-
-  - name: configure vtp password
-    nxos_vtp_password: &configure
-      vtp_password: ntc
-      state: present
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-  
-  - name: "Conf Idempotence"
-    nxos_vtp_password: *configure
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: remove vtp password
-    nxos_vtp_password: &remove
-      vtp_password: ntc
-      state: absent
-    register: result
-
-  - assert: *true
-
-  - name: "Remove Idempotence"
-    nxos_vtp_password: *remove
-    register: result
-
-  - assert: *false
-
-  when: vtp_run
-
-  always:
-  - name: disable feature vtp
-    nxos_feature:
-      feature: vtp
-      state: disabled
-
-- debug: msg="END connection={{ ansible_connection }} nxos_vtp_password sanity test"
diff --git a/test/integration/targets/nxos_vtp_version/defaults/main.yaml b/test/integration/targets/nxos_vtp_version/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_vtp_version/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_vtp_version/meta/main.yml b/test/integration/targets/nxos_vtp_version/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_vtp_version/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_vtp_version/tasks/cli.yaml b/test/integration/targets/nxos_vtp_version/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_vtp_version/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vtp_version/tasks/main.yaml b/test/integration/targets/nxos_vtp_version/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_vtp_version/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_vtp_version/tasks/nxapi.yaml b/test/integration/targets/nxos_vtp_version/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_vtp_version/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vtp_version/tests/common/sanity.yaml b/test/integration/targets/nxos_vtp_version/tests/common/sanity.yaml
deleted file mode 100644
index ef5c3231d3..0000000000
--- a/test/integration/targets/nxos_vtp_version/tests/common/sanity.yaml
+++ /dev/null
@@ -1,49 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_vtp_version sanity test"
-
-- set_fact: vtp_run="true"
-- set_fact: vtp_run="false"
-  when: platform is search('N3K-F|N9K-F')
-
-- block:
-  - name: disable feature vtp
-    nxos_feature:
-      feature: vtp
-      state: disabled
-    ignore_errors: yes
-
-  - name: enable feature vtp
-    nxos_feature:
-      feature: vtp
-      state: enabled
-
-  - name: configure supporting vtp domain
-    nxos_vtp_domain:
-      domain: foo
-
-  - name: configure vtp version
-    nxos_vtp_version: &configure
-      version: 2
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Conf Idempotence"
-    nxos_vtp_version: *configure
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  when: vtp_run | bool
-
-  always:
-  - name: disable feature vtp
-    nxos_feature:
-      feature: vtp
-      state: disabled
-
-- debug: msg="END connection={{ ansible_connection }} nxos_vtp_version sanity test"
diff --git a/test/integration/targets/nxos_vxlan_vtep/defaults/main.yaml b/test/integration/targets/nxos_vxlan_vtep/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_vxlan_vtep/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_vxlan_vtep/meta/main.yml b/test/integration/targets/nxos_vxlan_vtep/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_vxlan_vtep/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_vxlan_vtep/tasks/cli.yaml b/test/integration/targets/nxos_vxlan_vtep/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_vxlan_vtep/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vxlan_vtep/tasks/main.yaml b/test/integration/targets/nxos_vxlan_vtep/tasks/main.yaml
deleted file mode 100644
index 4b0f8c64d9..0000000000
--- a/test/integration/targets/nxos_vxlan_vtep/tasks/main.yaml
+++ /dev/null
@@ -1,3 +0,0 @@
----
-- { include: cli.yaml, tags: ['cli'] }
-- { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_vxlan_vtep/tasks/nxapi.yaml b/test/integration/targets/nxos_vxlan_vtep/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_vxlan_vtep/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vxlan_vtep/tasks/platform/n7k/cleanup.yaml b/test/integration/targets/nxos_vxlan_vtep/tasks/platform/n7k/cleanup.yaml
deleted file mode 100644
index 5f0fe44949..0000000000
--- a/test/integration/targets/nxos_vxlan_vtep/tasks/platform/n7k/cleanup.yaml
+++ /dev/null
@@ -1,22 +0,0 @@
----
-- name: "Unconfigure VDC setting limit-resource module-type f3"
-  nxos_config:
-    commands:
-      - 'terminal dont-ask ; vdc {{ vdcid }} ;  no limit-resource module-type f3'
-    match: none
-  ignore_errors: yes
-
-- name: Previous command is asynchronous and can take a while.  Allow time for it to complete
-  pause:
-    seconds: 45
-
-- name: "Configure VDC setting allocate interface unallocated-interfaces"
-  nxos_config: &allocate
-    commands:
-      - 'terminal dont-ask ; vdc {{ vdcid }} ; allocate interface unallocated-interfaces'
-    match: none
-  ignore_errors: yes
-
-- name: Previous command is asynchronous can take a while.  Allow time for it to complete
-  pause:
-    seconds: 45
diff --git a/test/integration/targets/nxos_vxlan_vtep/tasks/platform/n7k/setup.yaml b/test/integration/targets/nxos_vxlan_vtep/tasks/platform/n7k/setup.yaml
deleted file mode 100644
index 0501a90985..0000000000
--- a/test/integration/targets/nxos_vxlan_vtep/tasks/platform/n7k/setup.yaml
+++ /dev/null
@@ -1,29 +0,0 @@
----
-- name: "Get default vdc id"
-  nxos_command:
-    commands: ['show vdc current-vdc | json']
-  register: vdcout
-
-- set_fact: vdcid="{{ vdcout.stdout_lines[0].name }}"
-
-- name: "Configure VDC setting limit-resource module-type f3"
-  nxos_config:
-    commands:
-      - "terminal dont-ask ; vdc {{ vdcid }} ;  limit-resource module-type f3"
-    match: none
-  ignore_errors: yes
-
-- name: Previous command is asynchronous and can take a while.  Allow time for it to complete
-  pause:
-    seconds: 45
-
-- name: "Configure VDC setting allocate interface unallocated-interfaces"
-  nxos_config: &allocate
-    commands:
-      - "terminal dont-ask ; vdc {{ vdcid }} ; allocate interface unallocated-interfaces"
-    match: none
-  ignore_errors: yes
-
-- name: Previous command is asynchronous and can take a while.  Allow time for it to complete
-  pause:
-    seconds: 45
diff --git a/test/integration/targets/nxos_vxlan_vtep/tests/common/sanity.yaml b/test/integration/targets/nxos_vxlan_vtep/tests/common/sanity.yaml
deleted file mode 100644
index 69e54ec7a6..0000000000
--- a/test/integration/targets/nxos_vxlan_vtep/tests/common/sanity.yaml
+++ /dev/null
@@ -1,219 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_vxlan_vtep sanity test"
-
-- block:
-  # N9K(v9.2+) specific attrs
-  - set_fact: global_mcast_group_L2="225.1.1.2"
-  - set_fact: def_global_mcast_group_L2="default"
-
-  # Layer 3 Tenant Routed Multicast (TRM) dependency.
-  # global_mcast_group_l3 / global_ingress_replication_bgp have a dependency on TRM.
-  # TRM requires specific 92/93/95 chassis and -EX/-FX line cards.
-  - block:
-    - set_fact: global_mcast_group_L3="225.1.1.1"
-    - set_fact: def_global_mcast_group_L3="default"
-    - set_fact: global_ingress_replication_bgp="true"
-    - set_fact: def_global_ingress_replication_bgp="false"
-    when: false # Manually change this to true when correct h/w is present
-
-  - name: "TCAM resource check for global_suppress_arp"
-    # GSA requires tcam resources. Skip these attrs when arp-ether size is 0.
-    # Note: TCAM changes require a switch reload.
-    # Sample Input: "Ingress ARP-Ether ACL [arp-ether] size =  256"
-    nxos_command:
-      commands:
-        - command: show hardware access-list tcam region | incl arp-ether | sed 's/.*size = *//'
-          output: text
-    connection: network_cli
-    register: tcam_state
-  - block:
-    - set_fact: global_suppress_arp="true"
-    - set_fact: def_global_suppress_arp="false"
-    when: "tcam_state.stdout[0]|int > 0"
-
-  when:  platform is search('N9K') and (major_version is version('9.2', 'ge'))
-
-- block:
-  - name: "Apply N7K specific setup config"
-    include: targets/nxos_vxlan_vtep/tasks/platform/n7k/setup.yaml
-    when: platform is match('N7K')
-
-  - name: "Enable feature nv overlay"
-    nxos_config:
-      commands:
-        - feature nv overlay
-        - nv overlay evpn
-      match: none
-
-  - block:
-    - name: "Enable feature ngmvpn"
-      nxos_config:
-        commands:
-          - feature ngmvpn
-        match: none
-    when: global_mcast_group_L3 is defined
-
-  - block:
-    - name: configure vxlan_vtep
-      nxos_vxlan_vtep: &configure9
-        interface: nve1
-        description: "abcd"
-        host_reachability: true
-        source_interface: Loopback0
-        source_interface_hold_down_time: 30
-        global_ingress_replication_bgp: "{{ global_ingress_replication_bgp|default(omit) }}"
-        global_suppress_arp: "{{ global_suppress_arp|default(omit) }}"
-        global_mcast_group_L3: "{{ global_mcast_group_L3|default(omit) }}"
-        shutdown: false
-      register: result
-
-    - assert: &true
-        that:
-          - "result.changed == true"
-
-    - name: "Conf Idempotence"
-      nxos_vxlan_vtep: *configure9
-      register: result
-
-    - assert: &false
-        that:
-          - "result.changed == false"
-
-    - name: reset vxlan_vtep
-      nxos_vxlan_vtep: &def9
-        interface: nve1
-        description: default
-        host_reachability: false
-        source_interface_hold_down_time: default
-        source_interface: default
-        global_ingress_replication_bgp: "{{ def_global_ingress_replication_bgp|default(omit) }}"
-        global_suppress_arp: "{{ def_global_suppress_arp|default(omit) }}"
-        global_mcast_group_L3: "{{ def_global_mcast_group_L3|default(omit) }}"
-        shutdown: true
-      register: result
-
-    - assert: *true
-
-    - name: "reset Idempotence"
-      nxos_vxlan_vtep: *def9
-      register: result
-
-    - assert: *false
-
-    - name: configure global mcast L2
-      nxos_vxlan_vtep: &gml2
-        interface: nve1
-        host_reachability: true
-        global_mcast_group_L2: "{{ global_mcast_group_L2|default(omit) }}"
-      register: result
-
-    - assert: *true
-
-    - name: "Conf Idempotence"
-      nxos_vxlan_vtep: *gml2
-      register: result
-
-    - assert: *false
-
-    - name: reset global mcast L2
-      nxos_vxlan_vtep: &rgml2
-        interface: nve1
-        host_reachability: false
-        global_mcast_group_L2: "{{ def_global_mcast_group_L2|default(omit) }}"
-      register: result
-
-    - assert: *true
-
-    - name: "reset Idempotence"
-      nxos_vxlan_vtep: *rgml2
-      register: result
-
-    - assert: *false
-
-    when: (platform is search('N9K'))
-
-  - block:
-    - name: configure vxlan_vtep
-      nxos_vxlan_vtep: &configure7
-        interface: nve1
-        description: default
-        host_reachability: true
-        source_interface: Loopback0
-        shutdown: false
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == true"
-
-    - name: "Conf Idempotence"
-      nxos_vxlan_vtep: *configure7
-      register: result
-
-    - assert:
-        that:
-          - "result.changed == false"
-
-    - name: reset vxlan_vtep
-      nxos_vxlan_vtep: &def7
-        interface: nve1
-        description: default
-        host_reachability: false
-        source_interface: default
-        shutdown: true
-      register: result
-
-    - assert: *true
-
-    - name: "reset Idempotence"
-      nxos_vxlan_vtep: *def7
-      register: result
-
-    - assert: *false
-
-    when: (platform is search('N7K'))
-
-  - name: remove vxlan_vtep
-    nxos_vxlan_vtep: &remove
-      interface: nve1
-      description: default
-      host_reachability: true
-      source_interface: Loopback0
-      source_interface_hold_down_time: 30
-      shutdown: true
-      state: absent
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == true"
-
-  - name: "Remove Idempotence"
-    nxos_vxlan_vtep: *remove
-    register: result
-
-  - assert:
-      that:
-        - "result.changed == false"
-
-  when: (platform is search("N7K|N9K"))
-
-  always:
-  - name: "Apply N7K specific cleanup config"
-    include: targets/nxos_vxlan_vtep/tasks/platform/n7k/cleanup.yaml
-    when: platform is match('N7K')
-
-  - name: "Disable nv overlay evpn"
-    nxos_config:
-      commands:
-        - no nv overlay evpn
-      match: none
-    ignore_errors: yes
-
-  - name: "Disable feature nv overlay"
-    nxos_feature:
-      feature: nve
-      state: disabled
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_vxlan_vtep sanity test"
diff --git a/test/integration/targets/nxos_vxlan_vtep_vni/defaults/main.yaml b/test/integration/targets/nxos_vxlan_vtep_vni/defaults/main.yaml
deleted file mode 100644
index 5f709c5aac..0000000000
--- a/test/integration/targets/nxos_vxlan_vtep_vni/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
diff --git a/test/integration/targets/nxos_vxlan_vtep_vni/meta/main.yml b/test/integration/targets/nxos_vxlan_vtep_vni/meta/main.yml
deleted file mode 100644
index ae741cbdc7..0000000000
--- a/test/integration/targets/nxos_vxlan_vtep_vni/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-dependencies:
-  - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_vxlan_vtep_vni/tasks/cli.yaml b/test/integration/targets/nxos_vxlan_vtep_vni/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_vxlan_vtep_vni/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vxlan_vtep_vni/tasks/main.yaml b/test/integration/targets/nxos_vxlan_vtep_vni/tasks/main.yaml
deleted file mode 100644
index fea9337c14..0000000000
--- a/test/integration/targets/nxos_vxlan_vtep_vni/tasks/main.yaml
+++ /dev/null
@@ -1,7 +0,0 @@
----
-# Use block to ensure that both cli and nxapi tests
-# will run even if there are failures or errors.
-- block:
-  - { include: cli.yaml, tags: ['cli'] }
-  always:
-  - { include: nxapi.yaml, tags: ['nxapi'] }
diff --git a/test/integration/targets/nxos_vxlan_vtep_vni/tasks/nxapi.yaml b/test/integration/targets/nxos_vxlan_vtep_vni/tasks/nxapi.yaml
deleted file mode 100644
index cbf41b9294..0000000000
--- a/test/integration/targets/nxos_vxlan_vtep_vni/tasks/nxapi.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect nxapi test cases
-  find:
-    paths: "{{ role_path }}/tests/nxapi"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: nxapi_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ nxapi_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=httpapi)
-  include: "{{ test_case_to_run }} ansible_connection=httpapi connection={{ nxapi }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_vxlan_vtep_vni/tests/common/sanity.yaml b/test/integration/targets/nxos_vxlan_vtep_vni/tests/common/sanity.yaml
deleted file mode 100644
index 4f68ea9c0c..0000000000
--- a/test/integration/targets/nxos_vxlan_vtep_vni/tests/common/sanity.yaml
+++ /dev/null
@@ -1,251 +0,0 @@
----
-- debug: msg="START connection={{ ansible_connection }} nxos_vxlan_vtep_vni sanity test"
-
-- block:
-  - name: "Apply N7K specific setup config"
-    include: targets/nxos_vxlan_vtep/tasks/platform/n7k/setup.yaml
-    when: platform is match('N7K')
-
-  - name: "Enable feature nv overlay"
-    nxos_config: 
-      commands:
-        - feature nv overlay
-      match: none
-
-  - name: configure vxlan_vtep
-    nxos_vxlan_vtep:
-      interface: nve1
-      host_reachability: True
-
-  - name: configure vxlan_vtep_vni assoc-vrf
-    nxos_vxlan_vtep_vni: &conf1
-      interface: nve1
-      vni: 6000
-      assoc_vrf: True
-    register: result
-
-  - assert: &true
-      that:
-        - "result.changed == true"
-
-  - name: "Conf 1 Idempotence"
-    nxos_vxlan_vtep_vni: *conf1
-    register: result
-
-  - assert: &false
-      that:
-        - "result.changed == false"
-
-  - name: remove vxlan_vtep_vni
-    nxos_vxlan_vtep_vni:
-      interface: nve1
-      vni: 6000
-      assoc_vrf: True
-      state: absent
-
-  - name: configure vxlan_vtep_vni
-    nxos_vxlan_vtep_vni: &conf2
-      interface: nve1
-      vni: 8000
-    register: result
-
-  - assert: *true
-
-  - name: configure vxlan_vtep_vni mcast
-    nxos_vxlan_vtep_vni: &conf3
-      interface: nve1
-      vni: 8000
-      multicast_group: 224.1.1.1
-    register: result
-
-  - assert: *true
-
-  - name: "Conf 3 Idempotence"
-    nxos_vxlan_vtep_vni: *conf3
-    register: result
-
-  - assert: *false
-
-  - name: configure vxlan_vtep_vni default mcast
-    nxos_vxlan_vtep_vni: &conf4
-      interface: nve1
-      vni: 8000
-      multicast_group: default
-    register: result
-
-  - assert: *true
-
-  - name: "Conf 4 Idempotence"
-    nxos_vxlan_vtep_vni: *conf4
-    register: result
-
-  - assert: *false
-
-  - name: "remove config"
-    nxos_vxlan_vtep_vni: &remove
-      interface: nve1
-      vni: 8000
-      state: absent
-
-  - name: configure vxlan_vtep
-    nxos_vxlan_vtep:
-      interface: nve1
-      host_reachability: False
-
-  - block:
-    - name: configure vxlan_vtep_vni
-      nxos_vxlan_vtep_vni: &conf5
-        interface: nve1
-        vni: 8000
-      register: result
-  
-    - assert: *true
-
-    - name: configure vxlan_vtep_vni ingress static
-      nxos_vxlan_vtep_vni: &conf6
-        interface: nve1
-        vni: 8000
-        ingress_replication: static
-      register: result
-  
-    - assert: *true
-
-    - name: check configure vxlan_vtep_vni ingress static idempotence check
-      nxos_vxlan_vtep_vni: *conf6
-      register: result
-
-    - assert: *false
-
-    - name: Remove and reconfigure vxlan_vtep
-      nxos_vxlan_vtep: &remove_vtep
-        interface: nve1
-        state: absent
-
-    - name: Configure vxlan_vtep with host reachability bgp
-      nxos_vxlan_vtep:
-        interface: nve1
-        host_reachability: True
-
-    - name: configure vxlan_vtep_vni
-      nxos_vxlan_vtep_vni: &config_vni
-        interface: nve1
-        vni: 8000
-
-    - name: configure vxlan_vtep_vni ingress bgp
-      nxos_vxlan_vtep_vni: &conf7
-        interface: nve1
-        vni: 8000
-        ingress_replication: bgp
-      register: result
-  
-    - assert: *true
-
-    - name: "Conf 7 Idempotence"
-      nxos_vxlan_vtep_vni: *conf7
-      register: result
-
-    - assert: *false
-
-    - name: remove ingress_repl
-      nxos_vxlan_vtep_vni: &conf8
-        interface: nve1
-        vni: 8000
-        ingress_replication: default
-      register: result
-  
-    - assert: *true
-
-    - name: "Conf 8 Idempotence"
-      nxos_vxlan_vtep_vni: *conf8
-      register: result
-
-    - assert: *false
-
-    - name: Remove and reconfigure vxlan_vtep
-      nxos_vxlan_vtep: *remove_vtep
-
-    - name: Configure vxlan_vtep with host reachability static
-      nxos_vxlan_vtep:
-        interface: nve1
-        host_reachability: False
-
-    - name: configure vxlan_vtep_vni
-      nxos_vxlan_vtep_vni: *config_vni
-
-    - name: configure vxlan_vtep_vni peer-list
-      nxos_vxlan_vtep_vni: &conf9
-        interface: nve1
-        vni: 8000
-        peer_list: 
-          - 192.0.2.1
-          - 192.0.2.2
-          - 192.0.2.3
-          - 192.0.2.4
-        ingress_replication: static
-      register: result
-  
-    - assert: *true
-
-    - name: "Conf 9 Idempotence"
-      nxos_vxlan_vtep_vni: *conf9
-      register: result
-  
-    - assert: *false
-
-    - name: configure vxlan_vtep_vni default peer-list
-      nxos_vxlan_vtep_vni: &conf10
-        interface: nve1
-        vni: 8000
-        peer_list: default
-        ingress_replication: static
-      register: result
-  
-    - assert: *true
-
-    - name: "Conf 10 Idempotence"
-      nxos_vxlan_vtep_vni: *conf10
-      register: result
-  
-    - assert: *false
-
-    - name: "Conf 9 again"
-      nxos_vxlan_vtep_vni: *conf9
-      register: result
-  
-    - assert: *true
-
-    - name: remove vxlan_vtep_vni
-      nxos_vxlan_vtep_vni: *remove
-      register: result
-
-    - assert: *true
-
-    - name: "remove Idempotence"
-      nxos_vxlan_vtep_vni: *remove
-      register: result
-
-    - assert: *false
-
-    when: (platform is search('N9K'))
-
-  when: (platform is search("N7K|N9K"))
-
-  always:
-  - name: "Apply N7K specific cleanup config"
-    include: targets/nxos_vxlan_vtep/tasks/platform/n7k/cleanup.yaml
-    when: platform is match('N7K')
-
-  - name: remove vxlan_vtep
-    nxos_vxlan_vtep:
-      interface: nve1
-      shutdown: true
-      state: absent
-    ignore_errors: yes
-
-  - name: "Disable feature nv overlay"
-    nxos_feature: 
-      feature: nve
-      state: disabled
-    ignore_errors: yes
-
-- debug: msg="END connection={{ ansible_connection }} nxos_vxlan_vtep_vni sanity test"
diff --git a/test/integration/targets/nxos_zone_zoneset/defaults/main.yaml b/test/integration/targets/nxos_zone_zoneset/defaults/main.yaml
deleted file mode 100644
index 55a93fc23d..0000000000
--- a/test/integration/targets/nxos_zone_zoneset/defaults/main.yaml
+++ /dev/null
@@ -1,2 +0,0 @@
----
-testcase: "*"
\ No newline at end of file
diff --git a/test/integration/targets/nxos_zone_zoneset/meta/main.yml b/test/integration/targets/nxos_zone_zoneset/meta/main.yml
deleted file mode 100644
index 42c635d6d2..0000000000
--- a/test/integration/targets/nxos_zone_zoneset/meta/main.yml
+++ /dev/null
@@ -1,2 +0,0 @@
-# dependencies:
-#   - prepare_nxos_tests
diff --git a/test/integration/targets/nxos_zone_zoneset/tasks/cli.yaml b/test/integration/targets/nxos_zone_zoneset/tasks/cli.yaml
deleted file mode 100644
index 9b62eaba65..0000000000
--- a/test/integration/targets/nxos_zone_zoneset/tasks/cli.yaml
+++ /dev/null
@@ -1,27 +0,0 @@
----
-- name: collect common test cases
-  find:
-    paths: "{{ role_path }}/tests/common"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: test_cases
-
-- name: collect cli test cases
-  find:
-    paths: "{{ role_path }}/tests/cli"
-    patterns: "{{ testcase }}.yaml"
-  connection: local
-  register: cli_cases
-
-- set_fact:
-    test_cases:
-      files: "{{ test_cases.files }} + {{ cli_cases.files }}"
-
-- name: set test_items
-  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"
-
-- name: run test cases (connection=network_cli)
-  include: "{{ test_case_to_run }} ansible_connection=network_cli connection={{ cli }}"
-  with_items: "{{ test_items }}"
-  loop_control:
-    loop_var: test_case_to_run
diff --git a/test/integration/targets/nxos_zone_zoneset/tasks/main.yaml b/test/integration/targets/nxos_zone_zoneset/tasks/main.yaml
deleted file mode 100644
index eb3f9ca07c..0000000000
--- a/test/integration/targets/nxos_zone_zoneset/tasks/main.yaml
+++ /dev/null
@@ -1,16 +0,0 @@
-#---
-# Check platform type and skip if not MDS
----
-- name: Check platform type and skip if not MDS
-  nxos_command:
-    commands: show version | grep MDS
-  register: result
- 
-- set_fact: skip_test=False
-- set_fact: skip_test=True
-  when: result.stdout[0] is not search('MDS')
- 
-- include: cli.yaml
-  tags: 'cli'
-  when: not skip_test
- 
\ No newline at end of file
diff --git a/test/integration/targets/nxos_zone_zoneset/tests/common/sanity.yaml b/test/integration/targets/nxos_zone_zoneset/tests/common/sanity.yaml
deleted file mode 100644
index f08f3ec365..0000000000
--- a/test/integration/targets/nxos_zone_zoneset/tests/common/sanity.yaml
+++ /dev/null
@@ -1,145 +0,0 @@
----
-- debug: "msg=\"START nxos_zone_zoneset sanity test with connection={{ ansible_connection }} \""
-- debug: "msg=\"Using vsans {{ vsan1 }}, {{ vsan2 }} for running this sanity test, please make sure these are not used in the setup, these will be deleted after the tests\""
-- always:
-    - name: "Remove vsan config"
-      nxos_vsan:
-        vsan:
-          - id: "{{ vsan1 | int }}"
-            remove: true
-          - id: "{{ vsan2 | int }}"
-            remove: true
-  block:
-    - ignore_errors: true
-      name: "Setup - Remove vsan if configured"
-      nxos_vsan:
-        vsan:
-          - id: "{{ vsan1 | int }}"
-            remove: true
-          - id: "{{ vsan2 | int }}"
-            remove: true
-    - name: "Configure vsan"
-      nxos_vsan:
-        vsan:
-          - id: "{{ vsan1 | int }}"
-          - id: "{{ vsan2 | int }}"
-    - name: "Configure zone and zoneset"
-      nxos_zone_zoneset: &zoneset
-        zone_zoneset_details:
-          - mode: enhanced
-            vsan: "{{ vsan1 | int }}"
-            zone:
-              - members:
-                  - pwwn: "11:11:11:11:11:11:11:11"
-                  - device_alias: test123
-                  - pwwn: "61:61:62:62:12:12:12:12"
-                    remove: true
-                name: zoneA
-              - members:
-                  - pwwn: "10:11:11:11:11:11:11:11"
-                  - pwwn: "62:62:62:62:21:21:21:21"
-                name: zoneB
-              - name: zoneC
-                remove: true
-            zoneset:
-              - action: activate
-                members:
-                  - name: zoneA
-                  - name: zoneB
-                  - name: zoneC
-                    remove: true
-                name: zsetname1
-              - action: deactivate
-                name: zsetTestExtra
-                remove: true
-          - mode: basic
-            smart_zoning: true
-            vsan: "{{ vsan2 | int }}"
-            zone:
-              - members:
-                  - devtype: both
-                    pwwn: "11:11:11:11:11:11:11:11"
-                  - pwwn: "62:62:62:62:12:12:12:12"
-                  - devtype: both
-                    pwwn: "92:62:62:62:12:12:1a:1a"
-                    remove: true
-                name: zone21A
-              - members:
-                  - pwwn: "10:11:11:11:11:11:11:11"
-                  - pwwn: "62:62:62:62:21:21:21:21"
-                  - device_alias: somedummyname
-                  - device_alias: anydummyname
-                    remove: true
-                name: zone21B
-            zoneset:
-              - action: activate
-                members:
-                  - name: zone21A
-                  - name: zone21B
-                name: zsetname21
-      register: result
-    - assert:
-        that:
-          - result.changed == true
-    - assert:
-        that: 
-          - result.commands == ["terminal dont-ask", "zone mode enhanced vsan 922", "zone name zoneA vsan 922", "member pwwn 11:11:11:11:11:11:11:11", "member device-alias test123", "zone name zoneB vsan 922", "member pwwn 10:11:11:11:11:11:11:11", "member pwwn 62:62:62:62:21:21:21:21", "zoneset name zsetname1 vsan 922", "member zoneA", "member zoneB", "zoneset activate name zsetname1 vsan 922", "zone commit vsan 922", "zone smart-zoning enable vsan 923", "zone name zone21A vsan 923", "member pwwn 11:11:11:11:11:11:11:11 both", "member pwwn 62:62:62:62:12:12:12:12", "zone name zone21B vsan 923", "member pwwn 10:11:11:11:11:11:11:11", "member pwwn 62:62:62:62:21:21:21:21", "member device-alias somedummyname", "zoneset name zsetname21 vsan 923", "member zone21A", "member zone21B", "zoneset activate name zsetname21 vsan 923", "no terminal dont-ask"]
-    
-    - name: "Idempotence Check"
-      nxos_zone_zoneset: *zoneset
-      register: result
-    - assert:
-        that: 
-          - result.commands == []
-    - assert:
-        that:
-          - result.changed == false
-
-    - name: "Delete zone and zoneset that was configured"
-      nxos_zone_zoneset: &zonesetdelete
-        zone_zoneset_details:
-          - mode: enhanced
-            vsan: "{{ vsan1 | int }}"
-            zone:
-              - name: zoneA
-                remove: true
-              - name: zoneB
-                remove: true
-              - name: zoneC
-                remove: true
-            zoneset:
-              - name: zsetname1
-                remove: true
-              - action: deactivate
-                name: zsetTestExtra
-                remove: true
-          - mode: basic
-            smart_zoning: true
-            vsan: "{{ vsan2 | int }}"
-            zone:
-              - name: zone21A
-                remove: true
-              - name: zone21B
-                remove: true
-            zoneset:
-              - name: zsetname21
-                remove: true
-      register: result
-
-    - assert:
-        that:
-          - result.changed == true
-    - assert:
-        that: 
-          - result.commands == ["terminal dont-ask", "no zone name zoneA vsan 922", "no zone name zoneB vsan 922", "no zoneset name zsetname1 vsan 922", "zone commit vsan 922", "no zone name zone21A vsan 923", "no zone name zone21B vsan 923", "no zoneset name zsetname21 vsan 923", "no terminal dont-ask"]
-
-    - name: "Idempotence Check for zone/zoneset removal"
-      nxos_zone_zoneset: *zonesetdelete
-      register: result
-
-    - assert:
-        that: 
-          - result.commands == []
-    - assert:
-        that:
-          - result.changed == false
diff --git a/test/integration/targets/nxos_zone_zoneset/vars/main.yml b/test/integration/targets/nxos_zone_zoneset/vars/main.yml
deleted file mode 100644
index 2e3bcbadef..0000000000
--- a/test/integration/targets/nxos_zone_zoneset/vars/main.yml
+++ /dev/null
@@ -1,4 +0,0 @@
-vsan1: 922
-vsan2: 923
-intA1: fc1/1
-intB1: fc1/2
diff --git a/test/sanity/ignore.txt b/test/sanity/ignore.txt
index 4e163869ff..2ff18a9d6a 100644
--- a/test/sanity/ignore.txt
+++ b/test/sanity/ignore.txt
@@ -100,16 +100,6 @@ lib/ansible/module_utils/network/junos/facts/legacy/base.py future-import-boiler
 lib/ansible/module_utils/network/junos/facts/legacy/base.py metaclass-boilerplate
 lib/ansible/module_utils/network/junos/junos.py future-import-boilerplate
 lib/ansible/module_utils/network/junos/junos.py metaclass-boilerplate
-lib/ansible/module_utils/network/nxos/argspec/facts/facts.py future-import-boilerplate
-lib/ansible/module_utils/network/nxos/argspec/facts/facts.py metaclass-boilerplate
-lib/ansible/module_utils/network/nxos/facts/facts.py future-import-boilerplate
-lib/ansible/module_utils/network/nxos/facts/facts.py metaclass-boilerplate
-lib/ansible/module_utils/network/nxos/facts/legacy/base.py future-import-boilerplate
-lib/ansible/module_utils/network/nxos/facts/legacy/base.py metaclass-boilerplate
-lib/ansible/module_utils/network/nxos/nxos.py future-import-boilerplate
-lib/ansible/module_utils/network/nxos/nxos.py metaclass-boilerplate
-lib/ansible/module_utils/network/nxos/utils/utils.py future-import-boilerplate
-lib/ansible/module_utils/network/nxos/utils/utils.py metaclass-boilerplate
 lib/ansible/module_utils/network/skydive/api.py future-import-boilerplate
 lib/ansible/module_utils/network/skydive/api.py metaclass-boilerplate
 lib/ansible/module_utils/network/vyos/vyos.py future-import-boilerplate
@@ -1930,521 +1920,6 @@ lib/ansible/modules/network/junos/junos_vrf.py validate-modules:missing-suboptio
 lib/ansible/modules/network/junos/junos_vrf.py validate-modules:parameter-list-no-elements
 lib/ansible/modules/network/junos/junos_vrf.py validate-modules:parameter-type-not-in-doc
 lib/ansible/modules/network/junos/junos_vrf.py validate-modules:undocumented-parameter
-lib/ansible/modules/network/nxos/_nxos_interface.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/_nxos_interface.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/_nxos_interface.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/_nxos_interface.py validate-modules:doc-elements-mismatch
-lib/ansible/modules/network/nxos/_nxos_interface.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/_nxos_interface.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/_nxos_interface.py validate-modules:missing-suboption-docs
-lib/ansible/modules/network/nxos/_nxos_interface.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/_nxos_interface.py validate-modules:undocumented-parameter
-lib/ansible/modules/network/nxos/_nxos_l2_interface.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/_nxos_l2_interface.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/_nxos_l2_interface.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/_nxos_l2_interface.py validate-modules:doc-elements-mismatch
-lib/ansible/modules/network/nxos/_nxos_l2_interface.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/_nxos_l2_interface.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/_nxos_l2_interface.py validate-modules:missing-suboption-docs
-lib/ansible/modules/network/nxos/_nxos_l2_interface.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/_nxos_l2_interface.py validate-modules:undocumented-parameter
-lib/ansible/modules/network/nxos/_nxos_l3_interface.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/_nxos_l3_interface.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/_nxos_l3_interface.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/_nxos_l3_interface.py validate-modules:doc-elements-mismatch
-lib/ansible/modules/network/nxos/_nxos_l3_interface.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/_nxos_l3_interface.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/_nxos_l3_interface.py validate-modules:missing-suboption-docs
-lib/ansible/modules/network/nxos/_nxos_l3_interface.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/_nxos_l3_interface.py validate-modules:undocumented-parameter
-lib/ansible/modules/network/nxos/_nxos_linkagg.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/_nxos_linkagg.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/_nxos_linkagg.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/_nxos_linkagg.py validate-modules:doc-elements-mismatch
-lib/ansible/modules/network/nxos/_nxos_linkagg.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/_nxos_linkagg.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/_nxos_linkagg.py validate-modules:missing-suboption-docs
-lib/ansible/modules/network/nxos/_nxos_linkagg.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/_nxos_linkagg.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/_nxos_linkagg.py validate-modules:undocumented-parameter
-lib/ansible/modules/network/nxos/_nxos_vlan.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/_nxos_vlan.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/_nxos_vlan.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/_nxos_vlan.py validate-modules:doc-elements-mismatch
-lib/ansible/modules/network/nxos/_nxos_vlan.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/_nxos_vlan.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/_nxos_vlan.py validate-modules:missing-suboption-docs
-lib/ansible/modules/network/nxos/_nxos_vlan.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/_nxos_vlan.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/_nxos_vlan.py validate-modules:undocumented-parameter
-lib/ansible/modules/network/nxos/nxos_aaa_server.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_aaa_server.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_aaa_server.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/nxos_aaa_server.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_aaa_server.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_aaa_server.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_aaa_server.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_aaa_server.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_aaa_server_host.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_aaa_server_host.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_aaa_server_host.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_aaa_server_host.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_aaa_server_host.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_aaa_server_host.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_aaa_server_host.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_acl.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_acl.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_acl.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/nxos_acl.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_acl.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_acl.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_acl.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_acl.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_acl_interface.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_acl_interface.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_acl_interface.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_acl_interface.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_acl_interface.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_acl_interface.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_acl_interface.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_banner.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_banner.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_banner.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_banner.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_banner.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_banner.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_bfd_global.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_bfd_global.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_bfd_global.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_bfd_global.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_bfd_global.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_bgp.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_bgp.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_bgp.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/nxos_bgp.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_bgp.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_bgp.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_bgp.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_bgp.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/nxos_bgp.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_bgp_af.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_bgp_af.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_bgp_af.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_bgp_af.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_bgp_af.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_bgp_af.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_bgp_af.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/nxos_bgp_af.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_bgp_neighbor.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_bgp_neighbor.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_bgp_neighbor.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_bgp_neighbor.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_bgp_neighbor.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_bgp_neighbor.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_bgp_neighbor.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_bgp_neighbor_af.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_bgp_neighbor_af.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_bgp_neighbor_af.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/nxos_bgp_neighbor_af.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_bgp_neighbor_af.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_bgp_neighbor_af.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_bgp_neighbor_af.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_bgp_neighbor_af.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/nxos_bgp_neighbor_af.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_command.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/nxos_command.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_command.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_command.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_command.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_command.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/nxos_command.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_config.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_config.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_config.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_config.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_config.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_config.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_config.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/nxos_config.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_evpn_global.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_evpn_global.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_evpn_global.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_evpn_global.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_evpn_global.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_evpn_vni.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_evpn_vni.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_evpn_vni.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_evpn_vni.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_evpn_vni.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_evpn_vni.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_evpn_vni.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/nxos_evpn_vni.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_facts.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_facts.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_facts.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_facts.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_facts.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_facts.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/nxos_facts.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_feature.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_feature.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_feature.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_feature.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_feature.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_feature.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_feature.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_gir.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_gir.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_gir.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/nxos_gir.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_gir.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_gir.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_gir.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_gir.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_gir_profile_management.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_gir_profile_management.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_gir_profile_management.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_gir_profile_management.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_gir_profile_management.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_gir_profile_management.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_gir_profile_management.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/nxos_gir_profile_management.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_hsrp.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_hsrp.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_hsrp.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_hsrp.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_hsrp.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_hsrp.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_hsrp.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_igmp.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_igmp.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_igmp.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_igmp.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_igmp.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_igmp.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_igmp_interface.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_igmp_interface.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_igmp_interface.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/nxos_igmp_interface.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_igmp_interface.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_igmp_interface.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_igmp_interface.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_igmp_interface.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_igmp_snooping.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_igmp_snooping.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_igmp_snooping.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_igmp_snooping.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_igmp_snooping.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_igmp_snooping.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_igmp_snooping.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_install_os.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_install_os.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_install_os.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_install_os.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_install_os.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_install_os.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_interface_ospf.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_interface_ospf.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_interface_ospf.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_interface_ospf.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_interface_ospf.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_interface_ospf.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_interface_ospf.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_lag_interfaces.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/nxos_lag_interfaces.py validate-modules:doc-elements-mismatch
-lib/ansible/modules/network/nxos/nxos_lldp.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/nxos_lldp.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_lldp.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_lldp.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_lldp.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_logging.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_logging.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_logging.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_logging.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_logging.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_logging.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_logging.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/nxos_logging.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_ntp.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_ntp.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_ntp.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_ntp.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_ntp.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_ntp_auth.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_ntp_auth.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_ntp_auth.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_ntp_auth.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_ntp_auth.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_ntp_auth.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_ntp_auth.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_ntp_options.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_ntp_options.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_ntp_options.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_ntp_options.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_ntp_options.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_ntp_options.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_ntp_options.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_nxapi.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_nxapi.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_nxapi.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/nxos_nxapi.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_nxapi.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_nxapi.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_nxapi.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_nxapi.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_ospf.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_ospf.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_ospf.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_ospf.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_ospf.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_ospf.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_ospf.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_ospf_vrf.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_ospf_vrf.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_ospf_vrf.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_ospf_vrf.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_ospf_vrf.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_ospf_vrf.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_ospf_vrf.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_overlay_global.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_overlay_global.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_overlay_global.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_overlay_global.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_overlay_global.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_overlay_global.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_pim.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_pim.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_pim.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_pim.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_pim.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_pim.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/nxos_pim.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_pim_interface.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_pim_interface.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_pim_interface.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/nxos_pim_interface.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_pim_interface.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_pim_interface.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_pim_rp_address.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_pim_rp_address.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_pim_rp_address.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/nxos_pim_rp_address.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_pim_rp_address.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_pim_rp_address.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_pim_rp_address.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_pim_rp_address.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_ping.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_ping.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_ping.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_ping.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_ping.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_ping.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_ping.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_reboot.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_reboot.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_reboot.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_reboot.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_reboot.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_rollback.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_rollback.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_rollback.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_rollback.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_rollback.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_rollback.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_rpm.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_rpm.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_rpm.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/nxos_rpm.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_rpm.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_rpm.py validate-modules:doc-elements-mismatch
-lib/ansible/modules/network/nxos/nxos_rpm.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_rpm.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_rpm.py validate-modules:missing-suboption-docs
-lib/ansible/modules/network/nxos/nxos_rpm.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_rpm.py validate-modules:undocumented-parameter
-lib/ansible/modules/network/nxos/nxos_smu.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_smu.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_smu.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_smu.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_smu.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_smu.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_snapshot.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_snapshot.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_snapshot.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_snapshot.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_snapshot.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_snapshot.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_snapshot.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_snmp_community.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_snmp_community.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_snmp_community.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_snmp_community.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_snmp_community.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_snmp_community.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_snmp_community.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_snmp_contact.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_snmp_contact.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_snmp_contact.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_snmp_contact.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_snmp_contact.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_snmp_contact.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_snmp_contact.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_snmp_host.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_snmp_host.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_snmp_host.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_snmp_host.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_snmp_host.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_snmp_host.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_snmp_host.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_snmp_location.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_snmp_location.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_snmp_location.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_snmp_location.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_snmp_location.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_snmp_location.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_snmp_location.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_snmp_traps.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_snmp_traps.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_snmp_traps.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_snmp_traps.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_snmp_traps.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_snmp_traps.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_snmp_user.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_snmp_user.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_snmp_user.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_snmp_user.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_snmp_user.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_snmp_user.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_snmp_user.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_static_route.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_static_route.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_static_route.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/nxos_static_route.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_static_route.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_static_route.py validate-modules:doc-elements-mismatch
-lib/ansible/modules/network/nxos/nxos_static_route.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_static_route.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_static_route.py validate-modules:missing-suboption-docs
-lib/ansible/modules/network/nxos/nxos_static_route.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_static_route.py validate-modules:undocumented-parameter
-lib/ansible/modules/network/nxos/nxos_system.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_system.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_system.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_system.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_system.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_system.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_system.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/nxos_system.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_telemetry.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/nxos_udld.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_udld.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_udld.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_udld.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_udld.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_udld.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_udld.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_udld_interface.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_udld_interface.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_udld_interface.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_udld_interface.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_udld_interface.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_udld_interface.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_udld_interface.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_user.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_user.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_user.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/nxos_user.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_user.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_user.py validate-modules:doc-elements-mismatch
-lib/ansible/modules/network/nxos/nxos_user.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_user.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_user.py validate-modules:missing-suboption-docs
-lib/ansible/modules/network/nxos/nxos_user.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/nxos_user.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_user.py validate-modules:undocumented-parameter
-lib/ansible/modules/network/nxos/nxos_vlans.py validate-modules:doc-elements-mismatch
-lib/ansible/modules/network/nxos/nxos_vpc.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_vpc.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_vpc.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_vpc.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_vpc.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_vpc.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_vpc.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_vpc_interface.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_vpc_interface.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_vpc_interface.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_vpc_interface.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_vpc_interface.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_vpc_interface.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_vpc_interface.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_vrf.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_vrf.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_vrf.py validate-modules:doc-choices-do-not-match-spec
-lib/ansible/modules/network/nxos/nxos_vrf.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_vrf.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_vrf.py validate-modules:doc-elements-mismatch
-lib/ansible/modules/network/nxos/nxos_vrf.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_vrf.py validate-modules:missing-suboption-docs
-lib/ansible/modules/network/nxos/nxos_vrf.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/nxos_vrf.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_vrf.py validate-modules:undocumented-parameter
-lib/ansible/modules/network/nxos/nxos_vrf_af.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_vrf_af.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_vrf_af.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_vrf_af.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_vrf_af.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_vrf_af.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_vrf_interface.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_vrf_interface.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_vrf_interface.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_vrf_interface.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_vrf_interface.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_vrf_interface.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_vrf_interface.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_vrrp.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_vrrp.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_vrrp.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_vrrp.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_vrrp.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_vrrp.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_vrrp.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_vtp_domain.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_vtp_domain.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_vtp_domain.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_vtp_domain.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_vtp_domain.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_vtp_domain.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_vtp_password.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_vtp_password.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_vtp_password.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_vtp_password.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_vtp_password.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_vtp_password.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_vtp_password.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_vtp_version.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_vtp_version.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_vtp_version.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_vtp_version.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_vtp_version.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_vtp_version.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_vxlan_vtep.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_vxlan_vtep.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_vxlan_vtep.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_vxlan_vtep.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_vxlan_vtep.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_vxlan_vtep.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_vxlan_vtep.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/nxos_vxlan_vtep_vni.py future-import-boilerplate
-lib/ansible/modules/network/nxos/nxos_vxlan_vtep_vni.py metaclass-boilerplate
-lib/ansible/modules/network/nxos/nxos_vxlan_vtep_vni.py validate-modules:doc-default-does-not-match-spec
-lib/ansible/modules/network/nxos/nxos_vxlan_vtep_vni.py validate-modules:doc-default-incompatible-type
-lib/ansible/modules/network/nxos/nxos_vxlan_vtep_vni.py validate-modules:doc-missing-type
-lib/ansible/modules/network/nxos/nxos_vxlan_vtep_vni.py validate-modules:doc-required-mismatch
-lib/ansible/modules/network/nxos/nxos_vxlan_vtep_vni.py validate-modules:parameter-list-no-elements
-lib/ansible/modules/network/nxos/nxos_vxlan_vtep_vni.py validate-modules:parameter-type-not-in-doc
-lib/ansible/modules/network/nxos/storage/nxos_devicealias.py validate-modules:doc-elements-mismatch
-lib/ansible/modules/network/nxos/storage/nxos_vsan.py validate-modules:doc-elements-mismatch
-lib/ansible/modules/network/nxos/storage/nxos_zone_zoneset.py validate-modules:doc-elements-mismatch
 lib/ansible/modules/network/ovs/openvswitch_bridge.py validate-modules:doc-choices-do-not-match-spec
 lib/ansible/modules/network/ovs/openvswitch_bridge.py validate-modules:doc-missing-type
 lib/ansible/modules/network/ovs/openvswitch_bridge.py validate-modules:parameter-type-not-in-doc
@@ -2828,7 +2303,6 @@ lib/ansible/plugins/action/dellos6.py action-plugin-docs # base class for deprec
 lib/ansible/plugins/action/dellos9.py action-plugin-docs # base class for deprecated network platform modules using `connection: local`
 lib/ansible/plugins/action/junos.py action-plugin-docs # base class for deprecated network platform modules using `connection: local`
 lib/ansible/plugins/action/normal.py action-plugin-docs # default action plugin for modules without a dedicated action plugin
-lib/ansible/plugins/action/nxos.py action-plugin-docs # base class for deprecated network platform modules using `connection: local`
 lib/ansible/plugins/action/vyos.py action-plugin-docs # base class for deprecated network platform modules using `connection: local`
 lib/ansible/plugins/cache/base.py ansible-doc!skip  # not a plugin, but a stub for backwards compatibility
 lib/ansible/plugins/doc_fragments/azure.py future-import-boilerplate
@@ -2859,8 +2333,6 @@ lib/ansible/plugins/doc_fragments/inventory_cache.py future-import-boilerplate
 lib/ansible/plugins/doc_fragments/inventory_cache.py metaclass-boilerplate
 lib/ansible/plugins/doc_fragments/junos.py future-import-boilerplate
 lib/ansible/plugins/doc_fragments/junos.py metaclass-boilerplate
-lib/ansible/plugins/doc_fragments/nxos.py future-import-boilerplate
-lib/ansible/plugins/doc_fragments/nxos.py metaclass-boilerplate
 lib/ansible/plugins/doc_fragments/openstack.py future-import-boilerplate
 lib/ansible/plugins/doc_fragments/openstack.py metaclass-boilerplate
 lib/ansible/plugins/doc_fragments/ovirt.py future-import-boilerplate
@@ -3138,7 +2610,6 @@ test/units/modules/cloud/openstack/test_os_server.py metaclass-boilerplate
 test/units/modules/conftest.py future-import-boilerplate
 test/units/modules/conftest.py metaclass-boilerplate
 test/units/modules/files/test_copy.py future-import-boilerplate
-test/units/modules/network/nxos/test_nxos_acl_interface.py metaclass-boilerplate
 test/units/modules/packaging/language/test_pip.py future-import-boilerplate
 test/units/modules/packaging/language/test_pip.py metaclass-boilerplate
 test/units/modules/packaging/os/conftest.py future-import-boilerplate
diff --git a/test/units/modules/network/nxos/fixtures/_nxos_interface/show_interface b/test/units/modules/network/nxos/fixtures/_nxos_interface/show_interface
deleted file mode 100644
index f50b8f24e9..0000000000
--- a/test/units/modules/network/nxos/fixtures/_nxos_interface/show_interface
+++ /dev/null
@@ -1,129 +0,0 @@
-{
-  "TABLE_interface": {
-    "ROW_interface": [
-      {
-        "interface": "Ethernet2/1", 
-        "state": "up", 
-        "admin_state": "up", 
-        "share_state": "Dedicated", 
-        "eth_hw_desc": "Ethernet", 
-        "eth_hw_addr": "fa16.3e50.6647", 
-        "eth_bia_addr": "fa16.3e50.6619", 
-        "desc": "Test aggregation on first interface", 
-        "eth_mtu": "1500", 
-        "eth_bw": 1000000, 
-        "eth_dly": 10, 
-        "eth_reliability": "255", 
-        "eth_txload": "1", 
-        "eth_rxload": "1", 
-        "medium": "broadcast", 
-        "eth_mode": "routed", 
-        "eth_duplex": "full", 
-        "eth_speed": "1000 Mb/s", 
-        "eth_beacon": "off", 
-        "eth_autoneg": "off", 
-        "eth_in_flowctrl": "off", 
-        "eth_out_flowctrl": "off", 
-        "eth_mdix": "off", 
-        "eth_swt_monitor": "off", 
-        "eth_ethertype": "0x8100", 
-        "eth_eee_state": "n/a", 
-        "eth_link_flapped": "4d15h", 
-        "eth_clear_counters": "never", 
-        "eth_reset_cntr": 87, 
-        "eth_load_interval1_rx": 0, 
-        "eth_inrate1_bits": 0, 
-        "eth_inrate1_pkts": 0, 
-        "eth_load_interval1_tx": 0, 
-        "eth_outrate1_bits": 0, 
-        "eth_outrate1_pkts": 0, 
-        "eth_inrate1_summary_bits": "0 bps", 
-        "eth_inrate1_summary_pkts": "0 pps", 
-        "eth_outrate1_summary_bits": "0 bps", 
-        "eth_outrate1_summary_pkts": "0 pps", 
-        "eth_load_interval2_rx": 0, 
-        "eth_inrate2_bits": 0, 
-        "eth_inrate2_pkts": 0, 
-        "eth_load_interval2_tx": 0, 
-        "eth_outrate2_bits": 0, 
-        "eth_outrate2_pkts": 0, 
-        "eth_inrate2_summary_bits": "0 bps", 
-        "eth_inrate2_summary_pkts": "0 pps", 
-        "eth_outrate2_summary_bits": "0 bps", 
-        "eth_outrate2_summary_pkts": "0 pps", 
-        "eth_inucast": 0, 
-        "eth_inmcast": 0, 
-        "eth_inbcast": 0, 
-        "eth_inpkts": 0, 
-        "eth_inbytes": 0, 
-        "eth_jumbo_inpkts": 0, 
-        "eth_storm_supp": 0, 
-        "eth_runts": 0, 
-        "eth_giants": 0, 
-        "eth_crc": 0, 
-        "eth_nobuf": 0, 
-        "eth_inerr": 0, 
-        "eth_frame": 0, 
-        "eth_overrun": 0, 
-        "eth_underrun": 0, 
-        "eth_ignored": 0, 
-        "eth_watchdog": 0, 
-        "eth_bad_eth": 0, 
-        "eth_bad_proto": 0, 
-        "eth_in_ifdown_drops": 0, 
-        "eth_dribble": 0, 
-        "eth_indiscard": 0, 
-        "eth_inpause": 0, 
-        "eth_outucast": 0, 
-        "eth_outmcast": 0, 
-        "eth_outbcast": 0, 
-        "eth_outpkts": 0, 
-        "eth_outbytes": 0, 
-        "eth_jumbo_outpkts": 0, 
-        "eth_outerr": 0, 
-        "eth_coll": 0, 
-        "eth_deferred": 0, 
-        "eth_latecoll": 0, 
-        "eth_lostcarrier": 0, 
-        "eth_nocarrier": 0, 
-        "eth_babbles": 0, 
-        "eth_outdiscard": 0, 
-        "eth_outpause": 0
-      }, 
-      {
-        "interface": "loopback0", 
-        "state": "up", 
-        "admin_state": "up", 
-        "eth_hw_desc": "Loopback", 
-        "desc": "Loopback", 
-        "eth_ip_addr": "192.168.255.1", 
-        "eth_ip_mask": 32, 
-        "eth_ip_prefix": "192.168.255.1", 
-        "eth_mtu": "1500", 
-        "eth_bw": 8000000, 
-        "eth_dly": 5000, 
-        "eth_reliability": "255", 
-        "eth_txload": "1", 
-        "eth_rxload": "1", 
-        "medium": "broadcast", 
-        "eth_mode": "routed", 
-        "eth_mdix": "off", 
-        "loop_in_pkts": 1451854, 
-        "loop_in_bytes": 75138128, 
-        "loop_in_mcast": 0, 
-        "loop_in_compressed": 0, 
-        "loop_in_errors": 0, 
-        "loop_in_frame": 0, 
-        "loop_in_overrun": 0, 
-        "loop_in_fifo": 0, 
-        "loop_out_pkts": 0, 
-        "loop_out_bytes": 0, 
-        "loop_out_underruns": 0, 
-        "loop_out_errors": 0, 
-        "loop_out_collisions": 0, 
-        "loop_out_fifo": 0, 
-        "loop_out_carriers": 0
-      }
-    ]
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/_nxos_interface/show_interface_Ethernet2_1 b/test/units/modules/network/nxos/fixtures/_nxos_interface/show_interface_Ethernet2_1
deleted file mode 100644
index f478350f0d..0000000000
--- a/test/units/modules/network/nxos/fixtures/_nxos_interface/show_interface_Ethernet2_1
+++ /dev/null
@@ -1,96 +0,0 @@
-{
-  "TABLE_interface": {
-    "ROW_interface": {
-      "interface": "Ethernet2/1",
-      "state": "up",
-      "admin_state": "up",
-      "share_state": "Dedicated",
-      "eth_hw_desc": "Ethernet",
-      "eth_hw_addr": "fa16.3e00.0001",
-      "eth_bia_addr": "fa16.3e27.f279",
-      "desc": "to nxos03",
-      "eth_ip_addr": "10.0.0.45",
-      "eth_ip_mask": 30,
-      "eth_ip_prefix": "10.0.0.44",
-      "eth_mtu": "1500",
-      "eth_bw": 1000000,
-      "eth_dly": 10,
-      "eth_reliability": "255",
-      "eth_txload": "1",
-      "eth_rxload": "1",
-      "medium": "broadcast",
-      "eth_mode": "routed",
-      "eth_duplex": "full",
-      "eth_speed": "1000 Mb/s",
-      "eth_beacon": "off",
-      "eth_autoneg": "off",
-      "eth_in_flowctrl": "off",
-      "eth_out_flowctrl": "off",
-      "eth_mdix": "off",
-      "eth_swt_monitor": "off",
-      "eth_ethertype": "0x8100",
-      "eth_eee_state": "n/a",
-      "eth_link_flapped": "14week(s) 0day(s)",
-      "eth_clear_counters": "never",
-      "eth_reset_cntr": 1,
-      "eth_load_interval1_rx": 0,
-      "eth_inrate1_bits": 0,
-      "eth_inrate1_pkts": 0,
-      "eth_load_interval1_tx": 0,
-      "eth_outrate1_bits": 0,
-      "eth_outrate1_pkts": 0,
-      "eth_inrate1_summary_bits": "0 bps",
-      "eth_inrate1_summary_pkts": "0 pps",
-      "eth_outrate1_summary_bits": "0 bps",
-      "eth_outrate1_summary_pkts": "0 pps",
-      "eth_load_interval2_rx": 0,
-      "eth_inrate2_bits": 0,
-      "eth_inrate2_pkts": 0,
-      "eth_load_interval2_tx": 0,
-      "eth_outrate2_bits": 0,
-      "eth_outrate2_pkts": 0,
-      "eth_inrate2_summary_bits": "0 bps",
-      "eth_inrate2_summary_pkts": "0 pps",
-      "eth_outrate2_summary_bits": "0 bps",
-      "eth_outrate2_summary_pkts": "0 pps",
-      "eth_inucast": 0,
-      "eth_inmcast": 0,
-      "eth_inbcast": 0,
-      "eth_inpkts": 0,
-      "eth_inbytes": 0,
-      "eth_jumbo_inpkts": 0,
-      "eth_storm_supp": 0,
-      "eth_runts": 0,
-      "eth_giants": 0,
-      "eth_crc": 0,
-      "eth_nobuf": 0,
-      "eth_inerr": 0,
-      "eth_frame": 0,
-      "eth_overrun": 0,
-      "eth_underrun": 0,
-      "eth_ignored": 0,
-      "eth_watchdog": 0,
-      "eth_bad_eth": 0,
-      "eth_bad_proto": 0,
-      "eth_in_ifdown_drops": 0,
-      "eth_dribble": 0,
-      "eth_indiscard": 0,
-      "eth_inpause": 0,
-      "eth_outucast": 0,
-      "eth_outmcast": 0,
-      "eth_outbcast": 0,
-      "eth_outpkts": 0,
-      "eth_outbytes": 0,
-      "eth_jumbo_outpkts": 0,
-      "eth_outerr": 0,
-      "eth_coll": 0,
-      "eth_deferred": 0,
-      "eth_latecoll": 0,
-      "eth_lostcarrier": 0,
-      "eth_nocarrier": 0,
-      "eth_babbles": 0,
-      "eth_outdiscard": 0,
-      "eth_outpause": 0
-    }
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/_nxos_interface/show_interface_loopback0 b/test/units/modules/network/nxos/fixtures/_nxos_interface/show_interface_loopback0
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/test/units/modules/network/nxos/fixtures/_nxos_interface/show_run_interface_Ethernet2_1 b/test/units/modules/network/nxos/fixtures/_nxos_interface/show_run_interface_Ethernet2_1
deleted file mode 100644
index e60c3b4c01..0000000000
--- a/test/units/modules/network/nxos/fixtures/_nxos_interface/show_run_interface_Ethernet2_1
+++ /dev/null
@@ -1,8 +0,0 @@
-interface Ethernet1/5
-  description to csr02
-  no switchport
-  speed 1000
-  mtu 1500
-  mac-address fa16.3e00.000b
-  ip address 172.31.0.66/30
-  no shutdown
diff --git a/test/units/modules/network/nxos/fixtures/_nxos_interface/show_run_interface_loopback0 b/test/units/modules/network/nxos/fixtures/_nxos_interface/show_run_interface_loopback0
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/test/units/modules/network/nxos/fixtures/_nxos_ip_interface.cfg b/test/units/modules/network/nxos/fixtures/_nxos_ip_interface.cfg
deleted file mode 100644
index 3ca37d78ee..0000000000
--- a/test/units/modules/network/nxos/fixtures/_nxos_ip_interface.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-IP Interface Status for VRF "default"(1)
-Ethernet2/4, Interface status: protocol-up/link-up/admin-up, iod: 39,
-  IP address: 192.0.2.1, IP subnet: 1.1.1.0/8 route-preference: 0, tag: 0 
-  IP broadcast address: 255.255.255.255
-  IP multicast groups locally joined: none
-  IP MTU: 1500 bytes (using link MTU)
-  IP primary address route-preference: 0, tag: 0
-  IP proxy ARP : disabled
-  IP Local Proxy ARP : disabled
-  IP multicast routing: disabled
-  IP icmp redirects: enabled
-  IP directed-broadcast: disabled 
-  IP Forwarding: disabled 
-  IP icmp unreachables (except port): disabled
-  IP icmp port-unreachable: enabled
-  IP unicast reverse path forwarding: none
-  IP load sharing: none 
-  IP interface statistics last reset: never
-  IP interface software stats: (sent/received/forwarded/originated/consumed)
-    Unicast packets    : 0/0/0/0/0
-    Unicast bytes      : 0/0/0/0/0
-    Multicast packets  : 0/0/0/0/0
-    Multicast bytes    : 0/0/0/0/0
-    Broadcast packets  : 0/0/0/0/0
-    Broadcast bytes    : 0/0/0/0/0
-    Labeled packets    : 0/0/0/0/0
-    Labeled bytes      : 0/0/0/0/0
-  WCCP Redirect outbound: disabled
-  WCCP Redirect inbound: disabled
-  WCCP Redirect exclude: disabled
diff --git a/test/units/modules/network/nxos/fixtures/_nxos_switchport/show_interface_ethernet b/test/units/modules/network/nxos/fixtures/_nxos_switchport/show_interface_ethernet
deleted file mode 100644
index 60e729b2c3..0000000000
--- a/test/units/modules/network/nxos/fixtures/_nxos_switchport/show_interface_ethernet
+++ /dev/null
@@ -1,97 +0,0 @@
-{
-  "TABLE_interface": {
-    "ROW_interface": {
-      "interface": "Ethernet2/1", 
-      "state": "up", 
-      "admin_state": "up", 
-      "share_state": "Dedicated", 
-      "eth_hw_desc": "Ethernet", 
-      "eth_hw_addr": "fa16.3e00.0001", 
-      "eth_bia_addr": "fa16.3e27.f279", 
-      "desc": "to nxos03", 
-      "eth_ip_addr": "10.0.0.45", 
-      "eth_ip_mask": 30, 
-      "eth_ip_prefix": "10.0.0.44", 
-      "eth_mtu": "1500", 
-      "eth_bw": 1000000, 
-      "eth_dly": 10, 
-      "eth_reliability": "255", 
-      "eth_txload": "1", 
-      "eth_rxload": "1", 
-      "medium": "broadcast", 
-      "eth_mode": "access", 
-      "eth_bundle": 0,
-      "eth_duplex": "full", 
-      "eth_speed": "1000 Mb/s", 
-      "eth_beacon": "off", 
-      "eth_autoneg": "off", 
-      "eth_in_flowctrl": "off", 
-      "eth_out_flowctrl": "off", 
-      "eth_mdix": "off", 
-      "eth_swt_monitor": "off", 
-      "eth_ethertype": "0x8100", 
-      "eth_eee_state": "n/a", 
-      "eth_link_flapped": "13week(s) 0day(s)", 
-      "eth_clear_counters": "never", 
-      "eth_reset_cntr": 1, 
-      "eth_load_interval1_rx": 0, 
-      "eth_inrate1_bits": 0, 
-      "eth_inrate1_pkts": 0, 
-      "eth_load_interval1_tx": 0, 
-      "eth_outrate1_bits": 0, 
-      "eth_outrate1_pkts": 0, 
-      "eth_inrate1_summary_bits": "0 bps", 
-      "eth_inrate1_summary_pkts": "0 pps", 
-      "eth_outrate1_summary_bits": "0 bps", 
-      "eth_outrate1_summary_pkts": "0 pps", 
-      "eth_load_interval2_rx": 0, 
-      "eth_inrate2_bits": 0, 
-      "eth_inrate2_pkts": 0, 
-      "eth_load_interval2_tx": 0, 
-      "eth_outrate2_bits": 0, 
-      "eth_outrate2_pkts": 0, 
-      "eth_inrate2_summary_bits": "0 bps", 
-      "eth_inrate2_summary_pkts": "0 pps", 
-      "eth_outrate2_summary_bits": "0 bps", 
-      "eth_outrate2_summary_pkts": "0 pps", 
-      "eth_inucast": 0, 
-      "eth_inmcast": 0, 
-      "eth_inbcast": 0, 
-      "eth_inpkts": 0, 
-      "eth_inbytes": 0, 
-      "eth_jumbo_inpkts": 0, 
-      "eth_storm_supp": 0, 
-      "eth_runts": 0, 
-      "eth_giants": 0, 
-      "eth_crc": 0, 
-      "eth_nobuf": 0, 
-      "eth_inerr": 0, 
-      "eth_frame": 0, 
-      "eth_overrun": 0, 
-      "eth_underrun": 0, 
-      "eth_ignored": 0, 
-      "eth_watchdog": 0, 
-      "eth_bad_eth": 0, 
-      "eth_bad_proto": 0, 
-      "eth_in_ifdown_drops": 0, 
-      "eth_dribble": 0, 
-      "eth_indiscard": 0, 
-      "eth_inpause": 0, 
-      "eth_outucast": 0, 
-      "eth_outmcast": 0, 
-      "eth_outbcast": 0, 
-      "eth_outpkts": 0, 
-      "eth_outbytes": 0, 
-      "eth_jumbo_outpkts": 0, 
-      "eth_outerr": 0, 
-      "eth_coll": 0, 
-      "eth_deferred": 0, 
-      "eth_latecoll": 0, 
-      "eth_lostcarrier": 0, 
-      "eth_nocarrier": 0, 
-      "eth_babbles": 0, 
-      "eth_outdiscard": 0, 
-      "eth_outpause": 0
-    }
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/_nxos_switchport/show_interface_ethernet_switchport b/test/units/modules/network/nxos/fixtures/_nxos_switchport/show_interface_ethernet_switchport
deleted file mode 100644
index 352da5e7a3..0000000000
--- a/test/units/modules/network/nxos/fixtures/_nxos_switchport/show_interface_ethernet_switchport
+++ /dev/null
@@ -1,14 +0,0 @@
-{
-  "TABLE_interface": {
-    "ROW_interface": {
-      "interface": "Ethernet2/1", 
-      "oper_mode": "access",
-      "switchport": "Enabled",
-      "access_vlan": 2,
-      "access_vlan_name": "VLAN2",
-      "native_vlan": 10,
-      "native_vlan_name": "VLAN10",
-      "trunk_vlans": "1-50"
-    }
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/_nxos_switchport/show_vlan b/test/units/modules/network/nxos/fixtures/_nxos_switchport/show_vlan
deleted file mode 100644
index 407267bb00..0000000000
--- a/test/units/modules/network/nxos/fixtures/_nxos_switchport/show_vlan
+++ /dev/null
@@ -1,18 +0,0 @@
-{
-  "TABLE_vlanbrief": {
-    "ROW_vlanbrief": {
-      "vlanshowbr-vlanid": 1, 
-      "vlanshowbr-vlanid-utf": 1, 
-      "vlanshowbr-vlanname": "VLAN1", 
-      "vlanshowbr-vlanstate": "active", 
-      "vlanshowbr-shutstate": "noshutdown"
-    }
-  }, 
-  "TABLE_mtuinfo": {
-    "ROW_mtuinfo": {
-      "vlanshowinfo-vlanid": 1, 
-      "vlanshowinfo-media-type": "enet", 
-      "vlanshowinfo-vlanmode": "ce-vlan"
-    }
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_acl/show_ip_access-list.txt b/test/units/modules/network/nxos/fixtures/nxos_acl/show_ip_access-list.txt
deleted file mode 100644
index 37be9f7d78..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_acl/show_ip_access-list.txt
+++ /dev/null
@@ -1,227 +0,0 @@
-{
-  "TABLE_ip_ipv6_mac": {
-    "ROW_ip_ipv6_mac": [
-      {
-        "op_ip_ipv6_mac": "ip", 
-        "acl_name": "copp-system-p-acl-bgp", 
-        "TABLE_seqno": {
-          "ROW_seqno": [
-            {
-              "seqno": 10, 
-              "permitdeny": "permit", 
-              "proto_str": "tcp", 
-              "src_any": "any", 
-              "src_port_op": "gt", 
-              "src_port1_num": "1024", 
-              "dest_any": "any", 
-              "dest_port_op": "eq", 
-              "dest_port1_str": "bgp", 
-              "dest_port1_num": "179"
-            }, 
-            {
-              "seqno": 20, 
-              "permitdeny": "permit",
-              "proto_str": "tcp", 
-              "src_any": "any", 
-              "src_port_op": "eq", 
-              "src_port1_str": "bgp", 
-              "src_port1_num": "179", 
-              "dest_any": "any", 
-              "dest_port_op": "gt", 
-              "dest_port1_num": "1024"
-            }
-          ]
-        }
-      }, 
-      {
-        "op_ip_ipv6_mac": "ip", 
-        "acl_name": "copp-system-p-acl-cts", 
-        "TABLE_seqno": {
-          "ROW_seqno": [
-            {
-              "seqno": 10, 
-              "permitdeny": "permit", 
-              "proto_str": "tcp", 
-              "src_any": "any", 
-              "dest_any": "any", 
-              "dest_port_op": "eq", 
-              "dest_port1_num": "64999"
-            }, 
-            {
-              "seqno": 20, 
-              "permitdeny": "permit", 
-              "proto_str": "tcp", 
-              "src_any": "any", 
-              "src_port_op": "eq", 
-              "src_port1_num": "64999", 
-              "dest_any": "any"
-            }
-          ]
-        }
-      }, 
-      {
-        "op_ip_ipv6_mac": "ip", 
-        "acl_name": "copp-system-p-acl-dhcp", 
-        "TABLE_seqno": {
-          "ROW_seqno": [
-            {
-              "seqno": 10, 
-              "permitdeny": "permit", 
-              "proto_str": "udp", 
-              "src_any": "any", 
-              "src_port_op": "eq", 
-              "src_port1_str": "bootpc", 
-              "src_port1_num": "68", 
-              "dest_any": "any"
-            }, 
-            {
-              "seqno": 20, 
-              "permitdeny": "permit", 
-              "proto_str": "udp", 
-              "src_any": "any", 
-              "src_port_op": "neq", 
-              "src_port1_str": "bootps", 
-              "src_port1_num": "67", 
-              "dest_any": "any", 
-              "dest_port_op": "eq", 
-              "dest_port1_str": "bootps", 
-              "dest_port1_num": "67"
-            }
-          ]
-        }
-      }, 
-      {
-        "op_ip_ipv6_mac": "ip", 
-        "acl_name": "copp-system-p-acl-dhcp-relay-response", 
-        "TABLE_seqno": {
-          "ROW_seqno": [
-            {
-              "seqno": 10, 
-              "permitdeny": "permit", 
-              "proto_str": "udp", 
-              "src_any": "any", 
-              "src_port_op": "eq", 
-              "src_port1_str": "bootps", 
-              "src_port1_num": "67", 
-              "dest_any": "any"
-            }, 
-            {
-              "seqno": 20, 
-              "permitdeny": "permit", 
-              "proto_str": "udp", 
-              "src_any": "any", 
-              "dest_any": "any", 
-              "dest_port_op": "eq", 
-              "dest_port1_str": "bootpc", 
-              "dest_port1_num": "68"
-            }
-          ]
-        }
-      }, 
-      {
-        "op_ip_ipv6_mac": "ip", 
-        "acl_name": "copp-system-p-acl-eigrp", 
-        "TABLE_seqno": {
-          "ROW_seqno": {
-            "seqno": 10, 
-            "permitdeny": "permit",
-            "proto_str": "eigrp", 
-            "src_any": "any", 
-            "dest_any": "any"
-          }
-        }
-      }, 
-      {
-        "op_ip_ipv6_mac": "ip", 
-        "acl_name": "copp-system-p-acl-ftp", 
-        "TABLE_seqno": {
-          "ROW_seqno": [
-            {
-              "seqno": 10, 
-              "permitdeny": "permit", 
-              "proto_str": "tcp", 
-              "src_any": "any", 
-              "dest_any": "any", 
-              "dest_port_op": "eq", 
-              "dest_port1_str": "ftp-data", 
-              "dest_port1_num": "20"
-            }, 
-            {
-              "seqno": 20, 
-              "permitdeny": "permit", 
-              "proto_str": "tcp", 
-              "src_any": "any", 
-              "dest_any": "any", 
-              "dest_port_op": "eq", 
-              "dest_port1_str": "ftp", 
-              "dest_port1_num": "21"
-            }, 
-            {
-              "seqno": 30, 
-              "permitdeny": "permit", 
-              "proto_str": "tcp", 
-              "src_any": "any", 
-              "src_port_op": "eq", 
-              "src_port1_str": "ftp-data", 
-              "src_port1_num": "20", 
-              "dest_any": "any"
-            }, 
-            {
-              "seqno": 40, 
-              "permitdeny": "permit", 
-              "proto_str": "tcp", 
-              "src_any": "any", 
-              "src_port_op": "eq", 
-              "src_port1_str": "ftp", 
-              "src_port1_num": "21", 
-              "dest_any": "any"
-            }
-          ]
-        }
-      }, 
-      {
-        "op_ip_ipv6_mac": "ip", 
-        "acl_name": "copp-system-p-acl-glbp", 
-        "TABLE_seqno": {
-          "ROW_seqno": {
-            "seqno": 10, 
-            "permitdeny": "permit", 
-            "proto_str": "udp", 
-            "src_any": "any", 
-            "src_port_op": "eq", 
-            "src_port1_num": "3222", 
-            "dest_ip_prefix": "224.0.0.0/24", 
-            "dest_port_op": "eq", 
-            "dest_port1_num": "3222"
-          }
-        }
-      }, 
-      {
-        "op_ip_ipv6_mac": "ip", 
-        "acl_name": "copp-system-p-acl-hsrp", 
-        "TABLE_seqno": {
-          "ROW_seqno": [
-            {
-              "seqno": 10, 
-              "permitdeny": "permit", 
-              "proto_str": "udp", 
-              "src_any": "any", 
-              "dest_ip_prefix": "224.0.0.2/32", 
-              "dest_port_op": "eq", 
-              "dest_port1_num": "1985"
-            }, 
-            {
-              "seqno": 20, 
-              "permitdeny": "permit", 
-              "proto_str": "udp", 
-              "src_any": "any", 
-              "dest_ip_prefix": "224.0.0.102/32", 
-              "dest_port_op": "eq", 
-              "dest_port1_num": "1985"
-            }
-          ]
-        }
-      } 
-	]
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_acl_interface/show_running-config_aclmgr.txt b/test/units/modules/network/nxos/fixtures/nxos_acl_interface/show_running-config_aclmgr.txt
deleted file mode 100644
index ccf92c9913..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_acl_interface/show_running-config_aclmgr.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-ip access-list ANSIBLE_OUT
-  10 permit tcp 192.0.2.1/24 any
-interface Ethernet1/41
-  ip access-group copp-system-p-acl-bgp out
diff --git a/test/units/modules/network/nxos/fixtures/nxos_acl_interfaces/nxos_acl_interfaces.cfg b/test/units/modules/network/nxos/fixtures/nxos_acl_interfaces/nxos_acl_interfaces.cfg
deleted file mode 100644
index 199244e784..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_acl_interfaces/nxos_acl_interfaces.cfg
+++ /dev/null
@@ -1,2 +0,0 @@
-interface Ethernet1/2
-  ip access-group ACL1v4 out
\ No newline at end of file
diff --git a/test/units/modules/network/nxos/fixtures/nxos_bfd_global/N7K.cfg b/test/units/modules/network/nxos/fixtures/nxos_bfd_global/N7K.cfg
deleted file mode 100644
index efe9626869..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_bfd_global/N7K.cfg
+++ /dev/null
@@ -1,16 +0,0 @@
-feature bfd
-
-bfd echo-interface loopback2
-bfd echo-rx-interval 56
-bfd interval 51 min_rx 52 multiplier 4
-bfd slow-timer 2001
-bfd startup-timer 6
-bfd ipv4 echo-rx-interval 54
-bfd ipv4 interval 54 min_rx 54 multiplier 4
-bfd ipv4 slow-timer 2004
-bfd ipv6 echo-rx-interval 56
-bfd ipv6 interval 56 min_rx 56 multiplier 6
-bfd ipv6 slow-timer 2006
-bfd fabricpath slow-timer 2008
-bfd fabricpath interval 58 min_rx 58 multiplier 8
-bfd fabricpath vlan 2
diff --git a/test/units/modules/network/nxos/fixtures/nxos_bfd_global/N9K.cfg b/test/units/modules/network/nxos/fixtures/nxos_bfd_global/N9K.cfg
deleted file mode 100644
index ab1d2d4a51..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_bfd_global/N9K.cfg
+++ /dev/null
@@ -1,13 +0,0 @@
-feature bfd
-
-bfd echo-interface loopback2
-bfd echo-rx-interval 56
-bfd interval 51 min_rx 52 multiplier 4
-bfd slow-timer 2001
-bfd startup-timer 6
-bfd ipv4 echo-rx-interval 54
-bfd ipv4 interval 54 min_rx 54 multiplier 4
-bfd ipv4 slow-timer 2004
-bfd ipv6 echo-rx-interval 56
-bfd ipv6 interval 56 min_rx 56 multiplier 6
-bfd ipv6 slow-timer 2006
diff --git a/test/units/modules/network/nxos/fixtures/nxos_bgp/config.cfg b/test/units/modules/network/nxos/fixtures/nxos_bgp/config.cfg
deleted file mode 100644
index 2ef5533e42..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_bgp/config.cfg
+++ /dev/null
@@ -1,17 +0,0 @@
-feature bgp
-
-router bgp 65535
-  router-id 192.168.1.1
-  event-history cli size medium
-  event-history detail
-  vrf test2
-    address-family ipv4 unicast
-    timers bgp 1 10
-  neighbor 1.1.1.1
-  neighbor 1.1.1.2
-    bfd
-  neighbor 3.3.3.4
-    remove-private-as all
-  neighbor 3.3.3.5
-    address-family ipv4 unicast
-      maximum-prefix 30 30
diff --git a/test/units/modules/network/nxos/fixtures/nxos_bgp/config_32_bits_as.cfg b/test/units/modules/network/nxos/fixtures/nxos_bgp/config_32_bits_as.cfg
deleted file mode 100644
index 03db9936fd..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_bgp/config_32_bits_as.cfg
+++ /dev/null
@@ -1,6 +0,0 @@
-feature bgp
-
-router bgp 65535.65535
-  router-id 192.168.1.1
-  vrf test
-    address-family ipv4 unicast
diff --git a/test/units/modules/network/nxos/fixtures/nxos_command/show_version.txt b/test/units/modules/network/nxos/fixtures/nxos_command/show_version.txt
deleted file mode 100644
index ba9ae66515..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_command/show_version.txt
+++ /dev/null
@@ -1,68 +0,0 @@
-Cisco NX-OS Software
-Copyright (c) 2002-2016, Cisco Systems, Inc. All rights reserved.
-NX-OSv software ("NX-OSv Software") and related documentation,
-files or other reference materials ("Documentation") are
-the proprietary property and confidential information of Cisco
-Systems, Inc. ("Cisco") and are protected, without limitation,
-pursuant to United States and International copyright and trademark
-laws in the applicable jurisdiction which provide civil and criminal
-penalties for copying or distribution without Cisco's authorization.
-
-Any use or disclosure, in whole or in part, of the NX-OSv Software
-or Documentation to any third party for any purposes is expressly
-prohibited except as otherwise authorized by Cisco in writing.
-The copyrights to certain works contained herein are owned by other
-third parties and are used and distributed under license. Some parts
-of this software may be covered under the GNU Public License or the
-GNU Lesser General Public License. A copy of each such license is
-available at
-http://www.gnu.org/licenses/gpl.html and
-http://www.gnu.org/licenses/lgpl.html
-***************************************************************************
-*  NX-OSv is strictly limited to use for evaluation, demonstration and    *
-*  NX-OS education. NX-OSv is provided as-is and is not supported by      *
-*  Cisco's Technical Advisory Center. Any use or disclosure, in whole or  *
-*  in part of the NX-OSv Software or Documentation to any third party for *
-*  any purposes is expressly prohibited except as otherwise authorized by *
-*  Cisco in writing.                                                      *
-***************************************************************************
-nxos01# show version
-Cisco Nexus Operating System (NX-OS) Software
-TAC support: http://www.cisco.com/tac
-Documents: http://www.cisco.com/en/US/products/ps9372/tsd_products_support_series_home.html
-Copyright (c) 2002-2016, Cisco Systems, Inc. All rights reserved.
-The copyrights to certain works contained herein are owned by
-other third parties and are used and distributed under license.
-Some parts of this software are covered under the GNU Public
-License. A copy of the license is available at
-http://www.gnu.org/licenses/gpl.html.
-
-NX-OSv is a demo version of the Nexus Operating System
-
-Software
-  loader:    version N/A
-  kickstart: version 7.3(0)D1(1)
-  system:    version 7.3(0)D1(1)
-  kickstart image file is: bootflash:///titanium-d1-kickstart.7.3.0.D1.1.bin
-  kickstart compile time:  1/11/2016 16:00:00 [02/11/2016 10:30:12]
-  system image file is:    bootflash:///titanium-d1.7.3.0.D1.1.bin
-  system compile time:     1/11/2016 16:00:00 [02/11/2016 13:08:11]
-
-
-Hardware
-  cisco NX-OSv Chassis ("NX-OSv Supervisor Module")
-  QEMU Virtual CPU version 2.0 with 3064860 kB of memory.
-  Processor Board ID TM3E35B910B
-
-  Device name: nxos01
-  bootflash:    3184776 kB
-
-Kernel uptime is 7 day(s), 17 hour(s), 0 minute(s), 23 second(s)
-
-
-plugin
-  Core Plugin, Ethernet Plugin
-
-Active Package(s)
-
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_config/candidate.cfg b/test/units/modules/network/nxos/fixtures/nxos_config/candidate.cfg
deleted file mode 100644
index b11bc93e25..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_config/candidate.cfg
+++ /dev/null
@@ -1,7 +0,0 @@
-hostname switch01
-!
-interface Ethernet1
-   description test interface
-   no shutdown
-!
-ip routing
diff --git a/test/units/modules/network/nxos/fixtures/nxos_config/config.cfg b/test/units/modules/network/nxos/fixtures/nxos_config/config.cfg
deleted file mode 100644
index 6a471371a5..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_config/config.cfg
+++ /dev/null
@@ -1,26 +0,0 @@
-!
-hostname localhost
-ip domain-name eng.ansible.com
-!
-vrf definition mgmt
-!
-vrf definition test
-!
-interface Management1
-   ip address 192.168.1.1/24
-!
-interface Ethernet1
-   shutdown
-!
-interface Ethernet2
-   shutdown
-!
-interface Ethernet3
-   shutdown
-!
-interface Ethernet4
-   shutdown
-!
-interface Ethernet5
-   shutdown
-!
diff --git a/test/units/modules/network/nxos/fixtures/nxos_devicealias/shdadatabse.cfg b/test/units/modules/network/nxos/fixtures/nxos_devicealias/shdadatabse.cfg
deleted file mode 100644
index cc526a7146..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_devicealias/shdadatabse.cfg
+++ /dev/null
@@ -1,5 +0,0 @@
-device-alias name test1_add pwwn 56:02:22:11:22:88:11:67
-device-alias name test2_add pwwn 65:22:22:11:22:22:11:0d
-device-alias name tieHost-1 pwwn 10:00:00:00:89:a1:01:01
-device-alias name tieHost-2 pwwn 10:00:00:00:89:a1:01:02
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_devicealias/shdastatus.cfg b/test/units/modules/network/nxos/fixtures/nxos_devicealias/shdastatus.cfg
deleted file mode 100644
index 7db8803456..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_devicealias/shdastatus.cfg
+++ /dev/null
@@ -1,4 +0,0 @@
-Fabric Distribution : Enabled
-Database:- Device Aliases 3831  Mode: Enhanced
-           Checksum: 0xdc7b6c6c124abd8fe28cf6a1ab293c
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_devicealias/shdastatus_mansi.cfg b/test/units/modules/network/nxos/fixtures/nxos_devicealias/shdastatus_mansi.cfg
deleted file mode 100644
index aa399b6410..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_devicealias/shdastatus_mansi.cfg
+++ /dev/null
@@ -1,4 +0,0 @@
-Fabric Distribution : Disabled
-Database:- Device Aliases 3831  Mode: Basic
-           Checksum: 0xdc7b6c6c124abd8fe28cf6a1ab293c
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_devicealias/shdastatuslock.cfg b/test/units/modules/network/nxos/fixtures/nxos_devicealias/shdastatuslock.cfg
deleted file mode 100644
index 65cb052f5f..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_devicealias/shdastatuslock.cfg
+++ /dev/null
@@ -1,6 +0,0 @@
-Fabric Distribution : Enabled
-Database:- Device Aliases 3831  Mode: Enhanced
-           Checksum: 0xdc7b6c6c124abd8fe28cf6a1ab293c
-Locked By:- User "CLI/SNMPv3:admin" SWWN 20:00:54:7f:ee:1b:13:f0
-Pending Database:- Device Aliases 3831  Mode: Enhanced
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_evpn_global/configured.cfg b/test/units/modules/network/nxos/fixtures/nxos_evpn_global/configured.cfg
deleted file mode 100644
index 32504f6bfb..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_evpn_global/configured.cfg
+++ /dev/null
@@ -1,3 +0,0 @@
-hostname switch01
-nv overlay evpn
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_evpn_global/unconfigured.cfg b/test/units/modules/network/nxos/fixtures/nxos_evpn_global/unconfigured.cfg
deleted file mode 100644
index c555eaaf96..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_evpn_global/unconfigured.cfg
+++ /dev/null
@@ -1 +0,0 @@
-hostname switch01
diff --git a/test/units/modules/network/nxos/fixtures/nxos_evpn_vni_config.cfg b/test/units/modules/network/nxos/fixtures/nxos_evpn_vni_config.cfg
deleted file mode 100644
index b1c8352f58..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_evpn_vni_config.cfg
+++ /dev/null
@@ -1,8 +0,0 @@
-nv overlay evpn
-feature nv overlay
-
-evpn
-  vni 6000 l2
-    rd auto
-    route-target import auto
-    route-target export auto
diff --git a/test/units/modules/network/nxos/fixtures/nxos_feature/show_feature.txt b/test/units/modules/network/nxos/fixtures/nxos_feature/show_feature.txt
deleted file mode 100644
index cf6dbdbde8..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_feature/show_feature.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-Feature Name         Instance State 
--------------------- -------- -----
-nve                  1        disabled
-ospf                 1        enabled
diff --git a/test/units/modules/network/nxos/fixtures/nxos_interface_ospf/config.cfg b/test/units/modules/network/nxos/fixtures/nxos_interface_ospf/config.cfg
deleted file mode 100644
index 2061d4d71a..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_interface_ospf/config.cfg
+++ /dev/null
@@ -1,17 +0,0 @@
-interface Ethernet1/33
-interface Ethernet1/33.101
-  ip router ospf 1 area 0.0.0.1
-interface Ethernet1/34
-  ip router ospf 1 area 0.0.0.1
-  ip ospf passive-interface
-interface Ethernet1/35
-  ip router ospf 1 area 0.0.0.1
-  no ip ospf passive-interface
-
-interface Ethernet1/36
-  ip router ospf 1 area 0.0.0.1
-  ip ospf bfd
-
-interface Ethernet1/37
-  ip router ospf 1 area 0.0.0.1
-  ip ospf bfd disable
diff --git a/test/units/modules/network/nxos/fixtures/nxos_l3_interface/ethernet_noshut b/test/units/modules/network/nxos/fixtures/nxos_l3_interface/ethernet_noshut
deleted file mode 100644
index b0407edc49..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_l3_interface/ethernet_noshut
+++ /dev/null
@@ -1,3 +0,0 @@
-interface Ethernet1/1
-  description Configured by Ansible
-  no shutdown
diff --git a/test/units/modules/network/nxos/fixtures/nxos_l3_interface/ethernet_noshut_ipv4_ipv6 b/test/units/modules/network/nxos/fixtures/nxos_l3_interface/ethernet_noshut_ipv4_ipv6
deleted file mode 100644
index 3e4f197876..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_l3_interface/ethernet_noshut_ipv4_ipv6
+++ /dev/null
@@ -1,5 +0,0 @@
-interface Ethernet1/1
-  description Configured by Ansible
-  ip address 192.168.0.1/24
-  ipv6 address 2001:db8::1/124
-  no shutdown
diff --git a/test/units/modules/network/nxos/fixtures/nxos_l3_interface/ethernet_noshut_multiple_ipv6 b/test/units/modules/network/nxos/fixtures/nxos_l3_interface/ethernet_noshut_multiple_ipv6
deleted file mode 100644
index 9013b1348e..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_l3_interface/ethernet_noshut_multiple_ipv6
+++ /dev/null
@@ -1,7 +0,0 @@
-interface Ethernet1/1
-  description Configured by Ansible
-  ip address 192.168.0.1/24
-  ipv6 address 2001:db8:1::1/124
-  ipv6 address 2001:db8:2::1/124
-  ipv6 address 2001:db8::1/124
-  no shutdown
diff --git a/test/units/modules/network/nxos/fixtures/nxos_nxapi/n3k/show_run_all b/test/units/modules/network/nxos/fixtures/nxos_nxapi/n3k/show_run_all
deleted file mode 100644
index da0dfaa79f..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_nxapi/n3k/show_run_all
+++ /dev/null
@@ -1,2 +0,0 @@
-feature nxapi
-nxapi http port 80
diff --git a/test/units/modules/network/nxos/fixtures/nxos_nxapi/n7k/show_run_all b/test/units/modules/network/nxos/fixtures/nxos_nxapi/n7k/show_run_all
deleted file mode 100644
index 0c4a3ea5a6..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_nxapi/n7k/show_run_all
+++ /dev/null
@@ -1,5 +0,0 @@
-feature nxapi
-nxapi http port 80
-no nxapi https
-no nxapi sandbox
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_overlay_global_config.cfg b/test/units/modules/network/nxos/fixtures/nxos_overlay_global_config.cfg
deleted file mode 100644
index 45a6ff99c7..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_overlay_global_config.cfg
+++ /dev/null
@@ -1 +0,0 @@
-fabric forwarding anycast-gateway-mac 000B.000B.000B
diff --git a/test/units/modules/network/nxos/fixtures/nxos_pim/config.cfg b/test/units/modules/network/nxos/fixtures/nxos_pim/config.cfg
deleted file mode 100644
index 9771622d6f..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_pim/config.cfg
+++ /dev/null
@@ -1,2 +0,0 @@
-ip pim bfd
-ip pim ssm range 127.0.0.0/31
diff --git a/test/units/modules/network/nxos/fixtures/nxos_pim_interface/config.cfg b/test/units/modules/network/nxos/fixtures/nxos_pim_interface/config.cfg
deleted file mode 100644
index 2120e607bf..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_pim_interface/config.cfg
+++ /dev/null
@@ -1,11 +0,0 @@
-!Command: show running-config interface Ethernet2/1
-!Time: Mon Aug 21 17:22:02 2017
-
-version 7.3(0)D1(1)
-
-interface Ethernet2/1
-  description Configured by Ansible - Layer3
-  no switchport
-  mac-address fa16.3e00.0006
-  ip address 10.0.0.69/30
-  no shutdown
diff --git a/test/units/modules/network/nxos/fixtures/nxos_pim_interface/sh_run_interface_eth2_1_all b/test/units/modules/network/nxos/fixtures/nxos_pim_interface/sh_run_interface_eth2_1_all
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/test/units/modules/network/nxos/fixtures/nxos_pim_interface/show_interface_eth2_1 b/test/units/modules/network/nxos/fixtures/nxos_pim_interface/show_interface_eth2_1
deleted file mode 100644
index f478350f0d..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_pim_interface/show_interface_eth2_1
+++ /dev/null
@@ -1,96 +0,0 @@
-{
-  "TABLE_interface": {
-    "ROW_interface": {
-      "interface": "Ethernet2/1",
-      "state": "up",
-      "admin_state": "up",
-      "share_state": "Dedicated",
-      "eth_hw_desc": "Ethernet",
-      "eth_hw_addr": "fa16.3e00.0001",
-      "eth_bia_addr": "fa16.3e27.f279",
-      "desc": "to nxos03",
-      "eth_ip_addr": "10.0.0.45",
-      "eth_ip_mask": 30,
-      "eth_ip_prefix": "10.0.0.44",
-      "eth_mtu": "1500",
-      "eth_bw": 1000000,
-      "eth_dly": 10,
-      "eth_reliability": "255",
-      "eth_txload": "1",
-      "eth_rxload": "1",
-      "medium": "broadcast",
-      "eth_mode": "routed",
-      "eth_duplex": "full",
-      "eth_speed": "1000 Mb/s",
-      "eth_beacon": "off",
-      "eth_autoneg": "off",
-      "eth_in_flowctrl": "off",
-      "eth_out_flowctrl": "off",
-      "eth_mdix": "off",
-      "eth_swt_monitor": "off",
-      "eth_ethertype": "0x8100",
-      "eth_eee_state": "n/a",
-      "eth_link_flapped": "14week(s) 0day(s)",
-      "eth_clear_counters": "never",
-      "eth_reset_cntr": 1,
-      "eth_load_interval1_rx": 0,
-      "eth_inrate1_bits": 0,
-      "eth_inrate1_pkts": 0,
-      "eth_load_interval1_tx": 0,
-      "eth_outrate1_bits": 0,
-      "eth_outrate1_pkts": 0,
-      "eth_inrate1_summary_bits": "0 bps",
-      "eth_inrate1_summary_pkts": "0 pps",
-      "eth_outrate1_summary_bits": "0 bps",
-      "eth_outrate1_summary_pkts": "0 pps",
-      "eth_load_interval2_rx": 0,
-      "eth_inrate2_bits": 0,
-      "eth_inrate2_pkts": 0,
-      "eth_load_interval2_tx": 0,
-      "eth_outrate2_bits": 0,
-      "eth_outrate2_pkts": 0,
-      "eth_inrate2_summary_bits": "0 bps",
-      "eth_inrate2_summary_pkts": "0 pps",
-      "eth_outrate2_summary_bits": "0 bps",
-      "eth_outrate2_summary_pkts": "0 pps",
-      "eth_inucast": 0,
-      "eth_inmcast": 0,
-      "eth_inbcast": 0,
-      "eth_inpkts": 0,
-      "eth_inbytes": 0,
-      "eth_jumbo_inpkts": 0,
-      "eth_storm_supp": 0,
-      "eth_runts": 0,
-      "eth_giants": 0,
-      "eth_crc": 0,
-      "eth_nobuf": 0,
-      "eth_inerr": 0,
-      "eth_frame": 0,
-      "eth_overrun": 0,
-      "eth_underrun": 0,
-      "eth_ignored": 0,
-      "eth_watchdog": 0,
-      "eth_bad_eth": 0,
-      "eth_bad_proto": 0,
-      "eth_in_ifdown_drops": 0,
-      "eth_dribble": 0,
-      "eth_indiscard": 0,
-      "eth_inpause": 0,
-      "eth_outucast": 0,
-      "eth_outmcast": 0,
-      "eth_outbcast": 0,
-      "eth_outpkts": 0,
-      "eth_outbytes": 0,
-      "eth_jumbo_outpkts": 0,
-      "eth_outerr": 0,
-      "eth_coll": 0,
-      "eth_deferred": 0,
-      "eth_latecoll": 0,
-      "eth_lostcarrier": 0,
-      "eth_nocarrier": 0,
-      "eth_babbles": 0,
-      "eth_outdiscard": 0,
-      "eth_outpause": 0
-    }
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_pim_interface/show_ip_pim_interface_eth2_1 b/test/units/modules/network/nxos/fixtures/nxos_pim_interface/show_ip_pim_interface_eth2_1
deleted file mode 100644
index e013423ba4..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_pim_interface/show_ip_pim_interface_eth2_1
+++ /dev/null
@@ -1,68 +0,0 @@
-{
-  "TABLE_vrf": {
-    "ROW_vrf": {
-      "vrf-name": "default",
-      "TABLE_iod": {
-        "ROW_iod": {
-          "if-name": "Ethernet2/1",
-          "if-status": "protocol-up/link-up/admin-up",
-          "if-addr-summary": "IP address: 10.0.0.45, IP subnet: 10.0.0.44/30",
-          "pim-dr-address": "10.0.0.45",
-          "dr-priority": 2,
-          "nbr-cnt": 0,
-          "hello-interval-sec": 35,
-          "hello-timer": "PT3S",
-          "holdtime-sec": 105,
-          "if-conf-dr-priority": 1,
-          "if-conf-delay": 3,
-          "is-border": "true",
-          "genid": "38c4b959",
-          "isauth-config": "false",
-          "nbr-policy-name": "none configured",
-          "jp-interval": 1,
-          "jp-next-send": 1,
-          "pim-bfd-enabled": "no",
-          "is-passive": "false",
-          "is-pim-vpc-svi": "no",
-          "is-auto-enabled": "no",
-          "last-cleared": "PT0S",
-          "hello-sent": 23,
-          "hello-rcvd": 0,
-          "hello-early-sent": 0,
-          "jp-sent": 0,
-          "jp-rcvd": 0,
-          "assert-sent": 0,
-          "assert-rcvd": 0,
-          "graft-sent": 0,
-          "graft-rcvd": 0,
-          "graft-ack-sent": 0,
-          "graft-ack-rcvd": 0,
-          "df-offer-sent": 0,
-          "df-offer-rcvd": 0,
-          "df-winner-sent": 0,
-          "df-winner-rcvd": 0,
-          "df-backoff-sent": 0,
-          "df-backoff-rcvd": 0,
-          "pass-sent": 0,
-          "pass-rcvd": 0,
-          "cksum-errors": 0,
-          "invalid-errors": 0,
-          "invalid-df-errors": 0,
-          "auth-failed": 0,
-          "pak-len-errors": 0,
-          "ver-errors": 0,
-          "pkts-self": 0,
-          "pkts-non-nbr": 0,
-          "pkts-on-passive": 0,
-          "jp-rcvd-on-rpf": 0,
-          "jp-rcvd-no-rp": 0,
-          "jp-rcvd-wrong-rp": 0,
-          "jp-rcvd-for-ssm": 0,
-          "jp-rcvd-for-bidir": 0,
-          "jp-in-policy-filter": 0,
-          "jp-out-policy-filter": 0
-        }
-      }
-    }
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_pim_rp_address/config.cfg b/test/units/modules/network/nxos/fixtures/nxos_pim_rp_address/config.cfg
deleted file mode 100644
index ca9730ec7e..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_pim_rp_address/config.cfg
+++ /dev/null
@@ -1 +0,0 @@
-ip pim rp-address 1.2.3.4
diff --git a/test/units/modules/network/nxos/fixtures/nxos_static_route.cfg b/test/units/modules/network/nxos/fixtures/nxos_static_route.cfg
deleted file mode 100644
index 8b1a6fe863..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_static_route.cfg
+++ /dev/null
@@ -1,3 +0,0 @@
-ip route 10.10.30.0/24 1.2.4.8
-vrf context test
-  ip route 10.8.0.0/14 15.16.17.18
diff --git a/test/units/modules/network/nxos/fixtures/nxos_system_config.cfg b/test/units/modules/network/nxos/fixtures/nxos_system_config.cfg
deleted file mode 100644
index 362b733215..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_system_config.cfg
+++ /dev/null
@@ -1,16 +0,0 @@
-hostname nxos01
-system jumbomtu 1500
-!
-no ip domain-lookup
-ip domain-name ansible.com
-ip domain-list ansible.com
-ip domain-list redhat.com
-ip name-server 8.8.8.8 172.26.1.1
-!
-vrf context management
-  ip domain-name eng.ansible.com
-  ip domain-list ansible.com
-  ip domain-list redhat.com
-  ip name-server 172.26.1.1 8.8.8.8
-  ip route 172.26.0.0/16 172.26.4.1
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_telemetry/N9K.cfg b/test/units/modules/network/nxos/fixtures/nxos_telemetry/N9K.cfg
deleted file mode 100644
index 697c2c18bf..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_telemetry/N9K.cfg
+++ /dev/null
@@ -1,43 +0,0 @@
-feature telemetry
-
-telemetry
-  certificate /bootflash/server.key localhost
-  destination-profile
-    use-vrf management
-    use-compression gzip
-    source-interface loopback55
-  destination-group 2
-    ip address 192.168.0.1 port 50001 protocol gRPC encoding GPB
-    ip address 192.168.0.2 port 60001 protocol gRPC encoding GPB
-  destination-group 10
-    ip address 192.168.0.1 port 50001 protocol gRPC encoding GPB
-    ip address 192.168.0.2 port 60001 protocol gRPC encoding GPB
-  sensor-group 2
-    data-source DME
-    path boo depth 0
-    path sys/ospf depth 0 query-condition qc filter-condition fc
-    path interfaces depth 0
-    path sys/bgp
-    path sys/bgp/inst depth 0 query-condition foo filter-condition foo
-    path sys/bgp/inst/dom-default/peer-[10.10.10.11]/ent-[10.10.10.11]
-    path sys/bgp/inst/dom-default/peer-[20.20.20.11]/ent-[20.20.20.11]
-    path too depth 0 filter-condition foo
-  sensor-group 55
-  sensor-group 56
-    data-source DME
-    path environment
-    path interface
-    path resources
-    path vxlan
-  subscription 3
-  subscription 4
-    dst-grp 2
-    snsr-grp 2 sample-interval 1000
-  subscription 5
-    dst-grp 2
-    snsr-grp 2 sample-interval 1000
-  subscription 6
-    dst-grp 10
-  subscription 7
-    dst-grp 10
-    snsr-grp 2 sample-interval 1000
diff --git a/test/units/modules/network/nxos/fixtures/nxos_telemetry/N9K_SGs.cfg b/test/units/modules/network/nxos/fixtures/nxos_telemetry/N9K_SGs.cfg
deleted file mode 100644
index 1729ad813a..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_telemetry/N9K_SGs.cfg
+++ /dev/null
@@ -1,19 +0,0 @@
-feature telemetry
-
-telemetry
-  sensor-group 1
-    path sys/ch depth 4
-    path sys/procsys depth 1
-  sensor-group 2
-    data-source NX-API
-    path "show bgp l2vpn evpn summary"
-    path "show isis adjacency"
-    path "show mac address-table count" depth 2
-    path "show bgp sessions"
-  sensor-group 3
-    data-source NX-API
-    path "show interface ethernet1/1-52"
-  sensor-group 4
-    path sys/bd depth 2
-    path sys/eps/epId-1/nws depth 2
-    path sys/eps/epId-1/peers depth 2
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vlan/agg_show_vlan_brief.txt b/test/units/modules/network/nxos/fixtures/nxos_vlan/agg_show_vlan_brief.txt
deleted file mode 100644
index 4ba12553ed..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vlan/agg_show_vlan_brief.txt
+++ /dev/null
@@ -1,27 +0,0 @@
-{
-  "TABLE_vlanbriefxbrief": {
-    "ROW_vlanbriefxbrief": [
-      {
-       "vlanshowbr-vlanid": 1,
-       "vlanshowbr-vlanid-utf": 1,
-       "vlanshowbr-vlanname": "default",
-       "vlanshowbr-vlanstate": "active",
-       "vlanshowbr-shutstate": "noshutdown"
-      },
-      {
-       "vlanshowbr-vlanid": 4,
-       "vlanshowbr-vlanid-utf": 4,
-       "vlanshowbr-vlanname": "_4_",
-       "vlanshowbr-vlanstate": "active",
-       "vlanshowbr-shutstate": "noshutdown"
-      },
-      {
-       "vlanshowbr-vlanid": 5,
-       "vlanshowbr-vlanid-utf": 5,
-       "vlanshowbr-vlanname": "_5_",
-       "vlanshowbr-vlanstate": "active",
-       "vlanshowbr-shutstate": "noshutdown"
-      }
-    ]
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vlan/config.cfg b/test/units/modules/network/nxos/fixtures/nxos_vlan/config.cfg
deleted file mode 100644
index 905d309ff0..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vlan/config.cfg
+++ /dev/null
@@ -1,4 +0,0 @@
-vlan 1
-  mode ce
-  state active
-  no shutdown
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vlan/show_vlan_brief.txt b/test/units/modules/network/nxos/fixtures/nxos_vlan/show_vlan_brief.txt
deleted file mode 100644
index ca90e5d494..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vlan/show_vlan_brief.txt
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-  "TABLE_vlanbriefxbrief": {
-    "ROW_vlanbriefxbrief": {
-      "vlanshowbr-vlanid": 16777216, 
-      "vlanshowbr-vlanid-utf": 1, 
-      "vlanshowbr-vlanname": "default", 
-      "vlanshowbr-vlanstate": "active", 
-      "vlanshowbr-shutstate": "noshutdown"
-    }
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vlans/show_running-config b/test/units/modules/network/nxos/fixtures/nxos_vlans/show_running-config
deleted file mode 100644
index 51e64c9967..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vlans/show_running-config
+++ /dev/null
@@ -1,13 +0,0 @@
-vlan 1,3-5,8
-vlan 3
-  name test-vlan3
-vlan 5
-  shutdown
-  name test-changeme
-  mode fabricpath
-  state suspend
-  vn-segment 942
-vlan 8
-  shutdown
-  name test-changeme-not
-  state suspend
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vlans/show_running-config_no_facts b/test/units/modules/network/nxos/fixtures/nxos_vlans/show_running-config_no_facts
deleted file mode 100644
index ef66a7fff4..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vlans/show_running-config_no_facts
+++ /dev/null
@@ -1 +0,0 @@
-! no data
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vlans/show_running-config_vlan_1 b/test/units/modules/network/nxos/fixtures/nxos_vlans/show_running-config_vlan_1
deleted file mode 100644
index 4343b9f294..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vlans/show_running-config_vlan_1
+++ /dev/null
@@ -1 +0,0 @@
-vlan 1
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vlans/show_vlan b/test/units/modules/network/nxos/fixtures/nxos_vlans/show_vlan
deleted file mode 100644
index 9d53309f3f..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vlans/show_vlan
+++ /dev/null
@@ -1,45 +0,0 @@
-{
-  "TABLE_vlanbrief": {
-    "ROW_vlanbrief": [
-      { "vlanshowbr-vlanid": "1", "vlanshowbr-vlanid-utf": "1",
-        "vlanshowbr-vlanname": "default",
-        "vlanshowbr-vlanstate": "active",
-        "vlanshowbr-shutstate": "noshutdown"
-      },
-      { "vlanshowbr-vlanid": "3", "vlanshowbr-vlanid-utf": "3",
-        "vlanshowbr-vlanname": "test-vlan3",
-        "vlanshowbr-vlanstate": "active",
-        "vlanshowbr-shutstate": "noshutdown"
-      },
-      { "vlanshowbr-vlanid": "4", "vlanshowbr-vlanid-utf": "4",
-        "vlanshowbr-vlanname": "VLAN0004",
-        "vlanshowbr-vlanstate": "active",
-        "vlanshowbr-shutstate": "noshutdown"
-      },
-      { "vlanshowbr-vlanid": "5", "vlanshowbr-vlanid-utf": "5",
-        "vlanshowbr-vlanname": "test-changeme",
-        "vlanshowbr-vlanstate": "suspend",
-        "vlanshowbr-shutstate": "shutdown"
-      },
-      { "vlanshowbr-vlanid": "8", "vlanshowbr-vlanid-utf": "8",
-        "vlanshowbr-vlanname": "test-changeme-not",
-        "vlanshowbr-vlanstate": "suspend",
-        "vlanshowbr-shutstate": "shutdown"
-      }
-    ]
-  },
-  "TABLE_mtuinfo": {
-    "ROW_mtuinfo": [
-      { "vlanshowinfo-vlanid": "1", "vlanshowinfo-media-type": "enet",
-        "vlanshowinfo-vlanmode": "ce-vlan" },
-      { "vlanshowinfo-vlanid": "3", "vlanshowinfo-media-type": "enet",
-        "vlanshowinfo-vlanmode": "ce-vlan" },
-      { "vlanshowinfo-vlanid": "4", "vlanshowinfo-media-type": "enet",
-        "vlanshowinfo-vlanmode": "ce-vlan" },
-      { "vlanshowinfo-vlanid": "5", "vlanshowinfo-media-type": "enet",
-        "vlanshowinfo-vlanmode": "fabricpath-vlan" },
-      { "vlanshowinfo-vlanid": "8", "vlanshowinfo-media-type": "enet",
-        "vlanshowinfo-vlanmode": "ce-vlan" }
-    ]
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vlans/show_vlan_no_facts b/test/units/modules/network/nxos/fixtures/nxos_vlans/show_vlan_no_facts
deleted file mode 100644
index 0967ef424b..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vlans/show_vlan_no_facts
+++ /dev/null
@@ -1 +0,0 @@
-{}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vlans/show_vlan_vlan_1 b/test/units/modules/network/nxos/fixtures/nxos_vlans/show_vlan_vlan_1
deleted file mode 100644
index 630ebbc34b..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vlans/show_vlan_vlan_1
+++ /dev/null
@@ -1,16 +0,0 @@
-{
-  "TABLE_vlanbrief": {
-    "ROW_vlanbrief": {
-      "vlanshowbr-vlanid": "1", "vlanshowbr-vlanid-utf": "1",
-      "vlanshowbr-vlanname": "default",
-      "vlanshowbr-vlanstate": "active",
-      "vlanshowbr-shutstate": "noshutdown"
-    },
-  },
-  "TABLE_mtuinfo": {
-    "ROW_mtuinfo": {
-      "vlanshowinfo-vlanid": "1", "vlanshowinfo-media-type": "enet",
-      "vlanshowinfo-vlanmode": "ce-vlan"
-    },
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vpc/show_vpc b/test/units/modules/network/nxos/fixtures/nxos_vpc/show_vpc
deleted file mode 100644
index 7d2c2eaeee..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vpc/show_vpc
+++ /dev/null
@@ -1,20 +0,0 @@
-{
-  "vpc-domain-id": "not configured",
-  "vpc-peer-status": "peer-not-configured",
-  "vpc-peer-status-reason": "SUCCESS",
-  "vpc-peer-keepalive-status": "disabled",
-  "vpc-peer-consistency": "inconsistent",
-  "vpc-peer-consistency-status": "SYSERR_MCECM_MCT_DOES_NOT_EXISTS",
-  "vpc-per-vlan-peer-consistency": "inconsistent",
-  "vpc-type-2-consistency": "inconsistent",
-  "vpc-type-2-consistency-status": "SYSERR_MCECM_MCT_DOES_NOT_EXISTS",
-  "vpc-role": "none-established",
-  "num-of-vpcs": "0",
-  "peer-gateway": "disabled",
-  "dual-active-excluded-vlans": "-",
-  "vpc-graceful-consistency-check-status": "enabled",
-  "vpc-auto-recovery-status": "Enabled (timeout = 240 seconds)",
-  "operational-l3-peer": "disabled",
-  "vpc-isolation-status": "disabled-user",
-  "vpc-check-consist-note": "disabled"
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vpc/show_vrf_all b/test/units/modules/network/nxos/fixtures/nxos_vpc/show_vrf_all
deleted file mode 100644
index 838190fb71..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vpc/show_vrf_all
+++ /dev/null
@@ -1,30 +0,0 @@
-{
-  "TABLE_vrf": {
-    "ROW_vrf": [
-      {
-        "vrf_name": "coke",
-        "vrf_id": 4,
-        "vrf_state": "Up",
-        "vrf_reason": "--"
-      },
-      {
-        "vrf_name": "default",
-        "vrf_id": 1,
-        "vrf_state": "Up",
-        "vrf_reason": "--"
-      },
-      {
-        "vrf_name": "management",
-        "vrf_id": 2,
-        "vrf_state": "Up",
-        "vrf_reason": "--"
-      },
-      {
-        "vrf_name": "test-vrf",
-        "vrf_id": 3,
-        "vrf_state": "Up",
-        "vrf_reason": "--"
-      }
-    ]
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vpc/vrf_test_show_hardware b/test/units/modules/network/nxos/fixtures/nxos_vpc/vrf_test_show_hardware
deleted file mode 100644
index 612a6b3da0..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vpc/vrf_test_show_hardware
+++ /dev/null
@@ -1,3 +0,0 @@
-{
-  "kickstart_ver_str": "7.0(3)I5(3)"
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vpc/vrf_test_show_inventory b/test/units/modules/network/nxos/fixtures/nxos_vpc/vrf_test_show_inventory
deleted file mode 100644
index c1a149ddb2..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vpc/vrf_test_show_inventory
+++ /dev/null
@@ -1,13 +0,0 @@
-{
-  "TABLE_inv": {
-    "ROW_inv": [
-      {
-        "name": "Chassis",
-        "desc": "Nexus9000 C9504 (4 Slot) Chassis",
-        "productid": "N9K-C9504",
-        "vendorid": "V01",
-        "serialnum": "BR-549"
-      }
-    ]
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vpc/vrf_test_show_vpc b/test/units/modules/network/nxos/fixtures/nxos_vpc/vrf_test_show_vpc
deleted file mode 100644
index f86daa6bda..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vpc/vrf_test_show_vpc
+++ /dev/null
@@ -1,3 +0,0 @@
-{
-  "vpc-domain-id": "100"
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vpc/vrf_test_show_vrf_all b/test/units/modules/network/nxos/fixtures/nxos_vpc/vrf_test_show_vrf_all
deleted file mode 100644
index 3f56f8adbb..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vpc/vrf_test_show_vrf_all
+++ /dev/null
@@ -1,36 +0,0 @@
-{
-  "TABLE_vrf": {
-    "ROW_vrf": [
-      {
-        "vrf_name": "my_vrf",
-        "vrf_id": 4,
-        "vrf_state": "Up",
-        "vrf_reason": "--"
-      },
-      {
-        "vrf_name": "default",
-        "vrf_id": 1,
-        "vrf_state": "Up",
-        "vrf_reason": "--"
-      },
-      {
-        "vrf_name": "management",
-        "vrf_id": 2,
-        "vrf_state": "Up",
-        "vrf_reason": "--"
-      },
-      {
-        "vrf_name": "test-vrf",
-        "vrf_id": 3,
-        "vrf_state": "Up",
-        "vrf_reason": "--"
-      },
-      {
-        "vrf_name": "obviously-different-vrf",
-        "vrf_id": 4,
-        "vrf_state": "Up",
-        "vrf_reason": "--"
-      }
-    ]
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vpc/vrf_test_vpc_config b/test/units/modules/network/nxos/fixtures/nxos_vpc/vrf_test_vpc_config
deleted file mode 100644
index e7258296fd..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vpc/vrf_test_vpc_config
+++ /dev/null
@@ -1,2 +0,0 @@
-vpc domain 100
-  peer-keepalive destination 192.168.1.1 source 10.1.1.1 vrf my_vrf
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vpc_interface/show_port-channel_summary b/test/units/modules/network/nxos/fixtures/nxos_vpc_interface/show_port-channel_summary
deleted file mode 100644
index d62bea661a..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vpc_interface/show_port-channel_summary
+++ /dev/null
@@ -1,22 +0,0 @@
-{
-  "TABLE_channel": {
-    "ROW_channel": [
-      {
-        "group": "10",
-        "port-channel": "port-channel10",
-        "layer": "R",
-        "status": "D",
-        "type": "Eth",
-        "prtcl": "NONE"
-      },
-      {
-        "group": "20",
-        "port-channel": "port-channel20",
-        "layer": "R",
-        "status": "D",
-        "type": "Eth",
-        "prtcl": "NONE"
-      }
-    ]
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vpc_interface/show_vpc_brief b/test/units/modules/network/nxos/fixtures/nxos_vpc_interface/show_vpc_brief
deleted file mode 100644
index 2206eca096..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vpc_interface/show_vpc_brief
+++ /dev/null
@@ -1,14 +0,0 @@
-{
-  "TABLE_vpc": {
-    "ROW_vpc": [
-      {
-	"vpc-id": 100,
-	"vpc-ifindex": "Po10",
-	"vpc-port-state": "Up",
-	"vpc-thru-peerlink": 19,
-	"vpc-consistency": "consistent",
-	"vpc-consistency-status": "SUCCESS"
-       }
-    ]
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vrf/show_run_all b/test/units/modules/network/nxos/fixtures/nxos_vrf/show_run_all
deleted file mode 100644
index 06fe9f91d9..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vrf/show_run_all
+++ /dev/null
@@ -1,4 +0,0 @@
-vrf context coke
-vrf context management
-  ip route 172.26.0.0/16 172.26.4.1
-vrf context test-vrf
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vrf/show_vrf_default b/test/units/modules/network/nxos/fixtures/nxos_vrf/show_vrf_default
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vrf/show_vrf_default_interface b/test/units/modules/network/nxos/fixtures/nxos_vrf/show_vrf_default_interface
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vrf/show_vrf_management b/test/units/modules/network/nxos/fixtures/nxos_vrf/show_vrf_management
deleted file mode 100644
index 2b6e9b5212..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vrf/show_vrf_management
+++ /dev/null
@@ -1,10 +0,0 @@
-{
-  "TABLE_vrf": {
-    "ROW_vrf": {
-      "vrf_name": "management", 
-      "vrf_id": 2, 
-      "vrf_state": "Up", 
-      "vrf_reason": "--"
-    }
-  }
-}
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vrf/show_vrf_management_interface b/test/units/modules/network/nxos/fixtures/nxos_vrf/show_vrf_management_interface
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vrf/show_vrf_ntc b/test/units/modules/network/nxos/fixtures/nxos_vrf/show_vrf_ntc
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vrf/show_vrf_ntc_interface b/test/units/modules/network/nxos/fixtures/nxos_vrf/show_vrf_ntc_interface
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vrf_af/config.cfg b/test/units/modules/network/nxos/fixtures/nxos_vrf_af/config.cfg
deleted file mode 100644
index 1ac093f71f..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vrf_af/config.cfg
+++ /dev/null
@@ -1,22 +0,0 @@
-vrf context vrf1
-  address-family ipv4 unicast
-
-vrf context vrf11
-  address-family ipv4 unicast
-    route-target both auto evpn
-
-vrf context vrf21
-  address-family ipv4 unicast
-    route-target import 65000:1000
-    route-target import 65001:1000
-    route-target import 65002:1000
-    route-target export 65000:1000
-    route-target export 65001:1000
-    route-target export 65002:1000
-
-vrf context vrf31
-  address-family ipv4 unicast
-    route-target import 65000:1000
-    route-target export 65001:1000
-    route-target import 65002:1000
-    route-target export 65003:1000
\ No newline at end of file
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vsan/shvsan.cfg b/test/units/modules/network/nxos/fixtures/nxos_vsan/shvsan.cfg
deleted file mode 100644
index 035351a9f6..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vsan/shvsan.cfg
+++ /dev/null
@@ -1,35 +0,0 @@
-vsan 1 information
-         name:VSAN0001  state:active 
-         interoperability mode:default 
-         loadbalancing:src-id/dst-id/oxid 
-         operational state:up 
-
-vsan 10 information
-         name:VsanAll  state:suspended 
-         interoperability mode:default 
-         loadbalancing:src-id/dst-id/oxid 
-         operational state:down 
-
-vsan 221 information
-         name:VSAN0221  state:active 
-         interoperability mode:default 
-         loadbalancing:src-id/dst-id/oxid 
-         operational state:up 
-
-vsan 922 information
-         name:vsan-SAN-A  state:active 
-         interoperability mode:default 
-         loadbalancing:src-id/dst-id/oxid 
-         operational state:down 
-
-vsan 923 information
-         name:vsan-SAN-B  state:active 
-         interoperability mode:default 
-         loadbalancing:src-id/dst-id/oxid 
-         operational state:up 
-
-vsan 4079:evfp_isolated_vsan
-
-vsan 4094:isolated_vsan
-
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vsan/shvsanmem.cfg b/test/units/modules/network/nxos/fixtures/nxos_vsan/shvsanmem.cfg
deleted file mode 100644
index c57c72a2f0..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vsan/shvsanmem.cfg
+++ /dev/null
@@ -1,30 +0,0 @@
-vsan 1 interfaces:
-    fc1/4             fc1/5             fc1/6             fc1/7             
-    fc1/8             fc1/9             fc1/10            fc1/12            
-    fc1/13            fc1/14            fc1/15            fc1/16            
-    fc1/17            fc1/18            fc1/19            fc1/20            
-    fc1/22            fc1/23            fc1/24            fc1/25            
-    fc1/26            fc1/27            fc1/28            fc1/29            
-    fc1/30            fc1/31            fc1/32            fc1/33            
-    fc1/34            fc1/35            fc1/36            fc1/37            
-    fc1/38            fc1/39            fc1/40            
-
-vsan 10 interfaces:
-
-
-vsan 221 interfaces:
-
-
-vsan 922 interfaces:
-    fc1/1             fc1/2             fc1/3             port-channel55    
-
-vsan 923 interfaces:
-    fc1/11            fc1/21            port-channel56    
-
-vsan 4079(evfp_isolated_vsan) interfaces:
-
-
-vsan 4094(isolated_vsan) interfaces:
-    port-channel145   
-
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vxlan_vtep/config.cfg b/test/units/modules/network/nxos/fixtures/nxos_vxlan_vtep/config.cfg
deleted file mode 100644
index 88e2f0ba9a..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vxlan_vtep/config.cfg
+++ /dev/null
@@ -1,2 +0,0 @@
-interface nve1
-  member vni 6000
diff --git a/test/units/modules/network/nxos/fixtures/nxos_vxlan_vtep_vni/config.cfg b/test/units/modules/network/nxos/fixtures/nxos_vxlan_vtep_vni/config.cfg
deleted file mode 100644
index 88e2f0ba9a..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_vxlan_vtep_vni/config.cfg
+++ /dev/null
@@ -1,2 +0,0 @@
-interface nve1
-  member vni 6000
diff --git a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzone_0.cfg b/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzone_0.cfg
deleted file mode 100644
index 14b431b9b0..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzone_0.cfg
+++ /dev/null
@@ -1,8 +0,0 @@
-zone name zoneA vsan 923
-  pwwn 11:11:11:11:11:11:11:11
-  device-alias test123
-
-zone name zoneB vsan 923
-  pwwn 10:11:11:11:11:11:11:11
-  pwwn 62:62:62:62:21:21:21:21
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzone_1.cfg b/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzone_1.cfg
deleted file mode 100644
index 73d58c51e8..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzone_1.cfg
+++ /dev/null
@@ -1,8 +0,0 @@
-zone name zoneA vsan 922
-  pwwn 11:11:11:11:11:11:11:11
-  device-alias test123 both
-
-zone name zoneB vsan 922
-  pwwn 10:11:11:11:11:11:11:11
-  pwwn 62:62:62:62:21:21:21:21
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzone_2.cfg b/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzone_2.cfg
deleted file mode 100644
index 530266d4ca..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzone_2.cfg
+++ /dev/null
@@ -1,6 +0,0 @@
-zone name zv221 vsan 221
-  pwwn 21:01:00:1b:32:a1:c0:a8 [h181-dell-linux-top-p2]
-  pwwn 10:00:00:90:fa:c7:da:42 [h172-32ghost-p2]
-  pwwn 21:01:00:1b:32:aa:50:4b [h190-dell-linux-top-p2]
-  pwwn 50:06:01:6a:47:e4:6e:59 [VNX_UNITY_235_SPB-1-2]
-  pwwn 21:01:00:1b:32:aa:ff:4a [h189-dell-windows-bottom-p2]
diff --git a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzoneset_0.cfg b/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzoneset_0.cfg
deleted file mode 100644
index c1b560053d..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzoneset_0.cfg
+++ /dev/null
@@ -1,10 +0,0 @@
-zoneset name zsetname21 vsan 922
-  zone name zone21A vsan 922
-    pwwn 11:11:11:11:11:11:11:11  both
-    pwwn 62:62:62:62:12:12:12:12
-
-  zone name zone21B vsan 922
-    pwwn 10:11:11:11:11:11:11:11
-    pwwn 62:62:62:62:21:21:21:21
-    device-alias somedummyname
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzoneset_1.cfg b/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzoneset_1.cfg
deleted file mode 100644
index 77d296229c..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzoneset_1.cfg
+++ /dev/null
@@ -1,9 +0,0 @@
-zoneset name zsetname1 vsan 923
-  zone name zoneA vsan 923
-    pwwn 11:11:11:11:11:11:11:11
-    device-alias test123
-
-  zone name zoneB vsan 923
-    pwwn 10:11:11:11:11:11:11:11
-    pwwn 62:62:62:62:21:21:21:21
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzoneset_2.cfg b/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzoneset_2.cfg
deleted file mode 100644
index 923f54e4b6..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzoneset_2.cfg
+++ /dev/null
@@ -1,7 +0,0 @@
-zoneset name zsv221 vsan 221
-  zone name zv221 vsan 221
-    pwwn 21:01:00:1b:32:a1:c0:a8 [h181-dell-linux-top-p2]
-    pwwn 10:00:00:90:fa:c7:da:42 [h172-32ghost-p2]
-    pwwn 21:01:00:1b:32:aa:50:4b [h190-dell-linux-top-p2]
-    pwwn 50:06:01:6a:47:e4:6e:59 [VNX_UNITY_235_SPB-1-2]
-    pwwn 21:01:00:1b:32:aa:ff:4a [h189-dell-windows-bottom-p2]
diff --git a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonesetactive_0.cfg b/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonesetactive_0.cfg
deleted file mode 100644
index 1180410a1a..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonesetactive_0.cfg
+++ /dev/null
@@ -1,8 +0,0 @@
-zoneset name zsv221 vsan 221
-  zone name zv221 vsan 221
-  * fcid 0x2f0000 [pwwn 21:01:00:1b:32:a1:c0:a8] [h181-dell-linux-top-p2]
-  * fcid 0xa90000 [pwwn 10:00:00:90:fa:c7:da:42] [h172-32ghost-p2]
-  * fcid 0xd50000 [pwwn 21:01:00:1b:32:aa:50:4b] [h190-dell-linux-top-p2]
-  * fcid 0xde0000 [pwwn 50:06:01:6a:47:e4:6e:59] [VNX_UNITY_235_SPB-1-2]
-    pwwn 21:01:00:1b:32:aa:ff:4a [h189-dell-windows-bottom-p2]
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonestatus_0.cfg b/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonestatus_0.cfg
deleted file mode 100644
index 0bfced832b..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonestatus_0.cfg
+++ /dev/null
@@ -1,23 +0,0 @@
-VSAN: 922 default-zone: deny distribute: active only Interop: default
-    mode: basic merge-control: allow
-    session:  none
-    hard-zoning: enabled broadcast: unsupported
-    smart-zoning: enabled
-    rscn-format: fabric-address
-    activation overwrite control: disabled
-Default zone:
-    qos: none broadcast: unsupported ronly: unsupported
-Full Zoning Database :
-    DB size: 358 bytes
-    Zonesets:  1 Zones: 2 Aliases: 0
-Active Zoning Database :
-    DB Size: 125 bytes
-    Name: zsetname21 Zonesets: 1 Zones: 2
-Current Total Zone DB Usage: 483 / 2097152 bytes (0 % used)
-Pending (Session) DB size:
-    Full DB Copy size: n/a
-    Active DB Copy size: n/a
-SFC size: 483 / 2097152 bytes (0 % used)
-Status: Activation completed at 23:50:35 IST Jul  3 2019
-
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonestatus_1.cfg b/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonestatus_1.cfg
deleted file mode 100644
index bf7a4615fb..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonestatus_1.cfg
+++ /dev/null
@@ -1,23 +0,0 @@
-VSAN: 922 default-zone: deny distribute: full Interop: default
-    mode: enhanced merge-control: allow
-    session:  none
-    hard-zoning: enabled broadcast: unsupported
-    smart-zoning: disabled
-    rscn-format: fabric-address
-    activation overwrite control: disabled
-Default zone:
-    qos: none broadcast: unsupported ronly: unsupported
-Full Zoning Database :
-    DB size: 376 bytes
-    Zonesets:  1 Zones: 2 Aliases: 0 Attribute-groups: 1
-Active Zoning Database :
-    DB Size: 156 bytes
-    Name: zsetname21 Zonesets: 1 Zones: 2
-Current Total Zone DB Usage: 532 / 2097152 bytes (0 % used)
-Pending (Session) DB size:
-    Full DB Copy size: 0 bytes
-    Active DB Copy size: 0 bytes
-SFC size: 0 / 2097152 bytes (0 % used)
-Status: Set zoning mode complete at 10:19:02 IST Jul  5 2019
-
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonestatus_2.cfg b/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonestatus_2.cfg
deleted file mode 100644
index eb0db28eb9..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonestatus_2.cfg
+++ /dev/null
@@ -1,24 +0,0 @@
-VSAN: 923 default-zone: permit distribute: full Interop: default
-    mode: enhanced merge-control: allow
-    session:  none
-    hard-zoning: enabled broadcast: unsupported
-    smart-zoning: disabled
-    rscn-format: fabric-address
-    activation overwrite control: disabled
-Default zone:
-    qos: none broadcast: unsupported ronly: unsupported
-Full Zoning Database :
-    DB size: 356 bytes
-    Zonesets:  1 Zones: 2 Aliases: 0 Attribute-groups: 1
-Active Zoning Database :
-    DB Size: 136 bytes
-    Name: zsetname1 Zonesets: 1 Zones: 2
-Current Total Zone DB Usage: 492 / 2097152 bytes (0 % used)
-Pending (Session) DB size:
-    Full DB Copy size: 0 bytes
-    Active DB Copy size: 0 bytes
-SFC size: 0 / 2097152 bytes (0 % used)
-Status: Operation failed: [Error: WARNING: Specified zoneset already active and unchanged]:
-        at 11:06:21 IST Jul  5 2019
-
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonestatus_3.cfg b/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonestatus_3.cfg
deleted file mode 100644
index c5c32db0b4..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonestatus_3.cfg
+++ /dev/null
@@ -1,24 +0,0 @@
-VSAN: 923 default-zone: permit distribute: full Interop: default
-    mode: basic merge-control: allow
-    session:  none
-    hard-zoning: enabled broadcast: unsupported
-    smart-zoning: disabled
-    rscn-format: fabric-address
-    activation overwrite control: disabled
-Default zone:
-    qos: none broadcast: unsupported ronly: unsupported
-Full Zoning Database :
-    DB size: 356 bytes
-    Zonesets:  1 Zones: 2 Aliases: 0 Attribute-groups: 1
-Active Zoning Database :
-    DB Size: 136 bytes
-    Name: zsetname1 Zonesets: 1 Zones: 2
-Current Total Zone DB Usage: 492 / 2097152 bytes (0 % used)
-Pending (Session) DB size:
-    Full DB Copy size: 0 bytes
-    Active DB Copy size: 0 bytes
-SFC size: 0 / 2097152 bytes (0 % used)
-Status: Operation failed: [Error: WARNING: Specified zoneset already active and unchanged]:
-        at 11:06:21 IST Jul  5 2019
-
-
diff --git a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonestatus_4.cfg b/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonestatus_4.cfg
deleted file mode 100644
index 97c3a7156c..0000000000
--- a/test/units/modules/network/nxos/fixtures/nxos_zone_zoneset/shzonestatus_4.cfg
+++ /dev/null
@@ -1,23 +0,0 @@
-VSAN: 221 default-zone: deny distribute: full Interop: default
-    mode: enhanced merge-control: allow
-    session:  none
-    hard-zoning: enabled broadcast: unsupported
-    smart-zoning: disabled
-    rscn-format: fabric-address
-    activation overwrite control: disabled
-Default zone:
-    qos: none broadcast: unsupported ronly: unsupported
-Full Zoning Database :
-    DB size: 300 bytes
-    Zonesets:  1 Zones: 1 Aliases: 0 Attribute-groups: 1
-Active Zoning Database :
-    DB Size: 112 bytes
-    Name: zsv221 Zonesets: 1 Zones: 1
-Current Total Zone DB Usage: 412 / 2097152 bytes (0 % used)
-Pending (Session) DB size:
-    Full DB Copy size: 0 bytes
-    Active DB Copy size: 0 bytes
-SFC size: 0 / 2097152 bytes (0 % used)
-Status: 
-
-
diff --git a/test/units/modules/network/nxos/nxos_module.py b/test/units/modules/network/nxos/nxos_module.py
deleted file mode 100644
index 07670a282c..0000000000
--- a/test/units/modules/network/nxos/nxos_module.py
+++ /dev/null
@@ -1,117 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-import os
-import json
-
-from units.modules.utils import AnsibleExitJson, AnsibleFailJson, ModuleTestCase
-from units.modules.utils import set_module_args as _set_module_args
-
-
-def set_module_args(args, ignore_provider=None):
-    if 'provider' not in args and not ignore_provider:
-        args['provider'] = {'transport': args.get('transport') or 'cli'}
-
-    return _set_module_args(args)
-
-
-fixture_path = os.path.join(os.path.dirname(__file__), 'fixtures')
-fixture_data = {}
-
-
-def load_fixture(module_name, name, device=''):
-    path = os.path.join(fixture_path, module_name, device, name)
-    if not os.path.exists(path):
-        path = os.path.join(fixture_path, module_name, name)
-
-    if path in fixture_data:
-        return fixture_data[path]
-
-    with open(path) as f:
-        data = f.read()
-
-    try:
-        data = json.loads(data)
-    except Exception:
-        pass
-
-    fixture_data[path] = data
-    return data
-
-
-class TestNxosModule(ModuleTestCase):
-
-    def execute_module_devices(self, failed=False, changed=False, commands=None, sort=True, defaults=False):
-        module_name = self.module.__name__.rsplit('.', 1)[1]
-        local_fixture_path = os.path.join(fixture_path, module_name)
-
-        models = []
-        for path in os.listdir(local_fixture_path):
-            path = os.path.join(local_fixture_path, path)
-            if os.path.isdir(path):
-                models.append(os.path.basename(path))
-        if not models:
-            models = ['']
-
-        retvals = {}
-        for model in models:
-            retvals[model] = self.execute_module(
-                failed, changed, commands, sort, device=model)
-
-        return retvals
-
-    def execute_module(self, failed=False, changed=False, commands=None, sort=True, device=''):
-
-        self.load_fixtures(commands, device=device)
-
-        if failed:
-            result = self.failed()
-            self.assertTrue(result['failed'], result)
-        else:
-            result = self.changed(changed)
-            self.assertEqual(result['changed'], changed, result)
-        if commands is not None and len(commands) > 0:
-            if sort:
-                self.assertEqual(sorted(commands), sorted(
-                    result['commands']), result['commands'])
-            else:
-                self.assertEqual(
-                    commands, result['commands'], result['commands'])
-
-        return result
-
-    def failed(self):
-        with self.assertRaises(AnsibleFailJson) as exc:
-            self.module.main()
-        result = exc.exception.args[0]
-        self.assertTrue(result['failed'], result)
-        return result
-
-    def changed(self, changed=False):
-        with self.assertRaises(AnsibleExitJson) as exc:
-            self.module.main()
-
-        result = exc.exception.args[0]
-        self.assertEqual(result['changed'], changed, result)
-        return result
-
-    def load_fixtures(self, commands=None, device=''):
-        pass
diff --git a/test/units/modules/network/nxos/storage/test_nxos_devicealias.py b/test/units/modules/network/nxos/storage/test_nxos_devicealias.py
deleted file mode 100644
index 68080afef2..0000000000
--- a/test/units/modules/network/nxos/storage/test_nxos_devicealias.py
+++ /dev/null
@@ -1,229 +0,0 @@
-#!/usr/bin/env python
-# Copyright: Ansible Project
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import (absolute_import, division, print_function)
-
-__metaclass__ = type
-
-import pytest
-
-from units.compat.mock import patch
-from units.modules.utils import AnsibleFailJson
-from ansible.modules.network.nxos.storage import nxos_devicealias
-from ansible.modules.network.nxos.storage.nxos_devicealias import showDeviceAliasStatus
-from ansible.modules.network.nxos.storage.nxos_devicealias import showDeviceAliasDatabase
-
-from ..nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosDeviceAliasModule(TestNxosModule):
-    module = nxos_devicealias
-
-    def setUp(self):
-        super(TestNxosDeviceAliasModule, self).setUp()
-        module_path = 'ansible.modules.network.nxos.storage.nxos_devicealias.'
-
-        self.mock_run_commands = patch(module_path + 'run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-        self.mock_execute_show_cmd = patch(module_path + 'showDeviceAliasStatus.execute_show_cmd')
-        self.execute_show_cmd = self.mock_execute_show_cmd.start()
-
-        self.mock_execute_show_cmd_1 = patch(module_path + 'showDeviceAliasDatabase.execute_show_cmd')
-        self.execute_show_cmd_1 = self.mock_execute_show_cmd_1.start()
-
-        self.mock_load_config = patch(module_path + 'load_config')
-        self.load_config = self.mock_load_config.start()
-
-    def tearDown(self):
-        super(TestNxosDeviceAliasModule, self).tearDown()
-        self.mock_run_commands.stop()
-        self.mock_execute_show_cmd.stop()
-        self.mock_execute_show_cmd_1.stop()
-        self.mock_load_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.load_config.return_value = None
-
-    def test_da_mode_1(self):
-        # Playbook mode is basic
-        # Switch has mode as enahnced
-        set_module_args(dict(mode='basic'), True)
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatus.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask', 'no device-alias mode enhanced',
-                                              'device-alias commit', 'no terminal dont-ask'])
-
-    def test_da_mode_2(self):
-        # Playbook mode is enhanced
-        # Switch has mode as enahnced
-        set_module_args(dict(mode='enhanced'), True)
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatus.cfg')
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_da_distribute_1(self):
-        # Playbook mode is enhanced , distrbute = True
-        # Switch has mode as enahnced, distrbute = True
-        set_module_args(dict(distribute=True, mode='enhanced'), True)
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatus.cfg')
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_da_distribute_2(self):
-        # Playbook mode is enhanced , distrbute = False
-        # Switch has mode as enhanced, distrbute = True
-        set_module_args(dict(distribute=False, mode='enhanced'), True)
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatus.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['no device-alias distribute'])
-
-    def test_da_distribute_3(self):
-        # Playbook mode is basic , distrbute = False
-        # Switch has mode as enahnced, distrbute = True
-        set_module_args(dict(distribute=False, mode='basic'), True)
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatus.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['no device-alias distribute', 'no device-alias mode enhanced'])
-
-    def test_da_add_1(self):
-        # Playbook mode is enhanced , distrbute = true , some new da being added
-        # Switch has mode as enahnced, distrbute = True, switch doesnt have the new da being added
-        set_module_args(dict(distribute=True, mode='enhanced',
-                             da=[dict(name='somename', pwwn='10:00:00:00:89:a1:01:03'),
-                                 dict(name='somename1', pwwn='10:00:00:00:89:a1:02:03')]),
-                        True)
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatus.cfg')
-        self.execute_show_cmd_1.return_value = load_fixture('nxos_devicealias', 'shdadatabse.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask', 'device-alias database',
-                                              'device-alias name somename pwwn 10:00:00:00:89:a1:01:03',
-                                              'device-alias name somename1 pwwn 10:00:00:00:89:a1:02:03',
-                                              'device-alias commit', 'no terminal dont-ask'])
-
-    def test_da_add_2(self):
-        # Playbook mode is enhanced , distrbute = true , some new da being added
-        # Switch has mode as enahnced, distrbute = True, switch already has the pwwn:name
-        set_module_args(dict(distribute=True, mode='enhanced',
-                             da=[dict(name='tieHost-2', pwwn='10:00:00:00:89:a1:01:02')]),
-                        True)
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatus.cfg')
-        self.execute_show_cmd_1.return_value = load_fixture('nxos_devicealias', 'shdadatabse.cfg')
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_da_add_3(self):
-        # Playbook mode is enhanced , distrbute = true , some new da being added
-        # Switch has mode as enahnced, distrbute = True, switch same name present with different pwwn
-        set_module_args(dict(distribute=True, mode='enhanced',
-                             da=[dict(name='tieHost-2', pwwn='10:00:00:00:89:a1:01:ff')]),
-                        True)
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatus.cfg')
-        self.execute_show_cmd_1.return_value = load_fixture('nxos_devicealias', 'shdadatabse.cfg')
-        result = self.execute_module(changed=False, failed=True)
-
-    def test_da_add_4(self):
-        # Playbook mode is enhanced , distrbute = true , some new da being added
-        # Switch has mode as enahnced, distrbute = True, switch same pwwn present with different name
-        set_module_args(dict(distribute=True, mode='enhanced',
-                             da=[dict(name='tieHost-2222', pwwn='10:00:00:00:89:a1:01:02')]),
-                        True)
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatus.cfg')
-        self.execute_show_cmd_1.return_value = load_fixture('nxos_devicealias', 'shdadatabse.cfg')
-        result = self.execute_module(changed=False, failed=True)
-
-    def test_da_remove_1(self):
-        # Playbook mode is enhanced , distrbute = true , some da being removed
-        # Switch has mode as enahnced, distrbute = True, switch has the da that needs to be removed
-        set_module_args(dict(distribute=True, mode='enhanced',
-                             da=[dict(name='tieHost-2', pwwn='10:00:00:00:89:a1:01:02', remove=True)]),
-                        True)
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatus.cfg')
-        self.execute_show_cmd_1.return_value = load_fixture('nxos_devicealias', 'shdadatabse.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask', 'device-alias database',
-                                              'no device-alias name tieHost-2',
-                                              'device-alias commit', 'no terminal dont-ask'])
-
-    def test_da_remove_2(self):
-        # Playbook mode is enhanced , distrbute = true , some da being removed
-        # Switch has mode as enahnced, distrbute = True, switch does NOT have the da that needs to be removed
-        set_module_args(dict(distribute=True, mode='enhanced',
-                             da=[dict(name='somename', pwwn='10:00:00:00:89:a1:01:02', remove=True)]),
-                        True)
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatus.cfg')
-        self.execute_show_cmd_1.return_value = load_fixture('nxos_devicealias', 'shdadatabse.cfg')
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_da_lock(self):
-        # Playbook mode with some data, but switch has cfs lock acq
-        set_module_args(dict(distribute=True, mode='enhanced',
-                             da=[dict(name='somename', pwwn='10:00:00:00:89:a1:01:02', remove=True)]),
-                        True)
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatuslock.cfg')
-        self.execute_module(failed=True)
-
-    def test_da_paramete_not_supported(self):
-        # Playbook mode with some data, but switch has cfs lock acq
-        # the below one instead of 'mode' we are passing 'mod', kind of typo in playbook
-        set_module_args(dict(distribute=True, mod='enhanced',
-                             da=[dict(name='somename', pwwn='10:00:00:00:89:a1:01:02', remove=True)]),
-                        True)
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatus.cfg')
-        self.execute_show_cmd_1.return_value = load_fixture('nxos_devicealias', 'shdadatabse.cfg')
-        with pytest.raises(AnsibleFailJson) as errinfo:
-            self.execute_module()
-        testdata = errinfo.value.args[0]
-        assert 'Unsupported parameters' in str(testdata['msg'])
-        assert testdata['failed']
-
-    def test_da_name_parameter_missing(self):
-        # Lets say you are trying to add a device alias but forgot to put 'name' in the 'da' parameter
-        set_module_args(dict(distribute=True, mode='enhanced',
-                             da=[dict(pwwn='10:00:00:00:89:a1:01:02')]),
-                        True)
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatus.cfg')
-        self.execute_show_cmd_1.return_value = load_fixture('nxos_devicealias', 'shdadatabse.cfg')
-        with pytest.raises(AnsibleFailJson) as errinfo:
-            self.execute_module()
-        testdata = errinfo.value.args[0]
-        assert 'missing required arguments' in str(testdata['msg'])
-        assert testdata['failed']
-
-    def test_da_rename_1(self):
-        # rename works
-        set_module_args(dict(rename=[dict(old_name='test1_add', new_name='test234'),
-                                     dict(old_name='tieHost-1', new_name='tieTarget-1')]), True)
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatus.cfg')
-        self.execute_show_cmd_1.return_value = load_fixture('nxos_devicealias', 'shdadatabse.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask', 'device-alias database',
-                                              'device-alias rename test1_add test234',
-                                              'device-alias rename tieHost-1 tieTarget-1',
-                                              'device-alias commit', 'no terminal dont-ask'])
-
-    def test_da_rename_2(self):
-        # rename : oldname not present
-        set_module_args(dict(rename=[dict(old_name='test1', new_name='test234'),
-                                     dict(old_name='tie', new_name='tieTarget-1')]), True)
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatus.cfg')
-        self.execute_show_cmd_1.return_value = load_fixture('nxos_devicealias', 'shdadatabse.cfg')
-        result = self.execute_module(changed=False, failed=True)
-        self.assertEqual(result['commands'], [])
-
-    def test_da_mansi(self):
-        set_module_args(
-            {
-                "distribute": True,
-                "mode": "enhanced",
-            },
-            True
-        )
-        self.execute_show_cmd.return_value = load_fixture('nxos_devicealias', 'shdastatus_mansi.cfg')
-        self.execute_show_cmd_1.return_value = load_fixture('nxos_devicealias', 'shdadatabse.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['device-alias distribute', 'terminal dont-ask',
-                                              'device-alias mode enhanced',
-                                              'device-alias commit', 'no terminal dont-ask'])
diff --git a/test/units/modules/network/nxos/storage/test_nxos_vsan.py b/test/units/modules/network/nxos/storage/test_nxos_vsan.py
deleted file mode 100644
index 5e94601d72..0000000000
--- a/test/units/modules/network/nxos/storage/test_nxos_vsan.py
+++ /dev/null
@@ -1,237 +0,0 @@
-#!/usr/bin/env python
-# Copyright: Ansible Project
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import (absolute_import, division, print_function)
-
-__metaclass__ = type
-
-import pytest
-
-from units.compat.mock import patch
-from units.modules.utils import AnsibleFailJson
-from ansible.modules.network.nxos.storage import nxos_vsan
-from ansible.modules.network.nxos.storage.nxos_vsan import GetVsanInfoFromSwitch
-
-from ..nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosVsanModule(TestNxosModule):
-    module = nxos_vsan
-
-    def setUp(self):
-        super(TestNxosVsanModule, self).setUp()
-        module_path = 'ansible.modules.network.nxos.storage.nxos_vsan.'
-
-        self.mock_run_commands = patch(module_path + 'run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-        self.mock_execute_show_vsan_cmd = patch(module_path + 'GetVsanInfoFromSwitch.execute_show_vsan_cmd')
-        self.execute_show_vsan_cmd = self.mock_execute_show_vsan_cmd.start()
-
-        self.mock_execute_show_vsanmemcmd = patch(module_path + 'GetVsanInfoFromSwitch.execute_show_vsan_mem_cmd')
-        self.execute_show_vsanmem_cmd = self.mock_execute_show_vsanmemcmd.start()
-
-        self.mock_load_config = patch(module_path + 'load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.maxDiff = None
-
-    def tearDown(self):
-        super(TestNxosVsanModule, self).tearDown()
-        self.mock_run_commands.stop()
-        self.execute_show_vsan_cmd.stop()
-        self.execute_show_vsanmem_cmd.stop()
-        self.mock_load_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.load_config.return_value = None
-
-    def test_vsan_add_remove_but_present_in_switch(self):
-        margs = {
-            "vsan": [
-                {
-                    "interface": [
-                        "fc1/1",
-                        "port-channel 55"
-                    ],
-                    "id": 922,
-                    "remove": False,
-                    "name": "vsan-SAN-A"
-                },
-                {
-                    "interface": [
-                        "fc1/11",
-                        "fc1/21",
-                        "port-channel 56"
-                    ],
-                    "id": 923,
-                    "remove": False,
-                    "name": "vsan-SAN-B"
-                },
-                {
-                    "id": 1923,
-                    "remove": True,
-                    "name": "vsan-SAN-Old"
-                }
-            ]
-        }
-        set_module_args(margs, True)
-        self.execute_show_vsan_cmd.return_value = load_fixture('nxos_vsan', 'shvsan.cfg')
-        self.execute_show_vsanmem_cmd.return_value = load_fixture('nxos_vsan', 'shvsanmem.cfg')
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_vsan_remove(self):
-        margs = {
-            "vsan": [
-                {
-                    "id": 922,
-                    "remove": True
-                },
-                {
-                    "id": 923,
-                    "remove": True
-                }
-            ]
-        }
-        set_module_args(margs, True)
-        self.execute_show_vsan_cmd.return_value = load_fixture('nxos_vsan', 'shvsan.cfg')
-        self.execute_show_vsanmem_cmd.return_value = load_fixture('nxos_vsan', 'shvsanmem.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ["terminal dont-ask"] + ["vsan database"] +
-                         ["no vsan 922", "no vsan 923"] + ["no terminal dont-ask"])
-
-    def test_vsan_add(self):
-        margs = {
-            "vsan": [
-                {
-                    "interface": [
-                        "fc1/1",
-                        "port-channel 55"
-                    ],
-                    "id": 924,
-                    "name": "vsan-SAN-924"
-                },
-                {
-                    "interface": [
-                        "fc1/11",
-                        "fc1/21",
-                        "port-channel 56"
-                    ],
-                    "id": 925,
-                    "name": "vsan-SAN-925"
-                }
-            ]
-        }
-        set_module_args(margs, True)
-        self.execute_show_vsan_cmd.return_value = load_fixture('nxos_vsan', 'shvsan.cfg')
-        self.execute_show_vsanmem_cmd.return_value = load_fixture('nxos_vsan', 'shvsanmem.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ["terminal dont-ask"] + ["vsan database"] +
-                         ["vsan 924", "vsan 924 name vsan-SAN-924", "no vsan 924 suspend",
-                          "vsan 924 interface fc1/1", "vsan 924 interface port-channel 55"] +
-                         ["vsan 925", "vsan 925 name vsan-SAN-925", "no vsan 925 suspend", "vsan 925 interface fc1/11",
-                          "vsan 925 interface fc1/21", "vsan 925 interface port-channel 56"] +
-                         ["no terminal dont-ask"])
-
-    def test_vsan_suspend(self):
-        margs = {
-            "vsan": [
-                {
-                    "interface": [
-                        "fc1/1",
-                        "port-channel 55"
-                    ],
-                    "id": 924,
-                    "name": "vsan-SAN-924"
-                },
-                {
-                    "id": 925,
-                    "name": "vsan-SAN-925",
-                    "suspend": True
-                }
-            ]
-        }
-        set_module_args(margs, True)
-        self.execute_show_vsan_cmd.return_value = load_fixture('nxos_vsan', 'shvsan.cfg')
-        self.execute_show_vsanmem_cmd.return_value = load_fixture('nxos_vsan', 'shvsanmem.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ["terminal dont-ask"] + ["vsan database"] +
-                         ["vsan 924", "vsan 924 name vsan-SAN-924", "no vsan 924 suspend",
-                          "vsan 924 interface fc1/1", "vsan 924 interface port-channel 55"] +
-                         ["vsan 925", "vsan 925 name vsan-SAN-925", "vsan 925 suspend"] +
-                         ["no terminal dont-ask"])
-
-    def test_vsan_invalid_vsan(self):
-        margs = {
-            "vsan": [
-                {
-                    "id": 4096,
-                    "name": "vsan-SAN-925",
-                    "suspend": True
-                }
-            ]
-        }
-        set_module_args(margs, True)
-        self.execute_show_vsan_cmd.return_value = load_fixture('nxos_vsan', 'shvsan.cfg')
-        self.execute_show_vsanmem_cmd.return_value = load_fixture('nxos_vsan', 'shvsanmem.cfg')
-        with pytest.raises(AnsibleFailJson) as errinfo:
-            self.execute_module()
-            testdata = errinfo.value.args[0]
-            assert 'invalid vsan' in str(testdata['msg'])
-            assert testdata['failed']
-
-    def test_vsan_change_reserved_vsan(self):
-        margs = {
-            "vsan": [
-                {
-                    "id": 4094,
-                    "name": "vsan-SAN-925",
-                    "suspend": True
-                }
-            ]
-        }
-        set_module_args(margs, True)
-        self.execute_show_vsan_cmd.return_value = load_fixture('nxos_vsan', 'shvsan.cfg')
-        self.execute_show_vsanmem_cmd.return_value = load_fixture('nxos_vsan', 'shvsanmem.cfg')
-        result = self.execute_module(changed=False)
-        assert 'reserved vsan' in str(result['messages'])
-        self.assertEqual(result['commands'], [])
-
-    def test_vsan_add_int_existing_vsan(self):
-        margs = {
-            "vsan": [
-                {
-                    "interface": [
-                        "fc1/1",
-                        "fc1/40",
-                        "port-channel 155"
-                    ],
-                    "id": 922,
-                },
-            ]
-        }
-        set_module_args(margs, True)
-        self.execute_show_vsan_cmd.return_value = load_fixture('nxos_vsan', 'shvsan.cfg')
-        self.execute_show_vsanmem_cmd.return_value = load_fixture('nxos_vsan', 'shvsanmem.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ["terminal dont-ask"] + ["vsan database"] +
-                         ["vsan 922 interface fc1/40", "vsan 922 interface port-channel 155"] +
-                         ["no terminal dont-ask"])
-
-    def test_vsan_remove_non_existing_vsan(self):
-        margs = {
-            "vsan": [
-                {
-                    "id": 1111,
-                    "remove": True
-                },
-            ]
-        }
-        set_module_args(margs, True)
-        self.execute_show_vsan_cmd.return_value = load_fixture('nxos_vsan', 'shvsan.cfg')
-        self.execute_show_vsanmem_cmd.return_value = load_fixture('nxos_vsan', 'shvsanmem.cfg')
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-        assert 'no vsan' in str(result['messages'])
diff --git a/test/units/modules/network/nxos/storage/test_nxos_zone_zoneset.py b/test/units/modules/network/nxos/storage/test_nxos_zone_zoneset.py
deleted file mode 100644
index ec85dec41f..0000000000
--- a/test/units/modules/network/nxos/storage/test_nxos_zone_zoneset.py
+++ /dev/null
@@ -1,496 +0,0 @@
-#!/usr/bin/env python
-# Copyright: Ansible Project
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-from __future__ import (absolute_import, division, print_function)
-
-__metaclass__ = type
-
-import pytest
-
-from units.compat.mock import patch
-from units.modules.utils import AnsibleFailJson, AnsibleExitJson
-from ansible.modules.network.nxos.storage import nxos_zone_zoneset
-from ansible.modules.network.nxos.storage.nxos_zone_zoneset import ShowZonesetActive
-from ansible.modules.network.nxos.storage.nxos_zone_zoneset import ShowZoneset
-from ansible.modules.network.nxos.storage.nxos_zone_zoneset import ShowZone
-from ansible.modules.network.nxos.storage.nxos_zone_zoneset import ShowZoneStatus
-
-from ..nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosZoneZonesetModule(TestNxosModule):
-    module = nxos_zone_zoneset
-
-    def setUp(self):
-        super(TestNxosZoneZonesetModule, self).setUp()
-        module_path = 'ansible.modules.network.nxos.storage.nxos_zone_zoneset.'
-
-        self.mock_run_commands = patch(module_path + 'run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-        self.mock_execute_show_cmd_zoneset_active = patch(
-            module_path + 'ShowZonesetActive.execute_show_zoneset_active_cmd')
-        self.execute_show_cmd_zoneset_active = self.mock_execute_show_cmd_zoneset_active.start()
-
-        self.mock_execute_show_cmd_zoneset = patch(module_path + 'ShowZoneset.execute_show_zoneset_cmd')
-        self.execute_show_cmd_zoneset = self.mock_execute_show_cmd_zoneset.start()
-
-        self.mock_execute_show_cmd_zone = patch(module_path + 'ShowZone.execute_show_zone_vsan_cmd')
-        self.execute_show_cmd_zone = self.mock_execute_show_cmd_zone.start()
-
-        self.mock_execute_show_cmd_zone_status = patch(module_path + 'ShowZoneStatus.execute_show_zone_status_cmd')
-        self.execute_show_cmd_zone_status = self.mock_execute_show_cmd_zone_status.start()
-
-        self.mock_load_config = patch(module_path + 'load_config')
-        self.load_config = self.mock_load_config.start()
-
-    def tearDown(self):
-        super(TestNxosZoneZonesetModule, self).tearDown()
-        self.mock_run_commands.stop()
-
-        self.execute_show_cmd_zoneset_active.stop()
-        self.execute_show_cmd_zoneset.stop()
-        self.execute_show_cmd_zone.stop()
-        self.execute_show_cmd_zone_status.stop()
-
-        self.mock_load_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.load_config.return_value = None
-
-    # Test def zone from deny to permit and vice versa
-    def test_zone_defzone_deny_to_permit(self):
-        # switch has def-zone deny and mode basic
-        a = dict(zone_zoneset_details=[dict(vsan=922, default_zone='permit')])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_0.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask',
-                                              'zone default-zone permit vsan 922',
-                                              'no terminal dont-ask'])
-
-    def test_zone_defzone_deny_to_permit_1(self):
-        # switch has def-zone deny and mode enhanced
-        a = dict(zone_zoneset_details=[dict(vsan=922, default_zone='permit')])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_1.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask',
-                                              'zone default-zone permit vsan 922',
-                                              'zone commit vsan 922',
-                                              'no terminal dont-ask'])
-
-    def test_zone_defzone_permit_to_deny_1(self):
-        # switch has def-zone deny and mode enhanced
-        a = dict(zone_zoneset_details=[dict(vsan=923, default_zone='deny')])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_2.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask',
-                                              'no zone default-zone permit vsan 923',
-                                              'zone commit vsan 923',
-                                              'no terminal dont-ask'])
-
-    def test_zone_defzone_permit_to_deny_2(self):
-        # switch has def-zone deny and mode enhanced
-        a = dict(zone_zoneset_details=[dict(vsan=923, default_zone='deny')])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_3.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask',
-                                              'no zone default-zone permit vsan 923',
-                                              'no terminal dont-ask'])
-
-    # Test zone mode from basic to enhanced and vice versa
-    def test_zone_mode_basic_to_enh(self):
-        # switch has def-zone deny and mode basic
-        a = dict(zone_zoneset_details=[dict(vsan=922, mode='enhanced')])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_0.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask',
-                                              'zone mode enhanced vsan 922',
-                                              'zone commit vsan 922',
-                                              'no terminal dont-ask'])
-
-    # Test zone mode from basic to enhanced and vice versa
-    def test_zone_mode_basic_to_enh_1(self):
-        # switch has def-zone deny and mode basic
-        a = dict(zone_zoneset_details=[dict(vsan=922, mode='basic')])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_1.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask',
-                                              'no zone mode enhanced vsan 922',
-                                              'no terminal dont-ask'])
-
-    # Test zone smart-zone from enabled to disabled and vice versa
-    def test_zone_smart_zone(self):
-        # switch has def-zone deny and mode basic
-        a = dict(zone_zoneset_details=[dict(vsan=922, smart_zoning=False)])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_0.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask',
-                                              'no zone smart-zoning enable vsan 922',
-                                              'no terminal dont-ask'])
-
-    def test_zone_smart_zone_1(self):
-        # switch has def-zone deny and mode basic
-        a = dict(zone_zoneset_details=[dict(vsan=923, smart_zoning=True)])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_1.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask',
-                                              'zone smart-zoning enable vsan 923',
-                                              'zone commit vsan 923',
-                                              'no terminal dont-ask'])
-
-    # Test zone  add/removal
-    def test_zone_add_rem(self):
-        a = dict(zone_zoneset_details=[dict(
-            vsan=923,
-            zone=[
-                dict(
-                    name='zoneB',
-                    remove=True)
-            ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_1.cfg')
-        self.execute_show_cmd_zone.return_value = load_fixture('nxos_zone_zoneset', 'shzone_0.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'],
-                         ['terminal dont-ask', 'no zone name zoneB vsan 923', 'zone commit vsan 923',
-                          'no terminal dont-ask'])
-
-    def test_zone_add_rem_1(self):
-        a = dict(zone_zoneset_details=[dict(
-            vsan=923,
-            zone=[
-                dict(
-                    name='zoneC',
-                    remove=True)
-            ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_1.cfg')
-        self.execute_show_cmd_zone.return_value = load_fixture('nxos_zone_zoneset', 'shzone_0.cfg')
-        result = self.execute_module(changed=False, failed=False)
-        m = "zone 'zoneC' is not present in vsan 923"
-        assert m in str(result['messages'])
-        self.assertEqual(result['commands'], [])
-
-    def test_zone_add_rem_2(self):
-        a = dict(zone_zoneset_details=[dict(
-            vsan=923,
-            zone=[
-                dict(
-                    name='zoneBNew')
-            ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_1.cfg')
-        self.execute_show_cmd_zone.return_value = load_fixture('nxos_zone_zoneset', 'shzone_0.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask',
-                                              'zone name zoneBNew vsan 923',
-                                              'zone commit vsan 923',
-                                              'no terminal dont-ask'])
-
-    def test_zone_add_rem_3(self):
-        a = dict(zone_zoneset_details=[dict(
-            vsan=923,
-            zone=[
-                dict(
-                    name='zoneB')
-            ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_1.cfg')
-        self.execute_show_cmd_zone.return_value = load_fixture('nxos_zone_zoneset', 'shzone_0.cfg')
-        result = self.execute_module(changed=False, failed=False)
-        m = "zone 'zoneB' is already present in vsan 923"
-        assert m in str(result['messages'])
-        self.assertEqual(result['commands'], [])
-
-    # Test zone mem add/removal
-    def test_zonemem_add_rem(self):
-        mem1 = {'pwwn': '10:00:10:94:00:00:00:01'}
-        mem2 = {'device_alias': 'somename'}
-        a = dict(zone_zoneset_details=[dict(
-            vsan=923,
-            zone=[
-                dict(
-                    name='zoneBNew',
-                    members=[mem1, mem2])
-            ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_1.cfg')
-        self.execute_show_cmd_zone.return_value = load_fixture('nxos_zone_zoneset', 'shzone_0.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask',
-                                              'zone name zoneBNew vsan 923',
-                                              'member pwwn 10:00:10:94:00:00:00:01',
-                                              'member device-alias somename',
-                                              'zone commit vsan 923',
-                                              'no terminal dont-ask'])
-
-    # Test zone mem add/removal
-    def test_zonemem_add_rem_1(self):
-        mem1 = {'pwwn': '11:11:11:11:11:11:11:11', 'remove': True}
-        mem2 = {'device_alias': 'test123', 'remove': True}
-        a = dict(zone_zoneset_details=[dict(
-            vsan=923,
-            zone=[
-                dict(
-                    name='zoneA',
-                    members=[mem1, mem2])
-            ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_1.cfg')
-        self.execute_show_cmd_zone.return_value = load_fixture('nxos_zone_zoneset', 'shzone_0.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask',
-                                              'zone name zoneA vsan 923',
-                                              'no member pwwn 11:11:11:11:11:11:11:11',
-                                              'no member device-alias test123',
-                                              'zone commit vsan 923',
-                                              'no terminal dont-ask'])
-
-    # Test zone mem add/removal
-    def test_zonemem_add_rem_2(self):
-        mem1 = {'pwwn': '11:11:11:11:11:11:11:11', 'remove': True}
-        mem2 = {'device_alias': 'test123', 'remove': True}
-        a = dict(zone_zoneset_details=[dict(
-            vsan=923,
-            zone=[
-                dict(
-                    name='zoneA1',
-                    members=[mem1, mem2])
-            ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_1.cfg')
-        self.execute_show_cmd_zone.return_value = load_fixture('nxos_zone_zoneset', 'shzone_0.cfg')
-        result = self.execute_module(changed=False, failed=False)
-        m = "zone 'zoneA1' is not present in vsan 923 , hence cannot remove the members"
-        assert m in str(result['messages'])
-        self.assertEqual(result['commands'], [])
-
-    def test_zonemem_add_rem_3(self):
-        mem1 = {'pwwn': '10:00:10:94:00:00:00:01', 'devtype': 'initiator'}
-        mem2 = {'device_alias': 'somename', 'devtype': 'target'}
-        mem3 = {'device_alias': 'somenameWithBoth', 'devtype': 'both'}
-
-        a = dict(zone_zoneset_details=[dict(
-            vsan=922,
-            zone=[
-                dict(
-                    name='zoneBNew',
-                    members=[mem1, mem2, mem3])
-            ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_0.cfg')
-        self.execute_show_cmd_zone.return_value = load_fixture('nxos_zone_zoneset', 'shzone_1.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'],
-                         ['terminal dont-ask', 'zone name zoneBNew vsan 922',
-                          'member pwwn 10:00:10:94:00:00:00:01 initiator',
-                          'member device-alias somename target',
-                          'member device-alias somenameWithBoth both',
-                          'no terminal dont-ask'])
-
-    # Test zone mem add/removal with devtype
-    def test_zonemem_add_rem_4(self):
-        mem2 = {'device_alias': 'test123', 'devtype': 'both', 'remove': True}
-
-        a = dict(zone_zoneset_details=[dict(
-            vsan=922,
-            zone=[
-                dict(
-                    name='zoneA',
-                    members=[mem2])
-            ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_0.cfg')
-        self.execute_show_cmd_zone.return_value = load_fixture('nxos_zone_zoneset', 'shzone_1.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'],
-                         ['terminal dont-ask', 'zone name zoneA vsan 922',
-                          'no member device-alias test123 both',
-                          'no terminal dont-ask'])
-
-    # Test zoneset add/removal
-    def test_zoneset_add_rem(self):
-        a = dict(zone_zoneset_details=[
-            dict(vsan=922,
-                 zoneset=[
-                     dict(name='zsetname21', remove=True)
-                 ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_0.cfg')
-        self.execute_show_cmd_zoneset.return_value = load_fixture('nxos_zone_zoneset', 'shzoneset_0.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'],
-                         ['terminal dont-ask', 'no zoneset name zsetname21 vsan 922', 'no terminal dont-ask']
-                         )
-
-    def test_zoneset_add_rem_1(self):
-        a = dict(zone_zoneset_details=[
-            dict(vsan=922,
-                 zoneset=[
-                     dict(name='zsetname21New')
-                 ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_0.cfg')
-        self.execute_show_cmd_zoneset.return_value = load_fixture('nxos_zone_zoneset', 'shzoneset_0.cfg')
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'],
-                         ['terminal dont-ask', 'zoneset name zsetname21New vsan 922', 'no terminal dont-ask']
-                         )
-
-    def test_zoneset_add_rem_2(self):
-        a = dict(zone_zoneset_details=[
-            dict(vsan=922,
-                 zoneset=[
-                     dict(name='zsetname21')
-                 ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_0.cfg')
-        self.execute_show_cmd_zoneset.return_value = load_fixture('nxos_zone_zoneset', 'shzoneset_0.cfg')
-        result = self.execute_module(changed=False, failed=False)
-        m = "zoneset 'zsetname21' is already present in vsan 922"
-        self.assertEqual(result['commands'], [])
-        self.assertEqual(result['messages'], [m])
-
-    def test_zoneset_add_rem_3(self):
-        a = dict(zone_zoneset_details=[
-            dict(vsan=922,
-                 zoneset=[
-                     dict(name='zsetname21New', remove=True)
-                 ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_0.cfg')
-        self.execute_show_cmd_zoneset.return_value = load_fixture('nxos_zone_zoneset', 'shzoneset_0.cfg')
-        result = self.execute_module(changed=False, failed=False)
-        m = "zoneset 'zsetname21New' is not present in vsan 922 ,hence there is nothing to remove"
-        self.assertEqual(result['commands'], [])
-        self.assertEqual(result['messages'], [m])
-
-    # Test zoneset mem add/removal
-    def test_zoneset_mem_add_rem(self):
-        mem1 = {'name': 'newZoneV100'}
-
-        a = dict(zone_zoneset_details=[
-            dict(vsan=922,
-                 zoneset=[
-                     dict(name='zsetname21', members=[mem1])
-                 ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_0.cfg')
-        self.execute_show_cmd_zoneset.return_value = load_fixture('nxos_zone_zoneset', 'shzoneset_0.cfg')
-        result = self.execute_module(changed=True, failed=False)
-        self.assertEqual(result['commands'],
-                         ['terminal dont-ask', 'zoneset name zsetname21 vsan 922', 'member newZoneV100',
-                          'no terminal dont-ask']
-                         )
-
-    # Test zoneset mem add/removal
-    def test_zoneset_mem_add_rem_1(self):
-        mem1 = {'name': 'zone21A', 'remove': True}
-
-        a = dict(zone_zoneset_details=[
-            dict(vsan=922,
-                 zoneset=[
-                     dict(name='zsetname21', members=[mem1])
-                 ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_0.cfg')
-        self.execute_show_cmd_zoneset.return_value = load_fixture('nxos_zone_zoneset', 'shzoneset_0.cfg')
-        result = self.execute_module(changed=True, failed=False)
-        self.assertEqual(result['commands'],
-                         ['terminal dont-ask', 'zoneset name zsetname21 vsan 922', 'no member zone21A',
-                          'no terminal dont-ask']
-                         )
-
-    # Test zoneset mem add/removal
-    def test_zoneset_mem_add_rem_2(self):
-        mem1 = {'name': 'zone21', 'remove': True}
-
-        a = dict(zone_zoneset_details=[
-            dict(vsan=922,
-                 zoneset=[
-                     dict(name='zsetname21', members=[mem1])
-                 ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_0.cfg')
-        self.execute_show_cmd_zoneset.return_value = load_fixture('nxos_zone_zoneset', 'shzoneset_0.cfg')
-        result = self.execute_module(changed=False, failed=False)
-        m = "zoneset member 'zone21' is not present in zoneset 'zsetname21' in vsan 922 ,hence there is nothing to remove"
-        self.assertEqual(result['commands'], [])
-        self.assertEqual(result['messages'], [m])
-
-    # Test zoneset activate/deactivate
-    def test_zoneset_activate_deactivate(self):
-        a = dict(zone_zoneset_details=[
-            dict(vsan=221,
-                 zoneset=[
-                     dict(name='zsv221', action='activate')
-                 ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_4.cfg')
-        self.execute_show_cmd_zoneset.return_value = load_fixture('nxos_zone_zoneset', 'shzoneset_2.cfg')
-        self.execute_show_cmd_zoneset_active.return_value = load_fixture('nxos_zone_zoneset', 'shzonesetactive_0.cfg')
-        result = self.execute_module(changed=False, failed=False)
-        m = "zoneset 'zsv221' is already present in vsan 221"
-        m1 = "zoneset 'zsv221' in vsan 221 is already activated"
-        self.assertEqual(result['commands'], [])
-        self.assertEqual(result['messages'], [m, m1])
-
-    def test_zoneset_activate_deactivate_1(self):
-        a = dict(zone_zoneset_details=[
-            dict(vsan=221,
-                 zoneset=[
-                     dict(name='zsv221', action='deactivate')
-                 ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_4.cfg')
-        self.execute_show_cmd_zoneset.return_value = load_fixture('nxos_zone_zoneset', 'shzoneset_2.cfg')
-        self.execute_show_cmd_zoneset_active.return_value = load_fixture('nxos_zone_zoneset', 'shzonesetactive_0.cfg')
-        result = self.execute_module(changed=True, failed=False)
-        self.assertEqual(result['commands'], ['terminal dont-ask',
-                                              'no zoneset activate name zsv221 vsan 221',
-                                              'zone commit vsan 221',
-                                              'no terminal dont-ask'])
-
-    def test_zoneset_activate_deactivate_2(self):
-        a = dict(zone_zoneset_details=[
-            dict(vsan=221,
-                 zoneset=[
-                     dict(name='zsv221New', action='activate')
-                 ])
-        ])
-        set_module_args(a, True)
-        self.execute_show_cmd_zone_status.return_value = load_fixture('nxos_zone_zoneset', 'shzonestatus_4.cfg')
-        self.execute_show_cmd_zoneset.return_value = load_fixture('nxos_zone_zoneset', 'shzoneset_2.cfg')
-        self.execute_show_cmd_zoneset_active.return_value = load_fixture('nxos_zone_zoneset', 'shzonesetactive_0.cfg')
-        result = self.execute_module(changed=True, failed=False)
-        self.assertEqual(result['commands'], ['terminal dont-ask', 'zoneset name zsv221New vsan 221',
-                                              'zoneset activate name zsv221New vsan 221',
-                                              'zone commit vsan 221',
-                                              'no terminal dont-ask'])
diff --git a/test/units/modules/network/nxos/test_nxos_acl.py b/test/units/modules/network/nxos/test_nxos_acl.py
deleted file mode 100644
index 39fb0b0486..0000000000
--- a/test/units/modules/network/nxos/test_nxos_acl.py
+++ /dev/null
@@ -1,79 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-import json
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_acl
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosAclModule(TestNxosModule):
-
-    module = nxos_acl
-
-    def setUp(self):
-        super(TestNxosAclModule, self).setUp()
-
-        self.mock_run_commands = patch('ansible.modules.network.nxos.nxos_acl.run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_acl.load_config')
-        self.load_config = self.mock_load_config.start()
-
-    def tearDown(self):
-        super(TestNxosAclModule, self).tearDown()
-        self.mock_run_commands.stop()
-        self.mock_load_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        def load_from_file(*args, **kwargs):
-            module, commands = args
-            output = list()
-
-            for item in commands:
-                try:
-                    obj = json.loads(item)
-                    command = obj['command']
-                except ValueError:
-                    command = item
-                filename = '%s.txt' % str(command).split(' | ')[0].replace(' ', '_')
-                output.append(load_fixture('nxos_acl', filename))
-            return output
-
-        self.run_commands.side_effect = load_from_file
-        self.load_config.return_value = None
-
-    def test_nxos_acl(self):
-        set_module_args(dict(name='ANSIBLE', seq=10, action='permit',
-                             proto='tcp', src='192.0.2.1/24', dest='any'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['ip access-list ANSIBLE', '10 permit tcp 192.0.2.1/24 any'])
-
-    def test_nxos_acl_remove(self):
-        set_module_args(dict(name='copp-system-p-acl-bgp', seq=10, state='absent'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['ip access-list copp-system-p-acl-bgp', 'no 10'])
-
-    def test_nxos_acl_delete_acl(self):
-        set_module_args(dict(name='copp-system-p-acl-bgp', state='delete_acl'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['no ip access-list copp-system-p-acl-bgp'])
diff --git a/test/units/modules/network/nxos/test_nxos_acl_interface.py b/test/units/modules/network/nxos/test_nxos_acl_interface.py
deleted file mode 100644
index bfcab65a94..0000000000
--- a/test/units/modules/network/nxos/test_nxos_acl_interface.py
+++ /dev/null
@@ -1,71 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metacl_interfaceass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_acl_interface
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosAclInterfaceModule(TestNxosModule):
-
-    module = nxos_acl_interface
-
-    def setUp(self):
-        super(TestNxosAclInterfaceModule, self).setUp()
-
-        self.mock_run_commands = patch('ansible.modules.network.nxos.nxos_acl_interface.run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_acl_interface.load_config')
-        self.load_config = self.mock_load_config.start()
-
-    def tearDown(self):
-        super(TestNxosAclInterfaceModule, self).tearDown()
-        self.mock_run_commands.stop()
-        self.mock_load_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        def load_from_file(*args, **kwargs):
-            module, commands = args
-            output = list()
-
-            for item in commands:
-                try:
-                    command = item['command']
-                except ValueError:
-                    command = item
-                filename = '%s.txt' % str(command).split(' | ')[0].replace(' ', '_')
-                output.append(load_fixture('nxos_acl_interface', filename))
-            return output
-
-        self.run_commands.side_effect = load_from_file
-        self.load_config.return_value = None
-
-    def test_nxos_acl_interface(self):
-        set_module_args(dict(name='ANSIBLE', interface='ethernet1/41', direction='egress'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface ethernet1/41', 'ip access-group ANSIBLE out'])
-
-    def test_nxos_acl_interface_remove(self):
-        set_module_args(dict(name='copp-system-p-acl-bgp', interface='ethernet1/41',
-                             direction='egress', state='absent'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface ethernet1/41', 'no ip access-group copp-system-p-acl-bgp out'])
diff --git a/test/units/modules/network/nxos/test_nxos_acl_interfaces.py b/test/units/modules/network/nxos/test_nxos_acl_interfaces.py
deleted file mode 100644
index 8c55cd9480..0000000000
--- a/test/units/modules/network/nxos/test_nxos_acl_interfaces.py
+++ /dev/null
@@ -1,303 +0,0 @@
-#
-# (c) 2019, Ansible by Red Hat, inc
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-#
-
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from ansible.modules.network.nxos import nxos_acl_interfaces
-from units.compat.mock import patch, MagicMock
-from units.modules.utils import set_module_args
-from .nxos_module import TestNxosModule, load_fixture
-
-
-class TestNxosAclInterfacesModule(TestNxosModule):
-
-    module = nxos_acl_interfaces
-
-    def setUp(self):
-        super(TestNxosAclInterfacesModule, self).setUp()
-
-        self.mock_get_config = patch(
-            'ansible.module_utils.network.common.network.Config.get_config')
-        self.get_config = self.mock_get_config.start()
-
-        self.mock_load_config = patch(
-            'ansible.module_utils.network.common.network.Config.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_resource_connection_config = patch(
-            'ansible.module_utils.network.common.cfg.base.get_resource_connection'
-        )
-        self.get_resource_connection_config = self.mock_get_resource_connection_config.start(
-        )
-
-        self.mock_get_resource_connection_facts = patch(
-            'ansible.module_utils.network.common.facts.facts.get_resource_connection'
-        )
-        self.get_resource_connection_facts = self.mock_get_resource_connection_facts.start()
-
-        self.mock_edit_config = patch(
-            'ansible.module_utils.network.nxos.config.acl_interfaces.acl_interfaces.Acl_interfaces.edit_config'
-        )
-        self.edit_config = self.mock_edit_config.start()
-
-        self.mock_execute_show_command = patch(
-            'ansible.module_utils.network.nxos.facts.acl_interfaces.acl_interfaces.Acl_interfacesFacts.get_device_data'
-        )
-        self.execute_show_command = self.mock_execute_show_command.start()
-
-    def tearDown(self):
-        super(TestNxosAclInterfacesModule, self).tearDown()
-        self.mock_get_resource_connection_config.stop()
-        self.mock_get_resource_connection_facts.stop()
-        self.mock_edit_config.stop()
-        self.mock_get_config.stop()
-        self.mock_load_config.stop()
-        self.mock_execute_show_command.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        def load_from_file(*args, **kwargs):
-            output = '''interface Ethernet1/2\n  ip access-group ACL1v4 out\n interface Ethernet1/4\n ipv6 port traffic-filter ACL2v6 in\n'''
-            return output
-
-        self.execute_show_command.side_effect = load_from_file
-
-    def test_nxos_acl_interfaces_merged(self):
-        set_module_args(
-            dict(config=[
-                dict(name="Ethernet1/3",
-                     access_groups=[
-                         dict(afi="ipv4",
-                              acls=[
-                                  dict(
-                                      name="ACL1v4",
-                                      direction="in",
-                                  )
-                              ]
-                              )
-                     ]
-                     )
-            ], state="merged"))
-        commands = ['interface Ethernet1/3',
-                    'ip access-group ACL1v4 in']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_acl_interfaces_merged_idempotent(self):
-        set_module_args(
-            dict(config=[
-                dict(name="Ethernet1/2",
-                     access_groups=[
-                         dict(afi="ipv4",
-                              acls=[
-                                  dict(
-                                      name="ACL1v4",
-                                      direction="out",
-                                  )
-                              ]
-                              )
-                     ]
-                     ),
-                dict(name="Ethernet1/4",
-                     access_groups=[
-                         dict(afi="ipv6",
-                              acls=[
-                                  dict(
-                                      name="ACL2v6",
-                                      direction="in",
-                                      port=True
-                                  )
-                              ]
-                              )
-                     ]
-                     ),
-
-            ], state="merged"))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_acl_interfaces_replaced(self):
-        set_module_args(
-            dict(config=[
-                dict(name="Ethernet1/2",
-                     access_groups=[
-                          dict(afi="ipv6",
-                               acls=[
-                                   dict(
-                                       name="ACL1v6",
-                                       direction="in",
-                                       port=True
-                                   )
-                               ]
-                               )
-                     ]
-                     ),
-                dict(name="Ethernet1/5",
-                     access_groups=[
-                         dict(afi="ipv4",
-                              acls=[
-                                  dict(
-                                      name="ACL2v4",
-                                      direction="in",
-                                      port=True
-                                  )
-                              ]
-                              )
-                     ]
-                     )
-            ], state="replaced"))
-        commands = ['interface Ethernet1/2', 'no ip access-group ACL1v4 out',
-                    'ipv6 port traffic-filter ACL1v6 in', 'interface Ethernet1/5', 'ip port access-group ACL2v4 in']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_acl_interfaces_replaced_idempotent(self):
-        set_module_args(
-            dict(config=[
-                dict(name="Ethernet1/2",
-                     access_groups=[
-                         dict(afi="ipv4",
-                              acls=[
-                                  dict(
-                                      name="ACL1v4",
-                                      direction="out",
-                                  )
-                              ]
-                              )
-                     ]
-                     )], state="replaced"))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_acl_interfaces_overridden(self):
-        set_module_args(
-            dict(config=[
-                dict(name="Ethernet1/3",
-                     access_groups=[
-                          dict(afi="ipv4",
-                               acls=[
-                                   dict(
-                                       name="ACL2v4",
-                                       direction="out"
-                                   ),
-                                   dict(
-                                       name="PortACL",
-                                       direction="in",
-                                       port=True
-                                   ),
-                               ]
-                               )
-                     ]
-                     )], state="overridden"))
-        commands = ['interface Ethernet1/2', 'no ip access-group ACL1v4 out', 'interface Ethernet1/4',
-                    'no ipv6 port traffic-filter ACL2v6 in', 'interface Ethernet1/3', 'ip access-group ACL2v4 out', 'ip port access-group PortACL in']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_acl_interfaces_overridden_idempotent(self):
-        set_module_args(
-            dict(config=[
-                dict(name="Ethernet1/2",
-                     access_groups=[
-                          dict(afi="ipv4",
-                               acls=[
-                                   dict(
-                                       name="ACL1v4",
-                                       direction="out",
-                                   )
-                               ]
-                               )
-                     ]
-                     ),
-                dict(name="Ethernet1/4",
-                     access_groups=[
-                          dict(afi="ipv6",
-                               acls=[
-                                   dict(
-                                       name="ACL2v6",
-                                       direction="in",
-                                       port=True
-                                   )
-                               ]
-                               )
-                     ]
-                     ),
-            ], state="overridden"))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_acl_interfaces_deletedname(self):
-        set_module_args(
-            dict(config=[dict(name="Ethernet1/2")], state="deleted"))
-        commands = ['interface Ethernet1/2', 'no ip access-group ACL1v4 out']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_acl_interfaces_deletedafi(self):
-        set_module_args(
-            dict(config=[dict(name="Ethernet1/2", access_groups=[
-                dict(afi="ipv4")
-            ])], state="deleted"))
-        commands = ['interface Ethernet1/2', 'no ip access-group ACL1v4 out']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_acl_interfaces_deletedacl(self):
-        set_module_args(
-            dict(config=[dict(name="Ethernet1/2", access_groups=[
-                dict(afi="ipv4", acls=[
-                    dict(
-                        name="ACL1v4",
-                        direction="out"
-                    )
-                ])
-            ])], state="deleted"))
-        commands = ['interface Ethernet1/2', 'no ip access-group ACL1v4 out']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_acl_interfaces_rendered(self):
-        set_module_args(
-            dict(config=[
-                dict(name="Ethernet1/2",
-                     access_groups=[
-                          dict(afi="ipv4",
-                               acls=[
-                                   dict(
-                                       name="ACL1v4",
-                                       direction="out",
-                                   )
-                               ]
-                               )
-                     ]
-                     ),
-                dict(name="Ethernet1/4",
-                     access_groups=[
-                          dict(afi="ipv6",
-                               acls=[
-                                   dict(
-                                       name="ACL2v6",
-                                       direction="in",
-                                       port=True
-                                   )
-                               ]
-                               )
-                     ]
-                     ),
-            ], state="rendered"))
-        commands = ['interface Ethernet1/2', 'ip access-group ACL1v4 out',
-                    'interface Ethernet1/4', 'ipv6 port traffic-filter ACL2v6 in']
-        result = self.execute_module(changed=False)
-        self.assertEqual(sorted(result['rendered']), sorted(
-            commands), result['rendered'])
-
-    def test_nxos_acl_interfaces_parsed(self):
-        set_module_args(dict(running_config='''interface Ethernet1/2\n ip access-group ACL1v4 out\n interface Ethernet1/4\n \
-          ipv6 port traffic-filter ACL2v6 in''',
-                             state="parsed"))
-        result = self.execute_module(changed=False)
-        compare_list = [{'access_groups': [{'acls': [{'direction': 'out', 'name': 'ACL1v4'}], 'afi': 'ipv4'}], 'name': 'Ethernet1/2'},
-                        {'access_groups': [{'acls': [{'direction': 'in', 'name': 'ACL2v6', 'port': True}], 'afi': 'ipv6'}], 'name': 'Ethernet1/4'}]
-        self.assertEqual(result['parsed'],
-                         compare_list, result['parsed'])
-
-    def test_nxos_acl_interfaces_gathered(self):
-        set_module_args(dict(config=[], state="gathered"))
-        result = self.execute_module(changed=False)
-        compare_list = [{'access_groups': [{'acls': [{'direction': 'out', 'name': 'ACL1v4'}], 'afi': 'ipv4'}], 'name': 'Ethernet1/2'},
-                        {'access_groups': [{'acls': [{'direction': 'in', 'name': 'ACL2v6', 'port': True}], 'afi': 'ipv6'}], 'name': 'Ethernet1/4'}]
-        self.assertEqual(result['gathered'],
-                         compare_list, result['gathered'])
diff --git a/test/units/modules/network/nxos/test_nxos_acls.py b/test/units/modules/network/nxos/test_nxos_acls.py
deleted file mode 100644
index 32cfbdc168..0000000000
--- a/test/units/modules/network/nxos/test_nxos_acls.py
+++ /dev/null
@@ -1,370 +0,0 @@
-#
-# (c) 2019, Ansible by Red Hat, inc
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-#
-
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from ansible.modules.network.nxos import nxos_acls
-from units.compat.mock import patch, MagicMock
-from units.modules.utils import set_module_args
-from .nxos_module import TestNxosModule, load_fixture
-
-
-class TestNxosAclsModule(TestNxosModule):
-
-    module = nxos_acls
-
-    def setUp(self):
-        super(TestNxosAclsModule, self).setUp()
-
-        self.mock_get_config = patch(
-            'ansible.module_utils.network.common.network.Config.get_config')
-        self.get_config = self.mock_get_config.start()
-
-        self.mock_load_config = patch(
-            'ansible.module_utils.network.common.network.Config.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_resource_connection_config = patch(
-            'ansible.module_utils.network.common.cfg.base.get_resource_connection'
-        )
-        self.get_resource_connection_config = self.mock_get_resource_connection_config.start(
-        )
-
-        self.mock_get_resource_connection_facts = patch(
-            'ansible.module_utils.network.common.facts.facts.get_resource_connection'
-        )
-        self.get_resource_connection_facts = self.mock_get_resource_connection_facts.start()
-
-        self.mock_edit_config = patch(
-            'ansible.module_utils.network.nxos.config.acls.acls.Acls.edit_config'
-        )
-        self.edit_config = self.mock_edit_config.start()
-
-        self.mock_execute_show_command = patch(
-            'ansible.module_utils.network.nxos.facts.acls.acls.AclsFacts.get_device_data'
-        )
-        self.execute_show_command = self.mock_execute_show_command.start()
-
-    def tearDown(self):
-        super(TestNxosAclsModule, self).tearDown()
-        self.mock_get_resource_connection_config.stop()
-        self.mock_get_resource_connection_facts.stop()
-        self.mock_edit_config.stop()
-        self.mock_get_config.stop()
-        self.mock_load_config.stop()
-        self.mock_execute_show_command.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        def load_from_file(*args, **kwargs):
-            v4 = '''\nip access-list ACL1v4\n 10 permit ip any any\n 20 deny udp any any'''
-            v6 = '''\nipv6 access-list ACL1v6\n 10 permit sctp any any'''
-            return v4 + v6
-
-        self.execute_show_command.side_effect = load_from_file
-
-    def test_nxos_acls_merged(self):
-        set_module_args(
-            dict(config=[
-                dict(afi="ipv4",
-                     acls=[
-                         dict(name="ACL2v4",
-                              aces=[
-                                  dict(
-                                      grant="deny",
-                                      destination=dict(any=True),
-                                      source=dict(any=True),
-                                      fragments=True,
-                                      sequence=20,
-                                      protocol="tcp",
-                                      protocol_options=dict(
-                                          tcp=dict(ack=True))
-                                  )
-                              ]
-                              )
-                     ]
-                     ),
-                dict(afi="ipv6",
-                     acls=[
-                         dict(name="ACL2v6")
-                     ])
-            ], state="merged"))
-        commands = ['ip access-list ACL2v4',
-                    '20 deny tcp any any ack fragments',
-                    'ipv6 access-list ACL2v6']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_acls_merged_idempotent(self):
-        set_module_args(
-            dict(config=[
-                dict(afi="ipv4",
-                     acls=[
-                         dict(name="ACL1v4",
-                              aces=[
-                                  dict(
-                                      grant="permit",
-                                      destination=dict(any=True),
-                                      source=dict(any=True),
-                                      sequence=10,
-                                      protocol="ip"
-                                  ),
-                                  dict(
-                                      grant="deny",
-                                      destination=dict(any=True),
-                                      source=dict(any=True),
-                                      sequence=20,
-                                      protocol="udp")
-                              ]
-                              ),
-                     ]
-                     ),
-                dict(afi="ipv6",
-                     acls=[
-                         dict(name="ACL1v6",
-                              aces=[
-                                  dict(
-                                      grant="permit",
-                                      destination=dict(any=True),
-                                      source=dict(any=True),
-                                      sequence=10,
-                                      protocol="sctp",
-                                  )
-                              ])
-                     ])
-            ], state="merged"))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_acls_replaced(self):
-        set_module_args(
-            dict(config=[
-                dict(afi="ipv4",
-                     acls=[
-                         dict(name="ACL1v4",
-                              aces=[
-                                  dict(
-                                      grant="permit",
-                                      destination=dict(host="192.0.2.28"),
-                                      source=dict(any=True),
-                                      log=True,
-                                      sequence=50,
-                                      protocol="icmp",
-                                      protocol_options=dict(
-                                          icmp=dict(administratively_prohibited=True))
-                                  )
-                              ]
-                              )
-                     ]
-                     )
-            ], state="replaced"))
-        commands = ['ip access-list ACL1v4', 'no 20 deny udp any any',
-                    'no 10 permit ip any any',
-                    '50 permit icmp any host 192.0.2.28 administratively-prohibited log']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_acls_replaced_idempotent(self):
-        set_module_args(
-            dict(config=[
-                dict(afi="ipv4",
-                     acls=[
-                         dict(name="ACL1v4",
-                              aces=[
-                                  dict(
-                                      grant="permit",
-                                      destination=dict(any=True),
-                                      source=dict(any=True),
-                                      sequence=10,
-                                      protocol="ip",
-                                  ),
-                                  dict(
-                                      grant="deny",
-                                      destination=dict(any=True),
-                                      source=dict(any=True),
-                                      sequence=20,
-                                      protocol="udp")
-                              ]
-                              ),
-                     ]
-                     ),
-                dict(afi="ipv6",
-                     acls=[
-                         dict(name="ACL1v6",
-                              aces=[
-                                  dict(
-                                      grant="permit",
-                                      destination=dict(any=True),
-                                      source=dict(any=True),
-                                      sequence=10,
-                                      protocol="sctp",
-                                  )
-                              ])
-                     ])
-            ], state="replaced"))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_acls_overridden(self):
-        set_module_args(
-            dict(config=[
-                dict(afi="ipv4",
-                     acls=[
-                         dict(name="ACL2v4",
-                              aces=[
-                                   dict(
-                                       grant="permit",
-                                       destination=dict(host="192.0.2.28"),
-                                       source=dict(any=True),
-                                       log=True,
-                                       sequence=50,
-                                       protocol="icmp",
-                                       protocol_options=dict(
-                                           icmp=dict(administratively_prohibited=True))
-                                   ),
-                                  dict(
-                                       remark="Overridden ACL"
-                                   )
-                              ]
-                              )
-                     ]
-                     )
-            ], state="overridden"))
-        commands = ['no ip access-list ACL1v4', 'no ipv6 access-list ACL1v6', 'ip access-list ACL2v4',
-                    '50 permit icmp any host 192.0.2.28 administratively-prohibited log', 'remark Overridden ACL']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_acls_overridden_idempotent(self):
-        set_module_args(
-            dict(config=[
-                dict(afi="ipv4",
-                     acls=[
-                         dict(name="ACL1v4",
-                              aces=[
-                                  dict(
-                                      grant="permit",
-                                      destination=dict(any=True),
-                                      source=dict(any=True),
-                                      sequence=10,
-                                      protocol="ip",
-                                  ),
-                                  dict(
-                                      grant="deny",
-                                      destination=dict(any=True),
-                                      source=dict(any=True),
-                                      sequence=20,
-                                      protocol="udp")
-                              ]
-                              ),
-                     ]
-                     ),
-                dict(afi="ipv6",
-                     acls=[
-                         dict(name="ACL1v6",
-                              aces=[
-                                  dict(
-                                      grant="permit",
-                                      destination=dict(any=True),
-                                      source=dict(any=True),
-                                      sequence=10,
-                                      protocol="sctp",
-                                  )
-                              ])
-                     ])
-            ], state="overridden"))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_acls_deletedafi(self):
-        set_module_args(
-            dict(config=[dict(afi="ipv4")], state="deleted"))
-        commands = ['no ip access-list ACL1v4']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_acls_deletedace(self):
-        set_module_args(
-            dict(config=[dict(afi="ipv6",
-                              acls=[
-                                  dict(name="ACL1v6",
-                                       aces=[
-                                           dict(
-                                               grant="permit",
-                                               destination=dict(any=True),
-                                               source=dict(any=True),
-                                               sequence=10,
-                                               protocol="sctp",
-                                           )
-                                       ])
-                              ])], state="deleted"))
-        commands = ['ipv6 access-list ACL1v6', 'no 10 permit sctp any any']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_acls_deletedall(self):
-        set_module_args(dict(config=[], state='deleted'))
-        commands = ['no ipv6 access-list ACL1v6', 'no ip access-list ACL1v4']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_acls_rendered(self):
-        set_module_args(
-            dict(config=[
-                dict(afi="ipv4",
-                     acls=[
-                         dict(name="ACL1v4",
-                              aces=[
-                                   dict(
-                                       grant="permit",
-                                       destination=dict(any=True),
-                                       source=dict(any=True),
-                                       sequence=10,
-                                       protocol="ip",
-                                   ),
-                                  dict(
-                                       grant="deny",
-                                       destination=dict(any=True),
-                                       source=dict(any=True),
-                                       sequence=20,
-                                       protocol="udp")
-                              ]
-                              ),
-                     ]
-                     ),
-                dict(afi="ipv6",
-                     acls=[
-                         dict(name="ACL1v6",
-                              aces=[
-                                   dict(
-                                       grant="permit",
-                                       destination=dict(any=True),
-                                       source=dict(any=True),
-                                       sequence=10,
-                                       protocol="sctp",
-                                   )
-                              ])
-                     ])
-            ], state="rendered"))
-        commands = ['ip access-list ACL1v4', '10 permit ip any any', '20 deny udp any any',
-                    'ipv6 access-list ACL1v6', '10 permit sctp any any']
-        result = self.execute_module(changed=False)
-        self.assertEqual(sorted(result['rendered']), sorted(
-            commands), result['rendered'])
-
-    def test_nxos_acls_parsed(self):
-        set_module_args(dict(running_config='''\nip access-list ACL1v4\n 10 permit ip any any\n 20 deny udp any any dscp AF23 precedence critical''',
-                             state="parsed"))
-        result = self.execute_module(changed=False)
-        compare_list = [{'afi': 'ipv4', 'acls': [{'name': 'ACL1v4',
-                                                  'aces': [{'grant': 'permit', 'sequence': 10, 'protocol': 'ip', 'source': {'any': True},
-                                                            'destination': {'any': True}}, {'grant': 'deny', 'sequence': 20,
-                                                                                            'protocol': 'udp', 'source': {'any': True},
-                                                                                            'destination': {'any': True},
-                                                                                            'dscp': 'AF23', 'precedence': 'critical'}]}]}]
-        self.assertEqual(result['parsed'], compare_list, result['parsed'])
-
-    def test_nxos_acls_gathered(self):
-        set_module_args(dict(config=[], state="gathered"))
-        result = self.execute_module(changed=False)
-        compare_list = [{'acls': [{'aces': [{'destination': {'any': True}, 'sequence': 10, 'protocol': 'sctp', 'source': {'any': True}, 'grant': 'permit'}],
-                                   'name': 'ACL1v6'}], 'afi': 'ipv6'}, {'acls': [{'aces': [{'destination': {'any': True}, 'sequence': 10, 'protocol': 'ip',
-                                                                                            'source': {'any': True}, 'grant': 'permit'},
-                                                                                           {'destination': {'any': True}, 'sequence': 20, 'protocol': 'udp',
-                                                                                            'source': {'any': True}, 'grant': 'deny'}], 'name': 'ACL1v4'}],
-                                                                        'afi': 'ipv4'}]
-        self.assertEqual(result['gathered'],
-                         compare_list, result['gathered'])
diff --git a/test/units/modules/network/nxos/test_nxos_banner.py b/test/units/modules/network/nxos/test_nxos_banner.py
deleted file mode 100644
index 326f9a3088..0000000000
--- a/test/units/modules/network/nxos/test_nxos_banner.py
+++ /dev/null
@@ -1,83 +0,0 @@
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_banner
-from .nxos_module import TestNxosModule, set_module_args
-
-
-class TestNxosBannerModule(TestNxosModule):
-
-    module = nxos_banner
-
-    def setUp(self):
-        super(TestNxosBannerModule, self).setUp()
-        self.mock_run_commands = patch('ansible.modules.network.nxos.nxos_banner.run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_banner.load_config')
-        self.load_config = self.mock_load_config.start()
-
-    def tearDown(self):
-        super(TestNxosBannerModule, self).tearDown()
-        self.mock_run_commands.stop()
-        self.mock_load_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.load_config.return_value = dict(diff=None, session='session')
-
-    def test_nxos_banner_exec_create(self):
-        set_module_args(dict(banner='exec', text='test\nbanner\nstring'))
-        commands = ['banner exec @\ntest\nbanner\nstring\n@']
-        self.run_commands.return_value = commands
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_banner_exec_remove(self):
-        set_module_args(dict(banner='exec', state='absent'))
-        commands = ['no banner exec']
-        self.run_commands.return_value = commands
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_banner_exec_fail_create(self):
-        set_module_args(dict(banner='exec', text='test\nbanner\nstring'))
-        commands = ['banner exec @\ntest\nbanner\nstring\n@']
-        err_rsp = ['Invalid command']
-        self.run_commands.return_value = err_rsp
-        result = self.execute_module(failed=True, changed=True)
-        self.assertEqual(result['msg'], 'banner: exec may not be supported on this platform.  Possible values are : exec | motd')
-
-    def test_nxos_banner_exec_fail_remove(self):
-        set_module_args(dict(banner='exec', state='absent'))
-        commands = ['no banner exec']
-        err_rsp = ['Invalid command']
-        self.run_commands.return_value = err_rsp
-        result = self.execute_module(failed=True, changed=True)
-        self.assertEqual(result['msg'], 'banner: exec may not be supported on this platform.  Possible values are : exec | motd')
-
-    def test_nxos_banner_motd_create(self):
-        set_module_args(dict(banner='motd', text='test\nbanner\nstring'))
-        commands = ['banner motd @\ntest\nbanner\nstring\n@']
-        self.run_commands.return_value = commands
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_banner_motd_remove(self):
-        set_module_args(dict(banner='motd', state='absent'))
-        commands = ['no banner motd']
-        self.run_commands.return_value = commands
-        self.execute_module(changed=True, commands=commands)
diff --git a/test/units/modules/network/nxos/test_nxos_bfd_global.py b/test/units/modules/network/nxos/test_nxos_bfd_global.py
deleted file mode 100644
index 67891d0fc6..0000000000
--- a/test/units/modules/network/nxos/test_nxos_bfd_global.py
+++ /dev/null
@@ -1,284 +0,0 @@
-# (c) 2019 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_bfd_global
-from ansible.module_utils.network.nxos.nxos import NxosCmdRef
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-# TBD: These imports / import checks are only needed as a workaround for
-# shippable, which fails this test due to import yaml & import ordereddict.
-import pytest
-from ansible.module_utils.network.nxos.nxos import nxosCmdRef_import_check
-msg = nxosCmdRef_import_check()
-@pytest.mark.skipif(len(msg), reason=msg)
-class TestNxosBfdGlobalModule(TestNxosModule):
-
-    module = nxos_bfd_global
-
-    def setUp(self):
-        super(TestNxosBfdGlobalModule, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_bfd_global.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_execute_show_command = patch('ansible.module_utils.network.nxos.nxos.NxosCmdRef.execute_show_command')
-        self.execute_show_command = self.mock_execute_show_command.start()
-
-        self.mock_get_platform_shortname = patch('ansible.module_utils.network.nxos.nxos.NxosCmdRef.get_platform_shortname')
-        self.get_platform_shortname = self.mock_get_platform_shortname.start()
-
-    def tearDown(self):
-        super(TestNxosBfdGlobalModule, self).tearDown()
-        self.mock_load_config.stop()
-        self.execute_show_command.stop()
-        self.get_platform_shortname.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.load_config.return_value = None
-
-    def test_bfd_defaults_n9k(self):
-        # feature bfd is enabled, no non-defaults are set.
-        self.execute_show_command.return_value = "feature bfd"
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args(dict(
-            echo_interface='deleted',
-            echo_rx_interval=50,
-            interval={'tx': 50, 'min_rx': 50, 'multiplier': 3},
-            slow_timer=2000,
-            startup_timer=5,
-            ipv4_echo_rx_interval=50,
-            ipv4_interval={'tx': 50, 'min_rx': 50, 'multiplier': 3},
-            ipv4_slow_timer=2000,
-            ipv6_echo_rx_interval=50,
-            ipv6_interval={'tx': 50, 'min_rx': 50, 'multiplier': 3},
-            ipv6_slow_timer=2000
-        ))
-        self.execute_module(changed=False)
-
-    def test_bfd_non_defaults_n9k(self):
-        # feature bfd is enabled, apply all non-default values.
-        # This testcase also tests reordering of echo_interface to make sure
-        # it gets applied last.
-        self.execute_show_command.return_value = "feature bfd"
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args(dict(
-            echo_interface='loopback1',
-            echo_rx_interval=51,
-            interval={'tx': 51, 'min_rx': 51, 'multiplier': 4},
-            slow_timer=2001,
-            startup_timer=6,
-            ipv4_echo_rx_interval=51,
-            ipv4_interval={'tx': 51, 'min_rx': 51, 'multiplier': 4},
-            ipv4_slow_timer=2001,
-            ipv6_echo_rx_interval=51,
-            ipv6_interval={'tx': 51, 'min_rx': 51, 'multiplier': 4},
-            ipv6_slow_timer=2001
-        ))
-        self.execute_module(changed=True, commands=[
-            'bfd interval 51 min_rx 51 multiplier 4',
-            'bfd ipv4 echo-rx-interval 51',
-            'bfd ipv4 interval 51 min_rx 51 multiplier 4',
-            'bfd ipv4 slow-timer 2001',
-            'bfd ipv6 echo-rx-interval 51',
-            'bfd ipv6 interval 51 min_rx 51 multiplier 4',
-            'bfd ipv6 slow-timer 2001',
-            'bfd slow-timer 2001',
-            'bfd startup-timer 6',
-            'bfd echo-interface loopback1',
-            'bfd echo-rx-interval 51'
-        ])
-
-    def test_bfd_defaults_n3k(self):
-        # feature bfd is enabled, no non-defaults are set.
-        self.execute_show_command.return_value = "feature bfd"
-        self.get_platform_shortname.return_value = 'N3K'
-        set_module_args(dict(
-            echo_interface='deleted',
-            echo_rx_interval=250,
-            interval={'tx': 250, 'min_rx': 250, 'multiplier': 3},
-            slow_timer=2000,
-            startup_timer=5,
-            ipv4_echo_rx_interval=250,
-            ipv4_interval={'tx': 250, 'min_rx': 250, 'multiplier': 3},
-            ipv4_slow_timer=2000,
-            ipv6_echo_rx_interval=250,
-            ipv6_interval={'tx': 250, 'min_rx': 250, 'multiplier': 3},
-            ipv6_slow_timer=2000
-        ))
-        self.execute_module(changed=False)
-
-    def test_bfd_defaults_n35(self):
-        # feature bfd is enabled, no non-defaults are set.
-        self.execute_show_command.return_value = "feature bfd"
-        self.get_platform_shortname.return_value = 'N35'
-        set_module_args(dict(
-            echo_interface='deleted',
-            echo_rx_interval=50,
-            interval={'tx': 50, 'min_rx': 50, 'multiplier': 3},
-            slow_timer=2000,
-            startup_timer=5,
-            ipv4_echo_rx_interval=50,
-            ipv4_interval={'tx': 50, 'min_rx': 50, 'multiplier': 3},
-            ipv4_slow_timer=2000,
-        ))
-        self.execute_module(changed=False)
-
-    def test_bfd_defaults_n6k(self):
-        # feature bfd is enabled, no non-defaults are set.
-        self.execute_show_command.return_value = "feature bfd"
-        self.get_platform_shortname.return_value = 'N6K'
-        set_module_args(dict(
-            echo_interface='deleted',
-            interval={'tx': 50, 'min_rx': 50, 'multiplier': 3},
-            slow_timer=2000,
-            fabricpath_interval={'tx': 50, 'min_rx': 50, 'multiplier': 3},
-            fabricpath_slow_timer=2000,
-            fabricpath_vlan=1
-        ))
-        self.execute_module(changed=False)
-
-    def test_bfd_defaults_n7k(self):
-        # feature bfd is enabled, no non-defaults are set.
-        self.execute_show_command.return_value = "feature bfd"
-        self.get_platform_shortname.return_value = 'N7K'
-        set_module_args(dict(
-            echo_interface='deleted',
-            echo_rx_interval=50,
-            interval={'tx': 50, 'min_rx': 50, 'multiplier': 3},
-            slow_timer=2000,
-            ipv4_echo_rx_interval=50,
-            ipv4_interval={'tx': 50, 'min_rx': 50, 'multiplier': 3},
-            ipv4_slow_timer=2000,
-            ipv6_echo_rx_interval=50,
-            ipv6_interval={'tx': 50, 'min_rx': 50, 'multiplier': 3},
-            ipv6_slow_timer=2000,
-            fabricpath_interval={'tx': 50, 'min_rx': 50, 'multiplier': 3},
-            fabricpath_slow_timer=2000,
-            fabricpath_vlan=1
-        ))
-        self.execute_module(changed=False)
-
-    def test_bfd_existing_n9k(self):
-        module_name = self.module.__name__.rsplit('.', 1)[1]
-        self.execute_show_command.return_value = load_fixture(module_name, 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args(dict(
-            echo_interface='deleted',
-            echo_rx_interval=51,
-            interval={'tx': 51, 'min_rx': 51, 'multiplier': 3},
-            slow_timer=2000,
-            startup_timer=5,
-            ipv4_echo_rx_interval=50,
-            ipv4_interval={'tx': 51, 'min_rx': 51, 'multiplier': 3},
-            ipv4_slow_timer=2000,
-            ipv6_echo_rx_interval=50,
-            ipv6_interval={'tx': 51, 'min_rx': 51, 'multiplier': 3},
-            ipv6_slow_timer=2000
-        ))
-        self.execute_module(changed=True, commands=[
-            'no bfd echo-interface loopback2',
-            'bfd echo-rx-interval 51',
-            'bfd interval 51 min_rx 51 multiplier 3',
-            'bfd slow-timer 2000',
-            'bfd startup-timer 5',
-            'bfd ipv4 echo-rx-interval 50',
-            'bfd ipv4 interval 51 min_rx 51 multiplier 3',
-            'bfd ipv4 slow-timer 2000',
-            'bfd ipv6 echo-rx-interval 50',
-            'bfd ipv6 interval 51 min_rx 51 multiplier 3',
-            'bfd ipv6 slow-timer 2000',
-        ])
-
-    def test_bfd_idempotence_n9k(self):
-        module_name = self.module.__name__.rsplit('.', 1)[1]
-        self.execute_show_command.return_value = load_fixture(module_name, 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args(dict(
-            echo_interface='loopback2',
-            echo_rx_interval=56,
-            interval={'tx': 51, 'min_rx': 52, 'multiplier': 4},
-            slow_timer=2001,
-            startup_timer=6,
-            ipv4_echo_rx_interval=54,
-            ipv4_interval={'tx': 54, 'min_rx': 54, 'multiplier': 4},
-            ipv4_slow_timer=2004,
-            ipv6_echo_rx_interval=56,
-            ipv6_interval={'tx': 56, 'min_rx': 56, 'multiplier': 6},
-            ipv6_slow_timer=2006
-        ))
-        self.execute_module(changed=False)
-
-    def test_bfd_existing_n7k(self):
-        module_name = self.module.__name__.rsplit('.', 1)[1]
-        self.execute_show_command.return_value = load_fixture(module_name, 'N7K.cfg')
-        self.get_platform_shortname.return_value = 'N7K'
-        set_module_args(dict(
-            echo_interface='deleted',
-            echo_rx_interval=51,
-            interval={'tx': 51, 'min_rx': 51, 'multiplier': 3},
-            slow_timer=2002,
-            ipv4_echo_rx_interval=51,
-            ipv4_interval={'tx': 51, 'min_rx': 51, 'multiplier': 3},
-            ipv4_slow_timer=2002,
-            ipv6_echo_rx_interval=51,
-            ipv6_interval={'tx': 51, 'min_rx': 51, 'multiplier': 3},
-            ipv6_slow_timer=2002,
-            fabricpath_interval={'tx': 51, 'min_rx': 51, 'multiplier': 3},
-            fabricpath_slow_timer=2003,
-            fabricpath_vlan=3,
-        ))
-        self.execute_module(changed=True, commands=[
-            'no bfd echo-interface loopback2',
-            'bfd echo-rx-interval 51',
-            'bfd interval 51 min_rx 51 multiplier 3',
-            'bfd slow-timer 2002',
-            'bfd ipv4 echo-rx-interval 51',
-            'bfd ipv4 interval 51 min_rx 51 multiplier 3',
-            'bfd ipv4 slow-timer 2002',
-            'bfd ipv6 echo-rx-interval 51',
-            'bfd ipv6 interval 51 min_rx 51 multiplier 3',
-            'bfd ipv6 slow-timer 2002',
-            'bfd fabricpath interval 51 min_rx 51 multiplier 3',
-            'bfd fabricpath slow-timer 2003',
-            'bfd fabricpath vlan 3',
-        ])
-
-    def test_bfd_idempotence_n7k(self):
-        module_name = self.module.__name__.rsplit('.', 1)[1]
-        self.execute_show_command.return_value = load_fixture(module_name, 'N7K.cfg')
-        self.get_platform_shortname.return_value = 'N7K'
-        set_module_args(dict(
-            echo_interface='loopback2',
-            echo_rx_interval=56,
-            interval={'tx': 51, 'min_rx': 52, 'multiplier': 4},
-            slow_timer=2001,
-            ipv4_echo_rx_interval=54,
-            ipv4_interval={'tx': 54, 'min_rx': 54, 'multiplier': 4},
-            ipv4_slow_timer=2004,
-            ipv6_echo_rx_interval=56,
-            ipv6_interval={'tx': 56, 'min_rx': 56, 'multiplier': 6},
-            ipv6_slow_timer=2006,
-            fabricpath_interval={'tx': 58, 'min_rx': 58, 'multiplier': 8},
-            fabricpath_slow_timer=2008,
-            fabricpath_vlan=2,
-        ))
-        self.execute_module(changed=False)
diff --git a/test/units/modules/network/nxos/test_nxos_bfd_interfaces.py b/test/units/modules/network/nxos/test_nxos_bfd_interfaces.py
deleted file mode 100644
index 83630f2937..0000000000
--- a/test/units/modules/network/nxos/test_nxos_bfd_interfaces.py
+++ /dev/null
@@ -1,303 +0,0 @@
-# (c) 2019 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from textwrap import dedent
-from units.compat.mock import patch
-from units.modules.utils import AnsibleFailJson
-from ansible.modules.network.nxos import nxos_bfd_interfaces
-from ansible.module_utils.network.nxos.config.bfd_interfaces.bfd_interfaces import Bfd_interfaces
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-ignore_provider_arg = True
-
-
-class TestNxosBfdInterfacesModule(TestNxosModule):
-
-    module = nxos_bfd_interfaces
-
-    def setUp(self):
-        super(TestNxosBfdInterfacesModule, self).setUp()
-
-        self.mock_FACT_LEGACY_SUBSETS = patch('ansible.module_utils.network.nxos.facts.facts.FACT_LEGACY_SUBSETS')
-        self.FACT_LEGACY_SUBSETS = self.mock_FACT_LEGACY_SUBSETS.start()
-
-        self.mock_get_resource_connection_config = patch('ansible.module_utils.network.common.cfg.base.get_resource_connection')
-        self.get_resource_connection_config = self.mock_get_resource_connection_config.start()
-
-        self.mock_get_resource_connection_facts = patch('ansible.module_utils.network.common.facts.facts.get_resource_connection')
-        self.get_resource_connection_facts = self.mock_get_resource_connection_facts.start()
-
-        self.mock_edit_config = patch('ansible.module_utils.network.nxos.config.bfd_interfaces.bfd_interfaces.Bfd_interfaces.edit_config')
-        self.edit_config = self.mock_edit_config.start()
-
-    def tearDown(self):
-        super(TestNxosBfdInterfacesModule, self).tearDown()
-        self.mock_FACT_LEGACY_SUBSETS.stop()
-        self.mock_get_resource_connection_config.stop()
-        self.mock_get_resource_connection_facts.stop()
-        self.mock_edit_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.mock_FACT_LEGACY_SUBSETS.return_value = dict()
-        self.get_resource_connection_config.return_value = None
-        self.edit_config.return_value = None
-
-    # ---------------------------
-    # Bfd_interfaces Test Cases
-    # ---------------------------
-
-    # 'state' logic behaviors
-    #
-    # - 'merged'    : Update existing device state with any differences in the play.
-    # - 'deleted'   : Reset existing device state to default values. Ignores any
-    #                 play attrs other than 'name'. Scope is limited to interfaces
-    #                 in the play.
-    # - 'overridden': The play is the source of truth. Similar to replaced but the
-    #                 scope includes all interfaces; ie. it will also reset state
-    #                 on interfaces not found in the play.
-    # - 'replaced'  : Scope is limited to the interfaces in the play.
-
-    SHOW_CMD = "show running-config | section '^interface|^feature bfd'"
-
-    def test_1(self):
-        # Setup: No BFD configs shown on device interfaces
-        # NOTE: The bfd 'enable' state is the default and does not nvgen.
-        existing = dedent('''\
-          feature bfd
-          interface Ethernet1/1
-          interface Ethernet1/2
-          interface Ethernet1/3
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(
-                name='Ethernet1/1',
-                bfd='disable',
-                echo='disable'),
-            dict(
-                name='Ethernet1/2',
-                bfd='disable'),
-        ])
-        # Expected result commands for each 'state'
-        merged = ['interface Ethernet1/1', 'no bfd', 'no bfd echo',
-                  'interface Ethernet1/2', 'no bfd']
-        deleted = []
-        overridden = merged
-        replaced = merged
-
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=merged)
-
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False, commands=deleted)
-
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-
-    def test_2(self):
-        # Change existing BFD configs
-        existing = dedent('''\
-          feature bfd
-          interface Ethernet1/1
-            no bfd
-          interface Ethernet1/2
-            no bfd echo
-          interface Ethernet1/3
-            no bfd
-            no bfd echo
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(
-                name='Ethernet1/1',
-                bfd='enable',
-                echo='disable'),
-            dict(
-                name='Ethernet1/2'),
-            # Eth1/3 not present! Thus overridden should set Eth1/3 to defaults;
-            # replaced should ignore Eth1/3.
-        ])
-        # Expected result commands for each 'state'
-        merged = ['interface Ethernet1/1', 'bfd', 'no bfd echo']
-        deleted = ['interface Ethernet1/1', 'bfd',
-                   'interface Ethernet1/2', 'bfd echo']
-        overridden = ['interface Ethernet1/3', 'bfd', 'bfd echo',
-                      'interface Ethernet1/1', 'bfd', 'no bfd echo',
-                      'interface Ethernet1/2', 'bfd echo']
-        replaced = ['interface Ethernet1/1', 'bfd', 'no bfd echo',
-                    'interface Ethernet1/2', 'bfd echo']
-
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=merged)
-
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-
-    def test_3(self):
-        # Device has bfd configs, playbook has no values
-        existing = dedent('''\
-          feature bfd
-          interface Ethernet1/1
-            no bfd
-          interface Ethernet1/2
-            no bfd echo
-          interface Ethernet1/3
-            no bfd
-            no bfd echo
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(name='Ethernet1/1'),
-        ])
-        # Expected result commands for each 'state'
-        merged = []
-        deleted = ['interface Ethernet1/1', 'bfd']
-        overridden = ['interface Ethernet1/1', 'bfd',
-                      'interface Ethernet1/2', 'bfd echo',
-                      'interface Ethernet1/3', 'bfd', 'bfd echo']
-        replaced = ['interface Ethernet1/1', 'bfd']
-
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False, commands=merged)
-
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-
-    def test_4(self):
-        # Test with interface that doesn't exist yet
-        existing = dedent('''\
-          feature bfd
-          interface Ethernet1/1
-            no bfd
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(
-                name='Ethernet1/1.42',
-                bfd='enable',
-                echo='disable'),
-        ])
-        # Expected result commands for each 'state'
-        merged = ['interface Ethernet1/1.42', 'bfd', 'no bfd echo']
-        deleted = []
-        overridden = ['interface Ethernet1/1.42', 'bfd', 'no bfd echo',
-                      'interface Ethernet1/1', 'bfd']
-        replaced = ['interface Ethernet1/1.42', 'bfd', 'no bfd echo']
-
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=merged)
-
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False, commands=deleted)
-
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-
-    def test_5(self):
-        # idempotence
-        existing = dedent('''\
-          feature bfd
-          interface Ethernet1/1
-            no bfd
-            no bfd echo
-          interface Ethernet1/2
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(
-                name='Ethernet1/1',
-                bfd='disable',
-                echo='disable'),
-            dict(
-                name='Ethernet1/2',
-                bfd='enable',
-                echo='enable'),
-        ])
-        # Expected result commands for each 'state'
-        merged = []
-        deleted = ['interface Ethernet1/1', 'bfd', 'bfd echo']
-        overridden = []
-        replaced = []
-
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False, commands=merged)
-
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False, commands=overridden)
-
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False, commands=replaced)
-
-
-def build_args(data, type, state=None, check_mode=None):
-    if state is None:
-        state = 'merged'
-    if check_mode is None:
-        check_mode = False
-    args = {
-        'state': state,
-        '_ansible_check_mode': check_mode,
-        'config': {
-            type: data
-        }
-    }
-    return args
diff --git a/test/units/modules/network/nxos/test_nxos_bgp.py b/test/units/modules/network/nxos/test_nxos_bgp.py
deleted file mode 100644
index cc3ae8c890..0000000000
--- a/test/units/modules/network/nxos/test_nxos_bgp.py
+++ /dev/null
@@ -1,134 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_bgp
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosBgpModule(TestNxosModule):
-
-    module = nxos_bgp
-
-    def setUp(self):
-        super(TestNxosBgpModule, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_bgp.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_bgp.get_config')
-        self.get_config = self.mock_get_config.start()
-
-    def tearDown(self):
-        super(TestNxosBgpModule, self).tearDown()
-        self.mock_load_config.stop()
-        self.mock_get_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.get_config.return_value = load_fixture('nxos_bgp', 'config.cfg')
-        self.load_config.return_value = []
-
-    def test_nxos_bgp(self):
-        set_module_args(dict(asn=65535, router_id='192.0.2.1'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['router bgp 65535', 'router-id 192.0.2.1'])
-
-    def test_nxos_bgp_change_nothing(self):
-        set_module_args(dict(asn=65535, router_id='192.168.1.1'))
-        self.execute_module(changed=False)
-
-    def test_nxos_bgp_wrong_asn(self):
-        set_module_args(dict(asn=10, router_id='192.168.1.1'))
-        result = self.execute_module(failed=True)
-        self.assertEqual(result['msg'], 'Another BGP ASN already exists.')
-
-    def test_nxos_bgp_remove(self):
-        set_module_args(dict(asn=65535, state='absent'))
-        self.execute_module(changed=True, commands=['no router bgp 65535'])
-
-    def test_nxos_bgp_remove_vrf(self):
-        set_module_args(dict(asn=65535, vrf='test2', state='absent'))
-        self.execute_module(changed=True, commands=['router bgp 65535', 'no vrf test2'])
-
-    def test_nxos_bgp_remove_nonexistant_vrf(self):
-        set_module_args(dict(asn=65535, vrf='foo', state='absent'))
-        self.execute_module(changed=False)
-
-    def test_nxos_bgp_remove_wrong_asn(self):
-        set_module_args(dict(asn=10, state='absent'))
-        self.execute_module(changed=False)
-
-    def test_nxos_bgp_vrf(self):
-        set_module_args(dict(asn=65535, vrf='test', router_id='192.0.2.1'))
-        result = self.execute_module(changed=True, commands=['router bgp 65535', 'vrf test', 'router-id 192.0.2.1'])
-        self.assertEqual(result['warnings'], ["VRF test doesn't exist."])
-
-    def test_nxos_bgp_global_param(self):
-        set_module_args(dict(asn=65535, shutdown=True))
-        self.execute_module(changed=True, commands=['router bgp 65535', 'shutdown'])
-
-    def test_nxos_bgp_global_param_outside_default(self):
-        set_module_args(dict(asn=65535, vrf='test', shutdown=True))
-        result = self.execute_module(failed=True)
-        self.assertEqual(result['msg'], 'Global params can be modified only under "default" VRF.')
-
-    def test_nxos_bgp_default_value(self):
-        set_module_args(dict(asn=65535, graceful_restart_timers_restart='default'))
-        self.execute_module(
-            changed=True,
-            commands=['router bgp 65535', 'graceful-restart restart-time 120']
-        )
-
-
-class TestNxosBgp32BitsAS(TestNxosModule):
-
-    module = nxos_bgp
-
-    def setUp(self):
-        super(TestNxosBgp32BitsAS, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_bgp.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_bgp.get_config')
-        self.get_config = self.mock_get_config.start()
-
-    def tearDown(self):
-        super(TestNxosBgp32BitsAS, self).tearDown()
-        self.mock_load_config.stop()
-        self.mock_get_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.get_config.return_value = load_fixture('nxos_bgp', 'config_32_bits_as.cfg')
-        self.load_config.return_value = []
-
-    def test_nxos_bgp_change_nothing(self):
-        set_module_args(dict(asn='65535.65535', router_id='192.168.1.1'))
-        self.execute_module(changed=False)
-
-    def test_nxos_bgp_wrong_asn(self):
-        set_module_args(dict(asn='65535.10', router_id='192.168.1.1'))
-        result = self.execute_module(failed=True)
-        self.assertEqual(result['msg'], 'Another BGP ASN already exists.')
-
-    def test_nxos_bgp_remove(self):
-        set_module_args(dict(asn='65535.65535', state='absent'))
-        self.execute_module(changed=True, commands=['no router bgp 65535.65535'])
diff --git a/test/units/modules/network/nxos/test_nxos_bgp_af.py b/test/units/modules/network/nxos/test_nxos_bgp_af.py
deleted file mode 100644
index 452caef80f..0000000000
--- a/test/units/modules/network/nxos/test_nxos_bgp_af.py
+++ /dev/null
@@ -1,103 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_bgp_af
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosBgpAfModule(TestNxosModule):
-
-    module = nxos_bgp_af
-
-    def setUp(self):
-        super(TestNxosBgpAfModule, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_bgp_af.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_bgp_af.get_config')
-        self.get_config = self.mock_get_config.start()
-
-    def tearDown(self):
-        super(TestNxosBgpAfModule, self).tearDown()
-        self.mock_load_config.stop()
-        self.mock_get_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.get_config.return_value = load_fixture('nxos_bgp', 'config.cfg')
-        self.load_config.return_value = None
-
-    def test_nxos_bgp_af(self):
-        set_module_args(dict(asn=65535, afi='ipv4', safi='unicast'))
-        self.execute_module(
-            changed=True, sort=False,
-            commands=['router bgp 65535', 'address-family ipv4 unicast']
-        )
-
-    def test_nxos_bgp_af_vrf(self):
-        set_module_args(dict(asn=65535, vrf='test', afi='ipv4', safi='unicast'))
-        self.execute_module(
-            changed=True, sort=False,
-            commands=['router bgp 65535', 'vrf test', 'address-family ipv4 unicast']
-        )
-
-    def test_nxos_bgp_af_vrf_exists(self):
-        set_module_args(dict(asn=65535, vrf='test2', afi='ipv4', safi='unicast'))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_bgp_af_dampening_routemap(self):
-        set_module_args(dict(asn=65535, afi='ipv4', safi='unicast',
-                             dampening_routemap='route-map-a'))
-        self.execute_module(
-            changed=True,
-            commands=['router bgp 65535', 'address-family ipv4 unicast',
-                      'dampening route-map route-map-a']
-        )
-
-    def test_nxos_bgp_af_dampening_manual(self):
-        set_module_args(dict(asn=65535, afi='ipv4', safi='unicast',
-                             dampening_half_time=5, dampening_suppress_time=2000,
-                             dampening_reuse_time=1900, dampening_max_suppress_time=10))
-        self.execute_module(
-            changed=True,
-            commands=['router bgp 65535', 'address-family ipv4 unicast',
-                      'dampening 5 1900 2000 10']
-        )
-
-    def test_nxos_bgp_af_dampening_mix(self):
-        set_module_args(dict(asn=65535, afi='ipv4', safi='unicast',
-                             dampening_routemap='route-map-a',
-                             dampening_half_time=5, dampening_suppress_time=2000,
-                             dampening_reuse_time=1900, dampening_max_suppress_time=10))
-        result = self.execute_module(failed=True)
-        self.assertEqual(result['msg'], 'parameters are mutually exclusive: dampening_routemap|dampening_half_time, '
-                                        'dampening_routemap|dampening_suppress_time, dampening_routemap|dampening_reuse_time, '
-                                        'dampening_routemap|dampening_max_suppress_time')
-
-    def test_nxos_bgp_af_client(self):
-        set_module_args(dict(asn=65535, afi='ipv4', safi='unicast',
-                             client_to_client=False))
-        self.execute_module(
-            changed=True,
-            commands=['router bgp 65535', 'address-family ipv4 unicast',
-                      'no client-to-client reflection']
-        )
diff --git a/test/units/modules/network/nxos/test_nxos_bgp_neighbor.py b/test/units/modules/network/nxos/test_nxos_bgp_neighbor.py
deleted file mode 100644
index 564ef301e4..0000000000
--- a/test/units/modules/network/nxos/test_nxos_bgp_neighbor.py
+++ /dev/null
@@ -1,81 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_bgp_neighbor
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosBgpNeighborModule(TestNxosModule):
-
-    module = nxos_bgp_neighbor
-
-    def setUp(self):
-        super(TestNxosBgpNeighborModule, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_bgp_neighbor.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_bgp_neighbor.get_config')
-        self.get_config = self.mock_get_config.start()
-
-    def tearDown(self):
-        super(TestNxosBgpNeighborModule, self).tearDown()
-        self.mock_load_config.stop()
-        self.mock_get_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.get_config.return_value = load_fixture('nxos_bgp', 'config.cfg')
-        self.load_config.return_value = []
-
-    def test_nxos_bgp_neighbor_bfd_1(self):
-        # None (disable) -> enable
-        set_module_args(dict(asn=65535, neighbor='1.1.1.1', bfd='enable'))
-        self.execute_module(changed=True, commands=['router bgp 65535', 'neighbor 1.1.1.1', 'bfd'])
-
-        # enable -> enable (idempotence)
-        set_module_args(dict(asn=65535, neighbor='1.1.1.2', bfd='enable'))
-        self.execute_module(changed=False)
-
-    def test_nxos_bgp_neighbor_bfd_2(self):
-        # enable -> None (disable)
-        set_module_args(dict(asn=65535, neighbor='1.1.1.2', bfd='disable'))
-        self.execute_module(changed=True, commands=['router bgp 65535', 'neighbor 1.1.1.2', 'no bfd'])
-
-        # None (disable) -> disable (idempotence)
-        set_module_args(dict(asn=65535, neighbor='1.1.1.1', bfd='disable'))
-        self.execute_module(changed=False)
-
-    def test_nxos_bgp_neighbor(self):
-        set_module_args(dict(asn=65535, neighbor='192.0.2.3', description='some words'))
-        self.execute_module(changed=True, commands=['router bgp 65535', 'neighbor 192.0.2.3', 'description some words'])
-
-    def test_nxos_bgp_neighbor_absent(self):
-        set_module_args(dict(asn=65535, neighbor='1.1.1.1', state='absent'))
-        self.execute_module(changed=True, commands=['router bgp 65535', 'no neighbor 1.1.1.1'])
-
-    def test_nxos_bgp_neighbor_remove_private_as(self):
-        set_module_args(dict(asn=65535, neighbor='3.3.3.4', remove_private_as='all'))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_bgp_neighbor_remove_private_as_changed(self):
-        set_module_args(dict(asn=65535, neighbor='3.3.3.4', remove_private_as='replace-as'))
-        self.execute_module(changed=True, commands=['router bgp 65535', 'neighbor 3.3.3.4', 'remove-private-as replace-as'])
diff --git a/test/units/modules/network/nxos/test_nxos_bgp_neighbor_af.py b/test/units/modules/network/nxos/test_nxos_bgp_neighbor_af.py
deleted file mode 100644
index 78cb1e3307..0000000000
--- a/test/units/modules/network/nxos/test_nxos_bgp_neighbor_af.py
+++ /dev/null
@@ -1,108 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_bgp_neighbor_af
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosBgpNeighborAfModule(TestNxosModule):
-
-    module = nxos_bgp_neighbor_af
-
-    def setUp(self):
-        super(TestNxosBgpNeighborAfModule, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_bgp_neighbor_af.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_bgp_neighbor_af.get_config')
-        self.get_config = self.mock_get_config.start()
-
-    def tearDown(self):
-        super(TestNxosBgpNeighborAfModule, self).tearDown()
-        self.mock_load_config.stop()
-        self.mock_get_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.get_config.return_value = load_fixture('nxos_bgp', 'config.cfg')
-        self.load_config.return_value = []
-
-    def test_nxos_bgp_neighbor_af(self):
-        set_module_args(dict(asn=65535, neighbor='192.0.2.3', afi='ipv4',
-                             safi='unicast', route_reflector_client=True))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], [
-            'router bgp 65535', 'neighbor 192.0.2.3', 'address-family ipv4 unicast',
-            'route-reflector-client'
-        ])
-
-    def test_nxos_bgp_neighbor_af_exists(self):
-        set_module_args(dict(asn=65535, neighbor='3.3.3.5', afi='ipv4', safi='unicast'))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_bgp_neighbor_af_absent(self):
-        set_module_args(dict(asn=65535, neighbor='3.3.3.5', afi='ipv4', safi='unicast', state='absent'))
-        self.execute_module(
-            changed=True, sort=False,
-            commands=['router bgp 65535', 'neighbor 3.3.3.5', 'no address-family ipv4 unicast']
-        )
-
-    def test_nxos_bgp_neighbor_af_advertise_map(self):
-        set_module_args(dict(asn=65535, neighbor='3.3.3.5', afi='ipv4', safi='unicast',
-                             advertise_map_exist=['my_advertise_map', 'my_exist_map']))
-        self.execute_module(
-            changed=True, sort=False,
-            commands=['router bgp 65535', 'neighbor 3.3.3.5', 'address-family ipv4 unicast', 'advertise-map my_advertise_map exist-map my_exist_map']
-        )
-
-    def test_nxos_bgp_neighbor_af_advertise_map_non_exist(self):
-        set_module_args(dict(asn=65535, neighbor='3.3.3.5', afi='ipv4', safi='unicast',
-                             advertise_map_non_exist=['my_advertise_map', 'my_non_exist_map']))
-        self.execute_module(
-            changed=True, sort=False,
-            commands=['router bgp 65535', 'neighbor 3.3.3.5', 'address-family ipv4 unicast', 'advertise-map my_advertise_map non-exist-map my_non_exist_map']
-        )
-
-    def test_nxos_bgp_neighbor_af_max_prefix_limit_default(self):
-        set_module_args(dict(asn=65535, neighbor='3.3.3.5', afi='ipv4',
-                             safi='unicast', max_prefix_limit='default'))
-        self.execute_module(
-            changed=True, sort=False,
-            commands=['router bgp 65535', 'neighbor 3.3.3.5', 'address-family ipv4 unicast', 'no maximum-prefix']
-        )
-
-    def test_nxos_bgp_neighbor_af_max_prefix(self):
-        set_module_args(dict(asn=65535, neighbor='3.3.3.5', afi='ipv4',
-                             safi='unicast', max_prefix_threshold=20,
-                             max_prefix_limit=20))
-        self.execute_module(
-            changed=True, sort=False,
-            commands=['router bgp 65535', 'neighbor 3.3.3.5', 'address-family ipv4 unicast', 'maximum-prefix 20 20']
-        )
-
-    def test_nxos_bgp_neighbor_af_disable_peer_as_check(self):
-        set_module_args(dict(asn=65535, neighbor='3.3.3.5', afi='ipv4',
-                             safi='unicast', disable_peer_as_check=True))
-        self.execute_module(
-            changed=True,
-            commands=['router bgp 65535', 'neighbor 3.3.3.5', 'address-family ipv4 unicast', 'disable-peer-as-check']
-        )
diff --git a/test/units/modules/network/nxos/test_nxos_command.py b/test/units/modules/network/nxos/test_nxos_command.py
deleted file mode 100644
index a3c148212a..0000000000
--- a/test/units/modules/network/nxos/test_nxos_command.py
+++ /dev/null
@@ -1,106 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-import json
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_command
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosCommandModule(TestNxosModule):
-
-    module = nxos_command
-
-    def setUp(self):
-        super(TestNxosCommandModule, self).setUp()
-
-        self.mock_run_commands = patch('ansible.modules.network.nxos.nxos_command.run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-    def tearDown(self):
-        super(TestNxosCommandModule, self).tearDown()
-        self.mock_run_commands.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        def load_from_file(*args, **kwargs):
-            module, commands = args
-            output = list()
-
-            for item in commands:
-                try:
-                    obj = json.loads(item['command'])
-                    command = obj['command']
-                except ValueError:
-                    command = item['command']
-                filename = '%s.txt' % str(command).replace(' ', '_')
-                output.append(load_fixture('nxos_command', filename))
-            return output
-
-        self.run_commands.side_effect = load_from_file
-
-    def test_nxos_command_simple(self):
-        set_module_args(dict(commands=['show version']))
-        result = self.execute_module()
-        self.assertEqual(len(result['stdout']), 1)
-        self.assertTrue(result['stdout'][0].startswith('Cisco'))
-
-    def test_nxos_command_multiple(self):
-        set_module_args(dict(commands=['show version', 'show version']))
-        result = self.execute_module()
-        self.assertEqual(len(result['stdout']), 2)
-        self.assertTrue(result['stdout'][0].startswith('Cisco'))
-
-    def test_nxos_command_wait_for(self):
-        wait_for = 'result[0] contains "NX-OS"'
-        set_module_args(dict(commands=['show version'], wait_for=wait_for))
-        self.execute_module()
-
-    def test_nxos_command_wait_for_fails(self):
-        wait_for = 'result[0] contains "test string"'
-        set_module_args(dict(commands=['show version'], wait_for=wait_for))
-        self.execute_module(failed=True)
-        self.assertEqual(self.run_commands.call_count, 10)
-
-    def test_nxos_command_retries(self):
-        wait_for = 'result[0] contains "test string"'
-        set_module_args(dict(commands=['show version'], wait_for=wait_for, retries=2))
-        self.execute_module(failed=True)
-        self.assertEqual(self.run_commands.call_count, 2)
-
-    def test_nxos_command_match_any(self):
-        wait_for = ['result[0] contains "Cisco"',
-                    'result[0] contains "test string"']
-        set_module_args(dict(commands=['show version'], wait_for=wait_for, match='any'))
-        self.execute_module()
-
-    def test_nxos_command_match_all(self):
-        wait_for = ['result[0] contains "Cisco"',
-                    'result[0] contains "image file"']
-        set_module_args(dict(commands=['show version'], wait_for=wait_for, match='all'))
-        self.execute_module()
-
-    def test_nxos_command_match_all_failure(self):
-        wait_for = ['result[0] contains "Cisco"',
-                    'result[0] contains "test string"']
-        commands = ['show version', 'show version']
-        set_module_args(dict(commands=commands, wait_for=wait_for, match='all'))
-        self.execute_module(failed=True)
diff --git a/test/units/modules/network/nxos/test_nxos_config.py b/test/units/modules/network/nxos/test_nxos_config.py
deleted file mode 100644
index 37d1f164e8..0000000000
--- a/test/units/modules/network/nxos/test_nxos_config.py
+++ /dev/null
@@ -1,224 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch, MagicMock
-from ansible.modules.network.nxos import nxos_config
-from ansible.plugins.cliconf.nxos import Cliconf
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosConfigModule(TestNxosModule):
-
-    module = nxos_config
-
-    def setUp(self):
-        super(TestNxosConfigModule, self).setUp()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_config.get_config')
-        self.get_config = self.mock_get_config.start()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_config.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_save_config = patch('ansible.modules.network.nxos.nxos_config.save_config')
-        self.save_config = self.mock_save_config.start()
-
-        self.mock_get_connection = patch('ansible.modules.network.nxos.nxos_config.get_connection')
-        self.get_connection = self.mock_get_connection.start()
-
-        self.conn = self.get_connection()
-        self.conn.edit_config = MagicMock()
-
-        self.mock_run_commands = patch('ansible.modules.network.nxos.nxos_config.run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-        self.cliconf_obj = Cliconf(MagicMock())
-        self.running_config = load_fixture('nxos_config', 'config.cfg')
-
-    def tearDown(self):
-        super(TestNxosConfigModule, self).tearDown()
-        self.mock_get_config.stop()
-        self.mock_load_config.stop()
-        self.mock_run_commands.stop()
-        self.mock_get_connection.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.get_config.return_value = load_fixture('nxos_config', 'config.cfg')
-        self.load_config.return_value = None
-
-    def test_nxos_config_no_change(self):
-        lines = ['hostname localhost']
-        args = dict(lines=lines)
-        self.conn.get_diff = MagicMock(return_value=self.cliconf_obj.get_diff('\n'.join(lines), self.running_config))
-        set_module_args(args)
-        result = self.execute_module()
-
-    def test_nxos_config_src(self):
-        src = load_fixture('nxos_config', 'candidate.cfg')
-        args = dict(src=src)
-        self.conn.get_diff = MagicMock(return_value=self.cliconf_obj.get_diff(src, self.running_config))
-        set_module_args(args)
-
-        result = self.execute_module(changed=True)
-        config = ['hostname switch01', 'interface Ethernet1',
-                  'description test interface', 'no shutdown', 'ip routing']
-
-        self.assertEqual(sorted(config), sorted(result['commands']), result['commands'])
-
-    def test_nxos_config_replace_src(self):
-        set_module_args(dict(replace_src='bootflash:config', replace='config'))
-        self.conn.get_diff = MagicMock(return_value=self.cliconf_obj.get_diff(self.running_config, self.running_config, diff_replace='config'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['config replace bootflash:config'])
-
-    def test_nxos_config_lines(self):
-        lines = ['hostname switch01', 'ip domain-name eng.ansible.com']
-        args = dict(lines=lines)
-        self.conn.get_diff = MagicMock(return_value=self.cliconf_obj.get_diff('\n'.join(lines), self.running_config))
-        set_module_args(args)
-
-        result = self.execute_module(changed=True)
-        config = ['hostname switch01']
-
-        self.assertEqual(sorted(config), sorted(result['commands']), result['commands'])
-
-    def test_nxos_config_before(self):
-        lines = ['hostname switch01', 'ip domain-name eng.ansible.com']
-        args = dict(lines=lines,
-                    before=['before command'])
-        self.conn.get_diff = MagicMock(return_value=self.cliconf_obj.get_diff('\n'.join(lines), self.running_config))
-        set_module_args(args)
-
-        result = self.execute_module(changed=True)
-        config = ['before command', 'hostname switch01']
-
-        self.assertEqual(sorted(config), sorted(result['commands']), result['commands'])
-        self.assertEqual('before command', result['commands'][0])
-
-    def test_nxos_config_after(self):
-        lines = ['hostname switch01', 'ip domain-name eng.ansible.com']
-        args = dict(lines=lines,
-                    after=['after command'])
-
-        self.conn.get_diff = MagicMock(return_value=self.cliconf_obj.get_diff('\n'.join(lines), self.running_config))
-        set_module_args(args)
-
-        result = self.execute_module(changed=True)
-        config = ['after command', 'hostname switch01']
-
-        self.assertEqual(sorted(config), sorted(result['commands']), result['commands'])
-        self.assertEqual('after command', result['commands'][-1])
-
-    def test_nxos_config_parents(self):
-        lines = ['ip address 1.2.3.4/5', 'no shutdown']
-        parents = ['interface Ethernet10']
-        args = dict(lines=lines, parents=parents)
-        self.conn.get_diff = MagicMock(return_value=self.cliconf_obj.get_diff('\n'.join(parents + lines), self.running_config, path=parents))
-        set_module_args(args)
-
-        result = self.execute_module(changed=True)
-        config = ['interface Ethernet10', 'ip address 1.2.3.4/5', 'no shutdown']
-
-        self.assertEqual(config, result['commands'], result['commands'])
-
-    def test_nxos_config_src_and_lines_fails(self):
-        args = dict(src='foo', lines='foo')
-        set_module_args(args)
-        result = self.execute_module(failed=True)
-
-    def test_nxos_config_src_and_parents_fails(self):
-        args = dict(src='foo', parents='foo')
-        set_module_args(args)
-        result = self.execute_module(failed=True)
-
-    def test_nxos_config_match_exact_requires_lines(self):
-        args = dict(match='exact')
-        set_module_args(args)
-        result = self.execute_module(failed=True)
-
-    def test_nxos_config_match_strict_requires_lines(self):
-        args = dict(match='strict')
-        set_module_args(args)
-        result = self.execute_module(failed=True)
-
-    def test_nxos_config_replace_block_requires_lines(self):
-        args = dict(replace='block')
-        set_module_args(args)
-        result = self.execute_module(failed=True)
-
-    def test_nxos_config_replace_config_requires_src(self):
-        args = dict(replace='config')
-        set_module_args(args)
-        result = self.execute_module(failed=True)
-
-    def test_nxos_config_backup_returns__backup__(self):
-        args = dict(backup=True)
-        set_module_args(args)
-        result = self.execute_module()
-        self.assertIn('__backup__', result)
-
-    def test_nxos_config_save_always(self):
-        args = dict(save_when='always')
-        set_module_args(args)
-        self.execute_module()
-        self.assertEqual(self.save_config.call_count, 1)
-        self.assertEqual(self.get_config.call_count, 0)
-        self.assertEqual(self.load_config.call_count, 0)
-
-    def test_nxos_config_save_changed_true(self):
-        args = dict(save_when='changed', lines=['hostname foo', 'interface GigabitEthernet0/0', 'no ip address'])
-        set_module_args(args)
-        self.execute_module(changed=True)
-        self.assertEqual(self.save_config.call_count, 1)
-        self.assertEqual(self.get_config.call_count, 1)
-        self.assertEqual(self.load_config.call_count, 1)
-
-    def test_nxos_config_save_changed_false(self):
-        args = dict(save_when='changed')
-        set_module_args(args)
-        self.execute_module()
-        self.assertEqual(self.save_config.call_count, 0)
-        self.assertEqual(self.get_config.call_count, 0)
-        self.assertEqual(self.load_config.call_count, 0)
-
-    def test_nxos_config_defaults_false(self):
-        set_module_args(dict(lines=['hostname localhost'], defaults=False))
-        result = self.execute_module(changed=True)
-        self.assertEqual(self.get_config.call_count, 1)
-        self.assertEqual(self.get_config.call_args[1], dict(flags=[]))
-
-    def test_nxos_config_defaults_true(self):
-        set_module_args(dict(lines=['hostname localhost'], defaults=True))
-        result = self.execute_module(changed=True)
-        self.assertEqual(self.get_config.call_count, 1)
-        self.assertEqual(self.get_config.call_args[1], dict(flags=['all']))
-
-    def test_nxos_config_defaults_false_backup_true(self):
-        set_module_args(dict(lines=['hostname localhost'], defaults=False, backup=True))
-        result = self.execute_module(changed=True)
-        self.assertEqual(self.get_config.call_count, 1)
-        self.assertEqual(self.get_config.call_args[1], dict(flags=[]))
-
-    def test_nxos_config_defaults_true_backup_true(self):
-        set_module_args(dict(lines=['hostname localhost'], defaults=True, backup=True))
-        result = self.execute_module(changed=True)
-        self.assertEqual(self.get_config.call_count, 1)
-        self.assertEqual(self.get_config.call_args[1], dict(flags=['all']))
diff --git a/test/units/modules/network/nxos/test_nxos_evpn_global.py b/test/units/modules/network/nxos/test_nxos_evpn_global.py
deleted file mode 100644
index f83e242d20..0000000000
--- a/test/units/modules/network/nxos/test_nxos_evpn_global.py
+++ /dev/null
@@ -1,69 +0,0 @@
-#
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_evpn_global
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosEvpnGlobalModule(TestNxosModule):
-
-    module = nxos_evpn_global
-
-    def setUp(self):
-        super(TestNxosEvpnGlobalModule, self).setUp()
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_evpn_global.get_config')
-        self.get_config = self.mock_get_config.start()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_evpn_global.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_capabilities = patch('ansible.modules.network.nxos.nxos_evpn_global.get_capabilities')
-        self.get_capabilities = self.mock_get_capabilities.start()
-        self.get_capabilities.return_value = {'network_api': 'cliconf'}
-
-    def tearDown(self):
-        super(TestNxosEvpnGlobalModule, self).tearDown()
-        self.mock_get_config.stop()
-        self.mock_load_config.stop()
-        self.mock_get_capabilities.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.load_config.return_value = None
-
-    def start_configured(self, *args, **kwargs):
-        self.get_config.return_value = load_fixture('nxos_evpn_global', 'configured.cfg')
-        return self.execute_module(*args, **kwargs)
-
-    def start_unconfigured(self, *args, **kwargs):
-        self.get_config.return_value = load_fixture('nxos_evpn_global', 'unconfigured.cfg')
-        return self.execute_module(*args, **kwargs)
-
-    def test_nxos_evpn_global_enable(self):
-        set_module_args(dict(nv_overlay_evpn=True))
-        commands = ['nv overlay evpn']
-        self.start_unconfigured(changed=True, commands=commands)
-
-    def test_nxos_evpn_global_disable(self):
-        set_module_args(dict(nv_overlay_evpn=False))
-        commands = ['no nv overlay evpn']
-        self.start_configured(changed=True, commands=commands)
diff --git a/test/units/modules/network/nxos/test_nxos_evpn_vni.py b/test/units/modules/network/nxos/test_nxos_evpn_vni.py
deleted file mode 100644
index 64e55e4410..0000000000
--- a/test/units/modules/network/nxos/test_nxos_evpn_vni.py
+++ /dev/null
@@ -1,67 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_evpn_vni
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosEvpnVniModule(TestNxosModule):
-
-    module = nxos_evpn_vni
-
-    def setUp(self):
-        super(TestNxosEvpnVniModule, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_evpn_vni.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_evpn_vni.get_config')
-        self.get_config = self.mock_get_config.start()
-
-    def tearDown(self):
-        super(TestNxosEvpnVniModule, self).tearDown()
-        self.mock_load_config.stop()
-        self.mock_get_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.get_config.return_value = load_fixture('', 'nxos_evpn_vni_config.cfg')
-        self.load_config.return_value = None
-
-    def test_nxos_evpn_vni_present(self):
-        set_module_args(dict(vni='6000',
-                             route_target_import='5000:10',
-                             state='present'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['evpn',
-                                              'vni 6000 l2',
-                                              'route-target import 5000:10',
-                                              'no route-target import auto'])
-
-    def test_nxos_evpn_vni_absent_not_existing(self):
-        set_module_args(dict(vni='12000', state='absent'))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_evpn_vni_absent_existing(self):
-        set_module_args(dict(vni='6000', state='absent'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['evpn', 'no vni 6000 l2'])
diff --git a/test/units/modules/network/nxos/test_nxos_feature.py b/test/units/modules/network/nxos/test_nxos_feature.py
deleted file mode 100644
index d0ca483410..0000000000
--- a/test/units/modules/network/nxos/test_nxos_feature.py
+++ /dev/null
@@ -1,77 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-import json
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_feature
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosFeatureModule(TestNxosModule):
-
-    module = nxos_feature
-
-    def setUp(self):
-        super(TestNxosFeatureModule, self).setUp()
-        self.mock_run_commands = patch('ansible.modules.network.nxos.nxos_feature.run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_feature.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_capabilities = patch('ansible.modules.network.nxos.nxos_feature.get_capabilities')
-        self.get_capabilities = self.mock_get_capabilities.start()
-        self.get_capabilities.return_value = {'network_api': 'cliconf'}
-
-    def tearDown(self):
-        super(TestNxosFeatureModule, self).tearDown()
-        self.mock_run_commands.stop()
-        self.mock_load_config.stop()
-        self.mock_get_capabilities.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        def load_from_file(*args, **kwargs):
-            module, commands = args
-            output = list()
-
-            for item in commands:
-                try:
-                    obj = json.loads(item['command'])
-                    command = obj['command']
-                except ValueError:
-                    command = item['command']
-            filename = '%s.txt' % str(command).replace(' ', '_')
-            output.append(load_fixture('nxos_feature', filename))
-            return output
-
-        self.run_commands.side_effect = load_from_file
-        self.load_config.return_value = None
-
-    def test_nxos_feature_enable(self):
-        set_module_args(dict(feature='nve', state='enabled'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask', 'feature nv overlay'])
-
-    def test_nxos_feature_disable(self):
-        set_module_args(dict(feature='ospf', state='disabled'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['terminal dont-ask', 'no feature ospf'])
diff --git a/test/units/modules/network/nxos/test_nxos_hsrp.py b/test/units/modules/network/nxos/test_nxos_hsrp.py
deleted file mode 100644
index dc459ab9cd..0000000000
--- a/test/units/modules/network/nxos/test_nxos_hsrp.py
+++ /dev/null
@@ -1,66 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_hsrp
-from .nxos_module import TestNxosModule, set_module_args
-
-
-class TestNxosHsrpModule(TestNxosModule):
-
-    module = nxos_hsrp
-
-    def setUp(self):
-        super(TestNxosHsrpModule, self).setUp()
-        self.mock_run_commands = patch('ansible.modules.network.nxos.nxos_hsrp.run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_hsrp.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_capabilities = patch('ansible.modules.network.nxos.nxos_hsrp.get_capabilities')
-        self.get_capabilities = self.mock_get_capabilities.start()
-        self.get_capabilities.return_value = {'network_api': 'cliconf'}
-
-    def tearDown(self):
-        super(TestNxosHsrpModule, self).tearDown()
-        self.mock_run_commands.stop()
-        self.mock_load_config.stop()
-        self.mock_get_capabilities.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.load_config.return_value = None
-
-    def test_nxos_hsrp(self):
-        set_module_args(dict(group='10',
-                             vip='192.0.2.2/8',
-                             priority='150',
-                             interface='Ethernet1/2',
-                             preempt='enabled',
-                             ))
-        result = self.execute_module(changed=True)
-        self.assertEqual(sorted(result['commands']), sorted(['config t',
-                                                             'interface ethernet1/2',
-                                                             'hsrp version 1',
-                                                             'hsrp 10',
-                                                             'priority 150',
-                                                             'ip 192.0.2.2/8',
-                                                             'preempt']))
diff --git a/test/units/modules/network/nxos/test_nxos_hsrp_interfaces.py b/test/units/modules/network/nxos/test_nxos_hsrp_interfaces.py
deleted file mode 100644
index 91225520f2..0000000000
--- a/test/units/modules/network/nxos/test_nxos_hsrp_interfaces.py
+++ /dev/null
@@ -1,293 +0,0 @@
-# (c) 2019 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from textwrap import dedent
-from units.compat.mock import patch
-from units.modules.utils import AnsibleFailJson
-from ansible.modules.network.nxos import nxos_hsrp_interfaces
-from ansible.module_utils.network.nxos.config.hsrp_interfaces.hsrp_interfaces import Hsrp_interfaces
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-ignore_provider_arg = True
-
-
-class TestNxosHsrpInterfacesModule(TestNxosModule):
-
-    module = nxos_hsrp_interfaces
-
-    def setUp(self):
-        super(TestNxosHsrpInterfacesModule, self).setUp()
-
-        self.mock_FACT_LEGACY_SUBSETS = patch('ansible.module_utils.network.nxos.facts.facts.FACT_LEGACY_SUBSETS')
-        self.FACT_LEGACY_SUBSETS = self.mock_FACT_LEGACY_SUBSETS.start()
-
-        self.mock_get_resource_connection_config = patch('ansible.module_utils.network.common.cfg.base.get_resource_connection')
-        self.get_resource_connection_config = self.mock_get_resource_connection_config.start()
-
-        self.mock_get_resource_connection_facts = patch('ansible.module_utils.network.common.facts.facts.get_resource_connection')
-        self.get_resource_connection_facts = self.mock_get_resource_connection_facts.start()
-
-        self.mock_edit_config = patch('ansible.module_utils.network.nxos.config.hsrp_interfaces.hsrp_interfaces.Hsrp_interfaces.edit_config')
-        self.edit_config = self.mock_edit_config.start()
-
-    def tearDown(self):
-        super(TestNxosHsrpInterfacesModule, self).tearDown()
-        self.mock_FACT_LEGACY_SUBSETS.stop()
-        self.mock_get_resource_connection_config.stop()
-        self.mock_get_resource_connection_facts.stop()
-        self.mock_edit_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.mock_FACT_LEGACY_SUBSETS.return_value = dict()
-        self.get_resource_connection_config.return_value = None
-        self.edit_config.return_value = None
-
-    # ---------------------------
-    # Hsrp_interfaces Test Cases
-    # ---------------------------
-
-    # 'state' logic behaviors
-    #
-    # - 'merged'    : Update existing device state with any differences in the play.
-    # - 'deleted'   : Reset existing device state to default values. Ignores any
-    #                 play attrs other than 'name'. Scope is limited to interfaces
-    #                 in the play.
-    # - 'overridden': The play is the source of truth. Similar to replaced but the
-    #                 scope includes all interfaces; ie. it will also reset state
-    #                 on interfaces not found in the play.
-    # - 'replaced'  : Scope is limited to the interfaces in the play.
-
-    SHOW_CMD = 'show running-config | section ^interface'
-
-    def test_1(self):
-        # Setup: No HSRP BFD configs shown on device interfaces
-        existing = dedent('''\
-          interface Ethernet1/1
-          interface Ethernet1/2
-          interface Ethernet1/3
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(
-                name='Ethernet1/1',
-                bfd='enable'),
-            dict(
-                name='Ethernet1/2',
-                bfd='disable'),
-        ])
-        # Expected result commands for each 'state'
-        merged = ['interface Ethernet1/1', 'hsrp bfd']
-        deleted = []
-        overridden = merged
-        replaced = merged
-
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=merged)
-
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False, commands=deleted)
-
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-
-    def test_2(self):
-        # Change existing HSRP configs
-        existing = dedent('''\
-          interface Ethernet1/1
-            hsrp bfd
-          interface Ethernet1/2
-            hsrp bfd
-          interface Ethernet1/3
-            hsrp bfd
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(
-                name='Ethernet1/1',
-                bfd='disable'),
-            dict(name='Ethernet1/2'),
-            # Eth1/3 not present! Thus overridden should set Eth1/3 to defaults;
-            # replaced should ignore Eth1/3.
-        ])
-        # Expected result commands for each 'state'
-        merged = ['interface Ethernet1/1', 'no hsrp bfd']
-        deleted = ['interface Ethernet1/1', 'no hsrp bfd',
-                   'interface Ethernet1/2', 'no hsrp bfd']
-        overridden = ['interface Ethernet1/3', 'no hsrp bfd',
-                      'interface Ethernet1/1', 'no hsrp bfd',
-                      'interface Ethernet1/2', 'no hsrp bfd']
-        replaced = ['interface Ethernet1/1', 'no hsrp bfd',
-                    'interface Ethernet1/2', 'no hsrp bfd']
-
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=merged)
-
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-
-    def test_3(self):
-        # Device has hsrp bfd configs, playbook has no values
-        existing = dedent('''\
-          interface Ethernet1/1
-            hsrp bfd
-          interface Ethernet1/2
-            hsrp bfd
-          interface Ethernet1/3
-            hsrp bfd
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(name='Ethernet1/1'),
-            dict(name='Ethernet1/2'),
-        ])
-        # Expected result commands for each 'state'
-        merged = []
-        deleted = ['interface Ethernet1/1', 'no hsrp bfd',
-                   'interface Ethernet1/2', 'no hsrp bfd']
-        overridden = ['interface Ethernet1/3', 'no hsrp bfd',
-                      'interface Ethernet1/1', 'no hsrp bfd',
-                      'interface Ethernet1/2', 'no hsrp bfd']
-        replaced = ['interface Ethernet1/1', 'no hsrp bfd',
-                    'interface Ethernet1/2', 'no hsrp bfd']
-
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False, commands=merged)
-
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-
-    def test_4(self):
-        # Test with interface that doesn't exist yet
-        existing = dedent('''\
-          interface Ethernet1/1
-            hsrp bfd
-          interface Ethernet1/2
-            hsrp bfd
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(
-                name='Ethernet1/1.42',
-                bfd='enable'),
-        ])
-        # Expected result commands for each 'state'
-        merged = ['interface Ethernet1/1.42', 'hsrp bfd']
-        deleted = []
-        overridden = ['interface Ethernet1/1.42', 'hsrp bfd',
-                      'interface Ethernet1/1', 'no hsrp bfd',
-                      'interface Ethernet1/2', 'no hsrp bfd']
-        replaced = ['interface Ethernet1/1.42', 'hsrp bfd']
-
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=merged)
-
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False, commands=deleted)
-
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-
-    def test_5(self):
-        # idempotence
-        existing = dedent('''\
-          interface Ethernet1/1
-            hsrp bfd
-          interface Ethernet1/2
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(
-                name='Ethernet1/1',
-                bfd='enable'),
-            dict(
-                name='Ethernet1/2',
-                bfd='disable'),
-        ])
-        # Expected result commands for each 'state'
-        merged = []
-        deleted = ['interface Ethernet1/1', 'no hsrp bfd']
-        overridden = []
-        replaced = []
-
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False, commands=merged)
-
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False, commands=overridden)
-
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False, commands=replaced)
-
-
-def build_args(data, type, state=None, check_mode=None):
-    if state is None:
-        state = 'merged'
-    if check_mode is None:
-        check_mode = False
-    args = {
-        'state': state,
-        '_ansible_check_mode': check_mode,
-        'config': {
-            type: data
-        }
-    }
-    return args
diff --git a/test/units/modules/network/nxos/test_nxos_interface.py b/test/units/modules/network/nxos/test_nxos_interface.py
deleted file mode 100644
index f9a2fbc870..0000000000
--- a/test/units/modules/network/nxos/test_nxos_interface.py
+++ /dev/null
@@ -1,91 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import _nxos_interface
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosInterfaceModule(TestNxosModule):
-
-    module = _nxos_interface
-
-    def setUp(self):
-        super(TestNxosInterfaceModule, self).setUp()
-        self.mock_run_commands = patch('ansible.modules.network.nxos._nxos_interface.run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos._nxos_interface.load_config')
-        self.load_config = self.mock_load_config.start()
-
-    def tearDown(self):
-        super(TestNxosInterfaceModule, self).tearDown()
-        self.mock_run_commands.stop()
-        self.mock_load_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        module_name = self.module.__name__.rsplit('.', 1)[1]
-
-        def load_from_file(*args, **kwargs):
-            module, commands = args
-            output = list()
-
-            for command in commands:
-                if type(command) == dict:
-                    command = command['command']
-                filename = str(command).split(' | ')[0].replace(' ', '_').replace('/', '_')
-                print(filename)
-                output.append(load_fixture(module_name, filename))
-            return output
-
-        self.load_config.return_value = None
-        self.run_commands.side_effect = load_from_file
-
-    def test_nxos_interface_up(self):
-        set_module_args(dict(interface='loopback0'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface loopback0', 'no shutdown'])
-
-    def test_nxos_interface_down(self):
-        set_module_args(dict(interface='loopback0', admin_state='down'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface loopback0', 'shutdown'])
-
-    def test_nxos_interface_delete(self):
-        set_module_args(dict(interface='loopback0', state='absent'))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_interface_type(self):
-        set_module_args(dict(interface_type='loopback', state='absent'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['no interface loopback0'])
-
-    def test_nxos_interface_mtu(self):
-        set_module_args(dict(interface='Ethernet2/1', mode='layer2', mtu='1800'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface Ethernet2/1', 'switchport', 'mtu 1800',
-                                              'interface Ethernet2/1', 'no shutdown'])
-
-    def test_nxos_interface_speed_idempotence(self):
-        set_module_args(dict(interface='Ethernet2/1', speed='1000'))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
diff --git a/test/units/modules/network/nxos/test_nxos_interface_ospf.py b/test/units/modules/network/nxos/test_nxos_interface_ospf.py
deleted file mode 100644
index d4156b43dd..0000000000
--- a/test/units/modules/network/nxos/test_nxos_interface_ospf.py
+++ /dev/null
@@ -1,141 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_interface_ospf
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosInterfaceOspfModule(TestNxosModule):
-
-    module = nxos_interface_ospf
-
-    def setUp(self):
-        super(TestNxosInterfaceOspfModule, self).setUp()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_interface_ospf.get_config')
-        self.get_config = self.mock_get_config.start()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_interface_ospf.load_config')
-        self.load_config = self.mock_load_config.start()
-
-    def tearDown(self):
-        super(TestNxosInterfaceOspfModule, self).tearDown()
-        self.mock_get_config.stop()
-        self.mock_load_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        module_name = self.module.__name__.rsplit('.', 1)[1]
-        self.get_config.return_value = load_fixture(module_name, 'config.cfg')
-        self.load_config.return_value = None
-
-    def test_nxos_interface_ospf(self):
-        set_module_args(dict(interface='ethernet1/32', ospf=1, area=1))
-        self.execute_module(changed=True, commands=['interface Ethernet1/32', 'ip router ospf 1 area 0.0.0.1'])
-
-    def test_bfd_1(self):
-        # default -> enable
-        set_module_args(dict(interface='ethernet1/33', ospf=1, area=1, bfd='enable'))
-        self.execute_module(changed=True, commands=['interface Ethernet1/33', 'ip router ospf 1 area 0.0.0.1', 'ip ospf bfd'])
-
-        # default -> disable
-        set_module_args(dict(interface='ethernet1/33', ospf=1, area=1, bfd='disable'))
-        self.execute_module(changed=True, commands=['interface Ethernet1/33', 'ip router ospf 1 area 0.0.0.1', 'ip ospf bfd disable'])
-
-    def test_bfd_2(self):
-        # default -> default
-        set_module_args(dict(interface='ethernet1/33.101', ospf=1, area=1, bfd='default'))
-        self.execute_module(changed=False)
-
-        # enable -> default
-        set_module_args(dict(interface='ethernet1/36', ospf=1, area=1, bfd='default'))
-        self.execute_module(changed=True, commands=['interface Ethernet1/36', 'no ip ospf bfd'])
-
-        # disable -> default
-        set_module_args(dict(interface='ethernet1/37', ospf=1, area=1, bfd='default'))
-        self.execute_module(changed=True, commands=['interface Ethernet1/37', 'no ip ospf bfd'])
-
-    def test_bfd_3(self):
-        # enable -> idempotence
-        set_module_args(dict(interface='ethernet1/36', ospf=1, area=1, bfd='enable'))
-        self.execute_module(changed=False)
-
-        # disable -> idempotence
-        set_module_args(dict(interface='ethernet1/37', ospf=1, area=1, bfd='disable'))
-        self.execute_module(changed=False)
-
-    def test_bfd_4(self):
-        # None -> absent
-        set_module_args(dict(interface='ethernet1/33.101', ospf=1, area=1, state='absent'))
-        self.execute_module(changed=True, commands=['interface Ethernet1/33.101', 'no ip router ospf 1 area 0.0.0.1'])
-
-        # enable -> absent
-        set_module_args(dict(interface='ethernet1/36', ospf=1, area=1, bfd='enable', state='absent'))
-        self.execute_module(changed=True, commands=['interface Ethernet1/36', 'no ip router ospf 1 area 0.0.0.1', 'no ip ospf bfd'])
-
-        # disable -> absent
-        set_module_args(dict(interface='ethernet1/37', ospf=1, area=1, bfd='disable', state='absent'))
-        self.execute_module(changed=True, commands=['interface Ethernet1/37', 'no ip router ospf 1 area 0.0.0.1', 'no ip ospf bfd'])
-
-    def test_absent_1(self):
-        # area only -> absent
-        set_module_args(dict(interface='ethernet1/33.101', ospf=1, area=1, state='absent'))
-        self.execute_module(changed=True, commands=['interface Ethernet1/33.101', 'no ip router ospf 1 area 0.0.0.1'])
-
-        # None -> absent
-        set_module_args(dict(interface='ethernet1/33', ospf=1, area=1, state='absent'))
-        self.execute_module(changed=False)
-
-    def test_loopback_interface_failed(self):
-        set_module_args(dict(interface='loopback0', ospf=1, area=0, passive_interface=True))
-        self.execute_module(failed=True, changed=False)
-        set_module_args(dict(interface='loopback0', ospf=1, area=0, network='broadcast'))
-        self.execute_module(failed=True, changed=False)
-
-    def test_nxos_interface_ospf_passive(self):
-        # default -> True
-        set_module_args(dict(interface='ethernet1/33', ospf=1, area=1, passive_interface=True))
-        self.execute_module(changed=True, commands=['interface Ethernet1/33',
-                                                    'ip router ospf 1 area 0.0.0.1',
-                                                    'ip ospf passive-interface'])
-        # default -> False
-        set_module_args(dict(interface='ethernet1/33', ospf=1, area=1, passive_interface=False))
-        self.execute_module(changed=True, commands=['interface Ethernet1/33',
-                                                    'ip router ospf 1 area 0.0.0.1',
-                                                    'no ip ospf passive-interface'])
-        # True -> False
-        set_module_args(dict(interface='ethernet1/34', ospf=1, area=1, passive_interface=False))
-        self.execute_module(changed=True, commands=['interface Ethernet1/34',
-                                                    'no ip ospf passive-interface'])
-        # True -> default (absent)
-        set_module_args(dict(interface='ethernet1/34', ospf=1, area=1, state='absent'))
-        self.execute_module(changed=True, commands=['interface Ethernet1/34',
-                                                    'no ip router ospf 1 area 0.0.0.1',
-                                                    'default ip ospf passive-interface'])
-        # False -> True
-        set_module_args(dict(interface='ethernet1/35', ospf=1, area=1, passive_interface=True))
-        self.execute_module(changed=True, commands=['interface Ethernet1/35',
-                                                    'ip ospf passive-interface'])
-        # False -> default (absent)
-        set_module_args(dict(interface='ethernet1/35', ospf=1, area=1, state='absent'))
-        self.execute_module(changed=True, commands=['interface Ethernet1/35',
-                                                    'no ip router ospf 1 area 0.0.0.1',
-                                                    'default ip ospf passive-interface'])
diff --git a/test/units/modules/network/nxos/test_nxos_interfaces.py b/test/units/modules/network/nxos/test_nxos_interfaces.py
deleted file mode 100644
index 26467abfd6..0000000000
--- a/test/units/modules/network/nxos/test_nxos_interfaces.py
+++ /dev/null
@@ -1,461 +0,0 @@
-# (c) 2019 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from textwrap import dedent
-from units.compat.mock import patch
-from units.modules.utils import AnsibleFailJson
-from ansible.modules.network.nxos import nxos_interfaces
-from ansible.module_utils.network.nxos.config.interfaces.interfaces import Interfaces
-from ansible.module_utils.network.nxos.facts.interfaces.interfaces import InterfacesFacts
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-ignore_provider_arg = True
-
-
-class TestNxosInterfacesModule(TestNxosModule):
-
-    module = nxos_interfaces
-
-    def setUp(self):
-        super(TestNxosInterfacesModule, self).setUp()
-
-        self.mock_FACT_LEGACY_SUBSETS = patch('ansible.module_utils.network.nxos.facts.facts.FACT_LEGACY_SUBSETS')
-        self.FACT_LEGACY_SUBSETS = self.mock_FACT_LEGACY_SUBSETS.start()
-
-        self.mock_get_resource_connection_config = patch('ansible.module_utils.network.common.cfg.base.get_resource_connection')
-        self.get_resource_connection_config = self.mock_get_resource_connection_config.start()
-
-        self.mock_get_resource_connection_facts = patch('ansible.module_utils.network.common.facts.facts.get_resource_connection')
-        self.get_resource_connection_facts = self.mock_get_resource_connection_facts.start()
-
-        self.mock_edit_config = patch('ansible.module_utils.network.nxos.config.interfaces.interfaces.Interfaces.edit_config')
-        self.edit_config = self.mock_edit_config.start()
-        self.mock__device_info = patch('ansible.module_utils.network.nxos.facts.interfaces.interfaces.InterfacesFacts._device_info')
-        self._device_info = self.mock__device_info.start()
-
-    def tearDown(self):
-        super(TestNxosInterfacesModule, self).tearDown()
-        self.mock_FACT_LEGACY_SUBSETS.stop()
-        self.mock_get_resource_connection_config.stop()
-        self.mock_get_resource_connection_facts.stop()
-        self.mock_edit_config.stop()
-        self.mock__device_info.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.mock_FACT_LEGACY_SUBSETS.return_value = dict()
-        self.get_resource_connection_config.return_value = None
-        self.edit_config.return_value = None
-        if device == 'legacy':
-            # call execute_module() with device='legacy' to use this codepath
-            self._device_info.return_value = {'network_os_platform': 'N3K-Cxxx'}
-        else:
-            self._device_info.return_value = {'network_os_platform': 'N9K-Cxxx'}
-
-    SHOW_RUN_SYSDEF = "show running-config all | incl 'system default switchport'"
-    SHOW_RUN_INTF = 'show running-config | section ^interface'
-
-    def test_1(self):
-        # Overall general test for each state: merged, deleted, overridden, replaced
-        sysdefs = dedent('''\
-          !
-          ! Interfaces default to L3 !!
-          !
-          no system default switchport
-          no system default switchport shutdown
-        ''')
-        intf = dedent('''\
-          interface mgmt0
-            description do not manage mgmt0!
-          interface Ethernet1/1
-            description foo
-          interface Ethernet1/2
-            description bar
-            speed 1000
-            duplex full
-            mtu 4096
-            ip forward
-            fabric forwarding mode anycast-gateway
-          interface Ethernet1/3
-          interface Ethernet1/4
-          interface Ethernet1/5
-          interface Ethernet1/6
-            no shutdown
-          interface loopback0
-            description test-loopback
-        ''')
-        self.get_resource_connection_facts.return_value = {
-            self.SHOW_RUN_SYSDEF: sysdefs,
-            self.SHOW_RUN_INTF: intf
-        }
-        playbook = dict(config=[
-            dict(name='Ethernet1/1', description='ansible', mode='layer3'),
-            dict(name='Ethernet1/2', speed=10000, duplex='auto', mtu=1500,
-                 ip_forward=False, fabric_forwarding_anycast_gateway=False),
-            dict(name='Ethernet1/3', description='ansible', mode='layer3'),
-            dict(name='Ethernet1/3.101', description='test-sub-intf', enabled=False),
-            dict(name='Ethernet1/4', mode='layer2'),
-            dict(name='Ethernet1/5'),
-            dict(name='loopback1', description='test-loopback')
-        ])
-        merged = [
-            # Update existing device states with any differences in the playbook.
-            'interface Ethernet1/1', 'description ansible',
-            'interface Ethernet1/2', 'speed 10000', 'duplex auto', 'mtu 1500',
-            'no ip forward', 'no fabric forwarding mode anycast-gateway',
-            'interface Ethernet1/3', 'description ansible',
-            'interface Ethernet1/3.101', 'description test-sub-intf',
-            'interface Ethernet1/4', 'switchport',
-            'interface loopback1', 'description test-loopback'
-        ]
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=merged)
-
-        deleted = [
-            # Reset existing device state to default values. Scope is limited to
-            # objects in the play. Ignores any play attrs other than 'name'.
-            'interface Ethernet1/1', 'no description',
-            'interface Ethernet1/2', 'no description', 'no speed', 'no duplex', 'no mtu',
-            'no ip forward', 'no fabric forwarding mode anycast-gateway',
-        ]
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-
-        replaced = [
-            # Scope is limited to objects in the play. The play is the source of
-            # truth for the objects that are explicitly listed.
-            'interface Ethernet1/1', 'description ansible',
-            'interface Ethernet1/2', 'no description',
-            'no ip forward', 'no fabric forwarding mode anycast-gateway',
-            'speed 10000', 'duplex auto', 'mtu 1500',
-            'interface Ethernet1/3', 'description ansible',
-            'interface Ethernet1/3.101', 'description test-sub-intf',
-            'interface Ethernet1/4', 'switchport',
-            'interface loopback1', 'description test-loopback'
-        ]
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-
-        overridden = [
-            # The play is the source of truth. Similar to replaced but the scope
-            # includes all objects on the device; i.e. it will also reset state
-            # on objects not found in the play.
-            'interface Ethernet1/1', 'description ansible',
-            'interface Ethernet1/2', 'no description',
-            'no ip forward', 'no fabric forwarding mode anycast-gateway',
-            'speed 10000', 'duplex auto', 'mtu 1500',
-            'interface Ethernet1/6', 'shutdown',
-            'interface loopback0', 'no description',
-            'interface Ethernet1/3', 'description ansible',
-            'interface Ethernet1/4', 'switchport',
-            'interface Ethernet1/3.101', 'description test-sub-intf',
-            'interface loopback1', 'description test-loopback'
-        ]
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-    def test_2(self):
-        # 'enabled'/shutdown behaviors are tricky:
-        # - different default states for different interface types for different
-        #   platforms, based on 'system default switchport' settings
-        # - virtual interfaces may not exist yet
-        # - idempotence for interfaces with all default states
-        sysdefs = dedent('''\
-          !
-          ! Interfaces default to L3 !!
-          !
-          no system default switchport
-          no system default switchport shutdown
-        ''')
-        intf = dedent('''\
-          interface mgmt0
-          interface Ethernet1/1
-          interface Ethernet1/2
-            switchport
-            shutdown
-          interface Ethernet1/3
-            switchport
-          interface loopback1
-          interface loopback2
-            shutdown
-          interface loopback3
-          interface loopback8
-          interface loopback9
-            shutdown
-          interface port-channel2
-          interface port-channel3
-            shutdown
-        ''')
-        self.get_resource_connection_facts.return_value = {
-            self.SHOW_RUN_SYSDEF: sysdefs,
-            self.SHOW_RUN_INTF: intf
-        }
-        playbook = dict(config=[
-            # Set non-default states on existing objs
-            dict(name='Ethernet1/1', mode='layer3', enabled=True),
-            dict(name='loopback1', enabled=False),
-            # Set default states on existing objs
-            dict(name='Ethernet1/2', enabled=True),
-            dict(name='loopback2', enabled=True),
-            # Set explicit default state on existing objs (no chg)
-            dict(name='Ethernet1/3', enabled=True),
-            dict(name='loopback3', enabled=True),
-            dict(name='port-channel3', enabled=True),
-            # Set default state on non-existent objs; no state changes but need to create intf
-            dict(name='loopback4', enabled=True),
-            dict(name='port-channel4', enabled=True),
-            dict(name='Ethernet1/4.101')
-        ])
-        # Testing with newer code version
-        merged = [
-            'interface Ethernet1/1', 'no shutdown',
-            'interface loopback1', 'shutdown',
-            'interface Ethernet1/2', 'no shutdown',
-            'interface loopback2', 'no shutdown',
-            'interface port-channel3', 'no shutdown',
-            'interface loopback4',
-            'interface port-channel4',
-            'interface Ethernet1/4.101'
-        ]
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=merged)
-
-        deleted = [
-            # e1/2 becomes L3 so enable default changes to false
-            'interface Ethernet1/2', 'no switchport',
-            'interface loopback2', 'no shutdown',
-            'interface Ethernet1/3', 'no switchport',
-            'interface port-channel3', 'no shutdown'
-        ]
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-
-        replaced = [
-            'interface Ethernet1/1', 'no shutdown',
-            'interface loopback1', 'shutdown',
-            'interface Ethernet1/2', 'no switchport', 'no shutdown',
-            'interface loopback2', 'no shutdown',
-            'interface Ethernet1/3', 'no switchport', 'no shutdown',
-            'interface port-channel3', 'no shutdown',
-            'interface loopback4',
-            'interface port-channel4',
-            'interface Ethernet1/4.101'
-        ]
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-
-        overridden = [
-            'interface Ethernet1/2', 'no switchport', 'no shutdown',
-            'interface Ethernet1/3', 'no switchport', 'no shutdown',
-            'interface loopback2', 'no shutdown',
-            'interface loopback9', 'no shutdown',
-            'interface port-channel3', 'no shutdown',
-            'interface Ethernet1/1', 'no shutdown',
-            'interface loopback1', 'shutdown',
-            'interface loopback4',
-            'interface port-channel4',
-            'interface Ethernet1/4.101'
-        ]
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-    def test_3(self):
-        # Testing 'enabled' with different 'system default' settings.
-        # This is the same as test_2 with some minor changes.
-        sysdefs = dedent('''\
-          !
-          ! Interfaces default to L2 !!
-          !
-          system default switchport
-          system default switchport shutdown
-        ''')
-        intf = dedent('''\
-          interface mgmt0
-          interface Ethernet1/1
-          interface Ethernet1/2
-            no switchport
-            no shutdown
-          interface Ethernet1/3
-            no switchport
-          interface loopback1
-          interface loopback2
-            shutdown
-          interface loopback3
-          interface loopback8
-          interface loopback9
-            shutdown
-          interface port-channel2
-          interface port-channel3
-            shutdown
-        ''')
-        self.get_resource_connection_facts.return_value = {
-            self.SHOW_RUN_SYSDEF: sysdefs,
-            self.SHOW_RUN_INTF: intf
-        }
-        playbook = dict(config=[
-            # Set non-default states on existing objs
-            dict(name='Ethernet1/1', mode='layer3', enabled=True),
-            dict(name='loopback1', enabled=False),
-            # Set default states on existing objs
-            dict(name='Ethernet1/2', enabled=False),
-            dict(name='loopback2', enabled=True),
-            # Set explicit default state on existing objs (no chg)
-            dict(name='Ethernet1/3', enabled=False),
-            dict(name='loopback3', enabled=True),
-            dict(name='port-channel3', enabled=True),
-            # Set default state on non-existent objs; no state changes but need to create intf
-            dict(name='loopback4', enabled=True),
-            dict(name='port-channel4', enabled=True),
-            dict(name='Ethernet1/4.101')
-        ])
-        merged = [
-            'interface Ethernet1/1', 'no switchport', 'no shutdown',
-            'interface loopback1', 'shutdown',
-            'interface Ethernet1/2', 'shutdown',
-            'interface loopback2', 'no shutdown',
-            'interface port-channel3', 'no shutdown',
-            'interface loopback4',
-            'interface port-channel4',
-            'interface Ethernet1/4.101'
-        ]
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=merged)
-
-        # Test with an older image version which has different defaults
-        merged_legacy = [
-            'interface Ethernet1/1', 'no switchport',
-            'interface loopback1', 'shutdown',
-            'interface Ethernet1/2', 'shutdown',
-            'interface loopback2', 'no shutdown',
-            'interface Ethernet1/3', 'shutdown',
-            'interface port-channel3', 'no shutdown',
-            'interface loopback4',
-            'interface port-channel4',
-            'interface Ethernet1/4.101'
-        ]
-        self.execute_module(changed=True, commands=merged_legacy, device='legacy')
-
-        deleted = [
-            'interface Ethernet1/2', 'switchport', 'shutdown',
-            'interface loopback2', 'no shutdown',
-            'interface Ethernet1/3', 'switchport',
-            'interface port-channel3', 'no shutdown'
-        ]
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-
-        replaced = [
-            'interface Ethernet1/1', 'no switchport', 'no shutdown',
-            'interface loopback1', 'shutdown',
-            'interface Ethernet1/2', 'switchport', 'shutdown',
-            'interface loopback2', 'no shutdown',
-            'interface Ethernet1/3', 'switchport',
-            'interface port-channel3', 'no shutdown',
-            'interface loopback4',
-            'interface port-channel4',
-            'interface Ethernet1/4.101'
-        ]
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-
-        overridden = [
-            'interface Ethernet1/2', 'switchport', 'shutdown',
-            'interface Ethernet1/3', 'switchport',
-            'interface loopback2', 'no shutdown',
-            'interface loopback9', 'no shutdown',
-            'interface port-channel3', 'no shutdown',
-            'interface Ethernet1/1', 'no switchport', 'no shutdown',
-            'interface loopback1', 'shutdown',
-            'interface loopback4',
-            'interface port-channel4',
-            'interface Ethernet1/4.101'
-        ]
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-    def test_4(self):
-        # Basic idempotence test
-        sysdefs = dedent('''\
-          !
-          ! Interfaces default to L3 !!
-          !
-          no system default switchport
-          no system default switchport shutdown
-        ''')
-        intf = dedent('''\
-          interface Ethernet1/1
-          interface Ethernet1/2
-            switchport
-            speed 1000
-            shutdown
-        ''')
-        self.get_resource_connection_facts.return_value = {
-            self.SHOW_RUN_SYSDEF: sysdefs,
-            self.SHOW_RUN_INTF: intf
-        }
-        playbook = dict(config=[
-            dict(name='Ethernet1/1', mode='layer3'),
-            dict(name='Ethernet1/2', mode='layer2', enabled=False)
-        ])
-        merged = []
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False, commands=merged)
-
-    def test_5(self):
-        # 'state: deleted' without 'config'; clean all objects.
-        sysdefs = dedent('''\
-          !
-          ! Interfaces default to L3 !!
-          !
-          no system default switchport
-          no system default switchport shutdown
-        ''')
-        intf = dedent('''\
-          interface Ethernet1/1
-            switchport
-          interface Ethernet1/2
-            speed 1000
-            no shutdown
-        ''')
-        self.get_resource_connection_facts.return_value = {
-            self.SHOW_RUN_SYSDEF: sysdefs,
-            self.SHOW_RUN_INTF: intf
-        }
-        playbook = dict()
-        deleted = [
-            'interface Ethernet1/1', 'no switchport',
-            'interface Ethernet1/2', 'no speed', 'shutdown'
-        ]
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
diff --git a/test/units/modules/network/nxos/test_nxos_l3_interface.py b/test/units/modules/network/nxos/test_nxos_l3_interface.py
deleted file mode 100644
index 9e23f5702c..0000000000
--- a/test/units/modules/network/nxos/test_nxos_l3_interface.py
+++ /dev/null
@@ -1,226 +0,0 @@
-# Copyright: (c) 2019, Olivier Blin <olivier.oblin@gmail.com>
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import _nxos_l3_interface
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosL3InterfaceModule(TestNxosModule):
-
-    module = _nxos_l3_interface
-
-    def setUp(self):
-        super(TestNxosL3InterfaceModule, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos._nxos_l3_interface.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos._nxos_l3_interface.get_config')
-        self.get_config = self.mock_get_config.start()
-
-    def tearDown(self):
-        super(TestNxosL3InterfaceModule, self).tearDown()
-        self.mock_load_config.stop()
-        self.mock_get_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.load_config.return_value = None
-        self.get_config.return_value = load_fixture('nxos_l3_interface', self.mode)
-
-    def test_nxos_l3_interface_unknonw_ethernet(self):
-        self.mode = 'ethernet_noshut'
-        set_module_args(dict(name='Ethernet1/2', ipv4='192.168.0.1/24'))
-        result = self.execute_module(changed=False)
-
-    # Add when missing
-    def test_nxos_l3_interface_add_missing_ipv4(self):
-        self.mode = 'ethernet_noshut'
-        set_module_args(dict(name='Ethernet1/1', ipv4='192.168.0.1/24'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface Ethernet1/1', 'ip address 192.168.0.1/24', 'exit'])
-
-    def test_nxos_l3_interface_add_missing_ipv4_on_e11(self):
-        self.mode = 'ethernet_noshut'
-        set_module_args(dict(name='et1/1', ipv4='192.168.0.1/24'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface Ethernet1/1', 'ip address 192.168.0.1/24', 'exit'])
-
-    def test_nxos_l3_interface_add_missing_ipv6(self):
-        self.mode = 'ethernet_noshut'
-        set_module_args(dict(name='Ethernet1/1', ipv6='2001:db8::1/124'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface Ethernet1/1', 'ipv6 address 2001:db8::1/124', 'exit'])
-
-    def test_nxos_l3_interface_add_missing_ipv4_and_ipv6(self):
-        self.mode = 'ethernet_noshut'
-        set_module_args(dict(name='Ethernet1/1', ipv4='192.168.0.1/24', ipv6='2001:db8::1/124'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface Ethernet1/1', 'ip address 192.168.0.1/24', 'ipv6 address 2001:db8::1/124', 'exit'])
-
-    # Add when existing
-    def test_nxos_l3_interface_add_existing_ipv4(self):
-        self.mode = 'ethernet_noshut_ipv4_ipv6'
-        set_module_args(dict(name='Ethernet1/1', ipv4='192.168.0.1/24'))
-        result = self.execute_module()
-
-    def test_nxos_l3_interface_add_existing_ipv4_on_e11(self):
-        self.mode = 'ethernet_noshut_ipv4_ipv6'
-        set_module_args(dict(name='et1/1', ipv4='192.168.0.1/24'))
-        result = self.execute_module()
-
-    def test_nxos_l3_interface_add_existing_ipv6(self):
-        self.mode = 'ethernet_noshut_ipv4_ipv6'
-        set_module_args(dict(name='Ethernet1/1', ipv6='2001:db8::1/124'))
-        result = self.execute_module()
-
-    def test_nxos_l3_interface_add_existing_ipv4_and_ipv6(self):
-        self.mode = 'ethernet_noshut_ipv4_ipv6'
-        set_module_args(dict(name='Ethernet1/1', ipv4='192.168.0.1/24', ipv6='2001:db8::1/124'))
-        result = self.execute_module()
-
-    def test_nxos_l3_interface_new_ipv4_and_ipv6(self):
-        self.mode = 'ethernet_noshut_ipv4_ipv6'
-        set_module_args(dict(name='Ethernet1/1', ipv4='192.168.0.2/24', ipv6='2001:db8::2/124'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface Ethernet1/1', 'ip address 192.168.0.2/24', 'ipv6 address 2001:db8::2/124', 'exit'])
-
-    # Add when existing with multiple IPv6
-    def test_nxos_l3_interface_multiple_ipv6_add_first(self):
-        self.mode = 'ethernet_noshut_multiple_ipv6'
-        set_module_args(dict(name='Ethernet1/1', ipv6='2001:db8::1/124'))
-        result = self.execute_module()
-
-    def test_nxos_l3_interface_multiple_ipv6_add_last(self):
-        self.mode = 'ethernet_noshut_multiple_ipv6'
-        set_module_args(dict(name='Ethernet1/1', ipv6='2001:db8:2::1/124'))
-        result = self.execute_module()
-
-    # Add aggregate
-    def test_nxos_l3_interface_add_missing_with_empty_aggregate(self):
-        self.mode = 'ethernet_noshut'
-        set_module_args(dict(aggregate=[]))
-        result = self.execute_module()
-
-    def test_nxos_l3_interface_add_missing_with_aggregate(self):
-        self.mode = 'ethernet_noshut'
-        set_module_args(dict(aggregate=[
-            dict(name='Ethernet1/1', ipv4='192.168.0.2/24', ipv6='2001:db8::2/124'),
-            dict(name='Ethernet1/1', ipv6='2001:db8:1::2/124'),
-            dict(name='Ethernet1/1', ipv6='2001:db8:2::2/124')]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], [
-            'interface Ethernet1/1', 'ip address 192.168.0.2/24', 'ipv6 address 2001:db8::2/124', 'exit',
-            'interface Ethernet1/1', 'ipv6 address 2001:db8:1::2/124', 'exit',
-            'interface Ethernet1/1', 'ipv6 address 2001:db8:2::2/124', 'exit'])
-
-    # Rem when missing
-    def test_nxos_l3_interface_rem_missing_ipv4(self):
-        self.mode = 'ethernet_noshut'
-        set_module_args(dict(name='Ethernet1/1', ipv4='192.168.0.1/24', state='absent'))
-        result = self.execute_module()
-
-    def test_nxos_l3_interface_rem_missing_ipv4_on_e11(self):
-        self.mode = 'ethernet_noshut'
-        set_module_args(dict(name='et1/1', ipv4='192.168.0.1/24', state='absent'))
-        result = self.execute_module()
-
-    def test_nxos_l3_interface_rem_missing_ipv6(self):
-        self.mode = 'ethernet_noshut'
-        set_module_args(dict(name='Ethernet1/1', ipv6='2001:db8::1/124', state='absent'))
-        result = self.execute_module()
-
-    def test_nxos_l3_interface_rem_missing_ipv4_and_ipv6(self):
-        self.mode = 'ethernet_noshut'
-        set_module_args(dict(name='Ethernet1/1', ipv4='192.168.0.1/24', ipv6='2001:db8::1/124', state='absent'))
-        result = self.execute_module()
-
-    # Rem when existing
-    def test_nxos_l3_interface_rem_existing_ipv4(self):
-        self.mode = 'ethernet_noshut_ipv4_ipv6'
-        set_module_args(dict(name='Ethernet1/1', ipv4='192.168.0.1/24', state='absent'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface Ethernet1/1', 'no ip address 192.168.0.1/24', 'exit'])
-
-    def test_nxos_l3_interface_rem_existing_ipv4_on_e11(self):
-        self.mode = 'ethernet_noshut_ipv4_ipv6'
-        set_module_args(dict(name='et1/1', ipv4='192.168.0.1/24', state='absent'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface Ethernet1/1', 'no ip address 192.168.0.1/24', 'exit'])
-
-    def test_nxos_l3_interface_rem_existing_ipv6(self):
-        self.mode = 'ethernet_noshut_ipv4_ipv6'
-        set_module_args(dict(name='Ethernet1/1', ipv6='2001:db8::1/124', state='absent'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface Ethernet1/1', 'no ipv6 address 2001:db8::1/124', 'exit'])
-
-    def test_nxos_l3_interface_rem_existing_ipv4_and_ipv6(self):
-        self.mode = 'ethernet_noshut_ipv4_ipv6'
-        set_module_args(dict(name='Ethernet1/1', ipv4='192.168.0.1/24', ipv6='2001:db8::1/124', state='absent'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface Ethernet1/1', 'no ip address 192.168.0.1/24', 'no ipv6 address 2001:db8::1/124', 'exit'])
-
-    # Rem when existing with multiple IPv6
-    def test_nxos_l3_interface_multiple_ipv6_rem_first(self):
-        self.mode = 'ethernet_noshut_multiple_ipv6'
-        set_module_args(dict(name='Ethernet1/1', ipv6='2001:db8::1/124', state='absent'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface Ethernet1/1', 'no ipv6 address 2001:db8::1/124', 'exit'])
-
-    def test_nxos_l3_interface_multiple_ipv6_rem_last(self):
-        self.mode = 'ethernet_noshut_multiple_ipv6'
-        set_module_args(dict(name='Ethernet1/1', ipv6='2001:db8:2::1/124', state='absent'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface Ethernet1/1', 'no ipv6 address 2001:db8:2::1/124', 'exit'])
-
-    # Rem when missing with aggregate
-    def test_nxos_l3_interface_rem_with_empty_aggregate(self):
-        self.mode = 'ethernet_noshut_multiple_ipv6'
-        set_module_args(dict(aggregate=[], state='absent'))
-        result = self.execute_module()
-
-    def test_nxos_l3_interface_rem_missing_with_aggregate(self):
-        self.mode = 'ethernet_noshut_multiple_ipv6'
-        set_module_args(dict(state='absent', aggregate=[
-            dict(name='Ethernet1/1', ipv4='192.168.0.2/24', ipv6='2001:db8::2/124'),
-            dict(name='Ethernet1/1', ipv6='2001:db8:1::2/124'),
-            dict(name='Ethernet1/1', ipv6='2001:db8:2::2/124')]))
-        result = self.execute_module()
-
-    # Rem when existing with aggregate
-    def test_nxos_l3_interface_rem_existing_with_aggregate(self):
-        self.mode = 'ethernet_noshut_multiple_ipv6'
-        set_module_args(dict(state='absent', aggregate=[
-            dict(name='Ethernet1/1', ipv4='192.168.0.1/24', ipv6='2001:db8::1/124'),
-            dict(name='Ethernet1/1', ipv6='2001:db8:1::1/124'),
-            dict(name='Ethernet1/1', ipv6='2001:db8:2::1/124')]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], [
-            'interface Ethernet1/1', 'no ip address 192.168.0.1/24', 'no ipv6 address 2001:db8::1/124', 'exit',
-            'interface Ethernet1/1', 'no ipv6 address 2001:db8:1::1/124', 'exit',
-            'interface Ethernet1/1', 'no ipv6 address 2001:db8:2::1/124', 'exit'])
-
-    # Add itf only
-    def test_nxos_l3_interface_add_on_itf_only(self):
-        self.mode = 'ethernet_noshut'
-        set_module_args(dict(name='Ethernet1/1'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface Ethernet1/1'])
-
-    # Add unknown interface
-    def test_nxos_l3_interface_add_on_unknown_itf(self):
-        self.mode = 'ethernet_noshut'
-        set_module_args(dict(name='Ethernet1/2', ipv4='192.168.0.1/24'))
-        result = self.execute_module()
-        self.assertEqual(result['warnings'], ['Unknown interface Ethernet1/2'])
-
-    # Rem unknown interface
-    def test_nxos_l3_interface_rem_on_unknown_itf(self):
-        self.mode = 'ethernet_noshut'
-        set_module_args(dict(name='Ethernet1/2', ipv4='192.168.0.1/24', state='absent'))
-        result = self.execute_module()
-        self.assertEqual(result['warnings'], ['Unknown interface Ethernet1/2'])
diff --git a/test/units/modules/network/nxos/test_nxos_l3_interfaces.py b/test/units/modules/network/nxos/test_nxos_l3_interfaces.py
deleted file mode 100644
index 79ca244ef4..0000000000
--- a/test/units/modules/network/nxos/test_nxos_l3_interfaces.py
+++ /dev/null
@@ -1,580 +0,0 @@
-# (c) 2019 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from textwrap import dedent
-from units.compat.mock import patch
-from units.modules.utils import AnsibleFailJson
-from ansible.modules.network.nxos import nxos_l3_interfaces
-from ansible.module_utils.network.nxos.config.l3_interfaces.l3_interfaces import L3_interfaces
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-ignore_provider_arg = True
-
-
-class TestNxosL3InterfacesModule(TestNxosModule):
-
-    module = nxos_l3_interfaces
-
-    def setUp(self):
-        super(TestNxosL3InterfacesModule, self).setUp()
-
-        self.mock_FACT_LEGACY_SUBSETS = patch('ansible.module_utils.network.nxos.facts.facts.FACT_LEGACY_SUBSETS')
-        self.FACT_LEGACY_SUBSETS = self.mock_FACT_LEGACY_SUBSETS.start()
-
-        self.mock_get_resource_connection_config = patch('ansible.module_utils.network.common.cfg.base.get_resource_connection')
-        self.get_resource_connection_config = self.mock_get_resource_connection_config.start()
-
-        self.mock_get_resource_connection_facts = patch('ansible.module_utils.network.common.facts.facts.get_resource_connection')
-        self.get_resource_connection_facts = self.mock_get_resource_connection_facts.start()
-
-        self.mock_edit_config = patch('ansible.module_utils.network.nxos.config.l3_interfaces.l3_interfaces.L3_interfaces.edit_config')
-        self.edit_config = self.mock_edit_config.start()
-
-        self.mock_get_platform_type = patch('ansible.module_utils.network.nxos.config.l3_interfaces.l3_interfaces.L3_interfaces.get_platform_type')
-        self.get_platform_type = self.mock_get_platform_type.start()
-
-    def tearDown(self):
-        super(TestNxosL3InterfacesModule, self).tearDown()
-        self.mock_FACT_LEGACY_SUBSETS.stop()
-        self.mock_get_resource_connection_config.stop()
-        self.mock_get_resource_connection_facts.stop()
-        self.mock_edit_config.stop()
-        self.mock_get_platform_type.stop()
-
-    def load_fixtures(self, commands=None, device='N9K'):
-        self.mock_FACT_LEGACY_SUBSETS.return_value = dict()
-        self.get_resource_connection_config.return_value = None
-        self.edit_config.return_value = None
-        self.get_platform_type.return_value = device
-
-    # ---------------------------
-    # L3_interfaces Test Cases
-    # ---------------------------
-
-    # 'state' logic behaviors
-    #
-    # - 'merged'    : Update existing device state with any differences in the play.
-    # - 'deleted'   : Reset existing device state to default values. Ignores any
-    #                 play attrs other than 'name'. Scope is limited to interfaces
-    #                 in the play.
-    # - 'overridden': The play is the source of truth. Similar to replaced but the
-    #                 scope includes all interfaces; ie. it will also reset state
-    #                 on interfaces not found in the play.
-    # - 'replaced'  : Scope is limited to the interfaces in the play.
-
-    SHOW_CMD = 'show running-config | section ^interface'
-
-    def test_1(self):
-        # Verify raise when playbook specifies mgmt0
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: ''}
-        playbook = dict(config=[dict(name='mgmt0')])
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module({'failed': True, 'msg': "The 'mgmt0' interface is not allowed to be managed by this module"})
-
-    def test_2(self):
-        # basic tests
-        existing = dedent('''\
-          interface mgmt0
-            ip address 10.0.0.254/24
-          interface Ethernet1/1
-            ip address 10.1.1.1/24
-          interface Ethernet1/2
-            ip address 10.1.2.1/24
-          interface Ethernet1/3
-            ip address 10.1.3.1/24
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(
-                name='Ethernet1/1',
-                ipv4=[{'address': '192.168.1.1/24'}]),
-            dict(name='Ethernet1/2'),
-            # Eth1/3 not present! Thus overridden should set Eth1/3 to defaults;
-            # replaced should ignore Eth1/3.
-        ])
-        # Expected result commands for each 'state'
-        merged = ['interface Ethernet1/1', 'ip address 192.168.1.1/24']
-        deleted = ['interface Ethernet1/1', 'no ip address',
-                   'interface Ethernet1/2', 'no ip address']
-        replaced = ['interface Ethernet1/1', 'ip address 192.168.1.1/24',
-                    'interface Ethernet1/2', 'no ip address']
-        overridden = ['interface Ethernet1/1', 'ip address 192.168.1.1/24',
-                      'interface Ethernet1/2', 'no ip address',
-                      'interface Ethernet1/3', 'no ip address']
-
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=merged)
-
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-    def test_3(self):
-        # encap testing
-        existing = dedent('''\
-          interface mgmt0
-            ip address 10.0.0.254/24
-          interface Ethernet1/1.41
-            encapsulation dot1q 4100
-            ip address 10.1.1.1/24
-          interface Ethernet1/1.42
-            encapsulation dot1q 42
-          interface Ethernet1/1.44
-            encapsulation dot1q 44
-          interface Ethernet1/1.45
-            encapsulation dot1q 45
-            ip address 10.5.5.5/24
-            ipv6 address 10::5/128
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(name='Ethernet1/1.41', dot1q=41, ipv4=[{'address': '10.2.2.2/24'}]),
-            dict(name='Ethernet1/1.42', dot1q=42),
-            dict(name='Ethernet1/1.43', dot1q=43, ipv6=[{'address': '10::2/128'}]),
-            dict(name='Ethernet1/1.44')
-        ])
-        # Expected result commands for each 'state'
-        merged = [
-            'interface Ethernet1/1.41', 'encapsulation dot1q 41', 'ip address 10.2.2.2/24',
-            'interface Ethernet1/1.43', 'encapsulation dot1q 43', 'ipv6 address 10::2/128',
-        ]
-        deleted = [
-            'interface Ethernet1/1.41', 'no encapsulation dot1q', 'no ip address',
-            'interface Ethernet1/1.42', 'no encapsulation dot1q',
-            'interface Ethernet1/1.44', 'no encapsulation dot1q'
-        ]
-        replaced = [
-            'interface Ethernet1/1.41', 'encapsulation dot1q 41', 'ip address 10.2.2.2/24',
-            # 42 no chg
-            'interface Ethernet1/1.43', 'encapsulation dot1q 43', 'ipv6 address 10::2/128',
-            'interface Ethernet1/1.44', 'no encapsulation dot1q'
-        ]
-        overridden = [
-            'interface Ethernet1/1.41', 'encapsulation dot1q 41', 'ip address 10.2.2.2/24',
-            # 42 no chg
-            'interface Ethernet1/1.44', 'no encapsulation dot1q',
-            'interface Ethernet1/1.45', 'no encapsulation dot1q', 'no ip address', 'no ipv6 address',
-            'interface Ethernet1/1.43', 'encapsulation dot1q 43', 'ipv6 address 10::2/128'
-        ]
-
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=merged)
-
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-    def test_4(self):
-        # IPv4-centric testing
-        existing = dedent('''\
-          interface mgmt0
-            ip address 10.0.0.254/24
-          interface Ethernet1/1
-            no ip redirects
-            ip address 10.1.1.1/24 tag 11
-            ip address 10.2.2.2/24 secondary tag 12
-            ip address 10.3.3.3/24 secondary
-            ip address 10.4.4.4/24 secondary tag 14
-            ip address 10.5.5.5/24 secondary tag 15
-            ip address 10.6.6.6/24 secondary tag 16
-          interface Ethernet1/2
-            ip address 10.12.12.12/24
-          interface Ethernet1/3
-            ip address 10.13.13.13/24
-          interface Ethernet1/5
-            no ip redirects
-            ip address 10.15.15.15/24
-            ip address 10.25.25.25/24 secondary
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(name='Ethernet1/1',
-                 ipv4=[{'address': '10.1.1.1/24', 'secondary': True},  # prim->sec
-                       {'address': '10.2.2.2/24', 'secondary': True},  # rmv tag
-                       {'address': '10.3.3.3/24', 'tag': 3},           # become prim
-                       {'address': '10.4.4.4/24', 'secondary': True, 'tag': 14},  # no chg
-                       {'address': '10.5.5.5/24', 'secondary': True, 'tag': 55},  # chg tag
-                       {'address': '10.7.7.7/24', 'secondary': True, 'tag': 77}]),  # new ip
-            dict(name='Ethernet1/2'),
-            dict(name='Ethernet1/4',
-                 ipv4=[{'address': '10.40.40.40/24'},
-                       {'address': '10.41.41.41/24', 'secondary': True}]),
-            dict(name='Ethernet1/5'),
-        ])
-        # Expected result commands for each 'state'
-        merged = [
-            'interface Ethernet1/1',
-            'no ip address 10.5.5.5/24 secondary',
-            'no ip address 10.2.2.2/24 secondary',
-            'no ip address 10.3.3.3/24 secondary',
-            'ip address 10.3.3.3/24 tag 3',  # Changes primary
-            'ip address 10.1.1.1/24 secondary',
-            'ip address 10.2.2.2/24 secondary',
-            'ip address 10.7.7.7/24 secondary tag 77',
-            'ip address 10.5.5.5/24 secondary tag 55',
-            'interface Ethernet1/4',
-            'ip address 10.40.40.40/24',
-            'ip address 10.41.41.41/24 secondary'
-        ]
-        deleted = [
-            'interface Ethernet1/1', 'no ip address',
-            'interface Ethernet1/2', 'no ip address',
-            'interface Ethernet1/5', 'no ip address'
-        ]
-        replaced = [
-            'interface Ethernet1/1',
-            'no ip address 10.5.5.5/24 secondary',
-            'no ip address 10.2.2.2/24 secondary',
-            'no ip address 10.3.3.3/24 secondary',
-            'ip address 10.3.3.3/24 tag 3',  # Changes primary
-            'ip address 10.1.1.1/24 secondary',
-            'ip address 10.2.2.2/24 secondary',
-            'ip address 10.7.7.7/24 secondary tag 77',
-            'ip address 10.5.5.5/24 secondary tag 55',
-            'interface Ethernet1/2',
-            'no ip address',
-            'interface Ethernet1/4',
-            'ip address 10.40.40.40/24',
-            'ip address 10.41.41.41/24 secondary',
-            'interface Ethernet1/5',
-            'no ip address'
-        ]
-        overridden = [
-            'interface Ethernet1/1',
-            'no ip address 10.6.6.6/24 secondary',
-            'no ip address 10.5.5.5/24 secondary',
-            'no ip address 10.2.2.2/24 secondary',
-            'no ip address 10.3.3.3/24 secondary',
-            'ip address 10.3.3.3/24 tag 3',  # Changes primary
-            'ip address 10.1.1.1/24 secondary',
-            'ip address 10.2.2.2/24 secondary',
-            'ip address 10.7.7.7/24 secondary tag 77',
-            'ip address 10.5.5.5/24 secondary tag 55',
-            'interface Ethernet1/2',
-            'no ip address',
-            'interface Ethernet1/3',
-            'no ip address',
-            'interface Ethernet1/4',
-            'ip address 10.40.40.40/24',
-            'ip address 10.41.41.41/24 secondary',
-            'interface Ethernet1/5',
-            'no ip address',
-        ]
-
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=merged)
-
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-    def test_5(self):
-        # IPv6-centric testing
-        existing = dedent('''\
-          interface Ethernet1/1
-            ipv6 address 10::1/128
-            ipv6 address 10::2/128 tag 12
-            ipv6 address 10::3/128 tag 13
-            ipv6 address 10::4/128 tag 14
-          interface Ethernet1/2
-            ipv6 address 10::12/128
-          interface Ethernet1/3
-            ipv6 address 10::13/128
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(name='Ethernet1/1',
-                 ipv6=[{'address': '10::1/128'},               # no chg
-                       {'address': '10::3/128'},               # tag rmv
-                       {'address': '10::4/128', 'tag': 44},    # tag chg
-                       {'address': '10::5/128'},               # new addr
-                       {'address': '10::6/128', 'tag': 66}]),  # new addr+tag
-            dict(name='Ethernet1/2'),
-        ])
-        # Expected result commands for each 'state'
-        merged = [
-            'interface Ethernet1/1',
-            'ipv6 address 10::4/128 tag 44',
-            'ipv6 address 10::5/128',
-            'ipv6 address 10::6/128 tag 66',
-        ]
-        deleted = [
-            'interface Ethernet1/1', 'no ipv6 address',
-            'interface Ethernet1/2', 'no ipv6 address',
-        ]
-        replaced = [
-            'interface Ethernet1/1',
-            'no ipv6 address 10::3/128',
-            'no ipv6 address 10::2/128',
-            'ipv6 address 10::4/128 tag 44',
-            'ipv6 address 10::3/128',
-            'ipv6 address 10::5/128',
-            'ipv6 address 10::6/128 tag 66',
-            'interface Ethernet1/2',
-            'no ipv6 address 10::12/128'
-        ]
-        overridden = [
-            'interface Ethernet1/1',
-            'no ipv6 address 10::3/128',
-            'no ipv6 address 10::2/128',
-            'ipv6 address 10::4/128 tag 44',
-            'ipv6 address 10::3/128',
-            'ipv6 address 10::5/128',
-            'ipv6 address 10::6/128 tag 66',
-            'interface Ethernet1/2',
-            'no ipv6 address 10::12/128',
-            'interface Ethernet1/3',
-            'no ipv6 address'
-        ]
-
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=merged)
-
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-        #
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-        #
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-    def test_6(self):
-        # misc tests
-        existing = dedent('''\
-          interface Ethernet1/1
-            ip address 10.1.1.1/24
-            no ip redirects
-            ip unreachables
-          interface Ethernet1/2
-          interface Ethernet1/3
-          interface Ethernet1/4
-          interface Ethernet1/5
-            no ip redirects
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(name='Ethernet1/1', redirects=True, unreachables=False,
-                 ipv4=[{'address': '192.168.1.1/24'}]),
-            dict(name='Ethernet1/2'),
-            dict(name='Ethernet1/3', redirects=True, unreachables=False),  # defaults
-            dict(name='Ethernet1/4', redirects=False, unreachables=True),
-        ])
-        merged = [
-            'interface Ethernet1/1',
-            'ip redirects',
-            'no ip unreachables',
-            'ip address 192.168.1.1/24',
-            'interface Ethernet1/4',
-            'no ip redirects',
-            'ip unreachables'
-        ]
-        deleted = [
-            'interface Ethernet1/1',
-            'ip redirects',
-            'no ip unreachables',
-            'no ip address'
-        ]
-        replaced = [
-            'interface Ethernet1/1',
-            'ip redirects',
-            'no ip unreachables',
-            'ip address 192.168.1.1/24',
-            'interface Ethernet1/4',
-            'no ip redirects',
-            'ip unreachables'
-        ]
-        overridden = [
-            'interface Ethernet1/1',
-            'ip redirects',
-            'no ip unreachables',
-            'ip address 192.168.1.1/24',
-            'interface Ethernet1/5',
-            'ip redirects',
-            'interface Ethernet1/4',
-            'no ip redirects',
-            'ip unreachables'
-        ]
-
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=merged)
-
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-    def test_7(self):
-        # idempotence
-        existing = dedent('''\
-          interface Ethernet1/1
-            ip address 10.1.1.1/24
-            ip address 10.2.2.2/24 secondary tag 2
-            ip address 10.3.3.3/24 secondary tag 3
-            ip address 10.4.4.4/24 secondary
-            ipv6 address 10::1/128
-            ipv6 address 10::2/128 tag 2
-            no ip redirects
-            ip unreachables
-          interface Ethernet1/2
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(name='Ethernet1/1', redirects=False, unreachables=True,
-                 ipv4=[{'address': '10.1.1.1/24'},
-                       {'address': '10.2.2.2/24', 'secondary': True, 'tag': 2},
-                       {'address': '10.3.3.3/24', 'secondary': True, 'tag': 3},
-                       {'address': '10.4.4.4/24', 'secondary': True}],
-                 ipv6=[{'address': '10::1/128'},
-                       {'address': '10::2/128', 'tag': 2}]),
-            dict(name='Ethernet1/2')
-        ])
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False)
-
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False)
-
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False)
-
-        # Modify output for deleted idempotence test
-        existing = dedent('''\
-          interface Ethernet1/1
-          interface Ethernet1/2
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False)
-
-    def test_8(self):
-        # no 'config' key in playbook
-        existing = dedent('''\
-          interface Ethernet1/1
-            ip address 10.1.1.1/24
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict()
-
-        for i in ['merged', 'replaced', 'overridden']:
-            playbook['state'] = i
-            set_module_args(playbook, ignore_provider_arg)
-            self.execute_module(failed=True)
-
-        deleted = [
-            'interface Ethernet1/1',
-            'no ip address',
-        ]
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-
-    def test_9(self):
-        # Platform specific checks
-        # 'ip redirects' has platform-specific behaviors
-        existing = dedent('''\
-          interface mgmt0
-            ip address 10.0.0.254/24
-          interface Ethernet1/3
-            ip address 10.13.13.13/24
-          interface Ethernet1/5
-            no ip redirects
-            ip address 10.15.15.15/24
-            ip address 10.25.25.25/24 secondary
-        ''')
-        self.get_resource_connection_facts.return_value = {self.SHOW_CMD: existing}
-        playbook = dict(config=[
-            dict(name='Ethernet1/3'),
-            dict(name='Ethernet1/5'),
-        ])
-        # Expected result commands for each 'state'
-        deleted = [
-            'interface Ethernet1/3', 'no ip address',
-            'interface Ethernet1/5', 'no ip address', 'ip redirects'
-        ]
-        replaced = [
-            'interface Ethernet1/3', 'no ip address',
-            'interface Ethernet1/5', 'no ip address', 'ip redirects'
-        ]
-        overridden = [
-            'interface Ethernet1/3', 'no ip address',
-            'interface Ethernet1/5', 'no ip address', 'ip redirects'
-        ]
-        platform = 'N3K'
-
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=False, device=platform)
-
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted, device=platform)
-
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced, device=platform)
-
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden, device=platform)
diff --git a/test/units/modules/network/nxos/test_nxos_lldp_interfaces.py b/test/units/modules/network/nxos/test_nxos_lldp_interfaces.py
deleted file mode 100644
index fb70ed2e1c..0000000000
--- a/test/units/modules/network/nxos/test_nxos_lldp_interfaces.py
+++ /dev/null
@@ -1,236 +0,0 @@
-#
-# (c) 2019, Ansible by Red Hat, inc
-# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
-#
-
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from ansible.modules.network.nxos import nxos_lldp_interfaces
-from units.compat.mock import patch, MagicMock
-from units.modules.utils import set_module_args
-from .nxos_module import TestNxosModule, load_fixture
-
-
-class TestNxosLldpInterfacesModule(TestNxosModule):
-
-    module = nxos_lldp_interfaces
-
-    def setUp(self):
-        super(TestNxosLldpInterfacesModule, self).setUp()
-
-        self.mock_get_config = patch(
-            'ansible.module_utils.network.common.network.Config.get_config')
-        self.get_config = self.mock_get_config.start()
-
-        self.mock_load_config = patch(
-            'ansible.module_utils.network.common.network.Config.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_resource_connection_config = patch(
-            'ansible.module_utils.network.common.cfg.base.get_resource_connection'
-        )
-        self.get_resource_connection_config = self.mock_get_resource_connection_config.start(
-        )
-
-        self.mock_get_resource_connection_facts = patch(
-            'ansible.module_utils.network.common.facts.facts.get_resource_connection'
-        )
-        self.get_resource_connection_facts = self.mock_get_resource_connection_facts.start()
-
-        self.mock_edit_config = patch(
-            'ansible.module_utils.network.nxos.config.lldp_interfaces.lldp_interfaces.Lldp_interfaces.edit_config'
-        )
-        self.edit_config = self.mock_edit_config.start()
-
-        self.mock_execute_show_command = patch(
-            'ansible.module_utils.network.nxos.facts.lldp_interfaces.lldp_interfaces.Lldp_interfacesFacts.get_device_data'
-        )
-        self.execute_show_command = self.mock_execute_show_command.start()
-
-    def tearDown(self):
-        super(TestNxosLldpInterfacesModule, self).tearDown()
-        self.mock_get_resource_connection_config.stop()
-        self.mock_get_resource_connection_facts.stop()
-        self.mock_edit_config.stop()
-        self.mock_get_config.stop()
-        self.mock_load_config.stop()
-        self.mock_execute_show_command.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        def load_from_file(*args, **kwargs):
-            output = '''interface Ethernet1/1
-            lldp receive
-            no lldp transmit
-          interface Ethernet1/2
-            no lldp receive
-            lldp tlv-set vlan 12'''
-            return output
-
-        self.execute_show_command.side_effect = load_from_file
-
-    def test_nxos_lldp_interfaces_merged(self):
-        set_module_args(
-            dict(config=[
-                dict(name="Ethernet1/3",
-                     receive=False,
-                     tlv_set=dict(
-                         vlan=123
-                     )
-                     )
-            ], state="merged"))
-        commands = ['interface Ethernet1/3',
-                    'no lldp receive',
-                    'lldp tlv-set vlan 123']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_lldp_interfaces_merged_idempotent(self):
-        set_module_args(
-            dict(config=[
-                dict(name="Ethernet1/2",
-                     receive=False,
-                     tlv_set=dict(
-                         vlan=12
-                     )
-                     ),
-                dict(name="Ethernet1/1",
-                          receive=True,
-                          transmit=False)
-            ], state="merged"))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_lldp_interfaces_replaced(self):
-        set_module_args(
-            dict(config=[
-                dict(name="Ethernet1/2",
-                     receive=True,
-                     transmit=False,
-                     tlv_set=dict(
-                         management_address='192.0.2.123'
-                     )
-                     )
-            ], state="replaced"))
-        commands = ['interface Ethernet1/2',
-                    'lldp receive',
-                    'no lldp transmit',
-                    'no lldp tlv-set vlan 12',
-                    'lldp tlv-set management-address 192.0.2.123']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_lldp_interfaces_replaced_idempotent(self):
-        set_module_args(
-            dict(config=[
-                dict(name="Ethernet1/2",
-                     receive=False,
-                     tlv_set=dict(
-                         vlan=12
-                     )
-                     ),
-                dict(name="Ethernet1/1",
-                          receive=True,
-                          transmit=False)
-            ], state="replaced"))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_lldp_interfaces_overridden(self):
-        set_module_args(
-            dict(config=[
-                dict(name="Ethernet1/4",
-                     receive=True,
-                     transmit=False
-                     )
-            ], state="overridden"))
-        commands = ['interface Ethernet1/4',
-                    'lldp receive',
-                    'no lldp transmit',
-                    'interface Ethernet1/1',
-                    'lldp receive',
-                    'lldp transmit',
-                    'interface Ethernet1/2',
-                    'lldp receive',
-                    'no lldp tlv-set vlan 12']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_lldp_interfaces_overridden_idempotent(self):
-        set_module_args(
-            dict(config=[
-                dict(name="Ethernet1/2",
-                     receive=False,
-                     tlv_set=dict(
-                         vlan=12
-                     )
-                     ),
-                dict(name="Ethernet1/1",
-                          receive=True,
-                          transmit=False)
-            ], state="overridden"))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_lldp_interfaces_deleted_intf(self):
-        set_module_args(
-            dict(config=[
-                dict(name="Ethernet1/2")
-            ], state="deleted"))
-        commands = ['interface Ethernet1/2',
-                    'lldp receive',
-                    'no lldp tlv-set vlan 12']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_lldp_interfaces_deleted_all(self):
-        set_module_args(
-            dict(state="deleted"))
-        commands = ['interface Ethernet1/2',
-                    'lldp receive',
-                    'no lldp tlv-set vlan 12',
-                    'interface Ethernet1/1',
-                    'lldp receive',
-                    'lldp transmit']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_lldp_interfaces_rendered(self):
-        set_module_args(
-            dict(config=[
-                dict(name="Ethernet1/2",
-                     receive=False,
-                     tlv_set=dict(
-                         vlan=12
-                     )
-                     ),
-                dict(name="Ethernet1/1",
-                     receive=True,
-                     transmit=False)
-            ], state="rendered"))
-        commands = ['interface Ethernet1/1',
-                    'lldp receive',
-                    'no lldp transmit',
-                    'interface Ethernet1/2',
-                    'no lldp receive',
-                    'lldp tlv-set vlan 12']
-        result = self.execute_module(changed=False)
-        self.assertEqual(sorted(result['rendered']), sorted(
-            commands), result['rendered'])
-
-    def test_nxos_lldp_interfaces_parsed(self):
-        set_module_args(dict(running_config='''interface Ethernet1/1
-            lldp receive
-            no lldp transmit
-          interface Ethernet1/2
-            no lldp receive
-            lldp tlv-set vlan 12''', state="parsed"))
-        result = self.execute_module(changed=False)
-        compare_list = [{'name': 'Ethernet1/1', 'receive': True, 'transmit': False},
-                        {'name': 'Ethernet1/2', 'receive': False, 'tlv_set': {
-                            'vlan': 12
-                        }}]
-        self.assertEqual(result['parsed'],
-                         compare_list, result['parsed'])
-
-    def test_nxos_lldp_interfaces_gathered(self):
-        set_module_args(dict(state="gathered"))
-        result = self.execute_module(changed=False)
-        compare_list = [{'name': 'Ethernet1/1', 'receive': True, 'transmit': False},
-                        {'name': 'Ethernet1/2', 'receive': False, 'tlv_set': {
-                            'vlan': 12
-                        }}]
-        self.assertEqual(result['gathered'],
-                         compare_list, result['gathered'])
diff --git a/test/units/modules/network/nxos/test_nxos_nxapi.py b/test/units/modules/network/nxos/test_nxos_nxapi.py
deleted file mode 100644
index c0eae1a341..0000000000
--- a/test/units/modules/network/nxos/test_nxos_nxapi.py
+++ /dev/null
@@ -1,74 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_nxapi
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosNxapiModule(TestNxosModule):
-
-    module = nxos_nxapi
-
-    def setUp(self):
-        super(TestNxosNxapiModule, self).setUp()
-
-        self.mock_run_commands = patch('ansible.modules.network.nxos.nxos_nxapi.run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_nxapi.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_capabilities = patch('ansible.modules.network.nxos.nxos_nxapi.get_capabilities')
-        self.get_capabilities = self.mock_get_capabilities.start()
-        self.get_capabilities.return_value = {'device_info': {'network_os_platform': 'N7K-C7018', 'network_os_version': '8.3(1)'}, 'network_api': 'cliconf'}
-
-    def tearDown(self):
-        super(TestNxosNxapiModule, self).tearDown()
-        self.mock_run_commands.stop()
-        self.mock_load_config.stop()
-        self.mock_get_capabilities.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        def load_from_file(*args, **kwargs):
-            module, commands = args
-            module_name = self.module.__name__.rsplit('.', 1)[1]
-
-            output = list()
-            for command in commands:
-                filename = str(command).split(' | ')[0].replace(' ', '_')
-                output.append(load_fixture(module_name, filename, device))
-            return output
-
-        self.run_commands.side_effect = load_from_file
-        self.load_config.return_value = None
-
-    def test_nxos_nxapi_no_change(self):
-        set_module_args(dict(http=True, https=False, http_port=80, https_port=443, sandbox=False))
-        self.execute_module_devices(changed=False, commands=[])
-
-    def test_nxos_nxapi_disable(self):
-        set_module_args(dict(state='absent'))
-        self.execute_module_devices(changed=True, commands=['no feature nxapi'])
-
-    def test_nxos_nxapi_no_http(self):
-        set_module_args(dict(https=True, http=False, https_port=8443))
-        self.execute_module_devices(changed=True, commands=['no nxapi http', 'nxapi https port 8443'])
diff --git a/test/units/modules/network/nxos/test_nxos_ospf.py b/test/units/modules/network/nxos/test_nxos_ospf.py
deleted file mode 100644
index 6f5cb3df82..0000000000
--- a/test/units/modules/network/nxos/test_nxos_ospf.py
+++ /dev/null
@@ -1,56 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_ospf
-from .nxos_module import TestNxosModule, set_module_args
-
-
-class TestNxosOspfModule(TestNxosModule):
-
-    module = nxos_ospf
-
-    def setUp(self):
-        super(TestNxosOspfModule, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_ospf.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_ospf.get_config')
-        self.get_config = self.mock_get_config.start()
-
-    def tearDown(self):
-        super(TestNxosOspfModule, self).tearDown()
-        self.mock_load_config.stop()
-        self.mock_get_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.load_config.return_value = None
-
-    def test_nxos_ospf_present(self):
-        set_module_args(dict(ospf=1, state='present'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['router ospf 1'])
-
-    def test_nxos_ospf_absent(self):
-        set_module_args(dict(ospf=1, state='absent'))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
diff --git a/test/units/modules/network/nxos/test_nxos_ospf_vrf.py b/test/units/modules/network/nxos/test_nxos_ospf_vrf.py
deleted file mode 100644
index 165d127437..0000000000
--- a/test/units/modules/network/nxos/test_nxos_ospf_vrf.py
+++ /dev/null
@@ -1,128 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_ospf_vrf
-from .nxos_module import TestNxosModule, set_module_args
-
-
-class TestNxosOspfVrfModule(TestNxosModule):
-
-    module = nxos_ospf_vrf
-
-    def setUp(self):
-        super(TestNxosOspfVrfModule, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_ospf_vrf.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_ospf_vrf.get_config')
-        self.get_config = self.mock_get_config.start()
-
-    def tearDown(self):
-        super(TestNxosOspfVrfModule, self).tearDown()
-        self.mock_load_config.stop()
-        self.mock_get_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.load_config.return_value = None
-
-    def test_nxos_ospf_vrf_present(self):
-        set_module_args(dict(ospf=1,
-                             vrf='test',
-                             timer_throttle_spf_start=50,
-                             timer_throttle_spf_hold=1000,
-                             timer_throttle_spf_max=2000,
-                             timer_throttle_lsa_start=60,
-                             timer_throttle_lsa_hold=1100,
-                             timer_throttle_lsa_max=3000,
-                             bfd='enable',
-                             state='present'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(sorted(result['commands']),
-                         sorted(['router ospf 1',
-                                 'vrf test',
-                                 'timers throttle lsa 60 1100 3000',
-                                 'timers throttle spf 50 1000 2000',
-                                 'bfd',
-                                 ]))
-
-    def test_nxos_ospf_vrf_absent(self):
-        set_module_args(dict(ospf=1, vrf='test', state='absent'))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_bfd_1(self):
-        self.get_config.return_value = 'router ospf 1\n  bfd\nrouter ospf 2'
-        # enable -> disable
-        set_module_args(dict(
-            ospf=1,
-            bfd='disable',
-        ))
-        self.execute_module(changed=True, commands=[
-            'router ospf 1',
-            'no bfd',
-        ])
-
-        # disable -> enable
-        set_module_args(dict(
-            ospf=2,
-            bfd='enable',
-        ))
-        self.execute_module(changed=True, commands=[
-            'router ospf 2',
-            'bfd',
-        ])
-
-    def test_bfd_2(self):
-        # enable idempotence
-        self.get_config.return_value = 'router ospf 1\n  bfd\nrouter ospf 2'
-        set_module_args(dict(
-            ospf=1,
-            bfd='enable',
-        ))
-        self.execute_module(changed=False)
-
-        # disable idempotence
-        set_module_args(dict(
-            ospf=2,
-            bfd='disable',
-        ))
-        self.execute_module(changed=False)
-
-    def test_bfd_3(self):
-        # absent tests
-        self.get_config.return_value = 'router ospf 1\n  bfd\nrouter ospf 2'
-        set_module_args(dict(
-            ospf=1,
-            state='absent'
-        ))
-        self.execute_module(changed=True, commands=[
-            'router ospf 1',
-            'no bfd',
-        ])
-
-        # absent w/bfd disable
-        set_module_args(dict(
-            ospf=2,
-            state='absent'
-        ))
-        self.execute_module(changed=False)
diff --git a/test/units/modules/network/nxos/test_nxos_overlay_global.py b/test/units/modules/network/nxos/test_nxos_overlay_global.py
deleted file mode 100644
index ffbfe73e8d..0000000000
--- a/test/units/modules/network/nxos/test_nxos_overlay_global.py
+++ /dev/null
@@ -1,51 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_overlay_global
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosOverlayGlobalModule(TestNxosModule):
-
-    module = nxos_overlay_global
-
-    def setUp(self):
-        super(TestNxosOverlayGlobalModule, self).setUp()
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_overlay_global.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_overlay_global.get_config')
-        self.get_config = self.mock_get_config.start()
-
-    def tearDown(self):
-        super(TestNxosOverlayGlobalModule, self).tearDown()
-        self.mock_load_config.stop()
-        self.mock_get_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.get_config.return_value = load_fixture('', 'nxos_overlay_global_config.cfg')
-        self.load_config.return_value = None
-
-    def test_nxos_overlay_global_up(self):
-        set_module_args(dict(anycast_gateway_mac="a.a.a"))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['fabric forwarding anycast-gateway-mac 000A.000A.000A'])
diff --git a/test/units/modules/network/nxos/test_nxos_pim.py b/test/units/modules/network/nxos/test_nxos_pim.py
deleted file mode 100644
index f4aa433245..0000000000
--- a/test/units/modules/network/nxos/test_nxos_pim.py
+++ /dev/null
@@ -1,100 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_pim
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosPimModule(TestNxosModule):
-
-    module = nxos_pim
-
-    def setUp(self):
-        super(TestNxosPimModule, self).setUp()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_pim.get_config')
-        self.get_config = self.mock_get_config.start()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_pim.load_config')
-        self.load_config = self.mock_load_config.start()
-
-    def tearDown(self):
-        super(TestNxosPimModule, self).tearDown()
-        self.mock_get_config.stop()
-        self.mock_load_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.load_config.return_value = None
-
-    def test_nxos_pim_1(self):
-        # Add/ Modify
-        self.get_config.return_value = load_fixture('nxos_pim', 'config.cfg')
-        set_module_args(dict(ssm_range='233.0.0.0/8'))
-        self.execute_module(changed=True, commands=[
-            'ip pim ssm range 233.0.0.0/8',
-        ])
-
-    def test_nxos_pim_2(self):
-        # Remove existing values
-        self.get_config.return_value = load_fixture('nxos_pim', 'config.cfg')
-        set_module_args(dict(bfd='disable', ssm_range='none'))
-        self.execute_module(changed=True, commands=[
-            'no ip pim bfd',
-            'ip pim ssm range none',
-        ])
-
-    def test_nxos_pim_3(self):
-        # bfd None (disable)-> enable
-        self.get_config.return_value = None
-        set_module_args(dict(bfd='enable'))
-        self.execute_module(changed=True, commands=['ip pim bfd'])
-
-        # bfd None (disable) -> disable
-        set_module_args(dict(bfd='disable'))
-        self.execute_module(changed=False)
-
-        # ssm None to 'default'
-        set_module_args(dict(ssm_range='default'))
-        self.execute_module(changed=False)
-
-    def test_nxos_pim_4(self):
-        # SSM 'none'
-        self.get_config.return_value = load_fixture('nxos_pim', 'config.cfg')
-        set_module_args(dict(ssm_range='none'))
-        self.execute_module(changed=True, commands=['ip pim ssm range none'])
-
-    def test_nxos_pim_5(self):
-        # SSM 'default'
-        self.get_config.return_value = load_fixture('nxos_pim', 'config.cfg')
-        set_module_args(dict(ssm_range='default'))
-        self.execute_module(changed=True, commands=['no ip pim ssm range none'])
-
-        # SSM 'default' idempotence
-        self.get_config.return_value = None
-        set_module_args(dict(ssm_range='default'))
-        self.execute_module(changed=False)
-
-    def test_nxos_pim_6(self):
-        # Idempotence
-        self.get_config.return_value = load_fixture('nxos_pim', 'config.cfg')
-        set_module_args(dict(bfd='enable', ssm_range='127.0.0.0/31'))
-        self.execute_module(changed=False, commands=[])
diff --git a/test/units/modules/network/nxos/test_nxos_pim_interface.py b/test/units/modules/network/nxos/test_nxos_pim_interface.py
deleted file mode 100644
index 0248d77401..0000000000
--- a/test/units/modules/network/nxos/test_nxos_pim_interface.py
+++ /dev/null
@@ -1,249 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_pim_interface
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosIPInterfaceModule(TestNxosModule):
-
-    module = nxos_pim_interface
-
-    def setUp(self):
-        super(TestNxosIPInterfaceModule, self).setUp()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_pim_interface.get_config')
-        self.get_config = self.mock_get_config.start()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_pim_interface.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_run_commands = patch('ansible.modules.network.nxos.nxos_pim_interface.run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-    def tearDown(self):
-        super(TestNxosIPInterfaceModule, self).tearDown()
-        self.mock_get_config.stop()
-        self.mock_load_config.stop()
-        self.mock_run_commands.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        module_name = self.module.__name__.rsplit('.', 1)[1]
-
-        def load_from_file(*args, **kwargs):
-            module, commands = args
-            output = list()
-
-            for command in commands:
-                if type(command) == dict:
-                    command = command['command']
-                filename = str(command).split(' | ')[0].replace(' ', '_').replace('/', '_')
-                output.append(load_fixture(module_name, filename))
-            return output
-
-        self.get_config.return_value = load_fixture(module_name, 'config.cfg')
-        self.load_config.return_value = None
-        self.run_commands.side_effect = load_from_file
-
-    def test_nxos_pim_interface_present(self):
-        set_module_args(dict(interface='eth2/1', dr_prio=10, hello_interval=40, sparse=True, border=False))
-        self.execute_module(
-            changed=True,
-            commands=[
-                'interface eth2/1', 'ip pim dr-priority 10', 'ip pim hello-interval 40000',
-                'ip pim sparse-mode']
-        )
-
-    def test_nxos_pim_interface_jp(self):
-        set_module_args(dict(
-            interface='eth2/1', jp_policy_in='JPIN', jp_policy_out='JPOUT',
-            jp_type_in='routemap', jp_type_out='routemap',
-        ))
-        self.execute_module(
-            changed=True,
-            commands=['interface eth2/1', 'ip pim jp-policy JPOUT out',
-                      'ip pim jp-policy JPIN in']
-        )
-
-    def test_nxos_pim_interface_default(self):
-        set_module_args(dict(interface='eth2/1', state='default'))
-        self.execute_module(
-            changed=False,
-            commands=[]
-        )
-
-    def test_nxos_pim_interface_ip_absent(self):
-        set_module_args(dict(interface='eth2/1', state='absent'))
-        self.execute_module(changed=False, commands=[])
-
-
-class TestNxosPimInterfaceBfdModule(TestNxosModule):
-
-    module = nxos_pim_interface
-
-    def setUp(self):
-        super(TestNxosPimInterfaceBfdModule, self).setUp()
-
-        self.mock_get_interface_mode = patch('ansible.modules.network.nxos.nxos_pim_interface.get_interface_mode')
-        self.get_interface_mode = self.mock_get_interface_mode.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_pim_interface.get_config')
-        self.get_config = self.mock_get_config.start()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_pim_interface.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_run_commands = patch('ansible.modules.network.nxos.nxos_pim_interface.run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-    def tearDown(self):
-        super(TestNxosPimInterfaceBfdModule, self).tearDown()
-        self.mock_get_interface_mode.stop()
-        self.mock_get_config.stop()
-        self.mock_load_config.stop()
-        self.mock_run_commands.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.load_config.return_value = None
-
-    def test_bfd_1(self):
-        # default (None) -> enable
-        self.get_config.return_value = None
-        set_module_args(dict(interface='eth2/1', bfd='enable'))
-        self.execute_module(
-            changed=True,
-            commands=[
-                'interface eth2/1',
-                'ip pim bfd-instance',
-            ])
-
-        # default (None) -> disable
-        set_module_args(dict(interface='eth2/1', bfd='disable'))
-        self.execute_module(
-            changed=True,
-            commands=[
-                'interface eth2/1',
-                'ip pim bfd-instance disable',
-            ])
-
-        # default (None) -> default (None) (idempotence)
-        set_module_args(dict(interface='eth2/1', bfd='default'))
-        self.execute_module(changed=False,)
-
-        # default (None) -> interface state 'default'
-        set_module_args(dict(interface='Ethernet9/3', state='default'))
-        self.execute_module(changed=False,)
-
-        # default (None) -> interface state 'absent'
-        set_module_args(dict(interface='Ethernet9/3', state='absent'))
-        self.execute_module(changed=False,)
-
-    def test_bfd_2(self):
-        # From disable
-        self.get_config.return_value = '''
-            interface Ethernet9/2
-              ip pim bfd-instance disable
-        '''
-        # disable -> enable
-        set_module_args(dict(interface='Ethernet9/2', bfd='enable'))
-        self.execute_module(
-            changed=True,
-            commands=[
-                'interface Ethernet9/2',
-                'ip pim bfd-instance',
-            ])
-
-        # disable -> disable (idempotence)
-        set_module_args(dict(interface='Ethernet9/2', bfd='disable'))
-        self.execute_module(changed=False,)
-
-        # disable -> default (None)
-        set_module_args(dict(interface='Ethernet9/2', bfd='default'))
-        self.execute_module(
-            changed=True,
-            commands=[
-                'interface Ethernet9/2',
-                'no ip pim bfd-instance',
-            ])
-        # disable -> interface state 'default'
-        set_module_args(dict(interface='Ethernet9/3', state='default'))
-        self.execute_module(
-            changed=True,
-            commands=[
-                'interface Ethernet9/3',
-                'no ip pim bfd-instance',
-            ])
-
-        # disable -> interface state 'absent'
-        set_module_args(dict(interface='Ethernet9/3', state='absent'))
-        self.execute_module(
-            changed=True,
-            commands=[
-                'interface Ethernet9/3',
-                'no ip pim bfd-instance',
-            ])
-
-    def test_bfd_3(self):
-        # From enable
-        self.get_config.return_value = '''
-            interface Ethernet9/2
-              ip pim bfd-instance
-        '''
-        # enable -> disabled
-        set_module_args(dict(interface='Ethernet9/3', bfd='disable'))
-        self.execute_module(
-            changed=True,
-            commands=[
-                'interface Ethernet9/3',
-                'ip pim bfd-instance disable',
-            ])
-
-        # enable -> enable (idempotence)
-        set_module_args(dict(interface='Ethernet9/3', bfd='enable'))
-        self.execute_module(changed=False,)
-
-        # enable -> default (None)
-        set_module_args(dict(interface='Ethernet9/3', bfd='default'))
-        self.execute_module(
-            changed=True,
-            commands=[
-                'interface Ethernet9/3',
-                'no ip pim bfd-instance',
-            ])
-
-        # enable -> interface state 'default'
-        set_module_args(dict(interface='Ethernet9/3', state='default'))
-        self.execute_module(
-            changed=True,
-            commands=[
-                'interface Ethernet9/3',
-                'no ip pim bfd-instance',
-            ])
-
-        # enable -> interface state 'absent'
-        set_module_args(dict(interface='Ethernet9/3', state='absent'))
-        self.execute_module(
-            changed=True,
-            commands=[
-                'interface Ethernet9/3',
-                'no ip pim bfd-instance',
-            ])
diff --git a/test/units/modules/network/nxos/test_nxos_pim_rp_address.py b/test/units/modules/network/nxos/test_nxos_pim_rp_address.py
deleted file mode 100644
index f6e8919daf..0000000000
--- a/test/units/modules/network/nxos/test_nxos_pim_rp_address.py
+++ /dev/null
@@ -1,63 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_pim_rp_address
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosPimRpAddressModule(TestNxosModule):
-
-    module = nxos_pim_rp_address
-
-    def setUp(self):
-        super(TestNxosPimRpAddressModule, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_pim_rp_address.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_pim_rp_address.get_config')
-        self.get_config = self.mock_get_config.start()
-
-    def tearDown(self):
-        super(TestNxosPimRpAddressModule, self).tearDown()
-        self.mock_load_config.stop()
-        self.mock_get_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.get_config.return_value = load_fixture('nxos_pim_rp_address', 'config.cfg')
-        self.load_config.return_value = None
-
-    def test_nxos_pim_rp_address(self):
-        set_module_args(dict(rp_address='5.6.7.8'))
-        self.execute_module(changed=True, commands=['ip pim rp-address 5.6.7.8'])
-
-    def test_nxos_pim_rp_address_no_change(self):
-        set_module_args(dict(rp_address='1.2.3.4'))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_pim_rp_address_absent(self):
-        set_module_args(dict(rp_address='1.2.3.4', state='absent'))
-        self.execute_module(changed=True, commands=['no ip pim rp-address 1.2.3.4'])
-
-    def test_nxos_pim_rp_address_absent_no_change(self):
-        set_module_args(dict(rp_address='5.6.7.8', state='absent'))
-        self.execute_module(changed=False, commands=[])
diff --git a/test/units/modules/network/nxos/test_nxos_static_route.py b/test/units/modules/network/nxos/test_nxos_static_route.py
deleted file mode 100644
index cb9d13cc1a..0000000000
--- a/test/units/modules/network/nxos/test_nxos_static_route.py
+++ /dev/null
@@ -1,79 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_static_route
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosStaticRouteModule(TestNxosModule):
-
-    module = nxos_static_route
-
-    def setUp(self):
-        super(TestNxosStaticRouteModule, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_static_route.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_static_route.get_config')
-        self.get_config = self.mock_get_config.start()
-
-    def tearDown(self):
-        super(TestNxosStaticRouteModule, self).tearDown()
-        self.mock_load_config.stop()
-        self.mock_get_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.get_config.return_value = load_fixture('', 'nxos_static_route.cfg')
-        self.load_config.return_value = None
-
-    def test_nxos_static_route_present(self):
-        set_module_args(dict(prefix='192.168.20.64/24', next_hop='192.0.2.3'))
-        self.execute_module(changed=True, commands=['ip route 192.168.20.0/24 192.0.2.3'])
-
-    def test_nxos_static_route_present_no_defaults(self):
-        set_module_args(dict(prefix='192.168.20.64/24', next_hop='192.0.2.3',
-                             route_name='testing', pref=100))
-        self.execute_module(changed=True, commands=['ip route 192.168.20.0/24 192.0.2.3 name testing 100'])
-
-    def test_nxos_static_route_present_vrf(self):
-        set_module_args(dict(prefix='192.168.20.64/24', next_hop='192.0.2.3', vrf='test'))
-        self.execute_module(changed=True, sort=False, commands=['vrf context test', 'ip route 192.168.20.0/24 192.0.2.3'])
-
-    def test_nxos_static_route_no_change(self):
-        set_module_args(dict(prefix='10.10.30.64/24', next_hop='1.2.4.8'))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_static_route_absent(self):
-        set_module_args(dict(prefix='10.10.30.12/24', next_hop='1.2.4.8', state='absent'))
-        self.execute_module(changed=True, commands=['no ip route 10.10.30.0/24 1.2.4.8'])
-
-    def test_nxos_static_route_absent_no_change(self):
-        set_module_args(dict(prefix='192.168.20.6/24', next_hop='192.0.2.3', state='absent'))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_static_route_absent_vrf(self):
-        set_module_args(dict(prefix='10.11.12.13/14', next_hop='15.16.17.18', vrf='test', state='absent'))
-        self.execute_module(
-            changed=True, sort=False,
-            commands=['vrf context test', 'no ip route 10.8.0.0/14 15.16.17.18']
-        )
diff --git a/test/units/modules/network/nxos/test_nxos_system.py b/test/units/modules/network/nxos/test_nxos_system.py
deleted file mode 100644
index 6f38dd3893..0000000000
--- a/test/units/modules/network/nxos/test_nxos_system.py
+++ /dev/null
@@ -1,130 +0,0 @@
-#
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_system
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosSystemModule(TestNxosModule):
-
-    module = nxos_system
-
-    def setUp(self):
-        super(TestNxosSystemModule, self).setUp()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_system.get_config')
-        self.get_config = self.mock_get_config.start()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_system.load_config')
-        self.load_config = self.mock_load_config.start()
-
-    def tearDown(self):
-        super(TestNxosSystemModule, self).tearDown()
-        self.mock_get_config.stop()
-        self.mock_load_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.get_config.return_value = load_fixture('', 'nxos_system_config.cfg')
-        self.load_config.return_value = None
-
-    def test_nxos_system_hostname_changed(self):
-        set_module_args(dict(hostname='foo'))
-        commands = ['hostname foo']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_system_domain_lookup(self):
-        set_module_args(dict(domain_lookup=True))
-        commands = ['ip domain-lookup']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_system_missing_vrf(self):
-        domain_name = dict(name='example.com', vrf='example')
-        set_module_args(dict(domain_name=domain_name))
-        self.execute_module(failed=True)
-
-    def test_nxos_system_domain_name(self):
-        set_module_args(dict(domain_name=['example.net']))
-        commands = ['no ip domain-name ansible.com',
-                    'vrf context management', 'no ip domain-name eng.ansible.com', 'exit',
-                    'ip domain-name example.net']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_system_domain_name_complex(self):
-        domain_name = dict(name='example.net', vrf='management')
-        set_module_args(dict(domain_name=[domain_name]))
-        commands = ['no ip domain-name ansible.com',
-                    'vrf context management', 'no ip domain-name eng.ansible.com', 'exit',
-                    'vrf context management', 'ip domain-name example.net', 'exit']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_system_domain_search(self):
-        set_module_args(dict(domain_search=['example.net']))
-        commands = ['vrf context management', 'no ip domain-list ansible.com', 'exit',
-                    'vrf context management', 'no ip domain-list redhat.com', 'exit',
-                    'no ip domain-list ansible.com', 'no ip domain-list redhat.com',
-                    'ip domain-list example.net']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_system_domain_search_complex(self):
-        domain_search = dict(name='example.net', vrf='management')
-        set_module_args(dict(domain_search=[domain_search]))
-        commands = ['vrf context management', 'no ip domain-list ansible.com', 'exit',
-                    'vrf context management', 'no ip domain-list redhat.com', 'exit',
-                    'no ip domain-list ansible.com', 'no ip domain-list redhat.com',
-                    'vrf context management', 'ip domain-list example.net', 'exit']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_system_name_servers(self):
-        set_module_args(dict(name_servers=['1.2.3.4', '8.8.8.8']))
-        commands = ['no ip name-server 172.26.1.1',
-                    'vrf context management', 'no ip name-server 8.8.8.8', 'exit',
-                    'vrf context management', 'no ip name-server 172.26.1.1', 'exit',
-                    'ip name-server 1.2.3.4']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_system_name_servers_complex(self):
-        name_servers = dict(server='1.2.3.4', vrf='management')
-        set_module_args(dict(name_servers=[name_servers]))
-        commands = ['no ip name-server 8.8.8.8', 'no ip name-server 172.26.1.1',
-                    'vrf context management', 'no ip name-server 8.8.8.8', 'exit',
-                    'vrf context management', 'no ip name-server 172.26.1.1', 'exit',
-                    'vrf context management', 'ip name-server 1.2.3.4', 'exit']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_system_system_mtu(self):
-        set_module_args(dict(system_mtu=2000))
-        commands = ['system jumbomtu 2000']
-        self.execute_module(changed=True, commands=commands)
-
-    def test_nxos_system_state_absent(self):
-        set_module_args(dict(state='absent'))
-        commands = ['no hostname', 'no ip domain-name ansible.com',
-                    'vrf context management', 'no ip domain-name eng.ansible.com', 'exit',
-                    'no ip domain-list ansible.com', 'no ip domain-list redhat.com',
-                    'vrf context management', 'no ip domain-list ansible.com', 'exit',
-                    'vrf context management', 'no ip domain-list redhat.com', 'exit',
-                    'no ip name-server 8.8.8.8', 'no ip name-server 172.26.1.1',
-                    'vrf context management', 'no ip name-server 8.8.8.8', 'exit',
-                    'vrf context management', 'no ip name-server 172.26.1.1', 'exit',
-                    'no system jumbomtu']
-        self.execute_module(changed=True, commands=commands)
diff --git a/test/units/modules/network/nxos/test_nxos_telemetry.py b/test/units/modules/network/nxos/test_nxos_telemetry.py
deleted file mode 100644
index a752ab8615..0000000000
--- a/test/units/modules/network/nxos/test_nxos_telemetry.py
+++ /dev/null
@@ -1,1256 +0,0 @@
-# (c) 2019 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from units.modules.utils import AnsibleFailJson
-from ansible.modules.network.nxos import nxos_telemetry
-from ansible.module_utils.network.nxos.nxos import NxosCmdRef
-from ansible.module_utils.network.nxos.config.telemetry.telemetry import Telemetry
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-# TBD: These imports / import checks are only needed as a workaround for
-# shippable, which fails this test due to import yaml & import ordereddict.
-import pytest
-from ansible.module_utils.network.nxos.nxos import nxosCmdRef_import_check
-msg = nxosCmdRef_import_check()
-ignore_provider_arg = True
-
-
-@pytest.mark.skipif(len(msg), reason=msg)
-class TestNxosTelemetryModule(TestNxosModule):
-
-    module = nxos_telemetry
-
-    def setUp(self):
-        super(TestNxosTelemetryModule, self).setUp()
-
-        self.mock_FACT_LEGACY_SUBSETS = patch('ansible.module_utils.network.nxos.facts.facts.FACT_LEGACY_SUBSETS')
-        self.FACT_LEGACY_SUBSETS = self.mock_FACT_LEGACY_SUBSETS.start()
-
-        self.mock_get_resource_connection_config = patch('ansible.module_utils.network.common.cfg.base.get_resource_connection')
-        self.get_resource_connection_config = self.mock_get_resource_connection_config.start()
-
-        self.mock_get_resource_connection_facts = patch('ansible.module_utils.network.common.facts.facts.get_resource_connection')
-        self.get_resource_connection_facts = self.mock_get_resource_connection_facts.start()
-
-        self.mock_edit_config = patch('ansible.module_utils.network.nxos.config.telemetry.telemetry.Telemetry.edit_config')
-        self.edit_config = self.mock_edit_config.start()
-
-        self.mock_execute_show_command = patch('ansible.module_utils.network.nxos.nxos.NxosCmdRef.execute_show_command')
-        self.execute_show_command = self.mock_execute_show_command.start()
-
-        self.mock_get_platform_shortname = patch('ansible.module_utils.network.nxos.nxos.NxosCmdRef.get_platform_shortname')
-        self.get_platform_shortname = self.mock_get_platform_shortname.start()
-
-    def tearDown(self):
-        super(TestNxosTelemetryModule, self).tearDown()
-        self.mock_FACT_LEGACY_SUBSETS.stop()
-        self.mock_get_resource_connection_config.stop()
-        self.mock_get_resource_connection_facts.stop()
-        self.mock_edit_config.stop()
-        self.mock_execute_show_command.stop()
-        self.get_platform_shortname.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.mock_FACT_LEGACY_SUBSETS.return_value = dict()
-        self.get_resource_connection_config.return_value = 'Connection'
-        self.get_resource_connection_facts.return_value = 'Connection'
-        self.edit_config.return_value = None
-
-    # ---------------------------
-    # Telemetry Global Test Cases
-    # ---------------------------
-
-    def test_tms_global_merged_n9k(self):
-        # Assumes feature telemetry is disabled
-        # TMS global config is not present.
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args(dict(
-            config=dict(
-                certificate={'key': '/bootflash/sample.key', 'hostname': 'server.example.com'},
-                compression='gzip',
-                source_interface='Ethernet2/1',
-                vrf='blue',
-            )
-        ), ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'certificate /bootflash/sample.key server.example.com',
-            'destination-profile',
-            'use-compression gzip',
-            'source-interface Ethernet2/1',
-            'use-vrf blue'
-        ])
-
-    def test_tms_global_checkmode_n9k(self):
-        # Assumes feature telemetry is disabled
-        # TMS global config is not present.
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args(dict(
-            _ansible_check_mode=True,
-            config=dict(
-                certificate={'key': '/bootflash/sample.key', 'hostname': 'server.example.com'},
-                compression='gzip',
-                source_interface='Ethernet2/1',
-                vrf='blue',
-            )
-        ), ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'certificate /bootflash/sample.key server.example.com',
-            'destination-profile',
-            'use-compression gzip',
-            'source-interface Ethernet2/1',
-            'use-vrf blue'
-        ])
-
-    def test_tms_global_merged2_n9k(self):
-        # Assumes feature telemetry is disabled
-        # TMS global config is not present.
-        # Configure only vrf
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args(dict(
-            config=dict(
-                vrf='blue',
-            )
-        ), ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'destination-profile',
-            'use-vrf blue'
-        ])
-
-    def test_tms_global_idempotent_n9k(self):
-        # Assumes feature telemetry is enabled
-        # TMS global config is present.
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args(dict(
-            config=dict(
-                certificate={'key': '/bootflash/server.key', 'hostname': 'localhost'},
-                compression='gzip',
-                source_interface='loopback55',
-                vrf='management',
-            )
-        ), ignore_provider_arg)
-        self.execute_module(changed=False)
-
-    def test_tms_global_change_cert_n9k(self):
-        # Assumes feature telemetry is enabled
-        # TMS global config is present
-        # Change certificate
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args(dict(
-            config=dict(
-                certificate={'key': '/bootflash/server.key', 'hostname': 'my_host'},
-                compression='gzip',
-                source_interface='loopback55',
-                vrf='management',
-            )
-        ), ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'telemetry',
-            'certificate /bootflash/server.key my_host'
-        ])
-
-    def test_tms_global_change_interface_n9k(self):
-        # Assumes feature telemetry is enabled
-        # TMS global config is present
-        # Change interface
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args(dict(
-            config=dict(
-                certificate={'key': '/bootflash/server.key', 'hostname': 'localhost'},
-                compression='gzip',
-                source_interface='Ethernet8/1',
-                vrf='management',
-            )
-        ), ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'telemetry',
-            'destination-profile',
-            'source-interface Ethernet8/1'
-        ])
-
-    def test_tms_global_change_several_n9k(self):
-        # Assumes feature telemetry is enabled
-        # TMS global config is present
-        # Change source_interface, vrf and cert
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args(dict(
-            config=dict(
-                certificate={'key': '/bootflash/server_5.key', 'hostname': 'my_host'},
-                compression='gzip',
-                source_interface='Ethernet8/1',
-                vrf='blue',
-            )
-        ), ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'telemetry',
-            'certificate /bootflash/server_5.key my_host',
-            'destination-profile',
-            'source-interface Ethernet8/1',
-            'use-vrf blue',
-        ])
-
-    # ------------------------------
-    # Telemetry DestGroup Test Cases
-    # ------------------------------
-
-    def test_tms_destgroup_input_validation_1(self):
-        # Mandatory parameter 'id' missing.
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'destination': {'ip': '192.168.1.1', 'port': '5001', 'protocol': 'GRPC', 'encoding': 'GPB'}}
-        ], 'destination_groups')
-        set_module_args(args, ignore_provider_arg)
-        with pytest.raises(AnsibleFailJson) as errinfo:
-            self.execute_module()
-        testdata = errinfo.value.args[0]
-        assert 'Parameter <id> under <destination_groups> is required' in str(testdata['msg'])
-        assert testdata['failed']
-
-    def test_tms_destgroup_input_validation_2(self):
-        # Parameter 'destination' is not a dict.
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '88',
-             'destination': '192.168.1.1',
-             }
-        ], 'destination_groups')
-        set_module_args(args, ignore_provider_arg)
-        with pytest.raises(AnsibleFailJson) as errinfo:
-            self.execute_module()
-        testdata = errinfo.value.args[0]
-        assert "Parameter <destination> under <destination_groups> must be a dict" in str(testdata['msg'])
-        assert testdata['failed']
-
-    def test_tms_destgroup_input_validation_3(self):
-        # Parameter 'destination' is not a dict.
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '88',
-             'ip': '192.168.1.1',
-             'port': '5001'
-             }
-        ], 'destination_groups')
-        set_module_args(args, ignore_provider_arg)
-        with pytest.raises(AnsibleFailJson) as errinfo:
-            self.execute_module()
-        testdata = errinfo.value.args[0]
-        assert 'Playbook entry contains unrecongnized parameters' in str(testdata['msg'])
-        assert testdata['failed']
-
-    def test_tms_destgroup_merged_n9k(self):
-        # Assumes feature telemetry is enabled
-        # TMS destgroup config is not present.
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '88',
-             'destination': {'ip': '192.168.1.1', 'port': '5001', 'protocol': 'GRPC', 'encoding': 'GPB'},
-             },
-            {'id': '88',
-             'destination': {'ip': '192.168.1.2', 'port': '6001', 'protocol': 'GRPC', 'encoding': 'GPB'},
-             },
-            {'id': '99',
-             'destination': {'ip': '192.168.1.2', 'port': '6001', 'protocol': 'GRPC', 'encoding': 'GPB'},
-             },
-            {'id': '99',
-             'destination': {'ip': '192.168.1.1', 'port': '5001', 'protocol': 'GRPC', 'encoding': 'GPB'},
-             },
-        ], 'destination_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'destination-group 88',
-            'ip address 192.168.1.1 port 5001 protocol grpc encoding gpb',
-            'ip address 192.168.1.2 port 6001 protocol grpc encoding gpb',
-            'destination-group 99',
-            'ip address 192.168.1.2 port 6001 protocol grpc encoding gpb',
-            'ip address 192.168.1.1 port 5001 protocol grpc encoding gpb',
-        ])
-
-    def test_tms_destgroup_checkmode_n9k(self):
-        # Assumes feature telemetry is enabled
-        # TMS destgroup config is not present.
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '88',
-             'destination': {'ip': '192.168.1.1', 'port': '5001', 'protocol': 'GRPC', 'encoding': 'GPB'},
-             }
-        ], 'destination_groups', state='merged', check_mode=True)
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'destination-group 88',
-            'ip address 192.168.1.1 port 5001 protocol grpc encoding gpb'
-        ])
-
-    def test_tms_destgroup_merged2_n9k(self):
-        # Assumes feature telemetry is enabled
-        # TMS destgroup config is not present.
-        # Configure only identifier
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '88'}
-        ], 'destination_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'destination-group 88',
-        ])
-
-    def test_tms_destgroup_idempotent_n9k(self):
-        # Assumes feature telemetry is enabled
-        # TMS destgroup config is not present.
-        # Configure only identifier
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '2',
-             'destination': {'ip': '192.168.0.2', 'port': '60001', 'protocol': 'grpc', 'encoding': 'gpb'},
-             }
-        ], 'destination_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=False)
-
-    def test_tms_destgroup_idempotent2_n9k(self):
-        # Assumes feature telemetry is enabled
-        # TMS destgroup config is not present.
-        # Configure only identifier
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '2'}
-        ], 'destination_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=False)
-
-    def test_tms_destgroup_merged_aggregate_idempotent_n9k(self):
-        # Assumes feature telemetry is enabled
-        # TMS destgroup config is present.
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '2',
-             'destination': {'ip': '192.168.0.1', 'port': '50001', 'protocol': 'gRPC', 'encoding': 'gpb'}
-             },
-            {'id': '10',
-             'destination': {'ip': '192.168.0.1', 'port': '50001', 'protocol': 'gRPC', 'encoding': 'gpb'}
-             }
-        ], 'destination_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=False)
-
-    def test_tms_destgroup_change_n9k(self):
-        # TMS destgroup config is not present.
-        # Change protocol and encoding for dest group 2
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '2',
-             'destination': {'ip': '192.168.0.1', 'port': '50001', 'protocol': 'http', 'encoding': 'JSON'}
-             },
-            {'id': '10',
-             'destination': {'ip': '192.168.0.1', 'port': '50001', 'protocol': 'gRPC', 'encoding': 'gpb'}
-             }
-        ], 'destination_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'telemetry', 'destination-group 2',
-            'ip address 192.168.0.1 port 50001 protocol http encoding json'
-        ])
-
-    def test_tms_destgroup_add_n9k(self):
-        # TMS destgroup config is not present.
-        # Add destinations to destgroup 10
-        # Add new destgroup 55 and 56
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '10',
-             'destination': {'ip': '192.168.0.1', 'port': '50001', 'protocol': 'gRPC', 'encoding': 'gpb'}
-             },
-            {'id': '10',
-             'destination': {'ip': '192.168.0.10', 'port': '50001', 'protocol': 'gRPC', 'encoding': 'gpb'}
-             },
-            {'id': '55',
-             'destination': {'ip': '192.168.0.2', 'port': '50001', 'protocol': 'gRPC', 'encoding': 'gpb'}
-             },
-            {'id': '56'},
-        ], 'destination_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'telemetry',
-            'destination-group 10',
-            'ip address 192.168.0.10 port 50001 protocol grpc encoding gpb',
-            'destination-group 55',
-            'ip address 192.168.0.2 port 50001 protocol grpc encoding gpb',
-            'destination-group 56'
-        ])
-
-    # --------------------------------
-    # Telemetry SensorGroup Test Cases
-    # --------------------------------
-
-    def test_tms_sensorgroup_merged_n9k(self):
-        # Assumes feature telemetry is enabled
-        # TMS sensorgroup config is not present.
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        td55_name = 'sys/bgp/inst/dom-default/peer-[10.10.10.11]/ent-[10.10.10.11]'
-        td55_fc = 'or(eq(ethpmPhysIf.operSt,"down"),eq(ethpmPhysIf.operSt,"up"))'
-        args = build_args([
-            {'id': '2',
-             'data_source': 'NX-API',
-             'path': {'name': 'sys/bgp', 'depth': 0, 'query_condition': 'foo', 'filter_condition': 'foo'},
-             },
-            {'id': '2',
-             'data_source': 'NX-API',
-             'path': {'name': 'sys/bgp/inst', 'depth': 'unbounded', 'query_condition': 'foo', 'filter_condition': 'foo'},
-             },
-            {'id': '55',
-             'data_source': 'DME',
-             'path': {'name': td55_name, 'depth': 0, 'query_condition': 'foo', 'filter_condition': 'foo'},
-             },
-            {'id': '55',
-             'data_source': 'DME',
-             'path': {'name': 'sys/ospf', 'depth': 0, 'query_condition': 'foo', 'filter_condition': td55_fc},
-             },
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'sensor-group 2',
-            'data-source NX-API',
-            'path sys/bgp depth 0 query-condition foo filter-condition foo',
-            'path sys/bgp/inst depth unbounded query-condition foo filter-condition foo',
-            'sensor-group 55',
-            'data-source DME',
-            'path sys/bgp/inst/dom-default/peer-[10.10.10.11]/ent-[10.10.10.11] depth 0 query-condition foo filter-condition foo',
-            'path sys/ospf depth 0 query-condition foo filter-condition or(eq(ethpmPhysIf.operSt,"down"),eq(ethpmPhysIf.operSt,"up"))',
-        ])
-
-    def test_tms_sensorgroup_input_validation_1(self):
-        # Mandatory parameter 'id' missing.
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'data_source': 'DME',
-             'path': {'name': 'sys/bgp', 'depth': 0, 'query_condition': 'query_condition_xyz', 'filter_condition': 'filter_condition_xyz'},
-             },
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        with pytest.raises(AnsibleFailJson) as errinfo:
-            self.execute_module()
-        testdata = errinfo.value.args[0]
-        assert 'Parameter <id> under <sensor_groups> is required' in str(testdata['msg'])
-        assert testdata['failed']
-
-    def test_tms_sensorgroup_input_validation_2(self):
-        # Path present but mandatory 'name' key is not
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '77',
-             'data_source': 'DME',
-             'path': {'depth': 0, 'query_condition': 'query_condition_xyz', 'filter_condition': 'filter_condition_xyz'},
-             },
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        with pytest.raises(AnsibleFailJson) as errinfo:
-            self.execute_module()
-        testdata = errinfo.value.args[0]
-        assert 'Parameter <path> under <sensor_groups> requires <name> key' in str(testdata['msg'])
-        assert testdata['failed']
-
-    def test_tms_sensorgroup_resource_key_n9k(self):
-        # TMS sensorgroup config is not present.
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '77'}
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'sensor-group 77',
-        ])
-
-    def test_tms_sensorgroup_merged_variable_args1_n9k(self):
-        # TMS sensorgroup config is not present.
-        # Only path key name provided
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '77',
-             'data_source': 'DME',
-             'path': {'name': 'sys/bgp'},
-             },
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'sensor-group 77',
-            'data-source DME',
-            'path sys/bgp',
-        ])
-
-    def test_tms_sensorgroup_merged_variable_args2_n9k(self):
-        # TMS sensorgroup config is not present.
-        # Only path keys name and depth provided
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '77',
-             'data_source': 'DME',
-             'path': {'name': 'sys/bgp', 'depth': 0},
-             },
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'sensor-group 77',
-            'data-source DME',
-            'path sys/bgp depth 0',
-        ])
-
-    def test_tms_sensorgroup_merged_variable_args3_n9k(self):
-        # TMS sensorgroup config is not present.
-        # Only path keys name, depth and query_condition provided
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '77',
-             'data_source': 'DME',
-             'path': {'name': 'sys/bgp', 'depth': 0, 'query_condition': 'query_condition_xyz'},
-             },
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'sensor-group 77',
-            'data-source DME',
-            'path sys/bgp depth 0 query-condition query_condition_xyz',
-        ])
-
-    def test_tms_sensorgroup_merged_variable_args4_n9k(self):
-        # TMS sensorgroup config is not present.
-        # Only path keys name, depth and filter_condition provided
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '77',
-             'data_source': 'DME',
-             'path': {'name': 'sys/bgp', 'depth': 0, 'filter_condition': 'filter_condition_xyz'},
-             },
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'sensor-group 77',
-            'data-source DME',
-            'path sys/bgp depth 0 filter-condition filter_condition_xyz',
-        ])
-
-    def test_tms_sensorgroup_merged_idempotent_n9k(self):
-        # Assumes feature telemetry is enabled
-        # TMS sensorgroup config is not present.
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '2',
-             'data_source': 'DME',
-             'path': {'name': 'sys/ospf', 'depth': 0, 'query_condition': 'qc', 'filter_condition': 'fc'},
-             },
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=False)
-
-    def test_tms_sensorgroup_quotes_merged_idempotent_n9k(self):
-        # Assumes feature telemetry is enabled
-        # TMS sensorgroup config is present with quotes in NX-API path.
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K_SGs.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '2',
-             'data_source': 'NX-API',
-             'path': {'name': '"show mac address-table count"', 'depth': 2},
-             },
-            {'id': '3',
-             'data_source': 'NX-API',
-             'path': {'name': '"show interface ethernet1/1-52"'},
-             },
-            {'id': '1',
-             'path': {'name': 'sys/procsys', 'depth': 1},
-             },
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=False)
-
-    def test_tms_sensorgroup_vxlan_idempotent_n9k(self):
-        # TMS sensorgroup config present.
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '56',
-             'data_source': 'DME',
-             'path': {'name': 'vxlan'},
-             },
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=False)
-
-    def test_tms_sensorgroup_idempotent_variable1_n9k(self):
-        # TMS sensorgroup config is present with path key name.
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '2',
-             'data_source': 'DME',
-             'path': {'name': 'sys/bgp/inst/dom-default/peer-[10.10.10.11]/ent-[10.10.10.11]'},
-             },
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=False)
-
-    def test_tms_sensorgroup_idempotent_variable2_n9k(self):
-        # TMS sensorgroup config is present with path key name and depth.
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '2',
-             'data_source': 'DME',
-             'path': {'name': 'boo', 'depth': 0},
-             },
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=False)
-
-    def test_tms_sensorgroup_idempotent_resource_key_n9k(self):
-        # TMS sensorgroup config is present resource key only.
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '55'}
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=False)
-
-    def test_tms_sensorgroup_present_path_environment_n9k(self):
-        # TMS sensorgroup config is not present.
-        # Path name 'environment' test
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '77',
-             'data_source': 'YANG',
-             'path': {'name': 'environment'},
-             },
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'sensor-group 77',
-            'data-source YANG',
-            'path environment',
-        ])
-
-    def test_tms_sensorgroup_present_path_interface_n9k(self):
-        # TMS sensorgroup config is not present.
-        # Path name 'interface' test
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '77',
-             'data_source': 'NATIVE',
-             'path': {'name': 'interface'},
-             },
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'sensor-group 77',
-            'data-source NATIVE',
-            'path interface',
-        ])
-
-    def test_tms_sensorgroup_present_path_interface_n9k(self):
-        # TMS sensorgroup config is not present.
-        # Path name 'resources' test
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': '77',
-             'data_source': 'NX-API',
-             'path': {'name': 'resources'},
-             },
-        ], 'sensor_groups')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'sensor-group 77',
-            'data-source NX-API',
-            'path resources',
-        ])
-
-    # ---------------------------------
-    # Telemetry Subscription Test Cases
-    # ---------------------------------
-
-    def test_tms_subscription_merged_n9k(self):
-        # TMS subscription config is not present.
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': 5,
-             'destination_group': 55,
-             'sensor_group': {'id': 1, 'sample_interval': 1000},
-             },
-            {'id': 88,
-             'destination_group': 3,
-             'sensor_group': {'id': 4, 'sample_interval': 2000},
-             },
-        ], 'subscriptions')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'subscription 5',
-            'dst-grp 55',
-            'snsr-grp 1 sample-interval 1000',
-            'subscription 88',
-            'dst-grp 3',
-            'snsr-grp 4 sample-interval 2000'
-        ])
-
-    def test_tms_subscription_merged_idempotent_n9k(self):
-        # TMS subscription config is not present.
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': 3,
-             },
-            {'id': 7,
-             'destination_group': 10,
-             'sensor_group': {'id': 2, 'sample_interval': 1000},
-             },
-            {'id': 5,
-             'destination_group': 2,
-             'sensor_group': {'id': 2, 'sample_interval': 1000},
-             },
-        ], 'subscriptions')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=False)
-
-    def test_tms_subscription_merged_change1_n9k(self):
-        # TMS subscription config present.
-        # Change sample interval for sensor group 2
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': 3,
-             },
-            {'id': 7,
-             'destination_group': 10,
-             'sensor_group': {'id': 2, 'sample_interval': 3000},
-             },
-            {'id': 5,
-             'destination_group': 2,
-             'sensor_group': {'id': 2, 'sample_interval': 1000},
-             },
-        ], 'subscriptions')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'telemetry',
-            'subscription 7',
-            'snsr-grp 2 sample-interval 3000'
-        ])
-
-    def test_tms_subscription_add_n9k(self):
-        # TMS subscription config present.
-        # Add new destination_group and sensor_group to subscription 5
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        args = build_args([
-            {'id': 3,
-             },
-            {'id': 7,
-             'destination_group': 10,
-             'sensor_group': {'id': 2, 'sample_interval': 1000},
-             },
-            {'id': 5,
-             'destination_group': 2,
-             'sensor_group': {'id': 2, 'sample_interval': 1000},
-             },
-            {'id': 5,
-             'destination_group': 7,
-             'sensor_group': {'id': 2, 'sample_interval': 1000},
-             },
-            {'id': 5,
-             'destination_group': 8,
-             'sensor_group': {'id': 9, 'sample_interval': 1000},
-             },
-            {'id': 5,
-             'destination_group': 9,
-             'sensor_group': {'id': 10, 'sample_interval': 1000},
-             },
-        ], 'subscriptions')
-        set_module_args(args, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'telemetry',
-            'subscription 5',
-            'dst-grp 7',
-            'dst-grp 8',
-            'dst-grp 9',
-            'snsr-grp 9 sample-interval 1000',
-            'snsr-grp 10 sample-interval 1000'
-        ])
-
-    def test_telemetry_full_n9k(self):
-        # Assumes feature telemetry is disabled
-        # TMS global config is not present.
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args({
-            'state': 'merged',
-            'config': {
-                'certificate': {'key': '/bootflash/sample.key', 'hostname': 'server.example.com'},
-                'compression': 'gzip',
-                'source_interface': 'Ethernet2/1',
-                'vrf': 'blue',
-                'destination_groups': [
-                    {'id': '88',
-                     'destination': {'ip': '192.168.1.1', 'port': '5001', 'protocol': 'GRPC', 'encoding': 'GPB'},
-                     },
-                    {'id': '88',
-                     'destination': {'ip': '192.168.1.2', 'port': '6001', 'protocol': 'GRPC', 'encoding': 'GPB'},
-                     },
-                    {'id': '99',
-                     'destination': {'ip': '192.168.1.2', 'port': '6001', 'protocol': 'GRPC', 'encoding': 'GPB'},
-                     },
-                    {'id': '99',
-                     'destination': {'ip': '192.168.1.1', 'port': '5001', 'protocol': 'GRPC', 'encoding': 'GPB'},
-                     },
-                ],
-                'sensor_groups': [
-                    {'id': '77',
-                     'data_source': 'DME',
-                     'path': {'name': 'sys/bgp', 'depth': 0, 'query_condition': 'query_condition_xyz', 'filter_condition': 'filter_condition_xyz'},
-                     },
-                    {'id': '99',
-                     'data_source': 'DME',
-                     'path': {'name': 'sys/bgp', 'depth': 0, 'query_condition': 'query_condition_xyz', 'filter_condition': 'filter_condition_xyz'},
-                     },
-                ],
-                'subscriptions': [
-                    {'id': 5,
-                     'destination_group': 88,
-                     'sensor_group': {'id': 77, 'sample_interval': 1000},
-                     },
-                    {'id': 5,
-                     'destination_group': 99,
-                     'sensor_group': {'id': 77, 'sample_interval': 1000},
-                     },
-                    {'id': 88,
-                     'destination_group': 99,
-                     'sensor_group': {'id': 99, 'sample_interval': 2000},
-                     },
-                ],
-            }
-        }, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'feature telemetry',
-            'telemetry',
-            'certificate /bootflash/sample.key server.example.com',
-            'destination-profile',
-            'use-compression gzip',
-            'source-interface Ethernet2/1',
-            'use-vrf blue',
-            'destination-group 88',
-            'ip address 192.168.1.1 port 5001 protocol grpc encoding gpb',
-            'ip address 192.168.1.2 port 6001 protocol grpc encoding gpb',
-            'destination-group 99',
-            'ip address 192.168.1.2 port 6001 protocol grpc encoding gpb',
-            'ip address 192.168.1.1 port 5001 protocol grpc encoding gpb',
-            'sensor-group 77',
-            'data-source DME',
-            'path sys/bgp depth 0 query-condition query_condition_xyz filter-condition filter_condition_xyz',
-            'sensor-group 99',
-            'data-source DME',
-            'path sys/bgp depth 0 query-condition query_condition_xyz filter-condition filter_condition_xyz',
-            'subscription 5',
-            'dst-grp 88',
-            'dst-grp 99',
-            'snsr-grp 77 sample-interval 1000',
-            'subscription 88',
-            'dst-grp 99',
-            'snsr-grp 99 sample-interval 2000'
-        ])
-
-    def test_telemetry_deleted_input_validation_n9k(self):
-        # State is 'deleted' and 'config' key present.
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args(dict(
-            state='deleted',
-            config=dict(
-                certificate={'key': '/bootflash/server.key', 'hostname': 'localhost'},
-                compression='gzip',
-                source_interface='loopback55',
-                vrf='management',
-            )
-        ), ignore_provider_arg)
-        with pytest.raises(AnsibleFailJson) as errinfo:
-            self.execute_module()
-        testdata = errinfo.value.args[0]
-        assert 'Remove config key from playbook when state is <deleted>' in str(testdata['msg'])
-        assert testdata['failed']
-
-    def test_telemetry_deleted_n9k(self):
-        # Assumes feature telemetry is enabled
-        # TMS global config is present.
-        # Make absent with all playbook keys provided
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args(dict(
-            state='deleted',
-        ), ignore_provider_arg)
-        self.execute_module(changed=True, commands=['no telemetry'])
-
-    def test_telemetry_deleted_idempotent_n9k(self):
-        # Assumes feature telemetry is enabled
-        # TMS global config is present.
-        # Make absent with all playbook keys provided
-        self.execute_show_command.return_value = None
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args(dict(
-            state='deleted',
-        ), ignore_provider_arg)
-        self.execute_module(changed=False)
-
-    def test_tms_replaced1_n9k(self):
-        # Assumes feature telemetry is enabled
-        # Modify global config and remove everything else
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args(dict(
-            state='replaced',
-            config=dict(
-                certificate={'key': '/bootflash/sample.key', 'hostname': 'server.example.com'},
-                compression='gzip',
-                vrf='blue',
-            )
-        ), ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'telemetry',
-            'no subscription 3',
-            'no subscription 4',
-            'no subscription 5',
-            'no subscription 6',
-            'no subscription 7',
-            'no sensor-group 2',
-            'no sensor-group 55',
-            'no sensor-group 56',
-            'no destination-group 2',
-            'no destination-group 10',
-            'certificate /bootflash/sample.key server.example.com',
-            'destination-profile',
-            'no source-interface loopback55',
-            'use-vrf blue'
-        ])
-
-    def test_tms_replaced2_n9k(self):
-        # Assumes feature telemetry is enabled
-        # Remove/default all global config
-        # Modify destination-group 10, add 11 and 99, remove 2
-        # Modify sensor-group 55, 56
-        # remove all subscriptions
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args({
-            'state': 'replaced',
-            'config': {
-                'destination_groups': [
-                    {'id': 10,
-                     'destination': {'ip': '192.168.1.1', 'port': '5001', 'protocol': 'GRPC', 'encoding': 'GPB'},
-                     },
-                    {'id': 11,
-                     'destination': {'ip': '192.168.1.2', 'port': '6001', 'protocol': 'GRPC', 'encoding': 'GPB'},
-                     },
-                    {'id': 99,
-                     'destination': {'ip': '192.168.1.2', 'port': '6001', 'protocol': 'GRPC', 'encoding': 'GPB'},
-                     },
-                    {'id': '99',
-                     'destination': {'ip': '192.168.1.1', 'port': '5001', 'protocol': 'GRPC', 'encoding': 'GPB'},
-                     },
-                ],
-                'sensor_groups': [
-                    {'id': 55,
-                     'data_source': 'NX-API',
-                     'path': {'name': 'sys/bgp', 'depth': 0, 'query_condition': 'query_condition_xyz', 'filter_condition': 'filter_condition_xyz'},
-                     },
-                    {'id': '56',
-                     'data_source': 'NX-API',
-                     'path': {'name': 'sys/bgp', 'depth': 0, 'query_condition': 'query_condition_xyz', 'filter_condition': 'filter_condition_xyz'},
-                     },
-                ],
-            }
-        }, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'telemetry',
-            'no subscription 3',
-            'no subscription 5',
-            'no subscription 4',
-            'no subscription 7',
-            'no subscription 6',
-            'sensor-group 56',
-            'no data-source DME',
-            'no path environment',
-            'no path interface',
-            'no path resources',
-            'no path vxlan',
-            'no sensor-group 2',
-            'destination-group 10',
-            'no ip address 192.168.0.1 port 50001 protocol grpc encoding gpb',
-            'no ip address 192.168.0.2 port 60001 protocol grpc encoding gpb',
-            'no destination-group 2',
-            'destination-group 11',
-            'ip address 192.168.1.2 port 6001 protocol grpc encoding gpb',
-            'destination-group 10',
-            'ip address 192.168.1.1 port 5001 protocol grpc encoding gpb',
-            'destination-group 99',
-            'ip address 192.168.1.2 port 6001 protocol grpc encoding gpb',
-            'ip address 192.168.1.1 port 5001 protocol grpc encoding gpb',
-            'sensor-group 55',
-            'data-source NX-API',
-            'path sys/bgp depth 0 query-condition query_condition_xyz filter-condition filter_condition_xyz',
-            'sensor-group 56',
-            'data-source NX-API',
-            'path sys/bgp depth 0 query-condition query_condition_xyz filter-condition filter_condition_xyz',
-            'no certificate /bootflash/server.key localhost',
-            'no destination-profile'
-        ])
-
-    def test_tms_replaced3_n9k(self):
-        # Assumes feature telemetry is enabled
-        # Modify vrf global config, remove default all other global config.
-        # destination-group 2 destination '192.168.0.1' idempotent
-        # destination-group 2 destination '192.168.0.2' remove
-        # remove all other destination-groups
-        # Modify sensor-group 55 and delete all others
-        # Modify subscription 7, add 10 and delete all others
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args({
-            'state': 'replaced',
-            'config': {
-                'vrf': 'blue',
-                'destination_groups': [
-                    {'id': 2,
-                     'destination': {'ip': '192.168.0.1', 'port': 50001, 'protocol': 'GRPC', 'encoding': 'GPB'},
-                     },
-                ],
-                'sensor_groups': [
-                    {'id': 55,
-                     'data_source': 'NX-API',
-                     'path': {'name': 'sys/bgp', 'depth': 0, 'query_condition': 'query_condition_xyz', 'filter_condition': 'filter_condition_xyz'},
-                     },
-                ],
-                'subscriptions': [
-                    {'id': 7,
-                     'destination_group': 10,
-                     'sensor_group': {'id': 55, 'sample_interval': 1000},
-                     },
-                    {'id': 10,
-                     'destination_group': 2,
-                     'sensor_group': {'id': 55, 'sample_interval': 1000},
-                     },
-                ],
-            }
-        }, ignore_provider_arg)
-        self.execute_module(changed=True, commands=[
-            'telemetry',
-            'no subscription 3',
-            'no subscription 5',
-            'no subscription 4',
-            'subscription 7',
-            'no snsr-grp 2 sample-interval 1000',
-            'no subscription 6',
-            'no sensor-group 56',
-            'no sensor-group 2',
-            'no destination-group 10',
-            'destination-group 2',
-            'no ip address 192.168.0.2 port 60001 protocol grpc encoding gpb',
-            'sensor-group 55',
-            'data-source NX-API',
-            'path sys/bgp depth 0 query-condition query_condition_xyz filter-condition filter_condition_xyz',
-            'subscription 10',
-            'dst-grp 2',
-            'snsr-grp 55 sample-interval 1000',
-            'subscription 7',
-            'snsr-grp 55 sample-interval 1000',
-            'no certificate /bootflash/server.key localhost',
-            'destination-profile',
-            'no use-compression gzip',
-            'no source-interface loopback55',
-            'use-vrf blue'
-        ])
-
-    def test_tms_replaced_idempotent_n9k(self):
-        # Assumes feature telemetry is enabled
-        # Modify vrf global config, remove default all other global config.
-        # destination-group 2 destination '192.168.0.1' idempotent
-        # destination-group 2 destination '192.168.0.2' remove
-        # remove all other destination-groups
-        # Modify sensor-group 55 and delete all others
-        # Modify subscription 7, add 10 and delete all others
-        self.execute_show_command.return_value = load_fixture('nxos_telemetry', 'N9K.cfg')
-        self.get_platform_shortname.return_value = 'N9K'
-        set_module_args({
-            'state': 'replaced',
-            'config': {
-                'certificate': {'key': '/bootflash/server.key', 'hostname': 'localhost'},
-                'compression': 'gzip',
-                'vrf': 'management',
-                'source_interface': 'loopback55',
-                'destination_groups': [
-                    {'id': 2,
-                     'destination': {'ip': '192.168.0.1', 'port': 50001, 'protocol': 'GRPC', 'encoding': 'GPB'},
-                     },
-                    {'id': 2,
-                     'destination': {'ip': '192.168.0.2', 'port': 60001, 'protocol': 'GRPC', 'encoding': 'GPB'},
-                     },
-                    {'id': 10,
-                     'destination': {'ip': '192.168.0.1', 'port': 50001, 'protocol': 'GRPC', 'encoding': 'GPB'},
-                     },
-                    {'id': 10,
-                     'destination': {'ip': '192.168.0.2', 'port': 60001, 'protocol': 'GRPC', 'encoding': 'GPB'},
-                     },
-                ],
-                'sensor_groups': [
-                    {'id': 2,
-                     'data_source': 'DME',
-                     'path': {'name': 'boo', 'depth': 0},
-                     },
-                    {'id': 2,
-                     'path': {'name': 'sys/ospf', 'depth': 0, 'query_condition': 'qc', 'filter_condition': 'fc'},
-                     },
-                    {'id': 2,
-                     'path': {'name': 'interfaces', 'depth': 0},
-                     },
-                    {'id': 2,
-                     'path': {'name': 'sys/bgp'},
-                     },
-                    {'id': 2,
-                     'path': {'name': 'sys/bgp/inst', 'depth': 0, 'query_condition': 'foo', 'filter_condition': 'foo'},
-                     },
-                    {'id': 2,
-                     'path': {'name': 'sys/bgp/inst/dom-default/peer-[10.10.10.11]/ent-[10.10.10.11]'},
-                     },
-                    {'id': 2,
-                     'path': {'name': 'sys/bgp/inst/dom-default/peer-[20.20.20.11]/ent-[20.20.20.11]'},
-                     },
-                    {'id': 2,
-                     'path': {'name': 'too', 'depth': 0, 'filter_condition': 'foo'},
-                     },
-                    {'id': 55},
-                    {'id': 56,
-                     'data_source': 'DME',
-                     },
-                    {'id': 56,
-                     'path': {'name': 'environment'},
-                     },
-                    {'id': 56,
-                     'path': {'name': 'interface'},
-                     },
-                    {'id': 56,
-                     'path': {'name': 'resources'},
-                     },
-                    {'id': 56,
-                     'path': {'name': 'vxlan'},
-                     },
-                ],
-                'subscriptions': [
-                    {'id': 3},
-                    {'id': 4,
-                     'destination_group': 2,
-                     'sensor_group': {'id': 2, 'sample_interval': 1000},
-                     },
-                    {'id': 5,
-                     'destination_group': 2,
-                     },
-                    {'id': 5,
-                     'sensor_group': {'id': 2, 'sample_interval': 1000},
-                     },
-                    {'id': 6,
-                     'destination_group': 10,
-                     },
-                    {'id': 7,
-                     'destination_group': 10,
-                     'sensor_group': {'id': 2, 'sample_interval': 1000},
-                     },
-                ],
-            }
-        }, ignore_provider_arg)
-        self.execute_module(changed=False, commands=[])
-
-
-def build_args(data, type, state=None, check_mode=None):
-    if state is None:
-        state = 'merged'
-    if check_mode is None:
-        check_mode = False
-    args = {
-        'state': state,
-        '_ansible_check_mode': check_mode,
-        'config': {
-            type: data
-        }
-    }
-    return args
diff --git a/test/units/modules/network/nxos/test_nxos_vlan.py b/test/units/modules/network/nxos/test_nxos_vlan.py
deleted file mode 100644
index 30c9f076f5..0000000000
--- a/test/units/modules/network/nxos/test_nxos_vlan.py
+++ /dev/null
@@ -1,181 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-import json
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import _nxos_vlan
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosVlanModule(TestNxosModule):
-
-    module = _nxos_vlan
-
-    def setUp(self):
-        super(TestNxosVlanModule, self).setUp()
-
-        self.mock_run_commands = patch('ansible.modules.network.nxos._nxos_vlan.run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos._nxos_vlan.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos._nxos_vlan.get_config')
-        self.get_config = self.mock_get_config.start()
-
-        self.mock_get_capabilities = patch('ansible.modules.network.nxos._nxos_vlan.get_capabilities')
-        self.get_capabilities = self.mock_get_capabilities.start()
-        self.get_capabilities.return_value = {'device_info': {'network_os_platform': 'N9K-9000v'}, 'network_api': 'cliconf'}
-
-    def tearDown(self):
-        super(TestNxosVlanModule, self).tearDown()
-        self.mock_run_commands.stop()
-        self.mock_load_config.stop()
-        self.mock_get_config.stop()
-        self.mock_get_capabilities.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        def load_from_file(*args, **kwargs):
-            module, commands = args
-            output = list()
-
-            for item in commands:
-                try:
-                    obj = json.loads(item)
-                    command = obj['command']
-                except ValueError:
-                    command = item
-                filename = '%s.txt' % str(command).split(' | ')[0].replace(' ', '_')
-                output.append(load_fixture('nxos_vlan', filename))
-            return output
-
-        def agg_load_from_file(*args, **kwargs):
-            """Load vlan output for aggregate/purge tests"""
-            return([load_fixture('nxos_vlan', 'agg_show_vlan_brief.txt')])
-
-        if '_agg_' in self._testMethodName:
-            self.run_commands.side_effect = agg_load_from_file
-        else:
-            self.run_commands.side_effect = load_from_file
-
-        self.load_config.return_value = None
-        self.get_config.return_value = load_fixture('nxos_vlan', 'config.cfg')
-
-    def test_nxos_vlan_agg_1(self):
-        # Aggregate: vlan 4/5 exist -> Add 6
-        set_module_args(dict(aggregate=[
-            {'name': '_5_', 'vlan_id': 5},
-            {'name': '_6_', 'vlan_id': 6}
-        ]))
-        self.execute_module(changed=True, commands=[
-            'vlan 6',
-            'name _6_',
-            'state active',
-            'no shutdown',
-            'exit'
-        ])
-
-    def test_nxos_vlan_agg_2(self):
-        # Aggregate: vlan 4/5 exist -> Add none (idempotence)
-        set_module_args(dict(aggregate=[
-            {'name': '_5_', 'vlan_id': 5},
-            {'name': '_4_', 'vlan_id': 4}
-        ]))
-        self.execute_module(changed=False)
-
-    def test_nxos_vlan_agg_3(self):
-        # Aggregate/Purge: vlan 4/5 exist -> Add 6, Purge 4
-        set_module_args(dict(aggregate=[
-            {'name': '_5_', 'vlan_id': 5},
-            {'name': '_6_', 'vlan_id': 6}
-        ], purge=True))
-        self.execute_module(changed=True, commands=[
-            'vlan 6',
-            'name _6_',
-            'state active',
-            'no shutdown',
-            'exit',
-            'no vlan 4'
-        ])
-
-    def test_nxos_vlan_agg_4(self):
-        # Aggregate/Purge: vlan 4/5 exist -> Purge None (idempotence)
-        set_module_args(dict(aggregate=[
-            {'name': '_5_', 'vlan_id': 5},
-            {'name': '_4_', 'vlan_id': 4}
-        ]))
-        self.execute_module(changed=False)
-
-    def test_nxos_vlan_agg_5(self):
-        # Purge with Single Vlan: vlan 4/5 exist -> Add 6, Purge 4/5
-        set_module_args(dict(vlan_id=6, name='_6_', purge=True))
-        self.execute_module(changed=True, commands=[
-            'vlan 6',
-            'name _6_',
-            'state active',
-            'no shutdown',
-            'exit',
-            'no vlan 4',
-            'no vlan 5'
-        ])
-
-    def test_nxos_vlan_agg_6(self):
-        # Purge All: vlan 4/5 exist -> Purge 4/5
-        set_module_args(dict(vlan_id=1, purge=True))
-        self.execute_module(changed=True, commands=[
-            'no vlan 4',
-            'no vlan 5'
-        ])
-
-    def test_nxos_vlan_range(self):
-        set_module_args(dict(vlan_range='6-10'))
-        self.execute_module(changed=True, commands=['vlan 6', 'vlan 7', 'vlan 8', 'vlan 9', 'vlan 10'])
-
-    def test_nxos_vlan_range_absent(self):
-        set_module_args(dict(vlan_range='1-5', state='absent'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['no vlan 1'])
-
-    def test_nxos_vlan_id(self):
-        set_module_args(dict(vlan_id='15', state='present'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vlan 15', 'state active', 'no shutdown', 'exit'])
-
-    def test_nxos_vlan_id_absent(self):
-        set_module_args(dict(vlan_id='1', state='absent'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['no vlan 1'])
-
-    def test_nxos_vlan_named_vlan(self):
-        set_module_args(dict(vlan_id='15', name='WEB'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vlan 15', 'name WEB', 'state active', 'no shutdown', 'exit'])
-
-    def test_nxos_vlan_shut_down(self):
-        set_module_args(dict(vlan_id='1', admin_state='down'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vlan 1', 'shutdown', 'exit'])
-
-    def test_nxos_vlan_no_change(self):
-        set_module_args(dict(vlan_id='1', name='default', vlan_state='active', admin_state='up'))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
diff --git a/test/units/modules/network/nxos/test_nxos_vlans.py b/test/units/modules/network/nxos/test_nxos_vlans.py
deleted file mode 100644
index b8939c668d..0000000000
--- a/test/units/modules/network/nxos/test_nxos_vlans.py
+++ /dev/null
@@ -1,210 +0,0 @@
-# (c) 2019 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from textwrap import dedent
-from units.compat.mock import patch
-from units.modules.utils import AnsibleFailJson
-from ansible.modules.network.nxos import nxos_vlans
-from ansible.module_utils.network.nxos.config.vlans.vlans import Vlans
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-ignore_provider_arg = True
-
-
-class TestNxosVlansModule(TestNxosModule):
-
-    module = nxos_vlans
-
-    def setUp(self):
-        super(TestNxosVlansModule, self).setUp()
-
-        self.mock_FACT_LEGACY_SUBSETS = patch('ansible.module_utils.network.nxos.facts.facts.FACT_LEGACY_SUBSETS')
-        self.FACT_LEGACY_SUBSETS = self.mock_FACT_LEGACY_SUBSETS.start()
-
-        self.mock_get_resource_connection_config = patch('ansible.module_utils.network.common.cfg.base.get_resource_connection')
-        self.get_resource_connection_config = self.mock_get_resource_connection_config.start()
-
-        self.mock_get_resource_connection_facts = patch('ansible.module_utils.network.common.facts.facts.get_resource_connection')
-        self.get_resource_connection_facts = self.mock_get_resource_connection_facts.start()
-
-        self.mock_edit_config = patch('ansible.module_utils.network.nxos.config.vlans.vlans.Vlans.edit_config')
-        self.edit_config = self.mock_edit_config.start()
-
-        self.mock_get_device_data = patch('ansible.module_utils.network.nxos.facts.vlans.vlans.VlansFacts.get_device_data')
-        self.get_device_data = self.mock_get_device_data.start()
-
-    def tearDown(self):
-        super(TestNxosVlansModule, self).tearDown()
-        self.mock_FACT_LEGACY_SUBSETS.stop()
-        self.mock_get_resource_connection_config.stop()
-        self.mock_get_resource_connection_facts.stop()
-        self.mock_edit_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.mock_FACT_LEGACY_SUBSETS.return_value = dict()
-        self.edit_config.return_value = None
-
-        def load_from_file(*args, **kwargs):
-            cmd = args[1]
-            filename = str(cmd).split(' | ')[0].replace(' ', '_')
-            return load_fixture('nxos_vlans', filename)
-
-        def load_from_file_no_facts(*args, **kwargs):
-            cmd = args[1]
-            filename = str(cmd).split(' | ')[0].replace(' ', '_')
-            filename += '_no_facts'
-            return load_fixture('nxos_vlans', filename)
-
-        def load_from_file_vlan_1(*args, **kwargs):
-            cmd = args[1]
-            filename = str(cmd).split(' | ')[0].replace(' ', '_')
-            filename += '_vlan_1'
-            return load_fixture('nxos_vlans', filename)
-
-        if device == '':
-            self.get_device_data.side_effect = load_from_file
-        elif device == '_no_facts':
-            self.get_device_data.side_effect = load_from_file_no_facts
-        elif device == '_vlan_1':
-            self.get_device_data.side_effect = load_from_file_vlan_1
-
-    def test_1(self):
-        '''
-        **NOTE** This config is for reference only! See fixtures files for real data.
-        vlan 1,3-5,8
-        vlan 3
-          name test-vlan3
-        !Note:vlan 4 is present with default settings
-        vlan 5
-          shutdown
-          name test-changeme
-          mode fabricpath
-          state suspend
-          vn-segment 942
-        !Note:vlan 7 is not present
-        vlan 8
-          shutdown
-          name test-changeme-not
-          state suspend
-        '''
-        playbook = dict(config=[
-            dict(vlan_id=4),
-            dict(vlan_id=5, mapped_vni=555, mode='ce'),
-            dict(vlan_id=7, mapped_vni=777, name='test-vlan7', enabled=False),
-            dict(vlan_id='8', state='active', name='test-changeme-not')
-            # vlan 3 is not present in playbook.
-        ])
-
-        merged = [
-            # Update existing device states with any differences in the playbook.
-            'vlan 5', 'vn-segment 555', 'mode ce',
-            'vlan 7', 'vn-segment 777', 'name test-vlan7', 'shutdown',
-            'vlan 8', 'state active'
-        ]
-        playbook['state'] = 'merged'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=merged)
-
-        deleted = [
-            # Reset existing device state to default values. Scope is limited to
-            # objects in the play when the 'config' key is specified. For vlans
-            # this means deleting each vlan listed in the playbook and ignoring
-            # any play attrs other than 'vlan_id'.
-            'no vlan 4',
-            'no vlan 5',
-            'no vlan 8'
-        ]
-        playbook['state'] = 'deleted'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-
-        overridden = [
-            # The play is the source of truth. Similar to replaced but the scope
-            # includes all objects on the device; i.e. it will also reset state
-            # on objects not found in the play.
-            'no vlan 3',
-            'vlan 5', 'mode ce', 'vn-segment 555', 'no state', 'no shutdown', 'no name',
-            'vlan 8', 'no shutdown', 'state active',
-            'vlan 7', 'name test-vlan7', 'shutdown', 'vn-segment 777'
-        ]
-        playbook['state'] = 'overridden'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=overridden)
-
-        replaced = [
-            # Scope is limited to objects in the play.
-            # replaced should ignore existing vlan 3.
-            'vlan 5', 'mode ce', 'vn-segment 555', 'no state', 'no shutdown', 'no name',
-            'vlan 7', 'shutdown', 'name test-vlan7', 'vn-segment 777',
-            'vlan 8', 'no shutdown', 'state active'
-        ]
-        playbook['state'] = 'replaced'
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
-
-    def test_2(self):
-        # vlan 1 in playbook should raise
-        playbook = dict(config=[dict(vlan_id=1)], state='merged')
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(failed=True)
-
-    def test_3(self):
-        # Test when no 'config' key is used in playbook.
-        deleted = [
-            # Reset existing device state for all vlans found on device other than vlan 1.
-            'no vlan 3',
-            'no vlan 4',
-            'no vlan 5',
-            'no vlan 8'
-        ]
-        playbook = dict(state='deleted')
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=deleted)
-
-        for test_state in ['merged', 'replaced', 'overridden']:
-            set_module_args(dict(state=test_state), ignore_provider_arg)
-            self.execute_module(failed=True)
-
-    def test_4(self):
-        # Test only vlan 1 found
-        playbook = dict(state='deleted')
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(device='_vlan_1', changed=False)
-
-    def test_5(self):
-        # Test no facts returned
-        playbook = dict(state='deleted')
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(device='_no_facts', changed=False)
-
-    def test_6(self):
-        # Misc tests to hit codepaths highlighted by code coverage tool as missed.
-        playbook = dict(config=[
-            dict(vlan_id=8, enabled=True)
-        ])
-        replaced = [
-            # Update existing device states with any differences in the playbook.
-            'vlan 8', 'no shutdown', 'no state', 'no name'
-        ]
-        playbook['state'] = 'replaced'
-        playbook['_ansible_check_mode'] = True
-        set_module_args(playbook, ignore_provider_arg)
-        self.execute_module(changed=True, commands=replaced)
diff --git a/test/units/modules/network/nxos/test_nxos_vpc.py b/test/units/modules/network/nxos/test_nxos_vpc.py
deleted file mode 100644
index a65d14a6d0..0000000000
--- a/test/units/modules/network/nxos/test_nxos_vpc.py
+++ /dev/null
@@ -1,182 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_vpc
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosVpcModule(TestNxosModule):
-
-    module = nxos_vpc
-
-    def setUp(self):
-        super(TestNxosVpcModule, self).setUp()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_vpc.get_config')
-        self.get_config = self.mock_get_config.start()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_vpc.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_run_commands = patch('ansible.modules.network.nxos.nxos_vpc.run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-    def tearDown(self):
-        super(TestNxosVpcModule, self).tearDown()
-        self.mock_get_config.stop()
-        self.mock_load_config.stop()
-        self.mock_run_commands.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        def load_from_file(*args, **kwargs):
-            module, commands = args
-            output = list()
-
-            for command in commands:
-                filename = str(command).split(' | ')[0].replace(' ', '_')
-                output.append(load_fixture('nxos_vpc', filename))
-            return output
-
-        def vrf_load_from_file(*args, **kwargs):
-            """Load vpc output for vrf tests"""
-            module, commands = args
-            output = list()
-            for command in commands:
-                filename = 'vrf_test_' + str(command).split(' | ')[0].replace(' ', '_')
-                output.append(load_fixture('nxos_vpc', filename))
-            return output
-
-        self.load_config.return_value = None
-        if device == '_vrf_test':
-            self.run_commands.side_effect = vrf_load_from_file
-        else:
-            self.run_commands.side_effect = load_from_file
-
-    def test_nxos_vpc_present(self):
-        set_module_args(dict(domain=100, role_priority=32667, system_priority=2000,
-                             pkl_dest='192.168.100.4', pkl_src='10.1.100.20',
-                             peer_gw=True, auto_recovery=True))
-        self.execute_module(changed=True, commands=[
-            'vpc domain 100', 'terminal dont-ask', 'role priority 32667', 'system-priority 2000',
-            'peer-keepalive destination 192.168.100.4 source 10.1.100.20',
-            'peer-gateway', 'auto-recovery',
-        ])
-
-    def test_nxos_vpc_vrf_1(self):
-        # No vrf -> vrf 'default'
-        set_module_args(dict(
-            domain=100,
-            pkl_dest='192.168.1.1',
-            pkl_src='10.1.1.1',
-            pkl_vrf='default',
-        ))
-        self.execute_module(changed=True, commands=[
-            'vpc domain 100',
-            'peer-keepalive destination 192.168.1.1 source 10.1.1.1 vrf default'
-        ])
-
-    def test_nxos_vpc_vrf_2(self):
-        # vrf 'my_vrf'-> vrf 'test-vrf'
-        # All pkl commands should be present
-        self.get_config.return_value = load_fixture('nxos_vpc', 'vrf_test_vpc_config')
-        set_module_args(dict(
-            domain=100,
-            pkl_dest='192.168.1.1',
-            pkl_src='10.1.1.1',
-            pkl_vrf='test-vrf',
-        ))
-        self.execute_module(changed=True, device='_vrf_test', commands=[
-            'vpc domain 100',
-            'peer-keepalive destination 192.168.1.1 source 10.1.1.1 vrf test-vrf'
-        ])
-
-    def test_nxos_vpc_vrf_3(self):
-        # vrf 'my_vrf' -> vrf 'obviously-different-vrf'
-        # Existing pkl_src should be retained even though playbook does not specify it
-        self.get_config.return_value = load_fixture('nxos_vpc', 'vrf_test_vpc_config')
-        set_module_args(dict(
-            domain=100,
-            pkl_dest='192.168.1.1',
-            pkl_vrf='obviously-different-vrf'
-        ))
-        self.execute_module(changed=True, device='_vrf_test', commands=[
-            'vpc domain 100',
-            'peer-keepalive destination 192.168.1.1 source 10.1.1.1 vrf obviously-different-vrf'
-        ])
-
-    def test_nxos_vpc_vrf_4(self):
-        # vrf 'my_vrf'-> vrf 'management'
-        # 'management' is the default value for vrf, it will not nvgen
-        self.get_config.return_value = load_fixture('nxos_vpc', 'vrf_test_vpc_config')
-        set_module_args(dict(
-            domain=100,
-            pkl_dest='192.168.1.1',
-            pkl_vrf='management',
-        ))
-        self.execute_module(changed=True, device='_vrf_test', commands=[
-            'vpc domain 100',
-            'peer-keepalive destination 192.168.1.1 source 10.1.1.1 vrf management'
-        ])
-
-    def test_nxos_vpc_vrf_5(self):
-        # vrf 'my_vrf' -> vrf 'my_vrf' (idempotence)
-        self.get_config.return_value = load_fixture('nxos_vpc', 'vrf_test_vpc_config')
-        set_module_args(dict(
-            domain=100,
-            pkl_dest='192.168.1.1',
-            pkl_src='10.1.1.1',
-            pkl_vrf='my_vrf',
-        ))
-        self.execute_module(changed=False, device='_vrf_test')
-
-    def test_nxos_vpc_vrf_6(self):
-        # vrf 'my_vrf' -> absent tests
-        self.get_config.return_value = load_fixture('nxos_vpc', 'vrf_test_vpc_config')
-        set_module_args(dict(
-            domain=100,
-            state='absent'
-        ))
-        self.execute_module(changed=True, device='_vrf_test', commands=[
-            'terminal dont-ask',
-            'no vpc domain 100',
-        ])
-
-    def test_nxos_vpc_vrf_7(self):
-        # dest 192.168.1.1 source 10.1.1.1 vrf my_vrf -> (dest only) (idempotence)
-        # pkl_src/pkl_vrf not in playbook but exists on device.
-        self.get_config.return_value = load_fixture('nxos_vpc', 'vrf_test_vpc_config')
-        set_module_args(dict(
-            domain=100,
-            pkl_dest='192.168.1.1',
-        ))
-        self.execute_module(changed=False, device='_vrf_test')
-
-    def test_nxos_vpc_vrf_8(self):
-        # dest 192.168.1.1 source 10.1.1.1 vrf my_vrf -> (optional vrf) (idempotence)
-        # pkl_src not in playbook but exists on device.
-        self.get_config.return_value = load_fixture('nxos_vpc', 'vrf_test_vpc_config')
-        set_module_args(dict(
-            domain=100,
-            pkl_dest='192.168.1.1',
-            pkl_vrf='my_vrf',
-        ))
-        self.execute_module(changed=False, device='_vrf_test')
diff --git a/test/units/modules/network/nxos/test_nxos_vpc_interface.py b/test/units/modules/network/nxos/test_nxos_vpc_interface.py
deleted file mode 100644
index d61dbbfc4f..0000000000
--- a/test/units/modules/network/nxos/test_nxos_vpc_interface.py
+++ /dev/null
@@ -1,69 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_vpc_interface
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosVpcModule(TestNxosModule):
-
-    module = nxos_vpc_interface
-
-    def setUp(self):
-        super(TestNxosVpcModule, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_vpc_interface.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_vpc_interface.get_config')
-        self.get_config = self.mock_get_config.start()
-
-        self.mock_run_commands = patch('ansible.modules.network.nxos.nxos_vpc_interface.run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-    def tearDown(self):
-        super(TestNxosVpcModule, self).tearDown()
-        self.mock_load_config.stop()
-        self.mock_get_config.stop()
-        self.mock_run_commands.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        def load_from_file(*args, **kwargs):
-            module, commands = args
-            output = list()
-            for command in commands:
-                filename = str(command).split(' | ')[0].replace(' ', '_')
-                output.append(load_fixture('nxos_vpc_interface', filename))
-            return output
-
-        self.run_commands.side_effect = load_from_file
-        self.load_config.return_value = None
-
-    def test_nxos_vpc_interface_absent(self):
-        set_module_args(dict(portchannel=10, vpc=100, state='absent'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface port-channel10', 'no vpc'])
-
-    def test_nxos_vpc_interface_present(self):
-        set_module_args(dict(portchannel=20, vpc=200, state='present'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['interface port-channel20', 'vpc 200'])
diff --git a/test/units/modules/network/nxos/test_nxos_vrf.py b/test/units/modules/network/nxos/test_nxos_vrf.py
deleted file mode 100644
index 6479a9f2ba..0000000000
--- a/test/units/modules/network/nxos/test_nxos_vrf.py
+++ /dev/null
@@ -1,79 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_vrf
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosVrfModule(TestNxosModule):
-
-    module = nxos_vrf
-
-    def setUp(self):
-        super(TestNxosVrfModule, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_vrf.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_run_commands = patch('ansible.modules.network.nxos.nxos_vrf.run_commands')
-        self.run_commands = self.mock_run_commands.start()
-
-    def tearDown(self):
-        super(TestNxosVrfModule, self).tearDown()
-        self.mock_load_config.stop()
-        self.mock_run_commands.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        def load_from_file(*args, **kwargs):
-            module, commands = args
-            output = list()
-
-            for command in commands:
-                if isinstance(command, dict):
-                    command = command['command']
-                filename = str(command).split(' | ')[0].replace(' ', '_')
-                output.append(load_fixture('nxos_vrf', filename))
-            return output
-
-        self.load_config.return_value = None
-        self.run_commands.side_effect = load_from_file
-
-    def test_nxos_vrf_present(self):
-        set_module_args(dict(vrf='ntc', state='present', admin_state='up'))
-        self.execute_module(changed=True, commands=['vrf context ntc', 'no shutdown', 'exit'])
-
-    def test_nxos_vrf_present_no_change(self):
-        set_module_args(dict(vrf='management', state='present', admin_state='up'))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_vrf_absent(self):
-        set_module_args(dict(vrf='management', state='absent'))
-        self.execute_module(changed=True, commands=['no vrf context management'])
-
-    def test_nxos_vrf_absent_no_change(self):
-        set_module_args(dict(vrf='ntc', state='absent'))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_vrf_default(self):
-        set_module_args(dict(vrf='default'))
-        result = self.execute_module(failed=True)
-        self.assertEqual(result['msg'], 'cannot use default as name of a VRF')
diff --git a/test/units/modules/network/nxos/test_nxos_vrf_af.py b/test/units/modules/network/nxos/test_nxos_vrf_af.py
deleted file mode 100644
index 296f5656bb..0000000000
--- a/test/units/modules/network/nxos/test_nxos_vrf_af.py
+++ /dev/null
@@ -1,791 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_vrf_af
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosVrfafModule(TestNxosModule):
-
-    module = nxos_vrf_af
-
-    def setUp(self):
-        super(TestNxosVrfafModule, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_vrf_af.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_vrf_af.get_config')
-        self.get_config = self.mock_get_config.start()
-
-    def tearDown(self):
-        super(TestNxosVrfafModule, self).tearDown()
-        self.mock_load_config.stop()
-        self.mock_get_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.get_config.return_value = load_fixture('nxos_vrf_af', 'config.cfg')
-        self.load_config.return_value = None
-
-    def test_nxos_vrf_af_present_current_non_existing(self):
-        set_module_args(dict(vrf='vrf0', afi='ipv4', state='present'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf0',
-                                              'address-family ipv4 unicast'])
-
-    def test_nxos_vrf_af_present_current_existing(self):
-        set_module_args(dict(vrf='vrf1', afi='ipv4', state='present'))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_absent_current_non_existing(self):
-        set_module_args(dict(vrf='vrf0', afi='ipv4', state='absent'))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_absent_current_existing(self):
-        set_module_args(dict(vrf='vrf1', afi='ipv4', state='absent'))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf1',
-                                              'no address-family ipv4 unicast'])
-
-    def test_nxos_vrf_af_auto_evpn_route_target_present_current_existing(self):
-        set_module_args(dict(vrf='vrf11', afi='ipv4', route_target_both_auto_evpn=True))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_auto_evpn_route_target_present_current_non_existing(self):
-        set_module_args(dict(vrf='vrf10', afi='ipv4', route_target_both_auto_evpn=True))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf10',
-                                              'address-family ipv4 unicast',
-                                              'route-target both auto evpn'])
-
-    def test_nxos_vrf_af_auto_evpn_route_target_absent_current_existing(self):
-        set_module_args(dict(vrf='vrf11', afi='ipv4', route_target_both_auto_evpn=False))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf11',
-                                              'address-family ipv4 unicast',
-                                              'no route-target both auto evpn'])
-
-    def test_nxos_vrf_af_auto_evpn_route_target_absent_current_non_existing(self):
-        set_module_args(dict(vrf='vrf1', afi='ipv4', route_target_both_auto_evpn=False))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_route_target_import_present_current_non_existing(self):
-        set_module_args(dict(vrf='vrf1',
-                             afi='ipv4',
-                             route_targets=[{"rt": "65000:1000",
-                                             "direction": "import",
-                                             "state": "present"}]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf1',
-                                              'address-family ipv4 unicast',
-                                              'route-target import 65000:1000'])
-
-    def test_nxos_vrf_af_route_target_default_direction_present_current_non_existing(self):
-        set_module_args(dict(vrf='vrf1',
-                             afi='ipv4',
-                             route_targets=[{"rt": "65000:1000",
-                                             "state": "present"}]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf1',
-                                              'address-family ipv4 unicast',
-                                              'route-target import 65000:1000',
-                                              'route-target export 65000:1000'])
-
-    def test_nxos_vrf_af_route_target_import_present_current_existing(self):
-        set_module_args(dict(vrf='vrf21',
-                             afi='ipv4',
-                             route_targets=[{
-                                 "rt": "65000:1000",
-                                 "direction": "import",
-                                 "state": "present"}
-                             ]))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_route_target_default_direction_present_current_existing(self):
-        set_module_args(dict(vrf='vrf21',
-                             afi='ipv4',
-                             route_targets=[{
-                                 "rt": "65000:1000",
-                                 "state": "present"}
-                             ]))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_route_target_multi_import_present_current_non_existing(self):
-        set_module_args(dict(vrf='vrf1',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "import",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "direction": "import",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "import",
-                                     "state": "present"
-                                 }]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf1',
-                                              'address-family ipv4 unicast',
-                                              'route-target import 65000:1000',
-                                              'route-target import 65001:1000',
-                                              'route-target import 65002:1000'])
-
-    def test_nxos_vrf_af_route_target_multi_import_present_current_existing(self):
-        set_module_args(dict(vrf='vrf21',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "import",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "direction": "import",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "import",
-                                     "state": "present"
-                                 }
-                             ]))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_route_target_import_absent_current_non_existing(self):
-        set_module_args(dict(vrf='vrf1',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "import",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_route_target_import_absent_current_existing(self):
-        set_module_args(dict(vrf='vrf21',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "import",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf21',
-                                              'address-family ipv4 unicast',
-                                              'no route-target import 65000:1000'])
-
-    def test_nxos_vrf_af_route_target_multi_import_absent_current_non_existing(self):
-        set_module_args(dict(vrf='vrf1',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "import",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "direction": "import",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "import",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_route_target_multi_import_absent_current_existing(self):
-        set_module_args(dict(vrf='vrf21',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "import",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "direction": "import",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "import",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf21',
-                                              'address-family ipv4 unicast',
-                                              'no route-target import 65000:1000',
-                                              'no route-target import 65001:1000',
-                                              'no route-target import 65002:1000'])
-
-    def test_nxos_vrf_af_route_target_multi_import_absent_current_mix(self):
-        set_module_args(dict(vrf='vrf21',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "import",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "direction": "import",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "import",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65003:1000",
-                                     "direction": "import",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65004:1000",
-                                     "direction": "import",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf21',
-                                              'address-family ipv4 unicast',
-                                              'no route-target import 65002:1000',
-                                              'route-target import 65003:1000'])
-
-    def test_nxos_vrf_af_route_target_export_present_current_non_existing(self):
-        set_module_args(dict(vrf='vrf1',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "export",
-                                     "state": "present"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf1',
-                                              'address-family ipv4 unicast',
-                                              'route-target export 65000:1000'])
-
-    def test_nxos_vrf_af_route_target_export_present_current_existing(self):
-        set_module_args(dict(vrf='vrf21',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "export",
-                                     "state": "present"
-                                 }
-                             ]))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_route_target_multi_export_present_current_non_existing(self):
-        set_module_args(dict(vrf='vrf1',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "export",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "direction": "export",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "export",
-                                     "state": "present"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf1',
-                                              'address-family ipv4 unicast',
-                                              'route-target export 65000:1000',
-                                              'route-target export 65001:1000',
-                                              'route-target export 65002:1000'])
-
-    def test_nxos_vrf_af_route_target_multi_export_present_current_existing(self):
-        set_module_args(dict(vrf='vrf21',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "export",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "direction": "export",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "export",
-                                     "state": "present"
-                                 }
-                             ]))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_route_target_export_absent_current_non_existing(self):
-        set_module_args(dict(vrf='vrf1',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "export",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_route_target_export_absent_current_existing(self):
-        set_module_args(dict(vrf='vrf21',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "export",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf21',
-                                              'address-family ipv4 unicast',
-                                              'no route-target export 65000:1000'])
-
-    def test_nxos_vrf_af_route_target_multi_export_absent_current_non_existing(self):
-        set_module_args(dict(vrf='vrf1',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "export",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "direction": "export",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "export",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_route_target_multi_export_absent_current_existing(self):
-        set_module_args(dict(vrf='vrf21',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "export",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "direction": "export",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "export",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf21',
-                                              'address-family ipv4 unicast',
-                                              'no route-target export 65000:1000',
-                                              'no route-target export 65001:1000',
-                                              'no route-target export 65002:1000'])
-
-    def test_nxos_vrf_af_route_target_multi_export_absent_current_mix(self):
-        set_module_args(dict(vrf='vrf21',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "export",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "direction": "export",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "export",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65003:1000",
-                                     "direction": "export",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65004:1000",
-                                     "direction": "export",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf21',
-                                              'address-family ipv4 unicast',
-                                              'no route-target export 65002:1000',
-                                              'route-target export 65003:1000'])
-
-    def test_nxos_vrf_af_route_target_both_present_current_non_existing(self):
-        set_module_args(dict(vrf='vrf1',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "both",
-                                     "state": "present"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf1',
-                                              'address-family ipv4 unicast',
-                                              'route-target import 65000:1000',
-                                              'route-target export 65000:1000'])
-
-    def test_nxos_vrf_af_route_target_both_present_current_existing(self):
-        set_module_args(dict(vrf='vrf21',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "both",
-                                     "state": "present"
-                                 }
-                             ]))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_route_target_multi_both_present_current_non_existing(self):
-        set_module_args(dict(vrf='vrf1',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "both",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "direction": "both",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "both",
-                                     "state": "present"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf1',
-                                              'address-family ipv4 unicast',
-                                              'route-target import 65000:1000',
-                                              'route-target export 65000:1000',
-                                              'route-target import 65001:1000',
-                                              'route-target export 65001:1000',
-                                              'route-target import 65002:1000',
-                                              'route-target export 65002:1000'])
-
-    def test_nxos_vrf_af_route_target_multi_both_present_current_existing(self):
-        set_module_args(dict(vrf='vrf21',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "both",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "direction": "both",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "both",
-                                     "state": "present"
-                                 }
-                             ]))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_route_target_both_absent_current_non_existing(self):
-        set_module_args(dict(vrf='vrf1',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "both",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_route_target_both_absent_current_existing(self):
-        set_module_args(dict(vrf='vrf21',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "both",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf21',
-                                              'address-family ipv4 unicast',
-                                              'no route-target import 65000:1000',
-                                              'no route-target export 65000:1000'])
-
-    def test_nxos_vrf_af_route_target_multi_both_absent_current_non_existing(self):
-        set_module_args(dict(vrf='vrf1',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "both",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "direction": "both",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "both",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=False)
-        self.assertEqual(result['commands'], [])
-
-    def test_nxos_vrf_af_route_target_multi_both_absent_current_existing(self):
-        set_module_args(dict(vrf='vrf21',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "both",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "direction": "both",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "both",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf21',
-                                              'address-family ipv4 unicast',
-                                              'no route-target import 65000:1000',
-                                              'no route-target export 65000:1000',
-                                              'no route-target import 65001:1000',
-                                              'no route-target export 65001:1000',
-                                              'no route-target import 65002:1000',
-                                              'no route-target export 65002:1000'])
-
-    def test_nxos_vrf_af_route_target_multi_both_absent_current_mix(self):
-        set_module_args(dict(vrf='vrf21',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "both",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "direction": "both",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "both",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65003:1000",
-                                     "direction": "both",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65004:1000",
-                                     "direction": "both",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf21',
-                                              'address-family ipv4 unicast',
-                                              'no route-target import 65002:1000',
-                                              'no route-target export 65002:1000',
-                                              'route-target import 65003:1000',
-                                              'route-target export 65003:1000'])
-
-    def test_nxos_vrf_af_route_target_multi_both_current_only_import_or_export(self):
-        set_module_args(dict(vrf='vrf31',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "both",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "direction": "both",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "both",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65003:1000",
-                                     "direction": "both",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf31',
-                                              'address-family ipv4 unicast',
-                                              'route-target export 65000:1000',
-                                              'route-target import 65001:1000',
-                                              'no route-target import 65002:1000',
-                                              'no route-target export 65003:1000'])
-
-    def test_nxos_vrf_af_route_target_multi_direction_current_only_import_or_export(self):
-        set_module_args(dict(vrf='vrf31',
-                             afi='ipv4',
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "both",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65001:1000",
-                                     "state": "present"
-                                 },
-                                 {
-                                     "rt": "65002:1000",
-                                     "direction": "export",
-                                     "state": "absent"
-                                 },
-                                 {
-                                     "rt": "65003:1000",
-                                     "direction": "export",
-                                     "state": "absent"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf31',
-                                              'address-family ipv4 unicast',
-                                              'route-target export 65000:1000',
-                                              'route-target import 65001:1000',
-                                              'no route-target export 65003:1000'])
-
-    def test_nxos_vrf_af_auto_evpn_route_target_and_manual_route_target(self):
-        set_module_args(dict(vrf='vrf1',
-                             afi='ipv4',
-                             route_target_both_auto_evpn=True,
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "both",
-                                     "state": "present"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf1',
-                                              'address-family ipv4 unicast',
-                                              'route-target both auto evpn',
-                                              'route-target import 65000:1000',
-                                              'route-target export 65000:1000'])
-
-    def test_nxos_vrf_af_auto_evpn_route_target_and_manual_route_targets_with_absent_vrf(self):
-        set_module_args(dict(vrf='vrf1',
-                             afi='ipv4',
-                             state='absent',
-                             route_target_both_auto_evpn=True,
-                             route_targets=[
-                                 {
-                                     "rt": "65000:1000",
-                                     "direction": "both",
-                                     "state": "present"
-                                 }
-                             ]))
-        result = self.execute_module(changed=True)
-        self.assertEqual(result['commands'], ['vrf context vrf1',
-                                              'no address-family ipv4 unicast'])
diff --git a/test/units/modules/network/nxos/test_nxos_vxlan_vtep.py b/test/units/modules/network/nxos/test_nxos_vxlan_vtep.py
deleted file mode 100644
index c609f515e6..0000000000
--- a/test/units/modules/network/nxos/test_nxos_vxlan_vtep.py
+++ /dev/null
@@ -1,63 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_vxlan_vtep
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosVxlanVtepVniModule(TestNxosModule):
-
-    module = nxos_vxlan_vtep
-
-    def setUp(self):
-        super(TestNxosVxlanVtepVniModule, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_vxlan_vtep.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_vxlan_vtep.get_config')
-        self.get_config = self.mock_get_config.start()
-
-    def tearDown(self):
-        super(TestNxosVxlanVtepVniModule, self).tearDown()
-        self.mock_get_config.stop()
-        self.mock_load_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.get_config.return_value = load_fixture('nxos_vxlan_vtep', 'config.cfg')
-        self.load_config.return_value = None
-
-    def test_nxos_vxlan_vtep(self):
-        set_module_args(dict(interface='nve1', description='simple description'))
-        self.execute_module(changed=True, commands=['interface nve1', 'terminal dont-ask', 'description simple description'])
-
-    def test_nxos_vxlan_vtep_present_no_change(self):
-        set_module_args(dict(interface='nve1'))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_vxlan_vtep_absent(self):
-        set_module_args(dict(interface='nve1', state='absent'))
-        self.execute_module(changed=True, commands=['no interface nve1'])
-
-    def test_nxos_vxlan_vtep_absent_no_change(self):
-        set_module_args(dict(interface='nve2', state='absent'))
-        self.execute_module(changed=False, commands=[])
diff --git a/test/units/modules/network/nxos/test_nxos_vxlan_vtep_vni.py b/test/units/modules/network/nxos/test_nxos_vxlan_vtep_vni.py
deleted file mode 100644
index 798dd7ae05..0000000000
--- a/test/units/modules/network/nxos/test_nxos_vxlan_vtep_vni.py
+++ /dev/null
@@ -1,63 +0,0 @@
-# (c) 2016 Red Hat Inc.
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from units.compat.mock import patch
-from ansible.modules.network.nxos import nxos_vxlan_vtep_vni
-from .nxos_module import TestNxosModule, load_fixture, set_module_args
-
-
-class TestNxosVxlanVtepVniModule(TestNxosModule):
-
-    module = nxos_vxlan_vtep_vni
-
-    def setUp(self):
-        super(TestNxosVxlanVtepVniModule, self).setUp()
-
-        self.mock_load_config = patch('ansible.modules.network.nxos.nxos_vxlan_vtep_vni.load_config')
-        self.load_config = self.mock_load_config.start()
-
-        self.mock_get_config = patch('ansible.modules.network.nxos.nxos_vxlan_vtep_vni.get_config')
-        self.get_config = self.mock_get_config.start()
-
-    def tearDown(self):
-        super(TestNxosVxlanVtepVniModule, self).tearDown()
-        self.mock_get_config.stop()
-        self.mock_load_config.stop()
-
-    def load_fixtures(self, commands=None, device=''):
-        self.get_config.return_value = load_fixture('nxos_vxlan_vtep_vni', 'config.cfg')
-        self.load_config.return_value = None
-
-    def test_nxos_vxlan_vtep_vni_present_no_change(self):
-        set_module_args(dict(interface='nve1', vni=6000))
-        self.execute_module(changed=False, commands=[])
-
-    def test_nxos_vxlan_vtep_vni(self):
-        set_module_args(dict(interface='nve1', vni=5000))
-        self.execute_module(changed=True, commands=['interface nve1', 'member vni 5000'])
-
-    def test_nxos_vxlan_vtep_vni_absent(self):
-        set_module_args(dict(interface='nve1', vni=6000, state='absent'))
-        self.execute_module(changed=True, commands=['interface nve1', 'no member vni 6000'])
-
-    def test_nxos_vxlan_vtep_vni_absent_no_change(self):
-        set_module_args(dict(interface='nve2', vni=6000, state='absent'))
-        self.execute_module(changed=False, commands=[])

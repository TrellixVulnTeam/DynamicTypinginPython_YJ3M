commit 5bfbe85a26ac42a364175278097c1d91a174226f
Author: Chris Archibald <carchi@netapp.com>
Date:   Thu May 24 12:48:33 2018 -0700

    seconds set of netapp modules (#40487)
    
    * seconds set of netapp modules
    
    * fixes
    
    * Fix issues
    
    * Fix future issues
    
    * fix issues
    
    * Fix issues
    
    * changes
    
    * Change force
    
    * made fixes
    
    * add new line to end of file

diff --git a/lib/ansible/modules/storage/netapp/na_ontap_cluster.py b/lib/ansible/modules/storage/netapp/na_ontap_cluster.py
new file mode 100644
index 0000000000..ba49fb8763
--- /dev/null
+++ b/lib/ansible/modules/storage/netapp/na_ontap_cluster.py
@@ -0,0 +1,235 @@
+#!/usr/bin/python
+
+# (c) 2017, NetApp, Inc
+# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
+
+from __future__ import absolute_import, division, print_function
+__metaclass__ = type
+
+ANSIBLE_METADATA = {'metadata_version': '1.1',
+                    'status': ['preview'],
+                    'supported_by': 'community'}
+
+
+DOCUMENTATION = '''
+module: na_ontap_cluster
+short_description: Create/Join ONTAP cluster. Apply license to cluster
+extends_documentation_fragment:
+    - netapp.na_ontap
+version_added: '2.6'
+author: Suhas Bangalore Shekar (bsuhas@netapp.com), Archana Ganesan (garchana@netapp.com)
+description:
+- Create or join or apply licenses to ONTAP clusters
+options:
+  state:
+    description:
+    - Whether the specified cluster should exist or not.
+    choices: ['present']
+    default: present
+  cluster_name:
+    description:
+    - The name of the cluster to manage.
+  cluster_ip_address:
+    description:
+    - IP address of cluster to be joined
+  license_code:
+    description:
+    - License code to be applied to the cluster
+  license_package:
+    description:
+    - License package name of the license to be removed
+  node_serial_number:
+    description:
+    - Serial number of the cluster node
+
+'''
+
+EXAMPLES = """
+    - name: Create cluster
+      na_ontap_cluster:
+        state: present
+        cluster_name: new_cluster
+        hostname: "{{ netapp_hostname }}"
+        username: "{{ netapp_username }}"
+        password: "{{ netapp_password }}"
+    - name: Add license from cluster
+      na_ontap_cluster:
+        state: present
+        cluster_name: FPaaS-A300-01
+        license_code: SGHLQDBBVAAAAAAAAAAAAAAAAAAA
+        hostname: "{{ netapp_hostname }}"
+        username: "{{ netapp_username }}"
+        password: "{{ netapp_password }}"
+    - name: Join cluster
+      na_ontap_cluster:
+        state: present
+        cluster_name: FPaaS-A300
+        cluster_ip_address: 10.61.184.181
+        hostname: "{{ netapp_hostname }}"
+        username: "{{ netapp_username }}"
+        password: "{{ netapp_password }}"
+"""
+
+RETURN = """
+"""
+
+import traceback
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils._text import to_native
+import ansible.module_utils.netapp as netapp_utils
+
+HAS_NETAPP_LIB = netapp_utils.has_netapp_lib()
+
+
+class NetAppONTAPCluster(object):
+    """
+    object initialize and class methods
+    """
+    def __init__(self):
+        self.argument_spec = netapp_utils.na_ontap_host_argument_spec()
+        self.argument_spec.update(dict(
+            state=dict(required=False, choices=['present'], default='present'),
+            cluster_name=dict(required=False, type='str'),
+            cluster_ip_address=dict(required=False, type='str'),
+            license_code=dict(required=False, type='str'),
+            license_package=dict(required=False, type='str'),
+            node_serial_number=dict(required=False, type='str')
+        ))
+
+        self.module = AnsibleModule(
+            argument_spec=self.argument_spec,
+            supports_check_mode=True,
+            required_together=[
+                ['license_package', 'node_serial_number']
+            ],
+            mutually_exclusive=[
+                ['cluster_name', 'cluster_ip_address'],
+            ]
+        )
+
+        parameters = self.module.params
+
+        # set up state variables
+        self.state = parameters['state']
+        self.cluster_ip_address = parameters['cluster_ip_address']
+        self.cluster_name = parameters['cluster_name']
+        self.license_code = parameters['license_code']
+        self.license_package = parameters['license_package']
+        self.node_serial_number = parameters['node_serial_number']
+
+        if HAS_NETAPP_LIB is False:
+            self.module.fail_json(msg="the python NetApp-Lib module is required")
+        else:
+            self.server = netapp_utils.setup_na_ontap_zapi(module=self.module)
+
+    def create_cluster(self):
+        """
+        Create a cluster
+        """
+        cluster_create = netapp_utils.zapi.NaElement.create_node_with_children(
+            'cluster-create', **{'cluster-name': self.cluster_name})
+
+        try:
+            self.server.invoke_successfully(cluster_create,
+                                            enable_tunneling=True)
+            return True
+        except netapp_utils.zapi.NaApiError as error:
+            # Error 36503 denotes node already being used.
+            if to_native(error.code) == "36503":
+                return False
+            else:
+                self.module.fail_json(msg='Error creating cluster %s: %s'
+                                      % (self.cluster_name, to_native(error)),
+                                      exception=traceback.format_exc())
+
+    def cluster_join(self):
+        """
+        Add a node to an existing cluster
+        """
+        cluster_add_node = netapp_utils.zapi.NaElement.create_node_with_children(
+            'cluster-join', **{'cluster-ip-address': self.cluster_ip_address})
+
+        try:
+            self.server.invoke_successfully(cluster_add_node, enable_tunneling=True)
+            return True
+        except netapp_utils.zapi.NaApiError as error:
+            # Error 36503 denotes node already being used.
+            if to_native(error.code) == "36503":
+                return False
+            else:
+                self.module.fail_json(msg='Error adding node to cluster %s: %s'
+                                      % (self.cluster_name, to_native(error)),
+                                      exception=traceback.format_exc())
+
+    def license_v2_add(self):
+        """
+        Apply a license to cluster
+        """
+        license_add = netapp_utils.zapi.NaElement.create_node_with_children('license-v2-add')
+        license_add.add_node_with_children('codes', **{'license-code-v2': self.license_code})
+        try:
+            self.server.invoke_successfully(license_add, enable_tunneling=True)
+
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error adding license to the cluster %s: %s'
+                                  % (self.cluster_name, to_native(error)),
+                                  exception=traceback.format_exc())
+
+    def license_v2_delete(self):
+        """
+        Delete license from cluster
+        """
+        license_delete = netapp_utils.zapi.NaElement.create_node_with_children(
+            'license-v2-delete', **{'package': self.license_package,
+                                    'serial-number': self.node_serial_number})
+        try:
+            self.server.invoke_successfully(license_delete, enable_tunneling=True)
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error deleting license from cluster %s : %s'
+                                  % (self.cluster_name, to_native(error)),
+                                  exception=traceback.format_exc())
+
+    def apply(self):
+        """
+        Apply action to cluster
+        """
+        property_changed = False
+        create_flag = False
+        join_flag = False
+        changed = False
+
+        if self.state == 'absent':
+            pass
+        elif self.state == 'present':  # license add, delete
+            changed = True
+
+        if changed:
+            if self.module.check_mode:
+                pass
+            else:
+                if self.state == 'present':
+                    if self.cluster_name is not None:
+                        create_flag = self.create_cluster()
+                    if self.cluster_ip_address is not None:
+                        join_flag = self.cluster_join()
+                    if self.license_code is not None:
+                        self.license_v2_add()
+                        property_changed = True
+                    if self.license_package is not None and self.node_serial_number is not None:
+                        self.license_v2_delete()
+                        property_changed = True
+        changed = property_changed or create_flag or join_flag
+        self.module.exit_json(changed=changed)
+
+
+def main():
+    """
+    Create object and call apply
+    """
+    rule_obj = NetAppONTAPCluster()
+    rule_obj.apply()
+
+
+if __name__ == '__main__':
+    main()
diff --git a/lib/ansible/modules/storage/netapp/na_ontap_cluster_ha.py b/lib/ansible/modules/storage/netapp/na_ontap_cluster_ha.py
new file mode 100644
index 0000000000..55c31edbaa
--- /dev/null
+++ b/lib/ansible/modules/storage/netapp/na_ontap_cluster_ha.py
@@ -0,0 +1,114 @@
+#!/usr/bin/python
+
+# (c) 2018, NetApp, Inc
+# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
+
+from __future__ import absolute_import, division, print_function
+__metaclass__ = type
+
+ANSIBLE_METADATA = {'metadata_version': '1.1',
+                    'status': ['preview'],
+                    'supported_by': 'community'}
+
+
+DOCUMENTATION = '''
+author: "Suhas Bangalore Shekar (bsuhas@netapp.com), Archana Ganesan (garchana@netapp.com)"
+description:
+  - "Enable or disable HA on a cluster"
+extends_documentation_fragment:
+  - netapp.na_ontap
+module: na_ontap_cluster_ha
+options:
+  state:
+    choices: ['present', 'absent']
+    description:
+      - "Whether HA on cluster should be enabled or disabled."
+    default: present
+short_description: "Manage HA status for cluster"
+version_added: "2.6"
+'''
+
+EXAMPLES = """
+    - name: "Enable HA status for cluster"
+      na_ontap_cluster_ha:
+        state: present
+        hostname: "{{ netapp_hostname }}"
+        username: "{{ netapp_username }}"
+        password: "{{ netapp_password }}"
+"""
+
+RETURN = """
+"""
+
+import traceback
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils._text import to_native
+import ansible.module_utils.netapp as netapp_utils
+HAS_NETAPP_LIB = netapp_utils.has_netapp_lib()
+
+
+class NetAppOntapClusterHA(object):
+    """
+    object initialize and class methods
+    """
+    def __init__(self):
+
+        self.argument_spec = netapp_utils.na_ontap_host_argument_spec()
+        self.argument_spec.update(dict(
+            state=dict(required=False, choices=['present', 'absent'], default='present'),
+        ))
+        self.module = AnsibleModule(
+            argument_spec=self.argument_spec,
+            supports_check_mode=True
+        )
+        parameters = self.module.params
+        # set up state variable
+        self.state = parameters['state']
+
+        if HAS_NETAPP_LIB is False:
+            self.module.fail_json(msg="the python NetApp-Lib module is required")
+        else:
+            self.server = netapp_utils.setup_na_ontap_zapi(module=self.module)
+
+    def modify_cluster_ha(self, configure):
+        """
+        Enable or disable HA on cluster
+        """
+        cluster_ha_modify = netapp_utils.zapi.NaElement.create_node_with_children(
+            'cluster-ha-modify', **{'ha-configured': configure})
+        try:
+            self.server.invoke_successfully(cluster_ha_modify,
+                                            enable_tunneling=True)
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error modifying cluster HA to %s: %s'
+                                  % (configure, to_native(error)),
+                                  exception=traceback.format_exc())
+
+    def apply(self):
+        """
+        Apply action to cluster HA
+        """
+        changed = False
+        results = netapp_utils.get_cserver(self.server)
+        cserver = netapp_utils.setup_na_ontap_zapi(module=self.module, vserver=results)
+        netapp_utils.ems_log_event("na_ontap_cluster", cserver)
+        if self.state == 'present':
+            self.modify_cluster_ha("true")
+            changed = True
+        elif self.state == 'absent':
+            self.modify_cluster_ha("false")
+            changed = True
+
+        self.module.exit_json(changed=changed)
+
+
+def main():
+    """
+    Create object and call apply
+    """
+    ha_obj = NetAppOntapClusterHA()
+    ha_obj.apply()
+
+
+if __name__ == '__main__':
+    main()
diff --git a/lib/ansible/modules/storage/netapp/na_ontap_export_policy.py b/lib/ansible/modules/storage/netapp/na_ontap_export_policy.py
new file mode 100644
index 0000000000..0305fe42ee
--- /dev/null
+++ b/lib/ansible/modules/storage/netapp/na_ontap_export_policy.py
@@ -0,0 +1,228 @@
+#!/usr/bin/python
+
+# (c) 2018, NetApp, Inc
+# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
+
+from __future__ import absolute_import, division, print_function
+__metaclass__ = type
+
+ANSIBLE_METADATA = {'metadata_version': '1.1',
+                    'status': ['preview'],
+                    'supported_by': 'community'}
+
+
+DOCUMENTATION = '''
+module: na_ontap_export_policy
+short_description: Manage NetApp ONTAP export-policy
+extends_documentation_fragment:
+    - netapp.na_ontap
+version_added: '2.6'
+author: Archana Ganesan (garchana@netapp.com), Suhas Bangalore Shekar (bsuhas@netapp.com)
+description:
+- Create or destroy or rename export-policies on ONTAP
+options:
+  state:
+    description:
+    - Whether the specified export policy should exist or not.
+    choices: ['present', 'absent']
+    default: present
+  name:
+    description:
+    - The name of the export-policy to manage.
+    required: true
+  new_name:
+    description:
+    - The name of the export-policy to be renamed.
+  vserver:
+    description:
+    - Name of the vserver to use.
+'''
+
+EXAMPLES = """
+    - name: Create Export Policy
+      na_ontap_export_policy:
+        state: present
+        name: ansiblePolicyName
+        vserver: vs_hack
+        hostname: "{{ netapp_hostname }}"
+        username: "{{ netapp_username }}"
+        password: "{{ netapp_password }}"
+    - name: Rename Export Policy
+      na_ontap_export_policy:
+        action: present
+        name: ansiblePolicyName
+        vserver: vs_hack
+        new_name: newPolicyName
+        hostname: "{{ netapp_hostname }}"
+        username: "{{ netapp_username }}"
+        password: "{{ netapp_password }}"
+    - name: Delete Export Policy
+      na_ontap_export_policy:
+        state: absent
+        name: ansiblePolicyName
+        vserver: vs_hack
+        hostname: "{{ netapp_hostname }}"
+        username: "{{ netapp_username }}"
+        password: "{{ netapp_password }}"
+"""
+
+RETURN = """
+"""
+
+import traceback
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils._text import to_native
+import ansible.module_utils.netapp as netapp_utils
+
+HAS_NETAPP_LIB = netapp_utils.has_netapp_lib()
+
+
+class NetAppONTAPExportPolicy(object):
+    """
+    Class with export policy methods
+    """
+
+    def __init__(self):
+
+        self.argument_spec = netapp_utils.na_ontap_host_argument_spec()
+        self.argument_spec.update(dict(
+            state=dict(required=False, type='str', choices=['present', 'absent'], default='present'),
+            name=dict(required=True, type='str'),
+            new_name=dict(required=False, type='str', default=None),
+            vserver=dict(required=False, type='str')
+        ))
+        self.module = AnsibleModule(
+            argument_spec=self.argument_spec,
+            required_if=[
+                ('state', 'present', ['vserver'])
+            ],
+            supports_check_mode=True
+        )
+        parameters = self.module.params
+        # set up state variables
+        self.state = parameters['state']
+        self.name = parameters['name']
+        self.new_name = parameters['new_name']
+        self.vserver = parameters['vserver']
+
+        if HAS_NETAPP_LIB is False:
+            self.module.fail_json(msg="the python NetApp-Lib module is required")
+        else:
+            self.server = netapp_utils.setup_na_ontap_zapi(module=self.module, vserver=self.vserver)
+
+    def get_export_policy(self):
+        """
+        Return details about the export-policy
+        :param:
+            name : Name of the export-policy
+        :return: Details about the export-policy. None if not found.
+        :rtype: dict
+        """
+        export_policy_iter = netapp_utils.zapi.NaElement('export-policy-get-iter')
+        export_policy_info = netapp_utils.zapi.NaElement('export-policy-info')
+        export_policy_info.add_new_child('policy-name', self.name)
+        query = netapp_utils.zapi.NaElement('query')
+        query.add_child_elem(export_policy_info)
+        export_policy_iter.add_child_elem(query)
+        result = self.server.invoke_successfully(export_policy_iter, True)
+        return_value = None
+        # check if query returns the expected export-policy
+        if result.get_child_by_name('num-records') and \
+                int(result.get_child_content('num-records')) == 1:
+
+            export_policy = result.get_child_by_name('attributes-list').get_child_by_name('export-policy-info').get_child_by_name('policy-name')
+            return_value = {
+                'policy-name': export_policy
+            }
+        return return_value
+
+    def create_export_policy(self):
+        """
+        Creates an export policy
+        """
+        export_policy_create = netapp_utils.zapi.NaElement.create_node_with_children(
+            'export-policy-create', **{'policy-name': self.name})
+        try:
+            self.server.invoke_successfully(export_policy_create,
+                                            enable_tunneling=True)
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error creating export-policy %s: %s'
+                                  % (self.name, to_native(error)),
+                                  exception=traceback.format_exc())
+
+    def delete_export_policy(self):
+        """
+        Delete export-policy
+        """
+        export_policy_delete = netapp_utils.zapi.NaElement.create_node_with_children(
+            'export-policy-destroy', **{'policy-name': self.name, })
+        try:
+            self.server.invoke_successfully(export_policy_delete,
+                                            enable_tunneling=True)
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error deleting export-policy %s: %s'
+                                  % (self.name,
+                                     to_native(error)), exception=traceback.format_exc())
+
+    def rename_export_policy(self):
+        """
+        Rename the export-policy.
+        """
+        export_policy_rename = netapp_utils.zapi.NaElement.create_node_with_children(
+            'export-policy-rename', **{'policy-name': self.name,
+                                       'new-policy-name': self.new_name})
+        try:
+            self.server.invoke_successfully(export_policy_rename,
+                                            enable_tunneling=True)
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error renaming export-policy %s:%s'
+                                  % (self.name, to_native(error)),
+                                  exception=traceback.format_exc())
+
+    def apply(self):
+        """
+        Apply action to export-policy
+        """
+        changed = False
+        export_policy_exists = False
+        netapp_utils.ems_log_event("na_ontap_export_policy", self.server)
+        rename_flag = False
+        export_policy_details = self.get_export_policy()
+        if export_policy_details:
+            export_policy_exists = True
+            if self.state == 'present':
+                if self.new_name is not None:
+                    if self.new_name != self.name and self.new_name != export_policy_details['policy-name']:  # rename
+                        changed = True
+                        rename_flag = True
+            elif self.state == 'absent':  # delete
+                changed = True
+        else:
+            if self.state == 'present':  # create
+                changed = True
+        if changed:
+            if self.module.check_mode:
+                pass
+            else:
+                if self.state == 'present':  # execute create
+                    if not export_policy_exists:
+                        self.create_export_policy()
+                    else:  # execute rename
+                        if rename_flag:
+                            self.rename_export_policy()
+                elif self.state == 'absent':  # execute delete
+                    self.delete_export_policy()
+
+        self.module.exit_json(changed=changed)
+
+
+def main():
+    """
+    Execute action
+    """
+    export_policy = NetAppONTAPExportPolicy()
+    export_policy.apply()
+
+
+if __name__ == '__main__':
+    main()
diff --git a/lib/ansible/modules/storage/netapp/na_ontap_export_policy_rule.py b/lib/ansible/modules/storage/netapp/na_ontap_export_policy_rule.py
new file mode 100644
index 0000000000..634fc7b526
--- /dev/null
+++ b/lib/ansible/modules/storage/netapp/na_ontap_export_policy_rule.py
@@ -0,0 +1,528 @@
+#!/usr/bin/python
+
+# (c) 2018, NetApp, Inc
+# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
+
+from __future__ import absolute_import, division, print_function
+__metaclass__ = type
+
+
+ANSIBLE_METADATA = {'metadata_version': '1.1',
+                    'status': ['preview'],
+                    'supported_by': 'community'}
+
+
+DOCUMENTATION = '''
+
+module: na_ontap_export_policy_rule
+
+short_description: Manage ONTAP Export rules
+extends_documentation_fragment:
+    - netapp.na_ontap
+version_added: '2.6'
+author: Suhas Bangalore Shekar (bsuhas@netapp.com), Archana Ganeshan (garchana@netapp.com)
+
+description:
+- Create or delete or modify export rules in ONTAP
+
+options:
+  state:
+    description:
+    - Whether the specified export policy rule should exist or not.
+    required: false
+    choices: ['present', 'absent']
+    default: present
+
+  policy_name:
+    description:
+    - The name of the export rule to manage.
+    required: True
+
+  client_match:
+    description:
+    - List of Client Match Hostnames, IP Addresses, Netgroups, or Domains
+
+  ro_rule:
+    description:
+    - Read only access specifications for the rule
+    choices: ['any','none','never','krb5','krb5i','krb5p','ntlm','sys']
+
+  rw_rule:
+    description:
+    - Read Write access specifications for the rule
+    choices: ['any','none','never','krb5','krb5i','krb5p','ntlm','sys']
+
+  super_user_security:
+    description:
+    - Read Write access specifications for the rule
+    choices: ['any','none','never','krb5','krb5i','krb5p','ntlm','sys']
+
+  allow_suid:
+    description:
+    - If 'true', NFS server will honor SetUID bits in SETATTR operation. Default value is 'true'
+    choices: ['True', 'False']
+
+  protocol:
+    description:
+    - Client access protocol. Default value is 'any'
+    choices: [any,nfs,nfs3,nfs4,cifs,flexcache]
+    default: any
+
+  rule_index:
+    description:
+    - rule index of the export policy for delete and modify
+
+  vserver:
+    description:
+    - Name of the vserver to use.
+    required: true
+
+'''
+
+EXAMPLES = """
+    - name: Create ExportPolicyRule
+      na_ontap_export_policy_rule:
+        state: present
+        policy_name: default123
+        vserver: ci_dev
+        client_match: 0.0.0.0/0
+        ro_rule: any
+        rw_rule: any
+        protocol: any
+        super_user_security: any
+        allow_suid: true
+        hostname: "{{ netapp_hostname }}"
+        username: "{{ netapp_username }}"
+        password: "{{ netapp_password }}"
+
+    - name: Delete ExportPolicyRule
+      na_ontap_export_policy_rule:
+        state: absent
+        policy_name: default123
+        hostname: "{{ netapp_hostname }}"
+        username: "{{ netapp_username }}"
+        password: "{{ netapp_password }}"
+
+    - name: Modify ExportPolicyRule
+      na_ontap_export_policy_rule:
+        state: present
+        policy_name: default123
+        client_match: 0.0.0.0/0
+        ro_rule: any
+        rw_rule: any
+        super_user_security: none
+        protocol: any
+        allow_suid: false
+        hostname: "{{ netapp_hostname }}"
+        username: "{{ netapp_username }}"
+        password: "{{ netapp_password }}"
+"""
+
+RETURN = """
+
+
+"""
+import traceback
+
+import json
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils._text import to_native
+import ansible.module_utils.netapp as netapp_utils
+
+
+HAS_NETAPP_LIB = netapp_utils.has_netapp_lib()
+
+
+class NetAppontapExportRule(object):
+    ''' object initialize and class methods '''
+
+    def __init__(self):
+
+        self.argument_spec = netapp_utils.na_ontap_host_argument_spec()
+        self.argument_spec.update(dict(
+            state=dict(required=False, type='str', choices=['present', 'absent'], default='present'),
+            policy_name=dict(required=True, type='str'),
+            protocol=dict(required=False,
+                          type='str', default='any',
+                          choices=['any', 'nfs', 'nfs3', 'nfs4', 'cifs', 'flexcache']),
+            client_match=dict(required=False, type='str'),
+            ro_rule=dict(required=False,
+                         type='str', default=None,
+                         choices=['any', 'none', 'never', 'krb5', 'krb5i', 'krb5p', 'ntlm', 'sys']),
+            rw_rule=dict(required=False,
+                         type='str', default=None,
+                         choices=['any', 'none', 'never', 'krb5', 'krb5i', 'krb5p', 'ntlm', 'sys']),
+            super_user_security=dict(required=False,
+                                     type='str', default=None,
+                                     choices=['any', 'none', 'never', 'krb5', 'krb5i', 'krb5p', 'ntlm', 'sys']),
+            allow_suid=dict(required=False, choices=['True', 'False']),
+            rule_index=dict(required=False, type='int', default=None),
+            vserver=dict(required=True, type='str'),
+        ))
+
+        self.module = AnsibleModule(
+            argument_spec=self.argument_spec,
+            required_if=[
+                ('state', 'present', ['client_match', 'ro_rule', 'rw_rule']),
+                ('state', 'absent', ['client_match'])
+            ],
+            supports_check_mode=True
+        )
+
+        parameters = self.module.params
+
+        # set up state variables
+        self.state = parameters['state']
+        self.policy_name = parameters['policy_name']
+        self.protocol = parameters['protocol']
+        self.client_match = parameters['client_match']
+        self.ro_rule = parameters['ro_rule']
+        self.rw_rule = parameters['rw_rule']
+        self.allow_suid = parameters['allow_suid']
+        self.vserver = parameters['vserver']
+        self.super_user_security = parameters['super_user_security']
+
+        if HAS_NETAPP_LIB is False:
+            self.module.fail_json(
+                msg="the python NetApp-Lib module is required")
+        else:
+            self.server = netapp_utils.setup_na_ontap_zapi(
+                module=self.module, vserver=self.vserver)
+
+    def get_export_policy_rule(self):
+        """
+        Return details about the export policy rule
+        :param:
+            name : Name of the export_policy
+        :return: Details about the export_policy. None if not found.
+        :rtype: dict
+        """
+        rule_iter = netapp_utils.zapi.NaElement('export-rule-get-iter')
+        rule_info = netapp_utils.zapi.NaElement('export-rule-info')
+        rule_info.add_new_child('policy-name', self.policy_name)
+        if self.vserver:
+            rule_info.add_new_child('vserver-name', self.vserver)
+        else:
+            if self.client_match:
+                rule_info.add_new_child('client-match', self.client_match)
+
+        query = netapp_utils.zapi.NaElement('query')
+        query.add_child_elem(rule_info)
+
+        rule_iter.add_child_elem(query)
+        result = self.server.invoke_successfully(rule_iter, True)
+        return_value = None
+
+        if result.get_child_by_name('num-records') and \
+                int(result.get_child_content('num-records')) == 1:
+
+            export_policy_rule_details = result.get_child_by_name('attributes-list').\
+                get_child_by_name('export-rule-info')
+            export_policy_name = export_policy_rule_details.get_child_content(
+                'policy-name')
+            export_rule_index = export_policy_rule_details.get_child_content(
+                'rule-index')
+            export_rule_protocol = export_policy_rule_details.get_child_by_name(
+                'protocol').get_child_content('access-protocol')
+            export_rule_ro_rule = export_policy_rule_details.get_child_by_name(
+                'ro-rule').get_child_content('security-flavor')
+            export_rule_rw_rule = export_policy_rule_details.get_child_by_name(
+                'rw-rule').get_child_content('security-flavor')
+            export_rule_super_user_security = export_policy_rule_details.get_child_by_name(
+                'super-user-security').get_child_content('security-flavor')
+            export_rule_allow_suid = export_policy_rule_details.get_child_content(
+                'is-allow-set-uid-enabled')
+            export_rule_client_match = export_policy_rule_details.get_child_content(
+                'client-match')
+            export_vserver = export_policy_rule_details.get_child_content(
+                'vserver-name')
+            return_value = {
+                'policy-name': export_policy_name,
+                'rule-index': export_rule_index,
+                'protocol': export_rule_protocol,
+                'ro-rule': export_rule_ro_rule,
+                'rw-rule': export_rule_rw_rule,
+                'super-user-security': export_rule_super_user_security,
+                'is-allow-set-uid-enabled': export_rule_allow_suid,
+                'client-match': export_rule_client_match,
+                'vserver': export_vserver
+            }
+
+        elif result.get_child_by_name('num-records') and \
+                int(result.get_child_content('num-records')) >= 1:
+            return_value = {
+                'policy-name': self.policy_name
+            }
+        return return_value
+
+    def get_export_policy(self):
+        """
+        Return details about the export-policy
+        :param:
+            name : Name of the export-policy
+
+        :return: Details about the export-policy. None if not found.
+        :rtype: dict
+        """
+        export_policy_iter = netapp_utils.zapi.NaElement(
+            'export-policy-get-iter')
+        export_policy_info = netapp_utils.zapi.NaElement('export-policy-info')
+        export_policy_info.add_new_child('policy-name', self.policy_name)
+        export_policy_info.add_new_child('vserver', self.vserver)
+
+        query = netapp_utils.zapi.NaElement('query')
+        query.add_child_elem(export_policy_info)
+
+        export_policy_iter.add_child_elem(query)
+
+        result = self.server.invoke_successfully(export_policy_iter, True)
+
+        return_value = None
+
+        # check if query returns the expected export-policy
+        if result.get_child_by_name('num-records') and \
+                int(result.get_child_content('num-records')) == 1:
+
+            result.get_child_by_name('attributes-list').\
+                get_child_by_name('export-policy-info').\
+                get_child_by_name('policy-name')
+            return_value = {
+                'policy-name': self.policy_name
+            }
+
+        return return_value
+
+    def create_export_policy_rule(self):
+        """
+        create rule for the export policy.
+        """
+        if self.allow_suid is not None:
+            export_rule_create = netapp_utils.zapi.NaElement.create_node_with_children(
+                'export-rule-create', **{'policy-name': self.policy_name,
+                                         'client-match': self.client_match,
+                                         'is-allow-set-uid-enabled': str(self.allow_suid)
+                                         })
+        else:
+            export_rule_create = netapp_utils.zapi.NaElement.create_node_with_children(
+                'export-rule-create', **{'policy-name': self.policy_name,
+                                         'client-match': self.client_match
+                                         })
+        export_rule_create.add_node_with_children(
+            'ro-rule', **{'security-flavor': self.ro_rule})
+        export_rule_create.add_node_with_children(
+            'rw-rule', **{'security-flavor': self.rw_rule})
+        if self.protocol:
+            export_rule_create.add_node_with_children(
+                'protocol', **{'access-protocol': self.protocol})
+        if self.super_user_security:
+            export_rule_create.add_node_with_children(
+                'super-user-security', **{'security-flavor': self.super_user_security})
+
+        try:
+            self.server.invoke_successfully(export_rule_create,
+                                            enable_tunneling=True)
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error creating export policy rule %s: %s'
+                                  % (self.policy_name, to_native(error)),
+                                  exception=traceback.format_exc())
+
+    def create_export_policy(self):
+        """
+        Creates an export policy
+        """
+        export_policy_create = netapp_utils.zapi.NaElement.create_node_with_children(
+            'export-policy-create', **{'policy-name': self.policy_name})
+        try:
+            self.server.invoke_successfully(export_policy_create,
+                                            enable_tunneling=True)
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error creating export-policy %s: %s'
+                                  % (self.policy_name, to_native(error)),
+                                  exception=traceback.format_exc())
+
+    def delete_export_policy_rule(self, rule_index):
+        """
+        delete rule for the export policy.
+        """
+        export_rule_delete = netapp_utils.zapi.NaElement.create_node_with_children(
+            'export-rule-destroy', **{'policy-name': self.policy_name,
+                                      'rule-index': str(rule_index)})
+
+        try:
+            self.server.invoke_successfully(export_rule_delete,
+                                            enable_tunneling=True)
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error deleting export policy rule %s: %s'
+                                  % (self.policy_name, to_native(error)),
+                                  exception=traceback.format_exc())
+
+    def modify_protocol(self, rule_index):
+        """
+        Modify the protocol.
+        """
+        export_rule_modify_protocol = netapp_utils.zapi.NaElement.create_node_with_children(
+            'export-rule-modify',
+            **{'policy-name': self.policy_name,
+               'rule-index': rule_index})
+        export_rule_modify_protocol.add_node_with_children(
+            'protocol', **{'access-protocol': self.protocol})
+        try:
+            self.server.invoke_successfully(export_rule_modify_protocol,
+                                            enable_tunneling=True)
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error modifying protocol %s: %s' % (self.policy_name, to_native(error)),
+                                  exception=traceback.format_exc())
+
+    def modify_ro_rule(self, rule_index):
+        """
+        Modify ro_rule.
+        """
+        export_rule_modify_ro_rule = netapp_utils.zapi.NaElement.create_node_with_children(
+            'export-rule-modify',
+            **{'policy-name': self.policy_name,
+               'rule-index': rule_index})
+        export_rule_modify_ro_rule.add_node_with_children(
+            'ro-rule', **{'security-flavor': self.ro_rule})
+        try:
+            self.server.invoke_successfully(export_rule_modify_ro_rule,
+                                            enable_tunneling=True)
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error modifying ro_rule %s: %s' % (self.ro_rule, to_native(error)),
+                                  exception=traceback.format_exc())
+
+    def modify_rw_rule(self, rule_index):
+        """
+        Modify rw_rule.
+        """
+        export_rule_modify_rw_rule = netapp_utils.zapi.NaElement.create_node_with_children(
+            'export-rule-modify',
+            **{'policy-name': self.policy_name,
+               'rule-index': rule_index})
+        export_rule_modify_rw_rule.add_node_with_children(
+            'rw-rule', **{'security-flavor': self.rw_rule})
+        try:
+            self.server.invoke_successfully(export_rule_modify_rw_rule,
+                                            enable_tunneling=True)
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error modifying rw_rule %s: %s' % (self.rw_rule, to_native(error)),
+                                  exception=traceback.format_exc())
+
+    def modify_super_user_security(self, rule_index):
+        """
+        Modify super_user_security.
+        """
+        export_rule_modify_super_user_security = netapp_utils.zapi.NaElement.create_node_with_children(
+            'export-rule-modify',
+            **{'policy-name': self.policy_name,
+               'rule-index': rule_index})
+        export_rule_modify_super_user_security.add_node_with_children(
+            'super-user-security', **{'security-flavor': self.super_user_security})
+        try:
+            self.server.invoke_successfully(export_rule_modify_super_user_security,
+                                            enable_tunneling=True)
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error modifying super_user_security %s: %s' % (self.super_user_security, to_native(error)),
+                                  exception=traceback.format_exc())
+
+    def modify_allow_suid(self, rule_index):
+        """
+        Modify allow_suid.
+        """
+        export_rule_modify_allow_suid = netapp_utils.zapi.NaElement.create_node_with_children(
+            'export-rule-modify',
+            **{'policy-name': self.policy_name,
+               'rule-index': rule_index,
+               'is-allow-set-uid-enabled': str(self.allow_suid)})
+        try:
+            self.server.invoke_successfully(export_rule_modify_allow_suid,
+                                            enable_tunneling=True)
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error modifying allow_suid %s: %s' % (self.allow_suid, to_native(error)),
+                                  exception=traceback.format_exc())
+
+    def apply(self):
+        '''Apply action to export-policy'''
+        changed = False
+        export_policy_rule_exists = None
+        export_rule_protocol_changed = False
+        export_rule_ro_rule_changed = False
+        export_rule_rw_rule_changed = False
+        export_rule_allow_suid_enabled = False
+        export_rule_clientmatch_changed = False
+        export_rule_superuser_changed = False
+        netapp_utils.ems_log_event("na_ontap_export_policy_rules", self.server)
+        export_policy_details = self.get_export_policy()
+
+        if not export_policy_details:
+            if self.state == 'present':
+                self.create_export_policy()
+        export_policy_rule_exists = self.get_export_policy_rule()
+        if self.state == 'absent':
+            if export_policy_rule_exists:  # delete
+                changed = True
+                rule_index = export_policy_rule_exists['rule-index']
+
+        elif self.state == 'present':
+            if export_policy_rule_exists:  # modify
+                rule_index = export_policy_rule_exists['rule-index']
+                if rule_index:
+                    if (self.protocol is not None) and \
+                            (export_policy_rule_exists['protocol'] != self.protocol):
+                        export_rule_protocol_changed = True
+                        changed = True
+                    if self.ro_rule is not None and \
+                            (export_policy_rule_exists['ro-rule'] != self.ro_rule):
+                        export_rule_ro_rule_changed = True
+                        changed = True
+                    if self.rw_rule is not None and \
+                            (export_policy_rule_exists['rw-rule'] != self.rw_rule):
+                        export_rule_rw_rule_changed = True
+                        changed = True
+                    if (self.allow_suid is not None) and \
+                            (export_policy_rule_exists['is-allow-set-uid-enabled'] != self.allow_suid):
+                        export_rule_allow_suid_enabled = True
+                        changed = True
+                    if (self.super_user_security is not None) and \
+                            (export_policy_rule_exists['super-user-security'] != self.super_user_security):
+                        export_rule_superuser_changed = True
+                        changed = True
+                    if self.client_match is not None and \
+                            (export_policy_rule_exists['client-match'] != self.client_match):
+                        export_rule_clientmatch_changed = True
+                        changed = True
+            else:  # create
+                changed = True
+        if changed:
+            if self.module.check_mode:
+                pass
+            else:
+                if self.state == 'present':
+                    if not export_policy_rule_exists:
+                        self.create_export_policy_rule()
+                    else:
+                        if export_rule_protocol_changed is True:
+                            self.modify_protocol(rule_index)
+                        if export_rule_ro_rule_changed is True:
+                            self.modify_ro_rule(rule_index)
+                        if export_rule_rw_rule_changed is True:
+                            self.modify_rw_rule(rule_index)
+                        if export_rule_allow_suid_enabled is True:
+                            self.modify_allow_suid(rule_index)
+                        if export_rule_clientmatch_changed is True:
+                            self.modify_client_match(rule_index)
+                        if export_rule_superuser_changed is True:
+                            self.modify_super_user_security(rule_index)
+                elif self.state == 'absent':
+                    self.delete_export_policy_rule(rule_index)
+
+        self.module.exit_json(changed=changed)
+
+
+def main():
+    ''' Create object and call apply '''
+    rule_obj = NetAppontapExportRule()
+    rule_obj.apply()
+
+
+if __name__ == '__main__':
+    main()
diff --git a/lib/ansible/modules/storage/netapp/na_ontap_igroup.py b/lib/ansible/modules/storage/netapp/na_ontap_igroup.py
new file mode 100644
index 0000000000..fba4f5b3cf
--- /dev/null
+++ b/lib/ansible/modules/storage/netapp/na_ontap_igroup.py
@@ -0,0 +1,354 @@
+#!/usr/bin/python
+''' this is igroup module
+
+ (c) 2018, NetApp, Inc
+ # GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
+'''
+
+from __future__ import absolute_import, division, print_function
+__metaclass__ = type
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+
+module: na_ontap_igroup
+short_description: ONTAP iSCSI igroup configuration
+extends_documentation_fragment:
+    - netapp.na_ontap
+version_added: '2.6'
+author: chhaya gunawat (chhayag@netapp.com), Chris Archibald (carchi@netapp.com), Suhas Bangalore Shekar (bsuhas@netapp.com)
+
+description:
+    - create, destroy or rename Igroups and add or remove initiator in igroups.
+
+options:
+  state:
+    description:
+    - Whether the specified Igroup should exist or not.
+    choices: ['present', 'absent']
+    default: present
+
+  name:
+    description:
+    - The name of the lun to manage.
+    required: true
+
+  initiator_group_type:
+    description:
+    - Type of the initiator group.
+    - Required when C(state=present).
+    choices: ['fcp', 'iscsi', 'mixed']
+
+  new_name:
+    description:
+    - New name to be given to initiator group.
+
+  ostype:
+    description:
+    - OS type of the initiators within the group.
+
+  initiator:
+    description:
+    - WWPN, WWPN Alias, or iSCSI name of Initiator to add or remove.
+
+  bind_portset:
+    description:
+    - Name of a current portset to bind to the newly created igroup.
+
+  force_remove_initiator:
+    description:
+    -  Forcibly remove the initiator even if there are existing LUNs mapped to this initiator group.
+    type: bool
+    default: False
+
+  vserver:
+    description:
+    - The name of the vserver to use.
+    required: true
+
+'''
+
+EXAMPLES = '''
+    - name: Create Igroup
+      na_ontap_igroup:
+        state: present
+        name: ansibleIgroup3
+        initiator-group-type: iscsi
+        ostype: linux
+        initiator: iqn.1994-05.com.redhat:scspa0395855001.rtp.openenglab.netapp.com
+        vserver: ansibleVServer
+        hostname: "{{ netapp_hostname }}"
+        username: "{{ netapp_username }}"
+        password: "{{ netapp_password }}"
+
+    - name: rename Igroup
+      na_ontap_igroup:
+        state: absent
+        name: ansibleIgroup3
+        initiator-group-type: iscsi
+        ostype: linux
+        initiator: iqn.1994-05.com.redhat:scspa0395855001.rtp.openenglab.netapp.com
+        vserver: ansibleVServer
+        hostname: "{{ netapp_hostname }}"
+        username: "{{ netapp_username }}"
+        password: "{{ netapp_password }}"
+
+    - name: remove Igroup
+      na_ontap_igroup:
+        state: absent
+        name: ansibleIgroup3
+        initiator-group-type: iscsi
+        ostype: linux
+        initiator: iqn.1994-05.com.redhat:scspa0395855001.rtp.openenglab.netapp.com
+        vserver: ansibleVServer
+        hostname: "{{ netapp_hostname }}"
+        username: "{{ netapp_username }}"
+        password: "{{ netapp_password }}"
+
+'''
+
+RETURN = '''
+'''
+
+import traceback
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils._text import to_native
+import ansible.module_utils.netapp as netapp_utils
+
+HAS_NETAPP_LIB = netapp_utils.has_netapp_lib()
+
+
+class NetAppOntapIgroup(object):
+
+    def __init__(self):
+
+        self.argument_spec = netapp_utils.na_ontap_host_argument_spec()
+        self.argument_spec.update(dict(
+            state=dict(required=False, choices=[
+                       'present', 'absent'], default='present'),
+            name=dict(required=True, type='str'),
+            new_name=dict(required=False, type='str', default=None),
+            ostype=dict(required=False, type='str'),
+            initiator_group_type=dict(required=False, type='str',
+                                      choices=['fcp', 'iscsi', 'mixed']),
+            initiator=dict(required=False, type='str'),
+            vserver=dict(required=True, type='str'),
+            force_remove_initiator=dict(required=False, type='bool', default=False),
+            bind_portset=dict(required=False, type='str')
+        ))
+
+        self.module = AnsibleModule(
+            argument_spec=self.argument_spec,
+            supports_check_mode=True
+        )
+
+        params = self.module.params
+
+        # set up state variables
+        self.state = params['state']
+        self.name = params['name']
+        self.ostype = params['ostype']
+        self.initiator_group_type = params['initiator_group_type']
+        self.initiator = params['initiator']
+        self.vserver = params['vserver']
+        self.new_name = params['new_name']
+        self.force_remove_initiator = params['force_remove_initiator']
+        self.bind_portset = params['bind_portset']
+
+        if HAS_NETAPP_LIB is False:
+            self.module.fail_json(
+                msg="the python NetApp-Lib module is required")
+        else:
+            self.server = netapp_utils.setup_na_ontap_zapi(
+                module=self.module, vserver=self.vserver)
+
+    def get_igroup(self):
+        """
+        Return details about the igroup
+        :param:
+            name : Name of the igroup
+
+        :return: Details about the igroup. None if not found.
+        :rtype: dict
+        """
+        igroup_info = netapp_utils.zapi.NaElement('igroup-get-iter')
+        igroup_attributes = netapp_utils.zapi.NaElement('initiator-group-info')
+        igroup_attributes.add_new_child('initiator-group-name', self.name)
+        query = netapp_utils.zapi.NaElement('query')
+        query.add_child_elem(igroup_attributes)
+        igroup_info.add_child_elem(query)
+        result = self.server.invoke_successfully(igroup_info, True)
+        return_value = None
+
+        if result.get_child_by_name('num-records') and \
+                int(result.get_child_content('num-records')) >= 1:
+
+            igroup_attributes = result.get_child_by_name(
+                'attributes-list').get_child_by_name(
+                    'igroup-attributes')
+            return_value = {
+                'name': self.name,
+            }
+
+        return return_value
+
+    def add_initiator(self):
+        """
+        Add the initiator.
+        """
+        options = {'initiator-group-name': self.name}
+
+        if self.initiator is not None:
+            options['initiator'] = self.initiator
+
+        igroup_add = netapp_utils.zapi.NaElement.create_node_with_children(
+            'igroup-add', **options)
+
+        try:
+            self.server.invoke_successfully(igroup_add,
+                                            enable_tunneling=True)
+            return True
+        except netapp_utils.zapi.NaApiError as error:
+            if to_native(error.code) == "9008":
+                # Error 9008 denotes Initiator group already contains initiator
+                return False
+            else:
+                self.module.fail_json(msg='Error adding igroup initiator %s: %s' % (self.name, to_native(error)),
+                                      exception=traceback.format_exc())
+
+    def remove_initiator(self):
+        """
+        Remove the initiator.
+        """
+        options = {'initiator': self.initiator}
+
+        options['initiator-group-name'] = self.name
+
+        igroup_remove = netapp_utils.zapi.NaElement.create_node_with_children(
+            'igroup-remove', **options)
+
+        try:
+            self.server.invoke_successfully(igroup_remove,
+                                            enable_tunneling=True)
+            return True
+        except netapp_utils.zapi.NaApiError as error:
+            if to_native(error.code) == "9007":
+                # Error 9007 denotes Initiator group does not contain initiator
+                return False
+            else:
+                self.module.fail_json(msg='Error removing igroup initiator %s: %s' % (self.name, to_native(error)),
+                                      exception=traceback.format_exc())
+
+    def create_igroup(self):
+        """
+        Create the igroup.
+        """
+        options = {'initiator-group-name': self.name}
+        if self.ostype is not None:
+            options['os-type'] = self.ostype
+        if self.initiator_group_type is not None:
+            options['initiator-group-type'] = self.initiator_group_type
+        if self.bind_portset is not None:
+            options['bind-portset'] = self.bind_portset
+
+        igroup_create = netapp_utils.zapi.NaElement.create_node_with_children(
+            'igroup-create', **options)
+
+        try:
+            self.server.invoke_successfully(igroup_create,
+                                            enable_tunneling=True)
+            self.add_initiator()
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error provisioning igroup %s: %s' % (self.name, to_native(error)),
+                                  exception=traceback.format_exc())
+
+    def delete_igroup(self):
+        """
+        Delete the igroup.
+        """
+        igroup_delete = netapp_utils.zapi.NaElement.create_node_with_children(
+            'igroup-destroy', **{'initiator-group-name': self.name, 'force': 'true' if self.force_remove_initiator else 'false'})
+
+        try:
+            self.server.invoke_successfully(igroup_delete,
+                                            enable_tunneling=True)
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error deleting igroup %s: %s' % (self.name, to_native(error)),
+                                  exception=traceback.format_exc())
+
+    def rename_igroup(self):
+        """
+        Rename the igroup.
+        """
+        igroup_rename = netapp_utils.zapi.NaElement.create_node_with_children(
+            'igroup-rename', **{'initiator-group-name': self.name, 'initiator-group-new-name': str(
+                self.new_name)})
+        try:
+            self.server.invoke_successfully(igroup_rename,
+                                            enable_tunneling=True)
+        except netapp_utils.zapi.NaApiError as error:
+            self.module.fail_json(msg='Error renaming igroup %s: %s' % (self.name, to_native(error)),
+                                  exception=traceback.format_exc())
+
+    def apply(self):
+        changed = False
+        igroup_exists = False
+        rename_igroup = False
+        initiator_changed = False
+        check = False
+        netapp_utils.ems_log_event("na_ontap_igroup", self.server)
+        igroup_detail = self.get_igroup()
+
+        if igroup_detail:
+            igroup_exists = True
+            if self.state == 'absent':
+                changed = True
+
+            elif self.state == 'present':
+                if self.new_name is not None and self.new_name != self.name:
+                    rename_igroup = True
+                    changed = True
+                if changed:
+                    check = True
+                if self.initiator:
+                    changed = True
+        else:
+            if self.state == 'present':
+                changed = True
+
+        if changed:
+            if self.module.check_mode:
+                pass
+            else:
+                if self.state == 'present':
+                    if not igroup_exists:
+                        self.create_igroup()
+                    else:
+                        if self.initiator:
+                            initiator_changed = self.add_initiator()
+                        if rename_igroup:
+                            self.rename_igroup()
+                        if (not check) and (not initiator_changed):
+                            changed = False
+
+                elif self.state == 'absent':
+                    if self.initiator:
+                        self.remove_initiator()
+                    self.delete_igroup()
+
+        self.module.exit_json(changed=changed)
+
+
+def main():
+    obj = NetAppOntapIgroup()
+    obj.apply()
+
+
+if __name__ == '__main__':
+    main()

commit 3bad03d57afc69ae1db3ba76ce52132fd4ad3e52
Author: Brian Coca <bcoca@ansible.com>
Date:   Fri Jun 19 16:30:20 2015 -0400

    cleaned up and optimized become handling paths

diff --git a/lib/ansible/plugins/connections/ssh.py b/lib/ansible/plugins/connections/ssh.py
index 7fb62e2263..56cf996e80 100644
--- a/lib/ansible/plugins/connections/ssh.py
+++ b/lib/ansible/plugins/connections/ssh.py
@@ -179,18 +179,19 @@ class Connection(ConnectionBase):
                 if self._connection_info.become_pass:
                     self.check_incorrect_password(stdout)
                 elif self.check_password_prompt(stdout):
-                    raise AnsibleError('Missing %s password', self._connection_info.become_method)
+                    raise AnsibleError('Missing %s password' % self._connection_info.become_method)
 
-            if p.stdout in rfd:
-                dat = os.read(p.stdout.fileno(), 9000)
-                stdout += dat
-                if dat == '':
-                    rpipes.remove(p.stdout)
             if p.stderr in rfd:
                 dat = os.read(p.stderr.fileno(), 9000)
                 stderr += dat
                 if dat == '':
                     rpipes.remove(p.stderr)
+            elif p.stdout in rfd:
+                dat = os.read(p.stdout.fileno(), 9000)
+                stdout += dat
+                if dat == '':
+                    rpipes.remove(p.stdout)
+
             # only break out if no pipes are left to read or
             # the pipes are completely read and
             # the process is terminated
@@ -324,9 +325,6 @@ class Connection(ConnectionBase):
                   * detect prompt on stderr (no-tty)
             '''
 
-            out = ''
-            err = ''
-
             debug("Handling privilege escalation password prompt.")
 
             if self._connection_info.become and self._connection_info.become_pass:
@@ -342,34 +340,30 @@ class Connection(ConnectionBase):
                         break
 
                     rfd, wfd, efd = select.select([p.stdout, p.stderr], [], [p.stdout], self._connection_info.timeout)
-                    if p.stderr in rfd:
+                    if not rfd:
+                        # timeout. wrap up process communication
+                        stdout, stderr = p.communicate()
+                        raise AnsibleError('Connection error waiting for privilege escalation password prompt: %s' % become_output)
+
+                    elif p.stderr in rfd:
                         chunk = p.stderr.read()
-                        if not chunk:
-                            raise AnsibleError('Connection closed waiting for privilege escalation password prompt: %s ' % become_output)
                         become_errput += chunk
-
                         self.check_incorrect_password(become_errput)
 
-                    if p.stdout in rfd:
+                    elif p.stdout in rfd:
                         chunk = p.stdout.read()
-                        if not chunk:
-                            raise AnsibleError('Connection closed waiting for privilege escalation password prompt: %s ' % become_output)
                         become_output += chunk
 
-                    if not rfd:
-                        # timeout. wrap up process communication
-                        stdout, stderr = p.communicate()
-                        raise AnsibleError('Connection error waiting for privilege escalation password prompt: %s' % become_output)
+                    if not chunk:
+                        raise AnsibleError('Connection closed waiting for privilege escalation password prompt: %s ' % become_output)
 
                 if not self.check_become_success(become_output):
                     debug("Sending privilege escalation password.")
                     stdin.write(self._connection_info.become_pass + '\n')
                 else:
-                    out += become_output
-                    err += become_errput
+                    no_prompt_out = become_output
+                    no_prompt_err = become_errput
 
-            no_prompt_out = out
-            no_prompt_err =  err
 
         (returncode, stdout, stderr) = self._communicate(p, stdin, in_data, sudoable=sudoable)
 

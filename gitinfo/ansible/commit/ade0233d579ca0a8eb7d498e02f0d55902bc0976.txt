commit ade0233d579ca0a8eb7d498e02f0d55902bc0976
Author: bradobro <brado@movedbylight.com>
Date:   Mon Jul 23 16:04:28 2012 +0000

    Refactoring test-module to be more like ansible.

diff --git a/hacking/test-module b/hacking/test-module
index 398597fd13..7d6567fadf 100755
--- a/hacking/test-module
+++ b/hacking/test-module
@@ -30,6 +30,7 @@ import sys
 import os
 import subprocess
 import traceback
+import optparse
 import ansible.utils as utils
 import ansible.module_common as module_common
 
@@ -38,67 +39,93 @@ try:
 except ImportError:
     import simplejson as json
 
-modfile = None
-
-if len(sys.argv) == 1:
-    print >>sys.stderr, "usage: test-module ./library/command [key=value ...]"
-    sys.exit(1)
-
-modfile = sys.argv[1]
-if len(sys.argv) > 1:
-    args = " ".join(sys.argv[2:])
-else:
-    args = ""
-
-argspath = os.path.expanduser("~/.ansible_test_module_arguments")
-argsfile = open(argspath, 'w')
-argsfile.write(args)
-argsfile.close()
-
-module_fh = open(modfile)
-module_data = module_fh.read()
-included_boilerplate = module_data.find(module_common.REPLACER) != -1
-module_fh.close()
-
-if included_boilerplate:
-    module_data = module_data.replace(module_common.REPLACER, module_common.MODULE_COMMON)
-    modfile2_path = os.path.expanduser("~/.ansible_module_generated")
-    print "* including generated source, if any, saving to: %s" % modfile2_path
-    print "* this will offset any line numbers in tracebacks!"
-    modfile2 = open(modfile2_path, 'w')
-    modfile2.write(module_data)
-    modfile2.close()
-    modfile = modfile2_path
-else:
-    print "* module boilerplate substitution not requested in module, tracebacks will be unaltered"
-
-os.system("chmod +x %s" % modfile)
-cmd = subprocess.Popen("%s %s" % (modfile, argspath), 
-    shell=True,
-    stdout=subprocess.PIPE, 
-    stderr=subprocess.PIPE)
-(out, err) = cmd.communicate()
-
-try:
-    print "***********************************"
-    print "RAW OUTPUT"
-    print out
-    print err
-    results = utils.parse_json(out)
+def parse():
+    """parse command line
+
+    :return : (options, args)"""
+    parser = optparse.OptionParser()
+
+    parser.usage = "%prog [options] (-h for help)"
+
+    parser.add_option('-m', '--module-name', dest='module_name',
+        help="module name to execute")
+    parser.add_option('-a', '--args', dest='module_args', default="",
+        help="module arguments")
+    parser.add_option('-D', '--debugger', dest='debugger', 
+        help="path to python debugger (e.g. /usr/bin/pdb)")
+    options, args = parser.parse_args()
+    if not options.module_name:
+        parser.print_help()
+        sys.exit(1)
+    else:
+        return options, args
+
+def write_argsfile( argstring):
+    """Write args to a file for the module's use.
     
-except:
-    print "***********************************"
-    print "INVALID OUTPUT FORMAT"
-    print out
-    traceback.print_exc()
-    sys.exit(1)
-
-print "***********************************"
-print "PARSED OUTPUT"
+    :return: full path to args file"""
+    argspath = os.path.expanduser("~/.ansible_test_module_arguments")
+    argsfile = open(argspath, 'w')
+    argsfile.write(argstring)
+    argsfile.close()
+    return argspath
+
+def boilerplate_module( modfile):
+    module_fh = open(modfile)
+    module_data = module_fh.read()
+    included_boilerplate = module_data.find(module_common.REPLACER) != -1
+    module_fh.close()
+
+    if included_boilerplate:
+        module_data = module_data.replace(module_common.REPLACER, module_common.MODULE_COMMON)
+        modfile2_path = os.path.expanduser("~/.ansible_module_generated")
+        print "* including generated source, if any, saving to: %s" % modfile2_path
+        print "* this will offset any line numbers in tracebacks/debuggers!"
+        modfile2 = open(modfile2_path, 'w')
+        modfile2.write(module_data)
+        modfile2.close()
+        modfile = modfile2_path
+        return modfile2_path
+    else:
+        print "* module boilerplate substitution not requested in module, line numbers will be unaltered"
+        return modfile
+
+def main(): 
+    options, args = parse()
+
+    argspath = write_argsfile( options.module_args)
+    modfile = boilerplate_module( options.module_name)
+    print argspath, modfile
+    sys.exit(0)
+    #===== run or debug the module
+    os.system("chmod +x %s" % modfile)
+    cmd = subprocess.Popen("%s %s" % (modfile, argspath), 
+        shell=True,
+        stdout=subprocess.PIPE, 
+        stderr=subprocess.PIPE)
+    (out, err) = cmd.communicate()
+
+    try:
+        print "***********************************"
+        print "RAW OUTPUT"
+        print out
+        print err
+        results = utils.parse_json(out)
+        
+    except:
+        print "***********************************"
+        print "INVALID OUTPUT FORMAT"
+        print out
+        traceback.print_exc()
+        sys.exit(1)
 
-print utils.jsonify(results,format=True)
+    print "***********************************"
+    print "PARSED OUTPUT"
 
-sys.exit(0)
+    print utils.jsonify(results,format=True)
 
+	
+if __name__ == "__main__":
+    main()
 
 

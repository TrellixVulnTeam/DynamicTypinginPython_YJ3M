commit 3f17ad62cdd31173fc4e891efd12c734188003d7
Author: Peter Sankauskas <pas256@gmail.com>
Date:   Sun Jul 15 14:34:24 2012 -0400

    Squashed commit of the following:
    
    commit 5b9d29e08fba6402efccaa1ca56d834ff58f4b55
    Merge: 7286f3a 111561f
    Author: Michael DeHaan <michael.dehaan@gmail.com>
    Date:   Sun Jul 15 14:34:10 2012 -0400
    
        Merge branch 'devel' of https://github.com/pas256/ansible into pasec2
    
    commit 111561f7829b517fb0b7577a0e2147292bdba58f
    Author: Peter Sankauskas <pas256@gmail.com>
    Date:   Mon Jul 16 16:13:48 2012 -0700
    
        Reading the config file from the same directory as the script, and
        fixing typo in security group name
    
    commit e63659d04e65c0be3db833038f55a21d2ec511a9
    Author: Peter Sankauskas <pas256@gmail.com>
    Date:   Mon Jul 16 10:56:59 2012 -0700
    
        Adding list of variables to documentation
    
    commit d0aecf025e23cf26f3df5a253639b0ec425b7223
    Author: Peter Sankauskas <pas256@gmail.com>
    Date:   Fri Jul 13 15:35:00 2012 -0700
    
        Finished EC2 external inventory script
    
    commit 136b8a50824b7f964f162fad153784899d6dd634
    Author: Peter Sankauskas <pas256@gmail.com>
    Date:   Thu Jul 12 18:01:44 2012 -0700
    
        Almost done, just a few more types to deal with
    
    commit 09f92052ce2e21a2c216692a20ce1bb03eacc2d9
    Author: Peter Sankauskas <pas256@gmail.com>
    Date:   Tue Jul 10 23:43:30 2012 -0700
    
        Adding region options to config, and getting host details happening, but
        need to figure out complex types
    
    commit a940c9b8fb9258043ec4f4a37fef80fdbcfcda7b
    Author: Peter Sankauskas <pas256@gmail.com>
    Date:   Tue Jul 10 18:06:05 2012 -0700
    
        Converting to a class, commenting methods, reading settings from a
        config file, and starting to work on the host variables
    
    commit 43eb3214a6bdd65d3ef3961183252932b6984004
    Author: Peter Sankauskas <pas256@gmail.com>
    Date:   Mon Jul 9 13:11:27 2012 -0700
    
        First pass of the Ansible EC2 inventory script

diff --git a/examples/scripts/ec2.ini b/examples/scripts/ec2.ini
new file mode 100644
index 0000000000..cb4979df14
--- /dev/null
+++ b/examples/scripts/ec2.ini
@@ -0,0 +1,42 @@
+# Ansible EC2 external inventory script settings
+#
+
+[ec2]
+
+# AWS regions to make calls to. Set this to 'all' to make request to all regions
+# in AWS and merge the results together. Alternatively, set this to a comma
+# separated list of regions. E.g. 'us-east-1,us-west-1,us-west-2'
+regions = all
+
+# When generating inventory, Ansible needs to know how to address a server.
+# Each EC2 instance has a lot of variables associated with it. Here is the list:
+#   http://docs.pythonboto.org/en/latest/ref/ec2.html#module-boto.ec2.instance
+# Below are 2 variables that are used as the address of a server:
+#   - destination_variable
+#   - vpc_destination_variable
+
+# This is the normal destination variable to use. If you are running Ansible
+# from outside EC2, then 'public_dns_name' makes the most sense. If you are
+# running Ansible from within EC2, then perhaps you want to use the internal
+# address, and should set this to 'private_dns_name'.
+destination_variable = public_dns_name
+
+# For server inside a VPC, using DNS names may not make sense. When an instance
+# has 'subnet_id' set, this variable is used. If the subnet is public, setting
+# this to 'ip_address' will return the public IP address. For instances in a
+# private subnet, this should be set to 'private_ip_address', and Ansible must
+# be run from with EC2.
+vpc_destination_variable = ip_address
+
+# API calls to EC2 are slow. For this reason, we cache the results of an API
+# call. Set this to the path you want cache files to be written to. Two files
+# will be written to this directory:
+#   - ansible-ec2.cache
+#   - ansible-ec2.index
+cache_path = /tmp
+
+# The number of seconds a cache file is considered valid. After this many
+# seconds, a new API call will be made, and the cache file will be updated.
+cache_max_age = 300
+
+
diff --git a/examples/scripts/ec2_external_inventory.py b/examples/scripts/ec2_external_inventory.py
new file mode 100755
index 0000000000..9c2733e6d8
--- /dev/null
+++ b/examples/scripts/ec2_external_inventory.py
@@ -0,0 +1,377 @@
+#!/usr/bin/python -tt
+
+'''
+EC2 external inventory script
+=================================
+
+Generates inventory that Ansible can understand by making API request to
+AWS EC2 using the Boto library. 
+
+NOTE: This script assumes Ansible is being executed where the environment
+variables needed for Boto have already been set:
+    export AWS_ACCESS_KEY_ID='AK123'
+    export AWS_SECRET_ACCESS_KEY='abc123'
+    
+For more details, see: http://docs.pythonboto.org/en/latest/boto_config_tut.html
+
+When run against a specific host, this script returns the following variables:
+ - ec2_ami_launch_index
+ - ec2_architecture
+ - ec2_association
+ - ec2_attachTime
+ - ec2_attachment
+ - ec2_attachmentId
+ - ec2_client_token
+ - ec2_deleteOnTermination
+ - ec2_description
+ - ec2_deviceIndex
+ - ec2_dns_name
+ - ec2_eventsSet
+ - ec2_group_name
+ - ec2_hypervisor
+ - ec2_id
+ - ec2_image_id
+ - ec2_instanceState
+ - ec2_instance_type
+ - ec2_ipOwnerId
+ - ec2_ip_address
+ - ec2_item
+ - ec2_kernel
+ - ec2_key_name
+ - ec2_launch_time
+ - ec2_monitored
+ - ec2_monitoring
+ - ec2_networkInterfaceId
+ - ec2_ownerId
+ - ec2_persistent
+ - ec2_placement
+ - ec2_platform
+ - ec2_previous_state
+ - ec2_private_dns_name
+ - ec2_private_ip_address
+ - ec2_publicIp
+ - ec2_public_dns_name
+ - ec2_ramdisk
+ - ec2_reason
+ - ec2_region
+ - ec2_requester_id
+ - ec2_root_device_name
+ - ec2_root_device_type
+ - ec2_security_group_ids
+ - ec2_security_group_names
+ - ec2_shutdown_state
+ - ec2_sourceDestCheck
+ - ec2_spot_instance_request_id
+ - ec2_state
+ - ec2_state_code
+ - ec2_state_reason
+ - ec2_status
+ - ec2_subnet_id
+ - ec2_tenancy
+ - ec2_virtualization_type
+ - ec2_vpc_id
+
+These variables are pulled out of a boto.ec2.instance object. There is a lack of
+consistency with variable spellings (camelCase and underscores) since this
+just loops through all variables the object exposes. It is preferred to use the
+ones with underscores when multiple exist.
+
+In addition, if an instance has AWS Tags associated with it, each tag is a new
+variable named:
+ - ec2_tag_[Key] = [Value]
+
+Security groups are comma-separated in 'ec2_security_group_ids' and 
+'ec2_security_group_names'.
+'''
+
+# (c) 2012, Peter Sankauskas
+#
+# This file is part of Ansible,
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+
+######################################################################
+
+import os
+import argparse
+import re
+from time import time
+from boto import ec2
+import ConfigParser
+
+try:
+    import json
+except ImportError:
+    import simplejson as json
+
+
+class Ec2Inventory(object):
+    def __init__(self):
+        ''' Main execution path '''
+        
+        # Inventory grouped by instance IDs, tags, security groups, regions,
+        # and availability zones
+        self.inventory = {}
+        
+        # Index of hostname (address) to instance ID
+        self.index = {}
+        
+        # Read settings and parse CLI arguments
+        self.read_settings()
+        self.parse_cli_args()
+        
+        # Cache
+        if self.args.refresh_cache:
+            self.do_api_calls_update_cache()  
+        elif not self.is_cache_valid():
+            self.do_api_calls_update_cache()
+        
+        # Data to print
+        if self.args.host:
+            data_to_print = self.get_host_info()
+        
+        elif self.args.list:
+            # Display list of instances for inventory
+            if len(self.inventory) == 0:
+                data_to_print = self.get_inventory_from_cache()
+            else:
+                data_to_print = self.json_format_dict(self.inventory, True)
+              
+        print data_to_print
+        
+        
+    def is_cache_valid(self):
+        ''' Determines if the cache files have expired, or if it is still valid '''
+
+        if os.path.isfile(self.cache_path_cache):
+            mod_time = os.path.getmtime(self.cache_path_cache)
+            current_time = time()
+            if (mod_time + self.cache_max_age) > current_time:
+                if os.path.isfile(self.cache_path_index):
+                    return True
+                
+        return False
+        
+        
+    def read_settings(self):
+        ''' Reads the settings from the ec2.ini file '''
+        
+        config = ConfigParser.SafeConfigParser()
+        config.read(os.path.dirname(os.path.realpath(__file__)) + '/ec2.ini')
+        
+        # Regions
+        self.regions = []
+        configRegions = config.get('ec2', 'regions')
+        if (configRegions == 'all'):
+            for regionInfo in ec2.regions():
+                self.regions.append(regionInfo.name)
+        else:
+            self.regions = configRegions.split(",")
+        
+        # Destination addresses
+        self.destination_variable = config.get('ec2', 'destination_variable')
+        self.vpc_destination_variable = config.get('ec2', 'vpc_destination_variable')
+
+        # Cache related
+        cache_path = config.get('ec2', 'cache_path')
+        self.cache_path_cache = cache_path + "/ansible-ec2.cache"
+        self.cache_path_index = cache_path + "/ansible-ec2.index"
+        self.cache_max_age = config.getint('ec2', 'cache_max_age')
+        
+        
+    def parse_cli_args(self):
+        ''' Command line argument processing '''
+        
+        parser = argparse.ArgumentParser(description='Produce an Ansible Inventory file based on EC2')
+        parser.add_argument('--list', action='store_true', default=True, 
+                           help='List instances (default: True)')
+        parser.add_argument('--host', action='store', 
+                           help='Get all the variables about a specific instance')
+        parser.add_argument('--refresh-cache', action='store_true', default=False, 
+                           help='Force refresh of cache by making API requests to EC2 (default: False - use cache files)')
+        self.args = parser.parse_args()
+        
+        
+    def do_api_calls_update_cache(self):
+        ''' Do API calls to each region, and save data in cache files '''
+        
+        for region in self.regions:
+            self.get_instances_by_region(region)
+        
+        self.write_to_cache(self.inventory, self.cache_path_cache)
+        self.write_to_cache(self.index, self.cache_path_index)
+
+
+    def get_instances_by_region(self, region):
+        ''' Makes an AWS EC2 API call to the list of instances in a particular
+        region '''
+        
+        conn = ec2.connect_to_region(region)
+        reservations = conn.get_all_instances()
+        for reservation in reservations:
+            for instance in reservation.instances:
+                self.add_instance(instance, region)
+
+
+    def get_instance(self, region, instance_id):
+        ''' Gets details about a specific instance '''
+        conn = ec2.connect_to_region(region)
+        reservations = conn.get_all_instances([instance_id])
+        for reservation in reservations:
+            for instance in reservation.instances:
+                return instance
+            
+        
+    def add_instance(self, instance, region):
+        ''' Adds an instance to the inventory and index, as long as it is
+        addressable '''
+        
+        # Only want running instances
+        if instance.state == 'terminated':
+            return
+        
+        # Select the best destination address
+        if instance.subnet_id:
+            dest = getattr(instance, self.vpc_destination_variable)
+        else:
+            dest =  getattr(instance, self.destination_variable)
+
+        if dest == None:
+            # Skip instances we cannot address (e.g. private VPC subnet)
+            return
+
+        # Add to index
+        self.index[dest] = [region, instance.id]
+
+        # Inventory: Group by instance ID (always a group of 1)
+        self.inventory[instance.id] = [dest]
+        
+        # Inventory: Group by region
+        self.push(self.inventory, region, dest)
+                        
+        # Inventory: Group by availability zone
+        self.push(self.inventory, instance.placement, dest)
+        
+        # Inventory: Group by security group
+        for group in instance.groups:
+            key = self.to_safe("security_group_" + group.name)
+            self.push(self.inventory, key, dest)
+                
+        # Inventory: Group by tag keys
+        for k, v in instance.tags.iteritems():
+            key = self.to_safe("tag_" + k + "=" + v)
+            self.push(self.inventory, key, dest)        
+    
+    
+    def get_host_info(self):
+        ''' Get variables about a specific host '''
+        
+        if len(self.index) == 0:
+            # Need to load index from cache
+            self.load_index_from_cache()
+        
+        (region, instance_id) = self.index[self.args.host]
+        instance = self.get_instance(region, instance_id)
+        instance_vars = {}
+        for key in vars(instance):
+            value = getattr(instance, key)
+            key = self.to_safe('ec2_' + key)
+            
+            # Handle complex types
+            if type(value) in [int, bool]:
+                instance_vars[key] = value
+            elif type(value) in [str, unicode]:
+                instance_vars[key] = value.strip()
+            elif type(value) == type(None):
+                instance_vars[key] = ''
+            elif key == 'ec2_region':
+                instance_vars[key] = value.name
+            elif key == 'ec2_tags':
+                for k, v in value.iteritems():
+                    key = self.to_safe('ec2_tag_' + k)
+                    instance_vars[key] = v
+            elif key == 'ec2_groups':
+                group_ids = []
+                group_names = []
+                for group in value:
+                    group_ids.append(group.id)
+                    group_names.append(group.name)
+                instance_vars["ec2_security_group_ids"] = ','.join(group_ids)
+                instance_vars["ec2_security_group_names"] = ','.join(group_names)
+            else:
+                pass
+                # TODO Product codes if someone finds them useful
+                #print key
+                #print type(value)
+                #print value
+                           
+        return self.json_format_dict(instance_vars, True)        
+    
+    
+    def push(self, my_dict, key, element):
+        ''' Pushed an element onto an array that may not have been defined in
+        the dict '''
+        
+        if key in my_dict:
+            my_dict[key].append(element);
+        else:
+            my_dict[key] = [element]        
+    
+    
+    def get_inventory_from_cache(self):
+        ''' Reads the inventory from the cache file and returns it as a JSON
+        object '''
+
+        cache = open(self.cache_path_cache, 'r')
+        json_inventory = cache.read()
+        return json_inventory
+
+
+    def load_index_from_cache(self):
+        ''' Reads the index from the cache file sets self.index '''
+
+        cache = open(self.cache_path_index, 'r')
+        json_index = cache.read()
+        self.index = json.loads(json_index)
+    
+    
+    def write_to_cache(self, data, filename):
+        ''' Writes data in JSON format to a file '''
+        
+        json_data = self.json_format_dict(data, True)
+        cache = open(filename, 'w')
+        cache.write(json_data)
+        cache.close()
+        
+        
+    def to_safe(self, word):
+        ''' Converts 'bad' characters in a string to underscores so they can be
+        used as Ansible groups '''
+        
+        return re.sub("[^A-Za-z0-9\-]", "_", word)
+        
+        
+    def json_format_dict(self, data, pretty=False):
+        ''' Converts a dict to a JSON object and dumps it as a formatted
+        string '''
+        
+        if pretty:
+            return json.dumps(data, sort_keys=True, indent=2)
+        else:
+            return json.dumps(data)
+        
+    
+# Run the script
+Ec2Inventory()
+

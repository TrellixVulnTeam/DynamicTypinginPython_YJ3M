commit cae88ca12f1eec2251da504253f48846722341a9
Author: James Cammarata <jimi@sngx.net>
Date:   Fri Oct 3 07:08:03 2014 -0500

    Initial work to refactor Task

diff --git a/v2/ansible/playbook/__init__.py b/v2/ansible/playbook/__init__.py
index 0671c261ff..6b9cfa6ce6 100644
--- a/v2/ansible/playbook/__init__.py
+++ b/v2/ansible/playbook/__init__.py
@@ -15,7 +15,7 @@
 # You should have received a copy of the GNU General Public License
 # along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
 
-import v2.utils
+import ansible.utils
 
 class Playbook(object):
     def __init__(self, filename):
diff --git a/v2/ansible/playbook/base.py b/v2/ansible/playbook/base.py
index 3b4785ee46..ac7748caf7 100644
--- a/v2/ansible/playbook/base.py
+++ b/v2/ansible/playbook/base.py
@@ -15,8 +15,49 @@
 # You should have received a copy of the GNU General Public License
 # along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
 
+from errors import AnsibleError
+from playbook.tag import Tag
+
 class Base(object):
 
-   def __init__(self):
-       pass
+    def __init__(self):
+        self._tags = Tag()
+
+    def _ensure_int(self, attr, default=0):
+        value = getattr(self, attr)
+        if value is None:
+            setattr(self, attr, default)
+        elif not isinstance(value, int):
+            try:
+                setattr(self, attr, int(value))
+            except ValueError:
+                raise AnsibleError("failed to set attr %s to an integer, got '%s' which is a %s" % (attr, value, type(value)))
+
+    def _ensure_bool(self, attr, default=False):
+        value = getattr(self, attr)
+        if value is None:
+            setattr(self, attr, default)
+        elif not isinstance(value, bool):
+            setattr(self, attr, utils.boolean(value))
+
+    def _ensure_basestring(self, attr, default=""):
+        value = getattr(self, attr)
+        if value is None:
+            setattr(self, attr, default)
+        elif not isinstance(value, basestring):
+            setattr(self, attr, "%s" % value)
 
+    def _ensure_list_of_strings(self, attr, default=[]):
+        value = getattr(self, attr)
+        if value is None:
+            setattr(self, attr, default)
+        elif not isinstance(value, list):
+            setattr(self, attr, [ str(value) ])
+        else:
+            changed = False
+            for idx,val in enumerate(value):
+                if not isinstance(val, basestring):
+                    value[idx] = str(val)
+                    changed = True
+            if changed:
+                setattr(self, attr, value)
diff --git a/v2/ansible/playbook/conditional.py b/v2/ansible/playbook/conditional.py
index 6be68607a0..56028e29ea 100644
--- a/v2/ansible/playbook/conditional.py
+++ b/v2/ansible/playbook/conditional.py
@@ -15,15 +15,16 @@
 # You should have received a copy of the GNU General Public License
 # along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
 
-import v2.config as C
-from v2.utils import template
-from v2.utils import list_union
-
 class Conditional(object):
 
     def __init__(self, task):
-        pass
+        self._task = task
+        self._conditionals = []
 
     def evaluate(self, context):
         pass
 
+    def push(self, conditionals):
+        if not isinstance(conditionals, list):
+            conditionals = [ conditionals ]
+        self._conditionals.extend(conditionals)
diff --git a/v2/ansible/playbook/tag.py b/v2/ansible/playbook/tag.py
index 239038ea88..a992f8dee0 100644
--- a/v2/ansible/playbook/tag.py
+++ b/v2/ansible/playbook/tag.py
@@ -15,19 +15,25 @@
 # You should have received a copy of the GNU General Public License
 # along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
 
-from v2.errors import AnsibleError
-from v2.utils import list_union
+from errors import AnsibleError
+from ansible.utils import list_union
 
 class Tag(object):
     def __init__(self, tags=[]):
-        self.tags = tags
+        assert isinstance(tags, list)
+        self._tags = tags
 
-    def push(self, tag):
-        if tag not in self.tags:
-            self.tags.append(tag)
+    def push(self, tags):
+        if not isinstance(tags, list):
+            tags = [ tags ]
+        for tag in tags:
+            if not isinstance(tag, basestring):
+                tag = str(tag)
+            if tag not in self._tags:
+                self._tags.append(tag)
 
     def get_tags(self):
-        return self.tags
+        return self._tags
 
     def merge(self, tags):
         # returns a union of the tags, which can be a string,
@@ -38,8 +44,8 @@ class Tag(object):
             tags = Tag(tags)
         elif not isinstance(tags, Tag):
             raise AnsibleError('expected a Tag() instance, instead got %s' % type(tags))
-        return utils.list_union(self.tags, tags.get_tags())
+        return utils.list_union(self._tags, tags.get_tags())
 
     def matches(self, tag):
-        return tag in self.tags
+        return tag in self._tags
         
diff --git a/v2/ansible/playbook/task.py b/v2/ansible/playbook/task.py
index 2979ba2146..dc01515145 100644
--- a/v2/ansible/playbook/task.py
+++ b/v2/ansible/playbook/task.py
@@ -15,17 +15,205 @@
 # You should have received a copy of the GNU General Public License
 # along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
 
-from v2.playbook.base import PlaybookBase
+from playbook.base import Base
+from playbook.conditional import Conditional
+from errors import AnsibleError
+from ansible import utils
+
+class Task(Base):
+
+    # the list of valid keys for tasks
+    VALID_KEYS = [
+        'always_run',
+        'any_errors_fatal',
+        'async',
+        'connection',
+        'delay',
+        'delegate_to',
+        'environment',
+        'first_available_file',
+        'ignore_errors',
+        'include',
+        'local_action',
+        'meta',
+        'name',
+        'no_log',
+        'notify',
+        'poll',
+        'register',
+        'remote_user',
+        'retries',
+        'run_once',
+        'su',
+        'su_pass',
+        'su_user',
+        'sudo',
+        'sudo_pass',
+        'sudo_user',
+        'transport',
+        'until',
+    ]
 
-class Task(PlaybookBase):
     def __init__(self, block=None, role=None):
-        self.ds    = None
-        self.block = block
-        self.role  = role
+        self._ds    = None
+        self._block = block
+        self._role  = role
+        self._reset()
+        super(Task, self).__init__()
+
+    def __repr__(self):
+        if self._role:
+            return "%s : %s" % (self._role.get_name(), self._name)
+        else:
+            return self._name
+
+    def _reset(self):
+        ''' clears internal data structures '''
+
+        for k in self.VALID_KEYS:
+            setattr(self, '_%s' % k, None)
+
+        # attributes not set via the ds
+        self._action        = None
+        self._module_name   = None
+        self._parameters    = None
+        self._lookup_plugin = None
+        self._lookup_terms  = None
+
+        # special conditionals
+        self._changed_when = Conditional(self)
+        self._failed_when  = Conditional(self)
+        self._when         = Conditional(self)
+
+    def _load_parameters(data):
+        ''' sets the parameters for this task, based on the type of the data '''
+        if isinstance(data, dict):
+            self._parameters = data
+        elif isinstance(data, basestring):
+            self._parameters = utils.parse_kv(data)
+        elif isinstance(data, None):
+            self._parameters = ''
+        else:
+            raise AnsibleError("invalid arguments specified, got '%s' (type=%s')" % (data, type(data)))
 
     def load(self, ds):
-        self.ds = ds
-        self.name = ""
+        ''' parses and loads the task from the given datastructure '''
+
+        # reset everything internally
+        self._reset()
+
+        # 'action' and 'local_action' are mutually-exclusive options
+        if 'action' in ds and 'local_action' in ds:
+            raise AnsibleError("the 'action' and 'local_action' attributes can not be used together")
+
+        # iterate over each key/value in the datastructure to parse out its parameters.
+        args = None
+        for k,v in ds.iteritems():
+            if k in ('action', 'local_action'):
+                # task structure is:
+                # action: module_name k=v ...
+                # or
+                # local_action: module_name k=v ...
+                module_name, params = v.strip().split(' ', 1)
+                if module_name not in utils.plugins.module_finder:
+                    raise AnsibleError("the specified module '%s' could not be found, check your module path" % module_name)
+                self._module_name = module_name
+                self._parameters = utils.parse_kv(params)
+                if k == 'local_action':
+                    if 'delegate_to' in ds:
+                        raise AnsibleError("delegate_to cannot be specified with local_action in task: %s" % ds.get('name', v))
+                    self._delegate_to = '127.0.0.1'
+                    if not 'transport' in ds and not 'connection' in ds:
+                        self._transport = 'local'
+            elif k in utils.plugins.module_finder:
+                # task structure is:
+                # - module_name: k=v ...
+                if self._module_name:
+                    raise AnsibleError("the module name (%s) was already specified, '%s' is a duplicate" % (self._module_name, k))
+                elif 'action' in ds:
+                    raise AnsibleError("multiple actions specified in task: '%s' and '%s'" % (k, ds.get('name', ds['action'])))
+                self._module_name = k
+                if isinstance(v, dict) and 'args' in ds:
+                    raise AnsibleError("can't combine args: and a dict for %s: in task %s" % (k, ds.get('name', "%s: %s" % (k, v))))
+                self._parameters = self._load_parameters(v)
+            elif k == 'args':
+                args = self._load_parameters(v)
+            elif k.startswith('with_'):
+                if isinstance(v, basestring):
+                    param = v.strip()
+                    if (param.startswith('{{') and param.find('}}') == len(ds[x]) - 2 and param.find('|') == -1):
+                        utils.warning("It is unnecessary to use '{{' in loops, leave variables in loop expressions bare.")
+                plugin_name = k.replace("with_","")
+                if plugin_name in utils.plugins.lookup_loader:
+                    self._lookup_plugin = plugin_name
+                    self._lookup_terms  = v
+                else:
+                    raise errors.AnsibleError("cannot find lookup plugin named %s for usage in with_%s" % (plugin_name, plugin_name))
+            elif k.startswith('when_'):
+                utils.deprecated("The 'when_' conditional has been removed. Switch to using the regular unified 'when' statements as described on docs.ansible.com.","1.5", removed=True)
+                if self._when:
+                    raise errors.AnsibleError("multiple when_* statements specified in task %s" % (ds.get('name', ds.get('action'))))
+                when_name = k.replace("when_","")
+                self._when = "%s %s" % (when_name, v)
+            elif k in ('changed_when', 'failed_when', 'when'):
+                # these are conditional objects, so we push the new conditional value
+                # into the object so that it can be evaluated later
+                getattr(self, '_%s' % k).push(v)
+            elif k == 'tags':
+                # all taggable datastructures in Ansible (tasks, roles, etc.) are
+                # based on the Base() class, which includes the _tags attribute
+                # (which is a Tag() class)
+                tags = v
+                if isinstance(v, basestring):
+                    tags = v.split(',')
+                self._tags.push(tags)
+            elif k not in self.VALID_KEYS:
+                raise AnsibleError("%s is not a legal parameter in an Ansible task or handler" % k)
+            else:
+                setattr(self, '_%s' % k, v)
+
+        # if args were specified along with parameters, merge them now
+        # with the args taking lower precedence
+        if args:
+            self._parameters = utils.combine_vars(args, self._parameters)
+
+        # run validation
+        self._validate()
+
+        # finally, store the ds for later use/reference
+        self._ds = ds
+
+    def _validate(self):
+        '''
+        Validates internal datastructures and verifies mutually-exclusive
+        options are not in conflict.
+        '''
+
+        if not self._name:
+            # if no name: was specified, flatten the parameters back 
+            # into a string and combine them with with module name
+            flat_params = " ".join(["%s=%s" % (k,v) for k,v in self._parameters.iteritems()])
+            self._name = "%s %s" % (self._module_name, flat_params)
+
+        # use builtin _ensure* methods to massage/set values on attributes
+        # anything not listed here will be defaulted to None by _reset()
+        self._ensure_int("_async", 0)
+        self._ensure_int("_poll", 10)
+        self._ensure_bool("_ignore_errors", False)
+        self._ensure_bool("_always_run", False)
+        self._ensure_list_of_strings("_notify", [])
+
+        # handle mutually incompatible options
+        if (self._sudo or self._sudo_user or self._sudo_pass) and (self._su or self._su_user or self._su_pass):
+            raise AnsibleError('sudo params ("sudo", "sudo_user", "sudo_pass") and su params ("su", "su_user", "su_pass") cannot be used together')
+
+        incompatibles = [ x for x in [ self._first_available_file, self._lookup_plugin ] if x is not None ]
+        if len(incompatibles) > 1:
+            raise AnsibleError("with_(plugin), and first_available_file are mutually incompatible in a single task")
+
+    @property
+    def name(self):
+        return self.__repr__()
 
     def get_vars(self):
         return dict()

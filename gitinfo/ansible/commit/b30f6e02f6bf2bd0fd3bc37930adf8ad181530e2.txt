commit b30f6e02f6bf2bd0fd3bc37930adf8ad181530e2
Author: Mike Mars <codemeup@outlook.com>
Date:   Thu Jun 2 15:58:01 2016 -0700

    Fixing compile time errors irt exception handling for Python 3. This particular diff fixes problems with Exception handling and the use/misues IRT Python 3 of octal numbers (InvalidToken exceptions).

diff --git a/lib/ansible/modules/utilities/helper/accelerate.py b/lib/ansible/modules/utilities/helper/accelerate.py
index 6c656825b9..92ec31219f 100644
--- a/lib/ansible/modules/utilities/helper/accelerate.py
+++ b/lib/ansible/modules/utilities/helper/accelerate.py
@@ -168,14 +168,14 @@ def daemonize_self(module, password, port, minutes, pid_file):
             vvv("exiting pid %s" % pid)
             # exit first parent
             module.exit_json(msg="daemonized accelerate on port %s for %s minutes with pid %s" % (port, minutes, str(pid)))
-    except OSError, e:
+    except OSError as e:
         log("fork #1 failed: %d (%s)" % (e.errno, e.strerror))
         sys.exit(1)
 
     # decouple from parent environment
     os.chdir("/")
     os.setsid()
-    os.umask(022)
+    os.umask(Oo22)
 
     # do second fork
     try:
@@ -187,7 +187,7 @@ def daemonize_self(module, password, port, minutes, pid_file):
             pid_file.close()
             vvv("pid file written")
             sys.exit(0)
-    except OSError, e:
+    except OSError as e:
         log("fork #2 failed: %d (%s)" % (e.errno, e.strerror))
         sys.exit(1)
 
@@ -219,9 +219,9 @@ class LocalSocketThread(Thread):
                         # make sure the directory is accessible only to this
                         # user, as socket files derive their permissions from
                         # the directory that contains them
-                        os.chmod(dir, 0700)
+                        os.chmod(dir, Oo700)
                 elif not os.path.exists(dir):
-                    os.makedirs(dir, 0700)
+                    os.makedirs(dir, Oo700)
         except OSError:
             pass
         self.s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
@@ -260,7 +260,7 @@ class LocalSocketThread(Thread):
                             self.server.last_event = datetime.datetime.now()
                         finally:
                             self.server.last_event_lock.release()
-                    except Exception, e:
+                    except Exception as e:
                         vv("key loaded locally was invalid, ignoring (%s)" % e)
                         conn.sendall("BADKEY\n")
                 finally:
@@ -520,7 +520,7 @@ class ThreadedTCPRequestHandler(SocketServer.BaseRequestHandler):
                 if response.get('failed',False):
                     log("got a failed response from the master")
                     return dict(failed=True, stderr="Master reported failure, aborting transfer")
-        except Exception, e:
+        except Exception as e:
             fd.close()
             tb = traceback.format_exc()
             log("failed to fetch the file: %s" % tb)
@@ -541,7 +541,7 @@ class ThreadedTCPRequestHandler(SocketServer.BaseRequestHandler):
             tmp_path = os.path.expanduser('~/.ansible/tmp/')
             if not os.path.exists(tmp_path):
                 try:
-                    os.makedirs(tmp_path, 0700)
+                    os.makedirs(tmp_path, Oo700)
                 except:
                     return dict(failed=True, msg='could not create a temporary directory at %s' % tmp_path)
             (fd,out_path) = tempfile.mkstemp(prefix='ansible.', dir=tmp_path)
@@ -618,7 +618,7 @@ def daemonize(module, password, port, timeout, minutes, use_ipv6, pid_file):
                 server = ThreadedTCPServer(address, ThreadedTCPRequestHandler, module, password, timeout, use_ipv6=use_ipv6)
                 server.allow_reuse_address = True
                 break
-            except Exception, e:
+            except Exception as e:
                 vv("Failed to create the TCP server (tries left = %d) (error: %s) " % (tries,e))
             tries -= 1
             time.sleep(0.2)
@@ -641,7 +641,7 @@ def daemonize(module, password, port, timeout, minutes, use_ipv6, pid_file):
 
         v("server thread terminated, exiting!")
         sys.exit(0)
-    except Exception, e:
+    except Exception as e:
         tb = traceback.format_exc()
         log("exception caught, exiting accelerated mode: %s\n%s" % (e, tb))
         sys.exit(0)
@@ -685,7 +685,7 @@ def main():
                 # process, other than tell the calling program
                 # whether other signals can be sent
                 os.kill(daemon_pid, 0)
-            except OSError, e:
+            except OSError as e:
                 if e.errno == errno.EPERM:
                     # no permissions means the pid is probably
                     # running, but as a different user, so fail

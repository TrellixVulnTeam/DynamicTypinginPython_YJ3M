commit 349fb42f548ff41c63fee7e3b92b691cc11dba8c
Author: Thomas Steinbach <thomas.steinbach@aikq.de>
Date:   Fri Dec 4 03:24:44 2015 +0100

    Allow setup of docker remote connections

diff --git a/lib/ansible/playbook/play_context.py b/lib/ansible/playbook/play_context.py
index 5c02093980..414036dc9b 100644
--- a/lib/ansible/playbook/play_context.py
+++ b/lib/ansible/playbook/play_context.py
@@ -50,6 +50,7 @@ except ImportError:
 
 MAGIC_VARIABLE_MAPPING = dict(
    connection       = ('ansible_connection',),
+   connection_args  = ('ansible_connection_args',),
    remote_addr      = ('ansible_ssh_host', 'ansible_host'),
    remote_user      = ('ansible_ssh_user', 'ansible_user'),
    port             = ('ansible_ssh_port', 'ansible_port'),
@@ -136,6 +137,7 @@ class PlayContext(Base):
 
     # connection fields, some are inherited from Base:
     # (connection, port, remote_user, environment, no_log)
+    _connection_args  = FieldAttribute(isa='string')
     _remote_addr      = FieldAttribute(isa='string')
     _password         = FieldAttribute(isa='string')
     _private_key_file = FieldAttribute(isa='string', default=C.DEFAULT_PRIVATE_KEY_FILE)
@@ -243,6 +245,9 @@ class PlayContext(Base):
         if options.connection:
             self.connection = options.connection
 
+        if hasattr(options, 'connection_args') and options.connection_args:
+            self.connection_args = options.connection_args
+
         self.remote_user = options.remote_user
         self.private_key_file = options.private_key_file
         self.ssh_common_args = options.ssh_common_args
diff --git a/lib/ansible/plugins/connection/docker.py b/lib/ansible/plugins/connection/docker.py
index 4e08f56a09..96d4355f92 100644
--- a/lib/ansible/plugins/connection/docker.py
+++ b/lib/ansible/plugins/connection/docker.py
@@ -69,12 +69,15 @@ class Connection(ConnectionBase):
         # root.
 
         if 'docker_command' in kwargs:
-            self.docker_cmd = kwargs['docker_command']
+            self.docker_cmd = [kwargs['docker_command']]
         else:
-            self.docker_cmd = distutils.spawn.find_executable('docker')
-            if not self.docker_cmd:
+            self.docker_cmd = [distutils.spawn.find_executable('docker')]
+            if not self.docker_cmd[0]:
                 raise AnsibleError("docker command not found in PATH")
 
+        if play_context.connection_args:
+            self.docker_cmd = self.docker_cmd + play_context.connection_args.split(' ')
+
         self.can_copy_bothways = False
 
         docker_version = self._get_docker_version()
@@ -91,7 +94,7 @@ class Connection(ConnectionBase):
 
     def _get_docker_version(self):
 
-        cmd = [self.docker_cmd, 'version']
+        cmd = self.docker_cmd + ['version']
         cmd_output = subprocess.check_output(cmd)
 
         for line in cmd_output.split('\n'):
@@ -99,10 +102,7 @@ class Connection(ConnectionBase):
                 return self._sanitize_version(line.split()[2])
 
         # no result yet, must be newer Docker version
-        new_docker_cmd = [
-            self.docker_cmd,
-            'version', '--format', "'{{.Server.Version}}'"
-        ]
+        new_docker_cmd = self.docker_cmd + ['version', '--format', "'{{.Server.Version}}'"]
 
         cmd_output = subprocess.check_output(new_docker_cmd)
 
@@ -123,7 +123,7 @@ class Connection(ConnectionBase):
 
         executable = C.DEFAULT_EXECUTABLE.split()[0] if C.DEFAULT_EXECUTABLE else '/bin/sh'
         # -i is needed to keep stdin open which allows pipelining to work
-        local_cmd = [self.docker_cmd, "exec", '-i', self._play_context.remote_addr, executable, '-c', cmd]
+        local_cmd = self.docker_cmd + ["exec", '-i', self._play_context.remote_addr, executable, '-c', cmd]
 
         display.vvv("EXEC %s" % (local_cmd), host=self._play_context.remote_addr)
         p = subprocess.Popen(local_cmd, shell=False, stdin=subprocess.PIPE,
@@ -158,7 +158,7 @@ class Connection(ConnectionBase):
 
         if self.can_copy_bothways:
             # only docker >= 1.8.1 can do this natively
-            args = [ self.docker_cmd, "cp", in_path, "%s:%s" % (self._play_context.remote_addr, out_path) ]
+            args = self.docker_cmd + ["cp", in_path, "%s:%s" % (self._play_context.remote_addr, out_path) ]
             p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
             stdout, stderr = p.communicate()
             if p.returncode != 0:
@@ -168,7 +168,7 @@ class Connection(ConnectionBase):
             # Older docker doesn't have native support for copying files into
             # running containers, so we use docker exec to implement this
             executable = C.DEFAULT_EXECUTABLE.split()[0] if C.DEFAULT_EXECUTABLE else '/bin/sh'
-            args = [self.docker_cmd, "exec", "-i", self._play_context.remote_addr, executable, "-c",
+            args = self.docker_cmd + ["exec", "-i", self._play_context.remote_addr, executable, "-c",
                     "dd of={0} bs={1}".format(out_path, BUFSIZE)]
             with open(in_path, 'rb') as in_file:
                 try:
@@ -191,7 +191,7 @@ class Connection(ConnectionBase):
         # file path
         out_dir = os.path.dirname(out_path)
 
-        args = [self.docker_cmd, "cp", "%s:%s" % (self._play_context.remote_addr, in_path), out_dir]
+        args = self.docker_cmd + ["cp", "%s:%s" % (self._play_context.remote_addr, in_path), out_dir]
 
         p = subprocess.Popen(args, stdin=subprocess.PIPE,
                 stdout=subprocess.PIPE, stderr=subprocess.PIPE)

commit 197a360977a52a31d6ab40db1f4752454e8b93e3
Author: Toshio Kuratomi <a.badger@gmail.com>
Date:   Tue Jul 25 10:51:53 2017 -0700

    Fix undefined vars on python3 and a whole bunch of other cleanup. (#27202)
    
    * Fix undefined vars on python3 and a whole bunch of other cleanup.
    
    References #27193
    
    * No need to catch exception and reraise.  This just obfuscates the traceback
    * Build up a list and then join at the end instead of building up a string. list.append() is faster than string concatenation
    * No need to extract k, v pairs from one dict to make a second dict and then extract k, v pairs from the second dict.  Iterate over the k, v pairs extracted from the first dict directly instead of building the second dict.
    * No need to check if the dict is empty before iterating on it.  Iterating on an empty dict will automatically go to the end of the loop
    * Use isinstance instead of type(obj) is class, handles inheritance and is better style
    * use to_native instead of v.encode().  We can use the surrogate_or_strict error handler to deal with more potential tracebacks.  Does the right conversion on both Py2 and Py3.
    * Convert bool to string before combining it with the string we're building.
    * Don't reference unicode directly as unicode does not exist in Python3
    * The string resulting from this function will not have a trailing comma
    * Simplify the conversion to string int and bool values are now used in string formatting which will use str to transform them without an explicit invocation.

diff --git a/lib/ansible/module_utils/netscaler.py b/lib/ansible/module_utils/netscaler.py
index 214a75f30c..eaef706ddb 100644
--- a/lib/ansible/module_utils/netscaler.py
+++ b/lib/ansible/module_utils/netscaler.py
@@ -32,6 +32,8 @@ import json
 import re
 
 from ansible.module_utils.basic import env_fallback
+from ansible.module_utils.six import binary_type, text_type
+from ansible.module_utils._text import to_native
 
 
 class ConfigProxy(object):
@@ -260,65 +262,38 @@ def monkey_patch_nitro_api():
     from nssrc.com.citrix.netscaler.nitro.resource.base.Json import Json
 
     def new_resource_to_string_convert(self, resrc):
-        try:
-            # Line below is the actual patch
-            dict_valid_values = dict((k.replace('_', '', 1), v) for k, v in resrc.__dict__.items() if v)
-            return json.dumps(dict_valid_values)
-        except Exception as e:
-            raise e
+        # Line below is the actual patch
+        dict_valid_values = dict((k.replace('_', '', 1), v) for k, v in resrc.__dict__.items() if v)
+        return json.dumps(dict_valid_values)
     Json.resource_to_string_convert = new_resource_to_string_convert
 
     from nssrc.com.citrix.netscaler.nitro.util.nitro_util import nitro_util
 
     @classmethod
     def object_to_string_new(cls, obj):
-        try:
-            str_ = ""
-            flds = obj.__dict__
-            # Line below is the actual patch
-            flds = dict((k.replace('_', '', 1), v) for k, v in flds.items() if v)
-            if (flds):
-                for k, v in flds.items():
-                    str_ = str_ + "\"" + k + "\":"
-                    if type(v) is unicode:
-                        v = v.encode('utf8')
-                    if type(v) is bool:
-                        str_ = str_ + v
-                    elif type(v) is str:
-                        str_ = str_ + "\"" + v + "\""
-                    elif type(v) is int:
-                        str_ = str_ + "\"" + str(v) + "\""
-                    if str_:
-                        str_ = str_ + ","
-            return str_
-        except Exception as e:
-            raise e
+        output = []
+        flds = obj.__dict__
+        for k, v in ((k.replace('_', '', 1), v) for k, v in flds.items() if v):
+            if isinstance(v, bool):
+                output.append('"%s":%s' % (k, v))
+            elif isinstance(v, (binary_type, text_type)):
+                v = to_native(v, errors='surrogate_or_strict')
+                output.append('"%s":"%s"' % (k, v))
+            elif isinstance(v, int):
+                output.append('"%s":"%s"' % (k, v))
+        return ','.join(output)
 
     @classmethod
     def object_to_string_withoutquotes_new(cls, obj):
-        try:
-            str_ = ""
-            flds = obj.__dict__
-            # Line below is the actual patch
-            flds = dict((k.replace('_', '', 1), v) for k, v in flds.items() if v)
-            i = 0
-            if (flds):
-                for k, v in flds.items():
-                    str_ = str_ + k + ":"
-                    if type(v) is unicode:
-                        v = v.encode('utf8')
-                    if type(v) is bool:
-                        str_ = str_ + v
-                    elif type(v) is str:
-                        str_ = str_ + cls.encode(v)
-                    elif type(v) is int:
-                        str_ = str_ + str(v)
-                    i = i + 1
-                    if i != (len(flds.items())) and str_:
-                        str_ = str_ + ","
-            return str_
-        except Exception as e:
-            raise e
+        output = []
+        flds = obj.__dict__
+        for k, v in ((k.replace('_', '', 1), v) for k, v in flds.items() if v):
+            if isinstance(v, (int, bool)):
+                output.append('%s:%s' % (k, v))
+            elif isinstance(v, (binary_type, text_type)):
+                v = to_native(v, errors='surrogate_or_strict')
+                output.append('%s:%s' % (k, cls.encode(v)))
+        return ','.join(output)
 
     nitro_util.object_to_string = object_to_string_new
     nitro_util.object_to_string_withoutquotes = object_to_string_withoutquotes_new

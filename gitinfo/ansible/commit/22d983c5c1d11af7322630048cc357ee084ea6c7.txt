commit 22d983c5c1d11af7322630048cc357ee084ea6c7
Author: Brian Coca <bcoca@users.noreply.github.com>
Date:   Tue Nov 28 12:00:22 2017 -0500

    get_option instead of internal dict (#33191)
    
    * get_option instead of internal dict
    
    * fix slack issue
    
    * not a pugin, revert get_option

diff --git a/lib/ansible/plugins/callback/__init__.py b/lib/ansible/plugins/callback/__init__.py
index 2bd6b689b9..5f8b92124d 100644
--- a/lib/ansible/plugins/callback/__init__.py
+++ b/lib/ansible/plugins/callback/__init__.py
@@ -84,6 +84,9 @@ class CallbackBase(AnsiblePlugin):
     def set_option(self, k, v):
         self._plugin_options[k] = v
 
+    def get_option(self, k):
+        return self._plugin_options[k]
+
     def set_options(self, task_keys=None, var_options=None, direct=None):
         ''' This is different than the normal plugin method as callbacks get called early and really don't accept keywords.
             Also _options was already taken for CLI args and callbacks use _plugin_options instead.
diff --git a/lib/ansible/plugins/callback/logentries.py b/lib/ansible/plugins/callback/logentries.py
index a572c8e38c..53fa99a6f7 100644
--- a/lib/ansible/plugins/callback/logentries.py
+++ b/lib/ansible/plugins/callback/logentries.py
@@ -232,39 +232,26 @@ class CallbackModule(CallbackBase):
 
         self.le_jobid = str(uuid.uuid4())
 
-        # FIXME: remove when done testing
-        # initialize configurable
-        self.api_url = 'data.logentries.com'
-        self.api_port = 80
-        self.api_tls_port = 443
-        self.use_tls = False
-        self.flatten = False
-        self.token = None
-
         # FIXME: make configurable, move to options
         self.timeout = 10
 
-        # FIXME: remove testing
-        # self.set_options({'api': 'data.logentries.com', 'port': 80,
-        # 'tls_port': 10000, 'use_tls': True, 'flatten': False, 'token': 'ae693734-4c5b-4a44-8814-1d2feb5c8241'})
-
     def set_options(self, task_keys=None, var_options=None, direct=None):
 
         super(CallbackModule, self).set_options(task_keys=task_keys, var_options=var_options, direct=direct)
 
         # get options
         try:
-            self.api_url = self._plugin_options['api']
-            self.api_port = self._plugin_options['port']
-            self.api_tls_port = self._plugin_options['tls_port']
-            self.use_tls = self._plugin_options['use_tls']
-            self.flatten = self._plugin_options['flatten']
+            self.api_url = self.get_option('api')
+            self.api_port = self.get_option('port')
+            self.api_tls_port = self.get_option('tls_port')
+            self.use_tls = self.get_option('use_tls')
+            self.flatten = self.get_option('flatten')
         except KeyError as e:
             self._display.warning("Missing option for Logentries callback plugin: %s" % to_native(e))
             self.disabled = True
 
         try:
-            self.token = self._plugin_options['token']
+            self.token = self.get_option('token')
         except KeyError as e:
             self._display.warning('Logentries token was not provided, this is required for this callback to operate, disabling')
             self.disabled = True
diff --git a/lib/ansible/plugins/callback/profile_tasks.py b/lib/ansible/plugins/callback/profile_tasks.py
index 5869bfb2f6..da5f2ee7d6 100644
--- a/lib/ansible/plugins/callback/profile_tasks.py
+++ b/lib/ansible/plugins/callback/profile_tasks.py
@@ -123,7 +123,7 @@ class CallbackModule(CallbackBase):
 
         super(CallbackModule, self).set_options(task_keys=task_keys, var_options=var_options, direct=direct)
 
-        self.sort_order = self._plugin_options['sort_order']
+        self.sort_order = self.get_option('sort_order')
         if self.sort_order is not None:
             if self.sort_order == 'ascending':
                 self.sort_order = False
@@ -132,7 +132,7 @@ class CallbackModule(CallbackBase):
             elif self.sort_order == 'none':
                 self.sort_order = None
 
-        self.task_output_limit = self._plugin_options['output_limit']
+        self.task_output_limit = self.get_option('output_limit')
         if self.task_output_limit is not None:
             if self.task_output_limit == 'all':
                 self.task_output_limit = None
diff --git a/lib/ansible/plugins/callback/selective.py b/lib/ansible/plugins/callback/selective.py
index d839add5c9..372551c58b 100644
--- a/lib/ansible/plugins/callback/selective.py
+++ b/lib/ansible/plugins/callback/selective.py
@@ -93,7 +93,7 @@ class CallbackModule(CallbackBase):
         super(CallbackModule, self).set_options(task_keys=task_keys, var_options=var_options, direct=direct)
 
         global DONT_COLORIZE
-        DONT_COLORIZE = self._plugin_options['nocolor']
+        DONT_COLORIZE = self.get_option('nocolor')
 
     def _print_task(self, task_name=None):
         if task_name is None:
diff --git a/lib/ansible/plugins/callback/slack.py b/lib/ansible/plugins/callback/slack.py
index c7030fa43e..aac9062290 100644
--- a/lib/ansible/plugins/callback/slack.py
+++ b/lib/ansible/plugins/callback/slack.py
@@ -93,9 +93,9 @@ class CallbackModule(CallbackBase):
 
         super(CallbackModule, self).set_options(task_keys=task_keys, var_options=var_options, direct=direct)
 
-        self.webhook_url = self._plugin_options['webhook_url']
-        self.channel = self._plugin_options['channel']
-        self.username = self._plugin_options['username']
+        self.webhook_url = self.get_option('webhook_url')
+        self.channel = self.get_option('channel')
+        self.username = self.get_option('username')
         self.show_invocation = (self._display.verbosity > 1)
 
         if self.webhook_url is None:
@@ -133,12 +133,12 @@ class CallbackModule(CallbackBase):
         ]
         invocation_items = []
         if self._plugin_options and self.show_invocation:
-            tags = self._plugin_options.tags
-            skip_tags = self._plugin_options.skip_tags
-            extra_vars = self._plugin_options.extra_vars
-            subset = self._plugin_options.subset
+            tags = self.get_option('tags')
+            skip_tags = self.get_option('skip_tags')
+            extra_vars = self.get_option('extra_vars')
+            subset = self.get_option('subset')
             inventory = os.path.basename(
-                os.path.realpath(self._plugin_options.inventory)
+                os.path.realpath(self.get_option('inventory'))
             )
 
             invocation_items.append('Inventory:  %s' % inventory)
@@ -152,7 +152,7 @@ class CallbackModule(CallbackBase):
                 invocation_items.append('Extra Vars: %s' %
                                         ' '.join(extra_vars))
 
-            title.append('by *%s*' % self._plugin_options.remote_user)
+            title.append('by *%s*' % self.get_options('remote_user'))
 
         title.append('\n\n*%s*' % self.playbook_name)
         msg_items = [' '.join(title)]
diff --git a/lib/ansible/plugins/connection/paramiko_ssh.py b/lib/ansible/plugins/connection/paramiko_ssh.py
index 1466c65721..e6fee9624c 100644
--- a/lib/ansible/plugins/connection/paramiko_ssh.py
+++ b/lib/ansible/plugins/connection/paramiko_ssh.py
@@ -264,7 +264,7 @@ class Connection(ConnectionBase):
                 if proxy_command:
                     break
 
-        proxy_command = proxy_command or self._options['proxy_command']
+        proxy_command = proxy_command or self.get_option('proxy_command')
 
         sock_kwarg = {}
         if proxy_command:
@@ -299,7 +299,7 @@ class Connection(ConnectionBase):
 
         self.keyfile = os.path.expanduser("~/.ssh/known_hosts")
 
-        if self._options['host_key_checking']:
+        if self.get_option('host_key_checking'):
             for ssh_known_hosts in ("/etc/ssh/ssh_known_hosts", "/etc/openssh/ssh_known_hosts"):
                 try:
                     # TODO: check if we need to look at several possible locations, possible for loop
@@ -327,7 +327,7 @@ class Connection(ConnectionBase):
                 self._play_context.remote_addr,
                 username=self._play_context.remote_user,
                 allow_agent=allow_agent,
-                look_for_keys=self._options['look_for_keys'],
+                look_for_keys=self.get_option('look_for_keys'),
                 key_filename=key_filename,
                 password=self._play_context.password,
                 timeout=self._play_context.timeout,
@@ -371,7 +371,7 @@ class Connection(ConnectionBase):
         # sudo usually requires a PTY (cf. requiretty option), therefore
         # we give it one by default (pty=True in ansble.cfg), and we try
         # to initialise from the calling environment when sudoable is enabled
-        if self._options['pty'] and sudoable:
+        if self.get_option('pty') and sudoable:
             chan.get_pty(term=os.getenv('TERM', 'vt100'), width=int(os.getenv('COLUMNS', 0)), height=int(os.getenv('LINES', 0)))
 
         display.vvv("EXEC %s" % cmd, host=self._play_context.remote_addr)
@@ -524,7 +524,7 @@ class Connection(ConnectionBase):
             if self.sftp is not None:
                 self.sftp.close()
 
-        if self._options['host_key_checking'] and self._options['record_host_keys'] and self._any_keys_added():
+        if self.get_option('host_key_checking') and self.get_option('record_host_keys') and self._any_keys_added():
 
             # add any new SSH host keys -- warning -- this could be slow
             # (This doesn't acquire the connection lock because it needs
diff --git a/lib/ansible/plugins/connection/winrm.py b/lib/ansible/plugins/connection/winrm.py
index d36fa5d32c..2d20f0c552 100644
--- a/lib/ansible/plugins/connection/winrm.py
+++ b/lib/ansible/plugins/connection/winrm.py
@@ -176,12 +176,12 @@ class Connection(ConnectionBase):
         self._become_user = self._play_context.become_user
         self._become_pass = self._play_context.become_pass
 
-        self._winrm_port = self._options['port']
-        self._winrm_scheme = self._options['scheme']
-        self._winrm_path = self._options['path']
-        self._kinit_cmd = self._options['kerberos_command']
-        self._winrm_transport = self._options['transport']
-        self._winrm_connection_timeout = self._options['connection_timeout']
+        self._winrm_port = self.get_option('port')
+        self._winrm_scheme = self.get_option('scheme')
+        self._winrm_path = self.get_option('path')
+        self._kinit_cmd = self.get_option('kerberos_command')
+        self._winrm_transport = self.get_option('transport')
+        self._winrm_connection_timeout = self.get_option('connection_timeout')
 
         if hasattr(winrm, 'FEATURE_SUPPORTED_AUTHTYPES'):
             self._winrm_supported_authtypes = set(winrm.FEATURE_SUPPORTED_AUTHTYPES)
@@ -205,7 +205,7 @@ class Connection(ConnectionBase):
             raise AnsibleError('The installed version of WinRM does not support transport(s) %s' % list(unsupported_transports))
 
         # if kerberos is among our transports and there's a password specified, we're managing the tickets
-        kinit_mode = self._options['kerberos_mode']
+        kinit_mode = self.get_option('kerberos_mode')
         if kinit_mode is None:
             # HACK: ideally, remove multi-transport stuff
             self._kerb_managed = "kerberos" in self._winrm_transport and self._winrm_pass
@@ -221,7 +221,7 @@ class Connection(ConnectionBase):
         argspec = inspect.getargspec(Protocol.__init__)
         supported_winrm_args = set(argspec.args)
         supported_winrm_args.update(internal_kwarg_mask)
-        passed_winrm_args = set([v.replace('ansible_winrm_', '') for v in self._options['_extras']])
+        passed_winrm_args = set([v.replace('ansible_winrm_', '') for v in self.get_option('_extras')])
         unsupported_args = passed_winrm_args.difference(supported_winrm_args)
 
         # warn for kwargs unsupported by the installed version of pywinrm
@@ -230,7 +230,7 @@ class Connection(ConnectionBase):
 
         # pass through matching extras, excluding the list we want to treat specially
         for arg in passed_winrm_args.difference(internal_kwarg_mask).intersection(supported_winrm_args):
-            self._winrm_kwargs[arg] = self._options['_extras']['ansible_winrm_%s' % arg]
+            self._winrm_kwargs[arg] = self.get_option('_extras')['ansible_winrm_%s' % arg]
 
     # Until pykerberos has enough goodies to implement a rudimentary kinit/klist, simplest way is to let each connection
     # auth itself with a private CCACHE.
diff --git a/lib/ansible/plugins/inventory/constructed.py b/lib/ansible/plugins/inventory/constructed.py
index 87fdaf347a..fbbb74f979 100644
--- a/lib/ansible/plugins/inventory/constructed.py
+++ b/lib/ansible/plugins/inventory/constructed.py
@@ -91,7 +91,7 @@ class InventoryModule(BaseInventoryPlugin, Constructable):
 
         self._read_config_data(path)
 
-        strict = self._options['strict']
+        strict = self.get_option('strict')
         fact_cache = FactCache()
         try:
             # Go over hosts (less var copies)
@@ -103,7 +103,7 @@ class InventoryModule(BaseInventoryPlugin, Constructable):
                     hostvars = combine_vars(hostvars, fact_cache[host])
 
                 # create composite vars
-                self._set_composite_vars(self._options['compose'], hostvars, host, strict=strict)
+                self._set_composite_vars(self.get_option('compose'), hostvars, host, strict=strict)
 
                 # refetch host vars in case new ones have been created above
                 hostvars = inventory.hosts[host].get_vars()
@@ -111,10 +111,10 @@ class InventoryModule(BaseInventoryPlugin, Constructable):
                     hostvars = combine_vars(hostvars, self._cache[host])
 
                 # constructed groups based on conditionals
-                self._add_host_to_composed_groups(self._options['groups'], hostvars, host, strict=strict)
+                self._add_host_to_composed_groups(self.get_option('groups'), hostvars, host, strict=strict)
 
                 # constructed groups based variable values
-                self._add_host_to_keyed_groups(self._options['keyed_groups'], hostvars, host, strict=strict)
+                self._add_host_to_keyed_groups(self.get_option('keyed_groups'), hostvars, host, strict=strict)
 
         except Exception as e:
             raise AnsibleParserError("failed to parse %s: %s " % (to_native(path), to_native(e)))
diff --git a/lib/ansible/plugins/inventory/script.py b/lib/ansible/plugins/inventory/script.py
index 6b4ed17cd2..253c20bee8 100644
--- a/lib/ansible/plugins/inventory/script.py
+++ b/lib/ansible/plugins/inventory/script.py
@@ -77,7 +77,7 @@ class InventoryModule(BaseInventoryPlugin, Cacheable):
         super(InventoryModule, self).parse(inventory, loader, path)
 
         if cache is None:
-            cache = self._options['cache']
+            cache = self.get_option('cache')
 
         # Support inventory scripts that are not prefixed with some
         # path information but happen to be in the current working
diff --git a/lib/ansible/plugins/inventory/virtualbox.py b/lib/ansible/plugins/inventory/virtualbox.py
index 3fe44e98f6..bac45bfcbc 100644
--- a/lib/ansible/plugins/inventory/virtualbox.py
+++ b/lib/ansible/plugins/inventory/virtualbox.py
@@ -75,21 +75,21 @@ class InventoryModule(BaseInventoryPlugin, Constructable, Cacheable):
         # set vars in inventory from hostvars
         for host in hostvars:
 
-            query = self._options['query']
+            query = self.get_option('query')
             # create vars from vbox properties
             if query and isinstance(query, MutableMapping):
                 for varname in query:
                     hostvars[host][varname] = self._query_vbox_data(host, query[varname])
 
             # create composite vars
-            self._set_composite_vars(self._options['compose'], hostvars, host)
+            self._set_composite_vars(self.get_option('compose'), hostvars, host)
 
             # actually update inventory
             for key in hostvars[host]:
                 self.inventory.set_variable(host, key, hostvars[host][key])
 
             # constructed groups based on conditionals
-            self._add_host_to_composed_groups(self._options['groups'], hostvars, host)
+            self._add_host_to_composed_groups(self.get_option('groups'), hostvars, host)
 
     def _populate_from_source(self, source_data):
         hostvars = {}
@@ -97,7 +97,7 @@ class InventoryModule(BaseInventoryPlugin, Constructable, Cacheable):
         current_host = None
 
         # needed to possibly set ansible_host
-        netinfo = self._options['network_info_path']
+        netinfo = self.get_option('network_info_path')
 
         for line in source_data:
             try:
@@ -173,8 +173,8 @@ class InventoryModule(BaseInventoryPlugin, Constructable, Cacheable):
                 pass
 
         if not source_data:
-            b_pwfile = to_bytes(self._options['settings_password_file'], errors='surrogate_or_strict')
-            running = self._options['running_only']
+            b_pwfile = to_bytes(self.get_option('settings_password_file'), errors='surrogate_or_strict')
+            running = self.get_option('running_only')
 
             # start getting data
             cmd = [self.VBOX, b'list', b'-l']
diff --git a/lib/ansible/plugins/inventory/yaml.py b/lib/ansible/plugins/inventory/yaml.py
index c79ec2d76b..d9109177a9 100644
--- a/lib/ansible/plugins/inventory/yaml.py
+++ b/lib/ansible/plugins/inventory/yaml.py
@@ -81,7 +81,7 @@ class InventoryModule(BaseFileInventoryPlugin):
         valid = False
         if super(InventoryModule, self).verify_file(path):
             file_name, ext = os.path.splitext(path)
-            if not ext or ext in self._options['yaml_extensions']:
+            if not ext or ext in self.get_option('yaml_extensions'):
                 valid = True
         return valid
 
diff --git a/lib/ansible/plugins/lookup/etcd.py b/lib/ansible/plugins/lookup/etcd.py
index f8eabf74e4..fcefb3f744 100644
--- a/lib/ansible/plugins/lookup/etcd.py
+++ b/lib/ansible/plugins/lookup/etcd.py
@@ -164,9 +164,9 @@ class LookupModule(LookupBase):
 
         self.set_options(var_options=variables, direct=kwargs)
 
-        validate_certs = self._options['validate_certs']
-        url = self._options['url']
-        version = self._options['version']
+        validate_certs = self.get_option('validate_certs')
+        url = self.get_option('url')
+        version = self.get_option('version')
 
         etcd = Etcd(url=url, version=version, validate_certs=validate_certs)
 

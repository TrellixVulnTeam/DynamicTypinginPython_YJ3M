commit ad2736b2531892c0f5b9f932c8c01ed87b7c5af4
Author: Michael DeHaan <michael.dehaan@gmail.com>
Date:   Sun Sep 29 19:03:51 2013 -0400

    Update tags and async sections, among other changes.

diff --git a/docsite/latest/rst/_old_playbooks2.rst b/docsite/latest/rst/_old_playbooks2.rst
deleted file mode 100644
index 8d3777bdbd..0000000000
--- a/docsite/latest/rst/_old_playbooks2.rst
+++ /dev/null
@@ -1,1330 +0,0 @@
-Advanced Playbooks
-==================
-
-Here are some advanced features of the playbooks language.  Using all of these features
-is not necessary, but many of them will prove useful.  If a feature doesn't seem immediately
-relevant, feel free to skip it.  For many people, the features documented in `playbooks` will
-be 90% or more of what they use in Ansible.
-
-.. contents::
-   :depth: 2
-
-Tags
-````
-
-.. versionadded:: 0.6
-
-If you have a large playbook it may become useful to be able to run a
-specific part of the configuration.  Both plays and tasks support a
-"tags:" attribute for this reason.
-
-Example::
-
-    tasks:
-
-        - yum: name={{ item }} state=installed
-          with_items:
-             - httpd
-             - memcached
-          tags:
-             - packages
-
-        - template: src=templates/src.j2 dest=/etc/foo.conf
-          tags:
-             - configuration
-
-If you wanted to just run the "configuration" and "packages" part of a very long playbook, you could do this::
-
-    ansible-playbook example.yml --tags "configuration,packages"
-
-Playbooks Including Playbooks
-`````````````````````````````
-
-.. versionadded:: 0.6
-
-To further advance the concept of include files, playbook files can
-include other playbook files.  Suppose you define the behavior of all
-your webservers in "webservers.yml" and all your database servers in
-"dbservers.yml".  You can create a "site.yml" that would reconfigure
-all of your systems like this::
-
-    ---
-    - include: playbooks/webservers.yml
-    - include: playbooks/dbservers.yml
-
-This concept works great with tags to rapidly select exactly what plays you want to run, and exactly
-what parts of those plays.
-
-Ignoring Failed Commands
-````````````````````````
-
-.. versionadded:: 0.6
-
-Generally playbooks will stop executing any more steps on a host that
-has a failure.  Sometimes, though, you want to continue on.  To do so,
-write a task that looks like this::
-
-    - name: this will not be counted as a failure
-      command: /bin/false
-      ignore_errors: yes
-
-Overriding Changed Result
-`````````````````````````
-
-.. versionadded:: 1.3
-
-When a shell/command or other module runs it will typically report
-"changed" status based on whether it thinks it affected machine state.
-
-Sometimes you will know, based on the return code
-or output that it did not make any changes, and wish to override
-the "changed" result such that it does not appear in report output or
-does not cause handlers to fire::
-
-    tasks:
-
-      - shell: /usr/bin/billybass --mode="take me to the river"
-        register: bass_result
-        changed_when: "bass_result.rc != 2"
-
-      # this will never report 'changed' status
-      - shell: wall 'beep'
-
-Accessing Complex Variable Data
-```````````````````````````````
-
-Some provided facts, like networking information, are made available as nested data structures.  To access
-them a simple {{ foo }} is not sufficient, but it is still easy to do.   Here's how we get an IP address::
-
-    {{ ansible_eth0["ipv4"]["address"] }}
-
-Similarly, this is how we access the first element of an array::
-
-    {{ foo[0] }}
-
-Magic Variables, and How To Access Information About Other Hosts
-````````````````````````````````````````````````````````````````
-
-Even if you didn't define them yourself, Ansible provides a few variables for you automatically.
-The most important of these are 'hostvars', 'group_names', and 'groups'.  Users should not use
-these names themselves as they are reserved.  'environment' is also reserved.
-
-Hostvars lets you ask about the variables of another host, including facts that have been gathered
-about that host.  If, at this point, you haven't talked to that host yet in any play in the playbook
-or set of playbooks, you can get at the variables, but you will not be able to see the facts.
-
-If your database server wants to use the value of a 'fact' from another node, or an inventory variable
-assigned to another node, it's easy to do so within a template or even an action line::
-
-    {{ hostvars['test.example.com']['ansible_distribution'] }}
-
-Additionally, *group_names* is a list (array) of all the groups the current host is in.  This can be used in templates using Jinja2 syntax to make template source files that vary based on the group membership (or role) of the host::
-
-   {% if 'webserver' in group_names %}
-      # some part of a configuration file that only applies to webservers
-   {% endif %}
-
-*groups* is a list of all the groups (and hosts) in the inventory.  This can be used to enumerate all hosts within a group.
-For example::
-
-   {% for host in groups['app_servers'] %}
-      # something that applies to all app servers.
-   {% endfor %}
-
-A frequently used idiom is walking a group to find all IP addresses in that group::
-
-   {% for host in groups['app_servers'] %}
-      {{ hostvars[host]['ansible_eth0']['ipv4']['address'] }}
-   {% endfor %}
-
-An example of this could include pointing a frontend proxy server to all of the app servers, setting up the correct firewall rules between servers, etc.
-
-Just a few other 'magic' variables are available...  There aren't many.
-
-Additionally, *inventory_hostname* is the name of the hostname as configured in Ansible's inventory host file.  This can
-be useful for when you don't want to rely on the discovered hostname `ansible_hostname` or for other mysterious
-reasons.  If you have a long FQDN, *inventory_hostname_short* also contains the part up to the first
-period, without the rest of the domain.
-
-Don't worry about any of this unless you think you need it.  You'll know when you do.
-
-Also available, *inventory_dir* is the pathname of the directory holding Ansible's inventory host file, *inventory_file* is the pathname and the filename pointing to the Ansible's inventory host file.
-
-Variable File Separation
-````````````````````````
-
-It's a great idea to keep your playbooks under source control, but
-you may wish to make the playbook source public while keeping certain
-important variables private.  Similarly, sometimes you may just
-want to keep certain information in different files, away from
-the main playbook.
-
-You can do this by using an external variables file, or files, just like this::
-
-    ---
-    - hosts: all
-      remote_user: root
-      vars:
-        favcolor: blue
-      vars_files:
-        - /vars/external_vars.yml
-      tasks:
-      - name: this is just a placeholder
-        command: /bin/echo foo
-
-This removes the risk of sharing sensitive data with others when
-sharing your playbook source with them.
-
-The contents of each variables file is a simple YAML dictionary, like this::
-
-    ---
-    # in the above example, this would be vars/external_vars.yml
-    somevar: somevalue
-    password: magic
-
-.. note::
-   It's also possible to keep per-host and per-group variables in very
-   similar files, this is covered in :ref:`patterns`.
-
-Prompting For Sensitive Data
-````````````````````````````
-
-You may wish to prompt the user for certain input, and can
-do so with the similarly named 'vars_prompt' section.  This has uses
-beyond security, for instance, you may use the same playbook for all
-software releases and would prompt for a particular release version
-in a push-script::
-
-    ---
-    - hosts: all
-      remote_user: root
-      vars:
-        from: "camelot"
-      vars_prompt:
-        name: "what is your name?"
-        quest: "what is your quest?"
-        favcolor: "what is your favorite color?"
-
-There are full examples of both of these items in the github examples/playbooks directory.
-
-If you have a variable that changes infrequently, it might make sense to
-provide a default value that can be overridden.  This can be accomplished using
-the default argument::
-
-   vars_prompt:
-     - name: "release_version"
-       prompt: "Product release version"
-       default: "1.0"
-
-An alternative form of vars_prompt allows for hiding input from the user, and may later support
-some other options, but otherwise works equivalently::
-
-   vars_prompt:
-     - name: "some_password"
-       prompt: "Enter password"
-       private: yes
-     - name: "release_version"
-       prompt: "Product release version"
-       private: no
-
-If `Passlib <http://pythonhosted.org/passlib/>`_ is installed, vars_prompt can also crypt the
-entered value so you can use it, for instance, with the user module to define a password::
-
-   vars_prompt:
-     - name: "my_password2"
-       prompt: "Enter password2"
-       private: yes
-       encrypt: "md5_crypt"
-       confirm: yes
-       salt_size: 7
-
-You can use any crypt scheme supported by 'Passlib':
-
-- *des_crypt* - DES Crypt
-- *bsdi_crypt* - BSDi Crypt
-- *bigcrypt* - BigCrypt
-- *crypt16* - Crypt16
-- *md5_crypt* - MD5 Crypt
-- *bcrypt* - BCrypt
-- *sha1_crypt* - SHA-1 Crypt
-- *sun_md5_crypt* - Sun MD5 Crypt
-- *sha256_crypt* - SHA-256 Crypt
-- *sha512_crypt* - SHA-512 Crypt
-- *apr_md5_crypt* - Apache’s MD5-Crypt variant
-- *phpass* - PHPass’ Portable Hash
-- *pbkdf2_digest* - Generic PBKDF2 Hashes
-- *cta_pbkdf2_sha1* - Cryptacular’s PBKDF2 hash
-- *dlitz_pbkdf2_sha1* - Dwayne Litzenberger’s PBKDF2 hash
-- *scram* - SCRAM Hash
-- *bsd_nthash* - FreeBSD’s MCF-compatible nthash encoding
-
-However, the only parameters accepted are 'salt' or 'salt_size'. You can use you own salt using
-'salt', or have one generated automatically using 'salt_size'. If nothing is specified, a salt
-of size 8 will be generated.
-
-Passing Variables On The Command Line
-`````````````````````````````````````
-
-In addition to `vars_prompt` and `vars_files`, it is possible to send variables over
-the Ansible command line.  This is particularly useful when writing a generic release playbook
-where you may want to pass in the version of the application to deploy::
-
-    ansible-playbook release.yml --extra-vars "version=1.23.45 other_variable=foo"
-
-This is useful, for, among other things, setting the hosts group or the user for the playbook.
-
-Example::
-
-    ---
-    - remote_user: '{{ user }}'
-      hosts: '{{ hosts }}'
-      tasks:
-         - ...
-
-    ansible-playbook release.yml --extra-vars "hosts=vipers user=starbuck"
-
-As of Ansible 1.2, you can also pass in extra vars as quoted JSON, like so::
-
-    --extra-vars '{"pacman":"mrs","ghosts":["inky","pinky","clyde","sue"]}'
-
-The key=value form is obviously simpler, but it's there if you need it!
-
-As of Ansible 1.3, extra vars can be loaded from a JSON file with the "@" syntax::
-
-    --extra-vars "@some_file.json"
-
-Also as of Ansible 1.3, extra vars can be formatted as YAML, either on the command line
-or in a file as above.
-
-Conditional Execution
-`````````````````````
-
-(Note: this section covers 1.2 conditionals, if you are using a previous version, select
-the previous version of the documentation, `Ansible 1.1 Docs <http://www.ansibleworks.com/docs/released/1.1/>`_ .
-Those conditional forms continue to be operational in 1.2, although the new mechanisms are cleaner.)
-
-Sometimes you will want to skip a particular step on a particular host.  This could be something
-as simple as not installing a certain package if the operating system is a particular version,
-or it could be something like performing some cleanup steps if a filesystem is getting full.
-
-This is easy to do in Ansible, with the `when` clause, which contains a Jinja2 expression (see chapter
-`Playbooks <http://www.ansibleworks.com/docs/playbooks.html#vars-section>`_ for more info).
-Don't panic -- it's actually pretty simple::
-
-    tasks:
-      - name: "shutdown Debian flavored systems"
-        command: /sbin/shutdown -t now
-        when: ansible_os_family == "Debian"
-
-A number of Jinja2 "filters" can also be used in when statements, some of which are unique
-and provided by Ansible.  Suppose we want to ignore the error of one statement and then
-decide to do something conditionally based on success or failure::
-
-    tasks:
-      - command: /bin/false
-        register: result
-        ignore_errors: True
-      - command: /bin/something
-        when: result|failed
-      - command: /bin/something_else
-        when: result|success
-      - command: /bin/still/something_else
-        when: result|skipped
-
-
-As a reminder, to see what derived variables are available, you can do::
-
-    ansible hostname.example.com -m setup
-
-Tip: Sometimes you'll get back a variable that's a string and you'll want to do a comparison on it.  You can do this like so::
-
-    tasks:
-      - shell: echo "only on Red Hat 6, derivatives, and later"
-        when: ansible_os_family == "RedHat" and ansible_lsb.major_release|int >= 6
-
-Note the above example requires the lsb_release package on the target host in order to return the ansible_lsb.major_release fact.
-
-Variables defined in the playbooks or inventory can also be used.
-
-An example may be the execution of a task based on a variable's boolean value::
-
-    vars:
-      epic: true
-
-Then a conditional execution with action on the boolean value of epic being True::
-
-    tasks:
-        - shell: echo "This certainly is epic!"
-          when: epic
-
-With a boolean value of False::
- 
-    tasks:
-        - shell: echo "This certainly isn't epic!"
-          when: not epic
-
-If a required variable has not been set, you can skip or fail using Jinja2's
-`defined` test. For example::
-
-    tasks:
-        - shell: echo "I've got '{{ foo }}' and am not afraid to use it!"
-          when: foo is defined
-
-        - fail: msg="Bailing out: this play requires 'bar'"
-          when: bar is not defined
-
-This is especially useful in combination with the conditional import of vars
-files (see below).
-
-It's also easy to provide your own facts if you want, which is covered in :doc:`moduledev`.  To run them, just
-make a call to your own custom fact gathering module at the top of your list of tasks, and variables returned
-there will be accessible to future tasks::
-
-    tasks:
-        - name: gather site specific fact data
-          action: site_facts
-        - command: echo {{ my_custom_fact_can_be_used_now }}
-
-One useful trick with *when* is to key off the changed result of a last command.  As an example::
-
-    tasks:
-        - template: src=/templates/foo.j2 dest=/etc/foo.conf
-          register: last_result
-        - command: echo 'the file has changed'
-          when: last_result.changed
-
-{{ last_result }} is a variable set by the register directive. This assumes Ansible 0.8 and later.
-
-When combining `when` with `with_items`, be aware that the `when` statement is processed separately for each item.
-This is by design::
-
-    tasks:
-        - command: echo {{ item }}
-          with_items: [ 0, 2, 4, 6, 8, 10 ]
-          when: item > 5
-
-Note that if you have several tasks that all share the same conditional statement, you can affix the conditional
-to a task include statement as below.  Note this does not work with playbook includes, just task includes.  All the tasks
-get evaluated, but the conditional is applied to each and every task::
-
-    - include: tasks/sometasks.yml
-      when: "'reticulating splines' in output"
-
-Conditional Imports
-```````````````````
-
-Sometimes you will want to do certain things differently in a playbook based on certain criteria.
-Having one playbook that works on multiple platforms and OS versions is a good example.
-
-As an example, the name of the Apache package may be different between CentOS and Debian,
-but it is easily handled with a minimum of syntax in an Ansible Playbook::
-
-    ---
-    - hosts: all
-      remote_user: root
-      vars_files:
-        - "vars/common.yml"
-        - [ "vars/{{ ansible_os_family }}.yml", "vars/os_defaults.yml" ]
-      tasks:
-      - name: make sure apache is running
-        service: name={{ apache }} state=running
-
-.. note::
-   The variable 'ansible_os_family' is being interpolated into
-   the list of filenames being defined for vars_files.
-
-As a reminder, the various YAML files contain just keys and values::
-
-    ---
-    # for vars/CentOS.yml
-    apache: httpd
-    somethingelse: 42
-
-How does this work?  If the operating system was 'CentOS', the first file Ansible would try to import
-would be 'vars/CentOS.yml', followed by '/vars/os_defaults.yml' if that file
-did not exist.   If no files in the list were found, an error would be raised.
-On Debian, it would instead first look towards 'vars/Debian.yml' instead of 'vars/CentOS.yml', before
-falling back on 'vars/os_defaults.yml'. Pretty simple.
-
-To use this conditional import feature, you'll need facter or ohai installed prior to running the playbook, but
-you can of course push this out with Ansible if you like::
-
-    # for facter
-    ansible -m yum -a "pkg=facter ensure=installed"
-    ansible -m yum -a "pkg=ruby-json ensure=installed"
-
-    # for ohai
-    ansible -m yum -a "pkg=ohai ensure=installed"
-
-Ansible's approach to configuration -- separating variables from tasks, keeps your playbooks
-from turning into arbitrary code with ugly nested ifs, conditionals, and so on - and results
-in more streamlined & auditable configuration rules -- especially because there are a
-minimum of decision points to track.
-
-Do-Until
-````````
-
-Sometimes you would want to retry a task till a certain condition is met, In such conditions the Do/Until feature will help.
-Here's an example which show's the syntax to be applied for the task.::
-   
-    - action: shell /usr/bin/foo
-      register: result
-      until: register.stdout.find("all systems go") != -1
-      retries: 5
-      delay: 10
-
-The above example run the shell module recursively till the module's result has "all systems go" in it's stdout or the task has 
-been retried for 5 times with a delay of 10 seconds. The default value for "retries" is 3 and "delay" is 5.
-
-The task returns the results returned by the last task run. The results of individual retries can be viewed by -vv option.
-The results will have a new key "attempts" which will have the number of the retries for the task.
-
-.. Note::
-
-    The Do/Until does not take decision on whether to fail or pass the play when the maximum retries are completed, the user can
-    can do that in the next task as follows.
-   
-Example::
-    
-   - action: shell /usr/bin/foo
-     register: result
-     until: register.stdout.find("all systems go") != -1
-     retries: 5
-     delay: 10
-     failed_when: result.attempts == 5
-
-
-Loops
-`````
-
-To save some typing, repeated tasks can be written in short-hand like so::
-
-    - name: add several users
-      user: name={{ item }} state=present groups=wheel
-      with_items:
-         - testuser1
-         - testuser2
-
-If you have defined a YAML list in a variables file, or the 'vars' section, you can also do::
-
-    with_items: somelist
-
-The above would be the equivalent of::
-
-    - name: add user testuser1
-      user: name=testuser1 state=present groups=wheel
-    - name: add user testuser2
-      user: name=testuser2 state=present groups=wheel
-
-The yum and apt modules use with_items to execute fewer package manager transactions.
-
-Note that the types of items you iterate over with 'with_items' do not have to be simple lists of strings.
-If you have a list of hashes, you can reference subkeys using things like::
-
-    - name: add several users
-      user: name={{ item.name }} state=present groups={{ item.groups }}
-      with_items:
-        - { name: 'testuser1', groups: 'wheel' }
-        - { name: 'testuser2', groups: 'root' }
-
-Nested Loops
-````````````
-
-Loops can be nested as well::
-
-    - name: give users access to multiple databases
-      mysql_user: name={{ item[0] }} priv={{ item[1] }}.*:ALL password=foo
-      with_nested:
-        - [ 'alice', 'bob', 'eve' ]
-        - [ 'clientdb', 'employeedb', 'providerdb' ]
-
-As with the case of 'with_items' above, you can use previously defined variables. Just specify the variable's name without templating it with '{{ }}'::
-
-    - name: here, 'users' contains the above list of employees
-      mysql_user: name={{ item[0] }} priv={{ item[1] }}.*:ALL password=foo
-      with_nested:
-        - users
-        - [ 'clientdb', 'employeedb', 'providerdb' ]
-
-Lookup Plugins - Accessing Outside Data
-```````````````````````````````````````
-
-.. versionadded:: 0.8
-
-Various *lookup plugins* allow additional ways to iterate over data.  Ansible will have more of these
-over time.  You can write your own, as is covered in the API section.  Each typically takes a list and
-can accept more than one parameter.
-
-``with_fileglob`` matches all files in a single directory, non-recursively, that match a pattern.  It can
-be used like this::
-
-    ---
-    - hosts: all
-
-      tasks:
-
-        # first ensure our target directory exists
-        - file: dest=/etc/fooapp state=directory
-
-        # copy each file over that matches the given pattern
-        - copy: src={{ item }} dest=/etc/fooapp/ owner=root mode=600
-          with_fileglob:
-            - /playbooks/files/fooapp/*
-
-``with_file`` loads data in from a file directly::
-
-        - authorized_key: user=foo key={{ item }}
-          with_file:
-             - /home/foo/.ssh/id_rsa.pub
-
-.. note::
-
-   When using ``with_fileglob`` or ``with_file`` with :ref:`roles`, if you
-   specify a relative path (e.g., :file:`./foo`), Ansible resolves the path
-   relative to the :file:`roles/<rolename>/files` directory.
-
-.. versionadded:: 0.9
-
-Many new lookup abilities were added in 0.9.  Remember, lookup plugins are run on the *controlling* machine::
-
-    ---
-    - hosts: all
-
-      tasks:
-
-         - debug: msg="{{ lookup('env','HOME') }} is an environment variable"
-
-         - debug: msg="{{ item }} is a line from the result of this command"
-           with_lines:
-             - cat /etc/motd
-
-         - debug: msg="{{ lookup('pipe','date') }} is the raw result of running this command"
-
-         - debug: msg="{{ lookup('redis_kv', 'redis://localhost:6379,somekey') }} is value in Redis for somekey"
-
-         - debug: msg="{{ lookup('dnstxt', 'example.com') }} is a DNS TXT record for example.com"
-
-         - debug: msg="{{ lookup('template', './some_template.j2') }} is a value from evaluation of this template"
-
-As an alternative you can also assign lookup plugins to variables or use them
-elsewhere.  This macros are evaluated each time they are used in a task (or
-template)::
-
-    vars:
-      motd_value: "{{ lookup('file', '/etc/motd') }}"
-
-    tasks:
-      - debug: msg="motd value is {{ motd_value }}"
-
-.. versionadded:: 1.0
-
-``with_sequence`` generates a sequence of items in ascending numerical order. You
-can specify a start, end, and an optional step value.
-
-Arguments should be specified in key=value pairs.  If supplied, the 'format' is a printf style string.
-
-Numerical values can be specified in decimal, hexadecimal (0x3f8) or octal (0600).
-Negative numbers are not supported.  This works as follows::
-
-    ---
-    - hosts: all
-
-      tasks:
-
-        # create groups
-        - group: name=evens state=present
-        - group: name=odds state=present
-
-        # create some test users
-        - user: name={{ item }} state=present groups=evens
-          with_sequence: start=0 end=32 format=testuser%02x
-
-        # create a series of directories with even numbers for some reason
-        - file: dest=/var/stuff/{{ item }} state=directory
-          with_sequence: start=4 end=16 stride=2
-
-        # a simpler way to use the sequence plugin
-        # create 4 groups
-        - group: name=group{{ item }} state=present
-          with_sequence: count=4
-
-.. versionadded:: 1.1
-
-``with_password`` and associated lookup macro generate a random plaintext password and store it in
-a file at a given filepath.  Support for crypted save modes (as with vars_prompt) is pending.  If the
-file exists previously, it will retrieve its contents, behaving just like with_file. Usage of variables like "{{ inventory_hostname }}" in the filepath can be used to set
-up random passwords per host (what simplifies password management in 'host_vars' variables).
-
-Generated passwords contain a random mix of upper and lowercase ASCII letters, the
-numbers 0-9 and punctuation (". , : - _"). The default length of a generated password is 30 characters.
-This length can be changed by passing an extra parameter::
-
-    ---
-    - hosts: all
-
-      tasks:
-
-        # create a mysql user with a random password:
-        - mysql_user: name={{ client }}
-                      password="{{ lookup('password', 'credentials/' + client + '/' + tier + '/' + role + '/mysqlpassword length=15') }}"
-                      priv={{ client }}_{{ tier }}_{{ role }}.*:ALL
-
-        (...)
-
-        # dump a mysql database with a given password (this example showing the other form).
-        - mysql_db: name={{ client }}_{{ tier }}_{{ role }}
-                    login_user={{ client }}
-                    login_password={{ item }}
-                    state=dump
-                    target=/tmp/{{ client }}_{{ tier }}_{{ role }}_backup.sql
-          with_password: credentials/{{ client }}/{{ tier }}/{{ role }}/mysqlpassword length=15
-
-        (...)
-
-        # create a user with a given password
-        - user: name=guestuser
-                state=present
-                uid=5000
-                password={{ item }}
-          with_password: credentials/{{ hostname }}/userpassword encrypt=sha256_crypt
-
-Setting the Environment (and Working With Proxies)
-``````````````````````````````````````````````````
-
-.. versionadded:: 1.1
-
-It is quite possible that you may need to get package updates through a proxy, or even get some package
-updates through a proxy and access other packages not through a proxy.  Ansible makes it easy for you
-to configure your environment by using the 'environment' keyword.  Here is an example::
-
-    - hosts: all
-      remote_user: root
-
-      tasks:
-
-        - apt: name=cobbler state=installed
-          environment:
-            http_proxy: http://proxy.example.com:8080
-
-The environment can also be stored in a variable, and accessed like so::
-
-    - hosts: all
-      remote_user: root
-
-      # here we make a variable named "env" that is a dictionary
-      vars:
-        proxy_env:
-          http_proxy: http://proxy.example.com:8080
-
-      tasks:
-
-        - apt: name=cobbler state=installed
-          environment: "{{ proxy_env }}"
-
-While just proxy settings were shown above, any number of settings can be supplied.  The most logical place
-to define an environment hash might be a group_vars file, like so::
-
-    ---
-    # file: group_vars/boston
-
-    ntp_server: ntp.bos.example.com
-    backup: bak.bos.example.com
-    proxy_env:
-      http_proxy: http://proxy.bos.example.com:8080
-      https_proxy: http://proxy.bos.example.com:8080
-
-Getting values from files
-`````````````````````````
-
-.. versionadded:: 0.8
-
-Sometimes you'll want to include the content of a file directly into a playbook.  You can do so using a macro.
-This syntax will remain in future versions, though we will also will provide ways to do this via lookup plugins (see "More Loops") as well.  What follows
-is an example using the authorized_key module, which requires the actual text of the SSH key as a parameter::
-
-    tasks:
-        - name: enable key-based ssh access for users
-          authorized_key: user={{ item }} key="{{ lookup('file', '/keys/' + item ) }}"
-          with_items:
-             - pinky
-             - brain
-             - snowball
-
-Selecting Files And Templates Based On Variables
-````````````````````````````````````````````````
-
-Sometimes a configuration file you want to copy, or a template you will use may depend on a variable.
-The following construct selects the first available file appropriate for the variables of a given host, which is often much cleaner than putting a lot of if conditionals in a template.
-
-The following example shows how to template out a configuration file that was very different between, say, CentOS and Debian::
-
-    - name: template a file
-      template: src={{ item }} dest=/etc/myapp/foo.conf
-      first_available_file:
-        - /srv/templates/myapp/{{ ansible_distribution }}.conf
-        - /srv/templates/myapp/default.conf
-
-first_available_file is only available to the copy and template modules.
-
-Asynchronous Actions and Polling
-````````````````````````````````
-
-By default tasks in playbooks block, meaning the connections stay open
-until the task is done on each node.  If executing playbooks with
-a small parallelism value (aka ``--forks``), you may wish that long
-running operations can go faster.  The easiest way to do this is
-to kick them off all at once and then poll until they are done.
-
-You will also want to use asynchronous mode on very long running
-operations that might be subject to timeout.
-
-To launch a task asynchronously, specify its maximum runtime
-and how frequently you would like to poll for status.  The default
-poll value is 10 seconds if you do not specify a value for `poll`::
-
-    ---
-    - hosts: all
-      remote_user: root
-      tasks:
-      - name: simulate long running op (15 sec), wait for up to 45, poll every 5
-        command: /bin/sleep 15
-        async: 45
-        poll: 5
-
-.. note::
-   There is no default for the async time limit.  If you leave off the
-   'async' keyword, the task runs synchronously, which is Ansible's
-   default.
-
-Alternatively, if you do not need to wait on the task to complete, you may
-"fire and forget" by specifying a poll value of 0::
-
-    ---
-    - hosts: all
-      remote_user: root
-      tasks:
-      - name: simulate long running op, allow to run for 45, fire and forget
-        command: /bin/sleep 15
-        async: 45
-        poll: 0
-
-.. note::
-   You shouldn't "fire and forget" with operations that require
-   exclusive locks, such as yum transactions, if you expect to run other
-   commands later in the playbook against those same resources.
-
-.. note::
-   Using a higher value for ``--forks`` will result in kicking off asynchronous
-   tasks even faster.  This also increases the efficiency of polling.
-
-Local Playbooks
-```````````````
-
-It may be useful to use a playbook locally, rather than by connecting over SSH.  This can be useful
-for assuring the configuration of a system by putting a playbook on a crontab.  This may also be used
-to run a playbook inside a OS installer, such as an Anaconda kickstart.
-
-To run an entire playbook locally, just set the "hosts:" line to "hosts:127.0.0.1" and then run the playbook like so::
-
-    ansible-playbook playbook.yml --connection=local
-
-Alternatively, a local connection can be used in a single playbook play, even if other plays in the playbook
-use the default remote connection type::
-
-    hosts: 127.0.0.1
-    connection: local
-
-Turning Off Facts
-`````````````````
-
-If you know you don't need any fact data about your hosts, and know everything about your systems centrally, you
-can turn off fact gathering.  This has advantages in scaling Ansible in push mode with very large numbers of
-systems, mainly, or if you are using Ansible on experimental platforms.   In any play, just do this::
-
-    - hosts: whatever
-      gather_facts: no
-
-Pull-Mode Playbooks
-```````````````````
-
-The use of playbooks in local mode (above) is made extremely powerful with the addition of `ansible-pull`.
-A script for setting up ansible-pull is provided in the examples/playbooks directory of the source
-checkout.
-
-The basic idea is to use Ansible to set up a remote copy of Ansible on each managed node, each set to run via
-cron and update playbook source via git.  This inverts the default push architecture of Ansible into a pull
-architecture, which has near-limitless scaling potential.  The setup playbook can be tuned to change
-the cron frequency, logging locations, and parameters to ansible-pull.
-
-This is useful both for extreme scale-out as well as periodic remediation.  Usage of the 'fetch' module to retrieve
-logs from ansible-pull runs would be an excellent way to gather and analyze remote logs from ansible-pull.
-
-Register Variables
-``````````````````
-
-.. versionadded:: 0.7
-
-Often in a playbook it may be useful to store the result of a given command in a variable and access
-it later.  Use of the command module in this way can in many ways eliminate the need to write site specific facts, for
-instance, you could test for the existence of a particular program.
-
-The 'register' keyword decides what variable to save a result in.  The resulting variables can be used in templates, action lines, or *when* statements.  It looks like this (in an obviously trivial example)::
-
-    - name: test play
-      hosts: all
-
-      tasks:
-
-          - shell: cat /etc/motd
-            register: motd_contents
-
-          - shell: echo "motd contains the word hi"
-            when: motd_contents.stdout.find('hi') != -1
-
-As shown previously, the registered variable's string contents are accessible with the 'stdout' value.
-The registered result can be used in the "with_items" of a task if it is converted into
-a list (or already is a list) as shown below.  "stdout_lines" is already available on the object as
-well though you could also call "home_dirs.stdout.split()" if you wanted, and could split by other
-fields::
-
-    - name: registered variable usage as a with_items list
-      hosts: all
-
-      tasks:
-
-          - name: retrieve the list of home directories
-            command: ls /home
-            register: home_dirs
-
-          - name: add home dirs to the backup spooler
-            file: path=/mnt/bkspool/{{ item }} src=/home/{{ item }} state=link
-            with_items: home_dirs.stdout_lines
-            # with_items: home_dirs.stdout.split()
-
-Rolling Updates
-```````````````
-
-.. versionadded:: 0.7
-
-By default, Ansible will try to manage all of the machines referenced in a play in parallel.  For a rolling updates
-use case, you can define how many hosts Ansible should manage at a single time by using the ''serial'' keyword::
-
-
-    - name: test play
-      hosts: webservers
-      serial: 3
-
-In the above example, if we had 100 hosts, 3 hosts in the group 'webservers'
-would complete the play completely before moving on to the next 3 hosts.
-
-Maximum Failure Percentage
-``````````````````````````
-
-.. versionadded:: 1.3
-
-By default, Ansible will continue executing actions as long as there are hosts in the group that have not yet failed.
-In some situations, such as with the rolling updates described above, it may be desireable to abort the play when a 
-certain threshold of failures have been reached. To acheive this, as of version 1.3 you can set a maximum failure 
-percentage on a play as follows::
-
-    - hosts: webservers
-      max_fail_percentage: 30
-      serial: 10
-
-In the above example, if more than 3 of the 10 servers in the group were to fail, the rest of the play would be aborted.
-
-.. note::
-
-     The percentage set must be exceeded, not equaled. For example, if serial were set to 4 and you wanted the task to abort 
-     when 2 of the systems failed, the percentage should be set at 49 rather than 50.
-
-Delegation
-``````````
-
-.. versionadded:: 0.7
-
-If you want to perform a task on one host with reference to other hosts, use the 'delegate_to' keyword on a task.
-This is ideal for placing nodes in a load balanced pool, or removing them.  It is also very useful for controlling
-outage windows.  Using this with the 'serial' keyword to control the number of hosts executing at one time is also
-a good idea::
-
-    ---
-    - hosts: webservers
-      serial: 5
-
-      tasks:
-      - name: take out of load balancer pool
-        command: /usr/bin/take_out_of_pool {{ inventory_hostname }}
-        delegate_to: 127.0.0.1
-
-      - name: actual steps would go here
-        yum: name=acme-web-stack state=latest
-
-      - name: add back to load balancer pool
-        command: /usr/bin/add_back_to_pool {{ inventory_hostname }}
-        delegate_to: 127.0.0.1
-
-
-These commands will run on 127.0.0.1, which is the machine running Ansible. There is also a shorthand syntax that
-you can use on a per-task basis: 'local_action'. Here is the same playbook as above, but using the shorthand
-syntax for delegating to 127.0.0.1::
-
-    ---
-    # ...
-      tasks:
-      - name: take out of load balancer pool
-        local_action: command /usr/bin/take_out_of_pool {{ inventory_hostname }}
-
-    # ...
-
-      - name: add back to load balancer pool
-        local_action: command /usr/bin/add_back_to_pool {{ inventory_hostname }}
-
-A common pattern is to use a local action to call 'rsync' to recursively copy files to the managed servers.
-Here is an example::
-
-    ---
-    # ...
-      tasks:
-      - name: recursively copy files from management server to target
-        local_action: command rsync -a /path/to/files {{ inventory_hostname }}:/path/to/target/
-
-Note that you must have passphrase-less SSH keys or an ssh-agent configured for this to work, otherwise rsync
-will need to ask for a passphrase.
-
-Accelerated Mode
-````````````````
-
-.. versionadded:: 1.3
-
-While SSH using the ControlPersist feature is quite fast and scalable, there is a certain amount of overhead involved in
-creating connections. This can become something of a bottleneck when the number of hosts grows into the hundreds or 
-thousands. To help overcome this, Ansible offers an accelerated connection option. Accelerated mode can be anywhere from 
-2-6x faster than SSH with ControlPersist enabled, and 10x faster than paramiko.
-
-Accelerated mode works by launching a temporary daemon over SSH. Once the daemon is running, Ansible will connect directly
-to it via a raw socket connection. Ansible secures this communication by using a temporary AES key that is uploaded during
-the SSH connection (this key is different for every host, and is also regenerated every time the daemon is started). By default,
-Ansible will use port 5099 for the accelerated connection, though this is configurable. Once running, the daemon will accept
-connections for 30 minutes, after which time it will terminate itself and need to be restarted over SSH.
-
-Accelerated mode offers several improvments over the original fireball mode:
-
-* No bootstrapping is required, only a single line needs to be added to each play you wish to run in accelerated mode.
-* Support for sudo commands (see below for more details and caveats).
-* Fewer requirements! ZeroMQ is no longer required, nor are there any special packages beyond python-keyczar.
-
-In order to use accelerated mode, simply add `accelerate: true` to your play::
-
-    ---
-    - hosts: all
-      accelerate: true
-      tasks:
-      - name: some task
-        command: echo {{ item }}
-        with_items:
-        - foo
-        - bar
-        - baz
-
-If you wish to change the port Ansible will use for the accelerated connection, just add the `accelerated_port` option::
-
-    ---
-    - hosts: all
-      accelerate: true
-      # default port is 5099
-      accelerate_port: 10000
-
-The `accelerate_port` option can also be specified in the environment variable ACCELERATE_PORT, or in your `ansible.cfg` configuration::
-
-    [accelerate]
-    accelerate_port = 5099
-
-As noted above, accelerated mode also supports running tasks via sudo, however there are two important caveats:
-
-* You must remove requiretty from your sudoers options.
-* Prompting for the sudo password is not yet supported, so the NOPASSWD option is required for commands.
-
-
-
-Fireball Mode
-`````````````
-
-.. versionadded:: 0.8 (deprecated as of 1.3)
-
-.. note::
-
-    The following section has been deprecated as of Ansible 1.3 in favor of the accelerated mode described above. This
-    documentation is here for users who may still be using the original fireball connection method only, and should not
-    be used for any new deployments.
-
-Ansible's core connection types of 'local', 'paramiko', and 'ssh' are augmented in version 0.8 and later by a new extra-fast
-connection type called 'fireball'.  It can only be used with playbooks and does require some additional setup
-outside the lines of Ansible's normal "no bootstrapping" philosophy.  You are not required to use fireball mode
-to use Ansible, though some users may appreciate it.
-
-Fireball mode works by launching a temporary 0mq daemon from SSH that by default lives for only 30 minutes before
-shutting off.  Fireball mode, once running, uses temporary AES keys to encrypt a session, and requires direct
-communication to given nodes on the configured port.  The default is 5099.  The fireball daemon runs as any user you
-set it down as.  So it can run as you, root, or so on.  If multiple users are running Ansible as the same batch of hosts,
-take care to use unique ports.
-
-Fireball mode is roughly 10 times faster than paramiko for communicating with nodes and may be a good option
-if you have a large number of hosts::
-
-    ---
-
-    # set up the fireball transport
-    - hosts: all
-      gather_facts: no
-      connection: ssh # or paramiko
-      sudo: yes
-      tasks:
-          - action: fireball
-
-    # these operations will occur over the fireball transport
-    - hosts: all
-      connection: fireball
-      tasks:
-          - shell: echo "Hello {{ item }}"
-            with_items:
-                - one
-                - two
-
-In order to use fireball mode, certain dependencies must be installed on both ends.   You can use this playbook as a basis for initial bootstrapping on
-any platform.  You will also need gcc and zeromq-devel installed from your package manager, which you can of course also get Ansible to install::
-
-    ---
-    - hosts: all
-      sudo: yes
-      gather_facts: no
-      connection: ssh
-      tasks:
-          - easy_install: name=pip
-          - pip: name={{ item }} state=present
-            with_items:
-              - pyzmq
-              - pyasn1
-              - PyCrypto
-              - python-keyczar
-
-Fedora and EPEL also have Ansible RPM subpackages available for fireball-dependencies.
-
-Also see the module documentation section.
-
-
-Understanding Variable Precedence
-`````````````````````````````````
-
-You have already learned about inventory variables, 'vars', and 'vars_files'.  In the
-event the same variable name occurs in more than one place, what happens?  There are really three tiers
-of precedence, and within those tiers, some minor ordering rules that you probably won't even need to remember.
-We'll explain them anyway though.
-
-Variables that are set during the execution of the play have highest priority. This includes registered
-variables and facts, which are discovered pieces of information about remote hosts.
-
-Descending in priority are variables defined in the playbook.  'vars_files' as defined in the playbook are next up,
-followed by variables as passed to ansible-playbook via --extra-vars (-e), then variables defined in the 'vars' section.  These
-should all be taken to be basically the same thing -- good places to define constants about what the play does to all hosts
-in the play.
-
-Finally, inventory variables have the least priority.  Variables about hosts override those about groups.
-If a variable is defined in multiple groups and one group is a child of the other, the child group variable
-will override the variable set in the parent.
-
-This makes the 'group_vars/all' file the best place to define a default value you wish to override in another
-group, or even in a playbook.  For example, your organization might set a default ntp server in group_vars/all
-and then override it based on a group based on a geographic region.  However if you type 'ntpserver: asdf.example.com'
-in a vars section of a playbook, you know from reading the playbook that THAT specific value is definitely the one
-that is going to be used.  You won't be fooled by some variable from inventory sneaking up on you.
-
-So, in short, if you want something easy to remember: facts beat playbook definitions, and
-playbook definitions beat inventory variables.
-
-There's a little bit more if you are using roles -- roles fit in the "playbook definitions" category of scale.  They are
-trumped by facts, and still trump inventory variables.  However, there's a bit of extra magic.
-
-Variables passed as parameters to the role are accesible only within that role (and dependencies of that role).  You can
-almost think of them like programming functions or macros.
-
-Variables loaded via the 'vars/' directory of a role are made available to all roles and tasks, which in older versions of Ansible
-could be confusing in the case of a reused variable name.  In Ansible 1.3 and later, however, vars/ directories are guaranteed to be scoped to the current role, just like roles parameters.  They are still available globally though, so if you want to set a variable like "ntp_server" in a common role, other roles can still make use of it.  Thus they are just like "vars_files" construct that they emulate, but they have a bit more of a "Do What I Mean" semantic to them.  They are smarter.
-
-If there are role dependencies involved, dependent roles can set variables visible to the roles that require them, but
-the requiring role is allowed to override those variables.  For instance if a role "myapp" requires "apache", and
-the value of "apache_port" in "apache" is 80, "myapp" could choose to set it to 8080.  Thus you may think of this somewhat
-like an inheritance system if you're a developer -- though it's not exactly -- and we don't require folks to think in programming terms to know how things work.
-
-If you want, you can choose to prefix variable names with the name of your role and be extra sure of where
-data sources are coming from, but this is optional.  However it can be a nice thing to do in your templates as you immediately
-know where the variable was defined.
-
-Ultimately, the variable system may seem complex -- but it's really not.  It's mostly a "Do What I Mean" kind of system, though knowing the details may help you if you get stuck or are trying to do something advanced.  Feel free to experiment!
-
-Check Mode ("Dry Run") --check
-```````````````````````````````
-
-.. versionadded:: 1.1
-
-When ansible-playbook is executed with --check it will not make any changes on remote systems.  Instead, any module
-instrumented to support 'check mode' (which contains the primary core modules, but it is not required that all modules do
-this) will report what changes they would have made.  Other modules that do not support check mode will also take no
-action, but just will not report what changes they might have made.
-
-Check mode is just a simulation, and if you have steps that use conditionals that depend on the results of prior commands,
-it may be less useful for you.  However it is great for one-node-at-time basic configuration management use cases.
-
-Example::
-
-    ansible-playbook foo.yml --check
-
-Running a task in check mode
-````````````````````````````
-
-.. versionadded:: 1.3
-
-Sometimes you may want to have a task to be executed even in check
-mode. To achieve this, use the `always_run` clause on the task. Its
-value is a Jinja2 expression, just like the `when` clause. In simple
-cases a boolean YAML value would be sufficient as a value.
-
-Example::
-
-    tasks:
-
-      - name: this task is run even in check mode
-        command: /something/to/run --even-in-check-mode
-        always_run: yes
-
-As a reminder, a task with a `when` clause evaluated to false, will
-still be skipped even if it has a `always_run` clause evaluated to
-true.
-
-
-Showing Differences with --diff
-```````````````````````````````
-
-.. versionadded:: 1.1
-
-The --diff option to ansible-playbook works great with --check (detailed above) but can also be used by itself.  When this flag is supplied, if any templated files on the remote system are changed, and the ansible-playbook CLI will report back
-the textual changes made to the file (or, if used with --check, the changes that would have been made).  Since the diff
-feature produces a large amount of output, it is best used when checking a single host at a time, like so::
-
-    ansible-playbook foo.yml --check --diff --limit foo.example.com
-
-Dictionary & Nested (Complex) Arguments
-```````````````````````````````````````
-
-As a review, most tasks in Ansible are of this form::
-
-    tasks:
-
-      - name: ensure the cobbler package is installed
-        yum: name=cobbler state=installed
-
-However, in some cases, it may be useful to feed arguments directly in from a hash (dictionary).  In fact, a very small
-number of modules (the CloudFormations module is one) actually require complex arguments.  They work like this::
-
-    tasks:
-
-      - name: call a module that requires some complex arguments
-        foo_module:
-           fibonacci_list:
-             - 1
-             - 1
-             - 2
-             - 3
-           my_pets:
-             dogs:
-               - fido
-               - woof
-             fish:
-               - limpet
-               - nemo
-               - "{{ other_fish_name }}"
-
-You can of course use variables inside these, as noted above.
-
-If using local_action, you can do this::
-
-    - name: call a module that requires some complex arguments
-      local_action:
-        module: foo_module
-        arg1: 1234
-        arg2: 'asdf'
-
-Which of course means that, though more verbose, this is also legal syntax::
-
-    - name: foo
-      template: { src: '/templates/motd.j2', dest: '/etc/motd' }
-
-Local Facts (Facts.d)
-`````````````````````
-
-.. versionadded:: 1.3
-
-As discussed in the playbooks chapter, Ansible facts are a way of getting data about remote systems for use in playbook variables.
-Usually these are discovered automatically by the 'setup' module in Ansible. Users can also write custom facts modules, as described
-in the API guide.  However, what if you want to have a simple way to provide system or user 
-provided data for use in Ansible variables, without writing a fact module?  For instance, what if you want users to be able to control some aspect about how their systems are managed? "Facts.d" is one such mechanism.
-
-If a remotely managed system has an "/etc/ansible/facts.d" directory, any files in this directory
-ending in ".fact", can be JSON, INI, or executable files returning JSON, and these can supply local facts in Ansible.
-
-For instance assume a /etc/ansible/facts.d/preferences.fact::
-
-    [general]
-    asdf=1
-    bar=2
-
-This will produce a hash variable fact named "general" with 'asdf' and 'bar' as members.
-To validate this, run the following::
-
-    ansible <hostname> -m setup -a "filter=ansible_local"
-
-And you will see the following fact added::
-
-    "ansible_local": {
-            "preferences": {
-                "general": {
-                    "asdf" : "1", 
-                    "bar"  : "2"
-                }
-            }
-     }
-
-And this data can be accessed in a template/playbook as::
-
-     {{ ansible_local.preferences.general.asdf }}
-
-The local namespace prevents any user supplied fact from overriding system facts
-or variables defined elsewhere in the playbook.
-
-Style Points
-````````````
-
-Ansible playbooks are colorized.  If you do not like this, set the ANSIBLE_NOCOLOR=1 environment variable.
-
-Ansible playbooks also look more impressive with cowsay installed, and we encourage installing this package.
-
-.. seealso::
-
-   :doc:`YAMLSyntax`
-       Learn about YAML syntax
-   :doc:`playbooks`
-       Review the basic playbook features
-   :doc:`bestpractices`
-       Various tips about playbooks in the real world
-   :doc:`modules`
-       Learn about available modules
-   :doc:`moduledev`
-       Learn how to extend Ansible by writing your own modules
-   :doc:`patterns`
-       Learn about how to select hosts
-   `Github examples directory <https://github.com/ansible/ansible/tree/devel/examples/playbooks>`_
-       Complete playbook files from the github project source
-   `Mailing List <http://groups.google.com/group/ansible-project>`_
-       Questions? Help? Ideas?  Stop by the list on Google Groups
-
-
diff --git a/docsite/latest/rst/developing_api.rst b/docsite/latest/rst/developing_api.rst
index b07cba206d..ecc389af94 100644
--- a/docsite/latest/rst/developing_api.rst
+++ b/docsite/latest/rst/developing_api.rst
@@ -4,7 +4,7 @@ API & Integrations
 There are several interesting ways to use Ansible from an API perspective.   You can use
 the Ansible python API to control nodes, you can extend Ansible to respond to various python events,
 and you can plug in inventory data from external data sources.  Ansible is written in its own
-API so you have a considerable amount of power across the board.
+API so you have a considerable amount of power across the board.  This chapter discusses the Python API.
 
 .. contents:: `Table of contents`
    :depth: 2
@@ -81,317 +81,3 @@ Advanced programmers may also wish to read the source to ansible itself, for
 it uses the Runner() API (with all available options) to implement the
 command line tools ``ansible`` and ``ansible-playbook``.
 
-Plugins Available Online
-------------------------
-
-The remainder of features in the API docs have components available in `ansible-plugins <https://github.com/ansible/ansible/blob/devel/plugins>`_.  Send us a github pull request if you develop any interesting features.
-
-External Inventory Scripts
---------------------------
-
-Often a user of a configuration management system will want to keep inventory
-in a different system.  Frequent examples include LDAP, `Cobbler <http://cobbler.github.com>`_,
-or a piece of expensive enterprisey CMDB software.   Ansible easily supports all
-of these options via an external inventory system.  The plugins directory contains some of these already -- including options for EC2/Eucalyptus and OpenStack, which will be detailed below.
-
-It's possible to write an external inventory script in any language.  If you are familiar with Puppet terminology, this concept is basically the same as 'external nodes', with the slight difference that it also defines which hosts are managed.
-
-Script Conventions
-``````````````````
-
-When the external node script is called with the single argument '--list', the script must return a JSON hash/dictionary of all the groups to be managed.
-Each group's value should be either a hash/dictionary containing a list of each host/IP, potential child groups, and potential group variables, or
-simply a list of host/IP addresses, like so::
-
-    {
-        "databases"   : {
-            "hosts"   : [ "host1.example.com", "host2.example.com" ],
-            "vars"    : {
-                "a"   : true
-            }
-        },
-        "webservers"  : [ "host2.example.com", "host3.example.com" ],
-        "atlanta"     : {
-            "hosts"   : [ "host1.example.com", "host4.example.com", "host5.example.com" ],
-            "vars"    : {
-                "b"   : false
-            },
-            "children": [ "marietta", "5points" ],
-        },
-        "marietta"    : [ "host6.example.com" ],
-        "5points"     : [ "host7.example.com" ]
-    }
-
-.. versionadded:: 1.0
-
-Before version 1.0, each group could only have a list of hostnames/IP addresses, like the webservers, marietta, and 5points groups above.
-
-When called with the arguments '--host <hostname>' (where <hostname> is a host from above), the script must return either an empty JSON
-hash/dictionary, or a hash/dictionary of variables to make available to templates and playbooks.  Returning variables is optional,
-if the script does not wish to do this, returning an empty hash/dictionary is the way to go::
-
-    {
-        "favcolor"   : "red",
-        "ntpserver"  : "wolf.example.com",
-        "monitoring" : "pack.example.com"
-    }
-
-Tuning the External Inventory Script
-````````````````````````````````````
-
-.. versionadded:: 1.3
-
-The stock inventory script system detailed above works for all versions of Ansible, but calling
-'--host' for every host can be rather expensive,  especially if it involves expensive API calls to
-a remote subsystemm.  In Ansible 
-1.3 or later, if the inventory script returns a top level element called "_meta", it is possible
-to return all of the host variables in one inventory script call.  When this meta element contains
-a value for "hostvars", the inventory script will not be invoked with "--host" for each host.  This
-results in a significant performance increase for large numbers of hosts, and also makes client
-side caching easier to implement for the inventory script.
-
-The data to be added to the top level JSON dictionary looks like this::
-
-    {
-
-        # results of inventory script as above go here
-        # ...
-
-        "_meta" : {
-           "hostvars" : {
-              "moocow.example.com"     : { "asdf" : 1234 },
-              "llama.example.com"      : { "asdf" : 5678 },
-           }
-        }
-
-    }
-
-
-Example: The Cobbler External Inventory Script
-``````````````````````````````````````````````
-
-It is expected that many Ansible users will also be `Cobbler <http://cobbler.github.com>`_ users.  Cobbler has a generic
-layer that allows it to represent data for multiple configuration management systems (even at the same time), and has
-been referred to as a 'lightweight CMDB' by some admins.   This particular script will communicate with Cobbler
-using Cobbler's XMLRPC API.
-
-To tie Ansible's inventory to Cobbler (optional), copy `this script <https://raw.github.com/ansible/ansible/devel/plugins/inventory/cobbler.py>`_ to /etc/ansible/hosts and `chmod +x` the file.  cobblerd will now need
-to be running when you are using Ansible.
-
-Test the file by running `./etc/ansible/hosts` directly.   You should see some JSON data output, but it may not have
-anything in it just yet.
-
-Let's explore what this does.  In cobbler, assume a scenario somewhat like the following::
-
-    cobbler profile add --name=webserver --distro=CentOS6-x86_64
-    cobbler profile edit --name=webserver --mgmt-classes="webserver" --ksmeta="a=2 b=3"
-    cobbler system edit --name=foo --dns-name="foo.example.com" --mgmt-classes="atlanta" --ksmeta="c=4"
-    cobbler system edit --name=bar --dns-name="bar.example.com" --mgmt-classes="atlanta" --ksmeta="c=5"
-
-In the example above, the system 'foo.example.com' will be addressable by ansible directly, but will also be addressable when using the group names 'webserver' or 'atlanta'.  Since Ansible uses SSH, we'll try to contract system foo over 'foo.example.com', only, never just 'foo'.  Similarly, if you try "ansible foo" it wouldn't find the system... but "ansible 'foo*'" would, because the system DNS name starts with 'foo'.
-
-The script doesn't just provide host and group info.  In addition, as a bonus, when the 'setup' module is run (which happens automatically when using playbooks), the variables 'a', 'b', and 'c' will all be auto-populated in the templates::
-
-    # file: /srv/motd.j2
-    Welcome, I am templated with a value of a={{ a }}, b={{ b }}, and c={{ c }}
-
-Which could be executed just like this::
-
-    ansible webserver -m setup
-    ansible webserver -m template -a "src=/tmp/motd.j2 dest=/etc/motd"
-
-.. note::
-   The name 'webserver' came from cobbler, as did the variables for
-   the config file.  You can still pass in your own variables like
-   normal in Ansible, but variables from the external inventory script
-   will override any that have the same name.
-
-So, with the template above (motd.j2), this would result in the following data being written to /etc/motd for system 'foo'::
-
-    Welcome, I am templated with a value of a=2, b=3, and c=4
-
-And on system 'bar' (bar.example.com)::
-
-    Welcome, I am templated with a value of a=2, b=3, and c=5
-
-And technically, though there is no major good reason to do it, this also works too::
-
-    ansible webserver -m shell -a "echo {{ a }}"
-
-So in other words, you can use those variables in arguments/actions as well.  You might use this to name
-a conf.d file appropriately or something similar.  Who knows?
-
-So that's the Cobbler integration support -- using the cobbler script as an example, it should be trivial to adapt Ansible to pull inventory, as well as variable information, from any data source.  If you create anything interesting, please share with the mailing list, and we can keep it in the source code tree for others to use.
-
-Example: AWS EC2 External Inventory Script
-``````````````````````````````````````````
-
-If you use Amazon Web Services EC2, maintaining an inventory file might not be the best approach. For this reason, you can use the `EC2 external inventory  <https://raw.github.com/ansible/ansible/devel/plugins/inventory/ec2.py>`_ script.
-
-You can use this script in one of two ways. The easiest is to use Ansible's ``-i`` command line option and specify the path to the script.
-
-    ansible -i ec2.py -u ubuntu us-east-1d -m ping
-
-The second option is to copy the script to `/etc/ansible/hosts` and `chmod +x` it. You will also need to copy the `ec2.ini  <https://raw.github.com/ansible/ansible/devel/plugins/inventory/ec2.ini>`_ file to `/etc/ansible/ec2.ini`. Then you can run ansible as you would normally.
-
-To successfully make an API call to AWS, you will need to configure Boto (the Python interface to AWS). There are a `variety of methods <http://docs.pythonboto.org/en/latest/boto_config_tut.html>`_ available, but the simplest is just to export two environment variables:
-
-    export AWS_ACCESS_KEY_ID='AK123'
-    export AWS_SECRET_ACCESS_KEY='abc123'
-
-You can test the script by itself to make sure your config is correct
-
-    cd plugins/inventory
-    ./ec2.py --list
-
-After a few moments, you should see your entire EC2 inventory across all regions in JSON.
-
-Since each region requires its own API call, if you are only using a small set of regions, feel free to edit ``ec2.ini`` and list only the regions you are interested in. There are other config options in ``ec2.ini`` including cache control, and destination variables.
-
-At their heart, inventory files are simply a mapping from some name to a destination address. The default ``ec2.ini`` settings are configured for running Ansible from outside EC2 (from your laptop for example). If you are running Ansible from within EC2, internal DNS names and IP addresses may make more sense than public DNS names. In this case, you can modify the ``destination_variable`` in ``ec2.ini`` to be the private DNS name of an instance. This is particularly important when running Ansible within a private subnet inside a VPC, where the only way to access an instance is via its private IP address. For VPC instances, `vpc_destination_variable` in ``ec2.ini`` provides a means of using which ever `boto.ec2.instance variable <http://docs.pythonboto.org/en/latest/ref/ec2.html#module-boto.ec2.instance>`_ makes the most sense for your use case.
-
-The EC2 external inventory provides mappings to instances from several groups:
-
-Instance ID
-  These are groups of one since instance IDs are unique.
-  e.g.
-  ``i-00112233``
-  ``i-a1b1c1d1``
-
-Region
-  A group of all instances in an AWS region.
-  e.g.
-  ``us-east-1``
-  ``us-west-2``
-
-Availability Zone
-  A group of all instances in an availability zone.
-  e.g.
-  ``us-east-1a``
-  ``us-east-1b``
-
-Security Group
-  Instances belong to one or more security groups. A group is created for each security group, with all characters except alphanumerics, dashes (-) converted to underscores (_). Each group is prefixed by ``security_group_``
-  e.g.
-  ``security_group_default``
-  ``security_group_webservers``
-  ``security_group_Pete_s_Fancy_Group``
-
-Tags
-  Each instance can have a variety of key/value pairs associated with it called Tags. The most common tag key is 'Name', though anything is possible. Each key/value pair is its own group of instances, again with special characters converted to underscores, in the format ``tag_KEY_VALUE``
-  e.g.
-  ``tag_Name_Web``
-  ``tag_Name_redis-master-001``
-  ``tag_aws_cloudformation_logical-id_WebServerGroup``
-
-When the Ansible is interacting with a specific server, the EC2 inventory script is called again with the ``--host HOST`` option. This looks up the HOST in the index cache to get the instance ID, and then makes an API call to AWS to get information about that specific instance. It then makes information about that instance available as variables to your playbooks. Each variable is prefixed by ``ec2_``. Here are some of the variables available:
-
-- ec2_architecture
-- ec2_description
-- ec2_dns_name
-- ec2_id
-- ec2_image_id
-- ec2_instance_type
-- ec2_ip_address
-- ec2_kernel
-- ec2_key_name
-- ec2_launch_time
-- ec2_monitored
-- ec2_ownerId
-- ec2_placement
-- ec2_platform
-- ec2_previous_state
-- ec2_private_dns_name
-- ec2_private_ip_address
-- ec2_public_dns_name
-- ec2_ramdisk
-- ec2_region
-- ec2_root_device_name
-- ec2_root_device_type
-- ec2_security_group_ids
-- ec2_security_group_names
-- ec2_spot_instance_request_id
-- ec2_state
-- ec2_state_code
-- ec2_state_reason
-- ec2_status
-- ec2_subnet_id
-- ec2_tag_Name
-- ec2_tenancy
-- ec2_virtualization_type
-- ec2_vpc_id
-
-Both ``ec2_security_group_ids`` and ``ec2_security_group_names`` are comma-separated lists of all security groups. Each EC2 tag is a variable in the format ``ec2_tag_KEY``.
-
-To see the complete list of variables available for an instance, run the script by itself::
-
-    cd plugins/inventory
-    ./ec2.py --host ec2-12-12-12-12.compute-1.amazonaws.com
-
-Example: OpenStack Inventory Script
-```````````````````````````````````
-
-Though not detailed here in as much depth as the EC2 module, there's also a OpenStack Compute external inventory source in the plugins directory. It requires the Grizzly release of OpenStack or
-later. See the inline comments in the module source for how to use it.
-
-Callback Plugins
-----------------
-
-Ansible can be configured via code to respond to external events.  This can include enhancing logging, signalling an external software
-system, or even (yes, really) making sound effects.  Some examples are contained in the plugins directory.
-
-Connection Type Plugins
------------------------
-
-By default, ansible ships with a 'paramiko' SSH, native ssh (just called 'ssh'), and 'local' connection type, and an accelerated connection type named 'fireball'.  All of these can be used
-in playbooks and with /usr/bin/ansible to decide how you want to talk to remote machines.  The basics of these connection types
-are covered in the 'getting started' section.  Should you want to extend Ansible to support other transports (SNMP? Message bus?
-Carrier Pigeon?) it's as simple as copying the format of one of the existing modules and dropping it into the connection plugins
-directory.   The value of 'smart' for a connection allows selection of paramiko or openssh based on system capabilities, and chooses
-'ssh' if OpenSSH supports ControlPersist, in Ansible 1.2.1 an later.  Previous versions did not support 'smart'.
-
-Lookup Plugins
---------------
-
-Language constructs like "with_fileglob" and "with_items" are implemented via lookup plugins.  Just like other plugin types, you can write your own.
-
-Vars Plugins
-------------
-
-Playbook constructs like 'host_vars' and 'group_vars' work via 'vars' plugins.  They inject additional variable
-data into ansible runs that did not come from an inventory, playbook, or command line.  Note that variables
-can also be returned from inventory, so in most cases, you won't need to write or understand vars_plugins.
-
-Filter Plugins
---------------
-
-If you want more Jinja2 filters available in a Jinja2 template (filters like to_yaml and to_json are provided by default), they can be extended by writing a filter plugin.
-
-Distributing Plugins
---------------------
-
-.. versionadded:: 0.8
-
-Plugins are loaded from both Python's site_packages (those that ship with ansible) and a configured plugins directory, which defaults
-to /usr/share/ansible/plugins, in a subfolder for each plugin type::
-
-    * action_plugins
-    * lookup_plugins
-    * callback_plugins
-    * connection_plugins
-    * filter_plugins
-    * vars_plugins
-
-To change this path, edit the ansible configuration file.
-
-In addition, plugins can be shipped in a subdirectory relative to a top-level playbook, in folders named the same as indicated above.
-
-.. seealso::
-
-   :doc:`modules`
-       List of built-in modules
-   `Mailing List <http://groups.google.com/group/ansible-project>`_
-       Questions? Help? Ideas?  Stop by the list on Google Groups
-   `irc.freenode.net <http://irc.freenode.net>`_
-       #ansible IRC chat channel
-
diff --git a/docsite/latest/rst/developing_callbacks.rst b/docsite/latest/rst/developing_callbacks.rst
deleted file mode 100644
index b07cba206d..0000000000
--- a/docsite/latest/rst/developing_callbacks.rst
+++ /dev/null
@@ -1,397 +0,0 @@
-API & Integrations
-==================
-
-There are several interesting ways to use Ansible from an API perspective.   You can use
-the Ansible python API to control nodes, you can extend Ansible to respond to various python events,
-and you can plug in inventory data from external data sources.  Ansible is written in its own
-API so you have a considerable amount of power across the board.
-
-.. contents:: `Table of contents`
-   :depth: 2
-
-Python API
-----------
-
-The Python API is very powerful, and is how the ansible CLI and ansible-playbook
-are implemented.
-
-It's pretty simple::
-
-    import ansible.runner
-
-    runner = ansible.runner.Runner(
-       module_name='ping',
-       module_args='',
-       pattern='web*',
-       forks=10
-    )
-    datastructure = runner.run()
-
-The run method returns results per host, grouped by whether they
-could be contacted or not.  Return types are module specific, as
-expressed in the 'ansible-modules' documentation.::
-
-    {
-        "dark" : {
-           "web1.example.com" : "failure message"
-        },
-        "contacted" : {
-           "web2.example.com" : 1
-        }
-    }
-
-A module can return any type of JSON data it wants, so Ansible can
-be used as a framework to rapidly build powerful applications and scripts.
-
-Detailed API Example
-````````````````````
-
-The following script prints out the uptime information for all hosts::
-
-    #!/usr/bin/python
-
-    import ansible.runner
-    import sys
-
-    # construct the ansible runner and execute on all hosts
-    results = ansible.runner.Runner(
-        pattern='*', forks=10,
-        module_name='command', module_args='/usr/bin/uptime',
-    ).run()
-
-    if results is None:
-       print "No hosts found"
-       sys.exit(1)
-
-    print "UP ***********"
-    for (hostname, result) in results['contacted'].items():
-        if not 'failed' in result:
-            print "%s >>> %s" % (hostname, result['stdout'])
-
-    print "FAILED *******"
-    for (hostname, result) in results['contacted'].items():
-        if 'failed' in result:
-            print "%s >>> %s" % (hostname, result['msg'])
-
-    print "DOWN *********"
-    for (hostname, result) in results['dark'].items():
-        print "%s >>> %s" % (hostname, result)
-
-Advanced programmers may also wish to read the source to ansible itself, for
-it uses the Runner() API (with all available options) to implement the
-command line tools ``ansible`` and ``ansible-playbook``.
-
-Plugins Available Online
-------------------------
-
-The remainder of features in the API docs have components available in `ansible-plugins <https://github.com/ansible/ansible/blob/devel/plugins>`_.  Send us a github pull request if you develop any interesting features.
-
-External Inventory Scripts
---------------------------
-
-Often a user of a configuration management system will want to keep inventory
-in a different system.  Frequent examples include LDAP, `Cobbler <http://cobbler.github.com>`_,
-or a piece of expensive enterprisey CMDB software.   Ansible easily supports all
-of these options via an external inventory system.  The plugins directory contains some of these already -- including options for EC2/Eucalyptus and OpenStack, which will be detailed below.
-
-It's possible to write an external inventory script in any language.  If you are familiar with Puppet terminology, this concept is basically the same as 'external nodes', with the slight difference that it also defines which hosts are managed.
-
-Script Conventions
-``````````````````
-
-When the external node script is called with the single argument '--list', the script must return a JSON hash/dictionary of all the groups to be managed.
-Each group's value should be either a hash/dictionary containing a list of each host/IP, potential child groups, and potential group variables, or
-simply a list of host/IP addresses, like so::
-
-    {
-        "databases"   : {
-            "hosts"   : [ "host1.example.com", "host2.example.com" ],
-            "vars"    : {
-                "a"   : true
-            }
-        },
-        "webservers"  : [ "host2.example.com", "host3.example.com" ],
-        "atlanta"     : {
-            "hosts"   : [ "host1.example.com", "host4.example.com", "host5.example.com" ],
-            "vars"    : {
-                "b"   : false
-            },
-            "children": [ "marietta", "5points" ],
-        },
-        "marietta"    : [ "host6.example.com" ],
-        "5points"     : [ "host7.example.com" ]
-    }
-
-.. versionadded:: 1.0
-
-Before version 1.0, each group could only have a list of hostnames/IP addresses, like the webservers, marietta, and 5points groups above.
-
-When called with the arguments '--host <hostname>' (where <hostname> is a host from above), the script must return either an empty JSON
-hash/dictionary, or a hash/dictionary of variables to make available to templates and playbooks.  Returning variables is optional,
-if the script does not wish to do this, returning an empty hash/dictionary is the way to go::
-
-    {
-        "favcolor"   : "red",
-        "ntpserver"  : "wolf.example.com",
-        "monitoring" : "pack.example.com"
-    }
-
-Tuning the External Inventory Script
-````````````````````````````````````
-
-.. versionadded:: 1.3
-
-The stock inventory script system detailed above works for all versions of Ansible, but calling
-'--host' for every host can be rather expensive,  especially if it involves expensive API calls to
-a remote subsystemm.  In Ansible 
-1.3 or later, if the inventory script returns a top level element called "_meta", it is possible
-to return all of the host variables in one inventory script call.  When this meta element contains
-a value for "hostvars", the inventory script will not be invoked with "--host" for each host.  This
-results in a significant performance increase for large numbers of hosts, and also makes client
-side caching easier to implement for the inventory script.
-
-The data to be added to the top level JSON dictionary looks like this::
-
-    {
-
-        # results of inventory script as above go here
-        # ...
-
-        "_meta" : {
-           "hostvars" : {
-              "moocow.example.com"     : { "asdf" : 1234 },
-              "llama.example.com"      : { "asdf" : 5678 },
-           }
-        }
-
-    }
-
-
-Example: The Cobbler External Inventory Script
-``````````````````````````````````````````````
-
-It is expected that many Ansible users will also be `Cobbler <http://cobbler.github.com>`_ users.  Cobbler has a generic
-layer that allows it to represent data for multiple configuration management systems (even at the same time), and has
-been referred to as a 'lightweight CMDB' by some admins.   This particular script will communicate with Cobbler
-using Cobbler's XMLRPC API.
-
-To tie Ansible's inventory to Cobbler (optional), copy `this script <https://raw.github.com/ansible/ansible/devel/plugins/inventory/cobbler.py>`_ to /etc/ansible/hosts and `chmod +x` the file.  cobblerd will now need
-to be running when you are using Ansible.
-
-Test the file by running `./etc/ansible/hosts` directly.   You should see some JSON data output, but it may not have
-anything in it just yet.
-
-Let's explore what this does.  In cobbler, assume a scenario somewhat like the following::
-
-    cobbler profile add --name=webserver --distro=CentOS6-x86_64
-    cobbler profile edit --name=webserver --mgmt-classes="webserver" --ksmeta="a=2 b=3"
-    cobbler system edit --name=foo --dns-name="foo.example.com" --mgmt-classes="atlanta" --ksmeta="c=4"
-    cobbler system edit --name=bar --dns-name="bar.example.com" --mgmt-classes="atlanta" --ksmeta="c=5"
-
-In the example above, the system 'foo.example.com' will be addressable by ansible directly, but will also be addressable when using the group names 'webserver' or 'atlanta'.  Since Ansible uses SSH, we'll try to contract system foo over 'foo.example.com', only, never just 'foo'.  Similarly, if you try "ansible foo" it wouldn't find the system... but "ansible 'foo*'" would, because the system DNS name starts with 'foo'.
-
-The script doesn't just provide host and group info.  In addition, as a bonus, when the 'setup' module is run (which happens automatically when using playbooks), the variables 'a', 'b', and 'c' will all be auto-populated in the templates::
-
-    # file: /srv/motd.j2
-    Welcome, I am templated with a value of a={{ a }}, b={{ b }}, and c={{ c }}
-
-Which could be executed just like this::
-
-    ansible webserver -m setup
-    ansible webserver -m template -a "src=/tmp/motd.j2 dest=/etc/motd"
-
-.. note::
-   The name 'webserver' came from cobbler, as did the variables for
-   the config file.  You can still pass in your own variables like
-   normal in Ansible, but variables from the external inventory script
-   will override any that have the same name.
-
-So, with the template above (motd.j2), this would result in the following data being written to /etc/motd for system 'foo'::
-
-    Welcome, I am templated with a value of a=2, b=3, and c=4
-
-And on system 'bar' (bar.example.com)::
-
-    Welcome, I am templated with a value of a=2, b=3, and c=5
-
-And technically, though there is no major good reason to do it, this also works too::
-
-    ansible webserver -m shell -a "echo {{ a }}"
-
-So in other words, you can use those variables in arguments/actions as well.  You might use this to name
-a conf.d file appropriately or something similar.  Who knows?
-
-So that's the Cobbler integration support -- using the cobbler script as an example, it should be trivial to adapt Ansible to pull inventory, as well as variable information, from any data source.  If you create anything interesting, please share with the mailing list, and we can keep it in the source code tree for others to use.
-
-Example: AWS EC2 External Inventory Script
-``````````````````````````````````````````
-
-If you use Amazon Web Services EC2, maintaining an inventory file might not be the best approach. For this reason, you can use the `EC2 external inventory  <https://raw.github.com/ansible/ansible/devel/plugins/inventory/ec2.py>`_ script.
-
-You can use this script in one of two ways. The easiest is to use Ansible's ``-i`` command line option and specify the path to the script.
-
-    ansible -i ec2.py -u ubuntu us-east-1d -m ping
-
-The second option is to copy the script to `/etc/ansible/hosts` and `chmod +x` it. You will also need to copy the `ec2.ini  <https://raw.github.com/ansible/ansible/devel/plugins/inventory/ec2.ini>`_ file to `/etc/ansible/ec2.ini`. Then you can run ansible as you would normally.
-
-To successfully make an API call to AWS, you will need to configure Boto (the Python interface to AWS). There are a `variety of methods <http://docs.pythonboto.org/en/latest/boto_config_tut.html>`_ available, but the simplest is just to export two environment variables:
-
-    export AWS_ACCESS_KEY_ID='AK123'
-    export AWS_SECRET_ACCESS_KEY='abc123'
-
-You can test the script by itself to make sure your config is correct
-
-    cd plugins/inventory
-    ./ec2.py --list
-
-After a few moments, you should see your entire EC2 inventory across all regions in JSON.
-
-Since each region requires its own API call, if you are only using a small set of regions, feel free to edit ``ec2.ini`` and list only the regions you are interested in. There are other config options in ``ec2.ini`` including cache control, and destination variables.
-
-At their heart, inventory files are simply a mapping from some name to a destination address. The default ``ec2.ini`` settings are configured for running Ansible from outside EC2 (from your laptop for example). If you are running Ansible from within EC2, internal DNS names and IP addresses may make more sense than public DNS names. In this case, you can modify the ``destination_variable`` in ``ec2.ini`` to be the private DNS name of an instance. This is particularly important when running Ansible within a private subnet inside a VPC, where the only way to access an instance is via its private IP address. For VPC instances, `vpc_destination_variable` in ``ec2.ini`` provides a means of using which ever `boto.ec2.instance variable <http://docs.pythonboto.org/en/latest/ref/ec2.html#module-boto.ec2.instance>`_ makes the most sense for your use case.
-
-The EC2 external inventory provides mappings to instances from several groups:
-
-Instance ID
-  These are groups of one since instance IDs are unique.
-  e.g.
-  ``i-00112233``
-  ``i-a1b1c1d1``
-
-Region
-  A group of all instances in an AWS region.
-  e.g.
-  ``us-east-1``
-  ``us-west-2``
-
-Availability Zone
-  A group of all instances in an availability zone.
-  e.g.
-  ``us-east-1a``
-  ``us-east-1b``
-
-Security Group
-  Instances belong to one or more security groups. A group is created for each security group, with all characters except alphanumerics, dashes (-) converted to underscores (_). Each group is prefixed by ``security_group_``
-  e.g.
-  ``security_group_default``
-  ``security_group_webservers``
-  ``security_group_Pete_s_Fancy_Group``
-
-Tags
-  Each instance can have a variety of key/value pairs associated with it called Tags. The most common tag key is 'Name', though anything is possible. Each key/value pair is its own group of instances, again with special characters converted to underscores, in the format ``tag_KEY_VALUE``
-  e.g.
-  ``tag_Name_Web``
-  ``tag_Name_redis-master-001``
-  ``tag_aws_cloudformation_logical-id_WebServerGroup``
-
-When the Ansible is interacting with a specific server, the EC2 inventory script is called again with the ``--host HOST`` option. This looks up the HOST in the index cache to get the instance ID, and then makes an API call to AWS to get information about that specific instance. It then makes information about that instance available as variables to your playbooks. Each variable is prefixed by ``ec2_``. Here are some of the variables available:
-
-- ec2_architecture
-- ec2_description
-- ec2_dns_name
-- ec2_id
-- ec2_image_id
-- ec2_instance_type
-- ec2_ip_address
-- ec2_kernel
-- ec2_key_name
-- ec2_launch_time
-- ec2_monitored
-- ec2_ownerId
-- ec2_placement
-- ec2_platform
-- ec2_previous_state
-- ec2_private_dns_name
-- ec2_private_ip_address
-- ec2_public_dns_name
-- ec2_ramdisk
-- ec2_region
-- ec2_root_device_name
-- ec2_root_device_type
-- ec2_security_group_ids
-- ec2_security_group_names
-- ec2_spot_instance_request_id
-- ec2_state
-- ec2_state_code
-- ec2_state_reason
-- ec2_status
-- ec2_subnet_id
-- ec2_tag_Name
-- ec2_tenancy
-- ec2_virtualization_type
-- ec2_vpc_id
-
-Both ``ec2_security_group_ids`` and ``ec2_security_group_names`` are comma-separated lists of all security groups. Each EC2 tag is a variable in the format ``ec2_tag_KEY``.
-
-To see the complete list of variables available for an instance, run the script by itself::
-
-    cd plugins/inventory
-    ./ec2.py --host ec2-12-12-12-12.compute-1.amazonaws.com
-
-Example: OpenStack Inventory Script
-```````````````````````````````````
-
-Though not detailed here in as much depth as the EC2 module, there's also a OpenStack Compute external inventory source in the plugins directory. It requires the Grizzly release of OpenStack or
-later. See the inline comments in the module source for how to use it.
-
-Callback Plugins
-----------------
-
-Ansible can be configured via code to respond to external events.  This can include enhancing logging, signalling an external software
-system, or even (yes, really) making sound effects.  Some examples are contained in the plugins directory.
-
-Connection Type Plugins
------------------------
-
-By default, ansible ships with a 'paramiko' SSH, native ssh (just called 'ssh'), and 'local' connection type, and an accelerated connection type named 'fireball'.  All of these can be used
-in playbooks and with /usr/bin/ansible to decide how you want to talk to remote machines.  The basics of these connection types
-are covered in the 'getting started' section.  Should you want to extend Ansible to support other transports (SNMP? Message bus?
-Carrier Pigeon?) it's as simple as copying the format of one of the existing modules and dropping it into the connection plugins
-directory.   The value of 'smart' for a connection allows selection of paramiko or openssh based on system capabilities, and chooses
-'ssh' if OpenSSH supports ControlPersist, in Ansible 1.2.1 an later.  Previous versions did not support 'smart'.
-
-Lookup Plugins
---------------
-
-Language constructs like "with_fileglob" and "with_items" are implemented via lookup plugins.  Just like other plugin types, you can write your own.
-
-Vars Plugins
-------------
-
-Playbook constructs like 'host_vars' and 'group_vars' work via 'vars' plugins.  They inject additional variable
-data into ansible runs that did not come from an inventory, playbook, or command line.  Note that variables
-can also be returned from inventory, so in most cases, you won't need to write or understand vars_plugins.
-
-Filter Plugins
---------------
-
-If you want more Jinja2 filters available in a Jinja2 template (filters like to_yaml and to_json are provided by default), they can be extended by writing a filter plugin.
-
-Distributing Plugins
---------------------
-
-.. versionadded:: 0.8
-
-Plugins are loaded from both Python's site_packages (those that ship with ansible) and a configured plugins directory, which defaults
-to /usr/share/ansible/plugins, in a subfolder for each plugin type::
-
-    * action_plugins
-    * lookup_plugins
-    * callback_plugins
-    * connection_plugins
-    * filter_plugins
-    * vars_plugins
-
-To change this path, edit the ansible configuration file.
-
-In addition, plugins can be shipped in a subdirectory relative to a top-level playbook, in folders named the same as indicated above.
-
-.. seealso::
-
-   :doc:`modules`
-       List of built-in modules
-   `Mailing List <http://groups.google.com/group/ansible-project>`_
-       Questions? Help? Ideas?  Stop by the list on Google Groups
-   `irc.freenode.net <http://irc.freenode.net>`_
-       #ansible IRC chat channel
-
diff --git a/docsite/latest/rst/developing_inventory.rst b/docsite/latest/rst/developing_inventory.rst
index b07cba206d..04c5317793 100644
--- a/docsite/latest/rst/developing_inventory.rst
+++ b/docsite/latest/rst/developing_inventory.rst
@@ -1,107 +1,16 @@
-API & Integrations
-==================
+Inventory Plugins
+=================
 
-There are several interesting ways to use Ansible from an API perspective.   You can use
-the Ansible python API to control nodes, you can extend Ansible to respond to various python events,
-and you can plug in inventory data from external data sources.  Ansible is written in its own
-API so you have a considerable amount of power across the board.
+As described in `intro_inventory_dynamic`, ansible can pull inventory information from dynamic sources, including cloud sources.
 
-.. contents:: `Table of contents`
-   :depth: 2
+How do we write a new one?
 
-Python API
-----------
-
-The Python API is very powerful, and is how the ansible CLI and ansible-playbook
-are implemented.
-
-It's pretty simple::
-
-    import ansible.runner
-
-    runner = ansible.runner.Runner(
-       module_name='ping',
-       module_args='',
-       pattern='web*',
-       forks=10
-    )
-    datastructure = runner.run()
-
-The run method returns results per host, grouped by whether they
-could be contacted or not.  Return types are module specific, as
-expressed in the 'ansible-modules' documentation.::
-
-    {
-        "dark" : {
-           "web1.example.com" : "failure message"
-        },
-        "contacted" : {
-           "web2.example.com" : 1
-        }
-    }
-
-A module can return any type of JSON data it wants, so Ansible can
-be used as a framework to rapidly build powerful applications and scripts.
-
-Detailed API Example
-````````````````````
-
-The following script prints out the uptime information for all hosts::
-
-    #!/usr/bin/python
-
-    import ansible.runner
-    import sys
-
-    # construct the ansible runner and execute on all hosts
-    results = ansible.runner.Runner(
-        pattern='*', forks=10,
-        module_name='command', module_args='/usr/bin/uptime',
-    ).run()
-
-    if results is None:
-       print "No hosts found"
-       sys.exit(1)
-
-    print "UP ***********"
-    for (hostname, result) in results['contacted'].items():
-        if not 'failed' in result:
-            print "%s >>> %s" % (hostname, result['stdout'])
-
-    print "FAILED *******"
-    for (hostname, result) in results['contacted'].items():
-        if 'failed' in result:
-            print "%s >>> %s" % (hostname, result['msg'])
-
-    print "DOWN *********"
-    for (hostname, result) in results['dark'].items():
-        print "%s >>> %s" % (hostname, result)
-
-Advanced programmers may also wish to read the source to ansible itself, for
-it uses the Runner() API (with all available options) to implement the
-command line tools ``ansible`` and ``ansible-playbook``.
-
-Plugins Available Online
-------------------------
-
-The remainder of features in the API docs have components available in `ansible-plugins <https://github.com/ansible/ansible/blob/devel/plugins>`_.  Send us a github pull request if you develop any interesting features.
-
-External Inventory Scripts
---------------------------
-
-Often a user of a configuration management system will want to keep inventory
-in a different system.  Frequent examples include LDAP, `Cobbler <http://cobbler.github.com>`_,
-or a piece of expensive enterprisey CMDB software.   Ansible easily supports all
-of these options via an external inventory system.  The plugins directory contains some of these already -- including options for EC2/Eucalyptus and OpenStack, which will be detailed below.
-
-It's possible to write an external inventory script in any language.  If you are familiar with Puppet terminology, this concept is basically the same as 'external nodes', with the slight difference that it also defines which hosts are managed.
+Simple!  We just create a script that can return JSON in the right format when fed the proper arguments.
 
 Script Conventions
 ``````````````````
 
-When the external node script is called with the single argument '--list', the script must return a JSON hash/dictionary of all the groups to be managed.
-Each group's value should be either a hash/dictionary containing a list of each host/IP, potential child groups, and potential group variables, or
-simply a list of host/IP addresses, like so::
+When the external node script is called with the single argument '--list', the script must return a JSON hash/dictionary of all the groups to be managed. Each group's value should be either a hash/dictionary containing a list of each host/IP, potential child groups, and potential group variables, or simply a list of host/IP addresses, like so::
 
     {
         "databases"   : {
@@ -167,231 +76,3 @@ The data to be added to the top level JSON dictionary looks like this::
     }
 
 
-Example: The Cobbler External Inventory Script
-``````````````````````````````````````````````
-
-It is expected that many Ansible users will also be `Cobbler <http://cobbler.github.com>`_ users.  Cobbler has a generic
-layer that allows it to represent data for multiple configuration management systems (even at the same time), and has
-been referred to as a 'lightweight CMDB' by some admins.   This particular script will communicate with Cobbler
-using Cobbler's XMLRPC API.
-
-To tie Ansible's inventory to Cobbler (optional), copy `this script <https://raw.github.com/ansible/ansible/devel/plugins/inventory/cobbler.py>`_ to /etc/ansible/hosts and `chmod +x` the file.  cobblerd will now need
-to be running when you are using Ansible.
-
-Test the file by running `./etc/ansible/hosts` directly.   You should see some JSON data output, but it may not have
-anything in it just yet.
-
-Let's explore what this does.  In cobbler, assume a scenario somewhat like the following::
-
-    cobbler profile add --name=webserver --distro=CentOS6-x86_64
-    cobbler profile edit --name=webserver --mgmt-classes="webserver" --ksmeta="a=2 b=3"
-    cobbler system edit --name=foo --dns-name="foo.example.com" --mgmt-classes="atlanta" --ksmeta="c=4"
-    cobbler system edit --name=bar --dns-name="bar.example.com" --mgmt-classes="atlanta" --ksmeta="c=5"
-
-In the example above, the system 'foo.example.com' will be addressable by ansible directly, but will also be addressable when using the group names 'webserver' or 'atlanta'.  Since Ansible uses SSH, we'll try to contract system foo over 'foo.example.com', only, never just 'foo'.  Similarly, if you try "ansible foo" it wouldn't find the system... but "ansible 'foo*'" would, because the system DNS name starts with 'foo'.
-
-The script doesn't just provide host and group info.  In addition, as a bonus, when the 'setup' module is run (which happens automatically when using playbooks), the variables 'a', 'b', and 'c' will all be auto-populated in the templates::
-
-    # file: /srv/motd.j2
-    Welcome, I am templated with a value of a={{ a }}, b={{ b }}, and c={{ c }}
-
-Which could be executed just like this::
-
-    ansible webserver -m setup
-    ansible webserver -m template -a "src=/tmp/motd.j2 dest=/etc/motd"
-
-.. note::
-   The name 'webserver' came from cobbler, as did the variables for
-   the config file.  You can still pass in your own variables like
-   normal in Ansible, but variables from the external inventory script
-   will override any that have the same name.
-
-So, with the template above (motd.j2), this would result in the following data being written to /etc/motd for system 'foo'::
-
-    Welcome, I am templated with a value of a=2, b=3, and c=4
-
-And on system 'bar' (bar.example.com)::
-
-    Welcome, I am templated with a value of a=2, b=3, and c=5
-
-And technically, though there is no major good reason to do it, this also works too::
-
-    ansible webserver -m shell -a "echo {{ a }}"
-
-So in other words, you can use those variables in arguments/actions as well.  You might use this to name
-a conf.d file appropriately or something similar.  Who knows?
-
-So that's the Cobbler integration support -- using the cobbler script as an example, it should be trivial to adapt Ansible to pull inventory, as well as variable information, from any data source.  If you create anything interesting, please share with the mailing list, and we can keep it in the source code tree for others to use.
-
-Example: AWS EC2 External Inventory Script
-``````````````````````````````````````````
-
-If you use Amazon Web Services EC2, maintaining an inventory file might not be the best approach. For this reason, you can use the `EC2 external inventory  <https://raw.github.com/ansible/ansible/devel/plugins/inventory/ec2.py>`_ script.
-
-You can use this script in one of two ways. The easiest is to use Ansible's ``-i`` command line option and specify the path to the script.
-
-    ansible -i ec2.py -u ubuntu us-east-1d -m ping
-
-The second option is to copy the script to `/etc/ansible/hosts` and `chmod +x` it. You will also need to copy the `ec2.ini  <https://raw.github.com/ansible/ansible/devel/plugins/inventory/ec2.ini>`_ file to `/etc/ansible/ec2.ini`. Then you can run ansible as you would normally.
-
-To successfully make an API call to AWS, you will need to configure Boto (the Python interface to AWS). There are a `variety of methods <http://docs.pythonboto.org/en/latest/boto_config_tut.html>`_ available, but the simplest is just to export two environment variables:
-
-    export AWS_ACCESS_KEY_ID='AK123'
-    export AWS_SECRET_ACCESS_KEY='abc123'
-
-You can test the script by itself to make sure your config is correct
-
-    cd plugins/inventory
-    ./ec2.py --list
-
-After a few moments, you should see your entire EC2 inventory across all regions in JSON.
-
-Since each region requires its own API call, if you are only using a small set of regions, feel free to edit ``ec2.ini`` and list only the regions you are interested in. There are other config options in ``ec2.ini`` including cache control, and destination variables.
-
-At their heart, inventory files are simply a mapping from some name to a destination address. The default ``ec2.ini`` settings are configured for running Ansible from outside EC2 (from your laptop for example). If you are running Ansible from within EC2, internal DNS names and IP addresses may make more sense than public DNS names. In this case, you can modify the ``destination_variable`` in ``ec2.ini`` to be the private DNS name of an instance. This is particularly important when running Ansible within a private subnet inside a VPC, where the only way to access an instance is via its private IP address. For VPC instances, `vpc_destination_variable` in ``ec2.ini`` provides a means of using which ever `boto.ec2.instance variable <http://docs.pythonboto.org/en/latest/ref/ec2.html#module-boto.ec2.instance>`_ makes the most sense for your use case.
-
-The EC2 external inventory provides mappings to instances from several groups:
-
-Instance ID
-  These are groups of one since instance IDs are unique.
-  e.g.
-  ``i-00112233``
-  ``i-a1b1c1d1``
-
-Region
-  A group of all instances in an AWS region.
-  e.g.
-  ``us-east-1``
-  ``us-west-2``
-
-Availability Zone
-  A group of all instances in an availability zone.
-  e.g.
-  ``us-east-1a``
-  ``us-east-1b``
-
-Security Group
-  Instances belong to one or more security groups. A group is created for each security group, with all characters except alphanumerics, dashes (-) converted to underscores (_). Each group is prefixed by ``security_group_``
-  e.g.
-  ``security_group_default``
-  ``security_group_webservers``
-  ``security_group_Pete_s_Fancy_Group``
-
-Tags
-  Each instance can have a variety of key/value pairs associated with it called Tags. The most common tag key is 'Name', though anything is possible. Each key/value pair is its own group of instances, again with special characters converted to underscores, in the format ``tag_KEY_VALUE``
-  e.g.
-  ``tag_Name_Web``
-  ``tag_Name_redis-master-001``
-  ``tag_aws_cloudformation_logical-id_WebServerGroup``
-
-When the Ansible is interacting with a specific server, the EC2 inventory script is called again with the ``--host HOST`` option. This looks up the HOST in the index cache to get the instance ID, and then makes an API call to AWS to get information about that specific instance. It then makes information about that instance available as variables to your playbooks. Each variable is prefixed by ``ec2_``. Here are some of the variables available:
-
-- ec2_architecture
-- ec2_description
-- ec2_dns_name
-- ec2_id
-- ec2_image_id
-- ec2_instance_type
-- ec2_ip_address
-- ec2_kernel
-- ec2_key_name
-- ec2_launch_time
-- ec2_monitored
-- ec2_ownerId
-- ec2_placement
-- ec2_platform
-- ec2_previous_state
-- ec2_private_dns_name
-- ec2_private_ip_address
-- ec2_public_dns_name
-- ec2_ramdisk
-- ec2_region
-- ec2_root_device_name
-- ec2_root_device_type
-- ec2_security_group_ids
-- ec2_security_group_names
-- ec2_spot_instance_request_id
-- ec2_state
-- ec2_state_code
-- ec2_state_reason
-- ec2_status
-- ec2_subnet_id
-- ec2_tag_Name
-- ec2_tenancy
-- ec2_virtualization_type
-- ec2_vpc_id
-
-Both ``ec2_security_group_ids`` and ``ec2_security_group_names`` are comma-separated lists of all security groups. Each EC2 tag is a variable in the format ``ec2_tag_KEY``.
-
-To see the complete list of variables available for an instance, run the script by itself::
-
-    cd plugins/inventory
-    ./ec2.py --host ec2-12-12-12-12.compute-1.amazonaws.com
-
-Example: OpenStack Inventory Script
-```````````````````````````````````
-
-Though not detailed here in as much depth as the EC2 module, there's also a OpenStack Compute external inventory source in the plugins directory. It requires the Grizzly release of OpenStack or
-later. See the inline comments in the module source for how to use it.
-
-Callback Plugins
-----------------
-
-Ansible can be configured via code to respond to external events.  This can include enhancing logging, signalling an external software
-system, or even (yes, really) making sound effects.  Some examples are contained in the plugins directory.
-
-Connection Type Plugins
------------------------
-
-By default, ansible ships with a 'paramiko' SSH, native ssh (just called 'ssh'), and 'local' connection type, and an accelerated connection type named 'fireball'.  All of these can be used
-in playbooks and with /usr/bin/ansible to decide how you want to talk to remote machines.  The basics of these connection types
-are covered in the 'getting started' section.  Should you want to extend Ansible to support other transports (SNMP? Message bus?
-Carrier Pigeon?) it's as simple as copying the format of one of the existing modules and dropping it into the connection plugins
-directory.   The value of 'smart' for a connection allows selection of paramiko or openssh based on system capabilities, and chooses
-'ssh' if OpenSSH supports ControlPersist, in Ansible 1.2.1 an later.  Previous versions did not support 'smart'.
-
-Lookup Plugins
---------------
-
-Language constructs like "with_fileglob" and "with_items" are implemented via lookup plugins.  Just like other plugin types, you can write your own.
-
-Vars Plugins
-------------
-
-Playbook constructs like 'host_vars' and 'group_vars' work via 'vars' plugins.  They inject additional variable
-data into ansible runs that did not come from an inventory, playbook, or command line.  Note that variables
-can also be returned from inventory, so in most cases, you won't need to write or understand vars_plugins.
-
-Filter Plugins
---------------
-
-If you want more Jinja2 filters available in a Jinja2 template (filters like to_yaml and to_json are provided by default), they can be extended by writing a filter plugin.
-
-Distributing Plugins
---------------------
-
-.. versionadded:: 0.8
-
-Plugins are loaded from both Python's site_packages (those that ship with ansible) and a configured plugins directory, which defaults
-to /usr/share/ansible/plugins, in a subfolder for each plugin type::
-
-    * action_plugins
-    * lookup_plugins
-    * callback_plugins
-    * connection_plugins
-    * filter_plugins
-    * vars_plugins
-
-To change this path, edit the ansible configuration file.
-
-In addition, plugins can be shipped in a subdirectory relative to a top-level playbook, in folders named the same as indicated above.
-
-.. seealso::
-
-   :doc:`modules`
-       List of built-in modules
-   `Mailing List <http://groups.google.com/group/ansible-project>`_
-       Questions? Help? Ideas?  Stop by the list on Google Groups
-   `irc.freenode.net <http://irc.freenode.net>`_
-       #ansible IRC chat channel
-
diff --git a/docsite/latest/rst/developing_plugins.rst b/docsite/latest/rst/developing_plugins.rst
index b07cba206d..27c45f81ca 100644
--- a/docsite/latest/rst/developing_plugins.rst
+++ b/docsite/latest/rst/developing_plugins.rst
@@ -1,360 +1,33 @@
-API & Integrations
+Plugin Development
 ==================
 
-There are several interesting ways to use Ansible from an API perspective.   You can use
-the Ansible python API to control nodes, you can extend Ansible to respond to various python events,
-and you can plug in inventory data from external data sources.  Ansible is written in its own
-API so you have a considerable amount of power across the board.
+Ansible is pluggable in a lot of other ways seperate from inventory scripts and callbacks.  Many of these features are there to cover
+fringe use cases and are infrequently needed, and others are pluggable simply because they are there to implement core features
+in ansible and were most convient to be made pluggable.
 
-.. contents:: `Table of contents`
-   :depth: 2
-
-Python API
-----------
-
-The Python API is very powerful, and is how the ansible CLI and ansible-playbook
-are implemented.
-
-It's pretty simple::
-
-    import ansible.runner
-
-    runner = ansible.runner.Runner(
-       module_name='ping',
-       module_args='',
-       pattern='web*',
-       forks=10
-    )
-    datastructure = runner.run()
-
-The run method returns results per host, grouped by whether they
-could be contacted or not.  Return types are module specific, as
-expressed in the 'ansible-modules' documentation.::
-
-    {
-        "dark" : {
-           "web1.example.com" : "failure message"
-        },
-        "contacted" : {
-           "web2.example.com" : 1
-        }
-    }
-
-A module can return any type of JSON data it wants, so Ansible can
-be used as a framework to rapidly build powerful applications and scripts.
-
-Detailed API Example
-````````````````````
-
-The following script prints out the uptime information for all hosts::
-
-    #!/usr/bin/python
-
-    import ansible.runner
-    import sys
-
-    # construct the ansible runner and execute on all hosts
-    results = ansible.runner.Runner(
-        pattern='*', forks=10,
-        module_name='command', module_args='/usr/bin/uptime',
-    ).run()
-
-    if results is None:
-       print "No hosts found"
-       sys.exit(1)
-
-    print "UP ***********"
-    for (hostname, result) in results['contacted'].items():
-        if not 'failed' in result:
-            print "%s >>> %s" % (hostname, result['stdout'])
-
-    print "FAILED *******"
-    for (hostname, result) in results['contacted'].items():
-        if 'failed' in result:
-            print "%s >>> %s" % (hostname, result['msg'])
-
-    print "DOWN *********"
-    for (hostname, result) in results['dark'].items():
-        print "%s >>> %s" % (hostname, result)
-
-Advanced programmers may also wish to read the source to ansible itself, for
-it uses the Runner() API (with all available options) to implement the
-command line tools ``ansible`` and ``ansible-playbook``.
-
-Plugins Available Online
-------------------------
-
-The remainder of features in the API docs have components available in `ansible-plugins <https://github.com/ansible/ansible/blob/devel/plugins>`_.  Send us a github pull request if you develop any interesting features.
-
-External Inventory Scripts
---------------------------
-
-Often a user of a configuration management system will want to keep inventory
-in a different system.  Frequent examples include LDAP, `Cobbler <http://cobbler.github.com>`_,
-or a piece of expensive enterprisey CMDB software.   Ansible easily supports all
-of these options via an external inventory system.  The plugins directory contains some of these already -- including options for EC2/Eucalyptus and OpenStack, which will be detailed below.
-
-It's possible to write an external inventory script in any language.  If you are familiar with Puppet terminology, this concept is basically the same as 'external nodes', with the slight difference that it also defines which hosts are managed.
-
-Script Conventions
-``````````````````
-
-When the external node script is called with the single argument '--list', the script must return a JSON hash/dictionary of all the groups to be managed.
-Each group's value should be either a hash/dictionary containing a list of each host/IP, potential child groups, and potential group variables, or
-simply a list of host/IP addresses, like so::
-
-    {
-        "databases"   : {
-            "hosts"   : [ "host1.example.com", "host2.example.com" ],
-            "vars"    : {
-                "a"   : true
-            }
-        },
-        "webservers"  : [ "host2.example.com", "host3.example.com" ],
-        "atlanta"     : {
-            "hosts"   : [ "host1.example.com", "host4.example.com", "host5.example.com" ],
-            "vars"    : {
-                "b"   : false
-            },
-            "children": [ "marietta", "5points" ],
-        },
-        "marietta"    : [ "host6.example.com" ],
-        "5points"     : [ "host7.example.com" ]
-    }
-
-.. versionadded:: 1.0
-
-Before version 1.0, each group could only have a list of hostnames/IP addresses, like the webservers, marietta, and 5points groups above.
-
-When called with the arguments '--host <hostname>' (where <hostname> is a host from above), the script must return either an empty JSON
-hash/dictionary, or a hash/dictionary of variables to make available to templates and playbooks.  Returning variables is optional,
-if the script does not wish to do this, returning an empty hash/dictionary is the way to go::
-
-    {
-        "favcolor"   : "red",
-        "ntpserver"  : "wolf.example.com",
-        "monitoring" : "pack.example.com"
-    }
-
-Tuning the External Inventory Script
-````````````````````````````````````
-
-.. versionadded:: 1.3
-
-The stock inventory script system detailed above works for all versions of Ansible, but calling
-'--host' for every host can be rather expensive,  especially if it involves expensive API calls to
-a remote subsystemm.  In Ansible 
-1.3 or later, if the inventory script returns a top level element called "_meta", it is possible
-to return all of the host variables in one inventory script call.  When this meta element contains
-a value for "hostvars", the inventory script will not be invoked with "--host" for each host.  This
-results in a significant performance increase for large numbers of hosts, and also makes client
-side caching easier to implement for the inventory script.
-
-The data to be added to the top level JSON dictionary looks like this::
-
-    {
-
-        # results of inventory script as above go here
-        # ...
-
-        "_meta" : {
-           "hostvars" : {
-              "moocow.example.com"     : { "asdf" : 1234 },
-              "llama.example.com"      : { "asdf" : 5678 },
-           }
-        }
-
-    }
-
-
-Example: The Cobbler External Inventory Script
-``````````````````````````````````````````````
-
-It is expected that many Ansible users will also be `Cobbler <http://cobbler.github.com>`_ users.  Cobbler has a generic
-layer that allows it to represent data for multiple configuration management systems (even at the same time), and has
-been referred to as a 'lightweight CMDB' by some admins.   This particular script will communicate with Cobbler
-using Cobbler's XMLRPC API.
-
-To tie Ansible's inventory to Cobbler (optional), copy `this script <https://raw.github.com/ansible/ansible/devel/plugins/inventory/cobbler.py>`_ to /etc/ansible/hosts and `chmod +x` the file.  cobblerd will now need
-to be running when you are using Ansible.
-
-Test the file by running `./etc/ansible/hosts` directly.   You should see some JSON data output, but it may not have
-anything in it just yet.
-
-Let's explore what this does.  In cobbler, assume a scenario somewhat like the following::
-
-    cobbler profile add --name=webserver --distro=CentOS6-x86_64
-    cobbler profile edit --name=webserver --mgmt-classes="webserver" --ksmeta="a=2 b=3"
-    cobbler system edit --name=foo --dns-name="foo.example.com" --mgmt-classes="atlanta" --ksmeta="c=4"
-    cobbler system edit --name=bar --dns-name="bar.example.com" --mgmt-classes="atlanta" --ksmeta="c=5"
-
-In the example above, the system 'foo.example.com' will be addressable by ansible directly, but will also be addressable when using the group names 'webserver' or 'atlanta'.  Since Ansible uses SSH, we'll try to contract system foo over 'foo.example.com', only, never just 'foo'.  Similarly, if you try "ansible foo" it wouldn't find the system... but "ansible 'foo*'" would, because the system DNS name starts with 'foo'.
-
-The script doesn't just provide host and group info.  In addition, as a bonus, when the 'setup' module is run (which happens automatically when using playbooks), the variables 'a', 'b', and 'c' will all be auto-populated in the templates::
-
-    # file: /srv/motd.j2
-    Welcome, I am templated with a value of a={{ a }}, b={{ b }}, and c={{ c }}
-
-Which could be executed just like this::
-
-    ansible webserver -m setup
-    ansible webserver -m template -a "src=/tmp/motd.j2 dest=/etc/motd"
-
-.. note::
-   The name 'webserver' came from cobbler, as did the variables for
-   the config file.  You can still pass in your own variables like
-   normal in Ansible, but variables from the external inventory script
-   will override any that have the same name.
-
-So, with the template above (motd.j2), this would result in the following data being written to /etc/motd for system 'foo'::
-
-    Welcome, I am templated with a value of a=2, b=3, and c=4
-
-And on system 'bar' (bar.example.com)::
-
-    Welcome, I am templated with a value of a=2, b=3, and c=5
-
-And technically, though there is no major good reason to do it, this also works too::
-
-    ansible webserver -m shell -a "echo {{ a }}"
-
-So in other words, you can use those variables in arguments/actions as well.  You might use this to name
-a conf.d file appropriately or something similar.  Who knows?
-
-So that's the Cobbler integration support -- using the cobbler script as an example, it should be trivial to adapt Ansible to pull inventory, as well as variable information, from any data source.  If you create anything interesting, please share with the mailing list, and we can keep it in the source code tree for others to use.
-
-Example: AWS EC2 External Inventory Script
-``````````````````````````````````````````
-
-If you use Amazon Web Services EC2, maintaining an inventory file might not be the best approach. For this reason, you can use the `EC2 external inventory  <https://raw.github.com/ansible/ansible/devel/plugins/inventory/ec2.py>`_ script.
-
-You can use this script in one of two ways. The easiest is to use Ansible's ``-i`` command line option and specify the path to the script.
-
-    ansible -i ec2.py -u ubuntu us-east-1d -m ping
-
-The second option is to copy the script to `/etc/ansible/hosts` and `chmod +x` it. You will also need to copy the `ec2.ini  <https://raw.github.com/ansible/ansible/devel/plugins/inventory/ec2.ini>`_ file to `/etc/ansible/ec2.ini`. Then you can run ansible as you would normally.
-
-To successfully make an API call to AWS, you will need to configure Boto (the Python interface to AWS). There are a `variety of methods <http://docs.pythonboto.org/en/latest/boto_config_tut.html>`_ available, but the simplest is just to export two environment variables:
-
-    export AWS_ACCESS_KEY_ID='AK123'
-    export AWS_SECRET_ACCESS_KEY='abc123'
-
-You can test the script by itself to make sure your config is correct
-
-    cd plugins/inventory
-    ./ec2.py --list
-
-After a few moments, you should see your entire EC2 inventory across all regions in JSON.
-
-Since each region requires its own API call, if you are only using a small set of regions, feel free to edit ``ec2.ini`` and list only the regions you are interested in. There are other config options in ``ec2.ini`` including cache control, and destination variables.
-
-At their heart, inventory files are simply a mapping from some name to a destination address. The default ``ec2.ini`` settings are configured for running Ansible from outside EC2 (from your laptop for example). If you are running Ansible from within EC2, internal DNS names and IP addresses may make more sense than public DNS names. In this case, you can modify the ``destination_variable`` in ``ec2.ini`` to be the private DNS name of an instance. This is particularly important when running Ansible within a private subnet inside a VPC, where the only way to access an instance is via its private IP address. For VPC instances, `vpc_destination_variable` in ``ec2.ini`` provides a means of using which ever `boto.ec2.instance variable <http://docs.pythonboto.org/en/latest/ref/ec2.html#module-boto.ec2.instance>`_ makes the most sense for your use case.
-
-The EC2 external inventory provides mappings to instances from several groups:
-
-Instance ID
-  These are groups of one since instance IDs are unique.
-  e.g.
-  ``i-00112233``
-  ``i-a1b1c1d1``
-
-Region
-  A group of all instances in an AWS region.
-  e.g.
-  ``us-east-1``
-  ``us-west-2``
-
-Availability Zone
-  A group of all instances in an availability zone.
-  e.g.
-  ``us-east-1a``
-  ``us-east-1b``
-
-Security Group
-  Instances belong to one or more security groups. A group is created for each security group, with all characters except alphanumerics, dashes (-) converted to underscores (_). Each group is prefixed by ``security_group_``
-  e.g.
-  ``security_group_default``
-  ``security_group_webservers``
-  ``security_group_Pete_s_Fancy_Group``
-
-Tags
-  Each instance can have a variety of key/value pairs associated with it called Tags. The most common tag key is 'Name', though anything is possible. Each key/value pair is its own group of instances, again with special characters converted to underscores, in the format ``tag_KEY_VALUE``
-  e.g.
-  ``tag_Name_Web``
-  ``tag_Name_redis-master-001``
-  ``tag_aws_cloudformation_logical-id_WebServerGroup``
-
-When the Ansible is interacting with a specific server, the EC2 inventory script is called again with the ``--host HOST`` option. This looks up the HOST in the index cache to get the instance ID, and then makes an API call to AWS to get information about that specific instance. It then makes information about that instance available as variables to your playbooks. Each variable is prefixed by ``ec2_``. Here are some of the variables available:
-
-- ec2_architecture
-- ec2_description
-- ec2_dns_name
-- ec2_id
-- ec2_image_id
-- ec2_instance_type
-- ec2_ip_address
-- ec2_kernel
-- ec2_key_name
-- ec2_launch_time
-- ec2_monitored
-- ec2_ownerId
-- ec2_placement
-- ec2_platform
-- ec2_previous_state
-- ec2_private_dns_name
-- ec2_private_ip_address
-- ec2_public_dns_name
-- ec2_ramdisk
-- ec2_region
-- ec2_root_device_name
-- ec2_root_device_type
-- ec2_security_group_ids
-- ec2_security_group_names
-- ec2_spot_instance_request_id
-- ec2_state
-- ec2_state_code
-- ec2_state_reason
-- ec2_status
-- ec2_subnet_id
-- ec2_tag_Name
-- ec2_tenancy
-- ec2_virtualization_type
-- ec2_vpc_id
-
-Both ``ec2_security_group_ids`` and ``ec2_security_group_names`` are comma-separated lists of all security groups. Each EC2 tag is a variable in the format ``ec2_tag_KEY``.
-
-To see the complete list of variables available for an instance, run the script by itself::
-
-    cd plugins/inventory
-    ./ec2.py --host ec2-12-12-12-12.compute-1.amazonaws.com
-
-Example: OpenStack Inventory Script
-```````````````````````````````````
-
-Though not detailed here in as much depth as the EC2 module, there's also a OpenStack Compute external inventory source in the plugins directory. It requires the Grizzly release of OpenStack or
-later. See the inline comments in the module source for how to use it.
-
-Callback Plugins
-----------------
-
-Ansible can be configured via code to respond to external events.  This can include enhancing logging, signalling an external software
-system, or even (yes, really) making sound effects.  Some examples are contained in the plugins directory.
+This section will explore these features, though they are generally not common in terms of things people would look to extend.
 
 Connection Type Plugins
 -----------------------
 
-By default, ansible ships with a 'paramiko' SSH, native ssh (just called 'ssh'), and 'local' connection type, and an accelerated connection type named 'fireball'.  All of these can be used
+By default, ansible ships with a 'paramiko' SSH, native ssh (just called 'ssh'), and 'local' connection type, and an accelerated connection type named 'fireball' -- there are also some minor players like 'chroot' and 'jail'.  All of these can be used
 in playbooks and with /usr/bin/ansible to decide how you want to talk to remote machines.  The basics of these connection types
 are covered in the 'getting started' section.  Should you want to extend Ansible to support other transports (SNMP? Message bus?
 Carrier Pigeon?) it's as simple as copying the format of one of the existing modules and dropping it into the connection plugins
 directory.   The value of 'smart' for a connection allows selection of paramiko or openssh based on system capabilities, and chooses
 'ssh' if OpenSSH supports ControlPersist, in Ansible 1.2.1 an later.  Previous versions did not support 'smart'.
 
+More documentation on writing connection plugins is pending, though you can jump into lib/ansible/runner/connection_plugins and figure
+things out pretty easily.
+
 Lookup Plugins
 --------------
 
 Language constructs like "with_fileglob" and "with_items" are implemented via lookup plugins.  Just like other plugin types, you can write your own.
 
+More documentation on writing connection plugins is pending, though you can jump into lib/ansible/runner/lookup_plugins and figure
+things out pretty easily.
+
 Vars Plugins
 ------------
 
@@ -362,10 +35,46 @@ Playbook constructs like 'host_vars' and 'group_vars' work via 'vars' plugins.
 data into ansible runs that did not come from an inventory, playbook, or command line.  Note that variables
 can also be returned from inventory, so in most cases, you won't need to write or understand vars_plugins.
 
+More documentation on writing connection plugins is pending, though you can jump into lib/ansible/inventory/vars_plugins and figure
+things out pretty easily.
+
+If you find yourself wanting to write a vars_plugin, it's more likely you should write an inventory script instead.
+
 Filter Plugins
 --------------
 
-If you want more Jinja2 filters available in a Jinja2 template (filters like to_yaml and to_json are provided by default), they can be extended by writing a filter plugin.
+If you want more Jinja2 filters available in a Jinja2 template (filters like to_yaml and to_json are provided by default), they can be extended by writing a filter plugin.  Most of the time, when someone comes up with an idea for a new filter they would like to make available in a playbook, we'll just include them in 'core.py' instead.  
+
+Jump into lib/ansible/runner/filter_plugins/ for details.
+
+
+Callbacks
+---------
+
+Callbacks are one of the more interesting plugin types.  Adding additional callback plugins to Ansible allows for adding new behaviors when responding to events.
+
+Examples
+++++++++
+
+Example callbacks are shown `in github in the callbacks directory <https://github.com/ansible/ansible/tree/devel/plugins/callbacks>_`.
+
+The 'log_plays' callback is an example of how to intercept playbook events to a log file, and the 'mail' callback sends email
+when playbooks complete.
+
+The 'osx_say' callback provided is particularly entertaining -- it will respond with computer synthesized speech on OS X in relation
+to playbook events, and is guaranteed to entertain and/or annoy coworkers.
+
+Configuring
++++++++++++
+
+To active a callback drop it in a callback directory as configured in ansible.cfg.
+
+Development
++++++++++++
+
+More information will come later, though see the source of any of the existing callbacks and you should be able to get started quickly.  
+They should be reasonably self explanatory.
+
 
 Distributing Plugins
 --------------------
diff --git a/docsite/latest/rst/index.rst b/docsite/latest/rst/index.rst
index 94c9b79fe0..273f51f115 100644
--- a/docsite/latest/rst/index.rst
+++ b/docsite/latest/rst/index.rst
@@ -115,17 +115,10 @@ with other solutions in your environment.
 .. toctree::
    :maxdepth: 1
 
-   developing_contributing
-   developing_code_standards
    developing_api
    developing_inventory
    developing_modules
    developing_plugins
-   developing_callbacks
-   developing_filters
-   developing_lookups
-   developing_transports
-   developing_modules
    REST API <http://ansibleworks.com/ansibleworks-awx>
 
 Miscellaneous
diff --git a/docsite/latest/rst/intro_variables.rst b/docsite/latest/rst/intro_variables.rst
index 5e919fb79b..06bd8d13c7 100644
--- a/docsite/latest/rst/intro_variables.rst
+++ b/docsite/latest/rst/intro_variables.rst
@@ -231,82 +231,6 @@ The contents of each variables file is a simple YAML dictionary, like this::
    It's also possible to keep per-host and per-group variables in very
    similar files, this is covered in :ref:`patterns`.
 
-Prompting For Sensitive Data
-````````````````````````````
-
-You may wish to prompt the user for certain input, and can
-do so with the similarly named 'vars_prompt' section.  This has uses
-beyond security, for instance, you may use the same playbook for all
-software releases and would prompt for a particular release version
-in a push-script::
-
-    ---
-    - hosts: all
-      remote_user: root
-      vars:
-        from: "camelot"
-      vars_prompt:
-        name: "what is your name?"
-        quest: "what is your quest?"
-        favcolor: "what is your favorite color?"
-
-There are full examples of both of these items in the github examples/playbooks directory.
-
-If you have a variable that changes infrequently, it might make sense to
-provide a default value that can be overridden.  This can be accomplished using
-the default argument::
-
-   vars_prompt:
-     - name: "release_version"
-       prompt: "Product release version"
-       default: "1.0"
-
-An alternative form of vars_prompt allows for hiding input from the user, and may later support
-some other options, but otherwise works equivalently::
-
-   vars_prompt:
-     - name: "some_password"
-       prompt: "Enter password"
-       private: yes
-     - name: "release_version"
-       prompt: "Product release version"
-       private: no
-
-If `Passlib <http://pythonhosted.org/passlib/>`_ is installed, vars_prompt can also crypt the
-entered value so you can use it, for instance, with the user module to define a password::
-
-   vars_prompt:
-     - name: "my_password2"
-       prompt: "Enter password2"
-       private: yes
-       encrypt: "md5_crypt"
-       confirm: yes
-       salt_size: 7
-
-You can use any crypt scheme supported by 'Passlib':
-
-- *des_crypt* - DES Crypt
-- *bsdi_crypt* - BSDi Crypt
-- *bigcrypt* - BigCrypt
-- *crypt16* - Crypt16
-- *md5_crypt* - MD5 Crypt
-- *bcrypt* - BCrypt
-- *sha1_crypt* - SHA-1 Crypt
-- *sun_md5_crypt* - Sun MD5 Crypt
-- *sha256_crypt* - SHA-256 Crypt
-- *sha512_crypt* - SHA-512 Crypt
-- *apr_md5_crypt* - Apache’s MD5-Crypt variant
-- *phpass* - PHPass’ Portable Hash
-- *pbkdf2_digest* - Generic PBKDF2 Hashes
-- *cta_pbkdf2_sha1* - Cryptacular’s PBKDF2 hash
-- *dlitz_pbkdf2_sha1* - Dwayne Litzenberger’s PBKDF2 hash
-- *scram* - SCRAM Hash
-- *bsd_nthash* - FreeBSD’s MCF-compatible nthash encoding
-
-However, the only parameters accepted are 'salt' or 'salt_size'. You can use you own salt using
-'salt', or have one generated automatically using 'salt_size'. If nothing is specified, a salt
-of size 8 will be generated.
-
 Passing Variables On The Command Line
 `````````````````````````````````````
 
@@ -393,4 +317,3 @@ Ansible's approach to configuration -- separating variables from tasks, keeps yo
 from turning into arbitrary code with ugly nested ifs, conditionals, and so on - and results
 in more streamlined & auditable configuration rules -- especially because there are a
 minimum of decision points to track.
-
diff --git a/docsite/latest/rst/playbooks.rst b/docsite/latest/rst/playbooks.rst
index 078b6e2378..0873cb3627 100644
--- a/docsite/latest/rst/playbooks.rst
+++ b/docsite/latest/rst/playbooks.rst
@@ -1,347 +1,3 @@
-
- 
-Playbooks
-=========
-
-.. contents::
-   :depth: 2
-
-Introduction
-````````````
-
-Playbooks are a completely different way to use ansible than in task execution mode, and are
-particularly powerful. Simply put, playbooks are the basis for a really simple
-configuration management and multi-machine deployment system,
-unlike any that already exist, and one that is very well suited to deploying complex applications.
-
-Playbooks can declare configurations, but they can also orchestrate steps of
-any manual ordered process, even as different steps must bounce back and forth
-between sets of machines in particular orders.  They can launch tasks
-synchronously or asynchronously.
-
-While you might run the main /usr/bin/ansible program for ad-hoc
-tasks, playbooks are more likely to be kept in source control and used
-to push out your configuration or assure the configurations of your
-remote systems are in spec.
-
-Let's dive in and see how they work.  As you go, you may wish to open
-the `github examples directory <https://github.com/ansible/ansible/tree/devel/examples/playbooks>`_ in
-another tab, so you can apply the theory to what things look like in practice.
-
-There are also some full sets of playbooks illustrating a lot of these techniques in the
-`ansible-examples repository <https://github.com/ansible/ansible-examples>`_.
-
-There are also many jumping off points after you learn playbooks, so hop back to the documentation
-index after you're done with this section.
-
-Playbook Language Example
-`````````````````````````
-
-Playbooks are expressed in YAML format and have a minimum of syntax.
-Each playbook is composed of one or more 'plays' in a list.
-
-The goal of a play is to map a group of hosts to some well defined roles, represented by
-things ansible calls tasks.  At a basic level, a task is nothing more than a call
-to an ansible module, which you should have learned about in earlier chapters.
-
-By composing a playbook of multiple 'plays', it is possible to
-orchestrate multi-machine deployments, running certain steps on all
-machines in the webservers group, then certain steps on the database
-server group, then more commands back on the webservers group, etc.
-
-For starters, here's a playbook that contains just one play::
-
-    ---
-    - hosts: webservers
-      vars:
-        http_port: 80
-        max_clients: 200
-      remote_user: root
-      tasks:
-      - name: ensure apache is at the latest version
-        yum: pkg=httpd state=latest
-      - name: write the apache config file
-        template: src=/srv/httpd.j2 dest=/etc/httpd.conf
-        notify:
-        - restart apache
-      - name: ensure apache is running
-        service: name=httpd state=started
-      handlers:
-        - name: restart apache
-          service: name=httpd state=restarted
-
-Below, we'll break down what the various features of the playbook language are.
-
-Basics
-``````
-
-Hosts and Users
-+++++++++++++++
-
-For each play in a playbook, you get to choose which machines in your infrastructure
-to target and what remote user to complete the steps (called tasks) as.
-
-The `hosts` line is a list of one or more groups or host patterns,
-separated by colons, as described in the :ref:`patterns`
-documentation.  The `remote_user` is just the name of the user account::
-
-    ---
-    - hosts: webservers
-      remote_user: root
-
-.. Note::
-
-    The `remote_user` parameter was formerly called just `user`. It was renamed in Ansible 1.4 to make it more distinguishable from the `user` module (used to create users on remote systems).
-
-Support for running things from sudo is also available::
-
-    ---
-    - hosts: webservers
-      remote_user: yourname
-      sudo: yes
-
-You can also use sudo on a particular task instead of the whole play::
-
-    ---
-    - hosts: webservers
-      remote_user: yourname
-      tasks:
-        - service: name=nginx state=started
-          sudo: yes
-
-
-You can also login as you, and then sudo to different users than root::
-
-    ---
-    - hosts: webservers
-      remote_user: yourname
-      sudo: yes
-      sudo_user: postgres
-
-If you need to specify a password to sudo, run `ansible-playbook` with ``--ask-sudo-pass`` (`-K`).
-If you run a sudo playbook and the playbook seems to hang, it's probably stuck at the sudo prompt.
-Just `Control-C` to kill it and run it again with `-K`.
-
-.. important::
-
-   When using `sudo_user` to a user other than root, the module
-   arguments are briefly written into a random tempfile in /tmp.
-   These are deleted immediately after the command is executed.  This
-   only occurs when sudoing from a user like 'bob' to 'timmy', not
-   when going from 'bob' to 'root', or logging in directly as 'bob' or
-   'root'.  If this concerns you that this data is briefly readable
-   (not writeable), avoid transferring uncrypted passwords with
-   `sudo_user` set.  In other cases, '/tmp' is not used and this does
-   not come into play. Ansible also takes care to not log password
-   parameters.
-
-Tasks list
-++++++++++
-
-Each play contains a list of tasks.  Tasks are executed in order, one
-at a time, against all machines matched by the host pattern,
-before moving on to the next task.  It is important to understand that, within a play,
-all hosts are going to get the same task directives.  It is the purpose of a play to map
-a selection of hosts to tasks.
-
-When running the playbook, which runs top to bottom, hosts with failed tasks are
-taken out of the rotation for the entire playbook.  If things fail, simply correct the playbook file and rerun.
-
-The goal of each task is to execute a module, with very specific arguments.
-Variables, as mentioned above, can be used in arguments to modules.
-
-Modules are 'idempotent', meaning if you run them
-again, they will make only the changes they must in order to bring the
-system to the desired state.  This makes it very safe to rerun
-the same playbook multiple times.  They won't change things
-unless they have to change things.
-
-The `command` and `shell` modules will typically rerun the same command again,
-which is totally ok if the command is something like
-'chmod' or 'setsebool', etc.  Though there is a 'creates' flag available which can
-be used to make these modules also idempotent.
-
-Every task should have a `name`, which is included in the output from
-running the playbook.   This is output for humans, so it is
-nice to have reasonably good descriptions of each task step.  If the name
-is not provided though, the string fed to 'action' will be used for
-output.
-
-Tasks can be declared using the legacy "action: module options" format, but 
-it is recommeded that you use the more conventional "module: options" format.
-This recommended format is used throughout the documentation, but you may
-encounter the older format in some playbooks.
-
-Here is what a basic task looks like, as with most modules,
-the service module takes key=value arguments::
-
-   tasks:
-     - name: make sure apache is running
-       service: name=httpd state=running
-
-The `command` and `shell` modules are the one modules that just takes a list
-of arguments, and don't use the key=value form.  This makes
-them work just like you would expect. Simple::
-
-   tasks:
-     - name: disable selinux
-       command: /sbin/setenforce 0
-
-The command and shell module care about return codes, so if you have a command
-whose successful exit code is not zero, you may wish to do this::
-
-   tasks:
-     - name: run this command and ignore the result
-       shell: /usr/bin/somecommand || /bin/true
-
-Or this::
-
-   tasks:
-     - name: run this command and ignore the result
-       shell: /usr/bin/somecommand
-       ignore_errors: True
-
-
-If the action line is getting too long for comfort you can break it on
-a space and indent any continuation lines::
-
-    tasks:
-      - name: Copy ansible inventory file to client
-        copy: src=/etc/ansible/hosts dest=/etc/ansible/hosts
-                owner=root group=root mode=0644
-
-Variables can be used in action lines.   Suppose you defined
-a variable called 'vhost' in the 'vars' section, you could do this::
-
-   tasks:
-     - name: create a virtual host file for {{ vhost }}
-       template: src=somefile.j2 dest=/etc/httpd/conf.d/{{ vhost }}
-
-Those same variables are usable in templates, which we'll get to later.
-
-Now in a very basic playbook all the tasks will be listed directly in that play, though it will usually
-make more sense to break up tasks using the 'include:' directive.  We'll show that a bit later.
-
-Action Shorthand
-````````````````
-
-.. versionadded:: 0.8
-
-Ansible prefers listing modules like this in 0.8 and later::
-
-    template: src=templates/foo.j2 dest=/etc/foo.conf
-
-You will notice in earlier versions, this was only available as::
-
-    action: template src=templates/foo.j2 dest=/etc/foo.conf
-
-The old form continues to work in newer versions without any plan of deprecation.
-
-Handlers: Running Operations On Change
-``````````````````````````````````````
-
-As we've mentioned, modules are written to be 'idempotent' and can relay  when
-they have made a change on the remote system.   Playbooks recognize this and
-have a basic event system that can be used to respond to change.
-
-These 'notify' actions are triggered at the end of each block of tasks in a playbook, and will only be
-triggered once even if notified by multiple different tasks.
-
-For instance, multiple resources may indicate
-that apache needs to be restarted because they have changed a config file,
-but apache will only be bounced once to avoid unneccessary restarts.
-
-Here's an example of restarting two services when the contents of a file
-change, but only if the file changes::
-
-   - name: template configuration file
-     template: src=template.j2 dest=/etc/foo.conf
-     notify:
-        - restart memcached
-        - restart apache
-
-The things listed in the 'notify' section of a task are called
-handlers.
-
-Handlers are lists of tasks, not really any different from regular
-tasks, that are referenced by name.  Handlers are what notifiers
-notify.  If nothing notifies a handler, it will not run.  Regardless
-of how many things notify a handler, it will run only once, after all
-of the tasks complete in a particular play.
-
-Here's an example handlers section::
-
-    handlers:
-        - name: restart memcached
-          service:  name=memcached state=restarted
-        - name: restart apache
-          service: name=apache state=restarted
-
-Handlers are best used to restart services and trigger reboots.  You probably
-won't need them for much else.
-
-.. note::
-   Notify handlers are always run in the order written.
-
-Roles are described later on.  It's worthwhile to point out that handlers are
-automatically processed between 'pre_tasks', 'roles', 'tasks', and 'post_tasks'
-sections.  If you ever want to flush all the handler commands immediately though,
-in 1.2 and later, you can::
-
-    tasks:
-       - shell: some tasks go here
-       - meta: flush_handlers
-       - shell: some other tasks
-
-In the above example any queued up handlers would be processed early when the 'meta'
-statement was reached.  This is a bit of a niche case but can come in handy from
-time to time.
-
-Executing A Playbook
-````````````````````
-
-Now that you've learned playbook syntax, how do you run a playbook?  It's simple.
-Let's run a playbook using a parallelism level of 10::
-
-    ansible-playbook playbook.yml -f 10
-
-Tips and Tricks
-```````````````
-
-Look at the bottom of the playbook execution for a summary of the nodes that were targeted
-and how they performed.   General failures and fatal "unreachable" communication attempts are
-kept separate in the counts.
-
-If you ever want to see detailed output from successful modules as well as unsuccessful ones,
-use the '--verbose' flag.  This is available in Ansible 0.5 and later.
-
-Ansible playbook output is vastly upgraded if the cowsay
-package is installed.  Try it!
-
-To see what hosts would be affected by a playbook before you run it, you
-can do this::
-
-    ansible-playbook playbook.yml --list-hosts.
-
-.. seealso::
-
-   :doc:`YAMLSyntax`
-       Learn about YAML syntax
-   :doc:`bestpractices`
-       Various tips about managing playbooks in the real world
-   :doc:`modules`
-       Learn about available modules
-   :doc:`moduledev`
-       Learn how to extend Ansible by writing your own modules
-   :doc:`patterns`
-       Learn about how to select hosts
-   `Github examples directory <https://github.com/ansible/ansible/tree/devel/examples/playbooks>`_
-       Complete playbook files from the github project source
-   `Mailing List <http://groups.google.com/group/ansible-project>`_
-       Questions? Help? Ideas?  Stop by the list on Google Groups
-
-
-
 Playbooks
 =========
 
diff --git a/docsite/latest/rst/playbooks_async.rst b/docsite/latest/rst/playbooks_async.rst
new file mode 100644
index 0000000000..31d4c7f8ad
--- /dev/null
+++ b/docsite/latest/rst/playbooks_async.rst
@@ -0,0 +1,54 @@
+
+
+Asynchronous Actions and Polling
+================================
+
+By default tasks in playbooks block, meaning the connections stay open
+until the task is done on each node.  This may not always be desirable, or you may
+be running operations that take longer than the SSH timeout.
+
+The easiest way to do this is
+to kick them off all at once and then poll until they are done.
+
+You will also want to use asynchronous mode on very long running
+operations that might be subject to timeout.
+
+To launch a task asynchronously, specify its maximum runtime
+and how frequently you would like to poll for status.  The default
+poll value is 10 seconds if you do not specify a value for `poll`::
+
+    ---
+    - hosts: all
+      remote_user: root
+      tasks:
+      - name: simulate long running op (15 sec), wait for up to 45, poll every 5
+        command: /bin/sleep 15
+        async: 45
+        poll: 5
+
+.. note::
+   There is no default for the async time limit.  If you leave off the
+   'async' keyword, the task runs synchronously, which is Ansible's
+   default.
+
+Alternatively, if you do not need to wait on the task to complete, you may
+"fire and forget" by specifying a poll value of 0::
+
+    ---
+    - hosts: all
+      remote_user: root
+      tasks:
+      - name: simulate long running op, allow to run for 45, fire and forget
+        command: /bin/sleep 15
+        async: 45
+        poll: 0
+
+.. note::
+   You shouldn't "fire and forget" with operations that require
+   exclusive locks, such as yum transactions, if you expect to run other
+   commands later in the playbook against those same resources.
+
+.. note::
+   Using a higher value for ``--forks`` will result in kicking off asynchronous
+   tasks even faster.  This also increases the efficiency of polling.
+
diff --git a/docsite/latest/rst/playbooks_conditionals.rst b/docsite/latest/rst/playbooks_conditionals.rst
new file mode 100644
index 0000000000..7a51e5b429
--- /dev/null
+++ b/docsite/latest/rst/playbooks_conditionals.rst
@@ -0,0 +1,260 @@
+Conditionals
+============
+
+Often the result of a play may depend on the value of a variable, fact (something learned about the remote system), 
+or previous task result.  In some cases, the values of variables may depend on other variables.  
+Further, additional groups can be created to manage hosts based on
+whether the hosts match other criteria.   There are many options to control execution flow in Ansible.
+
+Let's dig into what they are.
+
+.. contents::
+   :depth: 2
+
+The When Statement
+``````````````````
+
+Sometimes you will want to skip a particular step on a particular host.  This could be something
+as simple as not installing a certain package if the operating system is a particular version,
+or it could be something like performing some cleanup steps if a filesystem is getting full.
+
+This is easy to do in Ansible, with the `when` clause, which contains a Jinja2 expression (see `playbooks_variables`).
+It's actually pretty simple:
+
+    tasks:
+      - name: "shutdown Debian flavored systems"
+        command: /sbin/shutdown -t now
+        when: ansible_os_family == "Debian"
+
+A number of Jinja2 "filters" can also be used in when statements, some of which are unique
+and provided by Ansible.  Suppose we want to ignore the error of one statement and then
+decide to do something conditionally based on success or failure::
+
+    tasks:
+      - command: /bin/false
+        register: result
+        ignore_errors: True
+      - command: /bin/something
+        when: result|failed
+      - command: /bin/something_else
+        when: result|success
+      - command: /bin/still/something_else
+        when: result|skipped
+
+Note that was a little bit of foreshadowing on the 'register' statement.  We'll get to it a bit later in this chapter.
+
+As a reminder, to see what facts are available on a particular system, you can do::
+
+    ansible hostname.example.com -m setup
+
+Tip: Sometimes you'll get back a variable that's a string and you'll want to do a math operation comparison on it.  You can do this like so::
+
+    tasks:
+      - shell: echo "only on Red Hat 6, derivatives, and later"
+        when: ansible_os_family == "RedHat" and ansible_lsb.major_release|int >= 6
+
+.. note:: the above example requires the lsb_release package on the target host in order to return the ansible_lsb.major_release fact.
+
+Variables defined in the playbooks or inventory can also be used.  An example may be the execution of a task based on a variable's boolean value::
+
+    vars:
+      epic: true
+
+Then a conditional execution might look like::
+
+    tasks:
+        - shell: echo "This certainly is epic!"
+          when: epic
+
+or::
+ 
+    tasks:
+        - shell: echo "This certainly isn't epic!"
+          when: not epic
+
+If a required variable has not been set, you can skip or fail using Jinja2's
+`defined` test. For example::
+
+    tasks:
+        - shell: echo "I've got '{{ foo }}' and am not afraid to use it!"
+          when: foo is defined
+
+        - fail: msg="Bailing out: this play requires 'bar'"
+          when: bar is not defined
+
+This is especially useful in combination with the conditional import of vars
+files (see below).
+
+.. note :: When combining `when` with `with_items`, be aware that the `when` statement is processed separately for each item.
+    This is by design::
+
+    tasks:
+        - command: echo {{ item }}
+          with_items: [ 0, 2, 4, 6, 8, 10 ]
+          when: item > 5
+
+Loading in Custom Facts
+```````````````````````
+
+It's also easy to provide your own facts if you want, which is covered in :doc:`moduledev`.  To run them, just
+make a call to your own custom fact gathering module at the top of your list of tasks, and variables returned
+there will be accessible to future tasks::
+
+    tasks:
+        - name: gather site specific fact data
+          action: site_facts
+        - command: /usr/bin/thingy
+          when: "{{ my_custom_fact_just_retrieved_from_the_remote_system }} == '1234'"
+                   
+The Register Keyword
+````````````````````
+
+The 'register' keyword saves the result of a command in a variable.  Use "-v" on the playbook command line to see
+what kind of values are available, but there are many. 
+
+One useful trick with *when* is to key off the result of a last command.  As an example::
+
+    tasks:
+        - template: src=/templates/foo.j2 dest=/etc/foo.conf
+          register: last_result
+        - command: echo 'the file has changed'
+          when: last_result.changed
+
+{{ last_result }} is a variable set by the register directive. This assumes Ansible 0.8 and later.
+
+Applying 'when' to roles and includes
+`````````````````````````````````````
+
+Note that if you have several tasks that all share the same conditional statement, you can affix the conditional
+to a task include statement as below.  Note this does not work with playbook includes, just task includes.  All the tasks
+get evaluated, but the conditional is applied to each and every task::
+
+    - include: tasks/sometasks.yml
+      when: "'reticulating splines' in output"
+
+Or with a role::
+
+    - hosts: webservers
+      roles:
+         - { role: debian_stock_config, when: ansible_os_family == 'Debian' }
+
+You will note a lot of 'skipped' output by default in Ansible when using this approach on systems that don't match the criteria.
+Read up on the 'group_by' module in the `modules` docs for a more streamlined way to accomplish the same thing.
+
+Conditional Imports
+```````````````````
+
+.. note:: This is an advanced topic that is infrequently used.  You can probably skip this section.
+
+Sometimes you will want to do certain things differently in a playbook based on certain criteria.
+Having one playbook that works on multiple platforms and OS versions is a good example.
+
+As an example, the name of the Apache package may be different between CentOS and Debian,
+but it is easily handled with a minimum of syntax in an Ansible Playbook::
+
+    ---
+    - hosts: all
+      remote_user: root
+      vars_files:
+        - "vars/common.yml"
+        - [ "vars/{{ ansible_os_family }}.yml", "vars/os_defaults.yml" ]
+      tasks:
+      - name: make sure apache is running
+        service: name={{ apache }} state=running
+
+.. note::
+   The variable 'ansible_os_family' is being interpolated into
+   the list of filenames being defined for vars_files.
+
+As a reminder, the various YAML files contain just keys and values::
+
+    ---
+    # for vars/CentOS.yml
+    apache: httpd
+    somethingelse: 42
+
+How does this work?  If the operating system was 'CentOS', the first file Ansible would try to import
+would be 'vars/CentOS.yml', followed by '/vars/os_defaults.yml' if that file
+did not exist.   If no files in the list were found, an error would be raised.
+On Debian, it would instead first look towards 'vars/Debian.yml' instead of 'vars/CentOS.yml', before
+falling back on 'vars/os_defaults.yml'. Pretty simple.
+
+To use this conditional import feature, you'll need facter or ohai installed prior to running the playbook, but
+you can of course push this out with Ansible if you like::
+
+    # for facter
+    ansible -m yum -a "pkg=facter ensure=installed"
+    ansible -m yum -a "pkg=ruby-json ensure=installed"
+
+    # for ohai
+    ansible -m yum -a "pkg=ohai ensure=installed"
+
+Ansible's approach to configuration -- separating variables from tasks, keeps your playbooks
+from turning into arbitrary code with ugly nested ifs, conditionals, and so on - and results
+in more streamlined & auditable configuration rules -- especially because there are a
+minimum of decision points to track.
+
+Selecting Files And Templates Based On Variables
+````````````````````````````````````````````````
+
+.. note:: This is an advanced topic that is infrequently used.  You can probably skip this section.
+
+Sometimes a configuration file you want to copy, or a template you will use may depend on a variable.
+The following construct selects the first available file appropriate for the variables of a given host, which is often much cleaner than putting a lot of if conditionals in a template.
+
+The following example shows how to template out a configuration file that was very different between, say, CentOS and Debian::
+
+    - name: template a file
+      template: src={{ item }} dest=/etc/myapp/foo.conf
+      with_first_found:
+        files: 
+           - {{ ansible_distribution }}.conf
+           - default.conf
+        paths:
+           - search_location_one/somedir/
+           - /opt/other_location/somedir/
+
+Register Variables
+``````````````````
+
+.. versionadded:: 0.7
+
+Often in a playbook it may be useful to store the result of a given command in a variable and access
+it later.  Use of the command module in this way can in many ways eliminate the need to write site specific facts, for
+instance, you could test for the existence of a particular program.
+
+The 'register' keyword decides what variable to save a result in.  The resulting variables can be used in templates, action lines, or *when* statements.  It looks like this (in an obviously trivial example)::
+
+    - name: test play
+      hosts: all
+
+      tasks:
+
+          - shell: cat /etc/motd
+            register: motd_contents
+
+          - shell: echo "motd contains the word hi"
+            when: motd_contents.stdout.find('hi') != -1
+
+As shown previously, the registered variable's string contents are accessible with the 'stdout' value.
+The registered result can be used in the "with_items" of a task if it is converted into
+a list (or already is a list) as shown below.  "stdout_lines" is already available on the object as
+well though you could also call "home_dirs.stdout.split()" if you wanted, and could split by other
+fields::
+
+    - name: registered variable usage as a with_items list
+      hosts: all
+
+      tasks:
+
+          - name: retrieve the list of home directories
+            command: ls /home
+            register: home_dirs
+
+          - name: add home dirs to the backup spooler
+            file: path=/mnt/bkspool/{{ item }} src=/home/{{ item }} state=link
+            with_items: home_dirs.stdout_lines
+            # same as with_items: home_dirs.stdout.split()
+
+
+
diff --git a/docsite/latest/rst/playbooks_strategies.rst b/docsite/latest/rst/playbooks_strategies.rst
deleted file mode 100644
index 8d3777bdbd..0000000000
--- a/docsite/latest/rst/playbooks_strategies.rst
+++ /dev/null
@@ -1,1330 +0,0 @@
-Advanced Playbooks
-==================
-
-Here are some advanced features of the playbooks language.  Using all of these features
-is not necessary, but many of them will prove useful.  If a feature doesn't seem immediately
-relevant, feel free to skip it.  For many people, the features documented in `playbooks` will
-be 90% or more of what they use in Ansible.
-
-.. contents::
-   :depth: 2
-
-Tags
-````
-
-.. versionadded:: 0.6
-
-If you have a large playbook it may become useful to be able to run a
-specific part of the configuration.  Both plays and tasks support a
-"tags:" attribute for this reason.
-
-Example::
-
-    tasks:
-
-        - yum: name={{ item }} state=installed
-          with_items:
-             - httpd
-             - memcached
-          tags:
-             - packages
-
-        - template: src=templates/src.j2 dest=/etc/foo.conf
-          tags:
-             - configuration
-
-If you wanted to just run the "configuration" and "packages" part of a very long playbook, you could do this::
-
-    ansible-playbook example.yml --tags "configuration,packages"
-
-Playbooks Including Playbooks
-`````````````````````````````
-
-.. versionadded:: 0.6
-
-To further advance the concept of include files, playbook files can
-include other playbook files.  Suppose you define the behavior of all
-your webservers in "webservers.yml" and all your database servers in
-"dbservers.yml".  You can create a "site.yml" that would reconfigure
-all of your systems like this::
-
-    ---
-    - include: playbooks/webservers.yml
-    - include: playbooks/dbservers.yml
-
-This concept works great with tags to rapidly select exactly what plays you want to run, and exactly
-what parts of those plays.
-
-Ignoring Failed Commands
-````````````````````````
-
-.. versionadded:: 0.6
-
-Generally playbooks will stop executing any more steps on a host that
-has a failure.  Sometimes, though, you want to continue on.  To do so,
-write a task that looks like this::
-
-    - name: this will not be counted as a failure
-      command: /bin/false
-      ignore_errors: yes
-
-Overriding Changed Result
-`````````````````````````
-
-.. versionadded:: 1.3
-
-When a shell/command or other module runs it will typically report
-"changed" status based on whether it thinks it affected machine state.
-
-Sometimes you will know, based on the return code
-or output that it did not make any changes, and wish to override
-the "changed" result such that it does not appear in report output or
-does not cause handlers to fire::
-
-    tasks:
-
-      - shell: /usr/bin/billybass --mode="take me to the river"
-        register: bass_result
-        changed_when: "bass_result.rc != 2"
-
-      # this will never report 'changed' status
-      - shell: wall 'beep'
-
-Accessing Complex Variable Data
-```````````````````````````````
-
-Some provided facts, like networking information, are made available as nested data structures.  To access
-them a simple {{ foo }} is not sufficient, but it is still easy to do.   Here's how we get an IP address::
-
-    {{ ansible_eth0["ipv4"]["address"] }}
-
-Similarly, this is how we access the first element of an array::
-
-    {{ foo[0] }}
-
-Magic Variables, and How To Access Information About Other Hosts
-````````````````````````````````````````````````````````````````
-
-Even if you didn't define them yourself, Ansible provides a few variables for you automatically.
-The most important of these are 'hostvars', 'group_names', and 'groups'.  Users should not use
-these names themselves as they are reserved.  'environment' is also reserved.
-
-Hostvars lets you ask about the variables of another host, including facts that have been gathered
-about that host.  If, at this point, you haven't talked to that host yet in any play in the playbook
-or set of playbooks, you can get at the variables, but you will not be able to see the facts.
-
-If your database server wants to use the value of a 'fact' from another node, or an inventory variable
-assigned to another node, it's easy to do so within a template or even an action line::
-
-    {{ hostvars['test.example.com']['ansible_distribution'] }}
-
-Additionally, *group_names* is a list (array) of all the groups the current host is in.  This can be used in templates using Jinja2 syntax to make template source files that vary based on the group membership (or role) of the host::
-
-   {% if 'webserver' in group_names %}
-      # some part of a configuration file that only applies to webservers
-   {% endif %}
-
-*groups* is a list of all the groups (and hosts) in the inventory.  This can be used to enumerate all hosts within a group.
-For example::
-
-   {% for host in groups['app_servers'] %}
-      # something that applies to all app servers.
-   {% endfor %}
-
-A frequently used idiom is walking a group to find all IP addresses in that group::
-
-   {% for host in groups['app_servers'] %}
-      {{ hostvars[host]['ansible_eth0']['ipv4']['address'] }}
-   {% endfor %}
-
-An example of this could include pointing a frontend proxy server to all of the app servers, setting up the correct firewall rules between servers, etc.
-
-Just a few other 'magic' variables are available...  There aren't many.
-
-Additionally, *inventory_hostname* is the name of the hostname as configured in Ansible's inventory host file.  This can
-be useful for when you don't want to rely on the discovered hostname `ansible_hostname` or for other mysterious
-reasons.  If you have a long FQDN, *inventory_hostname_short* also contains the part up to the first
-period, without the rest of the domain.
-
-Don't worry about any of this unless you think you need it.  You'll know when you do.
-
-Also available, *inventory_dir* is the pathname of the directory holding Ansible's inventory host file, *inventory_file* is the pathname and the filename pointing to the Ansible's inventory host file.
-
-Variable File Separation
-````````````````````````
-
-It's a great idea to keep your playbooks under source control, but
-you may wish to make the playbook source public while keeping certain
-important variables private.  Similarly, sometimes you may just
-want to keep certain information in different files, away from
-the main playbook.
-
-You can do this by using an external variables file, or files, just like this::
-
-    ---
-    - hosts: all
-      remote_user: root
-      vars:
-        favcolor: blue
-      vars_files:
-        - /vars/external_vars.yml
-      tasks:
-      - name: this is just a placeholder
-        command: /bin/echo foo
-
-This removes the risk of sharing sensitive data with others when
-sharing your playbook source with them.
-
-The contents of each variables file is a simple YAML dictionary, like this::
-
-    ---
-    # in the above example, this would be vars/external_vars.yml
-    somevar: somevalue
-    password: magic
-
-.. note::
-   It's also possible to keep per-host and per-group variables in very
-   similar files, this is covered in :ref:`patterns`.
-
-Prompting For Sensitive Data
-````````````````````````````
-
-You may wish to prompt the user for certain input, and can
-do so with the similarly named 'vars_prompt' section.  This has uses
-beyond security, for instance, you may use the same playbook for all
-software releases and would prompt for a particular release version
-in a push-script::
-
-    ---
-    - hosts: all
-      remote_user: root
-      vars:
-        from: "camelot"
-      vars_prompt:
-        name: "what is your name?"
-        quest: "what is your quest?"
-        favcolor: "what is your favorite color?"
-
-There are full examples of both of these items in the github examples/playbooks directory.
-
-If you have a variable that changes infrequently, it might make sense to
-provide a default value that can be overridden.  This can be accomplished using
-the default argument::
-
-   vars_prompt:
-     - name: "release_version"
-       prompt: "Product release version"
-       default: "1.0"
-
-An alternative form of vars_prompt allows for hiding input from the user, and may later support
-some other options, but otherwise works equivalently::
-
-   vars_prompt:
-     - name: "some_password"
-       prompt: "Enter password"
-       private: yes
-     - name: "release_version"
-       prompt: "Product release version"
-       private: no
-
-If `Passlib <http://pythonhosted.org/passlib/>`_ is installed, vars_prompt can also crypt the
-entered value so you can use it, for instance, with the user module to define a password::
-
-   vars_prompt:
-     - name: "my_password2"
-       prompt: "Enter password2"
-       private: yes
-       encrypt: "md5_crypt"
-       confirm: yes
-       salt_size: 7
-
-You can use any crypt scheme supported by 'Passlib':
-
-- *des_crypt* - DES Crypt
-- *bsdi_crypt* - BSDi Crypt
-- *bigcrypt* - BigCrypt
-- *crypt16* - Crypt16
-- *md5_crypt* - MD5 Crypt
-- *bcrypt* - BCrypt
-- *sha1_crypt* - SHA-1 Crypt
-- *sun_md5_crypt* - Sun MD5 Crypt
-- *sha256_crypt* - SHA-256 Crypt
-- *sha512_crypt* - SHA-512 Crypt
-- *apr_md5_crypt* - Apache’s MD5-Crypt variant
-- *phpass* - PHPass’ Portable Hash
-- *pbkdf2_digest* - Generic PBKDF2 Hashes
-- *cta_pbkdf2_sha1* - Cryptacular’s PBKDF2 hash
-- *dlitz_pbkdf2_sha1* - Dwayne Litzenberger’s PBKDF2 hash
-- *scram* - SCRAM Hash
-- *bsd_nthash* - FreeBSD’s MCF-compatible nthash encoding
-
-However, the only parameters accepted are 'salt' or 'salt_size'. You can use you own salt using
-'salt', or have one generated automatically using 'salt_size'. If nothing is specified, a salt
-of size 8 will be generated.
-
-Passing Variables On The Command Line
-`````````````````````````````````````
-
-In addition to `vars_prompt` and `vars_files`, it is possible to send variables over
-the Ansible command line.  This is particularly useful when writing a generic release playbook
-where you may want to pass in the version of the application to deploy::
-
-    ansible-playbook release.yml --extra-vars "version=1.23.45 other_variable=foo"
-
-This is useful, for, among other things, setting the hosts group or the user for the playbook.
-
-Example::
-
-    ---
-    - remote_user: '{{ user }}'
-      hosts: '{{ hosts }}'
-      tasks:
-         - ...
-
-    ansible-playbook release.yml --extra-vars "hosts=vipers user=starbuck"
-
-As of Ansible 1.2, you can also pass in extra vars as quoted JSON, like so::
-
-    --extra-vars '{"pacman":"mrs","ghosts":["inky","pinky","clyde","sue"]}'
-
-The key=value form is obviously simpler, but it's there if you need it!
-
-As of Ansible 1.3, extra vars can be loaded from a JSON file with the "@" syntax::
-
-    --extra-vars "@some_file.json"
-
-Also as of Ansible 1.3, extra vars can be formatted as YAML, either on the command line
-or in a file as above.
-
-Conditional Execution
-`````````````````````
-
-(Note: this section covers 1.2 conditionals, if you are using a previous version, select
-the previous version of the documentation, `Ansible 1.1 Docs <http://www.ansibleworks.com/docs/released/1.1/>`_ .
-Those conditional forms continue to be operational in 1.2, although the new mechanisms are cleaner.)
-
-Sometimes you will want to skip a particular step on a particular host.  This could be something
-as simple as not installing a certain package if the operating system is a particular version,
-or it could be something like performing some cleanup steps if a filesystem is getting full.
-
-This is easy to do in Ansible, with the `when` clause, which contains a Jinja2 expression (see chapter
-`Playbooks <http://www.ansibleworks.com/docs/playbooks.html#vars-section>`_ for more info).
-Don't panic -- it's actually pretty simple::
-
-    tasks:
-      - name: "shutdown Debian flavored systems"
-        command: /sbin/shutdown -t now
-        when: ansible_os_family == "Debian"
-
-A number of Jinja2 "filters" can also be used in when statements, some of which are unique
-and provided by Ansible.  Suppose we want to ignore the error of one statement and then
-decide to do something conditionally based on success or failure::
-
-    tasks:
-      - command: /bin/false
-        register: result
-        ignore_errors: True
-      - command: /bin/something
-        when: result|failed
-      - command: /bin/something_else
-        when: result|success
-      - command: /bin/still/something_else
-        when: result|skipped
-
-
-As a reminder, to see what derived variables are available, you can do::
-
-    ansible hostname.example.com -m setup
-
-Tip: Sometimes you'll get back a variable that's a string and you'll want to do a comparison on it.  You can do this like so::
-
-    tasks:
-      - shell: echo "only on Red Hat 6, derivatives, and later"
-        when: ansible_os_family == "RedHat" and ansible_lsb.major_release|int >= 6
-
-Note the above example requires the lsb_release package on the target host in order to return the ansible_lsb.major_release fact.
-
-Variables defined in the playbooks or inventory can also be used.
-
-An example may be the execution of a task based on a variable's boolean value::
-
-    vars:
-      epic: true
-
-Then a conditional execution with action on the boolean value of epic being True::
-
-    tasks:
-        - shell: echo "This certainly is epic!"
-          when: epic
-
-With a boolean value of False::
- 
-    tasks:
-        - shell: echo "This certainly isn't epic!"
-          when: not epic
-
-If a required variable has not been set, you can skip or fail using Jinja2's
-`defined` test. For example::
-
-    tasks:
-        - shell: echo "I've got '{{ foo }}' and am not afraid to use it!"
-          when: foo is defined
-
-        - fail: msg="Bailing out: this play requires 'bar'"
-          when: bar is not defined
-
-This is especially useful in combination with the conditional import of vars
-files (see below).
-
-It's also easy to provide your own facts if you want, which is covered in :doc:`moduledev`.  To run them, just
-make a call to your own custom fact gathering module at the top of your list of tasks, and variables returned
-there will be accessible to future tasks::
-
-    tasks:
-        - name: gather site specific fact data
-          action: site_facts
-        - command: echo {{ my_custom_fact_can_be_used_now }}
-
-One useful trick with *when* is to key off the changed result of a last command.  As an example::
-
-    tasks:
-        - template: src=/templates/foo.j2 dest=/etc/foo.conf
-          register: last_result
-        - command: echo 'the file has changed'
-          when: last_result.changed
-
-{{ last_result }} is a variable set by the register directive. This assumes Ansible 0.8 and later.
-
-When combining `when` with `with_items`, be aware that the `when` statement is processed separately for each item.
-This is by design::
-
-    tasks:
-        - command: echo {{ item }}
-          with_items: [ 0, 2, 4, 6, 8, 10 ]
-          when: item > 5
-
-Note that if you have several tasks that all share the same conditional statement, you can affix the conditional
-to a task include statement as below.  Note this does not work with playbook includes, just task includes.  All the tasks
-get evaluated, but the conditional is applied to each and every task::
-
-    - include: tasks/sometasks.yml
-      when: "'reticulating splines' in output"
-
-Conditional Imports
-```````````````````
-
-Sometimes you will want to do certain things differently in a playbook based on certain criteria.
-Having one playbook that works on multiple platforms and OS versions is a good example.
-
-As an example, the name of the Apache package may be different between CentOS and Debian,
-but it is easily handled with a minimum of syntax in an Ansible Playbook::
-
-    ---
-    - hosts: all
-      remote_user: root
-      vars_files:
-        - "vars/common.yml"
-        - [ "vars/{{ ansible_os_family }}.yml", "vars/os_defaults.yml" ]
-      tasks:
-      - name: make sure apache is running
-        service: name={{ apache }} state=running
-
-.. note::
-   The variable 'ansible_os_family' is being interpolated into
-   the list of filenames being defined for vars_files.
-
-As a reminder, the various YAML files contain just keys and values::
-
-    ---
-    # for vars/CentOS.yml
-    apache: httpd
-    somethingelse: 42
-
-How does this work?  If the operating system was 'CentOS', the first file Ansible would try to import
-would be 'vars/CentOS.yml', followed by '/vars/os_defaults.yml' if that file
-did not exist.   If no files in the list were found, an error would be raised.
-On Debian, it would instead first look towards 'vars/Debian.yml' instead of 'vars/CentOS.yml', before
-falling back on 'vars/os_defaults.yml'. Pretty simple.
-
-To use this conditional import feature, you'll need facter or ohai installed prior to running the playbook, but
-you can of course push this out with Ansible if you like::
-
-    # for facter
-    ansible -m yum -a "pkg=facter ensure=installed"
-    ansible -m yum -a "pkg=ruby-json ensure=installed"
-
-    # for ohai
-    ansible -m yum -a "pkg=ohai ensure=installed"
-
-Ansible's approach to configuration -- separating variables from tasks, keeps your playbooks
-from turning into arbitrary code with ugly nested ifs, conditionals, and so on - and results
-in more streamlined & auditable configuration rules -- especially because there are a
-minimum of decision points to track.
-
-Do-Until
-````````
-
-Sometimes you would want to retry a task till a certain condition is met, In such conditions the Do/Until feature will help.
-Here's an example which show's the syntax to be applied for the task.::
-   
-    - action: shell /usr/bin/foo
-      register: result
-      until: register.stdout.find("all systems go") != -1
-      retries: 5
-      delay: 10
-
-The above example run the shell module recursively till the module's result has "all systems go" in it's stdout or the task has 
-been retried for 5 times with a delay of 10 seconds. The default value for "retries" is 3 and "delay" is 5.
-
-The task returns the results returned by the last task run. The results of individual retries can be viewed by -vv option.
-The results will have a new key "attempts" which will have the number of the retries for the task.
-
-.. Note::
-
-    The Do/Until does not take decision on whether to fail or pass the play when the maximum retries are completed, the user can
-    can do that in the next task as follows.
-   
-Example::
-    
-   - action: shell /usr/bin/foo
-     register: result
-     until: register.stdout.find("all systems go") != -1
-     retries: 5
-     delay: 10
-     failed_when: result.attempts == 5
-
-
-Loops
-`````
-
-To save some typing, repeated tasks can be written in short-hand like so::
-
-    - name: add several users
-      user: name={{ item }} state=present groups=wheel
-      with_items:
-         - testuser1
-         - testuser2
-
-If you have defined a YAML list in a variables file, or the 'vars' section, you can also do::
-
-    with_items: somelist
-
-The above would be the equivalent of::
-
-    - name: add user testuser1
-      user: name=testuser1 state=present groups=wheel
-    - name: add user testuser2
-      user: name=testuser2 state=present groups=wheel
-
-The yum and apt modules use with_items to execute fewer package manager transactions.
-
-Note that the types of items you iterate over with 'with_items' do not have to be simple lists of strings.
-If you have a list of hashes, you can reference subkeys using things like::
-
-    - name: add several users
-      user: name={{ item.name }} state=present groups={{ item.groups }}
-      with_items:
-        - { name: 'testuser1', groups: 'wheel' }
-        - { name: 'testuser2', groups: 'root' }
-
-Nested Loops
-````````````
-
-Loops can be nested as well::
-
-    - name: give users access to multiple databases
-      mysql_user: name={{ item[0] }} priv={{ item[1] }}.*:ALL password=foo
-      with_nested:
-        - [ 'alice', 'bob', 'eve' ]
-        - [ 'clientdb', 'employeedb', 'providerdb' ]
-
-As with the case of 'with_items' above, you can use previously defined variables. Just specify the variable's name without templating it with '{{ }}'::
-
-    - name: here, 'users' contains the above list of employees
-      mysql_user: name={{ item[0] }} priv={{ item[1] }}.*:ALL password=foo
-      with_nested:
-        - users
-        - [ 'clientdb', 'employeedb', 'providerdb' ]
-
-Lookup Plugins - Accessing Outside Data
-```````````````````````````````````````
-
-.. versionadded:: 0.8
-
-Various *lookup plugins* allow additional ways to iterate over data.  Ansible will have more of these
-over time.  You can write your own, as is covered in the API section.  Each typically takes a list and
-can accept more than one parameter.
-
-``with_fileglob`` matches all files in a single directory, non-recursively, that match a pattern.  It can
-be used like this::
-
-    ---
-    - hosts: all
-
-      tasks:
-
-        # first ensure our target directory exists
-        - file: dest=/etc/fooapp state=directory
-
-        # copy each file over that matches the given pattern
-        - copy: src={{ item }} dest=/etc/fooapp/ owner=root mode=600
-          with_fileglob:
-            - /playbooks/files/fooapp/*
-
-``with_file`` loads data in from a file directly::
-
-        - authorized_key: user=foo key={{ item }}
-          with_file:
-             - /home/foo/.ssh/id_rsa.pub
-
-.. note::
-
-   When using ``with_fileglob`` or ``with_file`` with :ref:`roles`, if you
-   specify a relative path (e.g., :file:`./foo`), Ansible resolves the path
-   relative to the :file:`roles/<rolename>/files` directory.
-
-.. versionadded:: 0.9
-
-Many new lookup abilities were added in 0.9.  Remember, lookup plugins are run on the *controlling* machine::
-
-    ---
-    - hosts: all
-
-      tasks:
-
-         - debug: msg="{{ lookup('env','HOME') }} is an environment variable"
-
-         - debug: msg="{{ item }} is a line from the result of this command"
-           with_lines:
-             - cat /etc/motd
-
-         - debug: msg="{{ lookup('pipe','date') }} is the raw result of running this command"
-
-         - debug: msg="{{ lookup('redis_kv', 'redis://localhost:6379,somekey') }} is value in Redis for somekey"
-
-         - debug: msg="{{ lookup('dnstxt', 'example.com') }} is a DNS TXT record for example.com"
-
-         - debug: msg="{{ lookup('template', './some_template.j2') }} is a value from evaluation of this template"
-
-As an alternative you can also assign lookup plugins to variables or use them
-elsewhere.  This macros are evaluated each time they are used in a task (or
-template)::
-
-    vars:
-      motd_value: "{{ lookup('file', '/etc/motd') }}"
-
-    tasks:
-      - debug: msg="motd value is {{ motd_value }}"
-
-.. versionadded:: 1.0
-
-``with_sequence`` generates a sequence of items in ascending numerical order. You
-can specify a start, end, and an optional step value.
-
-Arguments should be specified in key=value pairs.  If supplied, the 'format' is a printf style string.
-
-Numerical values can be specified in decimal, hexadecimal (0x3f8) or octal (0600).
-Negative numbers are not supported.  This works as follows::
-
-    ---
-    - hosts: all
-
-      tasks:
-
-        # create groups
-        - group: name=evens state=present
-        - group: name=odds state=present
-
-        # create some test users
-        - user: name={{ item }} state=present groups=evens
-          with_sequence: start=0 end=32 format=testuser%02x
-
-        # create a series of directories with even numbers for some reason
-        - file: dest=/var/stuff/{{ item }} state=directory
-          with_sequence: start=4 end=16 stride=2
-
-        # a simpler way to use the sequence plugin
-        # create 4 groups
-        - group: name=group{{ item }} state=present
-          with_sequence: count=4
-
-.. versionadded:: 1.1
-
-``with_password`` and associated lookup macro generate a random plaintext password and store it in
-a file at a given filepath.  Support for crypted save modes (as with vars_prompt) is pending.  If the
-file exists previously, it will retrieve its contents, behaving just like with_file. Usage of variables like "{{ inventory_hostname }}" in the filepath can be used to set
-up random passwords per host (what simplifies password management in 'host_vars' variables).
-
-Generated passwords contain a random mix of upper and lowercase ASCII letters, the
-numbers 0-9 and punctuation (". , : - _"). The default length of a generated password is 30 characters.
-This length can be changed by passing an extra parameter::
-
-    ---
-    - hosts: all
-
-      tasks:
-
-        # create a mysql user with a random password:
-        - mysql_user: name={{ client }}
-                      password="{{ lookup('password', 'credentials/' + client + '/' + tier + '/' + role + '/mysqlpassword length=15') }}"
-                      priv={{ client }}_{{ tier }}_{{ role }}.*:ALL
-
-        (...)
-
-        # dump a mysql database with a given password (this example showing the other form).
-        - mysql_db: name={{ client }}_{{ tier }}_{{ role }}
-                    login_user={{ client }}
-                    login_password={{ item }}
-                    state=dump
-                    target=/tmp/{{ client }}_{{ tier }}_{{ role }}_backup.sql
-          with_password: credentials/{{ client }}/{{ tier }}/{{ role }}/mysqlpassword length=15
-
-        (...)
-
-        # create a user with a given password
-        - user: name=guestuser
-                state=present
-                uid=5000
-                password={{ item }}
-          with_password: credentials/{{ hostname }}/userpassword encrypt=sha256_crypt
-
-Setting the Environment (and Working With Proxies)
-``````````````````````````````````````````````````
-
-.. versionadded:: 1.1
-
-It is quite possible that you may need to get package updates through a proxy, or even get some package
-updates through a proxy and access other packages not through a proxy.  Ansible makes it easy for you
-to configure your environment by using the 'environment' keyword.  Here is an example::
-
-    - hosts: all
-      remote_user: root
-
-      tasks:
-
-        - apt: name=cobbler state=installed
-          environment:
-            http_proxy: http://proxy.example.com:8080
-
-The environment can also be stored in a variable, and accessed like so::
-
-    - hosts: all
-      remote_user: root
-
-      # here we make a variable named "env" that is a dictionary
-      vars:
-        proxy_env:
-          http_proxy: http://proxy.example.com:8080
-
-      tasks:
-
-        - apt: name=cobbler state=installed
-          environment: "{{ proxy_env }}"
-
-While just proxy settings were shown above, any number of settings can be supplied.  The most logical place
-to define an environment hash might be a group_vars file, like so::
-
-    ---
-    # file: group_vars/boston
-
-    ntp_server: ntp.bos.example.com
-    backup: bak.bos.example.com
-    proxy_env:
-      http_proxy: http://proxy.bos.example.com:8080
-      https_proxy: http://proxy.bos.example.com:8080
-
-Getting values from files
-`````````````````````````
-
-.. versionadded:: 0.8
-
-Sometimes you'll want to include the content of a file directly into a playbook.  You can do so using a macro.
-This syntax will remain in future versions, though we will also will provide ways to do this via lookup plugins (see "More Loops") as well.  What follows
-is an example using the authorized_key module, which requires the actual text of the SSH key as a parameter::
-
-    tasks:
-        - name: enable key-based ssh access for users
-          authorized_key: user={{ item }} key="{{ lookup('file', '/keys/' + item ) }}"
-          with_items:
-             - pinky
-             - brain
-             - snowball
-
-Selecting Files And Templates Based On Variables
-````````````````````````````````````````````````
-
-Sometimes a configuration file you want to copy, or a template you will use may depend on a variable.
-The following construct selects the first available file appropriate for the variables of a given host, which is often much cleaner than putting a lot of if conditionals in a template.
-
-The following example shows how to template out a configuration file that was very different between, say, CentOS and Debian::
-
-    - name: template a file
-      template: src={{ item }} dest=/etc/myapp/foo.conf
-      first_available_file:
-        - /srv/templates/myapp/{{ ansible_distribution }}.conf
-        - /srv/templates/myapp/default.conf
-
-first_available_file is only available to the copy and template modules.
-
-Asynchronous Actions and Polling
-````````````````````````````````
-
-By default tasks in playbooks block, meaning the connections stay open
-until the task is done on each node.  If executing playbooks with
-a small parallelism value (aka ``--forks``), you may wish that long
-running operations can go faster.  The easiest way to do this is
-to kick them off all at once and then poll until they are done.
-
-You will also want to use asynchronous mode on very long running
-operations that might be subject to timeout.
-
-To launch a task asynchronously, specify its maximum runtime
-and how frequently you would like to poll for status.  The default
-poll value is 10 seconds if you do not specify a value for `poll`::
-
-    ---
-    - hosts: all
-      remote_user: root
-      tasks:
-      - name: simulate long running op (15 sec), wait for up to 45, poll every 5
-        command: /bin/sleep 15
-        async: 45
-        poll: 5
-
-.. note::
-   There is no default for the async time limit.  If you leave off the
-   'async' keyword, the task runs synchronously, which is Ansible's
-   default.
-
-Alternatively, if you do not need to wait on the task to complete, you may
-"fire and forget" by specifying a poll value of 0::
-
-    ---
-    - hosts: all
-      remote_user: root
-      tasks:
-      - name: simulate long running op, allow to run for 45, fire and forget
-        command: /bin/sleep 15
-        async: 45
-        poll: 0
-
-.. note::
-   You shouldn't "fire and forget" with operations that require
-   exclusive locks, such as yum transactions, if you expect to run other
-   commands later in the playbook against those same resources.
-
-.. note::
-   Using a higher value for ``--forks`` will result in kicking off asynchronous
-   tasks even faster.  This also increases the efficiency of polling.
-
-Local Playbooks
-```````````````
-
-It may be useful to use a playbook locally, rather than by connecting over SSH.  This can be useful
-for assuring the configuration of a system by putting a playbook on a crontab.  This may also be used
-to run a playbook inside a OS installer, such as an Anaconda kickstart.
-
-To run an entire playbook locally, just set the "hosts:" line to "hosts:127.0.0.1" and then run the playbook like so::
-
-    ansible-playbook playbook.yml --connection=local
-
-Alternatively, a local connection can be used in a single playbook play, even if other plays in the playbook
-use the default remote connection type::
-
-    hosts: 127.0.0.1
-    connection: local
-
-Turning Off Facts
-`````````````````
-
-If you know you don't need any fact data about your hosts, and know everything about your systems centrally, you
-can turn off fact gathering.  This has advantages in scaling Ansible in push mode with very large numbers of
-systems, mainly, or if you are using Ansible on experimental platforms.   In any play, just do this::
-
-    - hosts: whatever
-      gather_facts: no
-
-Pull-Mode Playbooks
-```````````````````
-
-The use of playbooks in local mode (above) is made extremely powerful with the addition of `ansible-pull`.
-A script for setting up ansible-pull is provided in the examples/playbooks directory of the source
-checkout.
-
-The basic idea is to use Ansible to set up a remote copy of Ansible on each managed node, each set to run via
-cron and update playbook source via git.  This inverts the default push architecture of Ansible into a pull
-architecture, which has near-limitless scaling potential.  The setup playbook can be tuned to change
-the cron frequency, logging locations, and parameters to ansible-pull.
-
-This is useful both for extreme scale-out as well as periodic remediation.  Usage of the 'fetch' module to retrieve
-logs from ansible-pull runs would be an excellent way to gather and analyze remote logs from ansible-pull.
-
-Register Variables
-``````````````````
-
-.. versionadded:: 0.7
-
-Often in a playbook it may be useful to store the result of a given command in a variable and access
-it later.  Use of the command module in this way can in many ways eliminate the need to write site specific facts, for
-instance, you could test for the existence of a particular program.
-
-The 'register' keyword decides what variable to save a result in.  The resulting variables can be used in templates, action lines, or *when* statements.  It looks like this (in an obviously trivial example)::
-
-    - name: test play
-      hosts: all
-
-      tasks:
-
-          - shell: cat /etc/motd
-            register: motd_contents
-
-          - shell: echo "motd contains the word hi"
-            when: motd_contents.stdout.find('hi') != -1
-
-As shown previously, the registered variable's string contents are accessible with the 'stdout' value.
-The registered result can be used in the "with_items" of a task if it is converted into
-a list (or already is a list) as shown below.  "stdout_lines" is already available on the object as
-well though you could also call "home_dirs.stdout.split()" if you wanted, and could split by other
-fields::
-
-    - name: registered variable usage as a with_items list
-      hosts: all
-
-      tasks:
-
-          - name: retrieve the list of home directories
-            command: ls /home
-            register: home_dirs
-
-          - name: add home dirs to the backup spooler
-            file: path=/mnt/bkspool/{{ item }} src=/home/{{ item }} state=link
-            with_items: home_dirs.stdout_lines
-            # with_items: home_dirs.stdout.split()
-
-Rolling Updates
-```````````````
-
-.. versionadded:: 0.7
-
-By default, Ansible will try to manage all of the machines referenced in a play in parallel.  For a rolling updates
-use case, you can define how many hosts Ansible should manage at a single time by using the ''serial'' keyword::
-
-
-    - name: test play
-      hosts: webservers
-      serial: 3
-
-In the above example, if we had 100 hosts, 3 hosts in the group 'webservers'
-would complete the play completely before moving on to the next 3 hosts.
-
-Maximum Failure Percentage
-``````````````````````````
-
-.. versionadded:: 1.3
-
-By default, Ansible will continue executing actions as long as there are hosts in the group that have not yet failed.
-In some situations, such as with the rolling updates described above, it may be desireable to abort the play when a 
-certain threshold of failures have been reached. To acheive this, as of version 1.3 you can set a maximum failure 
-percentage on a play as follows::
-
-    - hosts: webservers
-      max_fail_percentage: 30
-      serial: 10
-
-In the above example, if more than 3 of the 10 servers in the group were to fail, the rest of the play would be aborted.
-
-.. note::
-
-     The percentage set must be exceeded, not equaled. For example, if serial were set to 4 and you wanted the task to abort 
-     when 2 of the systems failed, the percentage should be set at 49 rather than 50.
-
-Delegation
-``````````
-
-.. versionadded:: 0.7
-
-If you want to perform a task on one host with reference to other hosts, use the 'delegate_to' keyword on a task.
-This is ideal for placing nodes in a load balanced pool, or removing them.  It is also very useful for controlling
-outage windows.  Using this with the 'serial' keyword to control the number of hosts executing at one time is also
-a good idea::
-
-    ---
-    - hosts: webservers
-      serial: 5
-
-      tasks:
-      - name: take out of load balancer pool
-        command: /usr/bin/take_out_of_pool {{ inventory_hostname }}
-        delegate_to: 127.0.0.1
-
-      - name: actual steps would go here
-        yum: name=acme-web-stack state=latest
-
-      - name: add back to load balancer pool
-        command: /usr/bin/add_back_to_pool {{ inventory_hostname }}
-        delegate_to: 127.0.0.1
-
-
-These commands will run on 127.0.0.1, which is the machine running Ansible. There is also a shorthand syntax that
-you can use on a per-task basis: 'local_action'. Here is the same playbook as above, but using the shorthand
-syntax for delegating to 127.0.0.1::
-
-    ---
-    # ...
-      tasks:
-      - name: take out of load balancer pool
-        local_action: command /usr/bin/take_out_of_pool {{ inventory_hostname }}
-
-    # ...
-
-      - name: add back to load balancer pool
-        local_action: command /usr/bin/add_back_to_pool {{ inventory_hostname }}
-
-A common pattern is to use a local action to call 'rsync' to recursively copy files to the managed servers.
-Here is an example::
-
-    ---
-    # ...
-      tasks:
-      - name: recursively copy files from management server to target
-        local_action: command rsync -a /path/to/files {{ inventory_hostname }}:/path/to/target/
-
-Note that you must have passphrase-less SSH keys or an ssh-agent configured for this to work, otherwise rsync
-will need to ask for a passphrase.
-
-Accelerated Mode
-````````````````
-
-.. versionadded:: 1.3
-
-While SSH using the ControlPersist feature is quite fast and scalable, there is a certain amount of overhead involved in
-creating connections. This can become something of a bottleneck when the number of hosts grows into the hundreds or 
-thousands. To help overcome this, Ansible offers an accelerated connection option. Accelerated mode can be anywhere from 
-2-6x faster than SSH with ControlPersist enabled, and 10x faster than paramiko.
-
-Accelerated mode works by launching a temporary daemon over SSH. Once the daemon is running, Ansible will connect directly
-to it via a raw socket connection. Ansible secures this communication by using a temporary AES key that is uploaded during
-the SSH connection (this key is different for every host, and is also regenerated every time the daemon is started). By default,
-Ansible will use port 5099 for the accelerated connection, though this is configurable. Once running, the daemon will accept
-connections for 30 minutes, after which time it will terminate itself and need to be restarted over SSH.
-
-Accelerated mode offers several improvments over the original fireball mode:
-
-* No bootstrapping is required, only a single line needs to be added to each play you wish to run in accelerated mode.
-* Support for sudo commands (see below for more details and caveats).
-* Fewer requirements! ZeroMQ is no longer required, nor are there any special packages beyond python-keyczar.
-
-In order to use accelerated mode, simply add `accelerate: true` to your play::
-
-    ---
-    - hosts: all
-      accelerate: true
-      tasks:
-      - name: some task
-        command: echo {{ item }}
-        with_items:
-        - foo
-        - bar
-        - baz
-
-If you wish to change the port Ansible will use for the accelerated connection, just add the `accelerated_port` option::
-
-    ---
-    - hosts: all
-      accelerate: true
-      # default port is 5099
-      accelerate_port: 10000
-
-The `accelerate_port` option can also be specified in the environment variable ACCELERATE_PORT, or in your `ansible.cfg` configuration::
-
-    [accelerate]
-    accelerate_port = 5099
-
-As noted above, accelerated mode also supports running tasks via sudo, however there are two important caveats:
-
-* You must remove requiretty from your sudoers options.
-* Prompting for the sudo password is not yet supported, so the NOPASSWD option is required for commands.
-
-
-
-Fireball Mode
-`````````````
-
-.. versionadded:: 0.8 (deprecated as of 1.3)
-
-.. note::
-
-    The following section has been deprecated as of Ansible 1.3 in favor of the accelerated mode described above. This
-    documentation is here for users who may still be using the original fireball connection method only, and should not
-    be used for any new deployments.
-
-Ansible's core connection types of 'local', 'paramiko', and 'ssh' are augmented in version 0.8 and later by a new extra-fast
-connection type called 'fireball'.  It can only be used with playbooks and does require some additional setup
-outside the lines of Ansible's normal "no bootstrapping" philosophy.  You are not required to use fireball mode
-to use Ansible, though some users may appreciate it.
-
-Fireball mode works by launching a temporary 0mq daemon from SSH that by default lives for only 30 minutes before
-shutting off.  Fireball mode, once running, uses temporary AES keys to encrypt a session, and requires direct
-communication to given nodes on the configured port.  The default is 5099.  The fireball daemon runs as any user you
-set it down as.  So it can run as you, root, or so on.  If multiple users are running Ansible as the same batch of hosts,
-take care to use unique ports.
-
-Fireball mode is roughly 10 times faster than paramiko for communicating with nodes and may be a good option
-if you have a large number of hosts::
-
-    ---
-
-    # set up the fireball transport
-    - hosts: all
-      gather_facts: no
-      connection: ssh # or paramiko
-      sudo: yes
-      tasks:
-          - action: fireball
-
-    # these operations will occur over the fireball transport
-    - hosts: all
-      connection: fireball
-      tasks:
-          - shell: echo "Hello {{ item }}"
-            with_items:
-                - one
-                - two
-
-In order to use fireball mode, certain dependencies must be installed on both ends.   You can use this playbook as a basis for initial bootstrapping on
-any platform.  You will also need gcc and zeromq-devel installed from your package manager, which you can of course also get Ansible to install::
-
-    ---
-    - hosts: all
-      sudo: yes
-      gather_facts: no
-      connection: ssh
-      tasks:
-          - easy_install: name=pip
-          - pip: name={{ item }} state=present
-            with_items:
-              - pyzmq
-              - pyasn1
-              - PyCrypto
-              - python-keyczar
-
-Fedora and EPEL also have Ansible RPM subpackages available for fireball-dependencies.
-
-Also see the module documentation section.
-
-
-Understanding Variable Precedence
-`````````````````````````````````
-
-You have already learned about inventory variables, 'vars', and 'vars_files'.  In the
-event the same variable name occurs in more than one place, what happens?  There are really three tiers
-of precedence, and within those tiers, some minor ordering rules that you probably won't even need to remember.
-We'll explain them anyway though.
-
-Variables that are set during the execution of the play have highest priority. This includes registered
-variables and facts, which are discovered pieces of information about remote hosts.
-
-Descending in priority are variables defined in the playbook.  'vars_files' as defined in the playbook are next up,
-followed by variables as passed to ansible-playbook via --extra-vars (-e), then variables defined in the 'vars' section.  These
-should all be taken to be basically the same thing -- good places to define constants about what the play does to all hosts
-in the play.
-
-Finally, inventory variables have the least priority.  Variables about hosts override those about groups.
-If a variable is defined in multiple groups and one group is a child of the other, the child group variable
-will override the variable set in the parent.
-
-This makes the 'group_vars/all' file the best place to define a default value you wish to override in another
-group, or even in a playbook.  For example, your organization might set a default ntp server in group_vars/all
-and then override it based on a group based on a geographic region.  However if you type 'ntpserver: asdf.example.com'
-in a vars section of a playbook, you know from reading the playbook that THAT specific value is definitely the one
-that is going to be used.  You won't be fooled by some variable from inventory sneaking up on you.
-
-So, in short, if you want something easy to remember: facts beat playbook definitions, and
-playbook definitions beat inventory variables.
-
-There's a little bit more if you are using roles -- roles fit in the "playbook definitions" category of scale.  They are
-trumped by facts, and still trump inventory variables.  However, there's a bit of extra magic.
-
-Variables passed as parameters to the role are accesible only within that role (and dependencies of that role).  You can
-almost think of them like programming functions or macros.
-
-Variables loaded via the 'vars/' directory of a role are made available to all roles and tasks, which in older versions of Ansible
-could be confusing in the case of a reused variable name.  In Ansible 1.3 and later, however, vars/ directories are guaranteed to be scoped to the current role, just like roles parameters.  They are still available globally though, so if you want to set a variable like "ntp_server" in a common role, other roles can still make use of it.  Thus they are just like "vars_files" construct that they emulate, but they have a bit more of a "Do What I Mean" semantic to them.  They are smarter.
-
-If there are role dependencies involved, dependent roles can set variables visible to the roles that require them, but
-the requiring role is allowed to override those variables.  For instance if a role "myapp" requires "apache", and
-the value of "apache_port" in "apache" is 80, "myapp" could choose to set it to 8080.  Thus you may think of this somewhat
-like an inheritance system if you're a developer -- though it's not exactly -- and we don't require folks to think in programming terms to know how things work.
-
-If you want, you can choose to prefix variable names with the name of your role and be extra sure of where
-data sources are coming from, but this is optional.  However it can be a nice thing to do in your templates as you immediately
-know where the variable was defined.
-
-Ultimately, the variable system may seem complex -- but it's really not.  It's mostly a "Do What I Mean" kind of system, though knowing the details may help you if you get stuck or are trying to do something advanced.  Feel free to experiment!
-
-Check Mode ("Dry Run") --check
-```````````````````````````````
-
-.. versionadded:: 1.1
-
-When ansible-playbook is executed with --check it will not make any changes on remote systems.  Instead, any module
-instrumented to support 'check mode' (which contains the primary core modules, but it is not required that all modules do
-this) will report what changes they would have made.  Other modules that do not support check mode will also take no
-action, but just will not report what changes they might have made.
-
-Check mode is just a simulation, and if you have steps that use conditionals that depend on the results of prior commands,
-it may be less useful for you.  However it is great for one-node-at-time basic configuration management use cases.
-
-Example::
-
-    ansible-playbook foo.yml --check
-
-Running a task in check mode
-````````````````````````````
-
-.. versionadded:: 1.3
-
-Sometimes you may want to have a task to be executed even in check
-mode. To achieve this, use the `always_run` clause on the task. Its
-value is a Jinja2 expression, just like the `when` clause. In simple
-cases a boolean YAML value would be sufficient as a value.
-
-Example::
-
-    tasks:
-
-      - name: this task is run even in check mode
-        command: /something/to/run --even-in-check-mode
-        always_run: yes
-
-As a reminder, a task with a `when` clause evaluated to false, will
-still be skipped even if it has a `always_run` clause evaluated to
-true.
-
-
-Showing Differences with --diff
-```````````````````````````````
-
-.. versionadded:: 1.1
-
-The --diff option to ansible-playbook works great with --check (detailed above) but can also be used by itself.  When this flag is supplied, if any templated files on the remote system are changed, and the ansible-playbook CLI will report back
-the textual changes made to the file (or, if used with --check, the changes that would have been made).  Since the diff
-feature produces a large amount of output, it is best used when checking a single host at a time, like so::
-
-    ansible-playbook foo.yml --check --diff --limit foo.example.com
-
-Dictionary & Nested (Complex) Arguments
-```````````````````````````````````````
-
-As a review, most tasks in Ansible are of this form::
-
-    tasks:
-
-      - name: ensure the cobbler package is installed
-        yum: name=cobbler state=installed
-
-However, in some cases, it may be useful to feed arguments directly in from a hash (dictionary).  In fact, a very small
-number of modules (the CloudFormations module is one) actually require complex arguments.  They work like this::
-
-    tasks:
-
-      - name: call a module that requires some complex arguments
-        foo_module:
-           fibonacci_list:
-             - 1
-             - 1
-             - 2
-             - 3
-           my_pets:
-             dogs:
-               - fido
-               - woof
-             fish:
-               - limpet
-               - nemo
-               - "{{ other_fish_name }}"
-
-You can of course use variables inside these, as noted above.
-
-If using local_action, you can do this::
-
-    - name: call a module that requires some complex arguments
-      local_action:
-        module: foo_module
-        arg1: 1234
-        arg2: 'asdf'
-
-Which of course means that, though more verbose, this is also legal syntax::
-
-    - name: foo
-      template: { src: '/templates/motd.j2', dest: '/etc/motd' }
-
-Local Facts (Facts.d)
-`````````````````````
-
-.. versionadded:: 1.3
-
-As discussed in the playbooks chapter, Ansible facts are a way of getting data about remote systems for use in playbook variables.
-Usually these are discovered automatically by the 'setup' module in Ansible. Users can also write custom facts modules, as described
-in the API guide.  However, what if you want to have a simple way to provide system or user 
-provided data for use in Ansible variables, without writing a fact module?  For instance, what if you want users to be able to control some aspect about how their systems are managed? "Facts.d" is one such mechanism.
-
-If a remotely managed system has an "/etc/ansible/facts.d" directory, any files in this directory
-ending in ".fact", can be JSON, INI, or executable files returning JSON, and these can supply local facts in Ansible.
-
-For instance assume a /etc/ansible/facts.d/preferences.fact::
-
-    [general]
-    asdf=1
-    bar=2
-
-This will produce a hash variable fact named "general" with 'asdf' and 'bar' as members.
-To validate this, run the following::
-
-    ansible <hostname> -m setup -a "filter=ansible_local"
-
-And you will see the following fact added::
-
-    "ansible_local": {
-            "preferences": {
-                "general": {
-                    "asdf" : "1", 
-                    "bar"  : "2"
-                }
-            }
-     }
-
-And this data can be accessed in a template/playbook as::
-
-     {{ ansible_local.preferences.general.asdf }}
-
-The local namespace prevents any user supplied fact from overriding system facts
-or variables defined elsewhere in the playbook.
-
-Style Points
-````````````
-
-Ansible playbooks are colorized.  If you do not like this, set the ANSIBLE_NOCOLOR=1 environment variable.
-
-Ansible playbooks also look more impressive with cowsay installed, and we encourage installing this package.
-
-.. seealso::
-
-   :doc:`YAMLSyntax`
-       Learn about YAML syntax
-   :doc:`playbooks`
-       Review the basic playbook features
-   :doc:`bestpractices`
-       Various tips about playbooks in the real world
-   :doc:`modules`
-       Learn about available modules
-   :doc:`moduledev`
-       Learn how to extend Ansible by writing your own modules
-   :doc:`patterns`
-       Learn about how to select hosts
-   `Github examples directory <https://github.com/ansible/ansible/tree/devel/examples/playbooks>`_
-       Complete playbook files from the github project source
-   `Mailing List <http://groups.google.com/group/ansible-project>`_
-       Questions? Help? Ideas?  Stop by the list on Google Groups
-
-
diff --git a/docsite/latest/rst/playbooks_tags.rst b/docsite/latest/rst/playbooks_tags.rst
index b516b3f7d0..40bf292c12 100644
--- a/docsite/latest/rst/playbooks_tags.rst
+++ b/docsite/latest/rst/playbooks_tags.rst
@@ -1,19 +1,5 @@
-Conditionals
-============
-
-Often the result of a play may depend on the value of a variable, fact, or previous task result.  In some cases,
-the values of variables may depend on other variables.  Further, additional groups can be created to manage hosts based on
-whether the hosts match other criteria.   There are many options to control execution flow in Ansible.
-
-Let's dig into what they are.
-
-.. contents::
-   :depth: 2
-
 Tags
-````
-
-.. versionadded:: 0.6
+====
 
 If you have a large playbook it may become useful to be able to run a
 specific part of the configuration.  Both plays and tasks support a
@@ -38,1294 +24,15 @@ If you wanted to just run the "configuration" and "packages" part of a very long
 
     ansible-playbook example.yml --tags "configuration,packages"
 
-Playbooks Including Playbooks
-`````````````````````````````
-
-.. versionadded:: 0.6
-
-To further advance the concept of include files, playbook files can
-include other playbook files.  Suppose you define the behavior of all
-your webservers in "webservers.yml" and all your database servers in
-"dbservers.yml".  You can create a "site.yml" that would reconfigure
-all of your systems like this::
-
-    ---
-    - include: playbooks/webservers.yml
-    - include: playbooks/dbservers.yml
-
-This concept works great with tags to rapidly select exactly what plays you want to run, and exactly
-what parts of those plays.
-
-Ignoring Failed Commands
-````````````````````````
-
-.. versionadded:: 0.6
-
-Generally playbooks will stop executing any more steps on a host that
-has a failure.  Sometimes, though, you want to continue on.  To do so,
-write a task that looks like this::
-
-    - name: this will not be counted as a failure
-      command: /bin/false
-      ignore_errors: yes
-
-Overriding Changed Result
-`````````````````````````
-
-.. versionadded:: 1.3
-
-When a shell/command or other module runs it will typically report
-"changed" status based on whether it thinks it affected machine state.
-
-Sometimes you will know, based on the return code
-or output that it did not make any changes, and wish to override
-the "changed" result such that it does not appear in report output or
-does not cause handlers to fire::
-
-    tasks:
-
-      - shell: /usr/bin/billybass --mode="take me to the river"
-        register: bass_result
-        changed_when: "bass_result.rc != 2"
-
-      # this will never report 'changed' status
-      - shell: wall 'beep'
-
-Accessing Complex Variable Data
-```````````````````````````````
-
-Some provided facts, like networking information, are made available as nested data structures.  To access
-them a simple {{ foo }} is not sufficient, but it is still easy to do.   Here's how we get an IP address::
-
-    {{ ansible_eth0["ipv4"]["address"] }}
-
-Similarly, this is how we access the first element of an array::
-
-    {{ foo[0] }}
-
-Magic Variables, and How To Access Information About Other Hosts
-````````````````````````````````````````````````````````````````
-
-Even if you didn't define them yourself, Ansible provides a few variables for you automatically.
-The most important of these are 'hostvars', 'group_names', and 'groups'.  Users should not use
-these names themselves as they are reserved.  'environment' is also reserved.
-
-Hostvars lets you ask about the variables of another host, including facts that have been gathered
-about that host.  If, at this point, you haven't talked to that host yet in any play in the playbook
-or set of playbooks, you can get at the variables, but you will not be able to see the facts.
-
-If your database server wants to use the value of a 'fact' from another node, or an inventory variable
-assigned to another node, it's easy to do so within a template or even an action line::
-
-    {{ hostvars['test.example.com']['ansible_distribution'] }}
-
-Additionally, *group_names* is a list (array) of all the groups the current host is in.  This can be used in templates using Jinja2 syntax to make template source files that vary based on the group membership (or role) of the host::
-
-   {% if 'webserver' in group_names %}
-      # some part of a configuration file that only applies to webservers
-   {% endif %}
-
-*groups* is a list of all the groups (and hosts) in the inventory.  This can be used to enumerate all hosts within a group.
-For example::
-
-   {% for host in groups['app_servers'] %}
-      # something that applies to all app servers.
-   {% endfor %}
-
-A frequently used idiom is walking a group to find all IP addresses in that group::
-
-   {% for host in groups['app_servers'] %}
-      {{ hostvars[host]['ansible_eth0']['ipv4']['address'] }}
-   {% endfor %}
-
-An example of this could include pointing a frontend proxy server to all of the app servers, setting up the correct firewall rules between servers, etc.
-
-Just a few other 'magic' variables are available...  There aren't many.
-
-Additionally, *inventory_hostname* is the name of the hostname as configured in Ansible's inventory host file.  This can
-be useful for when you don't want to rely on the discovered hostname `ansible_hostname` or for other mysterious
-reasons.  If you have a long FQDN, *inventory_hostname_short* also contains the part up to the first
-period, without the rest of the domain.
-
-Don't worry about any of this unless you think you need it.  You'll know when you do.
-
-Also available, *inventory_dir* is the pathname of the directory holding Ansible's inventory host file, *inventory_file* is the pathname and the filename pointing to the Ansible's inventory host file.
-
-Variable File Separation
-````````````````````````
-
-It's a great idea to keep your playbooks under source control, but
-you may wish to make the playbook source public while keeping certain
-important variables private.  Similarly, sometimes you may just
-want to keep certain information in different files, away from
-the main playbook.
-
-You can do this by using an external variables file, or files, just like this::
-
-    ---
-    - hosts: all
-      remote_user: root
-      vars:
-        favcolor: blue
-      vars_files:
-        - /vars/external_vars.yml
-      tasks:
-      - name: this is just a placeholder
-        command: /bin/echo foo
-
-This removes the risk of sharing sensitive data with others when
-sharing your playbook source with them.
-
-The contents of each variables file is a simple YAML dictionary, like this::
-
-    ---
-    # in the above example, this would be vars/external_vars.yml
-    somevar: somevalue
-    password: magic
-
-.. note::
-   It's also possible to keep per-host and per-group variables in very
-   similar files, this is covered in :ref:`patterns`.
-
-Prompting For Sensitive Data
-````````````````````````````
-
-You may wish to prompt the user for certain input, and can
-do so with the similarly named 'vars_prompt' section.  This has uses
-beyond security, for instance, you may use the same playbook for all
-software releases and would prompt for a particular release version
-in a push-script::
-
-    ---
-    - hosts: all
-      remote_user: root
-      vars:
-        from: "camelot"
-      vars_prompt:
-        name: "what is your name?"
-        quest: "what is your quest?"
-        favcolor: "what is your favorite color?"
-
-There are full examples of both of these items in the github examples/playbooks directory.
-
-If you have a variable that changes infrequently, it might make sense to
-provide a default value that can be overridden.  This can be accomplished using
-the default argument::
-
-   vars_prompt:
-     - name: "release_version"
-       prompt: "Product release version"
-       default: "1.0"
-
-An alternative form of vars_prompt allows for hiding input from the user, and may later support
-some other options, but otherwise works equivalently::
-
-   vars_prompt:
-     - name: "some_password"
-       prompt: "Enter password"
-       private: yes
-     - name: "release_version"
-       prompt: "Product release version"
-       private: no
-
-If `Passlib <http://pythonhosted.org/passlib/>`_ is installed, vars_prompt can also crypt the
-entered value so you can use it, for instance, with the user module to define a password::
-
-   vars_prompt:
-     - name: "my_password2"
-       prompt: "Enter password2"
-       private: yes
-       encrypt: "md5_crypt"
-       confirm: yes
-       salt_size: 7
-
-You can use any crypt scheme supported by 'Passlib':
-
-- *des_crypt* - DES Crypt
-- *bsdi_crypt* - BSDi Crypt
-- *bigcrypt* - BigCrypt
-- *crypt16* - Crypt16
-- *md5_crypt* - MD5 Crypt
-- *bcrypt* - BCrypt
-- *sha1_crypt* - SHA-1 Crypt
-- *sun_md5_crypt* - Sun MD5 Crypt
-- *sha256_crypt* - SHA-256 Crypt
-- *sha512_crypt* - SHA-512 Crypt
-- *apr_md5_crypt* - Apache’s MD5-Crypt variant
-- *phpass* - PHPass’ Portable Hash
-- *pbkdf2_digest* - Generic PBKDF2 Hashes
-- *cta_pbkdf2_sha1* - Cryptacular’s PBKDF2 hash
-- *dlitz_pbkdf2_sha1* - Dwayne Litzenberger’s PBKDF2 hash
-- *scram* - SCRAM Hash
-- *bsd_nthash* - FreeBSD’s MCF-compatible nthash encoding
-
-However, the only parameters accepted are 'salt' or 'salt_size'. You can use you own salt using
-'salt', or have one generated automatically using 'salt_size'. If nothing is specified, a salt
-of size 8 will be generated.
-
-Passing Variables On The Command Line
-`````````````````````````````````````
-
-In addition to `vars_prompt` and `vars_files`, it is possible to send variables over
-the Ansible command line.  This is particularly useful when writing a generic release playbook
-where you may want to pass in the version of the application to deploy::
-
-    ansible-playbook release.yml --extra-vars "version=1.23.45 other_variable=foo"
-
-This is useful, for, among other things, setting the hosts group or the user for the playbook.
-
-Example::
-
-    ---
-    - remote_user: '{{ user }}'
-      hosts: '{{ hosts }}'
-      tasks:
-         - ...
-
-    ansible-playbook release.yml --extra-vars "hosts=vipers user=starbuck"
-
-As of Ansible 1.2, you can also pass in extra vars as quoted JSON, like so::
-
-    --extra-vars '{"pacman":"mrs","ghosts":["inky","pinky","clyde","sue"]}'
-
-The key=value form is obviously simpler, but it's there if you need it!
-
-As of Ansible 1.3, extra vars can be loaded from a JSON file with the "@" syntax::
-
-    --extra-vars "@some_file.json"
-
-Also as of Ansible 1.3, extra vars can be formatted as YAML, either on the command line
-or in a file as above.
-
-Conditional Execution
-`````````````````````
-
-(Note: this section covers 1.2 conditionals, if you are using a previous version, select
-the previous version of the documentation, `Ansible 1.1 Docs <http://www.ansibleworks.com/docs/released/1.1/>`_ .
-Those conditional forms continue to be operational in 1.2, although the new mechanisms are cleaner.)
-
-Sometimes you will want to skip a particular step on a particular host.  This could be something
-as simple as not installing a certain package if the operating system is a particular version,
-or it could be something like performing some cleanup steps if a filesystem is getting full.
-
-This is easy to do in Ansible, with the `when` clause, which contains a Jinja2 expression (see chapter
-`Playbooks <http://www.ansibleworks.com/docs/playbooks.html#vars-section>`_ for more info).
-Don't panic -- it's actually pretty simple::
-
-    tasks:
-      - name: "shutdown Debian flavored systems"
-        command: /sbin/shutdown -t now
-        when: ansible_os_family == "Debian"
-
-A number of Jinja2 "filters" can also be used in when statements, some of which are unique
-and provided by Ansible.  Suppose we want to ignore the error of one statement and then
-decide to do something conditionally based on success or failure::
-
-    tasks:
-      - command: /bin/false
-        register: result
-        ignore_errors: True
-      - command: /bin/something
-        when: result|failed
-      - command: /bin/something_else
-        when: result|success
-      - command: /bin/still/something_else
-        when: result|skipped
-
-
-As a reminder, to see what derived variables are available, you can do::
-
-    ansible hostname.example.com -m setup
-
-Tip: Sometimes you'll get back a variable that's a string and you'll want to do a comparison on it.  You can do this like so::
-
-    tasks:
-      - shell: echo "only on Red Hat 6, derivatives, and later"
-        when: ansible_os_family == "RedHat" and ansible_lsb.major_release|int >= 6
-
-Note the above example requires the lsb_release package on the target host in order to return the ansible_lsb.major_release fact.
-
-Variables defined in the playbooks or inventory can also be used.
-
-An example may be the execution of a task based on a variable's boolean value::
-
-    vars:
-      epic: true
-
-Then a conditional execution with action on the boolean value of epic being True::
-
-    tasks:
-        - shell: echo "This certainly is epic!"
-          when: epic
-
-With a boolean value of False::
- 
-    tasks:
-        - shell: echo "This certainly isn't epic!"
-          when: not epic
-
-If a required variable has not been set, you can skip or fail using Jinja2's
-`defined` test. For example::
-
-    tasks:
-        - shell: echo "I've got '{{ foo }}' and am not afraid to use it!"
-          when: foo is defined
-
-        - fail: msg="Bailing out: this play requires 'bar'"
-          when: bar is not defined
-
-This is especially useful in combination with the conditional import of vars
-files (see below).
-
-It's also easy to provide your own facts if you want, which is covered in :doc:`moduledev`.  To run them, just
-make a call to your own custom fact gathering module at the top of your list of tasks, and variables returned
-there will be accessible to future tasks::
-
-    tasks:
-        - name: gather site specific fact data
-          action: site_facts
-        - command: echo {{ my_custom_fact_can_be_used_now }}
-
-One useful trick with *when* is to key off the changed result of a last command.  As an example::
-
-    tasks:
-        - template: src=/templates/foo.j2 dest=/etc/foo.conf
-          register: last_result
-        - command: echo 'the file has changed'
-          when: last_result.changed
-
-{{ last_result }} is a variable set by the register directive. This assumes Ansible 0.8 and later.
-
-When combining `when` with `with_items`, be aware that the `when` statement is processed separately for each item.
-This is by design::
-
-    tasks:
-        - command: echo {{ item }}
-          with_items: [ 0, 2, 4, 6, 8, 10 ]
-          when: item > 5
-
-Note that if you have several tasks that all share the same conditional statement, you can affix the conditional
-to a task include statement as below.  Note this does not work with playbook includes, just task includes.  All the tasks
-get evaluated, but the conditional is applied to each and every task::
-
-    - include: tasks/sometasks.yml
-      when: "'reticulating splines' in output"
-
-Conditional Imports
-```````````````````
-
-Sometimes you will want to do certain things differently in a playbook based on certain criteria.
-Having one playbook that works on multiple platforms and OS versions is a good example.
-
-As an example, the name of the Apache package may be different between CentOS and Debian,
-but it is easily handled with a minimum of syntax in an Ansible Playbook::
-
-    ---
-    - hosts: all
-      remote_user: root
-      vars_files:
-        - "vars/common.yml"
-        - [ "vars/{{ ansible_os_family }}.yml", "vars/os_defaults.yml" ]
-      tasks:
-      - name: make sure apache is running
-        service: name={{ apache }} state=running
-
-.. note::
-   The variable 'ansible_os_family' is being interpolated into
-   the list of filenames being defined for vars_files.
-
-As a reminder, the various YAML files contain just keys and values::
-
-    ---
-    # for vars/CentOS.yml
-    apache: httpd
-    somethingelse: 42
-
-How does this work?  If the operating system was 'CentOS', the first file Ansible would try to import
-would be 'vars/CentOS.yml', followed by '/vars/os_defaults.yml' if that file
-did not exist.   If no files in the list were found, an error would be raised.
-On Debian, it would instead first look towards 'vars/Debian.yml' instead of 'vars/CentOS.yml', before
-falling back on 'vars/os_defaults.yml'. Pretty simple.
-
-To use this conditional import feature, you'll need facter or ohai installed prior to running the playbook, but
-you can of course push this out with Ansible if you like::
-
-    # for facter
-    ansible -m yum -a "pkg=facter ensure=installed"
-    ansible -m yum -a "pkg=ruby-json ensure=installed"
-
-    # for ohai
-    ansible -m yum -a "pkg=ohai ensure=installed"
-
-Ansible's approach to configuration -- separating variables from tasks, keeps your playbooks
-from turning into arbitrary code with ugly nested ifs, conditionals, and so on - and results
-in more streamlined & auditable configuration rules -- especially because there are a
-minimum of decision points to track.
-
-Do-Until
-````````
-
-Sometimes you would want to retry a task till a certain condition is met, In such conditions the Do/Until feature will help.
-Here's an example which show's the syntax to be applied for the task.::
-   
-    - action: shell /usr/bin/foo
-      register: result
-      until: register.stdout.find("all systems go") != -1
-      retries: 5
-      delay: 10
-
-The above example run the shell module recursively till the module's result has "all systems go" in it's stdout or the task has 
-been retried for 5 times with a delay of 10 seconds. The default value for "retries" is 3 and "delay" is 5.
-
-The task returns the results returned by the last task run. The results of individual retries can be viewed by -vv option.
-The results will have a new key "attempts" which will have the number of the retries for the task.
-
-.. Note::
-
-    The Do/Until does not take decision on whether to fail or pass the play when the maximum retries are completed, the user can
-    can do that in the next task as follows.
-   
-Example::
-    
-   - action: shell /usr/bin/foo
-     register: result
-     until: register.stdout.find("all systems go") != -1
-     retries: 5
-     delay: 10
-     failed_when: result.attempts == 5
-
-
-Loops
-`````
-
-To save some typing, repeated tasks can be written in short-hand like so::
-
-    - name: add several users
-      user: name={{ item }} state=present groups=wheel
-      with_items:
-         - testuser1
-         - testuser2
-
-If you have defined a YAML list in a variables file, or the 'vars' section, you can also do::
-
-    with_items: somelist
-
-The above would be the equivalent of::
-
-    - name: add user testuser1
-      user: name=testuser1 state=present groups=wheel
-    - name: add user testuser2
-      user: name=testuser2 state=present groups=wheel
-
-The yum and apt modules use with_items to execute fewer package manager transactions.
-
-Note that the types of items you iterate over with 'with_items' do not have to be simple lists of strings.
-If you have a list of hashes, you can reference subkeys using things like::
-
-    - name: add several users
-      user: name={{ item.name }} state=present groups={{ item.groups }}
-      with_items:
-        - { name: 'testuser1', groups: 'wheel' }
-        - { name: 'testuser2', groups: 'root' }
-
-Nested Loops
-````````````
-
-Loops can be nested as well::
-
-    - name: give users access to multiple databases
-      mysql_user: name={{ item[0] }} priv={{ item[1] }}.*:ALL password=foo
-      with_nested:
-        - [ 'alice', 'bob', 'eve' ]
-        - [ 'clientdb', 'employeedb', 'providerdb' ]
-
-As with the case of 'with_items' above, you can use previously defined variables. Just specify the variable's name without templating it with '{{ }}'::
-
-    - name: here, 'users' contains the above list of employees
-      mysql_user: name={{ item[0] }} priv={{ item[1] }}.*:ALL password=foo
-      with_nested:
-        - users
-        - [ 'clientdb', 'employeedb', 'providerdb' ]
-
-Lookup Plugins - Accessing Outside Data
-```````````````````````````````````````
-
-.. versionadded:: 0.8
-
-Various *lookup plugins* allow additional ways to iterate over data.  Ansible will have more of these
-over time.  You can write your own, as is covered in the API section.  Each typically takes a list and
-can accept more than one parameter.
-
-``with_fileglob`` matches all files in a single directory, non-recursively, that match a pattern.  It can
-be used like this::
-
-    ---
-    - hosts: all
-
-      tasks:
-
-        # first ensure our target directory exists
-        - file: dest=/etc/fooapp state=directory
-
-        # copy each file over that matches the given pattern
-        - copy: src={{ item }} dest=/etc/fooapp/ owner=root mode=600
-          with_fileglob:
-            - /playbooks/files/fooapp/*
-
-``with_file`` loads data in from a file directly::
-
-        - authorized_key: user=foo key={{ item }}
-          with_file:
-             - /home/foo/.ssh/id_rsa.pub
-
-.. note::
-
-   When using ``with_fileglob`` or ``with_file`` with :ref:`roles`, if you
-   specify a relative path (e.g., :file:`./foo`), Ansible resolves the path
-   relative to the :file:`roles/<rolename>/files` directory.
-
-.. versionadded:: 0.9
-
-Many new lookup abilities were added in 0.9.  Remember, lookup plugins are run on the *controlling* machine::
-
-    ---
-    - hosts: all
-
-      tasks:
-
-         - debug: msg="{{ lookup('env','HOME') }} is an environment variable"
-
-         - debug: msg="{{ item }} is a line from the result of this command"
-           with_lines:
-             - cat /etc/motd
-
-         - debug: msg="{{ lookup('pipe','date') }} is the raw result of running this command"
-
-         - debug: msg="{{ lookup('redis_kv', 'redis://localhost:6379,somekey') }} is value in Redis for somekey"
-
-         - debug: msg="{{ lookup('dnstxt', 'example.com') }} is a DNS TXT record for example.com"
-
-         - debug: msg="{{ lookup('template', './some_template.j2') }} is a value from evaluation of this template"
-
-As an alternative you can also assign lookup plugins to variables or use them
-elsewhere.  This macros are evaluated each time they are used in a task (or
-template)::
-
-    vars:
-      motd_value: "{{ lookup('file', '/etc/motd') }}"
-
-    tasks:
-      - debug: msg="motd value is {{ motd_value }}"
-
-.. versionadded:: 1.0
-
-``with_sequence`` generates a sequence of items in ascending numerical order. You
-can specify a start, end, and an optional step value.
-
-Arguments should be specified in key=value pairs.  If supplied, the 'format' is a printf style string.
-
-Numerical values can be specified in decimal, hexadecimal (0x3f8) or octal (0600).
-Negative numbers are not supported.  This works as follows::
-
-    ---
-    - hosts: all
-
-      tasks:
-
-        # create groups
-        - group: name=evens state=present
-        - group: name=odds state=present
-
-        # create some test users
-        - user: name={{ item }} state=present groups=evens
-          with_sequence: start=0 end=32 format=testuser%02x
-
-        # create a series of directories with even numbers for some reason
-        - file: dest=/var/stuff/{{ item }} state=directory
-          with_sequence: start=4 end=16 stride=2
-
-        # a simpler way to use the sequence plugin
-        # create 4 groups
-        - group: name=group{{ item }} state=present
-          with_sequence: count=4
-
-.. versionadded:: 1.1
-
-``with_password`` and associated lookup macro generate a random plaintext password and store it in
-a file at a given filepath.  Support for crypted save modes (as with vars_prompt) is pending.  If the
-file exists previously, it will retrieve its contents, behaving just like with_file. Usage of variables like "{{ inventory_hostname }}" in the filepath can be used to set
-up random passwords per host (what simplifies password management in 'host_vars' variables).
-
-Generated passwords contain a random mix of upper and lowercase ASCII letters, the
-numbers 0-9 and punctuation (". , : - _"). The default length of a generated password is 30 characters.
-This length can be changed by passing an extra parameter::
-
-    ---
-    - hosts: all
-
-      tasks:
-
-        # create a mysql user with a random password:
-        - mysql_user: name={{ client }}
-                      password="{{ lookup('password', 'credentials/' + client + '/' + tier + '/' + role + '/mysqlpassword length=15') }}"
-                      priv={{ client }}_{{ tier }}_{{ role }}.*:ALL
-
-        (...)
-
-        # dump a mysql database with a given password (this example showing the other form).
-        - mysql_db: name={{ client }}_{{ tier }}_{{ role }}
-                    login_user={{ client }}
-                    login_password={{ item }}
-                    state=dump
-                    target=/tmp/{{ client }}_{{ tier }}_{{ role }}_backup.sql
-          with_password: credentials/{{ client }}/{{ tier }}/{{ role }}/mysqlpassword length=15
-
-        (...)
-
-        # create a user with a given password
-        - user: name=guestuser
-                state=present
-                uid=5000
-                password={{ item }}
-          with_password: credentials/{{ hostname }}/userpassword encrypt=sha256_crypt
-
-Setting the Environment (and Working With Proxies)
-``````````````````````````````````````````````````
-
-.. versionadded:: 1.1
-
-It is quite possible that you may need to get package updates through a proxy, or even get some package
-updates through a proxy and access other packages not through a proxy.  Ansible makes it easy for you
-to configure your environment by using the 'environment' keyword.  Here is an example::
-
-    - hosts: all
-      remote_user: root
-
-      tasks:
-
-        - apt: name=cobbler state=installed
-          environment:
-            http_proxy: http://proxy.example.com:8080
-
-The environment can also be stored in a variable, and accessed like so::
-
-    - hosts: all
-      remote_user: root
-
-      # here we make a variable named "env" that is a dictionary
-      vars:
-        proxy_env:
-          http_proxy: http://proxy.example.com:8080
-
-      tasks:
-
-        - apt: name=cobbler state=installed
-          environment: "{{ proxy_env }}"
-
-While just proxy settings were shown above, any number of settings can be supplied.  The most logical place
-to define an environment hash might be a group_vars file, like so::
-
-    ---
-    # file: group_vars/boston
-
-    ntp_server: ntp.bos.example.com
-    backup: bak.bos.example.com
-    proxy_env:
-      http_proxy: http://proxy.bos.example.com:8080
-      https_proxy: http://proxy.bos.example.com:8080
-
-Getting values from files
-`````````````````````````
-
-.. versionadded:: 0.8
-
-Sometimes you'll want to include the content of a file directly into a playbook.  You can do so using a macro.
-This syntax will remain in future versions, though we will also will provide ways to do this via lookup plugins (see "More Loops") as well.  What follows
-is an example using the authorized_key module, which requires the actual text of the SSH key as a parameter::
-
-    tasks:
-        - name: enable key-based ssh access for users
-          authorized_key: user={{ item }} key="{{ lookup('file', '/keys/' + item ) }}"
-          with_items:
-             - pinky
-             - brain
-             - snowball
-
-Selecting Files And Templates Based On Variables
-````````````````````````````````````````````````
-
-Sometimes a configuration file you want to copy, or a template you will use may depend on a variable.
-The following construct selects the first available file appropriate for the variables of a given host, which is often much cleaner than putting a lot of if conditionals in a template.
-
-The following example shows how to template out a configuration file that was very different between, say, CentOS and Debian::
-
-    - name: template a file
-      template: src={{ item }} dest=/etc/myapp/foo.conf
-      first_available_file:
-        - /srv/templates/myapp/{{ ansible_distribution }}.conf
-        - /srv/templates/myapp/default.conf
-
-first_available_file is only available to the copy and template modules.
-
-Asynchronous Actions and Polling
-````````````````````````````````
-
-By default tasks in playbooks block, meaning the connections stay open
-until the task is done on each node.  If executing playbooks with
-a small parallelism value (aka ``--forks``), you may wish that long
-running operations can go faster.  The easiest way to do this is
-to kick them off all at once and then poll until they are done.
-
-You will also want to use asynchronous mode on very long running
-operations that might be subject to timeout.
-
-To launch a task asynchronously, specify its maximum runtime
-and how frequently you would like to poll for status.  The default
-poll value is 10 seconds if you do not specify a value for `poll`::
-
-    ---
-    - hosts: all
-      remote_user: root
-      tasks:
-      - name: simulate long running op (15 sec), wait for up to 45, poll every 5
-        command: /bin/sleep 15
-        async: 45
-        poll: 5
-
-.. note::
-   There is no default for the async time limit.  If you leave off the
-   'async' keyword, the task runs synchronously, which is Ansible's
-   default.
-
-Alternatively, if you do not need to wait on the task to complete, you may
-"fire and forget" by specifying a poll value of 0::
-
-    ---
-    - hosts: all
-      remote_user: root
-      tasks:
-      - name: simulate long running op, allow to run for 45, fire and forget
-        command: /bin/sleep 15
-        async: 45
-        poll: 0
-
-.. note::
-   You shouldn't "fire and forget" with operations that require
-   exclusive locks, such as yum transactions, if you expect to run other
-   commands later in the playbook against those same resources.
-
-.. note::
-   Using a higher value for ``--forks`` will result in kicking off asynchronous
-   tasks even faster.  This also increases the efficiency of polling.
-
-Local Playbooks
-```````````````
-
-It may be useful to use a playbook locally, rather than by connecting over SSH.  This can be useful
-for assuring the configuration of a system by putting a playbook on a crontab.  This may also be used
-to run a playbook inside a OS installer, such as an Anaconda kickstart.
-
-To run an entire playbook locally, just set the "hosts:" line to "hosts:127.0.0.1" and then run the playbook like so::
-
-    ansible-playbook playbook.yml --connection=local
-
-Alternatively, a local connection can be used in a single playbook play, even if other plays in the playbook
-use the default remote connection type::
-
-    hosts: 127.0.0.1
-    connection: local
-
-Turning Off Facts
-`````````````````
-
-If you know you don't need any fact data about your hosts, and know everything about your systems centrally, you
-can turn off fact gathering.  This has advantages in scaling Ansible in push mode with very large numbers of
-systems, mainly, or if you are using Ansible on experimental platforms.   In any play, just do this::
-
-    - hosts: whatever
-      gather_facts: no
-
-Pull-Mode Playbooks
-```````````````````
-
-The use of playbooks in local mode (above) is made extremely powerful with the addition of `ansible-pull`.
-A script for setting up ansible-pull is provided in the examples/playbooks directory of the source
-checkout.
-
-The basic idea is to use Ansible to set up a remote copy of Ansible on each managed node, each set to run via
-cron and update playbook source via git.  This inverts the default push architecture of Ansible into a pull
-architecture, which has near-limitless scaling potential.  The setup playbook can be tuned to change
-the cron frequency, logging locations, and parameters to ansible-pull.
-
-This is useful both for extreme scale-out as well as periodic remediation.  Usage of the 'fetch' module to retrieve
-logs from ansible-pull runs would be an excellent way to gather and analyze remote logs from ansible-pull.
-
-Register Variables
-``````````````````
-
-.. versionadded:: 0.7
-
-Often in a playbook it may be useful to store the result of a given command in a variable and access
-it later.  Use of the command module in this way can in many ways eliminate the need to write site specific facts, for
-instance, you could test for the existence of a particular program.
-
-The 'register' keyword decides what variable to save a result in.  The resulting variables can be used in templates, action lines, or *when* statements.  It looks like this (in an obviously trivial example)::
-
-    - name: test play
-      hosts: all
-
-      tasks:
-
-          - shell: cat /etc/motd
-            register: motd_contents
-
-          - shell: echo "motd contains the word hi"
-            when: motd_contents.stdout.find('hi') != -1
-
-As shown previously, the registered variable's string contents are accessible with the 'stdout' value.
-The registered result can be used in the "with_items" of a task if it is converted into
-a list (or already is a list) as shown below.  "stdout_lines" is already available on the object as
-well though you could also call "home_dirs.stdout.split()" if you wanted, and could split by other
-fields::
-
-    - name: registered variable usage as a with_items list
-      hosts: all
-
-      tasks:
-
-          - name: retrieve the list of home directories
-            command: ls /home
-            register: home_dirs
-
-          - name: add home dirs to the backup spooler
-            file: path=/mnt/bkspool/{{ item }} src=/home/{{ item }} state=link
-            with_items: home_dirs.stdout_lines
-            # with_items: home_dirs.stdout.split()
-
-Rolling Updates
-```````````````
-
-.. versionadded:: 0.7
-
-By default, Ansible will try to manage all of the machines referenced in a play in parallel.  For a rolling updates
-use case, you can define how many hosts Ansible should manage at a single time by using the ''serial'' keyword::
-
-
-    - name: test play
-      hosts: webservers
-      serial: 3
-
-In the above example, if we had 100 hosts, 3 hosts in the group 'webservers'
-would complete the play completely before moving on to the next 3 hosts.
-
-Maximum Failure Percentage
-``````````````````````````
-
-.. versionadded:: 1.3
-
-By default, Ansible will continue executing actions as long as there are hosts in the group that have not yet failed.
-In some situations, such as with the rolling updates described above, it may be desireable to abort the play when a 
-certain threshold of failures have been reached. To acheive this, as of version 1.3 you can set a maximum failure 
-percentage on a play as follows::
-
-    - hosts: webservers
-      max_fail_percentage: 30
-      serial: 10
-
-In the above example, if more than 3 of the 10 servers in the group were to fail, the rest of the play would be aborted.
-
-.. note::
-
-     The percentage set must be exceeded, not equaled. For example, if serial were set to 4 and you wanted the task to abort 
-     when 2 of the systems failed, the percentage should be set at 49 rather than 50.
-
-Delegation
-``````````
-
-.. versionadded:: 0.7
-
-If you want to perform a task on one host with reference to other hosts, use the 'delegate_to' keyword on a task.
-This is ideal for placing nodes in a load balanced pool, or removing them.  It is also very useful for controlling
-outage windows.  Using this with the 'serial' keyword to control the number of hosts executing at one time is also
-a good idea::
-
-    ---
-    - hosts: webservers
-      serial: 5
-
-      tasks:
-      - name: take out of load balancer pool
-        command: /usr/bin/take_out_of_pool {{ inventory_hostname }}
-        delegate_to: 127.0.0.1
-
-      - name: actual steps would go here
-        yum: name=acme-web-stack state=latest
-
-      - name: add back to load balancer pool
-        command: /usr/bin/add_back_to_pool {{ inventory_hostname }}
-        delegate_to: 127.0.0.1
-
-
-These commands will run on 127.0.0.1, which is the machine running Ansible. There is also a shorthand syntax that
-you can use on a per-task basis: 'local_action'. Here is the same playbook as above, but using the shorthand
-syntax for delegating to 127.0.0.1::
-
-    ---
-    # ...
-      tasks:
-      - name: take out of load balancer pool
-        local_action: command /usr/bin/take_out_of_pool {{ inventory_hostname }}
-
-    # ...
-
-      - name: add back to load balancer pool
-        local_action: command /usr/bin/add_back_to_pool {{ inventory_hostname }}
-
-A common pattern is to use a local action to call 'rsync' to recursively copy files to the managed servers.
-Here is an example::
-
-    ---
-    # ...
-      tasks:
-      - name: recursively copy files from management server to target
-        local_action: command rsync -a /path/to/files {{ inventory_hostname }}:/path/to/target/
-
-Note that you must have passphrase-less SSH keys or an ssh-agent configured for this to work, otherwise rsync
-will need to ask for a passphrase.
-
-Accelerated Mode
-````````````````
-
-.. versionadded:: 1.3
-
-While SSH using the ControlPersist feature is quite fast and scalable, there is a certain amount of overhead involved in
-creating connections. This can become something of a bottleneck when the number of hosts grows into the hundreds or 
-thousands. To help overcome this, Ansible offers an accelerated connection option. Accelerated mode can be anywhere from 
-2-6x faster than SSH with ControlPersist enabled, and 10x faster than paramiko.
-
-Accelerated mode works by launching a temporary daemon over SSH. Once the daemon is running, Ansible will connect directly
-to it via a raw socket connection. Ansible secures this communication by using a temporary AES key that is uploaded during
-the SSH connection (this key is different for every host, and is also regenerated every time the daemon is started). By default,
-Ansible will use port 5099 for the accelerated connection, though this is configurable. Once running, the daemon will accept
-connections for 30 minutes, after which time it will terminate itself and need to be restarted over SSH.
-
-Accelerated mode offers several improvments over the original fireball mode:
-
-* No bootstrapping is required, only a single line needs to be added to each play you wish to run in accelerated mode.
-* Support for sudo commands (see below for more details and caveats).
-* Fewer requirements! ZeroMQ is no longer required, nor are there any special packages beyond python-keyczar.
-
-In order to use accelerated mode, simply add `accelerate: true` to your play::
-
-    ---
-    - hosts: all
-      accelerate: true
-      tasks:
-      - name: some task
-        command: echo {{ item }}
-        with_items:
-        - foo
-        - bar
-        - baz
-
-If you wish to change the port Ansible will use for the accelerated connection, just add the `accelerated_port` option::
-
-    ---
-    - hosts: all
-      accelerate: true
-      # default port is 5099
-      accelerate_port: 10000
-
-The `accelerate_port` option can also be specified in the environment variable ACCELERATE_PORT, or in your `ansible.cfg` configuration::
-
-    [accelerate]
-    accelerate_port = 5099
-
-As noted above, accelerated mode also supports running tasks via sudo, however there are two important caveats:
-
-* You must remove requiretty from your sudoers options.
-* Prompting for the sudo password is not yet supported, so the NOPASSWD option is required for commands.
-
-
-
-Fireball Mode
-`````````````
-
-.. versionadded:: 0.8 (deprecated as of 1.3)
-
-.. note::
-
-    The following section has been deprecated as of Ansible 1.3 in favor of the accelerated mode described above. This
-    documentation is here for users who may still be using the original fireball connection method only, and should not
-    be used for any new deployments.
-
-Ansible's core connection types of 'local', 'paramiko', and 'ssh' are augmented in version 0.8 and later by a new extra-fast
-connection type called 'fireball'.  It can only be used with playbooks and does require some additional setup
-outside the lines of Ansible's normal "no bootstrapping" philosophy.  You are not required to use fireball mode
-to use Ansible, though some users may appreciate it.
-
-Fireball mode works by launching a temporary 0mq daemon from SSH that by default lives for only 30 minutes before
-shutting off.  Fireball mode, once running, uses temporary AES keys to encrypt a session, and requires direct
-communication to given nodes on the configured port.  The default is 5099.  The fireball daemon runs as any user you
-set it down as.  So it can run as you, root, or so on.  If multiple users are running Ansible as the same batch of hosts,
-take care to use unique ports.
-
-Fireball mode is roughly 10 times faster than paramiko for communicating with nodes and may be a good option
-if you have a large number of hosts::
-
-    ---
-
-    # set up the fireball transport
-    - hosts: all
-      gather_facts: no
-      connection: ssh # or paramiko
-      sudo: yes
-      tasks:
-          - action: fireball
-
-    # these operations will occur over the fireball transport
-    - hosts: all
-      connection: fireball
-      tasks:
-          - shell: echo "Hello {{ item }}"
-            with_items:
-                - one
-                - two
-
-In order to use fireball mode, certain dependencies must be installed on both ends.   You can use this playbook as a basis for initial bootstrapping on
-any platform.  You will also need gcc and zeromq-devel installed from your package manager, which you can of course also get Ansible to install::
-
-    ---
-    - hosts: all
-      sudo: yes
-      gather_facts: no
-      connection: ssh
-      tasks:
-          - easy_install: name=pip
-          - pip: name={{ item }} state=present
-            with_items:
-              - pyzmq
-              - pyasn1
-              - PyCrypto
-              - python-keyczar
-
-Fedora and EPEL also have Ansible RPM subpackages available for fireball-dependencies.
-
-Also see the module documentation section.
-
-
-Understanding Variable Precedence
-`````````````````````````````````
-
-You have already learned about inventory variables, 'vars', and 'vars_files'.  In the
-event the same variable name occurs in more than one place, what happens?  There are really three tiers
-of precedence, and within those tiers, some minor ordering rules that you probably won't even need to remember.
-We'll explain them anyway though.
-
-Variables that are set during the execution of the play have highest priority. This includes registered
-variables and facts, which are discovered pieces of information about remote hosts.
-
-Descending in priority are variables defined in the playbook.  'vars_files' as defined in the playbook are next up,
-followed by variables as passed to ansible-playbook via --extra-vars (-e), then variables defined in the 'vars' section.  These
-should all be taken to be basically the same thing -- good places to define constants about what the play does to all hosts
-in the play.
-
-Finally, inventory variables have the least priority.  Variables about hosts override those about groups.
-If a variable is defined in multiple groups and one group is a child of the other, the child group variable
-will override the variable set in the parent.
-
-This makes the 'group_vars/all' file the best place to define a default value you wish to override in another
-group, or even in a playbook.  For example, your organization might set a default ntp server in group_vars/all
-and then override it based on a group based on a geographic region.  However if you type 'ntpserver: asdf.example.com'
-in a vars section of a playbook, you know from reading the playbook that THAT specific value is definitely the one
-that is going to be used.  You won't be fooled by some variable from inventory sneaking up on you.
-
-So, in short, if you want something easy to remember: facts beat playbook definitions, and
-playbook definitions beat inventory variables.
-
-There's a little bit more if you are using roles -- roles fit in the "playbook definitions" category of scale.  They are
-trumped by facts, and still trump inventory variables.  However, there's a bit of extra magic.
-
-Variables passed as parameters to the role are accesible only within that role (and dependencies of that role).  You can
-almost think of them like programming functions or macros.
-
-Variables loaded via the 'vars/' directory of a role are made available to all roles and tasks, which in older versions of Ansible
-could be confusing in the case of a reused variable name.  In Ansible 1.3 and later, however, vars/ directories are guaranteed to be scoped to the current role, just like roles parameters.  They are still available globally though, so if you want to set a variable like "ntp_server" in a common role, other roles can still make use of it.  Thus they are just like "vars_files" construct that they emulate, but they have a bit more of a "Do What I Mean" semantic to them.  They are smarter.
-
-If there are role dependencies involved, dependent roles can set variables visible to the roles that require them, but
-the requiring role is allowed to override those variables.  For instance if a role "myapp" requires "apache", and
-the value of "apache_port" in "apache" is 80, "myapp" could choose to set it to 8080.  Thus you may think of this somewhat
-like an inheritance system if you're a developer -- though it's not exactly -- and we don't require folks to think in programming terms to know how things work.
-
-If you want, you can choose to prefix variable names with the name of your role and be extra sure of where
-data sources are coming from, but this is optional.  However it can be a nice thing to do in your templates as you immediately
-know where the variable was defined.
-
-Ultimately, the variable system may seem complex -- but it's really not.  It's mostly a "Do What I Mean" kind of system, though knowing the details may help you if you get stuck or are trying to do something advanced.  Feel free to experiment!
-
-Check Mode ("Dry Run") --check
-```````````````````````````````
-
-.. versionadded:: 1.1
-
-When ansible-playbook is executed with --check it will not make any changes on remote systems.  Instead, any module
-instrumented to support 'check mode' (which contains the primary core modules, but it is not required that all modules do
-this) will report what changes they would have made.  Other modules that do not support check mode will also take no
-action, but just will not report what changes they might have made.
-
-Check mode is just a simulation, and if you have steps that use conditionals that depend on the results of prior commands,
-it may be less useful for you.  However it is great for one-node-at-time basic configuration management use cases.
-
-Example::
-
-    ansible-playbook foo.yml --check
-
-Running a task in check mode
-````````````````````````````
-
-.. versionadded:: 1.3
-
-Sometimes you may want to have a task to be executed even in check
-mode. To achieve this, use the `always_run` clause on the task. Its
-value is a Jinja2 expression, just like the `when` clause. In simple
-cases a boolean YAML value would be sufficient as a value.
-
-Example::
-
-    tasks:
-
-      - name: this task is run even in check mode
-        command: /something/to/run --even-in-check-mode
-        always_run: yes
-
-As a reminder, a task with a `when` clause evaluated to false, will
-still be skipped even if it has a `always_run` clause evaluated to
-true.
-
-
-Showing Differences with --diff
-```````````````````````````````
-
-.. versionadded:: 1.1
-
-The --diff option to ansible-playbook works great with --check (detailed above) but can also be used by itself.  When this flag is supplied, if any templated files on the remote system are changed, and the ansible-playbook CLI will report back
-the textual changes made to the file (or, if used with --check, the changes that would have been made).  Since the diff
-feature produces a large amount of output, it is best used when checking a single host at a time, like so::
-
-    ansible-playbook foo.yml --check --diff --limit foo.example.com
-
-Dictionary & Nested (Complex) Arguments
-```````````````````````````````````````
-
-As a review, most tasks in Ansible are of this form::
-
-    tasks:
-
-      - name: ensure the cobbler package is installed
-        yum: name=cobbler state=installed
-
-However, in some cases, it may be useful to feed arguments directly in from a hash (dictionary).  In fact, a very small
-number of modules (the CloudFormations module is one) actually require complex arguments.  They work like this::
-
-    tasks:
-
-      - name: call a module that requires some complex arguments
-        foo_module:
-           fibonacci_list:
-             - 1
-             - 1
-             - 2
-             - 3
-           my_pets:
-             dogs:
-               - fido
-               - woof
-             fish:
-               - limpet
-               - nemo
-               - "{{ other_fish_name }}"
-
-You can of course use variables inside these, as noted above.
-
-If using local_action, you can do this::
-
-    - name: call a module that requires some complex arguments
-      local_action:
-        module: foo_module
-        arg1: 1234
-        arg2: 'asdf'
-
-Which of course means that, though more verbose, this is also legal syntax::
-
-    - name: foo
-      template: { src: '/templates/motd.j2', dest: '/etc/motd' }
-
-Local Facts (Facts.d)
-`````````````````````
-
-.. versionadded:: 1.3
-
-As discussed in the playbooks chapter, Ansible facts are a way of getting data about remote systems for use in playbook variables.
-Usually these are discovered automatically by the 'setup' module in Ansible. Users can also write custom facts modules, as described
-in the API guide.  However, what if you want to have a simple way to provide system or user 
-provided data for use in Ansible variables, without writing a fact module?  For instance, what if you want users to be able to control some aspect about how their systems are managed? "Facts.d" is one such mechanism.
-
-If a remotely managed system has an "/etc/ansible/facts.d" directory, any files in this directory
-ending in ".fact", can be JSON, INI, or executable files returning JSON, and these can supply local facts in Ansible.
-
-For instance assume a /etc/ansible/facts.d/preferences.fact::
-
-    [general]
-    asdf=1
-    bar=2
-
-This will produce a hash variable fact named "general" with 'asdf' and 'bar' as members.
-To validate this, run the following::
-
-    ansible <hostname> -m setup -a "filter=ansible_local"
-
-And you will see the following fact added::
-
-    "ansible_local": {
-            "preferences": {
-                "general": {
-                    "asdf" : "1", 
-                    "bar"  : "2"
-                }
-            }
-     }
-
-And this data can be accessed in a template/playbook as::
-
-     {{ ansible_local.preferences.general.asdf }}
-
-The local namespace prevents any user supplied fact from overriding system facts
-or variables defined elsewhere in the playbook.
-
-Style Points
-````````````
+You may also apply takes to roles:
 
-Ansible playbooks are colorized.  If you do not like this, set the ANSIBLE_NOCOLOR=1 environment variable.
+    roles:
+      - { role: webserver, port: 5000, tags: [ 'web', 'foo' ] }
 
-Ansible playbooks also look more impressive with cowsay installed, and we encourage installing this package.
+And you may also tag basic include statements:
 
-.. seealso::
+    - include: foo.yml tags=web,foo
 
-   :doc:`YAMLSyntax`
-       Learn about YAML syntax
-   :doc:`playbooks`
-       Review the basic playbook features
-   :doc:`bestpractices`
-       Various tips about playbooks in the real world
-   :doc:`modules`
-       Learn about available modules
-   :doc:`moduledev`
-       Learn how to extend Ansible by writing your own modules
-   :doc:`patterns`
-       Learn about how to select hosts
-   `Github examples directory <https://github.com/ansible/ansible/tree/devel/examples/playbooks>`_
-       Complete playbook files from the github project source
-   `Mailing List <http://groups.google.com/group/ansible-project>`_
-       Questions? Help? Ideas?  Stop by the list on Google Groups
+Both of these have the function of tagging every single task inside the include statement.
 
 

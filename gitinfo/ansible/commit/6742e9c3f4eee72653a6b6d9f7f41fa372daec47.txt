commit 6742e9c3f4eee72653a6b6d9f7f41fa372daec47
Author: Stephen Fromm <sfromm@gmail.com>
Date:   Thu Aug 30 10:31:23 2012 -0700

    Add option required=(True|False) to get_bin_path and update modules
    
    Added required as optional argument to get_bin_path(). It defaults to
    false.  Updated following modules to use required=True when calling
    get_bin_path():  apt_repository, easy_install, group, pip,
    supervisorctl, and user.
    Also removed _find_supervisorctl() from supervisorctl module and updated
    _is_running() to not need it.

diff --git a/lib/ansible/module_common.py b/lib/ansible/module_common.py
index aee5128c60..c237656441 100644
--- a/lib/ansible/module_common.py
+++ b/lib/ansible/module_common.py
@@ -202,9 +202,12 @@ class AnsibleModule(object):
         log_args = re.sub(r'login_password=.+ (.*)', r"login_password=NOT_LOGGING_PASSWORD \1", log_args)
         syslog.syslog(syslog.LOG_NOTICE, 'Invoked with %s' % log_args)
 
-    def get_bin_path(self, arg, opt_dirs=[]):
+    def get_bin_path(self, arg, required=False, opt_dirs=[]):
         '''
         find system executable in PATH.
+        Optional arguments:
+           - required:  if executable is not found and required is true, fail_json
+           - opt_dirs:  optional list of directories to search in addition to PATH
         if found return full path; otherwise return None
         '''
         sbin_paths = ['/sbin', '/usr/sbin', '/usr/local/sbin']
@@ -223,6 +226,8 @@ class AnsibleModule(object):
             if os.path.exists(path) and os.access(path, os.X_OK):
                 bin_path = path
                 break
+        if required and bin_path is None:
+            self.fail_json(msg='Failed to find required executable %s' % arg)
         return bin_path
 
     def boolean(self, arg):
diff --git a/library/apt_repository b/library/apt_repository
index 60539a86c6..67c1393700 100755
--- a/library/apt_repository
+++ b/library/apt_repository
@@ -46,9 +46,7 @@ def main():
 
     module = AnsibleModule(argument_spec=arg_spec)
 
-    add_apt_repository = module.get_bin_path(ADD_APT_REPO)
-    if add_apt_repository is None:
-        module.fail_json(msg='Unable to find executable %s' % ADD_APT_REPO)
+    add_apt_repository = module.get_bin_path(ADD_APT_REPO, True)
 
     repo = module.params['repo']
     state = module.params['state']
diff --git a/library/easy_install b/library/easy_install
index eeb010d1fb..cacd5203ed 100755
--- a/library/easy_install
+++ b/library/easy_install
@@ -50,16 +50,14 @@ def main():
 
     name = module.params['name']
     env = module.params['virtualenv']
-    easy_install = module.get_bin_path('easy_install', ['%s/bin' % env])
-    if easy_install is None:
-        module.fail_json(msg='easy_install is not installed')
+    easy_install = module.get_bin_path('easy_install', True, ['%s/bin' % env])
 
     rc = 0
     err = ''
     out = ''
 
     if env:
-        virtualenv = module.get_bin_path('virtualenv')
+        virtualenv = module.get_bin_path('virtualenv', True)
         if virtualenv is None:
             module.fail_json(msg='virtualenv is not installed')
 
diff --git a/library/group b/library/group
index d4c160ebb5..6df242d63a 100755
--- a/library/group
+++ b/library/group
@@ -20,22 +20,15 @@
 
 import grp
 
-def get_bin_path(module, arg):
-    bin = module.get_bin_path(arg)
-    if bin is None:
-        module.fail_json(msg="Cannot find %s" % arg)
-    else:
-        return bin
-
 def group_del(module, group):
-    cmd = [get_bin_path(module, 'groupdel'), group]
+    cmd = [module.get_bin_path('groupdel', True), group]
     p = subprocess.Popen(cmd, shell=False, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
     (out, err) = p.communicate()
     rc = p.returncode
     return (rc, out, err)
 
 def group_add(module, group, **kwargs):
-    cmd = [get_bin_path(module, 'groupadd')]
+    cmd = [module.get_bin_path('groupadd', True)]
     for key in kwargs:
         if key == 'gid' and kwargs[key] is not None:
             cmd.append('-g')
@@ -49,7 +42,7 @@ def group_add(module, group, **kwargs):
     return (rc, out, err)
 
 def group_mod(module, group, **kwargs):
-    cmd = [get_bin_path(module, 'groupmod')]
+    cmd = [module.get_bin_path('groupmod', True)]
     info = group_info(group)
     for key in kwargs:
         if key == 'gid':
diff --git a/library/pip b/library/pip
index 5dbbea561d..7ff047082f 100755
--- a/library/pip
+++ b/library/pip
@@ -77,9 +77,7 @@ def main():
     env = module.params['virtualenv']
 
     if env:
-        virtualenv = module.get_bin_path('virtualenv')
-        if virtualenv is None:
-            module.fail_json(msg='virtualenv is not installed')
+        virtualenv = module.get_bin_path('virtualenv', True)
 
         rc_venv, out_venv, err_venv = _ensure_virtualenv(module, env, virtualenv)
 
@@ -87,9 +85,7 @@ def main():
         out += out_venv
         err += err_venv
 
-    pip = module.get_bin_path('pip', ['%s/bin' % env])
-    if pip is None:
-        module.fail_json(msg='pip is not installed')
+    pip = module.get_bin_path('pip', True, ['%s/bin' % env])
 
     state = module.params['state']
     name = module.params['name']
diff --git a/library/supervisorctl b/library/supervisorctl
index e0671a5869..97502ff687 100755
--- a/library/supervisorctl
+++ b/library/supervisorctl
@@ -19,17 +19,8 @@
 # along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
 #
 
-def _find_supervisorctl():
-    paths = ['/usr/local/bin', '/usr/bin']
-
-    for p in paths:
-        e = p + '/supervisorctl'
-        if os.path.exists(e):
-            return e
-
-
-def _is_running(name):
-    rc, out, err = _run('%s status %s' % (_find_supervisorctl(), name))
+def _is_running(name, supervisorctl):
+    rc, out, err = _run('%s status %s' % (supervisorctl, name))
     return 'RUNNING' in out
 
 
@@ -52,14 +43,12 @@ def main():
     name = module.params['name']
     state = module.params['state']
 
-    SUPERVISORCTL = module.get_bin_path('supervisorctl')
-    if SUPERVISORCTL is None:
-        module.fail_json(msg='supervisorctl is not installed')
+    SUPERVISORCTL = module.get_bin_path('supervisorctl', True)
 
     if SUPERVISORCTL is None:
         module.fail_json(msg='supervisorctl is not installed')
 
-    running = _is_running(name)
+    running = _is_running(name, SUPERVISORCTL)
 
     if running and state == 'started':
         module.exit_json(changed=False, name=name, state=state)
diff --git a/library/user b/library/user
index a932978da8..d36c0cffce 100755
--- a/library/user
+++ b/library/user
@@ -35,15 +35,8 @@ if os.path.exists('/etc/master.passwd'):
 # invoke adduser in lieu of useradd, nor pw in lieu of usermod.
 # That is, this won't work on FreeBSD.
 
-def get_bin_path(module, arg):
-    bin = module.get_bin_path(arg)
-    if bin is None:
-        module.fail_json(msg="Cannot find %s" % arg)
-    else:
-        return bin
-
 def user_del(module, user, **kwargs):
-    cmd = [get_bin_path(module, 'userdel')]
+    cmd = [module.get_bin_path('userdel', True)]
     for key in kwargs:
         if key == 'force' and kwargs[key] == 'yes':
             cmd.append('-f')
@@ -56,7 +49,7 @@ def user_del(module, user, **kwargs):
     return (rc, out, err)
 
 def user_add(module, user, **kwargs):
-    cmd = [get_bin_path(module, 'useradd')]
+    cmd = [module.get_bin_path('useradd', True)]
     for key in kwargs:
         if key == 'uid' and kwargs[key] is not None:
             cmd.append('-u')
@@ -103,7 +96,7 @@ Without spwd, we would have to resort to reading /etc/shadow
 to get the encrypted string.  For now, punt on idempotent password changes.
 """
 def user_mod(module, user, **kwargs):
-    cmd = [get_bin_path(module, 'usermod')]
+    cmd = [module.get_bin_path('usermod', True)]
     info = user_info(user)
     for key in kwargs:
         if key == 'uid':

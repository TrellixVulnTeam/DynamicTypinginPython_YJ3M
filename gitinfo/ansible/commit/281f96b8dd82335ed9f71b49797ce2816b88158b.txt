commit 281f96b8dd82335ed9f71b49797ce2816b88158b
Author: Michael DeHaan <michael.dehaan@gmail.com>
Date:   Tue Feb 28 03:54:41 2012 -0500

    merge Seth's ansible-command script with ansible proper, so we can do nice output, one line output,
    and treeish saving everywhere.
    
    there are probably some quirks here we'll want to refine further later, for instance, we should
    be able to do nicer things with "can't contact host tracebacks".

diff --git a/bin/ansible b/bin/ansible
index 6459253972..9fe18b8b89 100755
--- a/bin/ansible
+++ b/bin/ansible
@@ -25,7 +25,7 @@ import shlex
 import ansible.runner
 import ansible.playbook
 import ansible.constants as C
-from ansible.scripts import base_ans_parser
+from ansible.scripts import base_ans_parser, error_print
 
 class Cli(object):
 
@@ -38,16 +38,24 @@ class Cli(object):
             help="module name to execute", default=C.DEFAULT_MODULE_NAME)
         parser.add_option("-a", "--args", dest="module_args",
             help="module arguments", default=C.DEFAULT_MODULE_ARGS)
+        parser.add_option('-o', '--one-line', dest='one_line', action='store_true',
+        help="output results on one line to make grepping easier, however will \
+            not remove newlines from command output")
+        parser.add_option('-t', '--tree', dest='output_dest', default=None,
+            help="if specified, a directory name to save output to, one file per host")
+
         options, args = parser.parse_args()
 
         # TODO: more shell like splitting on module_args would
         # be a good idea
 
         sshpass = None
-        if options.askpass:
+        if options.ask_pass:
             sshpass = getpass.getpass(prompt="SSH password: ")
 
-        return ansible.runner.Runner(
+        self.options = options
+
+        runner = ansible.runner.Runner(
             module_name=options.module_name,
             module_path=options.module_path,
             module_args=shlex.split(options.module_args),
@@ -58,10 +66,102 @@ class Cli(object):
             pattern=options.pattern,
             verbose=True,
         )
+        return runner
 
-if __name__ == '__main__':
+    def output(self, results):
+
+        # if specifying output destination (aka tree output saves), create the
+        # directory to output to
+
+        options = self.options
 
-    result = Cli().runner().run()
-    print json.dumps(result, sort_keys=True, indent=4)
+        # TODO: split into function 
+        if options.output_dest:
+            if options.output_dest[0] != '/':
+                options.output_dest = os.path.realpath(os.path.expanduser(options.output_dest))
+            if not os.path.exists(options.output_dest):
+                try:
+                    os.makedirs(options.output_dest)
+                except (IOError, OSError), e:
+                    print >> sys.stderr, "Could not make dir %s: %s" % (options.output_dest, e)
+                    sys.exit(1)
+            if not os.access(options.output_dest, os.W_OK):
+                print >> sys.stderr, "Cannot write to path %s" % options.output_dest
+                sys.exit(1)
 
+        # now walk results and print output
 
+        module_name = self.options.module_name
+        
+        for hostname in sorted(results['contacted']):
+            result    = results['contacted'][hostname]
+            rc        = 0
+            failed    = False
+            stdout    = None
+            stderr    = None
+            traceback = None
+            error     = None
+            if type(result) == dict:
+                failed    = result.get('failed', 0)
+                if module_name == 'command':
+                    rc        = result.get('rc',0)
+                    stdout    = result.get('stdout', '')
+                    stderr    = result.get('stderr', '')
+                    traceback = result.get('traceback', '')
+                    error     = result.get('error', '')
+
+            # detect and show failures, if any
+            if rc != 0 or failed:
+                msg = "Error: %s: \n" % hostname
+                if stdout:
+                    msg += stdout
+                if stderr:
+                    msg += stderr
+                if traceback:
+                    msg += traceback
+                if error:
+                    msg += error
+                error_print(msg)
+                continue
+
+            if options.one_line:
+                # try to print everything on one line, but don't strip newlines
+                # if the command output happend to be too long
+                if module_name == 'command':
+                    msg = "(stdout) %s" % stdout
+                    if stderr.rstrip() != '':
+                        msg = "(stdout) %s (stderr) %s" % (stdout,stderr)
+                    print "%s | rc=%s | %s" % (
+                        hostname, rc, msg
+                    ) 
+                else:
+                    print "%s | %s" % (hostname, result)
+            else:
+                # summarize response from command in multiple lines
+                if module_name == 'command':
+                    buf = ''
+                    buf += "%s | rc=%s >>\n" % (hostname, rc)
+                    buf += stdout
+                    if stderr:
+                        buf += stderr
+                    print buf
+                    if options.output_dest:
+                        path = os.path.join(options.output_dest, hostname)
+                        fd = open(path, "w+")
+                        fd.write(buf)
+                        fd.close()
+                else:
+                    print "%s >>" % hostname
+                    print json.dumps(result, indent=4, sort_keys=True)
+
+        if len(results['dark'].keys()) > 0:
+            error_print('*** Hosts which could not be contacted or did not respond: ***')
+            failed_hosts = results['dark'].keys()
+            for hostname in failed_hosts:
+                error_print("%s:\n%s\n" % (hostname, results['dark'][hostname]))
+                print ''
+
+if __name__ == '__main__':
+    cli = Cli()
+    cli.output(cli.runner().run())
+    
diff --git a/bin/ansible-command b/bin/ansible-command
deleted file mode 100755
index 19b8cf6b26..0000000000
--- a/bin/ansible-command
+++ /dev/null
@@ -1,154 +0,0 @@
-#!/usr/bin/python -tt
-
-# skvidal, (c) Red Hat, Inc 2012
-# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
-
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-#
-
-# TODO: add 'execution time' option output to the output
-
-import sys
-import os
-import getpass
-import ansible.runner
-import shlex
-from ansible.scripts import base_ans_parser, error_print
-
-
-def main(args):
-
-
-    # ==================================
-    # parse options
-    parser = base_ans_parser()
-    parser.usage = "ans-command [options] command-to-run"
-
-    parser.add_option('-o', '--one-line', dest='one_line', action='store_true', 
-        help="output results on one line to make grepping easier, however will \
-            not remove newlines from command output")
-    parser.add_option('-t', '--tree', dest='output_dest', default=None,
-        help="if specified, a directory name to save output to, one file per host")
-
-    options, args = parser.parse_args(args)
-
-    # get user's password if not supplied
-    # TODO: move into lib/ansible/scripts.py (?)
-    sshpass = None
-    if options.askpass:
-        sshpass = getpass.getpass(prompt="SSH password: ")
-
-    # if specifying output destination (aka tree output saves), create the 
-    # directory to output to
-
-    if options.output_dest:
-        if options.output_dest[0] != '/':
-            options.output_dest = os.path.realpath(os.path.expanduser(options.output_dest))
-        if not os.path.exists(options.output_dest):
-            try:
-                os.makedirs(options.output_dest)
-            except (IOError, OSError), e:
-                print >> sys.stderr, "Could not make dir %s: %s" % (options.output_dest, e)
-                sys.exit(1)
-        if not os.access(options.output_dest, os.W_OK):
-            print >> sys.stderr, "Cannot write to path %s" % options.output_dest
-            sys.exit(1)
-
-    # if no arguments are specified, error out
-
-    if len(args) == 0:
-       print >> sys.stderr, "Missing argument.  What should be executed?"
-       sys.exit(1)
-
-    # make the actual ansible API call
-
-    mycmd = ' '.join(args)
-    runner = ansible.runner.Runner(
-                module_name='command',
-                module_path=options.module_path,
-                module_args=shlex.split(mycmd),
-                remote_user=options.remote_user,
-                remote_pass=sshpass,
-                host_list=options.host_list,
-                forks=options.forks,
-                pattern=options.pattern,
-                verbose=True,
-            )
-    results = runner.run()
-
-    # walk through results and summarize them neatly
-
-    for hostname in sorted(results['contacted']):
-
-        result    = results['contacted'][hostname]
-        rc        = result.get('rc',0)
-        failed    = result.get('failed', 0)
-        stdout    = result.get('stdout', '')
-        stderr    = result.get('stderr', '')
-        traceback = result.get('traceback', '')
-        error     = result.get('error', '')
-
-        # detect and show failures, if any
-
-        if rc != 0 or failed:
-            msg = "Error: %s: \n" % hostname
-            msg += stdout
-            msg += stderr
-            msg += traceback
-            msg += error
-            error_print(msg)
-            continue
-
-        if options.one_line:
-            # try to print everything on one line, but don't strip newlines
-            # if the command output happend to be too long
-            msg = "(stdout) %s" % stdout
-            if stderr.rstrip() != '':
-                msg = "(stdout) %s (stderr) %s" % (stdout,stderr)
-            print "%s | rc=%s | %s" % (
-                hostname, rc, msg
-            )
-        else:
-            # summarize response from command in multiple lines
-            buf = ''
-            buf += "%s | rc=%s >>\n" % (hostname, rc)
-            buf += stdout
-            if stderr:
-                buf += stderr
-            print buf
-            if options.output_dest:
-                path = os.path.join(options.output_dest, hostname)
-                fd = open(path, "w+")
-                fd.write(buf)
-                fd.close()
-
-    # print errors for hosts we could not reach
-    if results['dark']:
-        print ''
-        error_print('Hosts which could not be contacted or did not respond:')
-        failed_hosts = results['dark'].keys()
-        for hostname in failed_hosts:
-            error_print("%s:\n%s\n" % (hostname, results['dark'][hostname]))
-        print ''
-
-    
-if __name__ == "__main__":
-    sys.exit(main(sys.argv[1:]))
-
-
-
-
-
diff --git a/library/ohai b/library/ohai
old mode 100644
new mode 100755
diff --git a/setup.py b/setup.py
index a79e5caffd..382f188cb9 100644
--- a/setup.py
+++ b/setup.py
@@ -34,7 +34,6 @@ setup(name='ansible',
       ],
       scripts=[
          'bin/ansible',
-         'bin/ansible-command',
          'bin/ansible-playbook'
       ]
 )

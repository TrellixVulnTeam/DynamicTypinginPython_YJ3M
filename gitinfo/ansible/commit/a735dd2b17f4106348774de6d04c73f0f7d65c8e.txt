commit a735dd2b17f4106348774de6d04c73f0f7d65c8e
Author: Michael DeHaan <michael.dehaan@gmail.com>
Date:   Wed Mar 14 21:49:27 2012 -0400

    Added the 'test-module' script, useful for testing modules without running them in Ansible.

diff --git a/hacking/test-module b/hacking/test-module
new file mode 100755
index 0000000000..3fcd0071c9
--- /dev/null
+++ b/hacking/test-module
@@ -0,0 +1,78 @@
+#!/usr/bin/python
+
+# (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>
+#
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+#
+
+# this script is for testing modules without running through the
+# entire guts of ansible, and is very helpful for when developing
+# modules
+#
+# example:
+#    test-module ../library/command /bin/sleep 3
+#    test-module ../library/service name=httpd ensure=restarted
+
+import sys
+import os
+import subprocess
+import traceback
+import ansible.utils
+
+try:
+    import json
+except ImportError:
+    import simplejson as json
+
+modfile = None
+
+if len(sys.argv) == 1:
+    print >>sys.stderr, "usage: test-module ./library/command [key=value ...]"
+    sys.exit(1)
+
+modfile = sys.argv[1]
+if len(sys.argv) > 1:
+    args = " ".join(sys.argv[2:])
+else:
+    args = ""
+
+argspath = os.path.expanduser("/.ansible_test_module_arguments")
+argsfile = open(argspath, 'w')
+argsfile.write(args)
+argsfile.close()
+
+os.system("chmod +x %s" % modfile)
+cmd = subprocess.Popen("%s %s" % (modfile, argspath), 
+    shell=True,
+    stdout=subprocess.PIPE, 
+    stderr=subprocess.PIPE)
+(out, err) = cmd.communicate()
+
+try:
+    results = ansible.utils.parse_json(out)
+except:
+    print "INVALID OUTPUT FORMAT"
+    print "*********************"
+    print out
+    print "*********************"
+    traceback.print_exc()
+    sys.exit(1)
+
+print results
+
+sys.exit(0)
+
+
diff --git a/library/service b/library/service
index bb609a868d..d45da40867 100755
--- a/library/service
+++ b/library/service
@@ -27,44 +27,26 @@ import shlex
 import subprocess
 
 # ===========================================
-# convert arguments of form a=b c=d
-# to a dictionary
-# FIXME: make more idiomatic
-
-
-if len(sys.argv) == 1:
-    print json.dumps({
-        "failed" : True,
-        "msg"    : "the command module requires arguments (-a)"
-    })
-    sys.exit(1)
 
 argfile = sys.argv[1]
-if not os.path.exists(argfile):
-    print json.dumps({
-        "failed" : True,
-        "msg"    : "Argument file not found"
-    })
-    sys.exit(1)
-
 args = open(argfile, 'r').read()
-itmes = shlex.split(args)
+items = shlex.split(args)
 
 if not len(items):
-    print json.dumps({
-        "failed" : True,
-        "msg"    : "the command module requires arguments (-a)"
-    })
+    print "failed=True msg='the module requires arguments (-a)'"
     sys.exit(1)
 
-
 params = {}
 for x in items:
     (k, v) = x.split("=")
     params[k] = v
 
 name = params['name']
-state = params.get('state','running')
+state = params.get('state','unknown')
+
+if state not in [ 'running', 'stopped', 'restarted' ]:
+    print "failed=True msg='invalid state'"
+    sys.exit(1)
 
 # ===========================================
 # get service status

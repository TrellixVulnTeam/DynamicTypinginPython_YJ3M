commit 704c3815d35a3fe6f7379b379f77c12affe23e9b
Author: Abhijit Menon-Sen <ams@2ndQuadrant.com>
Date:   Sun Aug 23 13:40:42 2015 +0530

    Reorder functions into a logical sequence based on usage
    
    There are no code changes; this is committed separately so as to make
    the subsequent "real" diffs easier to read.

diff --git a/lib/ansible/inventory/__init__.py b/lib/ansible/inventory/__init__.py
index e4ff5132d8..7d4263bdbc 100644
--- a/lib/ansible/inventory/__init__.py
+++ b/lib/ansible/inventory/__init__.py
@@ -136,48 +136,6 @@ class Inventory(object):
         for host in self.get_hosts():
             host.vars = combine_vars(host.vars, self.get_host_variables(host.name))
 
-
-    def _match(self, str, pattern_str):
-        try:
-            if pattern_str.startswith('~'):
-                return re.search(pattern_str[1:], str)
-            else:
-                return fnmatch.fnmatch(str, pattern_str)
-        except Exception, e:
-            raise AnsibleError('invalid host pattern: %s' % pattern_str)
-
-    def _match_list(self, items, item_attr, pattern_str):
-        results = []
-        try:
-            if not pattern_str.startswith('~'):
-                pattern = re.compile(fnmatch.translate(pattern_str))
-            else:
-                pattern = re.compile(pattern_str[1:])
-        except Exception, e:
-            raise AnsibleError('invalid host pattern: %s' % pattern_str)
-
-        for item in items:
-            if pattern.match(getattr(item, item_attr)):
-                results.append(item)
-        return results
-
-    def _split_pattern(self, pattern):
-        """
-        takes e.g. "webservers[0:5]:dbservers:others"
-        and returns ["webservers[0:5]", "dbservers", "others"]
-        """
-
-        term = re.compile(
-            r'''(?:             # We want to match something comprising:
-                    [^:\[\]]    # (anything other than ':', '[', or ']'
-                    |           # ...or...
-                    \[[^\]]*\]  # a single complete bracketed expression)
-                )*              # repeated as many times as possible
-            ''', re.X
-        )
-
-        return [x for x in term.findall(pattern) if x]
-
     def get_hosts(self, pattern="all"):
         """ 
         Takes a pattern or list of patterns and returns a list of matching
@@ -201,12 +159,29 @@ class Inventory(object):
             subset = self._evaluate_patterns(self._subset)
             hosts = [ h for h in hosts if h in subset ]
 
-        # exclude hosts mentioned in any restriction (ex: failed hosts)
+        # exclude hosts mentioned in any restriction
         if self._restriction is not None:
             hosts = [ h for h in hosts if h in self._restriction ]
 
         return hosts
 
+    def _split_pattern(self, pattern):
+        """
+        takes e.g. "webservers[0:5]:dbservers:others"
+        and returns ["webservers[0:5]", "dbservers", "others"]
+        """
+
+        term = re.compile(
+            r'''(?:             # We want to match something comprising:
+                    [^:\[\]]    # (anything other than ':', '[', or ']'
+                    |           # ...or...
+                    \[[^\]]*\]  # a single complete bracketed expression)
+                )*              # repeated as many times as possible
+            ''', re.X
+        )
+
+        return [x for x in term.findall(pattern) if x]
+
     def _evaluate_patterns(self, patterns):
         """
         Takes a list of patterns and returns a list of matching host names,
@@ -326,20 +301,6 @@ class Inventory(object):
         except IndexError:
             raise AnsibleError("no hosts matching the pattern '%s' were found" % pat)
 
-    def _create_implicit_localhost(self, pattern):
-        new_host = Host(pattern)
-        new_host.set_variable("ansible_python_interpreter", sys.executable)
-        new_host.set_variable("ansible_connection", "local")
-        new_host.ipv4_address = '127.0.0.1'
-
-        ungrouped = self.get_group("ungrouped")
-        if ungrouped is None:
-            self.add_group(Group('ungrouped'))
-            ungrouped = self.get_group('ungrouped')
-            self.get_group('all').add_child_group(ungrouped)
-        ungrouped.add_host(new_host)
-        return new_host
-
     def _hosts_in_unenumerated_pattern(self, pattern):
         """ Get all host names matching the pattern """
 
@@ -374,6 +335,44 @@ class Inventory(object):
             results.append(new_host)
         return results
 
+    def _match(self, str, pattern_str):
+        try:
+            if pattern_str.startswith('~'):
+                return re.search(pattern_str[1:], str)
+            else:
+                return fnmatch.fnmatch(str, pattern_str)
+        except Exception, e:
+            raise AnsibleError('invalid host pattern: %s' % pattern_str)
+
+    def _match_list(self, items, item_attr, pattern_str):
+        results = []
+        try:
+            if not pattern_str.startswith('~'):
+                pattern = re.compile(fnmatch.translate(pattern_str))
+            else:
+                pattern = re.compile(pattern_str[1:])
+        except Exception, e:
+            raise AnsibleError('invalid host pattern: %s' % pattern_str)
+
+        for item in items:
+            if pattern.match(getattr(item, item_attr)):
+                results.append(item)
+        return results
+
+    def _create_implicit_localhost(self, pattern):
+        new_host = Host(pattern)
+        new_host.set_variable("ansible_python_interpreter", sys.executable)
+        new_host.set_variable("ansible_connection", "local")
+        new_host.ipv4_address = '127.0.0.1'
+
+        ungrouped = self.get_group("ungrouped")
+        if ungrouped is None:
+            self.add_group(Group('ungrouped'))
+            ungrouped = self.get_group('ungrouped')
+            self.get_group('all').add_child_group(ungrouped)
+        ungrouped.add_host(new_host)
+        return new_host
+
     def clear_pattern_cache(self):
         ''' called exclusively by the add_host plugin to allow patterns to be recalculated '''
         self._pattern_cache = {}

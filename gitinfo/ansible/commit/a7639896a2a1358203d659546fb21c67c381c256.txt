commit a7639896a2a1358203d659546fb21c67c381c256
Author: Adrian Likins <alikins@redhat.com>
Date:   Wed Jun 15 12:07:40 2016 -0400

    Delete currently unused code. (#16290)
    
    This was kind of confusing, and also caused sphinx-apidoc
    to throw strange errors.

diff --git a/lib/ansible/new_inventory/__init__.py b/lib/ansible/new_inventory/__init__.py
deleted file mode 100644
index 4c57edc161..0000000000
--- a/lib/ansible/new_inventory/__init__.py
+++ /dev/null
@@ -1,344 +0,0 @@
-# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-#############################################
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-import re
-import sys
-from ansible import constants as C
-from ansible.inventory.group import Group
-from .host import Host
-from ansible.plugins.inventory.aggregate import InventoryAggregateParser
-from ansible import errors
-
-class Inventory:
-    '''
-    Create hosts and groups from inventory
-
-    Retrieve the hosts and groups that ansible knows about from this class.
-
-    Retrieve raw variables (non-expanded) from the Group and Host classes
-    returned from here.
-    '''
-
-    def __init__(self, inventory_list=C.DEFAULT_HOST_LIST):
-        '''
-        :kwarg inventory_list: A list of inventory sources.  This may be file
-            names which will be parsed as ini-like files, executable scripts
-            which return inventory data as json, directories of both of the above,
-            or hostnames.  Files and directories are 
-        :kwarg vault_password: Password to use if any of the inventory sources
-            are in an ansible vault
-        '''
-
-        self._restricted_to  = None
-        self._filter_pattern = None
-
-        parser = InventoryAggregateParser(inventory_list)
-        parser.parse()
-
-        self._basedir = parser.basedir
-        self._hosts   = parser.hosts
-        self._groups  = parser.groups
-
-    def get_hosts(self):
-        '''
-        Return the list of hosts, after filtering based on any set pattern
-        and restricting the results based on the set host restrictions.
-        '''
-
-        if self._filter_pattern:
-            hosts = self._filter_hosts()
-        else:
-            hosts = self._hosts[:]
-
-        if self._restricted_to is not None:
-            # this will preserve the order of hosts after intersecting them
-            res_set = set(hosts).intersection(self._restricted_to)
-            return [h for h in hosts if h in res_set]
-        else:
-            return hosts[:]
-
-    def get_groups(self):
-        '''
-        Retrieve the Group objects known to the Inventory
-        '''
-
-        return self._groups[:]
-
-    def get_host(self, hostname):
-        '''
-        Retrieve the Host object for a hostname
-        '''
-
-        for host in self._hosts:
-            if host.name == hostname:
-                return host
-
-        return None
-
-    def get_group(self, groupname):
-        '''
-        Retrieve the Group object for a groupname
-        '''
-
-        for group in self._groups:
-            if group.name == groupname:
-                return group
-
-        return None
-
-    def add_group(self, group):
-        '''
-        Add a new group to the inventory
-        '''
-
-        if group not in self._groups:
-            self._groups.append(group)
-
-    def set_filter_pattern(self, pattern='all'):
-        '''
-        Sets a pattern upon which hosts/groups will be filtered.
-        This pattern can contain logical groupings such as unions,
-        intersections and negations using special syntax.
-        '''
-
-        self._filter_pattern = pattern
-
-    def set_host_restriction(self, restriction):
-        '''
-        Restrict operations to hosts in the given list
-        '''
-
-        assert isinstance(restriction, list)
-        self._restricted_to = restriction[:]
-
-    def remove_host_restriction(self):
-        '''
-        Remove the restriction on hosts, if any.
-        '''
-
-        self._restricted_to = None
-
-    def _filter_hosts(self):
-        """
-        Limits inventory results to a subset of inventory that matches a given
-        list of patterns, such as to select a subset of a hosts selection that also
-        belongs to a certain geographic group or numeric slice.
-
-        Corresponds to --limit parameter to ansible-playbook
-
-        :arg patterns: The pattern to limit with.  If this is None it
-            clears the subset.  Multiple patterns may be specified as a comma,
-            semicolon, or colon separated string.
-        """
-
-        hosts = []
-
-        pattern_regular = []
-        pattern_intersection = []
-        pattern_exclude = []
-
-        patterns = self._pattern.replace(";",":").split(":")
-        for p in patterns:
-            if p.startswith("!"):
-                pattern_exclude.append(p)
-            elif p.startswith("&"):
-                pattern_intersection.append(p)
-            elif p:
-                pattern_regular.append(p)
-
-        # if no regular pattern was given, hence only exclude and/or intersection
-        # make that magically work
-        if pattern_regular == []:
-            pattern_regular = ['all']
-
-        # when applying the host selectors, run those without the "&" or "!"
-        # first, then the &s, then the !s.
-        patterns = pattern_regular + pattern_intersection + pattern_exclude
-
-        for p in patterns:
-            intersect = False
-            negate    = False
-            if p.startswith('&'):
-                intersect = True
-            elif p.startswith('!'):
-                p = p[1:]
-                negate = True
-
-            target = self._resolve_pattern(p)
-            if isinstance(target, Host):
-                if negate and target in hosts:
-                    # remove it
-                    hosts.remove(target)
-                elif target not in hosts:
-                    # for both union and intersections, we just append it
-                    hosts.append(target)
-            else:
-                if intersect:
-                    hosts = [ h for h in hosts if h not in target ]
-                elif negate:
-                    hosts = [ h for h in hosts if h in target ]
-                else:
-                    to_append = [ h for h in target if h.name not in [ y.name for y in hosts ] ]
-                    hosts.extend(to_append)
-
-        return hosts
-
-    def _resolve_pattern(self, pattern):
-        target = self.get_host(pattern)
-        if target:
-            return target
-        else:
-            (name, enumeration_details) = self._enumeration_info(pattern)
-            hpat = self._hosts_in_unenumerated_pattern(name)
-            result = self._apply_ranges(pattern, hpat)
-            return result
-
-    def _enumeration_info(self, pattern):
-        """
-        returns (pattern, limits) taking a regular pattern and finding out
-        which parts of it correspond to start/stop offsets.  limits is
-        a tuple of (start, stop) or None
-        """
-
-        # Do not parse regexes for enumeration info
-        if pattern.startswith('~'):
-            return (pattern, None)
-
-        # The regex used to match on the range, which can be [x] or [x-y].
-        pattern_re = re.compile("^(.*)\[([-]?[0-9]+)(?:(?:-)([0-9]+))?\](.*)$")
-        m = pattern_re.match(pattern)
-        if m:
-            (target, first, last, rest) = m.groups()
-            first = int(first)
-            if last:
-                if first < 0:
-                    raise errors.AnsibleError("invalid range: negative indices cannot be used as the first item in a range")
-                last = int(last)
-            else:
-                last = first
-            return (target, (first, last))
-        else:
-            return (pattern, None)
-
-    def _apply_ranges(self, pat, hosts):
-        """
-        given a pattern like foo, that matches hosts, return all of hosts
-        given a pattern like foo[0:5], where foo matches hosts, return the first 6 hosts
-        """ 
-
-        # If there are no hosts to select from, just return the
-        # empty set. This prevents trying to do selections on an empty set.
-        # issue#6258
-        if not hosts:
-            return hosts
-
-        (loose_pattern, limits) = self._enumeration_info(pat)
-        if not limits:
-            return hosts
-
-        (left, right) = limits
-
-        if left == '':
-            left = 0
-        if right == '':
-            right = 0
-        left=int(left)
-        right=int(right)
-        try:
-            if left != right:
-                return hosts[left:right]
-            else:
-                return [ hosts[left] ]
-        except IndexError:
-            raise errors.AnsibleError("no hosts matching the pattern '%s' were found" % pat)
-
-    def _hosts_in_unenumerated_pattern(self, pattern):
-        """ Get all host names matching the pattern """
-
-        results = []
-        hosts = []
-        hostnames = set()
-
-        # ignore any negative checks here, this is handled elsewhere
-        pattern = pattern.replace("!","").replace("&", "")
-
-        def __append_host_to_results(host):
-            if host not in results and host.name not in hostnames:
-                hostnames.add(host.name)
-                results.append(host)
-
-        groups = self.get_groups()
-        for group in groups:
-            if pattern == 'all':
-                for host in group.get_hosts():
-                    __append_host_to_results(host)
-            else:
-                if self._match(group.name, pattern):
-                    for host in group.get_hosts():
-                        __append_host_to_results(host)
-                else:
-                    matching_hosts = self._match_list(group.get_hosts(), 'name', pattern)
-                    for host in matching_hosts:
-                        __append_host_to_results(host)
-
-        if pattern in ["localhost", "127.0.0.1"] and len(results) == 0:
-            new_host = self._create_implicit_localhost(pattern)
-            results.append(new_host)
-        return results
-
-    def _create_implicit_localhost(self, pattern):
-        new_host = Host(pattern)
-        new_host._connection = 'local'
-        new_host.set_variable("ansible_python_interpreter", sys.executable)
-        ungrouped = self.get_group("ungrouped")
-        if ungrouped is None:
-            self.add_group(Group('ungrouped'))
-            ungrouped = self.get_group('ungrouped')
-            self.get_group('all').add_child_group(ungrouped)
-        ungrouped.add_host(new_host)
-        return new_host
-
-    def is_file(self):
-        '''
-        Did inventory come from a file?
-
-        :returns: True if the inventory is file based, False otherwise
-        '''
-        pass
-
-    def src(self):
-        '''
-        What's the complete path to the inventory file?
-
-        :returns: Complete path to the inventory file.  None if inventory is
-            not file-based
-        '''
-        pass
-
-    def basedir(self):
-        '''
-        What directory from which the inventory was read.
-        '''
-
-        return self._basedir
-
diff --git a/lib/ansible/new_inventory/group.py b/lib/ansible/new_inventory/group.py
deleted file mode 100644
index 785fc45992..0000000000
--- a/lib/ansible/new_inventory/group.py
+++ /dev/null
@@ -1,21 +0,0 @@
-# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
diff --git a/lib/ansible/new_inventory/host.py b/lib/ansible/new_inventory/host.py
deleted file mode 100644
index 78f190c423..0000000000
--- a/lib/ansible/new_inventory/host.py
+++ /dev/null
@@ -1,51 +0,0 @@
-# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-class Host:
-    def __init__(self, name):
-        self._name         = name
-        self._connection   = None
-        self._ipv4_address = ''
-        self._ipv6_address = ''
-        self._port         = 22
-        self._vars         = dict()
-
-    def __repr__(self):
-        return self.get_name()
-
-    def get_name(self):
-        return self._name
-
-    def get_groups(self):
-        return []
-
-    def set_variable(self, name, value):
-        ''' sets a variable for this host '''
-
-        self._vars[name] = value
-
-    def get_vars(self):
-        ''' returns all variables for this host '''
-
-        all_vars = self._vars.copy()
-        all_vars.update(dict(inventory_hostname=self._name))
-        return all_vars
-
diff --git a/lib/ansible/plugins/inventory/README.md b/lib/ansible/plugins/inventory/README.md
deleted file mode 100644
index 1988f9adc6..0000000000
--- a/lib/ansible/plugins/inventory/README.md
+++ /dev/null
@@ -1 +0,0 @@
-These are not currently in use, but this is what the future of inventory will become after 2.0
diff --git a/lib/ansible/plugins/inventory/__init__.py b/lib/ansible/plugins/inventory/__init__.py
deleted file mode 100644
index 4c23228a15..0000000000
--- a/lib/ansible/plugins/inventory/__init__.py
+++ /dev/null
@@ -1,81 +0,0 @@
-# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-#############################################
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-from abc import ABCMeta, abstractmethod
-
-from ansible.compat.six import with_metaclass
-
-class InventoryParser(with_metaclass(ABCMeta, object)):
-    '''Abstract Base Class for retrieving inventory information
-
-    Any InventoryParser functions by taking an inven_source.  The caller then
-    calls the parser() method.  Once parser is called, the caller can access
-    InventoryParser.hosts for a mapping of Host objects and
-    InventoryParser.Groups for a mapping of Group objects.
-    '''
-
-    def __init__(self, inven_source):
-        '''
-        InventoryParser contructors take a source of inventory information
-        that they will parse the host and group information from.
-        '''
-        self.inven_source = inven_source
-        self.reset_parser()
-
-    @abstractmethod
-    def reset_parser(self):
-        '''
-        InventoryParsers generally cache their data once parser() is
-        called.  This method initializes any parser state before calling parser
-        again.
-        '''
-        self.hosts = dict()
-        self.groups = dict()
-        self.parsed = False
-
-    def _merge(self, target, addition):
-        '''
-        This method is provided to InventoryParsers to merge host or group
-        dicts since it may take several passes to get all of the data
-
-        Example usage:
-            self.hosts = self.from_ini(filename)
-            new_hosts = self.from_script(scriptname)
-            self._merge(self.hosts, new_hosts)
-        '''
-        for i in addition:
-            if i in target:
-                target[i].merge(addition[i])
-            else:
-                target[i] = addition[i]
-
-    @abstractmethod
-    def parse(self, refresh=False):
-        if refresh:
-            self.reset_parser()
-        if self.parsed:
-            return self.parsed
-
-        # Parse self.inven_sources here
-        pass
-
diff --git a/lib/ansible/plugins/inventory/aggregate.py b/lib/ansible/plugins/inventory/aggregate.py
deleted file mode 100644
index 6bdf2ddcb6..0000000000
--- a/lib/ansible/plugins/inventory/aggregate.py
+++ /dev/null
@@ -1,61 +0,0 @@
-# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-#############################################
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-import os
-
-from . import InventoryParser
-#from . ini import InventoryIniParser
-#from . script import InventoryScriptParser
-
-class InventoryAggregateParser(InventoryParser):
-
-    def __init__(self, inven_sources):
-        self.inven_source = inven_sources
-        self.hosts = dict()
-        self.groups = dict()
-
-    def reset_parser(self):
-        super(InventoryAggregateParser, self).reset_parser()
-
-    def parse(self, refresh=False):
-        # InventoryDirectoryParser is a InventoryAggregateParser so we avoid
-        # a circular import by importing here
-        from . directory import InventoryAggregateParser
-        if super(InventoryAggregateParser, self).parse(refresh):
-            return self.parsed
-
-        for entry in self.inven_sources:
-            if os.path.sep in entry:
-                # file or directory
-                if os.path.isdir(entry):
-                    parser = directory.InventoryDirectoryParser(filename=entry)
-                elif utils.is_executable(entry):
-                    parser = InventoryScriptParser(filename=entry)
-                else:
-                    parser = InventoryIniParser(filename=entry)
-            else:
-                # hostname
-                parser = HostnameParser(hostname=entry)
-            hosts, groups = parser.parse()
-            self._merge(self.hosts, hosts)
-            self._merge(self.groups, groups)
diff --git a/lib/ansible/plugins/inventory/directory.py b/lib/ansible/plugins/inventory/directory.py
deleted file mode 100644
index 93ef7378b1..0000000000
--- a/lib/ansible/plugins/inventory/directory.py
+++ /dev/null
@@ -1,55 +0,0 @@
-# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-#############################################
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-import os
-from ansible import constants as C
-
-from . aggregate import InventoryAggregateParser
-
-class InventoryDirectoryParser(InventoryAggregateParser):
-
-    CONDITION="is_dir(%s)"
-
-    def __init__(self, inven_directory):
-        directory = inven_directory
-        names = os.listdir(inven_directory)
-        filtered_names = []
-
-        # Clean up the list of filenames
-        for filename in names:
-            # Skip files that end with certain extensions or characters
-            if any(filename.endswith(ext) for ext in C.DEFAULT_INVENTORY_IGNORE):
-                continue
-            # Skip hidden files
-            if filename.startswith('.') and not filename.startswith('.{0}'.format(os.path.sep)):
-                continue
-            # These are things inside of an inventory basedir
-            if filename in ("host_vars", "group_vars", "vars_plugins"):
-                continue
-            fullpath = os.path.join(directory, filename)
-            filtered_names.append(fullpath)
-
-        super(InventoryDirectoryParser, self).__init__(filtered_names)
-
-    def parse(self):
-        return super(InventoryDirectoryParser, self).parse()
diff --git a/lib/ansible/plugins/inventory/ini.py b/lib/ansible/plugins/inventory/ini.py
deleted file mode 100644
index 81601e5606..0000000000
--- a/lib/ansible/plugins/inventory/ini.py
+++ /dev/null
@@ -1,55 +0,0 @@
-# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-#############################################
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-import os
-
-from ansible import constants as C
-from . import InventoryParser
-
-class InventoryIniParser(InventoryAggregateParser):
-
-    CONDITION="is_file(%s)"
-
-    def __init__(self, inven_directory):
-        directory = inven_directory
-        names = os.listdir(inven_directory)
-        filtered_names = []
-
-        # Clean up the list of filenames
-        for filename in names:
-            # Skip files that end with certain extensions or characters
-            if any(filename.endswith(ext) for ext in C.DEFAULT_INVENTORY_IGNORE):
-                continue
-            # Skip hidden files
-            if filename.startswith('.') and not filename.startswith('.{0}'.format(os.path.sep)):
-                continue
-            # These are things inside of an inventory basedir
-            if filename in ("host_vars", "group_vars", "vars_plugins"):
-                continue
-            fullpath = os.path.join(directory, filename)
-            filtered_names.append(fullpath)
-
-        super(InventoryDirectoryParser, self).__init__(filtered_names)
-
-    def parse(self):
-        return super(InventoryDirectoryParser, self).parse()
diff --git a/lib/ansible/plugins/inventory/script.py b/lib/ansible/plugins/inventory/script.py
deleted file mode 100644
index 1346bf3562..0000000000
--- a/lib/ansible/plugins/inventory/script.py
+++ /dev/null
@@ -1,31 +0,0 @@
-# (c) 2012-2014, Michael DeHaan <michael.dehaan@gmail.com>
-#
-# This file is part of Ansible
-#
-# Ansible is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# Ansible is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
-
-#############################################
-
-# Make coding more python3-ish
-from __future__ import (absolute_import, division, print_function)
-__metaclass__ = type
-
-import os
-
-from ansible import constants as C
-from . import InventoryParser
-
-class InventoryScriptParser(InventoryParser):
-
-    CONDITION="is_file(%s) and is_executable(%s)"

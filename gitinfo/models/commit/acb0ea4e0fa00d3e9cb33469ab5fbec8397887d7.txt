commit acb0ea4e0fa00d3e9cb33469ab5fbec8397887d7
Author: Toby Boyd <tobyboyd@google.com>
Date:   Fri Aug 24 17:43:37 2018 -0700

    Add top_5 to to eval to resnet (#5178)
    
    * Add top_5 to to eval.
    
    * labels shape to [?] from [?,1] matches unittest.

diff --git a/official/resnet/imagenet_main.py b/official/resnet/imagenet_main.py
index 9ceb95db..b4b65b5b 100644
--- a/official/resnet/imagenet_main.py
+++ b/official/resnet/imagenet_main.py
@@ -97,7 +97,7 @@ def _parse_example_proto(example_serialized):
   feature_map = {
       'image/encoded': tf.FixedLenFeature([], dtype=tf.string,
                                           default_value=''),
-      'image/class/label': tf.FixedLenFeature([1], dtype=tf.int64,
+      'image/class/label': tf.FixedLenFeature([], dtype=tf.int64,
                                               default_value=-1),
       'image/class/text': tf.FixedLenFeature([], dtype=tf.string,
                                              default_value=''),
diff --git a/official/resnet/resnet_run_loop.py b/official/resnet/resnet_run_loop.py
index 8e3f9139..68313968 100644
--- a/official/resnet/resnet_run_loop.py
+++ b/official/resnet/resnet_run_loop.py
@@ -284,14 +284,15 @@ def resnet_model_fn(features, labels, mode, model_class,
     )
 
     def _dense_grad_filter(gvs):
-      '''
-      only apply gradient updates to the final layer. This function is used for
-      fine tuning
+      """Only apply gradient updates to the final layer.
+
+      This function is used for fine tuning.
+
       Args:
-      gvs : list of tuples with gradients and variable info
+        gvs: list of tuples with gradients and variable info
       Returns:
-      filtered gradients so that only the dense layer remains
-      '''
+        filtered gradients so that only the dense layer remains
+      """
       return [(g, v) for g, v in gvs if 'dense' in v.name]
 
     if loss_scale != 1:
@@ -320,12 +321,18 @@ def resnet_model_fn(features, labels, mode, model_class,
     train_op = None
 
   accuracy = tf.metrics.accuracy(labels, predictions['classes'])
-
-  metrics = {'accuracy': accuracy}
+  accuracy_top_5 = tf.metrics.mean(tf.nn.in_top_k(predictions=logits,
+                                                  targets=labels,
+                                                  k=5,
+                                                  name='top_5_op'))
+  metrics = {'accuracy': accuracy,
+             'accuracy_top_5': accuracy_top_5}
 
   # Create a tensor named train_accuracy for logging purposes
   tf.identity(accuracy[1], name='train_accuracy')
+  tf.identity(accuracy_top_5[1], name='train_accuracy_top_5')
   tf.summary.scalar('train_accuracy', accuracy[1])
+  tf.summary.scalar('train_accuracy_top_5', accuracy_top_5[1])
 
   return tf.estimator.EstimatorSpec(
       mode=mode,

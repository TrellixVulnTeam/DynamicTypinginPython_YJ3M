commit c6c78fb4fe0c4006dc5f2a11271050a5a98ec8e5
Author: Nathan Silberman <nsilberman@google.com>
Date:   Tue Aug 30 10:56:19 2016 -0400

    Fixing link in README, updates to notebook variable names, small notebook bug fixes

diff --git a/slim/README.md b/slim/README.md
index 54968e6e..5f84abac 100644
--- a/slim/README.md
+++ b/slim/README.md
@@ -13,7 +13,7 @@ converting them
 to TensorFlow's native TFRecord format and reading them in using TF-Slim's
 data reading and queueing utilities. You can easily train any model on any of
 these datasets, as we demonstrate below. We've also included a
-[jupyter notebook](https://github.com/tensorflow/models/tree/master/slim/slim_walkthrough.ipynb),
+[jupyter notebook](https://github.com/tensorflow/models/blob/master/slim/slim_walkthough.ipynb),
 which provides working examples of how to use TF-Slim for image classification.
 
 
diff --git a/slim/slim_walkthough.ipynb b/slim/slim_walkthough.ipynb
index 47a1f035..a8355a65 100644
--- a/slim/slim_walkthough.ipynb
+++ b/slim/slim_walkthough.ipynb
@@ -31,11 +31,11 @@
     "\n",
     "As of 8/28/16, the latest stable release of TF is r0.10, which does not contain the latest version of slim.\n",
     "To obtain the latest version of TF-Slim, please install the most recent nightly build of TF\n",
-    "as explained [here](https://github.com/nathansilberman/models/tree/master/slim#getting-started).\n",
+    "as explained [here](https://github.com/tensorflow/models/tree/master/slim#installing-latest-version-of-tf-slim).\n",
     "\n",
-    "To use TF-Slim for image classification (as we do in this notebook), you also have to install the TF-Slim image models library from [here](https://github.com/tensorflow/models/tree/master/slim). Let's suppose you install this into a directory called TF_MODELS. Then you should change directory to  TF_MODELS/slim **before** running this notebook, so that all the files are on the path.\n",
+    "To use TF-Slim for image classification (as we do in this notebook), you also have to install the TF-Slim image models library from [here](https://github.com/tensorflow/models/tree/master/slim). Let's suppose you install this into a directory called TF_MODELS. Then you should change directory to  TF_MODELS/slim **before** running this notebook, so that these files are in your python path.\n",
     "\n",
-    "To check you've got these two steps to work, just execute the cell below. It it complains about unknown modules, restart the notebook after moving to the TF-Slim models directory.\n"
+    "To check you've got these two steps to work, just execute the cell below. If it complains about unknown modules, restart the notebook after moving to the TF-Slim models directory.\n"
    ]
   },
   {
@@ -93,41 +93,41 @@
    "outputs": [],
    "source": [
     "def regression_model(inputs, is_training=True, scope=\"deep_regression\"):\n",
-    "  \"\"\"Creates the regression model.\n",
-    "  \n",
-    "  Args:\n",
-    "    input_node: A node that yields a `Tensor` of size [batch_size, dimensions].\n",
-    "    is_training: Whether or not we're currently training the model.\n",
-    "    scope: An optional variable_op scope for the model.\n",
-    "  \n",
-    "  Returns:\n",
-    "    output_node: 1-D `Tensor` of shape [batch_size] of responses.\n",
-    "    nodes: A dict of nodes representing the hidden layers.\n",
-    "  \"\"\"\n",
-    "  with tf.variable_scope(scope, 'deep_regression', [input_node]):\n",
-    "    nodes = {}\n",
-    "    # Set the default weight _regularizer and acvitation for each fully_connected layer.\n",
-    "    with slim.arg_scope([slim.fully_connected],\n",
-    "                        activation_fn=tf.nn.relu,\n",
-    "                        weights_regularizer=slim.l2_regularizer(0.01)):\n",
-    "      \n",
-    "      # Creates a fully connected layer from the inputs with 10 hidden units.\n",
-    "      fc1_node = slim.fully_connected(inputs, 10, scope='fc1')\n",
-    "      nodes['fc1'] = fc1_node\n",
-    "        \n",
-    "      # Adds a dropout layer to prevent over-fitting.\n",
-    "      dropout_node = slim.dropout(fc1_node, 0.8, is_training=is_training)\n",
-    "      \n",
-    "      # Adds another fully connected layer with 5 hidden units.\n",
-    "      fc2_node = slim.fully_connected(dropout_node, 5, scope='fc2')\n",
-    "      nodes['fc2'] = fc2_node\n",
-    "      \n",
-    "      # Creates a fully-connected layer with a single hidden unit. Note that the\n",
-    "      # layer is made linear by setting activation_fn=None.\n",
-    "      prediction_node = slim.fully_connected(fc2_node, 1, activation_fn=None, scope='prediction')\n",
-    "      nodes['out'] = prediction_node\n",
-    "\n",
-    "      return prediction_node, nodes"
+    "    \"\"\"Creates the regression model.\n",
+    "\n",
+    "    Args:\n",
+    "        inputs: A node that yields a `Tensor` of size [batch_size, dimensions].\n",
+    "        is_training: Whether or not we're currently training the model.\n",
+    "        scope: An optional variable_op scope for the model.\n",
+    "\n",
+    "    Returns:\n",
+    "        predictions: 1-D `Tensor` of shape [batch_size] of responses.\n",
+    "        end_points: A dict of end points representing the hidden layers.\n",
+    "    \"\"\"\n",
+    "    with tf.variable_scope(scope, 'deep_regression', [inputs]):\n",
+    "        end_points = {}\n",
+    "        # Set the default weight _regularizer and acvitation for each fully_connected layer.\n",
+    "        with slim.arg_scope([slim.fully_connected],\n",
+    "                            activation_fn=tf.nn.relu,\n",
+    "                            weights_regularizer=slim.l2_regularizer(0.01)):\n",
+    "\n",
+    "            # Creates a fully connected layer from the inputs with 32 hidden units.\n",
+    "            net = slim.fully_connected(inputs, 32, scope='fc1')\n",
+    "            end_points['fc1'] = net\n",
+    "\n",
+    "            # Adds a dropout layer to prevent over-fitting.\n",
+    "            net = slim.dropout(net, 0.8, is_training=is_training)\n",
+    "\n",
+    "            # Adds another fully connected layer with 16 hidden units.\n",
+    "            net = slim.fully_connected(net, 16, scope='fc2')\n",
+    "            end_points['fc2'] = net\n",
+    "\n",
+    "            # Creates a fully-connected layer with a single hidden unit. Note that the\n",
+    "            # layer is made linear by setting activation_fn=None.\n",
+    "            predictions = slim.fully_connected(net, 1, activation_fn=None, scope='prediction')\n",
+    "            end_points['out'] = predictions\n",
+    "\n",
+    "            return predictions, end_points"
    ]
   },
   {
@@ -148,24 +148,23 @@
    "outputs": [],
    "source": [
     "with tf.Graph().as_default():\n",
-    "  # Dummy placeholders for arbitrary number of 1d inputs and outputs\n",
-    "  input_node = tf.placeholder(tf.float32, shape=(None, 1))\n",
-    "  output_node = tf.placeholder(tf.float32, shape=(None, 1))\n",
-    "  \n",
-    "  # Build model\n",
-    "  prediction_node, all_nodes = regression_model(input_node)\n",
-    " \n",
-    "  # Print name and shape of each tensor.\n",
-    "  print \"Layers\"\n",
-    "  for k, v in all_nodes.iteritems():\n",
-    "    print 'name = {}, shape = {}'.format(v.name, v.get_shape())\n",
-    "\n",
-    "  # Print name and shape of parameter nodes  (values not yet initialized)\n",
-    "  print \"\\n\"\n",
-    "  print \"Parameters\"\n",
-    "  for v in slim.get_model_variables():\n",
-    "    print 'name = {}, shape = {}'.format(v.name, v.get_shape())\n",
-    "       "
+    "    # Dummy placeholders for arbitrary number of 1d inputs and outputs\n",
+    "    inputs = tf.placeholder(tf.float32, shape=(None, 1))\n",
+    "    outputs = tf.placeholder(tf.float32, shape=(None, 1))\n",
+    "\n",
+    "    # Build model\n",
+    "    predictions, end_points = regression_model(inputs)\n",
+    "\n",
+    "    # Print name and shape of each tensor.\n",
+    "    print \"Layers\"\n",
+    "    for k, v in end_points.iteritems():\n",
+    "        print 'name = {}, shape = {}'.format(v.name, v.get_shape())\n",
+    "\n",
+    "    # Print name and shape of parameter nodes  (values not yet initialized)\n",
+    "    print \"\\n\"\n",
+    "    print \"Parameters\"\n",
+    "    for v in slim.get_model_variables():\n",
+    "        print 'name = {}, shape = {}'.format(v.name, v.get_shape())\n"
    ]
   },
   {
@@ -186,12 +185,12 @@
    "outputs": [],
    "source": [
     "def produce_batch(batch_size, noise=0.3):\n",
-    "  xs = np.random.random(size=[batch_size, 1]) * 10\n",
-    "  ys = np.sin(xs) + 5 + np.random.normal(size=[batch_size, 1], scale=noise)\n",
-    "  return [xs.astype(np.float32), ys.astype(np.float32)]\n",
+    "    xs = np.random.random(size=[batch_size, 1]) * 10\n",
+    "    ys = np.sin(xs) + 5 + np.random.normal(size=[batch_size, 1], scale=noise)\n",
+    "    return [xs.astype(np.float32), ys.astype(np.float32)]\n",
     "\n",
-    "x_train, y_train = produce_batch(100)\n",
-    "x_test, y_test = produce_batch(100)\n",
+    "x_train, y_train = produce_batch(200)\n",
+    "x_test, y_test = produce_batch(200)\n",
     "plt.scatter(x_train, y_train)"
    ]
   },
@@ -208,22 +207,6 @@
     "- Occasionally store the model checkpoint in the specified directory. This is useful in case your machine crashes  - then you can simply restart from the specified checkpoint."
    ]
   },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {
-    "collapsed": false
-   },
-   "outputs": [],
-   "source": [
-    "# Everytime we run training, we need to store the model checkpoint in a new directory,\n",
-    "# in case anything has changed.\n",
-    "import time\n",
-    "ts = time.time()\n",
-    "ckpt_dir = '/tmp/tf/regression_model/model{}'.format(ts) # Place to store the checkpoint.\n",
-    "print('Saving to {}'.format(ckpt_dir))"
-   ]
-  },
   {
    "cell_type": "code",
    "execution_count": null,
@@ -233,11 +216,12 @@
    "outputs": [],
    "source": [
     "def convert_data_to_tensors(x, y):\n",
-    "  input_tensor = tf.constant(x)\n",
-    "  input_tensor.set_shape([None, 1])\n",
-    "  output_tensor = tf.constant(y)\n",
-    "  output_tensor.set_shape([None, 1])\n",
-    "  return input_tensor, output_tensor"
+    "    inputs = tf.constant(x)\n",
+    "    inputs.set_shape([None, 1])\n",
+    "    \n",
+    "    outputs = tf.constant(y)\n",
+    "    outputs.set_shape([None, 1])\n",
+    "    return inputs, outputs"
    ]
   },
   {
@@ -248,32 +232,34 @@
    },
    "outputs": [],
    "source": [
-    "graph = tf.Graph() # new graph\n",
-    "with graph.as_default():\n",
-    "  input_node, output_node = convert_data_to_tensors(x_train, y_train)\n",
+    "# The following snippet trains the regression model using a sum_of_squares loss.\n",
+    "ckpt_dir = '/tmp/regression_model/'\n",
     "\n",
-    "  # Make the model.\n",
-    "  prediction_node, nodes = regression_model(input_node, is_training=True)\n",
-    " \n",
-    "  # Add the loss function to the graph.\n",
-    "  loss_node = slim.losses.sum_of_squares(prediction_node, output_node)\n",
-    "  # The total loss is the uers's loss plus any regularization losses.\n",
-    "  total_loss_node = slim.losses.get_total_loss()\n",
-    "\n",
-    "  # Create some summaries to visualize the training process:\n",
-    "  ## TODO: add summaries.py to 3p\n",
-    "  #slim.summaries.add_scalar_summary(total_loss, 'Total Loss', print_summary=True)\n",
-    "  \n",
-    "  # Specify the optimizer and create the train op:\n",
-    "  optimizer = tf.train.AdamOptimizer(learning_rate=0.01)\n",
-    "  train_op_node = slim.learning.create_train_op(total_loss_node, optimizer) \n",
-    "\n",
-    "  # Run the training inside a session.\n",
-    "  final_loss = slim.learning.train(\n",
-    "    train_op_node,\n",
-    "    logdir=ckpt_dir,\n",
-    "    number_of_steps=500,\n",
-    "    save_summaries_secs=1)\n",
+    "with tf.Graph().as_default():\n",
+    "    tf.logging.set_verbosity(tf.logging.INFO)\n",
+    "    \n",
+    "    inputs, targets = convert_data_to_tensors(x_train, y_train)\n",
+    "\n",
+    "    # Make the model.\n",
+    "    predictions, nodes = regression_model(inputs, is_training=True)\n",
+    "\n",
+    "    # Add the loss function to the graph.\n",
+    "    loss = slim.losses.sum_of_squares(predictions, targets)\n",
+    "    \n",
+    "    # The total loss is the uers's loss plus any regularization losses.\n",
+    "    total_loss = slim.losses.get_total_loss()\n",
+    "\n",
+    "    # Specify the optimizer and create the train op:\n",
+    "    optimizer = tf.train.AdamOptimizer(learning_rate=0.005)\n",
+    "    train_op = slim.learning.create_train_op(total_loss, optimizer) \n",
+    "\n",
+    "    # Run the training inside a session.\n",
+    "    final_loss = slim.learning.train(\n",
+    "        train_op,\n",
+    "        logdir=ckpt_dir,\n",
+    "        number_of_steps=5000,\n",
+    "        save_summaries_secs=5,\n",
+    "        log_every_n_steps=500)\n",
     "  \n",
     "print(\"Finished training. Last batch loss:\", final_loss)\n",
     "print(\"Checkpoint saved in %s\" % ckpt_dir)"
@@ -298,48 +284,46 @@
    },
    "outputs": [],
    "source": [
-    "graph = tf.Graph()  # Make a new graph\n",
-    "with graph.as_default():\n",
-    "    input_node, output_node = convert_data_to_tensors(x_train, y_train)\n",
-    "    prediction_node, nodes = regression_model(input_node, is_training=True)\n",
+    "with tf.Graph().as_default():\n",
+    "    inputs, targets = convert_data_to_tensors(x_train, y_train)\n",
+    "    predictions, end_points = regression_model(inputs, is_training=True)\n",
     "\n",
     "    # Add multiple loss nodes.\n",
-    "    sum_of_squares_loss_node = slim.losses.sum_of_squares(prediction_node, output_node)\n",
-    "    absolute_difference_loss_node = slim.losses.absolute_difference(prediction_node, output_node)\n",
+    "    sum_of_squares_loss = slim.losses.sum_of_squares(predictions, targets)\n",
+    "    absolute_difference_loss = slim.losses.absolute_difference(predictions, targets)\n",
     "\n",
     "    # The following two ways to compute the total loss are equivalent\n",
-    "    regularization_loss_node = tf.add_n(slim.losses.get_regularization_losses())\n",
-    "    total_loss1_node = sum_of_squares_loss_node + absolute_difference_loss_node + regularization_loss_node\n",
+    "    regularization_loss = tf.add_n(slim.losses.get_regularization_losses())\n",
+    "    total_loss1 = sum_of_squares_loss + absolute_difference_loss + regularization_loss\n",
     "\n",
     "    # Regularization Loss is included in the total loss by default.\n",
     "    # This is good for training, but not for testing.\n",
-    "    total_loss2_node = slim.losses.get_total_loss(add_regularization_losses=True)\n",
+    "    total_loss2 = slim.losses.get_total_loss(add_regularization_losses=True)\n",
+    "    \n",
+    "    init_op = tf.initialize_all_variables()\n",
     "    \n",
-    "    init_node = tf.initialize_all_variables()\n",
     "    with tf.Session() as sess:\n",
-    "        sess.run(init_node) # Will randomize the parameters.\n",
-    "        total_loss1, total_loss2 = sess.run([total_loss1_node, total_loss2_node])\n",
+    "        sess.run(init_op) # Will initialize the parameters with random weights.\n",
+    "        \n",
+    "        total_loss1, total_loss2 = sess.run([total_loss1, total_loss2])\n",
+    "        \n",
     "        print('Total Loss1: %f' % total_loss1)\n",
     "        print('Total Loss2: %f' % total_loss2)\n",
     "\n",
     "        print('Regularization Losses:')\n",
-    "        for loss_node in slim.losses.get_regularization_losses():\n",
-    "            print(loss_node)\n",
+    "        for loss in slim.losses.get_regularization_losses():\n",
+    "            print(loss)\n",
     "\n",
     "        print('Loss Functions:')\n",
-    "        for loss_node in slim.losses.get_losses():\n",
-    "            print(loss_node)"
+    "        for loss in slim.losses.get_losses():\n",
+    "            print(loss)"
    ]
   },
   {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
-    "### Let's load the saved model and use it for prediction.\n",
-    "\n",
-    "The predictive accuracy is not very good, because we used a small model,\n",
-    "and only trained for 500 steps, to keep the demo fast. \n",
-    "Running for 5000 steps improves performance a lot."
+    "### Let's load the saved model and use it for prediction."
    ]
   },
   {
@@ -351,57 +335,28 @@
    "outputs": [],
    "source": [
     "with tf.Graph().as_default():\n",
-    "    input_node, output_node = convert_data_to_tensors(x_test, y_test)\n",
+    "    inputs, targets = convert_data_to_tensors(x_test, y_test)\n",
     "  \n",
     "    # Create the model structure. (Parameters will be loaded below.)\n",
-    "    prediction_node, nodes = regression_model(input_node, is_training=False)\n",
+    "    predictions, end_points = regression_model(inputs, is_training=False)\n",
     "\n",
     "    # Make a session which restores the old parameters from a checkpoint.\n",
     "    sv = tf.train.Supervisor(logdir=ckpt_dir)\n",
     "    with sv.managed_session() as sess:\n",
-    "        inputs, predictions, true_outputs = sess.run([input_node, prediction_node, output_node])\n",
+    "        inputs, predictions, targets = sess.run([inputs, predictions, targets])\n",
     "\n",
-    "plt.scatter(inputs, true_outputs, c='r');\n",
+    "plt.scatter(inputs, targets, c='r');\n",
     "plt.scatter(inputs, predictions, c='b');\n",
     "plt.title('red=true, blue=predicted')"
    ]
   },
-  {
-   "cell_type": "markdown",
-   "metadata": {},
-   "source": [
-    "### Let's examine the learned parameters."
-   ]
-  },
-  {
-   "cell_type": "code",
-   "execution_count": null,
-   "metadata": {
-    "collapsed": false
-   },
-   "outputs": [],
-   "source": [
-    "with tf.Graph().as_default():\n",
-    "    input_node = tf.placeholder(tf.float32, shape=(None, 1))\n",
-    "    output_node = tf.placeholder(tf.float32, shape=(None, 1))\n",
-    "    prediction_node, nodes = regression_model(input_node, is_training=False)\n",
-    "  \n",
-    "    sv = tf.train.Supervisor(logdir=ckpt_dir)\n",
-    "    with sv.managed_session() as sess:\n",
-    "        model_variables = slim.get_model_variables()\n",
-    "        for v in model_variables:\n",
-    "            val = sess.run(v)\n",
-    "            print v.name, val.shape, val\n"
-   ]
-  },
   {
    "cell_type": "markdown",
    "metadata": {},
    "source": [
     "### Let's compute various evaluation metrics on the test set.\n",
     "\n",
-    "In slim termiology, losses are optimized, but metrics (which may not be differentiable, e.g., precision and recall) are just measured.\n",
-    "As an illustration, the code below computes mean squared error and mean absolute error metrics on the test set.\n",
+    "In TF-Slim termiology, losses are optimized, but metrics (which may not be differentiable, e.g., precision and recall) are just measured. As an illustration, the code below computes mean squared error and mean absolute error metrics on the test set.\n",
     "\n",
     "Each metric declaration creates several local variables (which must be initialized via tf.initialize_local_variables()) and returns both a value_op and an update_op. When evaluated, the value_op returns the current value of the metric. The update_op loads a new batch of data, runs the model, obtains the predictions and accumulates the metric statistics appropriately before returning the current value of the metric. We store these value nodes and update nodes in 2 dictionaries.\n",
     "\n",
@@ -417,27 +372,21 @@
    "outputs": [],
    "source": [
     "with tf.Graph().as_default():\n",
-    "    input_node, output_node = convert_data_to_tensors(x_test, y_test)\n",
-    "    prediction_node, nodes = regression_model(input_node, is_training=False)\n",
+    "    inputs, targets = convert_data_to_tensors(x_test, y_test)\n",
+    "    predictions, end_points = regression_model(inputs, is_training=False)\n",
     "\n",
     "    # Specify metrics to evaluate:\n",
     "    names_to_value_nodes, names_to_update_nodes = slim.metrics.aggregate_metric_map({\n",
-    "      'Mean Squared Error': slim.metrics.streaming_mean_squared_error(prediction_node, output_node),\n",
-    "      'Mean Absolute Error': slim.metrics.streaming_mean_absolute_error(prediction_node, output_node)\n",
+    "      'Mean Squared Error': slim.metrics.streaming_mean_squared_error(predictions, targets),\n",
+    "      'Mean Absolute Error': slim.metrics.streaming_mean_absolute_error(predictions, targets)\n",
     "    })\n",
     "\n",
-    "\n",
-    "    init_node = tf.group(\n",
-    "        tf.initialize_all_variables(),\n",
-    "        tf.initialize_local_variables())\n",
-    "\n",
     "    # Make a session which restores the old graph parameters, and then run eval.\n",
     "    sv = tf.train.Supervisor(logdir=ckpt_dir)\n",
     "    with sv.managed_session() as sess:\n",
     "        metric_values = slim.evaluation.evaluation(\n",
     "            sess,\n",
     "            num_evals=1, # Single pass over data\n",
-    "            init_op=init_node,\n",
     "            eval_op=names_to_update_nodes.values(),\n",
     "            final_op=names_to_value_nodes.values())\n",
     "\n",
@@ -496,11 +445,15 @@
    },
    "outputs": [],
    "source": [
+    "import tensorflow as tf\n",
     "from datasets import dataset_utils\n",
     "\n",
     "url = \"http://download.tensorflow.org/data/flowers.tar.gz\"\n",
     "flowers_data_dir = '/tmp/flowers'\n",
     "\n",
+    "if not tf.gfile.Exists(flowers_data_dir):\n",
+    "    tf.gfile.MakeDirs(flowers_data_dir)\n",
+    "\n",
     "dataset_utils.download_and_uncompress_tarball(url, flowers_data_dir) "
    ]
   },
@@ -665,6 +618,11 @@
     "      height: The size of each image after preprocessing.\n",
     "      width: The size of each image after preprocessing.\n",
     "      is_training: Whether or not we're currently training or evaluating.\n",
+    "    \n",
+    "    Returns:\n",
+    "      images: A Tensor of size [batch_size, height, width, 3], image samples that have been preprocessed.\n",
+    "      images_raw: A Tensor of size [batch_size, height, width, 3], image samples that can be used for visualization.\n",
+    "      labels: A Tensor of size [batch_size], whose values range between 0 and dataset.num_classes.\n",
     "    \"\"\"\n",
     "    data_provider = slim.dataset_data_provider.DatasetDataProvider(\n",
     "        dataset, common_queue_capacity=32,\n",
@@ -701,7 +659,7 @@
     "\n",
     "# This might take a few minutes.\n",
     "train_dir = '/tmp/tfslim_model/'\n",
-    "print('Will save model to %s' % CHECKPOINT_DIR)\n",
+    "print('Will save model to %s' % train_dir)\n",
     "\n",
     "with tf.Graph().as_default():\n",
     "    tf.logging.set_verbosity(tf.logging.INFO)\n",
@@ -771,7 +729,7 @@
     "    })\n",
     "\n",
     "    print('Running evaluation Loop...')\n",
-    "    checkpoint_path = tf.train.latest_checkpoint(CHECKPOINT_DIR)\n",
+    "    checkpoint_path = tf.train.latest_checkpoint(train_dir)\n",
     "    metric_values = slim.evaluation.evaluate_once(\n",
     "        master='',\n",
     "        checkpoint_path=checkpoint_path,\n",
@@ -795,7 +753,7 @@
     "However, this  means they must be trained on big datasets. Since this process is slow, we provide various pre-trained models - see the list [here](https://github.com/tensorflow/models/tree/master/slim#pre-trained-models).\n",
     "\n",
     "\n",
-    "You can either use these models as-is, or you can perform \"surgery\" on them, to modify them for some other task. For example, it is common to \"chop off\" the final pre-softmax layer, and replace it with a new set of weights corresponding to some new set of labels. You can then quickly fine tune the new model on a small new dataset. We illustrate this below, using inception-v3 as the base model.\n"
+    "You can either use these models as-is, or you can perform \"surgery\" on them, to modify them for some other task. For example, it is common to \"chop off\" the final pre-softmax layer, and replace it with a new set of weights corresponding to some new set of labels. You can then quickly fine tune the new model on a small new dataset. We illustrate this below, using inception-v1 as the base model. While models like Inception V3 are more powerful, Inception V1 is used for speed purposes.\n"
    ]
   },
   {
@@ -820,6 +778,9 @@
     "url = \"http://download.tensorflow.org/models/inception_v1_2016_08_28.tar.gz\"\n",
     "checkpoints_dir = '/tmp/checkpoints'\n",
     "\n",
+    "if not tf.gfile.Exists(checkpoints_dir):\n",
+    "    tf.gfile.MakeDirs(checkpoints_dir)\n",
+    "\n",
     "dataset_utils.download_and_uncompress_tarball(url, checkpoints_dir)"
    ]
   },
@@ -855,14 +816,16 @@
     "slim = tf.contrib.slim\n",
     "\n",
     "batch_size = 3\n",
+    "image_size = inception.inception_v1.default_image_size\n",
     "\n",
     "with tf.Graph().as_default():\n",
     "    url = 'https://upload.wikimedia.org/wikipedia/commons/7/70/EnglishCockerSpaniel_simon.jpg'\n",
     "    image_string = urllib2.urlopen(url).read()\n",
     "    image = tf.image.decode_jpeg(image_string, channels=3)\n",
-    "    processed_image = inception_preprocessing.preprocess_image(image, 224, 224, is_training=False)\n",
+    "    processed_image = inception_preprocessing.preprocess_image(image, image_size, image_size, is_training=False)\n",
     "    processed_images  = tf.expand_dims(processed_image, 0)\n",
     "    \n",
+    "    # Create the model, use the default arg scope to configure the batch norm parameters.\n",
     "    with slim.arg_scope(inception.inception_v1_arg_scope()):\n",
     "        logits, _ = inception.inception_v1(processed_images, num_classes=1001, is_training=False)\n",
     "    probabilities = tf.nn.softmax(logits)\n",
@@ -875,14 +838,12 @@
     "        init_fn(sess)\n",
     "        np_image, probabilities = sess.run([image, probabilities])\n",
     "        probabilities = probabilities[0, 0:]\n",
-    "        sorted_inds = [i[0] for i in sorted(enumerate(probabilities), key=lambda x:x[1])]\n",
+    "        sorted_inds = [i[0] for i in sorted(enumerate(-probabilities), key=lambda x:x[1])]\n",
     "        \n",
     "    plt.figure()\n",
     "    plt.imshow(np_image.astype(np.uint8))\n",
     "    plt.axis('off')\n",
     "    plt.show()\n",
-    "    \n",
-    "    sorted_inds = [i[0] for i in sorted(enumerate(-probabilities), key=lambda x:x[1])]\n",
     "\n",
     "    names = imagenet.create_readable_names_for_imagenet_labels()\n",
     "    for i in range(5):\n",
@@ -907,6 +868,8 @@
    },
    "outputs": [],
    "source": [
+    "# Note that this may take several minutes.\n",
+    "\n",
     "import os\n",
     "\n",
     "from datasets import flowers\n",
@@ -914,6 +877,7 @@
     "from preprocessing import inception_preprocessing\n",
     "\n",
     "slim = tf.contrib.slim\n",
+    "image_size = inception.inception_v1.default_image_size\n",
     "\n",
     "\n",
     "def get_init_fn():\n",
@@ -943,9 +907,9 @@
     "    tf.logging.set_verbosity(tf.logging.INFO)\n",
     "    \n",
     "    dataset = flowers.get_split('train', flowers_data_dir)\n",
-    "    images, _, labels = load_batch(dataset, height=224, width=224)\n",
+    "    images, _, labels = load_batch(dataset, height=image_size, width=image_size)\n",
     "    \n",
-    "    # Create the model:\n",
+    "    # Create the model, use the default arg scope to configure the batch norm parameters.\n",
     "    with slim.arg_scope(inception.inception_v1_arg_scope()):\n",
     "        logits, _ = inception.inception_v1(images, num_classes=dataset.num_classes, is_training=True)\n",
     "        \n",
@@ -994,15 +958,16 @@
     "\n",
     "slim = tf.contrib.slim\n",
     "\n",
+    "image_size = inception.inception_v1.default_image_size\n",
     "batch_size = 3\n",
     "\n",
     "with tf.Graph().as_default():\n",
     "    tf.logging.set_verbosity(tf.logging.INFO)\n",
     "    \n",
     "    dataset = flowers.get_split('train', flowers_data_dir)\n",
-    "    images, images_raw, labels = load_batch(dataset, height=224, width=224)\n",
+    "    images, images_raw, labels = load_batch(dataset, height=image_size, width=image_size)\n",
     "    \n",
-    "    # Create the model:\n",
+    "    # Create the model, use the default arg scope to configure the batch norm parameters.\n",
     "    with slim.arg_scope(inception.inception_v1_arg_scope()):\n",
     "        logits, _ = inception.inception_v1(images, num_classes=dataset.num_classes, is_training=True)\n",
     "\n",

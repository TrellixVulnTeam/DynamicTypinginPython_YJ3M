commit 9927cfecf75e9a1e9fc1491abd449c5161877107
Author: Daniel Greenfeld <danny@eventbrite.com>
Date:   Sat Nov 8 11:52:08 2014 -0300

    Switched to use a direct port of the Python 3 'which' function

diff --git a/cookiecutter/compat.py b/cookiecutter/compat.py
index f4eef6c..b2bdb36 100644
--- a/cookiecutter/compat.py
+++ b/cookiecutter/compat.py
@@ -82,24 +82,66 @@ else:  # Forced testing
         """
         return os.path.isfile(program) and os.access(program, os.X_OK)
 
-    def which(shell_command):
+    def which(cmd, mode=os.F_OK | os.X_OK, path=None):
+        """Given a command, mode, and a PATH string, return the path which
+        conforms to the given mode on the PATH, or None if there is no such
+        file.
+        `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result
+        of os.environ.get("PATH"), or can be overridden with a custom search
+        path.
+
+        Note: This function was backported from the Python 3 source code.
         """
-        Returns the location of the shell command or None if it does not exist.
-
-        :param shell_command: The name of a shell command.
-        """
-        # http://stackoverflow.com/questions/377017/test-if-executable-exists-in-python
-        fpath, fname = os.path.split(shell_command)
-        if fpath:
-            if is_exe(shell_command):
-                return shell_command
+        # Check that a given file can be accessed with the correct mode.
+        # Additionally check that `file` is not a directory, as on Windows
+        # directories pass the os.access check.
+        def _access_check(fn, mode):
+            return (os.path.exists(fn) and os.access(fn, mode)
+                    and not os.path.isdir(fn))
+
+        # If we're given a path with a directory part, look it up directly
+        # rather than referring to PATH directories. This includes checking
+        # relative to the current directory, e.g. ./script
+        if os.path.dirname(cmd):
+            if _access_check(cmd, mode):
+                return cmd
+            return None
+
+        if path is None:
+            path = os.environ.get("PATH", os.defpath)
+        if not path:
+            return None
+        path = path.split(os.pathsep)
+
+        if sys.platform == "win32":
+            # The current directory takes precedence on Windows.
+            if os.curdir not in path:
+                path.insert(0, os.curdir)
+
+            # PATHEXT is necessary to check on Windows.
+            pathext = os.environ.get("PATHEXT", "").split(os.pathsep)
+            # See if the given file matches any of the expected path
+            # extensions. This will allow us to short circuit when given
+            # "python.exe". If it does match, only test that one, otherwise we
+            # have to try others.
+            if any(cmd.lower().endswith(ext.lower()) for ext in pathext):
+                files = [cmd]
+            else:
+                files = [cmd + ext for ext in pathext]
         else:
-            for path in os.environ["PATH"].split(os.pathsep):
-                path = path.strip('"')
-                exe_file = os.path.join(path, shell_command)
-                if is_exe(exe_file):
-                    return exe_file
-
+            # On other platforms you don't have things like PATHEXT to tell you
+            # what file suffixes are executable, so just pass on cmd as-is.
+            files = [cmd]
+
+        seen = set()
+        for dir in path:
+            normdir = os.path.normcase(dir)
+            if normdir not in seen:
+                seen.add(normdir)
+                for thefile in files:
+                    name = os.path.join(dir, thefile)
+                    if _access_check(name, mode):
+                        return name
         return None
 
 _hush_pyflakes = (patch, StringIO, json, OrderedDict, unittest, which)

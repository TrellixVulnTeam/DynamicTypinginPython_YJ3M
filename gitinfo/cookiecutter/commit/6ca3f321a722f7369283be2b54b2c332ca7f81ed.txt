commit 6ca3f321a722f7369283be2b54b2c332ca7f81ed
Author: Russell Keith-Magee <russell@keith-magee.com>
Date:   Sat Jun 17 11:31:56 2017 +0800

    Added support for downloading and templating from Zip files.

diff --git a/cookiecutter/repository.py b/cookiecutter/repository.py
index 0eb9c7c..f0cf80f 100644
--- a/cookiecutter/repository.py
+++ b/cookiecutter/repository.py
@@ -8,6 +8,7 @@ import re
 
 from .exceptions import RepositoryNotFound
 from .vcs import clone
+from .zipfile import unzip
 
 REPO_REGEX = re.compile(r"""
 (?x)
@@ -23,6 +24,11 @@ def is_repo_url(value):
     return bool(REPO_REGEX.match(value))
 
 
+def is_zip_file(value):
+    """Return True if value is a repository URL."""
+    return value.endswith('.zip')
+
+
 def expand_abbreviations(template, abbreviations):
     """Expand abbreviations in a template name.
 
@@ -76,7 +82,15 @@ def determine_repo_dir(template, abbreviations, clone_to_dir, checkout,
     """
     template = expand_abbreviations(template, abbreviations)
 
-    if is_repo_url(template):
+    if is_zip_file(template):
+        unzipped_dir = unzip(
+            zip_url=template,
+            is_url=is_repo_url(template),
+            clone_to_dir=clone_to_dir,
+            no_input=no_input
+        )
+        repository_candidates = [unzipped_dir]
+    elif is_repo_url(template):
         cloned_repo = clone(
             repo_url=template,
             checkout=checkout,
diff --git a/cookiecutter/zipfile.py b/cookiecutter/zipfile.py
new file mode 100644
index 0000000..328d0aa
--- /dev/null
+++ b/cookiecutter/zipfile.py
@@ -0,0 +1,86 @@
+import os
+import requests
+import shutil
+import sys
+from zipfile import ZipFile
+
+from .prompt import read_user_yes_no
+from .utils import make_sure_path_exists, rmtree
+
+
+def prompt_and_delete(path, no_input=False):
+    """Ask the user whether it's okay to delete the previously-downloaded file/directory.
+
+    If yes, deletes it. Otherwise, Cookiecutter exits.
+
+    :param path: Previously downloaded zipfile.
+    :param no_input: Suppress prompt to delete repo and just delete it.
+    """
+    # Suppress prompt if called via API
+    if no_input:
+        ok_to_delete = True
+    else:
+        question = (
+            "You've downloaded {} before. "
+            "Is it okay to delete and re-download it?"
+        ).format(path)
+
+        ok_to_delete = read_user_yes_no(question, 'yes')
+
+    if ok_to_delete:
+        if os.path.isdir(path):
+            rmtree(path)
+        else:
+            os.remove(path)
+    else:
+        sys.exit()
+
+    return ok_to_delete
+
+
+def unzip(zip_url, is_url, clone_to_dir='.', no_input=False):
+    # Ensure that clone_to_dir exists
+    clone_to_dir = os.path.expanduser(clone_to_dir)
+    make_sure_path_exists(clone_to_dir)
+
+    if is_url:
+        # Build the name of the cached zipfile,
+        # and prompt to delete if it already exists.
+        identifier = zip_url.rsplit('/', 1)[1]
+        zip_path = os.path.join(clone_to_dir, identifier)
+
+        if os.path.exists(zip_path):
+            ok_to_delete = prompt_and_delete(zip_path, no_input=no_input)
+        else:
+            ok_to_delete = None
+
+        # (Re) download the zipfile
+        r = requests.get(zip_url, stream=True)
+        with open(zip_path, 'wb') as f:
+            for chunk in r.iter_content(chunk_size=1024):
+                if chunk: # filter out keep-alive new chunks
+                    f.write(chunk)
+    else:
+        # Just use the local zipfile as-is.
+        zip_path = os.path.abspath(zip_url)
+        ok_to_delete = None
+
+    # Now unpack the repository. The zipfile will include
+    # the name of the template as the top level directory;
+    # Check if that directory already exists, and if so,
+    # prompt for deletion. If we've previously OK'd deletion,
+    # don't ask again.
+    zip_file = ZipFile(zip_path)
+    unzip_name = zip_file.namelist()[0][:-1]
+
+    unzip_path = os.path.join(clone_to_dir, unzip_name)
+    if os.path.exists(unzip_path):
+        if ok_to_delete is None:
+            ok_to_delete = prompt_and_delete(unzip_path, no_input=no_input)
+        else:
+            rmtree(unzip_path)
+
+    # Extract the zip file
+    zip_file.extractall(path=clone_to_dir)
+
+    return unzip_path
diff --git a/setup.py b/setup.py
index 44f9c6f..cd8fd05 100644
--- a/setup.py
+++ b/setup.py
@@ -29,7 +29,8 @@ requirements = [
     'click>=5.0',
     'whichcraft>=0.4.0',
     'poyo>=0.1.0',
-    'jinja2-time>=0.1.0'
+    'jinja2-time>=0.1.0',
+    'requests>=2.18.0',
 ]
 
 if sys.argv[-1] == 'readme':
diff --git a/tests/files/fake-repo-tmpl.zip b/tests/files/fake-repo-tmpl.zip
new file mode 100644
index 0000000..ddeb548
Binary files /dev/null and b/tests/files/fake-repo-tmpl.zip differ
diff --git a/tests/repository/test_determine_repo_dir_clones_repo.py b/tests/repository/test_determine_repo_dir_clones_repo.py
index cff8dd4..c6d916a 100644
--- a/tests/repository/test_determine_repo_dir_clones_repo.py
+++ b/tests/repository/test_determine_repo_dir_clones_repo.py
@@ -6,6 +6,47 @@ import pytest
 from cookiecutter import repository, exceptions
 
 
+@pytest.fixture(params=[
+    ('/path/to/zipfile.zip', False),
+    ('https://example.com/path/to/zipfile.zip', True),
+    ('http://example.com/path/to/zipfile.zip', True),
+])
+def zipfile(request):
+    return request.param
+
+
+def test_zipfile_unzip(
+        mocker, zipfile, user_config_data):
+    """`unzip()` should be called with correct args when
+    `determine_repo_dir()` is passed a zipfile, or a URL
+    to a zipfile.
+    """
+
+    mock_clone = mocker.patch(
+        'cookiecutter.repository.unzip',
+        return_value='tests/fake-repo-tmpl',
+        autospec=True
+    )
+
+    project_dir = repository.determine_repo_dir(
+        zipfile[0],
+        abbreviations={},
+        clone_to_dir=user_config_data['cookiecutters_dir'],
+        checkout=None,
+        no_input=True
+    )
+
+    mock_clone.assert_called_once_with(
+        zip_url=zipfile[0],
+        is_url=zipfile[1],
+        clone_to_dir=user_config_data['cookiecutters_dir'],
+        no_input=True
+    )
+
+    assert os.path.isdir(project_dir)
+    assert 'tests/fake-repo-tmpl' == project_dir
+
+
 @pytest.fixture
 def template_url():
     """URL to example Cookiecutter template on GitHub.
diff --git a/tests/repository/test_is_repo_url.py b/tests/repository/test_is_repo_url.py
index a29153c..53da129 100644
--- a/tests/repository/test_is_repo_url.py
+++ b/tests/repository/test_is_repo_url.py
@@ -2,7 +2,21 @@
 import pytest
 
 from cookiecutter.config import BUILTIN_ABBREVIATIONS
-from cookiecutter.repository import is_repo_url, expand_abbreviations
+from cookiecutter.repository import is_zip_file, is_repo_url, expand_abbreviations
+
+
+@pytest.fixture(params=[
+    '/path/to/zipfile.zip',
+    'https://example.com/path/to/zipfile.zip',
+    'http://example.com/path/to/zipfile.zip',
+])
+def zipfile(request):
+    return request.param
+
+
+def test_is_zip_file(zipfile):
+    """Verify is_repo_url works."""
+    assert is_zip_file(zipfile) is True
 
 
 @pytest.fixture(params=[
diff --git a/tests/zipfile/test_prompt_and_delete.py b/tests/zipfile/test_prompt_and_delete.py
new file mode 100644
index 0000000..cb8ff5a
--- /dev/null
+++ b/tests/zipfile/test_prompt_and_delete.py
@@ -0,0 +1,111 @@
+# -*- coding: utf-8 -*-
+import pytest
+
+from cookiecutter import zipfile
+
+
+def test_prompt_should_ask_and_rm_dir(mocker, tmpdir):
+    """In `prompt_and_delete()`, if the user agrees to delete/reclone the
+    repo, the repo should be deleted.
+    """
+    mock_read_user = mocker.patch(
+        'cookiecutter.zipfile.read_user_yes_no',
+        return_value=True,
+        autospec=True
+    )
+    dir = tmpdir.mkdir('repo')
+
+    zipfile.prompt_and_delete(str(dir))
+
+    assert mock_read_user.called
+    assert not dir.exists()
+
+
+def test_prompt_should_ask_and_keep_dir(mocker, tmpdir):
+    """In `prompt_and_delete()`, if the user wants to keep their old
+    cloned template repo, it should not be deleted.
+    """
+    mock_read_user = mocker.patch(
+        'cookiecutter.zipfile.read_user_yes_no',
+        return_value=False,
+        autospec=True
+    )
+    dir = tmpdir.mkdir('repo')
+
+    with pytest.raises(SystemExit):
+        zipfile.prompt_and_delete(str(dir))
+
+    assert mock_read_user.called
+    assert dir.exists()
+
+
+def test_prompt_should_not_ask_if_no_input_and_rm_dir(mocker, tmpdir):
+    """In `prompt_and_delete()`, if `no_input` is True, the call to
+    `zipfile.read_user_yes_no()` should be suppressed.
+    """
+    mock_read_user = mocker.patch(
+        'cookiecutter.zipfile.read_user_yes_no',
+        return_value=True,
+        autospec=True
+    )
+    dir = tmpdir.mkdir('repo')
+
+    zipfile.prompt_and_delete(str(dir), no_input=True)
+
+    assert not mock_read_user.called
+    assert not dir.exists()
+
+
+def test_prompt_should_ask_and_rm_file(mocker, tmpdir):
+    """In `prompt_and_delete()`, if the user agrees to delete/reclone the
+    template zipfile, the zipfile should be deleted.
+    """
+    mock_read_user = mocker.patch(
+        'cookiecutter.zipfile.read_user_yes_no',
+        return_value=True,
+        autospec=True
+    )
+    file = tmpdir.join('repo.zip')
+    file.write('this is zipfile content')
+
+    zipfile.prompt_and_delete(str(file))
+
+    assert mock_read_user.called
+    assert not file.exists()
+
+
+def test_prompt_should_ask_and_keep_file(mocker, tmpdir):
+    """In `prompt_and_delete()`, if the user wants to keep their old
+    downloaded template zipfile, it should not be deleted.
+    """
+    mock_read_user = mocker.patch(
+        'cookiecutter.zipfile.read_user_yes_no',
+        return_value=False,
+        autospec=True
+    )
+    file = tmpdir.join('repo.zip')
+    file.write('this is zipfile content')
+
+    with pytest.raises(SystemExit):
+        zipfile.prompt_and_delete(str(file))
+
+    assert mock_read_user.called
+    assert file.exists()
+
+
+def test_prompt_should_not_ask_if_no_input_and_rm_file(mocker, tmpdir):
+    """In `prompt_and_delete()`, if `no_input` is True, the call to
+    `zipfile.read_user_yes_no()` should be suppressed.
+    """
+    mock_read_user = mocker.patch(
+        'cookiecutter.zipfile.read_user_yes_no',
+        return_value=True,
+        autospec=True
+    )
+    file = tmpdir.join('repo.zip')
+    file.write('this is zipfile content')
+
+    zipfile.prompt_and_delete(str(file), no_input=True)
+
+    assert not mock_read_user.called
+    assert not file.exists()
diff --git a/tests/zipfile/test_unzip.py b/tests/zipfile/test_unzip.py
new file mode 100644
index 0000000..1142301
--- /dev/null
+++ b/tests/zipfile/test_unzip.py
@@ -0,0 +1,244 @@
+# -*- coding: utf-8 -*-
+import os
+from unittest.mock import MagicMock
+
+import pytest
+
+from cookiecutter import exceptions, zipfile
+
+
+def test_unzip_local_file(mocker, tmpdir):
+    """In `unzip()`, a local file reference is just unzipped where it is.
+    """
+    mock_prompt_and_delete = mocker.patch(
+        'cookiecutter.zipfile.prompt_and_delete',
+        return_value=True,
+        autospec=True
+    )
+
+    clone_to_dir = tmpdir.mkdir('clone')
+
+    output_dir = zipfile.unzip(
+        'tests/files/fake-repo-tmpl.zip',
+        is_url=False,
+        clone_to_dir=str(clone_to_dir)
+    )
+
+    assert output_dir == os.path.join(str(clone_to_dir), 'fake-repo-tmpl')
+    assert not mock_prompt_and_delete.called
+
+
+def test_unzip_should_abort_if_user_does_not_want_to_overwrite_template(mocker, tmpdir):
+    """In `unzip()`, if user doesn't want to overwrite an existing cached
+    template, Cookiecutter should exit.
+    """
+    mocker.patch(
+        'cookiecutter.zipfile.prompt_and_delete',
+        side_effect=SystemExit,
+        autospec=True
+    )
+
+    clone_to_dir = tmpdir.mkdir('clone')
+    existing_tmpl = clone_to_dir.mkdir('fake-repo-tmpl')
+
+    with pytest.raises(SystemExit):
+        zipfile.unzip(
+            'tests/files/fake-repo-tmpl.zip',
+            is_url=False,
+            clone_to_dir=str(clone_to_dir)
+        )
+
+
+def test_unzip_url(mocker, tmpdir):
+    """In `unzip()`, a url will be downloaded and unzipped
+    """
+    mock_prompt_and_delete = mocker.patch(
+        'cookiecutter.zipfile.prompt_and_delete',
+        return_value=True,
+        autospec=True
+    )
+
+    def mock_download():
+        with open('tests/files/fake-repo-tmpl.zip', 'rb') as zipfile:
+            chunk = zipfile.read(1024)
+            while chunk:
+                yield chunk
+                chunk = zipfile.read(1024)
+
+    request = MagicMock()
+    request.iter_content.return_value = mock_download()
+
+    mock_requests_get = mocker.patch(
+        'cookiecutter.zipfile.requests.get',
+        return_value=request,
+        autospec=True,
+    )
+
+    clone_to_dir = tmpdir.mkdir('clone')
+
+    output_dir = zipfile.unzip(
+        'https://example.com/path/to/fake-repo-tmpl.zip',
+        is_url=True,
+        clone_to_dir=str(clone_to_dir)
+    )
+
+    assert output_dir == os.path.join(str(clone_to_dir), 'fake-repo-tmpl')
+    assert not mock_prompt_and_delete.called
+
+
+def test_unzip_url_existing_cache(mocker, tmpdir):
+    """In `unzip()`, a url will be downloaded and unzipped; an existing zip file
+    will be removed.
+    """
+    mock_prompt_and_delete = mocker.patch(
+        'cookiecutter.zipfile.prompt_and_delete',
+        return_value=True,
+        autospec=True
+    )
+
+    def mock_download():
+        with open('tests/files/fake-repo-tmpl.zip', 'rb') as zipfile:
+            chunk = zipfile.read(1024)
+            while chunk:
+                yield chunk
+                chunk = zipfile.read(1024)
+
+    request = MagicMock()
+    request.iter_content.return_value = mock_download()
+
+    mock_requests_get = mocker.patch(
+        'cookiecutter.zipfile.requests.get',
+        return_value=request,
+        autospec=True,
+    )
+
+    clone_to_dir = tmpdir.mkdir('clone')
+
+    # Create an existing cache of the zipfile
+    existing_zip = clone_to_dir.join('fake-repo-tmpl.zip')
+    existing_zip.write('This is an existing zipfile')
+
+    output_dir = zipfile.unzip(
+        'https://example.com/path/to/fake-repo-tmpl.zip',
+        is_url=True,
+        clone_to_dir=str(clone_to_dir)
+    )
+
+    assert output_dir == os.path.join(str(clone_to_dir), 'fake-repo-tmpl')
+    assert mock_prompt_and_delete.call_count == 1
+
+
+def test_unzip_url_existing_template(mocker, tmpdir):
+    """In `unzip()`, a url will be downloaded and unzipped; an existing
+    template directory will be removed
+    """
+    mock_prompt_and_delete = mocker.patch(
+        'cookiecutter.zipfile.prompt_and_delete',
+        return_value=True,
+        autospec=True
+    )
+
+    def mock_download():
+        with open('tests/files/fake-repo-tmpl.zip', 'rb') as zipfile:
+            chunk = zipfile.read(1024)
+            while chunk:
+                yield chunk
+                chunk = zipfile.read(1024)
+
+    request = MagicMock()
+    request.iter_content.return_value = mock_download()
+
+    mock_requests_get = mocker.patch(
+        'cookiecutter.zipfile.requests.get',
+        return_value=request,
+        autospec=True,
+    )
+
+    clone_to_dir = tmpdir.mkdir('clone')
+
+    # Create an existing rolled out template directory
+    existing_template = clone_to_dir.mkdir('fake-repo-tmpl')
+
+    output_dir = zipfile.unzip(
+        'https://example.com/path/to/fake-repo-tmpl.zip',
+        is_url=True,
+        clone_to_dir=str(clone_to_dir)
+    )
+
+    assert output_dir == os.path.join(str(clone_to_dir), 'fake-repo-tmpl')
+    assert mock_prompt_and_delete.call_count == 1
+
+
+def test_unzip_url_existing_cache_and_template(mocker, tmpdir):
+    """In `unzip()`, a url will be downloaded and unzipped; an existing
+    zipfile cache and template directory will both be removed
+    """
+    mock_prompt_and_delete = mocker.patch(
+        'cookiecutter.zipfile.prompt_and_delete',
+        return_value=True,
+        autospec=True
+    )
+
+    def mock_download():
+        with open('tests/files/fake-repo-tmpl.zip', 'rb') as zipfile:
+            chunk = zipfile.read(1024)
+            while chunk:
+                yield chunk
+                chunk = zipfile.read(1024)
+
+    request = MagicMock()
+    request.iter_content.return_value = mock_download()
+
+    mock_requests_get = mocker.patch(
+        'cookiecutter.zipfile.requests.get',
+        return_value=request,
+        autospec=True,
+    )
+
+    clone_to_dir = tmpdir.mkdir('clone')
+
+    # Create an existing cache of the zipfile
+    existing_zip = clone_to_dir.join('fake-repo-tmpl.zip')
+    existing_zip.write('This is an existing zipfile')
+
+    # Create an existing rolled out template directory
+    existing_template = clone_to_dir.mkdir('fake-repo-tmpl')
+
+    output_dir = zipfile.unzip(
+        'https://example.com/path/to/fake-repo-tmpl.zip',
+        is_url=True,
+        clone_to_dir=str(clone_to_dir)
+    )
+
+    assert output_dir == os.path.join(str(clone_to_dir), 'fake-repo-tmpl')
+    assert mock_prompt_and_delete.call_count == 1
+
+
+def test_unzip_should_abort_if_user_does_not_want_to_redownload(mocker, tmpdir):
+    """In `unzip()`, if user doesn't want to download, Cookiecutter should exit
+    without cloning anything.
+    """
+    mocker.patch(
+        'cookiecutter.zipfile.prompt_and_delete',
+        side_effect=SystemExit,
+        autospec=True
+    )
+
+    mock_requests_get = mocker.patch(
+        'cookiecutter.zipfile.requests.get',
+        autospec=True,
+    )
+
+    clone_to_dir = tmpdir.mkdir('clone')
+
+    # Create an existing cache of the zipfile
+    existing_zip = clone_to_dir.join('fake-repo-tmpl.zip')
+    existing_zip.write('This is an existing zipfile')
+
+    zipfile_url = 'https://example.com/path/to/fake-repo-tmpl.zip'
+
+    with pytest.raises(SystemExit):
+        zipfile.unzip(zipfile_url, is_url=True, clone_to_dir=str(clone_to_dir))
+
+    assert not mock_requests_get.called
+

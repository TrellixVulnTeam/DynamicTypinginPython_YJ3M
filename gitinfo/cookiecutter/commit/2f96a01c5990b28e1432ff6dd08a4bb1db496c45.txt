commit 2f96a01c5990b28e1432ff6dd08a4bb1db496c45
Author: Raphael Pierzina <raphael@hackebrot.de>
Date:   Sat Aug 15 22:45:50 2015 +0200

    Split out replay tests into folder and create test data

diff --git a/cookiecutter/replay.py b/cookiecutter/replay.py
index 054c31b..af19083 100644
--- a/cookiecutter/replay.py
+++ b/cookiecutter/replay.py
@@ -27,6 +27,9 @@ def dump(template_name, context):
     if not isinstance(context, dict):
         raise TypeError('Context is required to be of type dict')
 
+    if not 'cookiecutter' in context:
+        raise ValueError('Context is required to contain a cookiecutter key')
+
     replay_dir = get_user_config()['replay_dir']
 
     if not make_sure_path_exists(replay_dir):
@@ -46,4 +49,9 @@ def load(template_name):
     replay_file = get_file_name(replay_dir, template_name)
 
     with open(replay_file, 'r') as infile:
-        return json.load(infile)
+        context = json.load(infile)
+
+    if not 'cookiecutter' in context:
+        raise ValueError('Context is required to contain a cookiecutter key')
+
+    return context
diff --git a/tests/replay/conftest.py b/tests/replay/conftest.py
new file mode 100644
index 0000000..296f63a
--- /dev/null
+++ b/tests/replay/conftest.py
@@ -0,0 +1,31 @@
+import pytest
+
+from cookiecutter import config
+
+
+@pytest.fixture
+def context():
+    """Fixture to return a valid context as known from a cookiecutter.json."""
+    return {
+        u'cookiecutter': {
+            u'email': u'raphael@hackebrot.de',
+            u'full_name': u'Raphael Pierzina',
+            u'github_username': u'hackebrot',
+            u'version': u'0.1.0',
+        }
+    }
+
+
+@pytest.fixture
+def replay_test_dir():
+    return 'tests/test-replay/'
+
+
+@pytest.fixture
+def mock_user_config(mocker, replay_test_dir):
+    user_config = config.DEFAULT_CONFIG
+    user_config.update({'replay_dir': replay_test_dir})
+
+    return mocker.patch(
+        'cookiecutter.replay.get_user_config', return_value=user_config
+    )
diff --git a/tests/replay/test_dump.py b/tests/replay/test_dump.py
new file mode 100644
index 0000000..0a0d067
--- /dev/null
+++ b/tests/replay/test_dump.py
@@ -0,0 +1,101 @@
+# -*- coding: utf-8 -*-
+
+"""
+test_dump
+---------
+"""
+
+import json
+import os
+import pytest
+
+from cookiecutter import replay
+
+
+@pytest.fixture
+def template_name():
+    """Fixture to return a valid template_name."""
+    return 'cookiedozer'
+
+
+@pytest.fixture
+def replay_file(replay_test_dir, template_name):
+    """Fixture to return a actual file name of the dump."""
+    file_name = '{}.json'.format(template_name)
+    return os.path.join(replay_test_dir, file_name)
+
+
+@pytest.fixture(autouse=True)
+def remove_replay_dump(request, replay_file):
+    """Remove the replay file created by tests."""
+    def fin_remove_replay_file():
+        if os.path.exists(replay_file):
+            os.remove(replay_file)
+    request.addfinalizer(fin_remove_replay_file)
+
+
+def test_type_error_if_no_template_name(context):
+    """Test that replay.dump raises if the tempate_name is not a valid str."""
+    with pytest.raises(TypeError):
+        replay.dump(None, context)
+
+
+def test_type_error_if_not_dict_context(template_name):
+    """Test that replay.dump raises if the context is not of type dict."""
+    with pytest.raises(TypeError):
+        replay.dump(template_name, 'not_a_dict')
+
+
+def test_value_error_if_key_missing_in_context(template_name):
+    """Test that replay.dump raises if the context does not contain a key
+    named 'cookiecutter'.
+    """
+    with pytest.raises(ValueError):
+        replay.dump(template_name, {'foo': 'bar'})
+
+
+@pytest.fixture
+def mock_ensure_failure(mocker):
+    return mocker.patch(
+        'cookiecutter.replay.make_sure_path_exists',
+        return_value=False
+    )
+
+
+@pytest.fixture
+def mock_ensure_success(mocker):
+    return mocker.patch(
+        'cookiecutter.replay.make_sure_path_exists',
+        return_value=True
+    )
+
+
+def test_ioerror_if_replay_dir_creation_fails(
+        mock_ensure_failure, mock_user_config, replay_test_dir):
+    """Test that replay.dump raises when the replay_dir cannot be created."""
+
+    with pytest.raises(IOError):
+        replay.dump('foo', {'cookiecutter': {'hello': 'world'}})
+
+    mock_ensure_failure.assert_called_once_with(replay_test_dir)
+
+
+def test_run_json_dump(mocker, mock_ensure_success, mock_user_config,
+                       template_name, context, replay_test_dir, replay_file):
+    """Test that replay.dump runs json.dump under the hood and that the context
+    is correctly written to the expected file in the replay_dir.
+    """
+    spy_get_replay_file = mocker.spy(replay, 'get_file_name')
+
+    mock_json_dump = mocker.patch('json.dump', side_effect=json.dump)
+
+    replay.dump(template_name, context)
+
+    assert mock_user_config.call_count == 1
+    mock_ensure_success.assert_called_once_with(replay_test_dir)
+    spy_get_replay_file.assert_called_once_with(replay_test_dir, template_name)
+
+    assert mock_json_dump.call_count == 1
+    (dumped_context, outfile_handler), kwargs = mock_json_dump.call_args
+    assert outfile_handler.name == replay_file
+    assert dumped_context == context
diff --git a/tests/replay/test_load.py b/tests/replay/test_load.py
new file mode 100644
index 0000000..f609deb
--- /dev/null
+++ b/tests/replay/test_load.py
@@ -0,0 +1,59 @@
+# -*- coding: utf-8 -*-
+
+"""
+test_load
+-----------
+"""
+
+import json
+import os
+import pytest
+
+from cookiecutter import replay
+
+
+@pytest.fixture
+def template_name():
+    """Fixture to return a valid template_name."""
+    return 'cookiedozer_load'
+
+
+@pytest.fixture
+def replay_file(replay_test_dir, template_name):
+    """Fixture to return a actual file name of the dump."""
+    file_name = '{}.json'.format(template_name)
+    return os.path.join(replay_test_dir, file_name)
+
+
+def test_type_error_if_no_template_name():
+    """Test that replay.load raises if the tempate_name is not a valid str."""
+    with pytest.raises(TypeError):
+        replay.load(None)
+
+
+def test_value_error_if_key_missing_in_context(mocker):
+    """Test that replay.load raises if the loaded context does not contain
+    'cookiecutter'.
+    """
+    with pytest.raises(ValueError):
+        replay.load('invalid_replay')
+
+
+def test_run_json_load(mocker, mock_user_config, template_name,
+                       context, replay_test_dir, replay_file):
+    """Test that replay.load runs json.load under the hood and that the context
+    is correctly loaded from the file in replay_dir.
+    """
+    spy_get_replay_file = mocker.spy(replay, 'get_file_name')
+
+    mock_json_load = mocker.patch('json.load', side_effect=json.load)
+
+    loaded_context = replay.load(template_name)
+
+    assert mock_user_config.call_count == 1
+    spy_get_replay_file.assert_called_once_with(replay_test_dir, template_name)
+
+    assert mock_json_load.call_count == 1
+    (infile_handler,), kwargs = mock_json_load.call_args
+    assert infile_handler.name == replay_file
+    assert loaded_context == context
diff --git a/tests/replay/test_replay.py b/tests/replay/test_replay.py
new file mode 100644
index 0000000..98febfe
--- /dev/null
+++ b/tests/replay/test_replay.py
@@ -0,0 +1,13 @@
+# -*- coding: utf-8 -*-
+
+"""
+test_replay
+-----------
+"""
+
+from cookiecutter import replay
+
+
+def test_get_replay_file_name():
+    """Make sure that replay.get_file_name generates a valid json file path."""
+    assert replay.get_file_name('foo', 'bar') == 'foo/bar.json'
diff --git a/tests/test-replay/cookiedozer.json b/tests/test-replay/cookiedozer.json
deleted file mode 100644
index e69de29..0000000
diff --git a/tests/test-replay/cookiedozer_load.json b/tests/test-replay/cookiedozer_load.json
new file mode 100644
index 0000000..fc1b0f2
--- /dev/null
+++ b/tests/test-replay/cookiedozer_load.json
@@ -0,0 +1 @@
+{"cookiecutter": {"version": "0.1.0", "email": "raphael@hackebrot.de", "full_name": "Raphael Pierzina", "github_username": "hackebrot"}}
\ No newline at end of file
diff --git a/tests/test-replay/invalid_replay.json b/tests/test-replay/invalid_replay.json
new file mode 100644
index 0000000..884c3bc
--- /dev/null
+++ b/tests/test-replay/invalid_replay.json
@@ -0,0 +1 @@
+{"not cookiecutter": {"version": "0.1.0", "email": "raphael@hackebrot.de", "full_name": "Raphael Pierzina", "github_username": "hackebrot"}}
diff --git a/tests/test_replay.py b/tests/test_replay.py
deleted file mode 100644
index 35e9756..0000000
--- a/tests/test_replay.py
+++ /dev/null
@@ -1,137 +0,0 @@
-# -*- coding: utf-8 -*-
-
-"""
-test_replay
------------
-"""
-
-import pytest
-
-
-from cookiecutter import replay, config
-
-
-@pytest.fixture
-def replay_test_dir():
-    return 'tests/test-replay/'
-
-
-@pytest.fixture
-def mock_user_config(mocker, replay_test_dir):
-    user_config = config.DEFAULT_CONFIG
-    user_config.update({'replay_dir': replay_test_dir})
-
-    return mocker.patch(
-        'cookiecutter.replay.get_user_config', return_value=user_config
-    )
-
-
-def test_get_replay_file_name():
-    """Make sure that replay.get_file_name generates a valid json file path."""
-    assert replay.get_file_name('foo', 'bar') == 'foo/bar.json'
-
-
-@pytest.fixture
-def template_name():
-    """Fixture to return a valid template_name."""
-    return 'cookiedozer'
-
-
-@pytest.fixture
-def context():
-    """Fixture to return a valid context as known from a cookiecutter.json."""
-    return {
-        u'email': u'raphael@hackebrot.de',
-        u'full_name': u'Raphael Pierzina',
-        u'github_username': u'hackebrot',
-        u'version': u'0.1.0',
-    }
-
-
-def test_dump_type_error_if_no_template_name(context):
-    """Test that replay.dump raises if the tempate_name is not a valid str."""
-    with pytest.raises(TypeError):
-        replay.dump(None, context)
-
-
-def test_dump_type_error_if_not_dict_context(template_name):
-    """Test that replay.dump raises if the context is not of type dict."""
-    with pytest.raises(TypeError):
-        replay.dump(template_name, 'not_a_dict')
-
-
-@pytest.fixture
-def mock_ensure_failure(mocker):
-    return mocker.patch(
-        'cookiecutter.replay.make_sure_path_exists',
-        return_value=False
-    )
-
-
-@pytest.fixture
-def mock_ensure_success(mocker):
-    return mocker.patch(
-        'cookiecutter.replay.make_sure_path_exists',
-        return_value=True
-    )
-
-
-def test_dump_ioerror_if_replay_dir_creation_fails(
-        mock_ensure_failure, mock_user_config, replay_test_dir):
-    """Test that replay.dump raises when the replay_dir cannot be created."""
-
-    with pytest.raises(IOError):
-        replay.dump('foo', {'hello': 'world'})
-
-    mock_ensure_failure.assert_called_once_with(replay_test_dir)
-
-
-def test_dump_run_json_dump(mocker, mock_ensure_success, mock_user_config,
-                            template_name, context, replay_test_dir):
-    """Test that replay.dump runs json.dump under the hood and that the context
-    is correctly written to the expected file in the replay_dir.
-    """
-    spy_get_replay_file = mocker.spy(replay, 'get_file_name')
-
-    mock_json_dump = mocker.patch('json.dump')
-
-    replay.dump(template_name, context)
-
-    assert mock_user_config.call_count == 1
-    mock_ensure_success.assert_called_once_with(replay_test_dir)
-    spy_get_replay_file.assert_called_once_with(replay_test_dir, template_name)
-
-    replay_file = replay.get_file_name(replay_test_dir, template_name)
-
-    assert mock_json_dump.call_count == 1
-    (dumped_context, outfile_handler), kwargs = mock_json_dump.call_args
-    assert outfile_handler.name == replay_file
-    assert dumped_context == context
-
-
-def test_load_type_error_if_no_template_name():
-    """Test that replay.load raises if the tempate_name is not a valid str."""
-    with pytest.raises(TypeError):
-        replay.load(None)
-
-
-def test_load_run_json_load(mocker, mock_user_config, template_name,
-                            context, replay_test_dir):
-    """Test that replay.load runs json.load under the hood and that the context
-    is correctly loaded from the file in replay_dir.
-    """
-    spy_get_replay_file = mocker.spy(replay, 'get_file_name')
-
-    mock_json_load = mocker.patch('json.load', return_value=context)
-
-    loaded_context = replay.load(template_name)
-
-    assert mock_user_config.call_count == 1
-    spy_get_replay_file.assert_called_once_with(replay_test_dir, template_name)
-
-    replay_file = replay.get_file_name(replay_test_dir, template_name)
-
-    assert mock_json_load.call_count == 1
-    (infile_handler,), kwargs = mock_json_load.call_args
-    assert infile_handler.name == replay_file
-    assert loaded_context == context

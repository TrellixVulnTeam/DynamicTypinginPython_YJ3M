commit 578660312ca48b80a706217a81b45c29844100f9
Author: Russell Keith-Magee <russell@keith-magee.com>
Date:   Fri Sep 15 07:41:57 2017 -0700

    Improved testing of zip file extraction problems.

diff --git a/cookiecutter/exceptions.py b/cookiecutter/exceptions.py
index bb01670..e41d981 100644
--- a/cookiecutter/exceptions.py
+++ b/cookiecutter/exceptions.py
@@ -117,3 +117,10 @@ class RepositoryNotFound(CookiecutterException):
 
 class RepositoryCloneFailed(CookiecutterException):
     """Raised when a cookiecutter template can't be cloned."""
+
+
+class InvalidZipRepository(CookiecutterException):
+    """
+    Raised when the specified cookiecutter repository isn't a valid
+    Zip archive.
+    """
diff --git a/cookiecutter/zipfile.py b/cookiecutter/zipfile.py
index 5eb2191..056d5d9 100644
--- a/cookiecutter/zipfile.py
+++ b/cookiecutter/zipfile.py
@@ -3,8 +3,14 @@ from __future__ import absolute_import
 import os
 import requests
 import sys
+import tempfile
 from zipfile import ZipFile
+try:
+    from zipfile import BadZipFile
+except ImportError:
+    from zipfile import BadZipfile as BadZipFile
 
+from .exceptions import InvalidZipRepository
 from .prompt import read_user_yes_no
 from .utils import make_sure_path_exists, rmtree
 
@@ -37,8 +43,6 @@ def prompt_and_delete(path, no_input=False):
     else:
         sys.exit()
 
-    return ok_to_delete
-
 
 def unzip(zip_uri, is_url, clone_to_dir='.', no_input=False):
     """Download and unpack a zipfile at a given URI.
@@ -59,13 +63,11 @@ def unzip(zip_uri, is_url, clone_to_dir='.', no_input=False):
     if is_url:
         # Build the name of the cached zipfile,
         # and prompt to delete if it already exists.
-        identifier = zip_uri.rsplit('/', 1)[1]
+        identifier = zip_uri.rsplit(os.path.sep, 1)[1]
         zip_path = os.path.join(clone_to_dir, identifier)
 
         if os.path.exists(zip_path):
-            ok_to_delete = prompt_and_delete(zip_path, no_input=no_input)
-        else:
-            ok_to_delete = None
+            prompt_and_delete(zip_path, no_input=no_input)
 
         # (Re) download the zipfile
         r = requests.get(zip_uri, stream=True)
@@ -76,24 +78,44 @@ def unzip(zip_uri, is_url, clone_to_dir='.', no_input=False):
     else:
         # Just use the local zipfile as-is.
         zip_path = os.path.abspath(zip_uri)
-        ok_to_delete = None
-
-    # Now unpack the repository. The zipfile will include
-    # the name of the template as the top level directory;
-    # Check if that directory already exists, and if so,
-    # prompt for deletion. If we've previously OK'd deletion,
-    # don't ask again.
-    zip_file = ZipFile(zip_path)
-    unzip_name = zip_file.namelist()[0][:-1]
-
-    unzip_path = os.path.join(clone_to_dir, unzip_name)
-    if os.path.exists(unzip_path):
-        if ok_to_delete is None:
-            ok_to_delete = prompt_and_delete(unzip_path, no_input=no_input)
-        else:
-            rmtree(unzip_path)
 
-    # Extract the zip file
-    zip_file.extractall(path=clone_to_dir)
+    # Now unpack the repository. The zipfile will be unpacked
+    # into a temporary directory
+    try:
+        zip_file = ZipFile(zip_path)
+
+        if len(zip_file.namelist()) == 0:
+            raise InvalidZipRepository(
+                'Zip repository {} is empty'.format(zip_uri)
+            )
+
+        # The first record in the zipfile should be the directory entry for
+        # the archive. If it isn't a directory, there's a problem.
+        first_filename = zip_file.namelist()[0]
+        if not first_filename.endswith(os.path.sep):
+            raise InvalidZipRepository(
+                'Zip repository {} does not include '
+                'a top-level directory'.format(zip_uri)
+            )
+
+        # Construct the final target directory
+        project_name = first_filename[:-1]
+        unzip_base = tempfile.mkdtemp()
+        unzip_path = os.path.join(unzip_base, project_name)
+
+        # Extract the zip file into the temporary directory
+        try:
+            zip_file.extractall(path=unzip_base)
+        except RuntimeError:
+            # File is encrypted; in the future, we can get a password
+            # and retry here.
+            raise InvalidZipRepository(
+                'Zip repository {} is password protected'.format(zip_uri)
+            )
+
+    except BadZipFile:
+        raise InvalidZipRepository(
+            'Zip repository {} is not a valid zip archive:'.format(zip_uri)
+        )
 
     return unzip_path
diff --git a/tests/files/bad-zip-file.zip b/tests/files/bad-zip-file.zip
new file mode 100644
index 0000000..55d97ba
--- /dev/null
+++ b/tests/files/bad-zip-file.zip
@@ -0,0 +1 @@
+Ceci n'est pas un zip file.
diff --git a/tests/files/empty.zip b/tests/files/empty.zip
new file mode 100644
index 0000000..15cb0ec
Binary files /dev/null and b/tests/files/empty.zip differ
diff --git a/tests/files/not-a-repo.zip b/tests/files/not-a-repo.zip
new file mode 100644
index 0000000..50e10e4
Binary files /dev/null and b/tests/files/not-a-repo.zip differ
diff --git a/tests/files/protected-fake-repo-tmpl.zip b/tests/files/protected-fake-repo-tmpl.zip
new file mode 100644
index 0000000..a4cbc91
Binary files /dev/null and b/tests/files/protected-fake-repo-tmpl.zip differ
diff --git a/tests/zipfile/test_unzip.py b/tests/zipfile/test_unzip.py
index 65ef98f..b44ae81 100644
--- a/tests/zipfile/test_unzip.py
+++ b/tests/zipfile/test_unzip.py
@@ -1,9 +1,11 @@
 # -*- coding: utf-8 -*-
 import os
+import tempfile
 
 import pytest
 
 from cookiecutter import zipfile
+from cookiecutter.exceptions import InvalidZipRepository
 
 
 def mock_download():
@@ -15,7 +17,7 @@ def mock_download():
 
 
 def test_unzip_local_file(mocker, tmpdir):
-    """In `unzip()`, a local file reference is just unzipped where it is.
+    """In `unzip()`, a local file reference can be unzipped.
     """
     mock_prompt_and_delete = mocker.patch(
         'cookiecutter.zipfile.prompt_and_delete',
@@ -31,33 +33,31 @@ def test_unzip_local_file(mocker, tmpdir):
         clone_to_dir=str(clone_to_dir)
     )
 
-    assert output_dir == os.path.join(str(clone_to_dir), 'fake-repo-tmpl')
+    assert output_dir.startswith(tempfile.gettempdir())
     assert not mock_prompt_and_delete.called
 
 
-def test_unzip_should_abort_not_overwrite_template(mocker, tmpdir):
-    """In `unzip()`, if user doesn't want to overwrite an existing cached
-    template, Cookiecutter should exit.
+def test_unzip_protected_local_file(mocker, tmpdir):
+    """In `unzip()`, a password-protected local file reference can be unzipped.
     """
-    mocker.patch(
+    mock_prompt_and_delete = mocker.patch(
         'cookiecutter.zipfile.prompt_and_delete',
-        side_effect=SystemExit,
+        return_value=True,
         autospec=True
     )
 
     clone_to_dir = tmpdir.mkdir('clone')
-    clone_to_dir.mkdir('fake-repo-tmpl')
 
-    with pytest.raises(SystemExit):
-        zipfile.unzip(
-            'tests/files/fake-repo-tmpl.zip',
+    with pytest.raises(InvalidZipRepository):
+        output_dir = zipfile.unzip(
+            'tests/files/protected-fake-repo-tmpl.zip',
             is_url=False,
             clone_to_dir=str(clone_to_dir)
         )
 
 
-def test_unzip_url(mocker, tmpdir):
-    """In `unzip()`, a url will be downloaded and unzipped
+def test_empty_zip_file(mocker, tmpdir):
+    """In `unzip()`, an empty file raises an error.
     """
     mock_prompt_and_delete = mocker.patch(
         'cookiecutter.zipfile.prompt_and_delete',
@@ -65,30 +65,56 @@ def test_unzip_url(mocker, tmpdir):
         autospec=True
     )
 
-    request = mocker.MagicMock()
-    request.iter_content.return_value = mock_download()
+    clone_to_dir = tmpdir.mkdir('clone')
 
-    mocker.patch(
-        'cookiecutter.zipfile.requests.get',
-        return_value=request,
-        autospec=True,
+    with pytest.raises(InvalidZipRepository):
+        zipfile.unzip(
+            'tests/files/empty.zip',
+            is_url=False,
+            clone_to_dir=str(clone_to_dir)
+        )
+
+
+def test_non_repo_zip_file(mocker, tmpdir):
+    """In `unzip()`, a repository must have a top level directory
+    """
+    mock_prompt_and_delete = mocker.patch(
+        'cookiecutter.zipfile.prompt_and_delete',
+        return_value=True,
+        autospec=True
     )
 
     clone_to_dir = tmpdir.mkdir('clone')
 
-    output_dir = zipfile.unzip(
-        'https://example.com/path/to/fake-repo-tmpl.zip',
-        is_url=True,
-        clone_to_dir=str(clone_to_dir)
+    with pytest.raises(InvalidZipRepository):
+        zipfile.unzip(
+            'tests/files/not-a-repo.zip',
+            is_url=False,
+            clone_to_dir=str(clone_to_dir)
+        )
+
+
+def test_bad_zip_file(mocker, tmpdir):
+    """In `unzip()`, a corrupted zip file raises an error.
+    """
+    mock_prompt_and_delete = mocker.patch(
+        'cookiecutter.zipfile.prompt_and_delete',
+        return_value=True,
+        autospec=True
     )
 
-    assert output_dir == os.path.join(str(clone_to_dir), 'fake-repo-tmpl')
-    assert not mock_prompt_and_delete.called
+    clone_to_dir = tmpdir.mkdir('clone')
 
+    with pytest.raises(InvalidZipRepository):
+        zipfile.unzip(
+            'tests/files/bad-zip-file.zip',
+            is_url=False,
+            clone_to_dir=str(clone_to_dir)
+        )
 
-def test_unzip_url_existing_cache(mocker, tmpdir):
-    """In `unzip()`, a url will be downloaded and unzipped; an existing zip file
-    will be removed.
+
+def test_unzip_url(mocker, tmpdir):
+    """In `unzip()`, a url will be downloaded and unzipped
     """
     mock_prompt_and_delete = mocker.patch(
         'cookiecutter.zipfile.prompt_and_delete',
@@ -107,23 +133,19 @@ def test_unzip_url_existing_cache(mocker, tmpdir):
 
     clone_to_dir = tmpdir.mkdir('clone')
 
-    # Create an existing cache of the zipfile
-    existing_zip = clone_to_dir.join('fake-repo-tmpl.zip')
-    existing_zip.write('This is an existing zipfile')
-
     output_dir = zipfile.unzip(
         'https://example.com/path/to/fake-repo-tmpl.zip',
         is_url=True,
         clone_to_dir=str(clone_to_dir)
     )
 
-    assert output_dir == os.path.join(str(clone_to_dir), 'fake-repo-tmpl')
-    assert mock_prompt_and_delete.call_count == 1
+    assert output_dir.startswith(tempfile.gettempdir())
+    assert not mock_prompt_and_delete.called
 
 
-def test_unzip_url_existing_template(mocker, tmpdir):
-    """In `unzip()`, a url will be downloaded and unzipped; an existing
-    template directory will be removed
+def test_unzip_url_existing_cache(mocker, tmpdir):
+    """In `unzip()`, a url will be downloaded and unzipped; an existing zip file
+    will be removed.
     """
     mock_prompt_and_delete = mocker.patch(
         'cookiecutter.zipfile.prompt_and_delete',
@@ -142,8 +164,9 @@ def test_unzip_url_existing_template(mocker, tmpdir):
 
     clone_to_dir = tmpdir.mkdir('clone')
 
-    # Create an existing rolled out template directory
-    clone_to_dir.mkdir('fake-repo-tmpl')
+    # Create an existing cache of the zipfile
+    existing_zip = clone_to_dir.join('fake-repo-tmpl.zip')
+    existing_zip.write('This is an existing zipfile')
 
     output_dir = zipfile.unzip(
         'https://example.com/path/to/fake-repo-tmpl.zip',
@@ -151,27 +174,13 @@ def test_unzip_url_existing_template(mocker, tmpdir):
         clone_to_dir=str(clone_to_dir)
     )
 
-    assert output_dir == os.path.join(str(clone_to_dir), 'fake-repo-tmpl')
+    assert output_dir.startswith(tempfile.gettempdir())
     assert mock_prompt_and_delete.call_count == 1
 
 
-def test_unzip_url_existing_cache_and_template(mocker, tmpdir):
-    """In `unzip()`, a url will be downloaded and unzipped; an existing
-    zipfile cache and template directory will both be removed
+def test_unzip_url_existing_cache_no_input(mocker, tmpdir):
+    """In `unzip()`, if no_input is provided, the existing file will be removed.
     """
-    mock_prompt_and_delete = mocker.patch(
-        'cookiecutter.zipfile.prompt_and_delete',
-        return_value=True,
-        autospec=True
-    )
-
-    def mock_download():
-        with open('tests/files/fake-repo-tmpl.zip', 'rb') as zipfile:
-            chunk = zipfile.read(1024)
-            while chunk:
-                yield chunk
-                chunk = zipfile.read(1024)
-
     request = mocker.MagicMock()
     request.iter_content.return_value = mock_download()
 
@@ -187,17 +196,14 @@ def test_unzip_url_existing_cache_and_template(mocker, tmpdir):
     existing_zip = clone_to_dir.join('fake-repo-tmpl.zip')
     existing_zip.write('This is an existing zipfile')
 
-    # Create an existing rolled out template directory
-    clone_to_dir.mkdir('fake-repo-tmpl')
-
     output_dir = zipfile.unzip(
         'https://example.com/path/to/fake-repo-tmpl.zip',
         is_url=True,
-        clone_to_dir=str(clone_to_dir)
+        clone_to_dir=str(clone_to_dir),
+        no_input=True
     )
 
-    assert output_dir == os.path.join(str(clone_to_dir), 'fake-repo-tmpl')
-    assert mock_prompt_and_delete.call_count == 1
+    assert output_dir.startswith(tempfile.gettempdir())
 
 
 def test_unzip_should_abort_if_no_redownload(mocker, tmpdir):

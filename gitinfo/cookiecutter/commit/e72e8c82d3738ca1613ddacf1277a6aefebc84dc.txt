commit e72e8c82d3738ca1613ddacf1277a6aefebc84dc
Author: Russell Keith-Magee <russell@keith-magee.com>
Date:   Fri Sep 15 17:51:30 2017 -0700

    Added handling for password-protected repositories.

diff --git a/cookiecutter/prompt.py b/cookiecutter/prompt.py
index 41e8964..d420d02 100644
--- a/cookiecutter/prompt.py
+++ b/cookiecutter/prompt.py
@@ -49,6 +49,15 @@ def read_user_yes_no(question, default_value):
     )
 
 
+def read_repo_password(question):
+    """Prompt the user to enter a password
+
+    :param str question: Question to the user
+    """
+    # Please see http://click.pocoo.org/4/api/#click.prompt
+    return click.prompt(question, hide_input=True)
+
+
 def read_user_choice(var_name, options):
     """Prompt the user to choose from several options for the given variable.
 
diff --git a/cookiecutter/utils.py b/cookiecutter/utils.py
index 24dcf5f..c3f91df 100644
--- a/cookiecutter/utils.py
+++ b/cookiecutter/utils.py
@@ -88,7 +88,7 @@ def prompt_and_delete(path, no_input=False):
     """Ask the user whether it's okay to delete the previously-downloaded
     file/directory.
 
-    If yes, deletes it. If no, checks to see if the old version should be
+    If yes, delete it. If no, checks to see if the old version should be
     reused. If yes, it's reused; otherwise, Cookiecutter exits.
 
     :param path: Previously downloaded zipfile.
diff --git a/cookiecutter/zipfile.py b/cookiecutter/zipfile.py
index 2440362..4cf5c0b 100644
--- a/cookiecutter/zipfile.py
+++ b/cookiecutter/zipfile.py
@@ -11,6 +11,7 @@ except ImportError:
     from zipfile import BadZipfile as BadZipFile
 
 from .exceptions import InvalidZipRepository
+from .prompt import read_repo_password
 from .utils import make_sure_path_exists, prompt_and_delete
 
 
@@ -80,11 +81,39 @@ def unzip(zip_uri, is_url, clone_to_dir='.', no_input=False):
         try:
             zip_file.extractall(path=unzip_base)
         except RuntimeError:
-            # File is encrypted; in the future, we can get a password
-            # and retry here.
-            raise InvalidZipRepository(
-                'Zip repository {} is password protected'.format(zip_uri)
-            )
+            # File is password protected; try to get a password from the
+            # environment; if that doesn't work, ask the user.
+            password = os.environ.get('COOKIECUTTER_REPO_PASSWORD')
+            if password:
+                try:
+                    zip_file.extractall(
+                        path=unzip_base,
+                        pwd=password.encode('utf-8')
+                    )
+                except RuntimeError:
+                    raise InvalidZipRepository(
+                        'Invalid password provided for protected repository'
+                    )
+            elif no_input:
+                raise InvalidZipRepository(
+                    'Unable to unlock password protected repository'
+                )
+            else:
+                retry = 0
+                while retry is not None:
+                    try:
+                        password = read_repo_password('Repo password')
+                        zip_file.extractall(
+                            path=unzip_base,
+                            pwd=password.encode('utf-8')
+                        )
+                        retry = None
+                    except RuntimeError:
+                        retry += 1
+                        if retry == 3:
+                            raise InvalidZipRepository(
+                                'Unable to unlock password protected repository'
+                            )
 
     except BadZipFile:
         raise InvalidZipRepository(
diff --git a/docs/usage.rst b/docs/usage.rst
index 47baa02..0fe39af 100644
--- a/docs/usage.rst
+++ b/docs/usage.rst
@@ -95,6 +95,17 @@ If you want to see an example Zipfile, find any Cookiecutter repository on Githu
 and download that repository as a zip file - Github repository downloads are in
 a valid format for Cookiecutter.
 
+Password-protected Zip files
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+If your repository Zip file is password protected, Cookiecutter will prompt you
+for that password whenever the template is used.
+
+Alternatively, if you want to use a password-protected Zip file in an
+automated environment, you can export the `COOKIECUTTER_REPO_PASSWORD`
+environment variable; the value of that environment variable will be used
+whenever a password is required.
+
 Keeping your cookiecutters organized
 ------------------------------------
 
diff --git a/tests/test_read_repo_password.py b/tests/test_read_repo_password.py
new file mode 100644
index 0000000..5e24303
--- /dev/null
+++ b/tests/test_read_repo_password.py
@@ -0,0 +1,14 @@
+# -*- coding: utf-8 -*-
+
+import click
+import pytest
+
+from cookiecutter.prompt import read_repo_password
+
+def test_click_invocation(mocker):
+    prompt = mocker.patch('click.prompt')
+    prompt.return_value = 'sekrit'
+
+    assert read_repo_password('Password') == 'sekrit'
+
+    prompt.assert_called_once_with('Password', hide_input=True)
diff --git a/tests/zipfile/test_unzip.py b/tests/zipfile/test_unzip.py
index b44ae81..b77ad54 100644
--- a/tests/zipfile/test_unzip.py
+++ b/tests/zipfile/test_unzip.py
@@ -37,7 +37,75 @@ def test_unzip_local_file(mocker, tmpdir):
     assert not mock_prompt_and_delete.called
 
 
-def test_unzip_protected_local_file(mocker, tmpdir):
+def test_unzip_protected_local_file_environment_password(mocker, tmpdir):
+    """In `unzip()`, the environment can be used to provide a repo password
+    """
+    mock_prompt_and_delete = mocker.patch(
+        'cookiecutter.zipfile.prompt_and_delete',
+        return_value=True,
+        autospec=True
+    )
+    mock_os_environ = mocker.patch(
+        'os.environ.get',
+        return_value='sekrit'
+    )
+
+    clone_to_dir = tmpdir.mkdir('clone')
+
+    output_dir = zipfile.unzip(
+        'tests/files/protected-fake-repo-tmpl.zip',
+        is_url=False,
+        clone_to_dir=str(clone_to_dir)
+    )
+
+    assert output_dir.startswith(tempfile.gettempdir())
+    assert not mock_prompt_and_delete.called
+
+
+def test_unzip_protected_local_file_bad_environment_password(mocker, tmpdir):
+    """In `unzip()`, an error occurs if the environment has a bad password.
+    """
+    mock_prompt_and_delete = mocker.patch(
+        'cookiecutter.zipfile.prompt_and_delete',
+        return_value=True,
+        autospec=True
+    )
+    mock_os_environ = mocker.patch(
+        'os.environ.get',
+        return_value='not-the-right-password'
+    )
+
+    clone_to_dir = tmpdir.mkdir('clone')
+
+    with pytest.raises(InvalidZipRepository):
+        output_dir = zipfile.unzip(
+            'tests/files/protected-fake-repo-tmpl.zip',
+            is_url=False,
+            clone_to_dir=str(clone_to_dir)
+        )
+
+
+def test_unzip_protected_local_file_user_password_with_noinput(mocker, tmpdir):
+    """In `unzip()`, you can't unpack a password-protected repo in no_input mode
+    """
+    mock_prompt_and_delete = mocker.patch(
+        'cookiecutter.zipfile.prompt_and_delete',
+        return_value=True,
+        autospec=True
+    )
+
+    clone_to_dir = tmpdir.mkdir('clone')
+
+    with pytest.raises(InvalidZipRepository):
+        zipfile.unzip(
+            'tests/files/protected-fake-repo-tmpl.zip',
+            is_url=False,
+            clone_to_dir=str(clone_to_dir),
+            no_input=True
+        )
+
+
+def test_unzip_protected_local_file_user_password(mocker, tmpdir):
     """In `unzip()`, a password-protected local file reference can be unzipped.
     """
     mock_prompt_and_delete = mocker.patch(
@@ -45,6 +113,35 @@ def test_unzip_protected_local_file(mocker, tmpdir):
         return_value=True,
         autospec=True
     )
+    mock_read_password = mocker.patch(
+        'cookiecutter.zipfile.read_repo_password',
+        return_value='sekrit'
+    )
+
+    clone_to_dir = tmpdir.mkdir('clone')
+
+    output_dir = zipfile.unzip(
+        'tests/files/protected-fake-repo-tmpl.zip',
+        is_url=False,
+        clone_to_dir=str(clone_to_dir)
+    )
+
+    assert output_dir.startswith(tempfile.gettempdir())
+    assert not mock_prompt_and_delete.called
+
+
+def test_unzip_protected_local_file_user_bad_password(mocker, tmpdir):
+    """In `unzip()`, If you can't provide a valid password, you get an error
+    """
+    mock_prompt_and_delete = mocker.patch(
+        'cookiecutter.zipfile.prompt_and_delete',
+        return_value=True,
+        autospec=True
+    )
+    mock_read_password = mocker.patch(
+        'cookiecutter.zipfile.read_repo_password',
+        return_value='not-the-right-password'
+    )
 
     clone_to_dir = tmpdir.mkdir('clone')
 

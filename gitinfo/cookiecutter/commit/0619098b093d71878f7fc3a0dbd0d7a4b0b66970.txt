commit 0619098b093d71878f7fc3a0dbd0d7a4b0b66970
Author: Andrey Shpak <insspb@users.noreply.github.com>
Date:   Sat Apr 18 19:26:02 2020 +0300

    tests: test_prompt Exception tests refactoring (#1380)
    
    * Tests refactoring: test_prompt Exception tests replaced by parametrization, docstrings, formatting, new tests
    
    * Remove wrong type limit. (Raw can be any)

diff --git a/cookiecutter/prompt.py b/cookiecutter/prompt.py
index bc77a83..69d0189 100644
--- a/cookiecutter/prompt.py
+++ b/cookiecutter/prompt.py
@@ -144,7 +144,7 @@ def render_variable(env, raw, cookiecutter_dict):
     This is then presented to the user as the default.
 
     :param Environment env: A Jinja2 Environment object.
-    :param str raw: The next value to be prompted for by the user.
+    :param raw: The next value to be prompted for by the user.
     :param dict cookiecutter_dict: The current context as it's gradually
         being populated with variables.
     :return: The rendered value for the default variable.
diff --git a/tests/test_prompt.py b/tests/test_prompt.py
index a3ed7b3..e687f87 100644
--- a/tests/test_prompt.py
+++ b/tests/test_prompt.py
@@ -11,152 +11,115 @@ import six
 from cookiecutter import prompt, exceptions, environment
 
 
-@pytest.mark.parametrize('raw_var, rendered_var', [
-    (1, '1'),
-    (True, 'True'),
-    ('foo', 'foo'),
-    ('{{cookiecutter.project}}', 'foobar'),
-    (None, None),
-])
-def test_convert_to_str(mocker, raw_var, rendered_var):
-    env = environment.StrictEnvironment()
-    from_string = mocker.patch(
-        'cookiecutter.prompt.StrictEnvironment.from_string',
-        wraps=env.from_string
-    )
-    context = {'project': 'foobar'}
-
-    result = prompt.render_variable(env, raw_var, context)
-    assert result == rendered_var
-
-    # Make sure that non None non str variables are converted beforehand
-    if raw_var is not None:
-        if not isinstance(raw_var, six.string_types):
-            raw_var = str(raw_var)
-        from_string.assert_called_once_with(raw_var)
-    else:
-        assert not from_string.called
-
-
 @pytest.fixture(autouse=True)
 def patch_readline_on_win(monkeypatch):
+    """Fixture. Overwrite windows end of line to linux standard."""
     if 'windows' in platform.platform().lower():
         monkeypatch.setattr('sys.stdin.readline', lambda: '\n')
 
 
-class TestPrompt(object):
-    """Class to unite user prompt related tests."""
+class TestRenderVariable:
+    """Class to unite simple and complex tests for render_variable function."""
 
-    def test_prompt_for_config_simple(self, monkeypatch):
-        monkeypatch.setattr(
-            'cookiecutter.prompt.read_user_variable',
-            lambda var, default: u'Audrey Roy'
+    @pytest.mark.parametrize(
+        'raw_var, rendered_var',
+        [
+            (1, '1'),
+            (True, 'True'),
+            ('foo', 'foo'),
+            ('{{cookiecutter.project}}', 'foobar'),
+            (None, None),
+        ],
+    )
+    def test_convert_to_str(self, mocker, raw_var, rendered_var):
+        """Verify simple items correctly rendered to strings."""
+        env = environment.StrictEnvironment()
+        from_string = mocker.patch(
+            'cookiecutter.prompt.StrictEnvironment.from_string', wraps=env.from_string
         )
-        context = {'cookiecutter': {'full_name': 'Your Name'}}
+        context = {'project': 'foobar'}
+
+        result = prompt.render_variable(env, raw_var, context)
+        assert result == rendered_var
+
+        # Make sure that non None non str variables are converted beforehand
+        if raw_var is not None:
+            if not isinstance(raw_var, six.string_types):
+                raw_var = str(raw_var)
+            from_string.assert_called_once_with(raw_var)
+        else:
+            assert not from_string.called
+
+    @pytest.mark.parametrize(
+        'raw_var, rendered_var',
+        [
+            ({1: True, 'foo': False}, {'1': 'True', 'foo': 'False'}),
+            (
+                {'{{cookiecutter.project}}': ['foo', 1], 'bar': False},
+                {'foobar': ['foo', '1'], 'bar': 'False'},
+            ),
+            (['foo', '{{cookiecutter.project}}', None], ['foo', 'foobar', None]),
+        ],
+    )
+    def test_convert_to_str_complex_variables(self, raw_var, rendered_var):
+        """Verify tree items correctly rendered."""
+        env = environment.StrictEnvironment()
+        context = {'project': 'foobar'}
 
-        cookiecutter_dict = prompt.prompt_for_config(context)
-        assert cookiecutter_dict == {'full_name': u'Audrey Roy'}
+        result = prompt.render_variable(env, raw_var, context)
+        assert result == rendered_var
 
-    def test_prompt_for_config_unicode(self, monkeypatch):
-        monkeypatch.setattr(
-            'cookiecutter.prompt.read_user_variable',
-            lambda var, default: u'Pizzä ïs Gööd'
-        )
-        context = {'cookiecutter': {'full_name': 'Your Name'}}
 
-        cookiecutter_dict = prompt.prompt_for_config(context)
-        assert cookiecutter_dict == {'full_name': u'Pizzä ïs Gööd'}
+class TestPrompt(object):
+    """Class to unite user prompt related tests."""
 
-    def test_prompt_for_config_empty_dict(self, monkeypatch):
+    @pytest.mark.parametrize(
+        'context',
+        [
+            {'cookiecutter': {'full_name': 'Your Name'}},
+            {'cookiecutter': {'full_name': u'Řekni či napiš své jméno'}},
+        ],
+        ids=['ASCII default prompt/input', 'Unicode default prompt/input'],
+    )
+    def test_prompt_for_config(self, monkeypatch, context):
+        """Verify `prompt_for_config` call `read_user_variable` on text request."""
         monkeypatch.setattr(
-            'cookiecutter.prompt.read_user_dict',
-            lambda var, default: {}
+            'cookiecutter.prompt.read_user_variable', lambda var, default: default,
         )
-        context = {'cookiecutter': {'details': {}}}
 
         cookiecutter_dict = prompt.prompt_for_config(context)
-        assert cookiecutter_dict == {'details': {}}
+        assert cookiecutter_dict == context['cookiecutter']
 
     def test_prompt_for_config_dict(self, monkeypatch):
+        """Verify `prompt_for_config` call `read_user_variable` on dict request."""
         monkeypatch.setattr(
             'cookiecutter.prompt.read_user_dict',
-            lambda var, default: {"key": "value", "integer": 37}
-        )
-        context = {'cookiecutter': {'details': {}}}
-
-        cookiecutter_dict = prompt.prompt_for_config(context)
-        assert cookiecutter_dict == {
-            'details': {
-                'key': u'value',
-                'integer': 37
-            }
-        }
-
-    def test_prompt_for_config_deep_dict(self, monkeypatch):
-        monkeypatch.setattr(
-            'cookiecutter.prompt.read_user_dict',
-            lambda var, default: {
-                "key": "value",
-                "integer_key": 37,
-                "dict_key": {
-                    "deep_key": "deep_value",
-                    "deep_integer": 42,
-                    "deep_list": [
-                        "deep value 1",
-                        "deep value 2",
-                        "deep value 3",
-                    ]
-                },
-                "list_key": [
-                    "value 1",
-                    "value 2",
-                    "value 3",
-                ]
-            }
+            lambda var, default: {"key": "value", "integer": 37},
         )
         context = {'cookiecutter': {'details': {}}}
 
         cookiecutter_dict = prompt.prompt_for_config(context)
-        assert cookiecutter_dict == {
-            'details': {
-                "key": "value",
-                "integer_key": 37,
-                "dict_key": {
-                    "deep_key": "deep_value",
-                    "deep_integer": 42,
-                    "deep_list": [
-                        "deep value 1",
-                        "deep value 2",
-                        "deep value 3",
-                    ]
-                },
-                "list_key": [
-                    "value 1",
-                    "value 2",
-                    "value 3",
-                ]
-            }
-        }
+        assert cookiecutter_dict == {'details': {'key': u'value', 'integer': 37}}
 
     def test_should_render_dict(self):
+        """Verify template inside dictionary variable rendered."""
         context = {
             'cookiecutter': {
                 'project_name': 'Slartibartfast',
                 'details': {
-                    'other_name': '{{cookiecutter.project_name}}'
-                }
+                    '{{cookiecutter.project_name}}': '{{cookiecutter.project_name}}'
+                },
             }
         }
 
         cookiecutter_dict = prompt.prompt_for_config(context, no_input=True)
         assert cookiecutter_dict == {
             'project_name': 'Slartibartfast',
-            'details': {
-                'other_name': u'Slartibartfast',
-            }
+            'details': {'Slartibartfast': u'Slartibartfast',},
         }
 
     def test_should_render_deep_dict(self):
+        """Verify nested structures like dict in dict, rendered correctly."""
         context = {
             'cookiecutter': {
                 'project_name': "Slartibartfast",
@@ -172,14 +135,14 @@ class TestPrompt(object):
                             "deep value 1",
                             "{{cookiecutter.project_name}}",
                             "deep value 3",
-                        ]
+                        ],
                     },
                     "list_key": [
                         "value 1",
                         "{{cookiecutter.project_name}}",
                         "value 3",
-                    ]
-                }
+                    ],
+                },
             }
         }
 
@@ -194,155 +157,145 @@ class TestPrompt(object):
                     "deep_key": "deep_value",
                     "deep_integer": "42",
                     "deep_other_name": "Slartibartfast",
-                    "deep_list": [
-                        "deep value 1",
-                        "Slartibartfast",
-                        "deep value 3",
-                    ]
+                    "deep_list": ["deep value 1", "Slartibartfast", "deep value 3",],
                 },
-                "list_key": [
-                    "value 1",
-                    "Slartibartfast",
-                    "value 3",
-                ]
-            }
+                "list_key": ["value 1", "Slartibartfast", "value 3",],
+            },
         }
 
-    def test_unicode_prompt_for_config_unicode(self, monkeypatch):
-        monkeypatch.setattr(
-            'cookiecutter.prompt.read_user_variable',
-            lambda var, default: u'Pizzä ïs Gööd'
-        )
-        context = {'cookiecutter': {'full_name': u'Řekni či napiš své jméno'}}
-
-        cookiecutter_dict = prompt.prompt_for_config(context)
-        assert cookiecutter_dict == {'full_name': u'Pizzä ïs Gööd'}
-
-    def test_unicode_prompt_for_default_config_unicode(self, monkeypatch):
+    def test_prompt_for_templated_config(self, monkeypatch):
+        """Verify Jinja2 templating works in unicode prompts."""
         monkeypatch.setattr(
-            'cookiecutter.prompt.read_user_variable',
-            lambda var, default: default
+            'cookiecutter.prompt.read_user_variable', lambda var, default: default
         )
-        context = {'cookiecutter': {'full_name': u'Řekni či napiš své jméno'}}
-
-        cookiecutter_dict = prompt.prompt_for_config(context)
-        assert cookiecutter_dict == {'full_name': u'Řekni či napiš své jméno'}
-
-    def test_unicode_prompt_for_templated_config(self, monkeypatch):
-        monkeypatch.setattr(
-            'cookiecutter.prompt.read_user_variable',
-            lambda var, default: default
-        )
-        context = {'cookiecutter': OrderedDict([
-            (
-                'project_name',
-                u'A New Project'
-            ), (
-                'pkg_name',
-                u'{{ cookiecutter.project_name|lower|replace(" ", "") }}'
+        context = {
+            'cookiecutter': OrderedDict(
+                [
+                    ('project_name', u'A New Project'),
+                    (
+                        'pkg_name',
+                        u'{{ cookiecutter.project_name|lower|replace(" ", "") }}',
+                    ),
+                ]
             )
-        ])}
+        }
 
         exp_cookiecutter_dict = {
-            'project_name': u'A New Project', 'pkg_name': u'anewproject'
+            'project_name': u'A New Project',
+            'pkg_name': u'anewproject',
         }
         cookiecutter_dict = prompt.prompt_for_config(context)
         assert cookiecutter_dict == exp_cookiecutter_dict
 
     def test_dont_prompt_for_private_context_var(self, monkeypatch):
+        """Verify `read_user_variable` not called for private context variables."""
         monkeypatch.setattr(
             'cookiecutter.prompt.read_user_variable',
             lambda var, default: pytest.fail(
                 'Should not try to read a response for private context var'
-            )
+            ),
         )
         context = {'cookiecutter': {'_copy_without_render': ['*.html']}}
         cookiecutter_dict = prompt.prompt_for_config(context)
         assert cookiecutter_dict == {'_copy_without_render': ['*.html']}
 
+    def test_should_not_render_private_variables(self):
+        """Verify private(underscored) variables not rendered by `prompt_for_config`.
+
+        Private variables designed to be raw, same as context input.
+        """
+        context = {
+            'cookiecutter': {
+                'project_name': 'Skip render',
+                '_skip_jinja_template': '{{cookiecutter.project_name}}',
+                '_skip_float': 123.25,
+                '_skip_integer': 123,
+                '_skip_boolean': True,
+                '_skip_nested': True,
+            }
+        }
+        cookiecutter_dict = prompt.prompt_for_config(context, no_input=True)
+        assert cookiecutter_dict == context['cookiecutter']
+
 
 class TestReadUserChoice(object):
     """Class to unite choices prompt related tests."""
 
     def test_should_invoke_read_user_choice(self, mocker):
+        """Verify correct function called for select(list) variables."""
         prompt_choice = mocker.patch(
             'cookiecutter.prompt.prompt_choice_for_config',
-            wraps=prompt.prompt_choice_for_config
+            wraps=prompt.prompt_choice_for_config,
         )
 
-        read_choice = mocker.patch('cookiecutter.prompt.read_user_choice')
-        read_choice.return_value = 'all'
+        read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')
+        read_user_choice.return_value = 'all'
 
-        read_variable = mocker.patch('cookiecutter.prompt.read_user_variable')
+        read_user_variable = mocker.patch('cookiecutter.prompt.read_user_variable')
 
-        CHOICES = ['landscape', 'portrait', 'all']
-        CONTEXT = {
-            'cookiecutter': {
-                'orientation': CHOICES
-            }
-        }
+        choices = ['landscape', 'portrait', 'all']
+        context = {'cookiecutter': {'orientation': choices}}
 
-        cookiecutter_dict = prompt.prompt_for_config(CONTEXT)
+        cookiecutter_dict = prompt.prompt_for_config(context)
 
-        assert not read_variable.called
+        assert not read_user_variable.called
         assert prompt_choice.called
-        read_choice.assert_called_once_with('orientation', CHOICES)
+        read_user_choice.assert_called_once_with('orientation', choices)
         assert cookiecutter_dict == {'orientation': 'all'}
 
-    def test_should_not_invoke_read_user_variable(self, mocker):
-        read_variable = mocker.patch('cookiecutter.prompt.read_user_variable')
-        read_variable.return_value = u'Audrey Roy'
+    def test_should_invoke_read_user_variable(self, mocker):
+        """Verify correct function called for string input variables."""
+        read_user_variable = mocker.patch('cookiecutter.prompt.read_user_variable')
+        read_user_variable.return_value = u'Audrey Roy'
 
-        prompt_choice = mocker.patch(
-            'cookiecutter.prompt.prompt_choice_for_config'
-        )
+        prompt_choice = mocker.patch('cookiecutter.prompt.prompt_choice_for_config')
 
-        read_choice = mocker.patch('cookiecutter.prompt.read_user_choice')
+        read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')
 
-        CONTEXT = {'cookiecutter': {'full_name': 'Your Name'}}
+        context = {'cookiecutter': {'full_name': 'Your Name'}}
 
-        cookiecutter_dict = prompt.prompt_for_config(CONTEXT)
+        cookiecutter_dict = prompt.prompt_for_config(context)
 
         assert not prompt_choice.called
-        assert not read_choice.called
-        read_variable.assert_called_once_with('full_name', 'Your Name')
+        assert not read_user_choice.called
+        read_user_variable.assert_called_once_with('full_name', 'Your Name')
         assert cookiecutter_dict == {'full_name': u'Audrey Roy'}
 
     def test_should_render_choices(self, mocker):
-        read_choice = mocker.patch('cookiecutter.prompt.read_user_choice')
-        read_choice.return_value = u'anewproject'
+        """Verify Jinja2 templating engine works inside choices variables."""
+        read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')
+        read_user_choice.return_value = u'anewproject'
 
-        read_variable = mocker.patch('cookiecutter.prompt.read_user_variable')
-        read_variable.return_value = u'A New Project'
+        read_user_variable = mocker.patch('cookiecutter.prompt.read_user_variable')
+        read_user_variable.return_value = u'A New Project'
 
-        RENDERED_CHOICES = [
-            u'foo',
-            u'anewproject',
-            u'bar'
-        ]
+        rendered_choices = [u'foo', u'anewproject', u'bar']
 
-        CONTEXT = {'cookiecutter': OrderedDict([
-            (
-                'project_name',
-                u'A New Project'
-            ), (
-                'pkg_name',
+        context = {
+            'cookiecutter': OrderedDict(
                 [
-                    u'foo',
-                    u'{{ cookiecutter.project_name|lower|replace(" ", "") }}',
-                    u'bar'
+                    ('project_name', u'A New Project'),
+                    (
+                        'pkg_name',
+                        [
+                            u'foo',
+                            u'{{ cookiecutter.project_name|lower|replace(" ", "") }}',
+                            u'bar',
+                        ],
+                    ),
                 ]
             )
-        ])}
+        }
 
-        EXP_COOKIECUTTER_DICT = {
-            'project_name': u'A New Project', 'pkg_name': u'anewproject'
+        expected = {
+            'project_name': u'A New Project',
+            'pkg_name': u'anewproject',
         }
-        cookiecutter_dict = prompt.prompt_for_config(CONTEXT)
+        cookiecutter_dict = prompt.prompt_for_config(context)
 
-        read_variable.assert_called_once_with('project_name', u'A New Project')
-        read_choice.assert_called_once_with('pkg_name', RENDERED_CHOICES)
-        assert cookiecutter_dict == EXP_COOKIECUTTER_DICT
+        read_user_variable.assert_called_once_with('project_name', u'A New Project')
+        read_user_choice.assert_called_once_with('pkg_name', rendered_choices)
+        assert cookiecutter_dict == expected
 
 
 class TestPromptChoiceForConfig(object):
@@ -350,101 +303,66 @@ class TestPromptChoiceForConfig(object):
 
     @pytest.fixture
     def choices(self):
+        """Fixture. Just populate choices variable."""
         return ['landscape', 'portrait', 'all']
 
     @pytest.fixture
     def context(self, choices):
-        return {
-            'cookiecutter': {
-                'orientation': choices
-            }
-        }
+        """Fixture. Just populate context variable."""
+        return {'cookiecutter': {'orientation': choices}}
 
-    def test_should_return_first_option_if_no_input(
-            self, mocker, choices, context):
-        read_choice = mocker.patch('cookiecutter.prompt.read_user_choice')
+    def test_should_return_first_option_if_no_input(self, mocker, choices, context):
+        """Verify prompt_choice_for_config return first list option on no_input=True."""
+        read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')
 
         expected_choice = choices[0]
 
         actual_choice = prompt.prompt_choice_for_config(
-            context,
-            environment.StrictEnvironment(),
-            'orientation',
-            choices,
-            True  # Suppress user input
+            cookiecutter_dict=context,
+            env=environment.StrictEnvironment(),
+            key='orientation',
+            options=choices,
+            no_input=True,  # Suppress user input
         )
-        assert not read_choice.called
+
+        assert not read_user_choice.called
         assert expected_choice == actual_choice
 
-    def test_should_read_userchoice(self, mocker, choices, context):
-        read_choice = mocker.patch('cookiecutter.prompt.read_user_choice')
-        read_choice.return_value = 'all'
+    def test_should_read_user_choice(self, mocker, choices, context):
+        """Verify prompt_choice_for_config return user selection on no_input=False."""
+        read_user_choice = mocker.patch('cookiecutter.prompt.read_user_choice')
+        read_user_choice.return_value = 'all'
 
         expected_choice = 'all'
 
         actual_choice = prompt.prompt_choice_for_config(
-            context,
-            environment.StrictEnvironment(),
-            'orientation',
-            choices,
-            False  # Ask the user for input
+            cookiecutter_dict=context,
+            env=environment.StrictEnvironment(),
+            key='orientation',
+            options=choices,
+            no_input=False,  # Ask the user for input
         )
-        read_choice.assert_called_once_with('orientation', choices)
+        read_user_choice.assert_called_once_with('orientation', choices)
         assert expected_choice == actual_choice
 
 
-def test_undefined_variable_in_cookiecutter_dict():
-    context = {
-        'cookiecutter': {
-            'hello': 'world',
-            'foo': '{{cookiecutter.nope}}'
-        }
-    }
-    with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:
-        prompt.prompt_for_config(context, no_input=True)
-
-    error = err.value
-    assert error.message == "Unable to render variable 'foo'"
-    assert error.context == context
-
-
-def test_undefined_variable_in_cookiecutter_dict_with_choices():
-    context = {
-        'cookiecutter': {
-            'hello': 'world',
-            'foo': ['123', '{{cookiecutter.nope}}', '456']
-        }
-    }
-    with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:
-        prompt.prompt_for_config(context, no_input=True)
-
-    error = err.value
-    assert error.message == "Unable to render variable 'foo'"
-    assert error.context == context
-
-
-def test_undefined_variable_in_cookiecutter_dict_with_dict_key():
-    context = {
-        'cookiecutter': {
-            'hello': 'world',
-            'foo': {'{{cookiecutter.nope}}': 'value'}
-        }
-    }
-    with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:
-        prompt.prompt_for_config(context, no_input=True)
-
-    error = err.value
-    assert error.message == "Unable to render variable 'foo'"
-    assert error.context == context
-
-
-def test_undefined_variable_in_cookiecutter_dict_with_key_value():
-    context = {
-        'cookiecutter': {
-            'hello': 'world',
-            'foo': {'key': '{{cookiecutter.nope}}'}
-        }
-    }
+@pytest.mark.parametrize(
+    'context',
+    (
+        {'cookiecutter': {'foo': '{{cookiecutter.nope}}'}},
+        {'cookiecutter': {'foo': ['123', '{{cookiecutter.nope}}', '456']}},
+        {'cookiecutter': {'foo': {'{{cookiecutter.nope}}': 'value'}}},
+        {'cookiecutter': {'foo': {'key': '{{cookiecutter.nope}}'}}},
+    ),
+    ids=[
+        'Undefined variable in cookiecutter dict',
+        'Undefined variable in cookiecutter dict with choices',
+        'Undefined variable in cookiecutter dict with dict_key',
+        'Undefined variable in cookiecutter dict with key_value',
+    ],
+)
+def test_undefined_variable(context):
+    """Verify `prompt.prompt_for_config` raises correct error."""
     with pytest.raises(exceptions.UndefinedVariableInTemplate) as err:
         prompt.prompt_for_config(context, no_input=True)
 

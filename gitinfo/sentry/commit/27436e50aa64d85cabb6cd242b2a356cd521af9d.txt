commit 27436e50aa64d85cabb6cd242b2a356cd521af9d
Author: Chris Fuller <cfuller@sentry.io>
Date:   Fri May 29 11:42:42 2020 -0400

    feat(workflow): Add translation layer for broken aggregation columns (#19052)
    
    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>

diff --git a/src/sentry/api/serializers/models/alert_rule.py b/src/sentry/api/serializers/models/alert_rule.py
index 7e618b6c75..c8dd00c209 100644
--- a/src/sentry/api/serializers/models/alert_rule.py
+++ b/src/sentry/api/serializers/models/alert_rule.py
@@ -6,6 +6,8 @@ import six
 
 from sentry.api.serializers import register, serialize, Serializer
 from sentry.incidents.models import AlertRule, AlertRuleExcludedProjects, AlertRuleTrigger
+from sentry.incidents.logic import translate_aggregate_field
+
 from sentry.models import Rule
 from sentry.utils.compat import zip
 from sentry.utils.db import attach_foreignkey
@@ -30,6 +32,10 @@ class AlertRuleSerializer(Serializer):
 
     def serialize(self, obj, attrs, user):
         env = obj.snuba_query.environment
+        # Temporary: Translate aggregate back here from `tags[sentry:user]` to `user` for the frontend.
+
+        aggregate = translate_aggregate_field(obj.snuba_query.aggregate, reverse=True)
+
         return {
             "id": six.text_type(obj.id),
             "name": obj.name,
@@ -37,7 +43,7 @@ class AlertRuleSerializer(Serializer):
             "status": obj.status,
             "dataset": obj.snuba_query.dataset,
             "query": obj.snuba_query.query,
-            "aggregate": obj.snuba_query.aggregate,
+            "aggregate": aggregate,
             # TODO: Start having the frontend expect seconds
             "timeWindow": obj.snuba_query.time_window / 60,
             "environment": env.name if env else None,
diff --git a/src/sentry/incidents/endpoints/serializers.py b/src/sentry/incidents/endpoints/serializers.py
index f112f9d3c4..fb4e080a5e 100644
--- a/src/sentry/incidents/endpoints/serializers.py
+++ b/src/sentry/incidents/endpoints/serializers.py
@@ -17,14 +17,16 @@ from sentry.incidents.logic import (
     AlertRuleNameAlreadyUsedError,
     AlertRuleTriggerLabelAlreadyUsedError,
     InvalidTriggerActionError,
+    check_aggregate_column_support,
     create_alert_rule,
     create_alert_rule_trigger,
     create_alert_rule_trigger_action,
+    delete_alert_rule_trigger,
+    delete_alert_rule_trigger_action,
+    translate_aggregate_field,
     update_alert_rule,
     update_alert_rule_trigger,
     update_alert_rule_trigger_action,
-    delete_alert_rule_trigger_action,
-    delete_alert_rule_trigger,
 )
 from sentry.incidents.models import (
     AlertRule,
@@ -309,6 +311,16 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
             "include_all_projects": {"default": False},
         }
 
+    def validate_aggregate(self, aggregate):
+        try:
+            if not check_aggregate_column_support(aggregate):
+                raise serializers.ValidationError(
+                    "Invalid Metric: We do not currently support this field."
+                )
+        except InvalidSearchQuery as e:
+            raise serializers.ValidationError("Invalid Metric: {}".format(e.message))
+        return translate_aggregate_field(aggregate)
+
     def validate_dataset(self, dataset):
         try:
             return QueryDatasets(dataset)
@@ -342,11 +354,11 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
                 },
             )
         except (InvalidSearchQuery, ValueError) as e:
-            raise serializers.ValidationError("Invalid Query or Aggregate: {}".format(e.message))
+            raise serializers.ValidationError("Invalid Query or Metric: {}".format(e.message))
         else:
             if not snuba_filter.aggregations:
                 raise serializers.ValidationError(
-                    "Invalid Aggregate: Please pass a valid function for aggregation"
+                    "Invalid Metric: Please pass a valid function for aggregation"
                 )
 
             try:
@@ -364,7 +376,7 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
             except Exception:
                 logger.exception("Error while validating snuba alert rule query")
                 raise serializers.ValidationError(
-                    "Invalid Query or Aggregate: An error occurred while attempting "
+                    "Invalid Query or Metric: An error occurred while attempting "
                     "to run the query"
                 )
 
diff --git a/src/sentry/incidents/logic.py b/src/sentry/incidents/logic.py
index da38052b00..c6dc135220 100644
--- a/src/sentry/incidents/logic.py
+++ b/src/sentry/incidents/logic.py
@@ -9,7 +9,7 @@ from django.db.models.signals import post_save
 from django.utils import timezone
 
 from sentry import analytics
-from sentry.api.event_search import get_filter
+from sentry.api.event_search import get_filter, resolve_field
 from sentry.incidents import tasks
 from sentry.incidents.models import (
     AlertRule,
@@ -1025,3 +1025,46 @@ def get_available_action_integrations_for_org(organization):
         if registration.integration_provider is not None
     ]
     return Integration.objects.filter(organizations=organization, provider__in=providers)
+
+
+# TODO: This is temporarily needed to support back and forth translations for snuba / frontend.
+# Uses a function from discover to break the aggregate down into parts, and then compare the "field"
+# to a list of accepted fields, or a list of fields we need to translate.
+# This can be dropped once snuba can handle this aliasing.
+SUPPORTED_COLUMNS = [
+    "tags[sentry:user]",
+    "tags[sentry:dist]",
+    "tags[sentry:release]",
+    "transaction.duration",
+]
+TRANSLATABLE_COLUMNS = {
+    "user": "tags[sentry:user]",
+    "dist": "tags[sentry:dist]",
+    "release": "tags[sentry:release]",
+}
+
+
+def get_column_from_aggregate(aggregate):
+    field = resolve_field(aggregate)
+    if field[1] is not None:
+        column = field[1][0][1]
+        return column
+    return None
+
+
+def check_aggregate_column_support(aggregate):
+    column = get_column_from_aggregate(aggregate)
+    return column is None or column in SUPPORTED_COLUMNS or column in TRANSLATABLE_COLUMNS.keys()
+
+
+def translate_aggregate_field(aggregate, reverse=False):
+    column = get_column_from_aggregate(aggregate)
+    if not reverse:
+        if column in TRANSLATABLE_COLUMNS.keys():
+            return aggregate.replace(column, TRANSLATABLE_COLUMNS[column])
+    else:
+        if column is not None:
+            for field, translated_field in TRANSLATABLE_COLUMNS.items():
+                if translated_field == column:
+                    return aggregate.replace(column, field)
+    return aggregate
diff --git a/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py b/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
index df99b0c6ef..a9d3ed6b48 100644
--- a/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
+++ b/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
@@ -20,7 +20,7 @@ class AlertRuleDetailsBase(object):
             "threshold_type": 0,
             "resolve_threshold": 1,
             "alert_threshold": 0,
-            "aggregate": "count()",
+            "aggregate": "count_unique(user)",
             "threshold_period": 1,
             "projects": [self.project.slug],
             "triggers": [
@@ -116,6 +116,25 @@ class AlertRuleDetailsGetEndpointTest(AlertRuleDetailsBase, APITestCase):
 
         assert resp.data == serialize(self.alert_rule)
 
+    def test_aggregate_translation(self):
+        self.create_member(
+            user=self.user, organization=self.organization, role="owner", teams=[self.team]
+        )
+        self.login_as(self.user)
+        alert_rule = create_alert_rule(
+            self.organization,
+            [self.project],
+            "hello",
+            "level:error",
+            "count_unique(tags[sentry:user])",
+            10,
+            1,
+        )
+        with self.feature("organizations:incidents"):
+            resp = self.get_valid_response(self.organization.slug, self.project.slug, alert_rule.id)
+            assert resp.data["aggregate"] == "count_unique(user)"
+            assert alert_rule.snuba_query.aggregate == "count_unique(tags[sentry:user])"
+
 
 class AlertRuleDetailsPutEndpointTest(AlertRuleDetailsBase, APITestCase):
     method = "put"
diff --git a/tests/sentry/incidents/endpoints/test_serializers.py b/tests/sentry/incidents/endpoints/test_serializers.py
index e531912553..b47223bb7c 100644
--- a/tests/sentry/incidents/endpoints/test_serializers.py
+++ b/tests/sentry/incidents/endpoints/test_serializers.py
@@ -128,27 +128,22 @@ class TestAlertRuleSerializer(TestCase):
     def test_aggregate(self):
         self.run_fail_validation_test(
             {"aggregate": "what()"},
-            {"nonFieldErrors": ["Invalid Query or Aggregate: what() is not a valid function"]},
+            {"aggregate": ["Invalid Metric: what() is not a valid function"]},
         )
         self.run_fail_validation_test(
             {"aggregate": "what"},
-            {"nonFieldErrors": ["Invalid Aggregate: Please pass a valid function for aggregation"]},
+            {"nonFieldErrors": ["Invalid Metric: Please pass a valid function for aggregation"]},
         )
         self.run_fail_validation_test(
             {"aggregate": "123"},
-            {"nonFieldErrors": ["Invalid Aggregate: Please pass a valid function for aggregation"]},
+            {"nonFieldErrors": ["Invalid Metric: Please pass a valid function for aggregation"]},
         )
         self.run_fail_validation_test(
             {"aggregate": "count_unique(123, hello)"},
-            {
-                "nonFieldErrors": [
-                    "Invalid Query or Aggregate: count_unique(123, hello): expected 1 arguments"
-                ]
-            },
+            {"aggregate": ["Invalid Metric: count_unique(123, hello): expected 1 arguments"]},
         )
         self.run_fail_validation_test(
-            {"aggregate": "max()"},
-            {"nonFieldErrors": ["Invalid Query or Aggregate: max(): expected 1 arguments"]},
+            {"aggregate": "max()"}, {"aggregate": ["Invalid Metric: max(): expected 1 arguments"]},
         )
         aggregate = "count_unique(tags[sentry:user])"
         base_params = self.valid_params.copy()
@@ -293,6 +288,32 @@ class TestAlertRuleSerializer(TestCase):
         )
         assert len(alert_rule_trigger_actions) == 0
 
+    def test_valid_metric_field(self):
+        base_params = self.valid_params.copy()
+        base_params.update({"name": "Aun1qu3n4m3", "aggregate": "count_unique(user)"})
+        serializer = AlertRuleSerializer(context=self.context, data=base_params)
+        assert serializer.is_valid()
+        serializer.save()
+        assert len(list(AlertRule.objects.filter(name="Aun1qu3n4m3"))) == 1
+        alert_rule = AlertRule.objects.filter(name="Aun1qu3n4m3").first()
+        assert alert_rule.snuba_query.aggregate == "count_unique(tags[sentry:user])"
+
+    def test_invalid_metric_field(self):
+        self.run_fail_validation_test(
+            {"name": "Aun1qu3n4m3", "aggregate": "percentile(transaction.length,0.5)"},
+            {
+                "aggregate": [
+                    "Invalid Metric: percentile(transaction.length,0.5): column argument invalid: transaction.length is not a valid column"
+                ]
+            },
+        )
+
+    def test_unsupported_metric_field(self):
+        self.run_fail_validation_test(
+            {"name": "Aun1qu3n4m3", "aggregate": "count_unique(stack.filename)"},
+            {"aggregate": ["Invalid Metric: We do not currently support this field."]},
+        )
+
 
 class TestAlertRuleTriggerSerializer(TestCase):
     @fixture
diff --git a/tests/sentry/incidents/test_logic.py b/tests/sentry/incidents/test_logic.py
index a87c41c617..8dd060f084 100644
--- a/tests/sentry/incidents/test_logic.py
+++ b/tests/sentry/incidents/test_logic.py
@@ -48,6 +48,7 @@ from sentry.incidents.logic import (
     update_alert_rule_trigger_action,
     update_alert_rule_trigger,
     update_incident_status,
+    translate_aggregate_field,
 )
 from sentry.incidents.models import (
     AlertRule,
@@ -1242,3 +1243,23 @@ class GetAvailableActionIntegrationsForOrgTest(TestCase):
         other_integration = Integration.objects.create(external_id="12345", provider="random")
         other_integration.add_organization(self.organization)
         assert list(get_available_action_integrations_for_org(self.organization)) == [integration]
+
+
+class MetricTranslationTest(TestCase):
+    def test_simple(self):
+        aggregate = "count_unique(user)"
+        translated = translate_aggregate_field(aggregate)
+        assert translated == "count_unique(tags[sentry:user])"
+
+        # Make sure it doesn't double encode:
+        translated_2 = translate_aggregate_field(translated)
+        assert translated_2 == "count_unique(tags[sentry:user])"
+
+    def test_reverse(self):
+        aggregate = "count_unique(tags[sentry:user])"
+        translated = translate_aggregate_field(aggregate, reverse=True)
+        assert translated == "count_unique(user)"
+
+        # Make sure it doesn't do anything wonky running twice:
+        translated_2 = translate_aggregate_field(translated, reverse=True)
+        assert translated_2 == "count_unique(user)"

commit ef762f49ee1df70c63afc5468aebf655436ee396
Author: Lyn Nagara <lyn.nagara@gmail.com>
Date:   Fri Sep 13 10:29:22 2019 -0700

    feat: Check nodestore instead of Events table for duplicate event (#14621)
    
    Since we plan to remove the Events table, we instead check nodestore
    before processing an event for the presence of a duplicate ID.
    
    The previously discussed approach of reprocessing all duplicates and
    changing from first-write-wins and last-write-wins will not work for
    events across different days since Snuba uses "toStartOfDay(timestamp)"
    as part of the primary key.
    
    Ref: SNS-238

diff --git a/src/sentry/event_manager.py b/src/sentry/event_manager.py
index 747e74f01d..d9adb092e2 100644
--- a/src/sentry/event_manager.py
+++ b/src/sentry/event_manager.py
@@ -3,6 +3,7 @@ from __future__ import absolute_import, print_function
 import time
 import jsonschema
 import logging
+import random
 import six
 
 from datetime import datetime, timedelta
@@ -13,7 +14,7 @@ from django.db.models import Func
 from django.utils import timezone
 from django.utils.encoding import force_text
 
-from sentry import buffer, eventtypes, eventstream, features, tagstore, tsdb
+from sentry import buffer, eventtypes, eventstream, features, nodestore, options, tagstore, tsdb
 from sentry.constants import (
     DEFAULT_STORE_NORMALIZER_ARGS,
     LOG_LEVELS,
@@ -511,16 +512,13 @@ class EventManager(object):
             id=project.organization_id
         )
 
-        # Check to make sure we're not about to do a bunch of work that's
-        # already been done if we've processed an event with this ID. (This
-        # isn't a perfect solution -- this doesn't handle ``EventMapping`` and
-        # there's a race condition between here and when the event is actually
-        # saved, but it's an improvement. See GH-7677.)
-        try:
-            event = Event.objects.get(project_id=project.id, event_id=data["event_id"])
-        except Event.DoesNotExist:
-            pass
-        else:
+        # Ensure an event with the same ID does not exist before processing it.
+        # We use a first write wins approach since Clickhouse cannot merge
+        # events from different days. (The timestamp rounded to
+        # start of day is part of the primary key in Clickhouse).
+        event = self._get_event_from_storage(project_id, data["event_id"])
+
+        if event:
             # Make sure we cache on the project before returning
             event._project_cache = project
             logger.info(
@@ -875,6 +873,31 @@ class EventManager(object):
 
         return event
 
+    def _get_event_from_storage(self, project_id, event_id):
+        nodestore_sample_rate = options.get("store.nodestore-sample-rate")
+        use_nodestore = random.random() < nodestore_sample_rate
+
+        if use_nodestore:
+            start = time.time()
+
+            node_data = nodestore.get(Event.generate_node_id(project_id, event_id))
+
+            metrics.timing(
+                "events.store.nodestore.duration",
+                int((time.time() - start) * 1000),
+                tags={"duplicate_found": bool(node_data)},
+            )
+
+            if node_data:
+                return Event(node_data)
+        else:
+            try:
+                event = Event.objects.get(project_id=project_id, event_id=event_id)
+                return event
+            except Event.DoesNotExist:
+                pass
+        return None
+
     def _get_event_user(self, project, data):
         user_data = data.get("user")
         if not user_data:
diff --git a/src/sentry/options/defaults.py b/src/sentry/options/defaults.py
index 8f13e75a0f..451b4aa43a 100644
--- a/src/sentry/options/defaults.py
+++ b/src/sentry/options/defaults.py
@@ -167,6 +167,9 @@ register("symbolicator.minidump-refactor-random-sampling", default=0.0)  # unuse
 register("store.normalize-after-processing", default=0.0)  # unused
 register("store.disable-trim-in-renormalization", default=0.0)  # unused
 
+# Percent ingested events with duplicate checking from nodestore instead of events table
+register("store.nodestore-sample-rate", default=0.0, flags=FLAG_PRIORITIZE_DISK)
+
 # Post Process Error Hook Sampling
 register("post-process.use-error-hook-sampling", default=False)  # unused
 # From 0.0 to 1.0: Randomly enqueue process_resource_change task
diff --git a/tests/sentry/api/endpoints/test_group_integration_details.py b/tests/sentry/api/endpoints/test_group_integration_details.py
index e42276c2ce..d6445a1297 100644
--- a/tests/sentry/api/endpoints/test_group_integration_details.py
+++ b/tests/sentry/api/endpoints/test_group_integration_details.py
@@ -347,7 +347,7 @@ class GroupIntegrationDetailsTest(APITestCase):
         self.login_as(user=self.user)
         org = self.organization
         event = self.store_event(
-            data={"event_id": "a" * 32, "timestamp": iso_format(self.min_ago)},
+            data={"event_id": "b" * 32, "timestamp": iso_format(self.min_ago)},
             project_id=self.project.id,
         )
         group = event.group
diff --git a/tests/sentry/event_manager/test_event_manager.py b/tests/sentry/event_manager/test_event_manager.py
index e4c6717dab..f8fbd0ed0a 100644
--- a/tests/sentry/event_manager/test_event_manager.py
+++ b/tests/sentry/event_manager/test_event_manager.py
@@ -43,7 +43,7 @@ from sentry.relay.config import get_project_config
 
 def make_event(**kwargs):
     result = {
-        "event_id": "a" * 32,
+        "event_id": uuid.uuid1().hex,
         "message": "foo",
         "level": logging.ERROR,
         "logger": "default",
@@ -1163,6 +1163,27 @@ class EventManagerTest(TestCase):
             == 1
         )
 
+    def test_nodestore_sampling(self):
+        with self.options({"store.nodestore-sample-rate": 1.0}):
+            manager = EventManager(make_event(event_id="a" * 32))
+            manager.normalize()
+            manager.save(1)
+
+            assert Event.objects.count() == 1
+
+            manager = EventManager(make_event(event_id="b" * 32))
+            manager.normalize()
+            manager.save(1)
+
+            assert Event.objects.count() == 2
+
+            # Duplicate event
+            manager = EventManager(make_event(event_id="a" * 32))
+            manager.normalize()
+            manager.save(1)
+
+            assert Event.objects.count() == 2
+
 
 class ReleaseIssueTest(TestCase):
     def setUp(self):

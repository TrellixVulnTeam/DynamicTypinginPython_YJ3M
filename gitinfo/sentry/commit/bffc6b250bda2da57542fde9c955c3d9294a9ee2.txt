commit bffc6b250bda2da57542fde9c955c3d9294a9ee2
Author: Ted Kaemming <ted@kaemming.com>
Date:   Thu Oct 8 11:01:25 2015 -0700

    Improve names.

diff --git a/src/sentry/tsdb/base.py b/src/sentry/tsdb/base.py
index 2039f8bc7b..1b08f8a976 100644
--- a/src/sentry/tsdb/base.py
+++ b/src/sentry/tsdb/base.py
@@ -105,7 +105,7 @@ class BaseTSDB(object):
                 return rollup
         return self.rollups[-1][0]
 
-    def get_optimal_rollup_intervals(self, start, end=None, rollup=None):
+    def get_optimal_rollup_series(self, start, end=None, rollup=None):
         if end is None:
             end = timezone.now()
 
diff --git a/src/sentry/tsdb/inmemory.py b/src/sentry/tsdb/inmemory.py
index 5e0855f6ee..207cb5c0f5 100644
--- a/src/sentry/tsdb/inmemory.py
+++ b/src/sentry/tsdb/inmemory.py
@@ -68,27 +68,27 @@ class InMemoryTSDB(BaseTSDB):
             self.sets[model][key][r].update(values)
 
     def get_distinct_counts_series(self, model, keys, start, end=None, rollup=None):
-        rollup, intervals = self.get_optimal_rollup_intervals(start, end, rollup)
+        rollup, series = self.get_optimal_rollup_series(start, end, rollup)
 
         results = {}
         for key in keys:
             source = self.sets[model][key]
-            series = results[key] = []
-            for interval in intervals:
-                r = self.normalize_ts_to_rollup(interval, rollup)
-                series.append((interval, len(source[r])))
+            counts = results[key] = []
+            for timestamp in series:
+                r = self.normalize_ts_to_rollup(timestamp, rollup)
+                counts.append((timestamp, len(source[r])))
 
         return results
 
     def get_distinct_counts_totals(self, model, keys, start, end=None, rollup=None):
-        rollup, intervals = self.get_optimal_rollup_intervals(start, end, rollup)
+        rollup, series = self.get_optimal_rollup_series(start, end, rollup)
 
         results = {}
         for key in keys:
             source = self.sets[model][key]
             values = set()
-            for interval in intervals:
-                r = self.normalize_ts_to_rollup(interval, rollup)
+            for timestamp in series:
+                r = self.normalize_ts_to_rollup(timestamp, rollup)
                 values.update(source[r])
             results[key] = len(values)
 
diff --git a/src/sentry/tsdb/redis.py b/src/sentry/tsdb/redis.py
index 42ce73fba1..8500d21660 100644
--- a/src/sentry/tsdb/redis.py
+++ b/src/sentry/tsdb/redis.py
@@ -207,7 +207,7 @@ class RedisTSDB(BaseTSDB):
         """
         Fetch counts of distinct items for each rollup interval within the range.
         """
-        rollup, intervals = self.get_optimal_rollup_intervals(start, end, rollup)
+        rollup, series = self.get_optimal_rollup_series(start, end, rollup)
 
         def get_key(key, timestamp):
             return self.make_key(
@@ -221,7 +221,7 @@ class RedisTSDB(BaseTSDB):
             for key in keys:
                 make_key = functools.partial(get_key, key)
                 c = client.target_key(key)
-                responses[key] = [(timestamp, c.pfcount(make_key(timestamp))) for timestamp in intervals]
+                responses[key] = [(timestamp, c.pfcount(make_key(timestamp))) for timestamp in series]
 
         return {k: [(t, p.value) for t, p in v] for k, v in responses.iteritems()}
 
@@ -229,7 +229,7 @@ class RedisTSDB(BaseTSDB):
         """
         Count distinct items during a time range.
         """
-        rollup, intervals = self.get_optimal_rollup_intervals(start, end, rollup)
+        rollup, series = self.get_optimal_rollup_series(start, end, rollup)
 
         def get_key(key, timestamp):
             return self.make_key(
@@ -244,7 +244,7 @@ class RedisTSDB(BaseTSDB):
                 make_key = functools.partial(get_key, key)
                 responses[key] = client.target_key(key).execute_command(
                     'pfcount',
-                    *map(make_key, intervals)
+                    *map(make_key, series)
                 )
 
         return {k: v.value for k, v in responses.iteritems()}

commit 7c3dcd1b5637aaeffc1a49468daf9aef7619028e
Author: ted kaemming <ted@kaemming.com>
Date:   Wed May 9 15:30:34 2018 -0700

    ref(services): Allow sharing additional context across threads (#8383)

diff --git a/src/sentry/utils/services.py b/src/sentry/utils/services.py
index 5870feeb30..16195570d0 100644
--- a/src/sentry/utils/services.py
+++ b/src/sentry/utils/services.py
@@ -95,6 +95,18 @@ def resolve_callable(value):
         raise TypeError('Expected callable or string')
 
 
+class Context(object):
+    def __init__(self, request, backends):
+        self.request = request
+        self.backends = backends
+
+    def copy(self):
+        return Context(
+            self.request,
+            self.backends.copy(),
+        )
+
+
 class ServiceDelegator(Service):
     """\
     This is backend that coordinates and delegates method execution to multiple
@@ -126,20 +138,20 @@ class ServiceDelegator(Service):
         # ... etc ...
 
     The backends used for a method call are determined by a selector function
-    which is provided with the method name (as a string) and arguments (in the
-    form returned by ``inspect.getcallargs``) and expected to return a list of
-    strings which correspond to names in the backend mapping. (This list should
-    contain at least one member.) The first item in the result list is
-    considered the "primary backend". The remainder of the items in the result
-    list are considered "secondary backends". The result value of the primary
-    backend will be the result value of the delegated method (to callers, this
-    appears as a synchronous method call.) The secondary backends are called
-    asynchronously in the background.  (To receive the result values of these
-    method calls, provide a callback_func, described below.) If the primary
-    backend name returned by the selector function doesn't correspond to any
-    registered backend, the function will raise a ``InvalidBackend`` exception.
-    If any referenced secondary backends are not registered names, they will be
-    discarded and logged.
+    which is provided with the current context, the method name (as a string)
+    and arguments (in the form returned by ``inspect.getcallargs``) and
+    expected to return a list of strings which correspond to names in the
+    backend mapping. (This list should contain at least one member.) The first
+    item in the result list is considered the "primary backend". The remainder
+    of the items in the result list are considered "secondary backends". The
+    result value of the primary backend will be the result value of the
+    delegated method (to callers, this appears as a synchronous method call.)
+    The secondary backends are called asynchronously in the background.  (To
+    receive the result values of these method calls, provide a callback_func,
+    described below.) If the primary backend name returned by the selector
+    function doesn't correspond to any registered backend, the function will
+    raise a ``InvalidBackend`` exception.  If any referenced secondary backends
+    are not registered names, they will be discarded and logged.
 
     The members and ordering of the selector function result (and thus the
     primary and secondary backends for a method call) may vary from call to
@@ -177,6 +189,7 @@ class ServiceDelegator(Service):
       attempting to retrieve the result.)
     - The ``callback_func`` is called after all futures have completed, either
       successfully or unsuccessfully. The function parameters are:
+      - the context,
       - the method name (as a string),
       - the calling arguments (as returned by ``inspect.getcallargs``),
       - the backend names (as returned by the selector function),
@@ -190,11 +203,11 @@ class ServiceDelegator(Service):
         function.
         """
 
-    class ServiceState(threading.local):
+    class State(threading.local):
         def __init__(self):
-            self.backends = {}
+            self.context = None
 
-    state = ServiceState()
+    __state = State()
 
     def __init__(self, backend_base, backends, selector_func, callback_func=None):
         self.__backend_base = import_string(backend_base)
@@ -247,10 +260,19 @@ class ServiceDelegator(Service):
             return base_value
 
         def execute(*args, **kwargs):
+            context = type(self).__state.context
+
+            # If there is no context object already set in the thread local
+            # state, we are entering the delegator for the first time and need
+            # to create a new context.
+            if context is None:
+                from sentry.app import env  # avoids a circular import
+                context = Context(env.request, {})
+
             # If this thread already has an active backend for this base class,
             # we can safely call that backend synchronously without delegating.
-            if self.__backend_base in self.state.backends:
-                backend = type(self).state.backends[self.__backend_base]
+            if self.__backend_base in context.backends:
+                backend = context.backends[self.__backend_base]
                 return getattr(backend, attribute_name)(*args, **kwargs)
 
             # Binding the call arguments to named arguments has two benefits:
@@ -263,7 +285,7 @@ class ServiceDelegator(Service):
             #    arguments that are supported by all backends.
             callargs = inspect.getcallargs(base_value, None, *args, **kwargs)
 
-            selected_backend_names = list(self.__selector_func(attribute_name, callargs))
+            selected_backend_names = list(self.__selector_func(context, attribute_name, callargs))
             if not len(selected_backend_names) > 0:
                 raise self.InvalidBackend('No backends returned by selector!')
 
@@ -275,23 +297,25 @@ class ServiceDelegator(Service):
                     '{!r} is not a registered backend.'.format(
                         selected_backend_names[0]))
 
-            def call_backend_method(backend):
-                base = self.__backend_base
-                active_backends = type(self).state.backends
+            def call_backend_method(context, backend):
+                # Update the thread local state in the executor to the provided
+                # context object. This allows the context to be propagated
+                # across different threads.
+                assert type(self).__state.context is None
+                type(self).__state.context = context
 
                 # Ensure that we haven't somehow accidentally entered a context
                 # where the backend we're calling has already been marked as
                 # active (or worse, some other backend is already active.)
-                assert base not in active_backends
+                base = self.__backend_base
+                assert base not in context.backends
 
                 # Mark the backend as active.
-                active_backends[base] = backend
+                context.backends[base] = backend
                 try:
                     return getattr(backend, attribute_name)(*args, **kwargs)
                 finally:
-                    # Unmark the backend as active.
-                    assert active_backends[base] is backend
-                    del active_backends[base]
+                    type(self).__state.context = None
 
             # Enqueue all of the secondary backend requests first since these
             # are non-blocking queue insertions. (Since the primary backend
@@ -315,7 +339,11 @@ class ServiceDelegator(Service):
                         exc_info=True)
                 else:
                     results[i] = executor.submit(
-                        functools.partial(call_backend_method, backend),
+                        functools.partial(
+                            call_backend_method,
+                            context.copy(),
+                            backend,
+                        ),
                         priority=1,
                         block=False,
                     )
@@ -325,7 +353,11 @@ class ServiceDelegator(Service):
             # since we already ensured that the primary backend exists.)
             backend, executor = self.__backends[selected_backend_names[0]]
             results[0] = executor.submit(
-                functools.partial(call_backend_method, backend),
+                functools.partial(
+                    call_backend_method,
+                    context.copy(),
+                    backend,
+                ),
                 priority=0,
                 block=True,
             )
@@ -333,6 +365,7 @@ class ServiceDelegator(Service):
             if self.__callback_func is not None:
                 FutureSet(filter(None, results)).add_done_callback(
                     lambda *a, **k: self.__callback_func(
+                        context,
                         attribute_name,
                         callargs,
                         selected_backend_names,

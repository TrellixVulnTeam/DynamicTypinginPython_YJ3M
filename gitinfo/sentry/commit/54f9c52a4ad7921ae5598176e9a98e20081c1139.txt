commit 54f9c52a4ad7921ae5598176e9a98e20081c1139
Author: David Cramer <dcramer@gmail.com>
Date:   Thu Jan 17 22:33:09 2013 -0800

    Initial working sourcemap implementation

diff --git a/src/sentry/tasks/fetch_source.py b/src/sentry/tasks/fetch_source.py
index b5c087badb..8c35d0bab6 100644
--- a/src/sentry/tasks/fetch_source.py
+++ b/src/sentry/tasks/fetch_source.py
@@ -7,9 +7,13 @@ sentry.tasks.fetch_source
 """
 
 import urllib2
+from collections import namedtuple
+from urlparse import urljoin
 
 from celery.task import task
+from sentry.utils.cache import cache
 from sentry.utils.lrucache import lrucache
+from sentry.utils.sourcemaps import sourcemap_to_index, find_source
 
 BAD_SOURCE = -1
 
@@ -17,23 +21,13 @@ BAD_SOURCE = -1
 LINES_OF_CONTEXT = 5
 
 
-@lrucache.memoize
-def fetch_url(url, logger=None):
-    import sentry
-
-    try:
-        opener = urllib2.build_opener()
-        opener.addheaders = [('User-Agent', 'Sentry/%s' % sentry.VERSION)]
-        req = opener.open(url)
-        result = req.read()
-    except Exception:
-        if logger:
-            logger.error('Unable to fetch remote source for %r', url, exc_info=True)
-        return BAD_SOURCE
-    return result
+UrlResult = namedtuple('UrlResult', ['url', 'headers', 'body'])
 
 
 def get_source_context(source, lineno, context=LINES_OF_CONTEXT):
+    # lineno's in JS are 1-indexed
+    lineno -= 1
+
     lower_bound = max(0, lineno - context)
     upper_bound = min(lineno + 1 + context, len(source))
 
@@ -55,11 +49,79 @@ def get_source_context(source, lineno, context=LINES_OF_CONTEXT):
     return pre_context, context_line, post_context
 
 
+def discover_sourcemap(result, logger=None):
+    """
+    Given a UrlResult object, attempt to discover a sourcemap.
+    """
+    sourcemap = result.headers.get('X-SourceMap', None)
+
+    if not sourcemap:
+        parsed_body = result.body.splitlines()
+        indicator = parsed_body[-1]
+        if indicator.startswith('//@'):
+            try:
+                parsed = dict(v.split('=') for v in indicator[3:].strip().split(' '))
+            except Exception:
+                if logger:
+                    logger.error('Failed parsing source map line for %r (line was %r)', result.url, indicator, exc_info=True)
+            else:
+                sourcemap = parsed.get('sourceMappingURL')
+
+    if sourcemap:
+        # fix url so its absolute
+        sourcemap = urljoin(result.url, sourcemap)
+
+    return sourcemap
+
+
+@lrucache.memoize
+def fetch_url(url, logger=None):
+    """
+    Pull down a URL, returning a UrlResult object.
+
+    Attempts to fetch from the cache.
+    """
+    import sentry
+
+    cache_key = 'fetch_url:%s' % url
+    result = cache.get(cache_key)
+    if result is not None:
+        return result
+
+    try:
+        opener = urllib2.build_opener()
+        opener.addheaders = [('User-Agent', 'Sentry/%s' % sentry.VERSION)]
+        req = opener.open(url)
+        headers = dict(req.headers)
+        body = req.read().rstrip('\n')
+    except Exception:
+        if logger:
+            logger.error('Unable to fetch remote source for %r', url, exc_info=True)
+        return BAD_SOURCE
+
+    result = UrlResult(url, headers, body)
+
+    cache.set(cache_key, result, 60 * 5)
+
+    return result
+
+
 @task(ignore_result=True)
 def fetch_javascript_source(event, **kwargs):
-    from sentry.utils.cache import cache
+    """
+    Attempt to fetch source code for javascript frames.
 
+    Frames must match the following requirements:
+
+    - lineno >= 0
+    - colno >= 0
+    - abs_path is the HTTP URI to the source
+    - context_line is empty
+    """
+    import logging
     logger = fetch_javascript_source.get_logger()
+    logger.setLevel(logging.INFO)
+    logger.addHandler(logging.StreamHandler())
 
     try:
         stacktrace = event.data['sentry.interfaces.Stacktrace']
@@ -70,32 +132,69 @@ def fetch_javascript_source(event, **kwargs):
     # build list of frames that we can actually grab source for
     frames = [f for f in stacktrace['frames']
         if f.get('lineno') is not None
-            and f.get('abs_path', '').startswith(('http://', 'https://'))
-            and not f.get('context_line')]
+            and f.get('colno') is not None
+            and f.get('abs_path', '').startswith(('http://', 'https://'))]
     if not frames:
         logger.info('Event %r has no frames with enough context to fetch remote source', event.id)
         return
 
     file_list = set((f['abs_path'] for f in frames))
     source_code = {}
+    sourcemaps = {}
+
+    while file_list:
+        filename = file_list.pop()
 
-    for filename in file_list:
-        cache_key = 'remotesource:%s' % filename
         # TODO: respect cache-contro/max-age headers to some extent
-        result = cache.get(cache_key)
-        if result is None:
-            result = fetch_url(filename)
-            cache.set(cache_key, result, 60 * 5)
+        result = fetch_url(filename)
 
-        if result != BAD_SOURCE:
-            result = result.splitlines()
-        source_code[filename] = result
+        if result == BAD_SOURCE:
+            continue
+
+        # TODO: we're currently running splitlines twice
+        sourcemap = discover_sourcemap(result, logger=logger)
+        source_code[filename] = (result.body.splitlines(), sourcemap)
+        if sourcemap:
+            logger.info('Found sourcemap %r for minified script %r', sourcemap, result.url)
+
+        # pull down sourcemap
+        if sourcemap and sourcemap not in sourcemaps:
+            result = fetch_url(sourcemap, logger=logger)
+            if result == BAD_SOURCE:
+                continue
+
+            index = sourcemap_to_index(result.body)
+            sourcemaps[sourcemap] = index
+
+            # queue up additional source files for download
+            for source in index.sources:
+                if source not in source_code:
+                    file_list.add(urljoin(result.url, source))
 
     for frame in frames:
-        source = source_code[frame['abs_path']]
-        if source == BAD_SOURCE:
+        try:
+            source, sourcemap = source_code[frame['abs_path']]
+        except KeyError:
+            # we must've failed pulling down the source
             continue
+
+        if sourcemap:
+            state = find_source(sourcemaps[sourcemap], frame['lineno'], frame['colno'])
+            # TODO: is this urljoin right? (is it relative to the sourcemap or the originating file)
+            abs_path = urljoin(sourcemap, state.src)
+            try:
+                source, _ = source_code[abs_path]
+            except KeyError:
+                pass
+            else:
+                frame['lineno'] = state.src_line
+                frame['colno'] = state.src_col
+                frame['name'] = state.name
+                frame['abs_path'] = abs_path
+                frame['filename'] = state.src
+
+        # TODO: theoretically a minified source could point to another mapped, minified source
         frame['pre_context'], frame['context_line'], frame['post_context'] = get_source_context(
-            source, int(frame['lineno']))
+            source=source, lineno=int(frame['lineno']))
 
     event.save()
diff --git a/src/sentry/utils/sourcemaps.py b/src/sentry/utils/sourcemaps.py
index 032c7ed5cc..aace976e53 100644
--- a/src/sentry/utils/sourcemaps.py
+++ b/src/sentry/utils/sourcemaps.py
@@ -14,7 +14,7 @@ from sentry.utils import json
 
 
 SourceMap = namedtuple('SourceMap', ['dst_line', 'dst_col', 'src', 'src_line', 'src_col', 'name'])
-SourceMapIndex = namedtuple('SourceMapIndex', ['state_list', 'key_list'])
+SourceMapIndex = namedtuple('SourceMapIndex', ['states', 'keys', 'sources'])
 
 # Mapping of base64 letter -> integer value.
 B64 = dict(
@@ -97,17 +97,19 @@ def parse_sourcemap(sourcemap):
             yield SourceMap(dst_line, dst_col, src, src_line, src_col, name)
 
 
-def sourcemap_to_index(parsed_sourcemap):
+def sourcemap_to_index(sourcemap):
     state_list = []
     key_list = []
+    src_list = set()
 
-    for state in parsed_sourcemap:
+    for state in parse_sourcemap(sourcemap):
         state_list.append(state)
         key_list.append((state.dst_line, state.dst_col))
+        src_list.add(state.src)
 
-    return SourceMapIndex(state_list, key_list)
+    return SourceMapIndex(state_list, key_list, src_list)
 
 
 def find_source(indexed_sourcemap, lineno, colno):
     # error says "line no 0, column no 56"
-    return indexed_sourcemap.state_list[bisect.bisect_left(indexed_sourcemap.key_list, (0, 56)) - 1]
+    return indexed_sourcemap.states[bisect.bisect_left(indexed_sourcemap.keys, (lineno, colno)) - 1]
diff --git a/tests/sentry/tasks/fetch_source/tests.py b/tests/sentry/tasks/fetch_source/tests.py
index 53fe3cb5cb..00da1d026c 100644
--- a/tests/sentry/tasks/fetch_source/tests.py
+++ b/tests/sentry/tasks/fetch_source/tests.py
@@ -24,11 +24,13 @@ class StoreEventTest(TestCase):
                         'abs_path': 'http://example.com/foo.js',
                         'filename': 'foo.js',
                         'lineno': 4,
+                        'colno': 0,
                     },
                     {
                         'abs_path': 'http://example.com/foo.js',
                         'filename': 'foo.js',
                         'lineno': 1,
+                        'colno': 0,
                     },
                 ],
             },
diff --git a/tests/sentry/utils/sourcemaps/tests.py b/tests/sentry/utils/sourcemaps/tests.py
index 0721406621..dc98dc6c05 100644
--- a/tests/sentry/utils/sourcemaps/tests.py
+++ b/tests/sentry/utils/sourcemaps/tests.py
@@ -21,8 +21,7 @@ class ParseVlqTest(TestCase):
 
 class FindSourceTest(TestCase):
     def test_simple(self):
-        parsed_sourcemap = parse_sourcemap(sourcemap)
-        indexed_sourcemap = sourcemap_to_index(parsed_sourcemap)
+        indexed_sourcemap = sourcemap_to_index(sourcemap)
 
         result = find_source(indexed_sourcemap, 0, 56)
 

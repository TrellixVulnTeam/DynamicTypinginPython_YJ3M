commit 01a7383a97dbabae6eefdbc42e45e56d3f43543a
Author: Armin Ronacher <armin.ronacher@active-4.com>
Date:   Wed Feb 15 12:25:57 2017 +0100

    Fixed various bugs in the new cache support

diff --git a/src/sentry/lang/native/plugin.py b/src/sentry/lang/native/plugin.py
index c9de1a1e55..0f8ebd8d05 100644
--- a/src/sentry/lang/native/plugin.py
+++ b/src/sentry/lang/native/plugin.py
@@ -9,10 +9,12 @@ import posixpath
 
 from symsynd.demangle import demangle_symbol
 from symsynd.heuristics import find_best_instruction
+from symsynd.utils import parse_addr
 
 from sentry.models import Project, EventError
 from sentry.plugins import Plugin2
-from sentry.lang.native.symbolizer import Symbolizer, SymbolicationFailed
+from sentry.lang.native.symbolizer import Symbolizer, SymbolicationFailed, \
+    ImageLookup
 from sentry.lang.native.utils import \
     find_apple_crash_report_referenced_images, get_sdk_from_event, \
     get_sdk_from_apple_system_info, cpu_name_from_data, APPLE_SDK_MAPPING
@@ -356,6 +358,7 @@ class NativeStacktraceProcessor(StacktraceProcessor):
             self.available = True
             self.debug_meta = debug_meta
             self.sdk_info = get_sdk_from_event(self.data)
+            self.image_lookup = ImageLookup(self.debug_meta['images'])
         else:
             self.available = False
 
@@ -369,6 +372,8 @@ class NativeStacktraceProcessor(StacktraceProcessor):
         """Given a frame, stacktrace info and frame index this returns the
         interpolated instruction address we then use for symbolication later.
         """
+        if self.cpu_name is None:
+            return parse_addr(processable_frame['instruction_addr'])
         meta = None
 
         # We only need to provide meta information for frame zero
@@ -390,7 +395,8 @@ class NativeStacktraceProcessor(StacktraceProcessor):
             }
 
         return find_best_instruction(
-            processable_frame.frame, self.cpu_name, meta=meta)
+            processable_frame['instruction_addr'],
+            self.cpu_name, meta=meta)
 
     def handles_frame(self, frame, stacktrace_info):
         platform = frame.get('platform') or self.data.get('platform')
@@ -402,14 +408,15 @@ class NativeStacktraceProcessor(StacktraceProcessor):
 
     def preprocess_frame(self, processable_frame):
         instr_addr = self.find_best_instruction(processable_frame)
-        img = self.sym.find_image(instr_addr)
+        img = self.image_lookup.find_image(instr_addr)
 
         processable_frame.data = {
             'instruction_addr': instr_addr,
+            'image_uuid': img['uuid'] if img is not None else None,
         }
 
         if img is not None:
-            processable_frame.set_cache_key_from_values(
+            processable_frame.set_cache_key_from_values((
                 FRAME_CACHE_VERSION,
                 processable_frame.data['instruction_addr'],
                 img['uuid'],
@@ -417,19 +424,19 @@ class NativeStacktraceProcessor(StacktraceProcessor):
                 img['cpu_subtype'],
                 img['image_size'],
                 img['image_addr']
-            )
+            ))
 
     def preprocess_step(self, processing_task):
         if not self.available:
             return False
 
         referenced_images = set(
-            pf.data['image']['uuid']
+            pf.data['image_uuid']
             for pf in processing_task.iter_processable_frames(self)
-            if pf.cache_value is None)
+            if pf.cache_value is None and pf.data['image_uuid'] is not None)
 
-        self.sym = Symbolizer(self.project, self.debug_meta['images'],
-                              self.cpu_name,
+        self.sym = Symbolizer(self.project, self.image_lookup,
+                              cpu_name=self.cpu_name,
                               referenced_images=referenced_images)
 
         # The symbolizer gets a reference to the debug meta's images so
@@ -444,7 +451,7 @@ class NativeStacktraceProcessor(StacktraceProcessor):
         new_frames = []
         raw_frame = dict(frame)
 
-        if frame.cache_value is None:
+        if processable_frame.cache_value is None:
             # Construct a raw frame that is used by the symbolizer
             # backend.  We only assemble the bare minimum we need here.
             sym_input_frame = {
@@ -475,13 +482,13 @@ class NativeStacktraceProcessor(StacktraceProcessor):
                                  exc_info=True)
                 return None, [raw_frame], errors
 
-            frame.set_cache_value({
+            processable_frame.set_cache_value({
                 'in_app': in_app,
                 'symbolicated_frames': symbolicated_frames,
             })
         else:
-            raw_frame['in_app'] = in_app = frame.cache_value['in_app']
-            symbolicated_frames = frame.cache_value['symbolicated_frames']
+            raw_frame['in_app'] = in_app = processable_frame.cache_value['in_app']
+            symbolicated_frames = processable_frame.cache_value['symbolicated_frames']
 
         for sfrm in symbolicated_frames:
             symbol = sfrm.get('symbol_name') or \
diff --git a/src/sentry/lang/native/symbolizer.py b/src/sentry/lang/native/symbolizer.py
index 19620b614e..0838a00c14 100644
--- a/src/sentry/lang/native/symbolizer.py
+++ b/src/sentry/lang/native/symbolizer.py
@@ -108,7 +108,7 @@ def find_system_symbol(img, instruction_addr, sdk_info=None, cpu_name=None):
     )
 
 
-def make_symbolizer(project, binary_images, referenced_images=None):
+def make_symbolizer(project, image_lookup, referenced_images=None):
     """Creates a symbolizer for the given project and binary images.  If a
     list of referenced images is referenced (UUIDs) then only images
     needed by those frames are loaded.
@@ -117,7 +117,7 @@ def make_symbolizer(project, binary_images, referenced_images=None):
 
     to_load = referenced_images
     if to_load is None:
-        to_load = [x['uuid'] for x in binary_images]
+        to_load = image_lookup.get_uuids()
 
     dsym_paths, loaded = dsymcache.fetch_dsyms(project, to_load)
 
@@ -125,45 +125,58 @@ def make_symbolizer(project, binary_images, referenced_images=None):
     # symbolizer to avoid the expensive FS operations that will otherwise
     # happen.
     user_images = []
-    for img in binary_images:
+    for img in image_lookup.iter_images():
         if img['uuid'] in loaded:
             user_images.append(img)
 
     return ReportSymbolizer(driver, dsym_paths, user_images)
 
 
-class Symbolizer(object):
-    """This symbolizer dispatches to both symsynd and the system symbols
-    we have in the database and reports errors slightly differently.
-    """
-
-    def __init__(self, project, binary_images, referenced_images=None,
-                 cpu_name=None):
-        self.symsynd_symbolizer = make_symbolizer(
-            project, binary_images, referenced_images=referenced_images)
+class ImageLookup(object):
 
-        # This is a duplication from symsynd.  The reason is that symsynd
-        # will only load images that it can find dsyms for but we also
-        # have system symbols which there are no dsyms for.
+    def __init__(self, images):
         self._image_addresses = []
         self.images = {}
-        for img in binary_images:
+        for img in images:
             img_addr = parse_addr(img['image_addr'])
             self._image_addresses.append(img_addr)
             self.images[img_addr] = img
         self._image_addresses.sort()
 
-        # This should always succeed but you never quite know.
+    def iter_images(self):
+        return six.itervalues(self.images)
+
+    def get_uuids(self):
+        return list(self.iter_uuids())
+
+    def iter_uuids(self):
+        for img in self.iter_images():
+            yield img['uuid']
+
+    def find_image(self, addr):
+        """Given an instruction address this locates the image this address
+        is contained in.
+        """
+        idx = bisect.bisect_left(self._image_addresses, parse_addr(addr))
+        if idx > 0:
+            return self.images[self._image_addresses[idx - 1]]
+
+
+class Symbolizer(object):
+    """This symbolizer dispatches to both symsynd and the system symbols
+    we have in the database and reports errors slightly differently.
+    """
+
+    def __init__(self, project, binary_images, referenced_images=None,
+                 cpu_name=None):
+        if isinstance(binary_images, ImageLookup):
+            self.image_lookup = binary_images
+        else:
+            self.image_lookup = ImageLookup(binary_images)
+        self.symsynd_symbolizer = make_symbolizer(
+            project, self.image_lookup,
+            referenced_images=referenced_images)
         self.cpu_name = cpu_name
-        if self.cpu_name is None:
-            for img in six.itervalues(self.images):
-                cpu_name = get_cpu_name(img['cpu_type'],
-                                        img['cpu_subtype'])
-                if self.cpu_name is None:
-                    self.cpu_name = cpu_name
-                elif self.cpu_name != cpu_name:
-                    self.cpu_name = None
-                    break
 
     def resolve_missing_vmaddrs(self):
         """When called this changes the vmaddr on all contained images from
@@ -174,7 +187,7 @@ class Symbolizer(object):
         changed_any = False
 
         loaded_images = self.symsynd_symbolizer.images
-        for image_addr, image in six.iteritems(self.images):
+        for image_addr, image in six.iteritems(self.image_lookup.images):
             if image.get('image_vmaddr') or not image.get('image_addr'):
                 continue
             image_info = loaded_images.get(image_addr)
@@ -195,14 +208,6 @@ class Symbolizer(object):
     def close(self):
         self.symsynd_symbolizer.driver.close()
 
-    def find_image(self, addr):
-        """Given an instruction address this locates the image this address
-        is contained in.
-        """
-        idx = bisect.bisect_left(self._image_addresses, parse_addr(addr))
-        if idx > 0:
-            return self.images[self._image_addresses[idx - 1]]
-
     def _process_frame(self, frame, img):
         rv = trim_frame(frame)
         if img is not None:
@@ -248,7 +253,7 @@ class Symbolizer(object):
         return _sim_platform_re.search(fn) is not None
 
     def is_in_app(self, frame):
-        img = self.find_image(frame['instruction_addr'])
+        img = self.image_lookup.find_image(frame['instruction_addr'])
         return img is not None and self._is_app_frame(frame, img)
 
     def symbolize_app_frame(self, frame, img, symbolize_inlined=False):
@@ -345,7 +350,7 @@ class Symbolizer(object):
                 message='Found multiple architectures.'
             )
 
-        img = self.find_image(frame['instruction_addr'])
+        img = self.image_lookup.find_image(frame['instruction_addr'])
         if img is None:
             raise SymbolicationFailed(
                 type=EventError.NATIVE_UNKNOWN_IMAGE
diff --git a/src/sentry/lang/native/utils.py b/src/sentry/lang/native/utils.py
index 5aefea95a6..9382399403 100644
--- a/src/sentry/lang/native/utils.py
+++ b/src/sentry/lang/native/utils.py
@@ -3,6 +3,8 @@ from __future__ import absolute_import
 import six
 import logging
 
+from symsynd.macho.arch import get_cpu_name
+
 from sentry.interfaces.contexts import DeviceContextType
 
 
@@ -136,3 +138,17 @@ def cpu_name_from_data(data):
         arch = device.get('arch')
         if isinstance(arch, six.string_types):
             return arch
+
+    # TODO: kill this here.  we want to not support that going forward
+    unique_cpu_name = None
+    images = (data.get('debug_meta') or {}).get('images') or []
+    for img in images:
+        cpu_name = get_cpu_name(img['cpu_type'],
+                                img['cpu_subtype'])
+        if unique_cpu_name is None:
+            unique_cpu_name = cpu_name
+        elif unique_cpu_name != cpu_name:
+            unique_cpu_name = None
+            break
+
+    return unique_cpu_name
diff --git a/src/sentry/stacktraces.py b/src/sentry/stacktraces.py
index 2af375a0b8..3d1accface 100644
--- a/src/sentry/stacktraces.py
+++ b/src/sentry/stacktraces.py
@@ -103,7 +103,7 @@ class StacktraceProcessingTask(object):
         return six.iteritems(self.processable_stacktraces)
 
     def iter_processable_frames(self, processor=None):
-        for frames in self.iter_processable_stacktraces():
+        for _, frames in self.iter_processable_stacktraces():
             for frame in frames:
                 if processor is None or frame.processor == processor:
                     yield frame
@@ -257,6 +257,7 @@ def process_single_stacktrace(processing_task, stacktrace_info,
                 processable_frame, processing_task)
         except Exception:
             logger.exception('Failed to process frame')
+            rv = None
         expand_processed, expand_raw, errors = rv or (None, None, None)
 
         if expand_processed is not None:
@@ -321,7 +322,7 @@ def get_stacktrace_processing_task(infos, processors):
 
     frame_cache = lookup_frame_cache(to_lookup)
     for cache_key, processable_frame in six.iteritems(to_lookup):
-        processable_frames.cache_value = frame_cache.get(cache_key)
+        processable_frame.cache_value = frame_cache.get(cache_key)
 
     return StacktraceProcessingTask(
         processable_stacktraces=by_stacktrace_info,

commit 4f42c3b75a1d55763f16704f5df207cb05233b07
Author: David Cramer <dcramer@gmail.com>
Date:   Mon Nov 19 21:21:27 2012 -0800

    Remove a large amount of deprecated legacy support and initial version of protocol 3

diff --git a/CHANGES b/CHANGES
index d53815c08b..51e42136a9 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,3 +1,11 @@
+Version 5.1.0
+-------------
+
+- Signed messages are no longer supported (signatures are not calculated).
+- Clients should pass sentry_secret for server-side requests as part of the auth
+  header.
+
+
 Version 5.0.0
 -------------
 
diff --git a/docs/developer/client/index.rst b/docs/developer/client/index.rst
index bd44a14536..bf18a4c8b4 100644
--- a/docs/developer/client/index.rst
+++ b/docs/developer/client/index.rst
@@ -131,7 +131,6 @@ For example, with an included Exception event, a basic JSON body might resemble
 
         {
             "event_id": "fc6d8c0c43fc4630ad850ee518f1b9d0",
-            "project": "default",
             "culprit": "my.module.function_name",
             "timestamp": "2011-05-02T17:41:36",
             "message": "SyntaxError: Wattttt!",
@@ -147,16 +146,6 @@ For example, with an included Exception event, a basic JSON body might resemble
 
 The following attributes are required for all events:
 
-.. data:: project
-
-    String value representing the project
-
-    ::
-
-        {
-            "project": "default"
-        }
-
 .. data:: event_id
 
     Hexadecimal string representing a uuid4 value.
@@ -330,7 +319,8 @@ An authentication header is expected to be sent along with the message body, whi
     X-Sentry-Auth: Sentry sentry_version=2.0,
     sentry_client=<client version, arbitrary>,
     sentry_timestamp=<current timestamp>,
-    sentry_key=<public api key>
+    sentry_key=<public api key>,
+    sentry_secret=<secret api key>
 
 .. note:: You should include the client version string in the User-Agent portion of the header, and it will be used if
           sentry_client is not sent in the auth header.
@@ -353,7 +343,15 @@ An authentication header is expected to be sent along with the message body, whi
 
 .. data:: sentry_key
 
-    The public key which should be provided as part of the client configuration
+    The public key which should be provided as part of the client configuration.
+
+.. data:: sentry_secret
+
+    The secret key which should be provided as part of the client configuration.
+
+    .. note:: You should only pass the secret key if you're communicating via the server. Client-side behavior (such
+              as JavaScript) should use CORS.
+
 
 
 A Working Example
@@ -368,8 +366,9 @@ The request body should then somewhat resemble the following::
 
     POST /api/store/
     User-Agent: raven-python/1.0
-    X-Sentry-Auth: Sentry sentry_version=2.0, sentry_timestamp=1329096377,
-        sentry_key=b70a31b3510c4cf793964a185cfe1fd0, sentry_client=raven-python/1.0
+    X-Sentry-Auth: Sentry sentry_version=3, sentry_timestamp=1329096377,
+        sentry_key=b70a31b3510c4cf793964a185cfe1fd0, sentry_client=raven-python/1.0,
+        sentry_secret=b7d80b520139450f903720eb7991bf3d
 
     {
         "project": "default",
diff --git a/src/sentry/coreapi.py b/src/sentry/coreapi.py
index b2e1474050..0b90b2de77 100644
--- a/src/sentry/coreapi.py
+++ b/src/sentry/coreapi.py
@@ -12,7 +12,6 @@ sentry.coreapi
 from datetime import datetime
 import base64
 import logging
-import time
 import uuid
 import zlib
 
@@ -24,7 +23,7 @@ from sentry.models import Project, ProjectKey, TeamMember, Team
 from sentry.plugins import plugins
 from sentry.tasks.store import store_event
 from sentry.utils import is_float, json
-from sentry.utils.auth import get_signature, parse_auth_header
+from sentry.utils.auth import parse_auth_header
 from sentry.utils.imports import import_string
 from sentry.utils.queue import maybe_delay
 
@@ -75,69 +74,46 @@ class APITimestampExpired(APIError):
 
 def extract_auth_vars(request):
     if request.META.get('HTTP_X_SENTRY_AUTH', '').startswith('Sentry'):
-        # Auth version 3.0 (same as 2.0, diff header)
         return parse_auth_header(request.META['HTTP_X_SENTRY_AUTH'])
     elif request.META.get('HTTP_AUTHORIZATION', '').startswith('Sentry'):
-        # Auth version 2.0
         return parse_auth_header(request.META['HTTP_AUTHORIZATION'])
     else:
         return None
 
 
-def project_from_auth_vars(auth_vars, data, require_signature=False):
+def project_from_auth_vars(auth_vars):
     api_key = auth_vars.get('sentry_key')
-    if api_key:
-        try:
-            pk = ProjectKey.objects.get_from_cache(public_key=api_key)
-        except ProjectKey.DoesNotExist:
-            raise APIForbidden('Invalid signature')
-
-        project = Project.objects.get_from_cache(pk=pk.project_id)
-        secret_key = pk.secret_key
-
-        if pk.user:
-            try:
-                team = Team.objects.get_from_cache(pk=project.team_id)
-            except Team.DoesNotExist:
-                raise APIUnauthorized('Member does not have access to project')
-
-            try:
-                tm = TeamMember.objects.get(team=team, user=pk.user, is_active=True)
-            except TeamMember.DoesNotExist:
-                raise APIUnauthorized('Member does not have access to project')
-
-            if not pk.user.is_active:
-                raise APIUnauthorized('Account is not active')
-
-        result = plugins.first('has_perm', tm.user, 'create_event', project)
-        if result is False:
-            raise APIForbidden('Creation of this event was blocked')
-    else:
-        project = None
-        secret_key = settings.KEY
+    if not api_key:
+        return None
+    try:
+        pk = ProjectKey.objects.get_from_cache(public_key=api_key)
+    except ProjectKey.DoesNotExist:
+        raise APIForbidden('Invalid api key')
 
-    signature = auth_vars.get('sentry_signature')
-    timestamp = auth_vars.get('sentry_timestamp')
-    if signature and timestamp:
-        validate_hmac(data, signature, timestamp, secret_key)
-    elif require_signature:
-        raise APIUnauthorized('Missing signature')
+    if pk.secret_key != auth_vars.get('sentry_secret', pk.secret_key):
+        raise APIForbidden('Invalid api key')
 
-    return project
+    project = Project.objects.get_from_cache(pk=pk.project_id)
 
+    if pk.user:
+        try:
+            team = Team.objects.get_from_cache(pk=project.team_id)
+        except Team.DoesNotExist:
+            raise APIUnauthorized('Member does not have access to project')
 
-def validate_hmac(message, signature, timestamp, secret_key):
-    try:
-        timestamp_float = float(timestamp)
-    except ValueError:
-        raise APIError('Invalid timestamp')
+        try:
+            tm = TeamMember.objects.get(team=team, user=pk.user, is_active=True)
+        except TeamMember.DoesNotExist:
+            raise APIUnauthorized('Member does not have access to project')
 
-    if timestamp_float < time.time() - 3600:  # 1 hour
-        raise APITimestampExpired('Message has expired')
+        if not pk.user.is_active:
+            raise APIUnauthorized('Account is not active')
 
-    sig_hmac = get_signature(message, timestamp, secret_key)
-    if sig_hmac != signature:
-        raise APIForbidden('Invalid signature')
+    result = plugins.first('has_perm', tm.user, 'create_event', project)
+    if result is False:
+        raise APIForbidden('Creation of this event was blocked')
+
+    return project
 
 
 def project_from_api_key_and_id(api_key, project_id):
@@ -244,12 +220,14 @@ def safely_load_json_string(json_string):
 def ensure_valid_project_id(desired_project, data):
     # Confirm they're using either the master key, or their specified project
     # matches with the signed project.
-    if desired_project:
-        if str(data.get('project', '')) not in [str(desired_project.pk), desired_project.slug]:
+    if desired_project and data.get('project'):
+        if str(data.get('project')) not in [str(desired_project.id), desired_project.slug]:
             raise APIForbidden('Invalid credentials')
-        data['project'] = desired_project.pk
+        data['project'] = desired_project.id
     elif not desired_project:
         data['project'] = 1
+    elif not data.get('project'):
+        data['project'] = desired_project.id
 
 
 def process_data_timestamp(data):
diff --git a/src/sentry/services/udp.py b/src/sentry/services/udp.py
index 49b543d723..9bcb4b8270 100644
--- a/src/sentry/services/udp.py
+++ b/src/sentry/services/udp.py
@@ -31,7 +31,7 @@ def handle_sentry(data, address):
             raise APIError('missing auth header')
 
         auth_vars = parse_auth_header(auth_header)
-        project = project_from_auth_vars(auth_vars, data)
+        project = project_from_auth_vars(auth_vars)
 
         client = auth_vars.get('sentry_client')
 
diff --git a/src/sentry/testutils.py b/src/sentry/testutils.py
index 73acf1e098..c08d5a51c9 100644
--- a/src/sentry/testutils.py
+++ b/src/sentry/testutils.py
@@ -9,15 +9,14 @@ sentry.testutils
 from __future__ import absolute_import
 
 import base64
-import time
 
 from sentry.conf import settings
 from sentry.utils import json
-from sentry.utils.auth import get_signature, get_auth_header
-from sentry.utils.compat import pickle
+from sentry.utils.auth import get_auth_header
 
 
 from django.conf import settings as django_settings
+from django.contrib.auth.models import User
 from django.core.cache import cache
 from django.core.management import call_command
 from django.core.urlresolvers import reverse
@@ -25,7 +24,7 @@ from django.db import connections, DEFAULT_DB_ALIAS
 from django.test import TestCase, TransactionTestCase
 from django.test.client import Client
 
-from sentry.models import ProjectOption, Option
+from sentry.models import Project, ProjectOption, Option
 from sentry.utils import cached_property
 
 
@@ -74,42 +73,43 @@ class BaseTestCase(object):
 
     Settings = Settings
 
+    @fixture
+    def projectkey(self):
+        user = User.objects.create(username='coreapi')
+        project = Project.objects.create(owner=user, name='Foo', slug='bar')
+        project.team.member_set.get_or_create(user=user)[0]
+        return project.key_set.get_or_create(user=user)[0]
+
     def _pre_setup(self):
         cache.clear()
         ProjectOption.objects.clear_cache()
         Option.objects.clear_cache()
         super(BaseTestCase, self)._pre_setup()
 
+    def _makeMessage(self, data):
+        return base64.b64encode(json.dumps(data))
+
     def _postWithKey(self, data, key=None):
         resp = self.client.post(reverse('sentry-api-store'), {
-            'data': base64.b64encode(pickle.dumps(data)),
+            'data': self._makeMessage(data),
             'key': settings.KEY,
         })
         return resp
 
-    def _makeMessage(self, data, key=None):
-        ts = time.time()
-        message = base64.b64encode(json.dumps(data))
-        sig = get_signature(message, ts, key)
-        return ts, message, sig
-
-    def _postWithSignature(self, data, key=None):
-        ts, message, sig = self._makeMessage(data, key)
+    def _postWithHeader(self, data, key=None, secret=None):
+        if key is None:
+            key = self.projectkey.public_key
+            secret = self.projectkey.secret_key
 
+        message = self._makeMessage(data)
         resp = self.client.post(reverse('sentry-api-store'), message,
             content_type='application/octet-stream',
-            HTTP_AUTHORIZATION=get_auth_header(sig, ts, '_postWithSignature', key),
+            HTTP_X_SENTRY_AUTH=get_auth_header('_postWithHeader', key, secret),
         )
         return resp
 
-    def _postWithNewSignature(self, data, key=None):
-        ts, message, sig = self._makeMessage(data, key)
-
-        resp = self.client.post(reverse('sentry-api-store'), message,
-            content_type='application/octet-stream',
-            HTTP_X_SENTRY_AUTH=get_auth_header(sig, ts, '_postWithSignature', key),
-        )
-        return resp
+    _postWithSignature = _postWithHeader
+    _postWithNewSignature = _postWithHeader
 
 
 class TestCase(BaseTestCase, TestCase):
diff --git a/src/sentry/utils/auth.py b/src/sentry/utils/auth.py
index 46e62d9b17..20b518c0c3 100644
--- a/src/sentry/utils/auth.py
+++ b/src/sentry/utils/auth.py
@@ -5,28 +5,22 @@ sentry.utils.auth
 :copyright: (c) 2010-2012 by the Sentry Team, see AUTHORS for more details.
 :license: BSD, see LICENSE for more details.
 """
-import hashlib
-import hmac
 from django.conf import settings as dj_settings
 from django.contrib.auth.models import User
 from django.contrib.auth.backends import ModelBackend
 from sentry.conf import settings
 
 
-def get_signature(message, timestamp, key=None):
-    if not key:
-        key = settings.KEY
-    return hmac.new(str(key), '%s %s' % (timestamp, message), hashlib.sha1).hexdigest()
-
-
-def get_auth_header(signature, timestamp, client, api_key=None):
+def get_auth_header(client, api_key=None, secret_key=None):
     header = [
-        ('sentry_timestamp', timestamp),
-        ('sentry_signature', signature),
         ('sentry_client', client),
+        ('sentry_version', '3'),
     ]
+
     if api_key:
         header.append(('sentry_key', api_key))
+    if secret_key:
+        header.append(('sentry_secret', secret_key))
 
     return 'Sentry %s' % ', '.join('%s=%s' % (k, v) for k, v in header)
 
diff --git a/src/sentry/web/api.py b/src/sentry/web/api.py
index ca95254144..7787dd0e50 100644
--- a/src/sentry/web/api.py
+++ b/src/sentry/web/api.py
@@ -15,24 +15,21 @@ from django.http import HttpResponse, HttpResponseBadRequest, \
 from django.utils import timezone
 from django.views.decorators.cache import never_cache
 from django.views.decorators.csrf import csrf_exempt
-from django.views.decorators.http import require_http_methods
 from django.views.decorators.vary import vary_on_cookie
-from functools import wraps
+from django.views.generic.base import View as BaseView
 from sentry.conf import settings
 from sentry.constants import MEMBER_USER
-from sentry.coreapi import project_from_auth_vars, project_from_id, \
+from sentry.coreapi import project_from_auth_vars, \
   decode_and_decompress_data, safely_load_json_string, validate_data, \
-  insert_data_to_database, APIError, APIUnauthorized, extract_auth_vars
-from sentry.models import Group, GroupBookmark, Project, ProjectCountByMinute, \
-  View
+  insert_data_to_database, APIError, extract_auth_vars
 from sentry.exceptions import InvalidData
-from sentry.models import Group, GroupBookmark, Project, View, FilterValue
+from sentry.models import Group, GroupBookmark, Project, ProjectCountByMinute, View, FilterValue
 from sentry.templatetags.sentry_helpers import with_metadata
 from sentry.utils import json
 from sentry.utils.cache import cache
 from sentry.utils.db import has_trending
 from sentry.utils.javascript import to_json
-from sentry.utils.http import is_same_domain, is_valid_origin, apply_access_control_headers, \
+from sentry.utils.http import is_valid_origin, apply_access_control_headers, \
   get_origins
 from sentry.web.decorators import has_access
 from sentry.web.frontend.groups import _get_group_list
@@ -63,37 +60,86 @@ def transform_groups(request, group_list, template='sentry/partial/_group.html')
     ]
 
 
-def api_method(func):
-    @wraps(func)
-    @csrf_exempt
-    def wrapped(request, project_id=None, *args, **kwargs):
+class Auth(object):
+    def __init__(self, auth_vars):
+        self.client = auth_vars.get('client')
+
+
+class APIView(BaseView):
+    def _get_project_from_id(self, project_id):
         if project_id:
             if project_id.isdigit():
                 lookup_kwargs = {'id': int(project_id)}
             else:
                 lookup_kwargs = {'slug': project_id}
+
             try:
-                project = Project.objects.get_from_cache(**lookup_kwargs)
+                return Project.objects.get_from_cache(**lookup_kwargs)
             except Project.DoesNotExist:
-                return HttpResponse('Invalid project_id: %r' % project_id, status=400)
-        else:
-            project = None
+                raise APIError('Invalid project_id: %r' % project_id)
+        return None
+
+    def _parse_header(self, request, project):
+        auth_vars = extract_auth_vars(request)
+
+        if not auth_vars:
+            raise APIError('Client/server version mismatch: Unsupported client')
+
+        server_version = auth_vars.get('sentry_version', '1.0')
+        client = auth_vars.get('sentry_client')
+
+        if server_version not in ('2.0', '3'):
+            raise APIError('Client/server version mismatch: Unsupported protocol version (%s)' % server_version)
+
+        if not client:
+            raise APIError('Client request error: Missing client version identifier.')
+
+        return auth_vars
+
+    @csrf_exempt
+    def dispatch(self, request, project_id=None, *args, **kwargs):
+        try:
+            project = self._get_project_from_id(project_id)
+        except APIError, e:
+            return HttpResponse(str(e), status=400)
+
+        try:
+            auth_vars = self._parse_header(request, project)
+        except APIError, e:
+            return HttpResponse(str(e), status=400)
+
+        project_ = project_from_auth_vars(auth_vars)
+
+        # Legacy API was /api/store/ and the project ID was only available elsewhere
+        if not project:
+            if not project_:
+                return HttpResponse('Unable to identify project', status=400)
+            project = project_
+        elif project_ != project:
+            return HttpResponse('Project ID mismatch', status=400)
 
         origin = request.META.get('HTTP_ORIGIN', None)
         if origin is not None and not is_valid_origin(origin, project):
             return HttpResponse('Invalid origin: %r' % origin, status=400)
 
-        response = func(request, project, *args, **kwargs)
-        response = apply_access_control_headers(response, origin)
+        auth = Auth(auth_vars)
+
+        try:
+            response = super(APIView, self).dispatch(request, project=project, auth=auth, **kwargs)
+
+        except APIError, error:
+            logger.info('Project %r raised API error: %s', project.slug, error, extra={
+                'request': request,
+            }, exc_info=True)
+            response = HttpResponse(unicode(error.msg), status=error.http_status)
+
+        else:
+            response = apply_access_control_headers(response, origin)
 
         return response
-    return wrapped
 
 
-@require_http_methods(['POST', 'OPTIONS'])
-@never_cache
-@api_method
-def store(request, project=None):
+class StoreView(APIView):
     """
     The primary endpoint for storing new events.
 
@@ -122,74 +168,26 @@ def store(request, project=None):
        the user be authenticated, and a project_id be sent in the GET variables.
 
     """
-    logger.debug('Inbound %r request from %r (%s)', request.method, request.META['REMOTE_ADDR'],
-        request.META.get('HTTP_USER_AGENT'))
-    client = '<unknown client>'
-
-    response = HttpResponse()
-
-    if request.method == 'POST':
-        try:
-            auth_vars = extract_auth_vars(request)
-            data = request.raw_post_data
-
-            if auth_vars:
-                server_version = auth_vars.get('sentry_version', '1.0')
-                client = auth_vars.get('sentry_client', request.META.get('HTTP_USER_AGENT'))
-            else:
-                server_version = request.GET.get('version', '1.0')
-                client = request.META.get('HTTP_USER_AGENT', request.GET.get('client'))
-
-            if server_version not in ('1.0', '2.0'):
-                raise APIError('Client/server version mismatch: Unsupported version: %r' % server_version)
-
-            if server_version != '1.0' and not client:
-                raise APIError('Client request error: Missing client version identifier.')
-
-            referrer = request.META.get('HTTP_REFERER')
+    http_method_names = ['post', 'options']
 
-            if auth_vars:
-                # We only require a signature if a referrer was not set
-                # (this is restricted via the CORS headers)
-                project_ = project_from_auth_vars(auth_vars, data,
-                    require_signature=False)
+    @never_cache
+    def post(self, request, project, auth, **kwargs):
+        data = request.raw_post_data
 
-                if not project:
-                    project = project_
-                elif project_ != project:
-                    raise APIError('Project ID mismatch')
+        if not data.startswith('{'):
+            data = decode_and_decompress_data(data)
+        data = safely_load_json_string(data)
 
-            elif request.user.is_authenticated() and is_same_domain(request.build_absolute_uri(), referrer):
-                # authenticated users are simply trusted to provide the right id
-                project_ = project_from_id(request)
-
-                if not project:
-                    project = project_
-                elif project_ != project:
-                    raise APIError('Project ID mismatch')
-
-            else:
-                raise APIUnauthorized('No authentication provided')
-
-            if not data.startswith('{'):
-                data = decode_and_decompress_data(data)
-            data = safely_load_json_string(data)
+        try:
+            validate_data(project, data, auth.client)
+        except InvalidData, e:
+            raise APIError(u'Invalid data: %s (%s)' % (unicode(e), type(e)))
 
-            try:
-                validate_data(project, data, client)
-            except InvalidData, e:
-                raise APIError(u'Invalid data: %s (%s)' % (unicode(e), type(e)))
+        insert_data_to_database(data)
 
-            insert_data_to_database(data)
-        except APIError, error:
-            logger.info('Client %r raised API error: %s', client, error, extra={
-                'request': request,
-            }, exc_info=True)
-            response = HttpResponse(unicode(error.msg), status=error.http_status)
-        else:
-            logger.info('New event from client %r (id=%s)', client, data['event_id'])
+        logger.info('New event from project %r (id=%s)', project.slug, data['event_id'])
 
-    return response
+        return HttpResponse()
 
 
 @csrf_exempt
diff --git a/src/sentry/web/urls.py b/src/sentry/web/urls.py
index f9378ebbf3..ae6f566ffe 100644
--- a/src/sentry/web/urls.py
+++ b/src/sentry/web/urls.py
@@ -34,16 +34,6 @@ init_all_applications()
 urlpatterns = patterns('',
     url(r'^_static/(?P<module>[^/]+)/(?P<path>.*)$', generic.static_media, name='sentry-media'),
 
-    # Legacy API
-    url(r'^store/$', api.store),
-
-    # Legacy redirects
-
-    url(r'^group/(?P<group_id>\d+)$', groups.group),
-    url(r'^group/(?P<group_id>\d+)/messages$', groups.group_event_list),
-    url(r'^group/(?P<group_id>\d+)/messages/(?P<event_id>\d+)$', groups.group_event_details),
-    url(r'^group/(?P<group_id>\d+)/actions/(?P<slug>[\w_-]+)$', groups.group_plugin_action),
-
     # Account
 
     url(r'^login/$', accounts.login, name='sentry-login'),
@@ -129,10 +119,10 @@ urlpatterns = patterns('',
 
     # API / JS
 
-    url(r'^api/store/$', api.store, name='sentry-api-store'),
+    url(r'^api/store/$', api.StoreView.as_view(), name='sentry-api-store'),
     url(r'^api/notification/$', api.notification, name='sentry-api-notification'),
     url(r'^api/(?P<project_id>[\w_-]+)/crossdomain\.xml$', api.crossdomain_xml, name='sentry-api-crossdomain-xml'),
-    url(r'^api/(?P<project_id>[\w_-]+)/store/$', api.store, name='sentry-api-store'),
+    url(r'^api/(?P<project_id>[\w_-]+)/store/$', api.StoreView.as_view(), name='sentry-api-store'),
     url(r'^api/(?P<project_id>[\w_-]+)/poll/$', api.poll, name='sentry-api-poll'),
     url(r'^api/(?P<project_id>[\w_-]+)/resolve/$', api.resolve, name='sentry-api-resolve'),
     url(r'^api/(?P<project_id>[\w_-]+)/bookmark/$', api.bookmark, name='sentry-api-bookmark'),
diff --git a/tests/sentry/coreapi/tests.py b/tests/sentry/coreapi/tests.py
index f6ad0668d2..16d2a705f1 100644
--- a/tests/sentry/coreapi/tests.py
+++ b/tests/sentry/coreapi/tests.py
@@ -4,18 +4,15 @@ from __future__ import absolute_import
 
 import datetime
 import mock
-import time
 
 from django.contrib.auth.models import User
 
 from sentry.models import Project
 from sentry.exceptions import InvalidTimestamp, InvalidInterface, InvalidData
 from sentry.coreapi import project_from_id, project_from_api_key_and_id, \
-  extract_auth_vars, project_from_auth_vars, validate_hmac, APIUnauthorized, \
-  APIForbidden, APITimestampExpired, APIError, process_data_timestamp, \
+  extract_auth_vars, project_from_auth_vars, APIUnauthorized, \
+  APIForbidden, process_data_timestamp, \
   insert_data_to_database, validate_data
-from sentry.utils.auth import get_signature
-
 from sentry.testutils import TestCase
 
 
@@ -27,14 +24,6 @@ class BaseAPITest(TestCase):
         self.pk = self.project.key_set.get_or_create(user=self.user)[0]
 
 
-class GetSignatureTest(BaseAPITest):
-    def test_valid_string(self):
-        self.assertEquals(get_signature('x', 'y', 'z'), '77e1f5656ddc2e93f64469cc18f9f195fe665428')
-
-    def test_valid_unicode(self):
-        self.assertEquals(get_signature(u'x', u'y', u'z'), '77e1f5656ddc2e93f64469cc18f9f195fe665428')
-
-
 class ProjectFromIdTest(BaseAPITest):
     def test_valid(self):
         request = mock.Mock()
@@ -133,86 +122,45 @@ class ExtractAuthVarsTest(BaseAPITest):
 
 class ProjectFromAuthVarsTest(BaseAPITest):
     def test_valid_without_key(self):
-        auth_vars = {
-            'sentry_signature': 'adf',
-            'sentry_timestamp': time.time(),
-        }
-        with mock.patch('sentry.coreapi.validate_hmac') as validate_hmac_:
-            validate_hmac_.return_value = True
-
-            # without key
-            result = project_from_auth_vars(auth_vars, '')
-            self.assertEquals(result, None)
-
-            # with key
-            auth_vars['sentry_key'] = self.pk.public_key
-            result = project_from_auth_vars(auth_vars, '')
-            self.assertEquals(result, self.project)
+        auth_vars = {}
+
+        # without key
+        result = project_from_auth_vars(auth_vars)
+        self.assertEquals(result, None)
+
+        # with key
+        auth_vars['sentry_key'] = self.pk.public_key
+        result = project_from_auth_vars(auth_vars)
+        self.assertEquals(result, self.project)
 
     def test_inactive_user(self):
         user = self.pm.user
         user.is_active = False
         user.save()
 
-        auth_vars = {
-            'sentry_signature': 'adf',
-            'sentry_timestamp': time.time(),
-        }
-        with mock.patch('sentry.coreapi.validate_hmac') as validate_hmac_:
-            validate_hmac_.return_value = True
+        auth_vars = {}
 
-            # without key
-            result = project_from_auth_vars(auth_vars, '')
-            self.assertEquals(result, None)
+        # without key
+        result = project_from_auth_vars(auth_vars)
+        self.assertEquals(result, None)
 
-            # with key
-            auth_vars['sentry_key'] = self.pk.public_key
-            self.assertRaises(APIUnauthorized, project_from_auth_vars, auth_vars, '')
+        # with key
+        auth_vars['sentry_key'] = self.pk.public_key
+        self.assertRaises(APIUnauthorized, project_from_auth_vars, auth_vars)
 
     def test_inactive_member(self):
         self.pm.is_active = False
         self.pm.save()
 
-        auth_vars = {
-            'sentry_signature': 'adf',
-            'sentry_timestamp': time.time(),
-        }
-        with mock.patch('sentry.coreapi.validate_hmac') as validate_hmac_:
-            validate_hmac_.return_value = True
-
-            # without key
-            result = project_from_auth_vars(auth_vars, '')
-            self.assertEquals(result, None)
+        auth_vars = {}
 
-            # with key
-            auth_vars['sentry_key'] = self.pk.public_key
-            self.assertRaises(APIUnauthorized, project_from_auth_vars, auth_vars, '')
-
-
-class ValidateHmacTest(BaseAPITest):
-    def test_valid(self):
-        with mock.patch('sentry.coreapi.get_signature') as get_signature:
-            get_signature.return_value = 'signature'
-
-            validate_hmac('foo', 'signature', time.time(), 'foo')
-
-    def test_invalid_signature(self):
-        with mock.patch('sentry.coreapi.get_signature') as get_signature:
-            get_signature.return_value = 'notsignature'
-
-            self.assertRaises(APIForbidden, validate_hmac, 'foo', 'signature', time.time(), 'foo')
-
-    def test_timestamp_expired(self):
-        with mock.patch('sentry.coreapi.get_signature') as get_signature:
-            get_signature.return_value = 'signature'
-
-            self.assertRaises(APITimestampExpired, validate_hmac, 'foo', 'signature', time.time() - 3601, 'foo')
-
-    def test_invalid_timestamp(self):
-        with mock.patch('sentry.coreapi.get_signature') as get_signature:
-            get_signature.return_value = 'signature'
+        # without key
+        result = project_from_auth_vars(auth_vars)
+        self.assertEquals(result, None)
 
-            self.assertRaises(APIError, validate_hmac, 'foo', 'signature', 'foo', 'foo')
+        # with key
+        auth_vars['sentry_key'] = self.pk.public_key
+        self.assertRaises(APIUnauthorized, project_from_auth_vars, auth_vars)
 
 
 class ProcessDataTimestampTest(BaseAPITest):
@@ -257,9 +205,10 @@ class InsertDataToDatabaseTest(BaseAPITest):
 
 class ValidateDataTest(BaseAPITest):
     def test_missing_project_id(self):
-        self.assertRaises(APIForbidden, validate_data, self.project, {
+        data = validate_data(self.project, {
             'message': 'foo',
         })
+        self.assertEquals(data['project'], self.project.id)
 
     def test_invalid_project_id(self):
         self.assertRaises(APIForbidden, validate_data, self.project, {
diff --git a/tests/sentry/http/tests.py b/tests/sentry/http/tests.py
index cc249a6488..a281664ddd 100644
--- a/tests/sentry/http/tests.py
+++ b/tests/sentry/http/tests.py
@@ -5,13 +5,12 @@ from __future__ import absolute_import
 import datetime
 import mock
 
+from django.contrib.auth.models import User
 from django.core.urlresolvers import reverse
 from django.utils import timezone
 
 from raven import Client
-from sentry.conf import settings
-from sentry.models import Group, Event
-
+from sentry.models import Group, Event, Project
 from sentry.testutils import TestCase
 
 
@@ -20,6 +19,12 @@ class RavenIntegrationTest(TestCase):
     This mocks the test server and specifically tests behavior that would
     happen between Raven <--> Sentry over HTTP communication.
     """
+    def setUp(self):
+        self.user = User.objects.create(username='coreapi')
+        self.project = Project.objects.create(owner=self.user, name='Foo', slug='bar')
+        self.pm = self.project.team.member_set.get_or_create(user=self.user)[0]
+        self.pk = self.project.key_set.get_or_create(user=self.user)[0]
+
     def sendRemote(self, url, data, headers={}):
         # TODO: make this install a temporary handler which raises an assertion error
         import logging
@@ -29,7 +34,7 @@ class RavenIntegrationTest(TestCase):
 
         content_type = headers.pop('Content-Type', None)
         headers = dict(('HTTP_' + k.replace('-', '_').upper(), v) for k, v in headers.iteritems())
-        resp = self.client.post(reverse('sentry-api-store'),
+        resp = self.client.post(reverse('sentry-api-store', args=[self.pk.project_id]),
             data=data,
             content_type=content_type,
             **headers)
@@ -39,12 +44,14 @@ class RavenIntegrationTest(TestCase):
     def test_basic(self, send_remote):
         send_remote.side_effect = self.sendRemote
         client = Client(
-            project=settings.PROJECT,
-            servers=['http://localhost:8000%s' % reverse('sentry-api-store')],
-            key=settings.KEY,
+            project=self.pk.project_id,
+            servers=['http://localhost:8000%s' % reverse('sentry-api-store', args=[self.pk.project_id])],
+            public_key=self.pk.public_key,
+            secret_key=self.pk.secret_key,
         )
         client.capture('Message', message='foo')
 
+        send_remote.assert_called_once()
         self.assertEquals(Group.objects.count(), 1)
         group = Group.objects.get()
         self.assertEquals(group.event_set.count(), 1)
@@ -53,18 +60,10 @@ class RavenIntegrationTest(TestCase):
 
 
 class SentryRemoteTest(TestCase):
-    def test_no_client_version(self):
-        resp = self.client.post(reverse('sentry-api-store') + '?version=2.0')
-        self.assertEquals(resp.status_code, 400, resp.content)
-
-    def test_no_key(self):
-        resp = self.client.post(reverse('sentry-api-store'))
-        self.assertEquals(resp.status_code, 401, resp.content)
-
     def test_correct_data(self):
         kwargs = {'message': 'hello', 'server_name': 'not_dcramer.local', 'level': 40, 'site': 'not_a_real_site'}
-        resp = self._postWithSignature(kwargs)
-        self.assertEquals(resp.status_code, 200)
+        resp = self._postWithHeader(kwargs)
+        self.assertEquals(resp.status_code, 200, resp.content)
         instance = Event.objects.get()
         self.assertEquals(instance.message, 'hello')
         self.assertEquals(instance.server_name, 'not_dcramer.local')
@@ -153,4 +152,3 @@ class SentryRemoteTest(TestCase):
         self.assertEquals(instance.server_name, 'not_dcramer.local')
         self.assertEquals(instance.site, 'not_a_real_site')
         self.assertEquals(instance.level, 40)
-
diff --git a/tests/sentry/udp/tests.py b/tests/sentry/udp/tests.py
index 083ffc1480..a78bdc1237 100644
--- a/tests/sentry/udp/tests.py
+++ b/tests/sentry/udp/tests.py
@@ -18,6 +18,6 @@ class SentryUDPTest(TestCase):
 
     def test_success(self):
         data = {'message': 'hello', 'server_name': 'not_dcramer.local', 'level': 40, 'site': 'not_a_real_site'}
-        ts, message, sig = self._makeMessage(data)
-        packet = get_auth_header(sig, ts, 'udpTest') + '\n\n' + message
+        message = self._makeMessage(data)
+        packet = get_auth_header('udpTest') + '\n\n' + message
         self.assertEquals(None, self.server.handle(packet, self.address))

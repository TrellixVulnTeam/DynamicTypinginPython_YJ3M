commit cc9f152f8c1ffdc2cfb52c3eb1737fd02a31ccde
Author: Alex Hofsteede <alex@hofsteede.com>
Date:   Wed Dec 5 14:58:14 2018 -0800

    Revert "feat: Allow specifying node_id (#10399)" (#10939)
    
    There is something not quite correct in the fallback path for generating
    node_ids. Reverting to have more time to investigate/repro
    
    This reverts commit 30dd542896c40c8fb324b50d614d73685db1b9af.

diff --git a/src/sentry/db/models/fields/node.py b/src/sentry/db/models/fields/node.py
index 42175315b2..4294248575 100644
--- a/src/sentry/db/models/fields/node.py
+++ b/src/sentry/db/models/fields/node.py
@@ -8,12 +8,10 @@ sentry.db.models.fields.node
 
 from __future__ import absolute_import, print_function
 
-from base64 import b64encode
 import collections
 import logging
 import six
 import warnings
-from uuid import uuid4
 
 from django.conf import settings
 from django.db import models
@@ -41,17 +39,8 @@ class NodeIntegrityFailure(Exception):
 
 
 class NodeData(collections.MutableMapping):
-    """
-        A wrapper for nodestore data that fetches the underlying data
-        from nodestore.
-
-        Initializing with:
-        data=None means, this is a node that needs to be fetched from nodestore.
-        data={...} means, this is an object that should be saved to nodestore.
-    """
     def __init__(self, field, id, data=None):
         self.field = field
-        assert id is not None
         self.id = id
         self.ref = None
         # ref version is used to discredit a previous ref
@@ -111,10 +100,6 @@ class NodeData(collections.MutableMapping):
 
     @memoize
     def data(self):
-        """
-        Get the current data object, fetching from nodestore if necessary.
-        """
-
         if self._node_data is not None:
             return self._node_data
 
@@ -148,24 +133,6 @@ class NodeData(collections.MutableMapping):
             self.data['_ref'] = ref
             self.data['_ref_version'] = self.field.ref_version
 
-    def save(self):
-        """
-        Write current data back to nodestore.
-        """
-
-        # We never loaded any data for reading or writing, so there
-        # is nothing to save.
-        if self._node_data is None:
-            return
-
-        # We can't put our wrappers into the nodestore, so we need to
-        # ensure that the data is converted into a plain old dict
-        to_write = self._node_data
-        if isinstance(to_write, CANONICAL_TYPES):
-            to_write = dict(to_write.items())
-
-        nodestore.set(self.id, to_write)
-
 
 class NodeField(GzippedDictField):
     """
@@ -177,7 +144,6 @@ class NodeField(GzippedDictField):
         self.ref_func = kwargs.pop('ref_func', None)
         self.ref_version = kwargs.pop('ref_version', None)
         self.wrapper = kwargs.pop('wrapper', None)
-        self.id_func = kwargs.pop('id_func', lambda x: b64encode(uuid4().bytes))
         super(NodeField, self).__init__(*args, **kwargs)
 
     def contribute_to_class(self, cls, name):
@@ -192,58 +158,45 @@ class NodeField(GzippedDictField):
         nodestore.delete(value.id)
 
     def to_python(self, value):
-        # If value is a string, we assume this is a value we've loaded from the
-        # database, it should be decompressed/unpickled, and we should end up
-        # with a dict.
-        if value and isinstance(value, six.string_types):
+        if isinstance(value, six.string_types) and value:
             try:
                 value = pickle.loads(decompress(value))
             except Exception as e:
-                # TODO this is a bit dangerous as a failure to read/decode the
-                # node_id will end up with this record being replaced with an
-                # empty value under a new key, potentially orphaning an
-                # original value in nodestore. OTOH if we can't decode the info
-                # here, the node was already effectively orphaned.
                 logger.exception(e)
-                value = None
-
-        if value:
-            if 'node_id' in value:
-                node_id = value.pop('node_id')
-                # If the value is now empty, that means that it only had the
-                # node_id in it, which means that we should be looking to *load*
-                # the event body from nodestore. If it does have other stuff in
-                # it, that means we got an event body with a precomputed id in
-                # it, and we want to *save* the rest of the body to nodestore.
-                if value == {}:
-                    value = None
-            else:
-                node_id = self.id_func(value)
-        else:
-            # Either we were passed a null/empty value in the constructor, or
-            # we failed to decode the value from the database. In this case,
-            # generate an id, and set the data to an empty dict so that we don't
-            # try and load anything from nodestore.
+                value = {}
+        elif not value:
             value = {}
-            node_id = self.id_func(value)
 
-        if value is not None and self.wrapper is not None:
-            value = self.wrapper(value)
+        if 'node_id' in value:
+            node_id = value.pop('node_id')
+            data = None
+        else:
+            node_id = None
+            data = value
+
+        if self.wrapper is not None and data is not None:
+            data = self.wrapper(data)
 
-        return NodeData(self, node_id, value)
+        return NodeData(self, node_id, data)
 
     def get_prep_value(self, value):
-        """
-            Prepares the NodeData to be written in a Model.save() call.
-
-            Makes sure the event body is written to nodestore and
-            returns the node_id reference to be written to rowstore.
-        """
         if not value and self.null:
             # save ourselves some storage
             return None
 
-        value.save()
+        # We can't put our wrappers into the nodestore, so we need to
+        # ensure that the data is converted into a plain old dict
+        data = value.data
+        if isinstance(data, CANONICAL_TYPES):
+            data = dict(data.items())
+
+        # TODO(dcramer): we should probably do this more intelligently
+        # and manually
+        if not value.id:
+            value.id = nodestore.create(data)
+        else:
+            nodestore.set(value.id, data)
+
         return compress(pickle.dumps({'node_id': value.id}))
 
 
diff --git a/src/sentry/event_manager.py b/src/sentry/event_manager.py
index 7607fbbd35..d414331d79 100644
--- a/src/sentry/event_manager.py
+++ b/src/sentry/event_manager.py
@@ -724,8 +724,6 @@ class EventManager(object):
         date = date.replace(tzinfo=timezone.utc)
         time_spent = data.get('time_spent')
 
-        data['node_id'] = Event.generate_node_id(project_id, event_id)
-
         return Event(
             project_id=project_id or self._project.id,
             event_id=event_id,
diff --git a/src/sentry/models/event.py b/src/sentry/models/event.py
index 7fb06573eb..05001a7216 100644
--- a/src/sentry/models/event.py
+++ b/src/sentry/models/event.py
@@ -15,7 +15,6 @@ from collections import OrderedDict
 from django.db import models
 from django.utils import timezone
 from django.utils.translation import ugettext_lazy as _
-from hashlib import md5
 
 from sentry import eventtypes
 from sentry.db.models import (
@@ -59,16 +58,6 @@ class Event(Model):
 
     __repr__ = sane_repr('project_id', 'group_id')
 
-    @classmethod
-    def generate_node_id(cls, project_id, event_id):
-        """
-        Returns a deterministic node_id for this event based on the project_id
-        and event_id which together are globally unique. The event body should
-        be saved under this key in nodestore so it can be retrieved using the
-        same generated id when we only have project_id and event_id.
-        """
-        return md5('{}:{}'.format(project_id, event_id)).hexdigest()
-
     def __getstate__(self):
         state = Model.__getstate__(self)
 
diff --git a/src/sentry/utils/canonical.py b/src/sentry/utils/canonical.py
index c5c0684364..6fedfcabcc 100644
--- a/src/sentry/utils/canonical.py
+++ b/src/sentry/utils/canonical.py
@@ -73,9 +73,6 @@ class CanonicalKeyView(collections.Mapping):
 
         raise KeyError(key)
 
-    def __repr__(self):
-        return self.data.__repr__()
-
 
 class CanonicalKeyDict(collections.MutableMapping):
     def __init__(self, data, legacy=None):
@@ -129,8 +126,5 @@ class CanonicalKeyDict(collections.MutableMapping):
     def __delitem__(self, key):
         del self.data[self._norm_func(key)]
 
-    def __repr__(self):
-        return self.data.__repr__()
-
 
 CANONICAL_TYPES = (CanonicalKeyDict, CanonicalKeyView)
diff --git a/tests/sentry/models/tests.py b/tests/sentry/models/tests.py
index 970a0300f3..f12553515c 100644
--- a/tests/sentry/models/tests.py
+++ b/tests/sentry/models/tests.py
@@ -12,7 +12,6 @@ from django.http import HttpRequest
 from django.utils import timezone
 from exam import fixture
 
-from sentry import nodestore
 from sentry.db.models.fields.node import NodeData, NodeIntegrityFailure
 from sentry.models import ProjectKey, Event, LostPasswordHash
 from sentry.testutils import TestCase
@@ -120,6 +119,7 @@ class EventNodeStoreTest(TestCase):
         event = Event.objects.get(id=event_id)
         assert type(event.data) == NodeData
         assert event.data == data
+        assert event.data.id is None
 
         event.save()
 
@@ -134,44 +134,6 @@ class EventNodeStoreTest(TestCase):
         assert event.data == data
         assert event.data.id == node_id
 
-    def test_event_node_id(self):
-        # Create an event without specifying node_id. A node_id should be generated
-        e1 = Event(project_id=1, event_id='abc', data={'foo': 'bar'})
-        assert e1.data.id is not None, "We should have generated a node_id for this event"
-        e1_node_id = e1.data.id
-        e1.save()
-        e1_body = nodestore.get(e1_node_id)
-        assert e1_body == {'foo': 'bar'}, "The event body should be in nodestore"
-
-        e1 = Event.objects.get(project_id=1, event_id='abc')
-        assert e1.data.data == {'foo': 'bar'}, "The event body should be loaded from nodestore"
-        assert e1.data.id == e1_node_id, "The event's node_id should be the same after load"
-
-        # Create another event that references the same nodestore object as the first event.
-        e2 = Event(project_id=1, event_id='def', data={'node_id': e1_node_id})
-        assert e2.data.id == e1_node_id, "The event should use the provided node_id"
-        e2_body = nodestore.get(e1_node_id)
-        assert e2_body == {'foo': 'bar'}, "The event body should be in nodestore already"
-        e2.save()
-        e2_body = nodestore.get(e1_node_id)
-        assert e2_body == {'foo': 'bar'}, "The event body should not be overwritten by save"
-
-        e2 = Event.objects.get(project_id=1, event_id='def')
-        assert e2.data.data == {'foo': 'bar'}, "The event body should be loaded from nodestore"
-        assert e2.data.id == e1_node_id, "The event's node_id should be the same after load"
-
-        # Create an event with a new event body that specifies the node_id to use.
-        e3 = Event(project_id=1, event_id='ghi', data={'baz': 'quux', 'node_id': '1:ghi'})
-        assert e3.data.id == '1:ghi', "Event should have the specified node_id"
-        assert e3.data.data == {'baz': 'quux'}, "Event body should be the one provided (sans node_id)"
-        e3.save()
-        e3_body = nodestore.get('1:ghi')
-        assert e3_body == {'baz': 'quux'}, "Event body should be saved to nodestore"
-
-        e3 = Event.objects.get(project_id=1, event_id='ghi')
-        assert e3.data.data == {'baz': 'quux'}, "Event body should be loaded from nodestore"
-        assert e3.data.id == '1:ghi', "Loaded event should have the correct node_id"
-
     def test_screams_bloody_murder_when_ref_fails(self):
         project1 = self.create_project()
         project2 = self.create_project()

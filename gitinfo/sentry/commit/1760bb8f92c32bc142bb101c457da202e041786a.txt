commit 1760bb8f92c32bc142bb101c457da202e041786a
Author: Jan Michael Auer <account@jauer.org>
Date:   Thu May 31 11:26:43 2018 -0700

    feat(native): Support gzipped chunk uploads (#8612)
    
    * feat(native): Support gzip chunk uploads
    
    * ref(chunks): Make compressions a list

diff --git a/src/sentry/api/endpoints/chunk.py b/src/sentry/api/endpoints/chunk.py
index 3218702d95..6d51f5a4d6 100644
--- a/src/sentry/api/endpoints/chunk.py
+++ b/src/sentry/api/endpoints/chunk.py
@@ -1,5 +1,7 @@
 from __future__ import absolute_import
 
+from io import BytesIO
+from gzip import GzipFile
 from itertools import izip
 from rest_framework import status
 from six.moves.urllib.parse import urljoin
@@ -21,6 +23,14 @@ MAX_CONCURRENCY = settings.DEBUG and 1 or 4
 HASH_ALGORITHM = 'sha1'
 
 
+class GzipChunk(BytesIO):
+    def __init__(self, file):
+        data = GzipFile(fileobj=file, mode='rb').read()
+        self.size = len(data)
+        self.name = file.name
+        super(GzipChunk, self).__init__(data)
+
+
 class ChunkUploadEndpoint(OrganizationEndpoint):
     permission_classes = (OrganizationReleasePermission, )
 
@@ -46,6 +56,7 @@ class ChunkUploadEndpoint(OrganizationEndpoint):
                 'maxRequestSize': MAX_REQUEST_SIZE,
                 'concurrency': MAX_CONCURRENCY,
                 'hashAlgorithm': HASH_ALGORITHM,
+                'compression': ['gzip'],
             }
         )
 
@@ -60,6 +71,7 @@ class ChunkUploadEndpoint(OrganizationEndpoint):
         :auth: required
         """
         files = request.FILES.getlist('file')
+        files += [GzipChunk(chunk) for chunk in request.FILES.getlist('file_gzip')]
         if len(files) == 0:
             # No files uploaded is ok
             return Response(status=status.HTTP_200_OK)
@@ -68,11 +80,11 @@ class ChunkUploadEndpoint(OrganizationEndpoint):
         checksums = []
         size = 0
         for chunk in files:
-            size += chunk._size
-            if chunk._size > DEFAULT_BLOB_SIZE:
+            size += chunk.size
+            if chunk.size > DEFAULT_BLOB_SIZE:
                 return Response({'error': 'Chunk size too large'},
                                 status=status.HTTP_400_BAD_REQUEST)
-            checksums.append(chunk._name)
+            checksums.append(chunk.name)
 
         if size > MAX_REQUEST_SIZE:
             return Response({'error': 'Request too large'},

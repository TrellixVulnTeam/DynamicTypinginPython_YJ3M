commit 260c0d11a33e661afc5c3e1a5a53a2145bb863ed
Author: Max Bittker <maxbittker@gmail.com>
Date:   Wed Sep 20 10:54:29 2017 -0700

    fix bulk query action (#6159)
    
    fix(workflow): Actually use 1000 limit in bulk query action

diff --git a/src/sentry/api/endpoints/project_group_index.py b/src/sentry/api/endpoints/project_group_index.py
index 38a43ff062..cc068a34b9 100644
--- a/src/sentry/api/endpoints/project_group_index.py
+++ b/src/sentry/api/endpoints/project_group_index.py
@@ -15,7 +15,8 @@ from sentry.api.base import DocSection
 from sentry.api.bases.project import ProjectEndpoint, ProjectEventPermission
 from sentry.api.fields import UserField
 from sentry.api.serializers import serialize
-from sentry.api.serializers.models.group import (SUBSCRIPTION_REASON_MAP, StreamGroupSerializer)
+from sentry.api.serializers.models.group import (
+    SUBSCRIPTION_REASON_MAP, StreamGroupSerializer)
 from sentry.constants import DEFAULT_SORT_OPTION
 from sentry.db.models.query import create_or_update
 from sentry.models import (
@@ -69,7 +70,8 @@ def list_project_issues_scenario(runner):
     project = runner.default_project
     runner.request(
         method='GET',
-        path='/projects/%s/%s/issues/?statsPeriod=24h' % (runner.org.slug, project.slug),
+        path='/projects/%s/%s/issues/?statsPeriod=24h' % (
+            runner.org.slug, project.slug),
     )
 
 
@@ -138,7 +140,8 @@ class StatusDetailsValidator(serializers.Serializer):
 
 
 class GroupValidator(serializers.Serializer):
-    status = serializers.ChoiceField(choices=zip(STATUS_CHOICES.keys(), STATUS_CHOICES.keys()))
+    status = serializers.ChoiceField(choices=zip(
+        STATUS_CHOICES.keys(), STATUS_CHOICES.keys()))
     statusDetails = StatusDetailsValidator()
     hasSeen = serializers.BooleanField()
     isBookmarked = serializers.BooleanField()
@@ -161,13 +164,15 @@ class GroupValidator(serializers.Serializer):
     def validate_assignedTo(self, attrs, source):
         value = attrs[source]
         if value and not self.context['project'].member_set.filter(user=value).exists():
-            raise serializers.ValidationError('Cannot assign to non-team member')
+            raise serializers.ValidationError(
+                'Cannot assign to non-team member')
         return attrs
 
     def validate(self, attrs):
         attrs = super(GroupValidator, self).validate(attrs)
         if len(attrs) > 1 and 'discard' in attrs:
-            raise serializers.ValidationError('Other attributes cannot be updated when discarding')
+            raise serializers.ValidationError(
+                'Other attributes cannot be updated when discarding')
         return attrs
 
 
@@ -224,7 +229,8 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint):
                 query_kwargs.update(parse_query(project, query, request.user))
             except InvalidQuery as e:
                 raise ValidationError(
-                    u'Your search query could not be parsed: {}'.format(e.message)
+                    u'Your search query could not be parsed: {}'.format(
+                        e.message)
                 )
 
         return query_kwargs
@@ -307,7 +313,8 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint):
                 else:
                     matching_group = Group.objects.get(id=mapping.group_id)
                     try:
-                        matching_event = Event.objects.get(event_id=query, project_id=project.id)
+                        matching_event = Event.objects.get(
+                            event_id=query, project_id=project.id)
                     except Event.DoesNotExist:
                         pass
 
@@ -329,7 +336,8 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint):
                         [matching_group], request.user,
                         StreamGroupSerializer(
                             stats_period=stats_period,
-                            matching_event_id=getattr(matching_event, 'id', None)
+                            matching_event_id=getattr(
+                                matching_event, 'id', None)
                         )
                     )
                 )
@@ -337,7 +345,8 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint):
                 return response
 
         try:
-            query_kwargs = self._build_query_params_from_request(request, project)
+            query_kwargs = self._build_query_params_from_request(
+                request, project)
         except ValidationError as exc:
             return Response({'detail': six.text_type(exc)}, status=400)
 
@@ -420,7 +429,8 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint):
         """
         group_ids = request.GET.getlist('id')
         if group_ids:
-            group_list = Group.objects.filter(project=project, id__in=group_ids)
+            group_list = Group.objects.filter(
+                project=project, id__in=group_ids)
             # filter down group ids to only valid matches
             group_ids = [g.id for g in group_list]
             if not group_ids:
@@ -441,16 +451,20 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint):
 
         if not group_ids:
             try:
-                query_kwargs = self._build_query_params_from_request(request, project)
+                query_kwargs = self._build_query_params_from_request(
+                    request, project)
             except ValidationError as exc:
                 return Response({'detail': six.text_type(exc)}, status=400)
 
             # bulk mutations are limited to 1000 items
             # TODO(dcramer): it'd be nice to support more than this, but its
             # a bit too complicated right now
-            query_kwargs['limit'] = 1000
+            limit = 1000
+            query_kwargs['limit'] = limit
 
-            cursor_result = search.query(**query_kwargs)
+            # the paginator has a default max_limit of 100, which must be overwritten.
+            cursor_result = search.query(
+                paginator_options={'max_limit': limit}, **query_kwargs)
 
             group_list = list(cursor_result)
             group_ids = [g.id for g in group_list]
@@ -551,7 +565,8 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint):
                             defaults=resolution_params,
                         )
                         if not created:
-                            resolution.update(datetime=timezone.now(), **resolution_params)
+                            resolution.update(
+                                datetime=timezone.now(), **resolution_params)
                     else:
                         resolution = None
 
@@ -567,7 +582,8 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint):
                     group.status = GroupStatus.RESOLVED
                     group.resolved_at = now
 
-                    self._subscribe_and_assign_issue(acting_user, group, result)
+                    self._subscribe_and_assign_issue(
+                        acting_user, group, result)
 
                     if created:
                         activity = Activity.objects.create(
@@ -613,10 +629,14 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint):
                         statusDetails.pop('ignoreDuration', None) or
                         statusDetails.pop('snoozeDuration', None)
                     ) or None
-                    ignore_count = statusDetails.pop('ignoreCount', None) or None
-                    ignore_window = statusDetails.pop('ignoreWindow', None) or None
-                    ignore_user_count = statusDetails.pop('ignoreUserCount', None) or None
-                    ignore_user_window = statusDetails.pop('ignoreUserWindow', None) or None
+                    ignore_count = statusDetails.pop(
+                        'ignoreCount', None) or None
+                    ignore_window = statusDetails.pop(
+                        'ignoreWindow', None) or None
+                    ignore_user_count = statusDetails.pop(
+                        'ignoreUserCount', None) or None
+                    ignore_user_window = statusDetails.pop(
+                        'ignoreUserWindow', None) or None
                     if ignore_duration or ignore_count or ignore_user_count:
                         if ignore_duration:
                             ignore_until = timezone.now() + timedelta(
@@ -705,7 +725,8 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint):
         if 'assignedTo' in result:
             if result['assignedTo']:
                 for group in group_list:
-                    GroupAssignee.objects.assign(group, result['assignedTo'], acting_user)
+                    GroupAssignee.objects.assign(
+                        group, result['assignedTo'], acting_user)
 
                     if 'isSubscribed' not in result or result['assignedTo'] != request.user:
                         GroupSubscription.objects.subscribe(
diff --git a/src/sentry/api/paginator.py b/src/sentry/api/paginator.py
index 39ea6efca6..1a02551d36 100644
--- a/src/sentry/api/paginator.py
+++ b/src/sentry/api/paginator.py
@@ -53,7 +53,8 @@ class BasePaginator(object):
             if self.key in queryset.query.order_by:
                 if not asc:
                     index = queryset.query.order_by.index(self.key)
-                    queryset.query.order_by[index] = '-%s' % (queryset.query.order_by[index])
+                    queryset.query.order_by[index] = '-%s' % (
+                        queryset.query.order_by[index])
             elif ('-%s' % self.key) in queryset.query.order_by:
                 if asc:
                     index = queryset.query.order_by.index('-%s' % (self.key))
@@ -75,12 +76,14 @@ class BasePaginator(object):
 
             if asc:
                 queryset = queryset.extra(
-                    where=['%s.%s >= %%s' % (queryset.model._meta.db_table, col_query, )],
+                    where=['%s.%s >= %%s' %
+                           (queryset.model._meta.db_table, col_query, )],
                     params=col_params,
                 )
             else:
                 queryset = queryset.extra(
-                    where=['%s.%s <= %%s' % (queryset.model._meta.db_table, col_query, )],
+                    where=['%s.%s <= %%s' %
+                           (queryset.model._meta.db_table, col_query, )],
                     params=col_params,
                 )
 
diff --git a/src/sentry/search/django/backend.py b/src/sentry/search/django/backend.py
index 8b88dfb91c..43165a885c 100644
--- a/src/sentry/search/django/backend.py
+++ b/src/sentry/search/django/backend.py
@@ -111,7 +111,8 @@ class DjangoSearchBackend(SearchBackend):
             # we should at least optimize this in Postgres so that it does
             # the query filter **after** the index filters, and restricts the
             # result set
-            queryset = queryset.filter(Q(message__icontains=query) | Q(culprit__icontains=query))
+            queryset = queryset.filter(
+                Q(message__icontains=query) | Q(culprit__icontains=query))
 
         if status is None:
             status_in = (
@@ -240,10 +241,12 @@ class DjangoSearchBackend(SearchBackend):
             event_queryset = Event.objects.filter(**params)
 
             if query:
-                event_queryset = event_queryset.filter(message__icontains=query)
+                event_queryset = event_queryset.filter(
+                    message__icontains=query)
 
             # limit to the first 1000 results
-            group_ids = event_queryset.distinct().values_list('group_id', flat=True)[:1000]
+            group_ids = event_queryset.distinct().values_list(
+                'group_id', flat=True)[:1000]
 
             # if Event is not on the primary database remove Django's
             # implicit subquery by coercing to a list
@@ -273,7 +276,10 @@ class DjangoSearchBackend(SearchBackend):
         )
         return queryset
 
-    def query(self, project, count_hits=False, **kwargs):
+    def query(self, project, count_hits=False, paginator_options=None, **kwargs):
+        if paginator_options is None:
+            paginator_options = {}
+
         queryset = self._build_queryset(project=project, **kwargs)
 
         sort_by = kwargs.get('sort_by', 'date')
@@ -298,5 +304,5 @@ class DjangoSearchBackend(SearchBackend):
             sort_clause = '-sort_value'
 
         queryset = queryset.order_by(sort_clause)
-        paginator = paginator_cls(queryset, sort_clause)
+        paginator = paginator_cls(queryset, sort_clause, **paginator_options)
         return paginator.get_result(limit, cursor, count_hits=count_hits)
diff --git a/tests/sentry/api/endpoints/test_project_group_index.py b/tests/sentry/api/endpoints/test_project_group_index.py
index 2468746715..0e20837f80 100644
--- a/tests/sentry/api/endpoints/test_project_group_index.py
+++ b/tests/sentry/api/endpoints/test_project_group_index.py
@@ -362,6 +362,39 @@ class GroupUpdateTest(APITestCase):
             group=new_group4,
         )
 
+    def test_bulk_resolve(self):
+        self.login_as(user=self.user)
+
+        for i in range(200):
+            self.create_group(status=GroupStatus.UNRESOLVED)
+
+        response = self.client.get(
+            '{}?sort_by=date&query=is:unresolved'.format(self.path),
+            format='json',
+        )
+
+        assert len(response.data) == 100
+
+        response = self.client.put(
+            '{}?status=unresolved'.format(self.path),
+            data={
+                'status': 'resolved',
+            },
+            format='json',
+        )
+        assert response.status_code == 200, response.data
+
+        assert response.data == {
+            'status': 'resolved',
+            'statusDetails': {},
+        }
+        response = self.client.get(
+            '{}?sort_by=date&query=is:unresolved'.format(self.path),
+            format='json',
+        )
+
+        assert len(response.data) == 0
+
     def test_self_assign_issue(self):
         group = self.create_group(checksum='b' * 32, status=GroupStatus.UNRESOLVED)
         user = self.user

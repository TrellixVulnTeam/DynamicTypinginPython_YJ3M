commit 1db4672ff3b56315da43643180760e0386aac48d
Author: William Mak <william@wmak.io>
Date:   Thu May 7 15:58:59 2020 -0400

    ref: Moving cache_suffix_time to snuba utils
    
    - Renaming it to quantize time since its being used for more than
      the suffix

diff --git a/src/sentry/tagstore/snuba/backend.py b/src/sentry/tagstore/snuba/backend.py
index eea33c0ac0..c857332b88 100644
--- a/src/sentry/tagstore/snuba/backend.py
+++ b/src/sentry/tagstore/snuba/backend.py
@@ -1,6 +1,5 @@
 from __future__ import absolute_import
 
-import datetime
 import functools
 import six
 from collections import defaultdict, Iterable
@@ -60,39 +59,6 @@ def get_project_list(project_id):
     return project_id if isinstance(project_id, Iterable) else [project_id]
 
 
-def cache_suffix_time(time, key_hash, duration=300):
-    """ Adds jitter based on the key_hash around start/end times for caching snuba queries
-
-        Given a time and a key_hash this should result in a timestamp that remains the same for a duration
-        The end of the duration will be different per key_hash which avoids spikes in the number of queries
-        Must be based on the key_hash so they cache keys are consistent per query
-
-        For example: the time is 17:02:00, there's two queries query A has a key_hash of 30, query B has a key_hash of
-        60, we have the default duration of 300 (5 Minutes)
-        - query A will have the suffix of 17:00:30 for a timewindow from 17:00:30 until 17:05:30
-            - eg. Even when its 17:05:00 the suffix will still be 17:00:30
-        - query B will have the suffix of 17:01:00 for a timewindow from 17:01:00 until 17:06:00
-    """
-    # Use the hash so that seconds past the hour gets rounded differently per query.
-    jitter = key_hash % duration
-    seconds_past_hour = time.minute * 60 + time.second
-    # Round seconds to a multiple of duration, cause this uses "floor" division shouldn't give us a future window
-    time_window_start = seconds_past_hour // duration * duration + jitter
-    # If the time is past the rounded seconds then we want our key to be for this timewindow
-    if time_window_start < seconds_past_hour:
-        seconds_past_hour = time_window_start
-    # Otherwise we're in the previous time window, subtract duration to give us the previous timewindows start
-    else:
-        seconds_past_hour = time_window_start - duration
-    return (
-        # Since we're adding seconds past the hour, we want time but without minutes or seconds
-        time.replace(minute=0, second=0, microsecond=0)
-        +
-        # Use timedelta here so keys are consistent around hour boundaries
-        datetime.timedelta(seconds=seconds_past_hour)
-    )
-
-
 class SnubaTagStorage(TagStorage):
     def __get_tag_key(self, project_id, group_id, environment_id, key):
         tag = u"tags[{}]".format(key)
@@ -226,8 +192,8 @@ class SnubaTagStorage(TagStorage):
             with a certain jitter to the cache key.
             This jitter is based on the hash of the key before duration/end time is added for consistency per query.
             The jitter's intent is to avoid a dogpile effect of many queries being invalidated at the same time.
-            This is done by changing the rounding of the end key to a random offset. See cache_suffix_time for further
-            explanation of how that is done.
+            This is done by changing the rounding of the end key to a random offset. See snuba.quantize_time for
+            further explanation of how that is done.
         """
         default_start, default_end = default_start_end_dates()
         if start is None:
@@ -268,7 +234,7 @@ class SnubaTagStorage(TagStorage):
             # Needs to happen before creating the cache suffix otherwise rounding will cause different durations
             duration = (end - start).total_seconds()
             # Cause there's rounding to create this cache suffix, we want to update the query end so results match
-            end = cache_suffix_time(end, key_hash)
+            end = snuba.quantize_time(end, key_hash)
             cache_key += u":{}@{}".format(duration, end.isoformat())
             result = cache.get(cache_key, None)
             if result is not None:
diff --git a/src/sentry/utils/snuba.py b/src/sentry/utils/snuba.py
index 283210f9d5..e1a825faf9 100644
--- a/src/sentry/utils/snuba.py
+++ b/src/sentry/utils/snuba.py
@@ -1023,3 +1023,36 @@ def shrink_time_window(issues, start):
 
 def naiveify_datetime(dt):
     return dt if not dt.tzinfo else dt.astimezone(pytz.utc).replace(tzinfo=None)
+
+
+def quantize_time(time, key_hash, duration=300):
+    """ Adds jitter based on the key_hash around start/end times for caching snuba queries
+
+        Given a time and a key_hash this should result in a timestamp that remains the same for a duration
+        The end of the duration will be different per key_hash which avoids spikes in the number of queries
+        Must be based on the key_hash so they cache keys are consistent per query
+
+        For example: the time is 17:02:00, there's two queries query A has a key_hash of 30, query B has a key_hash of
+        60, we have the default duration of 300 (5 Minutes)
+        - query A will have the suffix of 17:00:30 for a timewindow from 17:00:30 until 17:05:30
+            - eg. Even when its 17:05:00 the suffix will still be 17:00:30
+        - query B will have the suffix of 17:01:00 for a timewindow from 17:01:00 until 17:06:00
+    """
+    # Use the hash so that seconds past the hour gets rounded differently per query.
+    jitter = key_hash % duration
+    seconds_past_hour = time.minute * 60 + time.second
+    # Round seconds to a multiple of duration, cause this uses "floor" division shouldn't give us a future window
+    time_window_start = seconds_past_hour // duration * duration + jitter
+    # If the time is past the rounded seconds then we want our key to be for this timewindow
+    if time_window_start < seconds_past_hour:
+        seconds_past_hour = time_window_start
+    # Otherwise we're in the previous time window, subtract duration to give us the previous timewindows start
+    else:
+        seconds_past_hour = time_window_start - duration
+    return (
+        # Since we're adding seconds past the hour, we want time but without minutes or seconds
+        time.replace(minute=0, second=0, microsecond=0)
+        +
+        # Use timedelta here so keys are consistent around hour boundaries
+        timedelta(seconds=seconds_past_hour)
+    )
diff --git a/tests/sentry/utils/test_snuba.py b/tests/sentry/utils/test_snuba.py
index 6d55d0147e..9b7612bef2 100644
--- a/tests/sentry/utils/test_snuba.py
+++ b/tests/sentry/utils/test_snuba.py
@@ -1,6 +1,8 @@
 from __future__ import absolute_import
 
-from datetime import datetime
+from datetime import datetime, timedelta
+from django.utils import timezone
+
 import pytest
 import pytz
 
@@ -14,6 +16,7 @@ from sentry.utils.snuba import (
     Dataset,
     SnubaQueryParams,
     UnqualifiedQueryError,
+    quantize_time,
 )
 
 
@@ -198,3 +201,82 @@ class PrepareQueryParamsTest(TestCase):
 
         with pytest.raises(UnqualifiedQueryError):
             _prepare_query_params(query_params)
+
+
+class QuantizeTimeTest(TestCase):
+    def setUp(self):
+        self.now = timezone.now().replace(microsecond=0)
+
+    def test_cache_suffix_time(self):
+        starting_key = quantize_time(self.now, 0)
+        finishing_key = quantize_time(self.now + timedelta(seconds=300), 0)
+
+        assert starting_key != finishing_key
+
+    def test_quantize_hour_edges(self):
+        """ a suffix should still behave correctly around the end of the hour
+
+            At a duration of 10 only one key between 0-10 should flip on the hour, the other 9
+            should flip at different times.
+        """
+        before = datetime(2019, 9, 5, 17, 59, 59)
+        on_hour = datetime(2019, 9, 5, 18, 0, 0)
+        changed_on_hour = 0
+        # Check multiple keyhashes so that this test doesn't depend on implementation
+        for key_hash in range(10):
+            before_key = quantize_time(before, key_hash, duration=10)
+            on_key = quantize_time(on_hour, key_hash, duration=10)
+            if before_key != on_key:
+                changed_on_hour += 1
+
+        assert changed_on_hour == 1
+
+    def test_quantize_day_edges(self):
+        """ a suffix should still behave correctly around the end of a day
+
+            This test is nearly identical to test_quantize_hour_edges, but is to confirm that date changes don't
+            cause a different behaviour
+        """
+        before = datetime(2019, 9, 5, 23, 59, 59)
+        next_day = datetime(2019, 9, 6, 0, 0, 0)
+        changed_on_hour = 0
+        for key_hash in range(10):
+            before_key = quantize_time(before, key_hash, duration=10)
+            next_key = quantize_time(next_day, key_hash, duration=10)
+            if before_key != next_key:
+                changed_on_hour += 1
+
+        assert changed_on_hour == 1
+
+    def test_quantize_time_matches_duration(self):
+        """ The number of seconds between keys changing should match duration """
+        previous_key = quantize_time(self.now, 0, duration=10)
+        changes = []
+        for i in range(21):
+            current_time = self.now + timedelta(seconds=i)
+            current_key = quantize_time(current_time, 0, duration=10)
+            if current_key != previous_key:
+                changes.append(current_time)
+                previous_key = current_key
+
+        assert len(changes) == 2
+        assert (changes[1] - changes[0]).total_seconds() == 10
+
+    def test_quantize_time_jitter(self):
+        """ Different key hashes should change keys at different times
+
+            While starting_key and other_key might begin as the same values they should change at different times
+        """
+        starting_key = quantize_time(self.now, 0, duration=10)
+        for i in range(11):
+            current_key = quantize_time(self.now + timedelta(seconds=i), 0, duration=10)
+            if current_key != starting_key:
+                break
+
+        other_key = quantize_time(self.now, 5, duration=10)
+        for j in range(11):
+            current_key = quantize_time(self.now + timedelta(seconds=j), 5, duration=10)
+            if current_key != other_key:
+                break
+
+        assert i != j
diff --git a/tests/snuba/tagstore/test_tagstore_backend.py b/tests/snuba/tagstore/test_tagstore_backend.py
index 9d40c113c2..540ead64c9 100644
--- a/tests/snuba/tagstore/test_tagstore_backend.py
+++ b/tests/snuba/tagstore/test_tagstore_backend.py
@@ -1,7 +1,7 @@
 from __future__ import absolute_import
 
 import calendar
-from datetime import timedelta, datetime
+from datetime import timedelta
 import json
 import pytest
 import requests
@@ -17,7 +17,7 @@ from sentry.tagstore.exceptions import (
     TagKeyNotFound,
     TagValueNotFound,
 )
-from sentry.tagstore.snuba.backend import SnubaTagStorage, cache_suffix_time
+from sentry.tagstore.snuba.backend import SnubaTagStorage
 from sentry.testutils import SnubaTestCase, TestCase
 
 
@@ -601,77 +601,3 @@ class TagStorageTest(TestCase, SnubaTestCase):
             )
             == {}
         )
-
-    def test_cache_suffix_time(self):
-        starting_key = cache_suffix_time(self.now, 0)
-        finishing_key = cache_suffix_time(self.now + timedelta(seconds=300), 0)
-
-        assert starting_key != finishing_key
-
-    def test_cache_suffix_hour_edges(self):
-        """ a suffix should still behave correctly around the end of the hour
-
-            At a duration of 10 only one key between 0-10 should flip on the hour, the other 9
-            should flip at different times.
-        """
-        before = datetime(2019, 9, 5, 17, 59, 59)
-        on_hour = datetime(2019, 9, 5, 18, 0, 0)
-        changed_on_hour = 0
-        # Check multiple keyhashes so that this test doesn't depend on implementation
-        for key_hash in range(10):
-            before_key = cache_suffix_time(before, key_hash, duration=10)
-            on_key = cache_suffix_time(on_hour, key_hash, duration=10)
-            if before_key != on_key:
-                changed_on_hour += 1
-
-        assert changed_on_hour == 1
-
-    def test_cache_suffix_day_edges(self):
-        """ a suffix should still behave correctly around the end of a day
-
-            This test is nearly identical to test_cache_suffix_hour_edges, but is to confirm that date changes don't
-            cause a different behaviour
-        """
-        before = datetime(2019, 9, 5, 23, 59, 59)
-        next_day = datetime(2019, 9, 6, 0, 0, 0)
-        changed_on_hour = 0
-        for key_hash in range(10):
-            before_key = cache_suffix_time(before, key_hash, duration=10)
-            next_key = cache_suffix_time(next_day, key_hash, duration=10)
-            if before_key != next_key:
-                changed_on_hour += 1
-
-        assert changed_on_hour == 1
-
-    def test_cache_suffix_time_matches_duration(self):
-        """ The number of seconds between keys changing should match duration """
-        previous_key = cache_suffix_time(self.now, 0, duration=10)
-        changes = []
-        for i in range(21):
-            current_time = self.now + timedelta(seconds=i)
-            current_key = cache_suffix_time(current_time, 0, duration=10)
-            if current_key != previous_key:
-                changes.append(current_time)
-                previous_key = current_key
-
-        assert len(changes) == 2
-        assert (changes[1] - changes[0]).total_seconds() == 10
-
-    def test_cache_suffix_time_jitter(self):
-        """ Different key hashes should change keys at different times
-
-            While starting_key and other_key might begin as the same values they should change at different times
-        """
-        starting_key = cache_suffix_time(self.now, 0, duration=10)
-        for i in range(11):
-            current_key = cache_suffix_time(self.now + timedelta(seconds=i), 0, duration=10)
-            if current_key != starting_key:
-                break
-
-        other_key = cache_suffix_time(self.now, 5, duration=10)
-        for j in range(11):
-            current_key = cache_suffix_time(self.now + timedelta(seconds=j), 5, duration=10)
-            if current_key != other_key:
-                break
-
-        assert i != j

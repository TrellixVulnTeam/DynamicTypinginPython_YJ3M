commit 3536159924a66034efea1c333a559335ced0d5b2
Author: Dan Fuller <dfuller@sentry.io>
Date:   Fri Sep 20 15:09:55 2019 -0700

    feat(api): Convert `SubscriptionProcessor` to handle multiple projects per rule (SEN-983)
    
    Now that alert rules can have multiple related projects/subscriptions, we need to be able to trigger
    an incident per subscription. This mostly just involves namespacing the stats to be differentiated
    by the project.

diff --git a/src/sentry/incidents/subscription_processor.py b/src/sentry/incidents/subscription_processor.py
index 5a945b0a84..bcb03888c6 100644
--- a/src/sentry/incidents/subscription_processor.py
+++ b/src/sentry/incidents/subscription_processor.py
@@ -23,7 +23,7 @@ from sentry.utils.dates import to_datetime
 
 logger = logging.getLogger(__name__)
 REDIS_TTL = int(timedelta(days=7).total_seconds())
-ALERT_RULE_BASE_STAT_KEY = "{alert_rule:%s}:%%s"
+ALERT_RULE_BASE_STAT_KEY = "{alert_rule:%s:project:%s}:%%s"
 ALERT_RULE_STAT_KEYS = ("last_update", "alert_triggered", "resolve_triggered")
 
 
@@ -49,7 +49,7 @@ class SubscriptionProcessor(object):
             return
 
         self.last_update, self.alert_triggers, self.resolve_triggers = get_alert_rule_stats(
-            self.alert_rule
+            self.alert_rule, self.subscription
         )
         self.orig_alert_triggers = self.alert_triggers
         self.orig_resolve_triggers = self.resolve_triggers
@@ -66,6 +66,7 @@ class SubscriptionProcessor(object):
                     type=IncidentType.ALERT_TRIGGERED.value,
                     status=IncidentStatus.OPEN.value,
                     alert_rule=self.alert_rule,
+                    projects=self.subscription.project,
                 ).order_by("-date_added")[0]
             except IndexError:
                 self._active_incident = None
@@ -179,35 +180,39 @@ class SubscriptionProcessor(object):
         if self.resolve_triggers != self.orig_resolve_triggers:
             self.orig_resolve_trigger = kwargs["resolve_triggers"] = self.resolve_triggers
 
-        update_alert_rule_stats(self.alert_rule, self.last_update, **kwargs)
+        update_alert_rule_stats(self.alert_rule, self.subscription, self.last_update, **kwargs)
 
 
-def build_alert_rule_stat_keys(alert_rule):
-    key_base = ALERT_RULE_BASE_STAT_KEY % alert_rule.id
+def build_alert_rule_stat_keys(alert_rule, subscription):
+    key_base = ALERT_RULE_BASE_STAT_KEY % (alert_rule.id, subscription.project_id)
     return [key_base % stat_key for stat_key in ALERT_RULE_STAT_KEYS]
 
 
-def get_alert_rule_stats(alert_rule):
+def get_alert_rule_stats(alert_rule, subscription):
     """
-    Fetches stats about the alert rule
-    :return: A tuple containing the stats about the alert rule.
-     - last_update: Int representing the timestamp the rule was last updated
-     - alert_triggered: Int representing how many consecutive times the rule has
+    Fetches stats about the alert rule, specific to the current subscription
+    :return: A tuple containing the stats about the alert rule and subscription.
+     - last_update: Int representing the timestamp it was last updated
+     - alert_triggered: Int representing how many consecutive times the we have
        triggered the alert threshold
-     - resolve_triggered: Int representing how many consecutive times the rule has
-       triggered the resolve threshold
+     - resolve_triggered: Int representing how many consecutive times we have triggered
+       the resolve threshold
     """
-    results = get_redis_client().mget(build_alert_rule_stat_keys(alert_rule))
+    results = get_redis_client().mget(build_alert_rule_stat_keys(alert_rule, subscription))
     return tuple(0 if result is None else int(result) for result in results)
 
 
-def update_alert_rule_stats(alert_rule, last_update, alert_triggers=None, resolve_triggers=None):
+def update_alert_rule_stats(
+    alert_rule, subscription, last_update, alert_triggers=None, resolve_triggers=None
+):
     """
-    Updates stats about the alert rule, if they're changed.
+    Updates stats about the alert rule and subscription, if they're changed.
     :return:
     """
     pipeline = get_redis_client().pipeline()
-    last_update_key, alert_trigger_key, resolve_trigger_key = build_alert_rule_stat_keys(alert_rule)
+    last_update_key, alert_trigger_key, resolve_trigger_key = build_alert_rule_stat_keys(
+        alert_rule, subscription
+    )
     if alert_triggers is not None:
         pipeline.set(alert_trigger_key, alert_triggers, ex=REDIS_TTL)
     if resolve_triggers is not None:
diff --git a/tests/sentry/incidents/test_subscription_processor.py b/tests/sentry/incidents/test_subscription_processor.py
index fed8f76a6d..8cc6d17796 100644
--- a/tests/sentry/incidents/test_subscription_processor.py
+++ b/tests/sentry/incidents/test_subscription_processor.py
@@ -23,14 +23,22 @@ class ProcessUpdateTest(TestCase):
     metrics = patcher("sentry.incidents.subscription_processor.metrics")
 
     @fixture
-    def subscription(self):
-        return self.rule.query_subscriptions.get()
+    def other_project(self):
+        return self.create_project()
+
+    @fixture
+    def sub(self):
+        return self.rule.query_subscriptions.filter(project=self.project).get()
+
+    @fixture
+    def other_sub(self):
+        return self.rule.query_subscriptions.filter(project=self.other_project).get()
 
     @fixture
     def rule(self):
         rule = create_alert_rule(
             self.organization,
-            [self.project],
+            [self.project, self.other_project],
             "some rule",
             AlertRuleThresholdType.ABOVE,
             query="",
@@ -42,7 +50,7 @@ class ProcessUpdateTest(TestCase):
         )
         return rule
 
-    def build_subscription_update(self, subscription=None, time_delta=None, value=None):
+    def build_subscription_update(self, subscription, time_delta=None, value=None):
         if time_delta is not None:
             timestamp = int(to_timestamp(timezone.now() + time_delta))
         else:
@@ -65,37 +73,44 @@ class ProcessUpdateTest(TestCase):
             "offset": 1,
         }
 
-    def send_update(self, rule, value, time_delta=None):
+    def send_update(self, rule, value, time_delta=None, subscription=None):
         if time_delta is None:
             time_delta = timedelta()
-        subscription = rule.query_subscriptions.get()
+        if subscription is None:
+            subscription = self.sub
         processor = SubscriptionProcessor(subscription)
         message = self.build_subscription_update(subscription, value=value, time_delta=time_delta)
         processor.process_update(message)
         return processor
 
-    def assert_no_active_incident(self, rule):
-        assert not self.active_incident_exists(rule)
+    def assert_no_active_incident(self, rule, subscription=None):
+        assert not self.active_incident_exists(rule, subscription=subscription)
 
-    def assert_active_incident(self, rule):
-        assert self.active_incident_exists(rule)
+    def assert_active_incident(self, rule, subscription=None):
+        assert self.active_incident_exists(rule, subscription=subscription)
 
-    def active_incident_exists(self, rule):
+    def active_incident_exists(self, rule, subscription=None):
+        if subscription is None:
+            subscription = self.sub
         return Incident.objects.filter(
             type=IncidentType.ALERT_TRIGGERED.value,
             status=IncidentStatus.OPEN.value,
             alert_rule=rule,
+            projects=subscription.project,
         ).exists()
 
     def assert_trigger_counts(self, processor, alert_triggers=0, resolve_triggers=0):
         assert processor.alert_triggers == alert_triggers
         assert processor.resolve_triggers == resolve_triggers
-        assert get_alert_rule_stats(processor.alert_rule)[1:] == (alert_triggers, resolve_triggers)
+        assert get_alert_rule_stats(processor.alert_rule, processor.subscription)[1:] == (
+            alert_triggers,
+            resolve_triggers,
+        )
 
     def test_removed_alert_rule(self):
-        message = self.build_subscription_update(self.subscription)
+        message = self.build_subscription_update(self.sub)
         self.rule.delete()
-        SubscriptionProcessor(self.subscription).process_update(message)
+        SubscriptionProcessor(self.sub).process_update(message)
         self.metrics.incr.assert_called_once_with(
             "incidents.alert_rules.no_alert_rule_for_subscription"
         )
@@ -251,3 +266,76 @@ class ProcessUpdateTest(TestCase):
         processor = self.send_update(rule, rule.resolve_threshold + 1, timedelta(minutes=-1))
         self.assert_trigger_counts(processor, 0, 0)
         self.assert_no_active_incident(rule)
+
+    def test_multiple_subscriptions_do_not_conflict(self):
+        # Verify that multiple subscriptions associated with a rule don't conflict with
+        # each other
+        rule = self.rule
+        rule.update(threshold_period=2)
+
+        # Send an update through for the first subscription. This shouldn't trigger an
+        # incident, since we need two consecutive updates that are over the threshold.
+        processor = self.send_update(
+            rule, rule.alert_threshold + 1, timedelta(minutes=-10), subscription=self.sub
+        )
+        self.assert_trigger_counts(processor, 1, 0)
+        self.assert_no_active_incident(rule, self.sub)
+
+        # Have an update come through for the other sub. This shouldn't influence the original
+        processor = self.send_update(
+            rule, rule.alert_threshold + 1, timedelta(minutes=-9), subscription=self.other_sub
+        )
+        self.assert_trigger_counts(processor, 1, 0)
+        self.assert_no_active_incident(rule, self.sub)
+        self.assert_no_active_incident(rule, self.other_sub)
+
+        # Send another update through for the first subscription. This should trigger an
+        # incident for just this subscription.
+        processor = self.send_update(
+            rule, rule.alert_threshold + 1, timedelta(minutes=-9), subscription=self.sub
+        )
+        self.assert_trigger_counts(processor, 0, 0)
+        self.assert_active_incident(rule, self.sub)
+        self.assert_no_active_incident(rule, self.other_sub)
+
+        # Send another update through for the second subscription. This should trigger an
+        # incident for just this subscription.
+        processor = self.send_update(
+            rule, rule.alert_threshold + 1, timedelta(minutes=-8), subscription=self.other_sub
+        )
+        self.assert_trigger_counts(processor, 0, 0)
+        self.assert_active_incident(rule, self.sub)
+        self.assert_active_incident(rule, self.other_sub)
+
+        # Now we want to test that resolving is isolated. Send another update through
+        # for the first subscription.
+        processor = self.send_update(
+            rule, rule.resolve_threshold - 1, timedelta(minutes=-7), subscription=self.sub
+        )
+        self.assert_trigger_counts(processor, 0, 1)
+        self.assert_active_incident(rule, self.sub)
+        self.assert_active_incident(rule, self.other_sub)
+
+        processor = self.send_update(
+            rule, rule.resolve_threshold - 1, timedelta(minutes=-7), subscription=self.other_sub
+        )
+        self.assert_trigger_counts(processor, 0, 1)
+        self.assert_active_incident(rule, self.sub)
+        self.assert_active_incident(rule, self.other_sub)
+
+        # This second update for the second subscription should resolve its incident,
+        # but not the incident from the first subscription.
+        processor = self.send_update(
+            rule, rule.resolve_threshold - 1, timedelta(minutes=-6), subscription=self.other_sub
+        )
+        self.assert_trigger_counts(processor, 0, 0)
+        self.assert_active_incident(rule, self.sub)
+        self.assert_no_active_incident(rule, self.other_sub)
+
+        # This second update for the first subscription should resolve its incident now.
+        processor = self.send_update(
+            rule, rule.resolve_threshold - 1, timedelta(minutes=-6), subscription=self.sub
+        )
+        self.assert_trigger_counts(processor, 0, 0)
+        self.assert_no_active_incident(rule, self.sub)
+        self.assert_no_active_incident(rule, self.other_sub)

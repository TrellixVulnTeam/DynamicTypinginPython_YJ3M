commit ff25fa65719856a738a721fc37493967cbf83378
Author: Matt Robenolt <matt@ydekproductions.com>
Date:   Wed Dec 14 16:20:48 2016 -0800

    javascript: handle artifacts uploaded as gzip or deflate

diff --git a/src/sentry/lang/javascript/processor.py b/src/sentry/lang/javascript/processor.py
index 003929facd..f60692ace7 100644
--- a/src/sentry/lang/javascript/processor.py
+++ b/src/sentry/lang/javascript/processor.py
@@ -17,6 +17,7 @@ from requests.exceptions import RequestException, Timeout
 from requests.utils import get_encoding_from_headers
 from six.moves.urllib.parse import urlparse, urljoin, urlsplit
 from libsourcemap import from_json as view_from_json
+from urllib3.response import GzipDecoder, DeflateDecoder
 
 # In case SSL is unavailable (light builds) we can't import this here.
 try:
@@ -31,7 +32,6 @@ from sentry.exceptions import RestrictedIPAddress
 from sentry.interfaces.stacktrace import Stacktrace
 from sentry.models import EventError, Release, ReleaseFile
 from sentry.utils.cache import cache
-from sentry.utils.files import compress_file
 from sentry.utils.hashlib import md5_text
 from sentry.utils.http import is_valid_origin
 from sentry.utils.strings import truncatechars
@@ -136,6 +136,17 @@ def trim_line(line, column=0):
     return line
 
 
+# TODO(mattrobenolt): Generalize on this and leverage the urllib3
+# decoders inside coreapi as well so we have a unified method for
+# handling gzip/deflate decompression. urllib3 is pretty good at this.
+def get_content_decoder_from_headers(headers):
+    content_encoding = headers.get('content-encoding', '').lower()
+    if content_encoding == 'gzip':
+        return GzipDecoder()
+    if content_encoding == 'deflate':
+        return DeflateDecoder()
+
+
 def get_source_context(source, lineno, colno, context=LINES_OF_CONTEXT):
     if not source:
         return [], '', []
@@ -264,17 +275,30 @@ def fetch_release_file(filename, release):
         logger.debug('Found release artifact %r (id=%s, release_id=%s)',
                      filename, releasefile.id, release.id)
         try:
+            body = []
             with metrics.timer('sourcemaps.release_file_read'):
                 with releasefile.file.getfile() as fp:
-                    body = compress_file(fp)
+                    for chunk in fp.chunks():
+                        body.append(chunk)
+            body = b''.join(body)
         except Exception as e:
             logger.exception(six.text_type(e))
             cache.set(cache_key, -1, 3600)
             result = None
         else:
             headers = {k.lower(): v for k, v in releasefile.file.headers.items()}
-            encoding = get_encoding_from_headers(headers)
-            result = (headers, body, 200, encoding)
+            # Handle gzip/deflate compression depending on Content-Encoding header
+            decoder = get_content_decoder_from_headers(headers)
+            if decoder:
+                try:
+                    body = decoder.decompress(body)
+                except Exception:
+                    raise CannotFetchSource({
+                        'type': EventError.JS_INVALID_SOURCE_ENCODING,
+                        'value': headers.get('content-encoding'),
+                        'url': expose_url(filename),
+                    })
+            result = (headers, body, 200, get_encoding_from_headers(headers))
             cache.set(cache_key, result, 3600)
 
     elif result == -1:
diff --git a/src/sentry/utils/files.py b/src/sentry/utils/files.py
deleted file mode 100644
index 470cf988bf..0000000000
--- a/src/sentry/utils/files.py
+++ /dev/null
@@ -1,15 +0,0 @@
-"""
-sentry.utils.files
-~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-from __future__ import absolute_import
-
-
-def compress_file(fp):
-    chunks = []
-    for chunk in fp.chunks():
-        chunks.append(chunk)
-    return b''.join(chunks)
diff --git a/tests/sentry/lang/javascript/test_processor.py b/tests/sentry/lang/javascript/test_processor.py
index 2e44f90ae2..fbaf5feba3 100644
--- a/tests/sentry/lang/javascript/test_processor.py
+++ b/tests/sentry/lang/javascript/test_processor.py
@@ -5,6 +5,7 @@ from __future__ import absolute_import
 import pytest
 import responses
 import six
+import zlib
 from libsourcemap import Token
 
 from mock import patch
@@ -73,6 +74,126 @@ class FetchReleaseFileTest(TestCase):
 
         assert result == new_result
 
+    def test_deflate(self):
+        project = self.project
+        release = Release.objects.create(
+            project=project,
+            organization_id=project.organization_id,
+            version='abc',
+        )
+        release.add_project(project)
+
+        file = File.objects.create(
+            name='file.min.js',
+            type='release.file',
+            headers={
+                'Content-Type': 'application/json; charset=utf-8',
+                'Content-Encoding': 'deflate'
+            },
+        )
+
+        binary_body = unicode_body.encode('utf-8')
+        file.putfile(six.BytesIO(zlib.compress(binary_body)))
+
+        ReleaseFile.objects.create(
+            name='file.min.js',
+            release=release,
+            project=project,
+            file=file,
+        )
+
+        result = fetch_release_file('file.min.js', release)
+
+        assert type(result[1]) is six.binary_type
+        assert result == (
+            {'content-type': 'application/json; charset=utf-8', 'content-encoding': 'deflate'},
+            binary_body,
+            200,
+            'utf-8',
+        )
+
+        # test with cache hit, which should be compressed
+        new_result = fetch_release_file('file.min.js', release)
+
+        assert result == new_result
+
+    def test_gzip(self):
+        project = self.project
+        release = Release.objects.create(
+            project=project,
+            organization_id=project.organization_id,
+            version='abc',
+        )
+        release.add_project(project)
+
+        file = File.objects.create(
+            name='file.min.js',
+            type='release.file',
+            headers={
+                'Content-Type': 'application/json; charset=utf-8',
+                'Content-Encoding': 'gzip'
+            },
+        )
+
+        binary_body = unicode_body.encode('utf-8')
+        compressor = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
+        file.putfile(six.BytesIO(b''.join([
+            compressor.compress(binary_body),
+            compressor.flush(),
+        ])))
+
+        ReleaseFile.objects.create(
+            name='file.min.js',
+            release=release,
+            project=project,
+            file=file,
+        )
+
+        result = fetch_release_file('file.min.js', release)
+
+        assert type(result[1]) is six.binary_type
+        assert result == (
+            {'content-type': 'application/json; charset=utf-8', 'content-encoding': 'gzip'},
+            binary_body,
+            200,
+            'utf-8',
+        )
+
+        # test with cache hit, which should be compressed
+        new_result = fetch_release_file('file.min.js', release)
+
+        assert result == new_result
+
+    def test_garbage_encoding(self):
+        project = self.project
+        release = Release.objects.create(
+            project=project,
+            organization_id=project.organization_id,
+            version='abc',
+        )
+        release.add_project(project)
+
+        file = File.objects.create(
+            name='file.min.js',
+            type='release.file',
+            headers={
+                'Content-Type': 'application/json; charset=utf-8',
+                'Content-Encoding': 'gzip'
+            },
+        )
+
+        file.putfile(six.BytesIO('notgzipped'))
+
+        ReleaseFile.objects.create(
+            name='file.min.js',
+            release=release,
+            project=project,
+            file=file,
+        )
+
+        with pytest.raises(CannotFetchSource):
+            fetch_release_file('file.min.js', release)
+
 
 class FetchFileTest(TestCase):
     @responses.activate

commit 87ba9a8845f197056a948c24e02970b9ed06a68f
Author: Matt Robenolt <matt@ydekproductions.com>
Date:   Wed Jul 19 13:49:30 2017 -0700

    south: remove junk we don't need
    
    * tests
    * unused database backends

diff --git a/src/south/db/__init__.py b/src/south/db/__init__.py
index ac0564688c..d92ba777b8 100644
--- a/src/south/db/__init__.py
+++ b/src/south/db/__init__.py
@@ -10,25 +10,12 @@ engine_modules = {
     'django.db.backends.postgresql_psycopg2': 'postgresql_psycopg2',
     'django.db.backends.sqlite3': 'sqlite3',
     'django.db.backends.mysql': 'mysql',
-    'mysql_oursql.standard': 'mysql',
-    'django.db.backends.oracle': 'oracle',
-    'sql_server.pyodbc': 'sql_server.pyodbc', #django-pyodbc-azure
-    'django_pyodbc': 'sql_server.pyodbc', #django-pyodbc
-    'sqlserver_ado': 'sql_server.pyodbc', #django-mssql
-    'firebird': 'firebird', #django-firebird
-    'django.contrib.gis.db.backends.postgis': 'postgresql_psycopg2',
-    'django.contrib.gis.db.backends.spatialite': 'sqlite3',
-    'django.contrib.gis.db.backends.mysql': 'mysql',
-    'django.contrib.gis.db.backends.oracle': 'oracle',
-    'doj.backends.zxjdbc.postgresql': 'postgresql_psycopg2', #django-jython
-    'doj.backends.zxjdbc.mysql': 'mysql', #django-jython
-    'doj.backends.zxjdbc.oracle': 'oracle', #django-jython
     'mysql.connector.django': 'mysql', # MySQL Connector/Python
 }
 
 # First, work out if we're multi-db or not, and which databases we have
-try: 
-    from django.db import DEFAULT_DB_ALIAS 
+try:
+    from django.db import DEFAULT_DB_ALIAS
 except ImportError:
     #### 1.1 or below ####
     # We'll 'fake' multi-db; set the default alias
@@ -79,6 +66,6 @@ except ImportError:
         ) % (module_name,)
     )
     sys.exit(1)
-    
+
 # Finally, to make old migrations work, keep 'db' around as the default database
 db = dbs[DEFAULT_DB_ALIAS]
diff --git a/src/south/db/firebird.py b/src/south/db/firebird.py
deleted file mode 100644
index a079819bc3..0000000000
--- a/src/south/db/firebird.py
+++ /dev/null
@@ -1,362 +0,0 @@
-# firebird
-
-from __future__ import print_function
-
-import datetime
-
-from django.db import connection, models
-from django.core.management.color import no_style
-from django.db.utils import DatabaseError
-
-from south.db import generic
-from south.utils.py3 import string_types
-
-class DatabaseOperations(generic.DatabaseOperations):
-    backend_name = 'firebird'
-    alter_string_set_type = 'ALTER %(column)s TYPE %(type)s'
-    alter_string_set_default =  'ALTER %(column)s SET DEFAULT %(default)s;'
-    alter_string_drop_null = ''
-    add_column_string = 'ALTER TABLE %s ADD %s;'
-    delete_column_string = 'ALTER TABLE %s DROP %s;'
-    rename_table_sql = ''
-
-    # Features
-    allows_combined_alters = False
-    has_booleans = False
-
-    def _fill_constraint_cache(self, db_name, table_name):
-        self._constraint_cache.setdefault(db_name, {})
-        self._constraint_cache[db_name][table_name] = {}
-
-        rows = self.execute("""
-            SELECT
-                rc.RDB$CONSTRAINT_NAME,
-                rc.RDB$CONSTRAINT_TYPE,
-                cc.RDB$TRIGGER_NAME
-            FROM rdb$relation_constraints rc
-            JOIN rdb$check_constraints cc
-            ON rc.rdb$constraint_name = cc.rdb$constraint_name
-            WHERE rc.rdb$constraint_type = 'NOT NULL'
-            AND rc.rdb$relation_name = '%s'
-            """ % table_name)
-
-        for constraint, kind, column in rows:
-           self._constraint_cache[db_name][table_name].setdefault(column, set())
-           self._constraint_cache[db_name][table_name][column].add((kind, constraint))
-        return
-
-    def _alter_column_set_null(self, table_name, column_name, is_null):
-        sql = """
-            UPDATE RDB$RELATION_FIELDS SET RDB$NULL_FLAG = %(null_flag)s
-            WHERE RDB$FIELD_NAME = '%(column)s'
-            AND RDB$RELATION_NAME = '%(table_name)s'
-        """
-        null_flag = 'NULL' if is_null else '1'
-        return sql % {
-            'null_flag': null_flag,
-            'column': column_name.upper(),
-            'table_name': table_name.upper()
-        }
-
-    def _column_has_default(self, params):
-        sql = """
-            SELECT a.RDB$DEFAULT_VALUE
-            FROM RDB$RELATION_FIELDS a
-            WHERE a.RDB$FIELD_NAME = '%(column)s'
-            AND a.RDB$RELATION_NAME = '%(table_name)s'
-        """
-        value = self.execute(sql % params)
-        return True if value else False
-
-
-    def _alter_set_defaults(self, field, name, params, sqls):
-        "Subcommand of alter_column that sets default values (overrideable)"
-        # Historically, we used to set defaults here.
-        # But since South 0.8, we don't ever set defaults on alter-column -- we only
-        # use database-level defaults as scaffolding when adding columns.
-        # However, we still sometimes need to remove defaults in alter-column.
-        if self._column_has_default(params):
-            sqls.append(('ALTER COLUMN %s DROP DEFAULT' % (self.quote_name(name),), []))
-
-
-    @generic.invalidate_table_constraints
-    def create_table(self, table_name, fields):
-        columns = []
-        autoinc_sql = ''
-
-        for field_name, field in fields:
-            # avoid default values in CREATE TABLE statements (#925)
-            field._suppress_default = True
-            
-            col = self.column_sql(table_name, field_name, field)
-            if not col:
-                continue
-
-            columns.append(col)
-            if isinstance(field, models.AutoField):
-                field_name = field.db_column or field.column
-                autoinc_sql = connection.ops.autoinc_sql(table_name, field_name)
-
-        self.execute(self.create_table_sql % {
-            "table": self.quote_name(table_name),
-            "columns": ', '.join([col for col in columns if col]),
-        })
-        
-        if autoinc_sql:
-            self.execute(autoinc_sql[0])
-            self.execute(autoinc_sql[1])
-
-    def rename_table(self, old_table_name, table_name):
-        """
-        Renames table is not supported by firebird.
-        This involve recreate all related objects (store procedure, views, triggers, etc)
-        """
-        pass
-
-    @generic.invalidate_table_constraints
-    def delete_table(self, table_name, cascade=False):
-        """
-        Deletes the table 'table_name'.
-        Firebird will also delete any triggers associated with the table.
-        """
-        super(DatabaseOperations, self).delete_table(table_name, cascade=False)
-
-        # Also, drop sequence if exists
-        sql = connection.ops.drop_sequence_sql(table_name)
-        if sql:
-            try:
-                self.execute(sql)
-            except:
-                pass
-
-    def column_sql(self, table_name, field_name, field, tablespace='', with_name=True, field_prepared=False):
-        """
-        Creates the SQL snippet for a column. Used by add_column and add_table.
-        """
-
-        # If the field hasn't already been told its attribute name, do so.
-        if not field_prepared:
-            field.set_attributes_from_name(field_name)
-
-        # hook for the field to do any resolution prior to it's attributes being queried
-        if hasattr(field, 'south_init'):
-            field.south_init()
-
-        # Possible hook to fiddle with the fields (e.g. defaults & TEXT on MySQL)
-        field = self._field_sanity(field)
-
-        try:
-            sql = field.db_type(connection=self._get_connection())
-        except TypeError:
-            sql = field.db_type()
-
-        if sql:
-            # Some callers, like the sqlite stuff, just want the extended type.
-            if with_name:
-                field_output = [self.quote_name(field.column), sql]
-            else:
-                field_output = [sql]
-
-            if field.primary_key:
-                field_output.append('NOT NULL PRIMARY KEY')
-            elif field.unique:
-                # Just use UNIQUE (no indexes any more, we have delete_unique)
-                field_output.append('UNIQUE')
-
-            sql = ' '.join(field_output)
-            sqlparams = ()
-
-            # if the field is "NOT NULL" and a default value is provided, create the column with it
-            # this allows the addition of a NOT NULL field to a table with existing rows
-            if not getattr(field, '_suppress_default', False):
-                if field.has_default():
-                    default = field.get_default()
-                    # If the default is actually None, don't add a default term
-                    if default is not None:
-                        # If the default is a callable, then call it!
-                        if callable(default):
-                            default = default()
-                        # Now do some very cheap quoting. TODO: Redesign return values to avoid this.
-                        if isinstance(default, string_types):
-                            default = "'%s'" % default.replace("'", "''")
-                        elif isinstance(default, (datetime.date, datetime.time, datetime.datetime)):
-                            default = "'%s'" % default
-                        elif isinstance(default, bool):
-                            default = int(default)
-                        # Escape any % signs in the output (bug #317)
-                        if isinstance(default, string_types):
-                            default = default.replace("%", "%%")
-                        # Add it in
-                        sql += " DEFAULT %s"
-                        sqlparams = (default)
-                elif (not field.null and field.blank) or (field.get_default() == ''):
-                    if field.empty_strings_allowed and self._get_connection().features.interprets_empty_strings_as_nulls:
-                        sql += " DEFAULT ''"
-                    # Error here would be nice, but doesn't seem to play fair.
-                    #else:
-                    #    raise ValueError("Attempting to add a non null column that isn't character based without an explicit default value.")
-
-            # Firebird need set not null after of default value keyword
-            if not field.primary_key and not field.null:
-                sql += ' NOT NULL'
-
-            if field.rel and self.supports_foreign_keys:
-                self.add_deferred_sql(
-                    self.foreign_key_sql(
-                        table_name,
-                        field.column,
-                        field.rel.to._meta.db_table,
-                        field.rel.to._meta.get_field(field.rel.field_name).column
-                    )
-                )
-
-        # Things like the contrib.gis module fields have this in 1.1 and below
-        if hasattr(field, 'post_create_sql'):
-            for stmt in field.post_create_sql(no_style(), table_name):
-                self.add_deferred_sql(stmt)
-
-        # Avoid double index creation (#1317)
-        # Firebird creates an index implicity for each foreign key field 
-        # sql_indexes_for_field tries to create an index for that field too
-        if not field.rel:
-            # In 1.2 and above, you have to ask the DatabaseCreation stuff for it.
-            # This also creates normal indexes in 1.1.
-            if hasattr(self._get_connection().creation, "sql_indexes_for_field"):
-                # Make a fake model to pass in, with only db_table
-                model = self.mock_model("FakeModelForGISCreation", table_name)
-                for stmt in self._get_connection().creation.sql_indexes_for_field(model, field, no_style()):
-                    self.add_deferred_sql(stmt)
-
-        if sql:
-            return sql % sqlparams
-        else:
-            return None
-
-
-    def _drop_constraints(self, table_name, name, field):
-        if self.has_check_constraints:
-            check_constraints = self._constraints_affecting_columns(table_name, [name], "CHECK")
-            for constraint in check_constraints:
-                self.execute(self.delete_check_sql % {
-                    'table': self.quote_name(table_name),
-                    'constraint': self.quote_name(constraint),
-                })
-
-        # Drop or add UNIQUE constraint
-        unique_constraint = list(self._constraints_affecting_columns(table_name, [name], "UNIQUE"))
-        if field.unique and not unique_constraint:
-            self.create_unique(table_name, [name])
-        elif not field.unique and unique_constraint:
-            self.delete_unique(table_name, [name])
-
-        # Drop all foreign key constraints
-        try:
-            self.delete_foreign_key(table_name, name)
-        except ValueError:
-            # There weren't any
-            pass
-
-
-    @generic.invalidate_table_constraints
-    def alter_column(self, table_name, name, field, explicit_name=True, ignore_constraints=False):
-        """
-        Alters the given column name so it will match the given field.
-        Note that conversion between the two by the database must be possible.
-        Will not automatically add _id by default; to have this behavour, pass
-        explicit_name=False.
-
-        @param table_name: The name of the table to add the column to
-        @param name: The name of the column to alter
-        @param field: The new field definition to use
-        """
-
-        if self.dry_run:
-            if self.debug:
-                print('   - no dry run output for alter_column() due to dynamic DDL, sorry')
-            return
-
-
-        # hook for the field to do any resolution prior to it's attributes being queried
-        if hasattr(field, 'south_init'):
-            field.south_init()
-
-        # Add _id or whatever if we need to
-        field.set_attributes_from_name(name)
-        if not explicit_name:
-            name = field.column
-        else:
-            field.column = name
-
-        if not ignore_constraints:
-            # Drop all check constraints. Note that constraints will be added back
-            # with self.alter_string_set_type and self.alter_string_drop_null.
-            self._drop_constraints(table_name, name, field)
-
-        # First, change the type
-        params = {
-            "column": self.quote_name(name),
-            "type": self._db_type_for_alter_column(field),
-            "table_name": table_name
-        }
-
-        # SQLs is a list of (SQL, values) pairs.
-        sqls = []
-        sqls_extra = []
-
-        # Only alter the column if it has a type (Geometry ones sometimes don't)
-        if params["type"] is not None:
-            sqls.append((self.alter_string_set_type % params, []))
-
-        # Add any field- and backend- specific modifications
-        self._alter_add_column_mods(field, name, params, sqls)
-
-        # Next, nullity: modified, firebird doesn't support DROP NOT NULL
-        sqls_extra.append(self._alter_column_set_null(table_name, name, field.null))
-
-        # Next, set any default
-        self._alter_set_defaults(field, name, params, sqls)
-
-        # Finally, actually change the column
-        if self.allows_combined_alters:
-            sqls, values = list(zip(*sqls))
-            self.execute(
-                "ALTER TABLE %s %s;" % (self.quote_name(table_name), ", ".join(sqls)),
-                generic.flatten(values),
-            )
-        else:
-            # Databases like e.g. MySQL don't like more than one alter at once.
-            for sql, values in sqls:
-                try:
-                    self.execute("ALTER TABLE %s %s;" % (self.quote_name(table_name), sql), values)
-                except DatabaseError as e:
-                    print(e)
-
-
-        # Execute extra sql, which don't need ALTER TABLE statement
-        for sql in sqls_extra:
-            self.execute(sql)
-
-        if not ignore_constraints:
-            # Add back FK constraints if needed
-            if field.rel and self.supports_foreign_keys:
-                self.execute(
-                    self.foreign_key_sql(
-                        table_name,
-                        field.column,
-                        field.rel.to._meta.db_table,
-                        field.rel.to._meta.get_field(field.rel.field_name).column
-                    )
-                )
-
-    @generic.copy_column_constraints
-    @generic.delete_column_constraints
-    def rename_column(self, table_name, old, new):
-        if old == new:
-            # Short-circuit out
-            return []
-
-        self.execute('ALTER TABLE %s ALTER %s TO %s;' % (
-            self.quote_name(table_name),
-            self.quote_name(old),
-            self.quote_name(new),
-        ))
diff --git a/src/south/db/oracle.py b/src/south/db/oracle.py
deleted file mode 100644
index 79496d0aee..0000000000
--- a/src/south/db/oracle.py
+++ /dev/null
@@ -1,345 +0,0 @@
-from __future__ import print_function
-
-import os.path
-import sys
-import re
-import warnings
-import cx_Oracle
-
-
-from django.db import connection, models
-from django.db.backends.util import truncate_name
-from django.core.management.color import no_style
-from django.db.models.fields import NOT_PROVIDED
-from django.db.utils import DatabaseError
-
-# In revision r16016 function get_sequence_name has been transformed into
-# method of DatabaseOperations class. To make code backward-compatible we
-# need to handle both situations.
-try:
-    from django.db.backends.oracle.base import get_sequence_name\
-        as original_get_sequence_name
-except ImportError:
-    original_get_sequence_name = None
-
-from south.db import generic
-
-class DatabaseOperations(generic.DatabaseOperations):    
-    """
-    Oracle implementation of database operations.    
-    """
-    backend_name = 'oracle'
-
-    alter_string_set_type =     'ALTER TABLE %(table_name)s MODIFY %(column)s %(type)s %(nullity)s;'
-    alter_string_set_default =  'ALTER TABLE %(table_name)s MODIFY %(column)s DEFAULT %(default)s;'
-    alter_string_update_nulls_to_default = \
-                                'UPDATE %(table_name)s SET %(column)s = %(default)s WHERE %(column)s IS NULL;'
-    add_column_string =         'ALTER TABLE %s ADD %s;'
-    delete_column_string =      'ALTER TABLE %s DROP COLUMN %s;'
-    add_constraint_string =     'ALTER TABLE %(table_name)s ADD CONSTRAINT %(constraint)s %(clause)s'
-
-    allows_combined_alters = False
-    has_booleans = False
-    
-    constraints_dict = {
-        'P': 'PRIMARY KEY',
-        'U': 'UNIQUE',
-        'C': 'CHECK',
-        'R': 'FOREIGN KEY'
-    }
-
-    def get_sequence_name(self, table_name):
-        if original_get_sequence_name is None:
-            return self._get_connection().ops._get_sequence_name(table_name)
-        else:
-            return original_get_sequence_name(table_name)
-
-    #TODO: This will cause very obscure bugs if anyone uses a column name or string value
-    #      that looks like a column definition (with 'CHECK', 'DEFAULT' and/or 'NULL' in it)
-    #      e.g. "CHECK MATE" varchar(10) DEFAULT 'NULL'
-    def adj_column_sql(self, col):
-        # Syntax fixes -- Oracle is picky about clause order
-        col = re.sub('(?P<constr>CHECK \(.*\))(?P<any>.*)(?P<default>DEFAULT \d+)', 
-                     lambda mo: '%s %s%s'%(mo.group('default'), mo.group('constr'), mo.group('any')), col) #syntax fix for boolean/integer field only
-        col = re.sub('(?P<not_null>(NOT )?NULL) (?P<misc>(.* )?)(?P<default>DEFAULT.+)',
-                     lambda mo: '%s %s %s'%(mo.group('default'),mo.group('not_null'),mo.group('misc') or ''), col) #fix order of NULL/NOT NULL and DEFAULT
-        return col
-
-    def check_meta(self, table_name):
-        return table_name in [ m._meta.db_table for m in models.get_models() ] #caching provided by Django
-    
-    def normalize_name(self, name):
-        """
-        Get the properly shortened and uppercased identifier as returned by quote_name(), but without the actual quotes.
-        """
-        nn = self.quote_name(name)
-        if nn[0] == '"' and nn[-1] == '"':
-            nn = nn[1:-1]
-        return nn
-
-    @generic.invalidate_table_constraints
-    def create_table(self, table_name, fields): 
-        qn = self.quote_name(table_name)
-        columns = []
-        autoinc_sql = ''
-
-
-        for field_name, field in fields:
-            
-            field = self._field_sanity(field)
-
-            # avoid default values in CREATE TABLE statements (#925)
-            field._suppress_default = True
-
-
-            col = self.column_sql(table_name, field_name, field)
-            if not col:
-                continue
-            col = self.adj_column_sql(col)
-
-            columns.append(col)
-            if isinstance(field, models.AutoField):
-                autoinc_sql = connection.ops.autoinc_sql(table_name, field_name)
-
-        sql = 'CREATE TABLE %s (%s);' % (qn, ', '.join([col for col in columns]))
-        self.execute(sql)
-        if autoinc_sql:
-            self.execute(autoinc_sql[0])
-            self.execute(autoinc_sql[1])
-
-    @generic.invalidate_table_constraints
-    def delete_table(self, table_name, cascade=True):
-        qn = self.quote_name(table_name)
-
-        # Note: PURGE is not valid syntax for Oracle 9i (it was added in 10)
-        if cascade:
-            self.execute('DROP TABLE %s CASCADE CONSTRAINTS;' % qn)
-        else:
-            self.execute('DROP TABLE %s;' % qn)
-        
-        # If the table has an AutoField a sequence was created.
-        sequence_sql = """
-DECLARE
-    i INTEGER;
-BEGIN
-    SELECT COUNT(*) INTO i FROM USER_CATALOG
-        WHERE TABLE_NAME = '%(sq_name)s' AND TABLE_TYPE = 'SEQUENCE';
-    IF i = 1 THEN
-        EXECUTE IMMEDIATE 'DROP SEQUENCE "%(sq_name)s"';
-    END IF;
-END;
-/""" % {'sq_name': self.get_sequence_name(table_name)}
-        self.execute(sequence_sql)
-
-    @generic.invalidate_table_constraints
-    def alter_column(self, table_name, name, field, explicit_name=True, ignore_constraints=False):
-        
-        if self.dry_run:
-            if self.debug:
-                print('   - no dry run output for alter_column() due to dynamic DDL, sorry')
-            return
-
-        qn = self.quote_name(table_name)
-
-        # hook for the field to do any resolution prior to it's attributes being queried
-        if hasattr(field, 'south_init'):
-            field.south_init()
-        field = self._field_sanity(field)
-
-        # Add _id or whatever if we need to
-        field.set_attributes_from_name(name)
-        if not explicit_name:
-            name = field.column
-        qn_col = self.quote_name(name)
-
-        # First, change the type
-        # This will actually also add any CHECK constraints needed,
-        # since e.g. 'type' for a BooleanField is 'NUMBER(1) CHECK (%(qn_column)s IN (0,1))'
-        params = {
-            'table_name':qn,
-            'column': qn_col,
-            'type': self._db_type_for_alter_column(field),
-            'nullity': 'NOT NULL',
-            'default': 'NULL'
-        }
-        if field.null:
-            params['nullity'] = 'NULL'
-
-        sql_templates = [
-            (self.alter_string_set_type, params, []),
-            (self.alter_string_set_default, params, []),
-        ]
-        if not field.null and field.has_default():
-            # Use default for rows that had nulls. To support the case where
-            # the new default does not fit the old type, we need to first change
-            # the column type to the new type, but null=True; then set the default;
-            # then complete the type change. 
-            def change_params(**kw):
-                "A little helper for non-destructively changing the params"
-                p = params.copy()
-                p.update(kw)
-                return p
-            sql_templates[:0] = [
-                (self.alter_string_set_type, change_params(nullity='NULL'),[]),
-                (self.alter_string_update_nulls_to_default, change_params(default="%s"), [field.get_default()]),
-            ]
-
-        if not ignore_constraints:
-            # drop CHECK constraints. Make sure this is executed before the ALTER TABLE statements
-            # generated above, since those statements recreate the constraints we delete here.
-            check_constraints = self._constraints_affecting_columns(table_name, [name], "CHECK")
-            for constraint in check_constraints:
-                self.execute(self.delete_check_sql % {
-                    'table': self.quote_name(table_name),
-                    'constraint': self.quote_name(constraint),
-                })
-            # Drop foreign constraints
-            try:
-                self.delete_foreign_key(qn, qn_col)
-            except ValueError:
-                # There weren't any
-                pass
-
-        for sql_template, params, args in sql_templates:
-            try:
-                self.execute(sql_template % params, args, print_all_errors=False)
-            except DatabaseError as exc:
-                description = str(exc)
-                # Oracle complains if a column is already NULL/NOT NULL
-                if 'ORA-01442' in description or 'ORA-01451' in description:
-                    # so we just drop NULL/NOT NULL part from target sql and retry
-                    params['nullity'] = ''
-                    sql = sql_template % params
-                    self.execute(sql)
-                # Oracle also has issues if we try to change a regular column
-                # to a LOB or vice versa (also REF, object, VARRAY or nested
-                # table, but these don't come up much in Django apps)
-                elif 'ORA-22858' in description or 'ORA-22859' in description:
-                    self._alter_column_lob_workaround(table_name, name, field)
-                else:
-                    self._print_sql_error(exc, sql_template % params)
-                    raise
-
-        if not ignore_constraints:
-            # Add back FK constraints if needed
-            if field.rel: #and self.supports_foreign_keys:
-                self.add_deferred_sql(
-                    self.foreign_key_sql(
-                        qn[1:-1],      # foreign_key_sql uses this as part of constraint name
-                        qn_col[1:-1],  # foreign_key_sql uses this as part of constraint name
-                        field.rel.to._meta.db_table,
-                        field.rel.to._meta.get_field(field.rel.field_name).column
-                    )
-                )
-
-
-    def _alter_column_lob_workaround(self, table_name, name, field):
-        """
-        Oracle refuses to change a column type from/to LOB to/from a regular
-        column. In Django, this shows up when the field is changed from/to
-        a TextField.
-        What we need to do instead is:
-        - Rename the original column
-        - Add the desired field as new
-        - Update the table to transfer values from old to new
-        - Drop old column
-        """
-        renamed = self._generate_temp_name(name)
-        self.rename_column(table_name, name, renamed)
-        self.add_column(table_name, name, field, keep_default=False)
-        self.execute("UPDATE %s set %s=%s" % (
-            self.quote_name(table_name),
-            self.quote_name(name),
-            self.quote_name(renamed),
-        ))
-        self.delete_column(table_name, renamed)
-
-    def _generate_temp_name(self, for_name):
-        suffix = hex(hash(for_name)).upper()[1:]
-        return self.normalize_name(for_name + "_" + suffix)
-    
-    @generic.copy_column_constraints #TODO: Appears to be nulled by the delete decorator below...
-    @generic.delete_column_constraints
-    def rename_column(self, table_name, old, new):
-        if old == new:
-            # Short-circuit out
-            return []
-        self.execute('ALTER TABLE %s RENAME COLUMN %s TO %s;' % (
-            self.quote_name(table_name),
-            self.quote_name(old),
-            self.quote_name(new),
-        ))
-
-    @generic.invalidate_table_constraints
-    def add_column(self, table_name, name, field, keep_default=False):
-        field = self._field_sanity(field)
-        sql = self.column_sql(table_name, name, field)
-        sql = self.adj_column_sql(sql)
-
-        if sql:
-            params = (
-                self.quote_name(table_name),
-                sql
-            )
-            sql = self.add_column_string % params
-            self.execute(sql)
-
-            # Now, drop the default if we need to
-            if field.default is not None:
-                field.default = NOT_PROVIDED
-                self.alter_column(table_name, name, field, explicit_name=False, ignore_constraints=True)
-
-    def delete_column(self, table_name, name):
-        return super(DatabaseOperations, self).delete_column(self.quote_name(table_name), name)
-
-    def lookup_constraint(self, db_name, table_name, column_name=None):
-        if column_name:
-            # Column names in the constraint cache come from the database,
-            # make sure we use the properly shortened/uppercased version
-            # for lookup.
-            column_name = self.normalize_name(column_name)
-        return super(DatabaseOperations, self).lookup_constraint(db_name, table_name, column_name)
-
-    def _constraints_affecting_columns(self, table_name, columns, type="UNIQUE"):
-        if columns:
-            columns = [self.normalize_name(c) for c in columns]
-        return super(DatabaseOperations, self)._constraints_affecting_columns(table_name, columns, type)
-
-    def _field_sanity(self, field):
-        """
-        This particular override stops us sending DEFAULTs for BooleanField.
-        """
-        if isinstance(field, models.BooleanField) and field.has_default():
-            field.default = int(field.to_python(field.get_default()))
-        # On Oracle, empty strings are null
-        if isinstance(field, (models.CharField, models.TextField)):
-            field.null = field.empty_strings_allowed
-        return field
-
-
-    def _default_value_workaround(self, value):
-        from datetime import date,time,datetime
-        if isinstance(value, (date,time,datetime)):
-            return "'%s'" % value
-        else:
-            return super(DatabaseOperations, self)._default_value_workaround(value)
-
-    def _fill_constraint_cache(self, db_name, table_name):
-        self._constraint_cache.setdefault(db_name, {}) 
-        self._constraint_cache[db_name][table_name] = {} 
-
-        rows = self.execute("""
-            SELECT user_cons_columns.constraint_name,
-                   user_cons_columns.column_name,
-                   user_constraints.constraint_type
-            FROM user_constraints
-            JOIN user_cons_columns ON
-                 user_constraints.table_name = user_cons_columns.table_name AND 
-                 user_constraints.constraint_name = user_cons_columns.constraint_name
-            WHERE user_constraints.table_name = '%s'
-        """ % self.normalize_name(table_name))
-
-        for constraint, column, kind in rows:
-            self._constraint_cache[db_name][table_name].setdefault(column, set())
-            self._constraint_cache[db_name][table_name][column].add((self.constraints_dict[kind], constraint))
-        return
diff --git a/src/south/db/sql_server/__init__.py b/src/south/db/sql_server/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/db/sql_server/pyodbc.py b/src/south/db/sql_server/pyodbc.py
deleted file mode 100644
index b725ec0da6..0000000000
--- a/src/south/db/sql_server/pyodbc.py
+++ /dev/null
@@ -1,444 +0,0 @@
-from datetime import date, datetime, time
-from warnings import warn
-from django.db import models
-from django.db.models import fields
-from south.db import generic
-from south.db.generic import delete_column_constraints, invalidate_table_constraints, copy_column_constraints
-from south.exceptions import ConstraintDropped
-from south.utils.py3 import string_types
-try:
-    from django.utils.encoding import smart_text                    # Django >= 1.5
-except ImportError:
-    from django.utils.encoding import smart_unicode as smart_text   # Django < 1.5
-from django.core.management.color import no_style
-
-class DatabaseOperations(generic.DatabaseOperations):
-    """
-    django-pyodbc (sql_server.pyodbc) implementation of database operations.
-    """
-    
-    backend_name = "pyodbc"
-    
-    add_column_string = 'ALTER TABLE %s ADD %s;'
-    alter_string_set_type = 'ALTER COLUMN %(column)s %(type)s'
-    alter_string_set_null = 'ALTER COLUMN %(column)s %(type)s NULL'
-    alter_string_drop_null = 'ALTER COLUMN %(column)s %(type)s NOT NULL'
-    
-    allows_combined_alters = False
-
-    drop_index_string = 'DROP INDEX %(index_name)s ON %(table_name)s'
-    drop_constraint_string = 'ALTER TABLE %(table_name)s DROP CONSTRAINT %(constraint_name)s'
-    delete_column_string = 'ALTER TABLE %s DROP COLUMN %s'
-
-    #create_check_constraint_sql = "ALTER TABLE %(table)s " + \
-    #                              generic.DatabaseOperations.add_check_constraint_fragment 
-    create_foreign_key_sql = "ALTER TABLE %(table)s ADD CONSTRAINT %(constraint)s " + \
-                             "FOREIGN KEY (%(column)s) REFERENCES %(target)s"
-    create_unique_sql = "ALTER TABLE %(table)s ADD CONSTRAINT %(constraint)s UNIQUE (%(columns)s)"
-    
-    
-    default_schema_name = "dbo"
-    
-    has_booleans = False
-
-
-    @delete_column_constraints
-    def delete_column(self, table_name, name):
-        q_table_name, q_name = (self.quote_name(table_name), self.quote_name(name))
-
-        # Zap the constraints
-        for const in self._find_constraints_for_column(table_name,name):
-            params = {'table_name':q_table_name, 'constraint_name': const}
-            sql = self.drop_constraint_string % params
-            self.execute(sql, [])
-
-        # Zap the indexes
-        for ind in self._find_indexes_for_column(table_name,name):
-            params = {'table_name':q_table_name, 'index_name': ind}
-            sql = self.drop_index_string % params
-            self.execute(sql, [])
-
-        # Zap default if exists
-        drop_default = self.drop_column_default_sql(table_name, name)
-        if drop_default:
-            sql = "ALTER TABLE [%s] %s" % (table_name, drop_default)
-            self.execute(sql, [])
-
-        # Finally zap the column itself
-        self.execute(self.delete_column_string % (q_table_name, q_name), [])
-
-    def _find_indexes_for_column(self, table_name, name):
-        "Find the indexes that apply to a column, needed when deleting"
-
-        sql = """
-        SELECT si.name, si.id, sik.colid, sc.name
-        FROM dbo.sysindexes si WITH (NOLOCK)
-        INNER JOIN dbo.sysindexkeys sik WITH (NOLOCK)
-            ON  sik.id = si.id
-            AND sik.indid = si.indid
-        INNER JOIN dbo.syscolumns sc WITH (NOLOCK)
-            ON  si.id = sc.id
-            AND sik.colid = sc.colid
-        WHERE si.indid !=0
-            AND si.id = OBJECT_ID('%s')
-            AND sc.name = '%s'
-        """
-        idx = self.execute(sql % (table_name, name), [])
-        return [i[0] for i in idx]
-
-
-    def _find_constraints_for_column(self, table_name, name, just_names=True):
-        """
-        Find the constraints that apply to a column, needed when deleting. Defaults not included.
-        This is more general than the parent _constraints_affecting_columns, as on MSSQL this
-        includes PK and FK constraints.
-        """
-
-        sql = """
-         SELECT CC.[CONSTRAINT_NAME]
-              ,TC.[CONSTRAINT_TYPE]
-              ,CHK.[CHECK_CLAUSE]
-              ,RFD.TABLE_SCHEMA
-              ,RFD.TABLE_NAME
-              ,RFD.COLUMN_NAME
-              -- used for normalized names
-              ,CC.TABLE_NAME
-              ,CC.COLUMN_NAME
-          FROM [INFORMATION_SCHEMA].[TABLE_CONSTRAINTS] TC
-          JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE CC
-               ON TC.CONSTRAINT_CATALOG = CC.CONSTRAINT_CATALOG 
-              AND TC.CONSTRAINT_SCHEMA = CC.CONSTRAINT_SCHEMA
-              AND TC.CONSTRAINT_NAME = CC.CONSTRAINT_NAME
-          LEFT JOIN INFORMATION_SCHEMA.CHECK_CONSTRAINTS CHK
-               ON CHK.CONSTRAINT_CATALOG = CC.CONSTRAINT_CATALOG
-              AND CHK.CONSTRAINT_SCHEMA = CC.CONSTRAINT_SCHEMA
-              AND CHK.CONSTRAINT_NAME = CC.CONSTRAINT_NAME
-              AND 'CHECK' = TC.CONSTRAINT_TYPE
-          LEFT JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS REF
-               ON REF.CONSTRAINT_CATALOG = CC.CONSTRAINT_CATALOG
-              AND REF.CONSTRAINT_SCHEMA = CC.CONSTRAINT_SCHEMA
-              AND REF.CONSTRAINT_NAME = CC.CONSTRAINT_NAME
-              AND 'FOREIGN KEY' = TC.CONSTRAINT_TYPE
-          LEFT JOIN INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE RFD
-               ON RFD.CONSTRAINT_CATALOG = REF.UNIQUE_CONSTRAINT_CATALOG
-              AND RFD.CONSTRAINT_SCHEMA = REF.UNIQUE_CONSTRAINT_SCHEMA
-              AND RFD.CONSTRAINT_NAME = REF.UNIQUE_CONSTRAINT_NAME
-          WHERE CC.CONSTRAINT_CATALOG = CC.TABLE_CATALOG
-            AND CC.CONSTRAINT_SCHEMA = CC.TABLE_SCHEMA
-            AND CC.TABLE_CATALOG = %s
-            AND CC.TABLE_SCHEMA = %s
-            AND CC.TABLE_NAME = %s
-            AND CC.COLUMN_NAME = %s 
-        """
-        db_name = self._get_setting('name')
-        schema_name = self._get_schema_name()
-        table = self.execute(sql, [db_name, schema_name, table_name, name])
-        
-        if just_names:
-            return [r[0] for r in table]
-        
-        all = {}
-        for r in table:
-            cons_name, type = r[:2]
-            if type=='PRIMARY KEY' or type=='UNIQUE':
-                cons = all.setdefault(cons_name, (type,[]))
-                sql = '''
-                SELECT COLUMN_NAME
-                FROM INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE RFD
-                WHERE RFD.CONSTRAINT_CATALOG = %s
-                  AND RFD.CONSTRAINT_SCHEMA = %s
-                  AND RFD.TABLE_NAME = %s
-                  AND RFD.CONSTRAINT_NAME = %s
-                '''
-                columns = self.execute(sql, [db_name, schema_name, table_name, cons_name])
-                cons[1].extend(col for col, in columns)
-            elif type=='CHECK':
-                cons = (type, r[2])
-            elif type=='FOREIGN KEY':
-                if cons_name in all:
-                    raise NotImplementedError("Multiple-column foreign keys are not supported")
-                else:
-                    cons = (type, r[3:6])
-            else:
-                raise NotImplementedError("Don't know how to handle constraints of type "+ type)
-            all[cons_name] = cons
-        return all
-
-    @invalidate_table_constraints        
-    def alter_column(self, table_name, name, field, explicit_name=True, ignore_constraints=False):
-        """
-        Alters the given column name so it will match the given field.
-        Note that conversion between the two by the database must be possible.
-        Will not automatically add _id by default; to have this behavour, pass
-        explicit_name=False.
-
-        @param table_name: The name of the table to add the column to
-        @param name: The name of the column to alter
-        @param field: The new field definition to use
-        """
-        self._fix_field_definition(field)
-
-        if not ignore_constraints:
-            qn = self.quote_name
-            sch = qn(self._get_schema_name())
-            tab = qn(table_name)
-            table = ".".join([sch, tab])
-            try:
-                self.delete_foreign_key(table_name, name)
-            except ValueError:
-                # no FK constraint on this field. That's OK.
-                pass
-            constraints = self._find_constraints_for_column(table_name, name, False)
-            for constraint in constraints.keys():
-                params = dict(table_name = table,
-                              constraint_name = qn(constraint))
-                sql = self.drop_constraint_string % params
-                self.execute(sql, [])
-                
-        ret_val = super(DatabaseOperations, self).alter_column(table_name, name, field, explicit_name, ignore_constraints=True)
-        
-        if not ignore_constraints:
-            for cname, (ctype,args) in constraints.items():
-                params = dict(table = table,
-                              constraint = qn(cname))
-                if ctype=='UNIQUE':
-                    params['columns'] = ", ".join(map(qn,args))
-                    sql = self.create_unique_sql % params
-                elif ctype=='PRIMARY KEY':
-                    params['columns'] = ", ".join(map(qn,args))
-                    sql = self.create_primary_key_string % params
-                elif ctype=='FOREIGN KEY':
-                    continue
-                    # Foreign keys taken care of below 
-                    #target = "%s.%s(%s)" % tuple(map(qn,args))
-                    #params.update(column = qn(name), target = target)
-                    #sql = self.create_foreign_key_sql % params
-                elif ctype=='CHECK':
-                    warn(ConstraintDropped("CHECK "+ args, table_name, name))
-                    continue
-                    #TODO: Some check constraints should be restored; but not before the generic
-                    #      backend restores them.
-                    #params['check'] = args
-                    #sql = self.create_check_constraint_sql % params
-                else:
-                    raise NotImplementedError("Don't know how to handle constraints of type "+ type)                    
-                self.execute(sql, [])
-            # Create foreign key if necessary
-            if field.rel and self.supports_foreign_keys:
-                self.execute(
-                    self.foreign_key_sql(
-                        table_name,
-                        field.column,
-                        field.rel.to._meta.db_table,
-                        field.rel.to._meta.get_field(field.rel.field_name).column
-                    )
-                )
-                model = self.mock_model("FakeModelForIndexCreation", table_name)
-                for stmt in self._get_connection().creation.sql_indexes_for_field(model, field, no_style()):
-                    self.execute(stmt)
-
-
-        return ret_val
-    
-    def _alter_set_defaults(self, field, name, params, sqls): 
-        "Subcommand of alter_column that sets default values (overrideable)"
-        # Historically, we used to set defaults here.
-        # But since South 0.8, we don't ever set defaults on alter-column -- we only
-        # use database-level defaults as scaffolding when adding columns.
-        # However, we still sometimes need to remove defaults in alter-column.
-        table_name = self.quote_name(params['table_name'])
-        drop_default = self.drop_column_default_sql(table_name, name)
-        if drop_default:
-            sqls.append((drop_default, []))
-            
-    def _value_to_unquoted_literal(self, field, value):
-        # Start with the field's own translation
-        conn = self._get_connection()
-        value = field.get_db_prep_save(value, connection=conn)
-        # This is still a Python object -- nobody expects to need a literal.
-        if isinstance(value, string_types):
-            return smart_text(value)
-        elif isinstance(value, (date,time,datetime)):
-            return value.isoformat()
-        else:
-            #TODO: Anybody else needs special translations?
-            return str(value) 
-    def _default_value_workaround(self, value):
-        if isinstance(value, (date,time,datetime)):
-            return value.isoformat()
-        else:
-            return super(DatabaseOperations, self)._default_value_workaround(value)
-        
-    def _quote_string(self, s):
-        return "'" + s.replace("'","''") + "'"
-    
-
-    def drop_column_default_sql(self, table_name, name, q_name=None):
-        "MSSQL specific drop default, which is a pain"
-
-        sql = """
-        SELECT object_name(cdefault)
-        FROM syscolumns
-        WHERE id = object_id('%s')
-        AND name = '%s'
-        """
-        cons = self.execute(sql % (table_name, name), [])
-        if cons and cons[0] and cons[0][0]:
-            return "DROP CONSTRAINT %s" % cons[0][0]
-        return None
-
-    def _fix_field_definition(self, field):
-        if isinstance(field, (fields.BooleanField, fields.NullBooleanField)):
-            if field.default == True:
-                field.default = 1
-            if field.default == False:
-                field.default = 0
-
-    # This is copied from South's generic add_column, with two modifications:
-    # 1) The sql-server-specific call to _fix_field_definition
-    # 2) Removing a default, when needed, by calling drop_default and not the more general alter_column
-    @invalidate_table_constraints
-    def add_column(self, table_name, name, field, keep_default=False):
-        """
-        Adds the column 'name' to the table 'table_name'.
-        Uses the 'field' paramater, a django.db.models.fields.Field instance,
-        to generate the necessary sql
-
-        @param table_name: The name of the table to add the column to
-        @param name: The name of the column to add
-        @param field: The field to use
-        """
-        self._fix_field_definition(field)
-        sql = self.column_sql(table_name, name, field)
-        if sql:
-            params = (
-                self.quote_name(table_name),
-                sql,
-            )
-            sql = self.add_column_string % params
-            self.execute(sql)
-
-            # Now, drop the default if we need to
-            if not keep_default and field.default is not None:
-                field.default = fields.NOT_PROVIDED
-                #self.alter_column(table_name, name, field, explicit_name=False, ignore_constraints=True)
-                self.drop_default(table_name, name, field)
-
-    @invalidate_table_constraints
-    def drop_default(self, table_name, name, field):
-        fragment = self.drop_column_default_sql(table_name, name)
-        if fragment:
-            table_name = self.quote_name(table_name)
-            sql = " ".join(["ALTER TABLE", table_name, fragment])
-            self.execute(sql)        
-
-
-    @invalidate_table_constraints
-    def create_table(self, table_name, field_defs):
-        # Tweak stuff as needed
-        for _, f in field_defs:
-            self._fix_field_definition(f)
-
-        # Run
-        super(DatabaseOperations, self).create_table(table_name, field_defs)
-
-    def _find_referencing_fks(self, table_name):
-        "MSSQL does not support cascading FKs when dropping tables, we need to implement."
-
-        # FK -- Foreign Keys
-        # UCTU -- Unique Constraints Table Usage
-        # FKTU -- Foreign Key Table Usage
-        # (last two are both really CONSTRAINT_TABLE_USAGE, different join conditions)
-        sql = """
-        SELECT FKTU.TABLE_SCHEMA as REFING_TABLE_SCHEMA,
-               FKTU.TABLE_NAME as REFING_TABLE_NAME,
-               FK.[CONSTRAINT_NAME] as FK_NAME
-        FROM [INFORMATION_SCHEMA].[REFERENTIAL_CONSTRAINTS] FK
-        JOIN [INFORMATION_SCHEMA].[CONSTRAINT_TABLE_USAGE] UCTU
-          ON FK.UNIQUE_CONSTRAINT_CATALOG = UCTU.CONSTRAINT_CATALOG and
-             FK.UNIQUE_CONSTRAINT_NAME = UCTU.CONSTRAINT_NAME and
-             FK.UNIQUE_CONSTRAINT_SCHEMA = UCTU.CONSTRAINT_SCHEMA
-        JOIN [INFORMATION_SCHEMA].[CONSTRAINT_TABLE_USAGE] FKTU
-          ON FK.CONSTRAINT_CATALOG = FKTU.CONSTRAINT_CATALOG and
-             FK.CONSTRAINT_NAME = FKTU.CONSTRAINT_NAME and
-             FK.CONSTRAINT_SCHEMA = FKTU.CONSTRAINT_SCHEMA
-        WHERE FK.CONSTRAINT_CATALOG = %s
-          AND UCTU.TABLE_SCHEMA = %s -- REFD_TABLE_SCHEMA
-          AND UCTU.TABLE_NAME = %s -- REFD_TABLE_NAME
-        """
-        db_name = self._get_setting('name')
-        schema_name = self._get_schema_name()
-        return self.execute(sql, [db_name, schema_name, table_name])
-                
-    @invalidate_table_constraints
-    def delete_table(self, table_name, cascade=True):
-        """
-        Deletes the table 'table_name'.
-        """
-        if cascade:
-            refing = self._find_referencing_fks(table_name)
-            for schmea, table, constraint in refing:
-                table = ".".join(map (self.quote_name, [schmea, table]))
-                params = dict(table_name = table,
-                              constraint_name = self.quote_name(constraint))
-                sql = self.drop_constraint_string % params
-                self.execute(sql, [])
-            cascade = False
-        super(DatabaseOperations, self).delete_table(table_name, cascade)
-            
-    @copy_column_constraints
-    @delete_column_constraints
-    def rename_column(self, table_name, old, new):
-        """
-        Renames the column of 'table_name' from 'old' to 'new'.
-        WARNING - This isn't transactional on MSSQL!
-        """
-        if old == new:
-            # No Operation
-            return
-        # Examples on the MS site show the table name not being quoted...
-        params = (table_name, self.quote_name(old), self.quote_name(new))
-        self.execute("EXEC sp_rename '%s.%s', %s, 'COLUMN'" % params)
-
-    @invalidate_table_constraints
-    def rename_table(self, old_table_name, table_name):
-        """
-        Renames the table 'old_table_name' to 'table_name'.
-        WARNING - This isn't transactional on MSSQL!
-        """
-        if old_table_name == table_name:
-            # No Operation
-            return
-        params = (self.quote_name(old_table_name), self.quote_name(table_name))
-        self.execute('EXEC sp_rename %s, %s' % params)
-
-    def _db_type_for_alter_column(self, field): 
-        return self._db_positive_type_for_alter_column(DatabaseOperations, field)
-
-    def _alter_add_column_mods(self, field, name, params, sqls):
-        return self._alter_add_positive_check(DatabaseOperations, field, name, params, sqls)
-
-    @invalidate_table_constraints
-    def delete_foreign_key(self, table_name, column):
-        super(DatabaseOperations, self).delete_foreign_key(table_name, column)
-        # A FK also implies a non-unique index
-        find_index_sql = """
-            SELECT i.name -- s.name, t.name,  c.name
-            FROM sys.tables t
-            INNER JOIN sys.schemas s ON t.schema_id = s.schema_id
-            INNER JOIN sys.indexes i ON i.object_id = t.object_id
-            INNER JOIN sys.index_columns ic ON ic.object_id = t.object_id
-                                            AND ic.index_id = i.index_id
-            INNER JOIN sys.columns c ON c.object_id = t.object_id 
-                                     AND ic.column_id = c.column_id
-            WHERE i.is_unique=0 AND i.is_primary_key=0 AND i.is_unique_constraint=0
-              AND s.name = %s
-              AND t.name = %s
-              AND c.name = %s
-            """
-        schema = self._get_schema_name()
-        indexes = self.execute(find_index_sql, [schema, table_name, column])
-        qn = self.quote_name
-        for index in (i[0] for i in indexes if i[0]): # "if i[0]" added because an empty name may return
-            self.execute("DROP INDEX %s on %s.%s" % (qn(index), qn(schema), qn(table_name) ))
-            
diff --git a/src/south/tests/__init__.py b/src/south/tests/__init__.py
deleted file mode 100644
index 26779e35b2..0000000000
--- a/src/south/tests/__init__.py
+++ /dev/null
@@ -1,109 +0,0 @@
-from __future__ import print_function
-
-#import unittest
-import os
-import sys
-from functools import wraps
-from django.conf import settings
-from south.hacks import hacks
-
-# Make sure skipping tests is available.
-try:
-    # easiest and best is unittest included in Django>=1.3
-    from django.utils import unittest
-except ImportError:
-    # earlier django... use unittest from stdlib
-    import unittest
-# however, skipUnless was only added in Python 2.7;
-# if not available, we need to do something else
-try:
-    skipUnless = unittest.skipUnless #@UnusedVariable
-except AttributeError:
-    def skipUnless(condition, message):
-        def decorator(testfunc):
-            @wraps(testfunc)
-            def wrapper(self):
-                if condition:
-                    # Apply method
-                    testfunc(self)
-                else:
-                    # The skip exceptions are not available either...
-                    print("Skipping", testfunc.__name__,"--", message)
-            return wrapper
-        return decorator
-
-# ditto for skipIf
-try:
-    skipIf = unittest.skipIf #@UnusedVariable
-except AttributeError:
-    def skipIf(condition, message):
-        def decorator(testfunc):
-            @wraps(testfunc)
-            def wrapper(self):
-                if condition:
-                    print("Skipping", testfunc.__name__,"--", message)
-                else:
-                    # Apply method
-                    testfunc(self)
-            return wrapper
-        return decorator
-
-# Add the tests directory so fakeapp is on sys.path
-test_root = os.path.dirname(__file__)
-sys.path.append(test_root)
-
-# Note: the individual test files are imported below this.
-
-class Monkeypatcher(unittest.TestCase):
-
-    """
-    Base test class for tests that play with the INSTALLED_APPS setting at runtime.
-    """
-
-    def create_fake_app(self, name):
-        
-        class Fake:
-            pass
-        
-        fake = Fake()
-        fake.__name__ = name
-        try:
-            fake.migrations = __import__(name + ".migrations", {}, {}, ['migrations'])
-        except ImportError:
-            pass
-        return fake
-
-    def setUp(self):
-        """
-        Changes the Django environment so we can run tests against our test apps.
-        """
-        if hasattr(self, 'installed_apps'):
-            hacks.store_app_cache_state()
-            hacks.set_installed_apps(self.installed_apps)
-            # Make sure dependencies are calculated for new apps
-            Migrations._dependencies_done = False
-
-    def tearDown(self):
-        """
-        Undoes what setUp did.
-        """
-        if hasattr(self, 'installed_apps'):
-            hacks.reset_installed_apps()
-            hacks.restore_app_cache_state()
-
-
-# Try importing all tests if asked for (then we can run 'em)
-try:
-    skiptest = settings.SKIP_SOUTH_TESTS
-except:
-    skiptest = True
-
-if not skiptest:
-    from south.tests.db import *
-    from south.tests.db_mysql import *
-    from south.tests.db_firebird import *
-    from south.tests.logic import *
-    from south.tests.autodetection import *
-    from south.tests.logger import *
-    from south.tests.inspector import *
-    from south.tests.freezer import *
diff --git a/src/south/tests/autodetection.py b/src/south/tests/autodetection.py
deleted file mode 100644
index c320d3a8d2..0000000000
--- a/src/south/tests/autodetection.py
+++ /dev/null
@@ -1,360 +0,0 @@
-from south.tests import unittest
-
-from south.creator.changes import AutoChanges, InitialChanges
-from south.migration.base import Migrations
-from south.tests import Monkeypatcher
-from south.creator import freezer
-from south.orm import FakeORM
-from south.v2 import SchemaMigration
-
-try:
-    from django.utils.six.moves import reload_module
-except ImportError:
-    # Older django, no python3 support
-    reload_module = reload
-
-class TestComparison(unittest.TestCase):
-    
-    """
-    Tests the comparison methods of startmigration.
-    """
-    
-    def test_no_change(self):
-        "Test with a completely unchanged definition."
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['southdemo.Lizard']"}),
-                ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['southdemo.Lizard']"}),
-            ),
-            False,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.related.ForeignKey', ['ohhai', 'there'], {'to': "somewhere", "from": "there"}),
-                ('django.db.models.fields.related.ForeignKey', ['ohhai', 'there'], {"from": "there", 'to': "somewhere"}),
-            ),
-            False,
-        )
-    
-    
-    def test_pos_change(self):
-        "Test with a changed positional argument."
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.CharField', ['hi'], {'to': "foo"}),
-                ('django.db.models.fields.CharField', [], {'to': "foo"}),
-            ),
-            True,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.CharField', [], {'to': "foo"}),
-                ('django.db.models.fields.CharField', ['bye'], {'to': "foo"}),
-            ),
-            True,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.CharField', ['pi'], {'to': "foo"}),
-                ('django.db.models.fields.CharField', ['pi'], {'to': "foo"}),
-            ),
-            False,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.CharField', ['pisdadad'], {'to': "foo"}),
-                ('django.db.models.fields.CharField', ['pi'], {'to': "foo"}),
-            ),
-            True,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.CharField', ['hi'], {}),
-                ('django.db.models.fields.CharField', [], {}),
-            ),
-            True,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.CharField', [], {}),
-                ('django.db.models.fields.CharField', ['bye'], {}),
-            ),
-            True,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.CharField', ['pi'], {}),
-                ('django.db.models.fields.CharField', ['pi'], {}),
-            ),
-            False,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.CharField', ['pi'], {}),
-                ('django.db.models.fields.CharField', ['45fdfdf'], {}),
-            ),
-            True,
-        )
-    
-    
-    def test_kwd_change(self):
-        "Test a changed keyword argument"
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.CharField', ['pi'], {'to': "foo"}),
-                ('django.db.models.fields.CharField', ['pi'], {'to': "blue"}),
-            ),
-            True,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.CharField', [], {'to': "foo"}),
-                ('django.db.models.fields.CharField', [], {'to': "blue"}),
-            ),
-            True,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.CharField', ['b'], {'to': "foo"}),
-                ('django.db.models.fields.CharField', ['b'], {'to': "blue"}),
-            ),
-            True,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.CharField', [], {'to': "foo"}),
-                ('django.db.models.fields.CharField', [], {}),
-            ),
-            True,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.CharField', ['a'], {'to': "foo"}),
-                ('django.db.models.fields.CharField', ['a'], {}),
-            ),
-            True,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.CharField', [], {}),
-                ('django.db.models.fields.CharField', [], {'to': "foo"}),
-            ),
-            True,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('django.db.models.fields.CharField', ['a'], {}),
-                ('django.db.models.fields.CharField', ['a'], {'to': "foo"}),
-            ),
-            True,
-        )
-        
-    
-    
-    def test_backcompat_nochange(self):
-        "Test that the backwards-compatable comparison is working"
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('models.CharField', [], {}),
-                ('django.db.models.fields.CharField', [], {}),
-            ),
-            False,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('models.CharField', ['ack'], {}),
-                ('django.db.models.fields.CharField', ['ack'], {}),
-            ),
-            False,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('models.CharField', [], {'to':'b'}),
-                ('django.db.models.fields.CharField', [], {'to':'b'}),
-            ),
-            False,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('models.CharField', ['hah'], {'to':'you'}),
-                ('django.db.models.fields.CharField', ['hah'], {'to':'you'}),
-            ),
-            False,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('models.CharField', ['hah'], {'to':'you'}),
-                ('django.db.models.fields.CharField', ['hah'], {'to':'heh'}),
-            ),
-            True,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('models.CharField', ['hah'], {}),
-                ('django.db.models.fields.CharField', [], {'to':"orm['appname.hah']"}),
-            ),
-            False,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('models.CharField', ['hah'], {}),
-                ('django.db.models.fields.CharField', [], {'to':'hah'}),
-            ),
-            True,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('models.CharField', ['hah'], {}),
-                ('django.db.models.fields.CharField', [], {'to':'rrr'}),
-            ),
-            True,
-        )
-        
-        self.assertEqual(
-            AutoChanges.different_attributes(
-                ('models.CharField', ['hah'], {}),
-                ('django.db.models.fields.IntField', [], {'to':'hah'}),
-            ),
-            True,
-        )
-
-class TestNonManagedIgnored(Monkeypatcher):
-    
-    installed_apps = ["non_managed"]
-
-    full_defs = {
-        'non_managed.legacy': {
-            'Meta': {'object_name': 'Legacy', 'db_table': "'legacy_table'", 'managed': 'False'},
-            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
-            'name': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True'}),
-            'size': ('django.db.models.fields.IntegerField', [], {})
-        }
-    } 
-
-    def test_not_added_init(self):
-        
-        migrations = Migrations("non_managed")
-        changes = InitialChanges(migrations)
-        change_list = changes.get_changes()
-        if list(change_list):
-            self.fail("Initial migration creates table for non-managed model")
-
-    def test_not_added_auto(self):
-
-        empty_defs = { }
-        class EmptyMigration(SchemaMigration):
-            "Serves as fake previous migration"
-        
-            def forwards(self, orm):
-                pass
-        
-            def backwards(self, orm):
-                pass
-        
-            models = empty_defs
-
-            complete_apps = ['non_managed']
-                    
-        migrations = Migrations("non_managed")
-        empty_orm = FakeORM(EmptyMigration, "non_managed")
-        changes = AutoChanges(
-            migrations = migrations,
-            old_defs = empty_defs,
-            old_orm = empty_orm,
-            new_defs = self.full_defs,
-        )
-        change_list = changes.get_changes()
-        if list(change_list):
-            self.fail("Auto migration creates table for non-managed model")
-
-    def test_not_deleted_auto(self):
-
-        empty_defs = { }
-        old_defs = freezer.freeze_apps(["non_managed"])
-        class InitialMigration(SchemaMigration):
-            "Serves as fake previous migration"
-        
-            def forwards(self, orm):
-                pass
-        
-            def backwards(self, orm):
-                pass
-        
-            models = self.full_defs
-
-            complete_apps = ['non_managed']
-                    
-        migrations = Migrations("non_managed")
-        initial_orm = FakeORM(InitialMigration, "non_managed")
-        changes = AutoChanges(
-            migrations = migrations,
-            old_defs = self.full_defs,
-            old_orm = initial_orm,
-            new_defs = empty_defs,
-        )
-        change_list = changes.get_changes()
-        if list(change_list):
-            self.fail("Auto migration deletes table for non-managed model")
-
-    def test_not_modified_auto(self):
-
-        fake_defs = {
-            'non_managed.legacy': {
-                'Meta': {'object_name': 'Legacy', 'db_table': "'legacy_table'", 'managed': 'False'},
-                'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
-                'name': ('django.db.models.fields.CharField', [], {'max_length': '10', 'null': 'True'}),
-                #'size': ('django.db.models.fields.IntegerField', [], {}) # The "change" is the addition of this field
-            }
-        } 
-        class InitialMigration(SchemaMigration):
-            "Serves as fake previous migration"
-        
-            def forwards(self, orm):
-                pass
-        
-            def backwards(self, orm):
-                pass
-        
-            models = fake_defs
-
-            complete_apps = ['non_managed']
-                    
-        from non_managed import models as dummy_import_to_force_loading_models # TODO: Does needing this indicate a bug in MokeyPatcher?
-        reload_module(dummy_import_to_force_loading_models) # really force... 
-        
-        migrations = Migrations("non_managed")
-        initial_orm = FakeORM(InitialMigration, "non_managed")
-        changes = AutoChanges(
-            migrations = migrations,
-            old_defs = fake_defs,
-            old_orm = initial_orm,
-            new_defs = self.full_defs
-        )
-        change_list = changes.get_changes()
-        if list(change_list):
-            self.fail("Auto migration changes table for non-managed model")
diff --git a/src/south/tests/brokenapp/__init__.py b/src/south/tests/brokenapp/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/brokenapp/migrations/0001_depends_on_unmigrated.py b/src/south/tests/brokenapp/migrations/0001_depends_on_unmigrated.py
deleted file mode 100644
index d53f8364f7..0000000000
--- a/src/south/tests/brokenapp/migrations/0001_depends_on_unmigrated.py
+++ /dev/null
@@ -1,13 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    depends_on = [('unknown', '0001_initial')]
-    
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/brokenapp/migrations/0002_depends_on_unknown.py b/src/south/tests/brokenapp/migrations/0002_depends_on_unknown.py
deleted file mode 100644
index 389af80664..0000000000
--- a/src/south/tests/brokenapp/migrations/0002_depends_on_unknown.py
+++ /dev/null
@@ -1,13 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    depends_on = [('fakeapp', '9999_unknown')]
-    
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/brokenapp/migrations/0003_depends_on_higher.py b/src/south/tests/brokenapp/migrations/0003_depends_on_higher.py
deleted file mode 100644
index 319069ba88..0000000000
--- a/src/south/tests/brokenapp/migrations/0003_depends_on_higher.py
+++ /dev/null
@@ -1,13 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    depends_on = [('brokenapp', '0004_higher')]
-    
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/brokenapp/migrations/0004_higher.py b/src/south/tests/brokenapp/migrations/0004_higher.py
deleted file mode 100644
index d27ed3a172..0000000000
--- a/src/south/tests/brokenapp/migrations/0004_higher.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/brokenapp/migrations/__init__.py b/src/south/tests/brokenapp/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/brokenapp/models.py b/src/south/tests/brokenapp/models.py
deleted file mode 100644
index a7d84dced4..0000000000
--- a/src/south/tests/brokenapp/models.py
+++ /dev/null
@@ -1,55 +0,0 @@
-# -*- coding: UTF-8 -*-
-
-from django.db import models
-from django.contrib.auth.models import User as UserAlias
-
-def default_func():
-    return "yays"
-
-# An empty case.
-class Other1(models.Model): pass
-
-# Nastiness.
-class HorribleModel(models.Model):
-    "A model to test the edge cases of model parsing"
-    
-    ZERO, ONE = range(2)
-    
-    # First, some nice fields
-    name = models.CharField(max_length=255)
-    short_name = models.CharField(max_length=50)
-    slug = models.SlugField(unique=True)
-    
-    # A ForeignKey, to a model above, and then below
-    o1 = models.ForeignKey(Other1)
-    o2 = models.ForeignKey('Other2')
-    
-    # Now to something outside
-    user = models.ForeignKey(UserAlias, related_name="horribles")
-    
-    # Unicode!
-    code = models.CharField(max_length=25, default="↑↑↓↓←→←→BA")
-    
-    # Odd defaults!
-    class_attr = models.IntegerField(default=ZERO)
-    func = models.CharField(max_length=25, default=default_func)
-    
-    # Time to get nasty. Define a non-field choices, and use it
-    choices = [('hello', '1'), ('world', '2')]
-    choiced = models.CharField(max_length=20, choices=choices)
-    
-    class Meta:
-        db_table = "my_fave"
-        verbose_name = "Dr. Strangelove," + \
-                     """or how I learned to stop worrying
-and love the bomb"""
-    
-    # Now spread over multiple lines
-    multiline = \
-              models.TextField(
-        )
-    
-# Special case.
-class Other2(models.Model):
-    # Try loading a field without a newline after it (inspect hates this)
-    close_but_no_cigar = models.PositiveIntegerField(primary_key=True)
\ No newline at end of file
diff --git a/src/south/tests/circular_a/__init__.py b/src/south/tests/circular_a/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/circular_a/migrations/0001_first.py b/src/south/tests/circular_a/migrations/0001_first.py
deleted file mode 100644
index b0d90ebcb0..0000000000
--- a/src/south/tests/circular_a/migrations/0001_first.py
+++ /dev/null
@@ -1,13 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-    
-    depends_on = [('circular_b', '0001_first')]
-    
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/circular_a/migrations/__init__.py b/src/south/tests/circular_a/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/circular_a/models.py b/src/south/tests/circular_a/models.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/circular_b/__init__.py b/src/south/tests/circular_b/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/circular_b/migrations/0001_first.py b/src/south/tests/circular_b/migrations/0001_first.py
deleted file mode 100644
index b11b120971..0000000000
--- a/src/south/tests/circular_b/migrations/0001_first.py
+++ /dev/null
@@ -1,13 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-    
-    depends_on = [('circular_a', '0001_first')]
-    
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/circular_b/migrations/__init__.py b/src/south/tests/circular_b/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/circular_b/models.py b/src/south/tests/circular_b/models.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/db.py b/src/south/tests/db.py
deleted file mode 100644
index e63c563a8e..0000000000
--- a/src/south/tests/db.py
+++ /dev/null
@@ -1,1060 +0,0 @@
-import datetime
-from warnings import filterwarnings
-
-from south.db import db, generic
-from django.db import connection, models, IntegrityError as DjangoIntegrityError
-
-from south.tests import unittest, skipIf, skipUnless
-from south.utils.py3 import text_type, with_metaclass
-
-# Create a list of error classes from the various database libraries
-errors = []
-try:
-    from psycopg2 import ProgrammingError
-    errors.append(ProgrammingError)
-except ImportError:
-    pass
-errors = tuple(errors)
-
-# On SQL Server, the backend's IntegrityError is not (a subclass of) Django's.
-try:
-    from sql_server.pyodbc.base import IntegrityError as SQLServerIntegrityError
-    IntegrityError = (DjangoIntegrityError, SQLServerIntegrityError)
-except ImportError:
-    IntegrityError = DjangoIntegrityError
-
-try:
-    from south.db import mysql
-except ImportError:
-    mysql = None
-
-
-class TestOperations(unittest.TestCase):
-
-    """
-    Tests if the various DB abstraction calls work.
-    Can only test a limited amount due to DB differences.
-    """
-
-    def setUp(self):
-        db.debug = False
-        try:
-            import MySQLdb
-        except ImportError:
-            pass
-        else:
-            filterwarnings('ignore', category=MySQLdb.Warning)
-        db.clear_deferred_sql()
-        db.start_transaction()
-    
-    def tearDown(self):
-        db.rollback_transaction()
-
-    def test_create(self):
-        """
-        Test creation of tables.
-        """
-        cursor = connection.cursor()
-        # It needs to take at least 2 args
-        self.assertRaises(TypeError, db.create_table)
-        self.assertRaises(TypeError, db.create_table, "test1")
-        # Empty tables (i.e. no columns) are not fine, so make at least 1
-        db.create_table("test1", [('email_confirmed', models.BooleanField(default=False))])
-        # And should exist
-        cursor.execute("SELECT * FROM test1")
-        # Make sure we can't do the same query on an empty table
-        try:
-            cursor.execute("SELECT * FROM nottheretest1")
-        except:
-            pass
-        else:
-            self.fail("Non-existent table could be selected!")
-    
-    @skipUnless(db.raises_default_errors, 'This database does not raise errors on missing defaults.')
-    def test_create_default(self):
-        """
-        Test creation of tables, make sure defaults are not left in the database
-        """
-        db.create_table("test_create_default", [('a', models.IntegerField()),
-                                                ('b', models.IntegerField(default=17))])
-        cursor = connection.cursor()
-        self.assertRaises(IntegrityError, cursor.execute, "INSERT INTO test_create_default(a) VALUES (17)")
-        
-    def test_delete(self):
-        """
-        Test deletion of tables.
-        """
-        cursor = connection.cursor()
-        db.create_table("test_deltable", [('email_confirmed', models.BooleanField(default=False))])
-        db.delete_table("test_deltable")
-        # Make sure it went
-        try:
-            cursor.execute("SELECT * FROM test_deltable")
-        except:
-            pass
-        else:
-            self.fail("Just-deleted table could be selected!")
-    
-    def test_nonexistent_delete(self):
-        """
-        Test deletion of nonexistent tables.
-        """
-        try:
-            db.delete_table("test_nonexistdeltable")
-        except:
-            pass
-        else:
-            self.fail("Non-existent table could be deleted!")
-    
-    def test_foreign_keys(self):
-        """
-        Tests foreign key creation, especially uppercase (see #61)
-        """
-        Test = db.mock_model(model_name='Test', db_table='test5a',
-                             db_tablespace='', pk_field_name='ID',
-                             pk_field_type=models.AutoField, pk_field_args=[])
-        db.create_table("test5a", [('ID', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True))])
-        db.create_table("test5b", [
-            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
-            ('UNIQUE', models.ForeignKey(Test)),
-        ])
-        db.execute_deferred_sql()
-        
-    @skipUnless(db.supports_foreign_keys, 'Foreign keys can only be deleted on '
-                                          'engines that support them.')
-    def test_recursive_foreign_key_delete(self):
-        """
-        Test that recursive foreign keys are deleted correctly (see #1065)
-        """
-        Test = db.mock_model(model_name='Test', db_table='test_rec_fk_del',
-                             db_tablespace='', pk_field_name='id',
-                             pk_field_type=models.AutoField, pk_field_args=[])
-        db.create_table('test_rec_fk_del', [
-            ('id', models.AutoField(primary_key=True, auto_created=True)),
-            ('fk', models.ForeignKey(Test)),
-        ])
-        db.execute_deferred_sql()
-        db.delete_foreign_key('test_rec_fk_del', 'fk_id')
-    
-    def test_rename(self):
-        """
-        Test column renaming
-        """
-        cursor = connection.cursor()
-        db.create_table("test_rn", [('spam', models.BooleanField(default=False))])
-        # Make sure we can select the column
-        cursor.execute("SELECT spam FROM test_rn")
-        # Rename it
-        db.rename_column("test_rn", "spam", "eggs")
-        cursor.execute("SELECT eggs FROM test_rn")
-        db.commit_transaction()
-        db.start_transaction()
-        try:
-            cursor.execute("SELECT spam FROM test_rn")
-        except:
-            pass
-        else:
-            self.fail("Just-renamed column could be selected!")
-        db.rollback_transaction()
-        db.delete_table("test_rn")
-        db.start_transaction()
-    
-    def test_dry_rename(self):
-        """
-        Test column renaming while --dry-run is turned on (should do nothing)
-        See ticket #65
-        """
-        cursor = connection.cursor()
-        db.create_table("test_drn", [('spam', models.BooleanField(default=False))])
-        # Make sure we can select the column
-        cursor.execute("SELECT spam FROM test_drn")
-        # Rename it
-        db.dry_run = True
-        db.rename_column("test_drn", "spam", "eggs")
-        db.dry_run = False
-        cursor.execute("SELECT spam FROM test_drn")
-        db.commit_transaction()
-        db.start_transaction()
-        try:
-            cursor.execute("SELECT eggs FROM test_drn")
-        except:
-            pass
-        else:
-            self.fail("Dry-renamed new column could be selected!")
-        db.rollback_transaction()
-        db.delete_table("test_drn")
-        db.start_transaction()
-    
-    def test_table_rename(self):
-        """
-        Test column renaming
-        """
-        cursor = connection.cursor()
-        db.create_table("testtr", [('spam', models.BooleanField(default=False))])
-        # Make sure we can select the column
-        cursor.execute("SELECT spam FROM testtr")
-        # Rename it
-        db.rename_table("testtr", "testtr2")
-        cursor.execute("SELECT spam FROM testtr2")
-        db.commit_transaction()
-        db.start_transaction()
-        try:
-            cursor.execute("SELECT spam FROM testtr")
-        except:
-            pass
-        else:
-            self.fail("Just-renamed column could be selected!")
-        db.rollback_transaction()
-        db.delete_table("testtr2")
-        db.start_transaction()
-    
-    def test_percents_in_defaults(self):
-        """
-        Test that % in a default gets escaped to %%.
-        """
-        try:
-            db.create_table("testpind", [('cf', models.CharField(max_length=255, default="It should be 2%!"))])
-        except IndexError:
-            self.fail("% was not properly escaped in column SQL.")
-        db.delete_table("testpind")
-    
-    def test_index(self):
-        """
-        Test the index operations
-        """
-        db.create_table("test3", [
-            ('SELECT', models.BooleanField(default=False)),
-            ('eggs', models.IntegerField(unique=True)),
-        ])
-        db.execute_deferred_sql()
-        # Add an index on that column
-        db.create_index("test3", ["SELECT"])
-        # Add another index on two columns
-        db.create_index("test3", ["SELECT", "eggs"])
-        # Delete them both
-        db.delete_index("test3", ["SELECT"])
-        db.delete_index("test3", ["SELECT", "eggs"])
-        # Delete the unique index/constraint
-        if db.backend_name != "sqlite3":
-            db.delete_unique("test3", ["eggs"])
-        db.delete_table("test3")
-    
-    def test_primary_key(self):
-        """
-        Test the primary key operations
-        """
-        
-        db.create_table("test_pk", [
-            ('id', models.IntegerField(primary_key=True)),
-            ('new_pkey', models.IntegerField()),
-            ('eggs', models.IntegerField(unique=True)),
-        ])
-        db.execute_deferred_sql()
-        # Remove the default primary key, and make eggs it
-        db.delete_primary_key("test_pk")
-        db.create_primary_key("test_pk", "new_pkey")
-        # Try inserting a now-valid row pair
-        db.execute("INSERT INTO test_pk (id, new_pkey, eggs) VALUES (1, 2, 3)")
-        db.execute("INSERT INTO test_pk (id, new_pkey, eggs) VALUES (1, 3, 4)")
-        db.delete_table("test_pk")
-    
-    def test_primary_key_implicit(self):
-        """
-        Tests that changing primary key implicitly fails.
-        """
-        db.create_table("test_pki", [
-            ('id', models.IntegerField(primary_key=True)),
-            ('new_pkey', models.IntegerField()),
-            ('eggs', models.IntegerField(unique=True)),
-        ])
-        db.execute_deferred_sql()
-        # Fiddle with alter_column to attempt to make it remove the primary key
-        db.alter_column("test_pki", "id", models.IntegerField())
-        db.alter_column("test_pki", "new_pkey", models.IntegerField(primary_key=True))
-        # Try inserting a should-be-valid row pair
-        db.execute("INSERT INTO test_pki (id, new_pkey, eggs) VALUES (1, 2, 3)")
-        db.execute("INSERT INTO test_pki (id, new_pkey, eggs) VALUES (2, 2, 4)")
-        db.delete_table("test_pki")
-    
-    def test_add_columns(self):
-        """
-        Test adding columns
-        """
-        db.create_table("test_addc", [
-            ('spam', models.BooleanField(default=False)),
-            ('eggs', models.IntegerField()),
-        ])
-        # Add a column
-        db.add_column("test_addc", "add1", models.IntegerField(default=3))
-        User = db.mock_model(model_name='User', db_table='auth_user', db_tablespace='', pk_field_name='id', pk_field_type=models.AutoField, pk_field_args=[], pk_field_kwargs={})
-        # insert some data so we can test the default value of the added fkey
-        db.execute("INSERT INTO test_addc (spam, eggs, add1) VALUES (%s, 1, 2)", [False])
-        db.add_column("test_addc", "user", models.ForeignKey(User, null=True))
-        db.execute_deferred_sql()
-        # try selecting from the user_id column to make sure it was actually created
-        val = db.execute("SELECT user_id FROM test_addc")[0][0]
-        self.assertEquals(val, None)
-        db.delete_column("test_addc", "add1")
-        # make sure adding an indexed field works
-        db.add_column("test_addc", "add2", models.CharField(max_length=15, db_index=True, default='pi'))
-        db.execute_deferred_sql()
-        db.delete_table("test_addc")
-
-    def test_delete_columns(self):
-        """
-        Test deleting columns
-        """
-        db.create_table("test_delc", [
-            ('spam', models.BooleanField(default=False)),
-            ('eggs', models.IntegerField(db_index=True, unique=True)),
-        ])
-        db.delete_column("test_delc", "eggs")
-
-    def test_add_nullbool_column(self):
-        """
-        Test adding NullBoolean columns
-        """
-        db.create_table("test_addnbc", [
-            ('spam', models.BooleanField(default=False)),
-            ('eggs', models.IntegerField()),
-        ])
-        # Add a column
-        db.add_column("test_addnbc", "add1", models.NullBooleanField())
-        # Add a column with a default
-        db.add_column("test_addnbc", "add2", models.NullBooleanField(default=True))
-        # insert some data so we can test the default values of the added column
-        db.execute("INSERT INTO test_addnbc (spam, eggs) VALUES (%s, 1)", [False])
-        # try selecting from the new columns to make sure they were properly created
-        false, null1, null2 = db.execute("SELECT spam,add1,add2 FROM test_addnbc")[0][0:3]
-        self.assertIsNone(null1, "Null boolean field with no value inserted returns non-null")
-        self.assertIsNone(null2, "Null boolean field (added with default) with no value inserted returns non-null")
-        self.assertEquals(false, False)
-        db.delete_table("test_addnbc")
-    
-    def test_alter_columns(self):
-        """
-        Test altering columns
-        """
-        db.create_table("test_alterc", [
-            ('spam', models.BooleanField(default=False)),
-            ('eggs', models.IntegerField()),
-        ])
-        db.execute_deferred_sql()
-        # Change eggs to be a FloatField
-        db.alter_column("test_alterc", "eggs", models.FloatField())
-        db.execute_deferred_sql()
-        db.delete_table("test_alterc")
-        db.execute_deferred_sql()
-    
-    def test_alter_char_default(self):
-        """
-        Test altering column defaults with char fields
-        """
-        db.create_table("test_altercd", [
-            ('spam', models.CharField(max_length=30)),
-            ('eggs', models.IntegerField()),
-        ])
-        # Change spam default
-        db.alter_column("test_altercd", "spam", models.CharField(max_length=30, default="loof", null=True))
-        # Assert the default is not in the database
-        db.execute("INSERT INTO test_altercd (eggs) values (12)")
-        null = db.execute("SELECT spam FROM test_altercd")[0][0]
-        self.assertFalse(null, "Default for char field was installed into database")
-
-        # Change again to a column with default and not null
-        db.alter_column("test_altercd", "spam", models.CharField(max_length=30, default="loof", null=False))
-        # Assert the default is not in the database
-        if 'oracle' in db.backend_name:
-            # Oracle special treatment -- nulls are always allowed in char columns, so 
-            # inserting doesn't raise an integrity error; so we check again as above
-            db.execute("DELETE FROM test_altercd")
-            db.execute("INSERT INTO test_altercd (eggs) values (12)")
-            null = db.execute("SELECT spam FROM test_altercd")[0][0]
-            self.assertFalse(null, "Default for char field was installed into database")
-        else:
-            # For other backends, insert should now just fail
-            self.assertRaises(IntegrityError,
-                              db.execute, "INSERT INTO test_altercd (eggs) values (12)")
-
-    @skipIf('oracle' in db.backend_name, "Oracle does not differentiate empty trings from null")
-    def test_default_empty_string(self):
-        """
-        Test altering column defaults with char fields
-        """
-        db.create_table("test_cd_empty", [
-            ('spam', models.CharField(max_length=30, default='')),
-            ('eggs', models.CharField(max_length=30)),
-        ])
-        # Create a record
-        db.execute("INSERT INTO test_cd_empty (spam, eggs) values ('1','2')")
-        # Add a column
-        db.add_column("test_cd_empty", "ham", models.CharField(max_length=30, default=''))
-        
-        empty = db.execute("SELECT ham FROM test_cd_empty")[0][0]
-        self.assertEquals(empty, "", "Empty Default for char field isn't empty string")
-        
-    @skipUnless('oracle' in db.backend_name, "Oracle does not differentiate empty trings from null")
-    def test_oracle_strings_null(self):
-        """
-        Test that under Oracle, CherFields are created as null even when specified not-null,
-        because otherwise they would not be able to hold empty strings (which Oracle equates
-        with nulls).
-        Verify fix of #1269.
-        """
-        db.create_table("test_ora_char_nulls", [
-            ('spam', models.CharField(max_length=30, null=True)),
-            ('eggs', models.CharField(max_length=30)),
-        ])
-        db.add_column("test_ora_char_nulls", "ham", models.CharField(max_length=30))
-        db.alter_column("test_ora_char_nulls", "spam", models.CharField(max_length=30, null=False))
-        # So, by the look of it, we should now have three not-null columns
-        db.execute("INSERT INTO test_ora_char_nulls VALUES (NULL, NULL, NULL)")
-        
-
-    def test_mysql_defaults(self):
-        """
-        Test MySQL default handling for BLOB and TEXT.
-        """
-        db.create_table("test_altermyd", [
-            ('spam', models.BooleanField(default=False)),
-            ('eggs', models.TextField()),
-        ])
-        # Change eggs to be a FloatField
-        db.alter_column("test_altermyd", "eggs", models.TextField(null=True))
-        db.delete_table("test_altermyd")
-    
-    def test_alter_column_postgres_multiword(self):
-        """
-        Tests altering columns with multiple words in Postgres types (issue #125)
-        e.g. 'datetime with time zone', look at django/db/backends/postgresql/creation.py
-        """
-        db.create_table("test_multiword", [
-            ('col_datetime', models.DateTimeField(null=True)),
-            ('col_integer', models.PositiveIntegerField(null=True)),
-            ('col_smallint', models.PositiveSmallIntegerField(null=True)),
-            ('col_float', models.FloatField(null=True)),
-        ])
-        
-        # test if 'double precision' is preserved
-        db.alter_column('test_multiword', 'col_float', models.FloatField('float', null=True))
-
-        # test if 'CHECK ("%(column)s" >= 0)' is stripped
-        db.alter_column('test_multiword', 'col_integer', models.PositiveIntegerField(null=True))
-        db.alter_column('test_multiword', 'col_smallint', models.PositiveSmallIntegerField(null=True))
-
-        # test if 'with timezone' is preserved
-        if db.backend_name == "postgres":
-            db.execute("INSERT INTO test_multiword (col_datetime) VALUES ('2009-04-24 14:20:55+02')")
-            db.alter_column('test_multiword', 'col_datetime', models.DateTimeField(auto_now=True))
-            assert db.execute("SELECT col_datetime = '2009-04-24 14:20:55+02' FROM test_multiword")[0][0]
-
-        db.delete_table("test_multiword")
-    
-    @skipUnless(db.has_check_constraints, 'Only applies to databases that '
-                                          'support CHECK constraints.')
-    def test_alter_constraints(self):
-        """
-        Tests that going from a PostiveIntegerField to an IntegerField drops
-        the constraint on the database.
-        """
-        # Make the test table
-        db.create_table("test_alterc", [
-            ('num', models.PositiveIntegerField()),
-        ])
-        db.execute_deferred_sql()
-        # Add in some test values
-        db.execute("INSERT INTO test_alterc (num) VALUES (1)")
-        db.execute("INSERT INTO test_alterc (num) VALUES (2)")
-        # Ensure that adding a negative number is bad
-        db.commit_transaction()
-        db.start_transaction()
-        try:
-            db.execute("INSERT INTO test_alterc (num) VALUES (-3)")
-        except:
-            db.rollback_transaction()
-        else:
-            self.fail("Could insert a negative integer into a PositiveIntegerField.")
-        # Alter it to a normal IntegerField
-        db.alter_column("test_alterc", "num", models.IntegerField())
-        db.execute_deferred_sql()
-        # It should now work
-        db.execute("INSERT INTO test_alterc (num) VALUES (-3)")
-        db.delete_table("test_alterc")
-        # We need to match up for tearDown
-        db.start_transaction()
-    
-    @skipIf(db.backend_name == "sqlite3", "SQLite backend doesn't support this "
-                                          "yet.")
-    def test_unique(self):
-        """
-        Tests creating/deleting unique constraints.
-        """
-        db.create_table("test_unique2", [
-            ('id', models.AutoField(primary_key=True)),
-        ])
-        db.create_table("test_unique", [
-            ('spam', models.BooleanField(default=False)),
-            ('eggs', models.IntegerField()),
-            ('ham', models.ForeignKey(db.mock_model('Unique2', 'test_unique2'))),
-        ])
-        db.execute_deferred_sql()
-        # Add a constraint
-        db.create_unique("test_unique", ["spam"])
-        db.execute_deferred_sql()
-        # Shouldn't do anything during dry-run
-        db.dry_run = True
-        db.delete_unique("test_unique", ["spam"])
-        db.dry_run = False
-        db.delete_unique("test_unique", ["spam"])
-        db.create_unique("test_unique", ["spam"])
-        # Special preparations for Sql Server
-        if db.backend_name == "pyodbc":
-            db.execute("SET IDENTITY_INSERT test_unique2 ON;")
-        db.execute("INSERT INTO test_unique2 (id) VALUES (1)")
-        db.execute("INSERT INTO test_unique2 (id) VALUES (2)")
-        db.commit_transaction()
-        db.start_transaction()
-
-        
-        # Test it works
-        TRUE = (True,)
-        FALSE = (False,)
-        db.execute("INSERT INTO test_unique (spam, eggs, ham_id) VALUES (%s, 0, 1)", TRUE)
-        db.execute("INSERT INTO test_unique (spam, eggs, ham_id) VALUES (%s, 1, 2)", FALSE)
-        try:
-            db.execute("INSERT INTO test_unique (spam, eggs, ham_id) VALUES (%s, 2, 1)", FALSE)
-        except:
-            db.rollback_transaction()
-        else:
-            self.fail("Could insert non-unique item.")
-        
-        # Drop that, add one only on eggs
-        db.delete_unique("test_unique", ["spam"])
-        db.execute("DELETE FROM test_unique")
-        db.create_unique("test_unique", ["eggs"])
-        db.start_transaction()
-        
-        # Test similarly
-        db.execute("INSERT INTO test_unique (spam, eggs, ham_id) VALUES (%s, 0, 1)", TRUE)
-        db.execute("INSERT INTO test_unique (spam, eggs, ham_id) VALUES (%s, 1, 2)", FALSE)
-        try:
-            db.execute("INSERT INTO test_unique (spam, eggs, ham_id) VALUES (%s, 1, 1)", TRUE)
-        except:
-            db.rollback_transaction()
-        else:
-            self.fail("Could insert non-unique item.")
-        
-        # Drop those, test combined constraints
-        db.delete_unique("test_unique", ["eggs"])
-        db.execute("DELETE FROM test_unique")
-        db.create_unique("test_unique", ["spam", "eggs", "ham_id"])
-        db.start_transaction()
-        # Test similarly
-        db.execute("INSERT INTO test_unique (spam, eggs, ham_id) VALUES (%s, 0, 1)", TRUE)
-        db.execute("INSERT INTO test_unique (spam, eggs, ham_id) VALUES (%s, 1, 1)", FALSE)
-        try:
-            db.execute("INSERT INTO test_unique (spam, eggs, ham_id) VALUES (%s, 0, 1)", TRUE)
-        except:
-            db.rollback_transaction()
-        else:
-            self.fail("Could insert non-unique pair.")
-        db.delete_unique("test_unique", ["spam", "eggs", "ham_id"])
-        db.start_transaction()
-    
-    def test_alter_unique(self):
-        """
-        Tests that unique constraints are not affected when
-        altering columns (that's handled by create_/delete_unique)
-        """
-        db.create_table("test_alter_unique", [
-            ('spam', models.IntegerField()),
-            ('eggs', models.IntegerField(unique=True)),
-        ])
-        db.execute_deferred_sql()
-        
-        # Make sure the unique constraint is created
-        db.execute('INSERT INTO test_alter_unique (spam, eggs) VALUES (0, 42)')
-        db.commit_transaction()
-        db.start_transaction()
-        try:
-            db.execute("INSERT INTO test_alter_unique (spam, eggs) VALUES (1, 42)")
-        except:
-            pass
-        else:
-            self.fail("Could insert the same integer twice into a unique field.")
-        db.rollback_transaction()
-
-        # Alter without unique=True (should not affect anything)
-        db.alter_column("test_alter_unique", "eggs", models.IntegerField())
-
-        # Insertion should still fail
-        db.start_transaction()
-        try:
-            db.execute("INSERT INTO test_alter_unique (spam, eggs) VALUES (1, 42)")
-        except:
-            pass
-        else:
-            self.fail("Could insert the same integer twice into a unique field after alter_column with unique=False.")
-        db.rollback_transaction()
-        
-        # Delete the unique index/constraint
-        if db.backend_name != "sqlite3":
-            db.delete_unique("test_alter_unique", ["eggs"])
-        db.delete_table("test_alter_unique")
-        db.start_transaction()
-
-        # Test multi-field constraint
-        db.create_table("test_alter_unique2", [
-            ('spam', models.IntegerField()),
-            ('eggs', models.IntegerField()),
-        ])
-        db.create_unique('test_alter_unique2', ('spam', 'eggs'))
-        db.execute_deferred_sql()
-        db.execute('INSERT INTO test_alter_unique2 (spam, eggs) VALUES (0, 42)')
-        db.commit_transaction()
-        # Verify that constraint works
-        db.start_transaction()
-        try:
-            db.execute("INSERT INTO test_alter_unique2 (spam, eggs) VALUES (1, 42)")
-        except:
-            self.fail("Looks like multi-field unique constraint applied to only one field.")
-        db.rollback_transaction()
-        db.start_transaction()
-        try:
-            db.execute("INSERT INTO test_alter_unique2 (spam, eggs) VALUES (0, 43)")
-        except:
-            self.fail("Looks like multi-field unique constraint applied to only one field.")
-        db.rollback_transaction()
-        db.start_transaction()
-        try:
-            db.execute("INSERT INTO test_alter_unique2 (spam, eggs) VALUES (0, 42)")
-        except:
-            pass
-        else:
-            self.fail("Could insert the same pair twice into unique-together fields.")
-        db.rollback_transaction()
-        # Altering one column should not drop or modify multi-column constraint
-        db.alter_column("test_alter_unique2", "eggs", models.PositiveIntegerField())
-        db.start_transaction()
-        try:
-            db.execute("INSERT INTO test_alter_unique2 (spam, eggs) VALUES (1, 42)")
-        except:
-            self.fail("Altering one column broken multi-column unique constraint.")
-        db.rollback_transaction()
-        db.start_transaction()
-        try:
-            db.execute("INSERT INTO test_alter_unique2 (spam, eggs) VALUES (0, 43)")
-        except:
-            self.fail("Altering one column broken multi-column unique constraint.")
-        db.rollback_transaction()
-        db.start_transaction()
-        try:
-            db.execute("INSERT INTO test_alter_unique2 (spam, eggs) VALUES (0, 42)")
-        except:
-            pass
-        else:
-            self.fail("Could insert the same pair twice into unique-together fields after alter_column with unique=False.")
-        db.rollback_transaction()
-        db.delete_table("test_alter_unique2")
-        db.start_transaction()
-
-    def test_capitalised_constraints(self):
-        """
-        Under PostgreSQL at least, capitalised constraints must be quoted.
-        """
-        db.create_table("test_capconst", [
-            ('SOMECOL', models.PositiveIntegerField(primary_key=True)),
-        ])
-        # Alter it so it's not got the check constraint
-        db.alter_column("test_capconst", "SOMECOL", models.IntegerField())
-    
-    def test_text_default(self):
-        """
-        MySQL cannot have blank defaults on TEXT columns.
-        """
-        db.create_table("test_textdef", [
-            ('textcol', models.TextField(blank=True)),
-        ])
-
-    def test_text_to_char(self):
-        """
-        On Oracle, you can't simply ALTER TABLE MODIFY a textfield to a charfield
-        """
-        value = "kawabanga"
-        db.create_table("test_text_to_char", [
-            ('textcol', models.TextField()),
-        ])
-        db.execute_deferred_sql()
-        db.execute("INSERT INTO test_text_to_char VALUES (%s)", [value])
-        db.alter_column("test_text_to_char", "textcol", models.CharField(max_length=100))
-        db.execute_deferred_sql()
-        after = db.execute("select * from test_text_to_char")[0][0]
-        self.assertEqual(value, after, "Change from text to char altered value [ %r != %r ]" % (value, after))
-
-    def test_char_to_text(self):
-        """
-        On Oracle, you can't simply ALTER TABLE MODIFY a charfield to a textfield either
-        """
-        value = "agnabawak"
-        db.create_table("test_char_to_text", [
-            ('textcol', models.CharField(max_length=100)),
-        ])
-        db.execute_deferred_sql()
-        db.execute("INSERT INTO test_char_to_text VALUES (%s)", [value])
-        db.alter_column("test_char_to_text", "textcol", models.TextField())
-        db.execute_deferred_sql()
-        after = db.execute("select * from test_char_to_text")[0][0]
-        after = text_type(after) # Oracle text fields return a sort of lazy string -- force evaluation
-        self.assertEqual(value, after, "Change from char to text altered value [ %r != %r ]" % (value, after))
-
-    @skipUnless(db.raises_default_errors, 'This database does not raise errors on missing defaults.')
-    def test_datetime_default(self):
-        """
-        Test that defaults are correctly not created for datetime columns
-        """
-        end_of_world = datetime.datetime(2012, 12, 21, 0, 0, 1)
-
-        try:
-            from django.utils import timezone
-        except ImportError:
-            pass
-        else:
-            from django.conf import settings
-            if getattr(settings, 'USE_TZ', False):
-                end_of_world = end_of_world.replace(tzinfo=timezone.utc)
-
-        db.create_table("test_datetime_def", [
-            ('col0', models.IntegerField(null=True)),
-            ('col1', models.DateTimeField(default=end_of_world)),
-            ('col2', models.DateTimeField(null=True)),
-        ])
-        db.execute_deferred_sql()
-        # insert a row
-        db.execute("INSERT INTO test_datetime_def (col0, col1, col2) values (null,%s,null)", [end_of_world])
-        db.alter_column("test_datetime_def", "col2", models.DateTimeField(default=end_of_world))
-        db.add_column("test_datetime_def", "col3", models.DateTimeField(default=end_of_world))
-        db.execute_deferred_sql()
-        db.commit_transaction()
-        # In the single existing row, we now expect col1=col2=col3=end_of_world...
-        db.start_transaction()
-        ends = db.execute("select col1,col2,col3 from test_datetime_def")[0]
-        self.failUnlessEqual(len(ends), 3)
-        for e in ends:
-            self.failUnlessEqual(e, end_of_world)
-        db.commit_transaction()
-        # ...but there should not be a default in the database for col1 or col3
-        for cols in ["col1,col2", "col2,col3"]:
-            db.start_transaction()
-            statement = "insert into test_datetime_def (col0,%s) values (null,%%s,%%s)" % cols
-            self.assertRaises(
-                IntegrityError,
-                db.execute, statement, [end_of_world, end_of_world]
-            )
-            db.rollback_transaction()
-        
-        db.start_transaction() # To preserve the sanity and semantics of this test class
-        
-    def test_add_unique_fk(self):
-        """
-        Test adding a ForeignKey with unique=True or a OneToOneField
-        """
-        db.create_table("test_add_unique_fk", [
-            ('spam', models.BooleanField(default=False))
-        ])
-        
-        db.add_column("test_add_unique_fk", "mock1", models.ForeignKey(db.mock_model('User', 'auth_user'), null=True, unique=True))
-        db.add_column("test_add_unique_fk", "mock2", models.OneToOneField(db.mock_model('User', 'auth_user'), null=True))
-        db.execute_deferred_sql()
-        
-        db.delete_table("test_add_unique_fk")
-        
-    @skipUnless(db.has_check_constraints, 'Only applies to databases that '
-                                          'support CHECK constraints.')
-    def test_column_constraint(self):
-        """
-        Tests that the value constraint of PositiveIntegerField is enforced on
-        the database level.
-        """
-        db.create_table("test_column_constraint", [
-            ('spam', models.PositiveIntegerField()),
-        ])
-        db.execute_deferred_sql()
-        
-        # Make sure we can't insert negative values
-        db.commit_transaction()
-        db.start_transaction()
-        try:
-            db.execute("INSERT INTO test_column_constraint VALUES (-42)")
-        except:
-            pass
-        else:
-            self.fail("Could insert a negative value into a PositiveIntegerField.")
-        db.rollback_transaction()
-        
-        # remove constraint
-        db.alter_column("test_column_constraint", "spam", models.IntegerField())
-        db.execute_deferred_sql()
-        # make sure the insertion works now
-        db.execute('INSERT INTO test_column_constraint VALUES (-42)')
-        db.execute('DELETE FROM test_column_constraint')
-        
-        # add it back again
-        db.alter_column("test_column_constraint", "spam", models.PositiveIntegerField())
-        db.execute_deferred_sql()
-        # it should fail again
-        db.start_transaction()
-        try:
-            db.execute("INSERT INTO test_column_constraint VALUES (-42)")
-        except:
-            pass
-        else:
-            self.fail("Could insert a negative value after changing an IntegerField to a PositiveIntegerField.")
-        db.rollback_transaction()
-        
-        db.delete_table("test_column_constraint")
-        db.start_transaction()
-
-    def test_sql_defaults(self):
-        """
-        Test that sql default value is correct for non-string field types.
-        Datetimes are handled in test_datetime_default.
-        """
-
-        class CustomField(with_metaclass(models.SubfieldBase, models.CharField)):
-            description = 'CustomField'
-            def get_default(self):
-                if self.has_default():
-                    if callable(self.default):
-                        return self.default()
-                    return self.default
-                return super(CustomField, self).get_default()
-            def get_prep_value(self, value):
-                if not value:
-                    return value
-                return ','.join(map(str, value))
-            def to_python(self, value):
-                if not value or isinstance(value, list):
-                    return value
-                return list(map(int, value.split(',')))
-
-        false_value = db.has_booleans and 'False' or '0'
-        defaults = (
-            (models.CharField(default='sukasuka'), 'DEFAULT \'sukasuka'),
-            (models.BooleanField(default=False), 'DEFAULT %s' % false_value),
-            (models.IntegerField(default=42), 'DEFAULT 42'),
-            (CustomField(default=[2012, 2018, 2021, 2036]), 'DEFAULT \'2012,2018,2021,2036')
-        )
-        for field, sql_test_str in defaults:
-            sql = db.column_sql('fish', 'YAAAAAAZ', field)
-            if sql_test_str not in sql:
-                self.fail("default sql value was not properly generated for field %r.\nSql was %s" % (field, sql))
-
-    def test_make_added_foreign_key_not_null(self):
-        # Table for FK to target
-        User = db.mock_model(model_name='User', db_table='auth_user', db_tablespace='', pk_field_name='id', pk_field_type=models.AutoField, pk_field_args=[], pk_field_kwargs={})
-        # Table with no foreign key
-        db.create_table("test_fk", [
-            ('eggs', models.IntegerField()),
-        ])
-        db.execute_deferred_sql()
-        
-        # Add foreign key
-        db.add_column("test_fk", 'foreik', models.ForeignKey(User, null=True))
-        db.execute_deferred_sql()
-        
-        # Make the FK not null
-        db.alter_column("test_fk", "foreik_id", models.ForeignKey(User))
-        db.execute_deferred_sql()
-
-    def test_make_foreign_key_null(self):
-        # Table for FK to target
-        User = db.mock_model(model_name='User', db_table='auth_user', db_tablespace='', pk_field_name='id', pk_field_type=models.AutoField, pk_field_args=[], pk_field_kwargs={})
-        # Table with no foreign key
-        db.create_table("test_make_fk_null", [
-            ('eggs', models.IntegerField()),
-            ('foreik', models.ForeignKey(User))
-        ])
-        db.execute_deferred_sql()
-        
-        # Make the FK null
-        db.alter_column("test_make_fk_null", "foreik_id", models.ForeignKey(User, null=True))
-        db.execute_deferred_sql()
-
-    def test_change_foreign_key_target(self):
-        # Tables for FK to target
-        User = db.mock_model(model_name='User', db_table='auth_user', db_tablespace='', pk_field_name='id', pk_field_type=models.AutoField, pk_field_args=[], pk_field_kwargs={})
-        db.create_table("test_fk_changed_target", [
-            ('eggs', models.IntegerField(primary_key=True)),
-        ])
-        Egg = db.mock_model(model_name='Egg', db_table='test_fk_changed_target', db_tablespace='', pk_field_name='eggs', pk_field_type=models.AutoField, pk_field_args=[], pk_field_kwargs={})
-        # Table with a foreign key to the wrong table
-        db.create_table("test_fk_changing", [
-            ('egg', models.ForeignKey(User, null=True)),
-        ])
-        db.execute_deferred_sql()
-
-        # Change foreign key pointing
-        db.alter_column("test_fk_changing", "egg_id", models.ForeignKey(Egg, null=True))
-        db.execute_deferred_sql()
-
-        # Test that it is pointing at the right table now
-        try:
-            non_user_id = db.execute("SELECT MAX(id) FROM auth_user")[0][0] + 1
-        except (TypeError, IndexError):
-            # Got a "None" or no records, treat as 0
-            non_user_id = 17
-        db.execute("INSERT INTO test_fk_changed_target (eggs) VALUES (%s)", [non_user_id])
-        db.execute("INSERT INTO test_fk_changing (egg_id) VALUES (%s)", [non_user_id])
-        db.commit_transaction()
-        db.start_transaction()  # The test framework expects tests to end in transaction
-
-    def test_alter_double_indexed_column(self):
-        # Table for FK to target
-        User = db.mock_model(model_name='User', db_table='auth_user', db_tablespace='', pk_field_name='id', pk_field_type=models.AutoField, pk_field_args=[], pk_field_kwargs={})
-        # Table with no foreign key
-        db.create_table("test_2indexed", [
-            ('eggs', models.IntegerField()),
-            ('foreik', models.ForeignKey(User))
-        ])
-        db.create_unique("test_2indexed", ["eggs", "foreik_id"])
-        db.execute_deferred_sql()
-        
-        # Make the FK null
-        db.alter_column("test_2indexed", "foreik_id", models.ForeignKey(User, null=True))
-        db.execute_deferred_sql()
-
-class TestCacheGeneric(unittest.TestCase):
-    base_ops_cls = generic.DatabaseOperations
-    def setUp(self):
-        class CacheOps(self.base_ops_cls):
-            def __init__(self):
-                self._constraint_cache = {}
-                self.cache_filled = 0
-                self.settings = {'NAME': 'db'}
-
-            def _fill_constraint_cache(self, db, table):
-                self.cache_filled += 1
-                self._constraint_cache.setdefault(db, {})
-                self._constraint_cache[db].setdefault(table, {})
-
-            @generic.invalidate_table_constraints
-            def clear_con(self, table):
-                pass
-
-            @generic.copy_column_constraints
-            def cp_column(self, table, column_old, column_new):
-                pass
-
-            @generic.delete_column_constraints
-            def rm_column(self, table, column):
-                pass
-
-            @generic.copy_column_constraints
-            @generic.delete_column_constraints
-            def mv_column(self, table, column_old, column_new):
-                pass
-
-            def _get_setting(self, attr):
-                return self.settings[attr]
-        self.CacheOps = CacheOps
-
-    def test_cache(self):
-        ops = self.CacheOps()
-        self.assertEqual(0, ops.cache_filled)
-        self.assertFalse(ops.lookup_constraint('db', 'table'))
-        self.assertEqual(1, ops.cache_filled)
-        self.assertFalse(ops.lookup_constraint('db', 'table'))
-        self.assertEqual(1, ops.cache_filled)
-        ops.clear_con('table')
-        self.assertEqual(1, ops.cache_filled)
-        self.assertFalse(ops.lookup_constraint('db', 'table'))
-        self.assertEqual(2, ops.cache_filled)
-        self.assertFalse(ops.lookup_constraint('db', 'table', 'column'))
-        self.assertEqual(2, ops.cache_filled)
-
-        cache = ops._constraint_cache
-        cache['db']['table']['column'] = 'constraint'
-        self.assertEqual('constraint', ops.lookup_constraint('db', 'table', 'column'))
-        self.assertEqual([('column', 'constraint')], ops.lookup_constraint('db', 'table'))
-        self.assertEqual(2, ops.cache_filled)
-
-        # invalidate_table_constraints
-        ops.clear_con('new_table')
-        self.assertEqual('constraint', ops.lookup_constraint('db', 'table', 'column'))
-        self.assertEqual(2, ops.cache_filled)
-
-        self.assertFalse(ops.lookup_constraint('db', 'new_table'))
-        self.assertEqual(3, ops.cache_filled)
-
-        # delete_column_constraints
-        cache['db']['table']['column'] = 'constraint'
-        self.assertEqual('constraint', ops.lookup_constraint('db', 'table', 'column'))
-        ops.rm_column('table', 'column')
-        self.assertEqual([], ops.lookup_constraint('db', 'table', 'column'))
-        self.assertEqual([], ops.lookup_constraint('db', 'table', 'noexist_column'))
-
-        # copy_column_constraints
-        cache['db']['table']['column'] = 'constraint'
-        self.assertEqual('constraint', ops.lookup_constraint('db', 'table', 'column'))
-        ops.cp_column('table', 'column', 'column_new')
-        self.assertEqual('constraint', ops.lookup_constraint('db', 'table', 'column_new'))
-        self.assertEqual('constraint', ops.lookup_constraint('db', 'table', 'column'))
-
-        # copy + delete
-        cache['db']['table']['column'] = 'constraint'
-        self.assertEqual('constraint', ops.lookup_constraint('db', 'table', 'column'))
-        ops.mv_column('table', 'column', 'column_new')
-        self.assertEqual('constraint', ops.lookup_constraint('db', 'table', 'column_new'))
-        self.assertEqual([], ops.lookup_constraint('db', 'table', 'column'))
-
-    def test_valid(self):
-        ops = self.CacheOps()
-        # none of these should vivify a table into a valid state
-        self.assertFalse(ops._is_valid_cache('db', 'table'))
-        self.assertFalse(ops._is_valid_cache('db', 'table'))
-        ops.clear_con('table')
-        self.assertFalse(ops._is_valid_cache('db', 'table'))
-        ops.rm_column('table', 'column')
-        self.assertFalse(ops._is_valid_cache('db', 'table'))
-
-        # these should change the cache state
-        ops.lookup_constraint('db', 'table')
-        self.assertTrue(ops._is_valid_cache('db', 'table'))
-        ops.lookup_constraint('db', 'table', 'column')
-        self.assertTrue(ops._is_valid_cache('db', 'table'))
-        ops.clear_con('table')
-        self.assertFalse(ops._is_valid_cache('db', 'table'))
-
-    def test_valid_implementation(self):
-        # generic fills the cache on a per-table basis
-        ops = self.CacheOps()
-        self.assertFalse(ops._is_valid_cache('db', 'table'))
-        self.assertFalse(ops._is_valid_cache('db', 'other_table'))
-        ops.lookup_constraint('db', 'table')
-        self.assertTrue(ops._is_valid_cache('db', 'table'))
-        self.assertFalse(ops._is_valid_cache('db', 'other_table'))
-        ops.lookup_constraint('db', 'other_table')
-        self.assertTrue(ops._is_valid_cache('db', 'table'))
-        self.assertTrue(ops._is_valid_cache('db', 'other_table'))
-        ops.clear_con('table')
-        self.assertFalse(ops._is_valid_cache('db', 'table'))
-        self.assertTrue(ops._is_valid_cache('db', 'other_table'))
-
-if mysql:
-    class TestCacheMysql(TestCacheGeneric):
-        base_ops_cls = mysql.DatabaseOperations
-
-        def test_valid_implementation(self):
-            # mysql fills the cache on a per-db basis
-            ops = self.CacheOps()
-            self.assertFalse(ops._is_valid_cache('db', 'table'))
-            self.assertFalse(ops._is_valid_cache('db', 'other_table'))
-            ops.lookup_constraint('db', 'table')
-            self.assertTrue(ops._is_valid_cache('db', 'table'))
-            self.assertTrue(ops._is_valid_cache('db', 'other_table'))
-            ops.lookup_constraint('db', 'other_table')
-            self.assertTrue(ops._is_valid_cache('db', 'table'))
-            self.assertTrue(ops._is_valid_cache('db', 'other_table'))
-            ops.clear_con('table')
-            self.assertFalse(ops._is_valid_cache('db', 'table'))
-            self.assertTrue(ops._is_valid_cache('db', 'other_table'))
diff --git a/src/south/tests/db_firebird.py b/src/south/tests/db_firebird.py
deleted file mode 100644
index 2b6bd53202..0000000000
--- a/src/south/tests/db_firebird.py
+++ /dev/null
@@ -1,39 +0,0 @@
-from django.db import models
-
-from south.db import db
-from south.tests import unittest, skipUnless
-
-
-class FirebirdTests(unittest.TestCase):
-
-    """
-    Tests firebird related issues
-    """
-
-    def setUp(self):
-        print('=' * 80)
-        print('Begin Firebird test')
-
-    def tearDown(self):
-        print('End Firebird test')
-        print('=' * 80)
-
-    @skipUnless(db.backend_name == "firebird", "Firebird-only test")
-    def test_firebird_double_index_creation_1317(self):
-        """
-        Tests foreign key creation, especially uppercase (see #61)
-        """
-        Test = db.mock_model(model_name='Test',
-            db_table='test5a',
-            db_tablespace='',
-            pk_field_name='ID',
-            pk_field_type=models.AutoField,
-            pk_field_args=[]
-        )
-        db.create_table("test5a", [('ID', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True))])
-        db.create_table("test5b", [
-            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
-            ('UNIQUE', models.ForeignKey(Test)),
-        ])
-        db.execute_deferred_sql()
-
diff --git a/src/south/tests/db_mysql.py b/src/south/tests/db_mysql.py
deleted file mode 100644
index e83596c463..0000000000
--- a/src/south/tests/db_mysql.py
+++ /dev/null
@@ -1,164 +0,0 @@
-# Additional MySQL-specific tests
-# Written by: F. Gabriel Gosselin <gabrielNOSPAM@evidens.ca>
-# Based on tests by: aarranz
-from south.tests import unittest, skipUnless
-
-
-from south.db import db, generic, mysql
-from django.db import connection, models
-
-from south.utils.py3 import with_metaclass
-
-
-# A class decoration may be used in lieu of this when Python 2.5 is the
-# minimum.
-class TestMySQLOperationsMeta(type):
-
-    def __new__(mcs, name, bases, dict_):
-        decorator = skipUnless(db.backend_name == "mysql", 'MySQL-specific tests')
-
-        for key, method in dict_.items():
-            if key.startswith('test'):
-                dict_[key] = decorator(method)
-
-        return type.__new__(mcs, name, bases, dict_)
-
-class TestMySQLOperations(with_metaclass(TestMySQLOperationsMeta, unittest.TestCase)):
-    """MySQL-specific tests"""
-
-    def setUp(self):
-        db.debug = False
-        db.clear_deferred_sql()
-
-    def tearDown(self):
-        pass
-
-    def _create_foreign_tables(self, main_name, reference_name):
-        # Create foreign table and model
-        Foreign = db.mock_model(model_name='Foreign', db_table=reference_name,
-                                db_tablespace='', pk_field_name='id',
-                                pk_field_type=models.AutoField,
-                                pk_field_args=[])
-        db.create_table(reference_name, [
-                ('id', models.AutoField(primary_key=True)),
-            ])
-        # Create table with foreign key
-        db.create_table(main_name, [
-                ('id', models.AutoField(primary_key=True)),
-                ('foreign', models.ForeignKey(Foreign)),
-            ])
-        return Foreign
-
-    def test_constraint_references(self):
-        """Tests that referred table is reported accurately"""
-        main_table = 'test_cns_ref'
-        reference_table = 'test_cr_foreign'
-        db.start_transaction()
-        self._create_foreign_tables(main_table, reference_table)
-        db.execute_deferred_sql()
-        constraint = db._find_foreign_constraints(main_table, 'foreign_id')[0]
-        references = db._lookup_constraint_references(main_table, constraint)
-        self.assertEquals((reference_table, 'id'), references)
-        db.delete_table(main_table)
-        db.delete_table(reference_table)
-
-    def test_reverse_column_constraint(self):
-        """Tests that referred column in a foreign key (ex. id) is found"""
-        main_table = 'test_reverse_ref'
-        reference_table = 'test_rr_foreign'
-        db.start_transaction()
-        self._create_foreign_tables(main_table, reference_table)
-        db.execute_deferred_sql()
-        inverse = db._lookup_reverse_constraint(reference_table, 'id')
-        (cname, rev_table, rev_column) = inverse[0]
-        self.assertEquals(main_table, rev_table)
-        self.assertEquals('foreign_id', rev_column)
-        db.delete_table(main_table)
-        db.delete_table(reference_table)
-
-    def test_delete_fk_column(self):
-        main_table = 'test_drop_foreign'
-        ref_table = 'test_df_ref'
-        self._create_foreign_tables(main_table, ref_table)
-        db.execute_deferred_sql()
-        constraints = db._find_foreign_constraints(main_table, 'foreign_id')
-        self.assertEquals(len(constraints), 1)
-        db.delete_column(main_table, 'foreign_id')
-        constraints = db._find_foreign_constraints(main_table, 'foreign_id')
-        self.assertEquals(len(constraints), 0)
-        db.delete_table(main_table)
-        db.delete_table(ref_table)
-
-    def test_rename_fk_column(self):
-        main_table = 'test_rename_foreign'
-        ref_table = 'test_rf_ref'
-        self._create_foreign_tables(main_table, ref_table)
-        db.execute_deferred_sql()
-        constraints = db._find_foreign_constraints(main_table, 'foreign_id')
-        self.assertEquals(len(constraints), 1)
-        db.rename_column(main_table, 'foreign_id', 'reference_id')
-        db.execute_deferred_sql()  #Create constraints
-        constraints = db._find_foreign_constraints(main_table, 'reference_id')
-        self.assertEquals(len(constraints), 1)
-        db.delete_table(main_table)
-        db.delete_table(ref_table)
-
-    def test_rename_fk_inbound(self):
-        """
-        Tests that the column referred to by an external column can be renamed.
-        Edge case, but also useful as stepping stone to renaming tables.
-        """
-        main_table = 'test_rename_fk_inbound'
-        ref_table = 'test_rfi_ref'
-        self._create_foreign_tables(main_table, ref_table)
-        db.execute_deferred_sql()
-        constraints = db._lookup_reverse_constraint(ref_table, 'id')
-        self.assertEquals(len(constraints), 1)
-        db.rename_column(ref_table, 'id', 'rfi_id')
-        db.execute_deferred_sql()  #Create constraints
-        constraints = db._lookup_reverse_constraint(ref_table, 'rfi_id')
-        self.assertEquals(len(constraints), 1)
-        cname = db._find_foreign_constraints(main_table, 'foreign_id')[0]
-        (rtable, rcolumn) = db._lookup_constraint_references(main_table, cname)
-        self.assertEquals(rcolumn, 'rfi_id')
-        db.delete_table(main_table)
-        db.delete_table(ref_table)
-
-    def test_rename_constrained_table(self):
-        """Renames a table with a foreign key column (towards another table)"""
-        main_table = 'test_rn_table'
-        ref_table = 'test_rt_ref'
-        renamed_table = 'test_renamed_table'
-        self._create_foreign_tables(main_table, ref_table)
-        db.execute_deferred_sql()
-        constraints = db._find_foreign_constraints(main_table, 'foreign_id')
-        self.assertEquals(len(constraints), 1)
-        db.rename_table(main_table, renamed_table)
-        db.execute_deferred_sql()  #Create constraints
-        constraints = db._find_foreign_constraints(renamed_table, 'foreign_id')
-        self.assertEquals(len(constraints), 1)
-        (rtable, rcolumn) = db._lookup_constraint_references(
-                renamed_table, constraints[0])
-        self.assertEquals(rcolumn, 'id')
-        db.delete_table(renamed_table)
-        db.delete_table(ref_table)
-
-    def test_renamed_referenced_table(self):
-        """Rename a table referred to in a foreign key"""
-        main_table = 'test_rn_refd_table'
-        ref_table = 'test_rrt_ref'
-        renamed_table = 'test_renamed_ref'
-        self._create_foreign_tables(main_table, ref_table)
-        db.execute_deferred_sql()
-        constraints = db._lookup_reverse_constraint(ref_table)
-        self.assertEquals(len(constraints), 1)
-        db.rename_table(ref_table, renamed_table)
-        db.execute_deferred_sql()  #Create constraints
-        constraints = db._find_foreign_constraints(main_table, 'foreign_id')
-        self.assertEquals(len(constraints), 1)
-        (rtable, rcolumn) = db._lookup_constraint_references(
-                main_table, constraints[0])
-        self.assertEquals(renamed_table, rtable)
-        db.delete_table(main_table)
-        db.delete_table(renamed_table)
-
diff --git a/src/south/tests/deps_a/__init__.py b/src/south/tests/deps_a/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/deps_a/migrations/0001_a.py b/src/south/tests/deps_a/migrations/0001_a.py
deleted file mode 100644
index d27ed3a172..0000000000
--- a/src/south/tests/deps_a/migrations/0001_a.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/deps_a/migrations/0002_a.py b/src/south/tests/deps_a/migrations/0002_a.py
deleted file mode 100644
index d27ed3a172..0000000000
--- a/src/south/tests/deps_a/migrations/0002_a.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/deps_a/migrations/0003_a.py b/src/south/tests/deps_a/migrations/0003_a.py
deleted file mode 100644
index d27ed3a172..0000000000
--- a/src/south/tests/deps_a/migrations/0003_a.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/deps_a/migrations/0004_a.py b/src/south/tests/deps_a/migrations/0004_a.py
deleted file mode 100644
index e5c29771c8..0000000000
--- a/src/south/tests/deps_a/migrations/0004_a.py
+++ /dev/null
@@ -1,13 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    depends_on = [('deps_b', '0003_b')]
-
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/deps_a/migrations/0005_a.py b/src/south/tests/deps_a/migrations/0005_a.py
deleted file mode 100644
index d27ed3a172..0000000000
--- a/src/south/tests/deps_a/migrations/0005_a.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/deps_a/migrations/__init__.py b/src/south/tests/deps_a/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/deps_a/models.py b/src/south/tests/deps_a/models.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/deps_b/__init__.py b/src/south/tests/deps_b/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/deps_b/migrations/0001_b.py b/src/south/tests/deps_b/migrations/0001_b.py
deleted file mode 100644
index d27ed3a172..0000000000
--- a/src/south/tests/deps_b/migrations/0001_b.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/deps_b/migrations/0002_b.py b/src/south/tests/deps_b/migrations/0002_b.py
deleted file mode 100644
index 459ea5dd94..0000000000
--- a/src/south/tests/deps_b/migrations/0002_b.py
+++ /dev/null
@@ -1,13 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    depends_on = [('deps_a', '0002_a')]
-
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/deps_b/migrations/0003_b.py b/src/south/tests/deps_b/migrations/0003_b.py
deleted file mode 100644
index 1692888ed0..0000000000
--- a/src/south/tests/deps_b/migrations/0003_b.py
+++ /dev/null
@@ -1,13 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    depends_on = [('deps_a', '0003_a')]
-
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/deps_b/migrations/0004_b.py b/src/south/tests/deps_b/migrations/0004_b.py
deleted file mode 100644
index d27ed3a172..0000000000
--- a/src/south/tests/deps_b/migrations/0004_b.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/deps_b/migrations/0005_b.py b/src/south/tests/deps_b/migrations/0005_b.py
deleted file mode 100644
index d27ed3a172..0000000000
--- a/src/south/tests/deps_b/migrations/0005_b.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/deps_b/migrations/__init__.py b/src/south/tests/deps_b/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/deps_b/models.py b/src/south/tests/deps_b/models.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/deps_c/__init__.py b/src/south/tests/deps_c/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/deps_c/migrations/0001_c.py b/src/south/tests/deps_c/migrations/0001_c.py
deleted file mode 100644
index d27ed3a172..0000000000
--- a/src/south/tests/deps_c/migrations/0001_c.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/deps_c/migrations/0002_c.py b/src/south/tests/deps_c/migrations/0002_c.py
deleted file mode 100644
index d27ed3a172..0000000000
--- a/src/south/tests/deps_c/migrations/0002_c.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/deps_c/migrations/0003_c.py b/src/south/tests/deps_c/migrations/0003_c.py
deleted file mode 100644
index d27ed3a172..0000000000
--- a/src/south/tests/deps_c/migrations/0003_c.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/deps_c/migrations/0004_c.py b/src/south/tests/deps_c/migrations/0004_c.py
deleted file mode 100644
index d27ed3a172..0000000000
--- a/src/south/tests/deps_c/migrations/0004_c.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/deps_c/migrations/0005_c.py b/src/south/tests/deps_c/migrations/0005_c.py
deleted file mode 100644
index 459ea5dd94..0000000000
--- a/src/south/tests/deps_c/migrations/0005_c.py
+++ /dev/null
@@ -1,13 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-
-    depends_on = [('deps_a', '0002_a')]
-
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/deps_c/migrations/__init__.py b/src/south/tests/deps_c/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/deps_c/models.py b/src/south/tests/deps_c/models.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/emptyapp/__init__.py b/src/south/tests/emptyapp/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/emptyapp/migrations/__init__.py b/src/south/tests/emptyapp/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/emptyapp/models.py b/src/south/tests/emptyapp/models.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/fakeapp/__init__.py b/src/south/tests/fakeapp/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/fakeapp/migrations/0001_spam.py b/src/south/tests/fakeapp/migrations/0001_spam.py
deleted file mode 100644
index 9739648a22..0000000000
--- a/src/south/tests/fakeapp/migrations/0001_spam.py
+++ /dev/null
@@ -1,17 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-    
-    def forwards(self):
-        # Model 'Spam'
-        db.create_table("southtest_spam", (
-            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
-            ('weight', models.FloatField()),
-            ('expires', models.DateTimeField()),
-            ('name', models.CharField(max_length=255))
-        ))
-    
-    def backwards(self):
-        db.delete_table("southtest_spam")
-
diff --git a/src/south/tests/fakeapp/migrations/0002_eggs.py b/src/south/tests/fakeapp/migrations/0002_eggs.py
deleted file mode 100644
index 3ec83999fe..0000000000
--- a/src/south/tests/fakeapp/migrations/0002_eggs.py
+++ /dev/null
@@ -1,20 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-    
-    def forwards(self):
-        
-        Spam = db.mock_model(model_name='Spam', db_table='southtest_spam', db_tablespace='', pk_field_name='id', pk_field_type=models.AutoField)
-        
-        db.create_table("southtest_eggs", (
-            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
-            ('size', models.FloatField()),
-            ('quantity', models.IntegerField()),
-            ('spam', models.ForeignKey(Spam)),
-        ))
-    
-    def backwards(self):
-        
-        db.delete_table("southtest_eggs")
-
diff --git a/src/south/tests/fakeapp/migrations/0003_alter_spam.py b/src/south/tests/fakeapp/migrations/0003_alter_spam.py
deleted file mode 100644
index 39126c279b..0000000000
--- a/src/south/tests/fakeapp/migrations/0003_alter_spam.py
+++ /dev/null
@@ -1,18 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-    
-    def forwards(self):
-        
-        db.alter_column("southtest_spam", 'weight', models.FloatField(null=True))
-    
-    def backwards(self):
-        
-        db.alter_column("southtest_spam", 'weight', models.FloatField())
-
-    models = {
-        "fakeapp.bug135": {
-            'date':  ('models.DateTimeField', [], {'default': 'datetime.datetime(2009, 5, 6, 15, 33, 15, 780013)'}),
-        }
-    }
diff --git a/src/south/tests/fakeapp/migrations/__init__.py b/src/south/tests/fakeapp/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/fakeapp/models.py b/src/south/tests/fakeapp/models.py
deleted file mode 100644
index cc39eb74c0..0000000000
--- a/src/south/tests/fakeapp/models.py
+++ /dev/null
@@ -1,111 +0,0 @@
-# -*- coding: UTF-8 -*-
-
-from django.db import models
-from django.contrib.auth.models import User as UserAlias
-
-from south.modelsinspector import add_introspection_rules
-
-on_delete_is_available = hasattr(models, "PROTECT") # models here is django.db.models
-
-def default_func():
-    return "yays"
-
-# An empty case.
-class Other1(models.Model): pass
-
-# Another one
-class Other3(models.Model): pass
-def get_sentinel_object():
-    """
-    A function to return the object to be used in place of any deleted object,
-    when using the SET option for on_delete.
-    """
-    # Create a new one, so we always have an instance to test with. Can't work!
-    return Other3()
-
-# Nastiness.
-class HorribleModel(models.Model):
-    "A model to test the edge cases of model parsing"
-    
-    ZERO, ONE = 0, 1
-    
-    # First, some nice fields
-    name = models.CharField(max_length=255)
-    short_name = models.CharField(max_length=50)
-    slug = models.SlugField(unique=True)
-    
-    # A ForeignKey, to a model above, and then below
-    o1 = models.ForeignKey(Other1)
-    o2 = models.ForeignKey('Other2')
-    
-    if on_delete_is_available:
-        o_set_null_on_delete = models.ForeignKey('Other3', null=True, on_delete=models.SET_NULL)
-        o_cascade_delete = models.ForeignKey('Other3', null=True, on_delete=models.CASCADE, related_name="cascademe")
-        o_protect = models.ForeignKey('Other3', null=True, on_delete=models.PROTECT, related_name="dontcascademe")
-        o_default_on_delete = models.ForeignKey('Other3', null=True, default=1, on_delete=models.SET_DEFAULT, related_name="setmedefault")
-        o_set_on_delete_function = models.ForeignKey('Other3', null=True, default=1, on_delete=models.SET(get_sentinel_object), related_name="setsentinel")
-        o_set_on_delete_value = models.ForeignKey('Other3', null=True, default=1, on_delete=models.SET(get_sentinel_object()), related_name="setsentinelwithactualvalue") # dubious case
-        o_no_action_on_delete = models.ForeignKey('Other3', null=True, default=1, on_delete=models.DO_NOTHING, related_name="deletemeatyourperil")
-    
-    
-    # Now to something outside
-    user = models.ForeignKey(UserAlias, related_name="horribles")
-    
-    # Unicode!
-    code = models.CharField(max_length=25, default="↑↑↓↓←→←→BA")
-    
-    # Odd defaults!
-    class_attr = models.IntegerField(default=ZERO)
-    func = models.CharField(max_length=25, default=default_func)
-    
-    # Time to get nasty. Define a non-field choices, and use it
-    choices = [('hello', '1'), ('world', '2')]
-    choiced = models.CharField(max_length=20, choices=choices)
-    
-    class Meta:
-        db_table = "my_fave"
-        verbose_name = "Dr. Strangelove," + \
-                     """or how I learned to stop worrying
-and love the bomb"""
-    
-    # Now spread over multiple lines
-    multiline = \
-              models.TextField(
-        )
-
-# Special case.
-class Other2(models.Model):
-    # Try loading a field without a newline after it (inspect hates this)
-    close_but_no_cigar = models.PositiveIntegerField(primary_key=True)
-
-class CustomField(models.IntegerField):
-    def __init__(self, an_other_model, **kwargs):
-        super(CustomField, self).__init__(**kwargs)
-        self.an_other_model = an_other_model
-
-add_introspection_rules([
-    (
-        [CustomField],
-        [],
-        {'an_other_model': ('an_other_model', {})},
-    ),
-], ['^south\.tests\.fakeapp\.models\.CustomField'])
-
-class BaseModel(models.Model):
-    pass
-
-class SubModel(BaseModel):
-    others = models.ManyToManyField(Other1)
-    custom = CustomField(Other2)
-
-class CircularA(models.Model):
-    c = models.ForeignKey('CircularC')
-
-class CircularB(models.Model):
-    a = models.ForeignKey(CircularA)
-
-class CircularC(models.Model):
-    b = models.ForeignKey(CircularB)
-
-class Recursive(models.Model):
-   self = models.ForeignKey('self')
diff --git a/src/south/tests/freezer.py b/src/south/tests/freezer.py
deleted file mode 100644
index 82c44024af..0000000000
--- a/src/south/tests/freezer.py
+++ /dev/null
@@ -1,15 +0,0 @@
-from south.tests import unittest
-
-from south.creator.freezer import model_dependencies
-from south.tests.fakeapp import models
-
-class TestFreezer(unittest.TestCase):
-    def test_dependencies(self):
-        self.assertEqual(set(model_dependencies(models.SubModel)),
-                         set([models.BaseModel, models.Other1, models.Other2]))
-
-        self.assertEqual(set(model_dependencies(models.CircularA)),
-                         set([models.CircularA, models.CircularB, models.CircularC]))
-
-        self.assertEqual(set(model_dependencies(models.Recursive)),
-                         set([models.Recursive]))
diff --git a/src/south/tests/inspector.py b/src/south/tests/inspector.py
deleted file mode 100644
index dcd6d57de1..0000000000
--- a/src/south/tests/inspector.py
+++ /dev/null
@@ -1,109 +0,0 @@
-
-from south.tests import Monkeypatcher, skipUnless
-from south.modelsinspector import (convert_on_delete_handler, get_value,
-    IsDefault, models, value_clean)
-
-from fakeapp.models import HorribleModel, get_sentinel_object
-
-
-on_delete_is_available = hasattr(models, "PROTECT") # models here is django.db.models
-skipUnlessOnDeleteAvailable = skipUnless(on_delete_is_available, "not testing on_delete -- not available on Django<1.3")                    
-
-class TestModelInspector(Monkeypatcher):
-
-    """
-    Tests if the various parts of the modelinspector work.
-    """
-    
-    def test_get_value(self):
-        
-        # Let's start nicely.
-        name = HorribleModel._meta.get_field_by_name("name")[0]
-        slug = HorribleModel._meta.get_field_by_name("slug")[0]
-        user = HorribleModel._meta.get_field_by_name("user")[0]
-        
-        # Simple int retrieval
-        self.assertEqual(
-            get_value(name, ["max_length", {}]),
-            "255",
-        )
-        
-        # Bool retrieval
-        self.assertEqual(
-            get_value(slug, ["unique", {}]),
-            "True",
-        )
-        
-        # String retrieval
-        self.assertEqual(
-            get_value(user, ["rel.related_name", {}]),
-            "'horribles'",
-        )
-        
-        # Default triggering
-        self.assertEqual(
-            get_value(slug, ["unique", {"default": False}]),
-            "True",
-        )
-        self.assertRaises(
-            IsDefault,
-            get_value,
-            slug,
-            ["unique", {"default": True}],
-        )
-
-    @skipUnlessOnDeleteAvailable
-    def test_get_value_on_delete(self):
-
-        # First validate the FK fields with on_delete options
-        o_set_null_on_delete = HorribleModel._meta.get_field_by_name("o_set_null_on_delete")[0]
-        o_cascade_delete = HorribleModel._meta.get_field_by_name("o_cascade_delete")[0]
-        o_protect = HorribleModel._meta.get_field_by_name("o_protect")[0]
-        o_default_on_delete = HorribleModel._meta.get_field_by_name("o_default_on_delete")[0]
-        o_set_on_delete_function = HorribleModel._meta.get_field_by_name("o_set_on_delete_function")[0]
-        o_set_on_delete_value = HorribleModel._meta.get_field_by_name("o_set_on_delete_value")[0]
-        o_no_action_on_delete = HorribleModel._meta.get_field_by_name("o_no_action_on_delete")[0]
-        # TODO this is repeated from the introspection_details in modelsinspector:
-        # better to refactor that so we can reference these settings, in case they
-        # must change at some point.
-        on_delete = ["rel.on_delete", {"default": models.CASCADE, "is_django_function": True, "converter": convert_on_delete_handler, }]
-        
-        # Foreign Key cascade update/delete
-        self.assertRaises(
-            IsDefault,
-            get_value,
-            o_cascade_delete,
-            on_delete,
-        )
-        self.assertEqual(
-            get_value(o_protect, on_delete),
-            "models.PROTECT",
-        )
-        self.assertEqual(
-            get_value(o_no_action_on_delete, on_delete),
-            "models.DO_NOTHING",
-        )
-        self.assertEqual(
-            get_value(o_set_null_on_delete, on_delete),
-            "models.SET_NULL",
-        )
-        self.assertEqual(
-            get_value(o_default_on_delete, on_delete),
-            "models.SET_DEFAULT",
-        )
-        # For now o_set_on_delete raises, see modelsinspector.py
-        #self.assertEqual(
-        #    get_value(o_set_on_delete_function, on_delete),
-        #    "models.SET(get_sentinel_object)",
-        #)
-        self.assertRaises(
-            ValueError,
-            get_value,
-            o_set_on_delete_function,
-            on_delete,
-        )
-        self.assertEqual(
-            get_value(o_set_on_delete_value, on_delete),
-            "models.SET(%s)" % value_clean(get_sentinel_object()),
-        )
-        
\ No newline at end of file
diff --git a/src/south/tests/logger.py b/src/south/tests/logger.py
deleted file mode 100644
index 78d159dc86..0000000000
--- a/src/south/tests/logger.py
+++ /dev/null
@@ -1,82 +0,0 @@
-import io
-import logging
-import os
-import tempfile
-from south.tests import unittest
-import sys
-
-from django.conf import settings
-from django.db import connection, models
-
-from south.db import db
-from south.logger import close_logger
-
-class TestLogger(unittest.TestCase):
-
-    """
-    Tests if the logging is working reasonably. Some tests ignored if you don't
-    have write permission to the disk.
-    """
-    
-    def setUp(self):
-        db.debug = False
-        self.test_path = tempfile.mkstemp(suffix=".south.log")[1]
-    
-    def test_db_execute_logging_nofile(self):
-        "Does logging degrade nicely if SOUTH_LOGGING_ON not set?"
-        settings.SOUTH_LOGGING_ON = False     # this needs to be set to False
-                                              # to avoid issues where other tests
-                                              # set this to True. settings is shared
-                                              # between these tests.
-        db.create_table("test9", [('email_confirmed', models.BooleanField(default=False))])
-
-    def test_db_execute_logging_off_with_basic_config(self):
-        """
-        Does the south logger avoid outputing debug information with
-        south logging turned off and python logging configured with
-        a basic config?"
-        """
-        settings.SOUTH_LOGGING_ON = False
-
-        # Set root logger to capture WARNING and worse
-        logging_stream = io.StringIO()
-        logging.basicConfig(stream=logging_stream, level=logging.WARNING)
-
-        db.create_table("test12", [('email_confirmed', models.BooleanField(default=False))])
-
-        # since south logging is off, and our root logger is at WARNING
-        # we should not find DEBUG info in the log
-        self.assertEqual(logging_stream.getvalue(), '')
-
-    def test_db_execute_logging_validfile(self):
-        "Does logging work when passing in a valid file?"
-        settings.SOUTH_LOGGING_ON = True
-        settings.SOUTH_LOGGING_FILE = self.test_path
-        # Check to see if we can make the logfile
-        try:
-            fh = open(self.test_path, "w")
-        except IOError:
-            # Permission was denied, ignore the test.
-            return
-        else:
-            fh.close()
-        # Do an action which logs
-        db.create_table("test10", [('email_confirmed', models.BooleanField(default=False))])
-        # Close the logged file
-        close_logger()
-        try:
-            os.remove(self.test_path)
-        except:
-            # It's a tempfile, it's not vital we remove it.
-            pass
-
-    def test_db_execute_logging_missingfilename(self):
-        "Does logging raise an error if there is a missing filename?"
-        settings.SOUTH_LOGGING_ON = True
-        settings.SOUTH_LOGGING_FILE = None
-        self.assertRaises(
-            IOError,
-            db.create_table,
-            "test11",
-            [('email_confirmed', models.BooleanField(default=False))],
-        )
diff --git a/src/south/tests/logic.py b/src/south/tests/logic.py
deleted file mode 100644
index 2b21cef6e2..0000000000
--- a/src/south/tests/logic.py
+++ /dev/null
@@ -1,902 +0,0 @@
-from south.tests import unittest
-
-import datetime
-import sys
-try:
-    set # builtin, python >=2.6
-except NameError:
-    from sets import Set as set # in stdlib, python >=2.3
-
-from south import exceptions
-from south.migration import migrate_app
-from south.migration.base import all_migrations, Migrations
-from south.creator.changes import ManualChanges
-from south.migration.utils import depends, flatten, get_app_label
-from south.models import MigrationHistory
-from south.tests import Monkeypatcher
-from south.db import db
-
-
-
-class TestBrokenMigration(Monkeypatcher):
-    installed_apps = ["fakeapp", "otherfakeapp", "brokenapp"]
-
-    def test_broken_dependencies(self):
-        self.assertRaises(
-            exceptions.DependsOnUnmigratedApplication,
-            Migrations.calculate_dependencies,
-            force=True,
-        )
-        #depends_on_unknown = self.brokenapp['0002_depends_on_unknown']
-        #self.assertRaises(exceptions.DependsOnUnknownMigration,
-        #                  depends_on_unknown.dependencies)
-        #depends_on_higher = self.brokenapp['0003_depends_on_higher']
-        #self.assertRaises(exceptions.DependsOnHigherMigration,
-        #                  depends_on_higher.dependencies)
-
-
-class TestMigration(Monkeypatcher):
-    installed_apps = ["fakeapp", "otherfakeapp"]
-
-    def setUp(self):
-        super(TestMigration, self).setUp()
-        self.fakeapp = Migrations('fakeapp')
-        self.otherfakeapp = Migrations('otherfakeapp')
-        Migrations.calculate_dependencies(force=True)
-
-    def test_str(self):
-        migrations = [str(m) for m in self.fakeapp]
-        self.assertEqual(['fakeapp:0001_spam',
-                          'fakeapp:0002_eggs',
-                          'fakeapp:0003_alter_spam'],
-                         migrations)
-    
-    def test_repr(self):
-        migrations = [repr(m) for m in self.fakeapp]
-        self.assertEqual(['<Migration: fakeapp:0001_spam>',
-                          '<Migration: fakeapp:0002_eggs>',
-                          '<Migration: fakeapp:0003_alter_spam>'],
-                         migrations)
-
-    def test_app_label(self):
-        self.assertEqual(['fakeapp', 'fakeapp', 'fakeapp'],
-                         [m.app_label() for m in self.fakeapp])
-                         
-    def test_name(self):
-        self.assertEqual(['0001_spam', '0002_eggs', '0003_alter_spam'],
-                         [m.name() for m in self.fakeapp])
-
-    def test_full_name(self):
-        self.assertEqual(['fakeapp.migrations.0001_spam',
-                          'fakeapp.migrations.0002_eggs',
-                          'fakeapp.migrations.0003_alter_spam'],
-                         [m.full_name() for m in self.fakeapp])
-    
-    def test_migration(self):
-        # Can't use vanilla import, modules beginning with numbers aren't in grammar
-        M1 = __import__("fakeapp.migrations.0001_spam", {}, {}, ['Migration']).Migration
-        M2 = __import__("fakeapp.migrations.0002_eggs", {}, {}, ['Migration']).Migration
-        M3 = __import__("fakeapp.migrations.0003_alter_spam", {}, {}, ['Migration']).Migration
-        self.assertEqual([M1, M2, M3],
-                         [m.migration().Migration for m in self.fakeapp])
-        self.assertRaises(exceptions.UnknownMigration,
-                          self.fakeapp['9999_unknown'].migration)
-
-    def test_previous(self):
-        self.assertEqual([None,
-                          self.fakeapp['0001_spam'],
-                          self.fakeapp['0002_eggs']],
-                         [m.previous() for m in self.fakeapp])
-
-    def test_dependencies(self):
-        "Test that the dependency detection works."
-        self.assertEqual([
-                set([]),
-                set([self.fakeapp['0001_spam']]),
-                set([self.fakeapp['0002_eggs']])
-            ],
-            [m.dependencies for m in self.fakeapp],
-        )
-        self.assertEqual([
-                set([self.fakeapp['0001_spam']]),
-                set([self.otherfakeapp['0001_first']]),
-                set([
-                    self.otherfakeapp['0002_second'],
-                    self.fakeapp['0003_alter_spam'],
-                ])
-            ],
-            [m.dependencies for m in self.otherfakeapp],
-        )
-
-    def test_forwards_plan(self):
-        self.assertEqual([
-                [self.fakeapp['0001_spam']],
-                [
-                    self.fakeapp['0001_spam'],
-                    self.fakeapp['0002_eggs']
-                ],
-                [
-                    self.fakeapp['0001_spam'],
-                    self.fakeapp['0002_eggs'],
-                    self.fakeapp['0003_alter_spam'],
-                ]
-            ],
-            [m.forwards_plan() for m in self.fakeapp],
-        )
-        self.assertEqual([
-                [
-                    self.fakeapp['0001_spam'],
-                    self.otherfakeapp['0001_first']
-                ],
-                [
-                    self.fakeapp['0001_spam'],
-                    self.otherfakeapp['0001_first'],
-                    self.otherfakeapp['0002_second']
-                ],
-                [
-                    self.fakeapp['0001_spam'],
-                    self.otherfakeapp['0001_first'],
-                    self.otherfakeapp['0002_second'],
-                    self.fakeapp['0002_eggs'],
-                    self.fakeapp['0003_alter_spam'],
-                    self.otherfakeapp['0003_third'],
-                ]
-            ],
-            [m.forwards_plan() for m in self.otherfakeapp],
-        )
-
-    def test_is_before(self):
-        F1 = self.fakeapp['0001_spam']
-        F2 = self.fakeapp['0002_eggs']
-        F3 = self.fakeapp['0003_alter_spam']
-        O1 = self.otherfakeapp['0001_first']
-        O2 = self.otherfakeapp['0002_second']
-        O3 = self.otherfakeapp['0003_third']
-        self.assertTrue(F1.is_before(F2))
-        self.assertTrue(F1.is_before(F3))
-        self.assertTrue(F2.is_before(F3))
-        self.assertEqual(O3.is_before(O1), False)
-        self.assertEqual(O3.is_before(O2), False)
-        self.assertEqual(O2.is_before(O2), False)
-        self.assertEqual(O2.is_before(O1), False)
-        self.assertEqual(F2.is_before(O1), None)
-        self.assertEqual(F2.is_before(O2), None)
-        self.assertEqual(F2.is_before(O3), None)
-
-
-class TestMigrationDependencies(Monkeypatcher):
-    installed_apps = ['deps_a', 'deps_b', 'deps_c']
-
-    def setUp(self):
-        super(TestMigrationDependencies, self).setUp()
-        self.deps_a = Migrations('deps_a')
-        self.deps_b = Migrations('deps_b')
-        self.deps_c = Migrations('deps_c')
-        Migrations.calculate_dependencies(force=True)
-
-    def test_dependencies(self):
-        self.assertEqual(
-            [
-                set([]),
-                set([self.deps_a['0001_a']]),
-                set([self.deps_a['0002_a']]),
-                set([
-                    self.deps_a['0003_a'],
-                    self.deps_b['0003_b'],
-                ]),
-                set([self.deps_a['0004_a']]),
-            ],
-            [m.dependencies for m in self.deps_a],
-        )
-        self.assertEqual(
-            [
-                set([]),
-                set([
-                    self.deps_b['0001_b'],
-                    self.deps_a['0002_a']
-                ]),
-                set([
-                    self.deps_b['0002_b'],
-                    self.deps_a['0003_a']
-                ]),
-                set([self.deps_b['0003_b']]),
-                set([self.deps_b['0004_b']]),
-            ],
-            [m.dependencies for m in self.deps_b],
-        )
-        self.assertEqual(
-            [
-                set([]),
-                set([self.deps_c['0001_c']]),
-                set([self.deps_c['0002_c']]),
-                set([self.deps_c['0003_c']]),
-                set([
-                    self.deps_c['0004_c'],
-                    self.deps_a['0002_a']
-                ]),
-            ],
-            [m.dependencies for m in self.deps_c],
-        )
-
-    def test_dependents(self):
-        self.assertEqual([set([self.deps_a['0002_a']]),
-                          set([self.deps_c['0005_c'],
-                                 self.deps_b['0002_b'],
-                                 self.deps_a['0003_a']]),
-                          set([self.deps_b['0003_b'],
-                                 self.deps_a['0004_a']]),
-                          set([self.deps_a['0005_a']]),
-                          set([])],
-                         [m.dependents for m in self.deps_a])
-        self.assertEqual([set([self.deps_b['0002_b']]),
-                          set([self.deps_b['0003_b']]),
-                          set([self.deps_b['0004_b'],
-                                 self.deps_a['0004_a']]),
-                          set([self.deps_b['0005_b']]),
-                          set([])],
-                         [m.dependents for m in self.deps_b])
-        self.assertEqual([set([self.deps_c['0002_c']]),
-                          set([self.deps_c['0003_c']]),
-                          set([self.deps_c['0004_c']]),
-                          set([self.deps_c['0005_c']]),
-                          set([])],
-                         [m.dependents for m in self.deps_c])
-
-    def test_forwards_plan(self):
-        self.assertEqual([[self.deps_a['0001_a']],
-                          [self.deps_a['0001_a'],
-                           self.deps_a['0002_a']],
-                          [self.deps_a['0001_a'],
-                           self.deps_a['0002_a'],
-                           self.deps_a['0003_a']],
-                          [self.deps_b['0001_b'],
-                           self.deps_a['0001_a'],
-                           self.deps_a['0002_a'],
-                           self.deps_b['0002_b'],
-                           self.deps_a['0003_a'],
-                           self.deps_b['0003_b'],
-                           self.deps_a['0004_a']],
-                          [self.deps_b['0001_b'],
-                           self.deps_a['0001_a'],
-                           self.deps_a['0002_a'],
-                           self.deps_b['0002_b'],
-                           self.deps_a['0003_a'],
-                           self.deps_b['0003_b'],
-                           self.deps_a['0004_a'],
-                           self.deps_a['0005_a']]],
-                         [m.forwards_plan() for m in self.deps_a])
-        self.assertEqual([[self.deps_b['0001_b']],
-                          [self.deps_b['0001_b'],
-                           self.deps_a['0001_a'],
-                           self.deps_a['0002_a'],
-                           self.deps_b['0002_b']],
-                          [self.deps_b['0001_b'],
-                           self.deps_a['0001_a'],
-                           self.deps_a['0002_a'],
-                           self.deps_b['0002_b'],
-                           self.deps_a['0003_a'],
-                           self.deps_b['0003_b']],
-                          [self.deps_b['0001_b'],
-                           self.deps_a['0001_a'],
-                           self.deps_a['0002_a'],
-                           self.deps_b['0002_b'],
-                           self.deps_a['0003_a'],
-                           self.deps_b['0003_b'],
-                           self.deps_b['0004_b']],
-                          [self.deps_b['0001_b'],
-                           self.deps_a['0001_a'],
-                           self.deps_a['0002_a'],
-                           self.deps_b['0002_b'],
-                           self.deps_a['0003_a'],
-                           self.deps_b['0003_b'],
-                           self.deps_b['0004_b'],
-                           self.deps_b['0005_b']]],
-                         [m.forwards_plan() for m in self.deps_b])
-        self.assertEqual([[self.deps_c['0001_c']],
-                          [self.deps_c['0001_c'],
-                           self.deps_c['0002_c']],
-                          [self.deps_c['0001_c'],
-                           self.deps_c['0002_c'],
-                           self.deps_c['0003_c']],
-                          [self.deps_c['0001_c'],
-                           self.deps_c['0002_c'],
-                           self.deps_c['0003_c'],
-                           self.deps_c['0004_c']],
-                          [self.deps_c['0001_c'],
-                           self.deps_c['0002_c'],
-                           self.deps_c['0003_c'],
-                           self.deps_c['0004_c'],
-                           self.deps_a['0001_a'],
-                           self.deps_a['0002_a'],
-                           self.deps_c['0005_c']]],
-                         [m.forwards_plan() for m in self.deps_c])
-
-    def test_backwards_plan(self):
-        self.assertEqual([
-            [
-                self.deps_c['0005_c'],
-                self.deps_b['0005_b'],
-                self.deps_b['0004_b'],
-                self.deps_a['0005_a'],
-                self.deps_a['0004_a'],
-                self.deps_b['0003_b'],
-                self.deps_b['0002_b'],
-                self.deps_a['0003_a'],
-                self.deps_a['0002_a'],
-                self.deps_a['0001_a'],
-            ],
-            [
-                self.deps_c['0005_c'],
-                self.deps_b['0005_b'],
-                self.deps_b['0004_b'],
-                self.deps_a['0005_a'],
-                self.deps_a['0004_a'],
-                self.deps_b['0003_b'],
-                self.deps_b['0002_b'],
-                self.deps_a['0003_a'],
-                self.deps_a['0002_a'],
-            ],
-            [
-                self.deps_b['0005_b'],
-                self.deps_b['0004_b'],
-                self.deps_a['0005_a'],
-                self.deps_a['0004_a'],
-                self.deps_b['0003_b'],
-                self.deps_a['0003_a'],
-            ],
-            [
-                self.deps_a['0005_a'],
-                self.deps_a['0004_a'],
-            ],
-            [
-                self.deps_a['0005_a'],
-            ]
-        ], [m.backwards_plan() for m in self.deps_a])
-        self.assertEqual([
-            [
-                self.deps_b['0005_b'],
-                self.deps_b['0004_b'],
-                self.deps_a['0005_a'],
-                self.deps_a['0004_a'],
-                self.deps_b['0003_b'],
-                self.deps_b['0002_b'],
-                self.deps_b['0001_b'],
-            ],
-            [
-                self.deps_b['0005_b'],
-                self.deps_b['0004_b'],
-                self.deps_a['0005_a'],
-                self.deps_a['0004_a'],
-                self.deps_b['0003_b'],
-                self.deps_b['0002_b'],
-            ],
-            [
-                self.deps_b['0005_b'],
-                self.deps_b['0004_b'],
-                self.deps_a['0005_a'],
-                self.deps_a['0004_a'],
-                self.deps_b['0003_b'],
-            ],
-            [
-                self.deps_b['0005_b'],
-                self.deps_b['0004_b'],
-            ],
-            [
-                self.deps_b['0005_b'],
-            ],
-        ], [m.backwards_plan() for m in self.deps_b])
-        self.assertEqual([
-            [
-                self.deps_c['0005_c'],
-                self.deps_c['0004_c'],
-                self.deps_c['0003_c'],
-                self.deps_c['0002_c'],
-                self.deps_c['0001_c'],
-            ],
-            [
-                self.deps_c['0005_c'],
-                self.deps_c['0004_c'],
-                self.deps_c['0003_c'],
-                self.deps_c['0002_c'],
-            ],
-            [
-                self.deps_c['0005_c'],
-                self.deps_c['0004_c'],
-                self.deps_c['0003_c'],
-            ],
-            [
-                self.deps_c['0005_c'],
-                self.deps_c['0004_c'],
-            ],
-            [self.deps_c['0005_c']]
-        ],  [m.backwards_plan() for m in self.deps_c])
-
-
-class TestCircularDependencies(Monkeypatcher):
-    installed_apps = ["circular_a", "circular_b"]
-
-    def test_plans(self):
-        Migrations.calculate_dependencies(force=True)
-        circular_a = Migrations('circular_a')
-        circular_b = Migrations('circular_b')
-        self.assertRaises(
-            exceptions.CircularDependency,
-            circular_a[-1].forwards_plan,
-        )
-        self.assertRaises(
-            exceptions.CircularDependency,
-            circular_b[-1].forwards_plan,
-        )
-        self.assertRaises(
-            exceptions.CircularDependency,
-            circular_a[-1].backwards_plan,
-        )
-        self.assertRaises(
-            exceptions.CircularDependency,
-            circular_b[-1].backwards_plan,
-        )
-
-
-class TestMigrations(Monkeypatcher):
-    installed_apps = ["fakeapp", "otherfakeapp"]
-
-    def test_all(self):
-        
-        M1 = Migrations(__import__("fakeapp", {}, {}, ['']))
-        M2 = Migrations(__import__("otherfakeapp", {}, {}, ['']))
-        
-        self.assertEqual(
-            [M1, M2],
-            list(all_migrations()),
-        )
-
-    def test(self):
-        
-        M1 = Migrations(__import__("fakeapp", {}, {}, ['']))
-        
-        self.assertEqual(M1, Migrations("fakeapp"))
-        self.assertEqual(M1, Migrations(self.create_fake_app("fakeapp")))
-
-    def test_application(self):
-        fakeapp = Migrations("fakeapp")
-        application = __import__("fakeapp", {}, {}, [''])
-        self.assertEqual(application, fakeapp.application)
-
-    def test_migration(self):
-        # Can't use vanilla import, modules beginning with numbers aren't in grammar
-        M1 = __import__("fakeapp.migrations.0001_spam", {}, {}, ['Migration']).Migration
-        M2 = __import__("fakeapp.migrations.0002_eggs", {}, {}, ['Migration']).Migration
-        migration = Migrations('fakeapp')
-        self.assertEqual(M1, migration['0001_spam'].migration().Migration)
-        self.assertEqual(M2, migration['0002_eggs'].migration().Migration)
-        self.assertRaises(exceptions.UnknownMigration,
-                          migration['0001_jam'].migration)
-
-    def test_guess_migration(self):
-        # Can't use vanilla import, modules beginning with numbers aren't in grammar
-        M1 = __import__("fakeapp.migrations.0001_spam", {}, {}, ['Migration']).Migration
-        migration = Migrations('fakeapp')
-        self.assertEqual(M1, migration.guess_migration("0001_spam").migration().Migration)
-        self.assertEqual(M1, migration.guess_migration("0001_spa").migration().Migration)
-        self.assertEqual(M1, migration.guess_migration("0001_sp").migration().Migration)
-        self.assertEqual(M1, migration.guess_migration("0001_s").migration().Migration)
-        self.assertEqual(M1, migration.guess_migration("0001_").migration().Migration)
-        self.assertEqual(M1, migration.guess_migration("0001").migration().Migration)
-        self.assertRaises(exceptions.UnknownMigration,
-                          migration.guess_migration, "0001-spam")
-        self.assertRaises(exceptions.MultiplePrefixMatches,
-                          migration.guess_migration, "000")
-        self.assertRaises(exceptions.MultiplePrefixMatches,
-                          migration.guess_migration, "")
-        self.assertRaises(exceptions.UnknownMigration,
-                          migration.guess_migration, "0001_spams")
-        self.assertRaises(exceptions.UnknownMigration,
-                          migration.guess_migration, "0001_jam")
-
-    def test_app_label(self):
-        names = ['fakeapp', 'otherfakeapp']
-        self.assertEqual(names,
-                         [Migrations(n).app_label() for n in names])
-    
-    def test_full_name(self):
-        names = ['fakeapp', 'otherfakeapp']
-        self.assertEqual([n + '.migrations' for n in names],
-                         [Migrations(n).full_name() for n in names])
-
-
-class TestMigrationLogic(Monkeypatcher):
-
-    """
-    Tests if the various logic functions in migration actually work.
-    """
-    
-    installed_apps = ["fakeapp", "otherfakeapp"]
-
-    def setUp(self):
-        super(TestMigrationLogic, self).setUp()
-        MigrationHistory.objects.all().delete()
-        
-    def assertListEqual(self, list1, list2, msg=None):
-        list1 = set(list1)
-        list2 = set(list2)
-        return self.assert_(list1 == list2, "%s is not equal to %s" % (list1, list2))
-
-    def test_find_ghost_migrations(self):
-        pass
-    
-    def test_apply_migrations(self):
-        migrations = Migrations("fakeapp")
-        
-        # We should start with no migrations
-        self.assertEqual(list(MigrationHistory.objects.all()), [])
-        
-        # Apply them normally
-        migrate_app(migrations, target_name=None, fake=False,
-                    load_initial_data=True)
-        
-        # We should finish with all migrations
-        self.assertListEqual(
-            (("fakeapp", "0001_spam"),
-             ("fakeapp", "0002_eggs"),
-             ("fakeapp", "0003_alter_spam"),),
-            MigrationHistory.objects.values_list("app_name", "migration"),
-        )
-        
-        # Now roll them backwards
-        migrate_app(migrations, target_name="zero", fake=False)
-        
-        # Finish with none
-        self.assertEqual(list(MigrationHistory.objects.all()), [])
-    
-    
-    def test_migration_merge_forwards(self):
-        migrations = Migrations("fakeapp")
-        
-        # We should start with no migrations
-        self.assertEqual(list(MigrationHistory.objects.all()), [])
-        
-        # Insert one in the wrong order
-        MigrationHistory.objects.create(app_name = "fakeapp",
-                                        migration = "0002_eggs",
-                                        applied = datetime.datetime.now())
-        
-        # Did it go in?
-        self.assertListEqual(
-            (("fakeapp", "0002_eggs"),),
-            MigrationHistory.objects.values_list("app_name", "migration"),
-        )
-        
-        # Apply them normally
-        self.assertRaises(exceptions.InconsistentMigrationHistory,
-                          migrate_app,
-                          migrations, target_name=None, fake=False)
-        self.assertRaises(exceptions.InconsistentMigrationHistory,
-                          migrate_app,
-                          migrations, target_name='zero', fake=False)
-        try:
-            migrate_app(migrations, target_name=None, fake=False)
-        except exceptions.InconsistentMigrationHistory as e:
-            self.assertEqual(
-                [
-                    (
-                        migrations['0002_eggs'],
-                        migrations['0001_spam'],
-                    )
-                ],
-                e.problems,
-            )
-        try:
-            migrate_app(migrations, target_name="zero", fake=False)
-        except exceptions.InconsistentMigrationHistory as e:
-            self.assertEqual(
-                [
-                    (
-                        migrations['0002_eggs'],
-                        migrations['0001_spam'],
-                    )
-                ],
-                e.problems,
-            )
-        
-        # Nothing should have changed (no merge mode!)
-        self.assertListEqual(
-            (("fakeapp", "0002_eggs"),),
-            MigrationHistory.objects.values_list("app_name", "migration"),
-        )
-        
-        # Apply with merge
-        migrate_app(migrations, target_name=None, merge=True, fake=False)
-        
-        # We should finish with all migrations
-        self.assertListEqual(
-            (("fakeapp", "0001_spam"),
-             ("fakeapp", "0002_eggs"),
-             ("fakeapp", "0003_alter_spam"),),
-            MigrationHistory.objects.values_list("app_name", "migration"),
-        )
-        
-        # Now roll them backwards
-        migrate_app(migrations, target_name="0002", fake=False)
-        migrate_app(migrations, target_name="0001", fake=True)
-        migrate_app(migrations, target_name="zero", fake=False)
-        
-        # Finish with none
-        self.assertEqual(list(MigrationHistory.objects.all()), [])
-    
-    def test_alter_column_null(self):
-        
-        def null_ok(eat_exception=True):
-            from django.db import connection, transaction
-            # the DBAPI introspection module fails on postgres NULLs.
-            cursor = connection.cursor()
-        
-            # SQLite has weird now()
-            if db.backend_name == "sqlite3":
-                now_func = "DATETIME('NOW')"
-            # So does SQLServer... should we be using a backend attribute?
-            elif db.backend_name == "pyodbc":
-                now_func = "GETDATE()"
-            elif db.backend_name == "oracle":
-                now_func = "SYSDATE"
-            else:
-                now_func = "NOW()"
-            
-            try:
-                if db.backend_name == "pyodbc":
-                    cursor.execute("SET IDENTITY_INSERT southtest_spam ON;")
-                cursor.execute("INSERT INTO southtest_spam (id, weight, expires, name) VALUES (100, NULL, %s, 'whatever');" % now_func)
-            except:
-                if eat_exception:
-                    transaction.rollback()
-                    return False
-                else:
-                    raise
-            else:
-                cursor.execute("DELETE FROM southtest_spam")
-                transaction.commit()
-                return True
-
-        MigrationHistory.objects.all().delete()
-        migrations = Migrations("fakeapp")
-        
-        # by default name is NOT NULL
-        migrate_app(migrations, target_name="0002", fake=False)
-        self.failIf(null_ok())
-        self.assertListEqual(
-            (("fakeapp", "0001_spam"),
-             ("fakeapp", "0002_eggs"),),
-            MigrationHistory.objects.values_list("app_name", "migration"),
-        )
-        
-        # after 0003, it should be NULL
-        migrate_app(migrations, target_name="0003", fake=False)
-        self.assert_(null_ok(False))
-        self.assertListEqual(
-            (("fakeapp", "0001_spam"),
-             ("fakeapp", "0002_eggs"),
-             ("fakeapp", "0003_alter_spam"),),
-            MigrationHistory.objects.values_list("app_name", "migration"),
-        )
-
-        # make sure it is NOT NULL again
-        migrate_app(migrations, target_name="0002", fake=False)
-        self.failIf(null_ok(), 'weight not null after migration')
-        self.assertListEqual(
-            (("fakeapp", "0001_spam"),
-             ("fakeapp", "0002_eggs"),),
-            MigrationHistory.objects.values_list("app_name", "migration"),
-        )
-        
-        # finish with no migrations, otherwise other tests fail...
-        migrate_app(migrations, target_name="zero", fake=False)
-        self.assertEqual(list(MigrationHistory.objects.all()), [])
-    
-    def test_dependencies(self):
-        
-        fakeapp = Migrations("fakeapp")
-        otherfakeapp = Migrations("otherfakeapp")
-        
-        # Test a simple path
-        self.assertEqual([fakeapp['0001_spam'],
-                          fakeapp['0002_eggs'],
-                          fakeapp['0003_alter_spam']],
-                         fakeapp['0003_alter_spam'].forwards_plan())
-        
-        # And a complex one.
-        self.assertEqual(
-            [
-                fakeapp['0001_spam'],
-                otherfakeapp['0001_first'],
-                otherfakeapp['0002_second'],
-                fakeapp['0002_eggs'],
-                fakeapp['0003_alter_spam'],
-                otherfakeapp['0003_third']
-            ],
-            otherfakeapp['0003_third'].forwards_plan(),
-        )
-
-
-class TestMigrationUtils(Monkeypatcher):
-    installed_apps = ["fakeapp", "otherfakeapp"]
-
-    def test_get_app_label(self):
-        self.assertEqual(
-            "southtest",
-            get_app_label(self.create_fake_app("southtest.models")),
-        )
-        self.assertEqual(
-            "baz",
-            get_app_label(self.create_fake_app("foo.bar.baz.models")),
-        )
-
-class TestUtils(unittest.TestCase):
-
-    def test_flatten(self):
-        self.assertEqual([], list(flatten(iter([]))))
-        self.assertEqual([], list(flatten(iter([iter([]), ]))))
-        self.assertEqual([1], list(flatten(iter([1]))))
-        self.assertEqual([1, 2], list(flatten(iter([1, 2]))))
-        self.assertEqual([1, 2], list(flatten(iter([iter([1]), 2]))))
-        self.assertEqual([1, 2], list(flatten(iter([iter([1, 2])]))))
-        self.assertEqual([1, 2, 3], list(flatten(iter([iter([1, 2]), 3]))))
-        self.assertEqual([1, 2, 3],
-                         list(flatten(iter([iter([1]), iter([2]), 3]))))
-        self.assertEqual([1, 2, 3],
-                         list(flatten([[1], [2], 3])))
-
-    def test_depends(self):
-        graph = {'A1': []}
-        self.assertEqual(['A1'],
-                         depends('A1', lambda n: graph[n]))
-        graph = {'A1': [],
-                 'A2': ['A1'],
-                 'A3': ['A2']}
-        self.assertEqual(['A1', 'A2', 'A3'],
-                         depends('A3', lambda n: graph[n]))
-        graph = {'A1': [],
-                 'A2': ['A1'],
-                 'A3': ['A2', 'A1']}
-        self.assertEqual(['A1', 'A2', 'A3'],
-                         depends('A3', lambda n: graph[n]))
-        graph = {'A1': [],
-                 'A2': ['A1'],
-                 'A3': ['A2', 'A1', 'B1'],
-                 'B1': []}
-        self.assertEqual(
-            ['B1', 'A1', 'A2', 'A3'],
-            depends('A3', lambda n: graph[n]),
-        )
-        graph = {'A1': [],
-                 'A2': ['A1'],
-                 'A3': ['A2', 'A1', 'B2'],
-                 'B1': [],
-                 'B2': ['B1']}
-        self.assertEqual(
-            ['B1', 'B2', 'A1', 'A2', 'A3'],
-            depends('A3', lambda n: graph[n]),
-        )
-        graph = {'A1': [],
-                 'A2': ['A1', 'B1'],
-                 'A3': ['A2'],
-                 'B1': ['A1']}
-        self.assertEqual(['A1', 'B1', 'A2', 'A3'],
-                         depends('A3', lambda n: graph[n]))
-        graph = {'A1': [],
-                 'A2': ['A1'],
-                 'A3': ['A2', 'A1', 'B2'],
-                 'B1': [],
-                 'B2': ['B1', 'C1'],
-                 'C1': ['B1']}
-        self.assertEqual(
-            ['B1', 'C1', 'B2', 'A1', 'A2', 'A3'],
-            depends('A3', lambda n: graph[n]),
-        )
-        graph = {'A1': [],
-                 'A2': ['A1'],
-                 'A3': ['A2', 'B2', 'A1', 'C1'],
-                 'B1': ['A1'],
-                 'B2': ['B1', 'C2', 'A1'],
-                 'C1': ['B1'],
-                 'C2': ['C1', 'A1'],
-                 'C3': ['C2']}
-        self.assertEqual(
-            ['A1', 'B1', 'C1', 'C2', 'B2', 'A2', 'A3'],
-            depends('A3', lambda n: graph[n]),
-        )
-
-    def assertCircularDependency(self, trace, target, graph):
-        "Custom assertion that checks a circular dependency is detected correctly."
-        self.assertRaises(
-            exceptions.CircularDependency,
-            depends,
-            target,
-            lambda n: graph[n],
-        )
-        try:
-            depends(target, lambda n: graph[n])
-        except exceptions.CircularDependency as e:
-            self.assertEqual(trace, e.trace)
-
-    def test_depends_cycle(self):
-        graph = {'A1': ['A1']}
-        self.assertCircularDependency(
-            ['A1', 'A1'],
-            'A1',
-            graph,
-        )
-        graph = {'A1': [],
-                 'A2': ['A1', 'A2'],
-                 'A3': ['A2']}
-        self.assertCircularDependency(
-            ['A2', 'A2'],
-            'A3',
-            graph,
-        )
-        graph = {'A1': [],
-                 'A2': ['A1'],
-                 'A3': ['A2', 'A3'],
-                 'A4': ['A3']}
-        self.assertCircularDependency(
-            ['A3', 'A3'],
-            'A4',
-            graph,
-        )
-        graph = {'A1': ['B1'],
-                 'B1': ['A1']}
-        self.assertCircularDependency(
-            ['A1', 'B1', 'A1'],
-            'A1',
-            graph,
-        )
-        graph = {'A1': [],
-                 'A2': ['A1', 'B2'],
-                 'A3': ['A2'],
-                 'B1': [],
-                 'B2': ['B1', 'A2'],
-                 'B3': ['B2']}
-        self.assertCircularDependency(
-            ['A2', 'B2', 'A2'],
-            'A3',
-            graph,
-        )
-        graph = {'A1': [],
-                 'A2': ['A1', 'B3'],
-                 'A3': ['A2'],
-                 'B1': [],
-                 'B2': ['B1', 'A2'],
-                 'B3': ['B2']}
-        self.assertCircularDependency(
-            ['A2', 'B3', 'B2', 'A2'],
-            'A3',
-            graph,
-        )
-        graph = {'A1': [],
-                 'A2': ['A1'],
-                 'A3': ['A2', 'B2'],
-                 'A4': ['A3'],
-                 'B1': ['A3'],
-                 'B2': ['B1']}
-        self.assertCircularDependency(
-            ['A3', 'B2', 'B1', 'A3'],
-            'A4',
-            graph,
-        )
-
-class TestManualChanges(Monkeypatcher):
-    installed_apps = ["fakeapp", "otherfakeapp"]
-
-    def test_suggest_name(self):
-        migrations = Migrations('fakeapp')
-        change = ManualChanges(migrations,
-                               [],
-                               ['fakeapp.slug'],
-                               [])
-        self.assertEquals(change.suggest_name(), 
-                          'add_field_fakeapp_slug')
-
-        change = ManualChanges(migrations,
-                               [],
-                               [],
-                               ['fakeapp.slug'])
-        self.assertEquals(change.suggest_name(), 
-                          'add_index_fakeapp_slug')
diff --git a/src/south/tests/non_managed/__init__.py b/src/south/tests/non_managed/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/non_managed/migrations/__init__.py b/src/south/tests/non_managed/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/non_managed/models.py b/src/south/tests/non_managed/models.py
deleted file mode 100644
index e520d94b70..0000000000
--- a/src/south/tests/non_managed/models.py
+++ /dev/null
@@ -1,16 +0,0 @@
-# -*- coding: UTF-8 -*-
-
-"""
-An app with a model that is not managed for testing that South does
-not try to manage it in any way
-"""
-from django.db import models
-
-class Legacy(models.Model):
-    
-    name = models.CharField(max_length=10)
-    size = models.IntegerField()
-    
-    class Meta:
-        db_table = "legacy_table"
-        managed = False
diff --git a/src/south/tests/otherfakeapp/__init__.py b/src/south/tests/otherfakeapp/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/otherfakeapp/migrations/0001_first.py b/src/south/tests/otherfakeapp/migrations/0001_first.py
deleted file mode 100644
index ad9c09599c..0000000000
--- a/src/south/tests/otherfakeapp/migrations/0001_first.py
+++ /dev/null
@@ -1,15 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-    
-    depends_on = (
-        ("fakeapp", "0001_spam"),
-    )
-    
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/otherfakeapp/migrations/0002_second.py b/src/south/tests/otherfakeapp/migrations/0002_second.py
deleted file mode 100644
index 7c0fb0cf2f..0000000000
--- a/src/south/tests/otherfakeapp/migrations/0002_second.py
+++ /dev/null
@@ -1,11 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-    
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
-
diff --git a/src/south/tests/otherfakeapp/migrations/0003_third.py b/src/south/tests/otherfakeapp/migrations/0003_third.py
deleted file mode 100644
index fa8ed97639..0000000000
--- a/src/south/tests/otherfakeapp/migrations/0003_third.py
+++ /dev/null
@@ -1,14 +0,0 @@
-from south.db import db
-from django.db import models
-
-class Migration:
-    
-    depends_on = (
-        ("fakeapp", "0003_alter_spam"),
-    )
-    
-    def forwards(self):
-        pass
-    
-    def backwards(self):
-        pass
diff --git a/src/south/tests/otherfakeapp/migrations/__init__.py b/src/south/tests/otherfakeapp/migrations/__init__.py
deleted file mode 100644
index e69de29bb2..0000000000
diff --git a/src/south/tests/otherfakeapp/models.py b/src/south/tests/otherfakeapp/models.py
deleted file mode 100644
index 93a4b8edf2..0000000000
--- a/src/south/tests/otherfakeapp/models.py
+++ /dev/null
@@ -1 +0,0 @@
-# This file left intentionally blank.
\ No newline at end of file

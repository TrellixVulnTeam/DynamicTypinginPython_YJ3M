commit 05a54b3625d03ad71c5289e7b2ad0130c0c64d97
Author: Brett Hoerner <brett@bretthoerner.com>
Date:   Fri Dec 8 12:03:27 2017 -0600

    feat(tags): Beginning of v2 backend (setup, create, basic get) (#6637)

diff --git a/src/sentry/api/endpoints/group_details.py b/src/sentry/api/endpoints/group_details.py
index aa2e0faaa0..a0289111c0 100644
--- a/src/sentry/api/endpoints/group_details.py
+++ b/src/sentry/api/endpoints/group_details.py
@@ -217,7 +217,8 @@ class GroupDetailsEndpoint(GroupEndpoint, EnvironmentMixin):
         except Environment.DoesNotExist:
             tags = []
         else:
-            tags = tagstore.get_group_tag_keys(group.id, environment_id, limit=100)
+            tags = tagstore.get_group_tag_keys(
+                group.project_id, group.id, environment_id, limit=100)
 
         participants = list(
             User.objects.filter(
diff --git a/src/sentry/api/endpoints/group_tagkey_details.py b/src/sentry/api/endpoints/group_tagkey_details.py
index ec1b49496c..5dbc01f741 100644
--- a/src/sentry/api/endpoints/group_tagkey_details.py
+++ b/src/sentry/api/endpoints/group_tagkey_details.py
@@ -53,7 +53,8 @@ class GroupTagKeyDetailsEndpoint(GroupEndpoint, EnvironmentMixin):
             raise ResourceDoesNotExist
 
         try:
-            group_tag_key = tagstore.get_group_tag_key(group.id, environment_id, lookup_key)
+            group_tag_key = tagstore.get_group_tag_key(
+                group.project_id, group.id, environment_id, lookup_key)
         except tagstore.GroupTagKeyNotFound:
             raise ResourceDoesNotExist
 
diff --git a/src/sentry/api/endpoints/group_tags.py b/src/sentry/api/endpoints/group_tags.py
index d35d68b9db..2c25b9afeb 100644
--- a/src/sentry/api/endpoints/group_tags.py
+++ b/src/sentry/api/endpoints/group_tags.py
@@ -20,7 +20,7 @@ class GroupTagsEndpoint(GroupEndpoint, EnvironmentMixin):
         except Environment.DoesNotExist:
             group_tag_keys = []
         else:
-            group_tag_keys = tagstore.get_group_tag_keys(group.id, environment_id)
+            group_tag_keys = tagstore.get_group_tag_keys(group.project_id, group.id, environment_id)
 
         # O(N) db access
         data = []
diff --git a/src/sentry/api/endpoints/project_tagkey_details.py b/src/sentry/api/endpoints/project_tagkey_details.py
index f22379d9c9..53bfa94f47 100644
--- a/src/sentry/api/endpoints/project_tagkey_details.py
+++ b/src/sentry/api/endpoints/project_tagkey_details.py
@@ -37,14 +37,7 @@ class ProjectTagKeyDetailsEndpoint(ProjectEndpoint, EnvironmentMixin):
         lookup_key = tagstore.prefix_reserved_key(key)
 
         try:
-            environment_id = self._get_environment_id_from_request(request, project.organization_id)
-        except Environment.DoesNotExist:
-            # if the environment doesn't exist then the tag can't possibly exist
-            raise ResourceDoesNotExist
-
-        try:
-            deleted = tagstore.delete_tag_keys(
-                project.id, lookup_key, environment_id=environment_id)
+            deleted = tagstore.delete_tag_key(project.id, lookup_key)
         except tagstore.TagKeyNotFound:
             raise ResourceDoesNotExist
 
diff --git a/src/sentry/api/serializers/models/release.py b/src/sentry/api/serializers/models/release.py
index 6db2047d1f..8b7b06ad40 100644
--- a/src/sentry/api/serializers/models/release.py
+++ b/src/sentry/api/serializers/models/release.py
@@ -171,10 +171,9 @@ class ReleaseSerializer(Serializer):
             ).distinct())
 
         tags = {}
-        tvs = tagstore.get_tag_values(project_ids,
-                                      environment_id=None,
-                                      key='sentry:release',
-                                      values=[o.version for o in item_list])
+        tvs = tagstore.get_release_tags(project_ids,
+                                        environment_id=None,
+                                        versions=[o.version for o in item_list])
         for tv in tvs:
             val = tags.get(tv.value)
             tags[tv.value] = {
diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index 375ac7f694..8f78c16d5a 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -254,7 +254,7 @@ INSTALLED_APPS = (
     'sentry.analytics.events', 'sentry.nodestore', 'sentry.search', 'sentry.lang.java',
     'sentry.lang.javascript', 'sentry.lang.native', 'sentry.plugins.sentry_interface_types',
     'sentry.plugins.sentry_mail', 'sentry.plugins.sentry_urls', 'sentry.plugins.sentry_useragents',
-    'sentry.plugins.sentry_webhooks', 'social_auth', 'sudo',
+    'sentry.plugins.sentry_webhooks', 'social_auth', 'sudo', 'sentry.tagstore',
 )
 
 import django
diff --git a/src/sentry/models/group.py b/src/sentry/models/group.py
index cf1df33586..0322f45db6 100644
--- a/src/sentry/models/group.py
+++ b/src/sentry/models/group.py
@@ -165,7 +165,7 @@ class GroupManager(BaseManager):
                 'data': data,
             })
 
-            tagstore.incr_group_tag_value_times_seen(group.id, environment.id, key, value, {
+            tagstore.incr_group_tag_value_times_seen(project_id, group.id, environment.id, key, value, {
                 'project_id': project_id,
                 'last_seen': date,
             })
@@ -355,7 +355,7 @@ class Group(Model):
     def get_tags(self):
         if not hasattr(self, '_tag_cache'):
             group_tags = set(
-                [gtk.key for gtk in tagstore.get_group_tag_keys(self.id, environment_id=None)])
+                [gtk.key for gtk in tagstore.get_group_tag_keys(self.project_id, self.id, environment_id=None)])
 
             results = []
             for key in group_tags:
diff --git a/src/sentry/tagstore/base.py b/src/sentry/tagstore/base.py
index f0a8b12296..da07a9c88e 100644
--- a/src/sentry/tagstore/base.py
+++ b/src/sentry/tagstore/base.py
@@ -58,7 +58,7 @@ class TagStorage(Service):
         'get_group_tag_value',
         'get_group_tag_values',
 
-        'delete_tag_keys',
+        'delete_tag_key',
         'delete_all_group_tag_keys',
         'delete_all_group_tag_values',
 
@@ -68,6 +68,7 @@ class TagStorage(Service):
         'get_top_group_tag_values',
         'get_first_release',
         'get_last_release',
+        'get_release_tags',
         'incr_tag_key_values_seen',
         'incr_tag_value_times_seen',
         'incr_group_tag_key_values_seen',
@@ -82,6 +83,80 @@ class TagStorage(Service):
         'get_event_tag_qs',
     )
 
+    def setup_deletions(self, tagkey_model, tagvalue_model, grouptagkey_model,
+                        grouptagvalue_model, eventtag_model):
+        from sentry.deletions import default_manager
+        from sentry.deletions.defaults import BulkModelDeletionTask
+        from sentry.deletions.base import ModelRelation, ModelDeletionTask
+        from sentry.models import Group, Project, Event
+
+        class TagKeyDeletionTask(ModelDeletionTask):
+            def get_child_relations(self, instance):
+                # in bulk
+                model_list = (grouptagvalue_model, grouptagkey_model, tagvalue_model)
+                relations = [
+                    ModelRelation(m, {
+                        'project_id': instance.project_id,
+                        'key': instance.key,
+                    }) for m in model_list
+                ]
+                return relations
+
+            def mark_deletion_in_progress(self, instance_list):
+                for instance in instance_list:
+                    if instance.status != TagKeyStatus.DELETION_IN_PROGRESS:
+                        instance.update(status=TagKeyStatus.DELETION_IN_PROGRESS)
+
+        default_manager.register(tagkey_model, TagKeyDeletionTask)
+        default_manager.register(tagvalue_model, BulkModelDeletionTask)
+        default_manager.register(grouptagkey_model, BulkModelDeletionTask)
+        default_manager.register(grouptagvalue_model, BulkModelDeletionTask)
+        default_manager.register(eventtag_model, BulkModelDeletionTask)
+
+        default_manager.add_dependencies(Group, [
+            lambda instance: ModelRelation(eventtag_model, {'group_id': instance.id}),
+            lambda instance: ModelRelation(grouptagkey_model, {'group_id': instance.id}),
+            lambda instance: ModelRelation(grouptagvalue_model, {'group_id': instance.id}),
+        ])
+        default_manager.add_dependencies(Project, [
+            lambda instance: ModelRelation(tagkey_model, {'project_id': instance.id}),
+            lambda instance: ModelRelation(tagvalue_model, {'project_id': instance.id}),
+            lambda instance: ModelRelation(grouptagkey_model, {'project_id': instance.id}),
+            lambda instance: ModelRelation(grouptagvalue_model, {'project_id': instance.id}),
+        ])
+        default_manager.add_bulk_dependencies(Event, [
+            lambda instance_list: ModelRelation(eventtag_model,
+                                                {'event_id__in': [i.id for i in instance_list]},
+                                                ModelDeletionTask),
+        ])
+
+    def setup_cleanup(self, tagvalue_model, grouptagvalue_model, eventtag_model):
+        from sentry.runner.commands import cleanup
+
+        cleanup.EXTRA_BULK_QUERY_DELETES += [
+            (grouptagvalue_model, 'last_seen', None),
+            (tagvalue_model, 'last_seen', None),
+            (eventtag_model, 'date_added', 'date_added'),
+        ]
+
+    def setup_merge(self, grouptagkey_model, grouptagvalue_model):
+        from sentry.tasks import merge
+
+        merge.EXTRA_MERGE_MODELS += [
+            grouptagvalue_model,
+            grouptagkey_model,
+        ]
+
+    def setup_tasks(self, tagkey_model):
+        from .tasks import setup_tasks
+
+        setup_tasks(tagkey_model=tagkey_model)
+
+    def setup_receivers(self, tagvalue_model, grouptagvalue_model):
+        from .receivers import setup_receivers
+
+        setup_receivers(tagvalue_model=tagvalue_model, grouptagvalue_model=grouptagvalue_model)
+
     def is_valid_key(self, key):
         return bool(TAG_KEY_RE.match(key))
 
@@ -186,10 +261,9 @@ class TagStorage(Service):
         """
         raise NotImplementedError
 
-    def get_tag_keys(self, project_ids, environment_id, keys=None, status=TagKeyStatus.VISIBLE):
+    def get_tag_keys(self, project_id, environment_id, status=TagKeyStatus.VISIBLE):
         """
-        >>> get_tag_key([1, 2], 3, ["key1", "key2"])
-        >>> get_tag_key(1, 3, ["key1", "key2"])
+        >>> get_tag_key(1, 2)
         """
         raise NotImplementedError
 
@@ -199,42 +273,39 @@ class TagStorage(Service):
         """
         raise NotImplementedError
 
-    def get_tag_values(self, project_ids, environment_id, key, values=None):
+    def get_tag_values(self, project_id, environment_id, key):
         """
-        >>> get_tag_values([1, 2], "key1", ["value1, "value2"])
-        >>> get_tag_values(1, "key1", ["value1, "value2"])
+        >>> get_tag_values(1, 2, "key1")
         """
         raise NotImplementedError
 
-    def get_group_tag_key(self, group_id, environment_id, key):
+    def get_group_tag_key(self, project_id, group_id, environment_id, key):
         """
-        >>> get_group_tag_key(1, 2, "key1")
+        >>> get_group_tag_key(1, 2, 3, "key1")
         """
         raise NotImplementedError
 
-    def get_group_tag_keys(self, group_ids, environment_id, keys=None, limit=None):
+    def get_group_tag_keys(self, project_id, group_id, environment_id, limit=None):
         """
-        >>> get_group_tag_keys([1, 2], 3, ["key1", "key2"])
-        >>> get_group_tag_keys(1, 3, ["key1", "key2"])
+        >>> get_group_tag_key(1, 2, 3)
         """
         raise NotImplementedError
 
-    def get_group_tag_value(self, group_id, environment_id, key, value):
+    def get_group_tag_value(self, project_id, group_id, environment_id, key, value):
         """
-        >>> get_group_tag_value(1, 2, "key1", "value1")
+        >>> get_group_tag_value(1, 2, 3, "key1", "value1")
         """
         raise NotImplementedError
 
-    def get_group_tag_values(self, group_ids, environment_id, keys=None, values=None):
+    def get_group_tag_values(self, project_id, group_id, environment_id, key):
         """
-        >>> get_group_tag_values([1, 2], 3, ["key1", "key2"], ["value1", "value2"])
-        >>> get_group_tag_values(1, 3, ["key1", "key2"], ["value1", "value2"])
+        >>> get_group_tag_values(1, 2, 3, "key1")
         """
         raise NotImplementedError
 
-    def delete_tag_keys(self, project_id, keys, environment_id=None):
+    def delete_tag_key(self, project_id, key):
         """
-        >>> delete_tag_keys(1, ["key1"])
+        >>> delete_tag_key(1, "key1")
         """
         raise NotImplementedError
 
@@ -270,9 +341,9 @@ class TagStorage(Service):
         raise NotImplementedError
 
     def incr_group_tag_value_times_seen(
-            self, group_id, environment_id, key, value, extra=None, count=1):
+            self, project_id, group_id, environment_id, key, value, extra=None, count=1):
         """
-        >>> incr_group_tag_value_times_seen(1, 2, "key1", "value1")
+        >>> incr_group_tag_value_times_seen(1, 2, 3, "key1", "value1")
         """
         raise NotImplementedError
 
@@ -324,6 +395,12 @@ class TagStorage(Service):
         """
         raise NotImplementedError
 
+    def get_release_tags(self, project_ids, environment_id, versions):
+        """
+        >>> get_release_tags([1, 2], 3, ["1", "2"])
+        """
+        raise NotImplementedError
+
     def get_group_ids_for_users(self, project_ids, event_users, limit=100):
         """
         >>> get_group_ids_for_users([1,2], [EventUser(1), EventUser(2)])
@@ -348,8 +425,8 @@ class TagStorage(Service):
         """
         raise NotImplementedError
 
-    def update_group_tag_key_values_seen(self, group_ids):
+    def update_group_tag_key_values_seen(self, project_id, group_ids):
         """
-        >>> update_group_tag_key_values_seen([1, 2])
+        >>> update_group_tag_key_values_seen(1, [2, 3])
         """
         raise NotImplementedError
diff --git a/src/sentry/tagstore/legacy/__init__.py b/src/sentry/tagstore/legacy/__init__.py
index 0ca0014862..4a16473e56 100644
--- a/src/sentry/tagstore/legacy/__init__.py
+++ b/src/sentry/tagstore/legacy/__init__.py
@@ -8,5 +8,3 @@ sentry.tagstore.legacy
 from __future__ import absolute_import
 
 from .backend import LegacyTagStorage  # NOQA
-from .receivers import *  # NOQA
-from .tasks import *  # NOQA
diff --git a/src/sentry/tagstore/legacy/backend.py b/src/sentry/tagstore/legacy/backend.py
index f1c963069b..21bbfeccd6 100644
--- a/src/sentry/tagstore/legacy/backend.py
+++ b/src/sentry/tagstore/legacy/backend.py
@@ -19,6 +19,7 @@ from operator import or_
 from six.moves import reduce
 
 from sentry import buffer
+from sentry.signals import buffer_incr_complete
 from sentry.tagstore import TagKeyStatus
 from sentry.tagstore.base import TagStorage
 from sentry.utils import db
@@ -27,49 +28,94 @@ from .models import EventTag, GroupTagKey, GroupTagValue, TagKey, TagValue
 
 
 class LegacyTagStorage(TagStorage):
+    """\
+    The legacy tagstore backend ignores the ``environment_id`` (because it doesn't store this information
+    in its models) and stores ``times_seen`` and ``values_seen`` in Postgres.
+    """
+
     def setup(self):
-        from sentry.deletions import default_manager
-        from sentry.deletions.defaults import BulkModelDeletionTask
-        from sentry.deletions.base import ModelRelation, ModelDeletionTask
-        from sentry.models import Group, Project, Event
-        from sentry.runner.commands import cleanup
-        from sentry.tasks import merge
-
-        from .deletions import TagKeyDeletionTask
-
-        default_manager.register(TagKey, TagKeyDeletionTask)
-        default_manager.register(TagValue, BulkModelDeletionTask)
-        default_manager.register(GroupTagKey, BulkModelDeletionTask)
-        default_manager.register(GroupTagValue, BulkModelDeletionTask)
-        default_manager.register(EventTag, BulkModelDeletionTask)
-
-        default_manager.add_dependencies(Group, [
-            lambda instance: ModelRelation(EventTag, {'group_id': instance.id}),
-            lambda instance: ModelRelation(GroupTagKey, {'group_id': instance.id}),
-            lambda instance: ModelRelation(GroupTagValue, {'group_id': instance.id}),
-        ])
-        default_manager.add_dependencies(Project, [
-            lambda instance: ModelRelation(TagKey, {'project_id': instance.id}),
-            lambda instance: ModelRelation(TagValue, {'project_id': instance.id}),
-            lambda instance: ModelRelation(GroupTagKey, {'project_id': instance.id}),
-            lambda instance: ModelRelation(GroupTagValue, {'project_id': instance.id}),
-        ])
-        default_manager.add_bulk_dependencies(Event, [
-            lambda instance_list: ModelRelation(EventTag,
-                                                {'event_id__in': [i.id for i in instance_list]},
-                                                ModelDeletionTask),
-        ])
-
-        cleanup.EXTRA_BULK_QUERY_DELETES += [
-            (GroupTagValue, 'last_seen', None),
-            (TagValue, 'last_seen', None),
-            (EventTag, 'date_added', 'date_added'),
-        ]
-
-        merge.EXTRA_MERGE_MODELS += [
-            GroupTagValue,
-            GroupTagKey,
-        ]
+        self.setup_deletions(
+            tagkey_model=TagKey,
+            tagvalue_model=TagValue,
+            grouptagkey_model=GroupTagKey,
+            grouptagvalue_model=GroupTagValue,
+            eventtag_model=EventTag,
+        )
+
+        self.setup_cleanup(
+            tagvalue_model=TagValue,
+            grouptagvalue_model=GroupTagValue,
+            eventtag_model=EventTag,
+        )
+
+        self.setup_merge(
+            grouptagkey_model=GroupTagKey,
+            grouptagvalue_model=GroupTagValue,
+        )
+
+        self.setup_tasks(
+            tagkey_model=TagKey,
+        )
+
+        self.setup_receivers(
+            tagvalue_model=TagValue,
+            grouptagvalue_model=GroupTagValue,
+        )
+
+        # Legacy tag write flow:
+        #
+        # event_manager calls index_event_tags:
+        #   for tag in event:
+        #       get_or_create_tag_key
+        #       get_or_create_tag_value
+        #   create_event_tags
+        #
+        # event_manager calls Group.objects.add_tags:
+        #   for tag in event:
+        #       incr_tag_value_times_seen:
+        #           (async) buffer.incr(TagValue):
+        #                create_or_update(TagValue)
+        #                buffer_incr_complete.send_robust(TagValue):
+        #                   record_project_tag_count(TagValue)
+        #                   if created(TagValue):
+        #                       incr_tag_key_values_seen:
+        #                           (async) buffer.incr(TagKey):
+        #                               create_or_update(TagKey)
+        #       incr_group_tag_value_times_seen:
+        #           (async) buffer.incr(GroupTagValue):
+        #                create_or_update(GroupTagValue)
+        #                buffer_incr_complete.send_robust(GroupTagValue)
+        #                   record_project_tag_count(GroupTagValue)
+        #                   if created(GroupTagValue):
+        #                       incr_group_tag_key_values_seen:
+        #                           (async) buffer.incr(GroupTagKey):
+        #                               create_or_update(GroupTagKey)
+
+        @buffer_incr_complete.connect(sender=TagValue, weak=False)
+        def record_project_tag_count(filters, created, **kwargs):
+            from sentry import tagstore
+
+            if not created:
+                return
+
+            project_id = filters['project_id']
+            environment_id = filters.get('environment_id')
+
+            tagstore.incr_tag_key_values_seen(project_id, environment_id, filters['key'])
+
+        @buffer_incr_complete.connect(sender=GroupTagValue, weak=False)
+        def record_group_tag_count(filters, created, extra, **kwargs):
+            from sentry import tagstore
+
+            if not created:
+                return
+
+            project_id = extra['project_id']
+            group_id = filters['group_id']
+            environment_id = filters.get('environment_id')
+
+            tagstore.incr_group_tag_key_values_seen(
+                project_id, group_id, environment_id, filters['key'])
 
     def create_tag_key(self, project_id, environment_id, key, **kwargs):
         return TagKey.objects.create(project_id=project_id, key=key, **kwargs)
@@ -137,21 +183,12 @@ class LegacyTagStorage(TagStorage):
         except TagKey.DoesNotExist:
             raise TagKeyNotFound
 
-    def get_tag_keys(self, project_ids, environment_id, keys=None, status=TagKeyStatus.VISIBLE):
-        if isinstance(project_ids, six.integer_types):
-            qs = TagKey.objects.filter(project_id=project_ids)
-        else:
-            qs = TagKey.objects.filter(project_id__in=project_ids)
+    def get_tag_keys(self, project_id, environment_id, status=TagKeyStatus.VISIBLE):
+        qs = TagKey.objects.filter(project_id=project_id)
 
         if status is not None:
             qs = qs.filter(status=status)
 
-        if keys is not None:
-            if isinstance(keys, six.string_types):
-                qs = qs.filter(key=keys)
-            else:
-                qs = qs.filter(key__in=keys)
-
         return list(qs)
 
     def get_tag_value(self, project_id, environment_id, key, value):
@@ -166,25 +203,15 @@ class LegacyTagStorage(TagStorage):
         except TagValue.DoesNotExist:
             raise TagValueNotFound
 
-    def get_tag_values(self, project_ids, environment_id, key, values=None):
-        qs = TagValue.objects.filter(key=key)
-
-        if isinstance(project_ids, six.integer_types):
-            qs = qs.filter(project_id=project_ids)
-        else:
-            qs = qs.filter(project_id__in=project_ids)
-
+    def get_tag_values(self, project_id, environment_id, key):
         qs = TagValue.objects.filter(
-            project_id__in=project_ids,
-            key=key
+            project_id=project_id,
+            key=key,
         )
 
-        if values is not None:
-            qs = qs.filter(value__in=values)
-
         return list(qs)
 
-    def get_group_tag_key(self, group_id, environment_id, key):
+    def get_group_tag_key(self, project_id, group_id, environment_id, key):
         from sentry.tagstore.exceptions import GroupTagKeyNotFound
 
         try:
@@ -195,24 +222,15 @@ class LegacyTagStorage(TagStorage):
         except GroupTagKey.DoesNotExist:
             raise GroupTagKeyNotFound
 
-    def get_group_tag_keys(self, group_ids, environment_id, keys=None, limit=None):
-        if isinstance(group_ids, six.integer_types):
-            qs = GroupTagKey.objects.filter(group_id=group_ids)
-        else:
-            qs = GroupTagKey.objects.filter(group_id__in=group_ids)
-
-        if keys is not None:
-            if isinstance(keys, six.string_types):
-                qs = qs.filter(key=keys)
-            else:
-                qs = qs.filter(key__in=keys)
+    def get_group_tag_keys(self, project_id, group_id, environment_id, limit=None):
+        qs = GroupTagKey.objects.filter(group_id=group_id)
 
         if limit is not None:
             qs = qs[:limit]
 
         return list(qs)
 
-    def get_group_tag_value(self, group_id, environment_id, key, value):
+    def get_group_tag_value(self, project_id, group_id, environment_id, key, value):
         from sentry.tagstore.exceptions import GroupTagValueNotFound
 
         try:
@@ -224,32 +242,24 @@ class LegacyTagStorage(TagStorage):
         except GroupTagValue.DoesNotExist:
             raise GroupTagValueNotFound
 
-    def get_group_tag_values(self, group_ids, environment_id, keys=None, values=None):
-        if isinstance(group_ids, six.integer_types):
-            qs = GroupTagValue.objects.filter(group_id=group_ids)
-        else:
-            qs = GroupTagValue.objects.filter(group_id__in=group_ids)
-
-        if keys is not None:
-            if isinstance(keys, six.string_types):
-                qs = qs.filter(key=keys)
-            else:
-                qs = qs.filter(key__in=keys)
-
-        if values is not None:
-            if isinstance(values, six.string_types):
-                qs = qs.filter(value=values)
-            else:
-                qs = qs.filter(value__in=values)
+    def get_group_tag_values(self, project_id, group_id, environment_id, key):
+        qs = GroupTagValue.objects.filter(
+            group_id=group_id,
+            key=key,
+        )
 
         return list(qs)
 
-    def delete_tag_keys(self, project_id, keys, environment_id=None):
-        from .tasks import delete_tag_key as delete_tag_key_task
+    def delete_tag_key(self, project_id, key):
+        from sentry.tagstore.tasks import delete_tag_key as delete_tag_key_task
 
-        deleted = []
+        tagkeys_qs = TagKey.objects.filter(
+            project_id=project_id,
+            key=key,
+        )
 
-        for tagkey in self.get_tag_keys(project_id, environment_id, keys, status=None):
+        deleted = []
+        for tagkey in tagkeys_qs:
             updated = TagKey.objects.filter(
                 id=tagkey.id,
                 status=TagKeyStatus.VISIBLE,
@@ -272,41 +282,51 @@ class LegacyTagStorage(TagStorage):
         ).delete()
 
     def incr_tag_key_values_seen(self, project_id, environment_id, key, count=1):
-        buffer.incr(TagKey, {
-            'values_seen': count,
-        }, {
-            'project_id': project_id,
-            'key': key,
-        })
+        buffer.incr(TagKey,
+                    columns={
+                        'values_seen': count,
+                    },
+                    filters={
+                        'project_id': project_id,
+                        'key': key,
+                    })
 
     def incr_tag_value_times_seen(self, project_id, environment_id,
                                   key, value, extra=None, count=1):
-        buffer.incr(TagValue, {
-            'times_seen': count,
-        }, {
-            'project_id': project_id,
-            'key': key,
-            'value': value,
-        }, extra)
+        buffer.incr(TagValue,
+                    columns={
+                        'times_seen': count,
+                    },
+                    filters={
+                        'project_id': project_id,
+                        'key': key,
+                        'value': value,
+                    },
+                    extra=extra)
 
     def incr_group_tag_key_values_seen(self, project_id, group_id, environment_id, key, count=1):
-        buffer.incr(GroupTagKey, {
-            'values_seen': count,
-        }, {
-            'project_id': project_id,
-            'group_id': group_id,
-            'key': key,
-        })
-
-    def incr_group_tag_value_times_seen(
-            self, group_id, environment_id, key, value, extra=None, count=1):
-        buffer.incr(GroupTagValue, {
-            'times_seen': count,
-        }, {
-            'group_id': group_id,
-            'key': key,
-            'value': value,
-        }, extra)
+        buffer.incr(GroupTagKey,
+                    columns={
+                        'values_seen': count,
+                    },
+                    filters={
+                        'project_id': project_id,
+                        'group_id': group_id,
+                        'key': key,
+                    })
+
+    def incr_group_tag_value_times_seen(self, project_id, group_id, environment_id,
+                                        key, value, extra=None, count=1):
+        buffer.incr(GroupTagValue,
+                    columns={
+                        'times_seen': count,
+                    },
+                    filters={
+                        'group_id': group_id,
+                        'key': key,
+                        'value': value,
+                    },
+                    extra=extra)
 
     def get_group_event_ids(self, project_id, group_id, environment_id, tags):
         tagkeys = dict(
@@ -455,6 +475,13 @@ class LegacyTagStorage(TagStorage):
 
         return last_release.value
 
+    def get_release_tags(self, project_ids, environment_id, versions):
+        return list(TagValue.objects.filter(
+            project_id__in=project_ids,
+            key='sentry:release',
+            value__in=versions,
+        ))
+
     def get_group_ids_for_users(self, project_ids, event_users, limit=100):
         return list(GroupTagValue.objects.filter(
             key='sentry:user',
@@ -513,9 +540,13 @@ class LegacyTagStorage(TagStorage):
 
         return matches
 
-    def update_group_tag_key_values_seen(self, group_ids):
-        instances = self.get_group_tag_keys(group_ids, environment_id=None)
-        for instance in instances:
+    def update_group_tag_key_values_seen(self, project_id, group_ids):
+        gtk_qs = GroupTagKey.objects.filter(
+            project_id=project_id,
+            group_id__in=group_ids
+        )
+
+        for instance in gtk_qs:
             instance.update(
                 values_seen=GroupTagValue.objects.filter(
                     project_id=instance.project_id,
diff --git a/src/sentry/tagstore/legacy/deletions.py b/src/sentry/tagstore/legacy/deletions.py
deleted file mode 100644
index 5fce861923..0000000000
--- a/src/sentry/tagstore/legacy/deletions.py
+++ /dev/null
@@ -1,32 +0,0 @@
-"""
-sentry.tagstore.legacy.deletions
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010-2017 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-from __future__ import absolute_import, print_function
-
-from sentry.deletions.base import ModelDeletionTask, ModelRelation
-
-
-class TagKeyDeletionTask(ModelDeletionTask):
-    def get_child_relations(self, instance):
-        from .models import (GroupTagKey, GroupTagValue, TagValue)
-
-        # in bulk
-        model_list = (GroupTagValue, GroupTagKey, TagValue)
-        relations = [
-            ModelRelation(m, {
-                'project_id': instance.project_id,
-                'key': instance.key,
-            }) for m in model_list
-        ]
-        return relations
-
-    def mark_deletion_in_progress(self, instance_list):
-        from sentry.tagstore import TagKeyStatus
-
-        for instance in instance_list:
-            if instance.status != TagKeyStatus.DELETION_IN_PROGRESS:
-                instance.update(status=TagKeyStatus.DELETION_IN_PROGRESS)
diff --git a/src/sentry/tagstore/legacy/receivers.py b/src/sentry/tagstore/legacy/receivers.py
deleted file mode 100644
index 139ff983e3..0000000000
--- a/src/sentry/tagstore/legacy/receivers.py
+++ /dev/null
@@ -1,54 +0,0 @@
-"""
-sentry.tagstore.legacy.receivers
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010-2017 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-from __future__ import absolute_import
-
-from django.db.models.signals import post_save
-
-from sentry.signals import buffer_incr_complete
-from sentry.receivers.releases import ensure_release_exists
-
-from .models import TagValue, GroupTagValue
-
-
-@buffer_incr_complete.connect(sender=TagValue, weak=False)
-def record_project_tag_count(filters, created, **kwargs):
-    from sentry import tagstore
-
-    if not created:
-        return
-
-    # TODO(dcramer): remove in 7.6.x
-    project_id = filters.get('project_id')
-    if not project_id:
-        project_id = filters['project'].id
-
-    environment_id = filters.get('environment_id')
-
-    tagstore.incr_tag_key_values_seen(project_id, environment_id, filters['key'])
-
-
-@buffer_incr_complete.connect(sender=GroupTagValue, weak=False)
-def record_group_tag_count(filters, created, extra, **kwargs):
-    from sentry import tagstore
-
-    if not created:
-        return
-
-    project_id = extra.get('project_id')
-    if not project_id:
-        project_id = extra['project']
-
-    group_id = filters['group_id']
-    environment_id = filters.get('environment_id')
-
-    tagstore.incr_group_tag_key_values_seen(project_id, group_id, environment_id, filters['key'])
-
-
-post_save.connect(
-    ensure_release_exists, sender=TagValue, dispatch_uid="ensure_release_exists", weak=False
-)
diff --git a/src/sentry/tagstore/legacy/tasks.py b/src/sentry/tagstore/legacy/tasks.py
deleted file mode 100644
index 1dfa97a44e..0000000000
--- a/src/sentry/tagstore/legacy/tasks.py
+++ /dev/null
@@ -1,43 +0,0 @@
-"""
-sentry.tagstore.legacy.tasks
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010-2017 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-
-from __future__ import absolute_import
-
-from uuid import uuid4
-
-from sentry.exceptions import DeleteAborted
-from sentry.tasks.base import instrumented_task, retry
-from sentry.tasks.deletion import MAX_RETRIES
-
-
-@instrumented_task(
-    name='sentry.tagstore.legacy.tasks.delete_tag_key',
-    queue='cleanup',
-    default_retry_delay=60 * 5,
-    max_retries=MAX_RETRIES
-)
-@retry(exclude=(DeleteAborted, ))
-def delete_tag_key(object_id, transaction_id=None, **kwargs):
-    from sentry import deletions
-
-    from .models import TagKey
-
-    task = deletions.get(
-        model=TagKey,
-        query={
-            'id': object_id,
-        },
-        transaction_id=transaction_id or uuid4().hex,
-    )
-    has_more = task.chunk()
-    if has_more:
-        delete_tag_key.apply_async(
-            kwargs={'object_id': object_id,
-                    'transaction_id': transaction_id},
-            countdown=15,
-        )
diff --git a/src/sentry/tagstore/models.py b/src/sentry/tagstore/models.py
new file mode 100644
index 0000000000..754e0368e5
--- /dev/null
+++ b/src/sentry/tagstore/models.py
@@ -0,0 +1,18 @@
+"""
+sentry.tagstore.models
+~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2017 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from __future__ import absolute_import
+
+from django.conf import settings
+
+# HACK: This was taken from nodestore.models. Django doesn't play well with our
+# naming schemes, and we prefer our methods ways over Django's limited scoping
+if settings.SENTRY_TAGSTORE.startswith('sentry.tagstore.legacy.LegacyTagStorage'):
+    from sentry.tagstore.legacy.models import *  # NOQA
+elif settings.SENTRY_TAGSTORE.startswith('sentry.tagstore.v2'):
+    from sentry.tagstore.v2.models import *  # NOQA
diff --git a/src/sentry/tagstore/receivers.py b/src/sentry/tagstore/receivers.py
new file mode 100644
index 0000000000..2233846967
--- /dev/null
+++ b/src/sentry/tagstore/receivers.py
@@ -0,0 +1,18 @@
+"""
+sentry.tagstore.receivers
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2017 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+from __future__ import absolute_import
+
+from django.db.models.signals import post_save
+
+from sentry.receivers.releases import ensure_release_exists
+
+
+def setup_receivers(tagvalue_model, grouptagvalue_model):
+    post_save.connect(
+        ensure_release_exists, sender=tagvalue_model, dispatch_uid="ensure_release_exists", weak=False
+    )
diff --git a/src/sentry/tagstore/south_migrations/0001_initial.py b/src/sentry/tagstore/south_migrations/0001_initial.py
new file mode 100644
index 0000000000..0861f23bec
--- /dev/null
+++ b/src/sentry/tagstore/south_migrations/0001_initial.py
@@ -0,0 +1,235 @@
+# -*- coding: utf-8 -*-
+from south.utils import datetime_utils as datetime
+from south.db import db
+from south.v2 import SchemaMigration
+from django.db import models
+
+
+class Migration(SchemaMigration):
+
+    # Flag to indicate if this migration is too risky
+    # to run online and needs to be coordinated for offline
+    is_dangerous = True
+
+    def forwards(self, orm):
+        # Adding model 'EventTag'
+        db.create_table(u'tagstore_eventtag', (
+            ('id', self.gf('sentry.db.models.fields.bounded.BoundedBigAutoField')(primary_key=True)),
+            ('project_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')()),
+            ('environment_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')()),
+            ('group_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')()),
+            ('event_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')()),
+            ('key', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagKey'], db_column='key')),
+            ('value', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagValue'], db_column='value')),
+            ('date_added', self.gf('django.db.models.fields.DateTimeField')(
+                default=datetime.datetime.now, db_index=True)),
+        ))
+        db.send_create_signal('tagstore', ['EventTag'])
+
+        # Adding unique constraint on 'EventTag', fields ['event_id', 'key', 'value']
+        db.create_unique(u'tagstore_eventtag', ['event_id', 'key', 'value'])
+
+        # Adding index on 'EventTag', fields ['project_id', 'key', 'value']
+        db.create_index(u'tagstore_eventtag', ['project_id', 'key', 'value'])
+
+        # Adding index on 'EventTag', fields ['group_id', 'key', 'value']
+        db.create_index(u'tagstore_eventtag', ['group_id', 'key', 'value'])
+
+        # Adding index on 'EventTag', fields ['environment_id', 'key', 'value']
+        db.create_index(u'tagstore_eventtag', ['environment_id', 'key', 'value'])
+
+        # Adding model 'GroupTagKey'
+        db.create_table(u'tagstore_grouptagkey', (
+            ('id', self.gf('sentry.db.models.fields.bounded.BoundedBigAutoField')(primary_key=True)),
+            ('project_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('group_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('environment_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(null=True)),
+            ('_key', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagKey'], db_column='key')),
+            ('values_seen', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(default=0)),
+        ))
+        db.send_create_signal('tagstore', ['GroupTagKey'])
+
+        # Adding unique constraint on 'GroupTagKey', fields ['project_id',
+        # 'group_id', 'environment_id', '_key']
+        db.create_unique(
+            u'tagstore_grouptagkey', [
+                'project_id', 'group_id', 'environment_id', 'key'])
+
+        # Adding model 'GroupTagValue'
+        db.create_table(u'tagstore_grouptagvalue', (
+            ('id', self.gf('sentry.db.models.fields.bounded.BoundedBigAutoField')(primary_key=True)),
+            ('project_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('group_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('environment_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(null=True)),
+            ('times_seen', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(default=0)),
+            ('_key', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagKey'], db_column='key')),
+            ('_value', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagValue'], db_column='value')),
+            ('last_seen', self.gf('django.db.models.fields.DateTimeField')(
+                default=datetime.datetime.now, null=True, db_index=True)),
+            ('first_seen', self.gf('django.db.models.fields.DateTimeField')(
+                default=datetime.datetime.now, null=True, db_index=True)),
+        ))
+        db.send_create_signal('tagstore', ['GroupTagValue'])
+
+        # Adding unique constraint on 'GroupTagValue', fields ['project_id',
+        # 'group_id', 'environment_id', '_key', '_value']
+        db.create_unique(
+            u'tagstore_grouptagvalue', [
+                'project_id', 'group_id', 'environment_id', 'key', 'value'])
+
+        # Adding index on 'GroupTagValue', fields ['project_id', '_key', '_value', 'last_seen']
+        db.create_index(u'tagstore_grouptagvalue', ['project_id', 'key', 'value', 'last_seen'])
+
+        # Adding model 'TagKey'
+        db.create_table(u'tagstore_tagkey', (
+            ('id', self.gf('sentry.db.models.fields.bounded.BoundedBigAutoField')(primary_key=True)),
+            ('project_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('environment_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(null=True)),
+            ('key', self.gf('django.db.models.fields.CharField')(max_length=32)),
+            ('values_seen', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(default=0)),
+            ('status', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(default=0)),
+        ))
+        db.send_create_signal('tagstore', ['TagKey'])
+
+        # Adding unique constraint on 'TagKey', fields ['project_id', 'environment_id', 'key']
+        db.create_unique(u'tagstore_tagkey', ['project_id', 'environment_id', 'key'])
+
+        # Adding model 'TagValue'
+        db.create_table(u'tagstore_tagvalue', (
+            ('id', self.gf('sentry.db.models.fields.bounded.BoundedBigAutoField')(primary_key=True)),
+            ('project_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('environment_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(null=True)),
+            ('_key', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagKey'], db_column='key')),
+            ('value', self.gf('django.db.models.fields.CharField')(max_length=200)),
+            ('data', self.gf('sentry.db.models.fields.gzippeddict.GzippedDictField')(null=True, blank=True)),
+            ('times_seen', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(default=0)),
+            ('last_seen', self.gf('django.db.models.fields.DateTimeField')(
+                default=datetime.datetime.now, null=True, db_index=True)),
+            ('first_seen', self.gf('django.db.models.fields.DateTimeField')(
+                default=datetime.datetime.now, null=True, db_index=True)),
+        ))
+        db.send_create_signal('tagstore', ['TagValue'])
+
+        # Adding unique constraint on 'TagValue', fields ['project_id',
+        # 'environment_id', '_key', 'value']
+        db.create_unique(u'tagstore_tagvalue', ['project_id', 'environment_id', 'key', 'value'])
+
+        # Adding index on 'TagValue', fields ['project_id', '_key', 'last_seen']
+        db.create_index(u'tagstore_tagvalue', ['project_id', 'key', 'last_seen'])
+
+    def backwards(self, orm):
+        # Removing index on 'TagValue', fields ['project_id', '_key', 'last_seen']
+        db.delete_index(u'tagstore_tagvalue', ['project_id', 'key', 'last_seen'])
+
+        # Removing unique constraint on 'TagValue', fields ['project_id',
+        # 'environment_id', '_key', 'value']
+        db.delete_unique(u'tagstore_tagvalue', ['project_id', 'environment_id', 'key', 'value'])
+
+        # Removing unique constraint on 'TagKey', fields ['project_id', 'environment_id', 'key']
+        db.delete_unique(u'tagstore_tagkey', ['project_id', 'environment_id', 'key'])
+
+        # Removing index on 'GroupTagValue', fields ['project_id', '_key', '_value', 'last_seen']
+        db.delete_index(u'tagstore_grouptagvalue', ['project_id', 'key', 'value', 'last_seen'])
+
+        # Removing unique constraint on 'GroupTagValue', fields ['project_id',
+        # 'group_id', 'environment_id', '_key', '_value']
+        db.delete_unique(
+            u'tagstore_grouptagvalue', [
+                'project_id', 'group_id', 'environment_id', 'key', 'value'])
+
+        # Removing unique constraint on 'GroupTagKey', fields ['project_id',
+        # 'group_id', 'environment_id', '_key']
+        db.delete_unique(
+            u'tagstore_grouptagkey', [
+                'project_id', 'group_id', 'environment_id', 'key'])
+
+        # Removing index on 'EventTag', fields ['environment_id', 'key', 'value']
+        db.delete_index(u'tagstore_eventtag', ['environment_id', 'key', 'value'])
+
+        # Removing index on 'EventTag', fields ['group_id', 'key', 'value']
+        db.delete_index(u'tagstore_eventtag', ['group_id', 'key', 'value'])
+
+        # Removing index on 'EventTag', fields ['project_id', 'key', 'value']
+        db.delete_index(u'tagstore_eventtag', ['project_id', 'key', 'value'])
+
+        # Removing unique constraint on 'EventTag', fields ['event_id', 'key', 'value']
+        db.delete_unique(u'tagstore_eventtag', ['event_id', 'key', 'value'])
+
+        # Deleting model 'EventTag'
+        db.delete_table(u'tagstore_eventtag')
+
+        # Deleting model 'GroupTagKey'
+        db.delete_table(u'tagstore_grouptagkey')
+
+        # Deleting model 'GroupTagValue'
+        db.delete_table(u'tagstore_grouptagvalue')
+
+        # Deleting model 'TagKey'
+        db.delete_table(u'tagstore_tagkey')
+
+        # Deleting model 'TagValue'
+        db.delete_table(u'tagstore_tagvalue')
+
+    models = {
+        'tagstore.eventtag': {
+            'Meta': {'unique_together': "(('event_id', 'key', 'value'),)", 'object_name': 'EventTag', 'index_together': "(('project_id', 'key', 'value'), ('group_id', 'key', 'value'), ('environment_id', 'key', 'value'))"},
+            'date_added': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
+            'environment_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {}),
+            'event_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {}),
+            'group_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {}),
+            'id': ('sentry.db.models.fields.bounded.BoundedBigAutoField', [], {'primary_key': 'True'}),
+            'key': ('sentry.db.models.fields.foreignkey.FlexibleForeignKey', [], {'to': "orm['tagstore.TagKey']", 'db_column': "'key'"}),
+            'project_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {}),
+            'value': ('sentry.db.models.fields.foreignkey.FlexibleForeignKey', [], {'to': "orm['tagstore.TagValue']", 'db_column': "'value'"})
+        },
+        'tagstore.grouptagkey': {
+            'Meta': {'unique_together': "(('project_id', 'group_id', 'environment_id', '_key'),)", 'object_name': 'GroupTagKey'},
+            '_key': ('sentry.db.models.fields.foreignkey.FlexibleForeignKey', [], {'to': "orm['tagstore.TagKey']", 'db_column': "'key'"}),
+            'environment_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'null': 'True'}),
+            'group_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'db_index': 'True'}),
+            'id': ('sentry.db.models.fields.bounded.BoundedBigAutoField', [], {'primary_key': 'True'}),
+            'project_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'db_index': 'True'}),
+            'values_seen': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'default': '0'})
+        },
+        'tagstore.grouptagvalue': {
+            'Meta': {'unique_together': "(('project_id', 'group_id', 'environment_id', '_key', '_value'),)", 'object_name': 'GroupTagValue', 'index_together': "(('project_id', '_key', '_value', 'last_seen'),)"},
+            '_key': ('sentry.db.models.fields.foreignkey.FlexibleForeignKey', [], {'to': "orm['tagstore.TagKey']", 'db_column': "'key'"}),
+            '_value': ('sentry.db.models.fields.foreignkey.FlexibleForeignKey', [], {'to': "orm['tagstore.TagValue']", 'db_column': "'value'"}),
+            'environment_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'null': 'True'}),
+            'first_seen': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'db_index': 'True'}),
+            'group_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'db_index': 'True'}),
+            'id': ('sentry.db.models.fields.bounded.BoundedBigAutoField', [], {'primary_key': 'True'}),
+            'last_seen': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'db_index': 'True'}),
+            'project_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'db_index': 'True'}),
+            'times_seen': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'default': '0'})
+        },
+        'tagstore.tagkey': {
+            'Meta': {'unique_together': "(('project_id', 'environment_id', 'key'),)", 'object_name': 'TagKey'},
+            'environment_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'null': 'True'}),
+            'id': ('sentry.db.models.fields.bounded.BoundedBigAutoField', [], {'primary_key': 'True'}),
+            'key': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
+            'project_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'db_index': 'True'}),
+            'status': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'default': '0'}),
+            'values_seen': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'default': '0'})
+        },
+        'tagstore.tagvalue': {
+            'Meta': {'unique_together': "(('project_id', 'environment_id', '_key', 'value'),)", 'object_name': 'TagValue', 'index_together': "(('project_id', '_key', 'last_seen'),)"},
+            '_key': ('sentry.db.models.fields.foreignkey.FlexibleForeignKey', [], {'to': "orm['tagstore.TagKey']", 'db_column': "'key'"}),
+            'data': ('sentry.db.models.fields.gzippeddict.GzippedDictField', [], {'null': 'True', 'blank': 'True'}),
+            'environment_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'null': 'True'}),
+            'first_seen': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'db_index': 'True'}),
+            'id': ('sentry.db.models.fields.bounded.BoundedBigAutoField', [], {'primary_key': 'True'}),
+            'last_seen': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'db_index': 'True'}),
+            'project_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'db_index': 'True'}),
+            'times_seen': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'default': '0'}),
+            'value': ('django.db.models.fields.CharField', [], {'max_length': '200'})
+        }
+    }
+
+    complete_apps = ['tagstore']
diff --git a/src/sentry/tagstore/south_migrations/__init__.py b/src/sentry/tagstore/south_migrations/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/src/sentry/tagstore/tasks.py b/src/sentry/tagstore/tasks.py
new file mode 100644
index 0000000000..94718f84aa
--- /dev/null
+++ b/src/sentry/tagstore/tasks.py
@@ -0,0 +1,50 @@
+"""
+sentry.tagstore.tasks
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2017 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from __future__ import absolute_import
+
+from uuid import uuid4
+
+from sentry.exceptions import DeleteAborted
+from sentry.tasks.base import instrumented_task, retry
+from sentry.tasks.deletion import MAX_RETRIES
+
+
+# initialized below
+delete_tag_key = None
+
+
+def setup_tasks(tagkey_model):
+    global delete_tag_key
+
+    @instrumented_task(
+        name='sentry.tagstore.tasks.delete_tag_key',
+        queue='cleanup',
+        default_retry_delay=60 * 5,
+        max_retries=MAX_RETRIES
+    )
+    @retry(exclude=(DeleteAborted, ))
+    def delete_tag_key_task(object_id, transaction_id=None, **kwargs):
+        from sentry import deletions
+
+        task = deletions.get(
+            model=tagkey_model,
+            query={
+                'id': object_id,
+            },
+            transaction_id=transaction_id or uuid4().hex,
+        )
+        has_more = task.chunk()
+        if has_more:
+            delete_tag_key.apply_async(
+                kwargs={'object_id': object_id,
+                        'transaction_id': transaction_id},
+                countdown=15,
+            )
+
+    delete_tag_key = delete_tag_key_task
diff --git a/src/sentry/tagstore/v2/__init__.py b/src/sentry/tagstore/v2/__init__.py
index 77b9061294..8c0936c64b 100644
--- a/src/sentry/tagstore/v2/__init__.py
+++ b/src/sentry/tagstore/v2/__init__.py
@@ -8,5 +8,3 @@ sentry.tagstore.v2
 from __future__ import absolute_import
 
 from .backend import TagStorage  # NOQA
-# from .receivers import *  # NOQA
-# from .tasks import *  # NOQA
diff --git a/src/sentry/tagstore/v2/backend.py b/src/sentry/tagstore/v2/backend.py
index fdf46787c1..638a3304f7 100644
--- a/src/sentry/tagstore/v2/backend.py
+++ b/src/sentry/tagstore/v2/backend.py
@@ -8,8 +8,308 @@ sentry.tagstore.v2.backend
 
 from __future__ import absolute_import
 
+from django.db import IntegrityError, transaction
+
+from sentry.tagstore import TagKeyStatus
 from sentry.tagstore.base import TagStorage
 
+from .models import EventTag, GroupTagKey, GroupTagValue, TagKey, TagValue
+
 
 class TagStorage(TagStorage):
-    pass
+    """\
+    The v2 tagstore backend stores and respects ``environment_id`` arguments and stores
+    ``times_seen`` and ``values_seen`` in Redis for cheap incr/decrs.
+
+    An ``environment_id`` value of ``None`` is used to keep track of the aggregate value across
+    all environments.
+    """
+
+    def setup(self):
+        self.setup_deletions(
+            tagkey_model=TagKey,
+            tagvalue_model=TagValue,
+            grouptagkey_model=GroupTagKey,
+            grouptagvalue_model=GroupTagValue,
+            eventtag_model=EventTag,
+        )
+
+        self.setup_cleanup(
+            tagvalue_model=TagValue,
+            grouptagvalue_model=GroupTagValue,
+            eventtag_model=EventTag,
+        )
+
+        self.setup_merge(
+            grouptagkey_model=GroupTagKey,
+            grouptagvalue_model=GroupTagValue,
+        )
+
+        self.setup_tasks(
+            tagkey_model=TagKey,
+        )
+
+        self.setup_receivers(
+            tagvalue_model=TagValue,
+            grouptagvalue_model=GroupTagValue,
+        )
+
+        # TODO(brett): v2-specific receivers for keeping environment aggregates up to date
+
+    def create_tag_key(self, project_id, environment_id, key, **kwargs):
+        return TagKey.objects.create(
+            project_id=project_id,
+            environment_id=environment_id,
+            key=key,
+            **kwargs
+        )
+
+    def get_or_create_tag_key(self, project_id, environment_id, key, **kwargs):
+        return TagKey.objects.get_or_create(
+            project_id=project_id,
+            environment_id=environment_id,
+            key=key,
+            **kwargs
+        )
+
+    def create_tag_value(self, project_id, environment_id, key, value, **kwargs):
+        tag_key, _ = self.get_or_create_tag_key(
+            project_id, environment_id, key, **kwargs)
+
+        return TagValue.objects.create(
+            project_id=project_id,
+            environment_id=environment_id,
+            _key_id=tag_key.id,
+            value=value,
+            **kwargs
+        )
+
+    def get_or_create_tag_value(self, project_id, environment_id, key, value, **kwargs):
+        tag_key, _ = self.get_or_create_tag_key(
+            project_id, environment_id, key, **kwargs)
+
+        return TagValue.objects.get_or_create(
+            project_id=project_id,
+            environment_id=environment_id,
+            _key_id=tag_key.id,
+            value=value,
+            **kwargs
+        )
+
+    def create_group_tag_key(self, project_id, group_id, environment_id, key, **kwargs):
+        tag_key, _ = self.get_or_create_tag_key(
+            project_id, environment_id, key, **kwargs)
+
+        return GroupTagKey.objects.create(
+            project_id=project_id,
+            group_id=group_id,
+            environment_id=environment_id,
+            _key_id=tag_key.id,
+            **kwargs
+        )
+
+    def get_or_create_group_tag_key(self, project_id, group_id, environment_id, key, **kwargs):
+        tag_key, _ = self.get_or_create_tag_key(
+            project_id, environment_id, key, **kwargs)
+
+        return GroupTagKey.objects.get_or_create(
+            project_id=project_id,
+            group_id=group_id,
+            environment_id=environment_id,
+            _key_id=tag_key.id,
+            **kwargs
+        )
+
+    def create_group_tag_value(self, project_id, group_id, environment_id, key, value, **kwargs):
+        tag_key, _ = self.get_or_create_tag_key(
+            project_id, environment_id, key, **kwargs)
+
+        tag_value, _ = self.get_or_create_tag_value(
+            project_id, environment_id, key, value, **kwargs)
+
+        return GroupTagValue.objects.create(
+            project_id=project_id,
+            group_id=group_id,
+            environment_id=environment_id,
+            _key_id=tag_key.id,
+            _value_id=tag_value.id,
+            **kwargs
+        )
+
+    def get_or_create_group_tag_value(self, project_id, group_id,
+                                      environment_id, key, value, **kwargs):
+        tag_key, _ = self.get_or_create_tag_key(
+            project_id, environment_id, key, **kwargs)
+
+        tag_value, _ = self.get_or_create_tag_value(
+            project_id, environment_id, key, value, **kwargs)
+
+        return GroupTagValue.objects.get_or_create(
+            project_id=project_id,
+            group_id=group_id,
+            environment_id=environment_id,
+            _key_id=tag_key.id,
+            _value_id=tag_value.id,
+            **kwargs
+        )
+
+    def create_event_tags(self, project_id, group_id, environment_id, event_id, tags):
+        try:
+            # don't let a duplicate break the outer transaction
+            with transaction.atomic():
+                # Tags are bulk inserted because this is an all-or-nothing situation.
+                # Either the whole transaction works, or it doesn't. There's no value
+                # in a partial success where we'd need to replay half of the rows.
+                EventTag.objects.bulk_create([
+                    EventTag(
+                        project_id=project_id,
+                        environment_id=environment_id,
+                        group_id=group_id,
+                        event_id=event_id,
+                        key_id=key_id,
+                        value_id=value_id,
+                    )
+                    for key_id, value_id in tags
+                ])
+        except IntegrityError:
+            pass
+
+    def get_tag_key(self, project_id, environment_id, key, status=TagKeyStatus.VISIBLE):
+        from sentry.tagstore.exceptions import TagKeyNotFound
+
+        qs = TagKey.objects.filter(
+            project_id=project_id,
+            key=key,
+            **self._get_environment_filter(environment_id)
+        )
+
+        if status is not None:
+            qs = qs.filter(status=status)
+
+        try:
+            return qs.get()
+        except TagKey.DoesNotExist:
+            raise TagKeyNotFound
+
+    def get_tag_keys(self, project_id, environment_id, status=TagKeyStatus.VISIBLE):
+        qs = TagKey.objects.filter(
+            project_id=project_id,
+            **self._get_environment_filter(environment_id)
+        )
+
+        if status is not None:
+            qs = qs.filter(status=status)
+
+        return list(qs)
+
+    def get_tag_value(self, project_id, environment_id, key, value):
+        from sentry.tagstore.exceptions import TagValueNotFound
+
+        qs = TagValue.objects.filter(
+            project_id=project_id,
+            _key__key=key,
+            value=value,
+            **self._get_environment_filter(environment_id)
+        )
+
+        try:
+            return qs.get()
+        except TagValue.DoesNotExist:
+            raise TagValueNotFound
+
+    def get_tag_values(self, project_id, environment_id, key):
+        qs = TagValue.objects.filter(
+            project_id=project_id,
+            _key__key=key,
+            **self._get_environment_filter(environment_id)
+        )
+
+        return list(qs)
+
+    def get_group_tag_key(self, project_id, group_id, environment_id, key):
+        from sentry.tagstore.exceptions import GroupTagKeyNotFound
+
+        qs = GroupTagKey.objects.filter(
+            project_id=project_id,
+            group_id=group_id,
+            _key__key=key,
+            **self._get_environment_filter(environment_id)
+        )
+
+        try:
+            return qs.get()
+        except GroupTagKey.DoesNotExist:
+            raise GroupTagKeyNotFound
+
+    def get_group_tag_keys(self, project_id, group_id, environment_id, limit=None):
+        qs = GroupTagKey.objects.filter(
+            group_id=group_id,
+            **self._get_environment_filter(environment_id)
+        )
+
+        if limit is not None:
+            qs = qs[:limit]
+
+        return list(qs)
+
+    def get_group_tag_value(self, project_id, group_id, environment_id, key, value):
+        from sentry.tagstore.exceptions import GroupTagValueNotFound
+
+        qs = GroupTagValue.objects.filter(
+            project_id=project_id,
+            group_id=group_id,
+            _key__key=key,
+            _value__value=value,
+            **self._get_environment_filter(environment_id)
+        )
+
+        try:
+            return qs.get()
+        except GroupTagValue.DoesNotExist:
+            raise GroupTagValueNotFound
+
+    def get_group_tag_values(self, project_id, group_id, environment_id, key):
+        qs = GroupTagValue.objects.filter(
+            group_id=group_id,
+            _key__key=key,
+            **self._get_environment_filter(environment_id)
+        )
+
+        return list(qs)
+
+    def delete_tag_key(self, project_id, key):
+        from sentry.tagstore.tasks import delete_tag_key as delete_tag_key_task
+
+        tagkeys_qs = TagKey.objects.filter(
+            project_id=project_id,
+            key=key,
+        )
+
+        deleted = []
+        for tagkey in tagkeys_qs:
+            updated = TagKey.objects.filter(
+                id=tagkey.id,
+                status=TagKeyStatus.VISIBLE,
+            ).update(status=TagKeyStatus.PENDING_DELETION)
+
+            if updated:
+                delete_tag_key_task.delay(object_id=tagkey.id)
+                deleted.append(tagkey)
+
+        return deleted
+
+    def delete_all_group_tag_keys(self, group_id):
+        GroupTagKey.objects.filter(
+            group_id=group_id,
+        ).delete()
+
+    def delete_all_group_tag_values(self, group_id):
+        GroupTagValue.objects.filter(
+            group_id=group_id,
+        ).delete()
+
+    def _get_environment_filter(self, environment_id):
+        if environment_id is None:
+            return {'environment_id__isnull': True}
+        else:
+            return {'environment_id': environment_id}
diff --git a/src/sentry/tagstore/v2/models/eventtag.py b/src/sentry/tagstore/v2/models/eventtag.py
index 9c457755ae..f8596208ad 100644
--- a/src/sentry/tagstore/v2/models/eventtag.py
+++ b/src/sentry/tagstore/v2/models/eventtag.py
@@ -10,7 +10,7 @@ from __future__ import absolute_import
 from django.db import models
 from django.utils import timezone
 
-from sentry.db.models import (Model, BoundedPositiveIntegerField, sane_repr)
+from sentry.db.models import (Model, BoundedPositiveIntegerField, FlexibleForeignKey, sane_repr)
 
 
 class EventTag(Model):
@@ -20,17 +20,17 @@ class EventTag(Model):
     environment_id = BoundedPositiveIntegerField()
     group_id = BoundedPositiveIntegerField()
     event_id = BoundedPositiveIntegerField()
-    key_id = BoundedPositiveIntegerField()
-    value_id = BoundedPositiveIntegerField()
+    key = FlexibleForeignKey('tagstore.TagKey', db_column='key')
+    value = FlexibleForeignKey('tagstore.TagValue', db_column='value')
     date_added = models.DateTimeField(default=timezone.now, db_index=True)
 
     class Meta:
         app_label = 'tagstore'
-        unique_together = (('event_id', 'key_id', 'value_id'), )
+        unique_together = (('event_id', 'key', 'value'), )
         index_together = (
-            ('project_id', 'key_id', 'value_id'),
-            ('group_id', 'key_id', 'value_id'),
-            ('environment_id', 'key_id', 'value_id'),
+            ('project_id', 'key', 'value'),
+            ('group_id', 'key', 'value'),
+            ('environment_id', 'key', 'value'),
         )
 
-    __repr__ = sane_repr('event_id', 'key_id', 'value_id')
+    __repr__ = sane_repr('event_id', 'key', 'value')
diff --git a/src/sentry/tagstore/v2/models/grouptagkey.py b/src/sentry/tagstore/v2/models/grouptagkey.py
index f70dfc6952..c98086b515 100644
--- a/src/sentry/tagstore/v2/models/grouptagkey.py
+++ b/src/sentry/tagstore/v2/models/grouptagkey.py
@@ -13,7 +13,7 @@ from django.db import router, transaction, DataError
 
 from sentry.api.serializers import Serializer, register
 from sentry.db.models import (
-    Model, BoundedPositiveIntegerField, BaseManager, sane_repr
+    Model, BoundedPositiveIntegerField, BaseManager, FlexibleForeignKey, sane_repr
 )
 
 
@@ -27,23 +27,24 @@ class GroupTagKey(Model):
 
     project_id = BoundedPositiveIntegerField(db_index=True)
     group_id = BoundedPositiveIntegerField(db_index=True)
-    environment_id = BoundedPositiveIntegerField()
-    key_id = BoundedPositiveIntegerField()
-    # values_seen will be in Redis
+    environment_id = BoundedPositiveIntegerField(null=True)
+    _key = FlexibleForeignKey('tagstore.TagKey', db_column='key')
+    values_seen = BoundedPositiveIntegerField(default=0)
 
     objects = BaseManager()
 
     class Meta:
         app_label = 'tagstore'
-        unique_together = (('project_id', 'group_id', 'environment_id', 'key_id'), )
+        unique_together = (('project_id', 'group_id', 'environment_id', '_key'), )
         # TODO: environment index(es)
 
-    __repr__ = sane_repr('project_id', 'group_id', 'environment_id', 'key_id')
+    __repr__ = sane_repr('project_id', 'group_id', 'environment_id', '_key')
 
-    # TODO: key property to fetch actual key string?
+    @property
+    def key(self):
+        return self._key.key
 
     # TODO: this will have to iterate all of the possible environments a group has?
-    # TODO: values_seen will live in Redis
     def merge_counts(self, new_group):
         from sentry.tagstore.v2.models import GroupTagValue
 
diff --git a/src/sentry/tagstore/v2/models/grouptagvalue.py b/src/sentry/tagstore/v2/models/grouptagvalue.py
index 5ad23d4cd1..decfd94328 100644
--- a/src/sentry/tagstore/v2/models/grouptagvalue.py
+++ b/src/sentry/tagstore/v2/models/grouptagvalue.py
@@ -14,7 +14,8 @@ from django.utils import timezone
 
 from sentry.api.serializers import Serializer, register
 from sentry.db.models import (
-    Model, BoundedPositiveIntegerField, BaseManager, sane_repr)
+    Model, BoundedPositiveIntegerField, BaseManager, FlexibleForeignKey, sane_repr
+)
 
 
 class GroupTagValue(Model):
@@ -26,10 +27,10 @@ class GroupTagValue(Model):
 
     project_id = BoundedPositiveIntegerField(db_index=True)
     group_id = BoundedPositiveIntegerField(db_index=True)
-    environment_id = BoundedPositiveIntegerField()
-    # times_seen will live in Redis
-    key_id = BoundedPositiveIntegerField()
-    value_id = BoundedPositiveIntegerField()
+    environment_id = BoundedPositiveIntegerField(null=True)
+    times_seen = BoundedPositiveIntegerField(default=0)
+    _key = FlexibleForeignKey('tagstore.TagKey', db_column='key')
+    _value = FlexibleForeignKey('tagstore.TagValue', db_column='value')
     last_seen = models.DateTimeField(
         default=timezone.now, db_index=True, null=True)
     first_seen = models.DateTimeField(
@@ -39,14 +40,19 @@ class GroupTagValue(Model):
 
     class Meta:
         app_label = 'tagstore'
-        unique_together = (('project_id', 'group_id', 'environment_id', 'key_id', 'value_id'), )
+        unique_together = (('project_id', 'group_id', 'environment_id', '_key', '_value'), )
         # TODO: environment index(es)
-        index_together = (('project_id', 'key_id', 'value_id', 'last_seen'), )
+        index_together = (('project_id', '_key', '_value', 'last_seen'), )
 
-    __repr__ = sane_repr('project_id', 'group_id', 'key_id', 'value_id')
+    __repr__ = sane_repr('project_id', 'group_id', '_key', '_value')
 
-    # TODO: key property to fetch actual key string?
-    # TODO: value property to fetch actual value string?
+    @property
+    def key(self):
+        return self._key.key
+
+    @property
+    def value(self):
+        return self._value.value
 
     def save(self, *args, **kwargs):
         if not self.first_seen:
@@ -54,7 +60,6 @@ class GroupTagValue(Model):
         super(GroupTagValue, self).save(*args, **kwargs)
 
     # TODO: this will have to iterate all of the possible environments a group has?
-    # TODO: times_seen will live in Redis
     def merge_counts(self, new_group):
         try:
             with transaction.atomic(using=router.db_for_write(GroupTagValue)):
diff --git a/src/sentry/tagstore/v2/models/tagkey.py b/src/sentry/tagstore/v2/models/tagkey.py
index a5f469a056..e4dcbfa6c9 100644
--- a/src/sentry/tagstore/v2/models/tagkey.py
+++ b/src/sentry/tagstore/v2/models/tagkey.py
@@ -26,9 +26,9 @@ class TagKey(Model):
     __core__ = False
 
     project_id = BoundedPositiveIntegerField(db_index=True)
-    environment_id = BoundedPositiveIntegerField()
+    environment_id = BoundedPositiveIntegerField(null=True)
     key = models.CharField(max_length=MAX_TAG_KEY_LENGTH)
-    # values_seen will live in Redis
+    values_seen = BoundedPositiveIntegerField(default=0)
     status = BoundedPositiveIntegerField(
         choices=(
             (TagKeyStatus.VISIBLE, _('Visible')),
diff --git a/src/sentry/tagstore/v2/models/tagvalue.py b/src/sentry/tagstore/v2/models/tagvalue.py
index a9a09e724a..e8b6c72eee 100644
--- a/src/sentry/tagstore/v2/models/tagvalue.py
+++ b/src/sentry/tagstore/v2/models/tagvalue.py
@@ -15,7 +15,7 @@ from django.utils import timezone
 from sentry.api.serializers import Serializer, register
 from sentry.constants import MAX_TAG_VALUE_LENGTH
 from sentry.db.models import (
-    Model, BoundedPositiveIntegerField, GzippedDictField, BaseManager, sane_repr
+    Model, BoundedPositiveIntegerField, GzippedDictField, BaseManager, FlexibleForeignKey, sane_repr
 )
 
 
@@ -26,12 +26,11 @@ class TagValue(Model):
     __core__ = False
 
     project_id = BoundedPositiveIntegerField(db_index=True)
-    environment_id = BoundedPositiveIntegerField()
-    key_id = BoundedPositiveIntegerField()
+    environment_id = BoundedPositiveIntegerField(null=True)
+    _key = FlexibleForeignKey('tagstore.TagKey', db_column='key')
     value = models.CharField(max_length=MAX_TAG_VALUE_LENGTH)
-    # TODO: do we even use this anymore?
     data = GzippedDictField(blank=True, null=True)
-    # times_seen will live in Redis
+    times_seen = BoundedPositiveIntegerField(default=0)
     last_seen = models.DateTimeField(
         default=timezone.now, db_index=True, null=True)
     first_seen = models.DateTimeField(
@@ -41,13 +40,15 @@ class TagValue(Model):
 
     class Meta:
         app_label = 'tagstore'
-        unique_together = (('project_id', 'environment_id', 'key_id', 'value'), )
+        unique_together = (('project_id', 'environment_id', '_key', 'value'), )
         # TODO: environment index(es)
-        index_together = (('project_id', 'key_id', 'last_seen'), )
+        index_together = (('project_id', '_key', 'last_seen'), )
 
-    __repr__ = sane_repr('project_id', 'environment_id', 'key_id', 'value')
+    __repr__ = sane_repr('project_id', 'environment_id', '_key', 'value')
 
-    # TODO: key property to fetch actual key string?
+    @property
+    def key(self):
+        return self._key.key
 
     def get_label(self):
         from sentry import tagstore
diff --git a/src/sentry/tasks/post_process.py b/src/sentry/tasks/post_process.py
index 346cd8b9e5..f0abcd7241 100644
--- a/src/sentry/tasks/post_process.py
+++ b/src/sentry/tasks/post_process.py
@@ -126,7 +126,7 @@ def plugin_post_process_group(plugin_slug, event, **kwargs):
     name='sentry.tasks.index_event_tags', default_retry_delay=60 * 5, max_retries=None
 )
 def index_event_tags(organization_id, project_id, event_id, tags,
-                     group_id=None, environment_id=None, **kwargs):
+                     group_id, environment_id, **kwargs):
     from sentry import tagstore
 
     Raven.tags_context({
@@ -136,6 +136,8 @@ def index_event_tags(organization_id, project_id, event_id, tags,
     tag_ids = []
     for key, value in tags:
         tagkey, _ = tagstore.get_or_create_tag_key(project_id, environment_id, key)
+        # TODO(brett): optimization to hand `get_or_create_tag_value` the key_id
+        # so it doesn't have to hit the database for something we just had on hand
         tagvalue, _ = tagstore.get_or_create_tag_value(project_id, environment_id, key, value)
         tag_ids.append((tagkey.id, tagvalue.id))
 
diff --git a/src/sentry/tasks/unmerge.py b/src/sentry/tasks/unmerge.py
index cef3199600..0b9d9abfe7 100644
--- a/src/sentry/tasks/unmerge.py
+++ b/src/sentry/tasks/unmerge.py
@@ -4,7 +4,6 @@ import logging
 from collections import defaultdict
 
 from django.db import transaction
-from django.db.models import F
 
 from sentry import tagstore
 from sentry.app import tsdb
@@ -324,9 +323,14 @@ def repair_tag_data(caches, project, events):
                 )
 
                 if not created:
-                    instance.update(
-                        first_seen=first_seen,
-                        times_seen=F('times_seen') + times_seen,
+                    tagstore.incr_group_tag_value_times_seen(
+                        project_id=project.id,
+                        group_id=group_id,
+                        environment_id=environment.id,
+                        key=key,
+                        value=value,
+                        count=times_seen,
+                        extra={'first_seen': first_seen}
                     )
 
 
@@ -543,7 +547,7 @@ def unmerge(
 
     # If there are no more events to process, we're done with the migration.
     if not events:
-        tagstore.update_group_tag_key_values_seen([source_id, destination_id])
+        tagstore.update_group_tag_key_values_seen(project_id, [source_id, destination_id])
         unlock_hashes(project_id, fingerprints)
         return destination_id
 
diff --git a/tests/integration/tests.py b/tests/integration/tests.py
index 113237196f..ef64f10f19 100644
--- a/tests/integration/tests.py
+++ b/tests/integration/tests.py
@@ -175,8 +175,14 @@ class SentryRemoteTest(TestCase):
 
         assert tagstore.get_tag_key(self.project.id, None, 'foo') is not None
         assert tagstore.get_tag_value(self.project.id, None, 'foo', 'bar') is not None
-        assert tagstore.get_group_tag_key(instance.group_id, None, 'foo') is not None
-        assert tagstore.get_group_tag_value(instance.group_id, None, 'foo', 'bar') is not None
+        assert tagstore.get_group_tag_key(
+            self.project.id, instance.group_id, None, 'foo') is not None
+        assert tagstore.get_group_tag_value(
+            instance.project_id,
+            instance.group_id,
+            None,
+            'foo',
+            'bar') is not None
 
     def test_timestamp(self):
         timestamp = timezone.now().replace(
diff --git a/tests/sentry/api/endpoints/test_project_tagkey_details.py b/tests/sentry/api/endpoints/test_project_tagkey_details.py
index 3027feae2c..0af00291a2 100644
--- a/tests/sentry/api/endpoints/test_project_tagkey_details.py
+++ b/tests/sentry/api/endpoints/test_project_tagkey_details.py
@@ -39,7 +39,7 @@ class ProjectTagKeyDetailsTest(APITestCase):
 
 
 class ProjectTagKeyDeleteTest(APITestCase):
-    @mock.patch('sentry.tagstore.legacy.tasks.delete_tag_key')
+    @mock.patch('sentry.tagstore.tasks.delete_tag_key')
     def test_simple(self, mock_delete_tag_key):
         project = self.create_project()
         tagkey = tagstore.create_tag_key(
diff --git a/tests/sentry/deletions/test_tagkey.py b/tests/sentry/deletions/test_tagkey.py
index e48685eac9..e1e51727d5 100644
--- a/tests/sentry/deletions/test_tagkey.py
+++ b/tests/sentry/deletions/test_tagkey.py
@@ -68,12 +68,12 @@ class DeleteTagKeyTest(TestCase):
             run_deletion(deletion.id)
 
         try:
-            tagstore.get_group_tag_value(group.id, None, key, value)
+            tagstore.get_group_tag_value(group.project_id, group.id, None, key, value)
             assert False  # verify exception thrown
         except tagstore.GroupTagValueNotFound:
             pass
         try:
-            tagstore.get_group_tag_key(group.id, None, key)
+            tagstore.get_group_tag_key(group.project_id, group.id, None, key)
             assert False  # verify exception thrown
         except tagstore.GroupTagKeyNotFound:
             pass
@@ -89,7 +89,8 @@ class DeleteTagKeyTest(TestCase):
             pass
 
         assert tagstore.get_tag_key(project2.id, None, key) is not None
-        assert tagstore.get_group_tag_key(group2.id, None, key) is not None
-        assert tagstore.get_group_tag_value(group2.id, None, key, value) is not None
+        assert tagstore.get_group_tag_key(group2.project_id, group2.id, None, key) is not None
+        assert tagstore.get_group_tag_value(
+            group2.project_id, group2.id, None, key, value) is not None
         assert tagstore.get_event_tag_qs(key_id=tk.id).exists()
         assert tagstore.get_event_tag_qs(key_id=tk2.id).exists()
diff --git a/tests/sentry/manager/tests.py b/tests/sentry/manager/tests.py
index 63127dca05..9942cdc9e6 100644
--- a/tests/sentry/manager/tests.py
+++ b/tests/sentry/manager/tests.py
@@ -25,9 +25,10 @@ class SentryManagerTest(TestCase):
 
         results = sorted(
             tagstore.get_group_tag_values(
+                group.project_id,
                 group.id,
                 environment_id=None,
-                keys=['foo']),
+                key='foo'),
             key=lambda x: x.id)
         assert len(results) == 2
         res = results[0]
@@ -39,9 +40,10 @@ class SentryManagerTest(TestCase):
 
         results = sorted(
             tagstore.get_group_tag_values(
+                group.project_id,
                 group.id,
                 environment_id=None,
-                keys=['biz']),
+                key='biz'),
             key=lambda x: x.id)
         assert len(results) == 1
         res = results[0]
diff --git a/tests/sentry/tagstore/__init__.py b/tests/sentry/tagstore/__init__.py
new file mode 100644
index 0000000000..c3961685ab
--- /dev/null
+++ b/tests/sentry/tagstore/__init__.py
@@ -0,0 +1 @@
+from __future__ import absolute_import
diff --git a/tests/sentry/tagstore/v2/__init__.py b/tests/sentry/tagstore/v2/__init__.py
new file mode 100644
index 0000000000..c3961685ab
--- /dev/null
+++ b/tests/sentry/tagstore/v2/__init__.py
@@ -0,0 +1 @@
+from __future__ import absolute_import
diff --git a/tests/sentry/tagstore/v2/test_backend.py b/tests/sentry/tagstore/v2/test_backend.py
new file mode 100644
index 0000000000..a3b6822d3f
--- /dev/null
+++ b/tests/sentry/tagstore/v2/test_backend.py
@@ -0,0 +1,397 @@
+from __future__ import absolute_import
+
+import pytest
+
+from sentry.testutils import TestCase
+from sentry.tagstore import TagKeyStatus
+from sentry.tagstore.v2.backend import TagStorage
+from sentry.tagstore.v2.models import TagKey, TagValue, GroupTagKey, GroupTagValue, EventTag
+from sentry.tagstore.exceptions import TagKeyNotFound, TagValueNotFound, GroupTagKeyNotFound, GroupTagValueNotFound
+
+
+class V2TagStorage(TestCase):
+    def setUp(self):
+        self.ts = TagStorage()
+
+        self.proj1 = self.create_project()
+        self.proj1group1 = self.create_group(self.proj1)
+        self.proj1env1 = self.create_environment(project=self.proj1)
+        self.proj1env2 = self.create_environment(project=self.proj1)
+        self.proj1group1event1 = self.create_event(project=self.proj1, group=self.proj1group1)
+
+        self.proj2 = self.create_project()
+        self.proj2group1 = self.create_group(self.proj2)
+        self.proj2env1 = self.create_environment(project=self.proj2)
+
+        self.key1 = 'key1'
+        self.value1 = 'value1'
+
+    def test_create_tag_key(self):
+        with pytest.raises(TagKeyNotFound):
+            self.ts.get_tag_key(
+                project_id=self.proj1.id,
+                environment_id=self.proj1env1.id,
+                key=self.key1,
+            )
+
+        assert self.ts.get_tag_keys(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+        ) == []
+
+        tk = self.ts.create_tag_key(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        )
+
+        assert self.ts.get_tag_key(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        ).id == tk.id
+
+        assert self.ts.get_tag_keys(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+        ) == [tk]
+
+        assert TagKey.objects.all().count() == 1
+
+    def test_get_or_create_tag_key(self):
+        tk1, _ = self.ts.get_or_create_tag_key(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        )
+
+        tk2, _ = self.ts.get_or_create_tag_key(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        )
+
+        assert tk1.id == tk2.id
+        assert TagKey.objects.filter(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        ).count() == 1
+        assert TagKey.objects.all().count() == 1
+
+    def test_create_tag_value(self):
+        with pytest.raises(TagValueNotFound):
+            self.ts.get_tag_value(
+                project_id=self.proj1.id,
+                environment_id=self.proj1env1.id,
+                key=self.key1,
+                value=self.value1,
+            )
+
+        assert self.ts.get_tag_values(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        ) == []
+
+        tv = self.ts.create_tag_value(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+            value=self.value1,
+        )
+
+        assert self.ts.get_tag_values(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        ) == [tv]
+
+        assert self.ts.get_tag_value(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+            value=self.value1,
+        ).id == tv.id
+        assert TagKey.objects.all().count() == 1
+        assert TagValue.objects.all().count() == 1
+
+    def test_get_or_create_tag_value(self):
+        tv1, _ = self.ts.get_or_create_tag_value(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+            value=self.value1,
+        )
+
+        tv2, _ = self.ts.get_or_create_tag_value(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+            value=self.value1,
+        )
+
+        assert tv1.id == tv2.id
+
+        tk = TagKey.objects.get(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        )
+
+        assert TagKey.objects.all().count() == 1
+
+        assert TagValue.objects.filter(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            _key_id=tk.id,
+            value=self.value1,
+        ).count() == 1
+        assert TagValue.objects.all().count() == 1
+
+    def test_create_group_tag_key(self):
+        with pytest.raises(GroupTagKeyNotFound):
+            self.ts.get_group_tag_key(
+                project_id=self.proj1.id,
+                group_id=self.proj1group1.id,
+                environment_id=self.proj1env1.id,
+                key=self.key1,
+            )
+
+        assert self.ts.get_group_tag_keys(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+        ) == []
+
+        gtk = self.ts.create_group_tag_key(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        )
+
+        self.ts.get_group_tag_keys(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+        ) == [gtk]
+
+        TagKey.objects.get(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        )
+        assert TagKey.objects.all().count() == 1
+
+        assert self.ts.get_group_tag_key(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        ).id == gtk.id
+        assert GroupTagKey.objects.all().count() == 1
+
+    def test_get_or_create_group_tag_key(self):
+        gtk1, _ = self.ts.get_or_create_group_tag_key(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        )
+
+        gtk2, _ = self.ts.get_or_create_group_tag_key(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        )
+
+        assert gtk1.id == gtk2.id
+
+        tk = TagKey.objects.get(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        )
+        assert TagKey.objects.all().count() == 1
+
+        assert GroupTagKey.objects.filter(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            _key_id=tk.id,
+        ).count() == 1
+        assert GroupTagKey.objects.all().count() == 1
+
+    def test_create_group_tag_value(self):
+        with pytest.raises(GroupTagValueNotFound):
+            self.ts.get_group_tag_value(
+                project_id=self.proj1.id,
+                group_id=self.proj1group1.id,
+                environment_id=self.proj1env1.id,
+                key=self.key1,
+                value=self.value1,
+            )
+
+        assert self.ts.get_group_tag_values(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        ) == []
+
+        gtv = self.ts.create_group_tag_value(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+            value=self.value1,
+        )
+
+        assert self.ts.get_group_tag_values(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        ) == [gtv]
+
+        assert TagKey.objects.all().count() == 1
+        assert TagValue.objects.all().count() == 1
+
+        assert self.ts.get_group_tag_value(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+            value=self.value1,
+        ).id == gtv.id
+        assert GroupTagValue.objects.all().count() == 1
+
+    def test_get_or_create_group_tag_value(self):
+        gtv1, _ = self.ts.get_or_create_group_tag_value(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+            value=self.value1,
+        )
+
+        gtv2, _ = self.ts.get_or_create_group_tag_value(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+            value=self.value1,
+        )
+
+        assert gtv1.id == gtv2.id
+
+        tk = TagKey.objects.get(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        )
+        assert TagKey.objects.all().count() == 1
+
+        tv = TagValue.objects.get(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            _key_id=tk.id,
+            value=self.value1,
+        )
+        assert TagValue.objects.all().count() == 1
+
+        assert GroupTagValue.objects.filter(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            _key_id=tk.id,
+            _value_id=tv.id,
+        ).count() == 1
+        assert GroupTagValue.objects.all().count() == 1
+
+    def test_create_event_tags(self):
+        v1, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k1', 'v1')
+        v2, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k2', 'v2')
+        v3, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k3', 'v3')
+
+        tags = [(v1._key.id, v1.id), (v2._key.id, v2.id), (v3._key.id, v3.id)]
+        self.ts.create_event_tags(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            event_id=self.proj1group1event1.id,
+            tags=tags
+        )
+
+        assert EventTag.objects.count() == 3
+        for (key_id, value_id) in tags:
+            assert EventTag.objects.get(
+                project_id=self.proj1.id,
+                group_id=self.proj1group1.id,
+                environment_id=self.proj1env1.id,
+                event_id=self.proj1group1event1.id,
+                key_id=key_id,
+                value_id=value_id,
+            ) is not None
+
+    def test_delete_tag_key(self):
+        tk1 = self.ts.create_tag_key(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        )
+
+        tk2 = self.ts.create_tag_key(
+            project_id=self.proj1.id,
+            environment_id=self.proj1env2.id,
+            key=self.key1,
+        )
+
+        assert TagKey.objects.filter(
+            project_id=self.proj1.id,
+            status=TagKeyStatus.VISIBLE,
+        ).count() == 2
+
+        deleted = self.ts.delete_tag_key(self.proj1.id, self.key1)
+        assert tk1 in deleted
+        assert tk2 in deleted
+
+        assert TagKey.objects.filter(
+            project_id=self.proj1.id,
+            status=TagKeyStatus.VISIBLE,
+        ).count() == 0
+
+    def test_delete_all_group_tag_keys(self):
+        assert GroupTagKey.objects.count() == 0
+
+        self.ts.create_group_tag_key(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+        )
+
+        assert GroupTagKey.objects.count() == 1
+
+        self.ts.delete_all_group_tag_keys(self.proj1group1.id)
+
+        assert GroupTagKey.objects.count() == 0
+
+    def test_delete_all_group_tag_values(self):
+        assert GroupTagValue.objects.count() == 0
+
+        self.ts.create_group_tag_value(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            key=self.key1,
+            value=self.value1,
+        )
+
+        assert GroupTagValue.objects.count() == 1
+
+        self.ts.delete_all_group_tag_values(self.proj1group1.id)
+
+        assert GroupTagValue.objects.count() == 0
diff --git a/tests/sentry/tasks/test_deletion.py b/tests/sentry/tasks/test_deletion.py
index 6217f6d535..7b28f076bd 100644
--- a/tests/sentry/tasks/test_deletion.py
+++ b/tests/sentry/tasks/test_deletion.py
@@ -184,7 +184,7 @@ class DeleteProjectTest(TestCase):
 
 class DeleteTagKeyTest(TestCase):
     def test_simple(self):
-        from sentry.tagstore.legacy.tasks import delete_tag_key as delete_tag_key_task
+        from sentry.tagstore.tasks import delete_tag_key as delete_tag_key_task
 
         team = self.create_team(name='test', slug='test')
         project = self.create_project(team=team, name='test1', slug='test1')
@@ -245,12 +245,12 @@ class DeleteTagKeyTest(TestCase):
 
             assert tagstore.get_event_tag_qs(key_id=tk.id).exists()
             try:
-                tagstore.get_group_tag_value(group.id, None, key, value)
+                tagstore.get_group_tag_value(group.project_id, group.id, None, key, value)
                 assert False  # verify exception thrown
             except tagstore.GroupTagValueNotFound:
                 pass
             try:
-                tagstore.get_group_tag_key(group.id, None, key)
+                tagstore.get_group_tag_key(group.project_id, group.id, None, key)
                 assert False  # verify exception thrown
             except tagstore.GroupTagKeyNotFound:
                 pass
@@ -266,8 +266,9 @@ class DeleteTagKeyTest(TestCase):
                 pass
 
         assert tagstore.get_tag_key(project2.id, None, key) is not None
-        assert tagstore.get_group_tag_key(group2.id, None, key) is not None
-        assert tagstore.get_group_tag_value(group2.id, None, key, value) is not None
+        assert tagstore.get_group_tag_key(group2.project_id, group2.id, None, key) is not None
+        assert tagstore.get_group_tag_value(
+            group2.project_id, group2.id, None, key, value) is not None
         assert tagstore.get_event_tag_qs(key_id=tk2.id).exists()
 
 
diff --git a/tests/sentry/tasks/test_merge.py b/tests/sentry/tasks/test_merge.py
index a4f508b22f..780a4deda2 100644
--- a/tests/sentry/tasks/test_merge.py
+++ b/tests/sentry/tasks/test_merge.py
@@ -4,6 +4,7 @@ from collections import defaultdict
 from mock import patch
 
 from sentry import tagstore
+from sentry.tagstore.models import GroupTagValue
 from sentry.tasks.merge import merge_group, rehash_group_events
 from sentry.models import Event, Group, GroupMeta, GroupRedirect, UserReport
 from sentry.similarity import _make_index_backend
@@ -122,14 +123,24 @@ class MergeGroupTest(TestCase):
             merge_group(other.id, target.id)
 
         assert not Group.objects.filter(id=other.id).exists()
-        assert len(tagstore.get_group_tag_keys(other.id, None)) == 0
-        assert len(tagstore.get_group_tag_values(other.id, None)) == 0
+        assert len(
+            tagstore.get_group_tag_keys(
+                other.project_id,
+                other.id,
+                environment_id=None)) == 0
+        assert len(
+            GroupTagValue.objects.filter(
+                project_id=other.project_id,
+                group_id=other.id,
+            )) == 0
 
         for key, values_seen in output_group_tag_keys.items():
-            assert tagstore.get_group_tag_key(target.id, None, key).values_seen == values_seen
+            assert tagstore.get_group_tag_key(
+                target.project_id, target.id, environment_id=None, key=key).values_seen == values_seen
 
         for (key, value), times_seen in output_group_tag_values.items():
             assert tagstore.get_group_tag_value(
+                project_id=target.project_id,
                 group_id=target.id,
                 environment_id=None,
                 key=key,
diff --git a/tests/sentry/tasks/test_unmerge.py b/tests/sentry/tasks/test_unmerge.py
index bf433f9cc5..e68fbe08fc 100644
--- a/tests/sentry/tasks/test_unmerge.py
+++ b/tests/sentry/tasks/test_unmerge.py
@@ -13,6 +13,7 @@ from django.utils import timezone
 from mock import patch
 
 from sentry import tagstore
+from sentry.tagstore.models import GroupTagValue
 from sentry.app import tsdb
 from sentry.event_manager import ScoreClause
 from sentry.models import (
@@ -298,7 +299,8 @@ class UnmergeTestCase(TestCase):
             )
 
         assert set(
-            [(gtk.key, gtk.values_seen) for gtk in tagstore.get_group_tag_keys(source.id, None)]
+            [(gtk.key, gtk.values_seen)
+             for gtk in tagstore.get_group_tag_keys(source.project_id, source.id, None)]
         ) == set([
             (u'color', 3),
             (u'environment', 1),
@@ -307,7 +309,11 @@ class UnmergeTestCase(TestCase):
 
         assert set(
             [(gtv.key, gtv.value, gtv.times_seen)
-             for gtv in tagstore.get_group_tag_values(source.id, environment_id=None)]
+             for gtv in
+             GroupTagValue.objects.filter(
+                 project_id=source.project_id,
+                 group_id=source.id,
+            )]
         ) == set([
             (u'color', u'red', 6),
             (u'color', u'green', 6),
@@ -408,7 +414,8 @@ class UnmergeTestCase(TestCase):
         ])
 
         assert set(
-            [(gtk.key, gtk.values_seen) for gtk in tagstore.get_group_tag_keys(source.id, None)]
+            [(gtk.key, gtk.values_seen)
+             for gtk in tagstore.get_group_tag_keys(source.project_id, source.id, None)]
         ) == set([
             (u'color', 3),
             (u'environment', 1),
@@ -418,7 +425,11 @@ class UnmergeTestCase(TestCase):
         assert set(
             [(gtv.key, gtv.value, gtv.times_seen,
               gtv.first_seen, gtv.last_seen)
-             for gtv in tagstore.get_group_tag_values(source.id, environment_id=None)]
+             for gtv in
+             GroupTagValue.objects.filter(
+                project_id=source.project_id,
+                group_id=source.id,
+            )]
         ) == set([
             (u'color', u'red', 4, now + shift(0), now + shift(9), ),
             (u'color', u'green', 3, now + shift(1), now + shift(7), ),
@@ -460,7 +471,7 @@ class UnmergeTestCase(TestCase):
             (u'production', now + shift(10), now + shift(16), ),
         ])
 
-        assert set([(gtk.key, gtk.values_seen) for gtk in tagstore.get_group_tag_keys(source.id, None)]
+        assert set([(gtk.key, gtk.values_seen) for gtk in tagstore.get_group_tag_keys(source.project_id, source.id, None)]
                    ) == set(
             [
                 (u'color', 3),
@@ -472,7 +483,11 @@ class UnmergeTestCase(TestCase):
         assert set(
             [(gtv.key, gtv.value, gtv.times_seen,
               gtv.first_seen, gtv.last_seen)
-             for gtv in tagstore.get_group_tag_values(destination.id, environment_id=None)]
+             for gtv in
+             GroupTagValue.objects.filter(
+                 project_id=destination.project_id,
+                 group_id=destination.id,
+            )]
         ) == set([
             (u'color', u'red', 2, now + shift(12), now + shift(15), ),
             (u'color', u'green', 3, now + shift(10), now + shift(16), ),

commit 436c2105d9fae30a6ff102e7dbeefc72da8dd082
Author: Armin Ronacher <armin.ronacher@active-4.com>
Date:   Wed Feb 15 10:35:20 2017 +0100

    Added frame caching to native

diff --git a/src/sentry/lang/javascript/processor.py b/src/sentry/lang/javascript/processor.py
index b425c63b04..2e81f95737 100644
--- a/src/sentry/lang/javascript/processor.py
+++ b/src/sentry/lang/javascript/processor.py
@@ -625,7 +625,7 @@ class JavaScriptStacktraceProcessor(StacktraceProcessor):
             ])
         return frames
 
-    def preprocess_related_data(self, processing_task):
+    def preprocess_step(self, processing_task):
         frames = self.get_valid_frames()
         if not frames:
             logger.debug('Event %r has no frames with enough context to '
diff --git a/src/sentry/lang/native/plugin.py b/src/sentry/lang/native/plugin.py
index ef88bff450..281c02aa1d 100644
--- a/src/sentry/lang/native/plugin.py
+++ b/src/sentry/lang/native/plugin.py
@@ -14,14 +14,15 @@ from sentry.plugins import Plugin2
 from sentry.lang.native.symbolizer import Symbolizer, SymbolicationFailed
 from sentry.lang.native.utils import \
     find_apple_crash_report_referenced_images, get_sdk_from_event, \
-    find_stacktrace_referenced_images, get_sdk_from_apple_system_info, \
-    cpu_name_from_data, APPLE_SDK_MAPPING
+    get_sdk_from_apple_system_info, cpu_name_from_data, APPLE_SDK_MAPPING
 from sentry.stacktraces import StacktraceProcessor
 from sentry.constants import NATIVE_UNKNOWN_STRING
 
 
 logger = logging.getLogger(__name__)
 
+
+FRAME_CACHE_VERSION = 1
 model_re = re.compile(r'^(\S+?)\d')
 
 APP_BUNDLE_PATHS = (
@@ -362,21 +363,6 @@ class NativeStacktraceProcessor(StacktraceProcessor):
             self.sym.close()
             self.sym = None
 
-    def preprocess_related_data(self, processing_task):
-        if not self.available:
-            return False
-
-        referenced_images = find_stacktrace_referenced_images(
-            self.debug_meta['images'], [
-                x.stacktrace for x in self.stacktrace_infos])
-        self.sym = Symbolizer(self.project, self.debug_meta['images'],
-                              referenced_images=referenced_images)
-
-        # The symbolizer gets a reference to the debug meta's images so
-        # when it resolves the missing vmaddrs it changes them in the data
-        # dict.
-        return self.sym.resolve_missing_vmaddrs()
-
     def find_best_instruction(self, processable_frame):
         """Given a frame, stacktrace info and frame index this returns the
         interpolated instruction address we then use for symbolication later.
@@ -411,44 +397,87 @@ class NativeStacktraceProcessor(StacktraceProcessor):
             'instruction_addr' not in frame
         )
 
+    def preprocess_frame(self, processable_frame, processing_task):
+        instr_addr = self.find_best_instruction(processable_frame)
+        img = self.sym.find_image(instr_addr)
+
+        processable_frame.data = {
+            'instruction_addr': instr_addr,
+        }
+
+        if img is not None:
+            processable_frame.set_cache_key_from_values(
+                FRAME_CACHE_VERSION,
+                processable_frame.data['instruction_addr'],
+                img['uuid'],
+                img['cpu_type'],
+                img['cpu_subtype'],
+                img['image_size'],
+                img['image_addr']
+            )
+
+    def preprocess_step(self, processing_task):
+        if not self.available:
+            return False
+
+        referenced_images = set(
+            pf.data['image']['uuid']
+            for pf in processing_task.iter_processable_frames(self)
+            if pf.cache_value is None)
+
+        self.sym = Symbolizer(self.project, self.debug_meta['images'],
+                              referenced_images=referenced_images)
+
+        # The symbolizer gets a reference to the debug meta's images so
+        # when it resolves the missing vmaddrs it changes them in the data
+        # dict.
+        return self.sym.resolve_missing_vmaddrs()
+
     def process_frame(self, processable_frame, processing_task):
         frame = processable_frame.frame
         errors = []
 
-        # Construct a raw frame that is used by the symbolizer
-        # backend.  We only assemble the bare minimum we need here.
-        sym_input_frame = {
-            'object_name': frame.get('package'),
-            'instruction_addr': self.find_best_instruction(
-                processable_frame),
-            'symbol_name': frame.get('function'),
-            'symbol_addr': frame.get('symbol_addr'),
-        }
-        in_app = self.sym.is_in_app(sym_input_frame)
-
         new_frames = []
         raw_frame = dict(frame)
-        raw_frame['in_app'] = in_app
-
-        try:
-            symbolicated_frames = self.sym.symbolize_frame(
-                sym_input_frame, self.sdk_info, symbolize_inlined=True)
-            if not symbolicated_frames:
-                return None, [raw_frame], []
-        except SymbolicationFailed as e:
-            errors = []
-            if e.is_user_fixable or e.is_sdk_failure:
-                errors.append({
-                    'type': e.type,
-                    'image_uuid': e.image_uuid,
-                    'image_path': e.image_path,
-                    'image_arch': e.image_arch,
-                    'message': e.message,
-                })
-            else:
-                logger.debug('Failed to symbolicate with native backend',
-                             exc_info=True)
-            return None, [raw_frame], errors
+
+        if frame.cache_value is None:
+            # Construct a raw frame that is used by the symbolizer
+            # backend.  We only assemble the bare minimum we need here.
+            sym_input_frame = {
+                'object_name': frame.get('package'),
+                'instruction_addr': processable_frame.data['instruction_addr'],
+                'symbol_name': frame.get('function'),
+                'symbol_addr': frame.get('symbol_addr'),
+            }
+            in_app = self.sym.is_in_app(sym_input_frame)
+            raw_frame['in_app'] = in_app
+            try:
+                symbolicated_frames = self.sym.symbolize_frame(
+                    sym_input_frame, self.sdk_info, symbolize_inlined=True)
+                if not symbolicated_frames:
+                    return None, [raw_frame], []
+            except SymbolicationFailed as e:
+                errors = []
+                if e.is_user_fixable or e.is_sdk_failure:
+                    errors.append({
+                        'type': e.type,
+                        'image_uuid': e.image_uuid,
+                        'image_path': e.image_path,
+                        'image_arch': e.image_arch,
+                        'message': e.message,
+                    })
+                else:
+                    logger.debug('Failed to symbolicate with native backend',
+                                 exc_info=True)
+                return None, [raw_frame], errors
+
+            frame.set_cache_value({
+                'in_app': in_app,
+                'symbolicated_frames': symbolicated_frames,
+            })
+        else:
+            raw_frame['in_app'] = in_app = frame.cache_value['in_app']
+            symbolicated_frames = frame.cache_value['symbolicated_frames']
 
         for sfrm in symbolicated_frames:
             symbol = sfrm.get('symbol_name') or \
diff --git a/src/sentry/lang/native/utils.py b/src/sentry/lang/native/utils.py
index faca263acd..5aefea95a6 100644
--- a/src/sentry/lang/native/utils.py
+++ b/src/sentry/lang/native/utils.py
@@ -42,22 +42,6 @@ def find_apple_crash_report_referenced_images(binary_images, threads):
     return list(to_load)
 
 
-def find_stacktrace_referenced_images(debug_images, stacktraces):
-    image_map = {}
-    for image in debug_images:
-        image_map[image['image_addr']] = image['uuid']
-
-    to_load = set()
-    for stacktrace in stacktraces:
-        for frame in stacktrace['frames']:
-            if 'image_addr' in frame:
-                img_uuid = image_map.get(frame['image_addr'])
-                if img_uuid is not None:
-                    to_load.add(img_uuid)
-
-    return list(to_load)
-
-
 def find_all_stacktraces(data):
     """Given a data dictionary from an event this returns all
     relevant stacktraces in a list.  If a frame contains a raw_stacktrace
diff --git a/src/sentry/stacktraces.py b/src/sentry/stacktraces.py
index 79118b2750..f270dd27bc 100644
--- a/src/sentry/stacktraces.py
+++ b/src/sentry/stacktraces.py
@@ -18,17 +18,79 @@ from six import integer_types, text_type
 logger = logging.getLogger(__name__)
 
 
-ProcessableFrame = namedtuple('ProcessableFrame', [
-    'frame', 'idx', 'processor', 'stacktrace_info', 'cache_key'])
 StacktraceInfo = namedtuple('StacktraceInfo', [
     'stacktrace', 'container', 'platforms'])
 
 
+class ProcessableFrame(object):
+
+    def __init__(self, frame, idx, processor, stacktrace_info):
+        self.frame = frame
+        self.idx = idx
+        self.processor = processor
+        self.stacktrace_info = stacktrace_info
+        self.data = None
+        self.cache_key = None
+        self.cache_value = None
+
+    def __contains__(self, key):
+        return key in self.frame
+
+    def __getitem__(self, key):
+        return self.frame[key]
+
+    def get(self, key, default=None):
+        return self.frame.get(key, default)
+
+    def set_cache_value(self, value):
+        if self.cache_key is not None:
+            cache.set(self.cache_key, value, 3600)
+            return True
+        return False
+
+    def set_cache_key_from_values(self, values):
+        if values is None:
+            self.cache_key = None
+            return
+
+        h = hashlib.md5()
+        h.update((u'%s\xff' % self.processor.__class__.__name__).encode('utf-8'))
+
+        def _hash_value(value):
+            if value is None:
+                h.update(b'\x00')
+            elif value is True:
+                h.update(b'\x01')
+            elif value is False:
+                h.update(b'\x02')
+            elif isinstance(value, integer_types):
+                h.update(b'\x03' + text_type(value).encode('ascii') + b'\x00')
+            elif isinstance(value, (tuple, list)):
+                h.update(b'\x04' + text_type(len(value)).encode('utf-8'))
+                for item in value:
+                    _hash_value(item)
+            elif isinstance(value, dict):
+                h.update(b'\x05' + text_type(len(value)).encode('utf-8'))
+                for k, v in six.iteritems(value):
+                    _hash_value(k)
+                    _hash_value(v)
+            elif isinstance(value, bytes):
+                h.update(b'\x06' + value + b'\x00')
+            elif isinstance(value, text_type):
+                h.update(b'\x07' + value.encode('utf-8') + b'\x00')
+            else:
+                raise TypeError('Invalid value for frame cache')
+
+        for value in values:
+            _hash_value(value)
+
+        self.cache_key = 'pf:%s' % h.hexdigest()
+
+
 class StacktraceProcessingTask(object):
 
-    def __init__(self, processable_stacktraces, frame_cache, processors):
+    def __init__(self, processable_stacktraces, processors):
         self.processable_stacktraces = processable_stacktraces
-        self.frame_cache = frame_cache
         self.processors = processors
 
     def iter_processors(self):
@@ -37,13 +99,11 @@ class StacktraceProcessingTask(object):
     def iter_processable_stacktraces(self):
         return six.iteritems(self.processable_stacktraces)
 
-    def get_frame_cache_data(self, processing_frame):
-        if processing_frame.cache_key:
-            return self.frame_cache.get(processing_frame.cache_key)
-
-    def set_frame_cache_data(self, processing_frame, value):
-        if processing_frame.cache_key:
-            cache.set(processing_frame.cache_key, value, 3600)
+    def iter_processable_frames(self, processor=None):
+        for frames in self.iter_processable_stacktraces():
+            for frame in frames:
+                if processor is None or frame.processor == processor:
+                    yield frame
 
 
 class StacktraceProcessor(object):
@@ -58,23 +118,36 @@ class StacktraceProcessor(object):
     def close(self):
         pass
 
-    def get_frame_cache_attributes(self):
-        return None
-
-    def get_frame_cache_values(self, frame):
-        attributes = self.get_frame_cache_attributes()
-        if attributes is not None:
-            return [(attr, frame.get(attr)) for attr in attributes]
-
-    def preprocess_related_data(self, processing_task):
-        return False
-
     def handles_frame(self, frame, stacktrace_info):
+        """Returns true if this processor can handle this frame.  This is the
+        earliest check and operates on a raw frame and stacktrace info.  If
+        this returns `True` a processable frame is created.
+        """
         return False
 
-    def process_frame(self, processable_frame, processing_task):
+    def preprocess_frame(self, processable_frame):
+        """After a processable frame has been created this method is invoked
+        to give the processor a chance to store additional data to the frame
+        if wanted.  In particular a cache key can be set here.
+        """
         pass
 
+    def process_frame(self, processable_frame, processing_task):
+        """Processes the processable frame and returns a tuple of three
+        lists: ``(frames, raw_frames, errors)`` where frames is the list of
+        processed frames, raw_frames is the list of raw unprocessed frames
+        (which however can also be modified if needed) as well as a list of
+        optional errors.  Each one of the items can be `None` in which case
+        the original input frame is assumed.
+        """
+
+    def preprocess_step(self, processing_task):
+        """After frames are preprocesed but before frame processing kicks in
+        the preprocessing step is run.  This already has access to the cache
+        values on the frames.
+        """
+        return False
+
 
 def find_stacktraces_in_data(data):
     """Finds all stracktraces in a given data blob and returns it
@@ -150,48 +223,6 @@ def get_processors_for_stacktraces(data, infos):
     return processors
 
 
-def _get_frame_cache_key(processor, frame):
-    values = processor.get_frame_cache_values(frame)
-    if values is None:
-        return None
-
-    h = hashlib.md5()
-    h.update((u'%s\xff' % processor.__class__.__name__).encode('utf-8'))
-
-    def _hash_value(value):
-        if value is None:
-            h.update(b'\x00')
-        elif value is True:
-            h.update(b'\x01')
-        elif value is False:
-            h.update(b'\x02')
-        elif isinstance(value, integer_types):
-            h.update(b'\x03' + text_type(value).encode('ascii') + b'\x00')
-        elif isinstance(value, (tuple, list)):
-            h.update(b'\x04' + text_type(len(value)).encode('utf-8'))
-            for item in value:
-                _hash_value(item)
-        elif isinstance(value, dict):
-            h.update(b'\x05' + text_type(len(value)).encode('utf-8'))
-            for k, v in six.iteritems(value):
-                _hash_value(k)
-                _hash_value(v)
-        elif isinstance(value, bytes):
-            h.update(b'\x06' + value + b'\x00')
-        elif isinstance(value, text_type):
-            h.update(b'\x07' + value.encode('utf-8') + b'\x00')
-        else:
-            raise TypeError('Invalid value for frame cache')
-
-    for attr_name, value in values:
-        h.update((u'\xff%s|' % attr_name).encode('utf-8'))
-        value = frame.get(attr_name)
-        h.update(attr_name.encode('ascii') + b'\x00')
-        _hash_value(value)
-
-    return h.hexdigest()
-
-
 def get_processable_frames(stacktrace_info, processors):
     """Returns thin wrappers around the frames in a stacktrace associated
     with the processor for it.
@@ -204,7 +235,7 @@ def get_processable_frames(stacktrace_info, processors):
         if processor is not None:
             rv.append(ProcessableFrame(
                 frame, frame_count - idx - 1, processor,
-                stacktrace_info, _get_frame_cache_key(processor, frame)))
+                stacktrace_info))
     return rv
 
 
@@ -277,6 +308,7 @@ def get_stacktrace_processing_task(infos, processors):
     for info in infos:
         processable_frames = get_processable_frames(info, processors)
         for processable_frame in processable_frames:
+            processable_frame.processor.preprocess_frame(processable_frame)
             by_processor.setdefault(processable_frame.processor, []) \
                 .append(processable_frame)
             by_stacktrace_info.setdefault(processable_frame.stacktrace_info, []) \
@@ -284,9 +316,12 @@ def get_stacktrace_processing_task(infos, processors):
             if processable_frame.cache_key is not None:
                 to_lookup[processable_frame.cache_key] = processable_frame
 
+    frame_cache = lookup_frame_cache(to_lookup)
+    for cache_key, processable_frame in six.iteritems(to_lookup):
+        processable_frames.cache_value = frame_cache.get(cache_key)
+
     return StacktraceProcessingTask(
         processable_stacktraces=by_stacktrace_info,
-        frame_cache=lookup_frame_cache(to_lookup),
         processors=by_processor
     )
 
@@ -312,7 +347,7 @@ def process_stacktraces(data, make_processors=None):
 
         # Preprocess step
         for processor in processing_task.iter_processors():
-            if processor.preprocess_related_data(processing_task):
+            if processor.preprocess_step(processing_task):
                 changed = True
 
         # Process all stacktraces

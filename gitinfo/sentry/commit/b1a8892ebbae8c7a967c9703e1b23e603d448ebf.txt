commit b1a8892ebbae8c7a967c9703e1b23e603d448ebf
Author: David Cramer <dcramer@gmail.com>
Date:   Mon Aug 6 16:44:20 2018 -0700

    Slim down bitfield and remove obscure query support

diff --git a/src/bitfield/__init__.py b/src/bitfield/__init__.py
index 5425137a19..2fad4e7970 100644
--- a/src/bitfield/__init__.py
+++ b/src/bitfield/__init__.py
@@ -4,12 +4,6 @@ django-bitfield
 """
 from __future__ import absolute_import
 
-from bitfield.models import Bit, BitHandler, CompositeBitField, BitField  # NOQA
+from bitfield.models import Bit, BitHandler, BitField  # NOQA
 
 default_app_config = 'bitfield.apps.BitFieldAppConfig'
-
-try:
-    VERSION = __import__('pkg_resources') \
-        .get_distribution('bitfield').version
-except Exception:
-    VERSION = 'unknown'
diff --git a/src/bitfield/models.py b/src/bitfield/models.py
index f24efd23c1..224368a409 100644
--- a/src/bitfield/models.py
+++ b/src/bitfield/models.py
@@ -1,8 +1,5 @@
 from __future__ import absolute_import
 
-import six
-
-from django.db.models import signals
 from django.db.models.fields import BigIntegerField, Field
 
 from bitfield.forms import BitFormField
@@ -140,11 +137,6 @@ class BitField(BigIntegerField):
             value = value.mask
         return int(value)
 
-    # def get_db_prep_save(self, value, connection):
-    #     if isinstance(value, Bit):
-    #         return BitQuerySaveWrapper(self.model._meta.db_table, self.name, value)
-    #     return super(BitField, self).get_db_prep_save(value, connection=connection)
-
     def get_db_prep_lookup(self, lookup_type, value, connection, prepared=False):
         if isinstance(getattr(value, 'expression', None), Bit):
             value = value.expression
@@ -164,8 +156,6 @@ class BitField(BigIntegerField):
         if isinstance(getattr(value, 'expression', None), Bit):
             value = value.expression
         if isinstance(value, Bit):
-            if lookup_type in ('exact', ):
-                return value
             raise TypeError('Lookup type %r not supported with `Bit` type.' % lookup_type)
         return BigIntegerField.get_prep_lookup(self, lookup_type, value)
 
@@ -173,15 +163,6 @@ class BitField(BigIntegerField):
         if isinstance(value, Bit):
             value = value.mask
         if not isinstance(value, BitHandler):
-            # Regression for #1425: fix bad data that was created resulting
-            # in negative values for flags.  Compute the value that would
-            # have been visible ot the application to preserve compatibility.
-            if isinstance(value, six.integer_types) and value < 0:
-                new_value = 0
-                for bit_number, _ in enumerate(self.flags):
-                    new_value |= (value & (2**bit_number))
-                value = new_value
-
             value = BitHandler(value, self.flags, self.labels)
         else:
             # Ensure flags are consistent for unpickling
@@ -198,69 +179,3 @@ try:
     BitField.register_lookup(BitQueryLookupWrapper)
 except AttributeError:
     pass
-
-
-class CompositeBitFieldWrapper(object):
-    def __init__(self, fields):
-        self.fields = fields
-
-    def __getattr__(self, attr):
-        if attr == 'fields':
-            return super(CompositeBitFieldWrapper, self).__getattr__(attr)
-
-        for field in self.fields:
-            if hasattr(field, attr):
-                return getattr(field, attr)
-        raise AttributeError('%s is not a valid flag' % attr)
-
-    def __hasattr__(self, attr):
-        if attr == 'fields':
-            return super(CompositeBitFieldWrapper, self).__hasattr__(attr)
-
-        for field in self.fields:
-            if hasattr(field, attr):
-                return True
-        return False
-
-    def __setattr__(self, attr, value):
-        if attr == 'fields':
-            super(CompositeBitFieldWrapper, self).__setattr__(attr, value)
-            return
-
-        for field in self.fields:
-            if hasattr(field, attr):
-                setattr(field, attr, value)
-                return
-        raise AttributeError('%s is not a valid flag' % attr)
-
-
-class CompositeBitField(object):
-    is_relation = False
-    many_to_many = False
-    concrete = False
-
-    def __init__(self, fields):
-        self.fields = fields
-
-    def contribute_to_class(self, cls, name):
-        self.name = name
-        self.model = cls
-        cls._meta.virtual_fields.append(self)
-
-        signals.class_prepared.connect(self.validate_fields, sender=cls)
-
-        setattr(cls, name, self)
-
-    def validate_fields(self, sender, **kwargs):
-        cls = sender
-        model_fields = dict([(f.name, f) for f in cls._meta.fields if f.name in self.fields])
-        all_flags = sum([model_fields[f].flags for f in self.fields], [])
-        if len(all_flags) != len(set(all_flags)):
-            raise ValueError('BitField flags must be unique.')
-
-    def __get__(self, instance, instance_type=None):
-        fields = [getattr(instance, f) for f in self.fields]
-        return CompositeBitFieldWrapper(fields)
-
-    def __set__(self, *args, **kwargs):
-        raise NotImplementedError('CompositeBitField cannot be set.')
diff --git a/src/bitfield/query.py b/src/bitfield/query.py
index f3d36faf19..9ed05afc06 100644
--- a/src/bitfield/query.py
+++ b/src/bitfield/query.py
@@ -23,9 +23,9 @@ class BitQueryLookupWrapper(object):
 
 try:
     # Django 1.7+
-    from django.db.models.lookups import Exact
+    from django.db.models.lookups import Lookup
 
-    class BitQueryLookupWrapper(Exact):  # NOQA
+    class BitQueryLookupWrapper(Lookup):  # NOQA
         def process_lhs(self, qn, connection, lhs=None):
             lhs_sql, params = super(BitQueryLookupWrapper, self).process_lhs(
                 qn, connection, lhs)
@@ -45,18 +45,3 @@ try:
 
 except ImportError:
     pass
-
-
-class BitQuerySaveWrapper(BitQueryLookupWrapper):
-    def as_sql(self, qn, connection):
-        """
-        Create the proper SQL fragment. This inserts something like
-        "(T0.flags & value) != 0".
-
-        This will be called by Where.as_sql()
-        """
-        if self.bit:
-            return ("%s.%s | %d" % (qn(self.table_alias), qn(self.column), self.bit.mask), [])
-        return (
-            "%s.%s & ~%d" % (qn(self.table_alias), qn(self.column), self.bit.mask), []
-        )
diff --git a/src/bitfield/types.py b/src/bitfield/types.py
index 3e523376ae..0e17d896fe 100644
--- a/src/bitfield/types.py
+++ b/src/bitfield/types.py
@@ -202,6 +202,8 @@ class BitHandler(object):
             raise AttributeError('%s is not a valid flag' % key)
         return self.get_bit(self._keys.index(key))
 
+    __getitem__ = __getattr__
+
     def __setattr__(self, key, value):
         if key.startswith('_'):
             return object.__setattr__(self, key, value)
@@ -209,6 +211,8 @@ class BitHandler(object):
             raise AttributeError('%s is not a valid flag' % key)
         self.set_bit(self._keys.index(key), value)
 
+    __setitem__ = __setattr__
+
     def __iter__(self):
         return self.iteritems()  # NOQA
 
diff --git a/src/sentry/tasks/auth.py b/src/sentry/tasks/auth.py
index f46e45c20b..76968e9ce8 100644
--- a/src/sentry/tasks/auth.py
+++ b/src/sentry/tasks/auth.py
@@ -3,6 +3,7 @@ from __future__ import absolute_import, print_function
 import logging
 
 from django.db import IntegrityError
+from django.db.models import F
 
 from sentry import options
 from sentry.models import (
@@ -29,7 +30,7 @@ def email_missing_links(org_id, actor_id, provider_key, **kwargs):
 
     member_list = OrganizationMember.objects.filter(
         organization=org,
-        flags=~getattr(OrganizationMember.flags, 'sso:linked'),
+        flags=F('flags').bitand(~getattr(OrganizationMember.flags, 'sso:linked')),
     )
     for member in member_list:
         member.send_sso_link_email(actor, provider)
diff --git a/tests/bitfield/models.py b/tests/bitfield/models.py
index 1f68094b96..7503ea8d54 100644
--- a/tests/bitfield/models.py
+++ b/tests/bitfield/models.py
@@ -2,16 +2,10 @@ from __future__ import absolute_import
 
 from django.db import models
 
-from bitfield import BitField, CompositeBitField
+from bitfield import BitField
 
 
 class BitFieldTestModel(models.Model):
     flags = BitField(
         flags=('FLAG_0', 'FLAG_1', 'FLAG_2', 'FLAG_3', ), default=3, db_column='another_name'
     )
-
-
-class CompositeBitFieldTestModel(models.Model):
-    flags_1 = BitField(flags=('FLAG_0', 'FLAG_1', 'FLAG_2', 'FLAG_3', ), default=0)
-    flags_2 = BitField(flags=('FLAG_4', 'FLAG_5', 'FLAG_6', 'FLAG_7', ), default=0)
-    flags = CompositeBitField(('flags_1', 'flags_2', ))
diff --git a/tests/bitfield/tests.py b/tests/bitfield/tests.py
index 9cd6b971e0..48d93eae43 100644
--- a/tests/bitfield/tests.py
+++ b/tests/bitfield/tests.py
@@ -11,7 +11,7 @@ from bitfield import Bit, BitField, BitHandler
 from bitfield.compat import bitand, bitor
 
 from .forms import BitFieldTestModelForm
-from .models import BitFieldTestModel, CompositeBitFieldTestModel
+from .models import BitFieldTestModel
 
 
 class BitHandlerTest(TestCase):
@@ -330,42 +330,6 @@ class BitFieldSerializationTest(TestCase):
         self.assertTrue('FLAG_3' in inst.flags.keys())
 
 
-class CompositeBitFieldTest(TestCase):
-    def test_get_flag(self):
-        inst = CompositeBitFieldTestModel()
-        self.assertEqual(inst.flags.FLAG_0, inst.flags_1.FLAG_0)
-        self.assertEqual(inst.flags.FLAG_4, inst.flags_2.FLAG_4)
-        self.assertRaises(AttributeError, lambda: inst.flags.flag_NA)
-
-    def test_set_flag(self):
-        inst = CompositeBitFieldTestModel()
-
-        flag_0_original = bool(inst.flags.FLAG_0)
-        self.assertEqual(bool(inst.flags_1.FLAG_0), flag_0_original)
-        flag_4_original = bool(inst.flags.FLAG_4)
-        self.assertEqual(bool(inst.flags_2.FLAG_4), flag_4_original)
-
-        # flip flags' bits
-        inst.flags.FLAG_0 = not flag_0_original
-        inst.flags.FLAG_4 = not flag_4_original
-
-        # check to make sure the bit flips took effect
-        self.assertNotEqual(bool(inst.flags.FLAG_0), flag_0_original)
-        self.assertNotEqual(bool(inst.flags_1.FLAG_0), flag_0_original)
-        self.assertNotEqual(bool(inst.flags.FLAG_4), flag_4_original)
-        self.assertNotEqual(bool(inst.flags_2.FLAG_4), flag_4_original)
-
-        def set_flag():
-            inst.flags.flag_NA = False
-
-        self.assertRaises(AttributeError, set_flag)
-
-    def test_hasattr(self):
-        inst = CompositeBitFieldTestModel()
-        self.assertEqual(hasattr(inst.flags, 'flag_0'), hasattr(inst.flags_1, 'flag_0'))
-        self.assertEqual(hasattr(inst.flags, 'flag_4'), hasattr(inst.flags_2, 'flag_4'))
-
-
 class BitFormFieldTest(TestCase):
     def test_form_new_invalid(self):
         invalid_data_dicts = [
diff --git a/tests/sentry/tasks/test_auth.py b/tests/sentry/tasks/test_auth.py
index ea2ce8cf97..731a7dc5e1 100644
--- a/tests/sentry/tasks/test_auth.py
+++ b/tests/sentry/tasks/test_auth.py
@@ -11,22 +11,24 @@ class EmailMissingLinksTest(TestCase):
     def setUp(self):
         super(EmailMissingLinksTest, self).setUp()
         self.user = self.create_user(email='bar@example.com')
-        self.organization = self.create_organization(owner=self.user, name='Test')
+        self.organization = self.create_organization(name='Test')
         self.provider = AuthProvider.objects.create(
             organization=self.organization,
             provider='dummy',
         )
-        OrganizationMember.objects.create_or_update(
+        om = OrganizationMember.objects.create(
             user=self.user,
             organization=self.organization,
-            values={'flags': getattr(OrganizationMember.flags, 'sso:linked')},
+            flags=getattr(OrganizationMember.flags, 'sso:linked'),
         )
+        assert getattr(om.flags, 'sso:linked')
         self.user2 = self.create_user(email='baz@example.com')
-        OrganizationMember.objects.create(
+        om2 = OrganizationMember.objects.create(
             user=self.user2,
             organization=self.organization,
             flags=0,
         )
+        assert not getattr(om2.flags, 'sso:linked')
 
     def test_email_missing_links(self):
         with self.tasks():

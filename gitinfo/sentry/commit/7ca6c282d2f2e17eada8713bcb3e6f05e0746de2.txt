commit 7ca6c282d2f2e17eada8713bcb3e6f05e0746de2
Author: adhiraj <693121+adhiraj@users.noreply.github.com>
Date:   Tue Jun 19 17:34:32 2018 -0700

    Signup with Github initial commit (#8685)
    
    * social login

diff --git a/src/sentry/auth/helper.py b/src/sentry/auth/helper.py
index e92103cfa2..ea784ad219 100644
--- a/src/sentry/auth/helper.py
+++ b/src/sentry/auth/helper.py
@@ -103,12 +103,417 @@ class RedisBackedState(object):
         self._client.setex(self.auth_key, self.EXPIRATION_TTL, json.dumps(state))
 
 
+def handle_existing_identity(auth_provider, provider, organization,
+                             request, state, auth_identity, identity):
+    # TODO(dcramer): this is very similar to attach
+    now = timezone.now()
+    auth_identity.update(
+        data=provider.update_identity(
+            new_data=identity.get('data', {}),
+            current_data=auth_identity.data,
+        ),
+        last_verified=now,
+        last_synced=now,
+    )
+
+    try:
+        member = OrganizationMember.objects.get(
+            user=auth_identity.user,
+            organization=organization,
+        )
+    except OrganizationMember.DoesNotExist:
+        # this is likely the case when someone was removed from the org
+        # but still has access to rejoin
+        member = handle_new_membership(auth_provider, organization, request, auth_identity)
+    else:
+        if getattr(member.flags, 'sso:invalid') or not getattr(member.flags, 'sso:linked'):
+            setattr(member.flags, 'sso:invalid', False)
+            setattr(member.flags, 'sso:linked', True)
+            member.save()
+
+    user = auth_identity.user
+    user.backend = settings.AUTHENTICATION_BACKENDS[0]
+
+    if not auth.login(
+        request,
+        user,
+        after_2fa=request.build_absolute_uri(),
+        organization_id=organization.id
+    ):
+        return HttpResponseRedirect(auth.get_login_redirect(request))
+
+    state.clear()
+    metrics.incr('sso.login-success', tags={'provider': provider.key})
+
+    return HttpResponseRedirect(auth.get_login_redirect(request))
+
+
+def handle_new_membership(auth_provider, organization, request, auth_identity):
+    user = auth_identity.user
+
+    om = OrganizationMember.objects.create(
+        organization=organization,
+        role=organization.default_role,
+        user=user,
+        flags=getattr(OrganizationMember.flags, 'sso:linked'),
+    )
+
+    default_teams = auth_provider.default_teams.all()
+    for team in default_teams:
+        OrganizationMemberTeam.objects.create(
+            team=team,
+            organizationmember=om,
+        )
+
+    AuditLogEntry.objects.create(
+        organization=organization,
+        actor=user,
+        ip_address=request.META['REMOTE_ADDR'],
+        target_object=om.id,
+        target_user=om.user,
+        event=AuditLogEntryEvent.MEMBER_ADD,
+        data=om.get_audit_log_data(),
+    )
+
+    return om
+
+
+@transaction.atomic
+def handle_attach_identity(auth_provider, request, organization, provider, identity, member=None):
+    """
+    Given an already authenticated user, attach or re-attach an identity.
+    """
+    user = request.user
+
+    try:
+        try:
+            # prioritize identifying by the SSO provider's user ID
+            auth_identity = AuthIdentity.objects.get(
+                auth_provider=auth_provider,
+                ident=identity['id'],
+            )
+        except AuthIdentity.DoesNotExist:
+            # otherwise look for an already attached identity
+            # this can happen if the SSO provider's internal ID changes
+            auth_identity = AuthIdentity.objects.get(
+                auth_provider=auth_provider,
+                user=user,
+            )
+    except AuthIdentity.DoesNotExist:
+        auth_identity = AuthIdentity.objects.create(
+            auth_provider=auth_provider,
+            user=user,
+            ident=identity['id'],
+            data=identity.get('data', {}),
+        )
+        auth_is_new = True
+    else:
+        now = timezone.now()
+
+        # TODO(dcramer): this might leave the user with duplicate accounts,
+        # and in that kind of situation its very reasonable that we could
+        # test email addresses + is_managed to determine if we can auto
+        # merge
+        if auth_identity.user != user:
+            # it's possible the user has an existing identity, let's wipe it out
+            # so that the new identifier gets used (other we'll hit a constraint)
+            # violation since one might exist for (provider, user) as well as
+            # (provider, ident)
+            AuthIdentity.objects.exclude(
+                id=auth_identity.id,
+            ).filter(
+                auth_provider=auth_provider,
+                user=user,
+            ).delete()
+
+            # since we've identify an identity which is no longer valid
+            # lets preemptively mark it as such
+            try:
+                other_member = OrganizationMember.objects.get(
+                    user=auth_identity.user_id,
+                    organization=organization,
+                )
+            except OrganizationMember.DoesNotExist:
+                pass
+            else:
+                setattr(other_member.flags, 'sso:invalid', True)
+                setattr(other_member.flags, 'sso:linked', False)
+                other_member.save()
+
+        auth_identity.update(
+            user=user,
+            ident=identity['id'],
+            data=provider.update_identity(
+                new_data=identity.get('data', {}),
+                current_data=auth_identity.data,
+            ),
+            last_verified=now,
+            last_synced=now,
+        )
+        auth_is_new = False
+
+    if member is None:
+        try:
+            member = OrganizationMember.objects.get(
+                user=user,
+                organization=organization,
+            )
+        except OrganizationMember.DoesNotExist:
+            member = OrganizationMember.objects.create(
+                organization=organization,
+                role=organization.default_role,
+                user=user,
+                flags=getattr(OrganizationMember.flags, 'sso:linked'),
+            )
+
+            default_teams = auth_provider.default_teams.all()
+            for team in default_teams:
+                OrganizationMemberTeam.objects.create(
+                    team=team,
+                    organizationmember=member,
+                )
+
+            AuditLogEntry.objects.create(
+                organization=organization,
+                actor=user,
+                ip_address=request.META['REMOTE_ADDR'],
+                target_object=member.id,
+                target_user=user,
+                event=AuditLogEntryEvent.MEMBER_ADD,
+                data=member.get_audit_log_data(),
+            )
+    if getattr(member.flags, 'sso:invalid') or not getattr(member.flags, 'sso:linked'):
+        setattr(member.flags, 'sso:invalid', False)
+        setattr(member.flags, 'sso:linked', True)
+        member.save()
+
+    if auth_is_new:
+        AuditLogEntry.objects.create(
+            organization=organization,
+            actor=user,
+            ip_address=request.META['REMOTE_ADDR'],
+            target_object=auth_identity.id,
+            event=AuditLogEntryEvent.SSO_IDENTITY_LINK,
+            data=auth_identity.get_audit_log_data(),
+        )
+
+        messages.add_message(
+            request,
+            messages.SUCCESS,
+            OK_LINK_IDENTITY,
+        )
+
+    return auth_identity
+
+
+def get_display_name(identity):
+    return identity.get('name') or identity.get('email')
+
+
+def get_identifier(identity):
+    return identity.get('email') or identity.get('id')
+
+
+def respond(template, organization, request, context=None, status=200):
+    default_context = {
+        'organization': organization,
+    }
+    if context:
+        default_context.update(context)
+
+    return render_to_response(template, default_context, request, status=status)
+
+
+def handle_unknown_identity(request, organization, auth_provider, provider, state, identity):
+    """
+    Flow is activated upon a user logging in to where an AuthIdentity is
+    not present.
+
+    XXX(dcramer): this docstring is out of date
+
+    The flow will attempt to answer the following:
+
+    - Is there an existing user with the same email address? Should they be
+      merged?
+
+    - Is there an existing user (via authentication) that should be merged?
+
+    - Should I create a new user based on this identity?
+    """
+    op = request.POST.get('op')
+    if not request.user.is_authenticated():
+        # TODO(dcramer): its possible they have multiple accounts and at
+        # least one is managed (per the check below)
+        try:
+            acting_user = User.objects.filter(
+                id__in=UserEmail.objects.filter(email__iexact=identity['email']).values('user'),
+                is_active=True,
+            ).first()
+        except IndexError:
+            acting_user = None
+        login_form = AuthenticationForm(
+            request,
+            request.POST if request.POST.get('op') == 'login' else None,
+            initial={
+                'username': acting_user.username if acting_user else None,
+            },
+        )
+    else:
+        acting_user = request.user
+
+    # If they already have an SSO account and the identity provider says
+    # the email matches we go ahead and let them merge it. This is the
+    # only way to prevent them having duplicate accounts, and because
+    # we trust identity providers, its considered safe.
+    # Note: we do not trust things like SAML, so the SSO implementation needs
+    # to consider if 'email_verified' can be trusted or not
+    if acting_user and identity.get('email_verified'):
+        # we only allow this flow to happen if the existing user has
+        # membership, otherwise we short circuit because it might be
+        # an attempt to hijack membership of another organization
+        has_membership = OrganizationMember.objects.filter(
+            user=acting_user,
+            organization=organization,
+        ).exists()
+        if has_membership:
+            if not auth.login(
+                request,
+                acting_user,
+                after_2fa=request.build_absolute_uri(),
+                organization_id=organization.id
+            ):
+                if acting_user.has_usable_password():
+                    return HttpResponseRedirect(auth.get_login_redirect(request))
+                else:
+                    acting_user = None
+            else:
+                # assume they've confirmed they want to attach the identity
+                op = 'confirm'
+        else:
+            # force them to create a new account
+            acting_user = None
+    # without a usable password they cant login, so let's clear the acting_user
+    elif acting_user and not acting_user.has_usable_password():
+        acting_user = None
+
+    if op == 'confirm' and request.user.is_authenticated():
+        auth_identity = handle_attach_identity(
+            auth_provider,
+            request,
+            organization,
+            provider,
+            identity,
+        )
+    elif op == 'newuser':
+        auth_identity = handle_new_user(auth_provider, organization, request, identity)
+    elif op == 'login' and not request.user.is_authenticated():
+        # confirm authentication, login
+        op = None
+        if login_form.is_valid():
+            # This flow is special.  If we are going through a 2FA
+            # flow here (login returns False) we want to instruct the
+            # system to return upon completion of the 2fa flow to the
+            # current URL and continue with the dialog.
+            #
+            # If there is no 2fa we don't need to do this and can just
+            # go on.
+            if not auth.login(
+                request,
+                login_form.get_user(),
+                after_2fa=request.build_absolute_uri(),
+                organization_id=organization.id
+            ):
+                return HttpResponseRedirect(auth.get_login_redirect(request))
+        else:
+            auth.log_auth_failure(request, request.POST.get('username'))
+    else:
+        op = None
+
+    if not op:
+        if request.user.is_authenticated():
+            return respond(
+                'sentry/auth-confirm-link.html',
+                organization,
+                request,
+                {
+                    'identity': identity,
+                    'existing_user': request.user,
+                    'identity_display_name': get_display_name(identity),
+                    'identity_identifier': get_identifier(identity)
+                },
+            )
+
+        return respond(
+            'sentry/auth-confirm-identity.html',
+            organization,
+            request,
+            {
+                'existing_user': acting_user,
+                'identity': identity,
+                'login_form': login_form,
+                'identity_display_name': get_display_name(identity),
+                'identity_identifier': get_identifier(identity)
+            },
+        )
+
+    user = auth_identity.user
+    user.backend = settings.AUTHENTICATION_BACKENDS[0]
+
+    # XXX(dcramer): this is repeated from above
+    if not auth.login(
+        request,
+        user,
+        after_2fa=request.build_absolute_uri(),
+        organization_id=organization.id
+    ):
+        return HttpResponseRedirect(auth.get_login_redirect(request))
+
+    state.clear()
+
+    return HttpResponseRedirect(auth.get_login_redirect(request))
+
+
+def handle_new_user(auth_provider, organization, request, identity):
+    user = User.objects.create(
+        username=uuid4().hex,
+        email=identity['email'],
+        name=identity.get('name', '')[:200],
+    )
+
+    if settings.TERMS_URL and settings.PRIVACY_URL:
+        user.update(flags=F('flags').bitor(User.flags.newsletter_consent_prompt))
+
+    try:
+        with transaction.atomic():
+            auth_identity = AuthIdentity.objects.create(
+                auth_provider=auth_provider,
+                user=user,
+                ident=identity['id'],
+                data=identity.get('data', {}),
+            )
+    except IntegrityError:
+        auth_identity = AuthIdentity.objects.get(
+            auth_provider=auth_provider,
+            ident=identity['id'],
+        )
+        auth_identity.update(
+            user=user,
+            data=identity.get('data', {}),
+        )
+
+    user.send_confirm_emails(is_new_user=True)
+
+    handle_new_membership(auth_provider, organization, request, auth_identity)
+
+    return auth_identity
+
+
 class AuthHelper(object):
     """
     Helper class which is passed into AuthView's.
 
     Designed to link provider and views as well as manage the state and
-    pipeline.
+    pipeline. The pipeline is optional, in case can be done
 
     Auth has several flows:
 
@@ -249,397 +654,6 @@ class AuthHelper(object):
 
         return response
 
-    @transaction.atomic
-    def _handle_attach_identity(self, identity, member=None):
-        """
-        Given an already authenticated user, attach or re-attach an identity.
-        """
-        auth_provider = self.auth_provider
-        request = self.request
-        user = request.user
-        organization = self.organization
-
-        try:
-            try:
-                # prioritize identifying by the SSO provider's user ID
-                auth_identity = AuthIdentity.objects.get(
-                    auth_provider=auth_provider,
-                    ident=identity['id'],
-                )
-            except AuthIdentity.DoesNotExist:
-                # otherwise look for an already attached identity
-                # this can happen if the SSO provider's internal ID changes
-                auth_identity = AuthIdentity.objects.get(
-                    auth_provider=auth_provider,
-                    user=user,
-                )
-        except AuthIdentity.DoesNotExist:
-            auth_identity = AuthIdentity.objects.create(
-                auth_provider=auth_provider,
-                user=user,
-                ident=identity['id'],
-                data=identity.get('data', {}),
-            )
-            auth_is_new = True
-        else:
-            now = timezone.now()
-
-            # TODO(dcramer): this might leave the user with duplicate accounts,
-            # and in that kind of situation its very reasonable that we could
-            # test email addresses + is_managed to determine if we can auto
-            # merge
-            if auth_identity.user != user:
-                # it's possible the user has an existing identity, let's wipe it out
-                # so that the new identifier gets used (other we'll hit a constraint)
-                # violation since one might exist for (provider, user) as well as
-                # (provider, ident)
-                AuthIdentity.objects.exclude(
-                    id=auth_identity.id,
-                ).filter(
-                    auth_provider=auth_provider,
-                    user=user,
-                ).delete()
-
-                # since we've identify an identity which is no longer valid
-                # lets preemptively mark it as such
-                try:
-                    other_member = OrganizationMember.objects.get(
-                        user=auth_identity.user_id,
-                        organization=organization,
-                    )
-                except OrganizationMember.DoesNotExist:
-                    pass
-                else:
-                    setattr(other_member.flags, 'sso:invalid', True)
-                    setattr(other_member.flags, 'sso:linked', False)
-                    other_member.save()
-
-            auth_identity.update(
-                user=user,
-                ident=identity['id'],
-                data=self.provider.update_identity(
-                    new_data=identity.get('data', {}),
-                    current_data=auth_identity.data,
-                ),
-                last_verified=now,
-                last_synced=now,
-            )
-            auth_is_new = False
-
-        if member is None:
-            try:
-                member = OrganizationMember.objects.get(
-                    user=user,
-                    organization=organization,
-                )
-            except OrganizationMember.DoesNotExist:
-                member = OrganizationMember.objects.create(
-                    organization=organization,
-                    role=organization.default_role,
-                    user=user,
-                    flags=getattr(OrganizationMember.flags, 'sso:linked'),
-                )
-
-                default_teams = auth_provider.default_teams.all()
-                for team in default_teams:
-                    OrganizationMemberTeam.objects.create(
-                        team=team,
-                        organizationmember=member,
-                    )
-
-                AuditLogEntry.objects.create(
-                    organization=organization,
-                    actor=user,
-                    ip_address=request.META['REMOTE_ADDR'],
-                    target_object=member.id,
-                    target_user=user,
-                    event=AuditLogEntryEvent.MEMBER_ADD,
-                    data=member.get_audit_log_data(),
-                )
-        if getattr(member.flags, 'sso:invalid') or not getattr(member.flags, 'sso:linked'):
-            setattr(member.flags, 'sso:invalid', False)
-            setattr(member.flags, 'sso:linked', True)
-            member.save()
-
-        if auth_is_new:
-            AuditLogEntry.objects.create(
-                organization=organization,
-                actor=user,
-                ip_address=request.META['REMOTE_ADDR'],
-                target_object=auth_identity.id,
-                event=AuditLogEntryEvent.SSO_IDENTITY_LINK,
-                data=auth_identity.get_audit_log_data(),
-            )
-
-            messages.add_message(
-                request,
-                messages.SUCCESS,
-                OK_LINK_IDENTITY,
-            )
-
-        return auth_identity
-
-    def _handle_new_user(self, identity):
-        auth_provider = self.auth_provider
-
-        user = User.objects.create(
-            username=uuid4().hex,
-            email=identity['email'],
-            name=identity.get('name', '')[:200],
-        )
-
-        if settings.TERMS_URL and settings.PRIVACY_URL:
-            user.update(flags=F('flags').bitor(User.flags.newsletter_consent_prompt))
-
-        try:
-            with transaction.atomic():
-                auth_identity = AuthIdentity.objects.create(
-                    auth_provider=auth_provider,
-                    user=user,
-                    ident=identity['id'],
-                    data=identity.get('data', {}),
-                )
-        except IntegrityError:
-            auth_identity = AuthIdentity.objects.get(
-                auth_provider=auth_provider,
-                ident=identity['id'],
-            )
-            auth_identity.update(
-                user=user,
-                data=identity.get('data', {}),
-            )
-
-        user.send_confirm_emails(is_new_user=True)
-
-        self._handle_new_membership(auth_identity)
-
-        return auth_identity
-
-    def _handle_new_membership(self, identity):
-        auth_provider = self.auth_provider
-        organization = self.organization
-        request = self.request
-        user = identity.user
-
-        om = OrganizationMember.objects.create(
-            organization=organization,
-            role=organization.default_role,
-            user=user,
-            flags=getattr(OrganizationMember.flags, 'sso:linked'),
-        )
-
-        default_teams = auth_provider.default_teams.all()
-        for team in default_teams:
-            OrganizationMemberTeam.objects.create(
-                team=team,
-                organizationmember=om,
-            )
-
-        AuditLogEntry.objects.create(
-            organization=organization,
-            actor=user,
-            ip_address=request.META['REMOTE_ADDR'],
-            target_object=om.id,
-            target_user=om.user,
-            event=AuditLogEntryEvent.MEMBER_ADD,
-            data=om.get_audit_log_data(),
-        )
-
-        return om
-
-    def _get_login_form(self, existing_user=None):
-        request = self.request
-        return AuthenticationForm(
-            request,
-            request.POST if request.POST.get('op') == 'login' else None,
-            initial={
-                'username': existing_user.username if existing_user else None,
-            },
-        )
-
-    def _get_display_name(self, identity):
-        return identity.get('name') or identity.get('email')
-
-    def _get_identifier(self, identity):
-        return identity.get('email') or identity.get('id')
-
-    def _find_existing_user(self, email):
-        return User.objects.filter(
-            id__in=UserEmail.objects.filter(email__iexact=email).values('user'),
-            is_active=True,
-        ).first()
-
-    def _handle_unknown_identity(self, identity):
-        """
-        Flow is activated upon a user logging in to where an AuthIdentity is
-        not present.
-
-        XXX(dcramer): this docstring is out of date
-
-        The flow will attempt to answer the following:
-
-        - Is there an existing user with the same email address? Should they be
-          merged?
-
-        - Is there an existing user (via authentication) that should be merged?
-
-        - Should I create a new user based on this identity?
-        """
-        request = self.request
-        op = request.POST.get('op')
-        if not request.user.is_authenticated():
-            # TODO(dcramer): its possible they have multiple accounts and at
-            # least one is managed (per the check below)
-            try:
-                acting_user = self._find_existing_user(identity['email'])
-            except IndexError:
-                acting_user = None
-            login_form = self._get_login_form(acting_user)
-        else:
-            acting_user = request.user
-
-        # If they already have an SSO account and the identity provider says
-        # the email matches we go ahead and let them merge it. This is the
-        # only way to prevent them having duplicate accounts, and because
-        # we trust identity providers, its considered safe.
-        # Note: we do not trust things like SAML, so the SSO implementation needs
-        # to consider if 'email_verified' can be trusted or not
-        if acting_user and identity.get('email_verified'):
-            # we only allow this flow to happen if the existing user has
-            # membership, otherwise we short circuit because it might be
-            # an attempt to hijack membership of another organization
-            has_membership = OrganizationMember.objects.filter(
-                user=acting_user,
-                organization=self.organization,
-            ).exists()
-            if has_membership:
-                if not auth.login(
-                    request,
-                    acting_user,
-                    after_2fa=request.build_absolute_uri(),
-                    organization_id=self.organization.id
-                ):
-                    if acting_user.has_usable_password():
-                        return HttpResponseRedirect(auth.get_login_redirect(self.request))
-                    else:
-                        acting_user = None
-                else:
-                    # assume they've confirmed they want to attach the identity
-                    op = 'confirm'
-            else:
-                # force them to create a new account
-                acting_user = None
-        # without a usable password they cant login, so let's clear the acting_user
-        elif acting_user and not acting_user.has_usable_password():
-            acting_user = None
-
-        if op == 'confirm' and request.user.is_authenticated():
-            auth_identity = self._handle_attach_identity(identity)
-        elif op == 'newuser':
-            auth_identity = self._handle_new_user(identity)
-        elif op == 'login' and not request.user.is_authenticated():
-            # confirm authentication, login
-            op = None
-            if login_form.is_valid():
-                # This flow is special.  If we are going through a 2FA
-                # flow here (login returns False) we want to instruct the
-                # system to return upon completion of the 2fa flow to the
-                # current URL and continue with the dialog.
-                #
-                # If there is no 2fa we don't need to do this and can just
-                # go on.
-                if not auth.login(
-                    request,
-                    login_form.get_user(),
-                    after_2fa=request.build_absolute_uri(),
-                    organization_id=self.organization.id
-                ):
-                    return HttpResponseRedirect(auth.get_login_redirect(self.request))
-            else:
-                auth.log_auth_failure(request, request.POST.get('username'))
-        else:
-            op = None
-
-        if not op:
-            if request.user.is_authenticated():
-                return self.respond(
-                    'sentry/auth-confirm-link.html', {
-                        'identity': identity,
-                        'existing_user': request.user,
-                        'identity_display_name': self._get_display_name(identity),
-                        'identity_identifier': self._get_identifier(identity)
-                    }
-                )
-
-            return self.respond(
-                'sentry/auth-confirm-identity.html', {
-                    'existing_user': acting_user,
-                    'identity': identity,
-                    'login_form': login_form,
-                    'identity_display_name': self._get_display_name(identity),
-                    'identity_identifier': self._get_identifier(identity)
-                }
-            )
-
-        user = auth_identity.user
-        user.backend = settings.AUTHENTICATION_BACKENDS[0]
-
-        # XXX(dcramer): this is repeated from above
-        if not auth.login(
-            request,
-            user,
-            after_2fa=request.build_absolute_uri(),
-            organization_id=self.organization.id
-        ):
-            return HttpResponseRedirect(auth.get_login_redirect(self.request))
-
-        self.clear_session()
-
-        return HttpResponseRedirect(auth.get_login_redirect(self.request))
-
-    def _handle_existing_identity(self, auth_identity, identity):
-        # TODO(dcramer): this is very similar to attach
-        now = timezone.now()
-        auth_identity.update(
-            data=self.provider.update_identity(
-                new_data=identity.get('data', {}),
-                current_data=auth_identity.data,
-            ),
-            last_verified=now,
-            last_synced=now,
-        )
-
-        try:
-            member = OrganizationMember.objects.get(
-                user=auth_identity.user,
-                organization=self.organization,
-            )
-        except OrganizationMember.DoesNotExist:
-            # this is likely the case when someone was removed from the org
-            # but still has access to rejoin
-            member = self._handle_new_membership(auth_identity)
-        else:
-            if getattr(member.flags, 'sso:invalid') or not getattr(member.flags, 'sso:linked'):
-                setattr(member.flags, 'sso:invalid', False)
-                setattr(member.flags, 'sso:linked', True)
-                member.save()
-
-        user = auth_identity.user
-        user.backend = settings.AUTHENTICATION_BACKENDS[0]
-
-        if not auth.login(
-            self.request,
-            user,
-            after_2fa=self.request.build_absolute_uri(),
-            organization_id=self.organization.id
-        ):
-            return HttpResponseRedirect(auth.get_login_redirect(self.request))
-
-        self.clear_session()
-        metrics.incr('sso.login-success', tags={'provider': self.provider.key})
-
-        return HttpResponseRedirect(auth.get_login_redirect(self.request))
-
     @transaction.atomic
     def _finish_login_pipeline(self, identity):
         """
@@ -686,21 +700,47 @@ class AuthHelper(object):
                     auth_identity = None
 
             if not auth_identity:
-                return self._handle_unknown_identity(identity)
+                return handle_unknown_identity(
+                    self.request,
+                    self.organization,
+                    self.auth_provider,
+                    self.provider,
+                    self.state,
+                    identity,
+                )
 
             # If the User attached to this AuthIdentity is not active,
             # we want to clobber the old account and take it over, rather than
             # getting logged into the inactive account.
             if not auth_identity.user.is_active:
-
                 # Current user is also not logged in, so we have to
                 # assume unknown.
                 if not self.request.user.is_authenticated():
-                    return self._handle_unknown_identity(identity)
-
-                auth_identity = self._handle_attach_identity(identity)
+                    return handle_unknown_identity(
+                        self.request,
+                        self.organization,
+                        self.auth_provider,
+                        self.provider,
+                        self.state,
+                        identity,
+                    )
+                auth_identity = handle_attach_identity(
+                    self.auth_provider,
+                    self.request,
+                    self.organization,
+                    self.provider,
+                    identity,
+                )
 
-            return self._handle_existing_identity(auth_identity, identity)
+            return handle_existing_identity(
+                self.auth_provider,
+                self.provider,
+                self.organization,
+                self.request,
+                self.state,
+                auth_identity,
+                identity,
+            )
 
     @transaction.atomic
     def _finish_setup_pipeline(self, identity):
@@ -732,7 +772,14 @@ class AuthHelper(object):
             config=config,
         )
 
-        self._handle_attach_identity(identity, om)
+        handle_attach_identity(
+            self.auth_provider,
+            self.request,
+            self.organization,
+            self.provider,
+            identity,
+            om,
+        )
 
         auth.mark_sso_complete(request, self.organization.id)
 
@@ -762,15 +809,6 @@ class AuthHelper(object):
         )
         return HttpResponseRedirect(next_uri)
 
-    def respond(self, template, context=None, status=200):
-        default_context = {
-            'organization': self.organization,
-        }
-        if context:
-            default_context.update(context)
-
-        return render_to_response(template, default_context, self.request, status=status)
-
     def error(self, message):
         redirect_uri = '/'
 
diff --git a/src/sentry/identity/github/provider.py b/src/sentry/identity/github/provider.py
index df7edf4251..0193703a6c 100644
--- a/src/sentry/identity/github/provider.py
+++ b/src/sentry/identity/github/provider.py
@@ -18,6 +18,12 @@ def get_user_info(access_token):
     return resp
 
 
+# Github has 2 types of apps -- Github apps and OAuth apps. SSO is implemented
+# using OAuth App, but signup and integrations use the github app. When github
+# apps have API parity with OAuth apps, we should move SSO to it as well.
+# https://developer.github.com/apps/differences-between-apps/
+
+
 class GitHubIdentityProvider(OAuth2Provider):
     key = 'github'
     name = 'GitHub'
@@ -41,6 +47,10 @@ class GitHubIdentityProvider(OAuth2Provider):
             'type': 'github',
             'id': user['id'],
             'email': user['email'],
+            'email_verified': bool(user['email']),
+            'login': user['login'],
+            'name': user['name'],
+            'company': user['company'],
             'scopes': [],  # GitHub apps do not have user scopes
             'data': self.get_oauth_data(data),
         }
diff --git a/src/sentry/integrations/github/integration.py b/src/sentry/integrations/github/integration.py
index 098a2b66e1..ae5d8d936b 100644
--- a/src/sentry/integrations/github/integration.py
+++ b/src/sentry/integrations/github/integration.py
@@ -133,6 +133,7 @@ class GitHubIntegrationProvider(IntegrationProvider):
 
         return {
             'name': installation['account']['login'],
+            # TODO(adhiraj): This should be a constant representing the entire github cloud.
             'external_id': installation['id'],
             'metadata': {
                 # The access token will be populated upon API usage
diff --git a/src/sentry/pipeline/README.md b/src/sentry/pipeline/README.md
index 488095188c..0c28b16f97 100644
--- a/src/sentry/pipeline/README.md
+++ b/src/sentry/pipeline/README.md
@@ -24,8 +24,7 @@ Some key points to understanding pipelines:
    One to call the pipelines `initialize` method, and the next which is
    called to move through the pipeline
 
- * Pipelines are bound to a specific organization and user when they are being
-   executed.
+ * Pipelines are bound to a specific session when they are being executed.
 
 ## Pipeline Providers
 
@@ -113,7 +112,7 @@ Executing a pipeline
 Executing a pipeline is done through either one or two views.
 
 With one view it will both initialize the pipeline, and traverse through the
-pipeline. The downside of this approach is that the organization, provider key,
+pipeline. The downside of this approach is that the provider key,
 and potentially other information must be known at request time of each step,
 which may not always be possible (think strict oAuth redirect URL that cannot
 be parameterized)
diff --git a/src/sentry/pipeline/__init__.py b/src/sentry/pipeline/__init__.py
index 67c09906a7..cfb296e8b4 100644
--- a/src/sentry/pipeline/__init__.py
+++ b/src/sentry/pipeline/__init__.py
@@ -130,21 +130,21 @@ class Pipeline(object):
         if not state.is_valid():
             return None
 
-        organization_id = state.org_id
-        if not organization_id:
-            return None
-
         provider_model = None
         if state.provider_model_id:
             provider_model = cls.provider_model_cls.objects.get(id=state.provider_model_id)
 
-        organization = Organization.objects.get(id=state.org_id)
+        organization = None
+        if state.org_id:
+            organization = Organization.objects.get(id=state.org_id)
+
         provider_key = state.provider_key
         config = state.config
 
-        return cls(request, organization, provider_key, provider_model, config)
+        return cls(request, organization=organization, provider_key=provider_key,
+                   provider_model=provider_model, config=config)
 
-    def __init__(self, request, organization, provider_key, provider_model=None, config=None):
+    def __init__(self, request, provider_key, organization=None, provider_model=None, config=None):
         if config is None:
             config = {}
 
@@ -185,7 +185,7 @@ class Pipeline(object):
             'uid': self.request.user.id if self.request.user.is_authenticated() else None,
             'provider_model_id': self.provider_model.id if self.provider_model else None,
             'provider_key': self.provider.key,
-            'org_id': self.organization.id,
+            'org_id': self.organization.id if self.organization else None,
             'step_index': 0,
             'signature': self.signature,
             'config': self.config,
diff --git a/src/sentry/templates/sentry/auth-confirm-identity.html b/src/sentry/templates/sentry/auth-confirm-identity.html
index 99d8792b61..94d3a96712 100644
--- a/src/sentry/templates/sentry/auth-confirm-identity.html
+++ b/src/sentry/templates/sentry/auth-confirm-identity.html
@@ -16,6 +16,8 @@
       <span class="icon-arrow-left"></span>
       <span class="avatar">
         {% letter_avatar_svg identity_display_name identity_identifier %}
+      </span>
+      <span class="avatar">
         <img src="{% gravatar_url identity.email size 36 default 'blank' %}" class="avatar">
       </span>
     </div>
@@ -46,6 +48,8 @@
       <div class="sso-link">
         <span class="avatar">
           {% letter_avatar_svg identity_display_name identity_identifier %}
+        </span>
+        <span class="avatar">
           <img src="{% gravatar_url identity.email size 36 default 'blank' %}" class="avatar">
         </span>
       </div>
diff --git a/src/sentry/templates/sentry/auth-confirm-link.html b/src/sentry/templates/sentry/auth-confirm-link.html
index d9a9869fdb..62a5de279e 100644
--- a/src/sentry/templates/sentry/auth-confirm-link.html
+++ b/src/sentry/templates/sentry/auth-confirm-link.html
@@ -18,13 +18,15 @@
       <span class="icon-arrow-left"></span>
       <span class="avatar">
         {% letter_avatar_svg identity_display_name identity_identifier %}
+      </span>
+      <span class="avatar">
         <img src="{% gravatar_url identity.email size 36 default 'blank' %}">
       </span>
     </div>
 
     <div class="align-center">
 
-      {% if existing_user.email == identity.email %}
+      {% if force_link or existing_user.email == identity.email %}
         <p>We're going to associate your new identity with your existing account which means all of your existing settings will stay intact.</p>
 
         <p>
diff --git a/src/sentry/templates/sentry/login.html b/src/sentry/templates/sentry/login.html
index ca50eb6137..06d07bc4ad 100644
--- a/src/sentry/templates/sentry/login.html
+++ b/src/sentry/templates/sentry/login.html
@@ -41,6 +41,10 @@
         <fieldset class="form-actions">
           <button type="submit" class="btn btn-primary">{% trans "Continue" %}</button> <a class="pull-right" style="margin-top: 7px" href="{% url 'sentry-account-recover' %}">{% trans "Lost your password?" %}</a>
         </fieldset>
+
+        {% if github_login_template %}
+          {% include github_login_template %}
+        {% endif %}
       </form>
     </div>
     <div class="tab-pane{% if op == "register" %} active{% endif %}" id="register">
diff --git a/src/sentry/web/forms/accounts.py b/src/sentry/web/forms/accounts.py
index abd47f97d9..baf9536169 100644
--- a/src/sentry/web/forms/accounts.py
+++ b/src/sentry/web/forms/accounts.py
@@ -178,7 +178,7 @@ class AuthenticationForm(forms.Form):
         return self.user_cache
 
 
-class RegistrationForm(forms.ModelForm):
+class PasswordlessRegistrationForm(forms.ModelForm):
     name = forms.CharField(
         label=_('Name'),
         max_length=30,
@@ -191,9 +191,6 @@ class RegistrationForm(forms.ModelForm):
         widget=forms.TextInput(attrs={'placeholder': 'you@example.com'}),
         required=True
     )
-    password = forms.CharField(
-        required=True, widget=forms.PasswordInput(attrs={'placeholder': 'something super secret'})
-    )
     subscribe = CustomTypedChoiceField(
         coerce=lambda x: six.text_type(x) == u'1',
         label=_("Email updates"),
@@ -207,7 +204,7 @@ class RegistrationForm(forms.ModelForm):
     )
 
     def __init__(self, *args, **kwargs):
-        super(RegistrationForm, self).__init__(*args, **kwargs)
+        super(PasswordlessRegistrationForm, self).__init__(*args, **kwargs)
         if not newsletter.is_enabled():
             del self.fields['subscribe']
         else:
@@ -220,7 +217,8 @@ class RegistrationForm(forms.ModelForm):
                 "your data to third parties. See our "
                 "<a href=\"{privacy_link}\">Privacy Policy</a> for more details."
             )
-            self.fields['subscribe'].help_text = mark_safe(notice.format(privacy_link=settings.PRIVACY_URL))
+            self.fields['subscribe'].help_text = mark_safe(
+                notice.format(privacy_link=settings.PRIVACY_URL))
 
     class Meta:
         fields = ('username', 'name')
@@ -232,10 +230,26 @@ class RegistrationForm(forms.ModelForm):
             return
         if User.objects.filter(username__iexact=value).exists():
             raise forms.ValidationError(
-                _('An account is already registered with that email address.')
-            )
+                _('An account is already registered with that email address.'))
         return value.lower()
 
+    def save(self, commit=True):
+        user = super(PasswordlessRegistrationForm, self).save(commit=False)
+        user.email = user.username
+        if commit:
+            user.save()
+            if self.cleaned_data.get('subscribe'):
+                newsletter.create_or_update_subscriptions(
+                    user, list_ids=newsletter.get_default_list_ids())
+        return user
+
+
+class RegistrationForm(PasswordlessRegistrationForm):
+    password = forms.CharField(
+        required=True,
+        widget=forms.PasswordInput(attrs={'placeholder': 'something super secret'}),
+    )
+
     def clean_password(self):
         password = self.cleaned_data['password']
         password_validation.validate_password(password)
@@ -243,12 +257,12 @@ class RegistrationForm(forms.ModelForm):
 
     def save(self, commit=True):
         user = super(RegistrationForm, self).save(commit=False)
-        user.email = user.username
         user.set_password(self.cleaned_data['password'])
         if commit:
             user.save()
             if self.cleaned_data.get('subscribe'):
-                newsletter.create_or_update_subscriptions(user, list_ids=newsletter.get_default_list_ids())
+                newsletter.create_or_update_subscriptions(
+                    user, list_ids=newsletter.get_default_list_ids())
         return user
 
 
diff --git a/src/sentry/web/frontend/account_identity.py b/src/sentry/web/frontend/account_identity.py
index 85fd3ed576..231f08044c 100644
--- a/src/sentry/web/frontend/account_identity.py
+++ b/src/sentry/web/frontend/account_identity.py
@@ -45,6 +45,6 @@ class AccountIdentityLinkView(BaseView):
         pipeline = IdentityProviderPipeline.get_for_request(request)
 
         if pipeline is None or not pipeline.is_valid():
-            return self.redirect(reverse('sentry-account-settings-identity'))
+            return self.redirect(reverse('sentry-account-settings-identities'))
 
         return pipeline.current_step()
diff --git a/src/sentry/web/frontend/auth_login.py b/src/sentry/web/frontend/auth_login.py
index dfd79b344c..0daf266e82 100644
--- a/src/sentry/web/frontend/auth_login.py
+++ b/src/sentry/web/frontend/auth_login.py
@@ -9,6 +9,7 @@ from django.http import HttpResponseRedirect
 from django.utils.translation import ugettext_lazy as _
 from django.views.decorators.cache import never_cache
 
+from sentry.app import raven
 from sentry.auth.superuser import is_active_superuser
 from sentry.constants import WARN_SESSION_EXPIRED
 from sentry.http import get_server_hostname
@@ -21,6 +22,32 @@ ERR_NO_SSO = _(
     'The organization does not exist or does not have Single Sign-On enabled.')
 
 
+# Stores callbacks that are called to get additional template context data before the login page
+# is rendered. Callbacks are called in any order. If an error is encountered in a callback it is
+# ignored. This works like HookStore in Javascript.
+class AdditionalContext(object):
+    def __init__(self):
+        self._callbacks = set()
+
+    def add_callback(self, callback):
+        """callback should take a request object and return a dict of key-value pairs
+        to add to the context."""
+        self._callbacks.add(callback)
+
+    def run_callbacks(self, request):
+        context = {}
+        for cb in self._callbacks:
+            try:
+                result = cb(request)
+                context.update(result)
+            except Exception:
+                raven.captureException()
+        return context
+
+
+additional_context = AdditionalContext()
+
+
 class AuthLoginView(BaseView):
     auth_required = False
 
@@ -143,6 +170,8 @@ class AuthLoginView(BaseView):
             'register_form': register_form,
             'CAN_REGISTER': can_register,
         }
+        context.update(additional_context.run_callbacks(request))
+
         return self.respond_login(request, context, organization=organization, *args, **kwargs)
 
     def handle_authenticated(self, request, *args, **kwargs):
diff --git a/src/sentry/web/frontend/base.py b/src/sentry/web/frontend/base.py
index f4ebaf9a8c..7366829431 100644
--- a/src/sentry/web/frontend/base.py
+++ b/src/sentry/web/frontend/base.py
@@ -322,7 +322,7 @@ class OrganizationView(BaseView):
         if organization is None:
             return False
         if self.valid_sso_required:
-            if not request.access.sso_is_valid:
+            if request.access.requires_sso and not request.access.sso_is_valid:
                 return False
             if self.needs_sso(request, organization):
                 return False
diff --git a/tests/sentry/pipeline/test_pipeline.py b/tests/sentry/pipeline/test_pipeline.py
index 00505f41be..5e19deb697 100644
--- a/tests/sentry/pipeline/test_pipeline.py
+++ b/tests/sentry/pipeline/test_pipeline.py
@@ -37,7 +37,7 @@ class PipelineTestCase(TestCase):
         request.session = {}
         request.user = self.user
 
-        pipeline = DummyPipeline(request, org, 'dummy', config={'some_config': True})
+        pipeline = DummyPipeline(request, 'dummy', org, config={'some_config': True})
         pipeline.initialize()
 
         assert pipeline.is_valid()
@@ -71,7 +71,7 @@ class PipelineTestCase(TestCase):
         request.session = {}
         request.user = self.user
 
-        pipeline = DummyPipeline(request, org, 'dummy')
+        pipeline = DummyPipeline(request, 'dummy', org)
         pipeline.initialize()
 
         assert pipeline.is_valid()

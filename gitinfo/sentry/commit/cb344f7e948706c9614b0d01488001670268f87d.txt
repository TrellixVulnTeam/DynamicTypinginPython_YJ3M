commit cb344f7e948706c9614b0d01488001670268f87d
Author: Matt Robenolt <matt@ydekproductions.com>
Date:   Wed May 22 14:48:09 2019 -0700

    services: Enable support for logging metrics from service methods (#13312)
    
    And also turn on metrics for nodestore

diff --git a/src/sentry/metrics/logging.py b/src/sentry/metrics/logging.py
index 6df08466aa..5b787e928a 100644
--- a/src/sentry/metrics/logging.py
+++ b/src/sentry/metrics/logging.py
@@ -18,7 +18,7 @@ class LoggingBackend(MetricsBackend):
 
     def timing(self, key, value, instance=None, tags=None, sample_rate=1):
         logger.debug(
-            '%r: %g ms', key, value, extra={
+            '%r: %g ms', key, value * 1000, extra={
                 'instance': instance,
                 'tags': tags or {},
             }
diff --git a/src/sentry/nodestore/__init__.py b/src/sentry/nodestore/__init__.py
index d5a30655cd..213318f5bc 100644
--- a/src/sentry/nodestore/__init__.py
+++ b/src/sentry/nodestore/__init__.py
@@ -7,6 +7,7 @@ from sentry.utils.services import LazyServiceWrapper
 from .base import NodeStorage  # NOQA
 
 backend = LazyServiceWrapper(
-    NodeStorage, settings.SENTRY_NODESTORE, settings.SENTRY_NODESTORE_OPTIONS
+    NodeStorage, settings.SENTRY_NODESTORE, settings.SENTRY_NODESTORE_OPTIONS,
+    metrics_path='nodestore',
 )
 backend.expose(locals())
diff --git a/src/sentry/utils/metrics.py b/src/sentry/utils/metrics.py
index 3e19687ba7..d868fe64c7 100644
--- a/src/sentry/utils/metrics.py
+++ b/src/sentry/utils/metrics.py
@@ -4,6 +4,7 @@ __all__ = ['timing', 'incr']
 
 import logging
 
+import functools
 from contextlib import contextmanager
 from django.conf import settings
 from random import random
@@ -130,3 +131,13 @@ def timer(key, instance=None, tags=None):
         tags['result'] = 'success'
     finally:
         timing(key, time() - start, instance, tags)
+
+
+def wraps(key, instance=None, tags=None):
+    def wrapper(f):
+        @functools.wraps(f)
+        def inner(*args, **kwargs):
+            with timer(key, instance=instance, tags=tags):
+                return f(*args, **kwargs)
+        return inner
+    return wrapper
diff --git a/src/sentry/utils/services.py b/src/sentry/utils/services.py
index c2803016f1..2789cd9f46 100644
--- a/src/sentry/utils/services.py
+++ b/src/sentry/utils/services.py
@@ -9,7 +9,7 @@ import threading
 import six
 from django.utils.functional import empty, LazyObject
 
-from sentry.utils import warnings
+from sentry.utils import warnings, metrics
 from sentry.utils.concurrent import FutureSet, ThreadedExecutor
 
 from .imports import import_string
@@ -55,7 +55,7 @@ class LazyServiceWrapper(LazyObject):
     >>> service.expose(locals())
     """
 
-    def __init__(self, backend_base, backend_path, options, dangerous=()):
+    def __init__(self, backend_base, backend_path, options, dangerous=(), metrics_path=None):
         super(LazyServiceWrapper, self).__init__()
         self.__dict__.update(
             {
@@ -63,13 +63,27 @@ class LazyServiceWrapper(LazyObject):
                 '_options': options,
                 '_base': backend_base,
                 '_dangerous': dangerous,
+                '_metrics_path': metrics_path,
             }
         )
 
     def __getattr__(self, name):
         if self._wrapped is empty:
             self._setup()
-        return getattr(self._wrapped, name)
+
+        attr = getattr(self._wrapped, name)
+
+        # If we want to wrap in metrics, we need to make sure it's some callable,
+        # and within our list of exposed attributes. Then we can safely wrap
+        # in our metrics decorator.
+        if self._metrics_path and callable(attr) and name in self._base.__all__:
+            return metrics.wraps(
+                self._metrics_path,
+                instance=name,
+                tags={'backend': self._backend}
+            )(attr)
+
+        return attr
 
     def _setup(self):
         backend = import_string(self._backend)
diff --git a/tests/sentry/utils/test_metrics.py b/tests/sentry/utils/test_metrics.py
index 9f3ae55c8d..364e797c8d 100644
--- a/tests/sentry/utils/test_metrics.py
+++ b/tests/sentry/utils/test_metrics.py
@@ -3,17 +3,17 @@ from __future__ import absolute_import
 import mock
 import pytest
 
-from sentry.utils.metrics import timer
+from sentry.utils import metrics
 
 
 def test_timer_success():
     with mock.patch('sentry.utils.metrics.timing') as timing:
-        with timer('key', tags={'foo': True}) as tags:
+        with metrics.timer('key', tags={'foo': True}) as tags:
             tags['bar'] = False
 
-        assert timing.call_count is 1
+        assert timing.call_count == 1
         args, kwargs = timing.call_args
-        assert args[0] is 'key'
+        assert args[0] == 'key'
         assert args[3] == {
             'foo': True,
             'bar': False,
@@ -28,13 +28,30 @@ class ExpectedError(Exception):
 def test_timer_failure():
     with mock.patch('sentry.utils.metrics.timing') as timing:
         with pytest.raises(ExpectedError):
-            with timer('key', tags={'foo': True}):
+            with metrics.timer('key', tags={'foo': True}):
                 raise ExpectedError
 
-        assert timing.call_count is 1
+        assert timing.call_count == 1
         args, kwargs = timing.call_args
-        assert args[0] is 'key'
+        assert args[0] == 'key'
         assert args[3] == {
             'foo': True,
             'result': 'failure',
         }
+
+
+def test_wraps():
+    @metrics.wraps('key', tags={'foo': True})
+    def thing(a):
+        return a
+
+    with mock.patch('sentry.utils.metrics.timing') as timing:
+        thing(10) == 10
+
+        assert timing.call_count == 1
+        args, kwargs = timing.call_args
+        assert args[0] == 'key'
+        assert args[3] == {
+            'foo': True,
+            'result': 'success',
+        }

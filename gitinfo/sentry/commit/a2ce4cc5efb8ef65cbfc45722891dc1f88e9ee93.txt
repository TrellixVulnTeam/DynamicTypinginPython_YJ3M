commit a2ce4cc5efb8ef65cbfc45722891dc1f88e9ee93
Author: ted kaemming <ted@kaemming.com>
Date:   Tue Mar 6 11:45:37 2018 -0800

    ref: Use `environment` request parameter as implicit tag condition for search (#7444)

diff --git a/src/sentry/api/endpoints/group_events.py b/src/sentry/api/endpoints/group_events.py
index 7b53aa9deb..c9893493d4 100644
--- a/src/sentry/api/endpoints/group_events.py
+++ b/src/sentry/api/endpoints/group_events.py
@@ -36,47 +36,69 @@ class GroupEventsEndpoint(GroupEndpoint, EnvironmentMixin):
         :auth: required
         """
 
-        events = Event.objects.filter(
-            group_id=group.id,
-        )
-
-        query = request.GET.get('query')
-
-        if query:
+        def respond(queryset):
+            return self.paginate(
+                request=request,
+                queryset=queryset,
+                order_by='-datetime',
+                on_results=lambda x: serialize(x, request.user),
+                paginator_cls=DateTimePaginator,
+            )
+
+        events = Event.objects.filter(group_id=group.id)
+
+        try:
+            environment = self._get_environment_from_request(
+                request,
+                group.project.organization_id,
+            )
+        except Environment.DoesNotExist:
+            return respond(events.none())
+
+        raw_query = request.GET.get('query')
+
+        if raw_query:
             try:
-                query_kwargs = parse_query(group.project, query, request.user)
+                query_kwargs = parse_query(group.project, raw_query, request.user)
             except InvalidQuery as exc:
                 return Response({'detail': six.text_type(exc)}, status=400)
+            else:
+                query = query_kwargs.pop('query', None)
+                tags = query_kwargs.pop('tags', {})
+        else:
+            query = None
+            tags = {}
+
+        if environment is not None:
+            if 'environment' in tags and tags['environment'] != environment.name:
+                # An event can only be associated with a single
+                # environment, so if the environment associated with
+                # the request is different than the environment
+                # provided as a tag lookup, the query cannot contain
+                # any valid results.
+                return respond(events.none())
+            else:
+                tags['environment'] = environment.name
+
+        if query:
+            q = Q(message__icontains=query)
+
+            if len(query) == 32:
+                q |= Q(event_id__exact=query)
+
+            events = events.filter(q)
+
+        if tags:
+            event_ids = tagstore.get_group_event_ids(
+                group.project_id,
+                group.id,
+                environment.id if environment is not None else None,
+                tags,
+            )
+
+            if not event_ids:
+                return respond(events.none())
+
+            events = events.filter(id__in=event_ids)
 
-            if query_kwargs['query']:
-                q = Q(message__icontains=query_kwargs['query'])
-
-                if len(query) == 32:
-                    q |= Q(event_id__exact=query_kwargs['query'])
-
-                events = events.filter(q)
-
-            if query_kwargs['tags']:
-                try:
-                    environment_id = self._get_environment_id_from_request(
-                        request, group.project.organization_id)
-                except Environment.DoesNotExist:
-                    event_ids = []
-                else:
-                    event_ids = tagstore.get_group_event_ids(
-                        group.project_id, group.id, environment_id, query_kwargs['tags'])
-
-                if event_ids:
-                    events = events.filter(
-                        id__in=event_ids,
-                    )
-                else:
-                    events = events.none()
-
-        return self.paginate(
-            request=request,
-            queryset=events,
-            order_by='-datetime',
-            on_results=lambda x: serialize(x, request.user),
-            paginator_cls=DateTimePaginator,
-        )
+        return respond(events)
diff --git a/src/sentry/api/endpoints/project_group_index.py b/src/sentry/api/endpoints/project_group_index.py
index 1d7431e397..a1b8deee9b 100644
--- a/src/sentry/api/endpoints/project_group_index.py
+++ b/src/sentry/api/endpoints/project_group_index.py
@@ -222,6 +222,27 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint, EnvironmentMixin):
 
         return query_kwargs
 
+    def _search(self, request, project, extra_query_kwargs=None):
+        query_kwargs = self._build_query_params_from_request(request, project)
+
+        if extra_query_kwargs is not None:
+            assert 'environment' not in extra_query_kwargs
+            query_kwargs.update(extra_query_kwargs)
+
+        try:
+            query_kwargs['environment'] = self._get_environment_from_request(
+                request,
+                project.organization_id,
+            )
+        except Environment.DoesNotExist:
+            # XXX: The 1000 magic number for `max_hits` is an abstraction leak
+            # from `sentry.api.paginator.BasePaginator.get_result`.
+            result = CursorResult([], None, None, hits=0, max_hits=1000)
+        else:
+            result = search.query(**query_kwargs)
+
+        return result, query_kwargs
+
     def _subscribe_and_assign_issue(self, acting_user, group, result):
         if acting_user:
             GroupSubscription.objects.subscribe(
@@ -327,24 +348,10 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint, EnvironmentMixin):
                 return response
 
         try:
-            query_kwargs = self._build_query_params_from_request(
-                request, project)
+            cursor_result, query_kwargs = self._search(request, project, {'count_hits': True})
         except ValidationError as exc:
             return Response({'detail': six.text_type(exc)}, status=400)
 
-        try:
-            environment_id = self._get_environment_id_from_request(
-                request, project.organization_id)
-        except Environment.DoesNotExist:
-            # XXX: The 1000 magic number for `max_hits` is an abstraction leak
-            # from `sentry.api.paginator.BasePaginator.get_result`.
-            cursor_result = CursorResult([], None, None, hits=0, max_hits=1000)
-        else:
-            cursor_result = search.query(
-                count_hits=True,
-                environment_id=environment_id,
-                **query_kwargs)
-
         results = list(cursor_result)
 
         context = serialize(results, request.user, serializer())
@@ -437,21 +444,16 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint, EnvironmentMixin):
 
         if not group_ids:
             try:
-                query_kwargs = self._build_query_params_from_request(
-                    request, project)
+                # bulk mutations are limited to 1000 items
+                # TODO(dcramer): it'd be nice to support more than this, but its
+                # a bit too complicated right now
+                cursor_result, _ = self._search(request, project, {
+                    'limit': 1000,
+                    'paginator_options': {'max_limit': 1000},
+                })
             except ValidationError as exc:
                 return Response({'detail': six.text_type(exc)}, status=400)
 
-            # bulk mutations are limited to 1000 items
-            # TODO(dcramer): it'd be nice to support more than this, but its
-            # a bit too complicated right now
-            limit = 1000
-            query_kwargs['limit'] = limit
-
-            # the paginator has a default max_limit of 100, which must be overwritten.
-            cursor_result = search.query(
-                paginator_options={'max_limit': limit}, **query_kwargs)
-
             group_list = list(cursor_result)
             group_ids = [g.id for g in group_list]
 
diff --git a/src/sentry/search/django/backend.py b/src/sentry/search/django/backend.py
index 71e42369fb..beaf3f462e 100644
--- a/src/sentry/search/django/backend.py
+++ b/src/sentry/search/django/backend.py
@@ -57,10 +57,13 @@ class DjangoSearchBackend(SearchBackend):
         times_seen_upper_inclusive=True,
         cursor=None,
         limit=None,
-        environment_id=None,
+        environment=None,
     ):
         from sentry.models import Event, Group, GroupSubscription, GroupStatus
 
+        if tags is None:
+            tags = {}
+
         engine = get_db_engine('default')
 
         queryset = Group.objects.filter(project=project)
@@ -115,8 +118,20 @@ class DjangoSearchBackend(SearchBackend):
                 first_release__version=first_release,
             )
 
+        if environment is not None:
+            # XXX: This overwrites the ``environment`` tag, if present, to
+            # ensure that the result set is limited to groups that have been
+            # seen in this environment (there is no way to search for groups
+            # that match multiple values of a single tag without changes to the
+            # tagstore API.)
+            tags['environment'] = environment.name
+
         if tags:
-            matches = tagstore.get_group_ids_for_search_filter(project.id, environment_id, tags)
+            matches = tagstore.get_group_ids_for_search_filter(
+                project.id,
+                environment.id if environment is not None else None,
+                tags,
+            )
             if not matches:
                 return queryset.none()
             queryset = queryset.filter(
diff --git a/tests/sentry/api/endpoints/test_group_events.py b/tests/sentry/api/endpoints/test_group_events.py
index 38f4f192c3..21dd9bde81 100644
--- a/tests/sentry/api/endpoints/test_group_events.py
+++ b/tests/sentry/api/endpoints/test_group_events.py
@@ -3,6 +3,7 @@ from __future__ import absolute_import
 import six
 
 from sentry import tagstore
+from sentry.models import Environment
 from sentry.testutils import APITestCase
 
 
@@ -168,3 +169,62 @@ class GroupEventsTest(APITestCase):
                 six.text_type(event_2.id),
             ]
         )
+
+    def test_environment(self):
+        self.login_as(user=self.user)
+
+        group = self.create_group()
+        events = {}
+
+        for name in ['production', 'development']:
+            environment = Environment.get_or_create(group.project, name)
+
+            tagstore.get_or_create_tag_key(
+                project_id=group.project_id,
+                environment_id=environment.id,
+                key='environment',
+            )
+
+            tagstore.create_tag_value(
+                project_id=group.project_id,
+                environment_id=environment.id,
+                key='environment',
+                value=name,
+            )
+
+            events[name] = event = self.create_event(
+                group=group,
+                tags={'environment': name},
+            )
+
+            tagstore.create_event_tags(
+                project_id=group.project_id,
+                group_id=group.id,
+                environment_id=environment.id,
+                event_id=event.id,
+                tags=[
+                    ('environment', name),
+                ],
+            )
+
+        url = '/api/0/issues/{}/events/'.format(group.id)
+        response = self.client.get(url + '?environment=production', format='json')
+
+        assert response.status_code == 200, response.content
+        assert set(map(lambda x: x['id'], response.data)) == set([
+            six.text_type(events['production'].id),
+        ])
+
+        url = '/api/0/issues/{}/events/'.format(group.id)
+        response = self.client.get(url + '?environment=invalid', format='json')
+
+        assert response.status_code == 200, response.content
+        assert response.data == []
+
+        url = '/api/0/issues/{}/events/'.format(group.id)
+        response = self.client.get(
+            url + '?environment=production&query=environment:development',
+            format='json')
+
+        assert response.status_code == 200, response.content
+        assert response.data == []

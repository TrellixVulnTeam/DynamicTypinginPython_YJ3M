commit 7ee4bfb22d6ff6e8b8691f74a2e566d6f4579e8f
Author: David Cramer <dcramer@gmail.com>
Date:   Tue Aug 31 12:37:40 2010 -0700

    Support template debugging and refactor storage to use gzipped data (old messages are now unsupported)

diff --git a/example_project/settings.py b/example_project/settings.py
index 8959cef6fa..12930a92e9 100644
--- a/example_project/settings.py
+++ b/example_project/settings.py
@@ -2,8 +2,8 @@ import os.path
 
 # Django settings for example_project project.
 
-DEBUG = True
-TEMPLATE_DEBUG = DEBUG
+DEBUG = False
+TEMPLATE_DEBUG = True
 
 ADMINS = (
     # ('Your Name', 'your_email@domain.com'),
@@ -100,3 +100,6 @@ INSTALLED_APPS = (
     # Uncomment the next line to enable the admin:
     # 'django.contrib.admin',
 )
+
+import logging
+logging.basicConfig(level=logging.DEBUG)
\ No newline at end of file
diff --git a/sentry/helpers.py b/sentry/helpers.py
index ac485a992b..f7f9e353d8 100644
--- a/sentry/helpers.py
+++ b/sentry/helpers.py
@@ -3,23 +3,57 @@ from django.template import (Template, Context, TemplateDoesNotExist,
     TemplateSyntaxError)
 from django.utils.encoding import smart_unicode
 from django.utils.hashcompat import md5_constructor
-from django.views.debug import ExceptionReporter
+from django.utils.html import escape
+from django.views.debug import ExceptionReporter, linebreak_iter
 
 class ImprovedExceptionReporter(ExceptionReporter):
-    def __init__(self, request, exc_type, exc_value, frames):
+    def __init__(self, request, exc_type, exc_value, frames, template_info=None):
         ExceptionReporter.__init__(self, request, exc_type, exc_value, None)
         self.frames = frames
+        self._template = template_info
 
     def get_traceback_frames(self):
         return self.frames
 
+    def get_template_exception_info(self):
+        template_source, start, end, name = self._template
+        context_lines = 10
+        line = 0
+        upto = 0
+        source_lines = []
+        before = during = after = ""
+        for num, next in enumerate(linebreak_iter(template_source)):
+            if start >= upto and end <= next:
+                line = num
+                before = escape(template_source[upto:start])
+                during = escape(template_source[start:end])
+                after = escape(template_source[end:next])
+            source_lines.append( (num, escape(template_source[upto:next])) )
+            upto = next
+        total = len(source_lines)
+
+        top = max(1, line - context_lines)
+        bottom = min(total, line + 1 + context_lines)
+
+        self.template_info = {
+            'message': self.exc_value.args[0],
+            'source_lines': source_lines[top:bottom],
+            'before': before,
+            'during': during,
+            'after': after,
+            'top': top,
+            'bottom': bottom,
+            'total': total,
+            'line': line,
+            'name': name,
+        }
+
     def get_traceback_html(self):
         "Return HTML code for traceback."
 
         if issubclass(self.exc_type, TemplateDoesNotExist):
             self.template_does_not_exist = True
-        if (settings.TEMPLATE_DEBUG and hasattr(self.exc_value, 'source') and
-            isinstance(self.exc_value, TemplateSyntaxError)):
+        if self._template:
             self.get_template_exception_info()
 
         frames = self.get_traceback_frames()
diff --git a/sentry/manager.py b/sentry/manager.py
index f09bb46cf5..92ec975a7e 100644
--- a/sentry/manager.py
+++ b/sentry/manager.py
@@ -7,15 +7,11 @@ import socket
 import warnings
 import datetime
 import django
-import base64
 import sys
-try:
-    import cPickle as pickle
-except ImportError:
-    import pickle
 
 from django.core.cache import cache
 from django.db import models
+from django.template import TemplateSyntaxError
 from django.utils.encoding import smart_unicode
 from django.views.debug import ExceptionReporter
 
@@ -149,8 +145,16 @@ class DBLogManager(models.Manager):
         frames = reporter.get_traceback_frames()
 
         data = kwargs.pop('data', {}) or {}
-        data['exc'] = base64.b64encode(pickle.dumps(map(to_unicode, [exc_type.__class__.__module__, exc_value.args, frames])).encode('zlib'))
-
+        data['__sentry__'] = {
+            'exc': map(to_unicode, [exc_type.__class__.__module__, exc_value.args, frames]),
+        }
+
+        if isinstance(exc_value, TemplateSyntaxError) and hasattr(exc_value, 'source'):
+            origin, (start, end) = exc_value.source
+            data['__sentry__'].update({
+                'template': (origin.reload(), start, end, origin.name),
+            })
+        
         tb_message = '\n'.join(traceback_mod.format_exception(exc_type, exc_value, traceback))
 
         kwargs.setdefault('message', to_unicode(exc_value))
diff --git a/sentry/models.py b/sentry/models.py
index 3902d2ccdc..58aff70812 100644
--- a/sentry/models.py
+++ b/sentry/models.py
@@ -8,7 +8,7 @@ from django.utils.translation import ugettext_lazy as _
 from sentry import settings
 from sentry.helpers import construct_checksum, get_installed_apps
 from sentry.manager import DBLogManager, GroupedMessageManager
-from sentry.utils import JSONDictField
+from sentry.utils import GzippedDictField
 
 import datetime
 import warnings
@@ -129,8 +129,6 @@ class GroupedMessage(MessageBase):
                 else:
                     view = '%s.%s' % (exc_traceback.tb_frame.f_globals['__name__'], tb[-1][2]) 
 
-            print view
-
             if request:
                 data = dict(
                     META=request.META,
@@ -159,7 +157,7 @@ class GroupedMessage(MessageBase):
 
 class Message(MessageBase):
     datetime        = models.DateTimeField(default=datetime.datetime.now, db_index=True)
-    data            = JSONDictField(blank=True, null=True)
+    data            = GzippedDictField(blank=True, null=True)
     url             = models.URLField(verify_exists=False, null=True, blank=True)
 
     class Meta:
diff --git a/sentry/templates/sentry/index.html b/sentry/templates/sentry/index.html
index 8d3023231f..fd01bfe9ae 100644
--- a/sentry/templates/sentry/index.html
+++ b/sentry/templates/sentry/index.html
@@ -136,7 +136,7 @@
 			div.context ol.context-line li span { float: right; }
 			div.commands { margin-left: 40px; }
 			div.commands a { color:black; text-decoration:none; }
-			#template, #template-not-exist { background:#f6f6f6; }
+			#template, #template-not-exist { background:#f6f6f6; margin-top: 1em; }
 			#template-not-exist ul { margin: 0 0 0 20px; }
 			#unicode-hint { background:#eee; }
 			#traceback { background:#eee; padding: 10px; }
diff --git a/sentry/utils.py b/sentry/utils.py
index 0fededf004..ad501a2488 100644
--- a/sentry/utils.py
+++ b/sentry/utils.py
@@ -1,61 +1,37 @@
-from django.utils import simplejson as json
-from django.utils.encoding import smart_unicode
 from django.db import models
-from django import forms
-from django.core.serializers.json import DjangoJSONEncoder
 
-import uuid
-
-class BetterJSONEncoder(DjangoJSONEncoder):
-    def default(self, obj):
-        if isinstance(obj, uuid.UUID):
-            return obj.hex
-        elif not isinstance(obj, (basestring, tuple, list, dict, int, bool)):
-            return unicode(obj)
-        else:
-            return super(BetterJSONEncoder, self).default(obj)
-
-def json_dumps(value, **kwargs):
-    return json.dumps(value, cls=BetterJSONEncoder, **kwargs)
-
-class JSONDictWidget(forms.Textarea):
-    def render(self, name, value, attrs=None):
-        if not isinstance(value, basestring):
-            value = json_dumps(value, indent=2)
-        return super(JSONDictWidget, self).render(name, value, attrs)
-
-class JSONDictFormField(forms.CharField):
-    def __init__(self, *args, **kwargs):
-        kwargs['widget'] = kwargs.get('widget', JSONDictWidget)
-        super(JSONDictFormField, self).__init__(*args, **kwargs)
- 
-    def clean(self, value):
-        if not value: return
-        try:
-            return json.loads(value)
-        except Exception, exc:
-            raise forms.ValidationError(u'JSONDict decode error: %s' % (smart_unicode(exc),))
-
-class JSONDictField(models.TextField):
+import base64
+try:
+    import cPickle as pickle
+except ImportError:
+    import pickle
+
+def transform(value):
+    if isinstance(value, (tuple, list)):
+        return [transform(o) for o in value]
+    elif isinstance(value, dict):
+        return dict((k, transform(v)) for k, v in value.iteritems())
+    elif not isinstance(value, (int, bool, basestring)) and value is not None:
+        return unicode(value)
+    return value
+
+class GzippedDictField(models.TextField):
     """
     Slightly different from a JSONField in the sense that the default
     value is a dictionary.
     """
     __metaclass__ = models.SubfieldBase
  
-    def formfield(self, **kwargs):
-        return super(JSONDictField, self).formfield(form_class=JSONDictFormField, **kwargs)
- 
     def to_python(self, value):
         if isinstance(value, basestring) and value:
-            value = json.loads(value)
+            value = pickle.loads(base64.b64decode(value).decode('zlib'))
         elif not value:
             return {}
         return value
 
     def get_prep_value(self, value):
         if value is None: return
-        return json_dumps(value)
+        return base64.b64encode(pickle.dumps(transform(value)).encode('zlib'))
  
     def value_to_string(self, obj):
         value = self._get_val_from_obj(obj)
diff --git a/sentry/views.py b/sentry/views.py
index 21d1351890..8c0d108cbe 100644
--- a/sentry/views.py
+++ b/sentry/views.py
@@ -10,12 +10,7 @@ from sentry.models import GroupedMessage, Message, LOG_LEVELS
 from math import log
 from pygooglechart import SimpleLineChart, Axis
 
-import base64
 import datetime
-try:
-    import cPickle as pickle
-except ImportError:
-    import pickle
 
 def index(request):
     logger_names = SortedDict((l, l) for l in GroupedMessage.objects.values_list('logger', flat=True).distinct())
@@ -104,10 +99,10 @@ def group(request, group_id):
     message_list = Message.objects.filter(checksum=message.checksum, logger=message.logger, view=message.view)
     
     obj = message_list[0]
-    if 'exc' in obj.data:
-        module, args, frames = pickle.loads(base64.b64decode(obj.data['exc']).decode('zlib'))
+    if '__sentry__' in obj.data:
+        module, args, frames = obj.data['__sentry__']['exc']
         obj.class_name = str(obj.class_name)
-
+        
         # We fake the exception class due to many issues with imports/builtins/etc
         exc_type = type(obj.class_name, (Exception,), {})
         exc_value = exc_type(obj.message)
@@ -126,7 +121,7 @@ def group(request, group_id):
         else:
             fake_request.path_info = ''
 
-        reporter = ImprovedExceptionReporter(fake_request, exc_type, exc_value, frames)
+        reporter = ImprovedExceptionReporter(fake_request, exc_type, exc_value, frames, obj.data['__sentry__']['template'])
         traceback = mark_safe(reporter.get_traceback_html())
     else:
         traceback = mark_safe('<pre>%s</pre>' % (message.traceback,))

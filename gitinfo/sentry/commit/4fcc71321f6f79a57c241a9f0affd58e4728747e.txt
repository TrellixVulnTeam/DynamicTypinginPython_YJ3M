commit 4fcc71321f6f79a57c241a9f0affd58e4728747e
Author: Alex Hofsteede <alex@hofsteede.com>
Date:   Thu May 9 14:53:29 2019 -0700

    feat: Track other outcomes (#13067)
    
    These are things that raise APIErrors but that we don't track in
    outcomes at the moment. They may be useful for debugging people's
    integrations, or generally checking our API health.
    
    Note that these outcomes are all Outcome.INVALID, which is only reported
    to legacy TSDB if the `reason` is in the FilterStatsKeys. For all of
    these new ones, that will not be the case, and the metrics will only
    be reported to Kafka/Snuba Outcomes.

diff --git a/src/sentry/tasks/store.py b/src/sentry/tasks/store.py
index 76fb296a2d..8d7ac687d1 100644
--- a/src/sentry/tasks/store.py
+++ b/src/sentry/tasks/store.py
@@ -455,6 +455,8 @@ def _do_save_event(cache_key=None, data=None, start_time=None, event_id=None,
         project_id = data.pop('project')
 
     key_id = None if data is None else data.get('key_id')
+    if key_id is not None:
+        key_id = int(key_id)
     timestamp = to_datetime(start_time) if start_time is not None else None
 
     delete_raw_event(project_id, event_id, allow_hint_clear=True)
diff --git a/src/sentry/utils/outcomes.py b/src/sentry/utils/outcomes.py
index 032d07db9c..c43f2673df 100644
--- a/src/sentry/utils/outcomes.py
+++ b/src/sentry/utils/outcomes.py
@@ -6,10 +6,11 @@ sentry.utils.outcomes.py
 """
 from __future__ import absolute_import
 
-import random
-import time
+from datetime import datetime
 from django.conf import settings
 from enum import IntEnum
+import random
+import time
 
 from sentry import tsdb, options
 from sentry.utils import json, metrics
@@ -50,6 +51,12 @@ def track_outcome(org_id, project_id, key_id, outcome, reason=None, timestamp=No
             )
         )
 
+    assert isinstance(org_id, int)
+    assert isinstance(project_id, int)
+    assert isinstance(key_id, (type(None), int))
+    assert isinstance(outcome, Outcome)
+    assert isinstance(timestamp, (type(None), datetime))
+
     timestamp = timestamp or to_datetime(time.time())
     increment_list = []
     if outcome != Outcome.INVALID:
diff --git a/src/sentry/web/api.py b/src/sentry/web/api.py
index 2631006c2a..29e5f8d75f 100644
--- a/src/sentry/web/api.py
+++ b/src/sentry/web/api.py
@@ -237,22 +237,31 @@ class APIView(BaseView):
         if not project_id:
             return
         if not project_id.isdigit():
+            track_outcome(0, 0, None, Outcome.INVALID, "project_id")
             raise APIError('Invalid project_id: %r' % project_id)
         try:
             return Project.objects.get_from_cache(id=project_id)
         except Project.DoesNotExist:
+            track_outcome(0, 0, None, Outcome.INVALID, "project_id")
             raise APIError('Invalid project_id: %r' % project_id)
 
     def _parse_header(self, request, helper, project):
         auth = self.auth_helper_cls.auth_from_request(request)
 
         if auth.version not in PROTOCOL_VERSIONS:
+            track_outcome(
+                project.organization_id,
+                project.id,
+                None,
+                Outcome.INVALID,
+                "auth_version")
             raise APIError(
                 'Client using unsupported server protocol version (%r)' %
                 six.text_type(auth.version or '')
             )
 
         if not auth.client:
+            track_outcome(project.organization_id, project.id, None, Outcome.INVALID, "auth_client")
             raise APIError("Client did not send 'client' identifier")
 
         return auth
@@ -517,6 +526,7 @@ class StoreView(APIView):
         metrics.incr('events.total', skip_internal=False)
 
         if not data:
+            track_outcome(project.organization_id, project.id, key.id, Outcome.INVALID, "no_data")
             raise APIError('No JSON data was found')
 
         remote_addr = request.META['REMOTE_ADDR']
@@ -575,12 +585,14 @@ class MinidumpView(StoreView):
         # without Origin or Referer headers. Therefore, we cannot validate the
         # origin of the request, but we *can* validate the "prod" key in future.
         if request.method != 'POST':
+            track_outcome(0, 0, None, Outcome.INVALID, "disallowed_method")
             return HttpResponseNotAllowed(['POST'])
 
         content_type = request.META.get('CONTENT_TYPE')
         # In case of multipart/form-data, the Content-Type header also includes
         # a boundary. Therefore, we cannot check for an exact match.
         if content_type is None or not content_type.startswith(self.content_types):
+            track_outcome(0, 0, None, Outcome.INVALID, "content_type")
             raise APIError('Invalid Content-Type')
 
         request.user = AnonymousUser()
@@ -595,6 +607,12 @@ class MinidumpView(StoreView):
 
         key = helper.project_key_from_auth(auth)
         if key.project_id != project.id:
+            track_outcome(
+                project.organization_id,
+                project.id,
+                None,
+                Outcome.INVALID,
+                "multi_project_id")
             raise APIError('Two different projects were specified')
 
         helper.context.bind_auth(auth)
@@ -642,6 +660,12 @@ class MinidumpView(StoreView):
         try:
             minidump = request.FILES['upload_file_minidump']
         except KeyError:
+            track_outcome(
+                project.organization_id,
+                project.id,
+                None,
+                Outcome.INVALID,
+                "missing_minidump_upload")
             raise APIError('Missing minidump upload')
 
         # Breakpad on linux sometimes stores the entire HTTP request body as
@@ -674,9 +698,21 @@ class MinidumpView(StoreView):
             try:
                 minidump = files['upload_file_minidump']
             except KeyError:
+                track_outcome(
+                    project.organization_id,
+                    project.id,
+                    None,
+                    Outcome.INVALID,
+                    "missing_minidump_upload")
                 raise APIError('Missing minidump upload')
 
         if minidump.size == 0:
+            track_outcome(
+                project.organization_id,
+                project.id,
+                None,
+                Outcome.INVALID,
+                "empty_minidump")
             raise APIError('Empty minidump upload received')
 
         if settings.SENTRY_MINIDUMP_CACHE:
@@ -719,6 +755,12 @@ class MinidumpView(StoreView):
             merge_process_state_event(data, state)
         except ProcessMinidumpError as e:
             minidumps_logger.exception(e)
+            track_outcome(
+                project.organization_id,
+                project.id,
+                None,
+                Outcome.INVALID,
+                "process_minidump")
             raise APIError(e.message.split('\n', 1)[0])
 
         event_id = self.process(
@@ -743,10 +785,12 @@ class UnrealView(StoreView):
 
     def _dispatch(self, request, helper, sentry_key, project_id=None, origin=None, *args, **kwargs):
         if request.method != 'POST':
+            track_outcome(0, 0, None, Outcome.INVALID, "disallowed_method")
             return HttpResponseNotAllowed(['POST'])
 
         content_type = request.META.get('CONTENT_TYPE')
         if content_type is None or not content_type.startswith(self.content_types):
+            track_outcome(0, 0, None, Outcome.INVALID, "content_type")
             raise APIError('Invalid Content-Type')
 
         request.user = AnonymousUser()
@@ -759,6 +803,12 @@ class UnrealView(StoreView):
 
         key = helper.project_key_from_auth(auth)
         if key.project_id != project.id:
+            track_outcome(
+                project.organization_id,
+                project.id,
+                None,
+                Outcome.INVALID,
+                "multi_project_id")
             raise APIError('Two different projects were specified')
 
         helper.context.bind_auth(auth)
@@ -783,9 +833,17 @@ class UnrealView(StoreView):
                 if apple_crash_report:
                     merge_apple_crash_report(apple_crash_report, event)
                 else:
+                    track_outcome(project.organization_id, project.id, None,
+                                  Outcome.INVALID, "missing_minidump_unreal")
                     raise APIError("missing minidump in unreal crash report")
         except (ProcessMinidumpError, Unreal4Error) as e:
             minidumps_logger.exception(e)
+            track_outcome(
+                project.organization_id,
+                project.id,
+                None,
+                Outcome.INVALID,
+                "process_minidump_unreal")
             raise APIError(e.message.split('\n', 1)[0])
 
         try:
@@ -861,9 +919,11 @@ class SecurityReportView(StoreView):
         # that triggered the report. The Content-Type is supposed to be
         # `application/csp-report`, but FireFox sends it as `application/json`.
         if request.method != 'POST':
+            track_outcome(0, 0, None, Outcome.INVALID, "disallowed_method")
             return HttpResponseNotAllowed(['POST'])
 
         if request.META.get('CONTENT_TYPE') not in self.content_types:
+            track_outcome(0, 0, None, Outcome.INVALID, "content_type")
             raise APIError('Invalid Content-Type')
 
         request.user = AnonymousUser()
@@ -878,6 +938,12 @@ class SecurityReportView(StoreView):
 
         key = helper.project_key_from_auth(auth)
         if key.project_id != project.id:
+            track_outcome(
+                project.organization_id,
+                project.id,
+                None,
+                Outcome.INVALID,
+                "multi_project_id")
             raise APIError('Two different projects were specified')
 
         helper.context.bind_auth(auth)
@@ -890,12 +956,24 @@ class SecurityReportView(StoreView):
         json_body = safely_load_json_string(request.body)
         report_type = self.security_report_type(json_body)
         if report_type is None:
+            track_outcome(
+                project.organization_id,
+                project.id,
+                key.id,
+                Outcome.INVALID,
+                "security_report_type")
             raise APIError('Unrecognized security report type')
         interface = get_interface(report_type)
 
         try:
             instance = interface.from_raw(json_body)
         except jsonschema.ValidationError as e:
+            track_outcome(
+                project.organization_id,
+                project.id,
+                key.id,
+                Outcome.INVALID,
+                "security_report")
             raise APIError('Invalid security report: %s' % str(e).splitlines()[0])
 
         # Do origin check based on the `document-uri` key as explained in `_dispatch`.

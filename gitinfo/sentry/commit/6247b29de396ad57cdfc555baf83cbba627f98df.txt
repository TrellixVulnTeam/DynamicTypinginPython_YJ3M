commit 6247b29de396ad57cdfc555baf83cbba627f98df
Author: Ted Kaemming <ted@kaemming.com>
Date:   Mon Oct 26 18:51:34 2015 -0700

    Update documentation on digest lifecycle/states.

diff --git a/src/sentry/digests/backends/base.py b/src/sentry/digests/backends/base.py
index eb14ec1255..27a744db58 100644
--- a/src/sentry/digests/backends/base.py
+++ b/src/sentry/digests/backends/base.py
@@ -28,21 +28,42 @@ class Backend(object):
     key. Records within a timeline are also identified by a key that is unique
     with respect to the timeline they are a part of.
 
-    A timeline can be in one of two states: "waiting" or "ready". When the
-    first record is added to a timeline, the timeline transitions to the
-    "waiting" state. This transition also causes the timeline to be scheduled
-    for digestion after the waiting period. After the waiting period expires,
-    the timeline transitions to the "ready" state, which causes the timeline to
-    be digested. After the timeline is digested, it transitions back to the
-    "waiting" state (causing it to be rescheduled) if it contained records. If
-    the timeline did not contain any records when it was digested, it can be
-    deleted (although deletion may be preempted by a new record being added to
-    the timeline, requiring it to be transitioned to "waiting" instead.)
+    A timeline can be in one of two states: "waiting" or "ready".
+
+    When the first record is added to a timeline, the timeline transitions to
+    the "ready" state, and the digest is immediately available to be digested
+    and delivered. (This immediate state change to "ready" allows notifications
+    to be delivered with lower latency.)
+
+    After delivery, the digest transitions to the "waiting" state for the
+    duration of the delay interval. If more items are added to the digest
+    during this waiting period, the schedule is extended incrementally (up to
+    the value defined by the maximum delay option) to allow grouping the more
+    items into a single notification.
+
+    When the "waiting" period is over, the timeline transitions back to the
+    "ready" state, which causes the timeline to be again digested and
+    delivered. After the timeline is digested, it transitions back to the
+    "waiting" state if it contained records. If the timeline did not contain
+    any records when it was digested, it can be deleted (although deletion may
+    be preempted by a new record being added to the timeline, requiring it to
+    be transitioned to "waiting" instead.)
     """
-    interval = 60  # TODO: make option
-    maximum_delay = interval * 5
-
     def __init__(self, **options):
+        # The ``interval`` option defines the minimum amount of time (in
+        # seconds) to wait between scheduling digests for delivery after the
+        # initial scheduling.
+        self.interval = options.pop('interval', 120)
+
+        # The ``maximum_delay`` option defines the maximum amount of time (in
+        # seconds) to wait between scheduling digests for delivery.
+        self.maximum_delay = options.pop('maximum_delay', 60 * 5)
+
+        # The ``increment_delay`` option defines how long each observation of
+        # an event should delay scheduling (up until the ``maximum_delay``
+        # after the last time a digest was processed.)
+        self.increment_delay = options.pop('increment_delay', 5)
+
         # The ``codec`` option provides the strategy for encoding and decoding
         # records in the timeline.
         self.codec = load(options.pop('codec', DEFAULT_CODEC))
diff --git a/src/sentry/digests/backends/redis.py b/src/sentry/digests/backends/redis.py
index f5b0ff04fe..7447ce857a 100644
--- a/src/sentry/digests/backends/redis.py
+++ b/src/sentry/digests/backends/redis.py
@@ -255,7 +255,7 @@ class RedisBackend(Backend):
                 (
                     key,
                     record.timestamp,
-                    5,
+                    self.increment_delay,
                     self.maximum_delay,
                 ),
                 pipeline,

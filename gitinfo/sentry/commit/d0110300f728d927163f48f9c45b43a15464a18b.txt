commit d0110300f728d927163f48f9c45b43a15464a18b
Author: Chris Fuller <cfuller@sentry.io>
Date:   Thu Jan 23 15:25:35 2020 -0500

    ref(workflow): Moving logic from serializer, removing "Unified" serializer, piecemealing unified logic better (#16546)
    
    * Refactor logic into logic.py and more coherent

diff --git a/src/sentry/incidents/endpoints/organization_alert_rule_details.py b/src/sentry/incidents/endpoints/organization_alert_rule_details.py
index 2b6d8e74ce..197c75cbbd 100644
--- a/src/sentry/incidents/endpoints/organization_alert_rule_details.py
+++ b/src/sentry/incidents/endpoints/organization_alert_rule_details.py
@@ -6,7 +6,7 @@ from rest_framework.response import Response
 from sentry.api.serializers import serialize
 from sentry.api.serializers.models.alert_rule import DetailedAlertRuleSerializer
 from sentry.incidents.endpoints.bases import OrganizationAlertRuleEndpoint
-from sentry.incidents.endpoints.serializers import UnifiedAlertRuleSerializer as DrfAlertRuleSerializer
+from sentry.incidents.endpoints.serializers import AlertRuleSerializer as DrfAlertRuleSerializer
 from sentry.incidents.logic import AlreadyDeletedError, delete_alert_rule
 
 
diff --git a/src/sentry/incidents/endpoints/organization_alert_rule_index.py b/src/sentry/incidents/endpoints/organization_alert_rule_index.py
index fcbbcc7260..81982ee3d3 100644
--- a/src/sentry/incidents/endpoints/organization_alert_rule_index.py
+++ b/src/sentry/incidents/endpoints/organization_alert_rule_index.py
@@ -9,7 +9,7 @@ from sentry.api.exceptions import ResourceDoesNotExist
 from sentry.api.paginator import OffsetPaginator
 from sentry.api.serializers import serialize
 from sentry.incidents.models import AlertRule
-from sentry.incidents.endpoints.serializers import UnifiedAlertRuleSerializer
+from sentry.incidents.endpoints.serializers import AlertRuleSerializer
 
 
 class OrganizationAlertRuleIndexEndpoint(OrganizationEndpoint):
@@ -37,7 +37,7 @@ class OrganizationAlertRuleIndexEndpoint(OrganizationEndpoint):
         if not features.has("organizations:incidents", organization, actor=request.user):
             raise ResourceDoesNotExist
 
-        serializer = UnifiedAlertRuleSerializer(
+        serializer = AlertRuleSerializer(
             context={"organization": organization, "access": request.access}, data=request.data
         )
 
diff --git a/src/sentry/incidents/endpoints/serializers.py b/src/sentry/incidents/endpoints/serializers.py
index 1dd14ac4f9..bcbc033abd 100644
--- a/src/sentry/incidents/endpoints/serializers.py
+++ b/src/sentry/incidents/endpoints/serializers.py
@@ -8,8 +8,6 @@ import operator
 from enum import Enum
 from rest_framework import serializers
 
-from django.db import transaction
-
 from sentry.api.serializers.rest_framework.base import CamelSnakeModelSerializer
 from sentry.api.serializers.rest_framework.project import ProjectField
 from sentry.incidents.logic import (
@@ -241,31 +239,24 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
      - `access`: An access object (from `request.access`)
     """
 
-    # XXX: ArrayFields aren't supported automatically until DRF 3.1
-    aggregations = serializers.ListField(child=serializers.IntegerField(), required=False)
     # TODO: These might be slow for many projects, since it will query for each
     # individually. If we find this to be a problem then we can look into batching.
     projects = serializers.ListField(child=ProjectField(), required=False)
     excluded_projects = serializers.ListField(child=ProjectField(), required=False)
-    threshold_type = serializers.IntegerField(required=False)
-    alert_threshold = serializers.IntegerField(required=False)
-    resolve_threshold = serializers.IntegerField(required=False)
+    triggers = AlertRuleTriggerSerializer(many=True, required=True)
 
     class Meta:
         model = AlertRule
         fields = [
             "name",
-            "threshold_type",
             "query",
             "time_window",
-            "alert_threshold",
-            "resolve_threshold",
             "threshold_period",
             "aggregation",
-            "aggregations",
             "projects",
             "include_all_projects",
             "excluded_projects",
+            "triggers",
         ]
         extra_kwargs = {
             "query": {"allow_blank": True, "required": True},
@@ -289,86 +280,6 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
                 % [item.value for item in QueryAggregations]
             )
 
-    def validate_aggregations(self, aggregations):
-        # TODO: Remove this once FE transitions
-        try:
-            return [QueryAggregations(agg) for agg in aggregations]
-        except ValueError:
-            raise serializers.ValidationError(
-                "Invalid aggregation, valid values are %s"
-                % [item.value for item in QueryAggregations]
-            )
-
-    def validate(self, data):
-        return self._handle_old_fields_transition(data)
-
-    def create(self, validated_data):
-        try:
-            # TODO: Remove this, just temporary while we're supporting both fields.
-            if "aggregation" not in validated_data:
-                raise serializers.ValidationError("aggregation is required")
-
-            return create_alert_rule(organization=self.context["organization"], **validated_data)
-        except AlertRuleNameAlreadyUsedError:
-            raise serializers.ValidationError("This name is already in use for this project")
-
-    def _remove_unchanged_fields(self, instance, validated_data):
-        for field_name, value in list(six.iteritems(validated_data)):
-            # Remove any fields that haven't actually changed
-            if field_name == "triggers":
-                continue  # No removal for triggers
-
-            if field_name == "projects":
-                project_slugs = Project.objects.filter(
-                    querysubscription__alert_rules=instance
-                ).values_list("slug", flat=True)
-                if set(project_slugs) == set([project.slug for project in value]):
-                    validated_data.pop(field_name)
-                continue
-            if field_name == "excluded_projects":
-                excluded_slugs = [
-                    p.project.slug for p in get_excluded_projects_for_alert_rule(instance)
-                ]
-                if set(excluded_slugs) == set(project.slug for project in value):
-                    validated_data.pop(field_name)
-                continue
-            if isinstance(value, Enum):
-                value = value.value
-            if getattr(instance, field_name) == value:
-                validated_data.pop(field_name)
-        return validated_data
-
-    def _handle_old_fields_transition(self, validated_data):
-        # Temporary methods for transitioning from multiple aggregations to a single
-        # aggregate
-        if "aggregations" in validated_data and "aggregation" not in validated_data:
-            validated_data["aggregation"] = validated_data["aggregations"][0]
-
-        validated_data.pop("aggregations", None)
-        # TODO: Remove after frontend stops using these fields
-        validated_data.pop("threshold_type", None)
-        validated_data.pop("alert_threshold", None)
-        validated_data.pop("resolve_threshold", None)
-        return validated_data
-
-    def update(self, instance, validated_data):
-        validated_data = self._remove_unchanged_fields(instance, validated_data)
-        return update_alert_rule(instance, **validated_data)
-
-
-class UnifiedAlertRuleSerializer(AlertRuleSerializer):
-    """
-    Unified Serializer for creating/updating an alert rule - accepts trigger and action data, and does validation on it.
-    Required context:
-     - `organization`: The organization related to this alert rule.
-     - `access`: An access object (from `request.access`)
-    """
-
-    triggers = AlertRuleTriggerSerializer(many=True, required=True)
-
-    class Meta(AlertRuleSerializer.Meta):
-        fields = AlertRuleSerializer.Meta.fields + ["triggers"]
-
     def validate(self, data):
         """Performs validation on an alert rule's data
         This includes ensuring there is either 1 or 2 triggers, which each have actions, and have proper thresholds set.
@@ -456,71 +367,48 @@ class UnifiedAlertRuleSerializer(AlertRuleSerializer):
         else:
             raise serializers.ValidationError("Must include at least one trigger")
 
-        return super(UnifiedAlertRuleSerializer, self)._handle_old_fields_transition(data)
-
-    def create(self, validated_data):
-        with transaction.atomic():
-            try:
-                # TODO: Remove this, just temporary while we're supporting both fields.
-                if "aggregation" not in validated_data:
-                    raise serializers.ValidationError("aggregation is required")
-
-                triggers_data = validated_data.pop("triggers")
-                # TODO: User super.create and don't duplicate the aggreagation + duplicate name check?
-                alert_rule = create_alert_rule(
-                    organization=self.context["organization"], **validated_data
-                )
-                for trigger_data in triggers_data:
-                    trigger_actions_data = trigger_data.pop("actions")
-                    trigger = create_alert_rule_trigger(alert_rule=alert_rule, **trigger_data)
-                    for actions_data in trigger_actions_data:
-                        create_alert_rule_trigger_action(trigger=trigger, **actions_data)
-                return alert_rule
-            except AlertRuleNameAlreadyUsedError:
-                raise serializers.ValidationError("This name is already in use for this project")
+        return data
 
-    def update(self, instance, validated_data):
-        with transaction.atomic():
-            validated_data = self._remove_unchanged_fields(instance, validated_data)
-            triggers_data = validated_data.pop("triggers")
-            alert_rule = update_alert_rule(instance, **validated_data)
-
-            # Delete triggers we don't have present in the updated data.
-            trigger_ids = [x["id"] for x in triggers_data]
-            AlertRuleTrigger.objects.filter(alert_rule=alert_rule).exclude(
-                id__in=trigger_ids
-            ).delete()
-
-            for trigger_data in triggers_data:
-                actions_data = trigger_data.pop("actions")
-                try:
-                    if "id" in trigger_data:
-                        trigger_instance = AlertRuleTrigger.objects.get(
-                            alert_rule=alert_rule, id=trigger_data["id"]
-                        )
-                        trigger_data.pop("id")
-                        trigger = update_alert_rule_trigger(trigger_instance, **trigger_data)
-                    else:
-                        trigger = create_alert_rule_trigger(alert_rule=alert_rule, **trigger_data)
-                except AlertRuleTriggerLabelAlreadyUsedError:
-                    raise serializers.ValidationError(
-                        "This trigger label is already in use for this alert rule"
-                    )
+    def _remove_unchanged_fields(self, instance, validated_data):
+        for field_name, value in list(six.iteritems(validated_data)):
+            # Remove any fields that haven't actually changed
+            if field_name == "triggers":
+                continue  # No removal for triggers
 
-                # Delete actions we don't have present in the updated data.
-                action_ids = [x["id"] for x in actions_data]
-                AlertRuleTriggerAction.objects.filter(alert_rule_trigger=trigger).exclude(
-                    id__in=action_ids
-                ).delete()
+            if field_name == "projects":
+                project_slugs = Project.objects.filter(
+                    querysubscription__alert_rules=instance
+                ).values_list("slug", flat=True)
+                if set(project_slugs) == set([project.slug for project in value]):
+                    validated_data.pop(field_name)
+                continue
+            if field_name == "excluded_projects":
+                excluded_slugs = [
+                    p.project.slug for p in get_excluded_projects_for_alert_rule(instance)
+                ]
+                if set(excluded_slugs) == set(project.slug for project in value):
+                    validated_data.pop(field_name)
+                continue
+            if isinstance(value, Enum):
+                value = value.value
+            if getattr(instance, field_name) == value:
+                validated_data.pop(field_name)
+        return validated_data
 
-                for action_data in actions_data:
-                    if "id" in action_data:
-                        action_instance = AlertRuleTriggerAction.objects.get(
-                            alert_rule_trigger=trigger, id=action_data["id"]
-                        )
-                        action_data.pop("id")
-                        update_alert_rule_trigger_action(action_instance, **action_data)
-                    else:
-                        create_alert_rule_trigger_action(trigger=trigger, **action_data)
+    def create(self, validated_data):
+        try:
+            # TODO: Remove this, just temporary while we're supporting both fields.
+            if "aggregation" not in validated_data:
+                raise serializers.ValidationError("aggregation is required")
 
+            alert_rule = create_alert_rule(
+                organization=self.context["organization"], **validated_data
+            )
             return alert_rule
+        except AlertRuleNameAlreadyUsedError:
+            raise serializers.ValidationError("This name is already in use for this project")
+
+    def update(self, instance, validated_data):
+        validated_data = self._remove_unchanged_fields(instance, validated_data)
+        alert_rule = update_alert_rule(instance, **validated_data)
+        return alert_rule
diff --git a/src/sentry/incidents/logic.py b/src/sentry/incidents/logic.py
index 79b3da7ce6..3283e0fba2 100644
--- a/src/sentry/incidents/logic.py
+++ b/src/sentry/incidents/logic.py
@@ -2,6 +2,7 @@ from __future__ import absolute_import
 
 from collections import defaultdict
 from datetime import timedelta
+from rest_framework import serializers
 from uuid import uuid4
 
 import pytz
@@ -621,6 +622,8 @@ def create_alert_rule(
     from this organization
     :param excluded_projects: List of projects to exclude if we're using
     `include_all_projects`.
+    :param actions: A list of alert rule triggers for this for this rule
+
     :return: The created `AlertRule`
     """
     dataset = QueryDatasets.EVENTS
@@ -652,6 +655,11 @@ def create_alert_rule(
             AlertRuleExcludedProjects.objects.bulk_create(exclusions)
 
         subscribe_projects_to_alert_rule(alert_rule, projects)
+
+        if triggers:
+            for trigger_data in triggers:
+                create_alert_rule_trigger(alert_rule=alert_rule, **trigger_data)
+
     return alert_rule
 
 
@@ -791,6 +799,28 @@ def update_alert_rule(
                 timedelta(minutes=DEFAULT_ALERT_RULE_RESOLUTION),
             )
 
+        if triggers is not None:
+            # Delete triggers we don't have present in the updated data.
+            trigger_ids = [x["id"] for x in triggers if "id" in x]
+            AlertRuleTrigger.objects.filter(alert_rule=alert_rule).exclude(
+                id__in=trigger_ids
+            ).delete()
+
+            for trigger_data in triggers:
+                try:
+                    if "id" in trigger_data:
+                        trigger_instance = AlertRuleTrigger.objects.get(
+                            alert_rule=alert_rule, id=trigger_data["id"]
+                        )
+                        trigger_data.pop("id")
+                        update_alert_rule_trigger(trigger_instance, **trigger_data)
+                    else:
+                        create_alert_rule_trigger(alert_rule=alert_rule, **trigger_data)
+                except AlertRuleTriggerLabelAlreadyUsedError:
+                    raise serializers.ValidationError(
+                        "This trigger label is already in use for this alert rule"
+                    )
+
     return alert_rule
 
 
@@ -878,6 +908,7 @@ def create_alert_rule_trigger(
     resolve the alert
     :param excluded_projects: A list of Projects that should be excluded from this
     trigger. These projects must be associate with the alert rule already
+    :param actions: A list of alert rule trigger actions for this trigger
     :return: The created AlertRuleTrigger
     """
     if AlertRuleTrigger.objects.filter(alert_rule=alert_rule, label=label).exists():
@@ -901,6 +932,11 @@ def create_alert_rule_trigger(
                 for sub in excluded_subs
             ]
             AlertRuleTriggerExclusion.objects.bulk_create(new_exclusions)
+
+        if actions:
+            for action_data in actions:
+                create_alert_rule_trigger_action(trigger=trigger, **action_data)
+
     return trigger
 
 
@@ -923,6 +959,7 @@ def update_alert_rule_trigger(
     resolve the alert
     :param excluded_projects: A list of Projects that should be excluded from this
     trigger. These projects must be associate with the alert rule already
+    :param actions: A list of alert rule trigger actions for this trigger
     :return: The updated AlertRuleTrigger
     """
 
@@ -973,6 +1010,22 @@ def update_alert_rule_trigger(
             ]
             AlertRuleTriggerExclusion.objects.bulk_create(new_exclusions)
 
+        if actions is not None:
+            # Delete actions we don't have present in the updated data.
+            action_ids = [x["id"] for x in actions if "id" in x]
+            AlertRuleTriggerAction.objects.filter(alert_rule_trigger=trigger).exclude(
+                id__in=action_ids
+            ).delete()
+
+            for action_data in actions:
+                if "id" in action_data:
+                    action_instance = AlertRuleTriggerAction.objects.get(
+                        alert_rule_trigger=trigger, id=action_data["id"]
+                    )
+                    action_data.pop("id")
+                    update_alert_rule_trigger_action(action_instance, **action_data)
+                else:
+                    create_alert_rule_trigger_action(trigger=trigger, **action_data)
     return trigger
 
 
diff --git a/tests/sentry/incidents/endpoints/test_organization_alert_rule_details.py b/tests/sentry/incidents/endpoints/test_organization_alert_rule_details.py
index 0b15814aca..754e652812 100644
--- a/tests/sentry/incidents/endpoints/test_organization_alert_rule_details.py
+++ b/tests/sentry/incidents/endpoints/test_organization_alert_rule_details.py
@@ -10,7 +10,7 @@ from exam import fixture
 from sentry.api.serializers import serialize
 from sentry.api.serializers.models.alert_rule import DetailedAlertRuleSerializer
 from sentry.auth.access import OrganizationGlobalAccess
-from sentry.incidents.endpoints.serializers import UnifiedAlertRuleSerializer
+from sentry.incidents.endpoints.serializers import AlertRuleSerializer
 from sentry.incidents.models import AlertRule
 from sentry.testutils import APITestCase
 
@@ -66,7 +66,7 @@ class AlertRuleDetailsBase(object):
         if data is None:
             data = deepcopy(self.alert_rule_dict)
 
-        serializer = UnifiedAlertRuleSerializer(
+        serializer = AlertRuleSerializer(
             context={
                 "organization": self.organization,
                 "access": OrganizationGlobalAccess(self.organization),
diff --git a/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py b/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
index 91e460f242..9c6c68eb0f 100644
--- a/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
+++ b/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
@@ -12,6 +12,41 @@ from sentry.testutils import APITestCase
 class AlertRuleDetailsBase(object):
     endpoint = "sentry-api-0-project-alert-rule-details"
 
+    @fixture
+    def valid_params(self):
+        return {
+            "name": "hello",
+            "time_window": 10,
+            "query": "level:error",
+            "threshold_type": 0,
+            "resolve_threshold": 1,
+            "alert_threshold": 0,
+            "aggregation": 0,
+            "threshold_period": 1,
+            "projects": [self.project.slug],
+            "triggers": [
+                {
+                    "label": "critical",
+                    "alertThreshold": 200,
+                    "resolveThreshold": 100,
+                    "thresholdType": 0,
+                    "actions": [
+                        {"type": "email", "targetType": "team", "targetIdentifier": self.team.id}
+                    ],
+                },
+                {
+                    "label": "warning",
+                    "alertThreshold": 150,
+                    "resolveThreshold": 100,
+                    "thresholdType": 0,
+                    "actions": [
+                        {"type": "email", "targetType": "team", "targetIdentifier": self.team.id},
+                        {"type": "email", "targetType": "user", "targetIdentifier": self.user.id},
+                    ],
+                },
+            ],
+        }
+
     @fixture
     def organization(self):
         return self.create_organization()
@@ -83,10 +118,13 @@ class AlertRuleDetailsPutEndpointTest(AlertRuleDetailsBase, APITestCase):
             user=self.user, organization=self.organization, role="owner", teams=[self.team]
         )
 
+        test_params = self.valid_params.copy()
+        test_params.update({"name": "what"})
+
         self.login_as(self.user)
         with self.feature("organizations:incidents"):
             resp = self.get_valid_response(
-                self.organization.slug, self.project.slug, self.alert_rule.id, name="what"
+                self.organization.slug, self.project.slug, self.alert_rule.id, **test_params
             )
 
         self.alert_rule.name = "what"
@@ -94,6 +132,9 @@ class AlertRuleDetailsPutEndpointTest(AlertRuleDetailsBase, APITestCase):
         assert resp.data["name"] == "what"
 
     def test_not_updated_fields(self):
+        test_params = self.valid_params.copy()
+        test_params.update({"aggregation": self.alert_rule.aggregation})
+
         self.create_member(
             user=self.user, organization=self.organization, role="owner", teams=[self.team]
         )
@@ -101,10 +142,7 @@ class AlertRuleDetailsPutEndpointTest(AlertRuleDetailsBase, APITestCase):
         self.login_as(self.user)
         with self.feature("organizations:incidents"):
             resp = self.get_valid_response(
-                self.organization.slug,
-                self.project.slug,
-                self.alert_rule.id,
-                aggregation=self.alert_rule.aggregation,
+                self.organization.slug, self.project.slug, self.alert_rule.id, **test_params
             )
 
         existing_sub = self.alert_rule.query_subscriptions.first()
diff --git a/tests/sentry/incidents/endpoints/test_project_alert_rule_index.py b/tests/sentry/incidents/endpoints/test_project_alert_rule_index.py
index d6bb613458..0f961ac5af 100644
--- a/tests/sentry/incidents/endpoints/test_project_alert_rule_index.py
+++ b/tests/sentry/incidents/endpoints/test_project_alert_rule_index.py
@@ -82,19 +82,28 @@ class AlertRuleCreateEndpointTest(APITestCase):
             user=self.user, organization=self.organization, role="owner", teams=[self.team]
         )
         self.login_as(self.user)
-        name = "an alert"
-        query = "hi"
-        aggregation = 0
-        time_window = 10
+        valid_alert_rule = {
+            "aggregation": 0,
+            "aggregations": [0],
+            "query": "",
+            "timeWindow": "300",
+            "triggers": [
+                {
+                    "label": "critical",
+                    "alertThreshold": 200,
+                    "resolveThreshold": 100,
+                    "thresholdType": 0,
+                    "actions": [
+                        {"type": "email", "targetType": "team", "targetIdentifier": self.team.id}
+                    ],
+                }
+            ],
+            "projects": [self.project.slug],
+            "name": "JustAValidTestRule",
+        }
         with self.feature("organizations:incidents"):
             resp = self.get_valid_response(
-                self.organization.slug,
-                self.project.slug,
-                name=name,
-                query=query,
-                aggregation=aggregation,
-                timeWindow=time_window,
-                status_code=201,
+                self.organization.slug, self.project.slug, status_code=201, **valid_alert_rule
             )
         assert "id" in resp.data
         alert_rule = AlertRule.objects.get(id=resp.data["id"])
diff --git a/tests/sentry/incidents/endpoints/test_serializers.py b/tests/sentry/incidents/endpoints/test_serializers.py
index f438c79427..c6227112ad 100644
--- a/tests/sentry/incidents/endpoints/test_serializers.py
+++ b/tests/sentry/incidents/endpoints/test_serializers.py
@@ -28,15 +28,36 @@ class TestAlertRuleSerializer(TestCase):
     @fixture
     def valid_params(self):
         return {
-            "name": "something",
+            "name": "hello",
             "time_window": 10,
-            "query": "hi",
+            "query": "level:error",
             "threshold_type": 0,
             "resolve_threshold": 1,
             "alert_threshold": 0,
             "aggregation": 0,
             "threshold_period": 1,
             "projects": [self.project.slug],
+            "triggers": [
+                {
+                    "label": "critical",
+                    "alertThreshold": 200,
+                    "resolveThreshold": 100,
+                    "thresholdType": 0,
+                    "actions": [
+                        {"type": "email", "targetType": "team", "targetIdentifier": self.team.id}
+                    ],
+                },
+                {
+                    "label": "warning",
+                    "alertThreshold": 150,
+                    "resolveThreshold": 100,
+                    "thresholdType": 0,
+                    "actions": [
+                        {"type": "email", "targetType": "team", "targetIdentifier": self.team.id},
+                        {"type": "email", "targetType": "user", "targetIdentifier": self.user.id},
+                    ],
+                },
+            ],
         }
 
     @fixture
@@ -47,6 +68,13 @@ class TestAlertRuleSerializer(TestCase):
     def context(self):
         return {"organization": self.organization, "access": self.access}
 
+    def Any(self, cls):
+        class Any(object):
+            def __eq__(self, other):
+                return isinstance(other, cls)
+
+        return Any()
+
     def run_fail_validation_test(self, params, errors):
         base_params = self.valid_params.copy()
         base_params.update(params)
@@ -62,6 +90,7 @@ class TestAlertRuleSerializer(TestCase):
             "name": field_is_required,
             "timeWindow": field_is_required,
             "query": field_is_required,
+            "triggers": field_is_required,
         }
 
     def test_time_window(self):
@@ -86,16 +115,27 @@ class TestAlertRuleSerializer(TestCase):
         self.run_fail_validation_test({"aggregation": 50}, {"aggregation": invalid_values})
 
     def _run_changed_fields_test(self, alert_rule, params, expected):
+        test_params = self.valid_params.copy()
+        test_params.update(params)
+
+        expected.update({"triggers": self.Any(list)})
         serializer = AlertRuleSerializer(
-            context=self.context, instance=alert_rule, data=params, partial=True
+            context=self.context, instance=alert_rule, data=test_params, partial=True
         )
+
         assert serializer.is_valid(), serializer.errors
+
         assert (
             serializer._remove_unchanged_fields(alert_rule, serializer.validated_data) == expected
         )
 
     def test_remove_unchanged_fields(self):
-        projects = [self.project, self.create_project()]
+        a_project = self.create_project()
+        projects = [self.project, a_project]
+
+        test_params = self.valid_params.copy()
+        test_params.update({"projects": [self.project.slug, a_project.slug]})
+
         name = "hello"
         query = "level:error"
         aggregation = QueryAggregations.TOTAL
@@ -103,7 +143,6 @@ class TestAlertRuleSerializer(TestCase):
         alert_rule = create_alert_rule(
             self.organization, projects, name, query, aggregation, time_window, 1
         )
-
         self._run_changed_fields_test(
             alert_rule,
             {
@@ -116,31 +155,54 @@ class TestAlertRuleSerializer(TestCase):
             {},
         )
 
-        self._run_changed_fields_test(alert_rule, {"projects": [p.slug for p in projects]}, {})
+        temp_params = test_params.copy()
+        temp_params.update({"projects": [p.slug for p in projects]})
+        self._run_changed_fields_test(alert_rule, temp_params, {})
+
         self._run_changed_fields_test(
             alert_rule, {"projects": [self.project.slug]}, {"projects": [self.project]}
         )
 
-        self._run_changed_fields_test(alert_rule, {"name": name}, {})
-        self._run_changed_fields_test(alert_rule, {"name": "a name"}, {"name": "a name"})
+        temp_params = test_params.copy()
+        temp_params.update({"name": name})
+        self._run_changed_fields_test(alert_rule, temp_params, {})
 
-        self._run_changed_fields_test(alert_rule, {"query": query}, {})
-        self._run_changed_fields_test(
-            alert_rule, {"query": "level:warning"}, {"query": "level:warning"}
-        )
+        temp_params = test_params.copy()
+        temp_params.update({"name": "a name"})
+        self._run_changed_fields_test(alert_rule, temp_params, {"name": "a name"})
+
+        temp_params = test_params.copy()
+        temp_params.update({"query": query})
+        self._run_changed_fields_test(alert_rule, temp_params, {})
 
-        self._run_changed_fields_test(alert_rule, {"aggregation": aggregation.value}, {})
+        temp_params = test_params.copy()
+        temp_params.update({"query": "level:warning"})
+        self._run_changed_fields_test(alert_rule, temp_params, {"query": "level:warning"})
+
+        temp_params = test_params.copy()
+        temp_params.update({"aggregation": aggregation.value})
+        self._run_changed_fields_test(alert_rule, temp_params, {})
+
+        temp_params = test_params.copy()
+        temp_params.update({"aggregation": 1})
         self._run_changed_fields_test(
-            alert_rule, {"aggregation": 1}, {"aggregation": QueryAggregations.UNIQUE_USERS}
+            alert_rule, temp_params, {"aggregation": QueryAggregations.UNIQUE_USERS}
         )
 
-        self._run_changed_fields_test(alert_rule, {"time_window": time_window}, {})
-        self._run_changed_fields_test(alert_rule, {"time_window": 20}, {"time_window": 20})
+        temp_params = test_params.copy()
+        temp_params.update({"time_window": time_window})
+        self._run_changed_fields_test(alert_rule, temp_params, {})
+
+        temp_params = test_params.copy()
+        temp_params.update({"time_window": 20})
+        self._run_changed_fields_test(alert_rule, temp_params, {"time_window": 20})
 
     def test_remove_unchanged_fields_include_all(self):
         projects = [self.project]
         excluded = [self.create_project()]
-        alert_rule = self.create_alert_rule(include_all_projects=True, excluded_projects=excluded)
+        alert_rule = self.create_alert_rule(
+            name="hello", include_all_projects=True, excluded_projects=excluded
+        )
 
         self._run_changed_fields_test(
             alert_rule,

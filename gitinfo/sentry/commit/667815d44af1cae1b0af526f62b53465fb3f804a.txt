commit 667815d44af1cae1b0af526f62b53465fb3f804a
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Tue Apr 21 16:31:21 2020 -0700

    ref(ts): Refactor `<GroupDetails>` (#18368)
    
    Convert to typescript, cleaned up and fixed "issue not found" code path, added tests.

diff --git a/src/sentry/static/sentry/app/utils/recreateRoute.tsx b/src/sentry/static/sentry/app/utils/recreateRoute.tsx
index 3db7beee3e..d830e2731a 100644
--- a/src/sentry/static/sentry/app/utils/recreateRoute.tsx
+++ b/src/sentry/static/sentry/app/utils/recreateRoute.tsx
@@ -47,9 +47,12 @@ export default function recreateRoute(to: string | PlainRoute, options: Options)
     baseRoute = baseRoute.slice(0, stepBack);
   }
 
-  const query = typeof location !== 'undefined' && location.search ? location.search : '';
+  const search = location?.search ?? '';
+  const hash = location?.hash ?? '';
 
-  const fullRoute = `${baseRoute.join('')}${typeof to !== 'string' ? '' : to}${query}`;
+  const fullRoute = `${baseRoute.join('')}${
+    typeof to !== 'string' ? '' : to
+  }${search}${hash}`;
 
   return replaceRouterParams(fullRoute, params);
 }
diff --git a/src/sentry/static/sentry/app/views/organizationGroupDetails/groupDetails.jsx b/src/sentry/static/sentry/app/views/organizationGroupDetails/groupDetails.jsx
deleted file mode 100644
index 2dcc95b7f7..0000000000
--- a/src/sentry/static/sentry/app/views/organizationGroupDetails/groupDetails.jsx
+++ /dev/null
@@ -1,289 +0,0 @@
-import {browserHistory} from 'react-router';
-import DocumentTitle from 'react-document-title';
-import PropTypes from 'prop-types';
-import React from 'react';
-import Reflux from 'reflux';
-import * as Sentry from '@sentry/browser';
-import createReactClass from 'create-react-class';
-import isEqual from 'lodash/isEqual';
-
-import {PageContent} from 'app/styles/organization';
-import {t} from 'app/locale';
-import GlobalSelectionHeader from 'app/components/organizations/globalSelectionHeader';
-import GroupStore from 'app/stores/groupStore';
-import LoadingError from 'app/components/loadingError';
-import LoadingIndicator from 'app/components/loadingIndicator';
-import Projects from 'app/utils/projects';
-import SentryTypes from 'app/sentryTypes';
-import withProfiler from 'app/utils/withProfiler';
-import withApi from 'app/utils/withApi';
-
-import {ERROR_TYPES} from './constants';
-import GroupHeader from './header';
-
-const GroupDetails = createReactClass({
-  displayName: 'GroupDetails',
-
-  propTypes: {
-    api: PropTypes.object,
-
-    organization: SentryTypes.Organization,
-    environments: PropTypes.arrayOf(PropTypes.string),
-
-    finishProfile: PropTypes.func,
-  },
-
-  childContextTypes: {
-    group: SentryTypes.Group,
-    location: PropTypes.object,
-  },
-
-  mixins: [Reflux.listenTo(GroupStore, 'onGroupChange')],
-
-  getInitialState() {
-    return {
-      group: null,
-      loading: true,
-      error: false,
-      errorType: null,
-    };
-  },
-
-  getChildContext() {
-    return {
-      group: this.state.group,
-      location: this.props.location,
-    };
-  },
-
-  componentWillMount() {
-    this.fetchData();
-  },
-
-  componentWillReceiveProps(nextProps) {
-    if (nextProps.params.groupId !== this.props.params.groupId) {
-      this.remountComponent();
-    }
-  },
-
-  componentDidUpdate(prevProps, prevState) {
-    if (
-      prevProps.params.groupId !== this.props.params.groupId ||
-      !isEqual(prevProps.environments, this.props.environments)
-    ) {
-      this.fetchData();
-    }
-
-    if (
-      prevState.loading &&
-      !this.state.loading &&
-      typeof this.props.finishProfile === 'function'
-    ) {
-      this.props.finishProfile();
-    }
-  },
-
-  remountComponent() {
-    this.setState(this.getInitialState());
-  },
-
-  fetchData() {
-    const query = {};
-
-    if (this.props.environments) {
-      query.environment = this.props.environments;
-    }
-
-    this.props.api.request(this.getGroupDetailsEndpoint(), {
-      query,
-      success: data => {
-        // TODO: Ideally, this would rebuild the route before parameter
-        // interpolation, replace the `groupId` field of `this.routeParams`,
-        // and use `formatPattern` from `react-router` to rebuild the URL,
-        // rather than blindly pattern matching like we do here. Unfortunately,
-        // `formatPattern` isn't actually exported until `react-router` 2.0.1:
-        // https://github.com/reactjs/react-router/blob/v2.0.1/modules/index.js#L25
-        if (this.props.params.groupId !== data.id) {
-          const location = this.props.location;
-          browserHistory.push(
-            location.pathname.replace(
-              `/issues/${this.props.params.groupId}/`,
-              `/issues/${data.id}/`
-            ) +
-              location.search +
-              location.hash
-          );
-          return;
-        }
-        const project = data.project;
-
-        if (!project) {
-          Sentry.withScope(() => {
-            Sentry.captureException(new Error('Project not found'));
-          });
-        } else {
-          const locationWithProject = {...this.props.location};
-          if (
-            locationWithProject.query.project === undefined &&
-            locationWithProject.query._allp === undefined
-          ) {
-            //We use _allp as a temporary measure to know they came from the issue list page with no project selected (all projects included in filter).
-            //If it is not defined, we add the locked project id to the URL (this is because if someone navigates directly to an issue on single-project priveleges, then goes back - they were getting assigned to the first project).
-            //If it is defined, we do not so that our back button will bring us to the issue list page with no project selected instead of the locked project.
-            locationWithProject.query.project = project.id;
-          }
-          delete locationWithProject.query._allp; //We delete _allp from the URL to keep the hack a bit cleaner, but this is not an ideal solution and will ultimately be replaced with something smarter.
-          browserHistory.replace(locationWithProject);
-        }
-
-        this.setState({
-          loading: false,
-          error: false,
-          errorType: null,
-          project,
-        });
-
-        GroupStore.loadInitialData([data]);
-      },
-      error: (_, _textStatus, errorThrown) => {
-        let errorType = null;
-        switch (errorThrown) {
-          case 'NOT FOUND':
-            errorType = ERROR_TYPES.GROUP_NOT_FOUND;
-            break;
-          default:
-        }
-        this.setState({
-          loading: false,
-          error: true,
-          errorType,
-        });
-      },
-    });
-  },
-
-  onGroupChange(itemIds) {
-    const id = this.props.params.groupId;
-    if (itemIds.has(id)) {
-      const group = GroupStore.get(id);
-      if (group) {
-        if (group.stale) {
-          this.fetchData();
-          return;
-        }
-        this.setState({
-          group,
-        });
-      }
-    }
-  },
-
-  getGroupDetailsEndpoint() {
-    const id = this.props.params.groupId;
-
-    return '/issues/' + id + '/';
-  },
-
-  getTitle() {
-    const group = this.state.group;
-
-    if (!group) {
-      return 'Sentry';
-    }
-
-    switch (group.type) {
-      case 'error':
-        if (group.metadata.type && group.metadata.value) {
-          return `${group.metadata.type}: ${group.metadata.value}`;
-        }
-        return group.metadata.type || group.metadata.value;
-      case 'csp':
-        return group.metadata.message;
-      case 'expectct':
-      case 'expectstaple':
-      case 'hpkp':
-        return group.metadata.message;
-      case 'default':
-        return group.metadata.title;
-      default:
-        return '';
-    }
-  },
-
-  renderContent(project) {
-    const {children, environments} = this.props;
-    const {group} = this.state;
-
-    return (
-      <PageContent>
-        <DocumentTitle title={this.getTitle()}>
-          <div>
-            <GroupHeader project={project} group={group} />
-            {React.cloneElement(children, {
-              environments,
-              group,
-              project,
-            })}
-          </div>
-        </DocumentTitle>
-      </PageContent>
-    );
-  },
-
-  render() {
-    const {organization} = this.props;
-    const {group, project, loading} = this.state;
-
-    if (this.state.error) {
-      switch (this.state.errorType) {
-        case ERROR_TYPES.GROUP_NOT_FOUND:
-          return (
-            <div className="alert alert-block">
-              {t('The issue you were looking for was not found.')}
-            </div>
-          );
-        default:
-          return <LoadingError onRetry={this.remountComponent} />;
-      }
-    }
-
-    const isLoading = loading || !group;
-
-    return (
-      <React.Fragment>
-        <GlobalSelectionHeader
-          organization={organization}
-          forceProject={project}
-          showDateSelector={false}
-          shouldForceProject
-          lockedMessageSubject={t('issue')}
-          showIssueStreamLink
-          showProjectSettingsLink
-        />
-        {isLoading ? (
-          <PageContent>
-            <LoadingIndicator />
-          </PageContent>
-        ) : (
-          <Projects orgId={organization.slug} slugs={[project.slug]}>
-            {({projects, initiallyLoaded, fetchError}) =>
-              initiallyLoaded ? (
-                fetchError ? (
-                  <LoadingError message={t('Error loading the specified project')} />
-                ) : (
-                  this.renderContent(projects[0])
-                )
-              ) : (
-                <LoadingIndicator />
-              )
-            }
-          </Projects>
-        )}
-      </React.Fragment>
-    );
-  },
-});
-
-export {GroupDetails};
-
-export default withApi(withProfiler(GroupDetails));
diff --git a/src/sentry/static/sentry/app/views/organizationGroupDetails/groupDetails.tsx b/src/sentry/static/sentry/app/views/organizationGroupDetails/groupDetails.tsx
new file mode 100644
index 0000000000..47fd9d8ba7
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/organizationGroupDetails/groupDetails.tsx
@@ -0,0 +1,291 @@
+import DocumentTitle from 'react-document-title';
+import PropTypes from 'prop-types';
+import React from 'react';
+import * as ReactRouter from 'react-router';
+import * as Sentry from '@sentry/browser';
+
+import {Client} from 'app/api';
+import {Group, Organization, Project} from 'app/types';
+import {IconInfo} from 'app/icons';
+import {PageContent} from 'app/styles/organization';
+import {callIfFunction} from 'app/utils/callIfFunction';
+import {t} from 'app/locale';
+import Alert from 'app/components/alert';
+import GlobalSelectionHeader from 'app/components/organizations/globalSelectionHeader';
+import GroupStore from 'app/stores/groupStore';
+import LoadingError from 'app/components/loadingError';
+import LoadingIndicator from 'app/components/loadingIndicator';
+import Projects from 'app/utils/projects';
+import SentryTypes from 'app/sentryTypes';
+import recreateRoute from 'app/utils/recreateRoute';
+import withApi from 'app/utils/withApi';
+import withProfiler from 'app/utils/withProfiler';
+
+import {ERROR_TYPES} from './constants';
+import GroupHeader from './header';
+
+type Error = typeof ERROR_TYPES[keyof typeof ERROR_TYPES] | null;
+
+type Props = {
+  api: Client;
+  organization: Organization;
+  environments: string[];
+  children: React.ReactNode;
+  finishProfile: () => void;
+} & ReactRouter.RouteComponentProps<{orgId: string; groupId: string}, {}>;
+
+type State = {
+  group: Group | null;
+  loading: boolean;
+  error: boolean;
+  errorType: Error;
+  project: null | Pick<Project, 'platform' | 'id' | 'slug'>;
+};
+
+class GroupDetails extends React.Component<Props, State> {
+  static childContextTypes = {
+    group: SentryTypes.Group,
+    location: PropTypes.object,
+  };
+
+  state = this.initialState;
+
+  getChildContext() {
+    return {
+      group: this.state.group,
+      location: this.props.location,
+    };
+  }
+
+  componentDidMount() {
+    this.fetchData();
+  }
+
+  componentDidUpdate(_prevProps, prevState: State) {
+    if (prevState.loading && !this.state.loading) {
+      callIfFunction(this.props.finishProfile);
+    }
+  }
+
+  componentWillUnmount() {
+    callIfFunction(this.listener);
+  }
+
+  get initialState(): State {
+    return {
+      group: null,
+      loading: true,
+      error: false,
+      errorType: null,
+      project: null,
+    };
+  }
+
+  remountComponent() {
+    this.setState(this.initialState);
+  }
+
+  get groupDetailsEndpoint() {
+    return `/issues/${this.props.params.groupId}/`;
+  }
+
+  async fetchData() {
+    const {environments, api} = this.props;
+
+    try {
+      const data = await api.requestPromise(this.groupDetailsEndpoint, {
+        query: {
+          // Note, we do not want to include the environment key at all if there are no environments
+          ...(environments ? {environment: environments} : {}),
+        },
+      });
+
+      // TODO(billy): See if this is even in use and if not, can we just rip this out?
+      if (this.props.params.groupId !== data.id) {
+        const {routes, params, location} = this.props;
+        ReactRouter.browserHistory.push(
+          recreateRoute('', {
+            routes,
+            location,
+            params: {...params, groupId: data.id},
+          })
+        );
+        return;
+      }
+      const project = data.project;
+
+      if (!project) {
+        Sentry.withScope(() => {
+          Sentry.captureException(new Error('Project not found'));
+        });
+      } else {
+        const locationWithProject = {...this.props.location};
+        if (
+          locationWithProject.query.project === undefined &&
+          locationWithProject.query._allp === undefined
+        ) {
+          //We use _allp as a temporary measure to know they came from the issue list page with no project selected (all projects included in filter).
+          //If it is not defined, we add the locked project id to the URL (this is because if someone navigates directly to an issue on single-project priveleges, then goes back - they were getting assigned to the first project).
+          //If it is defined, we do not so that our back button will bring us to the issue list page with no project selected instead of the locked project.
+          locationWithProject.query.project = project.id;
+        }
+        delete locationWithProject.query._allp; //We delete _allp from the URL to keep the hack a bit cleaner, but this is not an ideal solution and will ultimately be replaced with something smarter.
+        ReactRouter.browserHistory.replace(locationWithProject);
+      }
+
+      this.setState({
+        error: false,
+        loading: false,
+        errorType: null,
+        project,
+      });
+
+      GroupStore.loadInitialData([data]);
+    } catch (err) {
+      let errorType: Error = null;
+      switch (err?.status) {
+        case 404:
+          errorType = ERROR_TYPES.GROUP_NOT_FOUND;
+          break;
+        default:
+      }
+
+      this.setState({
+        loading: false,
+        error: true,
+        errorType,
+      });
+    }
+  }
+
+  listener = GroupStore.listen(itemIds => this.onGroupChange(itemIds));
+
+  onGroupChange(itemIds: Set<string>) {
+    const id = this.props.params.groupId;
+    if (itemIds.has(id)) {
+      const group = GroupStore.get(id);
+      if (group) {
+        if (group.stale) {
+          this.fetchData();
+          return;
+        }
+        this.setState({
+          group,
+        });
+      }
+    }
+  }
+
+  getTitle() {
+    const {group} = this.state;
+
+    const defaultTitle = 'Sentry';
+
+    if (!group) {
+      return defaultTitle;
+    }
+
+    switch (group.type) {
+      case 'error':
+        if (group.metadata.type && group.metadata.value) {
+          return `${group.metadata.type}: ${group.metadata.value}`;
+        }
+        return group.metadata.type || group.metadata.value || defaultTitle;
+      case 'csp':
+        return group.metadata.message || defaultTitle;
+      case 'expectct':
+      case 'expectstaple':
+      case 'hpkp':
+        return group.metadata.message || defaultTitle;
+      case 'default':
+        return group.metadata.title || defaultTitle;
+      default:
+        return '';
+    }
+  }
+
+  renderContent(project) {
+    const {children, environments} = this.props;
+    const {group} = this.state;
+
+    return (
+      <React.Fragment>
+        <GroupHeader project={project} group={group} />
+        {React.isValidElement(children)
+          ? React.cloneElement(children, {
+              environments,
+              group,
+              project,
+            })
+          : children}
+      </React.Fragment>
+    );
+  }
+
+  renderError() {
+    if (!this.state.error) {
+      return null;
+    }
+
+    switch (this.state.errorType) {
+      case ERROR_TYPES.GROUP_NOT_FOUND:
+        return (
+          <Alert type="error" icon={<IconInfo size="lg" />}>
+            {t('The issue you were looking for was not found.')}
+          </Alert>
+        );
+      default:
+        return <LoadingError onRetry={this.remountComponent} />;
+    }
+  }
+
+  render() {
+    const {organization} = this.props;
+    const {error, group, project, loading} = this.state;
+
+    const isError = error;
+    const isLoading = loading || (!group && !isError);
+
+    return (
+      <DocumentTitle title={this.getTitle()}>
+        <React.Fragment>
+          {!isLoading && !isError ? (
+            <GlobalSelectionHeader
+              organization={organization}
+              forceProject={project}
+              showDateSelector={false}
+              shouldForceProject
+              lockedMessageSubject={t('issue')}
+              showIssueStreamLink
+              showProjectSettingsLink
+            />
+          ) : null}
+
+          <PageContent>
+            {isLoading ? (
+              <LoadingIndicator />
+            ) : isError ? (
+              this.renderError()
+            ) : (
+              <Projects orgId={organization.slug} slugs={[project!.slug]}>
+                {({projects, initiallyLoaded, fetchError}) =>
+                  initiallyLoaded ? (
+                    fetchError ? (
+                      <LoadingError message={t('Error loading the specified project')} />
+                    ) : (
+                      this.renderContent(projects[0])
+                    )
+                  ) : (
+                    <LoadingIndicator />
+                  )
+                }
+              </Projects>
+            )}
+          </PageContent>
+        </React.Fragment>
+      </DocumentTitle>
+    );
+  }
+}
+
+export default withApi(withProfiler(GroupDetails));
diff --git a/src/sentry/static/sentry/app/views/organizationGroupDetails/index.jsx b/src/sentry/static/sentry/app/views/organizationGroupDetails/index.tsx
similarity index 51%
rename from src/sentry/static/sentry/app/views/organizationGroupDetails/index.jsx
rename to src/sentry/static/sentry/app/views/organizationGroupDetails/index.tsx
index b9a4f5a04f..7a9d2eebd9 100644
--- a/src/sentry/static/sentry/app/views/organizationGroupDetails/index.jsx
+++ b/src/sentry/static/sentry/app/views/organizationGroupDetails/index.tsx
@@ -1,18 +1,20 @@
+import * as ReactRouter from 'react-router';
 import React from 'react';
 
-import SentryTypes from 'app/sentryTypes';
 import {analytics} from 'app/utils/analytics';
 import withGlobalSelection from 'app/utils/withGlobalSelection';
 import withOrganization from 'app/utils/withOrganization';
+import {GlobalSelection, Organization} from 'app/types';
 
 import GroupDetails from './groupDetails';
 
-class OrganizationGroupDetails extends React.Component {
-  static propTypes = {
-    selection: SentryTypes.GlobalSelection.isRequired,
-    organization: SentryTypes.Organization.isRequired,
-  };
+type Props = {
+  selection: GlobalSelection;
+  organization: Organization;
+  children: React.ReactNode;
+} & ReactRouter.RouteComponentProps<{orgId: string; groupId: string}, {}>;
 
+class OrganizationGroupDetails extends React.Component<Props> {
   componentDidMount() {
     analytics('issue_page.viewed', {
       group_id: parseInt(this.props.params.groupId, 10),
@@ -23,7 +25,13 @@ class OrganizationGroupDetails extends React.Component {
   render() {
     const {selection, ...props} = this.props;
 
-    return <GroupDetails environments={selection.environments} {...props} />;
+    return (
+      <GroupDetails
+        key={`${this.props.params.groupId}-envs:${selection.environments.join(',')}`}
+        environments={selection.environments}
+        {...props}
+      />
+    );
   }
 }
 
diff --git a/tests/js/spec/views/organizationGroupDetails/groupDetails.spec.jsx b/tests/js/spec/views/organizationGroupDetails/groupDetails.spec.jsx
new file mode 100644
index 0000000000..cd9e925cdf
--- /dev/null
+++ b/tests/js/spec/views/organizationGroupDetails/groupDetails.spec.jsx
@@ -0,0 +1,190 @@
+import {browserHistory} from 'react-router';
+import React from 'react';
+
+import {initializeOrg} from 'sentry-test/initializeOrg';
+import {mountWithTheme} from 'sentry-test/enzyme';
+import GlobalSelectionStore from 'app/stores/globalSelectionStore';
+import GroupDetails from 'app/views/organizationGroupDetails';
+import GroupStore from 'app/stores/groupStore';
+
+jest.mock('app/views/organizationGroupDetails/header', () => jest.fn(() => null));
+jest.unmock('app/utils/recreateRoute');
+
+describe('groupDetails', function() {
+  let wrapper;
+  const group = TestStubs.Group();
+  const {organization, project, router, routerContext} = initializeOrg({
+    project: TestStubs.Project(),
+    router: {
+      location: {
+        pathname: `/organizations/org-slug/issues/${group.id}/`,
+        query: {},
+        search: '?foo=bar',
+        hash: '#hash',
+      },
+      params: {
+        groupId: group.id,
+      },
+      routes: [
+        {path: '/', childRoutes: [], component: null},
+        {childRoutes: [], component: null},
+        {
+          path: '/organizations/:orgId/issues/:groupId/',
+          indexRoute: null,
+          childRoutes: [],
+          componentPromise: () => {},
+          component: null,
+        },
+        {componentPromise: null, component: null},
+      ],
+    },
+  });
+  let MockComponent;
+
+  const createWrapper = (props = {organization, router, routerContext}) => {
+    wrapper = mountWithTheme(
+      <GroupDetails
+        organization={props.organization}
+        params={props.router.params}
+        location={props.router.location}
+        routes={props.router.routes}
+      >
+        <MockComponent />
+      </GroupDetails>,
+      props.routerContext
+    );
+    return wrapper;
+  };
+
+  let issueDetailsMock;
+  beforeEach(function() {
+    MockComponent = jest.fn(() => null);
+    issueDetailsMock = MockApiClient.addMockResponse({
+      url: `/issues/${group.id}/`,
+      body: {...group},
+    });
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/projects/',
+      body: [project],
+    });
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/users/',
+      body: [],
+    });
+  });
+  afterEach(async function() {
+    if (wrapper) {
+      wrapper.unmount();
+    }
+    GroupStore.reset();
+    GlobalSelectionStore.reset();
+    MockApiClient.clearMockResponses();
+    await tick();
+    await tick();
+    await tick();
+  });
+
+  it('renders', async function() {
+    wrapper = createWrapper();
+
+    await tick();
+    wrapper.update();
+
+    expect(wrapper.find('LoadingIndicator')).toHaveLength(0);
+    expect(MockComponent).toHaveBeenLastCalledWith(
+      {
+        environments: [],
+        group,
+        project: expect.objectContaining({
+          id: project.id,
+          slug: project.slug,
+        }),
+      },
+      {}
+    );
+
+    expect(issueDetailsMock).toHaveBeenCalledTimes(1);
+  });
+
+  it('renders error when issue is not found', async function() {
+    issueDetailsMock = MockApiClient.addMockResponse({
+      url: `/issues/${group.id}/`,
+      statusCode: 404,
+    });
+    wrapper = createWrapper();
+
+    await tick();
+    wrapper.update();
+
+    expect(wrapper.find('LoadingIndicator')).toHaveLength(0);
+    expect(issueDetailsMock).toHaveBeenCalledTimes(1);
+    expect(MockComponent).not.toHaveBeenCalled();
+    expect(wrapper.find('Alert').text()).toEqual(
+      'The issue you were looking for was not found.'
+    );
+  });
+
+  it('fetches issue details for a given environment', async function() {
+    const props = initializeOrg({
+      project: TestStubs.Project(),
+      router: {
+        location: {
+          pathname: '/issues/groupId/',
+          query: {environment: 'staging'},
+        },
+        params: {
+          groupId: group.id,
+        },
+      },
+    });
+
+    wrapper = createWrapper(props);
+
+    await tick();
+    // Reflux and stuff
+    await tick();
+    wrapper.update();
+
+    expect(wrapper.find('LoadingIndicator')).toHaveLength(0);
+
+    // TODO(billy): This should be 1 time, but GSH syncs the environment to store and causes re-render and thus a second request
+    expect(issueDetailsMock).toHaveBeenCalledTimes(2);
+    expect(issueDetailsMock).toHaveBeenLastCalledWith(
+      expect.anything(),
+      expect.objectContaining({
+        query: {
+          environment: ['staging'],
+        },
+      })
+    );
+    expect(MockComponent).toHaveBeenLastCalledWith(
+      {
+        environments: ['staging'],
+        group,
+        project: expect.objectContaining({
+          id: project.id,
+          slug: project.slug,
+        }),
+      },
+      {}
+    );
+  });
+
+  /**
+   * This is legacy code that I'm not even sure still happens
+   */
+  it('redirects to new issue if params id !== id returned from API request', async function() {
+    issueDetailsMock = MockApiClient.addMockResponse({
+      url: `/issues/${group.id}/`,
+      body: {...group, id: 'new-id'},
+    });
+    wrapper = createWrapper();
+
+    await tick();
+    expect(MockComponent).not.toHaveBeenCalled();
+    expect(browserHistory.push).toHaveBeenCalledTimes(1);
+    expect(browserHistory.push).toHaveBeenCalledWith(
+      '/organizations/org-slug/issues/new-id/?foo=bar#hash'
+    );
+  });
+});

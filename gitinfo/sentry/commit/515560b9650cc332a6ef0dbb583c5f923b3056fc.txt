commit 515560b9650cc332a6ef0dbb583c5f923b3056fc
Author: David Cramer <dcramer@gmail.com>
Date:   Thu May 1 14:33:25 2014 -0300

    Add is_regression to group processors

diff --git a/src/sentry/manager.py b/src/sentry/manager.py
index 6917c56930..c28ec0d407 100644
--- a/src/sentry/manager.py
+++ b/src/sentry/manager.py
@@ -27,7 +27,9 @@ from raven.utils.encoding import to_string
 from sentry import app
 from sentry.constants import (
     STATUS_RESOLVED, STATUS_UNRESOLVED, MINUTE_NORMALIZATION,
-    LOG_LEVELS, DEFAULT_LOGGER_NAME, MAX_CULPRIT_LENGTH)
+    LOG_LEVELS, DEFAULT_LOGGER_NAME, MAX_CULPRIT_LENGTH,
+    MEMBER_USER
+)
 from sentry.db.models import BaseManager
 from sentry.processors.base import send_group_processors
 from sentry.signals import regression_signal
@@ -148,7 +150,7 @@ class ChartMixin(object):
         # and not have ~inaccurate data for up to MINUTE_NORMALIZATION
         today -= datetime.timedelta(minutes=MINUTE_NORMALIZATION)
 
-        if max_days >= 30:
+        if max_days >= 14:
             g_type = 'date'
             d_type = 'days'
             points = max_days
@@ -417,7 +419,7 @@ class GroupManager(BaseManager, ChartMixin):
                 tags.extend(added_tags)
 
         try:
-            group, is_new, is_sample = self._create_group(
+            group, is_new, is_regression, is_sample = self._create_group(
                 event=event,
                 tags=data['tags'],
                 **group_kwargs
@@ -458,8 +460,9 @@ class GroupManager(BaseManager, ChartMixin):
             send_group_processors(
                 group=group,
                 event=event,
-                is_new=is_new,
-                is_sample=is_sample
+                is_new=is_new or is_regression,  # backwards compat
+                is_sample=is_sample,
+                is_regression=is_regression,
             )
 
         if getattr(settings, 'SENTRY_INDEX_SEARCH', settings.SENTRY_USE_SEARCH):
@@ -524,7 +527,7 @@ class GroupManager(BaseManager, ChartMixin):
 
             if group.status == STATUS_RESOLVED or group.is_over_resolve_age():
                 # Making things atomic
-                is_new = bool(self.filter(
+                is_regression = bool(self.filter(
                     id=group.id,
                     status=STATUS_RESOLVED,
                 ).exclude(
@@ -535,6 +538,8 @@ class GroupManager(BaseManager, ChartMixin):
 
                 group.active_at = date
                 group.status = STATUS_UNRESOLVED
+            else:
+                is_regression = False
 
             group.last_seen = extra['last_seen']
 
@@ -542,6 +547,8 @@ class GroupManager(BaseManager, ChartMixin):
                 'id': group.id,
             }, extra)
         else:
+            is_regression = False
+
             # TODO: this update should actually happen as part of create
             group.update(score=ScoreClause(group))
 
@@ -581,7 +588,7 @@ class GroupManager(BaseManager, ChartMixin):
             (TSDBModel.project, project.id),
         ])
 
-        return group, is_new, is_sample
+        return group, is_new, is_regression, is_sample
 
     def add_tags(self, group, tags):
         from sentry.models import TagValue, GroupTagValue
@@ -723,8 +730,8 @@ class TeamManager(BaseManager):
         """
         Returns a SortedDict of all teams a user has some level of access to.
 
-        Each <Team> returned has a ``membership`` attribute which holds the
-        <TeamMember> instance.
+        Each <Team> returned has an ``access_type`` attribute which holds the
+        MEMBER_TYPE value.
         """
         from sentry.models import TeamMember, AccessGroup, Project
 
@@ -733,33 +740,38 @@ class TeamManager(BaseManager):
         if not user.is_authenticated():
             return results
 
-        if settings.SENTRY_PUBLIC and access is None:
-            for team in sorted(self.iterator(), key=lambda x: x.name.lower()):
-                results[team.slug] = team
-        else:
-            all_teams = set()
+        all_teams = set()
 
-            qs = TeamMember.objects.filter(
-                user=user,
+        qs = TeamMember.objects.filter(
+            user=user,
+        ).select_related('team')
+        if access is not None:
+            qs = qs.filter(type__lte=access)
+
+        for tm in qs:
+            team = tm.team
+            team.access_type = tm.type
+            all_teams.add(team)
+
+        if access_groups:
+            qs = AccessGroup.objects.filter(
+                members=user,
             ).select_related('team')
             if access is not None:
                 qs = qs.filter(type__lte=access)
 
-            for tm in qs:
-                all_teams.add(tm.team)
+            for group in qs:
+                team = group.team
+                team.access_type = group.type
+                all_teams.add(team)
 
-            if access_groups:
-                qs = AccessGroup.objects.filter(
-                    members=user,
-                ).select_related('team')
-                if access is not None:
-                    qs = qs.filter(type__lte=access)
-
-                for group in qs:
-                    all_teams.add(group.team)
+        if settings.SENTRY_PUBLIC and access is None:
+            for team in self.iterator():
+                all_teams.add(team)
+                team.access_type = MEMBER_USER
 
-            for team in sorted(all_teams, key=lambda x: x.name.lower()):
-                results[team.slug] = team
+        for team in sorted(all_teams, key=lambda x: x.name.lower()):
+            results[team.slug] = team
 
         if with_projects:
             # these kinds of queries make people sad :(

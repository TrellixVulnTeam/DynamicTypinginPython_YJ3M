commit d9471628b58ab93126465f8b0c93679fe1369874
Author: Danny Lee <leedongwei@gmail.com>
Date:   Tue Sep 17 21:44:26 2019 -0700

    feat(discover-v2): Add GridEditable component

diff --git a/src/sentry/static/sentry/app/components/globalModal.tsx b/src/sentry/static/sentry/app/components/globalModal.tsx
index f2f7387c1f..72f894b74f 100644
--- a/src/sentry/static/sentry/app/components/globalModal.tsx
+++ b/src/sentry/static/sentry/app/components/globalModal.tsx
@@ -21,7 +21,7 @@ class GlobalModal extends React.Component<Props> {
     /**
      * Needs to be a function that returns a React Element
      * Function is injected with:
-     * Modal `Header`, `Body`, and `Footer,
+     * Modal `Header`, `Body`, and `Footer`,
      * `closeModal`
      *
      */
diff --git a/src/sentry/static/sentry/app/components/gridEditable/flags.tsx b/src/sentry/static/sentry/app/components/gridEditable/flags.tsx
new file mode 100644
index 0000000000..95f92f2315
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/gridEditable/flags.tsx
@@ -0,0 +1,10 @@
+/**
+ * There are several stages to full functionality in for resizableGrid. These
+ * local flags to turn on/off these functions.
+ *
+ * 1. Allow edit mode (use Sentry's organization feature flag for this)
+ * 2. Allow resizing of column width
+ * 3. Allow drag-to-rearrage columns
+ */
+export const FLAG_GRID_RESIZABLE = false;
+export const FLAG_GRID_DRAGGABLE = false;
diff --git a/src/sentry/static/sentry/app/components/gridEditable/grid.tsx b/src/sentry/static/sentry/app/components/gridEditable/grid.tsx
new file mode 100644
index 0000000000..1c0251ad45
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/gridEditable/grid.tsx
@@ -0,0 +1,304 @@
+import React from 'react';
+
+import {t} from 'app/locale';
+import {openModal} from 'app/actionCreators/modal';
+
+import Alert from 'app/components/alert';
+import EmptyStateWarning from 'app/components/emptyStateWarning';
+import InlineSvg from 'app/components/inlineSvg';
+import LoadingContainer from 'app/components/loading/loadingContainer';
+import ToolTip from 'app/components/tooltip';
+
+import {GridColumn, GridColumnOrder, GridColumnSortBy} from './gridTypes';
+import GridHeadCell from './gridHeadCell';
+import GridModalEditColumn from './gridModalEditColumn';
+import {
+  GridPanel,
+  GridPanelBody,
+  Grid,
+  GridRow,
+  GridHead,
+  GridBody,
+  GridBodyCell,
+  GridBodyCellSpan,
+  GridBodyCellLoading,
+  GridEditGroup,
+  GridEditGroupButton,
+} from './styles';
+
+export type GridEditableProps<DataRow, ColumnKey extends keyof DataRow> = {
+  isEditable?: boolean;
+  isLoading?: boolean;
+  error?: React.ReactNode | null;
+
+  /**
+   * GridEditable (mostly) do not maintain any internal state and relies on the
+   * parent component to tell it how/what to render and will mutate the view
+   * based on this 3 main props.
+   *
+   * - `columnOrder` determines the columns to show, from left to right
+   * - `columnSortBy` is not used at the moment, however it might be better to
+   *   move sorting into Grid for performance
+   */
+  columnOrder: GridColumnOrder<ColumnKey>[];
+  columnSortBy: GridColumnSortBy<ColumnKey>[];
+  data: DataRow[];
+
+  /**
+   * GridEditable allows the parent component to determine how to display the
+   * data within it. Note that this is optional.
+   */
+  grid: {
+    renderHeaderCell?: (column: GridColumnOrder<ColumnKey>) => React.ReactNode;
+    renderBodyCell?: (
+      column: GridColumnOrder<ColumnKey>,
+      dataRow: DataRow
+    ) => React.ReactNode;
+  };
+
+  /**
+   * As GridEditable is unopinionated about the structure of GridColumn,
+   * ModalEditColumn relies on the parent component to provide the form layout
+   * and logic to create/update the columns
+   */
+  modalEditColumn: {
+    renderBodyWithForm: (
+      indexOfColumnOrder?: number,
+      column?: GridColumn<ColumnKey>
+    ) => React.ReactNode;
+    renderFooter: () => React.ReactNode;
+  };
+
+  /**
+   * As there is no internal state being maintained, the parent component will
+   * have to provide functions to move/delete the columns
+   */
+  actions: {
+    moveColumn: (fromIndex: number, toIndex: number) => void;
+    deleteColumn: (index: number) => void;
+  };
+};
+export type GridEditableState = {
+  isEditing: boolean;
+  numColumn: number;
+};
+
+class GridEditable<DataRow extends Object> extends React.Component<
+  GridEditableProps<DataRow, keyof DataRow>,
+  GridEditableState
+> {
+  static defaultProps = {
+    isEditable: false,
+  };
+
+  state = {
+    numColumn: 0,
+    isEditing: false,
+  };
+
+  // Static methods do not allow the use of generics bounded to the parent class
+  // For more info: https://github.com/microsoft/TypeScript/issues/14600
+  static getDerivedStateFromProps(
+    props: GridEditableProps<Object, keyof Object>,
+    prevState: GridEditableState
+  ): GridEditableState {
+    return {
+      ...prevState,
+      numColumn: props.columnOrder.length,
+    };
+  }
+
+  toggleEdit = () => {
+    this.setState({isEditing: !this.state.isEditing});
+  };
+
+  toggleModalEditColumn = (
+    indexOfColumnOrder?: number,
+    column?: GridColumn<keyof DataRow>
+  ) => {
+    if (this.state.isEditing) {
+      const {modalEditColumn} = this.props;
+
+      openModal(openModalProps => (
+        <GridModalEditColumn
+          {...openModalProps}
+          indexOfColumnOrder={indexOfColumnOrder}
+          column={column}
+          renderBody={modalEditColumn.renderBodyWithForm}
+          renderFooter={modalEditColumn.renderFooter}
+        />
+      ));
+    }
+  };
+
+  renderError = () => {
+    const {error} = this.props;
+
+    return (
+      <React.Fragment>
+        <Alert type="error" icon="icon-circle-exclamation">
+          {error}
+        </Alert>
+        <GridPanel>
+          <Grid numColumn={this.state.numColumn}>
+            {this.renderGridHead()}
+            <GridBody>
+              <GridBodyCellSpan>{error}</GridBodyCellSpan>
+            </GridBody>
+          </Grid>
+        </GridPanel>
+      </React.Fragment>
+    );
+  };
+
+  renderLoading = () => {
+    return (
+      <GridBody>
+        <GridBodyCellSpan>
+          <GridBodyCellLoading>
+            <LoadingContainer isLoading={true} />
+          </GridBodyCellLoading>
+        </GridBodyCellSpan>
+      </GridBody>
+    );
+  };
+
+  renderEmptyData = () => {
+    return (
+      <GridBody>
+        <GridBodyCellSpan>
+          <EmptyStateWarning>
+            <p>{t('No results found')}</p>
+          </EmptyStateWarning>
+        </GridBodyCellSpan>
+      </GridBody>
+    );
+  };
+
+  renderGridHead = () => {
+    const {isEditable, columnOrder, actions, grid} = this.props;
+    const {isEditing} = this.state;
+
+    // Ensure that the last column cannot be removed
+    const enableEdit = isEditing && columnOrder.length > 1;
+
+    return (
+      <GridHead>
+        <GridRow>
+          {/* GridHeadEdit must come first.
+
+              It is a <th> that uses `position: absolute` to set its placement.
+              The CSS selectors captures the last GridHeadCell and put a
+              padding-right to provide space for GridHeadEdit to be displayed.
+
+              FAQ:
+              Instead of using `position: absolute`, why can't we just put
+              GridHeadEdit at the end so it appears on the right?
+              Because CSS Grids need to have the same number of Head/Body cells
+              for everything to align properly. Sub-grids are new and may not be
+              well supported in older browsers/
+
+              Why can't we just put GridHeadEdit somewhere else?
+              Because HTML rules mandate that <div> cannot be a nested child of
+              a <table>. This seems the best way to make it correct to satisfy
+              HTML semantics. */
+          isEditable && this.renderGridHeadEditButtons()}
+
+          {columnOrder.map((column, i) => (
+            <GridHeadCell
+              key={`${column.key}${i}`}
+              isPrimary={column.isPrimary}
+              isEditing={enableEdit}
+              actions={{
+                deleteColumn: () => actions.deleteColumn(i),
+                toggleModalEditColumn: () => this.toggleModalEditColumn(i, column),
+              }}
+            >
+              {grid.renderHeaderCell ? grid.renderHeaderCell(column) : column.name}
+            </GridHeadCell>
+          ))}
+        </GridRow>
+      </GridHead>
+    );
+  };
+
+  renderGridHeadEditButtons = () => {
+    if (!this.props.isEditable) {
+      return null;
+    }
+
+    if (!this.state.isEditing) {
+      return (
+        <GridEditGroup>
+          <GridEditGroupButton onClick={this.toggleEdit}>
+            <ToolTip title={t('Edit Columns')}>
+              <InlineSvg src="icon-edit-pencil" />
+            </ToolTip>
+          </GridEditGroupButton>
+        </GridEditGroup>
+      );
+    }
+
+    return (
+      <GridEditGroup>
+        <GridEditGroupButton onClick={() => this.toggleModalEditColumn()}>
+          <ToolTip title={t('Add Columns')}>
+            <InlineSvg src="icon-circle-add" />
+          </ToolTip>
+        </GridEditGroupButton>
+        <GridEditGroupButton onClick={this.toggleEdit}>
+          <ToolTip title={t('Cancel Edit')}>
+            <InlineSvg src="icon-close" />
+          </ToolTip>
+        </GridEditGroupButton>
+      </GridEditGroup>
+    );
+  };
+
+  renderGridBody = () => {
+    const {data} = this.props;
+
+    if (!data || data.length === 0) {
+      return this.renderEmptyData();
+    }
+
+    return <GridBody>{data.map(this.renderGridBodyRow)}</GridBody>;
+  };
+
+  renderGridBodyRow = (dataRow: DataRow, row: number) => {
+    const {grid} = this.props;
+
+    return (
+      <GridRow key={row}>
+        {this.props.columnOrder.map((col, i) => (
+          <GridBodyCell key={`${col.key}${i}`}>
+            {grid.renderBodyCell ? grid.renderBodyCell(col, dataRow) : dataRow[col.key]}
+          </GridBodyCell>
+        ))}
+      </GridRow>
+    );
+  };
+
+  render() {
+    if (this.props.error) {
+      return this.renderError();
+    }
+
+    return (
+      <GridPanel>
+        <GridPanelBody>
+          <Grid
+            isEditable={this.props.isEditable}
+            isEditing={this.state.isEditing}
+            numColumn={this.state.numColumn}
+          >
+            {this.renderGridHead()}
+            {this.props.isLoading ? this.renderLoading() : this.renderGridBody()}
+          </Grid>
+        </GridPanelBody>
+      </GridPanel>
+    );
+  }
+}
+
+export default GridEditable;
diff --git a/src/sentry/static/sentry/app/components/gridEditable/gridHeadCell.tsx b/src/sentry/static/sentry/app/components/gridEditable/gridHeadCell.tsx
new file mode 100644
index 0000000000..1ff52f42f6
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/gridEditable/gridHeadCell.tsx
@@ -0,0 +1,104 @@
+import React from 'react';
+
+import InlineSvg from 'app/components/inlineSvg';
+
+import {FLAG_GRID_RESIZABLE, FLAG_GRID_DRAGGABLE} from './flags';
+import {
+  GridHeadCell as GridHeadCellWrapper,
+  GridHeadCellButton,
+  GridHeadCellButtonHover,
+  GridHeadCellButtonHoverBackground,
+  GridHeadCellButtonHoverButtonGroup,
+  GridHeadCellButtonHoverButton,
+  GridHeadCellButtonHoverDraggable,
+  GridHeadCellResizer,
+} from './styles';
+
+export type GridHeadCellProps = {
+  isEditing: boolean;
+  isPrimary: boolean;
+  children: React.ReactNode | React.ReactChild;
+
+  actions: {
+    deleteColumn: () => void;
+    toggleModalEditColumn: () => void;
+  };
+};
+export type GridHeadCellState = {
+  isHovering: boolean;
+};
+
+/**
+ * The GridHeadCell has several user interactions that result in different
+ * states that are only specific to the header. This component aims to abstract
+ * the complexity of GridHeadCell away.
+ */
+class GridHeadCell extends React.Component<GridHeadCellProps, GridHeadCellState> {
+  static defaultProps = {
+    isEditing: false,
+    isPrimary: false,
+  };
+
+  state = {
+    isHovering: false,
+  };
+
+  setHovering = (isHovering: boolean) => {
+    this.setState({isHovering});
+  };
+
+  renderButtonHoverDraggable(children: React.ReactNode) {
+    const {actions} = this.props;
+
+    return (
+      <React.Fragment>
+        {/* Ensure that background is always at the top. The background must be
+            independent because it has <100% opacity, but the elements on top
+            of it must be 100% opacity */}
+        <GridHeadCellButtonHoverBackground>{children}</GridHeadCellButtonHoverBackground>
+
+        <GridHeadCellButtonHover>
+          {FLAG_GRID_DRAGGABLE && (
+            <GridHeadCellButtonHoverDraggable src="icon-grabbable" />
+          )}
+
+          <GridHeadCellButtonHoverButtonGroup isFlagged={FLAG_GRID_DRAGGABLE}>
+            <GridHeadCellButtonHoverButton onClick={actions.toggleModalEditColumn}>
+              <InlineSvg src="icon-edit-pencil" />
+            </GridHeadCellButtonHoverButton>
+            <GridHeadCellButtonHoverButton onClick={actions.deleteColumn}>
+              <InlineSvg src="icon-trash" />
+            </GridHeadCellButtonHoverButton>
+          </GridHeadCellButtonHoverButtonGroup>
+
+          {FLAG_GRID_DRAGGABLE && (
+            <GridHeadCellButtonHoverDraggable src="icon-grabbable" />
+          )}
+        </GridHeadCellButtonHover>
+      </React.Fragment>
+    );
+  }
+
+  render() {
+    const {isEditing, children} = this.props;
+    const {isHovering} = this.state;
+
+    return (
+      <GridHeadCellWrapper
+        onMouseEnter={() => this.setHovering(true)}
+        onMouseLeave={() => this.setHovering(false)}
+      >
+        <GridHeadCellButton isEditing={isEditing}>
+          {children}
+          {isEditing && isHovering && this.renderButtonHoverDraggable(children)}
+        </GridHeadCellButton>
+
+        {/* Keep the Resizer at the bottom to ensure that it is will always
+            float on top of everything else */
+        FLAG_GRID_RESIZABLE && <GridHeadCellResizer isEditing={isEditing} />}
+      </GridHeadCellWrapper>
+    );
+  }
+}
+
+export default GridHeadCell;
diff --git a/src/sentry/static/sentry/app/components/gridEditable/gridModalEditColumn.tsx b/src/sentry/static/sentry/app/components/gridEditable/gridModalEditColumn.tsx
new file mode 100644
index 0000000000..f117f40c7c
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/gridEditable/gridModalEditColumn.tsx
@@ -0,0 +1,55 @@
+import React from 'react';
+
+import {t} from 'app/locale';
+
+export type GridModalEditColumnProps<Column> = {
+  indexOfColumnOrder?: number;
+  column?: Column;
+
+  renderBody: (indexOfColumnOrder?: number, column?: Column) => React.ReactNode;
+  renderFooter: () => React.ReactNode;
+
+  /**
+   * These are props passed in by the openModal function
+   * See 'app/actionCreators/modal' for more info
+   */
+  Header: React.ComponentType;
+  Body: React.ComponentType;
+  Footer: React.ComponentType;
+  closeModal: () => void;
+};
+
+class GridModalEditColumn<Column> extends React.Component<
+  GridModalEditColumnProps<Column>
+> {
+  static defaultProps = {
+    data: {},
+  };
+
+  renderHeader() {
+    const {column} = this.props;
+    return <h4>{column ? t('Edit Column') : t('New Column')}</h4>;
+  }
+
+  render() {
+    const {
+      Header,
+      Body,
+      Footer,
+      indexOfColumnOrder,
+      column,
+      renderBody,
+      renderFooter,
+    } = this.props;
+
+    return (
+      <React.Fragment>
+        <Header>{this.renderHeader()}</Header>
+        <Body>{renderBody(indexOfColumnOrder, column)}</Body>
+        <Footer>{renderFooter()}</Footer>
+      </React.Fragment>
+    );
+  }
+}
+
+export default GridModalEditColumn;
diff --git a/src/sentry/static/sentry/app/components/gridEditable/gridTypes.tsx b/src/sentry/static/sentry/app/components/gridEditable/gridTypes.tsx
new file mode 100644
index 0000000000..9665e2cb55
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/gridEditable/gridTypes.tsx
@@ -0,0 +1,22 @@
+/**
+ * For GridEditable, there are 2 generic types for the component, T and K
+ * - T is an element/object that represents the data to be displayed
+ * - K is a key of T
+ *   - columnKey should have the same set of values as K
+ */
+
+type ObjectKey = React.ReactText;
+
+export type GridColumn<K = ObjectKey> = {
+  key: K;
+};
+
+export type GridColumnHeader<K = ObjectKey> = GridColumn<K> & {
+  name: string;
+  isPrimary?: boolean;
+};
+
+export type GridColumnOrder<K = ObjectKey> = GridColumnHeader<K>;
+export type GridColumnSortBy<K = ObjectKey> = GridColumn<K> & {
+  order: -1 | 1;
+};
diff --git a/src/sentry/static/sentry/app/components/gridEditable/index.tsx b/src/sentry/static/sentry/app/components/gridEditable/index.tsx
new file mode 100644
index 0000000000..ec0e3d4efa
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/gridEditable/index.tsx
@@ -0,0 +1,12 @@
+import Grid from './grid';
+import gridModalEditColumn from './gridModalEditColumn';
+
+export default Grid;
+export {
+  GridColumn,
+  GridColumnHeader,
+  GridColumnOrder,
+  GridColumnSortBy,
+} from './gridTypes';
+export {GridEditableProps} from './grid';
+export {gridModalEditColumn};
diff --git a/src/sentry/static/sentry/app/components/gridEditable/styles.tsx b/src/sentry/static/sentry/app/components/gridEditable/styles.tsx
new file mode 100644
index 0000000000..fb118f81ba
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/gridEditable/styles.tsx
@@ -0,0 +1,306 @@
+import styled from 'react-emotion';
+
+import InlineSvg from 'app/components/inlineSvg';
+import {Panel, PanelBody} from 'app/components/panels';
+import space from 'app/styles/space';
+
+const GRID_HEADER_HEIGHT = '45px';
+const GRID_EDIT_WIDTH = '35px';
+const GRID_EDIT_WIDTH_DOUBLE = '70px'; // (2 * GRID_EDIT_WIDTH)
+
+/**
+ * Explanation of z-index:
+ *  - Resizer needs to float above <th> cells to be interactive.
+ *  - Editable needs to float above Resizer to hide the right-most Resizer,
+ */
+const Z_INDEX_RESIZER = '1';
+const Z_INDEX_EDITABLE = '10';
+
+type GridEditableProps = {
+  numColumn?: number;
+  isEditable?: boolean;
+  isEditing?: boolean;
+  isPrimary?: boolean;
+  isFlagged?: boolean;
+};
+
+export const GridPanel = styled(Panel)`
+  overflow: hidden;
+`;
+export const GridPanelBody = styled(PanelBody)``;
+
+/**
+ *
+ * Grid is the parent element for the tableResizable component.
+ *
+ * On newer browsers, it will use CSS Grids to implement its layout.
+ *
+ * However, it is based on <table>, which has a distinction between header/body
+ * HTML elements, which allows CSS selectors to its full potential. This has
+ * the added advantage that older browsers will still have a chance of
+ * displaying the data correctly (but this is untested).
+ *
+ * <thead>, <tbody>, <tr> are ignored by CSS Grid.
+ * The entire layout is determined by the usage of <th> and <td>.
+ *
+ */
+export const Grid = styled('table')<GridEditableProps>`
+  position: relative;
+  display: grid;
+  grid-template-columns: 2.5fr repeat(${p => (p.numColumn ? p.numColumn - 1 : 0)}, 1fr);
+
+  box-sizing: border-box;
+  border-collapse: collapse;
+  margin: 0;
+
+  background-color: ${p => p.theme.offWhite};
+  overflow: hidden;
+
+  /* For the last column, we want to have some space on the right if column
+     is editable.
+
+     For the header, we set padding for 1 or 2 buttons depending on state
+     For the body, use "td:last-child" */
+  th:last-child {
+    ${p => {
+      if (!p.isEditable) {
+        return '0px';
+      }
+      if (!p.isEditing) {
+        return `padding-right: ${GRID_EDIT_WIDTH};`;
+      }
+
+      return `padding-right: ${GRID_EDIT_WIDTH_DOUBLE};`;
+    }}
+  }
+`;
+export const GridRow = styled('tr')`
+  display: contents;
+`;
+
+/**
+ *
+ * GridHead is the collection of elements that builds the header section of the
+ * Grid. As the entirety of the add/remove/resize actions are performed on the
+ * header, most of the elements behave different for each stage.
+ *
+ */
+export const GridHead = styled('thead')`
+  display: contents;
+`;
+export const GridHeadCell = styled('th')`
+  /* By default, a grid item cannot be smaller than the size of its content.
+     We override this by setting min-width to be 0. */
+  position: relative;
+  min-width: 0;
+  height: ${GRID_HEADER_HEIGHT};
+
+  border-bottom: 1px solid ${p => p.theme.borderDark};
+  background: ${p => p.theme.offWhite};
+`;
+export const GridHeadCellButton = styled('div')<GridEditableProps>`
+  position: relative;
+  min-width: 24px; /* Ensure that edit/remove buttons are never hidden */
+  display: block;
+
+  margin: ${space(1)};
+  padding: ${space(1)} ${space(1.5)};
+  border-radius: ${p => p.theme.borderRadius};
+
+  color: ${p => p.theme.gray2};
+  font-size: 13px;
+  font-weight: 600;
+  line-height: 1;
+  text-transform: uppercase;
+  white-space: nowrap;
+  text-overflow: ellipsis;
+  overflow: hidden;
+
+  background: ${p => (p.isEditing ? p.theme.offWhite2 : 'none')};
+
+  a {
+    color: ${p => p.theme.gray2};
+  }
+
+  &:hover,
+  &:active {
+    color: ${p => p.theme.gray3};
+    a {
+      color: ${p => p.theme.gray3};
+    }
+  }
+`;
+export const GridHeadCellResizer = styled('span')<GridEditableProps>`
+  position: absolute;
+  top: 0;
+  right: -2px; /* Overlap half of Resizer into the right neighbor */
+  display: block;
+  width: 4px;
+  height: 100%;
+
+  padding: ${space(1.5)} 1px; /* Padding sets the size of ::after  */
+  z-index: ${Z_INDEX_RESIZER};
+  cursor: col-resize;
+
+  &::after {
+    content: ' ';
+    display: block;
+    width: 2px;
+    height: 100%;
+
+    border-left: 1px solid ${p => p.theme.gray2};
+    border-right: 1px solid ${p => p.theme.gray2};
+  }
+`;
+
+/**
+ *
+ * GridHeadCellButtonHover is the collection of interactive elements to add or
+ * move the columns. They are expected to be draggable.
+ *
+ */
+export const GridHeadCellButtonHover = styled('div')<GridEditableProps>`
+  position: absolute;
+  top: 0;
+  left: 0;
+  display: flex;
+  justify-content: space-between;
+  align-items: center;
+  width: 100%;
+  height: 100%;
+
+  color: ${p => p.theme.gray3};
+
+  &:hover {
+    color: ${p => p.theme.gray4};
+  }
+  &:active {
+    color: ${p => p.theme.gray5};
+  }
+`;
+export const GridHeadCellButtonHoverBackground = styled(GridHeadCellButton)`
+  position: absolute;
+  top: 0;
+  left: 0;
+  display: block;
+  width: 100%;
+  height: 100%;
+
+  background-color: ${p => p.theme.offWhite2};
+  margin: 0;
+
+  a,
+  &:hover a,
+  &:active a {
+    color: ${p => p.theme.gray1} !important;
+  }
+`;
+export const GridHeadCellButtonHoverButtonGroup = styled('div')<GridEditableProps>`
+  ${p => !p.isFlagged && 'margin: 0 auto;'}
+`;
+export const GridHeadCellButtonHoverButton = styled('div')`
+  display: inline-flex;
+  justify-content: center;
+  align-items: center;
+  width: 20px;
+  height: 20px;
+
+  margin: ${space(0.25)};
+  border: 2px solid ${p => p.theme.gray3};
+  border-radius: ${p => p.theme.borderRadius};
+  background-color: ${p => p.theme.offWhite2};
+  opacity: 1;
+
+  font-size: 14px;
+  cursor: pointer;
+
+  &:hover {
+    border: 2px solid ${p => p.theme.gray4};
+  }
+  &:active {
+    border: 2px solid ${p => p.theme.gray5};
+  }
+`;
+export const GridHeadCellButtonHoverDraggable = styled(InlineSvg)`
+  cursor: grab;
+  user-select: none;
+`;
+
+/**
+ *
+ * GridBody are the collection of elements that contains and display the data
+ * of the Grid. They are rather simple.
+ *
+ */
+export const GridBody = styled('tbody')`
+  display: contents;
+
+  > tr:last-child td {
+    border-bottom: none;
+  }
+`;
+export const GridBodyCell = styled('td')`
+  /* By default, a grid item cannot be smaller than the size of its content.
+     We override this by setting min-width to be 0. */
+  min-width: 0;
+  padding: ${space(2)};
+
+  background-color: ${p => p.theme.white};
+  border-bottom: 1px solid ${p => p.theme.borderLight};
+
+  font-size: ${p => p.theme.fontSizeMedium};
+`;
+export const GridBodyCellSpan = styled(GridBodyCell)`
+  grid-column: 1 / -1;
+`;
+export const GridBodyCellLoading = styled('div')`
+  min-height: 220px;
+`;
+
+/**
+ *
+ * GridEditGroup are the buttons that are on the top right of the Grid that
+ * allows the user to add/remove/resize the columns of the Grid
+ *
+ */
+export const GridEditGroup = styled('th')`
+  position: absolute;
+  top: 0;
+  right: 0;
+  display: flex;
+  height: ${GRID_HEADER_HEIGHT};
+
+  background-color: ${p => p.theme.offWhite};
+  border-bottom: 1px solid ${p => p.theme.borderDark};
+
+  z-index: ${Z_INDEX_EDITABLE};
+`;
+export const GridEditGroupButton = styled('div')`
+  display: block;
+  width: ${GRID_EDIT_WIDTH};
+  height: ${GRID_HEADER_HEIGHT};
+
+  color: ${p => p.theme.gray2};
+  font-size: 16px;
+  cursor: pointer;
+
+  &:hover {
+    color: ${p => p.theme.gray3};
+  }
+  &:active {
+    color: ${p => p.theme.gray4};
+  }
+  &:last-child {
+    border-left: 1px solid ${p => p.theme.borderDark};
+  }
+
+  /* Targets ToolTip to ensure that it will fill up the parent element and
+     its child elements will float in its center */
+  > span {
+    display: flex;
+    justify-content: center;
+    align-items: center;
+    width: 100%;
+    height: 100%;
+  }
+`;
diff --git a/src/sentry/static/sentry/app/icons/icon-delete.svg b/src/sentry/static/sentry/app/icons/icon-delete.svg
deleted file mode 100644
index 9db62b14ae..0000000000
--- a/src/sentry/static/sentry/app/icons/icon-delete.svg
+++ /dev/null
@@ -1,8 +0,0 @@
-<svg width="13" height="13" viewBox="0 0 13 13" fill="none" xmlns="http://www.w3.org/2000/svg">
-<path fill-rule="evenodd" clip-rule="evenodd" d="M1.94733 3.91522V9.6023C1.94733 10.7444 2.82297 11.6703 3.90313 11.6703H8.79265C9.87282 11.6703 10.7485 10.7444 10.7485 9.6023V3.91522H9.91486V9.73169C9.91486 10.3266 9.46156 10.8088 8.90239 10.8088H3.84002C3.28084 10.8088 2.82754 10.3266 2.82754 9.73169V3.91522H1.94733Z" fill="currentColor"/>
-<rect x="1.06778" y="3.05371" width="10.5614" height="0.861678" rx="0.430839" fill="currentColor"/>
-<path fill-rule="evenodd" clip-rule="evenodd" d="M7.80001 1.3302H4.89692C4.53395 1.3302 4.20821 1.54836 4.07665 1.87957L3.26807 3.91523H9.42886L8.62028 1.87957C8.48872 1.54836 8.16298 1.3302 7.80001 1.3302ZM4.89723 2.19195H7.80032L8.14258 3.05362H4.55496L4.89723 2.19195Z" fill="currentColor"/>
-<rect x="3.70779" y="4.77673" width="0.880108" height="5.17007" rx="0.440054" fill="currentColor"/>
-<rect x="5.90857" y="4.77673" width="0.880119" height="5.17007" rx="0.44006" fill="currentColor"/>
-<rect x="8.10883" y="4.77673" width="0.880112" height="5.17007" rx="0.440056" fill="currentColor"/>
-</svg>
diff --git a/src/sentry/static/sentry/app/icons/icon-edit-2.svg b/src/sentry/static/sentry/app/icons/icon-edit-pencil.svg
similarity index 100%
rename from src/sentry/static/sentry/app/icons/icon-edit-2.svg
rename to src/sentry/static/sentry/app/icons/icon-edit-pencil.svg

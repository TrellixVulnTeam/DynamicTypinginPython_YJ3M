commit 12db42784c2cc80e2867681c3fad6338aa370b06
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Tue Apr 23 09:21:05 2019 -0700

    fix(dashboard): Fix multiple queries on dashboard (#12861)
    
    There were a few race conditions when dashboards would get re-rendered (e.g. changing date). Parent component would fetch releases, as well as global state change, and a withRouter render as well. Also query builders were not being re-built. Also adds an additional integration test.

diff --git a/src/sentry/static/sentry/app/views/organizationDashboard/dashboard.jsx b/src/sentry/static/sentry/app/views/organizationDashboard/dashboard.jsx
index d0b582f35a..8d2cb8c499 100644
--- a/src/sentry/static/sentry/app/views/organizationDashboard/dashboard.jsx
+++ b/src/sentry/static/sentry/app/views/organizationDashboard/dashboard.jsx
@@ -8,18 +8,25 @@ import space from 'app/styles/space';
 
 class Dashboard extends React.Component {
   static propTypes = {
+    releasesLoading: PropTypes.bool,
     releases: PropTypes.arrayOf(SentryTypes.Release),
     widgets: PropTypes.arrayOf(SentryTypes.Widget),
+    router: PropTypes.object,
   };
 
   render() {
-    const {releases, widgets} = this.props;
+    const {releasesLoading, router, releases, widgets} = this.props;
 
     return (
       <Widgets>
         {widgets.map((widget, i) => (
           <WidgetWrapper key={i}>
-            <Widget releases={releases} widget={widget} />
+            <Widget
+              releasesLoading={releasesLoading}
+              releases={releases}
+              widget={widget}
+              router={router}
+            />
           </WidgetWrapper>
         ))}
       </Widgets>
diff --git a/src/sentry/static/sentry/app/views/organizationDashboard/discoverQuery.jsx b/src/sentry/static/sentry/app/views/organizationDashboard/discoverQuery.jsx
index 165872e18c..0d71b51e4d 100644
--- a/src/sentry/static/sentry/app/views/organizationDashboard/discoverQuery.jsx
+++ b/src/sentry/static/sentry/app/views/organizationDashboard/discoverQuery.jsx
@@ -1,4 +1,4 @@
-import {isEqual, omit} from 'lodash';
+import {isEqual, memoize, omit} from 'lodash';
 import PropTypes from 'prop-types';
 import React from 'react';
 
@@ -9,16 +9,28 @@ import {parsePeriodToHours} from 'app/utils';
 import SentryTypes from 'app/sentryTypes';
 import createQueryBuilder from 'app/views/organizationDiscover/queryBuilder';
 
+// Note: Limit max releases so that chart is still a bit readable
+const MAX_RECENT_RELEASES = 20;
 const createReleaseFieldCondition = releases => [
   [
     'if',
-    [['in', ['release', 'tuple', releases.map(r => `'${r}'`)]], 'release', "'other'"],
+    [
+      [
+        'in',
+        ['release', 'tuple', releases.slice(0, MAX_RECENT_RELEASES).map(r => `'${r}'`)],
+      ],
+      'release',
+      "'other'",
+    ],
     'release',
   ],
 ];
 
 class DiscoverQuery extends React.Component {
   static propTypes = {
+    // means a parent component is still loading releases
+    // and we should not perform any API requests yet (if we depend on releases)
+    releasesLoading: PropTypes.bool,
     compareToPeriod: PropTypes.shape({
       statsPeriodStart: PropTypes.string,
       statsPeriodEnd: PropTypes.string,
@@ -52,8 +64,19 @@ class DiscoverQuery extends React.Component {
       return true;
     }
 
-    if (this.props.releases !== nextProps.releases) {
-      return true;
+    // Allow component to update if queries are dependent on releases
+    // and if releases change, or releasesLoading prop changes
+    if (this.doesRequireReleases(nextProps.queries)) {
+      if (!isEqual(this.props.releases, nextProps.releases)) {
+        return true;
+      }
+
+      if (
+        !nextProps.releasesLoading &&
+        this.props.releasesLoading !== nextProps.releasesLoading
+      ) {
+        return true;
+      }
     }
 
     if (
@@ -68,25 +91,45 @@ class DiscoverQuery extends React.Component {
 
   componentDidUpdate(prevProps) {
     const keysToIgnore = ['children'];
+
+    // Ignore "releasesLoading" and "releases" props if we are not waiting for releases
+    // Otherwise we can potentially make an extra request if releasesLoading !== nextBusy and
+    // globalSelection === nextGlobalSelection
+    if (!this.doesRequireReleases(this.props.queries)) {
+      keysToIgnore.push('releasesLoading');
+      keysToIgnore.push('releases');
+    }
+
     if (isEqual(omit(prevProps, keysToIgnore), omit(this.props, keysToIgnore))) {
       return;
     }
 
-    if (this.props.releases !== prevProps.releases) {
-      this.createQueryBuilders();
-    } else {
-      this.fetchData();
-    }
+    this.createQueryBuilders();
+    this.fetchData();
   }
 
   componentWillUnmount() {
     this.queryBuilders.forEach(builder => builder.cancelRequests());
+    // Cleanup query builders
+    this.queryBuilders = [];
   }
 
+  // Checks queries for any that are dependent on recent releases
+  doesRequireReleases = memoize(
+    queries =>
+      !!queries.find(
+        ({constraints}) => constraints && constraints.includes('recentReleases')
+      )
+  );
+
   createQueryBuilders() {
     const {organization, queries} = this.props;
+
+    this.queryBuilders = [];
+
     queries.forEach(({constraints, ...query}) => {
       if (constraints && constraints.includes('recentReleases')) {
+        // Can't create query yet because no releases
         if (!this.props.releases) {
           return;
         }
@@ -147,8 +190,14 @@ class DiscoverQuery extends React.Component {
   }
 
   async fetchData() {
-    // Fetch
     this.setState({reloading: true});
+
+    // Do not fetch data if dependent on releases and parent component is busy fetching releases
+    if (this.doesRequireReleases(this.props.queries) && this.props.releasesLoading) {
+      return;
+    }
+
+    // Fetch
     const promises = this.queryBuilders.map(builder => builder.fetchWithoutLimit());
     const results = await Promise.all(promises);
 
diff --git a/src/sentry/static/sentry/app/views/organizationDashboard/organizationDashboardContainer.jsx b/src/sentry/static/sentry/app/views/organizationDashboard/organizationDashboardContainer.jsx
index 103d796b9d..2032cb63e2 100644
--- a/src/sentry/static/sentry/app/views/organizationDashboard/organizationDashboardContainer.jsx
+++ b/src/sentry/static/sentry/app/views/organizationDashboard/organizationDashboardContainer.jsx
@@ -1,4 +1,3 @@
-import {withRouter} from 'react-router';
 import React from 'react';
 
 import {PageContent, PageHeader} from 'app/styles/organization';
@@ -38,5 +37,5 @@ class OrganizationDashboardContainer extends React.Component {
     );
   }
 }
-export default withRouter(withOrganization(OrganizationDashboardContainer));
+export default withOrganization(OrganizationDashboardContainer);
 export {OrganizationDashboardContainer};
diff --git a/src/sentry/static/sentry/app/views/organizationDashboard/overviewDashboard.jsx b/src/sentry/static/sentry/app/views/organizationDashboard/overviewDashboard.jsx
index a0fe49ef79..cd5795e2d0 100644
--- a/src/sentry/static/sentry/app/views/organizationDashboard/overviewDashboard.jsx
+++ b/src/sentry/static/sentry/app/views/organizationDashboard/overviewDashboard.jsx
@@ -20,7 +20,18 @@ class OverviewDashboard extends AsyncView {
   }
 
   renderBody() {
-    return <Dashboard releases={this.state.releases} {...overviewDashboard} />;
+    // Passing the rest of `this.props` to `<Dashboard>` for tests
+    const {router, ...props} = this.props;
+
+    return (
+      <Dashboard
+        releases={this.state.releases}
+        releasesLoading={this.state.loading}
+        router={router}
+        {...overviewDashboard}
+        {...props}
+      />
+    );
   }
 }
 export default OverviewDashboard;
diff --git a/src/sentry/static/sentry/app/views/organizationDashboard/utils/getChartDataFunc.jsx b/src/sentry/static/sentry/app/views/organizationDashboard/utils/getChartDataFunc.jsx
index a8c7880fe2..7934ce3845 100644
--- a/src/sentry/static/sentry/app/views/organizationDashboard/utils/getChartDataFunc.jsx
+++ b/src/sentry/static/sentry/app/views/organizationDashboard/utils/getChartDataFunc.jsx
@@ -14,6 +14,7 @@ export function getChartDataFunc({queries, type, fieldLabelMap}) {
       getChartDataByDay,
       [
         {
+          allSeries: true,
           fieldLabelMap,
         },
       ],
diff --git a/src/sentry/static/sentry/app/views/organizationDashboard/widget.jsx b/src/sentry/static/sentry/app/views/organizationDashboard/widget.jsx
index f13bd99f96..03e8b67802 100644
--- a/src/sentry/static/sentry/app/views/organizationDashboard/widget.jsx
+++ b/src/sentry/static/sentry/app/views/organizationDashboard/widget.jsx
@@ -1,4 +1,3 @@
-import {withRouter} from 'react-router';
 import PropTypes from 'prop-types';
 import React from 'react';
 import styled from 'react-emotion';
@@ -18,6 +17,7 @@ import WidgetChart from './widgetChart';
 
 class Widget extends React.Component {
   static propTypes = {
+    releasesLoading: PropTypes.bool,
     releases: PropTypes.arrayOf(SentryTypes.Release),
     widget: SentryTypes.Widget,
     organization: SentryTypes.Organization,
@@ -26,12 +26,20 @@ class Widget extends React.Component {
   };
 
   render() {
-    const {organization, router, widget, releases, selection} = this.props;
+    const {
+      organization,
+      releasesLoading,
+      router,
+      widget,
+      releases,
+      selection,
+    } = this.props;
     const {title, includePreviousPeriod, compareToPeriod} = widget;
 
     return (
       <ErrorBoundary customComponent={<ErrorCard>{t('Error loading widget')}</ErrorCard>}>
         <DiscoverQuery
+          releasesLoading={releasesLoading}
           releases={releases}
           organization={organization}
           selection={selection}
@@ -77,7 +85,7 @@ class Widget extends React.Component {
   }
 }
 
-export default withRouter(withOrganization(withGlobalSelection(Widget)));
+export default withOrganization(withGlobalSelection(Widget));
 export {Widget};
 
 const StyledPanel = styled(Panel)`
diff --git a/tests/js/spec/views/organizationDashboard/dashboard.spec.jsx b/tests/js/spec/views/organizationDashboard/dashboard.spec.jsx
index 10ae9bee3a..0b394bbbbc 100644
--- a/tests/js/spec/views/organizationDashboard/dashboard.spec.jsx
+++ b/tests/js/spec/views/organizationDashboard/dashboard.spec.jsx
@@ -10,6 +10,9 @@ import OrganizationDashboardContainer from 'app/views/organizationDashboard';
 jest.mock('app/utils/withLatestContext');
 
 describe('OrganizationDashboard', function() {
+  let wrapper;
+  let discoverMock;
+
   const {organization, router, routerContext} = initializeOrg({
     projects: [{isMember: true}, {isMember: true, slug: 'new-project', id: 3}],
     organization: {
@@ -22,13 +25,20 @@ describe('OrganizationDashboard', function() {
       },
     },
   });
+
   const org = organization;
 
-  let discoverMock;
+  const createWrapper = props => {
+    wrapper = mount(
+      <OrganizationDashboardContainer>
+        <Dashboard {...props} />
+      </OrganizationDashboardContainer>,
+      routerContext
+    );
+    mockRouterPush(wrapper, router);
+  };
 
   beforeEach(function() {
-    router.push.mockRestore();
-    MockApiClient.clearMockResponses();
     MockApiClient.addMockResponse({
       url: `/organizations/${org.slug}/environments/`,
       body: TestStubs.Environments(),
@@ -44,14 +54,17 @@ describe('OrganizationDashboard', function() {
     });
   });
 
+  afterEach(function() {
+    router.push.mockRestore();
+    MockApiClient.clearMockResponses();
+    if (wrapper) {
+      wrapper.unmount();
+    }
+    discoverMock.mockRestore();
+  });
+
   it('queries and renders discover-based widgets grouped by time', async function() {
-    const wrapper = mount(
-      <OrganizationDashboardContainer>
-        <Dashboard {...TestStubs.Dashboard()} />
-      </OrganizationDashboardContainer>,
-      routerContext
-    );
-    mockRouterPush(wrapper, router);
+    createWrapper(TestStubs.Dashboard());
 
     expect(discoverMock).toHaveBeenCalledTimes(2);
     expect(discoverMock).toHaveBeenCalledWith(
@@ -99,36 +112,30 @@ describe('OrganizationDashboard', function() {
   });
 
   it('queries and renders discover-based widgets not grouped by time', async function() {
-    const wrapper = mount(
-      <OrganizationDashboardContainer>
-        <Dashboard
-          {...TestStubs.Dashboard([
-            TestStubs.Widget(
+    createWrapper(
+      TestStubs.Dashboard([
+        TestStubs.Widget(
+          {
+            discover: [
               {
-                discover: [
-                  {
-                    name: 'Browsers',
-                    fields: ['browser.name'],
-                    conditions: [],
-                    aggregations: [['count()', null, 'count']],
-                    limit: 1000,
-
-                    orderby: '-count',
-                    groupby: ['browser.name'],
-                  },
-                ],
+                name: 'Browsers',
+                fields: ['browser.name'],
+                conditions: [],
+                aggregations: [['count()', null, 'count']],
+                limit: 1000,
+
+                orderby: '-count',
+                groupby: ['browser.name'],
               },
-              {
-                type: 'table',
-                title: 'Table',
-              }
-            ),
-          ])}
-        />
-      </OrganizationDashboardContainer>,
-      routerContext
+            ],
+          },
+          {
+            type: 'table',
+            title: 'Table',
+          }
+        ),
+      ])
     );
-    mockRouterPush(wrapper, router);
 
     expect(discoverMock).toHaveBeenCalledTimes(1);
     expect(discoverMock).toHaveBeenCalledWith(
diff --git a/tests/js/spec/views/organizationDashboard/discoverQuery.spec.jsx b/tests/js/spec/views/organizationDashboard/discoverQuery.spec.jsx
index 67d66b071e..470dbba45f 100644
--- a/tests/js/spec/views/organizationDashboard/discoverQuery.spec.jsx
+++ b/tests/js/spec/views/organizationDashboard/discoverQuery.spec.jsx
@@ -103,7 +103,9 @@ describe('DiscoverQuery', function() {
     wrapper.update();
     expect(renderMock).toHaveBeenCalledTimes(0);
 
-    wrapper.setProps({organization: TestStubs.Organization()});
+    wrapper.setProps({
+      organization: TestStubs.Organization({projects: [TestStubs.Project()]}),
+    });
     wrapper.update();
 
     // Called twice because of fetchData (state.reloading)
diff --git a/tests/js/spec/views/organizationDashboard/overviewDashboard.spec.jsx b/tests/js/spec/views/organizationDashboard/overviewDashboard.spec.jsx
new file mode 100644
index 0000000000..ef4e4bfce6
--- /dev/null
+++ b/tests/js/spec/views/organizationDashboard/overviewDashboard.spec.jsx
@@ -0,0 +1,233 @@
+import React from 'react';
+
+import {initializeOrg} from 'app-test/helpers/initializeOrg';
+import {mockRouterPush} from 'app-test/helpers/mockRouterPush';
+import {mount} from 'enzyme';
+import OrganizationDashboardContainer from 'app/views/organizationDashboard';
+import OverviewDashboard from 'app/views/organizationDashboard/overviewDashboard';
+
+jest.mock('app/utils/withLatestContext');
+
+describe('OverviewDashboard', function() {
+  let wrapper;
+  let discoverMock;
+  let releasesMock;
+
+  const {organization, router, routerContext} = initializeOrg({
+    projects: [{isMember: true}, {isMember: true, slug: 'new-project', id: 3}],
+    organization: {
+      features: ['sentry10', 'discover', 'global-views'],
+    },
+    router: {
+      location: {
+        pathname: '/organizations/org-slug/dashboard/?statsPeriod=14d&utc=true',
+        query: {},
+      },
+    },
+  });
+
+  const org = organization;
+
+  const createWrapper = props => {
+    wrapper = mount(
+      <OrganizationDashboardContainer>
+        <OverviewDashboard params={{orgId: organization.slug}} {...props} />
+      </OrganizationDashboardContainer>,
+      routerContext
+    );
+    mockRouterPush(wrapper, router);
+  };
+
+  beforeEach(function() {
+    MockApiClient.addMockResponse({
+      url: `/organizations/${org.slug}/environments/`,
+      body: TestStubs.Environments(),
+    });
+    releasesMock = MockApiClient.addMockResponse({
+      url: `/organizations/${org.slug}/releases/`,
+      body: [TestStubs.Release()],
+    });
+    discoverMock = MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/discover/query/',
+      method: 'POST',
+      body: {
+        data: [],
+        meta: [],
+        timing: {},
+      },
+    });
+  });
+
+  afterEach(function() {
+    router.push.mockRestore();
+    MockApiClient.clearMockResponses();
+    if (wrapper) {
+      wrapper.unmount();
+    }
+    discoverMock.mockRestore();
+    releasesMock.mockRestore();
+  });
+
+  it('renders and updates "recentReleases" constraint ', async function() {
+    const eventsByReleaseWidget = TestStubs.Widget({
+      discover: [
+        {
+          name: 'Events by Release',
+          fields: ['release'],
+          constraints: ['recentReleases'],
+          conditions: [],
+          aggregations: [['count()', null, 'Events']],
+          limit: 5000,
+
+          orderby: '-time',
+          groupby: ['time', 'release'],
+          rollup: 86400,
+        },
+      ],
+    });
+    const dashboardData = TestStubs.Dashboard([
+      TestStubs.Widget(),
+      eventsByReleaseWidget,
+    ]);
+
+    createWrapper(dashboardData);
+
+    // TODO(billy): Figure out why releases gets called twice
+    expect(discoverMock).toHaveBeenCalledTimes(4);
+
+    expect(releasesMock).toHaveBeenCalledTimes(1);
+
+    // Known users
+    expect(discoverMock).toHaveBeenCalledWith(
+      expect.anything(),
+      expect.objectContaining({
+        data: expect.objectContaining({
+          environments: [],
+          projects: [2, 3],
+          range: '14d',
+
+          fields: [],
+          conditions: [['user.email', 'IS NOT NULL', null]],
+          aggregations: [['uniq', 'user.email', 'Known Users']],
+          limit: 1000,
+          orderby: '-time',
+          groupby: ['time'],
+          rollup: 86400,
+        }),
+      })
+    );
+
+    // Anonymous users
+    expect(discoverMock).toHaveBeenCalledWith(
+      expect.anything(),
+      expect.objectContaining({
+        data: expect.objectContaining({
+          environments: [],
+          projects: [2, 3],
+          range: '14d',
+
+          fields: [],
+          conditions: [['user.email', 'IS NULL', null]],
+          aggregations: [['count()', null, 'Anonymous Users']],
+          limit: 1000,
+          orderby: '-time',
+          groupby: ['time'],
+          rollup: 86400,
+        }),
+      })
+    );
+
+    // Events by Release
+    expect(discoverMock).toHaveBeenCalledWith(
+      expect.anything(),
+      expect.objectContaining({
+        data: expect.objectContaining({
+          environments: [],
+          projects: [2, 3],
+          range: '14d',
+
+          fields: [],
+          conditions: [],
+          aggregations: [['count()', null, 'Events']],
+          conditionFields: [
+            [
+              'if',
+              [
+                [
+                  'in',
+                  ['release', 'tuple', ["'92eccef279d966b2319f0802fa4b22b430a5f72b'"]],
+                ],
+                'release',
+                "'other'",
+              ],
+              'release',
+            ],
+          ],
+          limit: 5000,
+          orderby: '-time',
+          groupby: ['time', 'release'],
+          name: 'Events by Release',
+          rollup: 86400,
+        }),
+      })
+    );
+
+    await tick();
+    wrapper.update();
+
+    // Should have two LineCharts
+    expect(wrapper.find('LineChart')).toHaveLength(2);
+
+    discoverMock.mockRestore();
+    releasesMock.mockRestore();
+
+    // Change date time
+    wrapper.find('TimeRangeSelector HeaderItem').simulate('click');
+    wrapper.find('SelectorItem[value="7d"]').simulate('click');
+    wrapper.find('TimeRangeSelector HeaderItem').simulate('click');
+
+    await tick();
+    wrapper.update();
+
+    expect(discoverMock).toHaveBeenCalledTimes(4);
+
+    // Doesn't get called again because it doesn't use global selection header
+    // This request just fetches last 100 (paginated) releases
+    expect(releasesMock).toHaveBeenCalledTimes(0);
+
+    // requested with update date
+    expect(discoverMock).toHaveBeenCalledWith(
+      expect.anything(),
+      expect.objectContaining({
+        data: expect.objectContaining({
+          environments: [],
+          projects: [2, 3],
+          range: '7d',
+
+          fields: [],
+          conditions: [],
+          aggregations: [['count()', null, 'Events']],
+          conditionFields: [
+            [
+              'if',
+              [
+                [
+                  'in',
+                  ['release', 'tuple', ["'92eccef279d966b2319f0802fa4b22b430a5f72b'"]],
+                ],
+                'release',
+                "'other'",
+              ],
+              'release',
+            ],
+          ],
+          limit: 5000,
+          orderby: '-time',
+          groupby: ['time', 'release'],
+          name: 'Events by Release',
+          rollup: 86400,
+        }),
+      })
+    );
+  });
+});

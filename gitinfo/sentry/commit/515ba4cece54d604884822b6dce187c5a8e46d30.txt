commit 515ba4cece54d604884822b6dce187c5a8e46d30
Author: David Cramer <dcramer@gmail.com>
Date:   Tue May 20 00:43:52 2014 -0700

    Use Nydus threadpool for cleanup

diff --git a/src/sentry/tasks/cleanup.py b/src/sentry/tasks/cleanup.py
index d9fbf9e1eb..af132850a3 100644
--- a/src/sentry/tasks/cleanup.py
+++ b/src/sentry/tasks/cleanup.py
@@ -6,11 +6,16 @@ sentry.tasks.cleanup
 :license: BSD, see LICENSE for more details.
 """
 
+from nydus.utils import ThreadPool
 from sentry.tasks.base import instrumented_task
 
 
+def delete_object(item):
+    item.delete()
+
+
 @instrumented_task(name='sentry.tasks.cleanup.cleanup', queue='cleanup')
-def cleanup(days=30, project=None, chunk_size=1000, **kwargs):
+def cleanup(days=30, project=None, chunk_size=1000, concurrency=1, **kwargs):
     """
     Deletes a portion of the trailing data in Sentry based on
     their creation dates. For example, if ``days`` is 30, this
@@ -61,15 +66,20 @@ def cleanup(days=30, project=None, chunk_size=1000, **kwargs):
 
     # Remove types which can easily be bound to project + date
     for model, date_col in GENERIC_DELETES:
-        log.info("Removing %r for days=%s project=%r", model, days, project or '*')
+        log.info("Removing %s for days=%s project=%r", model.__name__, days, project or '*')
         qs = model.objects.filter(**{'%s__lte' % (date_col,): ts})
         if project:
             qs = qs.filter(project=project)
         # XXX: we step through because the deletion collector will pull all relations into memory
+
+        count = 0
         while qs.exists():
+            log.info("Removing %s chunk %d", model.__name__, count)
+            worker_pool = ThreadPool(workers=concurrency)
             for obj in list(qs[:chunk_size]):
-                log.info("Removing %r", obj)
-                obj.delete()
+                worker_pool.add(obj.id, delete_object, [obj])
+                count += 1
+            worker_pool.join()
 
     # EventMapping is fairly expensive and is special cased as it's likely you
     # won't need a reference to an event for nearly as long

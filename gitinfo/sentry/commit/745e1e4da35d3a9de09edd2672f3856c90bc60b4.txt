commit 745e1e4da35d3a9de09edd2672f3856c90bc60b4
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Tue Dec 3 19:00:41 2019 +0000

    feat(ui): Make Triggers form inline for Metric Rules [SEN-1215] (#15782)
    
    * feat(ui): Refactor Triggers in Metric Alert Rules
    
    This refactors metric alert rules and moves triggers inline with the
    rest of the alert form.
    
    * Fixing linting errors
    
    * Removing overlay change

diff --git a/src/sentry/static/sentry/app/types/alerts.tsx b/src/sentry/static/sentry/app/types/alerts.tsx
index 186ce4c1e7..38b9b25b0c 100644
--- a/src/sentry/static/sentry/app/types/alerts.tsx
+++ b/src/sentry/static/sentry/app/types/alerts.tsx
@@ -55,3 +55,31 @@ export type IssueAlertRule = {
   id: string;
   name: string;
 };
+
+/**
+ * This is an Action that is associated to a Trigger in a Metric Alert Rule
+ */
+export type MetricAction = {
+  /**
+   * The integration type e.g. 'email'
+   */
+  type: string;
+
+  /**
+   * e.g.
+   * - `user` - user id,
+   * - `team` - team id
+   * - `specific` - free text
+   */
+  allowedTargetTypes: Array<'user' | 'team' | 'specific'>;
+
+  /**
+   * Name of the integration. This is a text field that differentiates integrations from the same provider from each other
+   */
+  integrationName: string;
+
+  /**
+   * Integration id for this `type`, should be passed to backend as `integrationId` when creating an action
+   */
+  integrationId: number;
+};
diff --git a/src/sentry/static/sentry/app/types/index.tsx b/src/sentry/static/sentry/app/types/index.tsx
index 80b7a2a9c1..60027507fe 100644
--- a/src/sentry/static/sentry/app/types/index.tsx
+++ b/src/sentry/static/sentry/app/types/index.tsx
@@ -647,3 +647,8 @@ export type SavedQueryState = {
   hasError: boolean;
   isLoading: boolean;
 };
+
+export type SelectValue<T> = {
+  label: string;
+  value: T;
+};
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/actions.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/actions.tsx
index 7c713a5367..ebc38cb75a 100644
--- a/src/sentry/static/sentry/app/views/settings/incidentRules/actions.tsx
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/actions.tsx
@@ -1,6 +1,79 @@
 import {Client} from 'app/api';
-import {SavedIncidentRule, Trigger} from './types';
+import {SavedIncidentRule, IncidentRule, Trigger} from './types';
 
+function isSavedRule(rule: IncidentRule): rule is SavedIncidentRule {
+  return !!rule.id;
+}
+
+/**
+ * Add a new rule or update an existing rule
+ *
+ * @param api API Client
+ * @param orgId Organization slug
+ * @param rule Saved or Unsaved Metric Rule
+ */
+export async function addOrUpdateRule(
+  api: Client,
+  orgId: string,
+  rule: IncidentRule
+): Promise<unknown[]> {
+  const isExisting = isSavedRule(rule);
+  const endpoint = `/organizations/${orgId}/alert-rules/${
+    isSavedRule(rule) ? `${rule.id}/` : ''
+  }`;
+  const method = isExisting ? 'PUT' : 'POST';
+
+  const savedRule: SavedIncidentRule = await api.requestPromise(endpoint, {
+    method,
+    data: rule,
+  });
+
+  // TODO(incidents): New API endpoint should save triggers as well as actions in above endpoint
+  //
+  // For now save triggers and actions individually
+  const triggerPromises = rule.triggers.map(
+    async ({resolveThreshold, actions, ...trigger}) => {
+      const triggerEndpoint = `/organizations/${orgId}/alert-rules/${
+        savedRule.id
+      }/triggers/${trigger.id ? `${trigger.id}/` : ''}`;
+      const triggerMethod = trigger.id ? 'PUT' : 'POST';
+
+      // Be sure to not include actions for now (we destructure from trigger in params)
+      const savedTrigger = await api.requestPromise(triggerEndpoint, {
+        method: triggerMethod,
+        data: {
+          ...trigger,
+          // Note `resolveThreshold can be empty string, but need to remove it for API
+          ...(resolveThreshold !== '' ? {resolveThreshold} : {}),
+        },
+      });
+
+      return await Promise.all(
+        actions.map(action => {
+          const actionsEndpoint = `/organizations/${orgId}/alert-rules/${
+            savedRule.id
+          }/triggers/${savedTrigger.id}/actions/${action.id ? `${action.id}/` : ''}`;
+          const actionsMethod = action.id ? 'PUT' : 'POST';
+
+          return api.requestPromise(actionsEndpoint, {
+            method: actionsMethod,
+            data: action,
+          });
+        })
+      );
+    }
+  );
+
+  return Promise.all(triggerPromises);
+}
+
+/**
+ * Delete an existing rule
+ *
+ * @param api API Client
+ * @param orgId Organization slug
+ * @param rule Saved or Unsaved Metric Rule
+ */
 export function deleteRule(
   api: Client,
   orgId: string,
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/constants.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/constants.tsx
new file mode 100644
index 0000000000..76abd3ae91
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/constants.tsx
@@ -0,0 +1,28 @@
+import {
+  AlertRuleAggregations,
+  AlertRuleThresholdType,
+  UnsavedIncidentRule,
+  Trigger,
+} from 'app/views/settings/incidentRules/types';
+
+export function createDefaultTrigger(): Trigger {
+  return {
+    label: '',
+    alertThreshold: 0,
+    resolveThreshold: '',
+    thresholdType: AlertRuleThresholdType.ABOVE,
+    actions: [],
+  };
+}
+
+export const DEFAULT_METRIC = [AlertRuleAggregations.TOTAL];
+
+export function createDefaultRule(): UnsavedIncidentRule {
+  return {
+    aggregations: DEFAULT_METRIC,
+    query: '',
+    timeWindow: 60,
+    triggers: [createDefaultTrigger()],
+    projects: [],
+  };
+}
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/create.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/create.tsx
index ebf540bd3b..a8a5152a98 100644
--- a/src/sentry/static/sentry/app/views/settings/incidentRules/create.tsx
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/create.tsx
@@ -1,25 +1,20 @@
 import {RouteComponentProps} from 'react-router/lib/Router';
 import React from 'react';
 
-import {AlertRuleAggregations} from 'app/views/settings/incidentRules/types';
 import {Organization, Project} from 'app/types';
+import {createDefaultRule} from 'app/views/settings/incidentRules/constants';
 import recreateRoute from 'app/utils/recreateRoute';
 
 import RuleForm from './ruleForm';
 
-const DEFAULT_METRIC = [AlertRuleAggregations.TOTAL];
-const DEFAULT_RULE = {
-  aggregations: DEFAULT_METRIC,
-  query: '',
-  timeWindow: 60,
-  triggers: [],
-};
-
 type Props = {
   organization: Organization;
   project: Project;
 };
 
+/**
+ * Show metric rules form with an empty rule. Redirects to alerts list after creation.
+ */
 class IncidentRulesCreate extends React.Component<RouteComponentProps<{}, {}> & Props> {
   handleSubmitSuccess = () => {
     const {params, routes, router, location} = this.props;
@@ -34,7 +29,8 @@ class IncidentRulesCreate extends React.Component<RouteComponentProps<{}, {}> &
       <RuleForm
         organization={organization}
         onSubmitSuccess={this.handleSubmitSuccess}
-        rule={{...DEFAULT_RULE, projects: [project.slug]}}
+        rule={{...createDefaultRule(), projects: [project.slug]}}
+        params={this.props.params}
       />
     );
   }
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/details.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/details.tsx
index 59d61155ba..e4f706096d 100644
--- a/src/sentry/static/sentry/app/views/settings/incidentRules/details.tsx
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/details.tsx
@@ -1,12 +1,14 @@
 import {RouteComponentProps} from 'react-router/lib/Router';
 import React from 'react';
+import memoize from 'lodash/memoize';
 
 import {IncidentRule} from 'app/views/settings/incidentRules/types';
-import {Organization, Project} from 'app/types';
+import {Organization} from 'app/types';
+import {addErrorMessage} from 'app/actionCreators/indicator';
+import {t} from 'app/locale';
 import AsyncView from 'app/views/asyncView';
 import RuleForm from 'app/views/settings/incidentRules/ruleForm';
 import withOrganization from 'app/utils/withOrganization';
-import withProjects from 'app/utils/withProjects';
 
 type RouteParams = {
   orgId: string;
@@ -16,11 +18,11 @@ type RouteParams = {
 
 type Props = {
   organization: Organization;
-  projects: Project[];
 };
 
 type State = {
   rule: IncidentRule;
+  actions: Map<string, any>; // This is temp
 } & AsyncView['state'];
 
 class IncidentRulesDetails extends AsyncView<
@@ -38,15 +40,59 @@ class IncidentRulesDetails extends AsyncView<
     ];
   }
 
+  // XXX(billy): This is temporary, ideally we want actions fetched with triggers?
+  onRequestSuccess = async ({data}) => {
+    const {orgId, incidentRuleId} = this.props.params;
+
+    // fetch actions for trigger
+    this.setState({loading: true});
+
+    try {
+      const resp = data.triggers.map(async trigger => {
+        const actions = await this.api.requestPromise(
+          `/organizations/${orgId}/alert-rules/${incidentRuleId}/triggers/${
+            trigger.id
+          }/actions/`
+        );
+        return [trigger.id, actions];
+      });
+
+      const actionsTriggersTuples: [string, any][] = await Promise.all(resp);
+      this.setState(() => ({
+        actions: new Map(actionsTriggersTuples),
+      }));
+    } catch (_err) {
+      addErrorMessage(t('Unable to fetch actions'));
+    }
+    this.setState({loading: false});
+  };
+
+  getActions = memoize((rule, actions) => {
+    const triggers = rule.triggers.map(trigger => ({
+      ...trigger,
+      actions: actions.get(trigger.id) || [],
+    }));
+
+    return {
+      ...rule,
+      triggers,
+    };
+  });
+
   renderBody() {
     const {organization, params} = this.props;
     const {incidentRuleId} = params;
     const {rule} = this.state;
 
     return (
-      <RuleForm organization={organization} incidentRuleId={incidentRuleId} rule={rule} />
+      <RuleForm
+        organization={organization}
+        incidentRuleId={incidentRuleId}
+        params={params}
+        rule={this.getActions(rule, this.state.actions)}
+      />
     );
   }
 }
 
-export default withProjects(withOrganization(IncidentRulesDetails));
+export default withOrganization(IncidentRulesDetails);
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/ruleConditionsForm.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/ruleConditionsForm.tsx
new file mode 100644
index 0000000000..074c81cac5
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/ruleConditionsForm.tsx
@@ -0,0 +1,92 @@
+import React from 'react';
+
+import {Organization} from 'app/types';
+import {Panel, PanelBody, PanelHeader} from 'app/components/panels';
+import {t} from 'app/locale';
+import FormField from 'app/views/settings/components/forms/formField';
+import SearchBar from 'app/views/events/searchBar';
+import SelectField from 'app/views/settings/components/forms/selectField';
+
+import {AlertRuleAggregations, TimeWindow} from './types';
+import getMetricDisplayName from './utils/getMetricDisplayName';
+
+type Props = {
+  organization: Organization;
+};
+
+type TimeWindowMapType = {[key in TimeWindow]: string};
+
+const TIME_WINDOW_MAP: TimeWindowMapType = {
+  [TimeWindow.ONE_MINUTE]: t('1 minute'),
+  [TimeWindow.FIVE_MINUTES]: t('5 minutes'),
+  [TimeWindow.TEN_MINUTES]: t('10 minutes'),
+  [TimeWindow.FIFTEEN_MINUTES]: t('15 minutes'),
+  [TimeWindow.THIRTY_MINUTES]: t('30 minutes'),
+  [TimeWindow.ONE_HOUR]: t('1 hour'),
+  [TimeWindow.TWO_HOURS]: t('2 hours'),
+  [TimeWindow.FOUR_HOURS]: t('4 hours'),
+  [TimeWindow.ONE_DAY]: t('24 hours'),
+};
+
+class RuleConditionsForm extends React.PureComponent<Props> {
+  render() {
+    const {organization} = this.props;
+
+    return (
+      <Panel>
+        <PanelHeader>{t('Configure Rule Conditions')}</PanelHeader>
+        <PanelBody>
+          <SelectField
+            name="aggregations"
+            label={t('Metric')}
+            help={t('Choose which metric to trigger on')}
+            choices={[
+              [
+                AlertRuleAggregations.UNIQUE_USERS,
+                getMetricDisplayName(AlertRuleAggregations.UNIQUE_USERS),
+              ],
+              [
+                AlertRuleAggregations.TOTAL,
+                getMetricDisplayName(AlertRuleAggregations.TOTAL),
+              ],
+            ]}
+            required
+            setValue={value => (value && value.length ? value[0] : value)}
+            getValue={value => [value]}
+          />
+          <FormField
+            name="query"
+            label={t('Filter')}
+            defaultValue=""
+            placeholder="error.type:TypeError"
+            help={t(
+              'You can apply standard Sentry filter syntax to filter by status, user, etc.'
+            )}
+          >
+            {({onChange, onBlur, onKeyDown}) => {
+              return (
+                <SearchBar
+                  useFormWrapper={false}
+                  organization={organization}
+                  onChange={onChange}
+                  onBlur={onBlur}
+                  onKeyDown={onKeyDown}
+                  onSearch={query => onChange(query, {})}
+                />
+              );
+            }}
+          </FormField>
+          <SelectField
+            name="timeWindow"
+            label={t('Time Window')}
+            help={t('The time window to use when evaluating the Metric')}
+            choices={Object.entries(TIME_WINDOW_MAP)}
+            required
+          />
+        </PanelBody>
+      </Panel>
+    );
+  }
+}
+
+export default RuleConditionsForm;
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/ruleForm/index.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/ruleForm/index.tsx
index d2743aa2f6..3470c9fcca 100644
--- a/src/sentry/static/sentry/app/views/settings/incidentRules/ruleForm/index.tsx
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/ruleForm/index.tsx
@@ -1,113 +1,224 @@
-import findIndex from 'lodash/findIndex';
+import {RouteComponentProps} from 'react-router/lib/Router';
 import React from 'react';
 
-import {Project} from 'app/types';
-import {addErrorMessage} from 'app/actionCreators/indicator';
-import {deleteTrigger} from 'app/views/settings/incidentRules/actions';
-import {tct} from 'app/locale';
+import {Client} from 'app/api';
+import {MetricAction} from 'app/types/alerts';
+import {Organization, Project, Config} from 'app/types';
+import {
+  addErrorMessage,
+  addLoadingMessage,
+  addSuccessMessage,
+  clearIndicators,
+} from 'app/actionCreators/indicator';
+import {createDefaultTrigger} from 'app/views/settings/incidentRules/constants';
+import {defined} from 'app/utils';
+import {t} from 'app/locale';
+import AsyncComponent from 'app/components/asyncComponent';
 import Form from 'app/views/settings/components/forms/form';
-import RuleForm from 'app/views/settings/incidentRules/ruleForm/ruleForm';
-import SentryTypes from 'app/sentryTypes';
+import RuleNameForm from 'app/views/settings/incidentRules/ruleNameForm';
 import Triggers from 'app/views/settings/incidentRules/triggers';
+import TriggersChart from 'app/views/settings/incidentRules/triggers/chart';
 import withApi from 'app/utils/withApi';
 import withConfig from 'app/utils/withConfig';
 import withProject from 'app/utils/withProject';
 
 import {IncidentRule, Trigger} from '../types';
+import RuleConditionsForm from '../ruleConditionsForm';
+import FormModel from '../../components/forms/model';
+import {addOrUpdateRule} from '../actions';
 
 type Props = {
+  api: Client;
+  config: Config;
+  organization: Organization;
   project: Project;
   rule: IncidentRule;
   incidentRuleId?: string;
-} & Pick<React.ComponentProps<typeof RuleForm>, 'api' | 'config' | 'organization'> & {
+} & Pick<RouteComponentProps<{orgId: string; projectId: string}, {}>, 'params'> & {
     onSubmitSuccess?: Form['props']['onSubmitSuccess'];
-  };
+  } & AsyncComponent['props'];
 
 type State = {
-  rule: IncidentRule;
-};
+  triggers: Trigger[];
+  projects: Project[];
+  triggerErrors: Map<number, {[fieldName: string]: string}>;
 
-class RuleFormContainer extends React.Component<Props, State> {
-  static contextTypes = {
-    project: SentryTypes.Project,
-  };
+  // `null` means loading
+  availableActions: MetricAction[] | null;
+} & AsyncComponent['state'];
 
-  state = {
-    rule: this.props.rule,
-    projects: [this.props.project],
-  };
+const isEmpty = (str: unknown): boolean => str === '' || !defined(str);
 
-  handleAddTrigger = (trigger: Trigger) => {
-    this.setState(({rule}) => ({
-      rule: {
-        ...rule,
-        triggers: [...rule.triggers, trigger],
-      },
-    }));
-  };
+class RuleFormContainer extends AsyncComponent<Props, State> {
+  getDefaultState(): State {
+    return {
+      ...super.getDefaultState(),
+      triggerErrors: new Map(),
+      availableActions: null,
+      triggers: this.props.rule.triggers,
+      projects: [this.props.project],
+    };
+  }
+
+  getEndpoints(): [string, string][] {
+    const {params} = this.props;
+
+    // TODO(incidents): This is temporary until new API endpoints
+    // We should be able to just fetch the rule if rule.id exists
+
+    return [
+      [
+        'availableActions',
+        `/organizations/${params.orgId}/alert-rules/available-actions/`,
+      ],
+    ];
+  }
+
+  validateFieldInTrigger({errors, triggerIndex, field, message, isValid}) {
+    // If valid, reset error for fieldName
+    if (isValid()) {
+      const {[field]: _validatedField, ...otherErrors} = errors.get(triggerIndex) || {};
 
-  handleEditTrigger = (trigger: Trigger) => {
-    this.setState(({rule}) => {
-      const triggerIndex = findIndex(rule.triggers, ({id}) => id === trigger.id);
-      const triggers = [...rule.triggers];
-      triggers.splice(triggerIndex, 1, trigger);
-
-      return {
-        rule: {
-          ...rule,
-          triggers,
-        },
-      };
+      if (Object.keys(otherErrors).length > 0) {
+        errors.set(triggerIndex, otherErrors);
+      } else {
+        errors.delete(triggerIndex);
+      }
+
+      return errors;
+    }
+
+    if (!errors.has(triggerIndex)) {
+      errors.set(triggerIndex, {});
+    }
+    const currentErrors = errors.get(triggerIndex);
+
+    errors.set(triggerIndex, {
+      ...currentErrors,
+      [field]: message,
     });
-  };
 
-  handleDeleteTrigger = async (trigger: Trigger) => {
-    const {api, organization} = this.props;
-
-    // Optimistically update
-    const triggerIndex = findIndex(this.state.rule.triggers, ({id}) => id === trigger.id);
-    const triggersAfterDelete = [...this.state.rule.triggers];
-    triggersAfterDelete.splice(triggerIndex, 1);
-
-    this.setState(({rule}) => {
-      return {
-        rule: {
-          ...rule,
-          triggers: triggersAfterDelete,
-        },
-      };
+    return errors;
+  }
+
+  /**
+   * Validate triggers
+   *
+   * @return Returns true if triggers are valid
+   */
+  validateTriggers(triggers = this.state.triggers) {
+    const triggerErrors = new Map();
+
+    const requiredFields = ['label', 'alertThreshold'];
+    triggers.forEach((trigger, triggerIndex) => {
+      requiredFields.forEach(field => {
+        // check required fields
+        this.validateFieldInTrigger({
+          errors: triggerErrors,
+          triggerIndex,
+          isValid: () => !isEmpty(trigger[field]),
+          field,
+          message: t('Field is required'),
+        });
+      });
     });
 
-    // Trigger is potentially unsaved if it does not have an id, so don't try to remove from server
-    if (!trigger.id) {
+    return triggerErrors;
+  }
+
+  handleSubmit = async (
+    _data: Partial<IncidentRule>,
+    _onSubmitSuccess,
+    _onSubmitError,
+    _e,
+    model: FormModel
+  ) => {
+    // This validates all fields *except* for Triggers
+    const validRule = model.validateForm();
+
+    // Validate Triggers
+    const triggerErrors = this.validateTriggers();
+    const validTriggers = Array.from(triggerErrors).length === 0;
+
+    if (!validTriggers) {
+      this.setState(state => ({
+        triggerErrors: new Map([...triggerErrors, ...state.triggerErrors]),
+      }));
+    }
+
+    if (!validRule || !validTriggers) {
+      addErrorMessage(t('Alert not valid'));
       return;
     }
 
+    const {api, organization, rule, onSubmitSuccess} = this.props;
+
+    // form model has all form state data, however we use local state to keep
+    // track of the list of triggers (and actions within triggers)
     try {
-      await deleteTrigger(api, organization.slug, trigger);
-    } catch (err) {
-      addErrorMessage(
-        tct('There was a problem deleting trigger: [label]', {label: trigger.label})
-      );
-
-      // Add trigger back to list
-      this.setState(({rule}) => {
-        const triggers = [...rule.triggers];
-        triggers.splice(triggerIndex, 0, trigger);
-
-        return {
-          rule: {
-            ...rule,
-            triggers,
-          },
-        };
+      addLoadingMessage(t('Saving alert'));
+      const resp = await addOrUpdateRule(api, organization.slug, {
+        ...rule,
+        ...model.getTransformedData(),
+        triggers: this.state.triggers,
       });
+      addSuccessMessage(t('Successfully saved alert'));
+      if (onSubmitSuccess) {
+        onSubmitSuccess(resp, model);
+      }
+    } catch (err) {
+      addErrorMessage(t('Unable to save alert'));
     }
   };
 
-  render() {
-    const {api, config, organization, incidentRuleId, onSubmitSuccess} = this.props;
-    const {rule} = this.state;
+  /**
+   * Add a new trigger
+   */
+  handleAddTrigger = () => {
+    this.setState(({triggers}) => ({
+      triggers: [...triggers, createDefaultTrigger()],
+    }));
+  };
+
+  /**
+   * Callback for when triggers change
+   */
+  handleChangeTriggers = (triggers: Trigger[]) => {
+    this.setState(state => {
+      let triggerErrors = state.triggerErrors;
+
+      // If we have an existing trigger error, we should attempt to
+      // re-validate triggers when triggers has a change
+      //
+      // Otherwise wait until submit to validate triggers
+      if (Array.from(state.triggerErrors).length > 0) {
+        const newTriggerErrors = this.validateTriggers(triggers);
+        triggerErrors = newTriggerErrors;
+
+        if (Array.from(newTriggerErrors).length === 0) {
+          clearIndicators();
+        }
+      }
+
+      return {triggers, triggerErrors};
+    });
+  };
+
+  renderLoading() {
+    return this.renderBody();
+  }
+
+  renderBody() {
+    const {
+      api,
+      config,
+      organization,
+      incidentRuleId,
+      rule,
+      params,
+      onSubmitSuccess,
+    } = this.props;
+    const {triggers} = this.state;
 
     return (
       <Form
@@ -115,19 +226,42 @@ class RuleFormContainer extends React.Component<Props, State> {
         apiEndpoint={`/organizations/${organization.slug}/alert-rules/${
           incidentRuleId ? `${incidentRuleId}/` : ''
         }`}
-        initialData={rule}
+        initialData={{
+          name: rule.name || '',
+          aggregations: rule.aggregations,
+          query: rule.query || '',
+          timeWindow: rule.timeWindow,
+        }}
         saveOnBlur={false}
+        onSubmit={this.handleSubmit}
         onSubmitSuccess={onSubmitSuccess}
       >
-        <RuleForm api={api} config={config} organization={organization} rule={rule} />
+        {/* TODO(billy): Temp */}
+        <TriggersChart
+          api={api}
+          config={config}
+          organization={organization}
+          projects={this.state.projects}
+          query={rule.query}
+          aggregations={rule.aggregations}
+          timeWindow={rule.timeWindow}
+        />
+
+        <RuleConditionsForm organization={organization} />
+
         <Triggers
-          rule={rule}
+          projects={this.state.projects}
+          errors={this.state.triggerErrors}
+          triggers={triggers}
+          currentProject={params.projectId}
           organization={organization}
           incidentRuleId={incidentRuleId}
-          onDelete={this.handleDeleteTrigger}
-          onEdit={this.handleEditTrigger}
+          availableActions={this.state.availableActions}
+          onChange={this.handleChangeTriggers}
           onAdd={this.handleAddTrigger}
         />
+
+        <RuleNameForm />
       </Form>
     );
   }
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/ruleForm/ruleForm.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/ruleForm/ruleForm.tsx
deleted file mode 100644
index 58c6c79d75..0000000000
--- a/src/sentry/static/sentry/app/views/settings/incidentRules/ruleForm/ruleForm.tsx
+++ /dev/null
@@ -1,117 +0,0 @@
-import React from 'react';
-
-import {Client} from 'app/api';
-import {Config, Organization} from 'app/types';
-import {t} from 'app/locale';
-import FormField from 'app/views/settings/components/forms/formField';
-import JsonForm from 'app/views/settings/components/forms/jsonForm';
-import SearchBar from 'app/views/events/searchBar';
-
-import {AlertRuleAggregations, IncidentRule, TimeWindow} from '../types';
-import getMetricDisplayName from '../utils/getMetricDisplayName';
-
-type Props = {
-  api: Client;
-  config: Config;
-  organization: Organization;
-  rule?: IncidentRule;
-};
-
-type TimeWindowMapType = {[key in TimeWindow]: string};
-
-const TIME_WINDOW_MAP: TimeWindowMapType = {
-  [TimeWindow.ONE_MINUTE]: t('1 minute'),
-  [TimeWindow.FIVE_MINUTES]: t('5 minutes'),
-  [TimeWindow.TEN_MINUTES]: t('10 minutes'),
-  [TimeWindow.FIFTEEN_MINUTES]: t('15 minutes'),
-  [TimeWindow.THIRTY_MINUTES]: t('30 minutes'),
-  [TimeWindow.ONE_HOUR]: t('1 hour'),
-  [TimeWindow.TWO_HOURS]: t('2 hours'),
-  [TimeWindow.FOUR_HOURS]: t('4 hours'),
-  [TimeWindow.ONE_DAY]: t('24 hours'),
-};
-
-class RuleForm extends React.Component<Props> {
-  render() {
-    const {organization} = this.props;
-
-    return (
-      <React.Fragment>
-        <JsonForm
-          forms={[
-            {
-              title: t('Metric'),
-              fields: [
-                {
-                  name: 'name',
-                  type: 'text',
-                  label: t('Name'),
-                  help: t('Give your Incident Rule a name so it is easy to manage later'),
-                  placeholder: t('My Incident Rule Name'),
-                  required: true,
-                },
-                {
-                  name: 'aggregations',
-                  type: 'select',
-                  label: t('Metric'),
-                  help: t('Choose which metric to trigger on'),
-                  choices: [
-                    [
-                      AlertRuleAggregations.UNIQUE_USERS,
-                      getMetricDisplayName(AlertRuleAggregations.UNIQUE_USERS),
-                    ],
-                    [
-                      AlertRuleAggregations.TOTAL,
-                      getMetricDisplayName(AlertRuleAggregations.TOTAL),
-                    ],
-                  ],
-                  required: true,
-                  setValue: value => (value && value.length ? value[0] : value),
-                  getValue: value => [value],
-                },
-                {
-                  name: 'query',
-                  type: 'custom',
-                  label: t('Filter'),
-                  defaultValue: '',
-                  placeholder: 'error.type:TypeError',
-                  help: t(
-                    'You can apply standard Sentry filter syntax to filter by status, user, etc.'
-                  ),
-                  Component: props => {
-                    return (
-                      <FormField {...props}>
-                        {({onChange, onBlur, onKeyDown}) => {
-                          return (
-                            <SearchBar
-                              useFormWrapper={false}
-                              organization={organization}
-                              onChange={onChange}
-                              onBlur={onBlur}
-                              onKeyDown={onKeyDown}
-                              onSearch={query => onChange(query, {})}
-                            />
-                          );
-                        }}
-                      </FormField>
-                    );
-                  },
-                },
-                {
-                  name: 'timeWindow',
-                  type: 'select',
-                  label: t('Time Window'),
-                  help: t('The time window to use when evaluating the Metric'),
-                  choices: Object.entries(TIME_WINDOW_MAP),
-                  required: true,
-                },
-              ],
-            },
-          ]}
-        />
-      </React.Fragment>
-    );
-  }
-}
-
-export default RuleForm;
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/ruleNameForm.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/ruleNameForm.tsx
new file mode 100644
index 0000000000..cc44497c33
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/ruleNameForm.tsx
@@ -0,0 +1,27 @@
+import React from 'react';
+
+import {Panel, PanelBody, PanelHeader} from 'app/components/panels';
+import {t} from 'app/locale';
+import TextField from 'app/views/settings/components/forms/textField';
+
+class RuleNameForm extends React.PureComponent {
+  render() {
+    return (
+      <Panel>
+        <PanelHeader>{t('Give your rule a name')}</PanelHeader>
+        <PanelBody>
+          <TextField
+            name="name"
+            type="text"
+            label={t('Rule Name')}
+            help={t('Give your rule a name so it is easy to manage later')}
+            placeholder={t('Something really bad happened')}
+            required
+          />
+        </PanelBody>
+      </Panel>
+    );
+  }
+}
+
+export default RuleNameForm;
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/actionsPanel/deleteActionButton.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/actionsPanel/deleteActionButton.tsx
new file mode 100644
index 0000000000..0d1e4c728d
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/actionsPanel/deleteActionButton.tsx
@@ -0,0 +1,26 @@
+import React from 'react';
+import {t} from 'app/locale';
+import Button from 'app/components/button';
+
+type Props = Omit<Button['props'], 'onClick'> & {
+  index: number;
+  onClick: (index: number, e: React.MouseEvent) => void;
+};
+
+export default function DeleteActionButton(props: Props) {
+  const handleClick = (e: React.MouseEvent) => {
+    const {index, onClick} = props;
+    onClick(index, e);
+  };
+
+  return (
+    <Button
+      type="button"
+      size="xsmall"
+      icon="icon-trash"
+      aria-label={t('Remove action')}
+      {...props}
+      onClick={handleClick}
+    />
+  );
+}
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/actionsPanel/index.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/actionsPanel/index.tsx
index c095261d45..e9243ccfc6 100644
--- a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/actionsPanel/index.tsx
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/actionsPanel/index.tsx
@@ -1,39 +1,21 @@
 import React from 'react';
 import styled from 'react-emotion';
 
-import {
-  IncidentRule,
-  Trigger,
-  Action,
-  ActionType,
-  TargetType,
-} from 'app/views/settings/incidentRules/types';
-import {Organization, Project} from 'app/types';
-import {Panel, PanelBody, PanelItem, PanelHeader} from 'app/components/panels';
+import {Action, ActionType, TargetType} from 'app/views/settings/incidentRules/types';
+import {MetricAction} from 'app/types/alerts';
+import {Organization, Project, SelectValue} from 'app/types';
+import {PanelItem} from 'app/components/panels';
+import {removeAtArrayIndex} from 'app/utils/removeAtArrayIndex';
+import {replaceAtArrayIndex} from 'app/utils/replaceAtArrayIndex';
 import {t} from 'app/locale';
-import DropdownAutoComplete from 'app/components/dropdownAutoComplete';
-import DropdownButton from 'app/components/dropdownButton';
-import EmptyMessage from 'app/views/settings/components/emptyMessage';
+import DeleteActionButton from 'app/views/settings/incidentRules/triggers/actionsPanel/deleteActionButton';
 import LoadingIndicator from 'app/components/loadingIndicator';
+import PanelSubHeader from 'app/views/settings/incidentRules/triggers/panelSubHeader';
 import SelectControl from 'app/components/forms/selectControl';
 import SelectMembers from 'app/components/selectMembers';
 import space from 'app/styles/space';
 import withOrganization from 'app/utils/withOrganization';
 
-type Props = {
-  organization: Organization;
-  projects: Project[];
-  rule: IncidentRule;
-  loading: boolean;
-  error: boolean;
-
-  actions: Action[];
-  className?: string;
-  trigger?: Trigger;
-  onAdd: (type: Action['type']) => void;
-  onChange: (index: number, action: Action) => void;
-};
-
 const ActionLabel = {
   [ActionType.EMAIL]: t('E-mail'),
   [ActionType.SLACK]: t('Slack'),
@@ -45,87 +27,125 @@ const TargetLabel = {
   [TargetType.TEAM]: t('Team'),
 };
 
-class ActionsPanel extends React.Component<Props> {
+type Props = {
+  availableActions: MetricAction[] | null;
+  currentProject: string;
+  organization: Organization;
+  projects: Project[];
+  loading: boolean;
+  error: boolean;
+
+  actions: Action[];
+  className?: string;
+  triggerIndex: number;
+  onAdd: (type: Action['type']) => void;
+  onChange: (actions: Action[]) => void;
+};
+
+class ActionsPanel extends React.PureComponent<Props> {
   handleAddAction = (value: {label: string; value: Action['type']}) => {
     this.props.onAdd(value.value);
   };
+  handleDeleteAction = (index: number) => {
+    const {actions, onChange} = this.props;
+
+    onChange(removeAtArrayIndex(actions, index));
+  };
 
-  handleChangeTarget = (index: number, value) => {
-    const {actions} = this.props;
+  handleChangeTarget = (index: number, value: SelectValue<keyof typeof TargetLabel>) => {
+    const {actions, onChange} = this.props;
     const newAction = {
       ...actions[index],
-      targetType: Number(value.value),
+      targetType: value.value,
       targetIdentifier: '',
     };
 
-    this.props.onChange(index, newAction);
+    onChange(replaceAtArrayIndex(actions, index, newAction));
   };
 
-  handleChangeTargetIdentifier = (index, value) => {
-    const {actions} = this.props;
+  handleChangeTargetIdentifier = (index: number, value) => {
+    const {actions, onChange} = this.props;
     const newAction = {
       ...actions[index],
       targetIdentifier: value.value,
     };
 
-    this.props.onChange(index, newAction);
+    onChange(replaceAtArrayIndex(actions, index, newAction));
   };
 
   render() {
-    const {actions, className, loading, organization, projects, rule} = this.props;
-
-    const items = Object.entries(ActionLabel).map(([value, label]) => ({value, label}));
+    const {
+      actions,
+      availableActions,
+      currentProject,
+      loading,
+      organization,
+      projects,
+    } = this.props;
+
+    const items =
+      availableActions &&
+      availableActions.map(({type: value}) => ({
+        value,
+        label: ActionLabel[value],
+      }));
 
     return (
-      <Panel className={className}>
-        <PanelHeader hasButtons>
-          <div>{t('Actions')}</div>
-          <DropdownAutoComplete
-            blendCorner
-            hideInput
-            onSelect={this.handleAddAction}
-            items={items}
-          >
-            {() => <DropdownButton size="small">{t('Add Action')}</DropdownButton>}
-          </DropdownAutoComplete>
-        </PanelHeader>
-        <PanelBody>
+      <React.Fragment>
+        <PanelSubHeader>{t('Actions')}</PanelSubHeader>
+        <React.Fragment>
           {loading && <LoadingIndicator />}
-          {!loading && !actions.length && (
-            <EmptyMessage>{t('No Actions have been added')}</EmptyMessage>
-          )}
-          {actions.map((action: Action, i: number) => {
-            const isUser = action.targetType === TargetType.USER;
-            const isTeam = action.targetType === TargetType.TEAM;
-
-            return (
-              <PanelItemGrid key={i}>
-                {ActionLabel[action.type]}
-
-                <SelectControl
-                  value={action.targetType}
-                  options={Object.entries(TargetLabel).map(([value, label]) => ({
-                    value,
-                    label,
-                  }))}
-                  onChange={this.handleChangeTarget.bind(this, i)}
-                />
-
-                {(isUser || isTeam) && (
-                  <SelectMembers
-                    key={isTeam ? 'team' : 'member'}
-                    showTeam={isTeam}
-                    project={projects.find(({slug}) => slug === rule.projects[0])}
-                    organization={organization}
-                    value={action.targetIdentifier}
-                    onChange={this.handleChangeTargetIdentifier.bind(this, i)}
+          {actions &&
+            actions.map((action: Action, i: number) => {
+              const isUser = action.targetType === TargetType.USER;
+              const isTeam = action.targetType === TargetType.TEAM;
+              const availableAction =
+                availableActions &&
+                availableActions.find(({type}) => type === action.type);
+
+              return (
+                <PanelItemGrid key={i}>
+                  {ActionLabel[action.type]}
+
+                  <SelectControl
+                    disabled={loading}
+                    value={action.targetType}
+                    options={
+                      availableAction &&
+                      availableAction.allowedTargetTypes.map(allowedType => ({
+                        value: allowedType,
+                        label: TargetLabel[allowedType],
+                      }))
+                    }
+                    onChange={this.handleChangeTarget.bind(this, i)}
                   />
-                )}
-              </PanelItemGrid>
-            );
-          })}
-        </PanelBody>
-      </Panel>
+
+                  {(isUser || isTeam) && (
+                    <SelectMembers
+                      key={isTeam ? 'team' : 'member'}
+                      showTeam={isTeam}
+                      project={projects.find(({slug}) => slug === currentProject)}
+                      organization={organization}
+                      value={action.targetIdentifier}
+                      onChange={this.handleChangeTargetIdentifier.bind(this, i)}
+                    />
+                  )}
+                  <DeleteActionButton index={i} onClick={this.handleDeleteAction} />
+                </PanelItemGrid>
+              );
+            })}
+          <PanelItem>
+            <StyledSelectControl
+              name="add-action"
+              aria-label={t('Add an Action')}
+              disabled={loading}
+              placeholder={t('Add an Action')}
+              onChange={this.handleAddAction}
+              options={items}
+            />
+          </PanelItem>
+        </React.Fragment>
+      </React.Fragment>
     );
   }
 }
@@ -136,9 +156,13 @@ const ActionsPanelWithSpace = styled(ActionsPanel)`
 
 const PanelItemGrid = styled(PanelItem)`
   display: grid;
-  grid-template-columns: 1fr 1fr 1fr;
+  grid-template-columns: 1fr 1fr 1fr min-content;
   align-items: center;
   grid-gap: ${space(2)};
 `;
 
+const StyledSelectControl = styled(SelectControl)`
+  width: 100%;
+`;
+
 export default withOrganization(ActionsPanelWithSpace);
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/chart/draggableChart.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/chart/draggableChart.tsx
index 9e1e93b00b..3e499821ff 100644
--- a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/chart/draggableChart.tsx
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/chart/draggableChart.tsx
@@ -2,7 +2,6 @@ import {ECharts, EChartOption} from 'echarts';
 import debounce from 'lodash/debounce';
 import maxBy from 'lodash/maxBy';
 import React from 'react';
-import styled from 'react-emotion';
 
 import {ReactEchartsRef, Series, SeriesDataUnit} from 'app/types/echarts';
 import Graphic from 'app/components/charts/components/graphic';
@@ -34,7 +33,7 @@ const CHART_GRID = {
   bottom: space(1),
 };
 
-export default class IncidentRulesChart extends React.Component<Props, State> {
+export default class IncidentRulesChart extends React.PureComponent<Props, State> {
   static defaultProps = {
     data: [],
   };
@@ -246,37 +245,30 @@ export default class IncidentRulesChart extends React.Component<Props, State> {
       this.chartRef.convertToPixel({yAxisIndex: 0}, `${this.props.resolveThreshold}`);
 
     return (
-      <Wrapper>
-        <LineChart
-          isGroupedByDate
-          forwardedRef={this.handleRef}
-          grid={CHART_GRID}
-          xAxis={xAxis}
-          yAxis={{
-            max: this.state.yAxisMax,
-          }}
-          graphic={Graphic({
-            elements: [
-              ...this.getThresholdLine(
-                alertThresholdPosition,
-                false,
-                this.setIncidentThreshold
-              ),
-              ...this.getThresholdLine(
-                resolveThresholdPosition,
-                true,
-                this.setResolutionThreshold
-              ),
-            ],
-          })}
-          series={data}
-        />
-      </Wrapper>
+      <LineChart
+        isGroupedByDate
+        forwardedRef={this.handleRef}
+        grid={CHART_GRID}
+        xAxis={xAxis}
+        yAxis={{
+          max: this.state.yAxisMax,
+        }}
+        graphic={Graphic({
+          elements: [
+            ...this.getThresholdLine(
+              alertThresholdPosition,
+              false,
+              this.setIncidentThreshold
+            ),
+            ...this.getThresholdLine(
+              resolveThresholdPosition,
+              true,
+              this.setResolutionThreshold
+            ),
+          ],
+        })}
+        series={data}
+      />
     );
   }
 }
-
-const Wrapper = styled('div')`
-  position: relative;
-  border-bottom: 1px solid ${p => p.theme.borderLight};
-`;
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/chart/index.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/chart/index.tsx
index 090e278389..6300c2b429 100644
--- a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/chart/index.tsx
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/chart/index.tsx
@@ -1,15 +1,17 @@
-import maxBy from 'lodash/maxBy';
 import React from 'react';
+import maxBy from 'lodash/maxBy';
 import moment from 'moment-timezone';
 import styled from 'react-emotion';
 
 import {Client} from 'app/api';
 import {Config, Organization, Project} from 'app/types';
+import {Panel} from 'app/components/panels';
 import {SeriesDataUnit} from 'app/types/echarts';
 import {getFormattedDate} from 'app/utils/dates';
 import EventsRequest from 'app/views/events/utils/eventsRequest';
 import LoadingMask from 'app/components/loadingMask';
 import Placeholder from 'app/components/placeholder';
+import space from 'app/styles/space';
 
 import {AlertRuleAggregations, IncidentRule, TimeWindow} from '../../types';
 import DraggableChart from './draggableChart';
@@ -31,7 +33,7 @@ type Props = {
   onChangeResolutionThreshold?: (resolveThreshold: number) => void;
 };
 
-class TriggersChart extends React.Component<Props> {
+class TriggersChart extends React.PureComponent<Props> {
   render() {
     const {
       api,
@@ -66,38 +68,40 @@ class TriggersChart extends React.Component<Props> {
           }
 
           return (
-            <React.Fragment>
-              {loading ? (
-                <Placeholder height="200px" bottomGutter={1} />
-              ) : (
-                <React.Fragment>
-                  <TransparentLoadingMask visible={reloading} />
-                  <DraggableChart
-                    xAxis={{
-                      axisLabel: {
-                        formatter: (value: moment.MomentInput, index: number) => {
-                          const firstItem = index === 0;
-                          const format =
-                            timeWindow <= TimeWindow.FIVE_MINUTES && !firstItem
-                              ? 'LT'
-                              : 'MMM Do';
-                          return getFormattedDate(value, format, {
-                            local: config.user.options.timezone !== 'UTC',
-                          });
+            <StickyWrapper>
+              <PanelNoMargin>
+                {loading ? (
+                  <Placeholder height="200px" />
+                ) : (
+                  <React.Fragment>
+                    <TransparentLoadingMask visible={reloading} />
+                    <DraggableChart
+                      xAxis={{
+                        axisLabel: {
+                          formatter: (value: moment.MomentInput, index: number) => {
+                            const firstItem = index === 0;
+                            const format =
+                              timeWindow <= TimeWindow.FIVE_MINUTES && !firstItem
+                                ? 'LT'
+                                : 'MMM Do';
+                            return getFormattedDate(value, format, {
+                              local: config.user.options.timezone !== 'UTC',
+                            });
+                          },
                         },
-                      },
-                    }}
-                    maxValue={maxValue ? maxValue.value : maxValue}
-                    onChangeIncidentThreshold={this.props.onChangeIncidentThreshold}
-                    alertThreshold={alertThreshold}
-                    onChangeResolutionThreshold={this.props.onChangeResolutionThreshold}
-                    resolveThreshold={resolveThreshold}
-                    isInverted={isInverted}
-                    data={timeseriesData}
-                  />
-                </React.Fragment>
-              )}
-            </React.Fragment>
+                      }}
+                      maxValue={maxValue ? maxValue.value : maxValue}
+                      onChangeIncidentThreshold={this.props.onChangeIncidentThreshold}
+                      alertThreshold={alertThreshold}
+                      onChangeResolutionThreshold={this.props.onChangeResolutionThreshold}
+                      resolveThreshold={resolveThreshold}
+                      isInverted={isInverted}
+                      data={timeseriesData}
+                    />
+                  </React.Fragment>
+                )}
+              </PanelNoMargin>
+            </StickyWrapper>
           );
         }}
       </EventsRequest>
@@ -136,3 +140,19 @@ const TransparentLoadingMask = styled(LoadingMask)<{visible: boolean}>`
   opacity: 0.4;
   z-index: 1;
 `;
+
+const PanelNoMargin = styled(Panel)`
+  margin: 0;
+`;
+
+/**
+ * We wrap Panel with this (instead of applying styles to Panel) so that we can get the extra padding
+ * at the bottom so sticky chart does not bleed into other content.
+ */
+const StickyWrapper = styled('div')`
+  position: sticky;
+  top: 69px; /* Height of settings breadcrumb */
+  z-index: ${p => p.theme.zIndex.dropdown + 1};
+  padding-bottom: ${space(2)};
+  background-color: rgba(251, 251, 252, 0.9); /* p.theme.whiteDark */
+`;
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/form.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/form.tsx
index bc64bede88..3190554c97 100644
--- a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/form.tsx
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/form.tsx
@@ -1,32 +1,25 @@
-import FormModel from 'app/views/settings/components/forms/model';
-
-import debounce from 'lodash/debounce';
-import PropTypes from 'prop-types';
 import React from 'react';
 
 import {Client} from 'app/api';
 import {Config, Organization, Project} from 'app/types';
+import {MetricAction} from 'app/types/alerts';
 import {addErrorMessage} from 'app/actionCreators/indicator';
 import {fetchOrgMembers} from 'app/actionCreators/members';
-import {replaceAtArrayIndex} from 'app/utils/replaceAtArrayIndex';
 import {t} from 'app/locale';
 import ActionsPanel from 'app/views/settings/incidentRules/triggers/actionsPanel';
-import AsyncComponent from 'app/components/asyncComponent';
-import Form from 'app/views/settings/components/forms/form';
-import JsonForm from 'app/views/settings/components/forms/jsonForm';
+import Field from 'app/views/settings/components/forms/field';
+import Input from 'app/views/settings/components/forms/controls/input';
+import ThresholdControl from 'app/views/settings/incidentRules/triggers/thresholdControl';
 import withApi from 'app/utils/withApi';
 import withConfig from 'app/utils/withConfig';
 
 import {
   AlertRuleThreshold,
-  AlertRuleThresholdType,
-  IncidentRule,
-  UnsavedTrigger,
   Trigger,
   Action,
   TargetType,
+  ThresholdControlValue,
 } from '../types';
-import TriggersChart from './chart';
 
 type AlertRuleThresholdKey = {
   [AlertRuleThreshold.INCIDENT]: 'alertThreshold';
@@ -37,40 +30,19 @@ type Props = {
   api: Client;
   config: Config;
   organization: Organization;
+
+  /**
+   * Map of fieldName -> errorMessage
+   */
+  error?: {[fieldName: string]: string};
   projects: Project[];
-  rule: IncidentRule;
-  trigger?: Trigger;
-};
+  trigger: Trigger;
+  triggerIndex: number;
 
-type State = {
-  width?: number;
-  isInverted: boolean;
-  alertThreshold: number | null;
-  resolveThreshold: number | null;
-  maxThreshold: number | null;
+  onChange: (trigger: Trigger) => void;
 };
 
-class TriggerForm extends React.Component<Props, State> {
-  static contextTypes = {
-    form: PropTypes.any,
-  };
-
-  static defaultProps = {};
-
-  state = {
-    isInverted: this.props.trigger
-      ? this.props.trigger.thresholdType === AlertRuleThresholdType.BELOW
-      : false,
-    alertThreshold: this.props.trigger ? this.props.trigger.alertThreshold : null,
-    resolveThreshold: this.props.trigger ? this.props.trigger.resolveThreshold : null,
-    maxThreshold: this.props.trigger
-      ? Math.max(
-          this.props.trigger.alertThreshold,
-          this.props.trigger.resolveThreshold
-        ) || null
-      : null,
-  };
-
+class TriggerForm extends React.PureComponent<Props> {
   getThresholdKey = (
     type: AlertRuleThreshold
   ): AlertRuleThresholdKey[AlertRuleThreshold] =>
@@ -83,13 +55,18 @@ class TriggerForm extends React.Component<Props, State> {
    * @param type The threshold type to be updated
    * @param value The new threshold value
    */
-  canUpdateThreshold = (type: AlertRuleThreshold, value: number): boolean => {
+  canUpdateThreshold = (
+    type: AlertRuleThreshold,
+    value: ThresholdControlValue['threshold']
+  ): boolean => {
+    const {trigger} = this.props;
     const isResolution = type === AlertRuleThreshold.RESOLUTION;
     const otherKey = isResolution ? 'alertThreshold' : 'resolveThreshold';
-    const otherValue = this.state[otherKey];
+    const otherValue = trigger[otherKey];
 
-    // If other value is `null`, then there are no checks to perform against
-    if (otherValue === null) {
+    // If value and/or other value is empty
+    // then there are no checks to perform against
+    if (otherValue === '' || value === '') {
       return true;
     }
 
@@ -97,7 +74,7 @@ class TriggerForm extends React.Component<Props, State> {
     // If this is alert threshold and inverted, it can't be above resolve
     // If this is resolve threshold and not inverted, it can't be above resolve
     // If this is resolve threshold and inverted, it can't be below resolve
-    return !!this.state.isInverted !== isResolution
+    return !!trigger.thresholdType !== isResolution
       ? value <= otherValue
       : value >= otherValue;
   };
@@ -111,6 +88,7 @@ class TriggerForm extends React.Component<Props, State> {
    * with old values (so the dragged line "resets")
    */
   revertThresholdUpdate = (type: AlertRuleThreshold) => {
+    const {trigger} = this.props;
     const isIncident = type === AlertRuleThreshold.INCIDENT;
     const typeDisplay = isIncident ? t('Incident boundary') : t('Resolution boundary');
     const otherTypeDisplay = !isIncident
@@ -119,309 +97,172 @@ class TriggerForm extends React.Component<Props, State> {
 
     // if incident and not inverted: incident required to be >
     // if resolution and inverted: resolution required to be >
-    const direction = isIncident !== this.state.isInverted ? 'greater' : 'less';
+    const direction = isIncident !== !!trigger.thresholdType ? 'greater' : 'less';
 
     addErrorMessage(t(`${typeDisplay} must be ${direction} than ${otherTypeDisplay}`));
-
-    // Need to a re-render so that our chart re-renders and moves the draggable line back
-    // to its original position (since the drag update is not valid)
-    this.forceUpdate();
-
-    // Reset form value
-    const thresholdKey = this.getThresholdKey(type);
-    this.context.form.setValue(thresholdKey, this.state[thresholdKey]);
-  };
-
-  /**
-   * Handler for the range slider input. Needs to update state (as well as max threshold)
-   */
-  updateThresholdInput = (type: AlertRuleThreshold, value: number) => {
-    if (this.canUpdateThreshold(type, value)) {
-      this.setState(state => ({
-        ...state,
-        [this.getThresholdKey(type)]: value,
-        ...(value > (state.maxThreshold || 0) && {maxThreshold: value}),
-      }));
-    } else {
-      this.revertThresholdUpdate(type);
-    }
   };
 
   /**
    * Handler for threshold changes coming from slider or chart.
    * Needs to sync state with the form.
    */
-  updateThreshold = (type: AlertRuleThreshold, value: number) => {
-    if (this.canUpdateThreshold(type, value)) {
-      const thresholdKey = this.getThresholdKey(type);
-      const newValue = Math.round(value);
-      this.setState(state => ({
-        ...state,
-        [thresholdKey]: newValue,
-        ...(newValue > (state.maxThreshold || 0) && {maxThreshold: newValue}),
-      }));
-      this.context.form.setValue(thresholdKey, Math.round(newValue));
-    } else {
-      this.revertThresholdUpdate(type);
-    }
-  };
+  handleChangeThreshold = (type: AlertRuleThreshold, value: ThresholdControlValue) => {
+    const {onChange, trigger} = this.props;
 
-  handleChangeIncidentThresholdInput = debounce((value: number) => {
-    this.updateThresholdInput(AlertRuleThreshold.INCIDENT, value);
-  }, 50);
-
-  handleChangeIncidentThreshold = (value: number) => {
-    this.updateThreshold(AlertRuleThreshold.INCIDENT, value);
-  };
+    const thresholdKey = this.getThresholdKey(type);
+    const newValue =
+      value.threshold === '' ? value.threshold : Math.round(value.threshold);
 
-  handleChangeResolutionThresholdInput = debounce((value: number) => {
-    this.updateThresholdInput(AlertRuleThreshold.RESOLUTION, value);
-  }, 50);
+    onChange({
+      ...trigger,
+      [thresholdKey]: newValue,
+      thresholdType: value.thresholdType,
+    });
 
-  handleChangeResolutionThreshold = (value: number) => {
-    this.updateThreshold(AlertRuleThreshold.RESOLUTION, value);
+    if (!this.canUpdateThreshold(type, value.threshold)) {
+      this.revertThresholdUpdate(type);
+    }
   };
 
-  /**
-   * Changes the threshold type (i.e. if thresholds are inverted or not)
-   */
-  handleChangeThresholdType = (value: boolean) => {
-    // Swap values and toggle `state.isInverted`, so they if invert it twice, they get their original values
-    this.setState(state => {
-      const oldValues = {
-        resolve: state.resolveThreshold,
-        alert: state.alertThreshold,
-      };
+  handleChangeLabel = (e: React.ChangeEvent<HTMLInputElement>) => {
+    const {onChange, trigger} = this.props;
 
-      this.context.form.setValue('resolveThreshold', oldValues.alert);
-      this.context.form.setValue('alertThreshold', oldValues.resolve);
-      return {
-        isInverted: value,
-        resolveThreshold: oldValues.alert,
-        alertThreshold: oldValues.resolve,
-      };
-    });
+    onChange({...trigger, label: e.target.value});
   };
 
   render() {
-    const {api, config, organization, projects, rule} = this.props;
-    const {alertThreshold, resolveThreshold, isInverted} = this.state;
+    const {error, trigger} = this.props;
 
     return (
-      <JsonForm
-        renderHeader={() => (
-          <TriggersChart
-            api={api}
-            config={config}
-            organization={organization}
-            projects={projects}
-            isInverted={isInverted}
-            alertThreshold={alertThreshold}
-            resolveThreshold={resolveThreshold}
-            query={rule.query}
-            aggregations={rule.aggregations}
-            timeWindow={rule.timeWindow}
-            onChangeIncidentThreshold={this.handleChangeIncidentThreshold}
-            onChangeResolutionThreshold={this.handleChangeResolutionThreshold}
+      <React.Fragment>
+        <Field
+          label={t('Label')}
+          help={t('This will prefix alerts created by this trigger')}
+          required
+          error={error && error.label}
+        >
+          <Input
+            name="label"
+            placeholder={t('SEV-0')}
+            value={trigger.label}
+            required
+            onChange={this.handleChangeLabel}
           />
-        )}
-        fields={[
-          {
-            name: 'label',
-            type: 'text',
-            label: t('Label'),
-            help: t('This will prefix alerts created by this trigger'),
-            placeholder: t('SEV-0'),
-            required: true,
-          },
-          {
-            name: 'alertThreshold',
-            type: 'range',
-            label: t('Incident Boundary'),
-            help: !isInverted
-              ? t('Anything trending above this limit will trigger an Incident')
-              : t('Anything trending below this limit will trigger an Incident'),
-            onChange: this.handleChangeIncidentThresholdInput,
-            showCustomInput: true,
-            required: true,
-            min: 1,
-          },
-          {
-            name: 'resolveThreshold',
-            type: 'range',
-            label: t('Resolution Boundary'),
-            help: !isInverted
-              ? t('Anything trending below this limit will resolve an Incident')
-              : t('Anything trending above this limit will resolve an Incident'),
-            onChange: this.handleChangeResolutionThresholdInput,
-            showCustomInput: true,
-            placeholder: resolveThreshold === null ? t('Off') : '',
-            min: 1,
-          },
-          {
-            name: 'thresholdType',
-            type: 'boolean',
-            label: t('Reverse the Boundaries'),
-            defaultValue: AlertRuleThresholdType.ABOVE,
-            help: t('This is a metric that needs to stay above a certain threshold'),
-            onChange: this.handleChangeThresholdType,
-          },
-        ]}
-      />
+        </Field>
+        <Field
+          label={t('Trigger Threshold')}
+          help={t('The threshold that will trigger the associated action(s)')}
+          required
+          error={error && error.alertThreshold}
+        >
+          <ThresholdControl
+            type={AlertRuleThreshold.INCIDENT}
+            thresholdType={trigger.thresholdType}
+            threshold={trigger.alertThreshold}
+            onChange={this.handleChangeThreshold}
+          />
+        </Field>
+
+        <Field
+          label={t('Resolution Threshold')}
+          help={t('The threshold that will resolve an alert')}
+          error={error && error.resolutionThreshold}
+        >
+          <ThresholdControl
+            type={AlertRuleThreshold.RESOLUTION}
+            thresholdType={trigger.thresholdType}
+            threshold={trigger.resolveThreshold}
+            onChange={this.handleChangeThreshold}
+          />
+        </Field>
+      </React.Fragment>
     );
   }
 }
 
-type TriggerFormContainerProps = {
+type TriggerFormContainerProps = Omit<
+  React.ComponentProps<typeof TriggerForm>,
+  'onChange'
+> & {
+  api: Client;
+  availableActions: MetricAction[] | null;
   organization: Organization;
-  rule: IncidentRule;
+  currentProject: string;
   projects: Project[];
-  trigger?: Trigger;
-  onSave: (trigger: UnsavedTrigger) => void;
-} & React.ComponentProps<typeof TriggerForm>;
-
-type TriggerFormContainerState = {
-  actions: Action[];
+  trigger: Trigger;
+  onChange: (triggerIndex: number, trigger: Trigger) => void;
 };
 
-class TriggerFormContainer extends AsyncComponent<
-  TriggerFormContainerProps & AsyncComponent['props'],
-  TriggerFormContainerState & AsyncComponent['state']
-> {
-  getDefaultState() {
-    return {
-      ...super.getDefaultState(),
-      actions: [],
-    };
-  }
-
+class TriggerFormContainer extends React.Component<TriggerFormContainerProps> {
   componentDidMount() {
-    const {organization} = this.props;
-
-    fetchOrgMembers(this.api, organization.slug);
-  }
+    const {api, organization} = this.props;
 
-  getEndpoints(): [string, string][] {
-    const {organization, rule, trigger} = this.props;
-
-    if (!trigger || !trigger.id) {
-      return [];
-    }
-
-    return [
-      [
-        'actions',
-        `/organizations/${organization.slug}/alert-rules/${rule.id}/triggers/${
-          trigger.id
-        }/actions/`,
-      ],
-    ];
+    fetchOrgMembers(api, organization.slug);
   }
 
-  handleAddAction = (value: Action['type']) => {
-    this.setState(state => ({
-      ...state,
-      actions: [
-        ...state.actions,
-        {
-          type: value,
-          targetType: TargetType.USER,
-          targetIdentifier: null,
-        },
-      ],
-    }));
+  handleChangeTrigger = (trigger: Trigger) => {
+    const {onChange, triggerIndex} = this.props;
+    onChange(triggerIndex, trigger);
   };
 
-  handleChangeAction = (index: number, action: Action): void => {
-    const {api, organization, rule, trigger} = this.props;
-    this.setState(state => {
-      addOrUpdateAction(api, organization.slug, rule, action, trigger);
-
-      return {
-        actions: replaceAtArrayIndex(state.actions, index, action),
-      };
-    });
+  handleAddAction = (value: Action['type']) => {
+    const {onChange, trigger, triggerIndex} = this.props;
+    const actions = [
+      ...trigger.actions,
+      {
+        type: value,
+        targetType: TargetType.USER,
+        targetIdentifier: null,
+      },
+    ];
+    onChange(triggerIndex, {...trigger, actions});
   };
 
-  handleSubmit = (data, _onSuccess, _onError, _e, model: FormModel) => {
-    if (!model.validateForm()) {
-      return;
-    }
-
-    this.props.onSave(data as Trigger);
+  handleChangeActions = (actions: Action[]): void => {
+    const {onChange, trigger, triggerIndex} = this.props;
+    onChange(triggerIndex, {...trigger, actions});
   };
 
-  renderLoading() {
-    return this.renderBody();
-  }
-
-  renderBody() {
-    const {organization, rule, trigger, projects, ...props} = this.props;
+  render() {
+    const {
+      api,
+      availableActions,
+      config,
+      currentProject,
+      error,
+      organization,
+      trigger,
+      triggerIndex,
+      projects,
+    } = this.props;
 
     return (
-      <Form
-        apiMethod={trigger ? 'PUT' : 'POST'}
-        apiEndpoint={`/organizations/${organization.slug}/alert-rules/${
-          rule.id
-        }/triggers/${trigger ? `${trigger.id}/` : ''}`}
-        initialData={{
-          thresholdType: AlertRuleThresholdType.ABOVE,
-          ...trigger,
-        }}
-        saveOnBlur={false}
-        onSubmit={this.handleSubmit}
-        submitLabel={trigger ? t('Update Trigger') : t('Create Trigger')}
-      >
+      <React.Fragment>
         <TriggerForm
-          rule={rule}
+          api={api}
+          config={config}
+          error={error}
           trigger={trigger}
           organization={organization}
           projects={projects}
-          {...props}
+          triggerIndex={triggerIndex}
+          onChange={this.handleChangeTrigger}
         />
         <ActionsPanel
-          loading={this.state.loading}
-          error={this.state.error}
+          loading={availableActions === null}
+          error={false}
+          availableActions={availableActions}
+          currentProject={currentProject}
           organization={organization}
           projects={projects}
-          rule={rule}
-          trigger={trigger}
-          actions={this.state.actions}
-          onChange={this.handleChangeAction}
+          triggerIndex={triggerIndex}
+          actions={trigger.actions}
+          onChange={this.handleChangeActions}
           onAdd={this.handleAddAction}
         />
-      </Form>
+      </React.Fragment>
     );
   }
 }
 
 export default withConfig(withApi(TriggerFormContainer));
-
-function addOrUpdateAction(
-  api: Client,
-  orgId: string,
-  rule: IncidentRule,
-  action: Action,
-  trigger?: Trigger
-): Promise<any> {
-  // Don't do anything if we are not editing
-  if (!trigger) {
-    return Promise.resolve(null);
-  }
-
-  if (!action.targetIdentifier || typeof action.targetType === 'undefined') {
-    return Promise.resolve(null);
-  }
-
-  const method = action.id ? 'PUT' : 'POST';
-
-  return api.requestPromise(
-    `/organizations/${orgId}/alert-rules/${rule.id}/triggers/${trigger.id}/actions/${
-      action.id ? `${action.id}/` : ''
-    }`,
-    {
-      method,
-      data: action,
-    }
-  );
-}
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/index.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/index.tsx
index 7828e90b5e..049d395383 100644
--- a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/index.tsx
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/index.tsx
@@ -1,92 +1,129 @@
 import React from 'react';
-import styled, {css} from 'react-emotion';
+import styled from 'react-emotion';
 
-import {IncidentRule, Trigger} from 'app/views/settings/incidentRules/types';
+import {Trigger} from 'app/views/settings/incidentRules/types';
 import {Organization, Project} from 'app/types';
-import {openModal} from 'app/actionCreators/modal';
+import {Panel, PanelBody, PanelHeader} from 'app/components/panels';
+import {removeAtArrayIndex} from 'app/utils/removeAtArrayIndex';
+import {replaceAtArrayIndex} from 'app/utils/replaceAtArrayIndex';
 import {t} from 'app/locale';
 import Button from 'app/components/button';
-import SettingsPageHeader from 'app/views/settings/components/settingsPageHeader';
-import TriggersList from 'app/views/settings/incidentRules/triggers/list';
-import TriggersModal from 'app/views/settings/incidentRules/triggers/modal';
+import TriggerForm from 'app/views/settings/incidentRules/triggers/form';
 import withProjects from 'app/utils/withProjects';
+import {MetricAction} from 'app/types/alerts';
+
+type DeleteButtonProps = {
+  triggerIndex: number;
+  onDelete: (triggerIndex: number, e: React.MouseEvent<Element>) => void;
+};
+
+/**
+ * Button to delete a trigger
+ */
+const DeleteButton: React.FC<DeleteButtonProps> = ({
+  triggerIndex,
+  onDelete,
+}: DeleteButtonProps) => (
+  <Button
+    type="button"
+    icon="icon-trash"
+    size="xsmall"
+    aria-label={t('Delete Trigger')}
+    onClick={(e: React.MouseEvent<Element>) => onDelete(triggerIndex, e)}
+  >
+    {t('Delete')}
+  </Button>
+);
 
 type Props = {
   organization: Organization;
   projects: Project[];
   incidentRuleId?: string;
-  rule: IncidentRule;
+  triggers: Trigger[];
+  currentProject: string;
+  availableActions: MetricAction[] | null;
 
-  onAdd: (trigger: Trigger) => void;
-  onEdit: (trigger: Trigger) => void;
-  onDelete: (trigger: Trigger) => void;
+  errors: Map<number, {[fieldName: string]: string}>;
+
+  onAdd: () => void;
+  onChange: (triggers: Trigger[]) => void;
 };
 
+/**
+ * A list of forms to add, edit, and delete triggers.
+ */
 class Triggers extends React.Component<Props> {
-  openTriggersModal = (trigger?: Trigger) => {
-    const {organization, projects, rule, onAdd, onEdit} = this.props;
-
-    openModal(
-      ({closeModal}) => (
-        <TriggersModal
-          organization={organization}
-          projects={projects}
-          rule={rule}
-          trigger={trigger}
-          closeModal={closeModal}
-          onSave={trigger ? onEdit : onAdd}
-        />
-      ),
-      {
-        dialogClassName: css`
-          width: 80%;
-          margin-left: -40%;
-        `,
-      }
-    );
-  };
+  handleDeleteTrigger = (index: number) => {
+    const {triggers, onChange} = this.props;
+    const updatedTriggers = removeAtArrayIndex(triggers, index);
 
-  handleNewTrigger = () => {
-    this.openTriggersModal();
+    onChange(updatedTriggers);
   };
 
-  handleEditTrigger = (trigger: Trigger) => {
-    this.openTriggersModal(trigger);
+  handleChangeTrigger = (triggerIndex: number, trigger: Trigger) => {
+    const {triggers, onChange} = this.props;
+    const updatedTriggers = replaceAtArrayIndex(triggers, triggerIndex, trigger);
+
+    onChange(updatedTriggers);
   };
 
   render() {
-    const {rule, onDelete} = this.props;
+    const {
+      availableActions,
+      currentProject,
+      errors,
+      organization,
+      projects,
+      triggers,
+      onAdd,
+    } = this.props;
 
     return (
       <React.Fragment>
-        <TriggersHeader
-          title={t('Triggers')}
-          action={
-            <Button
-              type="button"
-              size="small"
-              priority="primary"
-              icon="icon-circle-add"
-              disabled={!rule}
-              onClick={this.handleNewTrigger}
-            >
-              {t('New Trigger')}
-            </Button>
-          }
-        />
-
-        <TriggersList
-          triggers={rule.triggers}
-          onDelete={onDelete}
-          onEdit={this.handleEditTrigger}
-        />
+        {triggers.map((trigger, index) => {
+          return (
+            <Panel key={index}>
+              <PanelHeader hasButtons>
+                {t('Define Trigger')}
+                <DeleteButton triggerIndex={index} onDelete={this.handleDeleteTrigger} />
+              </PanelHeader>
+              <PanelBody>
+                <TriggerForm
+                  error={errors && errors.get(index)}
+                  availableActions={availableActions}
+                  organization={organization}
+                  projects={projects}
+                  currentProject={currentProject}
+                  trigger={trigger}
+                  triggerIndex={index}
+                  onChange={this.handleChangeTrigger}
+                />
+              </PanelBody>
+            </Panel>
+          );
+        })}
+
+        <BorderlessPanel>
+          <FullWidthButton
+            type="button"
+            size="small"
+            icon="icon-circle-add"
+            onClick={onAdd}
+          >
+            {t('Add another Trigger')}
+          </FullWidthButton>
+        </BorderlessPanel>
       </React.Fragment>
     );
   }
 }
 
-export default withProjects(Triggers);
+const BorderlessPanel = styled(Panel)`
+  border: none;
+`;
 
-const TriggersHeader = styled(SettingsPageHeader)`
-  margin: 0;
+const FullWidthButton = styled(Button)`
+  width: 100%;
 `;
+
+export default withProjects(Triggers);
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/list.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/list.tsx
deleted file mode 100644
index e68411610f..0000000000
--- a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/list.tsx
+++ /dev/null
@@ -1,129 +0,0 @@
-import React from 'react';
-import styled, {css} from 'react-emotion';
-
-import {Panel, PanelBody, PanelItem, PanelHeader} from 'app/components/panels';
-import {t} from 'app/locale';
-import Button from 'app/components/button';
-import Confirm from 'app/components/confirm';
-import EmptyMessage from 'app/views/settings/components/emptyMessage';
-import space from 'app/styles/space';
-
-import {Trigger} from '../types';
-import getTriggerConditionDisplayName from '../utils/getTriggerConditionDisplayName';
-
-type Props = {
-  triggers: Trigger[];
-  onDelete: (trigger: Trigger) => void;
-  onEdit: (trigger: Trigger) => void;
-};
-
-export default class TriggersList extends React.Component<Props> {
-  handleEdit = (trigger: Trigger) => {
-    this.props.onEdit(trigger);
-  };
-
-  handleDelete = (trigger: Trigger) => {
-    this.props.onDelete(trigger);
-  };
-
-  render() {
-    const {triggers} = this.props;
-
-    const isEmpty = triggers && !triggers.length;
-
-    return (
-      <Panel>
-        <PanelHeaderGrid>
-          <div>{t('Label')}</div>
-          <div>{t('Condition')}</div>
-          <div>{t('Actions')}</div>
-        </PanelHeaderGrid>
-        <PanelBody>
-          {isEmpty && <EmptyMessage>{t('No triggers added')}</EmptyMessage>}
-          {triggers.map((trigger, index) => {
-            const [mainCondition, secondaryCondition] = getTriggerConditionDisplayName(
-              trigger
-            );
-
-            return (
-              <Grid key={trigger.id || `new-${index}`}>
-                <Label>{trigger.label}</Label>
-                <Condition>
-                  <MainCondition>{mainCondition}</MainCondition>
-                  {secondaryCondition !== null && (
-                    <SecondaryCondition>{secondaryCondition}</SecondaryCondition>
-                  )}
-                </Condition>
-                <Actions>
-                  N/A
-                  <ButtonBar>
-                    <Button
-                      type="button"
-                      priority="default"
-                      icon="icon-edit"
-                      size="small"
-                      onClick={() => this.handleEdit(trigger)}
-                    >
-                      {t('Edit')}
-                    </Button>
-                    <Confirm
-                      onConfirm={() => this.handleDelete(trigger)}
-                      message={t('Are you sure you want to delete this trigger?')}
-                      priority="danger"
-                    >
-                      <Button
-                        priority="default"
-                        size="small"
-                        aria-label={t('Delete Trigger')}
-                        icon="icon-trash"
-                      />
-                    </Confirm>
-                  </ButtonBar>
-                </Actions>
-              </Grid>
-            );
-          })}
-        </PanelBody>
-      </Panel>
-    );
-  }
-}
-
-const gridCss = css`
-  display: grid;
-  grid-template-columns: 1fr 2fr 3fr;
-  grid-gap: ${space(1)};
-  align-items: center;
-`;
-
-const PanelHeaderGrid = styled(PanelHeader)`
-  ${gridCss};
-`;
-
-const Grid = styled(PanelItem)`
-  ${gridCss};
-`;
-
-const Label = styled('div')`
-  font-size: 1.2em;
-`;
-
-const Condition = styled('div')``;
-
-const MainCondition = styled('div')``;
-const SecondaryCondition = styled('div')`
-  font-size: ${p => p.theme.fontSizeSmall};
-  color: ${p => p.theme.gray2};
-`;
-
-const Actions = styled('div')`
-  display: flex;
-  justify-content: space-between;
-  align-items: center;
-`;
-
-const ButtonBar = styled('div')`
-  display: grid;
-  grid-gap: ${space(1)};
-  grid-auto-flow: column;
-`;
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/modal.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/modal.tsx
deleted file mode 100644
index cdd0657042..0000000000
--- a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/modal.tsx
+++ /dev/null
@@ -1,64 +0,0 @@
-import React from 'react';
-import styled from 'react-emotion';
-
-import {
-  IncidentRule,
-  UnsavedTrigger,
-  Trigger,
-} from 'app/views/settings/incidentRules/types';
-import {Organization, Project} from 'app/types';
-import {t} from 'app/locale';
-import TriggerForm from 'app/views/settings/incidentRules/triggers/form';
-import space from 'app/styles/space';
-
-type Props = {
-  organization: Organization;
-  projects: Project[];
-  rule: IncidentRule;
-  closeModal: Function;
-  trigger?: Trigger;
-  onSave: (trigger: UnsavedTrigger) => void;
-};
-
-class TriggersModal extends React.Component<Props> {
-  handleSave = (newTrigger: Trigger) => {
-    const {onSave, closeModal} = this.props;
-
-    onSave(newTrigger);
-    closeModal();
-  };
-
-  render() {
-    const {organization, projects, rule, trigger} = this.props;
-
-    return (
-      <div>
-        <TinyHeader>{t('Trigger for')}</TinyHeader>
-        <RuleName>{rule.name}</RuleName>
-        <TriggerForm
-          organization={organization}
-          onSave={this.handleSave}
-          projects={projects}
-          rule={rule}
-          trigger={trigger}
-        />
-      </div>
-    );
-  }
-}
-
-export default TriggersModal;
-
-const TinyHeader = styled('h6')`
-  color: ${p => p.theme.gray2};
-  text-transform: uppercase;
-  margin-bottom: ${space(1)};
-
-  &::after {
-    content: ':';
-  }
-`;
-
-const RuleName = styled('h3')`
-  font-weight: normal;
-`;
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/panelSubHeader.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/panelSubHeader.tsx
new file mode 100644
index 0000000000..3e1f3bc31d
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/panelSubHeader.tsx
@@ -0,0 +1,17 @@
+import styled from 'react-emotion';
+
+import {PanelHeader} from 'app/components/panels';
+import space from 'app/styles/space';
+
+/**
+ * Displays a Panel Header that has less vertical padding as to not draw as much attention but still
+ * provide some logical separation
+ */
+const PanelSubHeader = styled(PanelHeader)`
+  display: flex;
+  justify-content: flex-start;
+  align-items: center;
+  padding: ${space(1)} ${space(2)};
+`;
+
+export default PanelSubHeader;
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/thresholdControl.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/thresholdControl.tsx
new file mode 100644
index 0000000000..df8c2c6f89
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/triggers/thresholdControl.tsx
@@ -0,0 +1,81 @@
+import React from 'react';
+import styled from 'react-emotion';
+
+import {
+  ThresholdControlValue,
+  AlertRuleThreshold,
+  AlertRuleThresholdType,
+} from 'app/views/settings/incidentRules/types';
+import {t} from 'app/locale';
+import Input from 'app/views/settings/components/forms/controls/input';
+import SelectControl from 'app/components/forms/selectControl';
+import space from 'app/styles/space';
+
+type Props = ThresholdControlValue & {
+  type: AlertRuleThreshold;
+  onChange: (
+    type: AlertRuleThreshold,
+    value: ThresholdControlValue,
+    e: React.FormEvent
+  ) => void;
+};
+
+function ThresholdControl({thresholdType, threshold, type, onChange, ...props}: Props) {
+  const onChangeThresholdType = ({value}, e) => {
+    onChange(
+      type,
+      {thresholdType: getThresholdTypeForThreshold(type, value), threshold},
+      e
+    );
+  };
+
+  const onChangeThreshold = (e: React.ChangeEvent<HTMLInputElement>) => {
+    const thresholdAsInt = parseInt(e.target.value, 10);
+
+    onChange(
+      type,
+      {thresholdType, threshold: isNaN(thresholdAsInt) ? '' : thresholdAsInt},
+      e
+    );
+  };
+
+  const thresholdName = AlertRuleThreshold.INCIDENT === type ? 'alert' : 'resolution';
+
+  return (
+    <div {...props}>
+      <SelectControl
+        name={`${thresholdName}ThresholdType`}
+        value={getThresholdTypeForThreshold(type, thresholdType)}
+        options={[
+          {value: AlertRuleThresholdType.BELOW, label: t('Below')},
+          {value: AlertRuleThresholdType.ABOVE, label: t('Above')},
+        ]}
+        onChange={onChangeThresholdType}
+      />
+      <Input
+        name={`${thresholdName}ThresholdInput`}
+        type="number"
+        placeholder="300"
+        value={threshold}
+        onChange={onChangeThreshold}
+      />
+    </div>
+  );
+}
+
+export default styled(ThresholdControl)`
+  display: grid;
+  align-items: center;
+  grid-template-columns: 1fr 3fr;
+  grid-gap: ${space(1)};
+`;
+
+function getThresholdTypeForThreshold(
+  type: AlertRuleThreshold,
+  thresholdType: AlertRuleThresholdType
+): AlertRuleThresholdType {
+  return (type === AlertRuleThreshold.INCIDENT) !==
+    (thresholdType === AlertRuleThresholdType.ABOVE)
+    ? AlertRuleThresholdType.BELOW
+    : AlertRuleThresholdType.ABOVE;
+}
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/types.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/types.tsx
index 4275396bdc..5bfac6e8e1 100644
--- a/src/sentry/static/sentry/app/views/settings/incidentRules/types.tsx
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/types.tsx
@@ -14,15 +14,20 @@ export enum AlertRuleAggregations {
 }
 
 export type UnsavedTrigger = {
-  alertRuleId: string;
+  // UnsavedTrigger can be apart of an Unsaved Alert Rule that does not have an id yet
+  alertRuleId?: string;
   label: string;
   thresholdType: AlertRuleThresholdType;
   alertThreshold: number;
-  resolveThreshold: number;
-  timeWindow: number;
+  resolveThreshold: number | '';
   actions: Action[];
 };
 
+export type ThresholdControlValue = {
+  thresholdType: AlertRuleThresholdType;
+  threshold: number | '';
+};
+
 export type SavedTrigger = UnsavedTrigger & {
   id: string;
   dateAdded: string;
@@ -66,20 +71,20 @@ export type ProjectSelectOption = {
 };
 
 export enum ActionType {
-  EMAIL = 0,
-  SLACK = 1,
-  PAGER_DUTY = 2,
+  EMAIL = 'email',
+  SLACK = 'slack',
+  PAGER_DUTY = 'pagerduty',
 }
 
 export enum TargetType {
   // The name can be customized for each integration. Email for email, channel for slack, service for Pagerduty). We probably won't support this for email at first, since we need to be careful not to enable spam
-  SPECIFIC = 0,
+  SPECIFIC = 'specific',
 
   // Just works with email for now, grabs given user's email address
-  USER = 1,
+  USER = 'user',
 
   // Just works with email for now, grabs the emails for all team members
-  TEAM = 2,
+  TEAM = 'team',
 }
 
 export type Action = {
diff --git a/src/sentry/static/sentry/app/views/settings/projectAlerts/issueEditor/index.tsx b/src/sentry/static/sentry/app/views/settings/projectAlerts/issueEditor/index.tsx
index 707b4b258f..d27ecabb07 100644
--- a/src/sentry/static/sentry/app/views/settings/projectAlerts/issueEditor/index.tsx
+++ b/src/sentry/static/sentry/app/views/settings/projectAlerts/issueEditor/index.tsx
@@ -24,6 +24,7 @@ import Form from 'app/views/settings/components/forms/form';
 import LoadingMask from 'app/components/loadingMask';
 import PanelAlert from 'app/components/panels/panelAlert';
 import PanelItem from 'app/components/panels/panelItem';
+import PanelSubHeader from 'app/views/settings/incidentRules/triggers/panelSubHeader';
 import SelectField from 'app/views/settings/components/forms/selectField';
 import SentryDocumentTitle from 'app/components/sentryDocumentTitle';
 import TextField from 'app/views/settings/components/forms/textField';
@@ -376,13 +377,6 @@ const StyledForm = styled(Form)`
   position: relative;
 `;
 
-const PanelSubHeader = styled(PanelHeader)`
-  display: flex;
-  justify-content: flex-start;
-  align-items: center;
-  padding: ${space(1)} ${space(2)};
-`;
-
 const PanelRuleItem = styled(PanelItem)`
   flex-direction: column;
 `;
diff --git a/tests/js/sentry-test/fixtures/incidentRule.js b/tests/js/sentry-test/fixtures/incidentRule.js
index 6fcf5f8774..f8dc1ae2d9 100644
--- a/tests/js/sentry-test/fixtures/incidentRule.js
+++ b/tests/js/sentry-test/fixtures/incidentRule.js
@@ -4,18 +4,13 @@ export function IncidentRule(params) {
   return {
     status: 0,
     dateAdded: '2019-07-31T23:02:02.731Z',
-    alertThreshold: 24,
     dataset: 'events',
-    thresholdType: 0,
     query: '',
     id: '4',
-    thresholdPeriod: 1,
     name: 'My Incident Rule',
     timeWindow: 60,
     aggregations: [0],
-    resolveThreshold: 13,
     projects: ['project-slug'],
-    resolution: 1,
     dateModified: '2019-07-31T23:02:02.731Z',
     triggers: [IncidentTrigger()],
     ...params,
diff --git a/tests/js/sentry-test/fixtures/incidentTrigger.js b/tests/js/sentry-test/fixtures/incidentTrigger.js
index 1157284835..8caeef2254 100644
--- a/tests/js/sentry-test/fixtures/incidentTrigger.js
+++ b/tests/js/sentry-test/fixtures/incidentTrigger.js
@@ -7,6 +7,7 @@ export function IncidentTrigger(params) {
     label: 'Trigger',
     resolveThreshold: 36,
     thresholdType: 0,
+    actions: [],
     ...params,
   };
 }
diff --git a/tests/js/sentry-test/select.js b/tests/js/sentry-test/select.js
index 0f1d28a462..bf48067e8d 100644
--- a/tests/js/sentry-test/select.js
+++ b/tests/js/sentry-test/select.js
@@ -11,8 +11,14 @@ export function getSelector(options = {}) {
 
 export function openMenu(wrapper, options = {}) {
   const selector = getSelector(options);
-  wrapper.find(`${selector} input[role="combobox"]`).simulate('focus');
-  wrapper.find(`${selector} .Select-control`).simulate('mouseDown', {button: 0});
+  wrapper
+    .find(`${selector} input[role="combobox"]`)
+    .at(options.at || 0)
+    .simulate('focus');
+  wrapper
+    .find(`${selector} .Select-control`)
+    .at(options.at || 0)
+    .simulate('mouseDown', {button: 0});
 
   return wrapper;
 }
@@ -34,10 +40,14 @@ export function findOption(wrapper, {value, label} = {}, options) {
 
 export function selectByLabel(wrapper, label, options = {}) {
   openMenu(wrapper, options);
-  findOption(wrapper, {label}, options).simulate('mouseDown');
+  findOption(wrapper, {label}, options)
+    .at(options.at || 0)
+    .simulate('mouseDown');
 }
 
 export function selectByValue(wrapper, value, options = {}) {
   openMenu(wrapper, options);
-  findOption(wrapper, {value}, options).simulate('mouseDown');
+  findOption(wrapper, {value}, options)
+    .at(options.at || 0)
+    .simulate('mouseDown');
 }
diff --git a/tests/js/spec/views/settings/incidentRules/create.spec.jsx b/tests/js/spec/views/settings/incidentRules/create.spec.jsx
index 31ba3b2c67..376de33729 100644
--- a/tests/js/spec/views/settings/incidentRules/create.spec.jsx
+++ b/tests/js/spec/views/settings/incidentRules/create.spec.jsx
@@ -11,6 +11,25 @@ describe('Incident Rules Create', function() {
       url: '/organizations/org-slug/tags/',
       body: [],
     });
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/users/',
+      body: [],
+    });
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/events-stats/',
+      body: TestStubs.EventsStats(),
+    });
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/alert-rules/available-actions/',
+      body: [
+        {
+          allowedTargetTypes: ['user', 'team'],
+          integrationName: null,
+          type: 'email',
+          integrationId: null,
+        },
+      ],
+    });
   });
 
   it('renders', function() {
diff --git a/tests/js/spec/views/settings/incidentRules/details.spec.jsx b/tests/js/spec/views/settings/incidentRules/details.spec.jsx
index 192fc2e30e..61d1669a41 100644
--- a/tests/js/spec/views/settings/incidentRules/details.spec.jsx
+++ b/tests/js/spec/views/settings/incidentRules/details.spec.jsx
@@ -1,9 +1,10 @@
 import React from 'react';
-import {mountWithTheme} from 'sentry-test/enzyme';
 
 import {initializeOrg} from 'sentry-test/initializeOrg';
-import IncidentRulesDetails from 'app/views/settings/incidentRules/details';
+import {mountWithTheme} from 'sentry-test/enzyme';
+import {selectByValue} from 'sentry-test/select';
 import GlobalModal from 'app/components/globalModal';
+import IncidentRulesDetails from 'app/views/settings/incidentRules/details';
 
 describe('Incident Rules Details', function() {
   beforeAll(function() {
@@ -19,6 +20,17 @@ describe('Incident Rules Details', function() {
       url: '/organizations/org-slug/events-stats/',
       body: null,
     });
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/alert-rules/available-actions/',
+      body: [
+        {
+          allowedTargetTypes: ['user', 'team'],
+          integrationName: null,
+          type: 'email',
+          integrationId: null,
+        },
+      ],
+    });
   });
 
   it('renders and adds and edits trigger', async function() {
@@ -29,29 +41,41 @@ describe('Incident Rules Details', function() {
       body: rule,
     });
 
-    // TODO: Implement creating/saving triggers
-    // const createTrigger = MockApiClient.addMockResponse({
-    // url: `/organizations/${organization.slug}/alert-rules/${rule.id}/triggers/`,
-    // method: 'POST',
-    // body: (_, options) =>
-    // TestStubs.IncidentTrigger({
-    // ...options.data,
-    // id: '123',
-    // }),
-    // });
-    // const updateTrigger = MockApiClient.addMockResponse({
-    // url: `/organizations/${organization.slug}/alert-rules/${rule.id}/triggers/123/`,
-    // method: 'PUT',
-    // body: (_, options) =>
-    // TestStubs.IncidentTrigger({
-    // ...options.data,
-    // }),
-    // });
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/members/',
+      body: [TestStubs.Member()],
+    });
+
+    const editRule = MockApiClient.addMockResponse({
+      url: `/organizations/${organization.slug}/alert-rules/${rule.id}/`,
+      method: 'PUT',
+      body: rule,
+    });
+
+    const editTrigger = MockApiClient.addMockResponse({
+      url: `/organizations/${organization.slug}/alert-rules/${rule.id}/triggers/1/`,
+      method: 'PUT',
+      body: TestStubs.IncidentTrigger(),
+    });
+
+    const createTrigger = MockApiClient.addMockResponse({
+      url: `/organizations/${organization.slug}/alert-rules/${rule.id}/triggers/`,
+      method: 'POST',
+      body: TestStubs.IncidentTrigger({id: 2}),
+    });
 
     MockApiClient.addMockResponse({
       url: `/organizations/${organization.slug}/alert-rules/${
         rule.id
-      }/triggers/123/actions/`,
+      }/triggers/1/actions/`,
+      body: [],
+    });
+
+    const addAction = MockApiClient.addMockResponse({
+      url: `/organizations/${organization.slug}/alert-rules/${
+        rule.id
+      }/triggers/1/actions/`,
+      method: 'POST',
       body: [],
     });
 
@@ -68,153 +92,177 @@ describe('Incident Rules Details', function() {
       </React.Fragment>,
       routerContext
     );
+
+    await tick();
     wrapper.update();
 
+    // has existing trigger
+    expect(
+      wrapper
+        .find('input[name="label"]')
+        .first()
+        .prop('value')
+    ).toEqual('Trigger');
+    expect(
+      wrapper
+        .find('input[name="alertThresholdInput"]')
+        .first()
+        .prop('value')
+    ).toEqual(70);
+    expect(
+      wrapper
+        .find('input[name="resolutionThresholdInput"]')
+        .first()
+        .prop('value')
+    ).toEqual(36);
+
     expect(req).toHaveBeenCalled();
-    expect(wrapper.find('TriggersList Label').text()).toBe('Trigger');
 
     // Create a new Trigger
-    wrapper.find('button[aria-label="New Trigger"]').simulate('click');
-    await tick(); // tick opening a modal
-    wrapper.update();
+    wrapper.find('button[aria-label="Add another Trigger"]').simulate('click');
 
     wrapper
-      .find('TriggersModal input[name="label"]')
+      .find('input[name="label"]')
+      .at(1)
       .simulate('change', {target: {value: 'New Trigger'}});
     wrapper
-      .find('TriggersModal input[name="alertThreshold"]')
-      .simulate('input', {target: {value: 13}});
+      .find('input[name="alertThresholdInput"]')
+      .at(1)
+      .simulate('change', {target: {value: 13}});
     wrapper
-      .find('TriggersModal input[name="resolveThreshold"]')
-      .simulate('input', {target: {value: 12}});
+      .find('input[name="resolutionThresholdInput"]')
+      .at(1)
+      .simulate('change', {target: {value: 12}});
+
+    // Add an action
+    selectByValue(wrapper, 'email', {
+      control: true,
+      name: 'add-action',
+    });
 
     // Save Trigger
-    wrapper.find('TriggersModal button[aria-label="Create Trigger"]').simulate('submit');
+    wrapper.find('button[aria-label="Save Changes"]').simulate('submit');
+
+    expect(editRule).toHaveBeenCalledWith(
+      expect.anything(),
+      expect.objectContaining({
+        data: expect.objectContaining({
+          aggregations: [0],
+          dataset: 'events',
+          id: '4',
+          name: 'My Incident Rule',
+          projects: ['project-slug'],
+          query: '',
+          status: 0,
+          timeWindow: 60,
+          triggers: [
+            expect.objectContaining({
+              actions: [
+                {
+                  targetIdentifier: null,
+                  targetType: 'user',
+                  type: 'email',
+                },
+              ],
+              alertRuleId: '4',
+              alertThreshold: 70,
+              id: '1',
+              label: 'Trigger',
+              resolveThreshold: 36,
+              thresholdType: 0,
+            }),
+            {
+              actions: [],
+              alertThreshold: 13,
+              label: 'New Trigger',
+              resolveThreshold: 12,
+              thresholdType: 0,
+            },
+          ],
+        }),
+        method: 'PUT',
+      })
+    );
 
     // New Trigger should be in list
     await tick();
-    await tick(); // tick#2 - flakiness
     wrapper.update();
-    expect(
-      wrapper
-        .find('TriggersList Label')
-        .last()
-        .text()
-    ).toBe('New Trigger');
-    expect(wrapper.find('TriggersModal')).toHaveLength(0);
 
-    // Edit new trigger
-    wrapper
-      .find('button[aria-label="Edit"]')
-      .last()
-      .simulate('click');
-    await tick(); // tick opening a modal
-    wrapper.update();
+    // TODO(incidents): This should be removed when we consolidate API
+    expect(editTrigger).toHaveBeenCalled();
+    // TODO(incidents): This should be removed when we consolidate API
+    expect(createTrigger).toHaveBeenCalled();
+    // TODO(incidents): This should be removed when we consolidate API
+    expect(addAction).toHaveBeenCalled();
 
     // Has correct values
-
-    expect(wrapper.find('TriggersModal input[name="label"]').prop('value')).toBe(
-      'New Trigger'
-    );
-    expect(wrapper.find('TriggersModal input[name="alertThreshold"]').prop('value')).toBe(
-      13
-    );
     expect(
-      wrapper.find('TriggersModal input[name="resolveThreshold"]').prop('value')
-    ).toBe(12);
-
-    wrapper
-      .find('TriggersModal input[name="label"]')
-      .simulate('change', {target: {value: 'New Trigger!!'}});
-
-    // Save Trigger
-    wrapper.find('TriggersModal button[aria-label="Update Trigger"]').simulate('submit');
-
-    // New Trigger should be in list
-    await tick();
-    await tick(); // tick#2 - flakiness
-    wrapper.update();
-
+      wrapper
+        .find('input[name="label"]')
+        .at(1)
+        .prop('value')
+    ).toBe('New Trigger');
     expect(
       wrapper
-        .find('TriggersList Label')
-        .last()
-        .text()
-    ).toBe('New Trigger!!');
-    expect(wrapper.find('TriggersModal')).toHaveLength(0);
-
-    // Attempt and fail to delete trigger
-    let deleteTrigger = MockApiClient.addMockResponse({
-      url: `/organizations/${organization.slug}/alert-rules/${rule.id}/triggers/1`,
-      method: 'DELETE',
-      statusCode: 400,
-    });
-    const deleteUndefinedTrigger = MockApiClient.addMockResponse({
-      url: `/organizations/${organization.slug}/alert-rules/${
-        rule.id
-      }/triggers/undefined`,
-      method: 'DELETE',
-    });
+        .find('input[name="alertThresholdInput"]')
+        .at(1)
+        .prop('value')
+    ).toBe(13);
+    expect(
+      wrapper
+        .find('input[name="resolutionThresholdInput"]')
+        .at(1)
+        .prop('value')
+    ).toBe(12);
 
+    // Delete Trigger
     wrapper
-      .find('TriggersList button[aria-label="Delete Trigger"]')
+      .find('button[aria-label="Delete Trigger"]')
       .first()
       .simulate('click');
 
-    wrapper.find('Confirm button[aria-label="Confirm"]').simulate('click');
-
-    await tick();
-    wrapper.update();
-
-    expect(deleteTrigger).toHaveBeenCalled();
+    // Save Trigger
+    wrapper.find('button[aria-label="Save Changes"]').simulate('submit');
+
+    expect(editRule).toHaveBeenCalledWith(
+      expect.anything(),
+      expect.objectContaining({
+        data: expect.objectContaining({
+          aggregations: [0],
+          dataset: 'events',
+          id: '4',
+          name: 'My Incident Rule',
+          projects: ['project-slug'],
+          query: '',
+          status: 0,
+          timeWindow: 60,
+          triggers: [
+            {
+              actions: [],
+              alertThreshold: 13,
+              label: 'New Trigger',
+              resolveThreshold: 12,
+              thresholdType: 0,
+            },
+          ],
+        }),
+        method: 'PUT',
+      })
+    );
 
     expect(
       wrapper
-        .find('TriggersList Label')
+        .find('input[name="label"]')
         .first()
-        .text()
-    ).toBe('Trigger');
-
-    // Remove unsaved trigger from list
-    wrapper
-      .find('TriggersList button[aria-label="Delete Trigger"]')
-      .last()
-      .simulate('click');
-
-    wrapper.find('Confirm button[aria-label="Confirm"]').simulate('click');
-
-    await tick();
-    wrapper.update();
-
-    expect(deleteUndefinedTrigger).not.toHaveBeenCalled();
+        .prop('value')
+    ).toBe('New Trigger');
 
     // The last trigger is now the first trigger
     expect(
       wrapper
-        .find('TriggersList Label')
+        .find('input[name="label"]')
         .last()
-        .text()
-    ).toBe('Trigger');
-
-    // Actually delete saved trigger
-    deleteTrigger = MockApiClient.addMockResponse({
-      url: `/organizations/${organization.slug}/alert-rules/${rule.id}/triggers/1`,
-      method: 'DELETE',
-    });
-
-    wrapper
-      .find('TriggersList button[aria-label="Delete Trigger"]')
-      .last()
-      .simulate('click');
-
-    wrapper.find('Confirm button[aria-label="Confirm"]').simulate('click');
-
-    await tick();
-    wrapper.update();
-
-    expect(deleteTrigger).toHaveBeenCalled();
-
-    // No triggers left
-    expect(wrapper.find('TriggersList Label')).toHaveLength(0);
+        .prop('value')
+    ).toBe('New Trigger');
   });
 });
diff --git a/tests/js/spec/views/settings/incidentRules/ruleForm.spec.jsx b/tests/js/spec/views/settings/incidentRules/ruleForm.spec.jsx
index 5f175903c9..2749dba7d9 100644
--- a/tests/js/spec/views/settings/incidentRules/ruleForm.spec.jsx
+++ b/tests/js/spec/views/settings/incidentRules/ruleForm.spec.jsx
@@ -2,13 +2,18 @@ import {mountWithTheme} from 'sentry-test/enzyme';
 import React from 'react';
 
 import {initializeOrg} from 'sentry-test/initializeOrg';
-import {RuleFormContainer} from 'app/views/settings/incidentRules/ruleForm';
+import RuleFormContainer from 'app/views/settings/incidentRules/ruleForm';
 
 describe('Incident Rules Form', function() {
   const {organization, project, routerContext} = initializeOrg();
   const createWrapper = props =>
     mountWithTheme(
-      <RuleFormContainer organization={organization} project={project} {...props} />,
+      <RuleFormContainer
+        params={{orgId: organization.slug}}
+        organization={organization}
+        project={project}
+        {...props}
+      />,
       routerContext
     );
 
@@ -18,6 +23,25 @@ describe('Incident Rules Form', function() {
       url: '/organizations/org-slug/tags/',
       body: [],
     });
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/users/',
+      body: [],
+    });
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/events-stats/',
+      body: TestStubs.EventsStats(),
+    });
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/alert-rules/available-actions/',
+      body: [
+        {
+          allowedTargetTypes: ['user', 'team'],
+          integrationName: null,
+          type: 'email',
+          integrationId: null,
+        },
+      ],
+    });
   });
 
   describe('Creating a new rule', function() {
@@ -63,6 +87,7 @@ describe('Incident Rules Form', function() {
 
   describe('Editing a rule', function() {
     let editRule;
+    let editTrigger;
     const rule = TestStubs.IncidentRule();
 
     beforeEach(function() {
@@ -71,6 +96,15 @@ describe('Incident Rules Form', function() {
         method: 'PUT',
         body: rule,
       });
+      editTrigger = MockApiClient.addMockResponse({
+        url: `/organizations/org-slug/alert-rules/${rule.id}/triggers/1/`,
+        method: 'PUT',
+        body: TestStubs.IncidentTrigger({id: 1}),
+      });
+    });
+    afterEach(function() {
+      editRule.mockReset();
+      editTrigger.mockReset();
     });
 
     it('edits metric', async function() {
@@ -93,7 +127,6 @@ describe('Incident Rules Form', function() {
           }),
         })
       );
-      editRule.mockReset();
     });
   });
 });
diff --git a/tests/js/spec/views/settings/incidentRules/triggers/modal.spec.jsx b/tests/js/spec/views/settings/incidentRules/triggers/modal.spec.jsx
deleted file mode 100644
index a975dd4481..0000000000
--- a/tests/js/spec/views/settings/incidentRules/triggers/modal.spec.jsx
+++ /dev/null
@@ -1,51 +0,0 @@
-import {mountWithTheme} from 'sentry-test/enzyme';
-import React from 'react';
-
-import {initializeOrg} from 'sentry-test/initializeOrg';
-import TriggersModal from 'app/views/settings/incidentRules/triggers/modal';
-
-describe('Incident Rules -> Triggers Modal', function() {
-  const {organization, project, routerContext} = initializeOrg();
-  const rule = TestStubs.IncidentRule();
-  let statsMock;
-  const createWrapper = props =>
-    mountWithTheme(
-      <TriggersModal
-        organization={organization}
-        projects={[project]}
-        rule={rule}
-        {...props}
-      />,
-      routerContext
-    );
-  beforeEach(function() {
-    MockApiClient.clearMockResponses();
-    MockApiClient.addMockResponse({
-      url: '/organizations/org-slug/users/',
-      body: [],
-    });
-    statsMock = MockApiClient.addMockResponse({
-      url: '/organizations/org-slug/events-stats/',
-    });
-  });
-
-  it('renders chart', async function() {
-    const wrapper = createWrapper();
-    await tick();
-    wrapper.update();
-
-    // API call to render chart
-    expect(statsMock).toHaveBeenCalledWith(
-      expect.anything(),
-      expect.objectContaining({
-        // Only check for project for now
-        query: expect.objectContaining({
-          project: [2],
-        }),
-      })
-    );
-
-    // Chart renders
-    expect(wrapper.find('LineChart')).toHaveLength(1);
-  });
-});

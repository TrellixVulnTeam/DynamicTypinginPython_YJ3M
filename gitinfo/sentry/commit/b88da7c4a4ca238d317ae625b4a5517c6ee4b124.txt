commit b88da7c4a4ca238d317ae625b4a5517c6ee4b124
Author: David Wang <davidw1339@gmail.com>
Date:   Wed Dec 4 17:34:34 2019 -0500

    feat(ui): Lazy Load Global Selection Project Selector (#15792)
    
    While waiting for all projects to load, a limited project selector will be available using the <Projects> utility component to supply a preliminary page of 50 projects. Scrolling down will proactively fetch additional pages of 50 projects. Once a search is conducted, a page of 50 projects will be retrieved based on the search query and scrolling down will fetch additional pages based on that search query. Both of these operations (search and scroll) are debounced by 200 milliseconds (mimicking the async search component debounce time).
    
    All this functionality will be temporary until the list of all projects comes in to replace the <Projects> component as the source of truth for projects within the selector. For most orgs this may happen before a user even has a chance to click on the selector, but larger orgs may interact with this paginated project selector for 10 seconds or more, which is good as it will allow them to select a project without having to wait those 10 seconds staring at a loading indicator.

diff --git a/src/sentry/static/sentry/app/components/dropdownAutoCompleteMenu.jsx b/src/sentry/static/sentry/app/components/dropdownAutoCompleteMenu.jsx
index cd1cf463ca..9994c35974 100644
--- a/src/sentry/static/sentry/app/components/dropdownAutoCompleteMenu.jsx
+++ b/src/sentry/static/sentry/app/components/dropdownAutoCompleteMenu.jsx
@@ -49,10 +49,15 @@ class DropdownAutoCompleteMenu extends React.Component {
     isOpen: PropTypes.bool,
 
     /**
-     * Show loading indicator next to input
+     * Show loading indicator next to input and "Searching..." text in the list
      */
     busy: PropTypes.bool,
 
+    /**
+     * Show loading indicator next to input but don't hide list items
+     */
+    busyItemsStillVisible: PropTypes.bool,
+
     /**
      * Hide's the input when there are no items. Avoid using this when querying
      * results in an async fashion.
@@ -78,6 +83,11 @@ class DropdownAutoCompleteMenu extends React.Component {
      */
     onClose: PropTypes.func,
 
+    /**
+     * Callback for when dropdown menu is being scrolled
+     */
+    onScroll: PropTypes.func,
+
     /**
      * Message to display when there are no items initially
      */
@@ -233,7 +243,7 @@ class DropdownAutoCompleteMenu extends React.Component {
     return Math.min(minHeight, maxHeight);
   };
 
-  renderList = ({items, ...otherProps}) => {
+  renderList = ({items, onScroll, ...otherProps}) => {
     const {virtualizedHeight, virtualizedLabelHeight} = this.props;
 
     // If `virtualizedHeight` is defined, use a virtualized list
@@ -245,6 +255,7 @@ class DropdownAutoCompleteMenu extends React.Component {
               width={width}
               style={{outline: 'none'}}
               height={this.getHeight(items)}
+              onScroll={onScroll}
               rowCount={items.length}
               rowHeight={({index}) => {
                 return items[index].groupLabel && virtualizedLabelHeight
@@ -327,6 +338,8 @@ class DropdownAutoCompleteMenu extends React.Component {
       searchPlaceholder,
       itemSize,
       busy,
+      busyItemsStillVisible,
+      onScroll,
       hideInput,
       filterValue,
       emptyHidesInput,
@@ -374,7 +387,8 @@ class DropdownAutoCompleteMenu extends React.Component {
           // No items to display
           const showNoItems = !busy && !filterValueOrInput && !hasItems;
           // Results mean there was an attempt to search
-          const showNoResultsMessage = !busy && filterValueOrInput && !hasResults;
+          const showNoResultsMessage =
+            !busy && !busyItemsStillVisible && filterValueOrInput && !hasResults;
 
           // Hide the input when we have no items to filter, only if
           // emptyHidesInput is set to true.
@@ -425,7 +439,9 @@ class DropdownAutoCompleteMenu extends React.Component {
                         {...getInputProps({...inputProps, onChange})}
                       />
                       <InputLoadingWrapper>
-                        {busy && <LoadingIndicator size={16} mini />}
+                        {(busy || busyItemsStillVisible) && (
+                          <LoadingIndicator size={16} mini />
+                        )}
                       </InputLoadingWrapper>
                       {renderedInputActions}
                     </StyledInputWrapper>
@@ -455,6 +471,7 @@ class DropdownAutoCompleteMenu extends React.Component {
                           highlightedIndex,
                           inputValue,
                           getItemProps,
+                          onScroll,
                         })}
                     </StyledItemList>
 
diff --git a/src/sentry/static/sentry/app/components/organizations/globalSelectionHeader/index.jsx b/src/sentry/static/sentry/app/components/organizations/globalSelectionHeader/index.jsx
index 1a2e17adc7..f39a3f5e76 100644
--- a/src/sentry/static/sentry/app/components/organizations/globalSelectionHeader/index.jsx
+++ b/src/sentry/static/sentry/app/components/organizations/globalSelectionHeader/index.jsx
@@ -1,3 +1,4 @@
+import debounce from 'lodash/debounce';
 import flatten from 'lodash/flatten';
 import isEqual from 'lodash/isEqual';
 import pick from 'lodash/pick';
@@ -26,6 +27,7 @@ import HeaderSeparator from 'app/components/organizations/headerSeparator';
 import InlineSvg from 'app/components/inlineSvg';
 import MultipleEnvironmentSelector from 'app/components/organizations/multipleEnvironmentSelector';
 import MultipleProjectSelector from 'app/components/organizations/multipleProjectSelector';
+import Projects from 'app/utils/projects';
 import SentryTypes from 'app/sentryTypes';
 import TimeRangeSelector from 'app/components/organizations/timeRangeSelector';
 import Tooltip from 'app/components/tooltip';
@@ -36,6 +38,8 @@ import withProjects from 'app/utils/withProjects';
 import {getStateFromQuery} from './utils';
 import Header from './header';
 
+const PROJECTS_PER_PAGE = 50;
+
 function getProjectIdFromProject(project) {
   return parseInt(project.id, 10);
 }
@@ -487,6 +491,28 @@ class GlobalSelectionHeader extends React.Component {
     );
   };
 
+  scrollFetchDispatcher = debounce(
+    (onSearch, options) => {
+      onSearch(this.state.searchQuery, options);
+    },
+    200,
+    {leading: true, trailing: false}
+  );
+
+  searchDispatcher = debounce((onSearch, searchQuery, options) => {
+    // in the case that a user repeats a search query (because search is
+    // debounced this is possible if the user types and then deletes what they
+    // typed) we should switch to an append strategy to not override all results
+    // with a new page.
+    if (this.state.searchQuery === searchQuery) {
+      options.append = true;
+    }
+    onSearch(searchQuery, options);
+    this.setState({
+      searchQuery,
+    });
+  }, 200);
+
   render() {
     const {
       className,
@@ -511,18 +537,45 @@ class GlobalSelectionHeader extends React.Component {
       <Header className={className}>
         <HeaderItemPosition>
           {shouldForceProject && this.getBackButton()}
-          <MultipleProjectSelector
-            organization={organization}
-            shouldForceProject={shouldForceProject}
-            forceProject={forceProject}
-            projects={memberProjects}
-            loadingProjects={loadingProjects}
-            nonMemberProjects={nonMemberProjects}
-            value={this.state.projects || this.props.selection.projects}
-            onChange={this.handleChangeProjects}
-            onUpdate={this.handleUpdateProjects}
-            multi={this.hasMultipleProjectSelection()}
-          />
+          <Projects orgId={organization.slug} limit={PROJECTS_PER_PAGE} globalSelection>
+            {({projects, initiallyLoaded, hasMore, onSearch, fetching}) => {
+              const paginatedProjectSelectorCallbacks = {
+                onScroll: ({clientHeight, scrollHeight, scrollTop}) => {
+                  // check if no new projects are being fetched and the user has
+                  // scrolled far enough to fetch a new page of projects
+                  if (
+                    !fetching &&
+                    scrollTop + clientHeight >= scrollHeight - clientHeight &&
+                    hasMore
+                  ) {
+                    this.scrollFetchDispatcher(onSearch, {append: true});
+                  }
+                },
+                onFilterChange: event => {
+                  this.searchDispatcher(onSearch, event.target.value, {
+                    append: false,
+                  });
+                },
+                searching: fetching,
+                paginated: true,
+              };
+              return (
+                <MultipleProjectSelector
+                  organization={organization}
+                  shouldForceProject={shouldForceProject}
+                  forceProject={forceProject}
+                  projects={loadingProjects ? projects : memberProjects}
+                  loadingProjects={!initiallyLoaded && loadingProjects}
+                  nonMemberProjects={nonMemberProjects}
+                  value={this.state.projects || this.props.selection.projects}
+                  onChange={this.handleChangeProjects}
+                  onUpdate={this.handleUpdateProjects}
+                  multi={this.hasMultipleProjectSelection()}
+                  {...(loadingProjects ? paginatedProjectSelectorCallbacks : {})}
+                />
+              );
+            }}
+          </Projects>
         </HeaderItemPosition>
 
         {showEnvironmentSelector && (
diff --git a/src/sentry/static/sentry/app/components/projectSelector.jsx b/src/sentry/static/sentry/app/components/projectSelector.jsx
index d082a7d3b1..db62686800 100644
--- a/src/sentry/static/sentry/app/components/projectSelector.jsx
+++ b/src/sentry/static/sentry/app/components/projectSelector.jsx
@@ -71,10 +71,26 @@ class ProjectSelector extends React.Component {
     // Callback when the menu is closed
     onClose: PropTypes.func,
 
+    // Callback when the input filter changes
+    onFilterChange: PropTypes.func,
+
+    // Callback when the list is scrolled
+    onScroll: PropTypes.func,
+
     // Callback when projects are selected via the multiple project selector
     // Calls back with (projects[], event)
     onMultiSelect: PropTypes.func,
     rootClassName: PropTypes.string,
+
+    // Represents if a search is taking place
+    searching: PropTypes.bool,
+
+    // Represents if the current project selector is paginated or fully loaded.
+    // Currently only used to ensure that in an empty state the input is not
+    // hidden. This is for the case in which a user searches for a project which
+    // does not exist. If we hide the input due to no results, the user cannot
+    // recover.
+    paginated: PropTypes.bool,
   };
 
   static defaultProps = {
@@ -206,6 +222,10 @@ class ProjectSelector extends React.Component {
       className,
       rootClassName,
       onClose,
+      onFilterChange,
+      onScroll,
+      searching,
+      paginated,
     } = this.props;
     const {activeProject} = this.state;
     const access = new Set(org.access);
@@ -252,7 +272,6 @@ class ProjectSelector extends React.Component {
           },
         ]
       : [];
-
     return (
       <DropdownAutoComplete
         alignMenu="left"
@@ -262,6 +281,9 @@ class ProjectSelector extends React.Component {
         searchPlaceholder={t('Filter projects')}
         onSelect={this.handleSelect}
         onClose={onClose}
+        onChange={onFilterChange}
+        busyItemsStillVisible={searching}
+        onScroll={onScroll}
         maxHeight={500}
         zIndex={theme.zIndex.dropdown}
         css={{marginTop: 6}}
@@ -272,7 +294,7 @@ class ProjectSelector extends React.Component {
         noResultsMessage={t('No projects found')}
         virtualizedHeight={theme.headerSelectorRowHeight}
         virtualizedLabelHeight={theme.headerSelectorLabelHeight}
-        emptyHidesInput
+        emptyHidesInput={!paginated}
         inputActions={() => (
           <AddButton
             disabled={!hasProjectWrite}
diff --git a/src/sentry/static/sentry/app/utils/projects.jsx b/src/sentry/static/sentry/app/utils/projects.jsx
index 346eca3dee..72e2fdfdb6 100644
--- a/src/sentry/static/sentry/app/utils/projects.jsx
+++ b/src/sentry/static/sentry/app/utils/projects.jsx
@@ -46,6 +46,8 @@ class Projects extends React.Component {
     fetching: false,
     isIncomplete: null,
     hasMore: null,
+    prevSearch: null,
+    nextCursor: null,
   };
 
   componentDidMount() {
@@ -167,13 +169,17 @@ class Projects extends React.Component {
     });
 
     try {
-      const {results, hasMore} = await fetchProjects(api, orgId, {limit, allProjects});
+      const {results, hasMore, nextCursor} = await fetchProjects(api, orgId, {
+        limit,
+        allProjects,
+      });
 
       this.setState({
         fetching: false,
         fetchedProjects: results,
         initiallyLoaded: true,
         hasMore,
+        nextCursor,
       });
     } catch (err) {
       console.error(err); // eslint-disable-line no-console
@@ -198,11 +204,18 @@ class Projects extends React.Component {
    */
   handleSearch = async (search, {append} = {}) => {
     const {api, orgId, limit} = this.props;
+    const {prevSearch} = this.state;
+    const cursor = this.state.nextCursor;
 
     this.setState({fetching: true});
 
     try {
-      const {results, hasMore} = await fetchProjects(api, orgId, {search, limit});
+      const {results, hasMore, nextCursor} = await fetchProjects(api, orgId, {
+        search,
+        limit,
+        prevSearch,
+        cursor,
+      });
 
       this.setState(state => {
         let fetchedProjects;
@@ -219,6 +232,8 @@ class Projects extends React.Component {
           fetchedProjects,
           hasMore,
           fetching: false,
+          prevSearch: search,
+          nextCursor,
         };
       });
     } catch (err) {
@@ -268,7 +283,11 @@ class Projects extends React.Component {
 
 export default withProjects(withApi(Projects));
 
-async function fetchProjects(api, orgId, {slugs, search, limit, allProjects} = {}) {
+async function fetchProjects(
+  api,
+  orgId,
+  {slugs, search, limit, prevSearch, cursor, allProjects} = {}
+) {
   const query = {};
 
   if (slugs && slugs.length) {
@@ -279,6 +298,10 @@ async function fetchProjects(api, orgId, {slugs, search, limit, allProjects} = {
     query.query = `${query.query ? `${query.query} ` : ''}${search}`;
   }
 
+  if (((!prevSearch && !search) || prevSearch === search) && cursor) {
+    query.cursor = cursor;
+  }
+
   // "0" shouldn't be a valid value, so this check is fine
   if (limit) {
     query.per_page = limit;
@@ -298,6 +321,7 @@ async function fetchProjects(api, orgId, {slugs, search, limit, allProjects} = {
   }
 
   let hasMore = false;
+  let nextCursor = null;
   const [results, _, xhr] = await api.requestPromise(
     `/organizations/${orgId}/projects/`,
     {
@@ -307,12 +331,12 @@ async function fetchProjects(api, orgId, {slugs, search, limit, allProjects} = {
   );
 
   const pageLinks = xhr && xhr.getResponseHeader('Link');
-
   if (pageLinks) {
     const paginationObject = parseLinkHeader(pageLinks);
     hasMore =
       paginationObject &&
       (paginationObject.next.results || paginationObject.previous.results);
+    nextCursor = paginationObject.next.cursor;
   }
 
   // populate the projects store if all projects were fetched
@@ -323,5 +347,6 @@ async function fetchProjects(api, orgId, {slugs, search, limit, allProjects} = {
   return {
     results,
     hasMore,
+    nextCursor,
   };
 }

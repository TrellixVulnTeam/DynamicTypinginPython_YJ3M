commit 071b9d595d52ed869aa6c3140e605273f762d5c9
Author: MeredithAnya <meredith.a.heller@gmail.com>
Date:   Thu Jul 5 11:12:22 2018 -0700

    feat(integrations): Add create/link issue for GitHub (#8841)
    
    * create, link and save comment with linking

diff --git a/src/sentry/api/endpoints/group_integration_details.py b/src/sentry/api/endpoints/group_integration_details.py
index 6b8dd00a5b..4403f3627e 100644
--- a/src/sentry/api/endpoints/group_integration_details.py
+++ b/src/sentry/api/endpoints/group_integration_details.py
@@ -31,7 +31,8 @@ class GroupIntegrationDetailsEndpoint(GroupEndpoint):
         except Integration.DoesNotExist:
             return Response(status=404)
 
-        if not integration.has_feature(IntegrationFeatures.ISSUE_SYNC):
+        if not (integration.has_feature(IntegrationFeatures.ISSUE_BASIC) or integration.has_feature(
+                IntegrationFeatures.ISSUE_SYNC)):
             return Response(
                 {'detail': 'This feature is not supported for this integration.'}, status=400)
 
@@ -61,13 +62,14 @@ class GroupIntegrationDetailsEndpoint(GroupEndpoint):
         except Integration.DoesNotExist:
             return Response(status=404)
 
-        if not integration.has_feature(IntegrationFeatures.ISSUE_SYNC):
+        if not (integration.has_feature(IntegrationFeatures.ISSUE_BASIC) or integration.has_feature(
+                IntegrationFeatures.ISSUE_SYNC)):
             return Response(
                 {'detail': 'This feature is not supported for this integration.'}, status=400)
 
         installation = integration.get_installation(organization_id)
         try:
-            data = installation.get_issue(external_issue_id)
+            data = installation.get_issue(external_issue_id, data=request.DATA)
         except IntegrationError as exc:
             return Response({'detail': exc.message}, status=400)
 
@@ -75,16 +77,20 @@ class GroupIntegrationDetailsEndpoint(GroupEndpoint):
             'title': data.get('title'),
             'description': data.get('description'),
         }
+
+        external_issue_key = installation.make_external_key(data)
         external_issue, created = ExternalIssue.objects.get_or_create(
             organization_id=organization_id,
             integration_id=integration.id,
-            key=external_issue_id,
+            key=external_issue_key,
             defaults=defaults,
         )
 
         if not created:
             external_issue.update(**defaults)
 
+        installation.after_link_issue(external_issue, data=request.DATA)
+
         try:
             with transaction.atomic():
                 GroupLink.objects.create(
@@ -112,7 +118,8 @@ class GroupIntegrationDetailsEndpoint(GroupEndpoint):
         except Integration.DoesNotExist:
             return Response(status=404)
 
-        if not integration.has_feature(IntegrationFeatures.ISSUE_SYNC):
+        if not (integration.has_feature(IntegrationFeatures.ISSUE_BASIC) or integration.has_feature(
+                IntegrationFeatures.ISSUE_SYNC)):
             return Response(
                 {'detail': 'This feature is not supported for this integration.'}, status=400)
 
@@ -122,10 +129,11 @@ class GroupIntegrationDetailsEndpoint(GroupEndpoint):
         except IntegrationError as exc:
             return Response({'non_field_errors': exc.message}, status=400)
 
+        external_issue_key = installation.make_external_key(data)
         external_issue = ExternalIssue.objects.get_or_create(
             organization_id=organization_id,
             integration_id=integration.id,
-            key=data['key'],
+            key=external_issue_key,
             defaults={
                 'title': data.get('title'),
                 'description': data.get('description'),
@@ -163,7 +171,8 @@ class GroupIntegrationDetailsEndpoint(GroupEndpoint):
         except Integration.DoesNotExist:
             return Response(status=404)
 
-        if not integration.has_feature(IntegrationFeatures.ISSUE_SYNC):
+        if not (integration.has_feature(IntegrationFeatures.ISSUE_BASIC) or integration.has_feature(
+                IntegrationFeatures.ISSUE_SYNC)):
             return Response(
                 {'detail': 'This feature is not supported for this integration.'}, status=400)
 
diff --git a/src/sentry/api/endpoints/group_integrations.py b/src/sentry/api/endpoints/group_integrations.py
index b255036c53..f812264c97 100644
--- a/src/sentry/api/endpoints/group_integrations.py
+++ b/src/sentry/api/endpoints/group_integrations.py
@@ -12,7 +12,7 @@ from sentry.models import Integration
 class GroupIntegrationsEndpoint(GroupEndpoint):
     def get(self, request, group):
         providers = [
-            i.key for i in integrations.all() if i.has_feature(IntegrationFeatures.ISSUE_SYNC)
+            i.key for i in integrations.all() if i.has_feature(IntegrationFeatures.ISSUE_BASIC) or i.has_feature(IntegrationFeatures.ISSUE_SYNC)
         ]
         return self.paginate(
             # TODO(jess): This should filter by integrations that
diff --git a/src/sentry/integrations/base.py b/src/sentry/integrations/base.py
index 1462d5ab7f..f4173a7d7e 100644
--- a/src/sentry/integrations/base.py
+++ b/src/sentry/integrations/base.py
@@ -30,6 +30,7 @@ IntegrationMetadata = namedtuple('IntegrationMetadata', [
 
 class IntegrationFeatures(Enum):
     NOTIFICATION = 'notification'
+    ISSUE_BASIC = 'issue_basic'
     ISSUE_SYNC = 'issue_sync'
     COMMITS = 'commits'
     CHAT_UNFURL = 'chat_unfurl'
diff --git a/src/sentry/integrations/example/integration.py b/src/sentry/integrations/example/integration.py
index fe1b82329b..c63a0bfbbf 100644
--- a/src/sentry/integrations/example/integration.py
+++ b/src/sentry/integrations/example/integration.py
@@ -55,7 +55,7 @@ class ExampleIntegration(Integration, IssueSyncMixin):
             'description': 'This is a test external issue description',
         }
 
-    def get_issue(self, issue_id):
+    def get_issue(self, issue_id, **kwargs):
         return {
             'key': issue_id,
             'title': 'This is a test external issue title',
diff --git a/src/sentry/integrations/github/client.py b/src/sentry/integrations/github/client.py
index 369310bc85..80d5d94ce3 100644
--- a/src/sentry/integrations/github/client.py
+++ b/src/sentry/integrations/github/client.py
@@ -52,6 +52,23 @@ class GitHubClientMixin(ApiClient):
         )
         return repositories['repositories']
 
+    def get_assignees(self, repo):
+        return self.get('/repos/{}/assignees'.format(repo))
+
+    def get_issues(self, repo):
+        return self.get('/repos/{}/issues'.format(repo))
+
+    def get_issue(self, repo, number):
+        return self.get('/repos/{}/issues/{}'.format(repo, number))
+
+    def create_issue(self, repo, data):
+        endpoint = '/repos/{}/issues'.format(repo)
+        return self.post(endpoint, data=data)
+
+    def create_comment(self, repo, issue_id, data):
+        endpoint = '/repos/{}/issues/{}/comments'.format(repo, issue_id)
+        return self.post(endpoint, data=data)
+
     def get_user(self, gh_username):
         return self.get('/users/{}'.format(gh_username))
 
diff --git a/src/sentry/integrations/github/integration.py b/src/sentry/integrations/github/integration.py
index dabe9ec247..732d669a79 100644
--- a/src/sentry/integrations/github/integration.py
+++ b/src/sentry/integrations/github/integration.py
@@ -13,6 +13,7 @@ from sentry.pipeline import NestedPipelineView, PipelineView
 from sentry.utils.http import absolute_uri
 
 from .client import GitHubAppsClient
+from .issues import GitHubIssueBasic
 from .repository import GitHubRepositoryProvider
 from .utils import get_jwt
 
@@ -41,7 +42,7 @@ API_ERRORS = {
 }
 
 
-class GitHubIntegration(Integration, RepositoryMixin):
+class GitHubIntegration(Integration, GitHubIssueBasic, RepositoryMixin):
 
     def get_client(self):
         return GitHubAppsClient(external_id=self.model.external_id)
@@ -49,6 +50,9 @@ class GitHubIntegration(Integration, RepositoryMixin):
     def get_repositories(self):
         return self.get_client().get_repositories()
 
+    def make_external_key(self, data):
+        return '{}#{}'.format(data['repo'], data['key'])
+
     def message_from_error(self, exc):
         if isinstance(exc, ApiError):
             message = API_ERRORS.get(exc.code)
@@ -69,10 +73,9 @@ class GitHubIntegrationProvider(IntegrationProvider):
     name = 'GitHub'
     metadata = metadata
     integration_cls = GitHubIntegration
-
     features = frozenset([
         IntegrationFeatures.COMMITS,
-        IntegrationFeatures.ISSUE_SYNC,
+        IntegrationFeatures.ISSUE_BASIC,
     ])
 
     setup_dialog_config = {
diff --git a/src/sentry/integrations/github/issues.py b/src/sentry/integrations/github/issues.py
new file mode 100644
index 0000000000..7c23cc0fea
--- /dev/null
+++ b/src/sentry/integrations/github/issues.py
@@ -0,0 +1,178 @@
+from __future__ import absolute_import
+
+from sentry.integrations.exceptions import ApiError, IntegrationError
+from sentry.integrations.issues import IssueBasicMixin
+
+
+class GitHubIssueBasic(IssueBasicMixin):
+    def make_external_key(self, data):
+        return '{}#{}'.format(data['repo'], data['key'])
+
+    def after_link_issue(self, external_issue, **kwargs):
+        data = kwargs['data']
+        client = self.get_client()
+
+        repo, issue_num = external_issue.key.split('#')
+        if not repo:
+            raise IntegrationError('repo must be provided')
+
+        if not issue_num:
+            raise IntegrationError('issue number must be provided')
+
+        comment = data.get('comment')
+        if comment:
+            try:
+                client.create_comment(
+                    repo=repo,
+                    issue_id=issue_num,
+                    data={
+                        'body': comment,
+                    },
+                )
+            except ApiError as e:
+                raise IntegrationError(self.message_from_error(e))
+
+    def get_create_issue_config(self, group, **kwargs):
+        fields = super(GitHubIssueBasic, self).get_create_issue_config(group, **kwargs)
+        try:
+            repos = self.get_repositories()
+        except ApiError:
+            repo_choices = [(' ', ' ')]
+        else:
+            repo_choices = [(repo['full_name'], repo['full_name']) for repo in repos]
+
+        params = kwargs.get('params', {})
+        default_repo = params.get('repo', repo_choices[0][0])
+        assignees = self.get_allowed_assignees(default_repo)
+
+        return [
+            {
+                'name': 'repo',
+                'label': 'GitHub Repository',
+                'type': 'select',
+                'default': default_repo,
+                'choices': repo_choices,
+                'updatesForm': True,
+            }
+        ] + fields + [
+            {
+                'name': 'assignee',
+                'label': 'Assignee',
+                'default': '',
+                'type': 'select',
+                'required': False,
+                'choices': assignees,
+            }
+        ]
+
+    def create_issue(self, data, **kwargs):
+        client = self.get_client()
+
+        repo = data.get('repo')
+
+        if not repo:
+            raise IntegrationError('repo kwarg must be provided')
+
+        try:
+            issue = client.create_issue(
+                repo=repo,
+                data={
+                    'title': data['title'],
+                    'body': data['description'],
+                    'assignee': data.get('assignee'),
+                })
+        except ApiError as e:
+            raise IntegrationError(self.message_from_error(e))
+
+        return {
+            'key': issue['number'],
+            'title': issue['title'],
+            'description': issue['body'],
+            'repo': repo,
+        }
+
+    def get_link_issue_config(self, group, **kwargs):
+        try:
+            repos = self.get_repositories()
+        except ApiError:
+            repo_choices = [(' ', ' ')]
+        else:
+            repo_choices = [(repo['full_name'], repo['full_name']) for repo in repos]
+
+        params = kwargs.get('params', {})
+        default_repo = params.get('repo', repo_choices[0][0])
+        issues = self.get_repo_issues(default_repo)
+
+        return [
+            {
+                'name': 'repo',
+                'label': 'GitHub Repository',
+                'type': 'select',
+                'default': default_repo,
+                'choices': repo_choices,
+                'updatesForm': True,
+            },
+            {
+                'name': 'externalIssue',
+                'label': 'Issue',
+                'default': '',
+                'type': 'select',
+                'choices': issues,
+
+            },
+            {
+                'name': 'comment',
+                'label': 'Comment',
+                'default': '',
+                'type': 'textarea',
+                'required': False,
+                'help': ('Leave blank if you don\'t want to '
+                         'add a comment to the GitHub issue.'),
+            }
+        ]
+
+    def get_issue(self, issue_id, **kwargs):
+        data = kwargs['data']
+        repo = data.get('repo')
+        issue_num = data.get('externalIssue')
+        client = self.get_client()
+
+        if not repo:
+            raise IntegrationError('repo must be provided')
+
+        if not issue_num:
+            raise IntegrationError('issue must be provided')
+
+        try:
+            issue = client.get_issue(repo, issue_num)
+        except ApiError as e:
+            raise IntegrationError(self.message_from_error(e))
+
+        return {
+            'key': issue['number'],
+            'title': issue['title'],
+            'description': issue['body'],
+            'repo': repo,
+        }
+
+    def get_allowed_assignees(self, repo):
+        client = self.get_client()
+        try:
+            response = client.get_assignees(repo)
+        except Exception as e:
+            self.raise_error(e)
+
+        users = tuple((u['login'], u['login']) for u in response)
+
+        return (('', 'Unassigned'), ) + users
+
+    def get_repo_issues(self, repo):
+        client = self.get_client()
+        try:
+            response = client.get_issues(repo)
+        except Exception as e:
+            self.raise_error(e)
+
+        issues = tuple((i['number'], '#{} {}'.format(i['number'], i['title'])) for i in response)
+
+        return issues
diff --git a/src/sentry/integrations/issues.py b/src/sentry/integrations/issues.py
index 198b5565f5..47a39c2d86 100644
--- a/src/sentry/integrations/issues.py
+++ b/src/sentry/integrations/issues.py
@@ -7,7 +7,8 @@ from sentry.utils.http import absolute_uri
 from sentry.utils.safe import safe_execute
 
 
-class IssueSyncMixin(object):
+class IssueBasicMixin(object):
+
     def get_group_title(self, group, event, **kwargs):
         return event.error()
 
@@ -112,6 +113,24 @@ class IssueSyncMixin(object):
         """
         raise NotImplementedError
 
+    def after_link_issue(self, external_issue, **kwargs):
+        """
+        Takes the external issue that has been linked via `get_issue`.
+
+        Does anything needed after an issue has been linked, i.e. creating
+        a comment for a linked issue.
+        """
+        pass
+
+    def make_external_key(self, data):
+        """
+        Takes result of `get_issue` or `create_issue` and returns the formatted key
+        """
+        return data['key']
+
+
+class IssueSyncMixin(IssueBasicMixin):
+
     def sync_assignee_outbound(self, external_issue, user, assign=True, **kwargs):
         """
         Propagate a sentry issue's assignee to a linked issue's assignee.
diff --git a/src/sentry/static/sentry/app/components/group/externalIssues.jsx b/src/sentry/static/sentry/app/components/group/externalIssues.jsx
index bba9f84b31..680efc90cf 100644
--- a/src/sentry/static/sentry/app/components/group/externalIssues.jsx
+++ b/src/sentry/static/sentry/app/components/group/externalIssues.jsx
@@ -79,7 +79,7 @@ class ExternalIssueForm extends AsyncComponent {
       action,
     };
     Object.entries(dynamicFieldValues).map(([key, val]) => {
-      query[key] = encodeURIComponent(val);
+      query[key] = val;
     });
     this.api.request(endpoint, {
       method: 'GET',
diff --git a/tests/sentry/integrations/github/test_issues.py b/tests/sentry/integrations/github/test_issues.py
new file mode 100644
index 0000000000..13dd365b6f
--- /dev/null
+++ b/tests/sentry/integrations/github/test_issues.py
@@ -0,0 +1,180 @@
+from __future__ import absolute_import
+
+import responses
+
+from mock import patch
+from exam import fixture
+from django.test import RequestFactory
+
+from sentry.integrations.github.integration import GitHubIntegration
+from sentry.models import Integration, ExternalIssue
+from sentry.testutils import TestCase
+from sentry.utils import json
+
+
+class GitHubIssueBasicTest(TestCase):
+    @fixture
+    def request(self):
+        return RequestFactory()
+
+    def setUp(self):
+        self.user = self.create_user()
+        self.organization = self.create_organization(owner=self.user)
+        self.model = Integration.objects.create(
+            provider='github',
+            external_id='github_external_id',
+            name='getsentry',
+        )
+        self.model.add_organization(self.organization.id)
+        self.integration = GitHubIntegration(self.model, self.organization.id)
+
+    @responses.activate
+    @patch('sentry.integrations.github.client.get_jwt', return_value='jwt_token_1')
+    def test_get_allowed_assignees(self, mock_get_jwt):
+        responses.add(
+            responses.POST,
+            'https://api.github.com/installations/github_external_id/access_tokens',
+            json={'token': 'token_1', 'expires_at': '2018-10-11T22:14:10Z'}
+        )
+
+        responses.add(
+            responses.GET,
+            'https://api.github.com/repos/getsentry/sentry/assignees',
+            json=[{'login': 'MeredithAnya'}]
+        )
+
+        repo = 'getsentry/sentry'
+        assert self.integration.get_allowed_assignees(repo) == (
+            ('', 'Unassigned'),
+            ('MeredithAnya', 'MeredithAnya')
+        )
+
+        request = responses.calls[0].request
+        assert request.headers['Authorization'] == 'Bearer jwt_token_1'
+
+        request = responses.calls[1].request
+        assert request.headers['Authorization'] == 'token token_1'
+
+    @responses.activate
+    @patch('sentry.integrations.github.client.get_jwt', return_value='jwt_token_1')
+    def test_create_issue(self, mock_get_jwt):
+        responses.add(
+            responses.POST,
+            'https://api.github.com/installations/github_external_id/access_tokens',
+            json={'token': 'token_1', 'expires_at': '2018-10-11T22:14:10Z'}
+        )
+
+        responses.add(
+            responses.POST,
+            'https://api.github.com/repos/getsentry/sentry/issues',
+            json={'number': 321, 'title': 'hello', 'body': 'This is the description'}
+        )
+
+        form_data = {
+            'repo': 'getsentry/sentry',
+            'title': 'hello',
+            'description': 'This is the description',
+        }
+
+        assert self.integration.create_issue(form_data) == {
+            'key': 321,
+            'description': 'This is the description',
+            'title': 'hello',
+            'repo': 'getsentry/sentry',
+        }
+        request = responses.calls[0].request
+        assert request.headers['Authorization'] == 'Bearer jwt_token_1'
+
+        request = responses.calls[1].request
+        assert request.headers['Authorization'] == 'token token_1'
+        payload = json.loads(request.body)
+        assert payload == {'body': 'This is the description', 'assignee': None, 'title': 'hello'}
+
+    @responses.activate
+    @patch('sentry.integrations.github.client.get_jwt', return_value='jwt_token_1')
+    def test_get_repo_issues(self, mock_get_jwt):
+        responses.add(
+            responses.POST,
+            'https://api.github.com/installations/github_external_id/access_tokens',
+            json={'token': 'token_1', 'expires_at': '2018-10-11T22:14:10Z'}
+        )
+
+        responses.add(
+            responses.GET,
+            'https://api.github.com/repos/getsentry/sentry/issues',
+            json=[{'number': 321, 'title': 'hello', 'body': 'This is the description'}]
+        )
+        repo = 'getsentry/sentry'
+        assert self.integration.get_repo_issues(repo) == ((321, '#321 hello'),)
+
+        request = responses.calls[0].request
+        assert request.headers['Authorization'] == 'Bearer jwt_token_1'
+
+        request = responses.calls[1].request
+        assert request.headers['Authorization'] == 'token token_1'
+
+    @responses.activate
+    @patch('sentry.integrations.github.client.get_jwt', return_value='jwt_token_1')
+    def test_link_issue(self, mock_get_jwt):
+        issue_id = 321
+        responses.add(
+            responses.POST,
+            'https://api.github.com/installations/github_external_id/access_tokens',
+            json={'token': 'token_1', 'expires_at': '2018-10-11T22:14:10Z'}
+        )
+
+        responses.add(
+            responses.GET,
+            'https://api.github.com/repos/getsentry/sentry/issues/321',
+            json={'number': issue_id, 'title': 'hello', 'body': 'This is the description'}
+        )
+
+        data = {
+            'repo': 'getsentry/sentry',
+            'externalIssue': issue_id,
+            'comment': 'hello',
+        }
+
+        assert self.integration.get_issue(issue_id, data=data) == {
+            'key': issue_id,
+            'description': 'This is the description',
+            'title': 'hello',
+            'repo': 'getsentry/sentry',
+        }
+        request = responses.calls[0].request
+        assert request.headers['Authorization'] == 'Bearer jwt_token_1'
+
+        request = responses.calls[1].request
+        assert request.headers['Authorization'] == 'token token_1'
+
+    @responses.activate
+    @patch('sentry.integrations.github.client.get_jwt', return_value='jwt_token_1')
+    def after_link_issue(self, mock_get_jwt):
+        responses.add(
+            responses.POST,
+            'https://api.github.com/installations/github_external_id/access_tokens',
+            json={'token': 'token_1', 'expires_at': '2018-10-11T22:14:10Z'}
+        )
+
+        responses.add(
+            responses.POST,
+            'https://api.github.com/repos/getsentry/sentry/issues/321/comments',
+            json={'body': 'hello'}
+        )
+
+        data = {'comment': 'hello'}
+        external_issue = ExternalIssue.objects.create(
+            organization_id=self.organization.id,
+            integration_id=self.model.id,
+            key='hello#321',
+        )
+
+        self.integration.after_link_issue(external_issue, data=data)
+
+        request = responses.calls[0].request
+        assert request.headers['Authorization'] == 'Bearer jwt_token_1'
+
+        request = responses.calls[1].request
+        assert request.headers['Authorization'] == 'token token_1'
+        payload = json.loads(request.body)
+        assert payload == {'body': 'hello'}

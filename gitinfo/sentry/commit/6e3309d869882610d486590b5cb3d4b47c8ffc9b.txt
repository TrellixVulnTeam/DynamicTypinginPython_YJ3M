commit 6e3309d869882610d486590b5cb3d4b47c8ffc9b
Author: Nola Chen <chen.no@husky.neu.edu>
Date:   Mon Nov 25 15:29:26 2019 -0800

    feat(app-platform): linking Sentry errors to failed Sentry App webhook requests (#15398)

diff --git a/src/sentry/api/endpoints/sentry_app_requests.py b/src/sentry/api/endpoints/sentry_app_requests.py
index 8eac689fff..10be4abeb8 100644
--- a/src/sentry/api/endpoints/sentry_app_requests.py
+++ b/src/sentry/api/endpoints/sentry_app_requests.py
@@ -9,7 +9,7 @@ from sentry.utils.sentryappwebhookrequests import (
     EXTENDED_VALID_EVENTS,
 )
 
-from sentry.models import Organization
+from sentry.models import Organization, Project
 
 
 class SentryAppRequestsEndpoint(SentryAppBaseEndpoint):
@@ -24,6 +24,19 @@ class SentryAppRequestsEndpoint(SentryAppBaseEndpoint):
             "responseCode": request.get("response_code"),
         }
 
+        if "error_id" in request and "project_id" in request:
+            try:
+                project = Project.objects.get_from_cache(id=request["project_id"])
+                # Make sure the project actually belongs to the org that owns the Sentry App
+                if project.organization_id == sentry_app.owner_id:
+                    error_url = "/organizations/{}/projects/{}/events/{}/".format(
+                        sentry_app.owner.slug, project.slug, request["error_id"]
+                    )
+                    formatted_request["errorUrl"] = error_url
+            except Project.DoesNotExist:
+                # If the project doesn't exist, don't add the error to the result
+                pass
+
         if "organization_id" in request:
             try:
                 org = Organization.objects.get_from_cache(id=request["organization_id"])
diff --git a/src/sentry/mediators/external_requests/util.py b/src/sentry/mediators/external_requests/util.py
index 92a615d6b3..ea8fa1ea33 100644
--- a/src/sentry/mediators/external_requests/util.py
+++ b/src/sentry/mediators/external_requests/util.py
@@ -60,6 +60,13 @@ def send_and_save_sentry_app_request(url, sentry_app, org_id, event, **kwargs):
         # Re-raise the exception because some of these tasks might retry on the exception
         raise
 
-    buffer.add_request(response_code=resp.status_code, org_id=org_id, event=event, url=url)
+    buffer.add_request(
+        response_code=resp.status_code,
+        org_id=org_id,
+        event=event,
+        url=url,
+        error_id=resp.headers.get("Sentry-Hook-Error"),
+        project_id=resp.headers.get("Sentry-Hook-Project"),
+    )
 
     return resp
diff --git a/src/sentry/static/sentry/app/types/index.tsx b/src/sentry/static/sentry/app/types/index.tsx
index 7aa3114213..1ea3c4ab8e 100644
--- a/src/sentry/static/sentry/app/types/index.tsx
+++ b/src/sentry/static/sentry/app/types/index.tsx
@@ -529,6 +529,7 @@ export type SentryAppWebhookRequest = {
     name: string;
   };
   responseCode: number;
+  errorUrl?: string;
 };
 
 export type PermissionValue = 'no-access' | 'read' | 'write' | 'admin';
diff --git a/src/sentry/tasks/sentry_apps.py b/src/sentry/tasks/sentry_apps.py
index 6e459c7189..4230c61a29 100644
--- a/src/sentry/tasks/sentry_apps.py
+++ b/src/sentry/tasks/sentry_apps.py
@@ -263,6 +263,21 @@ def send_webhooks(installation, event, **kwargs):
     # the event is within the allowed projects.
     project_limited = ServiceHookProject.objects.filter(service_hook_id=servicehook.id).exists()
 
+    # TODO(nola): This is disabled for now, because it could potentially affect internal integrations w/ error.created
+    # # If the event is error.created & the request is going out to the Org that owns the Sentry App,
+    # # Make sure we don't send the request, to prevent potential infinite loops
+    # if (
+    #     event == "error.created"
+    #     and installation.organization_id == installation.sentry_app.owner_id
+    # ):
+    #     # We just want to exclude error.created from the project that the integration lives in
+    #     # Need to first implement project mapping for integration partners
+    #     metrics.incr(
+    #         "webhook_request.dropped",
+    #         tags={"sentry_app": installation.sentry_app.id, "event": event},
+    #     )
+    #     return
+
     if not project_limited:
         resource, action = event.split(".")
 
@@ -293,6 +308,13 @@ def send_and_save_webhook_request(url, sentry_app, app_platform_event):
         # Re-raise the exception because some of these tasks might retry on the exception
         raise
 
-    buffer.add_request(response_code=resp.status_code, org_id=org_id, event=event, url=url)
+    buffer.add_request(
+        response_code=resp.status_code,
+        org_id=org_id,
+        event=event,
+        url=url,
+        error_id=resp.headers.get("Sentry-Hook-Error"),
+        project_id=resp.headers.get("Sentry-Hook-Project"),
+    )
 
     return resp
diff --git a/src/sentry/utils/sentryappwebhookrequests.py b/src/sentry/utils/sentryappwebhookrequests.py
index bc9077fe5a..ad15579a0a 100644
--- a/src/sentry/utils/sentryappwebhookrequests.py
+++ b/src/sentry/utils/sentryappwebhookrequests.py
@@ -104,7 +104,7 @@ class SentryAppWebhookRequestsBuffer(object):
     def get_requests(self, event=None, errors_only=False):
         return self._get_requests(event=event, error=errors_only)
 
-    def add_request(self, response_code, org_id, event, url):
+    def add_request(self, response_code, org_id, event, url, error_id=None, project_id=None):
         if event not in EXTENDED_VALID_EVENTS:
             return
 
@@ -121,6 +121,11 @@ class SentryAppWebhookRequestsBuffer(object):
         if not self.sentry_app.is_internal:
             request_data["organization_id"] = org_id
 
+        # We need both the error ID and project ID to link the error
+        if error_id is not None and project_id is not None:
+            request_data["error_id"] = error_id
+            request_data["project_id"] = project_id
+
         pipe = self.client.pipeline()
 
         self._add_to_buffer_pipeline(request_key, request_data, pipe)
diff --git a/tests/sentry/api/endpoints/test_sentry_app_requests.py b/tests/sentry/api/endpoints/test_sentry_app_requests.py
index 2b5ddf515c..11e440b398 100644
--- a/tests/sentry/api/endpoints/test_sentry_app_requests.py
+++ b/tests/sentry/api/endpoints/test_sentry_app_requests.py
@@ -194,3 +194,69 @@ class GetSentryAppRequestsTest(SentryAppRequestsTest):
         response = self.client.get(url, format="json")
         assert response.status_code == 200
         assert len(response.data) == 2
+
+    def test_linked_error_id_converts_to_url(self):
+        self.login_as(user=self.user)
+
+        buffer = SentryAppWebhookRequestsBuffer(self.published_app)
+        buffer.add_request(
+            response_code=200,
+            org_id=self.org.id,
+            event="issue.assigned",
+            url=self.unpublished_app.webhook_url,
+            error_id="d5111da2c28645c5889d072017e3445d",
+            project_id=self.project.id,
+        )
+
+        url = reverse("sentry-api-0-sentry-app-requests", args=[self.published_app.slug])
+        response = self.client.get(url, format="json")
+        assert response.status_code == 200
+        assert len(response.data) == 1
+        assert response.data[0]["organization"]["slug"] == self.org.slug
+        assert response.data[0]["sentryAppSlug"] == self.published_app.slug
+        assert response.data[0]["errorUrl"] == "/organizations/{}/projects/{}/events/{}/".format(
+            self.org.slug, self.project.slug, "d5111da2c28645c5889d072017e3445d"
+        )
+
+    def test_linked_error_not_returned_if_project_does_not_exist(self):
+        self.login_as(user=self.user)
+
+        buffer = SentryAppWebhookRequestsBuffer(self.published_app)
+        buffer.add_request(
+            response_code=200,
+            org_id=self.org.id,
+            event="issue.assigned",
+            url=self.unpublished_app.webhook_url,
+            error_id="d5111da2c28645c5889d072017e3445d",
+            project_id="1000",
+        )
+
+        url = reverse("sentry-api-0-sentry-app-requests", args=[self.published_app.slug])
+        response = self.client.get(url, format="json")
+        assert response.status_code == 200
+        assert len(response.data) == 1
+        assert response.data[0]["organization"]["slug"] == self.org.slug
+        assert response.data[0]["sentryAppSlug"] == self.published_app.slug
+        assert "errorUrl" not in response.data[0]
+
+    def test_linked_error_not_returned_if_project_doesnt_belong_to_org(self):
+        self.login_as(user=self.user)
+        unowned_project = self.create_project(organization=self.create_organization())
+
+        buffer = SentryAppWebhookRequestsBuffer(self.published_app)
+        buffer.add_request(
+            response_code=200,
+            org_id=self.org.id,
+            event="issue.assigned",
+            url=self.unpublished_app.webhook_url,
+            error_id="d5111da2c28645c5889d072017e3445d",
+            project_id=unowned_project.id,
+        )
+
+        url = reverse("sentry-api-0-sentry-app-requests", args=[self.published_app.slug])
+        response = self.client.get(url, format="json")
+        assert response.status_code == 200
+        assert len(response.data) == 1
+        assert response.data[0]["organization"]["slug"] == self.org.slug
+        assert response.data[0]["sentryAppSlug"] == self.published_app.slug
+        assert "errorUrl" not in response.data[0]
diff --git a/tests/sentry/tasks/test_sentry_apps.py b/tests/sentry/tasks/test_sentry_apps.py
index 3a32bdfa00..6e859b90da 100644
--- a/tests/sentry/tasks/test_sentry_apps.py
+++ b/tests/sentry/tasks/test_sentry_apps.py
@@ -1,6 +1,7 @@
 from __future__ import absolute_import
 
 import six
+import pytest
 
 from celery import Task
 from collections import namedtuple
@@ -34,6 +35,12 @@ RuleFuture = namedtuple("RuleFuture", ["rule", "kwargs"])
 MockResponse = namedtuple("MockResponse", ["headers", "content", "ok", "status_code"])
 MockResponseInstance = MockResponse({}, {}, True, 200)
 MockFailureResponseInstance = MockResponse({}, {}, False, 400)
+MockResponseWithHeadersInstance = MockResponse(
+    {"Sentry-Hook-Error": "d5111da2c28645c5889d072017e3445d", "Sentry-Hook-Project": "1"},
+    {},
+    False,
+    400,
+)
 
 
 class DictContaining(object):
@@ -252,6 +259,36 @@ class TestProcessResourceChange(TestCase):
         assert faux(safe_urlopen).kwargs_contain("headers.Sentry-Hook-Timestamp")
         assert faux(safe_urlopen).kwargs_contain("headers.Sentry-Hook-Signature")
 
+    # TODO(nola): Enable this test whenever we prevent infinite loops w/ error.created integrations
+    @pytest.mark.skip(reason="enable this when/if we do prevent infinite error.created loops")
+    @with_feature("organizations:integrations-event-hooks")
+    def test_integration_org_error_created_doesnt_send_webhook(self, safe_urlopen):
+        sentry_app = self.create_sentry_app(
+            organization=self.project.organization, events=["error.created"]
+        )
+        self.create_sentry_app_installation(
+            organization=self.project.organization, slug=sentry_app.slug
+        )
+
+        one_min_ago = iso_format(before_now(minutes=1))
+        event = self.store_event(
+            data={
+                "message": "Foo bar",
+                "exception": {"type": "Foo", "value": "shits on fiah yo"},
+                "level": "error",
+                "timestamp": one_min_ago,
+            },
+            project_id=self.project.id,
+            assert_no_errors=False,
+        )
+
+        with self.tasks():
+            post_process_group(
+                event=event, is_new=False, is_regression=False, is_new_group_environment=False
+            )
+
+        assert not safe_urlopen.called
+
 
 @patch("sentry.mediators.sentry_app_installations.InstallationNotifier.run")
 class TestInstallationWebhook(TestCase):
@@ -402,3 +439,20 @@ class TestWebhookRequests(TestCase):
         assert first_request["response_code"] == 0
         assert first_request["event_type"] == "issue.assigned"
         assert first_request["organization_id"] == self.install.organization.id
+
+    @patch("sentry.tasks.sentry_apps.safe_urlopen", return_value=MockResponseWithHeadersInstance)
+    def test_saves_error_event_id_if_in_header(self, safe_urlopen):
+        data = {"issue": serialize(self.issue)}
+        send_webhooks(installation=self.install, event="issue.assigned", data=data, actor=self.user)
+
+        requests = self.buffer.get_requests()
+        requests_count = len(requests)
+        first_request = requests[0]
+
+        assert safe_urlopen.called
+        assert requests_count == 1
+        assert first_request["response_code"] == 400
+        assert first_request["event_type"] == "issue.assigned"
+        assert first_request["organization_id"] == self.install.organization.id
+        assert first_request["error_id"] == "d5111da2c28645c5889d072017e3445d"
+        assert first_request["project_id"] == "1"
diff --git a/tests/sentry/utils/test_sentryappwebhookrequests.py b/tests/sentry/utils/test_sentryappwebhookrequests.py
index ec07b67942..4abbeb4f85 100644
--- a/tests/sentry/utils/test_sentryappwebhookrequests.py
+++ b/tests/sentry/utils/test_sentryappwebhookrequests.py
@@ -10,6 +10,7 @@ class TestSentryAppWebhookRequests(TestCase):
         self.sentry_app = self.create_sentry_app(
             name="Test App", events=["issue.resolved", "issue.ignored", "issue.assigned"]
         )
+        self.project = self.create_project()
 
         self.buffer = SentryAppWebhookRequestsBuffer(self.sentry_app)
 
@@ -30,3 +31,37 @@ class TestSentryAppWebhookRequests(TestCase):
         assert requests[0]["response_code"] == 500
         assert requests[99]["organization_id"] == 1
         assert requests[99]["response_code"] == 200
+
+    def test_error_added(self):
+        self.buffer.add_request(
+            200,
+            1,
+            "issue.assigned",
+            "https://example.com/hook",
+            error_id="d5111da2c28645c5889d072017e3445d",
+            project_id=1,
+        )
+        requests = self.buffer.get_requests()
+        assert len(requests) == 1
+        assert requests[0]["error_id"] == "d5111da2c28645c5889d072017e3445d"
+        assert requests[0]["project_id"] == 1
+
+    def test_error_not_added_if_project_id_missing(self):
+        self.buffer.add_request(
+            200,
+            1,
+            "issue.assigned",
+            "https://example.com/hook",
+            error_id="d5111da2c28645c5889d072017e3445d",
+        )
+        requests = self.buffer.get_requests()
+        assert len(requests) == 1
+        assert "error_id" not in requests[0]
+        assert "project_id" not in requests[0]
+
+    def test_error_not_added_if_error_id_missing(self):
+        self.buffer.add_request(200, 1, "issue.assigned", "https://example.com/hook", project_id=1)
+        requests = self.buffer.get_requests()
+        assert len(requests) == 1
+        assert "error_id" not in requests[0]
+        assert "project_id" not in requests[0]

commit 3b398c5b7dfca7f9f9de2cc3b945c6cc180e3c97
Author: Dan Fuller <dfuller@sentry.io>
Date:   Mon Mar 4 16:45:18 2019 -0800

    fix(api): Fix errors with null checks on non-string snuba columns. Add missed columns to type lists.
    
    Was looking into a fix for SENTRY-9PA, and while writing tests for it uncovered an extra class of
    errors that occur when checking that a date/numeric column are null/not null. Since we were using
    `ifNull` to convert them to strings, Clickhouse would end up throwing an error.
    
    Change our null checks to use `isNull` instead so that things will be more generic. Also added in a
    generic test to make sure that queries for all fields aren't hard failing due to schema issues,
    although it won't validate the results are correct, just that the query had no issues.

diff --git a/src/sentry/api/event_search.py b/src/sentry/api/event_search.py
index e83657775a..2b9dbb1d1f 100644
--- a/src/sentry/api/event_search.py
+++ b/src/sentry/api/event_search.py
@@ -194,8 +194,15 @@ class SearchVisitor(NodeVisitor):
     # A list of mappers that map source keys to a target name. Format is
     # <target_name>: [<list of source names>],
     key_mappings = {}
-    numeric_keys = set()
-    date_keys = set(['start', 'end', 'first_seen', 'last_seen', 'timestamp'])
+    numeric_keys = set([
+        'device.battery_level', 'device.charging', 'device.online',
+        'device.simulator', 'error.handled', 'issue.id', 'stack.colno',
+        'stack.in_app', 'stack.lineno', 'stack.stack_level',
+
+    ])
+    date_keys = set([
+        'start', 'end', 'first_seen', 'last_seen', 'time', 'timestamp',
+    ])
 
     unwrapped_exceptions = (InvalidSearchQuery,)
 
@@ -443,20 +450,38 @@ def convert_search_filter_to_snuba_query(search_filter):
         value = int(to_timestamp(value)) * 1000 if isinstance(value,
                                                               datetime) and snuba_name != 'timestamp' else value
 
-        if search_filter.operator == '!=' or search_filter.operator == '=' and search_filter.value.value == '':
-            # Handle null columns on (in)equality comparisons. Any comparison between a value
-            # and a null will result to null. There are two cases we handle here:
-            # - A column doesn't equal a value. In this case, we need to convert the column to
-            # an empty string so that we don't exclude rows that have it set to null
-            # - Checking that a value isn't present. In some cases the column will be null,
-            # and in other cases an empty string. To generalize this we convert values in the
-            # column to an empty string and just check for that.
-            snuba_name = ['ifNull', [snuba_name, "''"]]
+        # Handle checks for existence
+        if search_filter.operator in ('=', '!=') and search_filter.value.value == '':
+            # Tags are never null, so we need to check for empty values
+            if search_filter.key.is_tag:
+                return [snuba_name, search_filter.operator, value]
+            else:
+                # Otherwise, check that the column is null.
+                return [['isNull', [snuba_name]], search_filter.operator, 1]
+
+        is_null_condition = None
+        if search_filter.operator == '!=' and not search_filter.key.is_tag:
+            # Handle null columns on inequality comparisons. Any comparison
+            # between a value and a null will result to null, so we need to
+            # explicitly check for whether the condition is null, and OR it
+            # together with the inequality check.
+            # We don't need to apply this for tags, since if they don't exist
+            # they'll always be an empty string.
+            is_null_condition = [['isNull', [snuba_name]], '=', 1]
 
         if search_filter.value.is_wildcard():
-            return [['match', [snuba_name, "'(?i)%s'" % (value,)]], search_filter.operator, 1]
+            condition = [['match', [snuba_name, "'(?i)%s'" % (value,)]], search_filter.operator, 1]
+        else:
+            condition = [snuba_name, search_filter.operator, value]
+
+        # We only want to return as a list if we have the check for null
+        # present. Returning as a list causes these conditions to be ORed
+        # together. Otherwise just return the raw condition, so that it can be
+        # used correctly in aggregates.
+        if is_null_condition:
+            return [is_null_condition, condition]
         else:
-            return [snuba_name, search_filter.operator, value]
+            return condition
 
 
 def get_snuba_query_args(query=None, params=None):
diff --git a/src/sentry/utils/snuba.py b/src/sentry/utils/snuba.py
index ca50f17580..966ee08dfb 100644
--- a/src/sentry/utils/snuba.py
+++ b/src/sentry/utils/snuba.py
@@ -76,7 +76,7 @@ SENTRY_SNUBA_MAP = {
     'device.arch': 'device_arch',
     'device.battery_level': 'device_battery_level',
     'device.orientation': 'device_orientation',
-    'device.simulator': 'device_orientation',
+    'device.simulator': 'device_simulator',
     'device.online': 'device_online',
     'device.charging': 'device_charging',
     # geo
diff --git a/tests/sentry/api/test_event_search.py b/tests/sentry/api/test_event_search.py
index 05a23b9474..d6d0568463 100644
--- a/tests/sentry/api/test_event_search.py
+++ b/tests/sentry/api/test_event_search.py
@@ -579,7 +579,10 @@ class GetSnubaQueryArgsTest(TestCase):
     def test_negation(self):
         assert get_snuba_query_args('!user.email:foo@example.com') == {
             'conditions': [
-                [['ifNull', ['email', "''"]], '!=', 'foo@example.com'],
+                [
+                    [['isNull', ['email']], '=', 1],
+                    ['email', '!=', 'foo@example.com']
+                ]
             ],
             'filter_keys': {},
         }
@@ -608,9 +611,11 @@ class GetSnubaQueryArgsTest(TestCase):
     def test_negated_wildcard(self):
         assert get_snuba_query_args('!release:3.1.* user.email:*@example.com') == {
             'conditions': [
-                [['match', [['ifNull', ['tags[sentry:release]', "''"]],
-                            "'(?i)^3\\.1\\..*$'"]], '!=', 1],
-                [['match', ['email', "'(?i)^.*\\@example\\.com$'"]], '=', 1],
+                [
+                    [['isNull', ['tags[sentry:release]']], '=', 1],
+                    [['match', ['tags[sentry:release]', "'(?i)^3\\.1\\..*$'"]], '!=', 1]
+                ],
+                [['match', ['email', "'(?i)^.*\\@example\\.com$'"]], '=', 1]
             ],
             'filter_keys': {},
         }
@@ -639,13 +644,13 @@ class GetSnubaQueryArgsTest(TestCase):
     def test_has(self):
         assert get_snuba_query_args('has:release') == {
             'filter_keys': {},
-            'conditions': [[['ifNull', ['tags[sentry:release]', "''"]], '!=', '']]
+            'conditions': [[['isNull', ['tags[sentry:release]']], '!=', 1]]
         }
 
     def test_not_has(self):
         assert get_snuba_query_args('!has:release') == {
             'filter_keys': {},
-            'conditions': [[['ifNull', ['tags[sentry:release]', "''"]], '=', '']]
+            'conditions': [[['isNull', ['tags[sentry:release]']], '=', 1]]
         }
 
     def test_message_negative(self):
diff --git a/tests/snuba/search/test_backend.py b/tests/snuba/search/test_backend.py
index 26bcbb9661..9c3f44a3f3 100644
--- a/tests/snuba/search/test_backend.py
+++ b/tests/snuba/search/test_backend.py
@@ -11,6 +11,7 @@ from hashlib import md5
 from sentry import options
 from sentry.api.issue_search import (
     convert_query_values,
+    IssueSearchVisitor,
     parse_search_query,
 )
 from sentry.models import (
@@ -23,6 +24,10 @@ from sentry.testutils import (
     SnubaTestCase,
     xfail_if_not_postgres,
 )
+from sentry.utils.snuba import (
+    SENTRY_SNUBA_MAP,
+    SnubaError,
+)
 
 
 def date_to_query_format(date):
@@ -1272,7 +1277,7 @@ class SnubaSearchTest(SnubaTestCase):
                 'message': 'somet[hing]',
                 'environment': 'production',
                 'tags': {
-                    'server': 'example.com',
+                    'server': 'example.net',
                 },
                 'timestamp': self.base_datetime.isoformat()[:19],
                 'stacktrace': {
@@ -1306,6 +1311,14 @@ class SnubaSearchTest(SnubaTestCase):
             search_filter_query='environment:production s*]',
         )
         assert set(results) == set([escaped_event.group])
+        results = self.make_query(
+            search_filter_query='environment:production server:example.*',
+        )
+        assert set(results) == set([self.group1, escaped_event.group])
+        results = self.make_query(
+            search_filter_query='environment:production !server:*net',
+        )
+        assert set(results) == set([self.group1])
         # TODO: Disabling tests that use [] syntax for the moment. Re-enable
         # these if we decide to add back in, or remove if this comment has been
         # here a while.
@@ -1317,3 +1330,87 @@ class SnubaSearchTest(SnubaTestCase):
         #     search_filter_query='environment:production [z][of][mz]',
         # )
         # assert set(results) == set()
+
+    def test_null_tags(self):
+        tag_event = self.store_event(
+            data={
+                'fingerprint': ['hello-there'],
+                'event_id': 'f' * 32,
+                'message': 'something',
+                'environment': 'production',
+                'tags': {
+                    'server': 'example.net',
+                },
+                'timestamp': self.base_datetime.isoformat()[:19],
+                'stacktrace': {
+                    'frames': [{
+                        'module': 'group1'
+                    }]
+                },
+            },
+            project_id=self.project.id,
+        )
+        no_tag_event = self.store_event(
+            data={
+                'fingerprint': ['hello-there-2'],
+                'event_id': '5' * 32,
+                'message': 'something',
+                'environment': 'production',
+                'timestamp': self.base_datetime.isoformat()[:19],
+                'stacktrace': {
+                    'frames': [{
+                        'module': 'group2'
+                    }]
+                },
+            },
+            project_id=self.project.id,
+        )
+        results = self.make_query(
+            search_filter_query='environment:production !server:*net',
+        )
+        assert set(results) == set([self.group1, no_tag_event.group])
+        results = self.make_query(
+            search_filter_query='environment:production server:*net',
+        )
+        assert set(results) == set([tag_event.group])
+        results = self.make_query(
+            search_filter_query='environment:production !server:example.net',
+        )
+        assert set(results) == set([self.group1, no_tag_event.group])
+        results = self.make_query(
+            search_filter_query='environment:production server:example.net',
+        )
+        assert set(results) == set([tag_event.group])
+        results = self.make_query(
+            search_filter_query='environment:production has:server',
+        )
+        assert set(results) == set([self.group1, tag_event.group])
+        results = self.make_query(
+            search_filter_query='environment:production !has:server',
+        )
+        assert set(results) == set([no_tag_event.group])
+
+    def test_all_fields_do_not_error(self):
+        # Just a sanity check to make sure that all fields can be succesfully
+        # searched on without returning type errors and other schema related
+        # issues.
+        def test_query(query):
+            try:
+                self.make_query(search_filter_query=query)
+            except SnubaError as e:
+                self.fail('Query %s errored. Error info: %s' % (query, e))
+
+        for key in SENTRY_SNUBA_MAP:
+            if key == 'project.id':
+                continue
+            test_query('has:%s' % key)
+            test_query('!has:%s' % key)
+            if key in IssueSearchVisitor.numeric_keys:
+                val = '123'
+            elif key in IssueSearchVisitor.date_keys:
+                val = '2019-01-01'
+            else:
+                val = 'hello'
+                test_query('!%s:%s' % (key, val))
+
+            test_query('%s:%s' % (key, val))

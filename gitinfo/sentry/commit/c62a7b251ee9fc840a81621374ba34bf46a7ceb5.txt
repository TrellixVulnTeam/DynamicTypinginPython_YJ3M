commit c62a7b251ee9fc840a81621374ba34bf46a7ceb5
Author: ted kaemming <ted@kaemming.com>
Date:   Thu May 3 15:13:44 2018 -0700

    ref(tagstore): Use non-model types for read methods (#8270)

diff --git a/src/sentry/api/endpoints/group_tagkey_details.py b/src/sentry/api/endpoints/group_tagkey_details.py
index 187e8ff83a..4d91594ae9 100644
--- a/src/sentry/api/endpoints/group_tagkey_details.py
+++ b/src/sentry/api/endpoints/group_tagkey_details.py
@@ -1,7 +1,5 @@
 from __future__ import absolute_import
 
-import six
-
 from rest_framework.response import Response
 
 from sentry import tagstore
@@ -64,7 +62,6 @@ class GroupTagKeyDetailsEndpoint(GroupEndpoint, EnvironmentMixin):
             group.project_id, group.id, environment_id, lookup_key, limit=9)
 
         data = {
-            'id': six.text_type(tag_key.id),
             'key': key,
             'name': tagstore.get_tag_key_label(tag_key.key),
             'uniqueValues': group_tag_key.values_seen,
diff --git a/src/sentry/api/endpoints/group_tagkey_values.py b/src/sentry/api/endpoints/group_tagkey_values.py
index bbfca41842..84d3cc8787 100644
--- a/src/sentry/api/endpoints/group_tagkey_values.py
+++ b/src/sentry/api/endpoints/group_tagkey_values.py
@@ -8,6 +8,7 @@ from sentry.api.paginator import DateTimePaginator, Paginator
 from sentry.api.serializers import serialize
 from sentry.api.serializers.models.tagvalue import UserTagValueSerializer
 from sentry.models import Group, Environment
+from sentry.tagstore.types import GroupTagValue
 from sentry.utils.apidocs import scenario
 
 
@@ -65,7 +66,7 @@ class GroupTagKeyValuesEndpoint(GroupEndpoint, EnvironmentMixin):
             paginator_cls = Paginator
 
         if key == 'user':
-            serializer_cls = UserTagValueSerializer()
+            serializer_cls = UserTagValueSerializer(group.project_id)
         else:
             serializer_cls = None
 
@@ -74,5 +75,19 @@ class GroupTagKeyValuesEndpoint(GroupEndpoint, EnvironmentMixin):
             queryset=queryset,
             order_by=order_by,
             paginator_cls=paginator_cls,
-            on_results=lambda x: serialize(x, request.user, serializer_cls),
+            on_results=lambda results: serialize(
+                map(  # XXX: This is a pretty big abstraction leak
+                    lambda instance: GroupTagValue(
+                        group_id=instance.group_id,
+                        key=instance.key,
+                        value=instance.value,
+                        times_seen=instance.times_seen,
+                        last_seen=instance.last_seen,
+                        first_seen=instance.first_seen,
+                    ),
+                    results,
+                ),
+                request.user,
+                serializer_cls,
+            ),
         )
diff --git a/src/sentry/api/endpoints/project_tagkey_values.py b/src/sentry/api/endpoints/project_tagkey_values.py
index 6595a20a3c..dbef2e3e9e 100644
--- a/src/sentry/api/endpoints/project_tagkey_values.py
+++ b/src/sentry/api/endpoints/project_tagkey_values.py
@@ -7,6 +7,7 @@ from sentry.api.exceptions import ResourceDoesNotExist
 from sentry.api.paginator import DateTimePaginator
 from sentry.api.serializers import serialize
 from sentry.models import Environment
+from sentry.tagstore.types import TagValue
 
 
 class ProjectTagKeyValuesEndpoint(ProjectEndpoint, EnvironmentMixin):
@@ -51,5 +52,17 @@ class ProjectTagKeyValuesEndpoint(ProjectEndpoint, EnvironmentMixin):
             queryset=queryset,
             order_by='-last_seen',
             paginator_cls=DateTimePaginator,
-            on_results=lambda x: serialize(x, request.user),
+            on_results=lambda results: serialize(
+                map(  # XXX: This is a pretty big abstraction leak
+                    lambda instance: TagValue(
+                        key=instance.key,
+                        value=instance.value,
+                        times_seen=instance.times_seen,
+                        first_seen=instance.first_seen,
+                        last_seen=instance.last_seen,
+                    ),
+                    results,
+                ),
+                request.user
+            ),
         )
diff --git a/src/sentry/api/endpoints/project_tags.py b/src/sentry/api/endpoints/project_tags.py
index 2c809279ef..257e8b8761 100644
--- a/src/sentry/api/endpoints/project_tags.py
+++ b/src/sentry/api/endpoints/project_tags.py
@@ -1,7 +1,5 @@
 from __future__ import absolute_import
 
-import six
-
 from rest_framework.response import Response
 
 from sentry import tagstore
@@ -29,7 +27,6 @@ class ProjectTagsEndpoint(ProjectEndpoint, EnvironmentMixin):
         for tag_key in tag_keys:
             data.append(
                 {
-                    'id': six.text_type(tag_key.id),
                     'key': tagstore.get_standardized_key(tag_key.key),
                     'name': tagstore.get_tag_key_label(tag_key.key),
                     'uniqueValues': tag_key.values_seen,
diff --git a/src/sentry/api/serializers/models/tagvalue.py b/src/sentry/api/serializers/models/tagvalue.py
index 668eeb034b..c5eea4845e 100644
--- a/src/sentry/api/serializers/models/tagvalue.py
+++ b/src/sentry/api/serializers/models/tagvalue.py
@@ -15,9 +15,12 @@ class EnvironmentTagValueSerializer(Serializer):
 
 
 class UserTagValueSerializer(Serializer):
+    def __init__(self, project_id):
+        self.project_id = project_id
+
     def get_attrs(self, item_list, user):
         users = EventUser.for_tags(
-            project_id=item_list[0].project_id,
+            project_id=self.project_id,
             values=[t.value for t in item_list],
         )
 
diff --git a/src/sentry/tagstore/legacy/backend.py b/src/sentry/tagstore/legacy/backend.py
index 9a48ec3caa..f79663d469 100644
--- a/src/sentry/tagstore/legacy/backend.py
+++ b/src/sentry/tagstore/legacy/backend.py
@@ -24,7 +24,37 @@ from sentry.tagstore import TagKeyStatus
 from sentry.tagstore.base import TagStorage
 from sentry.utils import db
 
-from .models import EventTag, GroupTagKey, GroupTagValue, TagKey, TagValue
+from . import models
+from sentry.tagstore.types import TagKey, TagValue, GroupTagKey, GroupTagValue
+
+
+transformers = {
+    models.TagKey: lambda instance: TagKey(
+        key=instance.key,
+        values_seen=instance.values_seen,
+        status=instance.status,
+    ),
+    models.TagValue: lambda instance: TagValue(
+        key=instance.key,
+        value=instance.value,
+        times_seen=instance.times_seen,
+        first_seen=instance.first_seen,
+        last_seen=instance.last_seen,
+    ),
+    models.GroupTagKey: lambda instance: GroupTagKey(
+        group_id=instance.group_id,
+        key=instance.key,
+        values_seen=instance.values_seen,
+    ),
+    models.GroupTagValue: lambda instance: GroupTagValue(
+        group_id=instance.group_id,
+        key=instance.key,
+        value=instance.value,
+        times_seen=instance.times_seen,
+        first_seen=instance.first_seen,
+        last_seen=instance.last_seen,
+    ),
+}
 
 
 class LegacyTagStorage(TagStorage):
@@ -39,8 +69,8 @@ class LegacyTagStorage(TagStorage):
         self.setup_cleanup()
 
         self.setup_merge(
-            grouptagkey_model=GroupTagKey,
-            grouptagvalue_model=GroupTagValue,
+            grouptagkey_model=models.GroupTagKey,
+            grouptagvalue_model=models.GroupTagValue,
         )
 
         self.setup_receivers()
@@ -49,9 +79,9 @@ class LegacyTagStorage(TagStorage):
         from sentry.runner.commands import cleanup
 
         cleanup.EXTRA_BULK_QUERY_DELETES += [
-            (GroupTagValue, 'last_seen', None),
-            (TagValue, 'last_seen', None),
-            (EventTag, 'date_added', 'date_added', 50000),
+            (models.GroupTagValue, 'last_seen', None),
+            (models.TagValue, 'last_seen', None),
+            (models.EventTag, 'date_added', 'date_added', 50000),
         ]
 
     def setup_deletions(self):
@@ -61,49 +91,49 @@ class LegacyTagStorage(TagStorage):
         from sentry.models import Event, Group, Project
 
         deletion_manager.add_bulk_dependencies(Event, [
-            lambda instance_list: ModelRelation(EventTag,
+            lambda instance_list: ModelRelation(models.EventTag,
                                                 {'event_id__in': [i.id for i in instance_list]},
                                                 ModelDeletionTask),
         ])
 
-        deletion_manager.register(TagValue, BulkModelDeletionTask)
-        deletion_manager.register(GroupTagKey, BulkModelDeletionTask)
-        deletion_manager.register(GroupTagValue, BulkModelDeletionTask)
-        deletion_manager.register(EventTag, BulkModelDeletionTask)
+        deletion_manager.register(models.TagValue, BulkModelDeletionTask)
+        deletion_manager.register(models.GroupTagKey, BulkModelDeletionTask)
+        deletion_manager.register(models.GroupTagValue, BulkModelDeletionTask)
+        deletion_manager.register(models.EventTag, BulkModelDeletionTask)
 
         deletion_manager.add_dependencies(Group, [
             lambda instance: ModelRelation(
-                EventTag,
+                models.EventTag,
                 query={
                     'group_id': instance.id,
                 }),
             lambda instance: ModelRelation(
-                GroupTagKey,
+                models.GroupTagKey,
                 query={
                     'group_id': instance.id,
                 }),
             lambda instance: ModelRelation(
-                GroupTagValue,
+                models.GroupTagValue,
                 query={
                     'group_id': instance.id,
                 }),
         ])
 
         deletion_manager.add_dependencies(Project, [
-            lambda instance: ModelRelation(TagKey,
+            lambda instance: ModelRelation(models.TagKey,
                                            query={'project_id': instance.id}),
-            lambda instance: ModelRelation(TagValue,
+            lambda instance: ModelRelation(models.TagValue,
                                            query={'project_id': instance.id}),
-            lambda instance: ModelRelation(GroupTagKey,
+            lambda instance: ModelRelation(models.GroupTagKey,
                                            query={'project_id': instance.id}),
-            lambda instance: ModelRelation(GroupTagValue,
+            lambda instance: ModelRelation(models.GroupTagValue,
                                            query={'project_id': instance.id}),
         ])
 
         class TagKeyDeletionTask(ModelDeletionTask):
             def get_child_relations(self, instance):
                 # in bulk
-                model_list = (GroupTagValue, GroupTagKey, TagValue)
+                model_list = (models.GroupTagValue, models.GroupTagKey, models.TagValue)
                 relations = [
                     ModelRelation(m, {
                         'project_id': instance.project_id,
@@ -117,7 +147,7 @@ class LegacyTagStorage(TagStorage):
                     if instance.status != TagKeyStatus.DELETION_IN_PROGRESS:
                         instance.update(status=TagKeyStatus.DELETION_IN_PROGRESS)
 
-        deletion_manager.register(TagKey, TagKeyDeletionTask)
+        deletion_manager.register(models.TagKey, TagKeyDeletionTask)
 
     def setup_receivers(self):
         from sentry.signals import buffer_incr_complete
@@ -151,7 +181,7 @@ class LegacyTagStorage(TagStorage):
         #                           (async) buffer.incr(GroupTagKey):
         #                               create_or_update(GroupTagKey)
 
-        @buffer_incr_complete.connect(sender=TagValue, weak=False)
+        @buffer_incr_complete.connect(sender=models.TagValue, weak=False)
         def record_project_tag_count(filters, created, **kwargs):
             if not created:
                 return
@@ -159,7 +189,7 @@ class LegacyTagStorage(TagStorage):
             project_id = filters['project_id']
             key = filters['key']
 
-            buffer.incr(TagKey,
+            buffer.incr(models.TagKey,
                         columns={
                             'values_seen': 1,
                         },
@@ -168,7 +198,7 @@ class LegacyTagStorage(TagStorage):
                             'key': key,
                         })
 
-        @buffer_incr_complete.connect(sender=GroupTagValue, weak=False)
+        @buffer_incr_complete.connect(sender=models.GroupTagValue, weak=False)
         def record_group_tag_count(filters, created, extra, **kwargs):
             if not created:
                 return
@@ -177,7 +207,7 @@ class LegacyTagStorage(TagStorage):
             group_id = filters['group_id']
             key = filters['key']
 
-            buffer.incr(GroupTagKey,
+            buffer.incr(models.GroupTagKey,
                         columns={
                             'values_seen': 1,
                         },
@@ -188,34 +218,34 @@ class LegacyTagStorage(TagStorage):
                         })
 
     def create_tag_key(self, project_id, environment_id, key, **kwargs):
-        return TagKey.objects.create(project_id=project_id, key=key, **kwargs)
+        return models.TagKey.objects.create(project_id=project_id, key=key, **kwargs)
 
     def get_or_create_tag_key(self, project_id, environment_id, key, **kwargs):
-        return TagKey.objects.get_or_create(project_id=project_id, key=key, **kwargs)
+        return models.TagKey.objects.get_or_create(project_id=project_id, key=key, **kwargs)
 
     def create_tag_value(self, project_id, environment_id, key, value, **kwargs):
-        return TagValue.objects.create(project_id=project_id, key=key, value=value, **kwargs)
+        return models.TagValue.objects.create(project_id=project_id, key=key, value=value, **kwargs)
 
     def get_or_create_tag_value(self, project_id, environment_id,
                                 key, value, key_id=None, **kwargs):
-        return TagValue.objects.get_or_create(
+        return models.TagValue.objects.get_or_create(
             project_id=project_id, key=key, value=value, **kwargs)
 
     def create_group_tag_key(self, project_id, group_id, environment_id, key, **kwargs):
-        return GroupTagKey.objects.create(project_id=project_id, group_id=group_id,
-                                          key=key, **kwargs)
+        return models.GroupTagKey.objects.create(project_id=project_id, group_id=group_id,
+                                                 key=key, **kwargs)
 
     def get_or_create_group_tag_key(self, project_id, group_id, environment_id, key, **kwargs):
-        return GroupTagKey.objects.get_or_create(project_id=project_id, group_id=group_id,
-                                                 key=key, **kwargs)
+        return models.GroupTagKey.objects.get_or_create(project_id=project_id, group_id=group_id,
+                                                        key=key, **kwargs)
 
     def create_group_tag_value(self, project_id, group_id, environment_id, key, value, **kwargs):
-        return GroupTagValue.objects.create(
+        return models.GroupTagValue.objects.create(
             project_id=project_id, group_id=group_id, key=key, value=value, **kwargs)
 
     def get_or_create_group_tag_value(self, project_id, group_id,
                                       environment_id, key, value, **kwargs):
-        return GroupTagValue.objects.get_or_create(
+        return models.GroupTagValue.objects.get_or_create(
             project_id=project_id, group_id=group_id, key=key, value=value, **kwargs)
 
     def create_event_tags(self, project_id, group_id, environment_id,
@@ -236,8 +266,8 @@ class LegacyTagStorage(TagStorage):
                 # Tags are bulk inserted because this is an all-or-nothing situation.
                 # Either the whole transaction works, or it doesn't. There's no value
                 # in a partial success where we'd need to replay half of the rows.
-                EventTag.objects.bulk_create([
-                    EventTag(
+                models.EventTag.objects.bulk_create([
+                    models.EventTag(
                         project_id=project_id,
                         group_id=group_id,
                         event_id=event_id,
@@ -253,7 +283,7 @@ class LegacyTagStorage(TagStorage):
     def get_tag_key(self, project_id, environment_id, key, status=TagKeyStatus.VISIBLE):
         from sentry.tagstore.exceptions import TagKeyNotFound
 
-        qs = TagKey.objects.filter(
+        qs = models.TagKey.objects.filter(
             project_id=project_id,
             key=key,
         )
@@ -262,56 +292,62 @@ class LegacyTagStorage(TagStorage):
             qs = qs.filter(status=status)
 
         try:
-            return qs.get()
-        except TagKey.DoesNotExist:
+            instance = qs.get()
+        except models.TagKey.DoesNotExist:
             raise TagKeyNotFound
 
+        return transformers[models.TagKey](instance)
+
     def get_tag_keys(self, project_id, environment_id, status=TagKeyStatus.VISIBLE):
-        qs = TagKey.objects.filter(project_id=project_id)
+        qs = models.TagKey.objects.filter(project_id=project_id)
 
         if status is not None:
             qs = qs.filter(status=status)
 
-        return list(qs)
+        return list(map(transformers[models.TagKey], qs))
 
     def get_tag_value(self, project_id, environment_id, key, value):
         from sentry.tagstore.exceptions import TagValueNotFound
 
         try:
-            return TagValue.objects.get(
+            instance = models.TagValue.objects.get(
                 project_id=project_id,
                 key=key,
                 value=value
             )
-        except TagValue.DoesNotExist:
+        except models.TagValue.DoesNotExist:
             raise TagValueNotFound
 
+        return transformers[models.TagValue](instance)
+
     def get_tag_values(self, project_id, environment_id, key):
-        qs = TagValue.objects.filter(
+        qs = models.TagValue.objects.filter(
             project_id=project_id,
             key=key,
         )
 
-        return list(qs)
+        return list(map(transformers[models.TagValue], qs))
 
     def get_group_tag_key(self, project_id, group_id, environment_id, key):
         from sentry.tagstore.exceptions import GroupTagKeyNotFound
 
         try:
-            return GroupTagKey.objects.get(
+            instance = models.GroupTagKey.objects.get(
                 group_id=group_id,
                 key=key,
             )
-        except GroupTagKey.DoesNotExist:
+        except models.GroupTagKey.DoesNotExist:
             raise GroupTagKeyNotFound
 
+        return transformers[models.GroupTagKey](instance)
+
     def get_group_tag_keys(self, project_id, group_id, environment_id, limit=None):
-        qs = GroupTagKey.objects.filter(group_id=group_id)
+        qs = models.GroupTagKey.objects.filter(group_id=group_id)
 
         if limit is not None:
             qs = qs[:limit]
 
-        return list(qs)
+        return list(map(transformers[models.GroupTagKey], qs))
 
     def get_group_tag_value(self, project_id, group_id, environment_id, key, value):
         from sentry.tagstore.exceptions import GroupTagValueNotFound
@@ -330,55 +366,56 @@ class LegacyTagStorage(TagStorage):
         return value
 
     def get_group_tag_values(self, project_id, group_id, environment_id, key):
-        qs = GroupTagValue.objects.filter(
+        qs = models.GroupTagValue.objects.filter(
             group_id=group_id,
             key=key,
         )
 
-        return list(qs)
+        return list(map(transformers[models.GroupTagValue], qs))
 
     def get_group_list_tag_value(self, project_id, group_id_list, environment_id, key, value):
-        qs = GroupTagValue.objects.filter(
+        qs = models.GroupTagValue.objects.filter(
             group_id__in=group_id_list,
             key=key,
             value=value,
         )
-        return {result.group_id: result for result in qs}
+        t = transformers[models.GroupTagValue]
+        return {result.group_id: t(result) for result in qs}
 
     def delete_tag_key(self, project_id, key):
         from sentry.tagstore.tasks import delete_tag_key as delete_tag_key_task
 
-        tagkeys_qs = TagKey.objects.filter(
+        tagkeys_qs = models.TagKey.objects.filter(
             project_id=project_id,
             key=key,
         )
 
         deleted = []
         for tagkey in tagkeys_qs:
-            updated = TagKey.objects.filter(
+            updated = models.TagKey.objects.filter(
                 id=tagkey.id,
                 status=TagKeyStatus.VISIBLE,
             ).update(status=TagKeyStatus.PENDING_DELETION)
 
             if updated:
-                delete_tag_key_task.delay(object_id=tagkey.id, model=TagKey)
+                delete_tag_key_task.delay(object_id=tagkey.id, model=models.TagKey)
                 deleted.append(tagkey)
 
         return deleted
 
     def delete_all_group_tag_keys(self, project_id, group_id):
-        GroupTagKey.objects.filter(
+        models.GroupTagKey.objects.filter(
             group_id=group_id,
         ).delete()
 
     def delete_all_group_tag_values(self, project_id, group_id):
-        GroupTagValue.objects.filter(
+        models.GroupTagValue.objects.filter(
             group_id=group_id,
         ).delete()
 
     def incr_tag_value_times_seen(self, project_id, environment_id,
                                   key, value, extra=None, count=1):
-        buffer.incr(TagValue,
+        buffer.incr(models.TagValue,
                     columns={
                         'times_seen': count,
                     },
@@ -391,7 +428,7 @@ class LegacyTagStorage(TagStorage):
 
     def incr_group_tag_value_times_seen(self, project_id, group_id, environment_id,
                                         key, value, extra=None, count=1):
-        buffer.incr(GroupTagValue,
+        buffer.incr(models.GroupTagValue,
                     columns={
                         'times_seen': count,
                     },
@@ -404,7 +441,7 @@ class LegacyTagStorage(TagStorage):
 
     def get_group_event_ids(self, project_id, group_id, environment_id, tags):
         tagkeys = dict(
-            TagKey.objects.filter(
+            models.TagKey.objects.filter(
                 project_id=project_id,
                 key__in=tags.keys(),
                 status=TagKeyStatus.VISIBLE,
@@ -413,7 +450,7 @@ class LegacyTagStorage(TagStorage):
 
         tagvalues = {
             (t[1], t[2]): t[0]
-            for t in TagValue.objects.filter(
+            for t in models.TagValue.objects.filter(
                 reduce(or_, (Q(key=k, value=v)
                              for k, v in six.iteritems(tags))),
                 project_id=project_id,
@@ -435,7 +472,7 @@ class LegacyTagStorage(TagStorage):
         # get initial matches to start the filter
         k, v = tag_lookups.pop()
         matches = list(
-            EventTag.objects.filter(
+            models.EventTag.objects.filter(
                 key_id=k,
                 value_id=v,
                 group_id=group_id,
@@ -446,7 +483,7 @@ class LegacyTagStorage(TagStorage):
         # existing set, pruning it down each iteration
         for k, v in tag_lookups:
             matches = list(
-                EventTag.objects.filter(
+                models.EventTag.objects.filter(
                     key_id=k,
                     value_id=v,
                     event_id__in=matches,
@@ -459,7 +496,7 @@ class LegacyTagStorage(TagStorage):
         return matches
 
     def get_groups_user_counts(self, project_id, group_ids, environment_id):
-        qs = GroupTagKey.objects.filter(
+        qs = models.GroupTagKey.objects.filter(
             project_id=project_id,
             group_id__in=group_ids,
             key='sentry:user'
@@ -471,7 +508,7 @@ class LegacyTagStorage(TagStorage):
         if db.is_postgres():
             # This doesnt guarantee percentage is accurate, but it does ensure
             # that the query has a maximum cost
-            using = router.db_for_read(GroupTagValue)
+            using = router.db_for_read(models.GroupTagValue)
             cursor = connections[using].cursor()
             cursor.execute(
                 """
@@ -489,7 +526,7 @@ class LegacyTagStorage(TagStorage):
             return cursor.fetchone()[0] or 0
 
         cutoff = timezone.now() - timedelta(days=7)
-        return GroupTagValue.objects.filter(
+        return models.GroupTagValue.objects.filter(
             group_id=group_id,
             key=key,
             last_seen__gte=cutoff,
@@ -500,35 +537,41 @@ class LegacyTagStorage(TagStorage):
             # This doesnt guarantee percentage is accurate, but it does ensure
             # that the query has a maximum cost
             return list(
-                GroupTagValue.objects.raw(
-                    """
-                SELECT *
-                FROM (
-                    SELECT *
-                    FROM sentry_messagefiltervalue
-                    WHERE group_id = %%s
-                    AND key = %%s
-                    ORDER BY last_seen DESC
-                    LIMIT 10000
-                ) as a
-                ORDER BY times_seen DESC
-                LIMIT %d
-            """ % limit, [group_id, key]
+                map(
+                    transformers[models.GroupTagValue],
+                    models.GroupTagValue.objects.raw(
+                        """
+                        SELECT *
+                        FROM (
+                            SELECT *
+                            FROM sentry_messagefiltervalue
+                            WHERE group_id = %%s
+                            AND key = %%s
+                            ORDER BY last_seen DESC
+                            LIMIT 10000
+                        ) as a
+                        ORDER BY times_seen DESC
+                        LIMIT %d
+                        """ % limit, [group_id, key]
+                    )
                 )
             )
 
         cutoff = timezone.now() - timedelta(days=7)
         return list(
-            GroupTagValue.objects.filter(
-                group_id=group_id,
-                key=key,
-                last_seen__gte=cutoff,
-            ).order_by('-times_seen')[:limit]
+            map(
+                transformers[models.GroupTagValue],
+                models.GroupTagValue.objects.filter(
+                    group_id=group_id,
+                    key=key,
+                    last_seen__gte=cutoff,
+                ).order_by('-times_seen')[:limit]
+            )
         )
 
     def get_first_release(self, project_id, group_id):
         try:
-            first_release = GroupTagValue.objects.filter(
+            first_release = models.GroupTagValue.objects.filter(
                 project_id=project_id,
                 group_id=group_id,
                 key__in=('sentry:release', 'release'),
@@ -540,7 +583,7 @@ class LegacyTagStorage(TagStorage):
 
     def get_last_release(self, project_id, group_id):
         try:
-            last_release = GroupTagValue.objects.filter(
+            last_release = models.GroupTagValue.objects.filter(
                 project_id=project_id,
                 group_id=group_id,
                 key__in=('sentry:release', 'release'),
@@ -551,25 +594,37 @@ class LegacyTagStorage(TagStorage):
         return last_release.value
 
     def get_release_tags(self, project_ids, environment_id, versions):
-        return list(TagValue.objects.filter(
-            project_id__in=project_ids,
-            key='sentry:release',
-            value__in=versions,
-        ))
+        return list(
+            map(
+                transformers[models.TagValue],
+                models.TagValue.objects.filter(
+                    project_id__in=project_ids,
+                    key='sentry:release',
+                    value__in=versions,
+                ),
+            )
+        )
 
     def get_group_ids_for_users(self, project_ids, event_users, limit=100):
-        return list(GroupTagValue.objects.filter(
-            key='sentry:user',
-            value__in=[eu.tag_value for eu in event_users],
-            project_id__in=project_ids,
-        ).order_by('-last_seen').values_list('group_id', flat=True)[:limit])
+        return list(
+            models.GroupTagValue.objects.filter(
+                key='sentry:user',
+                value__in=[eu.tag_value for eu in event_users],
+                project_id__in=project_ids,
+            ).order_by('-last_seen').values_list('group_id', flat=True)[:limit]
+        )
 
     def get_group_tag_values_for_users(self, event_users, limit=100):
         tag_filters = [Q(value=eu.tag_value, project_id=eu.project_id) for eu in event_users]
-        return list(GroupTagValue.objects.filter(
-            reduce(or_, tag_filters),
-            key='sentry:user',
-        ).order_by('-last_seen')[:limit])
+        return list(
+            map(
+                transformers[models.GroupTagValue],
+                models.GroupTagValue.objects.filter(
+                    reduce(or_, tag_filters),
+                    key='sentry:user',
+                ).order_by('-last_seen')[:limit],
+            )
+        )
 
     def get_group_ids_for_search_filter(
             self, project_id, environment_id, tags, candidates=None, limit=1000):
@@ -589,14 +644,14 @@ class LegacyTagStorage(TagStorage):
         # existing set, pruning it down each iteration
         for k, v in tag_lookups:
             if v != ANY:
-                base_qs = GroupTagValue.objects.filter(
+                base_qs = models.GroupTagValue.objects.filter(
                     key=k,
                     value=v,
                     project_id=project_id,
                 )
 
             else:
-                base_qs = GroupTagValue.objects.filter(
+                base_qs = models.GroupTagValue.objects.filter(
                     key=k,
                     project_id=project_id,
                 ).distinct()
@@ -615,14 +670,14 @@ class LegacyTagStorage(TagStorage):
         return matches
 
     def update_group_tag_key_values_seen(self, project_id, group_ids):
-        gtk_qs = GroupTagKey.objects.filter(
+        gtk_qs = models.GroupTagKey.objects.filter(
             project_id=project_id,
             group_id__in=group_ids
         )
 
         for instance in gtk_qs:
             instance.update(
-                values_seen=GroupTagValue.objects.filter(
+                values_seen=models.GroupTagValue.objects.filter(
                     project_id=instance.project_id,
                     group_id=instance.group_id,
                     key=instance.key,
@@ -630,7 +685,7 @@ class LegacyTagStorage(TagStorage):
             )
 
     def get_tag_value_qs(self, project_id, environment_id, key, query=None):
-        queryset = TagValue.objects.filter(
+        queryset = models.TagValue.objects.filter(
             project_id=project_id,
             key=key,
         )
@@ -641,7 +696,7 @@ class LegacyTagStorage(TagStorage):
         return queryset
 
     def get_group_tag_value_qs(self, project_id, group_id, environment_id, key, value=None):
-        queryset = GroupTagValue.objects.filter(key=key)
+        queryset = models.GroupTagValue.objects.filter(key=key)
 
         if isinstance(group_id, collections.Iterable):
             queryset = queryset.filter(group_id__in=group_id)
@@ -657,7 +712,7 @@ class LegacyTagStorage(TagStorage):
         raise NotImplementedError  # there is no index that can appopriate satisfy this query
 
     def update_group_for_events(self, project_id, event_ids, destination_id):
-        return EventTag.objects.filter(
+        return models.EventTag.objects.filter(
             project_id=project_id,
             event_id__in=event_ids,
         ).update(group_id=destination_id)
diff --git a/src/sentry/tagstore/legacy/models/grouptagkey.py b/src/sentry/tagstore/legacy/models/grouptagkey.py
index 90a70b704e..73b7a178ca 100644
--- a/src/sentry/tagstore/legacy/models/grouptagkey.py
+++ b/src/sentry/tagstore/legacy/models/grouptagkey.py
@@ -7,11 +7,8 @@ sentry.tagstore.legacy.models.grouptagkey
 """
 from __future__ import absolute_import
 
-import six
-
 from django.db import models, router, transaction, DataError
 
-from sentry.api.serializers import Serializer, register
 from sentry.constants import MAX_TAG_KEY_LENGTH
 from sentry.db.models import (
     Model, BoundedPositiveIntegerField, BaseManager, sane_repr
@@ -57,27 +54,3 @@ class GroupTagKey(Model):
         except DataError:
             # it's possible to hit an out of range value for counters
             pass
-
-
-@register(GroupTagKey)
-class GroupTagKeySerializer(Serializer):
-    def get_attrs(self, item_list, user):
-        from sentry import tagstore
-
-        result = {}
-        for item in item_list:
-            key = tagstore.get_standardized_key(item.key)
-            result[item] = {
-                'name': tagstore.get_tag_key_label(item.key),
-                'key': key,
-            }
-
-        return result
-
-    def serialize(self, obj, attrs, user):
-        return {
-            'id': six.text_type(obj.id),
-            'name': attrs['name'],
-            'key': attrs['key'],
-            'uniqueValues': obj.values_seen,
-        }
diff --git a/src/sentry/tagstore/legacy/models/grouptagvalue.py b/src/sentry/tagstore/legacy/models/grouptagvalue.py
index bd6fd6bad7..4a4cf70d4c 100644
--- a/src/sentry/tagstore/legacy/models/grouptagvalue.py
+++ b/src/sentry/tagstore/legacy/models/grouptagvalue.py
@@ -7,12 +7,9 @@ sentry.tagstore.legacy.models.grouptagvalue
 """
 from __future__ import absolute_import
 
-import six
-
 from django.db import models, router, transaction, DataError
 from django.utils import timezone
 
-from sentry.api.serializers import Serializer, register
 from sentry.constants import MAX_TAG_KEY_LENGTH, MAX_TAG_VALUE_LENGTH
 from sentry.db.models import (
     Model, BoundedPositiveIntegerField, BaseManager, sane_repr)
@@ -66,30 +63,3 @@ class GroupTagValue(Model):
         except DataError:
             # it's possible to hit an out of range value for counters
             pass
-
-
-@register(GroupTagValue)
-class GroupTagValueSerializer(Serializer):
-    def get_attrs(self, item_list, user):
-        from sentry import tagstore
-
-        result = {}
-        for item in item_list:
-            result[item] = {
-                'name': tagstore.get_tag_value_label(item.key, item.value),
-            }
-
-        return result
-
-    def serialize(self, obj, attrs, user):
-        from sentry import tagstore
-
-        return {
-            'id': six.text_type(obj.id),
-            'name': attrs['name'],
-            'key': tagstore.get_standardized_key(obj.key),
-            'value': obj.value,
-            'count': obj.times_seen,
-            'lastSeen': obj.last_seen,
-            'firstSeen': obj.first_seen,
-        }
diff --git a/src/sentry/tagstore/legacy/models/tagkey.py b/src/sentry/tagstore/legacy/models/tagkey.py
index ba164ab542..78db1e9f4c 100644
--- a/src/sentry/tagstore/legacy/models/tagkey.py
+++ b/src/sentry/tagstore/legacy/models/tagkey.py
@@ -8,12 +8,9 @@ sentry.tagstore.legacy.models.tagkey
 
 from __future__ import absolute_import, print_function
 
-import six
-
 from django.db import models
 from django.utils.translation import ugettext_lazy as _
 
-from sentry.api.serializers import Serializer, register
 from sentry.tagstore import TagKeyStatus
 from sentry.constants import MAX_TAG_KEY_LENGTH
 from sentry.db.models import (Model, BoundedPositiveIntegerField, sane_repr)
@@ -54,16 +51,3 @@ class TagKey(Model):
         return {
             'key': self.key,
         }
-
-
-@register(TagKey)
-class TagKeySerializer(Serializer):
-    def serialize(self, obj, attrs, user):
-        from sentry import tagstore
-
-        return {
-            'id': six.text_type(obj.id),
-            'key': tagstore.get_standardized_key(obj.key),
-            'name': tagstore.get_tag_key_label(obj.key),
-            'uniqueValues': obj.values_seen,
-        }
diff --git a/src/sentry/tagstore/legacy/models/tagvalue.py b/src/sentry/tagstore/legacy/models/tagvalue.py
index 995ad83997..aa08f5d9ad 100644
--- a/src/sentry/tagstore/legacy/models/tagvalue.py
+++ b/src/sentry/tagstore/legacy/models/tagvalue.py
@@ -7,12 +7,9 @@ sentry.tagstore.legacy.models.tagvalue
 """
 from __future__ import absolute_import, print_function
 
-import six
-
 from django.db import models
 from django.utils import timezone
 
-from sentry.api.serializers import Serializer, register
 from sentry.constants import MAX_TAG_KEY_LENGTH, MAX_TAG_VALUE_LENGTH
 from sentry.db.models import (
     Model, BoundedPositiveIntegerField, GzippedDictField, BaseManager, sane_repr
@@ -49,29 +46,3 @@ class TagValue(Model):
         from sentry import tagstore
 
         return tagstore.get_tag_value_label(self.key, self.value)
-
-
-@register(TagValue)
-class TagValueSerializer(Serializer):
-    def get_attrs(self, item_list, user):
-        from sentry import tagstore
-
-        result = {}
-        for item in item_list:
-            result[item] = {
-                'name': tagstore.get_tag_value_label(item.key, item.value),
-            }
-        return result
-
-    def serialize(self, obj, attrs, user):
-        from sentry import tagstore
-
-        return {
-            'id': six.text_type(obj.id),
-            'key': tagstore.get_standardized_key(obj.key),
-            'name': attrs['name'],
-            'value': obj.value,
-            'count': obj.times_seen,
-            'lastSeen': obj.last_seen,
-            'firstSeen': obj.first_seen,
-        }
diff --git a/src/sentry/tagstore/types.py b/src/sentry/tagstore/types.py
new file mode 100644
index 0000000000..0e543f7504
--- /dev/null
+++ b/src/sentry/tagstore/types.py
@@ -0,0 +1,116 @@
+from __future__ import absolute_import
+
+from sentry.tagstore.base import TagKeyStatus
+
+
+class TagType(object):
+    def __repr__(self):
+        return '<%s: %s>' % (
+            type(self).__name__,
+            ', '.join('%s=%r' % (name, getattr(self, name)) for name in self.__slots__),
+        )
+
+    def __hash__(self):
+        return hash(tuple([getattr(self, name) for name in self.__slots__]))
+
+    def __eq__(self, other):
+        return type(self) == type(other) and \
+            all(getattr(self, name) == getattr(other, name) for name in self.__slots__)
+
+
+class TagKey(TagType):
+    __slots__ = ['key', 'values_seen', 'status']
+
+    def __init__(self, key, values_seen, status=TagKeyStatus.VISIBLE):
+        self.key = key
+        self.values_seen = values_seen
+        self.status = status
+
+
+class TagValue(TagType):
+    __slots__ = ['key', 'value', 'times_seen', 'first_seen', 'last_seen']
+
+    def __init__(self, key, value, times_seen, first_seen, last_seen):
+        self.key = key
+        self.value = value
+        self.times_seen = times_seen
+        self.first_seen = first_seen
+        self.last_seen = last_seen
+
+
+class GroupTagKey(TagType):
+    __slots__ = ['group_id', 'key', 'values_seen']
+
+    def __init__(self, group_id, key, values_seen):
+        self.group_id = group_id
+        self.key = key
+        self.values_seen = values_seen
+
+
+class GroupTagValue(TagType):
+    __slots__ = ['group_id', 'key', 'value', 'times_seen', 'first_seen', 'last_seen']
+
+    def __init__(self, group_id, key, value, times_seen, first_seen, last_seen):
+        self.group_id = group_id
+        self.key = key
+        self.value = value
+        self.times_seen = times_seen
+        self.first_seen = first_seen
+        self.last_seen = last_seen
+
+
+from sentry.api.serializers import Serializer, register
+
+
+@register(TagKey)
+class TagKeySerializer(Serializer):
+    def serialize(self, obj, attrs, user):
+        from sentry import tagstore
+
+        return {
+            'key': tagstore.get_standardized_key(obj.key),
+            'name': tagstore.get_tag_key_label(obj.key),
+            'uniqueValues': obj.values_seen,
+        }
+
+
+@register(TagValue)
+class TagValueSerializer(Serializer):
+    def serialize(self, obj, attrs, user):
+        from sentry import tagstore
+
+        return {
+            'key': tagstore.get_standardized_key(obj.key),
+            'name': tagstore.get_tag_value_label(obj.key, obj.value),
+            'value': obj.value,
+            'count': obj.times_seen,
+            'lastSeen': obj.last_seen,
+            'firstSeen': obj.first_seen,
+        }
+
+
+@register(GroupTagKey)
+class GroupTagKeySerializer(Serializer):
+    def serialize(self, obj, attrs, user):
+        from sentry import tagstore
+
+        return {
+            'name': tagstore.get_tag_key_label(obj.key),
+            'key': tagstore.get_standardized_key(obj.key),
+            'uniqueValues': obj.values_seen,
+        }
+
+
+@register(GroupTagValue)
+class GroupTagValueSerializer(Serializer):
+    def serialize(self, obj, attrs, user):
+        from sentry import tagstore
+
+        return {
+            'name': tagstore.get_tag_value_label(obj.key, obj.value),
+            'key': tagstore.get_standardized_key(obj.key),
+            'value': obj.value,
+            'count': obj.times_seen,
+            'lastSeen': obj.last_seen,
+            'firstSeen': obj.first_seen,
+        }
diff --git a/tests/sentry/api/endpoints/test_group_tagkey_details.py b/tests/sentry/api/endpoints/test_group_tagkey_details.py
index 9afbfc7c18..e48756cd15 100644
--- a/tests/sentry/api/endpoints/test_group_tagkey_details.py
+++ b/tests/sentry/api/endpoints/test_group_tagkey_details.py
@@ -47,7 +47,6 @@ class GroupTagDetailsTest(APITestCase):
         url = '/api/0/issues/{}/tags/{}/'.format(group.id, tagkey.key)
         response = self.client.get(url, format='json')
         assert response.status_code == 200, response.content
-        assert response.data['id'] == six.text_type(tagkey.id)
         assert response.data['key'] == six.text_type(tagkey.key)
         assert response.data['uniqueValues'] == 1
         assert response.data['totalValues'] == 3
diff --git a/tests/sentry/api/endpoints/test_project_tagkey_details.py b/tests/sentry/api/endpoints/test_project_tagkey_details.py
index 54606bfcc8..7c8d844505 100644
--- a/tests/sentry/api/endpoints/test_project_tagkey_details.py
+++ b/tests/sentry/api/endpoints/test_project_tagkey_details.py
@@ -1,7 +1,6 @@
 from __future__ import absolute_import
 
 import mock
-import six
 
 from django.conf import settings
 from django.core.urlresolvers import reverse
@@ -35,7 +34,6 @@ class ProjectTagKeyDetailsTest(APITestCase):
         response = self.client.get(url)
 
         assert response.status_code == 200
-        assert response.data['id'] == six.text_type(tagkey.id)
         assert response.data['uniqueValues'] == tagkey.values_seen
 
 
diff --git a/tests/sentry/api/serializers/test_grouptagkey.py b/tests/sentry/api/serializers/test_grouptagkey.py
index c22d496d30..e63be1463b 100644
--- a/tests/sentry/api/serializers/test_grouptagkey.py
+++ b/tests/sentry/api/serializers/test_grouptagkey.py
@@ -1,28 +1,19 @@
 from __future__ import absolute_import
 
-import six
-
-from sentry import tagstore
 from sentry.api.serializers import serialize
+from sentry.tagstore.types import GroupTagKey
 from sentry.testutils import TestCase
 
 
 class GroupTagKeySerializerTest(TestCase):
     def test(self):
         user = self.create_user()
-        project = self.create_project()
-        tagkey = tagstore.create_tag_key(
-            project_id=project.id,
-            environment_id=self.environment.id,
-            key='key'
-        )
-        grouptagkey = tagstore.create_group_tag_key(
-            project_id=project.id,
-            group_id=self.create_group(project=project).id,
-            environment_id=self.environment.id,
-            key=tagkey.key
+        grouptagkey = GroupTagKey(
+            group_id=0,
+            key='key',
+            values_seen=1,
         )
 
         result = serialize(grouptagkey, user)
-        assert result['id'] == six.text_type(grouptagkey.id)
         assert result['key'] == 'key'
+        assert result['uniqueValues'] == 1
diff --git a/tests/sentry/api/serializers/test_grouptagvalue.py b/tests/sentry/api/serializers/test_grouptagvalue.py
index 00a7c4b832..bb67c5a769 100644
--- a/tests/sentry/api/serializers/test_grouptagvalue.py
+++ b/tests/sentry/api/serializers/test_grouptagvalue.py
@@ -2,38 +2,26 @@
 
 from __future__ import absolute_import
 
-import six
+from datetime import datetime
 
-from sentry import tagstore
 from sentry.api.serializers import serialize
-from sentry.models import EventUser
+from sentry.tagstore.types import GroupTagValue
 from sentry.testutils import TestCase
 
 
 class GroupTagValueSerializerTest(TestCase):
     def test_with_user(self):
         user = self.create_user()
-        project = self.create_project()
-        euser = EventUser.objects.create(
-            project_id=project.id,
-            email='foo@example.com',
-        )
-        tagvalue = tagstore.create_tag_value(
-            project_id=project.id,
-            environment_id=self.environment.id,
+        grouptagvalue = GroupTagValue(
+            group_id=0,
             key='sentry:user',
-            value=euser.tag_value,
-        )
-        grouptagvalue = tagstore.create_group_tag_value(
-            project_id=project.id,
-            group_id=self.create_group(project=project).id,
-            environment_id=self.environment.id,
-            key=tagvalue.key,
-            value=tagvalue.value,
+            value='username:ted',
+            times_seen=1,
+            first_seen=datetime(2018, 1, 1),
+            last_seen=datetime(2018, 1, 1),
         )
 
         result = serialize(grouptagvalue, user)
-        assert result['id'] == six.text_type(grouptagvalue.id)
         assert result['key'] == 'user'
-        assert result['value'] == grouptagvalue.value
-        assert result['name'] == euser.get_label()
+        assert result['value'] == 'username:ted'
+        assert result['name'] == 'ted'
diff --git a/tests/sentry/api/serializers/test_tagvalue.py b/tests/sentry/api/serializers/test_tagvalue.py
index 28a32e13b4..a8bb5a3acb 100644
--- a/tests/sentry/api/serializers/test_tagvalue.py
+++ b/tests/sentry/api/serializers/test_tagvalue.py
@@ -2,63 +2,40 @@
 
 from __future__ import absolute_import
 
-import six
+from datetime import datetime
 
-from sentry import tagstore
 from sentry.api.serializers import serialize
-from sentry.models import EventUser
+from sentry.tagstore.types import TagValue
 from sentry.testutils import TestCase
 
 
 class TagValueSerializerTest(TestCase):
     def test_with_user(self):
         user = self.create_user()
-        project = self.create_project()
-        euser = EventUser.objects.create(
-            project_id=project.id,
-            email='foo@example.com',
-        )
-        tagvalue = tagstore.create_tag_value(
-            project_id=project.id,
-            environment_id=self.environment.id,
-            key='sentry:user',
-            value=euser.tag_value,
-        )
-
-        result = serialize(tagvalue, user)
-        assert result['id'] == six.text_type(tagvalue.id)
-        assert result['key'] == 'user'
-        assert result['value'] == tagvalue.value
-        assert result['name'] == euser.get_label()
-
-    def test_basic(self):
-        user = self.create_user()
-        project = self.create_project()
-        tagvalue = tagstore.create_tag_value(
-            project_id=project.id,
-            environment_id=self.environment.id,
+        tagvalue = TagValue(
             key='sentry:user',
-            value='email:foo@example.com',
+            value='username:ted',
+            times_seen=1,
+            first_seen=datetime(2018, 1, 1),
+            last_seen=datetime(2018, 1, 1),
         )
 
         result = serialize(tagvalue, user)
-        assert result['id'] == six.text_type(tagvalue.id)
         assert result['key'] == 'user'
-        assert result['value'] == tagvalue.value
-        assert result['name'] == tagvalue.get_label()
+        assert result['value'] == 'username:ted'
+        assert result['name'] == 'ted'
 
     def test_release(self):
         user = self.create_user()
-        project = self.create_project()
-        tagvalue = tagstore.create_tag_value(
-            project_id=project.id,
-            environment_id=self.environment.id,
+        tagvalue = TagValue(
             key='sentry:release',
             value='df84bccbb23ca15f2868be1f2a5f7c7a6464fadd',
+            times_seen=1,
+            first_seen=datetime(2018, 1, 1),
+            last_seen=datetime(2018, 1, 1),
         )
 
         result = serialize(tagvalue, user)
-        assert result['id'] == six.text_type(tagvalue.id)
         assert result['key'] == 'release'
-        assert result['value'] == tagvalue.value
-        assert result['name'] == tagvalue.get_label()
+        assert result['value'] == 'df84bccbb23ca15f2868be1f2a5f7c7a6464fadd'
+        assert result['name'] == 'df84bcc'
diff --git a/tests/sentry/manager/tests.py b/tests/sentry/manager/tests.py
index 72d37636ae..e99a82284b 100644
--- a/tests/sentry/manager/tests.py
+++ b/tests/sentry/manager/tests.py
@@ -20,16 +20,25 @@ class SentryManagerTest(TestCase):
         environment = self.create_environment()
 
         with self.tasks():
-            Group.objects.add_tags(group, environment, tags=(
-                ('foo', 'bar'), ('foo', 'baz'), ('biz', 'boz')))
+            Group.objects.add_tags(
+                group,
+                environment,
+                tags=[
+                    ('foo', 'bar'),
+                    ('foo', 'baz'),
+                    ('biz', 'boz'),
+                ],
+            )
 
         results = sorted(
             tagstore.get_group_tag_values(
                 group.project_id,
                 group.id,
                 environment_id=None,
-                key='foo'),
-            key=lambda x: x.id)
+                key='foo',
+            ),
+            key=lambda x: x.value,
+        )
         assert len(results) == 2
         res = results[0]
         self.assertEquals(res.value, 'bar')
@@ -38,13 +47,12 @@ class SentryManagerTest(TestCase):
         self.assertEquals(res.value, 'baz')
         self.assertEquals(res.times_seen, 1)
 
-        results = sorted(
-            tagstore.get_group_tag_values(
-                group.project_id,
-                group.id,
-                environment_id=None,
-                key='biz'),
-            key=lambda x: x.id)
+        results = tagstore.get_group_tag_values(
+            group.project_id,
+            group.id,
+            environment_id=None,
+            key='biz'
+        )
         assert len(results) == 1
         res = results[0]
         self.assertEquals(res.value, 'boz')
diff --git a/tests/sentry/tasks/post_process/tests.py b/tests/sentry/tasks/post_process/tests.py
index abe04743fe..3190b51753 100644
--- a/tests/sentry/tasks/post_process/tests.py
+++ b/tests/sentry/tasks/post_process/tests.py
@@ -7,7 +7,6 @@ from django.utils import timezone
 from mock import Mock, patch
 
 from sentry import tagstore
-from sentry.tagstore.models import EventTag
 from sentry.models import Group, GroupSnooze, GroupStatus, ServiceHook
 from sentry.testutils import TestCase
 from sentry.tasks.merge import merge_group
@@ -236,36 +235,12 @@ class IndexEventTagsTest(TestCase):
                 tags=[('foo', 'bar'), ('biz', 'baz')],
             )
 
-        tags = list(EventTag.objects.filter(
-            event_id=event.id,
-        ).values_list('key_id', 'value_id'))
-        assert len(tags) == 2
-
-        tagkey = tagstore.get_tag_key(
-            project_id=self.project.id,
-            environment_id=self.environment.id,
-            key='foo',
-        )
-        tagvalue = tagstore.get_tag_value(
-            project_id=self.project.id,
-            environment_id=self.environment.id,
-            key='foo',
-            value='bar',
-        )
-        assert (tagkey.id, tagvalue.id) in tags
-
-        tagkey = tagstore.get_tag_key(
-            project_id=self.project.id,
-            environment_id=self.environment.id,
-            key='biz',
-        )
-        tagvalue = tagstore.get_tag_value(
-            project_id=self.project.id,
-            environment_id=self.environment.id,
-            key='biz',
-            value='baz',
-        )
-        assert (tagkey.id, tagvalue.id) in tags
+        assert tagstore.get_group_event_ids(
+            self.project.id,
+            group.id,
+            self.environment.id,
+            {'foo': 'bar', 'biz': 'baz'},
+        ) == [event.id]
 
         # ensure it safely handles repeat runs
         with self.tasks():
@@ -278,7 +253,9 @@ class IndexEventTagsTest(TestCase):
                 tags=[('foo', 'bar'), ('biz', 'baz')],
             )
 
-        queryset = EventTag.objects.filter(
-            event_id=event.id,
-        )
-        assert queryset.count() == 2
+        assert tagstore.get_group_event_ids(
+            self.project.id,
+            group.id,
+            self.environment.id,
+            {'foo': 'bar', 'biz': 'baz'},
+        ) == [event.id]

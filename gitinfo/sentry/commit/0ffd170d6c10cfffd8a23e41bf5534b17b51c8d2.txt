commit 0ffd170d6c10cfffd8a23e41bf5534b17b51c8d2
Author: Evan Purkhiser <evanpurkhiser@gmail.com>
Date:   Wed Oct 9 14:21:42 2019 -0700

    ref(ts): Convert locale / translations (#15008)
    
    * Adds documentation to each translation function to make it much more
       clear how to use them
    
     * Includes some minor variable name cleanup, since these functions
       themselves are already pretty cryptic, this should help future
       readers to understand better what's going on here.
    
     * The types are mostly correct, gettext's return type could potentially
       be a React.ReactNode, however we rarely use it in that way and
       typically just expect a string back.

diff --git a/src/sentry/static/sentry/app/__mocks__/translations.jsx b/src/sentry/static/sentry/app/__mocks__/translations.tsx
similarity index 75%
rename from src/sentry/static/sentry/app/__mocks__/translations.jsx
rename to src/sentry/static/sentry/app/__mocks__/translations.tsx
index f68a885bf2..8fde1193d8 100644
--- a/src/sentry/static/sentry/app/__mocks__/translations.jsx
+++ b/src/sentry/static/sentry/app/__mocks__/translations.tsx
@@ -1,4 +1,4 @@
-export function getTranslations(language) {
+export function getTranslations() {
   return {
     '': {
       domain: 'the_domain',
diff --git a/src/sentry/static/sentry/app/components/events/eventAttachments.tsx b/src/sentry/static/sentry/app/components/events/eventAttachments.tsx
index 5cb1a96ea9..dcaaec6f8d 100644
--- a/src/sentry/static/sentry/app/components/events/eventAttachments.tsx
+++ b/src/sentry/static/sentry/app/components/events/eventAttachments.tsx
@@ -114,8 +114,9 @@ class EventAttachments extends React.Component<Props, State> {
                           href={downloadUrl || ''}
                           disabled={!downloadUrl}
                           title={
-                            !downloadUrl &&
-                            t('Insufficient permissions to download attachments')
+                            !downloadUrl
+                              ? t('Insufficient permissions to download attachments')
+                              : undefined
                           }
                         >
                           {t('Download')}
diff --git a/src/sentry/static/sentry/app/locale.jsx b/src/sentry/static/sentry/app/locale.jsx
deleted file mode 100644
index 37baa49141..0000000000
--- a/src/sentry/static/sentry/app/locale.jsx
+++ /dev/null
@@ -1,249 +0,0 @@
-/*eslint no-cond-assign:0*/
-import Jed from 'jed';
-import React from 'react';
-import {sprintf} from 'sprintf-js';
-import _ from 'lodash';
-import {css} from 'react-emotion';
-
-import {getTranslations} from 'app/translations';
-
-let LOCALE_DEBUG = false;
-
-const sessionStorage = window.sessionStorage;
-if (sessionStorage && sessionStorage.getItem('localeDebug') === '1') {
-  LOCALE_DEBUG = true;
-}
-
-const markerCss = css`
-  background: #ff801790;
-  outline: 2px solid #ff801790;
-`;
-
-export function setLocaleDebug(value) {
-  sessionStorage.setItem('localeDebug', value ? '1' : '0');
-  /*eslint no-console:0*/
-  console.log(`Locale debug is: ${value ? 'on' : 'off'}. Reload page to apply changes!`);
-}
-
-export function toggleLocaleDebug(value) {
-  const currentValue = sessionStorage.getItem('localeDebug');
-  setLocaleDebug(currentValue !== '1');
-  window.location.reload();
-}
-
-let i18n = null;
-
-export function setLocale(locale) {
-  const translations = getTranslations(locale);
-  i18n = new Jed({
-    domain: 'sentry',
-    missing_key_callback: function(key) {},
-    locale_data: {
-      sentry: translations,
-    },
-  });
-}
-
-setLocale('en');
-
-function formatForReact(formatString, args) {
-  const rv = [];
-  let cursor = 0;
-
-  // always re-parse, do not cache, because we change the match
-  sprintf.parse(formatString).forEach((match, idx) => {
-    if (_.isString(match)) {
-      rv.push(match);
-    } else {
-      let arg = null;
-      if (match[2]) {
-        arg = args[0][match[2][0]];
-      } else if (match[1]) {
-        arg = args[parseInt(match[1], 10) - 1];
-      } else {
-        arg = args[cursor++];
-      }
-
-      // this points to a react element!
-      if (React.isValidElement(arg)) {
-        rv.push(React.cloneElement(arg, {key: idx}));
-        // not a react element, fuck around with it so that sprintf.format
-        // can format it for us.  We make sure match[2] is null so that we
-        // do not go down the object path, and we set match[1] to the first
-        // index and then pass an array with two items in.
-      } else {
-        match[2] = null;
-        match[1] = 1;
-        rv.push(<span key={idx++}>{sprintf.format([match], [null, arg])}</span>);
-      }
-    }
-  });
-
-  return rv;
-}
-
-function argsInvolveReact(args) {
-  if (args.some(React.isValidElement)) {
-    return true;
-  }
-  if (args.length === 1 && _.isObject(args[0])) {
-    return Object.keys(args[0]).some(key => {
-      return React.isValidElement(args[0][key]);
-    });
-  }
-  return false;
-}
-
-export function parseComponentTemplate(string) {
-  const rv = {};
-
-  function process(startPos, group, inGroup) {
-    const regex = /\[(.*?)(:|\])|\]/g;
-    let match;
-    const buf = [];
-    let satisfied = false;
-
-    let pos = (regex.lastIndex = startPos);
-    while ((match = regex.exec(string)) !== null) {
-      const substr = string.substr(pos, match.index - pos);
-      if (substr !== '') {
-        buf.push(substr);
-      }
-
-      if (match[0] === ']') {
-        if (inGroup) {
-          satisfied = true;
-          break;
-        } else {
-          pos = regex.lastIndex;
-          continue;
-        }
-      }
-
-      if (match[2] === ']') {
-        pos = regex.lastIndex;
-      } else {
-        pos = regex.lastIndex = process(regex.lastIndex, match[1], true);
-      }
-      buf.push({group: match[1]});
-    }
-
-    let endPos = regex.lastIndex;
-    if (!satisfied) {
-      const rest = string.substr(pos);
-      if (rest) {
-        buf.push(rest);
-      }
-      endPos = string.length;
-    }
-
-    rv[group] = buf;
-    return endPos;
-  }
-
-  process(0, 'root', false);
-
-  return rv;
-}
-
-export function renderComponentTemplate(template, components) {
-  let idx = 0;
-  function renderGroup(group) {
-    const children = [];
-
-    (template[group] || []).forEach(item => {
-      if (_.isString(item)) {
-        children.push(<span key={idx++}>{item}</span>);
-      } else {
-        children.push(renderGroup(item.group));
-      }
-    });
-
-    // in case we cannot find our component, we call back to an empty
-    // span so that stuff shows up at least.
-    let reference = components[group] || <span key={idx++} />;
-    if (!React.isValidElement(reference)) {
-      reference = <span key={idx++}>{reference}</span>;
-    }
-
-    if (children.length > 0) {
-      return React.cloneElement(reference, {key: idx++}, children);
-    } else {
-      return React.cloneElement(reference, {key: idx++});
-    }
-  }
-
-  return renderGroup('root');
-}
-
-function mark(rv) {
-  if (!LOCALE_DEBUG) {
-    return rv;
-  }
-
-  const proxy = {
-    $$typeof: Symbol.for('react.element'),
-    type: 'span',
-    key: null,
-    ref: null,
-    props: {
-      className: markerCss,
-      children: _.isArray(rv) ? rv : [rv],
-    },
-    _owner: null,
-    _store: {},
-  };
-
-  proxy.toString = function() {
-    return '✅' + rv + '✅';
-  };
-
-  return proxy;
-}
-
-export function format(formatString, args) {
-  if (argsInvolveReact(args)) {
-    return formatForReact(formatString, args);
-  } else {
-    return sprintf(formatString, ...args);
-  }
-}
-
-export function gettext(string, ...args) {
-  let rv = i18n.gettext(string);
-  if (args.length > 0) {
-    rv = format(rv, args);
-  }
-  return mark(rv);
-}
-
-export function ngettext(singular, plural, ...args) {
-  let countArg;
-  if (args.length > 0) {
-    countArg = args[0] || 0;
-    args = [countArg.toLocaleString(), ...args.slice(1)];
-  } else {
-    countArg = 0;
-  }
-
-  return mark(format(i18n.ngettext(singular, plural, countArg), args));
-}
-
-/* special form of gettext where you can render nested react
-   components in template strings.  Example:
-
-      gettextComponentTemplate('Welcome. Click [link:here]', {
-        root: <p/>,
-        link: <a href="#" />
-      });
-
-   the root string is always called "root", the rest is prefixed
-   with the name in the brackets */
-export function gettextComponentTemplate(template, components) {
-  const tmpl = parseComponentTemplate(i18n.gettext(template));
-  return mark(renderComponentTemplate(tmpl, components));
-}
-
-export const t = gettext;
-export const tn = ngettext;
-export const tct = gettextComponentTemplate;
diff --git a/src/sentry/static/sentry/app/locale.tsx b/src/sentry/static/sentry/app/locale.tsx
new file mode 100644
index 0000000000..091f98ef4b
--- /dev/null
+++ b/src/sentry/static/sentry/app/locale.tsx
@@ -0,0 +1,353 @@
+import React from 'react';
+import Jed from 'jed';
+import {sprintf} from 'sprintf-js';
+import {isString, isArray, isObject} from 'lodash';
+import {css} from 'react-emotion';
+
+import {getTranslations} from 'app/translations';
+
+const markerCss = css`
+  background: #ff801790;
+  outline: 2px solid #ff801790;
+`;
+
+const sessionStorage = window.sessionStorage;
+const LOCALE_DEBUG = sessionStorage && sessionStorage.getItem('localeDebug') === '1';
+
+export function setLocaleDebug(value: boolean) {
+  sessionStorage.setItem('localeDebug', value ? '1' : '0');
+  // eslint-disable-next-line no-console
+  console.log(`Locale debug is: ${value ? 'on' : 'off'}. Reload page to apply changes!`);
+}
+
+export function toggleLocaleDebug() {
+  const currentValue = sessionStorage.getItem('localeDebug');
+  setLocaleDebug(currentValue !== '1');
+  window.location.reload();
+}
+
+/**
+ * Global Jed locale object loaded with translations via setLocale
+ */
+let i18n: any = null;
+
+/**
+ * Set the current application locale.
+ *
+ * NOTE: This MUST be called early in the application before calls to any
+ * translation functions, as this mutates a singleton translation object used
+ * to lookup translations at runtime.
+ */
+export function setLocale(locale: string) {
+  const translations = getTranslations(locale);
+  i18n = new Jed({
+    domain: 'sentry',
+    missing_key_callback: () => {},
+    locale_data: {
+      sentry: translations,
+    },
+  });
+}
+
+setLocale('en');
+
+type FormatArg = ComponentMap | React.ReactNode;
+
+/**
+ * printf style string formatting which render as react nodes.
+ */
+function formatForReact(formatString: string, args: FormatArg[]) {
+  const nodes: React.ReactNodeArray = [];
+  let cursor = 0;
+
+  // always re-parse, do not cache, because we change the match
+  sprintf.parse(formatString).forEach((match: any, idx: number) => {
+    if (isString(match)) {
+      nodes.push(match);
+      return;
+    }
+
+    let arg: FormatArg = null;
+
+    if (match[2]) {
+      arg = (args[0] as ComponentMap)[match[2][0]];
+    } else if (match[1]) {
+      arg = args[parseInt(match[1], 10) - 1];
+    } else {
+      arg = args[cursor++];
+    }
+
+    // this points to a react element!
+    if (React.isValidElement(arg)) {
+      nodes.push(React.cloneElement(arg, {key: idx}));
+    } else {
+      // not a react element, fuck around with it so that sprintf.format
+      // can format it for us.  We make sure match[2] is null so that we
+      // do not go down the object path, and we set match[1] to the first
+      // index and then pass an array with two items in.
+      match[2] = null;
+      match[1] = 1;
+      nodes.push(<span key={idx++}>{sprintf.format([match], [null, arg])}</span>);
+    }
+  });
+
+  return nodes;
+}
+
+/**
+ * Determine if any arguments include React elements.
+ */
+function argsInvolveReact(args: FormatArg[]) {
+  if (args.some(React.isValidElement)) {
+    return true;
+  }
+
+  if (args.length !== 1 || !isObject(args[0])) {
+    return false;
+  }
+
+  const componentMap = args[0] as ComponentMap;
+
+  return Object.keys(componentMap).some(key => React.isValidElement(componentMap[key]));
+}
+
+/**
+ * Parse template strings will be parsed into an array of TemplateSubvalue's,
+ * this represents either a portion of the string, or a object with the group
+ * key indicating the group to lookup the group value in.
+ */
+type TemplateSubvalue = string | {group: string};
+
+/**
+ * ParsedTemplate is a mapping of group names to Template Subvalue arrays.
+ */
+type ParsedTemplate = {[group: string]: TemplateSubvalue[]};
+
+/**
+ * ComponentMap maps template group keys to react node instances.
+ *
+ * NOTE: template group keys that include additional sub values (e.g.
+ * [groupName:this string is the sub value]) will override the mapped react
+ * nodes children prop.
+ *
+ * In the above example the component map of {groupName: <strong>text</strong>}
+ * will be translated to `<strong>this string is the sub value</strong>`.
+ */
+type ComponentMap = {[group: string]: React.ReactNode};
+
+/**
+ * Parses a template string into groups.
+ *
+ * The top level group will be keyed as `root`. All other group names will have
+ * been extracted from the template string.
+ */
+export function parseComponentTemplate(template: string) {
+  const parsed: ParsedTemplate = {};
+
+  function process(startPos: number, group: string, inGroup: boolean) {
+    const regex = /\[(.*?)(:|\])|\]/g;
+    const buf: TemplateSubvalue[] = [];
+
+    let satisfied = false;
+    let match: ReturnType<typeof regex.exec>;
+
+    let pos = (regex.lastIndex = startPos);
+
+    // eslint-disable-next-line no-cond-assign
+    while ((match = regex.exec(template)) !== null) {
+      const substr = template.substr(pos, match.index - pos);
+      if (substr !== '') {
+        buf.push(substr);
+      }
+
+      const [fullMatch, groupName, closeBraceOrValueSeparator] = match;
+
+      if (fullMatch === ']') {
+        if (inGroup) {
+          satisfied = true;
+          break;
+        } else {
+          pos = regex.lastIndex;
+          continue;
+        }
+      }
+
+      if (closeBraceOrValueSeparator === ']') {
+        pos = regex.lastIndex;
+      } else {
+        pos = regex.lastIndex = process(regex.lastIndex, groupName, true);
+      }
+      buf.push({group: groupName});
+    }
+
+    let endPos = regex.lastIndex;
+    if (!satisfied) {
+      const rest = template.substr(pos);
+      if (rest) {
+        buf.push(rest);
+      }
+      endPos = template.length;
+    }
+
+    parsed[group] = buf;
+    return endPos;
+  }
+
+  process(0, 'root', false);
+
+  return parsed;
+}
+
+/**
+ * Renders a parsed template into a React tree given a ComponentMap to use for
+ * the parsed groups.
+ */
+export function renderTemplate(template: ParsedTemplate, components: ComponentMap) {
+  let idx = 0;
+
+  function renderGroup(groupKey: string) {
+    const children: React.ReactNode[] = [];
+    const group = template[groupKey] || [];
+
+    for (const item of group) {
+      if (isString(item)) {
+        children.push(<span key={idx++}>{item}</span>);
+      } else {
+        children.push(renderGroup(item.group));
+      }
+    }
+
+    // In case we cannot find our component, we call back to an empty
+    // span so that stuff shows up at least.
+    let reference = components[groupKey] || <span key={idx++} />;
+
+    if (!React.isValidElement(reference)) {
+      reference = <span key={idx++}>{reference}</span>;
+    }
+
+    const element = reference as React.ReactElement;
+
+    return children.length === 0
+      ? React.cloneElement(element, {key: idx++})
+      : React.cloneElement(element, {key: idx++}, children);
+  }
+
+  return renderGroup('root');
+}
+
+/**
+ * mark is used to debug translations by visually marking translated strings.
+ *
+ * NOTE: This is a no-op and will return the node if LOCALE_DEBUG is not
+ * currently enabled. See setLocaleDebug and toggleLocaleDebug.
+ */
+function mark<T>(node: T): T {
+  if (!LOCALE_DEBUG) {
+    return node;
+  }
+
+  // TODO(epurkhiser): Explain why we manually create a react node and assign
+  // the toString function. This could likely also use better typing, but will
+  // require some understanding of reacts internal types.
+  const proxy: any = {
+    $$typeof: Symbol.for('react.element'),
+    type: 'span',
+    key: null,
+    ref: null,
+    props: {
+      className: markerCss,
+      children: isArray(node) ? node : [node],
+    },
+    _owner: null,
+    _store: {},
+  };
+
+  proxy.toString = () => '✅' + node + '✅';
+
+  return proxy;
+}
+
+/**
+ * sprintf style string formatting. Does not handle translations.
+ *
+ * See the sprintf-js library [0] for specifics on the argument
+ * parameterization format.
+ *
+ * [0]: https://github.com/alexei/sprintf.js
+ */
+export function format(formatString: string, args: FormatArg[]) {
+  if (argsInvolveReact(args)) {
+    return formatForReact(formatString, args);
+  }
+
+  return sprintf(formatString, ...args) as string;
+}
+
+/**
+ * Translates a string to the current locale.
+ *
+ * See the sprintf-js library [0] for specifics on the argument
+ * parameterization format.
+ *
+ * [0]: https://github.com/alexei/sprintf.js
+ */
+export function gettext(string: string, ...args: FormatArg[]) {
+  const val: string = i18n.gettext(string);
+
+  if (args.length === 0) {
+    return mark(val);
+  }
+
+  // XXX(ts): It IS possible to use gettext in such a way that it will return a
+  // React.ReactNodeArray, however we currently rarely (if at all) use it in
+  // this way, and usually just expect strings back.
+  return mark(format(val, args) as string);
+}
+
+/**
+ * Translates a singular and plural string to the current locale. Supports
+ * argument parameterization, and will use the first argument as the counter to
+ * determine which message to use.
+ *
+ * See the sprintf-js library [0] for specifics on the argument
+ * parameterization format.
+ *
+ * [0]: https://github.com/alexei/sprintf.js
+ */
+export function ngettext(singular: string, plural: string, ...args: FormatArg[]) {
+  let countArg = 0;
+
+  if (args.length > 0) {
+    countArg = (args[0] as number) || 0;
+    args = [countArg.toLocaleString(), ...args.slice(1)];
+  }
+
+  // XXX(ts): See XXX in gettext.
+  return mark(format(i18n.ngettext(singular, plural, countArg), args) as string);
+}
+
+/**
+ * special form of gettext where you can render nested react components in
+ * template strings.
+ *
+ * ```jsx
+ * gettextComponentTemplate('Welcome. Click [link:here]', {
+ *   root: <p/>,
+ *   link: <a href="#" />,
+ * });
+ * ```
+ *
+ * The root string is always called "root", the rest is prefixed with the name
+ * in the brackets
+ *
+ * You may recursively nest additional groups within the grouped string values.
+ */
+export function gettextComponentTemplate(template: string, components: ComponentMap) {
+  const tmpl = parseComponentTemplate(i18n.gettext(template));
+  return mark(renderTemplate(tmpl, components));
+}
+
+/**
+ * Shorthand versions should primarily be used.
+ */
+export {gettext as t, ngettext as tn, gettextComponentTemplate as tct};
diff --git a/src/sentry/static/sentry/app/translations.jsx b/src/sentry/static/sentry/app/translations.tsx
similarity index 79%
rename from src/sentry/static/sentry/app/translations.jsx
rename to src/sentry/static/sentry/app/translations.tsx
index ae154b375f..b329010796 100644
--- a/src/sentry/static/sentry/app/translations.jsx
+++ b/src/sentry/static/sentry/app/translations.tsx
@@ -1,19 +1,19 @@
 import * as Sentry from '@sentry/browser';
 
 // zh-cn => zh_CN
-function convertToDjangoLocaleFormat(language) {
+function convertToDjangoLocaleFormat(language: string) {
   const [left, right] = language.split('-');
   return left + (right ? '_' + right.toUpperCase() : '');
 }
 
-export function getTranslations(language) {
+export function getTranslations(language: string) {
   language = convertToDjangoLocaleFormat(language);
 
   try {
     return require(`sentry-locale/${language}/LC_MESSAGES/django.po`);
   } catch (e) {
     Sentry.withScope(scope => {
-      scope.setLevel('warning');
+      scope.setLevel(Sentry.Severity.Warning);
       scope.setFingerprint(['sentry-locale-not-found']);
       scope.setExtra('locale', language);
       Sentry.captureException(e);

commit 2a75e2f6fde47c77929a068582647d3a78e0b211
Author: Evan Purkhiser <evanpurkhiser@gmail.com>
Date:   Fri Jul 12 13:49:24 2019 -0700

    feat(api): Add auth/login endpoint (#13979)

diff --git a/src/sentry/api/endpoints/auth_config.py b/src/sentry/api/endpoints/auth_config.py
index 3f7d07e249..1ed5c47ccc 100644
--- a/src/sentry/api/endpoints/auth_config.py
+++ b/src/sentry/api/endpoints/auth_config.py
@@ -35,6 +35,9 @@ class AuthConfigEndpoint(Endpoint, OrganizationMixin):
         # we always reset the state on GET so you dont end up at an odd location
         auth.initiate_login(request, next_uri)
 
+        # Auth login verifies the test cookie is set
+        request.session.set_test_cookie()
+
         # Single org mode -- send them to the org-specific handler
         if settings.SENTRY_SINGLE_ORGANIZATION:
             org = Organization.get_default()
@@ -55,26 +58,13 @@ class AuthConfigEndpoint(Endpoint, OrganizationMixin):
         next_uri = self.get_next_uri(request)
 
         if not auth.is_valid_redirect(next_uri, host=request.get_host()):
-            next_uri = self.org_redirect_url(request)
+            active_org = self.get_active_organization(request)
+            next_uri = auth.get_org_redirect_url(request, active_org)
 
         return Response({
             'nextUri': next_uri,
         })
 
-    def org_redirect_url(self, request):
-        from sentry import features
-
-        organization = self.get_active_organization(request)
-        if organization:
-            return organization.get_url()
-
-        if not features.has('organizations:create'):
-            # TODO(dcramer): deal with case when the user cannot create orgs.
-            # This will likely cause an infinite loop right now.
-            return '/auth/login'
-
-        return '/organizations/new/'
-
     def get_next_uri(self, request):
         next_uri_fallback = None
         if request.session.get('_next') is not None:
diff --git a/src/sentry/api/endpoints/auth_login.py b/src/sentry/api/endpoints/auth_login.py
new file mode 100644
index 0000000000..63304f563d
--- /dev/null
+++ b/src/sentry/api/endpoints/auth_login.py
@@ -0,0 +1,88 @@
+from __future__ import absolute_import
+
+from rest_framework.response import Response
+
+from sentry.app import ratelimiter
+from sentry.utils import auth, metrics
+from sentry.utils.hashlib import md5_text
+from sentry.api.base import Endpoint
+from sentry.api.serializers.base import serialize
+from sentry.api.serializers.models.user import DetailedUserSerializer
+from sentry.web.forms.accounts import AuthenticationForm
+from sentry.web.frontend.base import OrganizationMixin
+
+
+class AuthLoginEndpoint(Endpoint, OrganizationMixin):
+    # Disable authentication and permission requirements.
+    permission_classes = []
+
+    def post(self, request, organization=None, *args, **kwargs):
+        """
+        Process a login request via username/password. SSO login is handled
+        elsewhere.
+        """
+        login_form = AuthenticationForm(request, request.DATA)
+
+        # Rate limit logins
+        is_limited = ratelimiter.is_limited(
+            u'auth:login:username:{}'.
+            format(md5_text(request.DATA.get('username').lower()).hexdigest()),
+            limit=10,
+            window=60,  # 10 per minute should be enough for anyone
+        )
+
+        if is_limited:
+            errors = {
+                '__all__': [login_form.error_messages['rate_limited']]
+            }
+            metrics.incr(
+                'login.attempt',
+                instance='rate_limited',
+                skip_internal=True,
+                sample_rate=1.0
+            )
+
+            return self.respond_with_error(errors)
+
+        if not login_form.is_valid():
+            metrics.incr(
+                'login.attempt',
+                instance='failure',
+                skip_internal=True,
+                sample_rate=1.0
+            )
+            return self.respond_with_error(login_form.errors)
+
+        user = login_form.get_user()
+
+        auth.login(
+            request,
+            user,
+            organization_id=organization.id if organization else None,
+        )
+        metrics.incr(
+            'login.attempt',
+            instance='success',
+            skip_internal=True,
+            sample_rate=1.0
+        )
+
+        if not user.is_active:
+            return Response({
+                'nextUri': '/auth/reactivate/',
+                'user': serialize(user, user, DetailedUserSerializer()),
+            })
+
+        active_org = self.get_active_organization(request)
+        redirect_url = auth.get_org_redirect_url(request, active_org)
+
+        return Response({
+            'nextUri': auth.get_login_redirect(request, redirect_url),
+            'user': serialize(user, user, DetailedUserSerializer()),
+        })
+
+    def respond_with_error(self, errors):
+        return Response({
+            'detail': 'Login attempt failed',
+            'errors': errors,
+        }, status=400)
diff --git a/src/sentry/api/urls.py b/src/sentry/api/urls.py
index 8ea6b8a536..61ea82f404 100644
--- a/src/sentry/api/urls.py
+++ b/src/sentry/api/urls.py
@@ -10,6 +10,7 @@ from .endpoints.api_tokens import ApiTokensEndpoint
 from .endpoints.assistant import AssistantEndpoint
 from .endpoints.auth_index import AuthIndexEndpoint
 from .endpoints.auth_config import AuthConfigEndpoint
+from .endpoints.auth_login import AuthLoginEndpoint
 from .endpoints.authenticator_index import AuthenticatorIndexEndpoint
 from .endpoints.broadcast_details import BroadcastDetailsEndpoint
 from .endpoints.broadcast_index import BroadcastIndexEndpoint
@@ -344,6 +345,7 @@ urlpatterns = patterns(
     url(r'^auth/', include([
         url(r'^$', AuthIndexEndpoint.as_view(), name='sentry-api-0-auth'),
         url(r'^config/$', AuthConfigEndpoint.as_view(), name='sentry-api-0-auth-config'),
+        url(r'^login/$', AuthLoginEndpoint.as_view(), name='sentry-api-0-auth-login'),
     ])),
 
     # List Authentiactors
diff --git a/src/sentry/utils/auth.py b/src/sentry/utils/auth.py
index 952e9ad1f0..4ce9846b55 100644
--- a/src/sentry/utils/auth.py
+++ b/src/sentry/utils/auth.py
@@ -103,6 +103,17 @@ def initiate_login(request, next_url=None):
         request.session['_next'] = next_url
 
 
+def get_org_redirect_url(request, active_organization):
+    from sentry import features
+
+    # TODO(dcramer): deal with case when the user cannot create orgs
+    if active_organization:
+        return active_organization.get_url()
+    if not features.has('organizations:create'):
+        return '/auth/login/'
+    return '/organizations/new/'
+
+
 def get_login_redirect(request, default=None):
     if default is None:
         default = get_login_url()
diff --git a/tests/sentry/api/endpoints/test_auth_login.py b/tests/sentry/api/endpoints/test_auth_login.py
new file mode 100644
index 0000000000..b30cd5540f
--- /dev/null
+++ b/tests/sentry/api/endpoints/test_auth_login.py
@@ -0,0 +1,64 @@
+from __future__ import absolute_import
+
+import six
+from django.core.urlresolvers import reverse
+from mock import patch
+from exam import fixture
+
+from sentry.testutils import APITestCase
+
+
+class AuthLoginEndpointTest(APITestCase):
+    @fixture
+    def path(self):
+        return reverse('sentry-api-0-auth-login')
+
+    def setUp(self):
+        # Requets to set the test cookie
+        self.client.get(reverse('sentry-api-0-auth-config'))
+
+    def test_login_invalid_password(self):
+        resp = self.client.post(self.path, {
+            'username': self.user.username,
+            'password': 'bizbar',
+        })
+        assert resp.status_code == 400
+        assert resp.data['errors']['__all__'] == [
+            u'Please enter a correct username and password. Note that both fields may be case-sensitive.'
+        ]
+
+    def test_login_valid_credentials(self):
+        resp = self.client.post(self.path, {
+            'username': self.user.username,
+            'password': 'admin',
+        })
+
+        assert resp.status_code == 200
+        assert resp.data['nextUri'] == '/organizations/new/'
+
+    def test_must_reactivate(self):
+        self.user.update(is_active=False)
+
+        resp = self.client.post(self.path, {
+            'username': self.user.username,
+            'password': 'admin',
+        })
+
+        assert resp.status_code == 200
+        assert resp.data['nextUri'] == '/auth/reactivate/'
+
+    @patch(
+        'sentry.api.endpoints.auth_login.ratelimiter.is_limited',
+        autospec=True,
+        return_value=True
+    )
+    def test_login_ratelimit(self, is_limited):
+        resp = self.client.post(self.path, {
+            'username': self.user.username,
+            'password': 'admin',
+        })
+
+        assert resp.status_code == 400
+        assert [six.text_type(s) for s in resp.data['errors']['__all__']] == [
+            u'You have made too many failed authentication attempts. Please try again later.'
+        ]

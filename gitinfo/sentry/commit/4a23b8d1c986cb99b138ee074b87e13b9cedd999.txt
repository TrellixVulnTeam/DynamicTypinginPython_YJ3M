commit 4a23b8d1c986cb99b138ee074b87e13b9cedd999
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Tue Sep 4 10:51:08 2018 -0700

    feat(health): Change Health Requester to handle more data transforms (#9535)
    
    This would be nice if it was handled by the API but for now we will just expand the period size and handle it on the frontend.
    
    * adds more transforms to render prop, add distinct data sets for current, previous, and all data

diff --git a/src/sentry/static/sentry/app/actionCreators/health.jsx b/src/sentry/static/sentry/app/actionCreators/health.jsx
index a3d16aa700..951fbc88cc 100644
--- a/src/sentry/static/sentry/app/actionCreators/health.jsx
+++ b/src/sentry/static/sentry/app/actionCreators/health.jsx
@@ -1,18 +1,29 @@
 const BASE_URL = org => `/organizations/${org.slug}/health/`;
 
+// Gets the period to query with if we need to double the initial period in order
+// to get data for the previous period
+const getPeriod = (originalPeriod, shouldDoublePeriod) => {
+  if (!shouldDoublePeriod) return originalPeriod;
+
+  const [, periodNumber, periodLength] = originalPeriod.match(/([0-9]+)([mhdw])/);
+
+  return `${parseInt(periodNumber, 10) * 2}${periodLength}`;
+};
+
 /**
  * Make requests to `health` endpoint
  *
  * @param {Object} api API client instance
  * @param {Object} options Request parameters
  * @param {Object} options.organization Organization object
- * @param {Number[]} options.projects List of proejct ids
+ * @param {Number[]} options.projects List of project ids
  * @param {String} options.tag The "tag" to query for
  * @param {Boolean} options.timeseries Should we group results by time period
  * @param {String[]} options.environments List of environments to query for
  * @param {String} options.period Time period to query for, in the format: <integer><units> where units are "d" or "h"
  * @param {String} options.interval Time interval to group results in, in the format: <integer><units> where units are "d", "h", "m", "s"
  * @param {Boolean} options.includePrevious Should request also return reqsults for previous period?
+ * @param {Number} options.limit The number of rows to return
  * @param {Number} options.topk Include topk results
  */
 export const doHealthRequest = (
@@ -27,18 +38,25 @@ export const doHealthRequest = (
     timeseries,
     includePrevious,
     topk,
+    specifiers,
+    limit,
   }
 ) => {
   if (!api) return Promise.reject(new Error('API client not available'));
 
   const path = timeseries ? 'graph/' : 'top/';
+  const shouldDoublePeriod = timeseries && includePrevious;
+  const totalPeriod = getPeriod(period, shouldDoublePeriod);
+
   const query = {
     tag,
     includePrevious,
     interval,
-    statsPeriod: period,
+    statsPeriod: totalPeriod,
     project: projects,
     environment: environments,
+    q: specifiers,
+    limit,
     ...(topk ? {topk} : {}),
   };
 
diff --git a/src/sentry/static/sentry/app/views/organizationHealth/util/healthRequest.jsx b/src/sentry/static/sentry/app/views/organizationHealth/util/healthRequest.jsx
index 877737fdbb..ba9e96734b 100644
--- a/src/sentry/static/sentry/app/views/organizationHealth/util/healthRequest.jsx
+++ b/src/sentry/static/sentry/app/views/organizationHealth/util/healthRequest.jsx
@@ -3,6 +3,7 @@ import PropTypes from 'prop-types';
 import React from 'react';
 
 import {doHealthRequest} from 'app/actionCreators/health';
+import LoadingIndicator from 'app/components/loadingIndicator';
 import SentryTypes from 'app/sentryTypes';
 import withApi from 'app/utils/withApi';
 import withLatestContext from 'app/utils/withLatestContext';
@@ -53,12 +54,12 @@ class HealthRequestWithParams extends React.Component {
     includePrevious: PropTypes.bool,
 
     /**
-     * Should we query for timeseries data
+     * number of rows to return
      */
-    timeseries: PropTypes.bool,
+    limit: PropTypes.number,
 
     /**
-     * topK value
+     * topK value, currently only hardcoded for topk projects
      */
     topk: PropTypes.number,
 
@@ -66,20 +67,53 @@ class HealthRequestWithParams extends React.Component {
      * Callback function to process category
      */
     getCategory: PropTypes.func,
+
+    /**
+     * Transform the response data to be something ingestible by charts
+     */
+    includeTransformedData: PropTypes.bool,
+
+    /**
+     * Include a dataset transform that will aggregate count values for each timestamp.
+     * Be sure to supply a name to `timeAggregationSeriesName`
+     */
+    includeTimeAggregation: PropTypes.bool,
+
+    /**
+     * Name of series of aggregated timeseries
+     */
+    timeAggregationSeriesName: PropTypes.string,
+
+    /**
+     * Include a map of series name -> percentage integers
+     *
+     * This is only valid for non-timeseries data
+     */
+    includePercentages: PropTypes.bool,
+
+    includeTimeseries: PropTypes.bool,
+
+    includeTop: PropTypes.bool,
+
+    showLoading: PropTypes.bool,
   };
 
   static defaultProps = {
     period: '7d',
-    includePrevious: true,
-    timeseries: true,
     interval: '1d',
+    limit: 15,
     getCategory: i => i,
+
+    includeTimeseries: true,
+    includePrevious: true,
+    includeTransformedData: true,
   };
 
   constructor(props) {
     super(props);
     this.state = {
-      data: null,
+      tagData: null,
+      timeseriesData: null,
     };
   }
 
@@ -93,28 +127,139 @@ class HealthRequestWithParams extends React.Component {
     this.fetchData();
   }
 
-  fetchData() {
-    let {api, ...props} = this.props;
-    doHealthRequest(api, props).then(({data}) => {
-      this.setState({
-        data,
-      });
+  fetchData = async () => {
+    const {tag} = this.props;
+
+    // If `includeTop` is defined and > 0, we need to fetch the top tags ordered by count
+    // And then if we need timeseries, we'll pass the specific tag values into the timeseries query
+    // to fetch only the counts for those tag values.
+    const tagData = await this.fetchTopTag();
+    const tagSpecifiers =
+      (tagData &&
+        tagData.data &&
+        tagData.data
+          .map(({[tag]: tagObject}) => tagObject && tagObject._health_id)
+          .filter(id => !!id)) ||
+      null;
+
+    const timeseriesData = await this.fetchTimeseriesData({
+      ...(tagSpecifiers && tagSpecifiers.length
+        ? {
+            specifiers: tagSpecifiers,
+          }
+        : {}),
     });
-  }
 
-  transformTimeseriesData = () => {
-    let {tag, getCategory} = this.props;
-    let {data} = this.state;
+    this.setState({
+      tagData,
+      timeseriesData,
+    });
+  };
+
+  fetchTopTag = otherProps => {
+    const {api, includeTop, ...props} = this.props;
+
+    if (!includeTop) return Promise.resolve({});
+
+    return doHealthRequest(api, {...props, ...otherProps, timeseries: false});
+  };
+
+  fetchTimeseriesData = otherProps => {
+    const {api, includeTimeseries, ...props} = this.props;
+    if (!includeTimeseries) return Promise.resolve({});
+    return doHealthRequest(api, {...props, ...otherProps, timeseries: true});
+  };
+
+  // Is going to be called with an object with `value` and `_health_id`
+  getCategory = ({value} = {}) => {
+    return this.props.getCategory(value);
+  };
+
+  /**
+   * Retrieves data set for the current period (since data can potentially contain previous period's data), as
+   * well as the previous period if possible.
+   *
+   * Returns `null` if data does not exist
+   */
+  getData = (data, isTimeseries) => {
+    const {includePrevious} = this.props;
+
+    if (!data) {
+      return {
+        previous: null,
+        current: null,
+      };
+    }
 
+    const hasPreviousPeriod = isTimeseries && includePrevious;
+    // Take the floor just in case, but data should always be divisible by 2
+    const dataMiddleIndex = Math.floor(data.length / 2);
+
+    return {
+      previous: hasPreviousPeriod ? data.slice(0, dataMiddleIndex) : null,
+      current: hasPreviousPeriod ? data.slice(dataMiddleIndex) : data,
+    };
+  };
+
+  // This aggregates all values per `timestamp`
+  calculateTotalsPerTimestamp = (data, getName = timestamp => timestamp * 1000) => {
+    return data.map(([timestamp, countArray], i) => ({
+      name: getName(timestamp, countArray, i),
+      value: countArray.reduce((acc, {count}) => acc + count, 0),
+    }));
+  };
+
+  transformSeriesPercentageMap = (transformedData, total) => {
+    return new Map(
+      transformedData.map(([name, value]) => [
+        name,
+        Math.round(value / total * 10000) / 100,
+      ])
+    );
+  };
+
+  /**
+   * Get previous period data, but transform timestampts so that data fits unto the current period's data axis
+   */
+  transformPreviousPeriodData = (current, previous) => {
+    // Need the current period data array so we can take the timestamp
+    // so we can be sure the data lines up
+    if (!previous) return [];
+
+    return {
+      seriesName: 'Previous Period',
+      data: this.calculateTotalsPerTimestamp(
+        previous,
+        (timestamp, countArray, i) => current[i][0] * 1000
+      ),
+    };
+  };
+
+  /**
+   * Aggregate all counts for each time stamp
+   */
+  transformAggregatedTimeseries = (data, seriesName) => {
+    if (!data) return null;
+
+    return {
+      seriesName,
+      data: this.calculateTotalsPerTimestamp(data),
+    };
+  };
+
+  /**
+   * Transforms query response into timeseries data to be used in a chart
+   */
+  transformTimeseriesData = (data, tag) => {
     const categorySet = new Set();
     const timestampMap = new Map();
 
     data.forEach(([timestamp, resultsForTimestamp]) => {
       resultsForTimestamp &&
         !!resultsForTimestamp.length &&
-        resultsForTimestamp.forEach(({count, [tag]: name}) => {
-          categorySet.add(getCategory(name));
-          timestampMap.set(`${timestamp}-${getCategory(name)}`, count);
+        resultsForTimestamp.forEach(({count, [tag]: tagObject}) => {
+          categorySet.add(this.getCategory(tagObject));
+          timestampMap.set(`${timestamp}-${this.getCategory(tagObject)}`, count);
         });
     });
 
@@ -129,25 +274,132 @@ class HealthRequestWithParams extends React.Component {
     });
   };
 
-  transformData = () => {
-    let {timeseries, tag} = this.props;
-    let {data} = this.state;
+  /**
+   * Transforms query response into a non-timeseries data to be used in a chart
+   */
+  transformNonTimeSeriesData = (data, tag) =>
+    data.map(({[tag]: tagObject, count}) => [this.getCategory(tagObject), count]);
+
+  transformData = (data, isTimeseries) => {
+    const {tag} = this.props;
     if (!data) return null;
 
-    return timeseries
-      ? this.transformTimeseriesData()
-      : data.map(({[tag]: name, count}) => [name, count]);
+    return isTimeseries
+      ? this.transformTimeseriesData(data, tag)
+      : this.transformNonTimeSeriesData(data, tag);
   };
 
+  processData({data, totals} = {}, isTimeseries) {
+    const {
+      tag,
+      includeTransformedData,
+      includePercentages,
+      includeTimeAggregation,
+      includeTop,
+      timeAggregationSeriesName,
+    } = this.props;
+    const shouldIncludePercentages = includePercentages && includeTop && !isTimeseries;
+    const {current, previous} = this.getData(data, isTimeseries);
+    const transformedData =
+      includeTransformedData || shouldIncludePercentages
+        ? this.transformData(current, isTimeseries)
+        : null;
+
+    const percentageMap =
+      shouldIncludePercentages &&
+      totals &&
+      this.transformSeriesPercentageMap(transformedData, totals.count);
+
+    const dataWithPercentages =
+      shouldIncludePercentages && current
+        ? current.map(({count, lastCount, [tag]: tagObject}) => {
+            const name = this.getCategory(tagObject);
+
+            return {
+              count,
+              lastCount,
+              name,
+              percentage: percentageMap.get(name),
+            };
+          })
+        : null;
+
+    const previousData =
+      isTimeseries && includeTransformedData
+        ? this.transformPreviousPeriodData(current, previous)
+        : null;
+
+    const timeAggregatedData =
+      isTimeseries && includeTimeAggregation
+        ? this.transformAggregatedTimeseries(current, timeAggregationSeriesName)
+        : null;
+
+    return {
+      data: transformedData,
+      allData: data,
+      originalData: current,
+      totals,
+      originalPreviousData: previous,
+      previousData,
+      timeAggregatedData,
+      dataWithPercentages,
+    };
+  }
+
   render() {
-    let {children} = this.props;
-    let {data} = this.state;
+    const {children, tag, showLoading, ...props} = this.props;
+
+    const {tagData, timeseriesData} = this.state;
+
+    // Is "loading" if data is null
+    const loading = tagData === null && timeseriesData === null;
+
+    if (showLoading && loading) {
+      return <LoadingIndicator />;
+    }
+
+    const {
+      data: transformedTagData,
+      allData: allTagData,
+      originalData: originalTagData,
+      totals: tagTotals,
+      dataWithPercentages: tagDataWithPercentages,
+    } =
+      (tagData && this.processData(tagData)) || {};
+
+    const {
+      data: transformedTimeseriesData,
+      allData: allTimeseriesData,
+      originalData: originalTimeseriesData,
+      totals: timeseriesTotals,
+      originalPreviousData: originalPreviousTimeseriesData,
+      previousData: previousTimeseriesData,
+      timeAggregatedData,
+    } =
+      (timeseriesData && this.processData(timeseriesData, true)) || {};
 
     return children({
-      // Loading if data is null
-      loading: data === null,
-      data: this.transformData(data),
-      originalData: data,
+      loading,
+
+      // tg data
+      tagData: transformedTagData,
+      allTagData,
+      originalTagData,
+      tagTotals,
+      tagDataWithPercentages,
+
+      // timeseries data
+      timeseriesData: transformedTimeseriesData,
+      allTimeseriesData,
+      originalTimeseriesData,
+      timeseriesTotals,
+      originalPreviousTimeseriesData,
+      previousTimeseriesData,
+      timeAggregatedData,
+
+      // sometimes we want to reference props that were given to HealthRequest
+      tag,
+      ...props,
     });
   }
 }
@@ -158,11 +410,12 @@ const HealthRequest = withLatestContext(
       render() {
         return (
           <HealthContext.Consumer>
-            {({projects, environments, period}) => (
+            {({projects, environments, period, filters}) => (
               <HealthRequestWithParams
                 projects={projects}
                 environments={environments}
                 period={period}
+                filters={filters}
                 {...this.props}
               />
             )}
diff --git a/tests/js/spec/actionCreators/health.spec.jsx b/tests/js/spec/actionCreators/health.spec.jsx
index 64a382eeee..1664982634 100644
--- a/tests/js/spec/actionCreators/health.spec.jsx
+++ b/tests/js/spec/actionCreators/health.spec.jsx
@@ -17,7 +17,7 @@ describe('Health ActionCreator', function() {
       projects: [project.id],
       environments: [],
       topk: 5,
-      includePrevious: true,
+      includePrevious: false,
       period: '7d',
     });
 
@@ -30,7 +30,7 @@ describe('Health ActionCreator', function() {
           project: [project.id],
           environment: [],
           topk: 5,
-          includePrevious: true,
+          includePrevious: false,
           statsPeriod: '7d',
         }),
       })
@@ -48,7 +48,7 @@ describe('Health ActionCreator', function() {
       environments: [],
       tag: 'release',
       topk: 5,
-      includePrevious: true,
+      includePrevious: false,
       period: '7d',
     });
 
@@ -62,7 +62,7 @@ describe('Health ActionCreator', function() {
           environment: [],
           tag: 'release',
           topk: 5,
-          includePrevious: true,
+          includePrevious: false,
           statsPeriod: '7d',
         }),
       })
@@ -97,4 +97,58 @@ describe('Health ActionCreator', function() {
       })
     );
   });
+
+  it('requests timeseries w/ tag and previous period', function() {
+    mock = MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/health/graph/',
+    });
+    doHealthRequest(api, {
+      timeseries: true,
+      organization,
+      projects: [project.id],
+      environments: [],
+      tag: 'release',
+      topk: 5,
+      includePrevious: true,
+      period: '7d',
+    });
+
+    expect(mock).toHaveBeenCalled();
+
+    expect(mock).toHaveBeenLastCalledWith(
+      '/organizations/org-slug/health/graph/',
+      expect.objectContaining({
+        query: expect.objectContaining({
+          statsPeriod: '14d',
+        }),
+      })
+    );
+  });
+
+  it('requests non-timeseries and previous period', function() {
+    mock = MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/health/top/',
+    });
+    doHealthRequest(api, {
+      timeseries: false,
+      organization,
+      projects: [project.id],
+      environments: [],
+      tag: 'release',
+      topk: 5,
+      includePrevious: true,
+      period: '7d',
+    });
+
+    expect(mock).toHaveBeenCalled();
+
+    expect(mock).toHaveBeenLastCalledWith(
+      '/organizations/org-slug/health/top/',
+      expect.objectContaining({
+        query: expect.objectContaining({
+          statsPeriod: '7d',
+        }),
+      })
+    );
+  });
 });
diff --git a/tests/js/spec/views/organizationHealth/util/healthRequest.spec.jsx b/tests/js/spec/views/organizationHealth/util/healthRequest.spec.jsx
index 540269d4fb..f934453a60 100644
--- a/tests/js/spec/views/organizationHealth/util/healthRequest.spec.jsx
+++ b/tests/js/spec/views/organizationHealth/util/healthRequest.spec.jsx
@@ -4,13 +4,17 @@ import React from 'react';
 import {doHealthRequest} from 'app/actionCreators/health';
 import {HealthRequestWithParams} from 'app/views/organizationHealth/util/healthRequest';
 
+const COUNT_OBJ = {
+  count: 123,
+  release: {
+    _health_id: 'release:release-slug',
+    value: {slug: 'release-slug'},
+  },
+};
+
 jest.mock('app/actionCreators/health', () => {
   return {
-    doHealthRequest: jest.fn(() =>
-      Promise.resolve({
-        data: [[new Date(), [{count: 123, release: {slug: 'release-slug'}}]]],
-      })
-    ),
+    doHealthRequest: jest.fn(),
   };
 });
 
@@ -18,47 +22,58 @@ describe('HealthRequest', function() {
   const project = TestStubs.Project();
   const organization = TestStubs.Organization();
   const mock = jest.fn(() => null);
+  const DEFAULTS = {
+    api: {},
+    projects: [project.id],
+    environments: [],
+    period: '24h',
+    organization,
+    tag: 'release',
+    includePrevious: false,
+    includeTimeseries: true,
+  };
+
   let wrapper;
 
   describe('with props changes', function() {
     beforeAll(function() {
       doHealthRequest.mockImplementation(() =>
         Promise.resolve({
-          data: [[new Date(), [{count: 123, release: 'release-name'}]]],
+          data: [[new Date(), [COUNT_OBJ]]],
         })
       );
       wrapper = mount(
-        <HealthRequestWithParams
-          api={{}}
-          projects={[project.id]}
-          environments={[]}
-          period="24h"
-          organization={organization}
-          tag="release"
-        >
-          {mock}
-        </HealthRequestWithParams>
+        <HealthRequestWithParams {...DEFAULTS}>{mock}</HealthRequestWithParams>
       );
     });
 
     it('makes requests', async function() {
-      expect(mock).toHaveBeenCalledWith({loading: true, data: null, originalData: null});
+      expect(mock).toHaveBeenNthCalledWith(
+        1,
+        expect.objectContaining({
+          loading: true,
+        })
+      );
 
-      expect(mock).toHaveBeenLastCalledWith({
-        loading: false,
-        data: [
-          {
-            seriesName: 'release-name',
-            data: [
-              expect.objectContaining({
-                name: expect.anything(),
-                value: 123,
-              }),
-            ],
-          },
-        ],
-        originalData: [[expect.anything(), expect.anything()]],
-      });
+      expect(mock).toHaveBeenLastCalledWith(
+        expect.objectContaining({
+          loading: false,
+          timeseriesData: [
+            {
+              seriesName: expect.anything(),
+              data: [
+                expect.objectContaining({
+                  name: expect.any(Number),
+                  value: 123,
+                }),
+              ],
+            },
+          ],
+          originalTimeseriesData: [[expect.anything(), expect.anything()]],
+          tagData: null,
+          originalTagData: null,
+        })
+      );
 
       expect(doHealthRequest).toHaveBeenCalled();
     });
@@ -67,6 +82,8 @@ describe('HealthRequest', function() {
       doHealthRequest.mockClear();
 
       wrapper.setProps({projects: ['123']});
+      await tick();
+      wrapper.update();
       expect(doHealthRequest).toHaveBeenCalledWith(
         expect.anything(),
         expect.objectContaining({
@@ -79,6 +96,8 @@ describe('HealthRequest', function() {
       doHealthRequest.mockClear();
 
       wrapper.setProps({environments: ['dev']});
+      await tick();
+      wrapper.update();
       expect(doHealthRequest).toHaveBeenCalledWith(
         expect.anything(),
         expect.objectContaining({
@@ -91,6 +110,8 @@ describe('HealthRequest', function() {
       doHealthRequest.mockClear();
 
       wrapper.setProps({period: '7d'});
+      await tick();
+      wrapper.update();
       expect(doHealthRequest).toHaveBeenCalledWith(
         expect.anything(),
         expect.objectContaining({
@@ -99,10 +120,12 @@ describe('HealthRequest', function() {
       );
     });
 
-    it('makes a new request if timeseries prop changes', async function() {
+    it('makes a new request if includeTimeseries prop changes', async function() {
       doHealthRequest.mockClear();
 
-      wrapper.setProps({timeseries: false});
+      wrapper.setProps({includeTimeseries: false, includeTop: true});
+      await tick();
+      wrapper.update();
       expect(doHealthRequest).toHaveBeenCalledWith(
         expect.anything(),
         expect.objectContaining({
@@ -112,69 +135,326 @@ describe('HealthRequest', function() {
     });
   });
 
-  it('defines a category name getter', async function() {
-    doHealthRequest.mockImplementation(() =>
-      Promise.resolve({
-        data: [[new Date(), [{count: 123, release: {slug: 'release-slug'}}]]],
-      })
-    );
-    wrapper = mount(
-      <HealthRequestWithParams
-        api={{}}
-        projects={[project.id]}
-        environments={[]}
-        period="24h"
-        organization={organization}
-        tag="release"
-        getCategory={release => release && release.slug}
-      >
-        {mock}
-      </HealthRequestWithParams>
-    );
-    await tick();
-    wrapper.update();
-    expect(mock).toHaveBeenLastCalledWith({
-      loading: false,
-      data: [
-        {
-          seriesName: 'release-slug',
+  describe('transforms', function() {
+    beforeEach(function() {
+      doHealthRequest.mockClear();
+    });
+
+    it('defines a category name getter', async function() {
+      doHealthRequest.mockImplementation(() =>
+        Promise.resolve({
+          data: [[new Date(), [COUNT_OBJ]]],
+        })
+      );
+      wrapper = mount(
+        <HealthRequestWithParams
+          {...DEFAULTS}
+          getCategory={release => release && release.slug}
+        >
+          {mock}
+        </HealthRequestWithParams>
+      );
+      await tick();
+      wrapper.update();
+      expect(mock).toHaveBeenLastCalledWith(
+        expect.objectContaining({
+          loading: false,
+          timeseriesData: [
+            {
+              seriesName: 'release-slug',
+              data: [
+                expect.objectContaining({
+                  name: expect.anything(),
+                  value: 123,
+                }),
+              ],
+            },
+          ],
+          originalTimeseriesData: [[expect.anything(), expect.anything()]],
+        })
+      );
+    });
+
+    it('expands period in query if `includePrevious` and `timeseries`', async function() {
+      doHealthRequest.mockImplementation(() =>
+        Promise.resolve({
+          data: [
+            [new Date(), [{...COUNT_OBJ, count: 321}, {...COUNT_OBJ, count: 79}]],
+            [new Date(), [COUNT_OBJ]],
+          ],
+        })
+      );
+      wrapper = mount(
+        <HealthRequestWithParams
+          {...DEFAULTS}
+          includeTimeseries={true}
+          includePrevious={true}
+          getCategory={({slug} = {}) => slug}
+        >
+          {mock}
+        </HealthRequestWithParams>
+      );
+
+      await tick();
+      wrapper.update();
+
+      // actionCreator handles expanding the period when calling the API
+      expect(doHealthRequest).toHaveBeenCalledWith(
+        expect.anything(),
+        expect.objectContaining({
+          period: '24h',
+        })
+      );
+
+      expect(mock).toHaveBeenLastCalledWith(
+        expect.objectContaining({
+          loading: false,
+          allTimeseriesData: [
+            [
+              expect.anything(),
+              [
+                expect.objectContaining({count: 321}),
+                expect.objectContaining({count: 79}),
+              ],
+            ],
+            [expect.anything(), [expect.objectContaining({count: 123})]],
+          ],
+          timeseriesData: [
+            {
+              seriesName: expect.anything(),
+              data: [
+                expect.objectContaining({
+                  name: expect.anything(),
+                  value: 123,
+                }),
+              ],
+            },
+          ],
+          previousTimeseriesData: {
+            seriesName: 'Previous Period',
+            data: [
+              expect.objectContaining({
+                name: expect.anything(),
+                value: 400,
+              }),
+            ],
+          },
+
+          originalTimeseriesData: [
+            [expect.anything(), [expect.objectContaining({count: 123})]],
+          ],
+
+          originalPreviousTimeseriesData: [
+            [
+              expect.anything(),
+              [
+                expect.objectContaining({count: 321}),
+                expect.objectContaining({count: 79}),
+              ],
+            ],
+          ],
+        })
+      );
+    });
+
+    it('transforms data for non-timeseries response', async function() {
+      doHealthRequest.mockImplementation(() =>
+        Promise.resolve({
+          data: [COUNT_OBJ],
+        })
+      );
+      wrapper = mount(
+        <HealthRequestWithParams
+          {...DEFAULTS}
+          includeTimeseries={false}
+          includeTop={true}
+          getCategory={({slug} = {}) => slug}
+        >
+          {mock}
+        </HealthRequestWithParams>
+      );
+
+      await tick();
+      wrapper.update();
+
+      expect(mock).toHaveBeenLastCalledWith(
+        expect.objectContaining({
+          loading: false,
+          tagData: [['release-slug', 123]],
+          originalTagData: [
+            {
+              count: 123,
+              release: {
+                value: {slug: 'release-slug'},
+                _health_id: 'release:release-slug',
+              },
+            },
+          ],
+        })
+      );
+    });
+
+    it('transforms data with percentages only when `includPercentages` prop is true', async function() {
+      doHealthRequest.mockImplementation(() =>
+        Promise.resolve({
           data: [
+            {...COUNT_OBJ, count: 100, lastCount: 50},
+            {
+              count: 80,
+              lastCount: 100,
+              release: {
+                value: {
+                  slug: 'new-release',
+                },
+              },
+            },
+          ],
+          totals: {
+            count: 180,
+          },
+        })
+      );
+
+      wrapper = mount(
+        <HealthRequestWithParams
+          {...DEFAULTS}
+          includeTimeseries={false}
+          includeTop={true}
+          includePercentages={false}
+          getCategory={({slug} = {}) => slug}
+        >
+          {mock}
+        </HealthRequestWithParams>
+      );
+
+      await tick();
+      wrapper.update();
+
+      expect(mock).toHaveBeenLastCalledWith(
+        expect.objectContaining({
+          tagDataWithPercentages: null,
+        })
+      );
+
+      wrapper.setProps({includePercentages: true});
+      await tick();
+      wrapper.update();
+
+      expect(mock).toHaveBeenLastCalledWith(
+        expect.objectContaining({
+          tagDataWithPercentages: [
             expect.objectContaining({
-              name: expect.anything(),
-              value: 123,
+              count: 100,
+              lastCount: 50,
+              percentage: 55.56,
+            }),
+            expect.objectContaining({
+              count: 80,
+              lastCount: 100,
+              percentage: 44.44,
             }),
           ],
-        },
-      ],
-      originalData: [[expect.anything(), expect.anything()]],
+        })
+      );
     });
-  });
 
-  it('transforms data for non-timeseries response', async function() {
-    doHealthRequest.mockImplementation(() =>
-      Promise.resolve({
-        data: [{count: 123, release: 'release-name'}],
-      })
-    );
-    wrapper = mount(
-      <HealthRequestWithParams
-        api={{}}
-        projects={[project.id]}
-        environments={[]}
-        period="24h"
-        organization={organization}
-        tag="release"
-        timeseries={false}
-      >
-        {mock}
-      </HealthRequestWithParams>
-    );
-    await tick();
-    wrapper.update();
-    expect(mock).toHaveBeenLastCalledWith({
-      loading: false,
-      data: [['release-name', 123]],
-      originalData: [{count: 123, release: 'release-name'}],
+    it('aggregates counts per timestamp only when `includeTimeAggregation` prop is true', async function() {
+      doHealthRequest.mockImplementation(() =>
+        Promise.resolve({
+          data: [[new Date(), [COUNT_OBJ, {...COUNT_OBJ, count: 100}]]],
+        })
+      );
+
+      wrapper = mount(
+        <HealthRequestWithParams
+          {...DEFAULTS}
+          includeTimeseries={true}
+          getCategory={({slug} = {}) => slug}
+        >
+          {mock}
+        </HealthRequestWithParams>
+      );
+
+      await tick();
+      wrapper.update();
+
+      expect(mock).toHaveBeenLastCalledWith(
+        expect.objectContaining({
+          timeAggregatedData: null,
+        })
+      );
+
+      wrapper.setProps({
+        includeTimeAggregation: true,
+        timeAggregationSeriesName: 'aggregated series',
+      });
+      await tick();
+      wrapper.update();
+
+      expect(mock).toHaveBeenLastCalledWith(
+        expect.objectContaining({
+          timeAggregatedData: {
+            seriesName: 'aggregated series',
+            data: [{name: expect.anything(), value: 223}],
+          },
+        })
+      );
+    });
+
+    it('transparently queries for top tags and then queries for timeseries data using only those top tags', async function() {
+      doHealthRequest.mockClear();
+      doHealthRequest.mockImplementation((api, props) => {
+        if (props.timeseries) {
+          return Promise.resolve({
+            data: [[new Date(), [COUNT_OBJ, {...COUNT_OBJ, count: 100}]]],
+          });
+        }
+
+        return Promise.resolve({
+          data: [{...COUNT_OBJ, count: 100}],
+          totals: {
+            count: 100,
+            lastCount: 50,
+          },
+        });
+      });
+
+      wrapper = mount(
+        <HealthRequestWithParams
+          {...DEFAULTS}
+          includeTop
+          includeTimeseries
+          includePercentages
+          includeTimeAggregation
+          includePrevious
+          timeAggregationSeriesName="Aggregated"
+          getCategory={({slug} = {}) => slug}
+        >
+          {mock}
+        </HealthRequestWithParams>
+      );
+
+      await tick();
+      wrapper.update();
+
+      expect(doHealthRequest).toHaveBeenCalledTimes(2);
+      expect(doHealthRequest).toHaveBeenNthCalledWith(
+        2,
+        expect.anything(),
+        expect.objectContaining({
+          timeseries: true,
+          specifiers: ['release:release-slug'],
+        })
+      );
+
+      expect(mock).toHaveBeenLastCalledWith(
+        expect.objectContaining({
+          timeAggregatedData: {
+            seriesName: 'Aggregated',
+            data: [{name: expect.anything(), value: 223}],
+          },
+        })
+      );
     });
   });
 });

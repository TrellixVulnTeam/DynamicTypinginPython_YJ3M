commit 888d325e4ffc0de18a4aa13e73d790551dcf32e2
Author: David Cramer <dcramer@gmail.com>
Date:   Mon Sep 15 19:51:47 2014 -0700

    Add bulk update/delete endpoints for project groups
    
    cherry-pick b19c7612abb388d69301c83b93a66454d4a24b5e

diff --git a/src/sentry/api/endpoints/project_group_index.py b/src/sentry/api/endpoints/project_group_index.py
index ed5389f010..2350e31313 100644
--- a/src/sentry/api/endpoints/project_group_index.py
+++ b/src/sentry/api/endpoints/project_group_index.py
@@ -1,18 +1,30 @@
 from __future__ import absolute_import
 
 from datetime import timedelta
+from django.db.models import Q
 from django.utils import timezone
+from rest_framework import serializers
 from rest_framework.response import Response
 
 from sentry.app import search
 from sentry.api.base import Endpoint
 from sentry.api.permissions import assert_perm
 from sentry.api.serializers import serialize
-from sentry.constants import DEFAULT_SORT_OPTION
-from sentry.models import TagKey, Project
+from sentry.constants import DEFAULT_SORT_OPTION, STATUS_CHOICES
+from sentry.db.models.query import create_or_update
+from sentry.models import (
+    Activity, Group, GroupBookmark, GroupStatus, Project, TagKey
+)
 from sentry.utils.dates import parse_date
 
 
+class GroupSerializer(serializers.Serializer):
+    status = serializers.ChoiceField(choices=zip(
+        STATUS_CHOICES.keys(), STATUS_CHOICES.keys()
+    ))
+    isBookmarked = serializers.BooleanField()
+
+
 class ProjectGroupIndexEndpoint(Endpoint):
     # bookmarks=0/1
     # status=<x>
@@ -83,3 +95,129 @@ class ProjectGroupIndexEndpoint(Endpoint):
         results = search.query(**query_kwargs)
 
         return Response(serialize(list(results), request.user))
+
+    def put(self, request, project_id):
+        """
+        Bulk mutate various attributes on groups.
+
+        - For non-status updates, only queries by 'id' are accepted.
+        - For status updates, the 'id' parameter may be omitted for a batch
+        "update all" query.
+
+        PUT ?id=1&id=2&id=3
+          status=resolved&
+          isBookmarked=1
+
+        Attributes:
+
+        - status=[resolved|unresolved|muted]
+        - isBookmarked=[1|0]
+
+        If any ids are out of scope this operation will succeed without any data
+        mutation
+        """
+        project = Project.objects.get_from_cache(
+            id=project_id,
+        )
+
+        assert_perm(project, request.user, request.auth)
+
+        group_ids = request.GET.getlist('id')
+        if group_ids:
+            group_list = Group.objects.filter(project=project, id__in=group_ids)
+            # filter down group ids to only valid matches
+            group_ids = [g.id for g in group_list]
+
+            if not group_ids:
+                return Response(status=204)
+
+        serializer = GroupSerializer(data=request.DATA, partial=True)
+        if not serializer.is_valid():
+            return Response(status=400)
+
+        result = serializer.object
+
+        # validate that we've passed a selector for non-status bulk operations
+        if not group_ids and result.get('isBookmarked') is not None:
+            return Response(status=400)
+
+        if group_ids:
+            filters = Q(id__in=group_ids)
+        else:
+            filters = Q(project=project)
+
+        if result.get('status') == 'resolved':
+            now = timezone.now()
+
+            happened = Group.objects.filter(filters).exclude(
+                status=GroupStatus.RESOLVED,
+            ).update(
+                status=GroupStatus.RESOLVED,
+                resolved_at=now,
+            )
+
+            if group_ids and happened:
+                for group in group_list:
+                    create_or_update(
+                        Activity,
+                        project=group.project,
+                        group=group,
+                        type=Activity.SET_RESOLVED,
+                        user=request.user,
+                    )
+        elif result.get('status'):
+            new_status = STATUS_CHOICES[result['status']]
+
+            Group.objects.filter(filters).exclude(
+                status=new_status,
+            ).update(
+                status=new_status,
+            )
+
+        if result.get('isBookmarked'):
+            for group in group_list:
+                GroupBookmark.objects.get_or_create(
+                    project=group.project,
+                    group=group,
+                    user=request.user,
+                )
+        elif result.get('isBookmarked') is False:
+            GroupBookmark.objects.filter(
+                group__in=group_ids,
+                user=request.user,
+            ).delete()
+
+        return Response(status=204)
+
+    def delete(self, request, project_id):
+        """
+        Permanently remove the given groups.
+
+        Only queries by 'id' are accepted.
+
+        DELETE ?id=1&id=2&id=3
+
+        If any ids are out of scope this operation will succeed without any data
+        mutation
+        """
+        project = Project.objects.get_from_cache(
+            id=project_id,
+        )
+
+        assert_perm(project, request.user, request.auth)
+
+        group_ids = request.GET.getlist('id')
+        if group_ids:
+            group_list = Group.objects.filter(project=project, id__in=group_ids)
+            # filter down group ids to only valid matches
+            group_ids = [g.id for g in group_list]
+        else:
+            # missing any kind of filter
+            return Response(status=400)
+
+        if not group_ids:
+            return Response(status=204)
+
+        group_list.delete()
+
+        return Response(status=204)
diff --git a/tests/sentry/api/endpoints/test_project_group_index.py b/tests/sentry/api/endpoints/test_project_group_index.py
index 9891ff1324..af16dd760d 100644
--- a/tests/sentry/api/endpoints/test_project_group_index.py
+++ b/tests/sentry/api/endpoints/test_project_group_index.py
@@ -1,8 +1,11 @@
 from django.core.urlresolvers import reverse
+
+from sentry.constants import STATUS_MUTED, STATUS_RESOLVED, STATUS_UNRESOLVED
+from sentry.models import Group, GroupBookmark
 from sentry.testutils import APITestCase
 
 
-class GroupIndexTest(APITestCase):
+class GroupListTest(APITestCase):
     def test_simple(self):
         self.create_group(checksum='a' * 32)
         self.create_group(checksum='b' * 32)
@@ -12,3 +15,151 @@ class GroupIndexTest(APITestCase):
             'project_id': self.project.id})
         response = self.client.get(url, format='json')
         assert response.status_code == 200
+
+
+class GroupUpdateTest(APITestCase):
+    def test_global_status_update(self):
+        group1 = self.create_group(checksum='a' * 32, status=STATUS_RESOLVED)
+        group2 = self.create_group(checksum='b' * 32, status=STATUS_UNRESOLVED)
+        group3 = self.create_group(checksum='c' * 32, status=STATUS_MUTED)
+        group4 = self.create_group(
+            project=self.create_project(slug='foo'),
+            checksum='b' * 32, status=STATUS_UNRESOLVED)
+
+        self.login_as(user=self.user)
+        url = reverse('sentry-api-0-project-group-index', kwargs={
+            'project_id': self.project.id})
+        response = self.client.put(url, data={
+            'status': 'resolved',
+        }, format='json')
+        assert response.status_code == 204
+
+        new_group1 = Group.objects.get(id=group1.id)
+        assert new_group1.status == STATUS_RESOLVED
+        assert new_group1.resolved_at is None
+
+        new_group2 = Group.objects.get(id=group2.id)
+        assert new_group2.status == STATUS_RESOLVED
+        assert new_group2.resolved_at is not None
+
+        new_group3 = Group.objects.get(id=group3.id)
+        assert new_group3.status == STATUS_RESOLVED
+        assert new_group3.resolved_at is not None
+
+        new_group4 = Group.objects.get(id=group4.id)
+        assert new_group4.status == STATUS_UNRESOLVED
+        assert new_group4.resolved_at is None
+
+    def test_selective_status_update(self):
+        group1 = self.create_group(checksum='a' * 32, status=STATUS_RESOLVED)
+        group2 = self.create_group(checksum='b' * 32, status=STATUS_UNRESOLVED)
+        group3 = self.create_group(checksum='c' * 32, status=STATUS_MUTED)
+        group4 = self.create_group(
+            project=self.create_project(slug='foo'),
+            checksum='b' * 32, status=STATUS_UNRESOLVED)
+
+        self.login_as(user=self.user)
+        url = '{url}?id={group1.id}&id={group2.id}&group4={group4.id}'.format(
+            url=reverse('sentry-api-0-project-group-index', kwargs={
+                'project_id': self.project.id
+            }),
+            group1=group1,
+            group2=group2,
+            group4=group4,
+        )
+        response = self.client.put(url, data={
+            'status': 'resolved',
+        }, format='json')
+        assert response.status_code == 204
+
+        new_group1 = Group.objects.get(id=group1.id)
+        assert new_group1.resolved_at is None
+
+        new_group2 = Group.objects.get(id=group2.id)
+        assert new_group2.resolved_at is not None
+        assert new_group2.status == STATUS_RESOLVED
+
+        new_group3 = Group.objects.get(id=group3.id)
+        assert new_group3.resolved_at is None
+        assert new_group3.status == STATUS_MUTED
+
+        new_group4 = Group.objects.get(id=group4.id)
+        assert new_group4.resolved_at is None
+        assert new_group4.status == STATUS_UNRESOLVED
+
+    def test_set_bookmarked(self):
+        group1 = self.create_group(checksum='a' * 32, status=STATUS_RESOLVED)
+        group2 = self.create_group(checksum='b' * 32, status=STATUS_UNRESOLVED)
+        group3 = self.create_group(checksum='c' * 32, status=STATUS_MUTED)
+        group4 = self.create_group(
+            project=self.create_project(slug='foo'),
+            checksum='b' * 32, status=STATUS_UNRESOLVED)
+
+        self.login_as(user=self.user)
+        url = '{url}?id={group1.id}&id={group2.id}&group4={group4.id}'.format(
+            url=reverse('sentry-api-0-project-group-index', kwargs={
+                'project_id': self.project.id
+            }),
+            group1=group1,
+            group2=group2,
+            group4=group4,
+        )
+        response = self.client.put(url, data={
+            'isBookmarked': '1',
+        }, format='json')
+        assert response.status_code == 204
+
+        bookmark1 = GroupBookmark.objects.filter(group=group1, user=self.user)
+        assert bookmark1.exists()
+
+        bookmark2 = GroupBookmark.objects.filter(group=group2, user=self.user)
+        assert bookmark2.exists()
+
+        bookmark3 = GroupBookmark.objects.filter(group=group3, user=self.user)
+        assert not bookmark3.exists()
+
+        bookmark4 = GroupBookmark.objects.filter(group=group4, user=self.user)
+        assert not bookmark4.exists()
+
+
+class GroupDeleteTest(APITestCase):
+    def test_global_is_forbidden(self):
+        self.login_as(user=self.user)
+        url = reverse('sentry-api-0-project-group-index', kwargs={
+            'project_id': self.project.id})
+        response = self.client.delete(url, data={
+            'status': 'resolved',
+        }, format='json')
+        assert response.status_code == 400
+
+    def test_delete_by_id(self):
+        group1 = self.create_group(checksum='a' * 32, status=STATUS_RESOLVED)
+        group2 = self.create_group(checksum='b' * 32, status=STATUS_UNRESOLVED)
+        group3 = self.create_group(checksum='c' * 32, status=STATUS_MUTED)
+        group4 = self.create_group(
+            project=self.create_project(slug='foo'),
+            checksum='b' * 32, status=STATUS_UNRESOLVED)
+
+        self.login_as(user=self.user)
+        url = '{url}?id={group1.id}&id={group2.id}&group4={group4.id}'.format(
+            url=reverse('sentry-api-0-project-group-index', kwargs={
+                'project_id': self.project.id
+            }),
+            group1=group1,
+            group2=group2,
+            group4=group4,
+        )
+        response = self.client.delete(url, format='json')
+        assert response.status_code == 204
+
+        new_group1 = Group.objects.filter(id=group1.id)
+        assert not new_group1.exists()
+
+        new_group2 = Group.objects.filter(id=group2.id)
+        assert not new_group2.exists()
+
+        new_group3 = Group.objects.filter(id=group3.id)
+        assert new_group3.exists()
+
+        new_group4 = Group.objects.filter(id=group4.id)
+        assert new_group4.exists()

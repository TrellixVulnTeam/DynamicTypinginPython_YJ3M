commit 58115676bf636e34e74d8f53560048dbca990c5f
Author: David Cramer <dcramer@gmail.com>
Date:   Tue Aug 2 12:20:53 2011 -0700

    Ensure we're cleaning up exc_info when we create it to avoid memory overhead

diff --git a/CHANGES b/CHANGES
index 9de04cb738..f120b36a97 100644
--- a/CHANGES
+++ b/CHANGES
@@ -6,6 +6,7 @@
 * Performance improvements to ``Client.send()``.
 * Added default 404/500 pages.
 * Added support for Django's LOGIN_URL setting.
+* Fixed a memory leak in the client (thanks to Ben Bangert).
 
 1.8.6.2
 
diff --git a/docs/config/index.rst b/docs/config/index.rst
index 31da68820a..81bda9691c 100644
--- a/docs/config/index.rst
+++ b/docs/config/index.rst
@@ -75,13 +75,13 @@ A recommended pattern in logging is to simply reference the modules name for eac
 
 You can also use the ``exc_info`` and ``extra=dict(url=foo)`` arguments on your ``log`` methods. This will store the appropriate information and allow django-sentry to render it based on that information::
 
-	logger.error('There was some crazy error', exc_info=sys.exc_info(), extra={'url': request.build_absolute_uri()})
+	logger.error('There was some crazy error', exc_info=True, extra={'url': request.build_absolute_uri()})
 
 You may also pass additional information to be stored as meta information with the event. As long as the key
 name is not reserved and not private (_foo) it will be displayed on the Sentry dashboard. To do this, pass it as ``data`` within
 your ``extra`` clause::
 
-	logger.error('There was some crazy error', exc_info=sys.exc_info(), extra={
+	logger.error('There was some crazy error', exc_info=True, extra={
 	    # Optionally pass a request and we'll grab any information we can
 	    'request': request,
 
diff --git a/sentry/client/base.py b/sentry/client/base.py
index 90e1271b7d..441105c42e 100644
--- a/sentry/client/base.py
+++ b/sentry/client/base.py
@@ -211,11 +211,11 @@ class SentryClient(object):
                 except urllib2.HTTPError, e:
                     body = e.read()
                     logger.error('Unable to reach Sentry log server: %s (url: %%s, body: %%s)' % (e,), url, body,
-                                 exc_info=sys.exc_info(), extra={'data':{'body': body, 'remote_url': url}})
+                                 exc_info=True, extra={'data':{'body': body, 'remote_url': url}})
                     logger.log(kwargs.pop('level', None) or logging.ERROR, kwargs.pop('message', None))
                 except urllib2.URLError, e:
                     logger.error('Unable to reach Sentry log server: %s (url: %%s)' % (e,), url,
-                                 exc_info=sys.exc_info(), extra={'data':{'remote_url': url}})
+                                 exc_info=True, extra={'data':{'remote_url': url}})
                     logger.log(kwargs.pop('level', None) or logging.ERROR, kwargs.pop('message', None))
         else:
             from sentry.models import GroupedMessage
@@ -266,80 +266,85 @@ class SentryClient(object):
         """
         Creates an error log from an exception.
         """
+        new_exc = bool(exc_info)
         if not exc_info:
             exc_info = sys.exc_info()
+        
+        try:
+            exc_type, exc_value, exc_traceback = exc_info
 
-        exc_type, exc_value, exc_traceback = exc_info
-
-        reporter = ExceptionReporter(None, exc_type, exc_value, exc_traceback)
-        frames = varmap(shorten, reporter.get_traceback_frames())
+            reporter = ExceptionReporter(None, exc_type, exc_value, exc_traceback)
+            frames = varmap(shorten, reporter.get_traceback_frames())
 
-        if not kwargs.get('view'):
-            # This should be cached
-            modules = get_installed_apps()
-            if settings.INCLUDE_PATHS:
-                modules = set(list(modules) + settings.INCLUDE_PATHS)
+            if not kwargs.get('view'):
+                # This should be cached
+                modules = get_installed_apps()
+                if settings.INCLUDE_PATHS:
+                    modules = set(list(modules) + settings.INCLUDE_PATHS)
 
-            def iter_tb_frames(tb):
-                while tb:
-                    yield tb.tb_frame
-                    tb = tb.tb_next
+                def iter_tb_frames(tb):
+                    while tb:
+                        yield tb.tb_frame
+                        tb = tb.tb_next
             
-            def contains(iterator, value):
-                for k in iterator:
-                    if value.startswith(k):
-                        return True
-                return False
+                def contains(iterator, value):
+                    for k in iterator:
+                        if value.startswith(k):
+                            return True
+                    return False
                 
-            # We iterate through each frame looking for an app in INSTALLED_APPS
-            # When one is found, we mark it as last "best guess" (best_guess) and then
-            # check it against SENTRY_EXCLUDE_PATHS. If it isnt listed, then we
-            # use this option. If nothing is found, we use the "best guess".
-            best_guess = None
-            view = None
-            for frame in iter_tb_frames(exc_traceback):
-                try:
-                    view = '.'.join([frame.f_globals['__name__'], frame.f_code.co_name])
-                except:
-                    continue
-                if contains(modules, view):
-                    if not (contains(settings.EXCLUDE_PATHS, view) and best_guess):
-                        best_guess = view
-                elif best_guess:
-                    break
-            if best_guess:
-                view = best_guess
+                # We iterate through each frame looking for an app in INSTALLED_APPS
+                # When one is found, we mark it as last "best guess" (best_guess) and then
+                # check it against SENTRY_EXCLUDE_PATHS. If it isnt listed, then we
+                # use this option. If nothing is found, we use the "best guess".
+                best_guess = None
+                view = None
+                for frame in iter_tb_frames(exc_traceback):
+                    try:
+                        view = '.'.join([frame.f_globals['__name__'], frame.f_code.co_name])
+                    except:
+                        continue
+                    if contains(modules, view):
+                        if not (contains(settings.EXCLUDE_PATHS, view) and best_guess):
+                            best_guess = view
+                    elif best_guess:
+                        break
+                if best_guess:
+                    view = best_guess
             
-            if view:
-                kwargs['view'] = view
-
-        data = kwargs.pop('data', {}) or {}
-        if hasattr(exc_type, '__class__'):
-            exc_module = exc_type.__class__.__module__
-        else:
-            exc_module = None
-        data['__sentry__'] = {
-            'exc': map(transform, [exc_module, exc_value.args, frames]),
-        }
-
-        if (isinstance(exc_value, TemplateSyntaxError) and \
-            isinstance(getattr(exc_value, 'source', None), (tuple, list)) and isinstance(exc_value.source[0], LoaderOrigin)):
-            origin, (start, end) = exc_value.source
-            data['__sentry__'].update({
-                'template': (origin.reload(), start, end, origin.name),
-            })
-            kwargs['view'] = origin.loadname
-        
-        tb_message = '\n'.join(traceback.format_exception(exc_type, exc_value, exc_traceback))
+                if view:
+                    kwargs['view'] = view
 
-        kwargs.setdefault('message', transform(force_unicode(exc_value)))
+            data = kwargs.pop('data', {}) or {}
+            if hasattr(exc_type, '__class__'):
+                exc_module = exc_type.__class__.__module__
+            else:
+                exc_module = None
+            data['__sentry__'] = {
+                'exc': map(transform, [exc_module, exc_value.args, frames]),
+            }
 
-        return self.process(
-            class_name=exc_type.__name__,
-            traceback=tb_message,
-            data=data,
-            **kwargs
-        )
+            if (isinstance(exc_value, TemplateSyntaxError) and \
+                isinstance(getattr(exc_value, 'source', None), (tuple, list)) and isinstance(exc_value.source[0], LoaderOrigin)):
+                origin, (start, end) = exc_value.source
+                data['__sentry__'].update({
+                    'template': (origin.reload(), start, end, origin.name),
+                })
+                kwargs['view'] = origin.loadname
+        
+            tb_message = '\n'.join(traceback.format_exception(exc_type, exc_value, exc_traceback))
+
+            kwargs.setdefault('message', transform(force_unicode(exc_value)))
+
+            return self.process(
+                class_name=exc_type.__name__,
+                traceback=tb_message,
+                data=data,
+                **kwargs
+            )
+        finally:
+            if new_exc:
+                del exc_info
 
 class DummyClient(SentryClient):
     "Sends messages into an empty void"
diff --git a/sentry/client/log/__init__.py b/sentry/client/log/__init__.py
index db28cee5cb..18e1dad1ba 100644
--- a/sentry/client/log/__init__.py
+++ b/sentry/client/log/__init__.py
@@ -13,6 +13,9 @@ class LoggingSentryClient(SentryClient):
     
     def send(self, **kwargs):
         exc_info = sys.exc_info()
-        self.logger.log(kwargs.pop('level', None) or self.default_level,
-                        kwargs.pop('message', None) or exc_info[0],
-                        exc_info=exc_info, extra=kwargs)
+        try:
+            self.logger.log(kwargs.pop('level', None) or self.default_level,
+                            kwargs.pop('message', None) or exc_info[0],
+                            exc_info=exc_info, extra=kwargs)
+        finally:
+            del exc_info
diff --git a/sentry/client/models.py b/sentry/client/models.py
index 1970e8b74d..09ce6e1df0 100644
--- a/sentry/client/models.py
+++ b/sentry/client/models.py
@@ -36,10 +36,10 @@ client = get_client()
 
 @transaction.commit_on_success
 def sentry_exception_handler(request=None, **kwargs):
+    exc_info = sys.exc_info()
     try:
-        exc_type, exc_value, exc_traceback = sys.exc_info()
 
-        if settings.DEBUG or getattr(exc_type, 'skip_sentry', False):
+        if settings.DEBUG or getattr(exc_info[0], 'skip_sentry', False):
             return
 
         if transaction.is_dirty():
@@ -55,6 +55,8 @@ def sentry_exception_handler(request=None, **kwargs):
             logger.exception(u'Unable to process log entry: %s' % (exc,))
         except Exception, exc:
             warnings.warn(u'Unable to process log entry: %s' % (exc,))
+    finally:
+        del exc_info
 
 got_request_exception.connect(sentry_exception_handler)
 
diff --git a/tests/tests.py b/tests/tests.py
index 04a5fc93f7..dbb43f0034 100644
--- a/tests/tests.py
+++ b/tests/tests.py
@@ -164,7 +164,7 @@ class SentryTestCase(BaseTestCase):
         try:
             raise ValueError('This is a test ValueError')
         except ValueError:
-            logger.info('This is a test info with an exception', exc_info=sys.exc_info())
+            logger.info('This is a test info with an exception', exc_info=True)
             self.assertEquals(Message.objects.count(), 6)
             self.assertEquals(GroupedMessage.objects.count(), 5)
             last = Message.objects.all().order_by('-id')[0:1].get()
@@ -267,7 +267,7 @@ class SentryTestCase(BaseTestCase):
             raise SyntaxMessage(value)
         except Exception, exc:
             logging.exception(exc)
-            logging.info('test', exc_info=sys.exc_info())
+            logging.info('test', exc_info=True)
         self.assertEquals(Message.objects.count(), cnt+5)
         
         self.tearDownHandler()
@@ -295,7 +295,7 @@ class SentryTestCase(BaseTestCase):
             raise SyntaxMessage(value)
         except Exception, exc:
             logging.exception(exc)
-            logging.info('test', exc_info=sys.exc_info())
+            logging.info('test', exc_info=True)
         self.assertEquals(Message.objects.count(), cnt+5)
         
         self.tearDownHandler()
@@ -487,7 +487,7 @@ class SentryTestCase(BaseTestCase):
         
         last = Message.objects.get()
         
-        self.assertEquals(last.view, 'tests.tests.testExclusionViewPath')
+        self.assertEquals(last.view, 'tests.tests.test_exclusion_view_path')
 
     def test_best_guess_view(self):
         settings.EXCLUDE_PATHS = ['tests.tests']
@@ -497,7 +497,7 @@ class SentryTestCase(BaseTestCase):
         
         last = Message.objects.get()
         
-        self.assertEquals(last.view, 'tests.tests.testBestGuessView')
+        self.assertEquals(last.view, 'tests.tests.test_best_guess_view')
         
         settings.EXCLUDE_PATHS = []
 
diff --git a/tests/views.py b/tests/views.py
index 6dc77fe1a4..3b12978efe 100644
--- a/tests/views.py
+++ b/tests/views.py
@@ -2,7 +2,6 @@ from django.http import HttpResponse
 from django.shortcuts import get_object_or_404, render_to_response
 
 import logging
-import sys
 
 def django_exc(request):
     return get_object_or_404(Exception, pk=1)
@@ -21,5 +20,5 @@ def logging_request_exc(request):
     try:
         raise Exception(request.GET.get('message', 'view exception'))
     except Exception, e:
-        logger.error(e, exc_info=sys.exc_info(), extra={'request': request})
+        logger.error(e, exc_info=True, extra={'request': request})
     return HttpResponse('')
\ No newline at end of file

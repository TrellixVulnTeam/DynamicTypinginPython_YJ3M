commit c24e94ac22c2de43a69efd17c7b06ab48a293106
Author: David Cramer <dcramer@gmail.com>
Date:   Tue Aug 16 12:27:28 2011 -0700

    Improve efficiency of cleanup command

diff --git a/CHANGES b/CHANGES
index f120b36a97..07663c318f 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,3 +1,7 @@
+1.8.8
+
+* Changed ``sentry cleanup`` to use a range query.
+
 1.8.7
 
 * Added "Clear Feed" option.
diff --git a/sentry/scripts/runner.py b/sentry/scripts/runner.py
index f75987862f..6eadf7b4ac 100644
--- a/sentry/scripts/runner.py
+++ b/sentry/scripts/runner.py
@@ -100,26 +100,34 @@ class SentryServer(DaemonRunner):
 
 def cleanup(days=30, logger=None, site=None, server=None):
     from sentry.models import GroupedMessage, Message
+    from sentry.utils.query import RangeQuerySetWrapper, SkinnyQuerySet
     import datetime
     
     ts = datetime.datetime.now() - datetime.timedelta(days=days)
     
-    qs = Message.objects.filter(datetime__lte=ts)
+    qs = SkinnyQuerySet(Message).filter(datetime__lte=ts)
     if logger:
         qs.filter(logger=logger)
     if site:
         qs.filter(site=site)
     if server:
         qs.filter(server_name=server)
-    qs.delete()
+
+    for obj in RangeQuerySetWrapper(qs):
+        print ">>> Removing <%s: id=%s>" % (obj.__class__.__name__, obj.pk)
+        obj.delete()
     
     # TODO: we should collect which messages above were deleted
     # and potentially just send out post_delete signals where
     # GroupedMessage can update itself accordingly
-    qs = GroupedMessage.objects.filter(last_seen__lte=ts)
+
+    qs = SkinnyQuerySet(GroupedMessage).filter(last_seen__lte=ts)
     if logger:
         qs.filter(logger=logger)
-    qs.delete()
+
+    for obj in RangeQuerySetWrapper(qs):
+        print ">>> Removing <%s: id=%s>" % (obj.__class__.__name__, obj.pk)
+        obj.delete()
 
 def upgrade(interactive=True):
     from sentry.conf import settings
diff --git a/sentry/utils/query.py b/sentry/utils/query.py
new file mode 100644
index 0000000000..44928a21fc
--- /dev/null
+++ b/sentry/utils/query.py
@@ -0,0 +1,90 @@
+from django.db.models import Min, Max
+from django.db.models.fields import AutoField, IntegerField
+from django.db.models.query import QuerySet
+
+class QuerySetDoubleIteration(Exception):
+    "A QuerySet was iterated over twice, you probably want to list() it."
+    pass
+
+class InvalidQuerySetError(ValueError): pass
+
+class SkinnyQuerySet(QuerySet):
+    def __len__(self):
+        if getattr(self, 'has_run_before', False):
+            raise TypeError("SkinnyQuerySet doesn't support __len__ after __iter__, if you *only* need a count you should use .count(), if you need to reuse the results you should coerce to a list and then len() that.")
+        return super(SkinnyQuerySet, self).__len__()
+
+    def __iter__(self):
+        if self._result_cache is not None:
+            # __len__ must have been run
+            return iter(self._result_cache)
+
+        has_run_before = getattr(self, 'has_run_before', False)
+        if has_run_before:
+            raise QuerySetDoubleIteration("This SkinnyQuerySet has already been iterated over once, you should assign it to a list if you want to reuse the data.")
+        self.has_run_before = True
+
+        return self.iterator()
+
+    def list(self):
+        return list(self)
+
+class RangeQuerySetWrapper(object):
+    """
+    Iterates through a result set using MIN/MAX on primary key and stepping through.
+
+    Very efficient, but ORDER BY statements will not work.
+    """
+
+    def __init__(self, queryset, step=10000, limit=None, min_id=None, max_id=None, sorted=False):
+        # Support for slicing
+        if queryset.query.low_mark == 0 and not\
+          (queryset.query.order_by or queryset.query.extra_order_by):
+            if limit is None:
+                limit = queryset.query.high_mark
+            queryset.query.clear_limits()
+        else:
+            raise InvalidQuerySetError
+
+        self.limit = limit
+        if limit:
+            self.step = min(limit, step)
+        else:
+            self.step = step
+        self.queryset = queryset
+        self.min_id, self.max_id = min_id, max_id
+        self.sorted = sorted
+
+    def __iter__(self):
+        pk = self.queryset.model._meta.pk
+        if not isinstance(pk, (IntegerField, AutoField)):
+            raise NotImplementedError
+        else:
+            if self.min_id is not None and self.max_id is not None:
+                at, max_id = self.min_id, self.max_id
+            else:
+                at = self.queryset.aggregate(Min('pk'), Max('pk'))
+                max_id, at = at['pk__max'], at['pk__min']
+                if self.min_id:
+                    at = self.min_id
+                if self.max_id:
+                    max_id = self.max_id
+
+            if not (at and max_id):
+                return
+
+            num = 0
+            limit = self.limit or max_id
+
+            while at <= max_id and (not self.limit or num < self.limit):
+                results = self.queryset.filter(id__gte=at, id__lte=min(at+self.step-1, max_id))
+                if self.sorted:
+                    results = results.order_by('id')
+                results = results.iterator()
+
+                for result in results:
+                    yield result
+                    num += 1
+                    if num >= limit:
+                        break
+                at += self.step
\ No newline at end of file
diff --git a/setup.py b/setup.py
index 16af6262bc..d0a7c9b78c 100755
--- a/setup.py
+++ b/setup.py
@@ -41,7 +41,7 @@ if sys.version_info[:2] < (2, 5):
 
 setup(
     name='django-sentry',
-    version='1.8.7',
+    version='1.8.8',
     author='David Cramer',
     author_email='dcramer@gmail.com',
     url='http://github.com/dcramer/django-sentry',

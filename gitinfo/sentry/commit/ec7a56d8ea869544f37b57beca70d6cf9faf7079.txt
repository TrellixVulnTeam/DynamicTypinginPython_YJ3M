commit ec7a56d8ea869544f37b57beca70d6cf9faf7079
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Thu Jan 9 10:22:31 2020 -0800

    fix(ui): Fix <ContextPickerModal> and refactor to ts (#16090)
    
    This removes `LatestContext` dependency and fixes `ContextPickerModal` and refactors it to ts.
    
    Co-Authored-By: Matej Minar <matej.minar@sentry.io>

diff --git a/src/sentry/static/sentry/app/components/contextPickerModal.jsx b/src/sentry/static/sentry/app/components/contextPickerModal.jsx
deleted file mode 100644
index 21d7282d77..0000000000
--- a/src/sentry/static/sentry/app/components/contextPickerModal.jsx
+++ /dev/null
@@ -1,320 +0,0 @@
-import PropTypes from 'prop-types';
-import React from 'react';
-import ReactDOM from 'react-dom';
-import Reflux from 'reflux';
-import createReactClass from 'create-react-class';
-import styled from 'react-emotion';
-
-import {fetchOrganizationDetails} from 'app/actionCreators/organizations';
-import {t} from 'app/locale';
-import LatestContextStore from 'app/stores/latestContextStore';
-import LoadingIndicator from 'app/components/loadingIndicator';
-import OrganizationsStore from 'app/stores/organizationsStore';
-import SelectControl from 'app/components/forms/selectControl';
-import SentryTypes from 'app/sentryTypes';
-import replaceRouterParams from 'app/utils/replaceRouterParams';
-import withProjects from 'app/utils/withProjects';
-import space from 'app/styles/space';
-
-class ContextPickerModal extends React.Component {
-  static propTypes = {
-    /**
-     * The destination route
-     */
-    nextPath: PropTypes.string.isRequired,
-
-    /**
-     * Finish callback
-     */
-    onFinish: PropTypes.func.isRequired,
-
-    /**
-     * Container for modal header
-     */
-    Header: PropTypes.oneOfType([PropTypes.element, PropTypes.func, PropTypes.string]),
-
-    /**
-     * Container for modal body
-     */
-    Body: PropTypes.oneOfType([PropTypes.element, PropTypes.func, PropTypes.string]),
-
-    /**
-     * List of available organizations
-     */
-    organizations: PropTypes.arrayOf(SentryTypes.Organization),
-
-    /**
-     * LatestContext store
-     */
-    latestContext: PropTypes.shape({
-      organization: SentryTypes.Organization,
-    }),
-
-    /**
-     * Does modal need to prompt for organization.
-     * TODO(billy): This can be derived from `nextPath`
-     */
-    needOrg: PropTypes.bool,
-
-    /**
-     * Does modal need to prompt for project
-     */
-    needProject: PropTypes.bool,
-  };
-
-  constructor(props) {
-    super(props);
-
-    const {needProject, latestContext} = props;
-
-    const shouldHaveEmptyOrgSelector = !needProject || !latestContext.organization;
-    this.state = {
-      // Initialize loading to true if there is only 1 organization because component will immediately
-      // attempt to fetch org details for that org. Otherwise we'd have to change state in `DidMount`
-      loading: props.organizations.length === 1,
-
-      // Org select should be empty except if we need a project and there's an org in context
-      // (otherwise they need to select an org before we can fetch projects)
-      selectedOrganization: shouldHaveEmptyOrgSelector
-        ? ''
-        : latestContext.organization.slug,
-    };
-  }
-
-  componentDidMount() {
-    const {latestContext, organizations} = this.props;
-
-    // Don't make any assumptions if there are multiple organizations
-    if (organizations.length !== 1) {
-      return;
-    }
-
-    // If there is an org in context (and there's only 1 org available),
-    // attempt to see if we need more info from user and redirect otherwise
-    if (latestContext.organization) {
-      // This will handle if we can intelligently move the user forward
-      this.navigateIfFinish(
-        [latestContext.organization],
-        latestContext.organization.projects
-      );
-      return;
-    }
-
-    // Since user belongs to only 1 org, we can set it as active and componentWillReceiveProps handle the rest
-    fetchOrganizationDetails(organizations[0].slug, {
-      setActive: true,
-      loadProjects: true,
-    });
-  }
-
-  componentWillReceiveProps(nextProps) {
-    // Should only check the case where there is no latestContext.organization and we're waiting
-    // for it to be set (after fetch in DidMount)
-    const {latestContext} = this.props;
-    if (
-      (!latestContext.organization &&
-        latestContext.organization !== nextProps.latestContext.organization) ||
-      (latestContext.organization &&
-        nextProps.latestContext.organization &&
-        latestContext.organization.slug !== nextProps.latestContext.organization.slug)
-    ) {
-      // Check if we can push the user forward w/o needing them to select anything
-      this.navigateIfFinish(
-        this.props.organizations,
-        nextProps.latestContext.organization.projects,
-        nextProps.latestContext.organization
-      );
-    }
-  }
-
-  // Performs checks to see if we need to prompt user
-  // i.e. When there is only 1 org and no project is needed or
-  // there is only 1 org and only 1 project (which should be rare)
-  navigateIfFinish = (
-    organizations,
-    projects,
-    latestOrg = this.props.latestContext && this.props.latestContext.organization
-  ) => {
-    const {needProject, onFinish, nextPath} = this.props;
-
-    // If no project is needed and theres only 1 org OR
-    // if we need a project and there's only 1 project
-    // then return because we can't navigate anywhere yet
-    if (
-      (!needProject && organizations.length !== 1) ||
-      (needProject && projects.length !== 1)
-    ) {
-      this.setState({loading: false});
-      return;
-    }
-
-    // If there is only one org and we dont need a project slug, then call finish callback
-    if (!needProject) {
-      onFinish(
-        replaceRouterParams(nextPath, {
-          orgId: organizations[0].slug,
-        })
-      );
-      return;
-    }
-
-    // Use latest org or if only 1 org, use that
-    let org = latestOrg;
-    if (!org && organizations.length === 1) {
-      org = organizations[0];
-    }
-
-    onFinish(
-      replaceRouterParams(nextPath, {
-        orgId: org.slug,
-        projectId: projects[0].slug,
-      })
-    );
-  };
-
-  focusProjectSelector = () => {
-    if (!this.projectSelect || this.state.loading) {
-      return;
-    }
-
-    ReactDOM.findDOMNode(this.projectSelect)
-      .querySelector('input')
-      .focus();
-  };
-
-  focusOrganizationSelector = () => {
-    if (!this.orgSelect || this.state.loading) {
-      return;
-    }
-
-    ReactDOM.findDOMNode(this.orgSelect)
-      .querySelector('input')
-      .focus();
-  };
-
-  handleSelectOrganization = ({value}) => {
-    // Don't do anything if org value doesn't actually change
-    if (this.state.selectedOrganization === value) {
-      return;
-    }
-
-    // If we do not need to select a project, we can early return after selecting an org
-    // No need to fetch org details
-    if (!this.props.needProject) {
-      this.navigateIfFinish([{slug: value}], []);
-      return;
-    }
-
-    this.setState(
-      {
-        selectedOrganization: value,
-        loading: true,
-      },
-      () => fetchOrganizationDetails(value, {setActive: true, loadProjects: true})
-    );
-  };
-
-  handleSelectProject = ({value}) => {
-    const {latestContext} = this.props;
-
-    if (!value || !latestContext.organization) {
-      return;
-    }
-
-    this.navigateIfFinish([latestContext.organization], [{slug: value}]);
-  };
-
-  render() {
-    const {latestContext, needOrg, needProject, organizations, Header, Body} = this.props;
-    const {loading} = this.state;
-
-    const shouldShowPicker = needOrg || needProject;
-
-    const projects = latestContext.organization && latestContext.organization.projects;
-
-    if (!shouldShowPicker) {
-      return null;
-    }
-
-    const shouldShowProjectSelector =
-      latestContext.organization && needProject && projects;
-
-    const orgChoices = organizations
-      .filter(({status}) => status.id !== 'pending_deletion')
-      .map(({slug}) => ({label: slug, value: slug}));
-
-    return (
-      <div>
-        <React.Fragment>
-          <Header closeButton>{t('Select...')}</Header>
-          <Body>
-            {loading && <StyledLoadingIndicator overlay />}
-            <div>{t('Select an organization/project to continue')}</div>
-            {needOrg && (
-              <StyledSelectControl
-                innerRef={ref => {
-                  this.orgSelect = ref;
-                  if (shouldShowProjectSelector) {
-                    return;
-                  }
-                  this.focusOrganizationSelector();
-                }}
-                placeholder="Select an Organization"
-                name="organization"
-                options={orgChoices}
-                openOnFocus
-                value={this.state.selectedOrganization}
-                onChange={this.handleSelectOrganization}
-              />
-            )}
-
-            {latestContext.organization && needProject && projects && (
-              <StyledSelectControl
-                innerRef={ref => {
-                  this.projectSelect = ref;
-                  this.focusProjectSelector();
-                }}
-                placeholder="Select a Project"
-                name="project"
-                value=""
-                openOnFocus
-                options={projects.map(({slug}) => ({label: slug, value: slug}))}
-                onChange={this.handleSelectProject}
-              />
-            )}
-          </Body>
-        </React.Fragment>
-      </div>
-    );
-  }
-}
-
-const ContextPickerModalContainer = withProjects(
-  createReactClass({
-    displayName: 'ContextPickerModalContainer',
-    mixins: [
-      Reflux.connect(LatestContextStore, 'latestContext'),
-      Reflux.connect(OrganizationsStore, 'organizations'),
-    ],
-    render() {
-      return (
-        <ContextPickerModal
-          {...this.props}
-          latestContext={this.state.latestContext}
-          organizations={this.state.organizations}
-        />
-      );
-    },
-  })
-);
-
-export default ContextPickerModalContainer;
-export {ContextPickerModal};
-
-const StyledSelectControl = styled(SelectControl)`
-  margin-top: ${space(1)};
-`;
-
-const StyledLoadingIndicator = styled(LoadingIndicator)`
-  z-index: 1;
-`;
diff --git a/src/sentry/static/sentry/app/components/contextPickerModal.tsx b/src/sentry/static/sentry/app/components/contextPickerModal.tsx
new file mode 100644
index 0000000000..5631ee571a
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/contextPickerModal.tsx
@@ -0,0 +1,308 @@
+import {ModalBody, ModalHeader} from 'react-bootstrap';
+import React from 'react';
+import ReactDOM from 'react-dom';
+import Reflux from 'reflux';
+import createReactClass from 'create-react-class';
+import styled from 'react-emotion';
+
+import {Organization, Project} from 'app/types';
+import {t} from 'app/locale';
+import LoadingIndicator from 'app/components/loadingIndicator';
+import OrganizationStore from 'app/stores/organizationStore';
+import OrganizationsStore from 'app/stores/organizationsStore';
+import Projects from 'app/utils/projects';
+import SelectControl from 'app/components/forms/selectControl';
+import replaceRouterParams from 'app/utils/replaceRouterParams';
+import space from 'app/styles/space';
+
+type Props = {
+  /**
+   * The destination route
+   */
+  nextPath: string;
+
+  /**
+   * Container for modal header
+   */
+  Header: typeof ModalHeader;
+
+  /**
+   * Container for modal body
+   */
+  Body: typeof ModalBody;
+
+  /**
+   * List of available organizations
+   */
+  organizations: Organization[];
+
+  /**
+   * Does modal need to prompt for organization.
+   * TODO(billy): This can be derived from `nextPath`
+   */
+  needOrg: boolean;
+
+  /**
+   * Does modal need to prompt for project
+   */
+  needProject: boolean;
+
+  /**
+   * Organization slug
+   */
+  organization: string;
+
+  projects: Project[];
+  loading: boolean;
+
+  /**
+   * Finish callback
+   */
+  onFinish: (path: string) => void;
+
+  /**
+   * Callback for when organization is selected
+   */
+  onSelectOrganization: (orgSlug: string) => void;
+};
+
+class ContextPickerModal extends React.Component<Props> {
+  componentDidMount() {
+    const {organization, projects, organizations} = this.props;
+
+    // Don't make any assumptions if there are multiple organizations
+    if (organizations.length !== 1) {
+      return;
+    }
+
+    // If there is an org in context (and there's only 1 org available),
+    // attempt to see if we need more info from user and redirect otherwise
+    if (organization) {
+      // This will handle if we can intelligently move the user forward
+      this.navigateIfFinish([{slug: organization}], projects);
+      return;
+    }
+  }
+
+  componentDidUpdate(prevProps) {
+    // Component may be mounted before projects is fetched, check if we can finish when
+    // component is updated with projects
+    if (prevProps.projects !== this.props.projects) {
+      this.navigateIfFinish(this.props.organizations, this.props.projects);
+    }
+  }
+
+  orgSelect: Element | null = null;
+  projectSelect: Element | null = null;
+
+  // Performs checks to see if we need to prompt user
+  // i.e. When there is only 1 org and no project is needed or
+  // there is only 1 org and only 1 project (which should be rare)
+  navigateIfFinish = (
+    organizations: Array<{slug: string}>,
+    projects: Array<{slug: string}>,
+    latestOrg: string = this.props.organization
+  ) => {
+    const {needProject, onFinish, nextPath} = this.props;
+
+    // If no project is needed and theres only 1 org OR
+    // if we need a project and there's only 1 project
+    // then return because we can't navigate anywhere yet
+    if (
+      (!needProject && organizations.length !== 1) ||
+      (needProject && projects.length !== 1)
+    ) {
+      return;
+    }
+
+    // If there is only one org and we dont need a project slug, then call finish callback
+    if (!needProject) {
+      onFinish(
+        replaceRouterParams(nextPath, {
+          orgId: organizations[0].slug,
+        })
+      );
+      return;
+    }
+
+    // Use latest org or if only 1 org, use that
+    let org = latestOrg;
+    if (!org && organizations.length === 1) {
+      org = organizations[0].slug;
+    }
+
+    onFinish(
+      replaceRouterParams(nextPath, {
+        orgId: org,
+        projectId: projects[0].slug,
+      })
+    );
+  };
+
+  doFocus = (ref: Element | null) => {
+    if (!ref || this.props.loading) {
+      return;
+    }
+
+    // eslint-disable-next-line react/no-find-dom-node
+    const el = ReactDOM.findDOMNode(ref) as HTMLElement;
+
+    if (el !== null) {
+      const input = el.querySelector('input');
+
+      input && input.focus();
+    }
+  };
+
+  focusProjectSelector = () => {
+    this.doFocus(this.projectSelect);
+  };
+
+  focusOrganizationSelector = () => {
+    this.doFocus(this.orgSelect);
+  };
+
+  handleSelectOrganization = ({value}: {value: string}) => {
+    // If we do not need to select a project, we can early return after selecting an org
+    // No need to fetch org details
+    if (!this.props.needProject) {
+      this.navigateIfFinish([{slug: value}], []);
+      return;
+    }
+
+    this.props.onSelectOrganization(value);
+  };
+
+  handleSelectProject = ({value}: {value: string}) => {
+    const {organization} = this.props;
+    if (!value || !organization) {
+      return;
+    }
+
+    this.navigateIfFinish([{slug: organization}], [{slug: value}]);
+  };
+
+  render() {
+    const {
+      needOrg,
+      needProject,
+      organization,
+      organizations,
+      projects,
+      loading,
+      Header,
+      Body,
+    } = this.props;
+
+    const shouldShowPicker = needOrg || needProject;
+
+    if (!shouldShowPicker) {
+      return null;
+    }
+
+    const shouldShowProjectSelector = organization && needProject && projects;
+
+    const orgChoices = organizations
+      .filter(({status}) => status.id !== 'pending_deletion')
+      .map(({slug}) => ({label: slug, value: slug}));
+
+    return (
+      <React.Fragment>
+        <Header closeButton>{t('Select...')}</Header>
+        <Body>
+          {loading && <StyledLoadingIndicator overlay />}
+          <div>{t('Select an organization/project to continue')}</div>
+          {needOrg && (
+            <StyledSelectControl
+              innerRef={ref => {
+                this.orgSelect = ref;
+                if (shouldShowProjectSelector) {
+                  return;
+                }
+                this.focusOrganizationSelector();
+              }}
+              placeholder={t('Select an Organization')}
+              name="organization"
+              options={orgChoices}
+              openOnFocus
+              value={organization}
+              onChange={this.handleSelectOrganization}
+            />
+          )}
+
+          {organization && needProject && projects && (
+            <StyledSelectControl
+              innerRef={ref => {
+                this.projectSelect = ref;
+                this.focusProjectSelector();
+              }}
+              placeholder={t('Select a Project')}
+              name="project"
+              value=""
+              openOnFocus
+              options={projects.map(({slug}) => ({label: slug, value: slug}))}
+              onChange={this.handleSelectProject}
+            />
+          )}
+        </Body>
+      </React.Fragment>
+    );
+  }
+}
+
+type ContainerProps = {};
+
+type ContainerState = {
+  organizations?: Organization[];
+  selectedOrganization?: string;
+};
+
+const ContextPickerModalContainer = createReactClass<ContainerProps, ContainerState>({
+  displayName: 'ContextPickerModalContainer',
+  mixins: [Reflux.connect(OrganizationsStore, 'organizations') as any],
+  getInitialState() {
+    return {
+      selectedOrganization:
+        OrganizationStore.organization && OrganizationStore.organization.slug,
+    };
+  },
+
+  handleSelectOrganization(organizationSlug) {
+    this.setState({selectedOrganization: organizationSlug});
+  },
+
+  renderModal({projects, fetching}) {
+    return (
+      <ContextPickerModal
+        {...this.props}
+        projects={projects}
+        loading={fetching}
+        organizations={this.state.organizations}
+        organization={this.state.selectedOrganization}
+        onSelectOrganization={this.handleSelectOrganization}
+      />
+    );
+  },
+
+  render() {
+    if (this.state.selectedOrganization) {
+      return (
+        <Projects orgId={this.state.selectedOrganization} allProjects>
+          {renderProps => this.renderModal(renderProps)}
+        </Projects>
+      );
+    }
+
+    return this.renderModal({});
+  },
+});
+
+export default ContextPickerModalContainer;
+
+const StyledSelectControl = styled(SelectControl)`
+  margin-top: ${space(1)};
+`;
+
+const StyledLoadingIndicator = styled(LoadingIndicator)`
+  z-index: 1;
+`;
diff --git a/tests/js/spec/components/contextPickerModal.spec.jsx b/tests/js/spec/components/contextPickerModal.spec.jsx
index 97b929e87a..ebd00d5295 100644
--- a/tests/js/spec/components/contextPickerModal.spec.jsx
+++ b/tests/js/spec/components/contextPickerModal.spec.jsx
@@ -1,8 +1,10 @@
 import React from 'react';
 
-import * as OrgActions from 'app/actionCreators/organizations';
 import {mountWithTheme} from 'sentry-test/enzyme';
-import {ContextPickerModal} from 'app/components/contextPickerModal';
+import ContextPickerModal from 'app/components/contextPickerModal';
+import OrganizationStore from 'app/stores/organizationStore';
+import OrganizationsStore from 'app/stores/organizationsStore';
+import ProjectsStore from 'app/stores/projectsStore';
 
 jest.mock('jquery');
 
@@ -11,6 +13,7 @@ describe('ContextPickerModal', function() {
   const onFinish = jest.fn();
 
   beforeEach(function() {
+    ProjectsStore.reset();
     MockApiClient.clearMockResponses();
     onFinish.mockReset();
 
@@ -23,6 +26,12 @@ describe('ContextPickerModal', function() {
     });
   });
 
+  afterEach(async function() {
+    OrganizationsStore.load([]);
+    OrganizationStore.reset();
+    await tick();
+  });
+
   const getComponent = props => (
     <ContextPickerModal
       Header={() => <div />}
@@ -30,88 +39,72 @@ describe('ContextPickerModal', function() {
       nextPath="/test/:orgId/path/"
       organizations={[org, org2]}
       needOrg
-      latestContext={{}}
       onFinish={onFinish}
       {...props}
     />
   );
 
-  it('renders with only org selector when no org in latest context', function() {
+  it('renders with only org selector when no org is selected', async function() {
     const wrapper = mountWithTheme(getComponent());
 
     expect(wrapper.find('StyledSelectControl[name="organization"]').exists()).toBe(true);
     expect(wrapper.find('StyledSelectControl[name="project"]').exists()).toBe(false);
-  });
 
-  it('fetches org details and sets as active org if there is only one org', function() {
-    const spy = jest.spyOn(OrgActions, 'fetchOrganizationDetails');
-    const api = MockApiClient.addMockResponse({
-      url: `/organizations/${org2.slug}/`,
-    });
-    const wrapper = mountWithTheme(
-      getComponent({organizations: [org2]}),
-      TestStubs.routerContext()
-    );
-
-    wrapper.update();
-    expect(spy).toHaveBeenCalledWith('org2', {
-      setActive: true,
-      loadProjects: true,
-    });
-    expect(api).toHaveBeenCalled();
+    await tick();
+    wrapper.unmount();
   });
 
-  it('calls onFinish after latestContext is set, if project id is not needed, and only 1 org', function() {
-    const spy = jest.spyOn(OrgActions, 'fetchOrganizationDetails');
-    const api = MockApiClient.addMockResponse({
-      url: `/organizations/${org2.slug}/`,
+  it('calls onFinish, if project id is not needed, and only 1 org', async function() {
+    OrganizationsStore.load([org2]);
+    OrganizationStore.onUpdate(org2);
+    MockApiClient.addMockResponse({
+      url: `/organizations/${org2.slug}/projects/`,
+      body: [],
     });
-    const wrapper = mountWithTheme(
-      getComponent({organizations: [org2]}),
-      TestStubs.routerContext()
-    );
+    const wrapper = mountWithTheme(getComponent(), TestStubs.routerContext());
 
-    expect(spy).toHaveBeenCalledWith('org2', {
-      setActive: true,
-      loadProjects: true,
-    });
-    expect(api).toHaveBeenCalled();
-
-    wrapper.setProps({latestContext: {organization: org2}});
-    wrapper.update();
     expect(onFinish).toHaveBeenCalledWith('/test/org2/path/');
+    await tick();
+    wrapper.unmount();
   });
 
-  it('calls onFinish if there is only 1 org and 1 project', function() {
-    const spy = jest.spyOn(OrgActions, 'fetchOrganizationDetails');
-    const api = MockApiClient.addMockResponse({
-      url: `/organizations/${org2.slug}/`,
+  it('calls onFinish if there is only 1 org and 1 project', async function() {
+    expect(onFinish).not.toHaveBeenCalled();
+    OrganizationsStore.load([org2]);
+    OrganizationStore.onUpdate(org2);
+
+    const fetchProjectsForOrg = MockApiClient.addMockResponse({
+      url: `/organizations/${org2.slug}/projects/`,
+      body: [project2],
     });
+
     const wrapper = mountWithTheme(
       getComponent({
         needOrg: true,
         needProject: true,
         nextPath: '/test/:orgId/path/:projectId/',
-        organizations: [org2],
       }),
       TestStubs.routerContext()
     );
 
-    expect(spy).toHaveBeenCalledWith('org2', {
-      setActive: true,
-      loadProjects: true,
-    });
-    expect(api).toHaveBeenCalled();
+    expect(fetchProjectsForOrg).toHaveBeenCalled();
+    expect(onFinish).not.toHaveBeenCalled();
 
-    wrapper.setProps({latestContext: {organization: {...org2, projects: [project2]}}});
+    await tick();
     wrapper.update();
-    expect(onFinish).toHaveBeenCalledWith('/test/org2/path/project2/');
+
+    expect(onFinish).toHaveBeenLastCalledWith('/test/org2/path/project2/');
+
+    await tick();
+    wrapper.unmount();
   });
 
-  it('selects an org and calls `onFinish` with URL with organization slug', function() {
+  it('selects an org and calls `onFinish` with URL with organization slug', async function() {
+    OrganizationsStore.load([org]);
     const wrapper = mountWithTheme(getComponent({}), TestStubs.routerContext());
-    const mock = MockApiClient.addMockResponse({
-      url: `/organizations/${org.slug}/`,
+    MockApiClient.addMockResponse({
+      url: `/organizations/${org.slug}/projects/`,
+      body: [],
     });
 
     wrapper.find('StyledSelectControl[name="organization"] input').simulate('focus');
@@ -122,25 +115,35 @@ describe('ContextPickerModal', function() {
       .find('Select[name="organization"] Option')
       .first()
       .simulate('mouseDown');
+
+    await tick();
+    wrapper.update();
     expect(onFinish).toHaveBeenCalledWith('/test/org-slug/path/');
-    // Is not called because we don't need to fetch org details
-    expect(mock).not.toHaveBeenCalled();
+
+    await tick();
+    wrapper.unmount();
   });
 
-  it('renders with project selector and org selector selected when org is in latest context', function() {
+  it('renders with project selector and org selector selected when org is already selected', async function() {
+    OrganizationStore.onUpdate(org);
+    const fetchProjectsForOrg = MockApiClient.addMockResponse({
+      url: `/organizations/${org.slug}/projects/`,
+      body: [project, project2],
+    });
+    await tick();
+
     const wrapper = mountWithTheme(
       getComponent({
         needOrg: true,
         needProject: true,
-        latestContext: {
-          organization: {
-            ...org,
-            projects: [project, project2],
-          },
-        },
       })
     );
 
+    await tick();
+    wrapper.update();
+
+    expect(fetchProjectsForOrg).toHaveBeenCalled();
+
     // Default to org in latest context
     expect(wrapper.find('StyledSelectControl[name="organization"]').prop('value')).toBe(
       org.slug
@@ -149,62 +152,63 @@ describe('ContextPickerModal', function() {
       {value: project.slug, label: project.slug},
       {value: project2.slug, label: project2.slug},
     ]);
+
+    await tick();
+    wrapper.unmount();
   });
 
   it('can select org and project', async function() {
-    const spy = jest.spyOn(OrgActions, 'fetchOrganizationDetails');
-    const api = MockApiClient.addMockResponse({
-      url: `/organizations/${org2.slug}/`,
+    const organizations = [
+      {
+        ...org,
+        projects: [project],
+      },
+      {
+        ...org2,
+        projects: [project2, TestStubs.Project({slug: 'project3'})],
+      },
+    ];
+    const fetchProjectsForOrg = MockApiClient.addMockResponse({
+      url: `/organizations/${org2.slug}/projects/`,
+      body: organizations[1].projects,
     });
+
+    OrganizationsStore.load(organizations);
+
     const wrapper = mountWithTheme(
       getComponent({
         needOrg: true,
         needProject: true,
         nextPath: '/test/:orgId/path/:projectId/',
-        organizations: [
-          {
-            ...org,
-            projects: [project],
-          },
-          {
-            ...org2,
-            projects: [project2],
-          },
-        ],
+        organizations,
       }),
       TestStubs.routerContext()
     );
 
+    await tick();
+    wrapper.update();
+
     // Should not have anything selected
     expect(wrapper.find('StyledSelectControl[name="organization"]').prop('value')).toBe(
-      ''
+      null
     );
 
-    spy.mockClear();
-
     // Select org2
     wrapper
       .find('StyledSelectControl[name="organization"]')
       .simulate('change', {value: org2.slug, label: org2.slug});
-
     wrapper.find('StyledSelectControl[name="organization"] input').simulate('focus');
     wrapper
       .find('Select[name="organization"] Option')
       .at(1)
       .simulate('mouseDown');
 
-    expect(spy).toHaveBeenCalledWith('org2', {
-      setActive: true,
-      loadProjects: true,
-    });
-    expect(api).toHaveBeenCalled();
-
-    // org2 should have 2 projects, project2 and project3
-    wrapper.setProps({
-      latestContext: {organization: {...org2, projects: [project2, {slug: 'project3'}]}},
-    });
+    await tick();
     wrapper.update();
 
+    // <Projects> will fetch projects for org2
+    expect(fetchProjectsForOrg).toHaveBeenCalled();
+
     expect(wrapper.find('StyledSelectControl[name="project"]').prop('options')).toEqual([
       {value: project2.slug, label: project2.slug},
       {value: 'project3', label: 'project3'},
@@ -218,5 +222,8 @@ describe('ContextPickerModal', function() {
       .simulate('mouseDown');
 
     expect(onFinish).toHaveBeenCalledWith('/test/org2/path/project3/');
+
+    await tick();
+    wrapper.unmount();
   });
 });

commit 3c56db036df8868795029aeae3a66ea0aadae934
Author: Brett Hoerner <brett@bretthoerner.com>
Date:   Wed Nov 21 16:53:50 2018 -0600

    fix(snuba): Fix search pagination, remove old/unused in-memory scorinâ€¦ (#10718)
    
    * fix(snuba): Fix search pagination, remove old/unused in-memory scoring logic
    
    * Adjust comment and filter on more_results.
    
    * Fix tests after more_results filter.
    
    * Spacing.

diff --git a/src/sentry/search/snuba/backend.py b/src/sentry/search/snuba/backend.py
index 057d13a0ac..dc2a4b1002 100644
--- a/src/sentry/search/snuba/backend.py
+++ b/src/sentry/search/snuba/backend.py
@@ -314,8 +314,6 @@ class SnubaSearchBackend(ds.DjangoSearchBackend):
         paginator_results = Paginator(Group.objects.none()).get_result()
         result_groups = []
         result_group_ids = set()
-        min_score = float('inf')
-        max_score = -1
 
         max_time = options.get('snuba.search.max-total-chunk-time-seconds')
         time_start = time.time()
@@ -380,29 +378,6 @@ class SnubaSearchBackend(ds.DjangoSearchBackend):
                     result_group_ids.add(group_id)
                     result_groups.append((group_id, group_score))
 
-                    # used for cursor logic
-                    min_score = min(min_score, group_score)
-                    max_score = max(max_score, group_score)
-
-            # HACK: If a cursor is being used and there may be more results available
-            # in Snuba, we need to detect whether the cursor's value will be
-            # found in the result groups. If it isn't in the results yet we need to
-            # continue querying before we hand off to the paginator to decide whether
-            # enough results are found or not, otherwise the paginator will happily
-            # return `limit` worth of results that don't take the cursor into account
-            # at all, since it can't know there are more results available.
-            # TODO: If chunked search works in practice we should probably extend the
-            # paginator to throw something if the cursor value is never found, or do
-            # something other than partially leak internal paginator logic up to here.
-            # Or make separate Paginator implementation just for Snuba search?
-            if cursor is not None \
-                    and not candidate_ids \
-                    and more_results:
-                if cursor.is_prev and min_score < cursor.value:
-                    continue
-                elif not cursor.is_prev and max_score > cursor.value:
-                    continue
-
             paginator_results = SequencePaginator(
                 [(score, id) for (id, score) in result_groups],
                 reverse=True,
@@ -418,6 +393,24 @@ class SnubaSearchBackend(ds.DjangoSearchBackend):
                     or not more_results:
                 break
 
+        # HACK: We're using the SequencePaginator to mask the complexities of going
+        # back and forth between two databases. This causes a problem with pagination
+        # because we're 'lying' to the SequencePaginator (it thinks it has the entire
+        # result set in memory when it does not). For this reason we need to make some
+        # best guesses as to whether the `prev` and `next` cursors have more results.
+        if len(paginator_results.results) == limit and more_results:
+            # Because we are going back and forth between DBs there is a small
+            # chance that we will hand the SequencePaginator exactly `limit`
+            # items. In this case the paginator will assume there are no more
+            # results, so we need to override the `next` cursor's results.
+            paginator_results.next.has_results = True
+
+        if cursor is not None and (not cursor.is_prev or len(paginator_results.results) > 0):
+            # If the user passed a cursor, and it isn't already a 0 result `is_prev`
+            # cursor, then it's worth allowing them to go back a page to check for
+            # more results.
+            paginator_results.prev.has_results = True
+
         metrics.timing('snuba.search.num_chunks', num_chunks)
 
         groups = Group.objects.in_bulk(paginator_results.results)
@@ -498,7 +491,7 @@ def snuba_search(start, end, project_id, environment_id, tags,
         having=having,
         filter_keys=filters,
         aggregations=aggregations,
-        orderby='-' + sort_field,
+        orderby=['-' + sort_field, 'issue'],  # ensure stable sort within the same score
         referrer='search',
         limit=limit + 1,
         offset=offset,
diff --git a/tests/snuba/search/test_backend.py b/tests/snuba/search/test_backend.py
index c8bb3d8676..b515d1c93b 100644
--- a/tests/snuba/search/test_backend.py
+++ b/tests/snuba/search/test_backend.py
@@ -338,23 +338,46 @@ class SnubaSearchTest(SnubaTestCase):
             with self.options(options_set):
                 results = self.backend.query(self.project, limit=1, sort_by='date')
                 assert set(results) == set([self.group1])
+                assert not results.prev.has_results
+                assert results.next.has_results
 
                 results = self.backend.query(
                     self.project, cursor=results.next, limit=1, sort_by='date')
                 assert set(results) == set([self.group2])
+                assert results.prev.has_results
+                assert not results.next.has_results
 
-                # note: previous
+                # note: previous cursor
                 results = self.backend.query(
                     self.project, cursor=results.prev, limit=1, sort_by='date')
                 assert set(results) == set([self.group1])
+                assert results.prev.has_results
+                assert results.next.has_results
+
+                # note: previous cursor, paging too far into 0 results
+                results = self.backend.query(
+                    self.project, cursor=results.prev, limit=1, sort_by='date')
+                assert set(results) == set([])
+                assert not results.prev.has_results
+                assert results.next.has_results
+
+                results = self.backend.query(
+                    self.project, cursor=results.next, limit=1, sort_by='date')
+                assert set(results) == set([self.group1])
+                assert results.prev.has_results
+                assert results.next.has_results
 
                 results = self.backend.query(
                     self.project, cursor=results.next, limit=1, sort_by='date')
                 assert set(results) == set([self.group2])
+                assert results.prev.has_results
+                assert not results.next.has_results
 
                 results = self.backend.query(
                     self.project, cursor=results.next, limit=1, sort_by='date')
                 assert set(results) == set([])
+                assert results.prev.has_results
+                assert not results.next.has_results
 
     def test_pagination_with_environment(self):
         for dt in [
@@ -830,7 +853,7 @@ class SnubaSearchTest(SnubaTestCase):
 
         self.backend.query(self.project, query='foo', sort_by='date', last_seen_from=timezone.now())
         assert query_mock.call_args == mock.call(
-            orderby='-last_seen',
+            orderby=['-last_seen', 'issue'],
             aggregations=[['toUInt64(max(timestamp)) * 1000', '', 'last_seen']],
             having=[('last_seen', '>=', Any(int))],
             **common_args
@@ -838,7 +861,7 @@ class SnubaSearchTest(SnubaTestCase):
 
         self.backend.query(self.project, query='foo', sort_by='priority')
         assert query_mock.call_args == mock.call(
-            orderby='-priority',
+            orderby=['-priority', 'issue'],
             aggregations=[
                 ['(toUInt64(log(times_seen) * 600)) + last_seen', '', 'priority'],
                 ['count()', '', 'times_seen'],
@@ -850,7 +873,7 @@ class SnubaSearchTest(SnubaTestCase):
 
         self.backend.query(self.project, query='foo', sort_by='freq', times_seen=5)
         assert query_mock.call_args == mock.call(
-            orderby='-times_seen',
+            orderby=['-times_seen', 'issue'],
             aggregations=[['count()', '', 'times_seen']],
             having=[('times_seen', '=', 5)],
             **common_args
@@ -858,7 +881,7 @@ class SnubaSearchTest(SnubaTestCase):
 
         self.backend.query(self.project, query='foo', sort_by='new', age_from=timezone.now())
         assert query_mock.call_args == mock.call(
-            orderby='-first_seen',
+            orderby=['-first_seen', 'issue'],
             aggregations=[['toUInt64(min(timestamp)) * 1000', '', 'first_seen']],
             having=[('first_seen', '>=', Any(int))],
             **common_args

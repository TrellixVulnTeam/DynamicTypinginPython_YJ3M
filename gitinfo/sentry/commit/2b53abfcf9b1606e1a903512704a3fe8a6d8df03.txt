commit 2b53abfcf9b1606e1a903512704a3fe8a6d8df03
Author: David Cramer <dcramer@gmail.com>
Date:   Thu Sep 2 19:10:51 2010 -0700

    Move sentry.client into sentry.client.base to avoid recursive imports in settings

diff --git a/README.rst b/README.rst
index 59ca775ec4..fe236c4ea1 100644
--- a/README.rst
+++ b/README.rst
@@ -177,7 +177,7 @@ If you wish to access these within your own views and models, you may do so via
 
 You can also record errors outside of handler if you want::
 
-	from sentry.client import SentryClient
+	from sentry.client.base import SentryClient
 	
 	try:
 		...
@@ -186,7 +186,7 @@ You can also record errors outside of handler if you want::
 
 If you wish to log normal messages (useful for non-``logging`` integration)::
 
-	from sentry.client import SentryClient
+	from sentry.client.base import SentryClient
 	import logging
 	
 	SentryClient.create_from_text('Message Message'[, level=logging.WARNING, url=None])
diff --git a/sentry/client/__init__.py b/sentry/client/__init__.py
index aae3956108..e69de29bb2 100644
--- a/sentry/client/__init__.py
+++ b/sentry/client/__init__.py
@@ -1,146 +0,0 @@
-import base64
-try:
-    import cPickle as pickle
-except ImportError:
-    import pickle
-import logging
-import socket
-import sys
-import traceback as traceback_mod
-import urllib
-import urllib2
-import warnings
-
-from django.core.cache import cache
-from django.template import TemplateSyntaxError
-from django.utils.encoding import smart_unicode
-from django.views.debug import ExceptionReporter
-
-from sentry import settings
-from sentry.helpers import construct_checksum, varmap, transform
-
-logger = logging.getLogger('sentry')
-
-class SentryClient(object):
-    def process(self, **kwargs):
-        from sentry.helpers import get_filters
-
-        for filter_ in get_filters():
-            kwargs = filter_(None).process(kwargs) or kwargs
-
-        kwargs.setdefault('level', logging.ERROR)
-        kwargs.setdefault('server_name', socket.gethostname())
-
-        checksum = construct_checksum(**kwargs)
-
-        if settings.THRASHING_TIMEOUT and settings.THRASHING_LIMIT:
-            cache_key = 'sentry:%s:%s' % (kwargs.get('class_name'), checksum)
-            added = cache.add(cache_key, 1, settings.THRASHING_TIMEOUT)
-            if not added and cache.incr(cache_key) > settings.THRASHING_LIMIT:
-                return
-
-        if settings.REMOTE_URL:
-            data = {
-                'data': base64.b64encode(pickle.dumps(transform(kwargs)).encode('zlib')),
-                'key': settings.KEY,
-            }
-            req = urllib2.Request(settings.REMOTE_URL, urllib.urlencode(data))
-
-            try:
-                response = urllib2.urlopen(req).read()
-            except urllib2.HTTPError, e:
-                logger.exception('Unable to reach Sentry log server', extra={'body': e.read()})
-        else:
-            from sentry.models import GroupedMessage
-            
-            return GroupedMessage.objects.from_kwargs(**kwargs)
-
-    def create_from_record(self, record, **kwargs):
-        """
-        Creates an error log for a `logging` module `record` instance.
-        """
-        for k in ('url', 'view', 'data'):
-            if k not in kwargs:
-                kwargs[k] = record.__dict__.get(k)
-        kwargs.update({
-            'logger': record.name,
-            'level': record.levelno,
-            'message': record.getMessage(),
-        })
-        if record.exc_info:
-            return self.create_from_exception(*record.exc_info[1:2], **kwargs)
-
-        return self.process(
-            traceback=record.exc_text,
-            **kwargs
-        )
-
-    def create_from_text(self, message, **kwargs):
-        """
-        Creates an error log for from ``type`` and ``message``.
-        """
-        return self.process(
-            message=message,
-            **kwargs
-        )
-
-    def create_from_exception(self, exception=None, traceback=None, **kwargs):
-        """
-        Creates an error log from an exception.
-        """
-        if not exception:
-            exc_type, exc_value, traceback = sys.exc_info()
-        elif not traceback:
-            warnings.warn('Using just the ``exception`` argument is deprecated, send ``traceback`` in addition.', DeprecationWarning)
-            exc_type, exc_value, traceback = sys.exc_info()
-        else:
-            exc_type = exception.__class__
-            exc_value = exception
-
-        def to_unicode(f):
-            if isinstance(f, dict):
-                nf = dict()
-                for k, v in f.iteritems():
-                    nf[str(k)] = to_unicode(v)
-                f = nf
-            elif isinstance(f, (list, tuple)):
-                f = [to_unicode(f) for f in f]
-            else:
-                try:
-                    f = smart_unicode(f)
-                except (UnicodeEncodeError, UnicodeDecodeError):
-                    f = '(Error decoding value)'
-            return f
-
-        def shorten(var):
-            if not isinstance(var, basestring):
-                var = to_unicode(var)
-            if len(var) > 500:
-                var = var[:500] + '...'
-            return var
-
-        reporter = ExceptionReporter(None, exc_type, exc_value, traceback)
-        frames = varmap(shorten, reporter.get_traceback_frames())
-
-        data = kwargs.pop('data', {}) or {}
-        data['__sentry__'] = {
-            'exc': map(to_unicode, [exc_type.__class__.__module__, exc_value.args, frames]),
-        }
-
-        if isinstance(exc_value, TemplateSyntaxError) and hasattr(exc_value, 'source'):
-            origin, (start, end) = exc_value.source
-            data['__sentry__'].update({
-                'template': (origin.reload(), start, end, origin.name),
-            })
-        
-        tb_message = '\n'.join(traceback_mod.format_exception(exc_type, exc_value, traceback))
-
-        kwargs.setdefault('message', to_unicode(exc_value))
-
-        return self.process(
-            class_name=exc_type.__name__,
-            traceback=tb_message,
-            data=data,
-            **kwargs
-        )
-SentryClient = SentryClient()
\ No newline at end of file
diff --git a/sentry/client/base.py b/sentry/client/base.py
new file mode 100644
index 0000000000..aae3956108
--- /dev/null
+++ b/sentry/client/base.py
@@ -0,0 +1,146 @@
+import base64
+try:
+    import cPickle as pickle
+except ImportError:
+    import pickle
+import logging
+import socket
+import sys
+import traceback as traceback_mod
+import urllib
+import urllib2
+import warnings
+
+from django.core.cache import cache
+from django.template import TemplateSyntaxError
+from django.utils.encoding import smart_unicode
+from django.views.debug import ExceptionReporter
+
+from sentry import settings
+from sentry.helpers import construct_checksum, varmap, transform
+
+logger = logging.getLogger('sentry')
+
+class SentryClient(object):
+    def process(self, **kwargs):
+        from sentry.helpers import get_filters
+
+        for filter_ in get_filters():
+            kwargs = filter_(None).process(kwargs) or kwargs
+
+        kwargs.setdefault('level', logging.ERROR)
+        kwargs.setdefault('server_name', socket.gethostname())
+
+        checksum = construct_checksum(**kwargs)
+
+        if settings.THRASHING_TIMEOUT and settings.THRASHING_LIMIT:
+            cache_key = 'sentry:%s:%s' % (kwargs.get('class_name'), checksum)
+            added = cache.add(cache_key, 1, settings.THRASHING_TIMEOUT)
+            if not added and cache.incr(cache_key) > settings.THRASHING_LIMIT:
+                return
+
+        if settings.REMOTE_URL:
+            data = {
+                'data': base64.b64encode(pickle.dumps(transform(kwargs)).encode('zlib')),
+                'key': settings.KEY,
+            }
+            req = urllib2.Request(settings.REMOTE_URL, urllib.urlencode(data))
+
+            try:
+                response = urllib2.urlopen(req).read()
+            except urllib2.HTTPError, e:
+                logger.exception('Unable to reach Sentry log server', extra={'body': e.read()})
+        else:
+            from sentry.models import GroupedMessage
+            
+            return GroupedMessage.objects.from_kwargs(**kwargs)
+
+    def create_from_record(self, record, **kwargs):
+        """
+        Creates an error log for a `logging` module `record` instance.
+        """
+        for k in ('url', 'view', 'data'):
+            if k not in kwargs:
+                kwargs[k] = record.__dict__.get(k)
+        kwargs.update({
+            'logger': record.name,
+            'level': record.levelno,
+            'message': record.getMessage(),
+        })
+        if record.exc_info:
+            return self.create_from_exception(*record.exc_info[1:2], **kwargs)
+
+        return self.process(
+            traceback=record.exc_text,
+            **kwargs
+        )
+
+    def create_from_text(self, message, **kwargs):
+        """
+        Creates an error log for from ``type`` and ``message``.
+        """
+        return self.process(
+            message=message,
+            **kwargs
+        )
+
+    def create_from_exception(self, exception=None, traceback=None, **kwargs):
+        """
+        Creates an error log from an exception.
+        """
+        if not exception:
+            exc_type, exc_value, traceback = sys.exc_info()
+        elif not traceback:
+            warnings.warn('Using just the ``exception`` argument is deprecated, send ``traceback`` in addition.', DeprecationWarning)
+            exc_type, exc_value, traceback = sys.exc_info()
+        else:
+            exc_type = exception.__class__
+            exc_value = exception
+
+        def to_unicode(f):
+            if isinstance(f, dict):
+                nf = dict()
+                for k, v in f.iteritems():
+                    nf[str(k)] = to_unicode(v)
+                f = nf
+            elif isinstance(f, (list, tuple)):
+                f = [to_unicode(f) for f in f]
+            else:
+                try:
+                    f = smart_unicode(f)
+                except (UnicodeEncodeError, UnicodeDecodeError):
+                    f = '(Error decoding value)'
+            return f
+
+        def shorten(var):
+            if not isinstance(var, basestring):
+                var = to_unicode(var)
+            if len(var) > 500:
+                var = var[:500] + '...'
+            return var
+
+        reporter = ExceptionReporter(None, exc_type, exc_value, traceback)
+        frames = varmap(shorten, reporter.get_traceback_frames())
+
+        data = kwargs.pop('data', {}) or {}
+        data['__sentry__'] = {
+            'exc': map(to_unicode, [exc_type.__class__.__module__, exc_value.args, frames]),
+        }
+
+        if isinstance(exc_value, TemplateSyntaxError) and hasattr(exc_value, 'source'):
+            origin, (start, end) = exc_value.source
+            data['__sentry__'].update({
+                'template': (origin.reload(), start, end, origin.name),
+            })
+        
+        tb_message = '\n'.join(traceback_mod.format_exception(exc_type, exc_value, traceback))
+
+        kwargs.setdefault('message', to_unicode(exc_value))
+
+        return self.process(
+            class_name=exc_type.__name__,
+            traceback=tb_message,
+            data=data,
+            **kwargs
+        )
+SentryClient = SentryClient()
\ No newline at end of file
diff --git a/sentry/client/handlers.py b/sentry/client/handlers.py
index 55b58fb6d6..9821346dde 100644
--- a/sentry/client/handlers.py
+++ b/sentry/client/handlers.py
@@ -2,6 +2,6 @@ import logging
 
 class SentryHandler(logging.Handler):
     def emit(self, record):
-        from sentry.client import SentryClient
+        from sentry.client.base import SentryClient
 
         SentryClient.create_from_record(record)
\ No newline at end of file
diff --git a/sentry/client/models.py b/sentry/client/models.py
index 51d68ea829..71c9f89a87 100644
--- a/sentry/client/models.py
+++ b/sentry/client/models.py
@@ -9,7 +9,7 @@ from django.db import  transaction
 from django.http import Http404
 
 from sentry import settings
-from sentry.client import SentryClient
+from sentry.client.base import SentryClient
 from sentry.helpers import get_installed_apps
 
 logger = logging.getLogger('sentry')
diff --git a/sentry/models.py b/sentry/models.py
index aac510af51..ebf87c70d4 100644
--- a/sentry/models.py
+++ b/sentry/models.py
@@ -17,7 +17,7 @@ from django.utils.encoding import smart_unicode
 from django.utils.translation import ugettext_lazy as _
 
 from sentry import settings
-from sentry.client import SentryClient
+from sentry.client.base import SentryClient
 from sentry.helpers import construct_checksum, get_installed_apps, transform
 from sentry.manager import SentryManager, GroupedMessageManager
 
diff --git a/sentry/tests/tests.py b/sentry/tests/tests.py
index d6cc5ef966..e422925b16 100644
--- a/sentry/tests/tests.py
+++ b/sentry/tests/tests.py
@@ -20,7 +20,7 @@ from django.utils.encoding import smart_unicode
 from sentry import settings
 from sentry.helpers import transform
 from sentry.models import Message, GroupedMessage
-from sentry.client import SentryClient
+from sentry.client.base import SentryClient
 from sentry.client.models import sentry_exception_handler
 
 from models import TestModel, DuplicateKeyModel

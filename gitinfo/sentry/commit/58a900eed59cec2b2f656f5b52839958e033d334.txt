commit 58a900eed59cec2b2f656f5b52839958e033d334
Author: David Cramer <dcramer@gmail.com>
Date:   Tue Feb 12 15:50:41 2013 -0800

    Attempt to do some useful math

diff --git a/Makefile b/Makefile
index d990955eb6..9d1fdf710c 100644
--- a/Makefile
+++ b/Makefile
@@ -32,7 +32,7 @@ update-submodules:
 
 test: install-test-requirements lint test-js test-python
 
-test-loop: install-test-requirements
+testloop: install-test-requirements
 	pip install pytest-xdist --use-mirrors
 	py.test tests -f
 
diff --git a/src/sentry/conf/defaults.py b/src/sentry/conf/defaults.py
index 4f26f1f7f2..ce33f97304 100644
--- a/src/sentry/conf/defaults.py
+++ b/src/sentry/conf/defaults.py
@@ -83,11 +83,6 @@ MAIL_INCLUDE_LOGGERS = None
 # A list of loggers to exclude in emails.
 MAIL_EXCLUDE_LOGGERS = []
 
-# Normalize counts to the 15 minute marker. This value MUST be less than 60. A
-# value of 0 would store counts for every minute, and is the lowest level of
-# accuracy provided.
-MINUTE_NORMALIZATION = 15
-
 # The number of events to display per page
 MESSAGES_PER_PAGE = 15
 
diff --git a/src/sentry/constants.py b/src/sentry/constants.py
index de1384472e..ac61868013 100644
--- a/src/sentry/constants.py
+++ b/src/sentry/constants.py
@@ -124,3 +124,8 @@ PLATFORM_TITLES = {
     'flask': 'Flask (Python)',
     'csharp': 'C#',
 }
+
+# Normalize counts to the 15 minute marker. This value MUST be less than 60. A
+# value of 0 would store counts for every minute, and is the lowest level of
+# accuracy provided.
+MINUTE_NORMALIZATION = 15
diff --git a/src/sentry/manager.py b/src/sentry/manager.py
index a7fec976ff..bdae273e6d 100644
--- a/src/sentry/manager.py
+++ b/src/sentry/manager.py
@@ -31,13 +31,13 @@ from django.utils.encoding import force_unicode
 from raven.utils.encoding import to_string
 from sentry import app
 from sentry.conf import settings
-from sentry.constants import STATUS_RESOLVED, STATUS_UNRESOLVED
+from sentry.constants import STATUS_RESOLVED, STATUS_UNRESOLVED, MINUTE_NORMALIZATION
 from sentry.processors.base import send_group_processors
 from sentry.signals import regression_signal
 from sentry.tasks.index import index_event
 from sentry.tasks.fetch_source import fetch_javascript_source
 from sentry.utils.cache import cache, Lock
-from sentry.utils.dates import get_sql_date_trunc
+from sentry.utils.dates import get_sql_date_trunc, normalize_datetime
 from sentry.utils.db import get_db_engine, has_charts, attach_foreignkey
 from sentry.utils.models import create_or_update, make_key
 from sentry.utils.queue import maybe_delay
@@ -311,7 +311,7 @@ class ChartMixin(object):
         # the last interval is not accurate, so we exclude it
         # TODO: it'd be ideal to normalize the last datapoint so that we can include it
         # and not have ~inaccurate data for up to MINUTE_NORMALIZATION
-        today -= datetime.timedelta(minutes=settings.MINUTE_NORMALIZATION)
+        today -= datetime.timedelta(minutes=MINUTE_NORMALIZATION)
 
         if max_days >= 30:
             g_type = 'date'
@@ -328,7 +328,7 @@ class ChartMixin(object):
         else:
             g_type = 'minute'
             d_type = 'minutes'
-            modifier = settings.MINUTE_NORMALIZATION
+            modifier = MINUTE_NORMALIZATION
             points = max_days * 24 * (60 / modifier)
 
         min_date = today - datetime.timedelta(days=max_days)
@@ -570,11 +570,7 @@ class GroupManager(BaseManager, ChartMixin):
             is_sample = True
 
         # Rounded down to the nearest interval
-        if settings.MINUTE_NORMALIZATION:
-            minutes = (date.minute - (date.minute % settings.MINUTE_NORMALIZATION))
-        else:
-            minutes = date.minute
-        normalized_datetime = date.replace(second=0, microsecond=0, minute=minutes)
+        normalized_datetime = normalize_datetime(date)
 
         app.buffer.incr(GroupCountByMinute, update_kwargs, {
             'group': group,
@@ -713,7 +709,7 @@ class GroupManager(BaseManager, ChartMixin):
         queryset = queryset._clone()
         queryset.query.select_related = False
 
-        normalization = float(settings.MINUTE_NORMALIZATION)
+        normalization = float(MINUTE_NORMALIZATION)
         assert minutes >= normalization
 
         engine = get_db_engine(queryset.db)
diff --git a/src/sentry/tasks/check_alerts.py b/src/sentry/tasks/check_alerts.py
index 6d57f2224d..f39319330c 100644
--- a/src/sentry/tasks/check_alerts.py
+++ b/src/sentry/tasks/check_alerts.py
@@ -15,8 +15,7 @@ sentry.tasks.cleanup
 Notes:
 
 - Nydus optimizes out multiple writes/gets, so its not as expensive as it looks
-- Values that are not set need to constitute missing data, and we either need to ignore them or normalize them to the
-  average from the before/after points
+- If there are not enough data points in history, alerts are never sent (as they could be false positives)
 
 Last Notified will be tracked by using a new Alert model, which has the following properties:
 
@@ -27,28 +26,72 @@ Last Notified will be tracked by using a new Alert model, which has the followin
 
 Type and ident would be similar to how Activity works.
 
+Alert expiration threshold MUST be > MINUTE_NORMALIZATION.
+
 :copyright: (c) 2010-2012 by the Sentry Team, see AUTHORS for more details.
 :license: BSD, see LICENSE for more details.
 """
+from __future__ import division
 
-from celery.task import task
-from sentry import app
-from sentry.utils.queue import maybe_delay
+from datetime import timedelta
+from celery.task import periodic_task, task
+from celery.task.schedules import crontab
+from django.utils import timezone
 
+def fsteps(start, stop, steps):
+    step = (stop - start) / steps
+    while start <= stop:
+        yield start
+        start += step
 
-@task(ignore_result=True)
+
+@periodic_task(ignore_result=True, run_every=crontab(minute='*'))
 def check_alerts(**kwargs):
     """
     Iterates all current keys and checks if fires additional tasks
     to check each individual project's alert settings.
     """
+    from sentry import app
+    from sentry.utils.queue import maybe_delay
+
     count_results = app.counter.extract_counts(prefix='project')
-    when = count_results.pop('time')
+    when = timezone.fromtimestamp(count_results.pop('time'))
     for name, results in count_results.iteritems():
         for project_id, count in results.iteritems():
             maybe_delay(check_project_alerts, name=name, project_id=project_id, when=when, count=count, expires=120)
 
 
 @task(ignore_result=True)
-def check_project_alerts(name, project_id, when, count, **kwargs):
-    pass
\ No newline at end of file
+def check_project_alerts(project_id, name, when, count, **kwargs):
+    """
+    Given 'when' and 'count', which should signify recent times we compare it to historical data for this project
+    and if over a given threshold, create an alert.
+    """
+    from sentry.constants import MINUTE_NORMALIZATION
+    from sentry.models import ProjectCountByMinute
+
+    # number of 15 minute intervals to capture
+    intervals = 8
+
+    min_date = when
+    max_date = when - timedelta(minutes=(intervals * MINUTE_NORMALIZATION))
+
+    # get historical data
+    data = list(ProjectCountByMinute.objects.filter(
+        project=project_id,
+        date__lt=min_date,
+        date__gte=max_date,
+    ).values_list('times_seen', flat=True))
+
+    # Bail if we dont have enough data points
+    if len(data) != intervals:
+        return False
+
+    # take a weighted mean, where the oldest value is worth .5 and the newest is 1.0
+    previous = sum((k * v) for k, v in zip(data, fsteps(0.5, 1.0, intervals))) / intervals / MINUTE_NORMALIZATION
+    threshold = 300  # 200 percent
+    if count / previous * 100 > threshold:
+        # we could raise an alert here!
+        return True
+    return False
+
diff --git a/src/sentry/utils/dates.py b/src/sentry/utils/dates.py
index 97135bab08..95a550d6fe 100644
--- a/src/sentry/utils/dates.py
+++ b/src/sentry/utils/dates.py
@@ -9,6 +9,7 @@ from datetime import datetime
 from dateutil.parser import parse
 from django.db import connections
 
+from sentry.constants import MINUTE_NORMALIZATION
 from sentry.utils.db import get_db_engine
 
 DATE_TRUNC_GROUPERS = {
@@ -51,3 +52,9 @@ def parse_date(datestr, timestr):
             return parse(datetimestr)
         except Exception:
             return
+
+
+def normalize_datetime(datetime, minutes=MINUTE_NORMALIZATION):
+    minutes = (datetime.minute - (datetime.minute % minutes))
+    normalized_datetime = datetime.replace(second=0, microsecond=0, minute=minutes)
+    return normalized_datetime
diff --git a/tests/sentry/tasks/check_alerts/__init__.py b/tests/sentry/tasks/check_alerts/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/tests/sentry/tasks/check_alerts/tests.py b/tests/sentry/tasks/check_alerts/tests.py
new file mode 100644
index 0000000000..66dfab62a9
--- /dev/null
+++ b/tests/sentry/tasks/check_alerts/tests.py
@@ -0,0 +1,47 @@
+from datetime import timedelta
+from django.utils import timezone
+from sentry.models import ProjectCountByMinute
+from sentry.tasks.check_alerts import check_project_alerts
+from sentry.testutils import TestCase
+from sentry.utils.dates import normalize_datetime
+
+
+class CheckProjectAlertsTest(TestCase):
+    def create_counts(self, when, amount, minute_offset=0):
+        ProjectCountByMinute.objects.create(
+            project=self.project,
+            date=normalize_datetime(when - timedelta(minutes=minute_offset)),
+            times_seen=amount,
+        )
+
+    def test_it_works(self):
+        now = timezone.now()
+
+        # create some data with gaps
+        self.create_counts(now, 50)  # just now
+        self.create_counts(now, 73, 15)  # 15 minutes ago
+        self.create_counts(now, 100, 45)  # 45 minutes ago
+        self.create_counts(now, 90, 60)  # 60 minutes ago
+        self.create_counts(now, 95, 75)  # 75 minutes ago
+        self.create_counts(now, 130, 90)  # 90 minutes ago
+        self.create_counts(now, 150, 105)  # 105 minutes ago
+        self.create_counts(now, 100, 120)  # 120 minutes ago
+
+        # the 45 minute interval should be ignored and the
+        # 30 minute interval should be normalized to the 15 minute interval
+        can_alert = check_project_alerts(
+            project_id=self.project.id,
+            name='total',
+            when=now,
+            count=15
+        )
+        assert can_alert is False
+
+        self.create_counts(now, 73, 30)  # 15 minutes ago
+        can_alert = check_project_alerts(
+            project_id=self.project.id,
+            name='total',
+            when=now,
+            count=15
+        )
+        assert can_alert is True

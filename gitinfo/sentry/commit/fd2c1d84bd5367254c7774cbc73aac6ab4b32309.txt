commit fd2c1d84bd5367254c7774cbc73aac6ab4b32309
Author: Matte Noble <me@mattenoble.com>
Date:   Wed Jan 23 14:10:06 2019 -0800

    feat(app-platform): Issue Resolved webhooks (#11574)
    
    - Adds Sentry App webhooks for when an Issue is resolved
    - Consolidates Sentry App task code into one file
    - Consolidates Sentry App signal receiving into one file

diff --git a/src/sentry/api/endpoints/project_group_index.py b/src/sentry/api/endpoints/project_group_index.py
index 6360828bc3..8f965384e5 100644
--- a/src/sentry/api/endpoints/project_group_index.py
+++ b/src/sentry/api/endpoints/project_group_index.py
@@ -29,7 +29,10 @@ from sentry.models import (
 )
 from sentry.models.event import Event
 from sentry.models.savedsearch import DEFAULT_SAVED_SEARCH_QUERIES
-from sentry.signals import advanced_search, issue_ignored, issue_resolved_in_release, resolved_with_commit
+from sentry.signals import (
+    advanced_search, issue_ignored, issue_resolved, issue_resolved_in_release,
+    resolved_with_commit,
+)
 from sentry.tasks.integrations import kick_off_status_syncs
 from sentry.tasks.merge import merge_groups
 from sentry.utils import metrics
@@ -491,6 +494,13 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint, EnvironmentMixin):
                         group=group,
                         sender=type(self),
                     )
+                else:
+                    issue_resolved.send_robust(
+                        project=project,
+                        group=group,
+                        user=acting_user,
+                        sender=type(self),
+                    )
 
                 kick_off_status_syncs.apply_async(kwargs={
                     'project_id': group.project_id,
diff --git a/src/sentry/api/serializers/models/app_platform_event.py b/src/sentry/api/serializers/models/app_platform_event.py
index f68430dc8b..d520ff206d 100644
--- a/src/sentry/api/serializers/models/app_platform_event.py
+++ b/src/sentry/api/serializers/models/app_platform_event.py
@@ -39,18 +39,17 @@ class AppPlatformEvent(object):
 
     @property
     def body(self):
-        return {
+        return json.dumps({
             'action': self.action,
             'installation': {
                 'uuid': self.install.uuid,
             },
             'data': self.data,
             'actor': self.get_actor(),
-        }
+        })
 
     @property
     def headers(self):
-        body = json.dumps(self.body)
         request_uuid = uuid4().hex
 
         return {
@@ -58,5 +57,5 @@ class AppPlatformEvent(object):
             'Request-ID': request_uuid,
             'Sentry-Hook-Resource': self.resource,
             'Sentry-Hook-Timestamp': six.text_type(int(time())),
-            'Sentry-Hook-Signature': self.install.sentry_app.build_signature(body)
+            'Sentry-Hook-Signature': self.install.sentry_app.build_signature(self.body)
         }
diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index ddc1563abc..99cac2b647 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -449,7 +449,7 @@ CELERY_IMPORTS = (
     'sentry.tasks.scheduler', 'sentry.tasks.signals', 'sentry.tasks.store', 'sentry.tasks.unmerge',
     'sentry.tasks.symcache_update', 'sentry.tasks.servicehooks',
     'sentry.tagstore.tasks', 'sentry.tasks.assemble', 'sentry.tasks.integrations',
-    'sentry.tasks.files', 'sentry.tasks.app_platform',
+    'sentry.tasks.files', 'sentry.tasks.sentry_apps',
 )
 CELERY_QUEUES = [
     Queue('activity.notify', routing_key='activity.notify'),
diff --git a/src/sentry/mediators/sentry_app_installations/creator.py b/src/sentry/mediators/sentry_app_installations/creator.py
index 4be79b730b..61d71c23d8 100644
--- a/src/sentry/mediators/sentry_app_installations/creator.py
+++ b/src/sentry/mediators/sentry_app_installations/creator.py
@@ -7,7 +7,7 @@ from sentry.models import (
     ApiAuthorization, ApiGrant, SentryApp, SentryAppInstallation
 )
 from sentry.utils.cache import memoize
-from sentry.tasks.app_platform import installation_webhook
+from sentry.tasks.sentry_apps import installation_webhook
 
 
 class Creator(Mediator):
diff --git a/src/sentry/mediators/service_hooks/creator.py b/src/sentry/mediators/service_hooks/creator.py
index cf3ed90f38..5e4db3e449 100644
--- a/src/sentry/mediators/service_hooks/creator.py
+++ b/src/sentry/mediators/service_hooks/creator.py
@@ -7,14 +7,7 @@ from itertools import chain
 
 from sentry.mediators import Mediator, Param
 from sentry.models import ServiceHook
-
-# Subscribing to these events via the UI is done in a resource-centric way.
-# This means you subscribe to "Issue" events. There are many types of Issue
-# events - this maps those resource-centric values to the actual events
-# emitted.
-EVENT_EXPANSION = {
-    'issue': ['issue.created'],
-}
+from sentry.models.sentryapp import EVENT_EXPANSION
 
 
 def expand_events(rolled_up_events):
@@ -50,8 +43,10 @@ class Creator(Mediator):
         return self.hook
 
     def _create_service_hook(self):
+        application_id = self.application.id if self.application else None
+
         return ServiceHook.objects.create(
-            application_id=self.application.id,
+            application_id=application_id,
             actor_id=self.actor.id,
             project_id=self.project.id,
             events=expand_events(self.events),
diff --git a/src/sentry/models/release.py b/src/sentry/models/release.py
index 67fb1fdb13..d65190f853 100644
--- a/src/sentry/models/release.py
+++ b/src/sentry/models/release.py
@@ -24,6 +24,7 @@ from sentry.db.models import (
 )
 
 from sentry.models import CommitFileChange
+from sentry.signals import resolved_with_commit
 
 from sentry.utils import metrics
 from sentry.utils.cache import cache
@@ -561,11 +562,19 @@ class Release(Model):
                         'actor_id': actor.id if actor else None,
                     },
                 )
-                Group.objects.filter(
+                group = Group.objects.get(
                     id=group_id,
-                ).update(status=GroupStatus.RESOLVED)
+                )
+                group.update(status=GroupStatus.RESOLVED)
                 metrics.incr('group.resolved', instance='in_commit', skip_internal=True)
 
+            resolved_with_commit.send_robust(
+                organization_id=self.organization_id,
+                user=actor,
+                group=group,
+                sender=type(self),
+            )
+
             kick_off_status_syncs.apply_async(kwargs={
                 'project_id': group_project_lookup[group_id],
                 'group_id': group_id,
diff --git a/src/sentry/models/sentryapp.py b/src/sentry/models/sentryapp.py
index 1cc0992fe0..81521ec73c 100644
--- a/src/sentry/models/sentryapp.py
+++ b/src/sentry/models/sentryapp.py
@@ -3,6 +3,7 @@ from __future__ import absolute_import
 import six
 import uuid
 import hmac
+import itertools
 
 from django.db import models
 from django.db.models import Q
@@ -20,6 +21,16 @@ from sentry.db.models import (
     ParanoidModel,
 )
 
+# When a developer selects to receive "<Resource> Webhooks" it really means
+# listening to a list of specific events. This is a mapping of what those
+# specific events are for each resource.
+EVENT_EXPANSION = {
+    'issue': ['issue.created', 'issue.resolved'],
+}
+
+# We present Webhook Subscriptions per-resource (Issue, Project, etc.), not
+# per-event-type (issue.created, project.deleted, etc.). These are valid
+# resources a Sentry App may subscribe to.
 VALID_EVENT_RESOURCES = (
     'issue',
 )
@@ -32,6 +43,13 @@ REQUIRED_EVENT_PERMISSIONS = {
     'team': 'team:read',
 }
 
+# The only events valid for Sentry Apps are the ones listed in the values of
+# EVENT_EXPANSION above. This list is likely a subset of all valid ServiceHook
+# events.
+VALID_EVENTS = tuple(itertools.chain(
+    *EVENT_EXPANSION.values()
+))
+
 
 def default_uuid():
     return six.binary_type(uuid.uuid4())
diff --git a/src/sentry/models/servicehook.py b/src/sentry/models/servicehook.py
index 16688ba748..b0a25ba7eb 100644
--- a/src/sentry/models/servicehook.py
+++ b/src/sentry/models/servicehook.py
@@ -63,10 +63,14 @@ class ServiceHook(Model):
 
     @property
     def created_by_sentry_app(self):
-        return self.application_id and \
-            SentryApp.objects.filter(
-                application_id=self.application_id,
-            ).exists()
+        return (self.application_id and self.sentry_app)
+
+    @property
+    def sentry_app(self):
+        try:
+            return SentryApp.objects.get(application_id=self.application_id)
+        except SentryApp.DoesNotExist:
+            return
 
     def __init__(self, *args, **kwargs):
         super(ServiceHook, self).__init__(*args, **kwargs)
diff --git a/src/sentry/models/signals.py b/src/sentry/models/signals.py
deleted file mode 100644
index cb9a3669c8..0000000000
--- a/src/sentry/models/signals.py
+++ /dev/null
@@ -1,18 +0,0 @@
-from __future__ import absolute_import
-
-from django.db.models.signals import post_save
-from django.dispatch import receiver
-
-from sentry.models import Group
-
-
-@receiver(post_save, sender=Group)
-def resource_changed(sender, instance, created, **kwargs):
-    if created:
-        from sentry.tasks.servicehooks import process_resource_change
-
-        process_resource_change.delay(
-            action='created',
-            sender=sender.__name__,
-            instance_id=instance.id,
-        )
diff --git a/src/sentry/receivers/sentry_apps.py b/src/sentry/receivers/sentry_apps.py
new file mode 100644
index 0000000000..47cb1b7442
--- /dev/null
+++ b/src/sentry/receivers/sentry_apps.py
@@ -0,0 +1,83 @@
+from __future__ import absolute_import
+
+from django.db.models.signals import post_save
+from django.dispatch import receiver
+
+from sentry.models import Group, Organization
+from sentry.signals import (
+    issue_resolved,
+    issue_resolved_in_release,
+    resolved_with_commit,
+)
+from sentry.tasks.sentry_apps import (
+    process_resource_change,
+    workflow_notification,
+)
+
+
+@receiver(post_save, sender=Group, weak=False)
+def issue_saved(sender, instance, created, **kwargs):
+    issue = instance
+
+    # We only send webhooks for creation right now.
+    if not created:
+        return
+
+    process_resource_change.delay(
+        action='created',
+        sender=sender.__name__,
+        instance_id=issue.id,
+    )
+
+
+@issue_resolved_in_release.connect(weak=False)
+def issue_resolved_in_release(project, group, user, resolution_type, **kwargs):
+    send_workflow_webhooks(
+        project.organization,
+        group,
+        user,
+        'issue.resolved',
+        'resolved_in_release',
+    )
+
+
+@issue_resolved.connect(weak=False)
+def issue_resolved(project, group, user, **kwargs):
+    send_workflow_webhooks(
+        project.organization,
+        group,
+        user,
+        'issue.resolved',
+        'resolved',
+    )
+
+
+@resolved_with_commit.connect(weak=False)
+def resolved_with_commit(organization_id, group, user, **kwargs):
+    organization = Organization.objects.get(id=organization_id)
+    send_workflow_webhooks(
+        organization,
+        group,
+        user,
+        'issue.resolved',
+        'resolved_in_commit',
+    )
+
+
+def send_workflow_webhooks(organization, issue, user, event, resolution_type):
+    for install in installations_to_notify(organization, event):
+        workflow_notification.delay(
+            installation_id=install.id,
+            issue_id=issue.id,
+            type='resolved',
+            user_id=(user.id if user else None),
+            data={'resolution_type': resolution_type},
+        )
+
+
+def installations_to_notify(organization, event):
+    installations = organization  \
+        .sentry_app_installations \
+        .select_related('sentry_app')
+
+    return filter(lambda i: event in i.sentry_app.events, installations)
diff --git a/src/sentry/signals.py b/src/sentry/signals.py
index 8008ad597b..c39a42cd3f 100644
--- a/src/sentry/signals.py
+++ b/src/sentry/signals.py
@@ -78,6 +78,7 @@ mocks_loaded = BetterSignal(providing_args=["project"])
 
 user_feedback_received = BetterSignal(providing_args=["project"])
 issue_assigned = BetterSignal(providing_args=["project", "group", "user"])
+issue_resolved = BetterSignal(providing_args=["project", "group", "user"])
 issue_resolved_in_release = BetterSignal(
     providing_args=[
         "project",
diff --git a/src/sentry/tasks/app_platform.py b/src/sentry/tasks/app_platform.py
deleted file mode 100644
index b7db6cabbf..0000000000
--- a/src/sentry/tasks/app_platform.py
+++ /dev/null
@@ -1,50 +0,0 @@
-from __future__ import absolute_import
-
-import logging
-
-from requests.exceptions import RequestException
-
-from sentry.models import SentryAppInstallation, User
-from sentry.tasks.base import instrumented_task, retry
-
-logger = logging.Logger('sentry.tasks.app_platform')
-
-
-@instrumented_task(
-    name='sentry.tasks.app_platform.installation_webhook',
-    queue='app_platform',
-    default_retry_delay=(60 * 5),  # 5 minutes
-    max_retries=3,
-)
-@retry(on=(RequestException, ))
-def installation_webhook(installation_id, user_id):
-    from sentry.mediators.sentry_app_installations import InstallationNotifier
-
-    try:
-        install = SentryAppInstallation.objects.get(id=installation_id)
-    except SentryAppInstallation.DoesNotExist:
-        logger.info(
-            'installation_webhook.missing_installation',
-            extra={
-                'installation_id': installation_id,
-                'user_id': user_id,
-            },
-        )
-        return
-
-    try:
-        user = User.objects.get(id=user_id)
-    except User.DoesNotExist:
-        logger.info(
-            'installation_webhook.missing_user',
-            extra={
-                'installation_id': installation_id,
-                'user_id': user_id,
-            },
-        )
-        return
-
-    InstallationNotifier.run(
-        install=install,
-        user=user,
-    )
diff --git a/src/sentry/tasks/sentry_apps.py b/src/sentry/tasks/sentry_apps.py
index 343c5aeb25..cf76024330 100644
--- a/src/sentry/tasks/sentry_apps.py
+++ b/src/sentry/tasks/sentry_apps.py
@@ -2,52 +2,56 @@ from __future__ import absolute_import, print_function
 
 import logging
 
+from celery.task import current
 from django.core.urlresolvers import reverse
 from requests.exceptions import RequestException
 
 from sentry.http import safe_urlopen
 from sentry.tasks.base import instrumented_task, retry
 from sentry.utils.http import absolute_uri
-from sentry.models import SentryAppInstallation, SentryApp
-from sentry.api.serializers import AppPlatformEvent
+from sentry.api.serializers import serialize, AppPlatformEvent
+from sentry.models import (
+    SentryAppInstallation, Group, User, ServiceHook, Project, SentryApp,
+)
+from sentry.models.sentryapp import VALID_EVENTS
 
 logger = logging.Logger('sentry.tasks.sentry_apps')
 
+TASK_OPTIONS = {
+    'queue': 'app_platform',
+    'default_retry_delay': (60 * 5),  # Five minutes.
+    'max_retries': 3,
+}
 
-def notify_sentry_app(event, futures):
-    for f in futures:
-        if not f.kwargs.get('sentry_app'):
-            continue
+# We call some models by a different name, publically, than their class name.
+# For example the model Group is called "Issue" in the UI. We want the Service
+# Hook events to match what we externally call these primitives.
+RESOURCE_RENAMES = {
+    'Group': 'issue',
+}
 
-        sentry_app = f.kwargs['sentry_app']
-        send_alert_event.delay(
-            event=event,
-            rule=f.rule.label,
-            sentry_app_id=sentry_app.id,
-        )
+TYPES = {
+    'Group': Group,
+}
 
 
-@instrumented_task(
-    name='sentry.tasks.sentry_apps.send_alert_event', default_retry_delay=60 * 5, max_retries=5
-)
+@instrumented_task(name='sentry.tasks.sentry_apps.send_alert_event', **TASK_OPTIONS)
 @retry(on=(RequestException, ))
 def send_alert_event(event, rule, sentry_app_id):
-
     group = event.group
     project = group.project
 
+    extra = {
+        'sentry_app_id': sentry_app_id,
+        'project': project.slug,
+        'organization': project.organization.slug,
+        'rule': rule,
+    }
+
     try:
         sentry_app = SentryApp.objects.get(id=sentry_app_id)
     except SentryApp.DoesNotExist:
-        logger.info(
-            'event_alert_webhook.missing_sentry_app',
-            extra={
-                'sentry_app_id': sentry_app_id,
-                'project': project.slug,
-                'organization': project.organization.slug,
-                'rule': rule,
-            },
-        )
+        logger.info('event_alert_webhook.missing_sentry_app', extra=extra)
         return
 
     try:
@@ -56,15 +60,7 @@ def send_alert_event(event, rule, sentry_app_id):
             sentry_app=sentry_app,
         )
     except SentryAppInstallation.DoesNotExist:
-        logger.info(
-            'event_alert_webhook.missing_installation',
-            extra={
-                'sentry_app': sentry_app.slug,
-                'project': project.slug,
-                'organization': project.organization.slug,
-                'rule': rule,
-            },
-        )
+        logger.info('event_alert_webhook.missing_installation', extra=extra)
         return
 
     event_context = event.as_dict()
@@ -79,16 +75,19 @@ def send_alert_event(event, rule, sentry_app_id):
         group.id,
         event.id,
     ]))
+
+    # The URL has a regex OR in it ("|") which means `reverse` cannot generate
+    # a valid URL (it can't know which option to pick). We have to manually
+    # create this URL for, that reason.
     event_context['issue_url'] = absolute_uri(
         '/api/0/issues/{}/'.format(group.id),
     )
 
     data = {
         'event': event_context,
+        'triggered_rule': rule,
     }
 
-    data['triggered_rule'] = rule
-
     request_data = AppPlatformEvent(
         resource='event_alert',
         action='triggered',
@@ -102,3 +101,151 @@ def send_alert_event(event, rule, sentry_app_id):
         headers=request_data.headers,
         timeout=5,
     )
+
+
+@instrumented_task('sentry.tasks.process_resource_change', **TASK_OPTIONS)
+@retry()
+def process_resource_change(action, sender, instance_id, *args, **kwargs):
+    # The class is serialized as a string when enqueueing the class.
+    model = TYPES[sender]
+
+    # Some resources are named differently than their model. eg. Group vs
+    # Issue. Looks up the human name for the model. Defaults to the model name.
+    name = RESOURCE_RENAMES.get(model.__name__, model.__name__.lower())
+
+    # We may run into a race condition where this task executes before the
+    # transaction that creates the Group has committed.
+    try:
+        instance = model.objects.get(id=instance_id)
+    except model.DoesNotExist as e:
+        # Explicitly requeue the task, so we don't report this to Sentry until
+        # we hit the max number of retries.
+        return current.retry(exc=e)
+
+    event = '{}.{}'.format(name, action)
+
+    if event not in VALID_EVENTS:
+        return
+
+    org = None
+
+    if isinstance(instance, Group):
+        org = instance.organization
+
+    installations = filter(
+        lambda i: event in i.sentry_app.events,
+        org.sentry_app_installations.select_related('sentry_app'),
+    )
+
+    for installation in installations:
+        send_webhooks(installation, event, data=serialize(instance))
+
+
+@instrumented_task(name='sentry.tasks.sentry_apps.installation_webhook', **TASK_OPTIONS)
+@retry(on=(RequestException, ))
+def installation_webhook(installation_id, user_id, *args, **kwargs):
+    from sentry.mediators.sentry_app_installations import InstallationNotifier
+
+    extra = {
+        'installation_id': installation_id,
+        'user_id': user_id,
+    }
+
+    try:
+        install = SentryAppInstallation.objects.get(id=installation_id)
+    except SentryAppInstallation.DoesNotExist:
+        logger.info('installation_webhook.missing_installation', extra=extra)
+        return
+
+    try:
+        user = User.objects.get(id=user_id)
+    except User.DoesNotExist:
+        logger.info('installation_webhook.missing_user', extra=extra)
+        return
+
+    InstallationNotifier.run(
+        install=install,
+        user=user,
+    )
+
+
+@instrumented_task(name='sentry.tasks.sentry_apps.workflow_notification', **TASK_OPTIONS)
+@retry(on=(RequestException, ))
+def workflow_notification(installation_id, issue_id, type, user_id, *args, **kwargs):
+    extra = {
+        'installation_id': installation_id,
+        'issue_id': issue_id,
+    }
+
+    try:
+        install = SentryAppInstallation.objects.get(id=installation_id)
+    except SentryAppInstallation.DoesNotExist:
+        logger.info('workflow_notification.missing_installation', extra=extra)
+        return
+
+    try:
+        issue = Group.objects.get(id=issue_id)
+    except Group.DoesNotExist:
+        logger.info('workflow_notification.missing_issue', extra=extra)
+        return
+
+    user = None
+
+    try:
+        user = User.objects.get(id=user_id) if user_id else None
+    except User.DoesNotExist:
+        logger.info('workflow_notification.missing_user', extra=extra)
+
+    data = kwargs.get('data', {})
+    data.update({'issue': serialize(issue)})
+
+    send_webhooks(
+        installation=install,
+        event=u'issue.{}'.format(type),
+        data=data,
+        actor=user,
+    )
+
+
+def notify_sentry_app(event, futures):
+    for f in futures:
+        if not f.kwargs.get('sentry_app'):
+            continue
+
+        send_alert_event.delay(
+            event=event,
+            rule=f.rule.label,
+            sentry_app_id=f.kwargs['sentry_app'].id,
+        )
+
+
+def send_webhooks(installation, event, **kwargs):
+    project_ids = Project.objects.filter(
+        organization_id=installation.organization_id,
+    ).values_list('id', flat=True)
+
+    servicehooks = ServiceHook.objects.filter(
+        project_id__in=project_ids,
+    )
+
+    for servicehook in filter(lambda s: event in s.events, servicehooks):
+        if not servicehook.created_by_sentry_app:
+            continue
+
+        if servicehook.sentry_app != installation.sentry_app:
+            continue
+
+        resource, action = event.split('.')
+
+        kwargs['resource'] = resource
+        kwargs['action'] = action
+        kwargs['install'] = installation
+
+        request_data = AppPlatformEvent(**kwargs)
+
+        safe_urlopen(
+            url=servicehook.sentry_app.webhook_url,
+            data=request_data.body,
+            headers=request_data.headers,
+            timeout=5,
+        )
diff --git a/src/sentry/tasks/servicehooks.py b/src/sentry/tasks/servicehooks.py
index acbbfef382..fc76fb5966 100644
--- a/src/sentry/tasks/servicehooks.py
+++ b/src/sentry/tasks/servicehooks.py
@@ -1,125 +1,18 @@
 from __future__ import absolute_import, print_function
 
 import six
-import inspect
 
 from time import time
-from celery.task import current
 
-from sentry.api.serializers import serialize, AppPlatformEvent
+from sentry.api.serializers import serialize
 from sentry.http import safe_urlopen
-from sentry.models import Group, SentryAppInstallation, ServiceHook
-from sentry.tasks.base import instrumented_task, retry
+from sentry.models import ServiceHook
+from sentry.tasks.base import instrumented_task
 from sentry.utils import json
 from sentry.utils.http import absolute_uri
 
-# This is an extra, explicit, measure to ensure we only send events for
-# resource changes we deem necessary.
-ALLOWED_EVENTS = (
-    'issue.created',
-)
-
-# We call some models by a different name, publically, than their class name.
-# For example the model Group is called "Issue" in the UI. We want the Service
-# Hook events to match what we externally call these primitives.
-RESOURCE_RENAMES = {
-    'Group': 'issue',
-}
-
-TYPES = {
-    'Group': Group,
-}
-
-
-@instrumented_task(
-    'sentry.tasks.process_resource_change',
-    queue='app_platform',
-    default_retry_delay=60 * 5,
-    max_retries=5,
-)
-@retry()
-def process_resource_change(action, sender, instance_id, *args, **kwargs):
-    model = None
-    name = None
-
-    # Previous method signature.
-    if inspect.isclass(sender):
-        model = sender
-    else:
-        model = TYPES[sender]
-
-    name = RESOURCE_RENAMES.get(model.__name__, model.__name__.lower())
-
-    # We may run into a race condition where this task executes before the
-    # transaction that creates the Group has committed.
-    try:
-        instance = model.objects.get(id=instance_id)
-    except model.DoesNotExist as e:
-        # Explicitly requeue the task, so we don't report this to Sentry until
-        # we hit the max number of retries.
-        return current.retry(exc=e)
-
-    event = '{}.{}'.format(name, action)
-
-    if event not in ALLOWED_EVENTS:
-        return
-
-    project = None
-
-    if isinstance(instance, Group):
-        project = instance.project
-
-    if not project:
-        return
-
-    servicehooks = ServiceHook.objects.filter(
-        project_id=project.id,
-    )
-
-    for servicehook in filter(lambda s: event in s.events, servicehooks):
-        # For now, these ``post_save`` callbacks are only valid for service
-        # hooks created by a Sentry App.
-        if not servicehook.created_by_sentry_app:
-            continue
-
-        request_data = AppPlatformEvent(
-            resource=name,
-            action=action,
-            install=SentryAppInstallation.objects.get(id=servicehook.actor_id),
-            data=serialize(instance),
-        )
-
-        safe_urlopen(
-            url=servicehook.url,
-            data=request_data.body,
-            headers=request_data.headers,
-            timeout=5,
-        )
-
-
-def send_request(servicehook, payload, verify_ssl=None):
-    from sentry import tsdb
-    tsdb.incr(tsdb.models.servicehook_fired, servicehook.id)
-
-    headers = {
-        'Content-Type': 'application/json',
-        'X-ServiceHook-Timestamp': six.text_type(int(time())),
-        'X-ServiceHook-GUID': servicehook.guid,
-        'X-ServiceHook-Signature': servicehook.build_signature(json.dumps(payload)),
-    }
-
-    safe_urlopen(
-        url=servicehook.url,
-        data=json.dumps(payload),
-        headers=headers,
-        timeout=5,
-        verify_ssl=(verify_ssl or False),
-    )
-
 
 def get_payload_v0(event):
-    from sentry.api.serializers import serialize
-
     group = event.group
     project = group.project
 
@@ -152,7 +45,9 @@ def get_payload_v0(event):
 
 
 @instrumented_task(
-    name='sentry.tasks.process_service_hook', default_retry_delay=60 * 5, max_retries=5
+    name='sentry.tasks.process_service_hook',
+    default_retry_delay=60 * 5,
+    max_retries=5,
 )
 def process_service_hook(servicehook_id, event, **kwargs):
     try:
@@ -165,4 +60,20 @@ def process_service_hook(servicehook_id, event, **kwargs):
     else:
         raise NotImplementedError
 
-    send_request(servicehook, payload)
+    from sentry import tsdb
+    tsdb.incr(tsdb.models.servicehook_fired, servicehook.id)
+
+    headers = {
+        'Content-Type': 'application/json',
+        'X-ServiceHook-Timestamp': six.text_type(int(time())),
+        'X-ServiceHook-GUID': servicehook.guid,
+        'X-ServiceHook-Signature': servicehook.build_signature(json.dumps(payload)),
+    }
+
+    safe_urlopen(
+        url=servicehook.url,
+        data=json.dumps(payload),
+        headers=headers,
+        timeout=5,
+        verify_ssl=False,
+    )
diff --git a/src/sentry/testutils/helpers/faux.py b/src/sentry/testutils/helpers/faux.py
index 7ad0e59e63..a3632c7c3f 100644
--- a/src/sentry/testutils/helpers/faux.py
+++ b/src/sentry/testutils/helpers/faux.py
@@ -4,6 +4,7 @@ import six
 
 from collections import deque
 
+from sentry.utils import json
 from sentry.utils.functional import compact
 
 
@@ -66,8 +67,8 @@ class Faux(object):
             )
         )
 
-    def kwargs_contain(self, key):
-        if self._kwarg_exists(key):
+    def kwargs_contain(self, key, **kwargs):
+        if self._kwarg_exists(key, **kwargs):
             return True
 
         raise AssertionError(
@@ -77,19 +78,21 @@ class Faux(object):
             ),
         )
 
-    def kwarg_equals(self, key, expected):
-        if self._kwarg_value(key) == expected:
+    def kwarg_equals(self, key, expected, **kwargs):
+        actual = self._kwarg_value(key, **kwargs)
+
+        if actual == expected:
             return True
 
         raise AssertionError(
             u'Expected kwargs[{}] to equal {!r}. Received {!r}.'.format(
                 key,
                 expected,
-                self._kwarg_value(key),
+                actual,
             )
         )
 
-    def args_contain(self, value):
+    def args_contain(self, value, **kwargs):
         if value in self.args:
             return True
 
@@ -100,7 +103,7 @@ class Faux(object):
             ),
         )
 
-    def args_equals(self, *args):
+    def args_equals(self, *args, **kwargs):
         if self.args == tuple(args):
             return True
 
@@ -118,7 +121,7 @@ class Faux(object):
         except (KeyError, TypeError):
             return False
 
-    def _kwarg_value(self, key):
+    def _kwarg_value(self, key, **kwargs):
         """
         Support a dot notation shortcut for deeply nested dicts or just look
         up the value if passed a normal key.
@@ -132,10 +135,18 @@ class Faux(object):
         if '.' in key:
             keys = deque(key.split('.'))
         else:
-            return self.kwargs[key]
+            kwarg = self.kwargs[key]
+
+            if kwargs.get('format') == 'json':
+                return json.loads(kwarg)
+
+            return kwarg
 
         kwarg = dict(self.kwargs)
 
+        if kwargs.get('format') == 'json':
+            kwarg = json.loads(kwarg[keys.popleft()])
+
         while keys:
             kwarg = kwarg[keys.popleft()]
 
diff --git a/tests/sentry/api/serializers/test_app_platform_event.py b/tests/sentry/api/serializers/test_app_platform_event.py
index c397f2c8cc..1aa19d586b 100644
--- a/tests/sentry/api/serializers/test_app_platform_event.py
+++ b/tests/sentry/api/serializers/test_app_platform_event.py
@@ -24,7 +24,8 @@ class AppPlatformEventSerializerTest(TestCase):
             install=self.install,
             data={},
         )
-        assert result.body == {
+
+        assert result.body == json.dumps({
             'action': 'triggered',
             'installation': {
                 'uuid': self.install.uuid,
@@ -35,9 +36,9 @@ class AppPlatformEventSerializerTest(TestCase):
                 'id': 'sentry',
                 'name': 'Sentry',
             }
-        }
-        body = json.dumps(result.body)
-        signature = self.sentry_app.build_signature(body)
+        })
+
+        signature = self.sentry_app.build_signature(result.body)
 
         assert result.headers['Content-Type'] == 'application/json'
         assert result.headers['Sentry-Hook-Resource'] == 'event_alert'
@@ -51,13 +52,14 @@ class AppPlatformEventSerializerTest(TestCase):
             data={},
             actor=self.sentry_app.proxy_user,
         )
-        assert result.body['actor'] == {
+
+        assert json.loads(result.body)['actor'] == {
             'type': 'application',
             'id': self.sentry_app.uuid,
             'name': self.sentry_app.name,
         }
-        body = json.dumps(result.body)
-        signature = self.sentry_app.build_signature(body)
+
+        signature = self.sentry_app.build_signature(result.body)
 
         assert result.headers['Content-Type'] == 'application/json'
         assert result.headers['Sentry-Hook-Resource'] == 'issue'
@@ -71,13 +73,14 @@ class AppPlatformEventSerializerTest(TestCase):
             data={},
             actor=self.user,
         )
-        assert result.body['actor'] == {
+
+        assert json.loads(result.body)['actor'] == {
             'type': 'user',
             'id': self.user.id,
             'name': self.user.name,
         }
-        body = json.dumps(result.body)
-        signature = self.sentry_app.build_signature(body)
+
+        signature = self.sentry_app.build_signature(result.body)
 
         assert result.headers['Content-Type'] == 'application/json'
         assert result.headers['Sentry-Hook-Resource'] == 'installation'
diff --git a/tests/sentry/mediators/sentry_app_installations/test_creator.py b/tests/sentry/mediators/sentry_app_installations/test_creator.py
index 8fac4952ed..c1d3ac8467 100644
--- a/tests/sentry/mediators/sentry_app_installations/test_creator.py
+++ b/tests/sentry/mediators/sentry_app_installations/test_creator.py
@@ -62,7 +62,7 @@ class TestCreator(TestCase):
         assert ServiceHook.objects.get(project_id=self.project1.id).events == self.sentry_app.events
         assert ServiceHook.objects.get(project_id=self.project2.id).events == self.sentry_app.events
 
-    @patch('sentry.tasks.app_platform.installation_webhook.delay')
+    @patch('sentry.tasks.sentry_apps.installation_webhook.delay')
     def test_notifies_service(self, installation_webhook):
         install = self.creator.call()
         installation_webhook.assert_called_once_with(install.id, self.user.id)
diff --git a/tests/sentry/mediators/sentry_app_installations/test_installation_notifier.py b/tests/sentry/mediators/sentry_app_installations/test_installation_notifier.py
index 2f17971adf..612082b247 100644
--- a/tests/sentry/mediators/sentry_app_installations/test_installation_notifier.py
+++ b/tests/sentry/mediators/sentry_app_installations/test_installation_notifier.py
@@ -6,6 +6,7 @@ from sentry.mediators import sentry_apps
 from sentry.mediators.sentry_app_installations import Creator, InstallationNotifier
 from sentry.testutils import TestCase
 from sentry.testutils.helpers.faux import faux
+from sentry.utils import json
 
 
 class DictContaining(object):
@@ -45,7 +46,7 @@ class TestInstallationNotifier(TestCase):
 
         data = faux(safe_urlopen).kwargs['data']
 
-        assert data == {
+        assert data == json.dumps({
             'action': 'created',
             'installation': {
                 'uuid': self.install.uuid,
@@ -66,7 +67,7 @@ class TestInstallationNotifier(TestCase):
                 'name': self.user.name,
                 'type': 'user',
             },
-        }
+        })
 
         assert faux(safe_urlopen).kwarg_equals('headers', DictContaining(
             'Content-Type',
diff --git a/tests/sentry/mediators/service_hooks/test_creator.py b/tests/sentry/mediators/service_hooks/test_creator.py
index 1a9829ba10..fbd59d5843 100644
--- a/tests/sentry/mediators/service_hooks/test_creator.py
+++ b/tests/sentry/mediators/service_hooks/test_creator.py
@@ -34,10 +34,10 @@ class TestCreator(TestCase):
     def test_expands_resource_events_to_specific_events(self):
         self.creator.events = ['issue']
         service_hook = self.creator.call()
-        assert service_hook.events == ['issue.created']
+        assert set(service_hook.events) == set(['issue.created', 'issue.resolved'])
 
     def test_expand_events(self):
-        assert expand_events(['issue']) == set(['issue.created'])
+        assert expand_events(['issue']) == set(['issue.created', 'issue.resolved'])
 
     def test_consolidate_events(self):
         assert consolidate_events(['issue.created']) == set(['issue'])
diff --git a/tests/sentry/receivers/test_sentry_apps.py b/tests/sentry/receivers/test_sentry_apps.py
new file mode 100644
index 0000000000..d4be2c026e
--- /dev/null
+++ b/tests/sentry/receivers/test_sentry_apps.py
@@ -0,0 +1,180 @@
+from __future__ import absolute_import
+
+from mock import patch
+
+from sentry.models import Commit, GroupLink, Repository, Release
+from sentry.testutils import APITestCase, TestCase
+from sentry.testutils.helpers.faux import faux
+
+
+@patch('sentry.tasks.sentry_apps.process_resource_change.delay')
+class TestIssueSaved(TestCase):
+    def test_processes_created_issues(self, delay):
+        issue = self.create_group()
+        assert faux(delay).called_with(
+            action='created',
+            sender='Group',
+            instance_id=issue.id,
+        )
+
+    def test_does_not_process_unless_created(self, delay):
+        issue = self.create_group()
+        delay.reset_mock()
+        issue.update(message='Stuff blew up')
+        assert len(delay.mock_calls) == 0
+
+
+# This testcase needs to be an APITestCase because all of the logic to resolve
+# Issues and kick off side effects are just chillin in the endpoint code -_-
+@patch('sentry.tasks.sentry_apps.workflow_notification.delay')
+class TestIssueResolved(APITestCase):
+    def setUp(self):
+        self.issue = self.create_group(project=self.project)
+
+        self.sentry_app = self.create_sentry_app(events=['issue.resolved'])
+
+        self.install = self.create_sentry_app_installation(
+            organization=self.organization,
+            slug=self.sentry_app.slug,
+        )
+
+        self.url = u'/api/0/projects/{}/{}/issues/?id={}'.format(
+            self.organization.slug,
+            self.issue.project.slug,
+            self.issue.id,
+        )
+
+        self.login_as(self.user)
+
+    def resolve_issue(self, _data=None):
+        data = {'status': 'resolved'}
+        data.update(_data or {})
+        self.client.put(self.url, data=data, format='json')
+
+    def test_notify_after_basic_resolved(self, delay):
+        self.resolve_issue()
+
+        assert faux(delay).called_with(
+            installation_id=self.install.id,
+            issue_id=self.issue.id,
+            type='resolved',
+            user_id=self.user.id,
+            data={'resolution_type': 'resolved'},
+        )
+
+    def test_notify_after_resolve_in_commit(self, delay):
+        repo = self.create_repo(project=self.project)
+        commit = self.create_commit(repo=repo)
+
+        self.resolve_issue({
+            'statusDetails': {
+                'inCommit': {
+                    'repository': repo.name,
+                    'commit': commit.key,
+                }
+            }
+        })
+
+        assert faux(delay).called_with(
+            installation_id=self.install.id,
+            issue_id=self.issue.id,
+            type='resolved',
+            user_id=self.user.id,
+            data={'resolution_type': 'resolved_in_commit'},
+        )
+
+    def test_notify_after_resolve_in_specific_release(self, delay):
+        release = self.create_release(project=self.project)
+
+        self.resolve_issue({
+            'statusDetails': {
+                'inRelease': release.version,
+            },
+        })
+
+        assert faux(delay).called_with(
+            installation_id=self.install.id,
+            issue_id=self.issue.id,
+            type='resolved',
+            user_id=self.user.id,
+            data={'resolution_type': 'resolved_in_release'},
+        )
+
+    def test_notify_after_resolve_in_latest_release(self, delay):
+        self.create_release(project=self.project)
+
+        self.resolve_issue({
+            'statusDetails': {
+                'inRelease': 'latest',
+            },
+        })
+
+        assert faux(delay).called_with(
+            installation_id=self.install.id,
+            issue_id=self.issue.id,
+            type='resolved',
+            user_id=self.user.id,
+            data={'resolution_type': 'resolved_in_release'},
+        )
+
+    def test_notify_after_resolve_in_next_release(self, delay):
+        self.create_release(project=self.project)
+
+        self.resolve_issue({
+            'statusDetails': {
+                'inNextRelease': True,
+            },
+        })
+
+        assert faux(delay).called_with(
+            installation_id=self.install.id,
+            issue_id=self.issue.id,
+            type='resolved',
+            user_id=self.user.id,
+            data={'resolution_type': 'resolved_in_release'},
+        )
+
+    def test_notify_after_resolve_from_set_commits(self, delay):
+        repo = Repository.objects.create(
+            organization_id=self.organization.id,
+            name='test/repo',
+        )
+
+        release = Release.objects.create(
+            version='abcabc',
+            organization=self.organization,
+        )
+
+        commit = Commit.objects.create(
+            repository_id=repo.id,
+            organization_id=self.organization.id,
+            key='b' * 40,
+        )
+
+        GroupLink.objects.create(
+            group_id=self.issue.id,
+            project_id=self.project.id,
+            linked_type=GroupLink.LinkedType.commit,
+            linked_id=commit.id,
+        )
+
+        release.add_project(self.project)
+        release.set_commits(
+            [
+                {
+                    'id': 'b' * 40,
+                    'repository': repo.name,
+                    'author_email': 'foo@example.com',
+                    'author_name': 'Foo Bar',
+                    'message': u'FIXES {}'.format(self.issue.qualified_short_id),
+                }
+            ]
+        )
+
+        assert faux(delay).called_with(
+            installation_id=self.install.id,
+            issue_id=self.issue.id,
+            type='resolved',
+            user_id=None,
+            data={'resolution_type': 'resolved_in_commit'},
+        )
diff --git a/tests/sentry/tasks/test_app_platform.py b/tests/sentry/tasks/test_app_platform.py
deleted file mode 100644
index 489b7d661e..0000000000
--- a/tests/sentry/tasks/test_app_platform.py
+++ /dev/null
@@ -1,33 +0,0 @@
-from __future__ import absolute_import
-
-from mock import patch
-
-from sentry.mediators import sentry_app_installations
-from sentry.tasks.app_platform import installation_webhook
-from sentry.testutils import TestCase
-
-
-class TestAppPlatformTasks(TestCase):
-    def setUp(self):
-        self.user = self.create_user()
-        self.org = self.create_organization(owner=self.user)
-
-        self.sentry_app = self.create_sentry_app(
-            name='foo',
-            organization=self.org,
-            webhook_url='https://example.com',
-            scopes=(),
-        )
-
-        self.install = sentry_app_installations.Creator.run(
-            slug='foo',
-            organization=self.org,
-            user=self.user,
-        )
-
-    @patch('sentry.mediators.sentry_app_installations.InstallationNotifier.run')
-    def test_installation_webhook(self, run):
-        with self.tasks():
-            installation_webhook(self.install.id, self.user.id)
-
-        run.assert_called_once_with(install=self.install, user=self.user)
diff --git a/tests/sentry/tasks/test_sentry_apps.py b/tests/sentry/tasks/test_sentry_apps.py
index 4fe0da1607..c0321fc7b0 100644
--- a/tests/sentry/tasks/test_sentry_apps.py
+++ b/tests/sentry/tasks/test_sentry_apps.py
@@ -1,27 +1,54 @@
 from __future__ import absolute_import
 
+import six
+
 from collections import namedtuple
 from django.core.urlresolvers import reverse
 from mock import patch
 
-from sentry.models import Rule
+from sentry.models import Rule, SentryApp, SentryAppInstallation
 from sentry.testutils import TestCase
-from sentry.tasks.sentry_apps import notify_sentry_app
 from sentry.testutils.helpers.faux import faux
 from sentry.utils.http import absolute_uri
+from sentry.receivers.sentry_apps import *  # NOQA
+from sentry.utils import json
+from sentry.tasks.sentry_apps import (
+    send_alert_event,
+    notify_sentry_app,
+    process_resource_change,
+    installation_webhook,
+    workflow_notification,
+)
 
 RuleFuture = namedtuple('RuleFuture', ['rule', 'kwargs'])
 
 
 class DictContaining(object):
-    def __init__(self, *keys):
-        self.keys = keys
+    def __init__(self, *args, **kwargs):
+        if len(args) == 1 and isinstance(args[0], dict):
+            self.args = []
+            self.kwargs = args[0]
+        else:
+            self.args = args
+            self.kwargs = kwargs
 
     def __eq__(self, other):
-        return all([k in other.keys() for k in self.keys])
+        return self._args_match(other) and self._kwargs_match(other)
+
+    def _args_match(self, other):
+        for key in self.args:
+            if key not in other.keys():
+                return False
+        return True
 
+    def _kwargs_match(self, other):
+        for key, value in six.iteritems(self.kwargs):
+            if self.kwargs[key] != other[key]:
+                return False
+        return True
 
-class TestSentryAppAlertEvent(TestCase):
+
+class TestSendAlertEvent(TestCase):
     def setUp(self):
         self.organization = self.create_organization(slug='foo')
         self.sentry_app = self.create_sentry_app(organization=self.organization)
@@ -36,6 +63,15 @@ class TestSentryAppAlertEvent(TestCase):
     def test_no_sentry_app(self, safe_urlopen):
         group = self.create_group(project=self.project)
         event = self.create_event(group=group)
+
+        send_alert_event(event, self.rule, 9999)
+
+        assert not safe_urlopen.called
+
+    @patch('sentry.tasks.sentry_apps.safe_urlopen')
+    def test_no_sentry_app_in_future(self, safe_urlopen):
+        group = self.create_group(project=self.project)
+        event = self.create_event(group=group)
         rule_future = RuleFuture(
             rule=self.rule,
             kwargs={},
@@ -72,19 +108,34 @@ class TestSentryAppAlertEvent(TestCase):
             kwargs={'sentry_app': self.sentry_app},
         )
 
-        event_data = self._get_event_data(event)
-
         with self.tasks():
             notify_sentry_app(event, [rule_future])
 
-        data = faux(safe_urlopen).kwargs['data']
+        data = json.loads(faux(safe_urlopen).kwargs['data'])
+
         assert data == {
             'action': 'triggered',
             'installation': {
                 'uuid': self.install.uuid,
             },
             'data': {
-                'event': event_data,
+                'event': DictContaining(
+                    event_id=event.event_id,
+                    url=absolute_uri(reverse('sentry-api-0-project-event-details', args=[
+                        self.organization.slug,
+                        self.project.slug,
+                        event.id,
+                    ])),
+                    web_url=absolute_uri(reverse('sentry-group-event', args=[
+                        self.organization.slug,
+                        self.project.slug,
+                        group.id,
+                        event.id,
+                    ])),
+                    issue_url=absolute_uri(
+                        '/api/0/issues/{}/'.format(group.id),
+                    ),
+                ),
                 'triggered_rule': self.rule.label,
             },
             'actor': {
@@ -102,21 +153,123 @@ class TestSentryAppAlertEvent(TestCase):
             'Sentry-Hook-Signature',
         ))
 
-    def _get_event_data(self, event):
-        group = event.group
-        event_data = event.as_dict()
-        event_data['url'] = absolute_uri(reverse('sentry-api-0-project-event-details', args=[
-            self.organization.slug,
-            self.project.slug,
-            event.id,
-        ]))
-        event_data['web_url'] = absolute_uri(reverse('sentry-group-event', args=[
-            self.organization.slug,
-            self.project.slug,
-            group.id,
-            event.id,
-        ]))
-        event_data['issue_url'] = absolute_uri(
-            '/api/0/issues/{}/'.format(group.id),
+
+@patch('sentry.tasks.sentry_apps.safe_urlopen')
+class TestProcessResourceChange(TestCase):
+    def setUp(self):
+        self.project = self.create_project()
+
+        self.sentry_app = self.create_sentry_app(
+            organization=self.project.organization,
+            events=['issue.created'],
+        )
+
+        self.install = self.create_sentry_app_installation(
+            organization=self.project.organization,
+            slug=self.sentry_app.slug,
+        )
+
+        self.hook = self.create_service_hook(
+            actor=self.install,
+            application=self.install.sentry_app.application,
+            project=self.project,
+            events=('issue.created', ),
+        )
+
+    def test_group_created_sends_webhook(self, safe_urlopen):
+        with self.tasks():
+            issue = self.create_group(project=self.project)
+
+        data = json.loads(faux(safe_urlopen).kwargs['data'])
+
+        assert data['action'] == 'created'
+        assert data['installation']['uuid'] == self.install.uuid
+        assert data['data']['id'] == six.text_type(issue.id)
+        assert faux(safe_urlopen).kwargs_contain('headers.Content-Type')
+        assert faux(safe_urlopen).kwargs_contain('headers.Request-ID')
+        assert faux(safe_urlopen).kwargs_contain('headers.Sentry-Hook-Resource')
+        assert faux(safe_urlopen).kwargs_contain('headers.Sentry-Hook-Timestamp')
+        assert faux(safe_urlopen).kwargs_contain('headers.Sentry-Hook-Signature')
+
+    def test_does_not_process_disallowed_event(self, safe_urlopen):
+        process_resource_change('delete', 'Group', self.create_group().id)
+        assert len(safe_urlopen.mock_calls) == 0
+
+    def test_does_not_process_sentry_apps_without_issue_webhooks(self, safe_urlopen):
+        SentryAppInstallation.objects.all().delete()
+        SentryApp.objects.all().delete()
+
+        # DOES NOT subscribe to Issue events
+        self.create_sentry_app_installation(organization=self.organization)
+
+        process_resource_change('created', 'Group', self.create_group().id)
+
+        assert len(safe_urlopen.mock_calls) == 0
+
+
+@patch('sentry.mediators.sentry_app_installations.InstallationNotifier.run')
+class TestInstallationWebhook(TestCase):
+    def setUp(self):
+        self.project = self.create_project()
+        self.user = self.create_user()
+
+        self.sentry_app = self.create_sentry_app(
+            organization=self.project.organization,
+        )
+
+        self.install = self.create_sentry_app_installation(
+            organization=self.project.organization,
+            slug=self.sentry_app.slug,
+        )
+
+    def test_sends_installation_notification(self, run):
+        installation_webhook(self.install.id, self.user.id)
+
+        run.assert_called_with(
+            install=self.install,
+            user=self.user,
+        )
+
+    def test_gracefully_handles_missing_install(self, run):
+        installation_webhook(999, self.user.id)
+        assert len(run.mock_calls) == 0
+
+    def test_gracefully_handles_missing_user(self, run):
+        installation_webhook(self.install.id, 999)
+        assert len(run.mock_calls) == 0
+
+
+@patch('sentry.tasks.sentry_apps.safe_urlopen')
+class TestWorkflowNotification(TestCase):
+    def setUp(self):
+        self.project = self.create_project()
+        self.user = self.create_user()
+
+        self.sentry_app = self.create_sentry_app(
+            organization=self.project.organization,
+            events=['issue.resolved', 'issue.ignored', 'issue.assigned'],
+        )
+
+        self.install = self.create_sentry_app_installation(
+            organization=self.project.organization,
+            slug=self.sentry_app.slug,
         )
-        return event_data
+
+        self.issue = self.create_group(project=self.project)
+
+    def test_sends_resolved_webhook(self, safe_urlopen):
+        workflow_notification(self.install.id, self.issue.id, 'resolved', self.user.id)
+
+        assert faux(safe_urlopen).kwarg_equals('url', self.sentry_app.webhook_url)
+        assert faux(safe_urlopen).kwarg_equals('data.action', 'resolved', format='json')
+        assert faux(safe_urlopen).kwarg_equals('headers.Sentry-Hook-Resource', 'issue')
+        assert faux(safe_urlopen).kwarg_equals(
+            'data.data.issue.id', six.binary_type(
+                self.issue.id), format='json')
+
+    def test_sends_resolved_webhook_as_Sentry_without_user(self, safe_urlopen):
+        workflow_notification(self.install.id, self.issue.id, 'resolved', None)
+
+        assert faux(safe_urlopen).kwarg_equals('data.actor.type', 'application', format='json')
+        assert faux(safe_urlopen).kwarg_equals('data.actor.id', 'sentry', format='json')
+        assert faux(safe_urlopen).kwarg_equals('data.actor.name', 'Sentry', format='json')
diff --git a/tests/sentry/tasks/test_servicehooks.py b/tests/sentry/tasks/test_servicehooks.py
index d5bcd04a03..515748f377 100644
--- a/tests/sentry/tasks/test_servicehooks.py
+++ b/tests/sentry/tasks/test_servicehooks.py
@@ -1,15 +1,9 @@
 from __future__ import absolute_import
 
-import six
-
-from datetime import datetime
 from mock import patch
 
-from sentry.models import Group
 from sentry.testutils import TestCase
-from sentry.tasks.servicehooks import (
-    get_payload_v0, process_service_hook, process_resource_change
-)
+from sentry.tasks.servicehooks import get_payload_v0, process_service_hook
 from sentry.testutils.helpers.faux import faux
 from sentry.utils import json
 
@@ -31,57 +25,28 @@ class TestServiceHooks(TestCase):
     def setUp(self):
         self.project = self.create_project()
 
-        self.install = self.create_sentry_app_installation(
-            organization=self.project.organization
-        )
-
         self.hook = self.create_service_hook(
-            actor=self.install,
-            application=self.install.sentry_app.application,
             project=self.project,
             events=('issue.created', ),
         )
 
-    @patch('sentry.tasks.servicehooks.safe_urlopen')
-    def test_group_created_sends_service_hook(self, safe_urlopen):
-        with self.tasks():
-            issue = self.create_group(project=self.project)
-
-        data = faux(safe_urlopen).kwargs['data']
-        assert data['action'] == 'created'
-        assert data['installation']['uuid'] == self.install.uuid
-        assert data['data']['id'] == six.text_type(issue.id)
-        assert faux(safe_urlopen).kwarg_equals('headers', DictContaining(
-            'Content-Type',
-            'Request-ID',
-            'Sentry-Hook-Resource',
-            'Sentry-Hook-Timestamp',
-            'Sentry-Hook-Signature',
-        ))
-
     @patch('sentry.tasks.servicehooks.safe_urlopen')
     def test_verify_sentry_hook_signature(self, safe_urlopen):
         import hmac
         from hashlib import sha256
 
-        with self.tasks():
-            self.create_group(project=self.project)
+        event = self.create_event(project=self.project)
+        process_service_hook(self.hook.id, event)
+
+        body = json.dumps(get_payload_v0(event))
 
-        secret = self.install.sentry_app.application.client_secret
-        body = json.dumps(faux(safe_urlopen).kwargs['data'])
         expected = hmac.new(
-            key=secret.encode('utf-8'),
-            msg=body,
+            key=self.hook.secret.encode('utf-8'),
+            msg=body.encode('utf-8'),
             digestmod=sha256,
         ).hexdigest()
-        assert expected == faux(safe_urlopen).kwargs['headers']['Sentry-Hook-Signature']
 
-    @patch('sentry.tasks.servicehooks.safe_urlopen')
-    def test_non_group_events_dont_send_service_hooks(self, safe_urlopen):
-        with self.tasks():
-            self.create_project()
-
-        assert len(safe_urlopen.calls) == 0
+        assert expected == faux(safe_urlopen).kwargs['headers']['X-ServiceHook-Signature']
 
     @patch('sentry.tasks.servicehooks.safe_urlopen')
     def test_event_created_sends_service_hook(self, safe_urlopen):
@@ -101,29 +66,3 @@ class TestServiceHooks(TestCase):
             'X-ServiceHook-GUID',
             'X-ServiceHook-Signature',
         ))
-
-    @patch('sentry.models.Group.objects.get')
-    @patch('sentry.tasks.servicehooks.process_resource_change.retry')
-    def test_gracefully_handles_commit_race_condition(self, retry, get):
-        does_not_exist = Group.DoesNotExist()
-
-        # Fail once, then transaction commits, and next retry succeeds
-        get.side_effect = [does_not_exist, None]
-
-        with self.tasks():
-            self.create_group(project=self.project)
-
-        retry.assert_called_with(exc=does_not_exist)
-
-    @patch('sentry.tasks.servicehooks.process_resource_change.delay')
-    def test_does_not_enqueue_tasks_for_resource_updates(self, delay):
-        group = self.create_group(project=self.project)
-        group.update(last_seen=datetime.now())
-
-        # Only called once for the create, not also for the update.
-        delay.assert_called_once_with(action='created', sender='Group', instance_id=group.id)
-
-    @patch('sentry.tasks.servicehooks.safe_urlopen')
-    def test_handles_previous_method_signature(self, safe_urlopen):
-        group = self.create_group(project=self.project)
-        process_resource_change('created', Group, group.id, True)  # Doesn't raise

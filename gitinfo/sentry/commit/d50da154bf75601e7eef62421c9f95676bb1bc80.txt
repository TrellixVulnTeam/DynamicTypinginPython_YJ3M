commit d50da154bf75601e7eef62421c9f95676bb1bc80
Author: Matt Robenolt <matt@ydekproductions.com>
Date:   Wed Sep 5 23:04:21 2018 -0700

    feat(security): Add method for safely creating a low level socket
    
    This function just wraps the creation of the socket with our security
    bits to prevent a socket from poking internal network when accepting
    addresses from user input.

diff --git a/src/sentry/http.py b/src/sentry/http.py
index ead0b5f63a..50b2f99536 100644
--- a/src/sentry/http.py
+++ b/src/sentry/http.py
@@ -16,6 +16,7 @@ import requests
 import warnings
 import time
 import logging
+from ssl import wrap_socket
 
 from sentry import options
 from django.core.exceptions import SuspiciousOperation
@@ -86,19 +87,25 @@ def is_valid_url(url):
     """
     Tests a URL to ensure it doesn't appear to be a blacklisted IP range.
     """
+    return is_safe_hostname(urlparse(url).hostname)
+
+
+def is_safe_hostname(hostname):
+    """
+    Tests a hostname to ensure it doesn't appear to be a blacklisted IP range.
+    """
     # If we have no disallowed ips, we can skip any further validation
     # and there's no point in doing a DNS lookup to validate against
     # an empty list.
     if not DISALLOWED_IPS:
         return True
 
-    parsed = urlparse(url)
-    if not parsed.hostname:
+    if not hostname:
         return False
 
     server_hostname = get_server_hostname()
 
-    if parsed.hostname == server_hostname:
+    if hostname == server_hostname:
         return True
 
     # NOTE: The use of `socket.gethostbyname` is slightly flawed.
@@ -122,7 +129,7 @@ def is_valid_url(url):
     # >>> socket.getaddrinfo('0177.0000.0000.0001', None)[0]
     # (2, 2, 17, '', ('177.0.0.1', 0))
     try:
-        ip_addresses = set(addr for _, _, _, _, addr in socket.getaddrinfo(parsed.hostname, 0))
+        ip_addresses = set(addr for _, _, _, _, addr in socket.getaddrinfo(hostname, 0))
     except socket.gaierror:
         return False
 
@@ -367,3 +374,18 @@ def fetch_file(
             response.close()
 
     return UrlResult(url, result[0], result[1], result[2], result[3])
+
+
+def safe_socket_connect(address, timeout=30, ssl=False):
+    """
+    Creates a socket and connects to address, but prevents connecting to
+    our disallowed IP blocks.
+    """
+    if not is_safe_hostname(address[0]):
+        raise RestrictedIPAddress('%s matches the hostname blacklist' % address[0])
+    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    s.settimeout(timeout)
+    s.connect(address)
+    if not ssl:
+        return s
+    return wrap_socket(s)
diff --git a/tests/sentry/test_http.py b/tests/sentry/test_http.py
index 7e9ebccdd6..2d3089f2b7 100644
--- a/tests/sentry/test_http.py
+++ b/tests/sentry/test_http.py
@@ -59,6 +59,11 @@ class HttpTest(TestCase):
             # '0177.0000.0000.0001' is an octal for '127.0.0.1'
             http.safe_urlopen('http://0177.0000.0000.0001')
 
+    def test_safe_socket_connect(self):
+        http.DISALLOWED_IPS = set([ipaddress.ip_network(u'127.0.0.1')])
+        with pytest.raises(SuspiciousOperation):
+            http.safe_socket_connect(('127.0.0.1', 80))
+
     @responses.activate
     def test_fetch_file(self):
         responses.add(

commit 0d7081c75563958b380feceadf637c16a033f580
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Thu Jun 14 14:34:37 2018 -0700

    feat(ui): Add shortid seach to Command Pal (#8732)
    
    /cc @ehfeng
    
    (excuse my typing skills)
    ![shortid-search](https://cl.ly/1q2n1Z0v0D1Z/download/Screen%20Recording%202018-06-13%20at%2001.01%20PM.gif)

diff --git a/src/sentry/static/sentry/app/components/search/searchResult.jsx b/src/sentry/static/sentry/app/components/search/searchResult.jsx
index ee8b40a99f..a2381fea23 100644
--- a/src/sentry/static/sentry/app/components/search/searchResult.jsx
+++ b/src/sentry/static/sentry/app/components/search/searchResult.jsx
@@ -23,6 +23,8 @@ class SearchResult extends React.Component {
         'member',
         'field',
         'route',
+        'issue',
+        'event',
       ]),
       /**
      * The type of result this is, for example:
@@ -30,7 +32,7 @@ class SearchResult extends React.Component {
      * - an application route (e.g. org dashboard)
      * - form field
      */
-      resultType: PropTypes.oneOf(['settings', 'route', 'field']),
+      resultType: PropTypes.oneOf(['settings', 'route', 'field', 'issue', 'event']),
       title: PropTypes.string,
       description: PropTypes.string,
       model: PropTypes.oneOfType([
@@ -38,6 +40,8 @@ class SearchResult extends React.Component {
         SentryTypes.Project,
         SentryTypes.Team,
         SentryTypes.Member,
+        SentryTypes.Group,
+        SentryTypes.Event,
       ]),
     }),
     matches: PropTypes.array,
diff --git a/src/sentry/static/sentry/app/components/search/sources/apiSource.jsx b/src/sentry/static/sentry/app/components/search/sources/apiSource.jsx
index 534fbe6bc6..c65950b936 100644
--- a/src/sentry/static/sentry/app/components/search/sources/apiSource.jsx
+++ b/src/sentry/static/sentry/app/components/search/sources/apiSource.jsx
@@ -4,10 +4,122 @@ import PropTypes from 'prop-types';
 import Raven from 'raven-js';
 import React from 'react';
 
+import {t} from 'app/locale';
 import {Client} from 'app/api';
 import {createFuzzySearch} from 'app/utils/createFuzzySearch';
 import withLatestContext from 'app/utils/withLatestContext';
 
+// event ids must have string length of 32
+const shouldSearchEventIds = query => typeof query === 'string' && query.length === 32;
+
+// STRING-HEXVAL
+const shouldSearchShortIds = query => /[\w\d]+-[\w\d]+/.test(query);
+
+// Helper functions to create result objects
+async function createOrganizationResults(organizationsPromise) {
+  let organizations = (await organizationsPromise) || [];
+  return flatten(
+    organizations.map(org => [
+      {
+        title: t('%s Dashboard', org.slug),
+        description: t('Organization Dashboard'),
+        model: org,
+        sourceType: 'organization',
+        resultType: 'route',
+        to: `/${org.slug}/`,
+      },
+      {
+        title: t('%s Settings', org.slug),
+        description: t('Organization Settings'),
+        model: org,
+        sourceType: 'organization',
+        resultType: 'settings',
+        to: `/settings/${org.slug}/`,
+      },
+    ])
+  );
+}
+async function createProjectResults(projectsPromise, orgId) {
+  let projects = (await projectsPromise) || [];
+  return flatten(
+    projects.map(project => [
+      {
+        title: `${project.slug} Dashboard`,
+        description: 'Project Dashboard',
+        model: project,
+        sourceType: 'project',
+        resultType: 'route',
+        to: `/${orgId}/${project.slug}/`,
+      },
+      {
+        title: `${project.slug} Settings`,
+        description: 'Project Settings',
+        model: project,
+        sourceType: 'project',
+        resultType: 'settings',
+        to: `/settings/${orgId}/${project.slug}/`,
+      },
+    ])
+  );
+}
+async function createTeamResults(teamsPromise, orgId) {
+  let teams = (await teamsPromise) || [];
+  return teams.map(team => ({
+    title: `#${team.slug}`,
+    description: 'Team Settings',
+    model: team,
+    sourceType: 'team',
+    resultType: 'settings',
+    to: `/settings/${orgId}/teams/${team.slug}/`,
+  }));
+}
+
+async function createMemberResults(membersPromise, orgId) {
+  let members = (await membersPromise) || [];
+  return members.map(member => ({
+    title: member.name,
+    description: member.email,
+    model: member,
+    sourceType: 'member',
+    resultType: 'settings',
+    to: `/settings/${orgId}/members/${member.id}/`,
+  }));
+}
+
+async function createShortIdLookupResult(shortIdLookupPromise) {
+  let shortIdLookup = await shortIdLookupPromise;
+  if (!shortIdLookup) return null;
+
+  let issue = shortIdLookup && shortIdLookup.group;
+  return {
+    item: {
+      title: `${(issue && issue.metadata && issue.metadata.type) ||
+        shortIdLookup.shortId}`,
+      description: `${(issue && issue.metadata && issue.metadata.value) || t('Issue')}`,
+      model: shortIdLookup.group,
+      sourceType: 'issue',
+      resultType: 'issue',
+      to: `/${shortIdLookup.organizationSlug}/${shortIdLookup.projectSlug}/issues/${shortIdLookup.groupId}/`,
+    },
+  };
+}
+
+async function createEventIdLookupResult(eventIdLookupPromise) {
+  let eventIdLookup = await eventIdLookupPromise;
+  if (!eventIdLookup) return null;
+
+  let event = eventIdLookup && eventIdLookup.event;
+  return {
+    item: {
+      title: `${(event && event.metadata && event.metadata.type) || t('Event')}`,
+      description: `${event && event.metadata && event.metadata.value}`,
+      sourceType: 'event',
+      resultType: 'event',
+      to: `/${eventIdLookup.organizationSlug}/${eventIdLookup.projectSlug}/issues/${eventIdLookup.groupId}/events/${eventIdLookup.eventId}/`,
+    },
+  };
+}
+
 class ApiSource extends React.Component {
   static propTypes = {
     // search term
@@ -34,6 +146,8 @@ class ApiSource extends React.Component {
     this.state = {
       loading: false,
       allResults: null,
+      searchResults: null,
+      directResults: null,
       fuzzy: null,
     };
 
@@ -48,30 +162,39 @@ class ApiSource extends React.Component {
     //
     // Otherwise it'd be constant :spinning_loading_wheel:
     if (
-      nextProps.query.length <= 2 &&
-      nextProps.query.substr(0, 2) !== this.props.query.substr(0, 2)
+      (nextProps.query.length <= 2 &&
+        nextProps.query.substr(0, 2) !== this.props.query.substr(0, 2)) ||
+      // Also trigger a search if next query value satisfies an eventid/shortid query
+      (shouldSearchShortIds(nextProps.query) || shouldSearchEventIds(nextProps.query))
     ) {
       this.setState({loading: true});
       this.doSearch(nextProps.query);
     }
   }
 
+  // Debounced method to handle querying all API endpoints (when necessary)
   doSearch = debounce(async query => {
-    let {params, searchOptions, organization} = this.props;
+    let {params, organization} = this.props;
     let orgId = (params && params.orgId) || (organization && organization.slug);
-    let urls = ['/organizations/'];
+    let searchUrls = ['/organizations/'];
+    let directUrls = [];
 
     // Only run these queries when we have an org in context
     if (orgId) {
-      urls = [
-        ...urls,
+      searchUrls = [
+        ...searchUrls,
         `/organizations/${orgId}/projects/`,
         `/organizations/${orgId}/teams/`,
         `/organizations/${orgId}/members/`,
       ];
+
+      directUrls = [
+        shouldSearchShortIds(query) ? `/organizations/${orgId}/shortids/${query}/` : null,
+        shouldSearchEventIds(query) ? `/organizations/${orgId}/eventids/${query}/` : null,
+      ];
     }
 
-    let reqs = urls.map(url =>
+    let searchRequests = searchUrls.map(url =>
       this.api
         .requestPromise(url, {
           query: {
@@ -81,94 +204,111 @@ class ApiSource extends React.Component {
         .then(
           resp => resp,
           err => {
-            Raven.captureException(err);
-            return [];
+            this.handleRequestError(err, {orgId, url});
+            return null;
           }
         )
     );
 
-    let [organizations, projects, teams, members] = await Promise.all(reqs);
-
-    let allResults = [
-      ...flatten(
-        organizations.map(org => [
-          {
-            title: `${org.slug} Dashboard`,
-            description: 'Organization Dashboard',
-            model: org,
-            sourceType: 'organization',
-            resultType: 'route',
-            to: `/${org.slug}/`,
-          },
-          {
-            title: `${org.slug} Settings`,
-            description: 'Organization Settings',
-            model: org,
-            sourceType: 'organization',
-            resultType: 'settings',
-            to: `/settings/${org.slug}/`,
-          },
-        ])
-      ),
-      ...flatten(
-        (projects || []).map(project => [
-          {
-            title: `${project.slug} Dashboard`,
-            description: 'Project Dashboard',
-            model: project,
-            sourceType: 'project',
-            resultType: 'route',
-            to: `/${orgId}/${project.slug}/`,
-          },
-          {
-            title: `${project.slug} Settings`,
-            description: 'Project Settings',
-            model: project,
-            sourceType: 'project',
-            resultType: 'settings',
-            to: `/settings/${orgId}/${project.slug}/`,
-          },
-        ])
+    let directRequests = directUrls.map(url => {
+      if (!url) return Promise.resolve(null);
+
+      return this.api.requestPromise(url).then(
+        resp => resp,
+        err => {
+          this.handleRequestError(err, {orgId, url});
+          return null;
+        }
+      );
+    });
+
+    this.handleSearchRequest(searchRequests, directRequests);
+  }, 150);
+
+  handleRequestError = (err, {url, orgId}) => {
+    Raven.captureException(
+      new Error(
+        `API Source Failed: ${err && err.responseJSON && err.responseJSON.detail}`
       ),
-      ...(teams || []).map(team => ({
-        title: `#${team.slug}`,
-        description: 'Team Settings',
-        model: team,
-        sourceType: 'team',
-        resultType: 'settings',
-        to: `/settings/${orgId}/teams/${team.slug}/`,
-      })),
-      ...(members || []).map(member => ({
-        title: member.name,
-        description: member.email,
-        model: member,
-        sourceType: 'member',
-        resultType: 'settings',
-        to: `/settings/${orgId}/members/${member.id}/`,
-      })),
-    ];
+      {
+        extra: {
+          url: url.replace(`/organizations/${orgId}/`, '/organizations/:orgId/'),
+        },
+      }
+    );
+  };
+
+  // Handles a list of search request promises, and then updates state with response objects
+  async handleSearchRequest(searchRequests, directRequests) {
+    let {searchOptions} = this.props;
+
+    // Note we don't wait for all requests to resolve here (e.g. `await Promise.all(reqs)`)
+    // so that we can start processing before all API requests are resolved
+    //
+    // This isn't particularly helpful in its current form because we still wait for all requests to finish before
+    // updating state, but you could potentially optimize rendering direct results before all requests are finished.
+    let [organizations, projects, teams, members] = searchRequests;
+    let [shortIdLookup, eventIdLookup] = directRequests;
+
+    let [searchResults, directResults] = await Promise.all([
+      this.getSearchableResults([organizations, projects, teams, members]),
+      this.getDirectResults([shortIdLookup, eventIdLookup]),
+    ]);
 
-    let fuzzy = createFuzzySearch(allResults, {
+    let fuzzy = createFuzzySearch(searchResults, {
       ...searchOptions,
       keys: ['title', 'description'],
     });
 
     this.setState({
       loading: false,
-      allResults,
+      allResults: [...searchResults, ...directResults],
       fuzzy: await fuzzy,
+      directResults,
     });
-  }, 150);
+  }
+
+  // Process API requests that create result objects that should be searchable
+  async getSearchableResults(requests) {
+    let {params, organization} = this.props;
+    let orgId = (params && params.orgId) || (organization && organization.slug);
+    let [organizations, projects, teams, members] = requests;
+    let searchResults = flatten(
+      await Promise.all([
+        createOrganizationResults(organizations),
+        createProjectResults(projects, orgId),
+        createTeamResults(teams, orgId),
+        createMemberResults(members, orgId),
+      ])
+    );
+
+    return searchResults;
+  }
+
+  // Create result objects from API requests that do not require fuzzy search
+  // i.e. these responses only return 1 object or they should always be displayed regardless of query input
+  async getDirectResults(requests, query) {
+    let [shortIdLookup, eventIdLookup] = requests;
+
+    let directResults = (await Promise.all([
+      createShortIdLookupResult(shortIdLookup),
+      createEventIdLookupResult(eventIdLookup),
+    ])).filter(result => !!result);
+
+    if (!directResults.length) return [];
+
+    return directResults;
+  }
 
   render() {
     let {children, query} = this.props;
-    let {fuzzy} = this.state;
-
+    let {fuzzy, directResults} = this.state;
     let results = (fuzzy && fuzzy.search(query)) || null;
+
     return children({
       isLoading: this.state.loading,
       allResults: this.state.allResults,
-      results,
+      results: flatten([results, directResults].filter(arr => !!arr)) || null,
     });
   }
 }
diff --git a/tests/js/setup.js b/tests/js/setup.js
index f4ae7212dc..75d832dfb0 100644
--- a/tests/js/setup.js
+++ b/tests/js/setup.js
@@ -429,11 +429,27 @@ window.TestStubs = {
       id: '1',
       message: 'ApiException',
       groupID: '1',
-      eventID: '12345',
+      eventID: '12345678901234567890123456789012',
       ...params,
     };
   },
 
+  EventIdQueryResult: params => {
+    let event = TestStubs.Event({
+      metadata: {
+        type: 'event type',
+        value: 'event description',
+      },
+    });
+    return {
+      organizationSlug: 'org-slug',
+      projectSlug: 'project-slug',
+      groupId: event.groupID,
+      eventId: event.eventID,
+      event,
+    };
+  },
+
   Events: () => {
     return [
       TestStubs.Event({eventID: '12345', id: '1', message: 'ApiException', groupID: '1'}),
@@ -859,6 +875,22 @@ window.TestStubs = {
     },
   ],
 
+  ShortIdQueryResult: params => {
+    let group = TestStubs.Group({
+      metadata: {
+        type: 'group type',
+        value: 'group description',
+      },
+    });
+    return {
+      organizationSlug: 'org-slug',
+      projectSlug: 'project-slug',
+      groupId: group.id,
+      shortId: 'test-1',
+      group,
+    };
+  },
+
   Subscriptions: () => {
     return [
       {
diff --git a/tests/js/spec/components/group/__snapshots__/sidebar.spec.jsx.snap b/tests/js/spec/components/group/__snapshots__/sidebar.spec.jsx.snap
index e57ad7313a..649837a7d0 100644
--- a/tests/js/spec/components/group/__snapshots__/sidebar.spec.jsx.snap
+++ b/tests/js/spec/components/group/__snapshots__/sidebar.spec.jsx.snap
@@ -7,7 +7,7 @@ exports[`GroupSidebar renders with tags renders 1`] = `
   <SuggestedOwners
     event={
       Object {
-        "eventID": "12345",
+        "eventID": "12345678901234567890123456789012",
         "groupID": "1",
         "id": "1",
         "message": "ApiException",
diff --git a/tests/js/spec/components/group/__snapshots__/suggestedOwners.spec.jsx.snap b/tests/js/spec/components/group/__snapshots__/suggestedOwners.spec.jsx.snap
index aaec50b720..685e1a7313 100644
--- a/tests/js/spec/components/group/__snapshots__/suggestedOwners.spec.jsx.snap
+++ b/tests/js/spec/components/group/__snapshots__/suggestedOwners.spec.jsx.snap
@@ -4,7 +4,7 @@ exports[`SuggestedOwners render() should not show owners committers without feat
 <SuggestedOwners
   event={
     Object {
-      "eventID": "12345",
+      "eventID": "12345678901234567890123456789012",
       "groupID": "1",
       "id": "1",
       "message": "ApiException",
@@ -184,7 +184,7 @@ exports[`SuggestedOwners render() should show owners when enable 1`] = `
 <SuggestedOwners
   event={
     Object {
-      "eventID": "12345",
+      "eventID": "12345678901234567890123456789012",
       "groupID": "1",
       "id": "1",
       "message": "ApiException",
diff --git a/tests/js/spec/components/search/sources/apiSource.spec.jsx b/tests/js/spec/components/search/sources/apiSource.spec.jsx
index a21c19acd6..ee70325999 100644
--- a/tests/js/spec/components/search/sources/apiSource.spec.jsx
+++ b/tests/js/spec/components/search/sources/apiSource.spec.jsx
@@ -10,9 +10,18 @@ describe('ApiSource', function() {
   let projectsMock;
   let teamsMock;
   let membersMock;
+  let shortIdMock;
+  let eventIdMock;
+  let allMocks;
 
   beforeEach(function() {
     MockApiClient.clearMockResponses();
+    MockApiClient.addMockResponse({
+      url: '/organizations/',
+      query: 'test-1',
+      body: [TestStubs.Organization({slug: 'test-org'})],
+    });
+
     orgsMock = MockApiClient.addMockResponse({
       url: '/organizations/',
       query: 'foo',
@@ -33,6 +42,17 @@ describe('ApiSource', function() {
       query: 'foo',
       body: TestStubs.Members(),
     });
+    shortIdMock = MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/shortids/test-1/',
+      query: 'TEST-1',
+      body: TestStubs.ShortIdQueryResult(),
+    });
+    eventIdMock = MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/eventids/12345678901234567890123456789012/',
+      query: '12345678901234567890123456789012',
+      body: TestStubs.EventIdQueryResult(),
+    });
+    allMocks = {orgsMock, projectsMock, teamsMock, membersMock, shortIdMock, eventIdMock};
   });
 
   it('queries all API endpoints', function() {
@@ -48,6 +68,98 @@ describe('ApiSource', function() {
     expect(projectsMock).toHaveBeenCalled();
     expect(teamsMock).toHaveBeenCalled();
     expect(membersMock).toHaveBeenCalled();
+    expect(shortIdMock).not.toHaveBeenCalled();
+    expect(eventIdMock).not.toHaveBeenCalled();
+  });
+
+  it('only queries for shortids when query matches shortid format', async function() {
+    let mock = jest.fn().mockReturnValue(null);
+    wrapper = mount(
+      <ApiSource params={{orgId: org.slug}} query="test-">
+        {mock}
+      </ApiSource>,
+      TestStubs.routerContext()
+    );
+
+    await tick();
+    expect(shortIdMock).not.toHaveBeenCalled();
+    // Reset all mocks
+    Object.values(allMocks).forEach(m => m.mockReset);
+
+    // This is a valid short id now
+    wrapper.setProps({query: 'test-1'});
+    await tick();
+    wrapper.update();
+
+    expect(shortIdMock).toHaveBeenCalled();
+
+    // These may not be desired behavior in future, but lets specify the expectation regardless
+    expect(orgsMock).toHaveBeenCalled();
+    expect(projectsMock).toHaveBeenCalled();
+    expect(teamsMock).toHaveBeenCalled();
+    expect(membersMock).toHaveBeenCalled();
+    expect(eventIdMock).not.toHaveBeenCalled();
+    expect(mock).toHaveBeenLastCalledWith(
+      expect.objectContaining({
+        results: [
+          {
+            item: expect.objectContaining({
+              title: 'group type',
+              description: 'group description',
+              sourceType: 'issue',
+              resultType: 'issue',
+              to: '/org-slug/project-slug/issues/1/',
+            }),
+          },
+        ],
+      })
+    );
+  });
+
+  it('only queries for eventids when query matches eventid format of 32 chars', async function() {
+    let mock = jest.fn().mockReturnValue(null);
+    wrapper = mount(
+      <ApiSource params={{orgId: org.slug}} query="1234567890123456789012345678901">
+        {mock}
+      </ApiSource>,
+      TestStubs.routerContext()
+    );
+
+    await tick();
+    expect(eventIdMock).not.toHaveBeenCalled();
+    // Reset all mocks
+    Object.values(allMocks).forEach(m => m.mockReset);
+
+    // This is a valid short id now
+    wrapper.setProps({query: '12345678901234567890123456789012'});
+    wrapper.update();
+
+    await tick();
+
+    expect(eventIdMock).toHaveBeenCalled();
+
+    // These may not be desired behavior in future, but lets specify the expectation regardless
+    expect(orgsMock).toHaveBeenCalled();
+    expect(projectsMock).toHaveBeenCalled();
+    expect(teamsMock).toHaveBeenCalled();
+    expect(membersMock).toHaveBeenCalled();
+    expect(shortIdMock).not.toHaveBeenCalled();
+    expect(mock).toHaveBeenLastCalledWith(
+      expect.objectContaining({
+        results: [
+          {
+            item: expect.objectContaining({
+              title: 'event type',
+              description: 'event description',
+              sourceType: 'event',
+              resultType: 'event',
+              to:
+                '/org-slug/project-slug/issues/1/events/12345678901234567890123456789012/',
+            }),
+          },
+        ],
+      })
+    );
   });
 
   it('only queries org endpoint if there is no org in context', function() {

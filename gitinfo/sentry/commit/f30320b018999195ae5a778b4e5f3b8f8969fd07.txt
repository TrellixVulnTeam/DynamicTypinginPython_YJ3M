commit f30320b018999195ae5a778b4e5f3b8f8969fd07
Author: Max Bittker <maxbittker@gmail.com>
Date:   Tue May 22 09:07:16 2018 -0700

    feat(integrations): github enterprise support  (#8348)
    
    * wip
    
    * wip
    
    * lambsa
    
    * fix import
    
    * wip
    
    * remove unused method
    
    * progress
    
    * fix lint
    
    * fix lint
    
    * comment
    
    * logging strings
    
    * use github identifier for jwt
    
    * add user indentity back in
    
    * add identity provider config
    
    * minor fix
    
    * add test
    
    * fix failing test
    
    * rename to pipeline_views for clarity
    
    * revert to 99624c7
    
    * refactor get_jwt
    
    * dont remove get_pipeline in this pr
    
    * add _get_oauth_parameter helper
    
    * modify helper
    
    * remove private key from oauth config
    
    * - to _
    
    * fix source_url
    
    * update description
    
    * formatting and refactoring
    
    * verify_ssl urlopen config option
    
    * move fields to class properties
    
    * urlopen_options
    
    * explicitly set verify_ssl
    
    * fix test
    
    * add GHE to internal integrations
    
    * add error message

diff --git a/src/sentry/api/endpoints/organization_config_integrations.py b/src/sentry/api/endpoints/organization_config_integrations.py
index 5f9be3f54b..4339cdc01e 100644
--- a/src/sentry/api/endpoints/organization_config_integrations.py
+++ b/src/sentry/api/endpoints/organization_config_integrations.py
@@ -19,7 +19,6 @@ class OrganizationConfigIntegrationsEndpoint(OrganizationEndpoint):
         for provider in integrations.all():
             metadata = provider.metadata
             metadata = metadata and metadata._asdict() or None
-
             if not has_catchall and provider.key in settings.SENTRY_INTERNAL_INTEGRATIONS:
                 continue
             providers.append(
diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index d0624922dd..0128cfa540 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -1246,6 +1246,7 @@ SENTRY_DEFAULT_INTEGRATIONS = (
     'sentry.integrations.bitbucket.BitbucketIntegrationProvider',
     'sentry.integrations.slack.SlackIntegrationProvider',
     'sentry.integrations.github.GitHubIntegrationProvider',
+    'sentry.integrations.github_enterprise.GitHubEnterpriseIntegrationProvider',
     'sentry.integrations.jira.JiraIntegrationProvider',
     'sentry.integrations.vsts.VSTSIntegrationProvider',
 )
@@ -1253,6 +1254,7 @@ SENTRY_DEFAULT_INTEGRATIONS = (
 SENTRY_INTERNAL_INTEGRATIONS = (
     'bitbucket',
     'github',
+    'github-enterprise',
     'jira',
     'vsts',
 )
diff --git a/src/sentry/identity/__init__.py b/src/sentry/identity/__init__.py
index de89a64e63..52b49dadba 100644
--- a/src/sentry/identity/__init__.py
+++ b/src/sentry/identity/__init__.py
@@ -6,6 +6,7 @@ from .oauth2 import *  # NOQA
 
 from .slack import *  # NOQA
 from .github import *  # NOQA
+from .github_enterprise import *  # NOQA
 from .vsts import *  # NOQA
 from .bitbucket import *  # NOQA
 
@@ -21,5 +22,6 @@ unregister = default_manager.unregister
 # initialized there.
 register(SlackIdentityProvider)  # NOQA
 register(GitHubIdentityProvider)  # NOQA
+register(GitHubEnterpriseIdentityProvider)  # NOQA
 register(VSTSIdentityProvider)  # NOQA
 register(BitbucketIdentityProvider)  # NOQA
diff --git a/src/sentry/identity/github_enterprise/__init__.py b/src/sentry/identity/github_enterprise/__init__.py
new file mode 100644
index 0000000000..1422fb52ef
--- /dev/null
+++ b/src/sentry/identity/github_enterprise/__init__.py
@@ -0,0 +1,5 @@
+from __future__ import absolute_import
+
+from sentry.utils.imports import import_submodules
+
+import_submodules(globals(), __name__, __path__)
diff --git a/src/sentry/identity/github_enterprise/provider.py b/src/sentry/identity/github_enterprise/provider.py
new file mode 100644
index 0000000000..8c86f52446
--- /dev/null
+++ b/src/sentry/identity/github_enterprise/provider.py
@@ -0,0 +1,38 @@
+from __future__ import absolute_import
+
+from sentry import http
+from sentry.identity.oauth2 import OAuth2Provider
+
+
+def get_user_info(url, access_token):
+    session = http.build_session()
+    resp = session.get(
+        'https://{}/api/v3/user'.format(url),
+        params={'access_token': access_token},
+        headers={'Accept': 'application/vnd.github.machine-man-preview+json'},
+        verify=False
+    )
+    resp.raise_for_status()
+    resp = resp.json()
+
+    return resp
+
+
+class GitHubEnterpriseIdentityProvider(OAuth2Provider):
+    key = 'github-enterprise'
+    name = 'GitHub Enterprise'
+
+    oauth_scopes = ()
+
+    def build_identity(self, data):
+        data = data['data']
+        # todo(meredith): this doesn't work yet, need to pass in the base url
+        user = get_user_info(data['access_token'])
+
+        return {
+            'type': 'github-enterprise',
+            'id': user['id'],
+            'email': user['email'],
+            'scopes': [],  # GitHub apps do not have user scopes
+            'data': self.get_oauth_data(data),
+        }
diff --git a/src/sentry/identity/oauth2.py b/src/sentry/identity/oauth2.py
index a8c640f9cb..4698dd6b8e 100644
--- a/src/sentry/identity/oauth2.py
+++ b/src/sentry/identity/oauth2.py
@@ -5,6 +5,7 @@ __all__ = ['OAuth2Provider', 'OAuth2CallbackView', 'OAuth2LoginView']
 from six.moves.urllib.parse import parse_qsl, urlencode
 from uuid import uuid4
 from time import time
+from django.views.decorators.csrf import csrf_exempt
 
 from sentry.http import safe_urlopen, safe_urlread
 from sentry.utils import json
@@ -30,11 +31,47 @@ class OAuth2Provider(Provider):
 
     oauth_scopes = ()
 
+    def _get_oauth_parameter(self, parameter_name):
+        """
+        Lookup an OAuth parameter for the provider. Depending on the context of the
+        pipeline using the provider, the parameter may come from 1 of 3 places:
+
+        1. Check the class property of the provider for the parameter.
+
+        2. If the provider has the parameters made available within the ``config``.
+
+        3. If provided, check the pipeline's ``provider_model`` for the oauth parameter
+           in the config field.
+
+        If the parameter cannot be found a KeyError will be raised.
+        """
+        try:
+            prop = getattr(self, u'oauth_{}'.format(parameter_name))
+            if prop is not '':
+                return prop
+        except AttributeError:
+            pass
+
+        if self.config.get(parameter_name):
+            return self.config.get(parameter_name)
+
+        model = self.pipeline.provider_model
+        if model and model.config.get(parameter_name) is not None:
+            return model.config.get(parameter_name)
+
+        raise KeyError(u'Unable to resolve OAuth parameter "{}"'.format(parameter_name))
+
+    def get_oauth_access_token_url(self):
+        return self._get_oauth_parameter('access_token_url')
+
+    def get_oauth_authorize_url(self):
+        return self._get_oauth_parameter('authorize_url')
+
     def get_oauth_client_id(self):
-        raise NotImplementedError
+        return self._get_oauth_parameter('client_id')
 
     def get_oauth_client_secret(self):
-        raise NotImplementedError
+        return self._get_oauth_parameter('client_secret')
 
     def get_oauth_scopes(self):
         return self.config.get('oauth_scopes', self.oauth_scopes)
@@ -42,12 +79,12 @@ class OAuth2Provider(Provider):
     def get_pipeline_views(self):
         return [
             OAuth2LoginView(
-                authorize_url=self.oauth_authorize_url,
+                authorize_url=self.get_oauth_authorize_url(),
                 client_id=self.get_oauth_client_id(),
                 scope=' '.join(self.get_oauth_scopes()),
             ),
             OAuth2CallbackView(
-                access_token_url=self.oauth_access_token_url,
+                access_token_url=self.get_oauth_access_token_url(),
                 client_id=self.get_oauth_client_id(),
                 client_secret=self.get_oauth_client_secret(),
             ),
@@ -95,6 +132,7 @@ class OAuth2LoginView(PipelineView):
             'redirect_uri': redirect_uri,
         }
 
+    @csrf_exempt
     def dispatch(self, request, pipeline):
         if 'code' in request.GET:
             return pipeline.next_step()
@@ -141,7 +179,8 @@ class OAuth2CallbackView(PipelineView):
             code=code,
             redirect_uri=absolute_uri(pipeline.redirect_url()),
         )
-        req = safe_urlopen(self.access_token_url, data=data)
+        verify_ssl = pipeline.config.get('verify_ssl', True)
+        req = safe_urlopen(self.access_token_url, data=data, verify_ssl=verify_ssl)
         body = safe_urlread(req)
         if req.headers['Content-Type'].startswith('application/x-www-form-urlencoded'):
             return dict(parse_qsl(body))
diff --git a/src/sentry/integrations/github/utils.py b/src/sentry/integrations/github/utils.py
index 542093c9c2..466a78681b 100644
--- a/src/sentry/integrations/github/utils.py
+++ b/src/sentry/integrations/github/utils.py
@@ -8,7 +8,11 @@ import time
 from sentry import options
 
 
-def get_jwt():
+def get_jwt(github_id=None, github_private_key=None):
+    if github_id is None:
+        github_id = options.get('github-app.id')
+    if github_private_key is None:
+        github_private_key = options.get('github-app.private-key')
     exp = datetime.datetime.utcnow() + datetime.timedelta(minutes=10)
     exp = calendar.timegm(exp.timetuple())
     # Generate the JWT
@@ -18,7 +22,7 @@ def get_jwt():
         # JWT expiration time (10 minute maximum)
         'exp': exp,
         # Integration's GitHub identifier
-        'iss': options.get('github-app.id'),
+        'iss': github_id,
     }
 
-    return jwt.encode(payload, options.get('github-app.private-key'), algorithm='RS256')
+    return jwt.encode(payload, github_private_key, algorithm='RS256')
diff --git a/src/sentry/integrations/github_enterprise/__init__.py b/src/sentry/integrations/github_enterprise/__init__.py
new file mode 100644
index 0000000000..1422fb52ef
--- /dev/null
+++ b/src/sentry/integrations/github_enterprise/__init__.py
@@ -0,0 +1,5 @@
+from __future__ import absolute_import
+
+from sentry.utils.imports import import_submodules
+
+import_submodules(globals(), __name__, __path__)
diff --git a/src/sentry/integrations/github_enterprise/integration.py b/src/sentry/integrations/github_enterprise/integration.py
new file mode 100644
index 0000000000..c6a60a69cc
--- /dev/null
+++ b/src/sentry/integrations/github_enterprise/integration.py
@@ -0,0 +1,222 @@
+from __future__ import absolute_import
+
+from six.moves.urllib.parse import urlparse
+from django.utils.translation import ugettext_lazy as _
+from django import forms
+
+from sentry import http
+from sentry.web.helpers import render_to_response
+from sentry.identity.pipeline import IdentityProviderPipeline
+from sentry.identity.github_enterprise import get_user_info
+from sentry.integrations import IntegrationMetadata
+from sentry.integrations.github.integration import GitHubIntegrationProvider
+from sentry.pipeline import NestedPipelineView, PipelineView
+from sentry.utils.http import absolute_uri
+
+from sentry.integrations.github.utils import get_jwt
+
+
+DESCRIPTION = """
+    Fill me out (Enterprise)
+"""
+
+
+metadata = IntegrationMetadata(
+    description=DESCRIPTION.strip(),
+    author='The Sentry Team',
+    noun=_('Installation'),
+    issue_url='https://github.com/getsentry/sentry/issues/new?title=GitHub%20Integration:%20&labels=Component%3A%20Integrations',
+    source_url='https://github.com/getsentry/sentry/tree/master/src/sentry/integrations/github_enterprise',
+    aspects={}
+)
+
+
+class InstallationForm(forms.Form):
+    url = forms.CharField(widget=forms.TextInput(
+        attrs={
+            'label': "Installation Url",
+            'placeholder': _('https://github.example.com'),
+        }
+    ))
+    id = forms.CharField(widget=forms.TextInput(
+        attrs={
+            'label': "Github App ID",
+            'placeholder': _('1'),
+        }
+    ))
+    name = forms.CharField(widget=forms.TextInput(
+        attrs={
+            'label': "Github App Name",
+            'placeholder': _('sentry-app'),
+        }
+    ))
+    client_id = forms.CharField(widget=forms.TextInput(
+        attrs={
+            'label': "Github App Client ID",
+            'placeholder': _('1'),
+        }
+    ))
+    client_secret = forms.CharField(widget=forms.TextInput(
+        attrs={
+            'label': "Github App Client Secret",
+            'placeholder': _('XXXXXXXXXXXXXXXXXXXXXXXXXXX'),
+        }
+    ))
+    webhook_secret = forms.CharField(required=False, widget=forms.TextInput(
+        attrs={
+            'label': "Github App Webhook Secret",
+            'placeholder': _('XXXXXXXXXXXXXXXXXXXXXXXXXXX'),
+        }
+    ))
+    private_key = forms.CharField(
+        widget=forms.Textarea(attrs={'rows': '60',
+                                     'label': "Github App Private Key",
+                                     'placeholder': _("-----BEGIN RSA PRIVATE KEY-----\n"
+                                                      "XXXXXXXXXXXXXXXXXXXXXXXXXXX\n"
+                                                      "XXXXXXXXXXXXXXXXXXXXXXXXXXX\n"
+                                                      "XXXXXXXXXXXXXXXXXXXXXXXXXXX\n"
+                                                      "XXXXXXXXXXXXXXXXXXXXXXXXXXX\n"
+                                                      "-----END RSA PRIVATE KEY-----"), }
+                              ))
+
+    def __init__(self, *args, **kwargs):
+        super(InstallationForm, self).__init__(*args, **kwargs)
+
+
+class InstallationConfigView(PipelineView):
+    def dispatch(self, request, pipeline):
+        form = InstallationForm(request.POST)
+        if form.is_valid():
+            form_data = form.cleaned_data
+            form_data['url'] = urlparse(form_data['url']).netloc
+
+            pipeline.bind_state('installation_data', form_data)
+
+            pipeline.bind_state('oauth_config_information', {
+                "access_token_url": "https://{}/login/oauth/access_token".format(form_data.get('url')),
+                "authorize_url": "https://{}/login/oauth/authorize".format(form_data.get('url')),
+                "client_id": form_data.get('client_id'),
+                "client_secret": form_data.get('client_secret'),
+            })
+
+            return pipeline.next_step()
+
+        project_form = InstallationForm()
+
+        return render_to_response(
+            template='sentry/integrations/github-enterprise-config.html',
+            context={
+                'form': project_form,
+            },
+            request=request,
+        )
+
+
+class GitHubEnterpriseIntegrationProvider(GitHubIntegrationProvider):
+    key = 'github-enterprise'
+    name = 'GitHub Enterprise'
+    metadata = metadata
+
+    def _make_identity_pipeline_view(self):
+        """
+        Make the nested identity provider view. It is important that this view is
+        not constructed until we reach this step and the
+        ``oauth_config_information`` is available in the pipeline state. This
+        method should be late bound into the pipeline vies.
+        """
+        identity_pipeline_config = dict(
+            oauth_scopes=(),
+            redirect_url=absolute_uri('/extensions/github-enterprise/setup/'),
+            verify_ssl=False,
+            **self.pipeline.fetch_state('oauth_config_information')
+        )
+
+        return NestedPipelineView(
+            bind_key='identity',
+            provider_key='github-enterprise',
+            pipeline_cls=IdentityProviderPipeline,
+            config=identity_pipeline_config,
+        )
+
+    def get_pipeline_views(self):
+        return [InstallationConfigView(),
+                GitHubEnterpriseInstallationRedirect(),
+
+                # The identity provider pipeline should be constructed at execution
+                # time, this allows for the oauth configuration parameters to be made
+                # available from the installation config view.
+                lambda: self._make_identity_pipeline_view()]
+
+    def get_installation_info(self, installation_data, access_token, installation_id):
+        session = http.build_session()
+        resp = session.get(
+            'https://{}/api/v3/app/installations/{}'.format(
+                installation_data['url'], installation_id),
+            headers={
+                'Authorization': 'Bearer %s' % get_jwt(github_id=installation_data['id'], github_private_key=installation_data['private_key']),
+                'Accept': 'application/vnd.github.machine-man-preview+json',
+            },
+            verify=False
+        )
+        resp.raise_for_status()
+        installation_resp = resp.json()
+
+        resp = session.get(
+            'https://{}/api/v3/user/installations'.format(installation_data['url']),
+            params={'access_token': access_token},
+            headers={'Accept': 'application/vnd.github.machine-man-preview+json'},
+            verify=False
+        )
+        resp.raise_for_status()
+        user_installations_resp = resp.json()
+
+        # verify that user actually has access to the installation
+        for installation in user_installations_resp['installations']:
+            if installation['id'] == installation_resp['id']:
+                return installation_resp
+
+        return None
+
+    def build_integration(self, state):
+        identity = state['identity']['data']
+        installation_data = state['installation_data']
+        user = get_user_info(installation_data['url'], identity['access_token'])
+        installation = self.get_installation_info(
+            installation_data,
+            identity['access_token'],
+            state['installation_id'])
+
+        return {
+            'name': installation['account']['login'],
+            'external_id': installation['id'],
+            'metadata': {
+                # The access token will be populated upon API usage
+                'access_token': None,
+                'expires_at': None,
+                'icon': installation['account']['avatar_url'],
+                'domain_name': installation['account']['html_url'].replace('https://', ''),
+                'installation': installation_data
+            },
+            'user_identity': {
+                'type': 'github-enterprise',
+                'external_id': user['id'],
+                'scopes': [],  # GitHub apps do not have user scopes
+                'data': {'access_token': identity['access_token']},
+            },
+            'identity_config': state['oauth_config_information']
+        }
+
+
+class GitHubEnterpriseInstallationRedirect(PipelineView):
+    def get_app_url(self, installation_data):
+        url = installation_data.get('url')
+        name = installation_data.get('name')
+        return 'https://{}/github-apps/{}'.format(url, name)
+
+    def dispatch(self, request, pipeline):
+        installation_data = pipeline.fetch_state(key='installation_data')
+        if 'installation_id' in request.GET:
+            pipeline.bind_state('installation_id', request.GET['installation_id'])
+            return pipeline.next_step()
+
+        return self.redirect(self.get_app_url(installation_data))
diff --git a/src/sentry/integrations/github_enterprise/payload.py b/src/sentry/integrations/github_enterprise/payload.py
new file mode 100644
index 0000000000..4067f635b5
--- /dev/null
+++ b/src/sentry/integrations/github_enterprise/payload.py
@@ -0,0 +1,76 @@
+from __future__ import absolute_import
+
+import hashlib
+import hmac
+import logging
+import six
+
+from django.http import HttpResponse
+from django.utils.crypto import constant_time_compare
+from django.utils.decorators import method_decorator
+from django.views.decorators.csrf import csrf_exempt
+from simplejson import JSONDecodeError
+from sentry import options
+
+from sentry.utils import json
+from sentry.api.base import Endpoint
+
+logger = logging.getLogger('sentry.integrations.github-enterprise')
+
+
+class GitHubEnterpriseAppsEndpoint(Endpoint):
+    authentication_classes = ()
+    permission_classes = ()
+
+    @method_decorator(csrf_exempt)
+    def dispatch(self, request, *args, **kwargs):
+        return super(GitHubEnterpriseAppsEndpoint, self).dispatch(request, *args, **kwargs)
+
+    def get_secret(self):
+        # todo(maxbittker)
+        return options.get('github-enterprise-app.webhook-secret')
+
+    def is_valid_signature(self, method, body, secret, signature):
+        if method != 'sha1':
+            raise NotImplementedError('signature method %s is not supported' % (method, ))
+
+        mod = hashlib.sha1
+        expected = hmac.new(
+            key=secret.encode('utf-8'),
+            msg=body,
+            digestmod=mod,
+        ).hexdigest()
+        return constant_time_compare(expected, signature)
+
+    def post(self, request, *kwargs):
+
+        secret = self.get_secret()
+        if secret is None:
+            logger.error('github-enterpise.webhook.missing-secret',)
+            return HttpResponse(status=401)
+
+        body = six.binary_type(request.body)
+        if not body:
+            logger.error('github-enterpise.webhook.missing-body',)
+            return HttpResponse(status=400)
+
+        try:
+            method, signature = request.META['HTTP_X_HUB_SIGNATURE'].split('=', 1)
+        except (KeyError, IndexError):
+            logger.error('github-enterpise.webhook.missing-signature',)
+            return HttpResponse(status=400)
+
+        if not self.is_valid_signature(method, body, self.get_secret(), signature):
+            logger.error('github-enterpise.webhook.invalid-signature',)
+            return HttpResponse(status=401)
+
+        try:
+            json.loads(body.decode('utf-8'))
+        except JSONDecodeError:
+            logger.error(
+                'github-enterpise.webhook.invalid-json',
+                exc_info=True,
+            )
+            return HttpResponse(status=400)
+
+        return HttpResponse(status=200)
diff --git a/src/sentry/integrations/github_enterprise/urls.py b/src/sentry/integrations/github_enterprise/urls.py
new file mode 100644
index 0000000000..d34f24cd51
--- /dev/null
+++ b/src/sentry/integrations/github_enterprise/urls.py
@@ -0,0 +1,11 @@
+from __future__ import absolute_import, print_function
+
+from django.conf.urls import patterns, url
+
+from .payload import GitHubEnterpriseAppsEndpoint
+
+
+urlpatterns = patterns(
+    '',
+    url(r'^payload/$', GitHubEnterpriseAppsEndpoint.as_view()),
+)
diff --git a/src/sentry/integrations/pipeline.py b/src/sentry/integrations/pipeline.py
index 3b43e16062..fbe80f4c2a 100644
--- a/src/sentry/integrations/pipeline.py
+++ b/src/sentry/integrations/pipeline.py
@@ -65,6 +65,7 @@ class IntegrationPipeline(Pipeline):
         # Does this integration provide a user identity for the user setting up
         # the integration?
         identity = data.get('user_identity')
+        identity_config = data.get('identity_config', {})
 
         if identity:
             # Create identity provider for this integration if necessary
@@ -72,8 +73,12 @@ class IntegrationPipeline(Pipeline):
                 external_id=data['external_id'],
                 organization=self.organization,
                 type=identity['type'],
+                defaults={'config': identity_config},
             )
 
+            if created:
+                idp.update(config=identity_config)
+
             identity, created = Identity.objects.get_or_create(
                 idp=idp,
                 user=self.request.user,
diff --git a/src/sentry/models/integration.py b/src/sentry/models/integration.py
index f7bb9f1d2a..2b90a3a43e 100644
--- a/src/sentry/models/integration.py
+++ b/src/sentry/models/integration.py
@@ -75,6 +75,7 @@ class Integration(Model):
 
         Returns True if the OrganizationIntegration was created
         """
+
         try:
             with transaction.atomic():
                 OrganizationIntegration.objects.create(
diff --git a/src/sentry/pipeline/__init__.py b/src/sentry/pipeline/__init__.py
index ef47617c9a..ec351b9d34 100644
--- a/src/sentry/pipeline/__init__.py
+++ b/src/sentry/pipeline/__init__.py
@@ -1,5 +1,7 @@
 from __future__ import absolute_import, print_function
 
+from types import LambdaType
+
 from sentry.models import Organization
 from sentry.web.frontend.base import BaseView
 from sentry.utils.session_store import RedisSessionStore
@@ -29,6 +31,12 @@ class PipelineProvider(object):
         """
         self.config = config
 
+    def set_pipeline(self, pipeline):
+        """
+        Used by the pipeline to give the provider access to the executing pipeline.
+        """
+        self.pipeline = pipeline
+
 
 class PipelineView(BaseView):
     """
@@ -79,6 +87,7 @@ class NestedPipelineView(PipelineView):
         )
 
         nested_pipeline.set_parent_pipeline(pipeline)
+        # nested_pipeline.bind_state('_parent', pipeline.fetch_state())
 
         if not nested_pipeline.is_valid():
             nested_pipeline.initialize()
@@ -146,6 +155,7 @@ class Pipeline(object):
         self.provider_model = provider_model
 
         self.config = config
+        self.provider.set_pipeline(self)
         self.provider.set_config(config)
 
         self.pipeline = self.get_pipeline_views()
@@ -153,7 +163,8 @@ class Pipeline(object):
         # we serialize the pipeline to be ['fqn.PipelineView', ...] which
         # allows us to determine if the pipeline has changed during the auth
         # flow or if the user is somehow circumventing a chunk of it
-        pipe_ids = ['{}.{}'.format(type(v).__module__, type(v).__name__) for v in self.pipeline]
+        pipe_ids = ['{}.{}'.format(type(v).__module__, type(v).__name__)
+                    for v in self.pipeline]
         self.signature = md5_text(*pipe_ids).hexdigest()
 
     def get_pipeline_views(self):
@@ -193,7 +204,13 @@ class Pipeline(object):
         if step_index == len(self.pipeline):
             return self.finish_pipeline()
 
-        return self.pipeline[step_index].dispatch(
+        step = self.pipeline[step_index]
+
+        # support late binding steps
+        if isinstance(step, LambdaType):
+            step = step()
+
+        return step.dispatch(
             request=self.request,
             pipeline=self,
         )
diff --git a/src/sentry/templates/sentry/integrations/github-enterprise-config.html b/src/sentry/templates/sentry/integrations/github-enterprise-config.html
new file mode 100644
index 0000000000..5a36a61d34
--- /dev/null
+++ b/src/sentry/templates/sentry/integrations/github-enterprise-config.html
@@ -0,0 +1,32 @@
+{% extends "sentry/bases/modal.html" %}
+{% load crispy_forms_tags %}
+{% load sentry_assets %}
+{% load i18n %}
+
+{% block wrapperclass %} narrow auth {% endblock %}
+{% block modal_header_signout %} {% endblock %}
+
+{% block title %} {% trans "Github Enterprise Setup" %} | {{ block.super }} {% endblock %}
+
+{% block main %}
+<h3>Github Enterprise Configuration</h3>
+
+<form action="" method="post" class="form-stacked">
+  {% csrf_token %}
+  <input type="hidden" name="provider" value="vsts" />
+
+  <p>
+    Configure Github Enterprise to use with Sentry.io.
+  </p>
+
+  {{ form|as_crispy_errors }}
+
+  {% for field in form %}
+   {{ field|as_crispy_field }}
+  {% endfor %}
+
+  <fieldset class="form-actions">
+    <button type="submit" class="btn btn-primary" name="save_mappings" value="url">{% trans "Submit" %}</button>
+  </fieldset>
+</form>
+{% endblock %}
diff --git a/src/sentry/utils/pytest/sentry.py b/src/sentry/utils/pytest/sentry.py
index c23caec980..753715c9b3 100644
--- a/src/sentry/utils/pytest/sentry.py
+++ b/src/sentry/utils/pytest/sentry.py
@@ -200,11 +200,13 @@ def register_extensions():
     from sentry import integrations
     from sentry.integrations.example import ExampleIntegrationProvider
     from sentry.integrations.github import GitHubIntegrationProvider
+    from sentry.integrations.github_enterprise import GitHubEnterpriseIntegrationProvider
     from sentry.integrations.jira import JiraIntegrationProvider
     from sentry.integrations.slack import SlackIntegrationProvider
     from sentry.integrations.vsts import VSTSIntegrationProvider
     integrations.register(ExampleIntegrationProvider)
     integrations.register(GitHubIntegrationProvider)
+    integrations.register(GitHubEnterpriseIntegrationProvider)
     integrations.register(JiraIntegrationProvider)
     integrations.register(SlackIntegrationProvider)
     integrations.register(VSTSIntegrationProvider)
diff --git a/tests/sentry/integrations/github_enterprise/__init__.py b/tests/sentry/integrations/github_enterprise/__init__.py
new file mode 100644
index 0000000000..c3961685ab
--- /dev/null
+++ b/tests/sentry/integrations/github_enterprise/__init__.py
@@ -0,0 +1 @@
+from __future__ import absolute_import
diff --git a/tests/sentry/integrations/github_enterprise/test_integration.py b/tests/sentry/integrations/github_enterprise/test_integration.py
new file mode 100644
index 0000000000..0683519173
--- /dev/null
+++ b/tests/sentry/integrations/github_enterprise/test_integration.py
@@ -0,0 +1,156 @@
+from __future__ import absolute_import
+
+import responses
+import six
+from mock import patch
+
+from six.moves.urllib.parse import parse_qs, urlencode, urlparse
+
+from sentry.integrations.github_enterprise import GitHubEnterpriseIntegrationProvider
+from sentry.models import Identity, IdentityProvider, IdentityStatus, Integration, OrganizationIntegration
+from sentry.testutils import IntegrationTestCase
+
+
+class GitHubEnterpriseIntegrationTest(IntegrationTestCase):
+    provider = GitHubEnterpriseIntegrationProvider
+    config = {
+        'url': 'https://35.232.149.196',
+        'id': 2,
+        'name': 'test-app',
+        'client_id': 'client_id',
+        'client_secret': 'client_secret',
+        'webhook_secret': 'webhook_secret',
+        'private_key': 'private_key'
+    }
+
+    @patch('sentry.integrations.github_enterprise.integration.get_jwt', return_value='jwt_token_1')
+    def assert_setup_flow(self, get_jwt, installation_id='install_id_1', user_id='user_id_1'):
+        responses.reset()
+        resp = self.client.get(self.init_path)
+        assert resp.status_code == 200
+        resp = self.client.post(self.init_path, data=self.config)
+        assert resp.status_code == 302
+        redirect = urlparse(resp['Location'])
+        assert redirect.scheme == 'https'
+        assert redirect.netloc == '35.232.149.196'
+        assert redirect.path == '/github-apps/test-app'
+
+        # App installation ID is provided, mveo thr
+        resp = self.client.get('{}?{}'.format(
+            self.setup_path,
+            urlencode({'installation_id': installation_id})
+        ))
+
+        assert resp.status_code == 302
+        redirect = urlparse(resp['Location'])
+        assert redirect.scheme == 'https'
+        assert redirect.netloc == '35.232.149.196'
+        assert redirect.path == '/login/oauth/authorize'
+
+        params = parse_qs(redirect.query)
+        assert params['state']
+        assert params['redirect_uri'] == ['http://testserver/extensions/github-enterprise/setup/']
+        assert params['response_type'] == ['code']
+        assert params['client_id'] == ['client_id']
+        # once we've asserted on it, switch to a singular values to make life
+        # easier
+        authorize_params = {k: v[0] for k, v in six.iteritems(params)}
+
+        access_token = 'xxxxx-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx'
+
+        responses.add(
+            responses.POST, 'https://35.232.149.196/login/oauth/access_token',
+            json={'access_token': access_token}
+        )
+
+        responses.add(
+            responses.GET, 'https://35.232.149.196/api/v3/user',
+            json={'id': user_id}
+        )
+
+        responses.add(
+            responses.GET,
+            u'https://35.232.149.196/api/v3/app/installations/{}'.format(installation_id),
+            json={
+                'id': installation_id,
+                'account': {
+                    'login': 'Test Organization',
+                    'avatar_url': 'https://35.232.149.196/avatar.png',
+                    'html_url': 'https://35.232.149.196/Test-Organization',
+                },
+            }
+        )
+
+        responses.add(
+            responses.GET, u'https://35.232.149.196/api/v3/user/installations',
+            json={
+                'installations': [{'id': installation_id}],
+            }
+        )
+
+        resp = self.client.get('{}?{}'.format(
+            self.setup_path,
+            urlencode({
+                'code': 'oauth-code',
+                'state': authorize_params['state'],
+            })
+        ))
+
+        mock_access_token_request = responses.calls[0].request
+        req_params = parse_qs(mock_access_token_request.body)
+        assert req_params['grant_type'] == ['authorization_code']
+        assert req_params['code'] == ['oauth-code']
+        assert req_params['redirect_uri'] == [
+            'http://testserver/extensions/github-enterprise/setup/']
+        assert req_params['client_id'] == ['client_id']
+        assert req_params['client_secret'] == ['client_secret']
+
+        assert resp.status_code == 200
+
+        auth_header = responses.calls[2].request.headers['Authorization']
+        assert auth_header == 'Bearer jwt_token_1'
+
+        self.assertDialogSuccess(resp)
+
+    @responses.activate
+    def test_basic_flow(self):
+        self.assert_setup_flow()
+
+        integration = Integration.objects.get(provider=self.provider.key)
+
+        assert integration.external_id == 'install_id_1'
+        assert integration.name == 'Test Organization'
+        assert integration.metadata == {
+            'access_token': None,
+            'expires_at': None,
+            'icon': 'https://35.232.149.196/avatar.png',
+            'domain_name': '35.232.149.196/Test-Organization',
+            'installation': {
+                'client_id': 'client_id',
+                'client_secret': 'client_secret',
+                'id': '2',
+                'name': 'test-app',
+                'private_key': 'private_key',
+                'url': '35.232.149.196',
+                'webhook_secret': 'webhook_secret',
+            }
+        }
+        oi = OrganizationIntegration.objects.get(
+            integration=integration,
+            organization=self.organization,
+        )
+        assert oi.config == {}
+
+        idp = IdentityProvider.objects.get(
+            type='github-enterprise',
+            organization=self.organization,
+        )
+        identity = Identity.objects.get(
+            idp=idp,
+            user=self.user,
+            external_id='user_id_1',
+        )
+        assert identity.status == IdentityStatus.VALID
+        assert identity.data == {
+            'access_token': 'xxxxx-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx'
+        }
diff --git a/tests/sentry/pipeline/test_pipeline.py b/tests/sentry/pipeline/test_pipeline.py
index f507b02d89..00505f41be 100644
--- a/tests/sentry/pipeline/test_pipeline.py
+++ b/tests/sentry/pipeline/test_pipeline.py
@@ -14,10 +14,10 @@ class PipelineStep(PipelineView):
 
 class DummyProvider(PipelineProvider):
     key = 'dummy'
-    pipeline = [PipelineStep(), PipelineStep()]
+    pipeline_views = [PipelineStep(), PipelineStep()]
 
     def get_pipeline_views(self):
-        return self.pipeline
+        return self.pipeline_views
 
 
 class DummyPipeline(Pipeline):
@@ -78,11 +78,11 @@ class PipelineTestCase(TestCase):
 
         # Mutate the provider, Remove an item from the pipeline, thus
         # invalidating the pipeline.
-        prev_pipeline = DummyProvider.pipeline
-        DummyProvider.pipeline = [PipelineStep()]
+        prev_pipeline_views = DummyProvider.pipeline_views
+        DummyProvider.pipeline_views = [PipelineStep()]
 
         pipeline = DummyPipeline.get_for_request(request)
 
         assert not pipeline.is_valid()
 
-        DummyProvider.pipeline = prev_pipeline
+        DummyProvider.pipeline_views = prev_pipeline_views

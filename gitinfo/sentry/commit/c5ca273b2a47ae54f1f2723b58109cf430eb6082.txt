commit c5ca273b2a47ae54f1f2723b58109cf430eb6082
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Mon Oct 1 11:18:59 2018 -0700

    ref(js): Refactor/fix GuideStore (#9913)
    
    I went down a rabbit hole trying to figure out why GuideStore tests were failing.
    I still do not know why they are passing on travis but fails locally,
    but I believe theres some concurrency issues here.
    
    This refactors GuideStore to handle async requests a bit better,
    the downside is that now `updateCurrentGuide` is async.

diff --git a/src/sentry/static/sentry/app/stores/guideStore.jsx b/src/sentry/static/sentry/app/stores/guideStore.jsx
index eab73a420e..28a27db9de 100644
--- a/src/sentry/static/sentry/app/stores/guideStore.jsx
+++ b/src/sentry/static/sentry/app/stores/guideStore.jsx
@@ -1,6 +1,5 @@
 import {browserHistory} from 'react-router';
 import Reflux from 'reflux';
-import $ from 'jquery';
 import GuideActions from 'app/actions/guideActions';
 import OrganizationsActions from 'app/actions/organizationsActions';
 import analytics from 'app/utils/analytics';
@@ -26,15 +25,17 @@ const GuideStore = Reflux.createStore({
       org: null,
       // Current project.
       project: null,
-      // Total events received in the project in the last 30 days. id (int) -> int.
-      projectStats: {},
-      // Whether the project has customized alert rules. id (int) -> bool.
-      projectRules: {},
       // We force show a guide if the URL contains #assistant.
       forceShow: false,
       // The previously shown guide.
       prevGuide: null,
     };
+
+    // Total events received in the project in the last 30 days. id (int) -> int.
+    this.projectStats = new Map();
+    // Whether the project has customized alert rules. id (int) -> bool.
+    this.projectRules = new Map();
+
     this.api = new Client();
     this.listenTo(GuideActions.fetchSucceeded, this.onFetchSucceeded);
     this.listenTo(GuideActions.closeGuide, this.onCloseGuide);
@@ -139,49 +140,99 @@ const GuideStore = Reflux.createStore({
     );
   },
 
-  checkAlertTipData() {
-    // Check if we have the data needed to determine if the alert-reminder tip should be shown.
-    // If not, take the necessary actions to fetch the data.
-    let {org, project, projectStats, projectRules} = this.state;
+  async getProjectStats(projectId) {
+    let {projectStats} = this;
+    let {org, project} = this.state;
 
-    if (!org || !project) {
-      return false;
+    if (projectStats.has(projectId)) {
+      return Promise.resolve(projectStats.get(projectId));
     }
 
-    let projectId = parseInt(project.id, 10);
-    let ready = true;
-
-    if (projectStats[projectId] === undefined) {
-      ready = false;
-      let path = `/projects/${org.slug}/${project.slug}/stats/`;
-      this.api.request(path, {
+    let path = `/projects/${org.slug}/${project.slug}/stats/`;
+    return this.api
+      .requestPromise(path, {
         query: {
           // Last 30 days.
           since: new Date().getTime() / 1000 - 3600 * 24 * 30,
         },
-        success: data => {
-          let eventsReceived = data.reduce((sum, point) => sum + point[1], 0);
-          projectStats[projectId] = eventsReceived;
-          this.updateCurrentGuide();
-        },
+      })
+      .then(data => {
+        let eventsReceived = data.reduce((sum, point) => sum + point[1], 0);
+        projectStats.set(projectId, eventsReceived);
+        return eventsReceived;
       });
+  },
+
+  async getProjectRules(projectId) {
+    let {projectRules} = this;
+    let {org, project} = this.state;
+
+    if (projectRules.has(projectId)) {
+      return Promise.resolve(projectRules.get(projectId));
     }
 
-    if (projectRules[projectId] === undefined) {
-      ready = false;
-      let path = `/projects/${org.slug}/${project.slug}/rules/`;
-      this.api.request(path, {
-        success: data => {
-          projectRules[projectId] = !this.isDefaultAlert(data);
-          this.updateCurrentGuide();
+    let path = `/projects/${org.slug}/${project.slug}/rules/`;
+    return this.api
+      .requestPromise(path, {
+        query: {
+          // Last 30 days.
+          since: new Date().getTime() / 1000 - 3600 * 24 * 30,
         },
+      })
+      .then(data => {
+        let result = !this.isDefaultAlert(data);
+        projectRules.set(projectId, result);
+        return result;
       });
+  },
+
+  async checkAlertTipData() {
+    // Check if we have the data needed to determine if the alert-reminder tip should be shown.
+    // If not, take the necessary actions to fetch the data.
+    let {org, project} = this.state;
+
+    if (!org || !project) {
+      return Promise.resolve([]);
     }
 
-    return ready;
+    let projectId = parseInt(project.id, 10);
+    return Promise.all([
+      this.getProjectStats(projectId),
+      this.getProjectRules(projectId),
+    ]);
   },
 
-  updateCurrentGuide() {
+  async getBestGuideKey(guideKeys) {
+    // Pick the first guide that satisfies conditions.
+    let user = ConfigStore.get('user');
+
+    return new Promise(async (resolve, reject) => {
+      let projectData = [];
+
+      if (guideKeys.includes(ALERT_REMINDER_1)) {
+        projectData = await this.checkAlertTipData();
+      }
+
+      resolve(
+        guideKeys.find(key => {
+          // Pick the first guide that satisfies conditions.
+          if (key === ALERT_REMINDER_1) {
+            let [stats, rules] = projectData;
+            return !rules && stats > 1000;
+          } else if (
+            user.isSuperuser ||
+            new Date(user.dateJoined) > new Date(2018, 4, 10)
+          ) {
+            return true;
+          }
+
+          return false;
+        })
+      );
+    });
+  },
+
+  async updateCurrentGuide() {
     // Logic to determine if a guide is shown:
     // 1. If any required target is missing, don't show the guide.
     // 2. If custom checks fail, don't show the guide.
@@ -191,6 +242,7 @@ const GuideStore = Reflux.createStore({
     // 6. Otherwise show the guide.
 
     let availableTargets = [...this.state.anchors].map(a => a.props.target);
+
     // sort() so that we pick a guide deterministically every time this function is called.
     let guideKeys = Object.keys(this.state.guides)
       .sort()
@@ -210,38 +262,20 @@ const GuideStore = Reflux.createStore({
     }
 
     // Pick the first guide that satisfies conditions.
-    let bestGuideKey = null;
-    let user = ConfigStore.get('user');
-    for (let key of guideKeys) {
-      if (key === ALERT_REMINDER_1) {
-        if (!this.checkAlertTipData()) {
-          // Wait for the required data.
-          break;
-        } else {
-          let projectId = parseInt(this.state.project.id, 10);
-          if (
-            this.state.projectStats[projectId] > 1000 &&
-            !this.state.projectRules[projectId]
-          ) {
-            bestGuideKey = key;
-            break;
-          }
-        }
-      } else if (user.isSuperuser || new Date(user.dateJoined) > new Date(2018, 4, 10)) {
-        bestGuideKey = key;
-        break;
-      }
-    }
+    let bestGuideKey = await this.getBestGuideKey(guideKeys);
 
     let bestGuide = null;
     if (bestGuideKey) {
-      bestGuide = $.extend(true, {}, this.state.guides[bestGuideKey]);
-      // Remove steps that don't have an anchor on the page.
-      bestGuide.steps = bestGuide.steps.filter(
-        step =>
-          step.target === null ||
-          (step.target && availableTargets.indexOf(step.target) >= 0)
-      );
+      bestGuide = {
+        ...this.state.guides[bestGuideKey],
+
+        // Remove steps that don't have an anchor on the page.
+        steps: this.state.guides[bestGuideKey].steps.filter(
+          step =>
+            step.target === null ||
+            (step.target && availableTargets.indexOf(step.target) >= 0)
+        ),
+      };
     }
 
     this.updatePrevGuide(bestGuide);
diff --git a/tests/js/spec/stores/guideStore.spec.jsx b/tests/js/spec/stores/guideStore.spec.jsx
index 67dc97f221..4f9a590574 100644
--- a/tests/js/spec/stores/guideStore.spec.jsx
+++ b/tests/js/spec/stores/guideStore.spec.jsx
@@ -64,8 +64,9 @@ describe('GuideStore', function() {
     sandbox.restore();
   });
 
-  it('should move through the steps in the guide', function() {
+  it('should move through the steps in the guide', async function() {
     GuideStore.onFetchSucceeded(data);
+    await tick();
     let guide = GuideStore.state.currentGuide;
     // Should pick the first non-seen guide in alphabetic order.
     expect(guide.id).toEqual(2);
@@ -73,32 +74,42 @@ describe('GuideStore', function() {
     GuideStore.onNextStep();
     expect(GuideStore.state.currentStep).toEqual(1);
     GuideStore.onCloseGuide();
+    await tick();
     guide = GuideStore.state.currentGuide;
     // We don't have the alert reminder guide's data yet, so we can't show it.
     expect(guide).toEqual(null);
   });
 
-  it('should not show a guide if the user is not in the experiment', function() {
+  it('should not show a guide if the user is not in the experiment', async function() {
     ConfigStore.get('features').delete('assistant');
     GuideStore.onFetchSucceeded(data);
+    await tick();
     expect(GuideStore.state.currentGuide).toEqual(null);
   });
 
-  it('should force show a guide', function() {
+  it('should force show a guide', async function() {
     GuideStore.onFetchSucceeded(data);
+    await tick();
     window.location.hash = '#assistant';
     GuideStore.onURLChange();
+    await tick();
     expect(GuideStore.state.currentGuide.id).toEqual(1);
     // Should prune steps that don't have anchors.
     expect(GuideStore.state.currentGuide.steps).toHaveLength(2);
     GuideStore.onCloseGuide();
+    await tick();
     expect(GuideStore.state.currentGuide.id).toEqual(2);
     window.location.hash = '';
   });
 
   it('should render tip', async function() {
-    data.Guide2.seen = true;
-    GuideStore.onFetchSucceeded(data);
+    GuideStore.onFetchSucceeded({
+      ...data,
+      Guide2: {
+        ...data.Guide2,
+        seen: true,
+      },
+    });
     expect(GuideStore.state.currentGuide).toEqual(null);
     let spy = jest.spyOn(GuideStore, 'isDefaultAlert').mockImplementation(() => true);
     GuideStore.onSetActiveOrganization({id: 1, slug: 'org'});
@@ -108,22 +119,25 @@ describe('GuideStore', function() {
     spy.mockRestore();
   });
 
-  it('should record analytics events when guide is cued', function() {
+  it('should record analytics events when guide is cued', async function() {
     let spy = jest.spyOn(GuideStore, 'recordCue');
 
     GuideStore.onFetchSucceeded(data);
+    await tick();
     expect(spy).toHaveBeenCalledWith(data.Guide2.id, data.Guide2.cue);
     expect(spy).toHaveBeenCalledTimes(1);
     spy.mockRestore();
   });
 
-  it('should not send multiple cue analytics events for same guide', function() {
+  it('should not send multiple cue analytics events for same guide', async function() {
     let spy = jest.spyOn(GuideStore, 'recordCue');
 
     GuideStore.onFetchSucceeded(data);
+    await tick();
     expect(spy).toHaveBeenCalledWith(data.Guide2.id, data.Guide2.cue);
     expect(spy).toHaveBeenCalledTimes(1);
     GuideStore.updateCurrentGuide();
+    await tick();
     expect(spy).toHaveBeenCalledTimes(1);
     spy.mockRestore();
   });

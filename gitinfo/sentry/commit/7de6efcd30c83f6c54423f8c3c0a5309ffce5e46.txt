commit 7de6efcd30c83f6c54423f8c3c0a5309ffce5e46
Author: Stephen Cefali <scefali@sentry.io>
Date:   Tue Mar 17 08:49:17 2020 -0700

    feat (integration): integration api caching (#17707)

diff --git a/src/sentry/integrations/client.py b/src/sentry/integrations/client.py
index 1b2a2ac81b..3ed319b69c 100644
--- a/src/sentry/integrations/client.py
+++ b/src/sentry/integrations/client.py
@@ -8,12 +8,14 @@ import six
 from collections import OrderedDict
 from time import time
 
+from django.core.cache import cache
 from bs4 import BeautifulSoup
 from django.utils.functional import cached_property
 from requests.exceptions import ConnectionError, Timeout, HTTPError
 from sentry.exceptions import InvalidIdentity
 from sentry.http import build_session
 from sentry.utils import metrics
+from sentry.utils.hashlib import md5_text
 
 from .exceptions import ApiHostError, ApiTimeoutError, ApiError, UnsupportedResponseType
 
@@ -124,10 +126,15 @@ class ApiClient(object):
     # Used in metrics and logging.
     integration_name = "undefined"
 
+    cache_time = 900
+
     def __init__(self, verify_ssl=True, logging_context=None):
         self.verify_ssl = verify_ssl
         self.logging_context = logging_context
 
+    def get_cache_prefix(self):
+        return "%s.client:" % six.text_type(self.integration_name)
+
     def track_response_data(self, code, error=None):
         logger = logging.getLogger("sentry.integrations.client")
 
@@ -230,6 +237,18 @@ class ApiClient(object):
     def delete(self, *args, **kwargs):
         return self.request("DELETE", *args, **kwargs)
 
+    def get_cached(self, path, *args, **kwargs):
+        query = ""
+        if kwargs.get("params", None):
+            query = json.dumps(kwargs.get("params"), sort_keys=True)
+        key = self.get_cache_prefix() + md5_text(self.build_url(path), query).hexdigest()
+
+        result = cache.get(key)
+        if result is None:
+            result = self.request("GET", path, *args, **kwargs)
+            cache.set(key, result, self.cache_time)
+        return result
+
     def get(self, *args, **kwargs):
         return self.request("GET", *args, **kwargs)
 
diff --git a/src/sentry/integrations/github/client.py b/src/sentry/integrations/github/client.py
index 526a50e0e2..78302b4716 100644
--- a/src/sentry/integrations/github/client.py
+++ b/src/sentry/integrations/github/client.py
@@ -19,12 +19,12 @@ class GitHubClientMixin(ApiClient):
         # return api request that fetches last ~30 commits
         # see https://developer.github.com/v3/repos/commits/#list-commits-on-a-repository
         # using end_sha as parameter
-        return self.get(u"/repos/{}/commits".format(repo), params={"sha": end_sha})
+        return self.get_cached(u"/repos/{}/commits".format(repo), params={"sha": end_sha})
 
     def compare_commits(self, repo, start_sha, end_sha):
         # see https://developer.github.com/v3/repos/commits/#compare-two-commits
         # where start sha is oldest and end is most recent
-        return self.get(u"/repos/{}/compare/{}...{}".format(repo, start_sha, end_sha))
+        return self.get_cached(u"/repos/{}/compare/{}...{}".format(repo, start_sha, end_sha))
 
     def repo_hooks(self, repo):
         return self.get(u"/repos/{}/hooks".format(repo))
@@ -33,7 +33,7 @@ class GitHubClientMixin(ApiClient):
         return self.get(u"/repos/{}/commits".format(repo))
 
     def get_commit(self, repo, sha):
-        return self.get(u"/repos/{}/commits/{}".format(repo, sha))
+        return self.get_cached(u"/repos/{}/commits/{}".format(repo, sha))
 
     def get_repo(self, repo):
         return self.get(u"/repos/{}".format(repo))
diff --git a/src/sentry/integrations/github/repository.py b/src/sentry/integrations/github/repository.py
index d971d5e42a..3fb26a490b 100644
--- a/src/sentry/integrations/github/repository.py
+++ b/src/sentry/integrations/github/repository.py
@@ -3,12 +3,9 @@ from __future__ import absolute_import
 import logging
 import six
 
-from django.core.cache import cache
-
 from sentry.integrations.exceptions import ApiError, IntegrationError
 from sentry.models import Integration
 from sentry.plugins import providers
-from sentry.utils.hashlib import md5_text
 
 WEBHOOK_EVENTS = ["push", "pull_request"]
 
@@ -112,13 +109,8 @@ class GitHubRepositoryProvider(providers.IntegrationRepositoryProvider):
     def _get_patchset(self, client, repo_name, sha):
         """Get the modified files for a commit
         """
-        key = u"get_commit:{}:{}".format(md5_text(repo_name).hexdigest(), sha)
-        commit_files = cache.get(key)
-        if commit_files is None:
-            commit_files = client.get_commit(repo_name, sha)["files"]
-            cache.set(key, commit_files, 900)
-
-        return self._transform_patchset(commit_files)
+        commit = client.get_commit(repo_name, sha)
+        return self._transform_patchset(commit["files"])
 
     def _transform_patchset(self, diff):
         """Convert the patch data from GitHub into our internal format
diff --git a/src/sentry/integrations/jira/client.py b/src/sentry/integrations/jira/client.py
index 5ddf1cacc1..fc585b6535 100644
--- a/src/sentry/integrations/jira/client.py
+++ b/src/sentry/integrations/jira/client.py
@@ -3,13 +3,9 @@ from __future__ import absolute_import
 import datetime
 import jwt
 import re
-import json
 import logging
-from hashlib import md5 as _md5
 from six.moves.urllib.parse import parse_qs, urlparse, urlsplit
 
-from sentry.utils.cache import cache
-from django.utils.encoding import force_bytes
 
 from sentry.integrations.atlassian_connect import get_query_hash
 from sentry.integrations.exceptions import ApiError
@@ -22,10 +18,6 @@ JIRA_KEY = "%s.jira" % (urlparse(absolute_uri()).hostname,)
 ISSUE_KEY_RE = re.compile(r"^[A-Za-z][A-Za-z0-9]*-\d+$")
 
 
-def md5(*bits):
-    return _md5(b":".join((force_bytes(bit, errors="replace") for bit in bits)))
-
-
 class JiraCloud(object):
     """
     Contains the jira-cloud specifics that a JiraClient needs
@@ -91,6 +83,11 @@ class JiraApiClient(ApiClient):
 
     integration_name = "jira"
 
+    # This timeout is completely arbitrary. Jira doesn't give us any
+    # caching headers to work with. Ideally we want a duration that
+    # lets the user make their second jira issue with cached data.
+    cache_time = 240
+
     def __init__(self, base_url, jira_style, verify_ssl, logging_context=None):
         self.base_url = base_url
         # `jira_style` encapsulates differences between jira server & jira cloud.
@@ -99,6 +96,9 @@ class JiraApiClient(ApiClient):
         self.jira_style = jira_style
         super(JiraApiClient, self).__init__(verify_ssl, logging_context)
 
+    def get_cache_prefix(self):
+        return self.jira_style.cache_prefix
+
     def request(self, method, path, data=None, params=None, **kwargs):
         """
         Use the request_hook method for our specific style of Jira to
@@ -120,23 +120,6 @@ class JiraApiClient(ApiClient):
     def query_field(self):
         return self.jira_style.query_field()
 
-    def get_cached(self, url, params=None):
-        """
-        Basic Caching mechanism for Jira metadata which changes infrequently
-        """
-        query = ""
-        if params:
-            query = json.dumps(params, sort_keys=True)
-        key = self.jira_style.cache_prefix + md5(url, query, self.base_url).hexdigest()
-        cached_result = cache.get(key)
-        if not cached_result:
-            cached_result = self.get(url, params=params)
-            # This timeout is completely arbitrary. Jira doesn't give us any
-            # caching headers to work with. Ideally we want a duration that
-            # lets the user make their second jira issue with cached data.
-            cache.set(key, cached_result, 240)
-        return cached_result
-
     def get_issue(self, issue_id):
         return self.get(self.ISSUE_URL % (issue_id,))
 
diff --git a/src/sentry_plugins/jira/client.py b/src/sentry_plugins/jira/client.py
index 8a15289ab5..0eba5576d2 100644
--- a/src/sentry_plugins/jira/client.py
+++ b/src/sentry_plugins/jira/client.py
@@ -101,6 +101,7 @@ class JiraClient(ApiClient):
         jql = 'project="%s" AND %s' % (project, jql)
         return self.get(self.SEARCH_URL, params={"jql": jql})
 
+    # Steve(XXX): Might consider moving this method to the base plugin API client
     def get_cached(self, full_url):
         """
         Basic Caching mechanism for requests and responses. It only caches responses
diff --git a/tests/sentry/integrations/test_client.py b/tests/sentry/integrations/test_client.py
index 3ff17041e9..7f1322e5f0 100644
--- a/tests/sentry/integrations/test_client.py
+++ b/tests/sentry/integrations/test_client.py
@@ -2,6 +2,7 @@ from __future__ import absolute_import
 
 import responses
 
+from sentry.utils.compat import mock
 from time import time
 from sentry.testutils import TestCase
 
@@ -47,6 +48,52 @@ class ApiClientTest(TestCase):
         resp = ApiClient().patch("http://example.com")
         assert resp.status_code == 200
 
+    @mock.patch("django.core.cache.cache.set")
+    @mock.patch("django.core.cache.cache.get")
+    @responses.activate
+    def test_cache_mocked(self, cache_get, cache_set):
+        cache_get.return_value = None
+        responses.add(responses.GET, "http://example.com", json={"key": "value1"})
+        resp = ApiClient().get_cached("http://example.com")
+        assert resp == {"key": "value1"}
+
+        key = "undefined.client:a9b9f04336ce0181a08e774e01113b31"
+        cache_get.assert_called_with(key)
+        cache_set.assert_called_with(key, {"key": "value1"}, 900)
+
+    @responses.activate
+    def test_get_cached_basic(self):
+        responses.add(responses.GET, "http://example.com", json={"key": "value1"})
+
+        resp = ApiClient().get_cached("http://example.com")
+        assert resp == {"key": "value1"}
+        assert len(responses.calls) == 1
+
+        # should still return old value
+        responses.replace(responses.GET, "http://example.com", json={"key": "value2"})
+        resp = ApiClient().get_cached("http://example.com")
+        assert resp == {"key": "value1"}
+        assert len(responses.calls) == 1
+
+        # make sure normal get isn't impacted
+        resp = ApiClient().get("http://example.com")
+        assert resp == {"key": "value2"}
+        assert len(responses.calls) == 2
+
+    @responses.activate
+    def test_get_cached_query_param(self):
+        responses.add(responses.GET, "http://example.com?param=val", json={})
+        responses.add(responses.GET, "http://example.com?param=different", json={})
+
+        ApiClient().get_cached("http://example.com", params={"param": "val"})
+        assert len(responses.calls) == 1
+
+        ApiClient().get_cached("http://example.com", params={"param": "val"})
+        assert len(responses.calls) == 1
+
+        ApiClient().get_cached("http://example.com", params={"param": "different"})
+        assert len(responses.calls) == 2
+
 
 class OAuthProvider(OAuth2Provider):
     key = "oauth"

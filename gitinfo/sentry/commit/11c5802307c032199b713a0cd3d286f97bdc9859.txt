commit 11c5802307c032199b713a0cd3d286f97bdc9859
Author: Matt Robenolt <matt@ydekproductions.com>
Date:   Mon Nov 30 11:38:51 2015 -0800

    Support for validating options

diff --git a/src/sentry/options/__init__.py b/src/sentry/options/__init__.py
index 8f80aec2dd..2ecd31a022 100644
--- a/src/sentry/options/__init__.py
+++ b/src/sentry/options/__init__.py
@@ -8,6 +8,11 @@ sentry.options
 from __future__ import absolute_import, print_function
 
 from .manager import OptionsManager
+from .manager import DEFAULT_FLAGS, FLAG_IMMUTABLE, FLAG_NOSTORE, FLAG_STOREONLY  # NOQA
+
+__all__ = (
+    'get', 'set', 'delete', 'register',
+)
 
 default_manager = OptionsManager()
 
@@ -16,3 +21,5 @@ get = default_manager.get
 set = default_manager.set
 delete = default_manager.delete
 register = default_manager.register
+
+from .defaults import *  # NOQA
diff --git a/src/sentry/options/defaults.py b/src/sentry/options/defaults.py
new file mode 100644
index 0000000000..d363f1af98
--- /dev/null
+++ b/src/sentry/options/defaults.py
@@ -0,0 +1,19 @@
+"""
+sentry.options.defaults
+~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+from __future__ import absolute_import, print_function
+
+
+from sentry.options import register, FLAG_NOSTORE
+
+
+register('cache.backend', default={}, flags=FLAG_NOSTORE)
+register('cache.options', default={}, flags=FLAG_NOSTORE)
+register('system.databases', default={}, flags=FLAG_NOSTORE)
+register('system.debug', default=False, flags=FLAG_NOSTORE)
+register('system.secret-key', flags=FLAG_NOSTORE)
+register('redis.options', default={}, flags=FLAG_NOSTORE)
diff --git a/src/sentry/options/manager.py b/src/sentry/options/manager.py
index 066e3df86d..014072df28 100644
--- a/src/sentry/options/manager.py
+++ b/src/sentry/options/manager.py
@@ -30,6 +30,16 @@ class UnknownOption(KeyError):
     pass
 
 
+DEFAULT_FLAGS = 0b000
+# Value can't be changed at runtime
+FLAG_IMMUTABLE = 0b001
+# Don't check/set in the datastore. Option only exists from file.
+FLAG_NOSTORE = 0b010
+# Values that should only exist in datastore, and shouldn't exist in
+# config files.
+FLAG_STOREONLY = 0b100
+
+
 class OptionsManager(object):
     """
     A backend for storing generic configuration within Sentry.
@@ -47,14 +57,6 @@ class OptionsManager(object):
     dynamic configuration with maximum uptime, where defaults are always taken from
     constants in the global configuration.
     """
-    DEFAULT_FLAGS = 0b000
-    # Value can't be changed at runtime
-    FLAG_IMMUTABLE = 0b001
-    # Don't check/set in the datastore. Option only exists from file.
-    FLAG_NOSTORE = 0b010
-    # Values that should only exist in datastore, and shouldn't exist in
-    # config files.
-    FLAG_STOREONLY = 0b100
 
     def __init__(self, cache=None, ttl=None, logger=None):
         if cache is None:
@@ -82,9 +84,9 @@ class OptionsManager(object):
         opt = self.lookup_key(key)
 
         # If an option isn't able to exist in the store, we can't set it at runtime
-        assert not (opt.flags & self.FLAG_NOSTORE), '%r cannot be changed at runtime' % key
+        assert not (opt.flags & FLAG_NOSTORE), '%r cannot be changed at runtime' % key
         # Enforce immutability on key
-        assert not (opt.flags & self.FLAG_IMMUTABLE), '%r cannot be changed at runtime' % key
+        assert not (opt.flags & FLAG_IMMUTABLE), '%r cannot be changed at runtime' % key
 
         if not isinstance(value, opt.type):
             raise TypeError('got %r, expected %r' % (_type(value), opt.type))
@@ -116,7 +118,7 @@ class OptionsManager(object):
                 self.logger.debug('Using legacy key: %s', key, exc_info=True)
                 # History shows, there was an expectation of no types, and empty string
                 # as the default response value
-                return Key(key, '', object, self.DEFAULT_FLAGS, self._make_cache_key(key))
+                return Key(key, '', object, DEFAULT_FLAGS, self._make_cache_key(key))
             raise UnknownOption(key)
 
     def get(self, key):
@@ -133,14 +135,14 @@ class OptionsManager(object):
         # values change. This case is unlikely, but good to cover our bases.
         opt = self.lookup_key(key)
 
-        if not (opt.flags & self.FLAG_NOSTORE):
+        if not (opt.flags & FLAG_NOSTORE):
             result = self.fetch_from_store(opt)
             if result is not None:
                 return result
 
         # Some values we don't want to allow them to be configured through
         # config files and should only exist in the datastore
-        if opt.flags & self.FLAG_STOREONLY:
+        if opt.flags & FLAG_STOREONLY:
             return opt.default
 
         try:
@@ -187,9 +189,9 @@ class OptionsManager(object):
         opt = self.lookup_key(key)
 
         # If an option isn't able to exist in the store, we can't set it at runtime
-        assert not (opt.flags & self.FLAG_NOSTORE), '%r cannot be changed at runtime' % key
+        assert not (opt.flags & FLAG_NOSTORE), '%r cannot be changed at runtime' % key
         # Enforce immutability on key
-        assert not (opt.flags & self.FLAG_IMMUTABLE), '%r cannot be changed at runtime' % key
+        assert not (opt.flags & FLAG_IMMUTABLE), '%r cannot be changed at runtime' % key
 
         Option.objects.filter(key=key).delete()
 
@@ -203,8 +205,14 @@ class OptionsManager(object):
     def update_cached_value(self, cache_key, value):
         self.cache.set(cache_key, value, self.ttl)
 
-    def register(self, key, default='', type=basestring, flags=DEFAULT_FLAGS):
+    def register(self, key, default='', type=None, flags=DEFAULT_FLAGS):
         assert key not in self.registry, 'Option already registered: %r' % key
+        # Guess type based on the default value
+        if type is None:
+            if isinstance(default, basestring):
+                type = basestring
+            else:
+                type = _type(default)
         # We disallow None as a value for options since this is ambiguous and doesn't
         # really make sense as config options. There should be a sensible default
         # value instead that matches the type expected, rather than relying on None.
@@ -220,3 +228,13 @@ class OptionsManager(object):
         except KeyError:
             # Raise here or nah?
             raise UnknownOption(key)
+
+    def validate(self, options):
+        for k, v in options.iteritems():
+            self.validate_option(k, v)
+
+    def validate_option(self, key, value):
+        opt = self.lookup_key(key)
+        assert not (opt.flags & FLAG_STOREONLY), '%r is not allowed to be loaded from config' % key
+        if not isinstance(value, opt.type):
+            raise TypeError('%r: got %r, expected %r' % (key, _type(value), opt.type))
diff --git a/src/sentry/runner/initializer.py b/src/sentry/runner/initializer.py
index c642293c4c..4543d8bfed 100644
--- a/src/sentry/runner/initializer.py
+++ b/src/sentry/runner/initializer.py
@@ -161,10 +161,8 @@ def validate_backends():
 
 
 def validate_options(settings):
-    options = settings.SENTRY_OPTIONS
-    for k, v in options.iteritems():
-        # TODO(mattrobenolt): Validate settings.SENTRY_OPTIONS.
-        pass
+    from sentry.options import default_manager
+    default_manager.validate(settings.SENTRY_OPTIONS)
 
 
 def fix_south(settings):
diff --git a/tests/sentry/options/test_manager.py b/tests/sentry/options/test_manager.py
index 77a8f46d13..b422458b06 100644
--- a/tests/sentry/options/test_manager.py
+++ b/tests/sentry/options/test_manager.py
@@ -6,7 +6,9 @@ from exam import fixture, around
 from mock import patch
 
 from sentry.models import Option
-from sentry.options.manager import OptionsManager, UnknownOption
+from sentry.options.manager import (
+    OptionsManager, UnknownOption,
+    FLAG_IMMUTABLE, FLAG_NOSTORE, FLAG_STOREONLY)
 from sentry.testutils import TestCase
 
 
@@ -86,14 +88,14 @@ class OptionsManagerTest(TestCase):
         assert self.manager.get('awesome') == 'lol'
 
     def test_flag_immutable(self):
-        self.manager.register('immutable', flags=OptionsManager.FLAG_IMMUTABLE)
+        self.manager.register('immutable', flags=FLAG_IMMUTABLE)
         with self.assertRaises(AssertionError):
             self.manager.set('immutable', 'thing')
         with self.assertRaises(AssertionError):
             self.manager.delete('immutable')
 
     def test_flag_nostore(self):
-        self.manager.register('nostore', flags=OptionsManager.FLAG_NOSTORE)
+        self.manager.register('nostore', flags=FLAG_NOSTORE)
         with self.assertRaises(AssertionError):
             self.manager.set('nostore', 'thing')
 
@@ -108,8 +110,22 @@ class OptionsManagerTest(TestCase):
         with self.assertRaises(AssertionError):
             self.manager.delete('nostore')
 
+    def test_validate(self):
+        with self.assertRaises(UnknownOption):
+            self.manager.validate({'unknown': ''})
+
+        self.manager.register('unknown')
+        self.manager.register('storeonly', flags=FLAG_STOREONLY)
+        self.manager.validate({'unknown': ''})
+
+        with self.assertRaises(AssertionError):
+            self.manager.validate({'storeonly': ''})
+
+        with self.assertRaises(TypeError):
+            self.manager.validate({'unknown': True})
+
     def test_flag_storeonly(self):
-        self.manager.register('storeonly', flags=OptionsManager.FLAG_STOREONLY)
+        self.manager.register('storeonly', flags=FLAG_STOREONLY)
         assert self.manager.get('storeonly') == ''
 
         with self.settings(SENTRY_OPTIONS={'storeonly': 'something-else!'}):

commit 1049a1010769823c2fbc45f5fe36586b4eb23483
Author: Mark Story <mark@sentry.io>
Date:   Tue Mar 3 11:00:06 2020 -0500

    feat(discover) Revise column picker modal (#17393)
    
    After playing with the previous picker inputs we found some awkward UX
    flows. This update simplifies building columns as fields, functions and
    tags are all in the first input. Once a function has been selected
    additional inputs are enabled to choose the function's column. In
    a future update additional parameter will be added for functions that
    require it.
    
    This also greatly expands the front-end's understanding of our functions
    and should get close to the server side definitions that Evan is working
    on.

diff --git a/docs-ui/components/columnEditor.stories.js b/docs-ui/components/columnEditor.stories.js
index 5c255ec04e..a74df56fb7 100644
--- a/docs-ui/components/columnEditor.stories.js
+++ b/docs-ui/components/columnEditor.stories.js
@@ -30,6 +30,14 @@ storiesOf('Discover|ColumnEditor', module).add(
         field: 'id',
         aggregation: 'count',
       },
+      {
+        field: 'title',
+        aggregation: 'count_unique',
+      },
+      {
+        field: '',
+        aggregation: 'p95',
+      },
     ];
 
     const showModal = () => {
diff --git a/src/sentry/static/sentry/app/views/eventsV2/eventQueryParams.tsx b/src/sentry/static/sentry/app/views/eventsV2/eventQueryParams.tsx
index 4b355e9d1c..81c013cf00 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/eventQueryParams.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/eventQueryParams.tsx
@@ -1,58 +1,126 @@
 import {assert} from 'app/types/utils';
 
-export type ColumnValueType =
-  | '*' // Matches to everything
+export type ColumnType =
+  | '*' // Matches to everything TODO(mark) remove this in favour of explicit type lists.
   | 'string'
   | 'integer'
   | 'number'
   | 'duration'
   | 'timestamp'
-  | 'boolean'
-  | 'never'; // Matches to nothing
+  | 'boolean';
+
+export type ColumnValueType = ColumnType | 'never'; // Matches to nothing
+
+export type AggregateParameter = {
+  kind: 'column' | 'value';
+  columnTypes: Readonly<ColumnType[]>;
+  required: boolean;
+};
 
 // Refer to src/sentry/api/event_search.py
 export const AGGREGATIONS = {
   count: {
-    type: '*',
+    parameters: [],
+    outputType: 'number',
+    type: ['*'],
     isSortable: true,
   },
   count_unique: {
-    type: '*',
+    parameters: [
+      {
+        kind: 'column',
+        columnTypes: ['string', 'integer', 'number', 'duration', 'timestamp', 'boolean'],
+        required: true,
+      },
+    ],
+    outputType: 'number',
+    type: ['*'],
     isSortable: true,
   },
-  /*
-  rpm: {
-    type: 'numeric',
-    isSortable: true,
-  },
-  pXX: {
-    type: 'numeric',
-    isSortable: true,
-  },
-  */
   min: {
+    parameters: [
+      {
+        kind: 'column',
+        columnTypes: ['integer', 'number', 'duration', 'timestamp'],
+        required: true,
+      },
+    ],
+    outputType: null,
     type: ['timestamp', 'duration'],
     isSortable: true,
   },
   max: {
+    parameters: [
+      {
+        kind: 'column',
+        columnTypes: ['integer', 'number', 'duration', 'timestamp'],
+        required: true,
+      },
+    ],
+    outputType: null,
     type: ['timestamp', 'duration'],
     isSortable: true,
   },
   avg: {
+    parameters: [
+      {
+        kind: 'column',
+        columnTypes: ['integer', 'number', 'duration'],
+        required: true,
+      },
+    ],
+    outputType: null,
     type: ['duration'],
     isSortable: true,
   },
   sum: {
+    parameters: [
+      {
+        kind: 'column',
+        columnTypes: ['integer', 'number', 'duration'],
+        required: true,
+      },
+    ],
+    outputType: null,
     type: ['duration'],
     isSortable: true,
   },
+  /* TODO(mark) swap these in with the new column builder
+  last_seen: {
+    parameters: [],
+    outputType: 'timestamp',
+    type: [],
+    isSortable: true,
+  },
+  p75: {
+    parameters: [],
+    outputType: 'duration',
+    type: [],
+    isSortable: true,
+  },
+  p95: {
+    parameters: [],
+    outputType: 'duration',
+    type: [],
+    isSortable: true,
+  },
+  p99: {
+    parameters: [],
+    outputType: 'duration',
+    type: [],
+    isSortable: true,
+  },
+  */
 } as const;
 
 assert(
   AGGREGATIONS as Readonly<
     {
       [key in keyof typeof AGGREGATIONS]: {
-        type: '*' | Readonly<ColumnValueType[]>;
+        parameters: Readonly<AggregateParameter[]>;
+        // null means to inherit from the column.
+        outputType: null | ColumnType;
+        type: Readonly<ColumnType[]>;
         isSortable: boolean;
       };
     }
@@ -135,18 +203,11 @@ export const FIELDS = {
   project: 'string',
   issue: 'string',
 
-  // duration aliases and fake functions.
-  // Once we've expanded the functions support these
-  // need to be revisited
+  // TODO(mark) Remove these with the new column builder.
+  last_seen: 'timestamp',
   p75: 'duration',
   p95: 'duration',
   p99: 'duration',
-
-  // TODO when these become real functions, we need to revisit how
-  // their types are inferred in decodeColumnOrder()
-  apdex: 'number',
-  impact: 'number',
-  error_rate: 'number',
 } as const;
 assert(FIELDS as Readonly<{[key in keyof typeof FIELDS]: ColumnValueType}>);
 
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditCollection.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditCollection.tsx
index ac4e04aefe..1732b47bf1 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditCollection.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditCollection.tsx
@@ -9,12 +9,13 @@ import {
 } from 'app/components/events/interfaces/spans/utils';
 import {IconAdd, IconGrabbable, IconClose} from 'app/icons';
 import {t} from 'app/locale';
-import {OrganizationSummary} from 'app/types';
+import {SelectValue, OrganizationSummary} from 'app/types';
 import space from 'app/styles/space';
 import theme from 'app/utils/theme';
 
+import {AGGREGATIONS, FIELDS, TRACING_FIELDS} from '../eventQueryParams';
 import {Column} from '../eventView';
-import ColumnEditRow from './columnEditRow';
+import {ColumnEditRow, FieldValue, FieldValueKind} from './columnEditRow';
 
 type Props = {
   // Input columns
@@ -31,6 +32,8 @@ type State = {
   draggingTargetIndex: undefined | number;
   left: undefined | number;
   top: undefined | number;
+  // Stored as a object so we can find elements later.
+  fieldOptions: {[key: string]: SelectValue<FieldValue>};
 };
 
 const DRAG_CLASS = 'draggable-item';
@@ -43,6 +46,7 @@ class ColumnEditCollection extends React.Component<Props, State> {
     draggingTargetIndex: void 0,
     left: void 0,
     top: void 0,
+    fieldOptions: {},
   };
 
   componentDidMount() {
@@ -58,6 +62,13 @@ class ColumnEditCollection extends React.Component<Props, State> {
 
       document.body.appendChild(this.portal);
     }
+    this.syncFields();
+  }
+
+  componentDidUpdate(prevProps: Props) {
+    if (this.props.tagKeys !== prevProps.tagKeys) {
+      this.syncFields();
+    }
   }
 
   componentWillUnmount() {
@@ -71,6 +82,62 @@ class ColumnEditCollection extends React.Component<Props, State> {
   portal: HTMLElement | null = null;
   dragGhostRef = React.createRef<HTMLDivElement>();
 
+  syncFields() {
+    const {organization, tagKeys} = this.props;
+
+    let fields = Object.keys(FIELDS);
+    let functions = Object.keys(AGGREGATIONS);
+
+    // Strip tracing features if the org doesn't have access.
+    if (!organization.features.includes('transaction-events')) {
+      fields = fields.filter(item => !TRACING_FIELDS.includes(item));
+      functions = functions.filter(item => !TRACING_FIELDS.includes(item));
+    }
+    const fieldOptions: {[key: string]: SelectValue<FieldValue>} = {};
+
+    // Index items by prefixed keys as custom tags
+    // can overlap both fields and function names.
+    // Having a mapping makes finding the value objects easier
+    // later as well.
+    functions.forEach(func => {
+      fieldOptions[`function:${func}`] = {
+        label: `${func}(...)`,
+        value: {
+          kind: FieldValueKind.FUNCTION,
+          meta: {
+            name: func,
+            parameters: AGGREGATIONS[func].parameters,
+          },
+        },
+      };
+    });
+
+    fields.forEach(field => {
+      fieldOptions[`field:${field}`] = {
+        label: field,
+        value: {
+          kind: FieldValueKind.FIELD,
+          meta: {
+            name: field,
+            dataType: FIELDS[field],
+          },
+        },
+      };
+    });
+
+    tagKeys.forEach(tag => {
+      fieldOptions[`tag:${tag}`] = {
+        label: tag,
+        value: {
+          kind: FieldValueKind.TAG,
+          meta: {name: tag, dataType: 'string'},
+        },
+      };
+    });
+
+    this.setState({fieldOptions});
+  }
+
   cleanUpListeners() {
     if (this.state.isDragging) {
       window.removeEventListener('mousemove', this.onDragMove);
@@ -202,16 +269,15 @@ class ColumnEditCollection extends React.Component<Props, State> {
     };
     const ghost = (
       <Ghost ref={this.dragGhostRef} style={style}>
-        {this.renderItem(col, index, true)}
+        {this.renderItem(col, index, true, true)}
       </Ghost>
     );
 
     return ReactDOM.createPortal(ghost, this.portal);
   }
 
-  renderItem(col: Column, i: number, isGhost = false) {
-    const {organization, tagKeys} = this.props;
-    const {isDragging, draggingTargetIndex} = this.state;
+  renderItem(col: Column, i: number, canDelete: boolean, isGhost: boolean = false) {
+    const {isDragging, draggingTargetIndex, fieldOptions} = this.state;
 
     // Replace the dragged row with a placeholder.
     if (isDragging && isGhost === false && draggingTargetIndex === i) {
@@ -220,39 +286,50 @@ class ColumnEditCollection extends React.Component<Props, State> {
 
     return (
       <RowContainer key={`container-${i}`}>
-        <IconButton
-          aria-label={t('Drag to reorder columns')}
-          onMouseDown={event => this.startDrag(event, i)}
-        >
-          <IconGrabbable size="sm" />
-        </IconButton>
+        {canDelete ? (
+          <IconButton
+            aria-label={t('Drag to reorder columns')}
+            onMouseDown={event => this.startDrag(event, i)}
+          >
+            <IconGrabbable size="sm" />
+          </IconButton>
+        ) : (
+          <span />
+        )}
         <ColumnEditRow
           className={DRAG_CLASS}
-          organization={organization}
+          fieldOptions={fieldOptions}
           column={col}
           parentIndex={i}
-          tagKeys={tagKeys}
           onChange={this.handleUpdateColumn}
         />
-        <IconButton aria-label={t('Remove column')} onClick={() => this.removeColumn(i)}>
-          <IconClose size="sm" />
-        </IconButton>
+        {canDelete ? (
+          <IconButton
+            aria-label={t('Remove column')}
+            onClick={() => this.removeColumn(i)}
+          >
+            <IconClose size="sm" />
+          </IconButton>
+        ) : (
+          <span />
+        )}
       </RowContainer>
     );
   }
 
   render() {
     const {columns} = this.props;
+    const canDelete = columns.length > 1;
     return (
       <div>
         {this.renderGhost()}
         <RowContainer>
           <Heading>
-            <strong>{t('Column')}</strong>
-            <strong>{t('Function')}</strong>
+            <strong>{t('Tag / Field / Function')}</strong>
+            <strong>{t('Field Parameter')}</strong>
           </Heading>
         </RowContainer>
-        {columns.map((col: Column, i: number) => this.renderItem(col, i))}
+        {columns.map((col: Column, i: number) => this.renderItem(col, i, canDelete))}
         <RowContainer>
           <Actions>
             <Button size="xsmall" onClick={this.handleAddColumn}>
@@ -282,7 +359,7 @@ const Ghost = styled('div')`
   padding: 4px;
   border: 4px solid ${p => p.theme.borderLight};
   border-radius: 4px;
-  width: 400px;
+  width: 450px;
   opacity: 0.8;
   cursor: grabbing;
 
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditRow.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditRow.tsx
index a74b7e859e..81405515bd 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditRow.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditRow.tsx
@@ -1,66 +1,101 @@
 import React from 'react';
 import styled from '@emotion/styled';
+import {components} from 'react-select';
 
+import Badge from 'app/components/badge';
 import SelectControl from 'app/components/forms/selectControl';
-import {OrganizationSummary, SelectValue} from 'app/types';
+import {SelectValue} from 'app/types';
+import {t} from 'app/locale';
 import space from 'app/styles/space';
 
-import {
-  AGGREGATIONS,
-  FIELDS,
-  TRACING_FIELDS,
-  Field,
-  Aggregation,
-} from '../eventQueryParams';
+import {ColumnType, AggregateParameter} from '../eventQueryParams';
 import {Column} from '../eventView';
-import {AGGREGATE_ALIASES} from '../data';
+
+export enum FieldValueKind {
+  TAG = 'tag',
+  FIELD = 'field',
+  FUNCTION = 'function',
+}
+
+// Payload of select options used to update column
+// data as the first picker has tags, fields and functions all combined.
+export type FieldValue =
+  | {
+      kind: FieldValueKind.TAG;
+      meta: {
+        name: string;
+        dataType: ColumnType;
+      };
+    }
+  | {
+      kind: FieldValueKind.FIELD;
+      meta: {
+        name: string;
+        dataType: ColumnType;
+      };
+    }
+  | {
+      kind: FieldValueKind.FUNCTION;
+      meta: {
+        name: string;
+        parameters: AggregateParameter[];
+      };
+    };
 
 type Props = {
   className?: string;
-  organization: OrganizationSummary;
   parentIndex: number;
   column: Column;
-  tagKeys: string[];
+  fieldOptions: {[key: string]: SelectValue<FieldValue>};
   onChange: (index: number, column: Column) => void;
 };
 
-type State = {
-  fields: SelectValue<string>[];
-  aggregations: string[];
-};
-
-class ColumnEditRow extends React.Component<Props, State> {
-  state = {
-    fields: generateOptions(Object.keys(FIELDS).concat(this.props.tagKeys)),
-    aggregations: filterAggregations(this.props.organization, this.props.column.field),
-  };
-
-  componentDidUpdate(prevProps: Props) {
-    if (prevProps.tagKeys !== this.props.tagKeys) {
-      this.syncFields();
-    }
-  }
+const NO_OPTIONS: SelectValue<string>[] = [{label: t('N/A'), value: ''}];
 
+class ColumnEditRow extends React.Component<Props> {
   handleFieldChange = ({value}) => {
-    this.setState((state: State, props: Props) => {
-      const newAggregates = filterAggregations(props.organization, value);
-      const newState = {...state, aggregations: newAggregates};
-      let aggregation = props.column.aggregation;
-
-      // If the new field makes the aggregation invalid, we should clear that state.
-      if (aggregation && !newAggregates.includes(aggregation as Aggregation)) {
+    const {column} = this.props;
+    let field = column.field,
+      aggregation = column.aggregation;
+
+    switch (value.kind) {
+      case FieldValueKind.TAG:
+      case FieldValueKind.FIELD:
+        field = value.meta.name;
         aggregation = '';
+        break;
+      case FieldValueKind.FUNCTION:
+        aggregation = value.meta.name;
+        break;
+      default:
+        throw new Error('Invald field type found in column picker');
+    }
+
+    const currentField = this.getFieldOrTagValue(field);
+    if (aggregation && currentField !== null) {
+      const parameterSpec: AggregateParameter = value.meta.parameters[0];
+
+      if (parameterSpec === undefined) {
+        // New function has no parameter, clear the field
+        field = '';
+      } else if (
+        (currentField.kind === FieldValueKind.FIELD ||
+          currentField.kind === FieldValueKind.TAG) &&
+        parameterSpec.columnTypes.includes(currentField.meta.dataType)
+      ) {
+        // New function accepts current field.
+        field = currentField.meta.name;
+      } else {
+        // field does not fit within new function requirements.
+        field = '';
       }
-      this.triggerChange(value, aggregation as string);
+    }
 
-      return newState;
-    });
+    this.triggerChange(field, aggregation);
   };
 
-  handleFunctionChange = ({value}) => {
-    // TODO(mark) When we add improved tracing function support also clear
-    // the function parameter as necessary.
-    this.triggerChange(this.props.column.field, value);
+  handleFieldParameterChange = ({value}) => {
+    this.triggerChange(value.meta.name, this.props.column.aggregation);
   };
 
   triggerChange(field: string, aggregation: string) {
@@ -71,79 +106,81 @@ class ColumnEditRow extends React.Component<Props, State> {
     });
   }
 
-  syncFields() {
-    this.setState({
-      fields: generateOptions(Object.keys(FIELDS).concat(this.props.tagKeys)),
-    });
+  getFieldOrTagValue(name: string): FieldValue | null {
+    const {fieldOptions} = this.props;
+    return (fieldOptions[`field:${name}`] || fieldOptions[`tag:${name}`] || {value: null})
+      .value;
+  }
+
+  getFieldParameterData() {
+    let field: FieldValue | null = null,
+      fieldParameter: FieldValue | null = null,
+      fieldParameterOptions: SelectValue<FieldValue>[] = [];
+
+    const {column, fieldOptions} = this.props;
+    const funcName = `function:${column.aggregation}`;
+
+    if (column.aggregation && fieldOptions[funcName] !== undefined) {
+      field = fieldOptions[funcName].value;
+      fieldParameter = this.getFieldOrTagValue(column.field);
+    } else {
+      field = this.getFieldOrTagValue(column.field);
+    }
+
+    if (
+      field &&
+      field.kind === FieldValueKind.FUNCTION &&
+      field.meta.parameters.length > 0
+    ) {
+      const parameters = field.meta.parameters;
+      fieldParameterOptions = Object.values(fieldOptions).filter(
+        item =>
+          item.value.kind === FieldValueKind.FIELD &&
+          parameters[0].columnTypes.includes(item.value.meta.dataType)
+      );
+    }
+
+    return {field, fieldParameter, fieldParameterOptions};
   }
 
   render() {
-    const {fields, aggregations} = this.state;
-    const {column, className} = this.props;
+    // TODO add additional parameter for tracing functions
+    const {className, fieldOptions} = this.props;
+    const {field, fieldParameter, fieldParameterOptions} = this.getFieldParameterData();
 
     return (
       <Container className={className}>
         <SelectControl
-          options={fields}
-          value={column.field}
+          options={Object.values(fieldOptions)}
+          components={{
+            Option: ({label, value, ...props}) => (
+              <components.Option {...props}>
+                <Label>
+                  {label}
+                  {value.kind === FieldValueKind.TAG && <Badge text="tag" />}
+                </Label>
+              </components.Option>
+            ),
+          }}
+          placeholder={t('Select (Required)')}
+          value={field}
           onChange={this.handleFieldChange}
         />
-        <SelectControl
-          options={generateOptions(aggregations)}
-          value={column.aggregation}
-          onChange={this.handleFunctionChange}
-        />
+        {fieldParameterOptions.length === 0 ? (
+          <SelectControl options={NO_OPTIONS} value="" isDisabled />
+        ) : (
+          <SelectControl
+            placeholder={t('Select (Required)')}
+            options={fieldParameterOptions}
+            value={fieldParameter}
+            onChange={this.handleFieldParameterChange}
+          />
+        )}
       </Container>
     );
   }
 }
 
-function generateOptions(values: string[]): SelectValue<string>[] {
-  return values.map(item => ({label: item, value: item}));
-}
-
-function filterAggregations(organization: OrganizationSummary, f?: Field): Aggregation[] {
-  let functionList = Object.keys(AGGREGATIONS);
-  if (!organization.features.includes('transaction-events')) {
-    functionList = functionList.filter(item => !TRACING_FIELDS.includes(item));
-  }
-
-  // sort list in ascending order
-  functionList.sort();
-
-  if (!f) {
-    return functionList as Aggregation[];
-  }
-  // Unknown fields are likely tag keys and thus strings.
-  const fieldType = FIELDS[f] || 'string';
-
-  if (fieldType === 'never') {
-    return [];
-  }
-
-  // Aggregate aliases cannot be aggregated again.
-  if (AGGREGATE_ALIASES.includes(f)) {
-    return [];
-  }
-
-  functionList = functionList.reduce((accumulator, a) => {
-    if (
-      AGGREGATIONS[a].type.includes(fieldType) ||
-      AGGREGATIONS[a].type === '*' ||
-      fieldType === '*'
-    ) {
-      accumulator.push(a as Aggregation);
-    }
-
-    return accumulator;
-  }, [] as Aggregation[]);
-
-  // sort list in ascending order
-  functionList.sort();
-
-  return functionList as Aggregation[];
-}
-
 const Container = styled('div')`
   display: grid;
   grid-template-columns: repeat(2, 1fr);
@@ -153,4 +190,11 @@ const Container = styled('div')`
   flex-grow: 1;
 `;
 
-export default ColumnEditRow;
+const Label = styled('span')`
+  display: flex;
+  justify-content: space-between;
+  align-items: center;
+  width: 100%;
+`;
+
+export {ColumnEditRow};
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/tableModalEditColumn.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/tableModalEditColumn.tsx
index 316589ca32..06394855bb 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/tableModalEditColumn.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/tableModalEditColumn.tsx
@@ -17,6 +17,7 @@ import {
   TRACING_FIELDS,
   Aggregation,
   Field,
+  ColumnType,
 } from '../eventQueryParams';
 import {TableColumn} from './types';
 
@@ -258,15 +259,14 @@ function filterFieldByAggregation(
   fieldList = fieldList.reduce((accumulator, f) => {
     // tag keys are all strings, and values not in FIELDS is a tag.
     const fieldType = FIELDS[f] || 'string';
-    if (fieldType === 'never') {
+    if (fieldType === 'never' || typeof AGGREGATIONS[a] === 'undefined') {
       return accumulator;
     }
 
-    if (
-      AGGREGATIONS[a].type.includes(fieldType) ||
-      AGGREGATIONS[a].type === '*' ||
-      fieldType === '*'
-    ) {
+    const aggregate = AGGREGATIONS[a];
+    // Acts as a cast to get around the `as const` type narrowing.
+    const aggregateType: ColumnType[] = [...aggregate.type];
+    if (aggregateType.includes('*') || aggregateType.includes(fieldType as ColumnType)) {
       accumulator.push(f as Field);
     }
 
diff --git a/src/sentry/static/sentry/app/views/eventsV2/utils.tsx b/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
index 7acb01147c..dc5c837176 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
@@ -221,13 +221,11 @@ export function decodeColumnOrder(
     }
     column.key = col.aggregationField;
 
-    // Aggregations on any field make numbers.
+    // Aggregations can have a strict outputType or they can inherit from their field.
     // Otherwise use the FIELDS data to infer types.
-    if (
-      AGGREGATIONS[column.aggregation] &&
-      AGGREGATIONS[column.aggregation].type === '*'
-    ) {
-      column.type = 'number';
+    const aggregate = AGGREGATIONS[column.aggregation];
+    if (aggregate && aggregate.outputType) {
+      column.type = aggregate.outputType;
     } else if (FIELDS[column.aggregation]) {
       column.type = FIELDS[column.aggregation];
     } else {

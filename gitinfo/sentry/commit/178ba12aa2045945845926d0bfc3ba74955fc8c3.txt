commit 178ba12aa2045945845926d0bfc3ba74955fc8c3
Author: Armin Ronacher <armin.ronacher@active-4.com>
Date:   Wed May 3 14:30:13 2017 +0200

    Kill and refactor more symbolication code

diff --git a/src/sentry/lang/native/plugin.py b/src/sentry/lang/native/plugin.py
index 35534d38b7..fe3835e4f6 100644
--- a/src/sentry/lang/native/plugin.py
+++ b/src/sentry/lang/native/plugin.py
@@ -3,7 +3,6 @@ from __future__ import absolute_import
 import logging
 import posixpath
 
-from symsynd.demangle import demangle_symbol
 from symsynd.heuristics import find_best_instruction
 from symsynd.utils import parse_addr
 from symsynd.images import ImageLookup
@@ -20,7 +19,6 @@ from sentry.lang.native.systemsymbols import lookup_system_symbols
 from sentry.utils import metrics
 from sentry.stacktraces import StacktraceProcessor
 from sentry.reprocessing import report_processing_issue
-from sentry.constants import NATIVE_UNKNOWN_STRING
 
 
 logger = logging.getLogger(__name__)
@@ -193,19 +191,15 @@ class NativeStacktraceProcessor(StacktraceProcessor):
         if processable_frame.cache_value is None:
             # Construct a raw frame that is used by the symbolizer
             # backend.  We only assemble the bare minimum we need here.
-            sym_input_frame = {
-                'object_name': frame.get('package'),
-                'instruction_addr': processable_frame.data['instruction_addr'],
-                'symbol_name': frame.get('function'),
-            }
-            in_app = self.sym.is_in_app(sym_input_frame)
+            instruction_addr = processable_frame.data['instruction_addr']
+            in_app = self.sym.is_in_app(instruction_addr)
             raw_frame['in_app'] = in_app
             img_uuid = processable_frame.data['image_uuid']
             if img_uuid is not None:
                 self.dsyms_referenced.add(img_uuid)
             try:
                 symbolicated_frames = self.sym.symbolize_frame(
-                    sym_input_frame, self.sdk_info,
+                    instruction_addr, self.sdk_info,
                     symbolserver_match=processable_frame.data['symbolserver_match'])
                 if not symbolicated_frames:
                     return None, [raw_frame], []
@@ -258,28 +252,19 @@ class NativeStacktraceProcessor(StacktraceProcessor):
             raw_frame['in_app'] = in_app
 
         for sfrm in symbolicated_frames:
-            symbol = sfrm.get('symbol_name') or \
-                frame.get('function') or NATIVE_UNKNOWN_STRING
-            function = demangle_symbol(symbol, simplified=True)
-
             new_frame = dict(frame)
-            new_frame['function'] = function
-
-            # If we demangled something, store the original in the
-            # symbol portion of the frame
-            if function != symbol:
-                new_frame['symbol'] = symbol
-
-            new_frame['abs_path'] = sfrm.get('filename') or None
-            if new_frame['abs_path']:
-                new_frame['filename'] = posixpath.basename(
-                    new_frame['abs_path'])
-            if sfrm.get('line') is not None:
-                new_frame['lineno'] = sfrm['line']
-            if sfrm.get('column') is not None:
-                new_frame['colno'] = sfrm['column']
-            new_frame['package'] = sfrm['object_name'] \
-                or new_frame.get('package')
+            new_frame['function'] = sfrm['function']
+            if sfrm.get('symbol'):
+                new_frame['symbol'] = sfrm['symbol']
+            new_frame['abs_path'] = sfrm['abs_path']
+            new_frame['filename'] = sfrm.get('filename') or \
+                posixpath.basename(sfrm['abs_path'])
+            if sfrm.get('lineno'):
+                new_frame['lineno'] = sfrm['lineno']
+            if sfrm.get('colno'):
+                new_frame['colno'] = sfrm['colno']
+            if sfrm.get('package'):
+                new_frame['package'] = sfrm['package']
             new_frame['in_app'] = in_app
             new_frames.append(new_frame)
 
diff --git a/src/sentry/lang/native/symbolizer.py b/src/sentry/lang/native/symbolizer.py
index 01df1f4c49..d27431137d 100644
--- a/src/sentry/lang/native/symbolizer.py
+++ b/src/sentry/lang/native/symbolizer.py
@@ -3,6 +3,7 @@ from __future__ import absolute_import
 import re
 import six
 
+from symsynd.demangle import demangle_symbol
 from symsynd.driver import Driver, SymbolicationError
 from symsynd.macho.arch import get_cpu_name
 from symsynd.images import ImageLookup
@@ -92,13 +93,6 @@ class SymbolicationFailed(Exception):
         return u''.join(rv)
 
 
-def trim_frame(frame):
-    # This matches what's in stacktrace.py
-    frame['symbol_name'] = trim(frame.get('symbol_name'), MAX_SYM)
-    frame['filename'] = trim(frame.get('filename'), 256)
-    return frame
-
-
 class Symbolizer(object):
     """This symbolizer dispatches to both symsynd and the system symbols
     we have in the database and reports errors slightly differently.
@@ -126,83 +120,72 @@ class Symbolizer(object):
         self.driver.close()
 
     def _process_frame(self, frame, img):
-        rv = trim_frame(frame)
-
-        if img is not None:
-            # Only set the object name if we "upgrade" it from a filename to
-            # full path.
-            if rv.get('object_name') is None or \
-               ('/' not in rv['object_name'] and '/' in img['name']):
-                rv['object_name'] = img['name']
-            rv['uuid'] = img['uuid']
-
-        return rv
-
-    def _get_frame_package(self, frame, img):
-        obj_name = frame.get('object_name')
-        if obj_name and '/' in obj_name:
-            return obj_name
-        return img['name']
-
-    def is_frame_from_app_bundle(self, frame, img):
-        fn = self._get_frame_package(frame, img)
+        symbol = trim(frame['function'], MAX_SYM)
+        function = trim(demangle_symbol(frame['function'], simplified=True),
+                        MAX_SYM)
+
+        frame['function'] = function
+        if function != symbol:
+            frame['symbol'] = symbol
+
+        frame['filename'] = trim(frame.get('filename'), 256)
+        frame['abs_path'] = trim(frame.get('abs_path'), 256)
+
+        return frame
+
+    def is_image_from_app_bundle(self, img):
+        fn = img['name']
         if not (fn.startswith(APP_BUNDLE_PATHS) or
                 (SIM_PATH in fn and SIM_APP_PATH in fn)):
             return False
         return True
 
-    def _is_support_framework(self, frame, img):
+    def _is_support_framework(self, img):
         """True if the frame is from a framework that is known and app
         bundled.  Those are frameworks which are specifically not frameworks
         that are ever in_app.
         """
-        fn = self._get_frame_package(frame, img)
-        return _support_framework.search(fn) is not None
+        return _support_framework.search(img['name']) is not None
 
-    def _is_app_bundled_framework(self, frame, img):
-        fn = self._get_frame_package(frame, img)
+    def _is_app_bundled_framework(self, img):
+        fn = img['name']
         return fn.startswith(APP_BUNDLE_PATHS) and '/Frameworks/' in fn
 
-    def _is_app_frame(self, frame, img):
+    def _is_app_frame(self, instruction_addr, img):
         """Given a frame derives the value of `in_app` by discarding the
         original value of the frame.
         """
-        if not self.is_frame_from_app_bundle(frame, img):
+        if not self.is_image_from_app_bundle(img):
             return False
-        return not self._is_app_bundled_framework(frame, img)
+        return not self._is_app_bundled_framework(img)
 
-    def _is_optional_dsym(self, frame, img):
+    def _is_optional_dsym(self, img):
         """Checks if this is a dsym that is optional."""
         # Frames that are not in the app are not considered optional.  In
         # theory we should never reach this anyways.
-        if not self.is_frame_from_app_bundle(frame, img):
+        if not self.is_image_from_app_bundle(img):
             return False
 
         # If we're dealing with an app bundled framework that is also
         # considered optional.
-        if self._is_app_bundled_framework(frame, img):
+        if self._is_app_bundled_framework(img):
             return True
 
         # Frameworks that are known to sentry and bundled helpers are always
         # optional for now.  In theory this should always be False here
         # because we should catch it with the last branch already.
-        if self._is_support_framework(frame, img):
+        if self._is_support_framework(img):
             return True
 
         return False
 
     def _is_simulator_frame(self, frame, img):
-        fn = self._get_frame_package(frame, img)
-        return _sim_platform_re.search(fn) is not None
-
-    def is_in_app(self, frame):
-        img = self.image_lookup.find_image(frame['instruction_addr'])
-        return img is not None and self._is_app_frame(frame, img)
+        return _sim_platform_re.search(img['name']) is not None
 
-    def symbolize_app_frame(self, frame, img):
+    def _symbolize_app_frame(self, instruction_addr, img):
         dsym_path = self.dsym_paths.get(img['uuid'])
         if dsym_path is None:
-            if self._is_optional_dsym(frame, img):
+            if self._is_optional_dsym(img):
                 type = EventError.NATIVE_MISSING_OPTIONALLY_BUNDLED_DSYM
             else:
                 type = EventError.NATIVE_MISSING_DSYM
@@ -211,7 +194,7 @@ class Symbolizer(object):
         try:
             rv = self.driver.symbolize(
                 dsym_path, img['image_vmaddr'], img['image_addr'],
-                img['instruction_addr'], self.cpu_name, symbolize_inlined=True)
+                instruction_addr, self.cpu_name, symbolize_inlined=True)
         except SymbolicationError as e:
             raise SymbolicationFailed(
                 type=EventError.NATIVE_BAD_DSYM,
@@ -226,23 +209,18 @@ class Symbolizer(object):
             )
         return [self._process_frame(nf, img) for nf in reversed(rv)]
 
-    def symbolize_system_frame(self, frame, img, sdk_info,
-                               symbolserver_match=None):
+    def _convert_symbolserver_match(self, symbolserver_match, img):
         """Symbolizes a frame with system symbols only."""
-        if symbolserver_match is not None:
-            rv = self._process_frame(dict(frame,
-                symbol_name=symbolserver_match['symbol'], filename=None,
-                line=0, column=0,
-                object_name=symbolserver_match['object_name']), img)
+        if symbolserver_match is None:
+            return []
 
-        return [rv]
+        return [self._process_frame(dict(
+            function=symbolserver_match['symbol'],
+            filename=None, abs_path=None, lineno=0, colno=0,
+            package=symbolserver_match['package']), img)]
 
-    def symbolize_symbolserver_match(self, frame, img, match):
-        return [self._process_frame(dict(frame,
-            symbol_name=match['symbol'], filename=None, line=0, column=0,
-            object_name=match['object_name']), img)]
-
-    def symbolize_frame(self, frame, sdk_info=None, symbolserver_match=None):
+    def symbolize_frame(self, instruction_addr, sdk_info=None,
+                        symbolserver_match=None):
         # If we do not have a CPU name we fail.  We currently only support
         # a single cpu architecture.
         if self.cpu_name is None:
@@ -251,7 +229,7 @@ class Symbolizer(object):
                 message='Found multiple architectures.'
             )
 
-        img = self.image_lookup.find_image(frame['instruction_addr'])
+        img = self.image_lookup.find_image(instruction_addr)
         if img is None:
             raise SymbolicationFailed(
                 type=EventError.NATIVE_UNKNOWN_IMAGE
@@ -260,8 +238,11 @@ class Symbolizer(object):
         # If we are dealing with a frame that is not bundled with the app
         # we look at system symbols.  If that fails, we go to looking for
         # app symbols explicitly.
-        if not self.is_frame_from_app_bundle(frame, img):
-            return self.symbolize_system_frame(frame, img, sdk_info,
-                                               symbolserver_match)
+        if not self.is_image_from_app_bundle(img):
+            return self._convert_symbolserver_match(symbolserver_match, img)
+
+        return self._symbolize_app_frame(instruction_addr, img)
 
-        return self.symbolize_app_frame(frame, img)
+    def is_in_app(self, instruction_addr):
+        img = self.image_lookup.find_image(instruction_addr)
+        return img is not None and self._is_app_frame(instruction_addr, img)

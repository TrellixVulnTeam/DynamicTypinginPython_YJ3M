commit 8087d6fe5588a6f75536c41b11fe2f582ea0a398
Author: Alberto Leal <mail4alberto@gmail.com>
Date:   Tue Mar 3 13:48:11 2020 -0500

    feat(discover2): Add count_unique drilldown (#16889)
    
    Add drill down links to count_unique() values. The generated view
    includes the unique values and their counts allowing further drilldowns
    if necessary. The `getExpandedResults` function was getting huge and
    has been decomposed a bit.
    
    Co-authored-by: Mark Story <mark@mark-story.com>

diff --git a/src/sentry/static/sentry/app/types/index.tsx b/src/sentry/static/sentry/app/types/index.tsx
index dbac620b17..21e92888f9 100644
--- a/src/sentry/static/sentry/app/types/index.tsx
+++ b/src/sentry/static/sentry/app/types/index.tsx
@@ -869,6 +869,10 @@ export type SelectValue<T> = {
   value: T;
 };
 
+export type StringMap<T> = {
+  [key: string]: T;
+};
+
 /**
  * The issue config form fields we get are basically the form fields we use in
  * the UI but with some extra information. Some fields marked optional in the
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
index 62914b6bba..e8082d3dc2 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
@@ -478,6 +478,7 @@ const ExpandAggregateRow = (props: {
   const exploded = explodeField(eventViewField);
   const {aggregation} = exploded;
 
+  // count(column) drilldown
   if (aggregation === 'count') {
     const nextView = getExpandedResults(eventView, {}, dataRow);
 
@@ -489,6 +490,22 @@ const ExpandAggregateRow = (props: {
     return <Link to={target}>{children({willExpand: true})}</Link>;
   }
 
+  // count_unique(column) drilldown
+  if (aggregation === 'count_unique') {
+    // Drilldown into each distinct value and get a count() for each value.
+    const nextView = getExpandedResults(eventView, {}, dataRow).withNewColumn({
+      field: '',
+      aggregation: 'count',
+    });
+
+    const target = {
+      pathname: location.pathname,
+      query: nextView.generateQueryStringObject(),
+    };
+
+    return <Link to={target}>{children({willExpand: true})}</Link>;
+  }
+
   return <React.Fragment>{children({willExpand: false})}</React.Fragment>;
 };
 
diff --git a/src/sentry/static/sentry/app/views/eventsV2/utils.tsx b/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
index dc5c837176..3e08a765d9 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
@@ -7,7 +7,7 @@ import {browserHistory} from 'react-router';
 
 import {tokenizeSearch, stringifyQueryObject} from 'app/utils/tokenizeSearch';
 import {t} from 'app/locale';
-import {Event, Organization, OrganizationSummary} from 'app/types';
+import {Event, StringMap, Organization, OrganizationSummary} from 'app/types';
 import {Client} from 'app/api';
 import {getTitle} from 'app/utils/events';
 import {getUtcDateString} from 'app/utils/dates';
@@ -351,55 +351,27 @@ const TRANSFORM_AGGREGATES: {[field: string]: AggregateTransformer} = {
   impact: () => undefined,
 };
 
+/**
+ * Convert an aggregated query into one that does not have aggregates.
+ * Can also apply additions conditions defined in `additionalConditions`
+ * and generate conditions based on the `dataRow` parameter and the current fields
+ * in the `eventView`.
+ */
 export function getExpandedResults(
   eventView: EventView,
-  additionalConditions: {[key: string]: string},
+  additionalConditions: StringMap<string>,
   dataRow?: TableDataRow | Event
 ): EventView {
-  let nextView = eventView.clone();
+  // Find aggregate fields and flag them for updates.
   const fieldsToUpdate: number[] = [];
-  const specialKeys = Object.values(URL_PARAM);
-
-  nextView.fields.forEach((field: FieldType, index: number) => {
+  eventView.fields.forEach((field: FieldType, index: number) => {
     const column = explodeField(field);
-
-    // Mark aggregated fields to be transformed into its un-aggregated form
     if (column.aggregation || AGGREGATE_ALIASES.includes(column.field)) {
       fieldsToUpdate.push(index);
-      return;
-    }
-
-    const dataKey = getAggregateAlias(field.field);
-    // Append the current field as a condition if it exists in the dataRow
-    // Or is a simple key in the event. More complex deeply nested fields are
-    // more challenging to get at as their location in the structure does not
-    // match their name.
-    if (dataRow) {
-      if (dataRow[dataKey]) {
-        const nextValue = String(dataRow[dataKey]).trim();
-
-        switch (column.field) {
-          case 'timestamp':
-            // normalize the "timestamp" field to ensure the payload works
-            additionalConditions[column.field] = getUtcDateString(nextValue);
-            break;
-          default:
-            additionalConditions[column.field] = nextValue;
-        }
-      }
-      // If we have an event, check tags as well.
-      if (dataRow && dataRow.tags && dataRow.tags instanceof Array) {
-        const tagIndex = dataRow.tags.findIndex(item => item.key === dataKey);
-        if (tagIndex > -1) {
-          const key = specialKeys.includes(column.field)
-            ? `tags[${column.field}]`
-            : column.field;
-          additionalConditions[key] = dataRow.tags[tagIndex].value;
-        }
-      }
     }
   });
 
+  let nextView = eventView.clone();
   const transformedFields = new Set();
   const fieldsToDelete: number[] = [];
 
@@ -466,7 +438,72 @@ export function getExpandedResults(
     nextView = nextView.withDeletedColumn(index, undefined);
   });
 
-  const parsedQuery = tokenizeSearch(nextView.query);
+  nextView.query = generateExpandedConditions(nextView, additionalConditions, dataRow);
+
+  return nextView;
+}
+
+/**
+ * Create additional conditions based on the fields in an EventView
+ * and a datarow/event
+ */
+function generateAdditionalConditions(
+  eventView: EventView,
+  dataRow?: TableDataRow | Event
+): StringMap<string> {
+  const specialKeys = Object.values(URL_PARAM);
+  const conditions: StringMap<string> = {};
+
+  if (!dataRow) {
+    return conditions;
+  }
+
+  eventView.fields.forEach((field: FieldType) => {
+    const column = explodeField(field);
+
+    // Skip aggregate fields
+    if (column.aggregation || AGGREGATE_ALIASES.includes(column.field)) {
+      return;
+    }
+
+    const dataKey = getAggregateAlias(field.field);
+    // Append the current field as a condition if it exists in the dataRow
+    // Or is a simple key in the event. More complex deeply nested fields are
+    // more challenging to get at as their location in the structure does not
+    // match their name.
+    if (dataRow[dataKey]) {
+      const nextValue = String(dataRow[dataKey]).trim();
+
+      switch (column.field) {
+        case 'timestamp':
+          // normalize the "timestamp" field to ensure the payload works
+          conditions[column.field] = getUtcDateString(nextValue);
+          break;
+        default:
+          conditions[column.field] = nextValue;
+      }
+    }
+
+    // If we have an event, check tags as well.
+    if (dataRow.tags && dataRow.tags instanceof Array) {
+      const tagIndex = dataRow.tags.findIndex(item => item.key === dataKey);
+      if (tagIndex > -1) {
+        const key = specialKeys.includes(column.field)
+          ? `tags[${column.field}]`
+          : column.field;
+        conditions[key] = dataRow.tags[tagIndex].value;
+      }
+    }
+  });
+  return conditions;
+}
+
+function generateExpandedConditions(
+  eventView: EventView,
+  additionalConditions: StringMap<string>,
+  dataRow?: TableDataRow | Event
+): string {
+  const parsedQuery = tokenizeSearch(eventView.query);
 
   // Remove any aggregates from the search conditions.
   // otherwise, it'll lead to an invalid query result.
@@ -477,14 +514,20 @@ export function getExpandedResults(
     }
   }
 
+  const conditions = Object.assign(
+    {},
+    additionalConditions,
+    generateAdditionalConditions(eventView, dataRow)
+  );
+
   // Add additional conditions provided and generated.
-  for (const key in additionalConditions) {
+  for (const key in conditions) {
     if (key === 'project.id') {
-      nextView.project = [...nextView.project, parseInt(additionalConditions[key], 10)];
+      eventView.project = [...eventView.project, parseInt(additionalConditions[key], 10)];
       continue;
     }
     if (key === 'environment') {
-      nextView.environment = [...nextView.environment, additionalConditions[key]];
+      eventView.environment = [...eventView.environment, additionalConditions[key]];
       continue;
     }
     const column = explodeFieldString(key);
@@ -496,11 +539,10 @@ export function getExpandedResults(
     if (key === 'project' || key === 'project.name') {
       continue;
     }
-    parsedQuery[key] = [additionalConditions[key]];
+    parsedQuery[key] = [conditions[key]];
   }
-  nextView.query = stringifyQueryObject(parsedQuery);
 
-  return nextView;
+  return stringifyQueryObject(parsedQuery);
 }
 
 export function getDiscoverLandingUrl(organization: OrganizationSummary): string {

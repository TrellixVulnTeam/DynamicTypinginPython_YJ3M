commit a11058dd8b0732c7fccf59513a0e499a3b9dfe91
Author: Ted Kaemming <ted@kaemming.com>
Date:   Wed Sep 30 17:49:50 2015 -0700

    Several miscellaneous lock recipe improvements.
    
    - Add `acquire` and `release` methods.
    - Allow checking the remaining duration of a lock, and whether or not
      it is held.
    - Don't sleep after the last failed acquisition attempt of a lock.
    - Prevent releasing a lock that may have been acquired by another
      process after it was timed out by the process attempting to release
      it.

diff --git a/src/sentry/utils/cache.py b/src/sentry/utils/cache.py
index c3f8a49996..58bf8063ba 100644
--- a/src/sentry/utils/cache.py
+++ b/src/sentry/utils/cache.py
@@ -39,37 +39,87 @@ class Lock(object):
         self.lock_key = lock_key
         self.nowait = nowait
 
-    def __enter__(self):
-        lock_key = self.lock_key
-        cache = self.cache
+        self.__acquired_at = None
+
+    def __repr__(self):
+        return '<Lock: %r>' % (self.lock_key,)
+
+    def acquire(self):
+        """
+        Attempt to acquire the lock, returning a boolean that represents if the
+        lock is held.
+        """
+        # NOTE: This isn't API compatible with the standard Python
+        # ``Lock.acquire`` method signature. It may make sense to make these
+        # compatible in the future, but that would also require changes to the
+        # the constructor: https://docs.python.org/2/library/threading.html#lock-objects
+
+        # XXX: This can lead to unexpected behavior, since the timeout is not
+        # correct -- maybe this should be an exception?
+        time_remaining = self.seconds_remaining
+        if time_remaining:
+            logger.warning('Tried to acquire lock that is already held, %.3fs remaining: %r', time_remaining, self)
+            return True
+
+        started_at = time()
+        self.__acquired_at = None
 
-        start = time()
         delay = 0.01 + random.random() / 10
-        attempt = 0
-        max_attempts = self.timeout / delay
-        got_lock = None
-        self.was_locked = False
-        while not got_lock and attempt < max_attempts:
-            got_lock = cache.add(lock_key, '', self.timeout)
-            if not got_lock:
-                if self.nowait:
-                    break
-                self.was_locked = True
+        for i in xrange(int(self.timeout // delay)):
+            if i != 0:
                 sleep(delay)
-                attempt += 1
-        stop = time()
 
-        if not got_lock:
-            raise UnableToGetLock('Unable to fetch lock after %.3fs on %s' % (
-                stop - start, lock_key,))
+            attempt_started_at = time()
+            if self.cache.add(self.lock_key, '', self.timeout):
+                self.__acquired_at = attempt_started_at
+                break
 
-        return self
+            if self.nowait:
+                break
+
+        return self.__acquired_at is not None
+
+    def release(self):
+        """
+        Release the lock.
+        """
+        # If we went over the lock duration (timeout), we need to exit to avoid
+        # accidentally releasing a lock that was acquired by another process.
+        if not self.held:
+            logger.warning('Tried to release unheld lock: %r', self)
+            return False
 
-    def __exit__(self, exc_type, exc_value, traceback):
         try:
             self.cache.delete(self.lock_key)
         except Exception as e:
             logger.exception(e)
+        finally:
+            self.__acquired_at = None
+
+        return True
+
+    @property
+    def seconds_remaining(self):
+        if self.__acquired_at is None:
+            return 0
+
+        lifespan = time() - self.__acquired_at
+        return max(self.timeout - lifespan, 0)
+
+    @property
+    def held(self):
+        return bool(self.seconds_remaining)
+
+    def __enter__(self):
+        start = time()
+
+        if not self.acquire():
+            raise UnableToGetLock('Unable to fetch lock after %.3fs: %r' % (time() - start, self,))
+
+        return self
+
+    def __exit__(self, exc_type, exc_value, traceback):
+        self.release()
 
 
 class memoize(object):
diff --git a/tests/sentry/utils/test_cache.py b/tests/sentry/utils/test_cache.py
new file mode 100644
index 0000000000..a5c07e4b87
--- /dev/null
+++ b/tests/sentry/utils/test_cache.py
@@ -0,0 +1,53 @@
+from __future__ import absolute_import
+
+import functools
+
+import pytest
+
+from sentry.testutils import TestCase
+from sentry.utils.cache import (
+    Lock,
+    UnableToGetLock,
+)
+
+
+class LockTestCase(TestCase):
+    def test_basic(self):
+        timeout = 10
+        lock = Lock('basic', timeout=timeout)
+
+        assert lock.held is False
+        assert lock.seconds_remaining is 0
+
+        assert lock.acquire() is True
+        assert timeout > lock.seconds_remaining > (timeout - 0.1)
+        assert lock.held is True
+
+        assert lock.acquire() is True  # ensure reentrancy
+
+        assert lock.release() is True
+        assert lock.seconds_remaining is 0
+        assert lock.held is False
+        assert lock.release() is False
+
+    def test_context(self):
+        timeout = 10
+        lock = Lock('ctx', timeout=timeout)
+
+        with lock as result:
+            assert lock is result
+            assert lock.held is True
+
+        assert lock.held is False
+
+    def test_concurrent(self):
+        make_lock = functools.partial(Lock, 'concurrent')
+        first = make_lock()
+        second = make_lock(nowait=True)
+
+        assert first.acquire() is True
+        assert second.acquire() is False
+
+        with pytest.raises(UnableToGetLock):
+            with second:
+                pass

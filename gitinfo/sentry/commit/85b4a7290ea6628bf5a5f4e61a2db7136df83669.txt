commit 85b4a7290ea6628bf5a5f4e61a2db7136df83669
Author: Jess MacQueen <macqueen@users.noreply.github.com>
Date:   Mon Jan 7 11:25:23 2019 -0800

    feat(api): Add organization issues list endpoint (#11133)

diff --git a/src/sentry/api/endpoints/group_events.py b/src/sentry/api/endpoints/group_events.py
index 77bc60f66c..a087c7892e 100644
--- a/src/sentry/api/endpoints/group_events.py
+++ b/src/sentry/api/endpoints/group_events.py
@@ -62,7 +62,7 @@ class GroupEventsEndpoint(GroupEndpoint, EnvironmentMixin):
 
         if raw_query:
             try:
-                query_kwargs = parse_query(group.project, raw_query, request.user)
+                query_kwargs = parse_query([group.project], raw_query, request.user)
             except InvalidQuery as exc:
                 return Response({'detail': six.text_type(exc)}, status=400)
             else:
diff --git a/src/sentry/api/endpoints/organization_group_index.py b/src/sentry/api/endpoints/organization_group_index.py
new file mode 100644
index 0000000000..95109623db
--- /dev/null
+++ b/src/sentry/api/endpoints/organization_group_index.py
@@ -0,0 +1,148 @@
+from __future__ import absolute_import, division, print_function
+
+import functools
+import six
+
+from django.conf import settings
+
+from rest_framework.response import Response
+
+from sentry.api.bases import OrganizationEventsEndpointBase
+from sentry.api.helpers.group_search import build_query_params_from_request, get_by_short_id, ValidationError
+from sentry.api.serializers import serialize
+from sentry.api.serializers.models.group import StreamGroupSerializerSnuba
+from sentry.models import Environment, Group, GroupStatus, Project
+from sentry.search.snuba.backend import SnubaSearchBackend
+
+
+ERR_INVALID_STATS_PERIOD = "Invalid stats_period. Valid choices are '', '24h', and '14d'"
+
+
+search = SnubaSearchBackend(**settings.SENTRY_SEARCH_OPTIONS)
+
+
+class OrganizationGroupIndexEndpoint(OrganizationEventsEndpointBase):
+
+    def _build_query_params_from_request(self, request, organization, project_ids):
+        projects = list(
+            Project.objects.filter(
+                id__in=project_ids,
+                organization=organization,
+            )
+        )
+        return build_query_params_from_request(request, projects)
+
+    def _search(self, request, organization, project_ids, environments, extra_query_kwargs=None):
+        query_kwargs = self._build_query_params_from_request(request, organization, project_ids)
+        if extra_query_kwargs is not None:
+            assert 'environment' not in extra_query_kwargs
+            query_kwargs.update(extra_query_kwargs)
+
+        query_kwargs['environments'] = environments if environments else None
+        result = search.query(**query_kwargs)
+        return result, query_kwargs
+
+    def get(self, request, organization):
+        """
+        List an Organization's Issues
+        `````````````````````````````
+
+        Return a list of issues (groups) bound to an organization.  All parameters are
+        supplied as query string parameters.
+
+        A default query of ``is:unresolved`` is applied. To return results
+        with other statuses send an new query value (i.e. ``?query=`` for all
+        results).
+
+        The ``statsPeriod`` parameter can be used to select the timeline
+        stats which should be present. Possible values are: '' (disable),
+        '24h', '14d'
+
+        :qparam string statsPeriod: an optional stat period (can be one of
+                                    ``"24h"``, ``"14d"``, and ``""``).
+        :qparam bool shortIdLookup: if this is set to true then short IDs are
+                                    looked up by this function as well.  This
+                                    can cause the return value of the function
+                                    to return an event issue of a different
+                                    project which is why this is an opt-in.
+                                    Set to `1` to enable.
+        :qparam querystring query: an optional Sentry structured search
+                                   query.  If not provided an implied
+                                   ``"is:unresolved"`` is assumed.)
+        :pparam string organization_slug: the slug of the organization the
+                                          issues belong to.
+        :auth: required
+        """
+        stats_period = request.GET.get('statsPeriod')
+        if stats_period not in (None, '', '24h', '14d'):
+            return Response({"detail": ERR_INVALID_STATS_PERIOD}, status=400)
+        elif stats_period is None:
+            # default
+            stats_period = '24h'
+        elif stats_period == '':
+            # disable stats
+            stats_period = None
+
+        environments = list(Environment.objects.filter(
+            organization_id=organization.id,
+            name__in=self.get_environments(request, organization),
+        ))
+
+        serializer = functools.partial(
+            StreamGroupSerializerSnuba,
+            environment_ids=[env.id for env in environments],
+            stats_period=stats_period,
+        )
+
+        project_ids = self.get_project_ids(request, organization)
+
+        if not project_ids:
+            return Response([])
+
+        query = request.GET.get('query', '').strip()
+        if query:
+            # check to see if we've got an event ID
+            if len(query) == 32:
+                groups = list(
+                    Group.objects.filter_by_event_id(
+                        project_ids,
+                        query,
+                    )
+                )
+
+                if groups:
+                    return Response(serialize(groups, request.user, serializer()))
+
+            group = get_by_short_id(organization.id, request.GET.get('shortIdLookup'), query)
+            if group is not None:
+                # check to make sure user has access to project
+                if group.project_id in project_ids:
+                    response = Response(
+                        serialize(
+                            [group], request.user, serializer()
+                        )
+                    )
+                    response['X-Sentry-Direct-Hit'] = '1'
+                    return response
+
+        try:
+            cursor_result, query_kwargs = self._search(
+                request, organization, project_ids, environments, {'count_hits': True})
+        except ValidationError as exc:
+            return Response({'detail': six.text_type(exc)}, status=400)
+
+        results = list(cursor_result)
+
+        context = serialize(results, request.user, serializer())
+
+        # HACK: remove auto resolved entries
+        if query_kwargs.get('status') == GroupStatus.UNRESOLVED:
+            context = [r for r in context if r['status'] == 'unresolved']
+
+        response = Response(context)
+
+        self.add_cursor_headers(request, response, cursor_result)
+
+        # TODO(jess): add metrics that are similar to project endpoint here
+
+        return response
diff --git a/src/sentry/api/endpoints/project_group_index.py b/src/sentry/api/endpoints/project_group_index.py
index 771195bce0..96b5edb1d3 100644
--- a/src/sentry/api/endpoints/project_group_index.py
+++ b/src/sentry/api/endpoints/project_group_index.py
@@ -15,11 +15,11 @@ from sentry import analytics, eventstream, features, search
 from sentry.api.base import DocSection, EnvironmentMixin
 from sentry.api.bases.project import ProjectEndpoint, ProjectEventPermission
 from sentry.api.fields import ActorField, Actor
+from sentry.api.helpers.group_search import build_query_params_from_request, get_by_short_id, ValidationError
 from sentry.api.serializers import serialize
 from sentry.api.serializers.models.actor import ActorSerializer
 from sentry.api.serializers.models.group import (
     SUBSCRIPTION_REASON_MAP, StreamGroupSerializer)
-from sentry.constants import DEFAULT_SORT_OPTION
 from sentry.db.models.query import create_or_update
 from sentry.models import (
     Activity, Commit, Environment, Group, GroupAssignee, GroupBookmark, GroupLink, GroupHash, GroupResolution,
@@ -27,16 +27,14 @@ from sentry.models import (
     GroupTombstone, Release, Repository, TOMBSTONE_FIELDS_FROM_GROUP, UserOption, User, Team
 )
 from sentry.models.event import Event
-from sentry.models.group import looks_like_short_id
 from sentry.receivers import DEFAULT_SAVED_SEARCHES
-from sentry.search.utils import InvalidQuery, parse_query
 from sentry.signals import advanced_search, issue_ignored, issue_resolved_in_release, issue_deleted, resolved_with_commit
 from sentry.tasks.deletion import delete_groups
 from sentry.tasks.integrations import kick_off_status_syncs
 from sentry.tasks.merge import merge_groups
 from sentry.utils import metrics
 from sentry.utils.apidocs import attach_scenarios, scenario
-from sentry.utils.cursors import Cursor, CursorResult
+from sentry.utils.cursors import CursorResult
 from sentry.utils.functional import extract_lazy_object
 
 delete_logger = logging.getLogger('sentry.deletions.api')
@@ -90,10 +88,6 @@ STATUS_CHOICES = {
 }
 
 
-class ValidationError(Exception):
-    pass
-
-
 class InCommitValidator(serializers.Serializer):
     commit = serializers.CharField(required=True)
     repository = serializers.CharField(required=True)
@@ -242,34 +236,7 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint, EnvironmentMixin):
     permission_classes = (ProjectEventPermission, )
 
     def _build_query_params_from_request(self, request, project):
-        query_kwargs = {
-            'projects': [project],
-            'sort_by': request.GET.get('sort', DEFAULT_SORT_OPTION),
-        }
-
-        limit = request.GET.get('limit')
-        if limit:
-            try:
-                query_kwargs['limit'] = int(limit)
-            except ValueError:
-                raise ValidationError('invalid limit')
-
-        # TODO: proper pagination support
-        cursor = request.GET.get('cursor')
-        if cursor:
-            query_kwargs['cursor'] = Cursor.from_string(cursor)
-
-        query = request.GET.get('query', 'is:unresolved').strip()
-        if query:
-            try:
-                query_kwargs.update(parse_query(project, query, request.user))
-            except InvalidQuery as e:
-                raise ValidationError(
-                    u'Your search query could not be parsed: {}'.format(
-                        e.message)
-                )
-
-        return query_kwargs
+        return build_query_params_from_request(request, [project])
 
     def _search(self, request, project, extra_query_kwargs=None):
         query_kwargs = self._build_query_params_from_request(request, project)
@@ -373,18 +340,14 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint, EnvironmentMixin):
                         pass
                     else:
                         Event.objects.bind_nodes([matching_event], 'data')
-
-            elif request.GET.get('shortIdLookup') == '1' and \
-                    looks_like_short_id(query):
-                try:
-                    matching_group = Group.objects.by_qualified_short_id(
-                        project.organization_id, query
-                    )
-                except Group.DoesNotExist:
+            elif matching_group is None:
+                matching_group = get_by_short_id(
+                    project.organization_id,
+                    request.GET.get('shortIdLookup'),
+                    query,
+                )
+                if matching_group is not None and matching_group.project_id != project.id:
                     matching_group = None
-                else:
-                    if matching_group.project_id != project.id:
-                        matching_group = None
 
             if matching_group is not None:
                 matching_event_environment = None
diff --git a/src/sentry/api/helpers/group_search.py b/src/sentry/api/helpers/group_search.py
new file mode 100644
index 0000000000..3fdbeda7c5
--- /dev/null
+++ b/src/sentry/api/helpers/group_search.py
@@ -0,0 +1,53 @@
+from __future__ import absolute_import
+
+from sentry.constants import DEFAULT_SORT_OPTION
+from sentry.models import Group
+from sentry.models.group import looks_like_short_id
+from sentry.search.utils import InvalidQuery, parse_query
+from sentry.utils.cursors import Cursor
+
+
+class ValidationError(Exception):
+    pass
+
+
+def build_query_params_from_request(request, projects):
+    query_kwargs = {
+        'projects': projects,
+        'sort_by': request.GET.get('sort', DEFAULT_SORT_OPTION),
+    }
+
+    limit = request.GET.get('limit')
+    if limit:
+        try:
+            query_kwargs['limit'] = int(limit)
+        except ValueError:
+            raise ValidationError('invalid limit')
+
+    # TODO: proper pagination support
+    cursor = request.GET.get('cursor')
+    if cursor:
+        query_kwargs['cursor'] = Cursor.from_string(cursor)
+
+    query = request.GET.get('query', 'is:unresolved').strip()
+    if query:
+        try:
+            query_kwargs.update(parse_query(projects, query, request.user))
+        except InvalidQuery as e:
+            raise ValidationError(
+                u'Your search query could not be parsed: {}'.format(
+                    e.message)
+            )
+
+    return query_kwargs
+
+
+def get_by_short_id(organization_id, is_short_id_lookup, query):
+    if is_short_id_lookup == '1' and \
+            looks_like_short_id(query):
+        try:
+            return Group.objects.by_qualified_short_id(
+                organization_id, query
+            )
+        except Group.DoesNotExist:
+            pass
diff --git a/src/sentry/api/urls.py b/src/sentry/api/urls.py
index 1ea991c4fa..19ee49305e 100644
--- a/src/sentry/api/urls.py
+++ b/src/sentry/api/urls.py
@@ -62,6 +62,7 @@ from .endpoints.organization_discover_query import OrganizationDiscoverQueryEndp
 from .endpoints.organization_discover_saved_queries import OrganizationDiscoverSavedQueriesEndpoint
 from .endpoints.organization_discover_saved_query_detail import OrganizationDiscoverSavedQueryDetailEndpoint
 from .endpoints.organization_events import OrganizationEventsEndpoint, OrganizationEventsMetaEndpoint, OrganizationEventsStatsEndpoint
+from .endpoints.organization_group_index import OrganizationGroupIndexEndpoint
 from .endpoints.organization_health import OrganizationHealthTopEndpoint, OrganizationHealthGraphEndpoint
 from .endpoints.organization_shortid import ShortIdLookupEndpoint
 from .endpoints.organization_environments import OrganizationEnvironmentsEndpoint
@@ -512,6 +513,11 @@ urlpatterns = patterns(
         r'^organizations/(?P<organization_slug>[^\/]+)/issues/new/$',
         OrganizationIssuesNewEndpoint.as_view(),
     ),
+    url(
+        r'^organizations/(?P<organization_slug>[^\/]+)/issues/$',
+        OrganizationGroupIndexEndpoint.as_view(),
+        name='sentry-api-0-organization-group-index'
+    ),
     url(
         r'^organizations/(?P<organization_slug>[^\/]+)/integrations/$',
         OrganizationIntegrationsEndpoint.as_view(),
diff --git a/src/sentry/models/group.py b/src/sentry/models/group.py
index ee0737253c..6ce7302b7d 100644
--- a/src/sentry/models/group.py
+++ b/src/sentry/models/group.py
@@ -149,6 +149,22 @@ class GroupManager(BaseManager):
 
         return Group.objects.get(id=group_id)
 
+    def filter_by_event_id(self, project_ids, event_id):
+        from sentry.models import EventMapping, Event
+        group_ids = set()
+        # see above for explanation as to why we're
+        # looking at both Event and EventMapping
+        for model in Event, EventMapping:
+            group_ids.update(
+                model.objects.filter(
+                    project_id__in=project_ids,
+                    event_id=event_id,
+                    group_id__isnull=False,
+                ).values_list('group_id', flat=True)
+            )
+
+        return Group.objects.filter(id__in=group_ids)
+
     def add_tags(self, group, environment, tags):
         project_id = group.project_id
         date = group.last_seen
diff --git a/src/sentry/search/utils.py b/src/sentry/search/utils.py
index 60b0c89cfe..e19f5ec1ea 100644
--- a/src/sentry/search/utils.py
+++ b/src/sentry/search/utils.py
@@ -17,12 +17,12 @@ class InvalidQuery(Exception):
     pass
 
 
-def get_user_tag(project, key, value):
+def get_user_tag(projects, key, value):
     # TODO(dcramer): do something with case of multiple matches
     try:
         lookup = EventUser.attr_from_keyword(key)
         euser = EventUser.objects.filter(
-            project_id=project.id, **{lookup: value})[0]
+            project_id__in=[p.id for p in projects], **{lookup: value})[0]
     except (KeyError, IndexError):
         return u'{}:{}'.format(key, value)
     except DataError:
@@ -184,16 +184,16 @@ def get_date_params(value, from_field, to_field):
     return result
 
 
-def parse_team_value(project, value, user):
+def parse_team_value(projects, value, user):
     return Team.objects.filter(
         slug__iexact=value[1:],
-        projectteam__project=project,
+        projectteam__project__in=projects,
     ).first() or Team(id=0)
 
 
-def parse_actor_value(project, value, user):
+def parse_actor_value(projects, value, user):
     if value.startswith('#'):
-        return parse_team_value(project, value, user)
+        return parse_team_value(projects, value, user)
     return parse_user_value(value, user)
 
 
@@ -353,7 +353,7 @@ def split_query_into_tokens(query):
     return tokens
 
 
-def parse_query(project, query, user):
+def parse_query(projects, query, user):
     # TODO(dcramer): handle query being wrapped in quotes
     tokens = tokenize_query(query)
 
@@ -373,7 +373,7 @@ def parse_query(project, query, user):
                     except KeyError:
                         raise InvalidQuery(u"'is:' had unknown status code '{}'.".format(value))
             elif key == 'assigned':
-                results['assigned_to'] = parse_actor_value(project, value, user)
+                results['assigned_to'] = parse_actor_value(projects, value, user)
             elif key == 'bookmarks':
                 results['bookmarked_by'] = parse_user_value(value, user)
             elif key == 'subscribed':
@@ -389,7 +389,7 @@ def parse_query(project, query, user):
                     comp, value = value.split(':', 1)
                 else:
                     comp = 'id'
-                results['tags']['sentry:user'] = get_user_tag(project, comp, value)
+                results['tags']['sentry:user'] = get_user_tag(projects, comp, value)
             elif key == 'has':
                 if value == 'user':
                     value = 'sentry:user'
@@ -405,7 +405,7 @@ def parse_query(project, query, user):
             elif key == 'activeSince':
                 results.update(get_date_params(value, 'active_at_from', 'active_at_to'))
             elif key.startswith('user.'):
-                results['tags']['sentry:user'] = get_user_tag(project, key.split('.', 1)[1], value)
+                results['tags']['sentry:user'] = get_user_tag(projects, key.split('.', 1)[1], value)
             elif key == 'event.timestamp':
                 results.update(get_date_params(value, 'date_from', 'date_to'))
             elif key == 'timesSeen':
diff --git a/tests/sentry/search/test_utils.py b/tests/sentry/search/test_utils.py
index 615260c6cd..a69fafc591 100644
--- a/tests/sentry/search/test_utils.py
+++ b/tests/sentry/search/test_utils.py
@@ -62,7 +62,7 @@ def test_get_numeric_field_value_invalid():
 
 class ParseQueryTest(TestCase):
     def parse_query(self, query):
-        return parse_query(self.project, query, self.user)
+        return parse_query([self.project], query, self.user)
 
     def test_simple(self):
         result = self.parse_query('foo bar')
diff --git a/tests/snuba/api/endpoints/test_organization_group_index.py b/tests/snuba/api/endpoints/test_organization_group_index.py
new file mode 100644
index 0000000000..228e90ced4
--- /dev/null
+++ b/tests/snuba/api/endpoints/test_organization_group_index.py
@@ -0,0 +1,330 @@
+from __future__ import absolute_import
+
+import json
+import six
+from datetime import timedelta
+from django.core.urlresolvers import reverse
+from django.utils import timezone
+from exam import fixture
+
+from sentry.models import ApiToken, Event, EventMapping, GroupStatus, Release
+from sentry.testutils import APITestCase, SnubaTestCase
+from sentry.testutils.helpers import parse_link_header
+from six.moves.urllib.parse import quote
+
+
+class GroupListTest(APITestCase, SnubaTestCase):
+    def setUp(self):
+        super(GroupListTest, self).setUp()
+        self.min_ago = timezone.now() - timedelta(minutes=1)
+
+    def _parse_links(self, header):
+        # links come in {url: {...attrs}}, but we need {rel: {...attrs}}
+        links = {}
+        for url, attrs in six.iteritems(parse_link_header(header)):
+            links[attrs['rel']] = attrs
+            attrs['href'] = url
+        return links
+
+    @fixture
+    def path(self):
+        return reverse(
+            'sentry-api-0-organization-group-index',
+            args=[self.project.organization.slug]
+        )
+
+    def test_sort_by_date_with_tag(self):
+        # XXX(dcramer): this tests a case where an ambiguous column name existed
+        now = timezone.now()
+        group1 = self.create_group(
+            checksum='a' * 32,
+            last_seen=now - timedelta(seconds=1),
+        )
+        self.login_as(user=self.user)
+
+        response = self.client.get(
+            u'{}?sort_by=date&query=is:unresolved'.format(self.path),
+            format='json',
+        )
+        assert response.status_code == 200
+        assert len(response.data) == 1
+        assert response.data[0]['id'] == six.text_type(group1.id)
+
+    def test_invalid_query(self):
+        now = timezone.now()
+        self.create_group(
+            checksum='a' * 32,
+            last_seen=now - timedelta(seconds=1),
+        )
+        self.login_as(user=self.user)
+
+        response = self.client.get(
+            u'{}?sort_by=date&query=timesSeen:>1k'.format(self.path),
+            format='json',
+        )
+        assert response.status_code == 400
+        assert 'could not' in response.data['detail']
+
+    def test_simple_pagination(self):
+        now = timezone.now().replace(microsecond=0)
+        group1 = self.create_group(
+            project=self.project,
+            last_seen=now - timedelta(seconds=1),
+        )
+        self.create_event(
+            group=group1,
+            datetime=now - timedelta(seconds=1),
+        )
+        group2 = self.create_group(
+            project=self.project,
+            last_seen=now,
+        )
+        self.create_event(
+            stacktrace=[['foo.py']],
+            group=group2,
+            datetime=now,
+        )
+        self.login_as(user=self.user)
+        response = self.client.get(
+            u'{}?sort_by=date&limit=1'.format(self.path),
+            format='json',
+        )
+        assert response.status_code == 200
+        assert len(response.data) == 1
+        assert response.data[0]['id'] == six.text_type(group2.id)
+
+        links = self._parse_links(response['Link'])
+
+        assert links['previous']['results'] == 'false'
+        assert links['next']['results'] == 'true'
+
+        response = self.client.get(links['next']['href'], format='json')
+        assert response.status_code == 200
+        assert len(response.data) == 1
+        assert response.data[0]['id'] == six.text_type(group1.id)
+
+        links = self._parse_links(response['Link'])
+
+        assert links['previous']['results'] == 'true'
+        assert links['next']['results'] == 'false'
+
+    def test_stats_period(self):
+        # TODO(dcramer): this test really only checks if validation happens
+        # on statsPeriod
+        now = timezone.now()
+        self.create_group(
+            checksum='a' * 32,
+            last_seen=now - timedelta(seconds=1),
+        )
+        self.create_group(
+            checksum='b' * 32,
+            last_seen=now,
+        )
+
+        self.login_as(user=self.user)
+
+        response = self.client.get(u'{}?statsPeriod=24h'.format(self.path), format='json')
+        assert response.status_code == 200
+
+        response = self.client.get(u'{}?statsPeriod=14d'.format(self.path), format='json')
+        assert response.status_code == 200
+
+        response = self.client.get(u'{}?statsPeriod='.format(self.path), format='json')
+        assert response.status_code == 200
+
+        response = self.client.get(u'{}?statsPeriod=48h'.format(self.path), format='json')
+        assert response.status_code == 400
+
+    def test_environment(self):
+        self.create_environment(name='production', organization=self.project.organization)
+        self.create_event(tags={'environment': 'production'})
+
+        self.login_as(user=self.user)
+
+        response = self.client.get(self.path + '?environment=production', format='json')
+        assert response.status_code == 200
+
+        response = self.client.get(self.path + '?environment=garbage', format='json')
+        assert response.status_code == 404
+
+    def test_auto_resolved(self):
+        project = self.project
+        project.update_option('sentry:resolve_age', 1)
+        now = timezone.now()
+        self.create_group(
+            checksum='a' * 32,
+            last_seen=now - timedelta(days=1),
+        )
+        group2 = self.create_group(
+            checksum='b' * 32,
+            last_seen=now,
+        )
+
+        self.login_as(user=self.user)
+        response = self.client.get(self.path, format='json')
+        assert response.status_code == 200
+        assert len(response.data) == 1
+        assert response.data[0]['id'] == six.text_type(group2.id)
+
+    def test_lookup_by_event_id(self):
+        project = self.project
+        project.update_option('sentry:resolve_age', 1)
+        group = self.create_group(checksum='a' * 32)
+        self.create_group(checksum='b' * 32)
+        event_id = 'c' * 32
+        Event.objects.create(project_id=self.project.id, event_id=event_id)
+        EventMapping.objects.create(
+            event_id=event_id,
+            project=group.project,
+            group=group,
+        )
+
+        self.login_as(user=self.user)
+
+        response = self.client.get(u'{}?query={}'.format(self.path, 'c' * 32), format='json')
+        assert response.status_code == 200
+        assert len(response.data) == 1
+        assert response.data[0]['id'] == six.text_type(group.id)
+
+    def test_lookup_by_event_id_with_whitespace(self):
+        project = self.project
+        project.update_option('sentry:resolve_age', 1)
+        group = self.create_group(checksum='a' * 32)
+        self.create_group(checksum='b' * 32)
+        EventMapping.objects.create(
+            event_id='c' * 32,
+            project=group.project,
+            group=group,
+        )
+
+        self.login_as(user=self.user)
+        response = self.client.get(
+            u'{}?query=%20%20{}%20%20'.format(self.path, 'c' * 32), format='json'
+        )
+        assert response.status_code == 200
+        assert len(response.data) == 1
+        assert response.data[0]['id'] == six.text_type(group.id)
+
+    def test_lookup_by_unknown_event_id(self):
+        project = self.project
+        project.update_option('sentry:resolve_age', 1)
+        self.create_group(checksum='a' * 32)
+        self.create_group(checksum='b' * 32)
+
+        self.login_as(user=self.user)
+        response = self.client.get(u'{}?query={}'.format(self.path, 'c' * 32), format='json')
+        assert response.status_code == 200
+        assert len(response.data) == 0
+
+    def test_lookup_by_short_id(self):
+        group = self.group
+        short_id = group.qualified_short_id
+
+        self.login_as(user=self.user)
+        response = self.client.get(
+            u'{}?query={}&shortIdLookup=1'.format(
+                self.path, short_id), format='json')
+        assert response.status_code == 200
+        assert len(response.data) == 1
+
+    def test_lookup_by_short_id_no_perms(self):
+        organization = self.create_organization()
+        project = self.create_project(organization=organization)
+        project2 = self.create_project(organization=organization)
+        team = self.create_team(organization=organization)
+        project2.add_team(team)
+        group = self.create_group(project=project)
+        user = self.create_user()
+        self.create_member(organization=organization, user=user, teams=[team])
+
+        short_id = group.qualified_short_id
+
+        self.login_as(user=user)
+
+        path = reverse(
+            'sentry-api-0-organization-group-index',
+            args=[organization.slug]
+        )
+        response = self.client.get(
+            u'{}?query={}&shortIdLookup=1'.format(
+                path, short_id), format='json')
+        assert response.status_code == 200
+        assert len(response.data) == 0
+
+    def test_lookup_by_first_release(self):
+        self.login_as(self.user)
+        project = self.project
+        project2 = self.create_project(name='baz', organization=project.organization)
+        release = Release.objects.create(organization=project.organization, version='12345')
+        release.add_project(project)
+        release.add_project(project2)
+        group = self.create_group(checksum='a' * 32, project=project, first_release=release)
+        group2 = self.create_group(checksum='b' * 32, project=project2, first_release=release)
+        url = '%s?query=%s' % (self.path, quote('first-release:"%s"' % release.version))
+        response = self.client.get(url, format='json')
+        issues = json.loads(response.content)
+        assert response.status_code == 200
+        assert len(issues) == 2
+        assert int(issues[0]['id']) == group2.id
+        assert int(issues[1]['id']) == group.id
+
+    def test_lookup_by_release(self):
+        self.login_as(self.user)
+        project = self.project
+        release = Release.objects.create(organization=project.organization, version='12345')
+        release.add_project(project)
+        self.create_event(
+            group_id=self.group.id,
+            datetime=self.min_ago,
+            tags={'sentry:release': release.version},
+        )
+
+        url = '%s?query=%s' % (self.path, quote('release:"%s"' % release.version))
+        response = self.client.get(url, format='json')
+        issues = json.loads(response.content)
+        assert response.status_code == 200
+        assert len(issues) == 1
+        assert int(issues[0]['id']) == self.group.id
+
+    def test_pending_delete_pending_merge_excluded(self):
+        self.create_group(
+            checksum='a' * 32,
+            status=GroupStatus.PENDING_DELETION,
+        )
+        group = self.create_group(
+            checksum='b' * 32,
+        )
+        self.create_group(
+            checksum='c' * 32,
+            status=GroupStatus.DELETION_IN_PROGRESS,
+        )
+        self.create_group(
+            checksum='d' * 32,
+            status=GroupStatus.PENDING_MERGE,
+        )
+
+        self.login_as(user=self.user)
+
+        response = self.client.get(self.path, format='json')
+        assert len(response.data) == 1
+        assert response.data[0]['id'] == six.text_type(group.id)
+
+    def test_filters_based_on_retention(self):
+        self.login_as(user=self.user)
+
+        self.create_group(last_seen=timezone.now() - timedelta(days=2))
+
+        with self.options({'system.event-retention-days': 1}):
+            response = self.client.get(self.path)
+
+        assert response.status_code == 200, response.content
+        assert len(response.data) == 0
+
+    def test_token_auth(self):
+        token = ApiToken.objects.create(user=self.user, scope_list=['org:read'])
+        response = self.client.get(
+            self.path,
+            format='json',
+            HTTP_AUTHORIZATION='Bearer %s' %
+            token.token)
+        assert response.status_code == 200, response.content

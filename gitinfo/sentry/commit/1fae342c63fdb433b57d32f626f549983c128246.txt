commit 1fae342c63fdb433b57d32f626f549983c128246
Author: David Cramer <dcramer@gmail.com>
Date:   Thu Feb 12 17:40:51 2015 -0800

    Ensure tooltips dont go outside window bounds

diff --git a/src/sentry/static/sentry/app/components/Tooltip.jsx b/src/sentry/static/sentry/app/components/Tooltip.jsx
new file mode 100644
index 0000000000..2a83b388aa
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/Tooltip.jsx
@@ -0,0 +1,56 @@
+var React = require('react');
+var joinClasses = require('react-bootstrap/utils/joinClasses');
+var classSet = require('react-bootstrap/utils/classSet');
+var BootstrapMixin = require('react-bootstrap/BootstrapMixin');
+
+
+var Tooltip = React.createClass({
+  mixins: [BootstrapMixin],
+
+  propTypes: {
+    placement: React.PropTypes.oneOf(['top','right', 'bottom', 'left']),
+    positionLeft: React.PropTypes.number,
+    positionTop: React.PropTypes.number,
+    modifiedLeft: React.PropTypes.number,
+    arrowOffsetLeft: React.PropTypes.number,
+    arrowOffsetTop: React.PropTypes.number
+  },
+
+  getDefaultProps: function () {
+    return {
+      placement: 'right'
+    };
+  },
+
+  render: function () {
+    var classes = {
+      tooltip: true,
+      in: this.props.positionLeft !== null || this.props.positionTop !== null
+    };
+    classes[this.props.placement] = true;
+
+    var style = {
+      left: this.props.positionLeft,
+      top: this.props.positionTop
+    };
+
+    var arrowStyle = {
+      // TODO(dcramer): figure out where this magical # is from and compute it
+      // in a correct way
+      marginLeft: this.props.modifiedLeft - 6,
+      left: this.props.arrowOffsetLeft,
+      top: this.props.arrowOffsetTop
+    };
+
+    return (
+        <div {...this.props} className={joinClasses(this.props.className, classSet(classes))} style={style}>
+          <div className="tooltip-arrow" style={arrowStyle} />
+          <div className="tooltip-inner">
+            {this.props.children}
+          </div>
+        </div>
+      );
+  }
+});
+
+module.exports = Tooltip;
diff --git a/src/sentry/static/sentry/app/components/barChart.jsx b/src/sentry/static/sentry/app/components/barChart.jsx
index 0d35fea74d..707945ddd7 100644
--- a/src/sentry/static/sentry/app/components/barChart.jsx
+++ b/src/sentry/static/sentry/app/components/barChart.jsx
@@ -1,8 +1,8 @@
 /*** @jsx React.DOM */
 var React = require("react");
 
-var OverlayTrigger = require("react-bootstrap/OverlayTrigger");
-var Tooltip = require("react-bootstrap/Tooltip");
+var OverlayTrigger = require("./OverlayTrigger");
+var Tooltip = require("./Tooltip");
 
 var BarChart = React.createClass({
   propTypes: {
@@ -15,18 +15,18 @@ var BarChart = React.createClass({
     placement: React.PropTypes.string
   },
 
-  getDefaultProps: function(){
+  getDefaultProps(){
     return {
       placement: "bottom"
     };
   },
 
-  floatFormat: function(number, places) {
+  floatFormat(number, places) {
       var multi = Math.pow(10, places);
       return parseInt(number * multi, 10) / multi;
   },
 
-  timeLabelAsHour: function(point) {
+  timeLabelAsHour(point) {
     var timeMoment = moment(point.x * 1000);
     var nextMoment = timeMoment.clone().add(59, "minute");
 
@@ -38,7 +38,7 @@ var BarChart = React.createClass({
     );
   },
 
-  timeLabelAsRange: function(interval, point) {
+  timeLabelAsRange(interval, point) {
     var timeMoment = moment(point.x * 1000);
     var nextMoment = timeMoment.clone().add(interval - 1, "second");
 
@@ -50,12 +50,12 @@ var BarChart = React.createClass({
     );
   },
 
-  timeLabelAsFull: function(point) {
+  timeLabelAsFull(point) {
     var timeMoment = moment(point.x * 1000);
     return timeMoment.format("lll");
   },
 
-  render: function(){
+  render(){
     // TODO: maxval could default to # of hours since first_seen / times_seen
     var points = this.props.points;
 
@@ -81,13 +81,12 @@ var BarChart = React.createClass({
         timeLabelFunc = this.timeLabelAsRange.bind(this, interval);
     }
 
-    var children = [];
-    points.forEach(function(point, pointIdx){
+    var children = points.map((point, pointIdx) => {
       var pct = this.floatFormat(point.y / maxval * 99, 2) + "%";
       var timeLabel = timeLabelFunc(point);
 
       var title = (
-        <div>
+        <div style={{minWidth: 200}}>
           {point.y} events<br/>
           {timeLabel}
         </div>
@@ -96,21 +95,22 @@ var BarChart = React.createClass({
         title += <div>({point.label})</div>;
       }
 
-      children.push((
-        <OverlayTrigger overlay={<Tooltip>{title}</Tooltip>}
+      var tooltip = (
+        <Tooltip>
+          {title}
+        </Tooltip>
+      );
+
+      return (
+        <OverlayTrigger overlay={tooltip}
                         placement={this.props.placement}
                         key={point.x}>
           <a style={{width: pointWidth}}>
             <span style={{height: pct}}>{point.y}</span>
           </a>
         </OverlayTrigger>
-      ));
-        // $("<a style="width:" + pointWidth + ";" rel="tooltip" title="" + title + ""><span style="height:" + pct + "">" + point.y + "</span></a>").tooltip({
-        //   placement: options.placement || "bottom",
-        //   html: true,
-        //   container: "body"
-        // }).appendTo($el);
-    }.bind(this));
+      );
+    });
 
     return (
       <figure className={this.props.className}>
diff --git a/src/sentry/static/sentry/app/components/overlayTrigger.jsx b/src/sentry/static/sentry/app/components/overlayTrigger.jsx
new file mode 100644
index 0000000000..6f27bf61cb
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/overlayTrigger.jsx
@@ -0,0 +1,244 @@
+var React = require('react');
+var OverlayMixin = require('react-bootstrap/OverlayMixin');
+var domUtils = require('react-bootstrap/utils/domUtils');
+var cloneWithProps = require('react-bootstrap/utils/cloneWithProps');
+
+var createChainedFunction = require('react-bootstrap/utils/createChainedFunction');
+var assign = require('react-bootstrap/utils/Object.assign');
+
+/**
+ * Check if value one is inside or equal to the of value
+ *
+ * @param {string} one
+ * @param {string|array} of
+ * @returns {boolean}
+ */
+function isOneOf(one, of) {
+  if (Array.isArray(of)) {
+    return of.indexOf(one) >= 0;
+  }
+  return one === of;
+}
+
+var OverlayTrigger = React.createClass({
+  mixins: [OverlayMixin],
+
+  propTypes: {
+    trigger: React.PropTypes.oneOfType([
+      React.PropTypes.oneOf(['manual', 'click', 'hover', 'focus']),
+      React.PropTypes.arrayOf(React.PropTypes.oneOf(['click', 'hover', 'focus']))
+    ]),
+    placement: React.PropTypes.oneOf(['top','right', 'bottom', 'left']),
+    delay: React.PropTypes.number,
+    delayShow: React.PropTypes.number,
+    delayHide: React.PropTypes.number,
+    defaultOverlayShown: React.PropTypes.bool,
+    overlay: React.PropTypes.node.isRequired
+  },
+
+  getDefaultProps: function () {
+    return {
+      placement: 'right',
+      trigger: ['hover', 'focus']
+    };
+  },
+
+  getInitialState: function () {
+    return {
+      isOverlayShown: this.props.defaultOverlayShown === null ?
+        false : this.props.defaultOverlayShown,
+      modifiedLeft: null,
+      overlayLeft: null,
+      overlayTop: null
+    };
+  },
+
+  show: function () {
+    this.setState({
+      isOverlayShown: true
+    }, function() {
+      this.updateOverlayPosition();
+    });
+  },
+
+  hide: function () {
+    this.setState({
+      isOverlayShown: false
+    });
+  },
+
+  toggle: function () {
+    if (this.state.isOverlayShown) {
+      this.hide();
+    } else {
+      this.show();
+    }
+  },
+
+  renderOverlay: function () {
+    if (!this.state.isOverlayShown) {
+      return <span />;
+    }
+
+    return cloneWithProps(
+      this.props.overlay,
+      {
+        onRequestHide: this.hide,
+        placement: this.props.placement,
+        positionLeft: this.state.overlayLeft,
+        positionTop: this.state.overlayTop,
+        modifiedLeft: this.state.modifiedLeft
+      }
+    );
+  },
+
+  render: function () {
+    if (this.props.trigger === 'manual') {
+      return React.Children.only(this.props.children);
+    }
+
+    var props = {};
+
+    if (isOneOf('click', this.props.trigger)) {
+      props.onClick = createChainedFunction(this.toggle, this.props.onClick);
+    }
+
+    if (isOneOf('hover', this.props.trigger)) {
+      props.onMouseOver = createChainedFunction(this.handleDelayedShow, this.props.onMouseOver);
+      props.onMouseOut = createChainedFunction(this.handleDelayedHide, this.props.onMouseOut);
+    }
+
+    if (isOneOf('focus', this.props.trigger)) {
+      props.onFocus = createChainedFunction(this.handleDelayedShow, this.props.onFocus);
+      props.onBlur = createChainedFunction(this.handleDelayedHide, this.props.onBlur);
+    }
+
+    return cloneWithProps(
+      React.Children.only(this.props.children),
+      props
+    );
+  },
+
+  componentWillUnmount: function() {
+    clearTimeout(this._hoverDelay);
+  },
+
+  componentDidMount: function() {
+    this.updateOverlayPosition();
+  },
+
+  handleDelayedShow: function () {
+    if (this._hoverDelay !== null) {
+      clearTimeout(this._hoverDelay);
+      this._hoverDelay = null;
+      return;
+    }
+
+    var delay = this.props.delayShow !== null ?
+      this.props.delayShow : this.props.delay;
+
+    if (!delay) {
+      this.show();
+      return;
+    }
+
+    this._hoverDelay = setTimeout(function() {
+      this._hoverDelay = null;
+      this.show();
+    }.bind(this), delay);
+  },
+
+  handleDelayedHide: function () {
+    if (this._hoverDelay !== null) {
+      clearTimeout(this._hoverDelay);
+      this._hoverDelay = null;
+      return;
+    }
+
+    var delay = this.props.delayHide !== null ?
+      this.props.delayHide : this.props.delay;
+
+    if (!delay) {
+      this.hide();
+      return;
+    }
+
+    this._hoverDelay = setTimeout(function() {
+      this._hoverDelay = null;
+      this.hide();
+    }.bind(this), delay);
+  },
+
+  updateOverlayPosition: function () {
+    if (!this.isMounted()) {
+      return;
+    }
+
+    var pos = this.calcOverlayPosition();
+
+    var overlayNode = this.getOverlayDOMNode();
+    var overlayHeight = overlayNode.offsetHeight;
+    var overlayWidth = overlayNode.offsetWidth;
+
+    // keep the overlay on screen
+    if (pos.left + overlayWidth + 5 > window.innerWidth) {
+      adjustedLeft = window.innerWidth - overlayWidth - 5;
+    } else {
+      adjustedLeft = pos.left;
+    }
+
+    this.setState({
+      overlayLeft: adjustedLeft,
+      overlayTop: pos.top,
+      modifiedLeft: pos.left - adjustedLeft
+    });
+  },
+
+  calcOverlayPosition: function () {
+    var childOffset = this.getPosition();
+
+    var overlayNode = this.getOverlayDOMNode();
+    var overlayHeight = overlayNode.offsetHeight;
+    var overlayWidth = overlayNode.offsetWidth;
+
+    switch (this.props.placement) {
+      case 'right':
+        return {
+          top: childOffset.top + childOffset.height / 2 - overlayHeight / 2,
+          left: childOffset.left + childOffset.width
+        };
+      case 'left':
+        return {
+          top: childOffset.top + childOffset.height / 2 - overlayHeight / 2,
+          left: childOffset.left - overlayWidth
+        };
+      case 'top':
+        return {
+          top: childOffset.top - overlayHeight,
+          left: childOffset.left + childOffset.width / 2 - overlayWidth / 2
+        };
+      case 'bottom':
+        return {
+          top: childOffset.top + childOffset.height,
+          left: childOffset.left + childOffset.width / 2 - overlayWidth / 2
+        };
+      default:
+        throw new Error('calcOverlayPosition(): No such placement of "' + this.props.placement + '" found.');
+    }
+  },
+
+  getPosition: function () {
+    var node = this.getDOMNode();
+    var container = this.getContainerDOMNode();
+
+    var offset = container.tagName == 'BODY' ?
+      domUtils.getOffset(node) : domUtils.getPosition(node, container);
+
+    return assign({}, offset, {
+      height: node.offsetHeight,
+      width: node.offsetWidth
+    });
+  }
+});
+
+module.exports = OverlayTrigger;

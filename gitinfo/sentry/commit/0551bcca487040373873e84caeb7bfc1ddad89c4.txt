commit 0551bcca487040373873e84caeb7bfc1ddad89c4
Author: Dan Fuller <dfuller@sentry.io>
Date:   Tue Mar 19 18:09:25 2019 -0700

    feat(api): Add endpoint to create recent searches (SEN-353)
    
    This adds an endpoint for recording recent searches. Whenever we create a new recent search, we also
    check that we haven't gone over the maximum number of recent searches for that user and remove any
    extra ones. We do this inside of a lock to prevent multiple processes trying to delete the same rows
    and erroring.

diff --git a/src/sentry/api/endpoints/organization_recent_searches.py b/src/sentry/api/endpoints/organization_recent_searches.py
index 4a181897d1..432f7fdf10 100644
--- a/src/sentry/api/endpoints/organization_recent_searches.py
+++ b/src/sentry/api/endpoints/organization_recent_searches.py
@@ -1,15 +1,38 @@
 from __future__ import absolute_import
 
-from django.utils import six
+from django.utils import (
+    six,
+    timezone,
+)
+from rest_framework import serializers
 from rest_framework.response import Response
 
-from sentry.api.bases.organization import OrganizationEndpoint
+from sentry.api.bases.organization import (
+    OrganizationEndpoint,
+    OrganizationPermission,
+)
 from sentry.api.serializers import serialize
-from sentry.models.recentsearch import RecentSearch
+from sentry.models.recentsearch import (
+    RecentSearch,
+    remove_excess_recent_searches,
+)
 from sentry.models.search_common import SearchType
 
 
+class RecentSearchSerializer(serializers.Serializer):
+    type = serializers.IntegerField(required=True)
+    query = serializers.CharField(required=True)
+
+
+class OrganizationRecentSearchPermission(OrganizationPermission):
+    scope_map = {
+        'GET': ['org:read', 'org:write', 'org:admin'],
+        'POST': ['org:read', 'org:write', 'org:admin'],
+    }
+
+
 class OrganizationRecentSearchesEndpoint(OrganizationEndpoint):
+    permission_classes = (OrganizationRecentSearchPermission, )
 
     def get(self, request, organization):
         """
@@ -43,3 +66,23 @@ class OrganizationRecentSearchesEndpoint(OrganizationEndpoint):
         ).order_by('-last_seen')[:limit])
 
         return Response(serialize(recent_searches, request.user))
+
+    def post(self, request, organization):
+        serializer = RecentSearchSerializer(data=request.DATA)
+
+        if serializer.is_valid():
+            result = serializer.object
+
+            created = RecentSearch.objects.create_or_update(
+                organization=organization,
+                user=request.user,
+                type=result['type'],
+                query=result['query'],
+                values={'last_seen': timezone.now()}
+            )[1]
+            if created:
+                remove_excess_recent_searches(organization, request.user, result['type'])
+            status = 201 if created else 204
+
+            return Response('', status=status)
+        return Response(serializer.errors, status=400)
diff --git a/src/sentry/models/recentsearch.py b/src/sentry/models/recentsearch.py
index 1f79d67491..dba7c67fac 100644
--- a/src/sentry/models/recentsearch.py
+++ b/src/sentry/models/recentsearch.py
@@ -6,9 +6,13 @@ from django.dispatch import receiver
 from django.utils import timezone
 
 from sentry.db.models import FlexibleForeignKey, Model, sane_repr
+from sentry.utils.db import is_mysql
 from sentry.utils.hashlib import md5_text
 
 
+MAX_RECENT_SEARCHES = 30
+
+
 class RecentSearch(Model):
     """
     Searches run by users recently.
@@ -31,6 +35,23 @@ class RecentSearch(Model):
     __repr__ = sane_repr('organization_id', 'user_id', 'type', 'query')
 
 
+def remove_excess_recent_searches(organization, user, search_type):
+    """
+    Remove any excess recent searches. We do this by sorting by `last_seen`
+    descending and removing any rows after the `MAX_RECENT_SEARCHES` row. In
+    practice this should only be removing a single row at most.
+    """
+    recent_searches_to_remove = RecentSearch.objects.filter(
+        organization=organization,
+        user=user,
+        type=search_type,
+    ).order_by('-last_seen')[MAX_RECENT_SEARCHES:]
+    if is_mysql():
+        # Mysql doesn't support limits in these types of subqueries
+        recent_searches_to_remove = list(recent_searches_to_remove.values_list("id", flat=True))
+    RecentSearch.objects.filter(id__in=recent_searches_to_remove).delete()
+
+
 @receiver(pre_save, sender=RecentSearch)
 def issue_saved(sender, instance, **kwargs):
     if not instance.query_hash:
diff --git a/tests/sentry/api/endpoints/test_organization_recent_searches.py b/tests/sentry/api/endpoints/test_organization_recent_searches.py
index aefc60f4a2..bb529380ff 100644
--- a/tests/sentry/api/endpoints/test_organization_recent_searches.py
+++ b/tests/sentry/api/endpoints/test_organization_recent_searches.py
@@ -1,9 +1,13 @@
 from __future__ import absolute_import
 
-from datetime import timedelta
+from datetime import (
+    datetime,
+    timedelta,
+)
 
 from django.utils import timezone
 from exam import fixture
+from freezegun import freeze_time
 
 from sentry.api.serializers import serialize
 from sentry.models.recentsearch import RecentSearch
@@ -88,3 +92,45 @@ class RecentSearchesListTest(APITestCase):
             )
             assert response.status_code == 400
             assert response.data['detail'].startswith(expected_error)
+
+
+class RecentSearchesCreateTest(APITestCase):
+    endpoint = 'sentry-api-0-organization-recent-searches'
+    method = 'post'
+
+    @fixture
+    def organization(self):
+        return self.create_organization()
+
+    @fixture
+    def user(self):
+        user = self.create_user('test@test.com')
+        self.create_team(members=[user], organization=self.organization)
+        return user
+
+    def test(self):
+        self.login_as(self.user)
+        search_type = 1
+        query = 'something'
+        the_date = datetime(2019, 1, 1, 1, 1, 1)
+        with freeze_time(the_date):
+            response = self.get_response(self.organization.slug, type=search_type, query=query)
+            assert response.status_code == 201
+            assert RecentSearch.objects.filter(
+                organization=self.organization,
+                user=self.user,
+                type=search_type,
+                query=query,
+                last_seen=the_date,
+            ).exists()
+        the_date = datetime(2019, 1, 1, 2, 2, 2)
+        with freeze_time(the_date):
+            response = self.get_response(self.organization.slug, type=search_type, query=query)
+            assert response.status_code == 204, response.content
+            assert RecentSearch.objects.filter(
+                organization=self.organization,
+                user=self.user,
+                type=search_type,
+                query=query,
+                last_seen=the_date,
+            ).exists()
diff --git a/tests/sentry/models/test_recentsearch.py b/tests/sentry/models/test_recentsearch.py
index 945db507b0..a27021dcc5 100644
--- a/tests/sentry/models/test_recentsearch.py
+++ b/tests/sentry/models/test_recentsearch.py
@@ -1,7 +1,15 @@
 from __future__ import absolute_import
 
+from datetime import timedelta
+
+from django.utils import timezone
+from mock import patch
+
 from sentry.testutils import TestCase
-from sentry.models.recentsearch import RecentSearch
+from sentry.models.recentsearch import (
+    RecentSearch,
+    remove_excess_recent_searches,
+)
 from sentry.utils.hashlib import md5_text
 
 
@@ -15,3 +23,25 @@ class RecentSearchTest(TestCase):
         )
         recent_search = RecentSearch.objects.get(id=recent_search.id)
         assert recent_search.query_hash == md5_text(recent_search.query).hexdigest()
+
+
+class RemoveExcessRecentSearchesTest(TestCase):
+    def test(self):
+        with patch('sentry.models.recentsearch.MAX_RECENT_SEARCHES', new=1):
+            RecentSearch.objects.create(
+                organization=self.organization,
+                user=self.user,
+                type=0,
+                query='hello',
+                last_seen=timezone.now() - timedelta(minutes=10)
+            )
+            remove_excess_recent_searches(self.organization, self.user, 0)
+            assert list(RecentSearch.objects.all().values_list('query', flat=True)) == ['hello']
+            RecentSearch.objects.create(
+                organization=self.organization,
+                user=self.user,
+                type=0,
+                query='goodbye',
+            )
+            remove_excess_recent_searches(self.organization, self.user, 0)
+            assert list(RecentSearch.objects.all().values_list('query', flat=True)) == ['goodbye']

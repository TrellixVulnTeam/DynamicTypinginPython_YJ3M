commit f74010932119f4cb527edbe84d0178d000a3d7f7
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Thu Apr 12 09:04:33 2018 -0700

    feat(ui): Add command palette for search and quick nav (#7969)
    
    * add "fuse" library for fuzzy searching
    * use fuzzy search for all searches and add highlighting
    * add react-keydown for hotkeys
    * add "/" hotkey to settings search

diff --git a/package.json b/package.json
index 0f8739600c..1772866600 100644
--- a/package.json
+++ b/package.json
@@ -36,6 +36,7 @@
     "enzyme-to-json": "3.3.1",
     "extract-text-webpack-plugin": "^3.0.0",
     "file-loader": "1.1.11",
+    "fuse.js": "^3.2.0",
     "gettext-parser": "1.1.1",
     "grid-emotion": "^2.1.0",
     "idx": "^1.5.0",
@@ -69,6 +70,7 @@
     "react-emotion": "^8.0.2-12 ",
     "react-hot-loader": "^3.1.3",
     "react-icon-base": "^2.0.4",
+    "react-keydown": "^1.9.7",
     "react-lazy-load": "3.0.13",
     "react-mentions": "^1.2.0",
     "react-router": "3.2.0",
diff --git a/src/sentry/static/sentry/app/actionCreators/formSearch.jsx b/src/sentry/static/sentry/app/actionCreators/formSearch.jsx
index 8e08905e58..1d4fd244d5 100644
--- a/src/sentry/static/sentry/app/actionCreators/formSearch.jsx
+++ b/src/sentry/static/sentry/app/actionCreators/formSearch.jsx
@@ -1,22 +1,59 @@
+import {flatten, flatMap} from 'lodash';
+
 import FormSearchActions from '../actions/formSearchActions';
-import addForm from '../utils/addForm';
 
-export function addSearchMap(searchMap) {
-  FormSearchActions.addSearchMap(searchMap);
-}
+/**
+ * Creates a list of objects to be injected by a search source
+ *
+ * @param {Object} formDataModule Exported object from a form configuration file
+ * @param {String} formDataModule.route The route a form field belongs on
+ * @param {Array<FormGroup>} formDataModule.formGroups An array of `FormGroup: {title: String, fields: [Field]}`
+ * @param {Map<String, Field>} formDataModule.fields An object whose key is field name and value is a `Field`
+ * @return {Array<SearchSource>} Returns a list of SearchSource objects
+ */
+const createSearchMap = ({route, formGroups, fields, ...other}) => {
+  // There are currently two ways to define forms (TODO(billy): Turn this into one):
+  // If `formGroups` is defined, then return a flattened list of fields in all formGroups
+  // Otherwise `fields` is a map of fieldName -> fieldObject -- create a list of fields
+  let listOfFields = formGroups
+    ? flatMap(formGroups, formGroup => formGroup.fields)
+    : Object.keys(fields).map(fieldName => fields[fieldName]);
+
+  return listOfFields.map(field => ({
+    ...other,
+    route,
+    title: field.label,
+    description: field.help,
+    field,
+  }));
+};
 
 export function loadSearchMap() {
-  // Load search map by directory via webpack
+  // Load all form configuration files via webpack that export a named `route`
+  // as well as either `fields` or `formGroups`
   let context = require.context('../data/forms', true, /\.jsx$/);
-  context.keys().forEach(function(key) {
-    let mod = context(key);
 
-    if (!mod) return;
+  // Get a list of all form fields defined in `../data/forms`
+  let allFormFields = flatten(
+    context
+      .keys()
+      .map(key => {
+        let mod = context(key);
+
+        // Since we're dynamically importing an entire directly, there could be malformed modules defined?
+        if (!mod) return null;
+        // Only look for module that have `route` exported
+        if (!mod.route) return null;
+
+        return createSearchMap({
+          // `formGroups` can be a default export or a named export :<
+          formGroups: mod.default || mod.formGroups,
+          fields: mod.fields,
+          route: mod.route,
+        });
+      })
+      .filter(i => !!i)
+  );
 
-    addForm({
-      formGroups: mod.default || mod.formGroups,
-      fields: mod.fields,
-      route: mod.route,
-    });
-  });
+  FormSearchActions.loadSearchMap(allFormFields);
 }
diff --git a/src/sentry/static/sentry/app/actionCreators/modal.jsx b/src/sentry/static/sentry/app/actionCreators/modal.jsx
index c3edc40830..3fa5aacab6 100644
--- a/src/sentry/static/sentry/app/actionCreators/modal.jsx
+++ b/src/sentry/static/sentry/app/actionCreators/modal.jsx
@@ -63,3 +63,13 @@ export function openCreateOwnershipRule(options = {}) {
       });
     });
 }
+
+export function openCommandPalette(options = {}) {
+  import(/* webpackChunkName: "CommandPalette" */ '../components/modals/commandPalette')
+    .then(mod => mod.default)
+    .then(Modal => {
+      openModal(deps => <Modal {...deps} {...options} />, {
+        modalClassName: 'command-palette',
+      });
+    });
+}
diff --git a/src/sentry/static/sentry/app/actions/formSearchActions.jsx b/src/sentry/static/sentry/app/actions/formSearchActions.jsx
index 9a4315e6dc..c616e57e05 100644
--- a/src/sentry/static/sentry/app/actions/formSearchActions.jsx
+++ b/src/sentry/static/sentry/app/actions/formSearchActions.jsx
@@ -1,3 +1,3 @@
 import Reflux from 'reflux';
 
-export default Reflux.createActions(['addSearchMap']);
+export default Reflux.createActions(['loadSearchMap']);
diff --git a/src/sentry/static/sentry/app/components/modals/commandPalette.jsx b/src/sentry/static/sentry/app/components/modals/commandPalette.jsx
new file mode 100644
index 0000000000..00d06e0aba
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/modals/commandPalette.jsx
@@ -0,0 +1,97 @@
+import PropTypes from 'prop-types';
+import React from 'react';
+import styled, {css} from 'react-emotion';
+
+import {t} from '../../locale';
+import Search from '../search';
+import SearchResult from '../search/searchResult';
+import SearchResultWrapper from '../search/searchResultWrapper';
+
+const dropdownStyle = css`
+  width: 100%;
+  border: transparent;
+  border-top-left-radius: 0;
+  border-top-right-radius: 0;
+  position: initial;
+  box-shadow: none;
+`;
+
+class CommandPaletteModal extends React.Component {
+  static propTypes = {
+    closeModal: PropTypes.func,
+    onClose: PropTypes.func,
+    Body: PropTypes.oneOfType([PropTypes.func, PropTypes.node]).isRequired,
+  };
+
+  handleSuccess = data => {
+    if (this.props.onClose) {
+      this.props.onClose(data);
+    }
+
+    this.props.closeModal();
+  };
+
+  render() {
+    let {Body} = this.props;
+
+    return (
+      <Body>
+        <Search
+          {...this.props}
+          minSearch={1}
+          maxResults={10}
+          dropdownStyle={dropdownStyle}
+          renderInput={({getInputProps}) => (
+            <InputWrapper>
+              <Input
+                autoFocus
+                innerRef={ref => (this.searchInput = ref)}
+                {...getInputProps({
+                  type: 'text',
+                  placeholder: t('Search for projects, teams, settings, etc...'),
+                })}
+              />
+            </InputWrapper>
+          )}
+          renderItem={({item, matches, itemProps, highlighted}) => (
+            <CommandPaletteSearchResultWrapper {...itemProps} highlighted={highlighted}>
+              <SearchResult item={item} matches={matches} />
+            </CommandPaletteSearchResultWrapper>
+          )}
+        />
+      </Body>
+    );
+  }
+}
+
+export default CommandPaletteModal;
+
+const InputWrapper = styled('div')`
+  padding: 2px;
+`;
+
+const Input = styled('input')`
+  width: 100%;
+  padding: 8px;
+  border: none;
+  border-radius: 8px;
+  outline: none;
+
+  &:focus {
+    outline: none;
+  }
+`;
+
+const CommandPaletteSearchResultWrapper = styled(SearchResultWrapper)`
+  &:first-child {
+    border-top-left-radius: 0;
+    border-top-right-radius: 0;
+  }
+
+  ${p =>
+    p.highlighted &&
+    css`
+      color: ${p.theme.whiteDark};
+      background: ${p.theme.purpleLight};
+    `};
+`;
diff --git a/src/sentry/static/sentry/app/components/search/formFieldSearch.jsx b/src/sentry/static/sentry/app/components/search/formFieldSearch.jsx
deleted file mode 100644
index 22e2396995..0000000000
--- a/src/sentry/static/sentry/app/components/search/formFieldSearch.jsx
+++ /dev/null
@@ -1,64 +0,0 @@
-import {withRouter} from 'react-router';
-import PropTypes from 'prop-types';
-import React from 'react';
-import Reflux from 'reflux';
-import createReactClass from 'create-react-class';
-
-import FormSearchStore from '../../stores/formSearchStore';
-import replaceRouterParams from '../../utils/replaceRouterParams';
-
-class FormFieldSearch extends React.Component {
-  static propTypes = {
-    searchMap: PropTypes.object,
-
-    query: PropTypes.string,
-    /**
-     * Render function that passes:
-     * `isLoading` - loading state
-     * `allResults` - All results returned from all queries: [searchIndex, model, type]
-     * `results` - Results array filtered by `this.props.query`: [searchIndex, model, type]
-     */
-    children: PropTypes.func.isRequired,
-  };
-
-  render() {
-    let {searchMap, query, params, children} = this.props;
-
-    let results = searchMap
-      ? Object.keys(searchMap)
-          .filter(key => key.indexOf(query) > -1)
-          .map(key => searchMap[key])
-          .map(item => ({
-            sourceType: 'field',
-            resultType: 'field',
-            ...item,
-            title: item.field.label,
-            description: item.field.help,
-            searchIndex: `${replaceRouterParams(item.route, params)}#${encodeURIComponent(
-              item.field.name
-            )}`,
-            to: `${replaceRouterParams(item.route, params)}#${encodeURIComponent(
-              item.field.name
-            )}`,
-          })) || []
-      : null;
-
-    return children({
-      isLoading: searchMap === null,
-      allResults: searchMap,
-      results,
-    });
-  }
-}
-
-const FormFieldSearchContainer = withRouter(
-  createReactClass({
-    displayName: 'FormFieldSearchContainer',
-    mixins: [Reflux.connect(FormSearchStore, 'searchMap')],
-    render() {
-      return <FormFieldSearch searchMap={this.state.searchMap} {...this.props} />;
-    },
-  })
-);
-
-export default FormFieldSearchContainer;
diff --git a/src/sentry/static/sentry/app/components/search/index.jsx b/src/sentry/static/sentry/app/components/search/index.jsx
new file mode 100644
index 0000000000..406b0b5671
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/search/index.jsx
@@ -0,0 +1,192 @@
+import {Flex} from 'grid-emotion';
+import {withRouter} from 'react-router';
+import PropTypes from 'prop-types';
+import React from 'react';
+import styled from 'react-emotion';
+
+import {navigateTo} from '../../actionCreators/navigation';
+import {t} from '../../locale';
+import AutoComplete from '../autoComplete';
+import LoadingIndicator from '../loadingIndicator';
+import SearchResult from './searchResult';
+import SearchResultWrapper from './searchResultWrapper';
+import SearchSources from './sources';
+import replaceRouterParams from '../../utils/replaceRouterParams';
+
+// "Omni" search
+class Search extends React.Component {
+  static propTypes = {
+    router: PropTypes.object,
+    /**
+     * Render prop for the main input for the search
+     */
+    renderInput: PropTypes.func.isRequired,
+
+    /**
+     * Maximum number of results to display
+     */
+    maxResults: PropTypes.number,
+
+    /**
+     * Minimum number of characters before search activates
+     */
+    minSearch: PropTypes.number,
+
+    /**
+     * Render prop for search results
+     *
+     * Args: {
+     *  item: Search Item
+     *  index: item's index in results
+     *  highlighted: is item highlighted
+     *  itemProps: props that should be spread for root item
+     * }
+     */
+    renderItem: PropTypes.func,
+    dropdownStyle: PropTypes.string,
+    searchOptions: PropTypes.object,
+  };
+
+  static defaultProps = {
+    // Default Search result rendering
+    renderItem: ({item, matches, itemProps, highlighted}) => (
+      <SearchResultWrapper {...itemProps} highlighted={highlighted}>
+        <SearchResult item={item} matches={matches} />
+      </SearchResultWrapper>
+    ),
+  };
+
+  handleSelect = (item, state) => {
+    if (!item) return;
+
+    let {to} = item;
+    if (!to) return;
+
+    let {params, router} = this.props;
+    let nextPath = replaceRouterParams(to, params);
+
+    navigateTo(nextPath, router);
+  };
+
+  renderItem = ({resultObj, index, highlightedIndex, getItemProps}) => {
+    // resultObj is a fuse.js result object with {item, matches, score}
+    let {renderItem} = this.props;
+    let highlighted = index === highlightedIndex;
+    let {item, matches} = resultObj;
+    let key = `${item.title}-${index}`;
+    let itemProps = {
+      ...getItemProps({
+        item,
+      }),
+    };
+
+    if (typeof renderItem !== 'function') {
+      throw new Error('Invalid `renderItem`');
+    }
+
+    return React.cloneElement(
+      renderItem({
+        item,
+        matches,
+        index,
+        highlighted,
+      }),
+      {
+        ...itemProps,
+        key,
+      }
+    );
+  };
+
+  render() {
+    let {
+      params,
+      dropdownStyle,
+      searchOptions,
+      minSearch,
+      maxResults,
+      renderInput,
+    } = this.props;
+
+    return (
+      <AutoComplete
+        defaultHighlightedIndex={0}
+        itemToString={() => ''}
+        onSelect={this.handleSelect}
+      >
+        {({
+          getInputProps,
+          getItemProps,
+          isOpen,
+          inputValue,
+          selectedItem,
+          highlightedIndex,
+          onChange,
+        }) => {
+          let searchQuery = inputValue.toLowerCase();
+          let isValidSearch = inputValue.length >= minSearch;
+
+          return (
+            <SearchWrapper>
+              {renderInput({
+                getInputProps,
+              })}
+
+              {isValidSearch && isOpen ? (
+                <SearchSources
+                  searchOptions={searchOptions}
+                  query={searchQuery}
+                  params={params}
+                >
+                  {({isLoading, results, hasAnyResults}) => (
+                    <DropdownBox css={dropdownStyle}>
+                      {isLoading && (
+                        <Flex justify="center" align="center" p={1}>
+                          <LoadingIndicator mini hideMessage relative />
+                        </Flex>
+                      )}
+                      {!isLoading &&
+                        results.slice(0, maxResults).map((resultObj, index) => {
+                          return this.renderItem({
+                            resultObj,
+                            index,
+                            highlightedIndex,
+                            getItemProps,
+                          });
+                        })}
+                      {!isLoading &&
+                        !hasAnyResults && <EmptyItem>{t('No results found')}</EmptyItem>}
+                    </DropdownBox>
+                  )}
+                </SearchSources>
+              ) : null}
+            </SearchWrapper>
+          );
+        }}
+      </AutoComplete>
+    );
+  }
+}
+
+export default withRouter(Search);
+
+const DropdownBox = styled.div`
+  background: #fff;
+  border: 1px solid ${p => p.theme.borderDark};
+  box-shadow: ${p => p.theme.dropShadowHeavy};
+  position: absolute;
+  top: 36px;
+  right: 0;
+  width: 400px;
+  border-radius: 5px;
+`;
+
+const SearchWrapper = styled.div`
+  position: relative;
+`;
+
+const EmptyItem = styled(SearchResultWrapper)`
+  text-align: center;
+  padding: 16px;
+  opacity: 0.5;
+`;
diff --git a/src/sentry/static/sentry/app/components/search/searchResult.jsx b/src/sentry/static/sentry/app/components/search/searchResult.jsx
new file mode 100644
index 0000000000..45e15cd409
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/search/searchResult.jsx
@@ -0,0 +1,132 @@
+import {Flex} from 'grid-emotion';
+import {withRouter} from 'react-router';
+import PropTypes from 'prop-types';
+import React from 'react';
+import styled from 'react-emotion';
+
+import Avatar from '../avatar';
+import InlineSvg from '../inlineSvg';
+import SentryTypes from '../../proptypes';
+import UserBadge from '../userBadge';
+import highlightFuseMatches from '../../utils/highlightFuseMatches';
+
+class SearchResult extends React.Component {
+  static propTypes = {
+    item: PropTypes.shape({
+      /**
+     * The source of the search result (i.e. a model type)
+     */
+      sourceType: PropTypes.oneOf([
+        'organization',
+        'project',
+        'team',
+        'member',
+        'field',
+        'route',
+      ]),
+      /**
+     * The type of result this is, for example:
+     * - can be a setting route,
+     * - an application route (e.g. org dashboard)
+     * - form field
+     */
+      resultType: PropTypes.oneOf(['settings', 'route', 'field']),
+      title: PropTypes.string,
+      description: PropTypes.string,
+      model: PropTypes.oneOfType([
+        SentryTypes.Organization,
+        SentryTypes.Project,
+        SentryTypes.Team,
+        SentryTypes.Member,
+      ]),
+    }),
+    matches: PropTypes.array,
+  };
+
+  renderContent() {
+    let {item, matches, params} = this.props;
+    let {sourceType, title, description, model} = item;
+
+    let matchedTitle = matches && matches.find(({key}) => key === 'title');
+    let matchedDescription = matches && matches.find(({key}) => key === 'description');
+    let highlightedTitle = matchedTitle ? highlightFuseMatches(matchedTitle) : title;
+    let highlightedDescription = matchedDescription
+      ? highlightFuseMatches(matchedDescription)
+      : description;
+
+    if (sourceType === 'member') {
+      return (
+        <UserBadge
+          displayName={highlightedTitle}
+          displayEmail={highlightedDescription}
+          userLink={false}
+          orgId={params.orgId}
+          user={model}
+          avatarSize={32}
+        />
+      );
+    }
+
+    return (
+      <React.Fragment>
+        <div>
+          {sourceType === 'team' && <TeamAvatar team={model} size={32} />}
+          <SearchTitle>{highlightedTitle}</SearchTitle>
+        </div>
+
+        <SearchDetail>{highlightedDescription}</SearchDetail>
+      </React.Fragment>
+    );
+  }
+
+  renderResultType() {
+    let {item} = this.props;
+    let {resultType} = item;
+
+    let isSettings = resultType === 'settings';
+    let isField = resultType === 'field';
+
+    if (isSettings) {
+      return <ResultTypeIcon src="icon-settings" />;
+    }
+
+    if (isField) {
+      return <ResultTypeIcon src="icon-input" />;
+    }
+
+    return <ResultTypeIcon src="icon-location" />;
+  }
+
+  render() {
+    return (
+      <Flex justify="space-between" align="center">
+        <Content>{this.renderContent()}</Content>
+        {this.renderResultType()}
+      </Flex>
+    );
+  }
+}
+
+export default withRouter(SearchResult);
+
+// This is for tests
+const SearchTitle = styled.span``;
+
+const SearchDetail = styled.div`
+  font-size: 0.8em;
+  line-height: 1.3;
+  margin-top: 4px;
+  opacity: 0.8;
+`;
+
+const Content = styled(props => <Flex direction="column" {...props} />)``;
+
+const ResultTypeIcon = styled(InlineSvg)`
+  color: ${p => p.theme.gray1};
+  font-size: 1.2em;
+  flex-shrink: 0;
+`;
+
+const TeamAvatar = styled(Avatar)`
+  margin-right: 0.5em;
+`;
diff --git a/src/sentry/static/sentry/app/components/search/searchResultWrapper.jsx b/src/sentry/static/sentry/app/components/search/searchResultWrapper.jsx
new file mode 100644
index 0000000000..e8d96972aa
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/search/searchResultWrapper.jsx
@@ -0,0 +1,28 @@
+import {css} from 'emotion';
+import React from 'react';
+import styled from 'react-emotion';
+
+const SearchResultWrapper = styled(({highlighted, ...props}) => <div {...props} />)`
+  display: block;
+  color: ${p => p.theme.gray5};
+  padding: 10px;
+  border-top: 1px solid ${p => p.theme.borderLight};
+
+  ${p =>
+    p.highlighted &&
+    css`
+      color: ${p.theme.purpleDarkest};
+      background: ${p.theme.offWhite};
+    `};
+
+  &:first-child {
+    border-radius: 5px 5px 0 0;
+  }
+
+  &:last-child {
+    border-bottom: 0;
+    border-radius: 0 0 5px 5px;
+  }
+`;
+
+export default SearchResultWrapper;
diff --git a/src/sentry/static/sentry/app/components/search/apiSearch.jsx b/src/sentry/static/sentry/app/components/search/sources/apiSource.jsx
similarity index 64%
rename from src/sentry/static/sentry/app/components/search/apiSearch.jsx
rename to src/sentry/static/sentry/app/components/search/sources/apiSource.jsx
index 9b3ca39fb9..e944f120dd 100644
--- a/src/sentry/static/sentry/app/components/search/apiSearch.jsx
+++ b/src/sentry/static/sentry/app/components/search/sources/apiSource.jsx
@@ -4,12 +4,18 @@ import PropTypes from 'prop-types';
 import Raven from 'raven-js';
 import React from 'react';
 
-import {Client} from '../../api';
-import withLatestContext from '../../utils/withLatestContext';
+import {Client} from '../../../api';
+import {createFuzzySearch} from '../../../utils/createFuzzySearch';
+import withLatestContext from '../../../utils/withLatestContext';
 
-class ApiSearch extends React.Component {
+class ApiSource extends React.Component {
   static propTypes = {
+    // search term
     query: PropTypes.string,
+
+    // fuse.js options
+    searchOptions: PropTypes.object,
+
     /**
      * Render function that passes:
      * `isLoading` - loading state
@@ -19,28 +25,39 @@ class ApiSearch extends React.Component {
     children: PropTypes.func.isRequired,
   };
 
+  static defaultProps = {
+    searchOptions: {},
+  };
+
   constructor(props, ...args) {
     super(props, ...args);
     this.state = {
       loading: false,
       allResults: null,
-      results: null,
+      fuzzy: null,
     };
 
     this.api = new Client();
 
-    if (props.query) this.doSearch(props.query);
+    if (typeof props.query !== 'undefined') this.doSearch(props.query);
   }
 
   componentWillReceiveProps(nextProps) {
-    if (nextProps.query !== this.props.query) {
+    // Limit the number of times we perform API queries by only attempting API queries
+    // using first two characters, otherwise perform in-memory search.
+    //
+    // Otherwise it'd be constant :spinning_loading_wheel:
+    if (
+      nextProps.query.length <= 2 &&
+      nextProps.query.substr(0, 2) !== this.props.query.substr(0, 2)
+    ) {
       this.setState({loading: true});
       this.doSearch(nextProps.query);
     }
   }
 
   doSearch = debounce(async query => {
-    let {params, organization} = this.props;
+    let {params, searchOptions, organization} = this.props;
     let orgId = params.orgId || (organization && organization.slug);
     let urls = ['/organizations/'];
 
@@ -76,14 +93,16 @@ class ApiSearch extends React.Component {
       ...flatten(
         organizations.map(org => [
           {
-            searchIndex: org.slug,
+            title: `${org.slug} Settings`,
+            description: 'Organization Settings',
             model: org,
             sourceType: 'organization',
             resultType: 'settings',
             to: `/settings/${org.slug}/`,
           },
           {
-            searchIndex: `${org.slug} Dashboard`,
+            title: `${org.slug} Dashboard`,
+            description: 'Organization Dashboard',
             model: org,
             sourceType: 'organization',
             resultType: 'route',
@@ -94,14 +113,16 @@ class ApiSearch extends React.Component {
       ...flatten(
         (projects || []).map(project => [
           {
-            searchIndex: project.slug,
+            title: `${project.slug} Settings`,
+            description: 'Project Settings',
             model: project,
             sourceType: 'project',
             resultType: 'settings',
             to: `/settings/${orgId}/${project.slug}/`,
           },
           {
-            searchIndex: `${project.slug} Dashboard`,
+            title: `${project.slug} Dashboard`,
+            description: 'Project Dashboard',
             model: project,
             sourceType: 'project',
             resultType: 'route',
@@ -110,14 +131,16 @@ class ApiSearch extends React.Component {
         ])
       ),
       ...(teams || []).map(team => ({
-        searchIndex: team.slug,
+        title: `#${team.slug}`,
+        description: 'Team Settings',
         model: team,
         sourceType: 'team',
         resultType: 'settings',
         to: `/settings/${orgId}/teams/${team.slug}/`,
       })),
       ...(members || []).map(member => ({
-        searchIndex: `${member.email}${member.name}`,
+        title: member.name,
+        description: member.email,
         model: member,
         sourceType: 'member',
         resultType: 'settings',
@@ -125,25 +148,30 @@ class ApiSearch extends React.Component {
       })),
     ];
 
-    let results = allResults.filter(({searchIndex}) => searchIndex.indexOf(query) > -1);
+    let fuzzy = createFuzzySearch(allResults, {
+      ...searchOptions,
+      keys: ['title', 'description'],
+    });
 
     this.setState({
       loading: false,
       allResults,
-      results,
+      fuzzy: await fuzzy,
     });
   }, 150);
 
   render() {
-    let {children} = this.props;
+    let {children, query} = this.props;
+    let {fuzzy} = this.state;
 
+    let results = (fuzzy && fuzzy.search(query)) || null;
     return children({
       isLoading: this.state.loading,
       allResults: this.state.allResults,
-      results: this.state.results,
+      results,
     });
   }
 }
 
-export {ApiSearch};
-export default withLatestContext(withRouter(ApiSearch));
+export {ApiSource};
+export default withLatestContext(withRouter(ApiSource));
diff --git a/src/sentry/static/sentry/app/components/search/sources/formSource.jsx b/src/sentry/static/sentry/app/components/search/sources/formSource.jsx
new file mode 100644
index 0000000000..a2cf6d76a9
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/search/sources/formSource.jsx
@@ -0,0 +1,96 @@
+import {withRouter} from 'react-router';
+import PropTypes from 'prop-types';
+import React from 'react';
+import Reflux from 'reflux';
+import createReactClass from 'create-react-class';
+
+import {createFuzzySearch} from '../../../utils/createFuzzySearch';
+import FormSearchStore from '../../../stores/formSearchStore';
+import replaceRouterParams from '../../../utils/replaceRouterParams';
+
+class FormSource extends React.Component {
+  static propTypes = {
+    // search term
+    query: PropTypes.string,
+
+    // fuse.js options
+    searchOptions: PropTypes.object,
+
+    // list of form fields to search
+    searchMap: PropTypes.array,
+
+    /**
+     * Render function that passes:
+     * `isLoading` - loading state
+     * `allResults` - All results returned from all queries: [searchIndex, model, type]
+     * `results` - Results array filtered by `this.props.query`: [searchIndex, model, type]
+     */
+    children: PropTypes.func.isRequired,
+  };
+
+  static defaultProps = {
+    searchOptions: {},
+  };
+
+  constructor(props, ...args) {
+    super(props, ...args);
+
+    this.state = {
+      fuzzy: null,
+    };
+
+    this.createSearch(props.searchMap);
+  }
+
+  componentWillReceiveProps(nextProps) {
+    if (this.props.searchMap !== nextProps.searchMap) {
+      this.createSearch(nextProps.searchMap);
+    }
+  }
+
+  async createSearch(searchMap) {
+    this.setState({
+      fuzzy: await createFuzzySearch(searchMap || [], {
+        ...this.props.searchOptions,
+        keys: ['field.label', 'field.help'],
+      }),
+    });
+  }
+
+  render() {
+    let {searchMap, query, params, children} = this.props;
+
+    let results =
+      searchMap && this.state.fuzzy
+        ? this.state.fuzzy.search(query).map(({item, ...rest}) => ({
+            item: {
+              ...item,
+              sourceType: 'field',
+              resultType: 'field',
+              to: `${replaceRouterParams(item.route, params)}#${encodeURIComponent(
+                item.field.name
+              )}`,
+            },
+            ...rest,
+          })) || []
+        : null;
+
+    return children({
+      isLoading: searchMap === null,
+      allResults: searchMap,
+      results,
+    });
+  }
+}
+
+const FormSourceContainer = withRouter(
+  createReactClass({
+    displayName: 'FormSourceContainer',
+    mixins: [Reflux.connect(FormSearchStore, 'searchMap')],
+    render() {
+      return <FormSource searchMap={this.state.searchMap} {...this.props} />;
+    },
+  })
+);
+
+export default FormSourceContainer;
diff --git a/src/sentry/static/sentry/app/components/search/sources/index.jsx b/src/sentry/static/sentry/app/components/search/sources/index.jsx
new file mode 100644
index 0000000000..e175fee18c
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/search/sources/index.jsx
@@ -0,0 +1,66 @@
+import {flatten} from 'lodash';
+import PropTypes from 'prop-types';
+import React from 'react';
+
+import {loadSearchMap} from '../../../actionCreators/formSearch';
+import ApiSource from './apiSource';
+import FormSource from './formSource';
+import RouteSource from './routeSource';
+
+class SearchSources extends React.Component {
+  static propTypes = {
+    query: PropTypes.string,
+    /**
+     * Render function the passes:
+     *
+     * `isLoading`
+     * `results` - Array of results
+     * `hasAnyResults` - if any results were found
+     */
+    children: PropTypes.func,
+  };
+
+  componentDidMount() {
+    // Loads form fields
+    loadSearchMap();
+  }
+
+  // `allSources` will be an array of all result objects from each source
+  renderResults(...allSources) {
+    let {children} = this.props;
+
+    // loading means if any result has `isLoading` OR any result is null
+    let isLoading = !!allSources.find(arg => arg.isLoading || arg.results === null);
+
+    let foundResults = isLoading
+      ? []
+      : flatten(allSources.map(({results}) => results || [])).sort(
+          (a, b) => a.score - b.score
+        );
+    let hasAnyResults = !!foundResults.length;
+
+    return children({
+      isLoading,
+      results: foundResults,
+      hasAnyResults,
+    });
+  }
+
+  render() {
+    return (
+      <ApiSource {...this.props}>
+        {apiArgs => (
+          <FormSource {...this.props}>
+            {formFieldArgs => (
+              <RouteSource {...this.props}>
+                {routeArgs => this.renderResults(apiArgs, formFieldArgs, routeArgs)}
+              </RouteSource>
+            )}
+          </FormSource>
+        )}
+      </ApiSource>
+    );
+  }
+}
+
+export default SearchSources;
diff --git a/src/sentry/static/sentry/app/components/search/sources/routeSource.jsx b/src/sentry/static/sentry/app/components/search/sources/routeSource.jsx
new file mode 100644
index 0000000000..021454f39f
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/search/sources/routeSource.jsx
@@ -0,0 +1,96 @@
+import {flattenDepth} from 'lodash';
+import PropTypes from 'prop-types';
+import React from 'react';
+
+import {createFuzzySearch} from '../../../utils/createFuzzySearch';
+import accountSettingsNavigation from '../../../views/settings/account/navigationConfiguration';
+import organizationSettingsNavigation from '../../../views/settings/organization/navigationConfiguration';
+import projectSettingsNavigation from '../../../views/settings/project/navigationConfiguration';
+import replaceRouterParams from '../../../utils/replaceRouterParams';
+
+// navigation configuration can currently be either:
+// * an array of {name: string, items: Array<{NavItem}>} OR
+// * a function that returns the above
+//   (some navigation items require additional context, e.g. a badge based on a `project` property)
+//
+// We need to go through all navigation configurations and get a flattened list of all navigation item objects
+const navigationItems = flattenDepth(
+  [
+    accountSettingsNavigation,
+    projectSettingsNavigation,
+    organizationSettingsNavigation,
+  ].map(config =>
+    (Array.isArray(config) ? config : config({project: {}})).map(({items}) => items)
+  ),
+  2
+);
+
+class RouteSource extends React.Component {
+  static propTypes = {
+    // search term
+    query: PropTypes.string,
+
+    // fuse.js options
+    searchOptions: PropTypes.object,
+
+    // Array of routes to search
+    searchMap: PropTypes.array,
+
+    /**
+     * Render function that passes:
+     * `isLoading` - loading state
+     * `allResults` - All results returned from all queries: [searchIndex, model, type]
+     * `results` - Results array filtered by `this.props.query`: [searchIndex, model, type]
+     */
+    children: PropTypes.func.isRequired,
+  };
+
+  static defaultProps = {
+    searchMap: [],
+    searchOptions: {},
+  };
+
+  constructor(...args) {
+    super(...args);
+
+    this.state = {
+      fuzzy: null,
+    };
+
+    this.createSearch(navigationItems);
+  }
+
+  async createSearch(searchMap) {
+    this.setState({
+      fuzzy: await createFuzzySearch(searchMap || [], {
+        ...this.props.searchOptions,
+        keys: ['title', 'description'],
+      }),
+    });
+  }
+
+  render() {
+    let {searchMap, query, params, children} = this.props;
+
+    let results =
+      (this.state.fuzzy &&
+        this.state.fuzzy.search(query).map(({item, ...rest}) => ({
+          item: {
+            ...item,
+            sourceType: 'route',
+            resultType: 'route',
+            to: `${replaceRouterParams(item.path, params)}`,
+          },
+          ...rest,
+        }))) ||
+      [];
+
+    return children({
+      isLoading: searchMap === null,
+      allResults: searchMap,
+      results,
+    });
+  }
+}
+
+export default RouteSource;
diff --git a/src/sentry/static/sentry/app/constants/index.jsx b/src/sentry/static/sentry/app/constants/index.jsx
index 669a3dc254..522dea1f48 100644
--- a/src/sentry/static/sentry/app/constants/index.jsx
+++ b/src/sentry/static/sentry/app/constants/index.jsx
@@ -35,3 +35,16 @@ export const DEFAULT_TOAST_DURATION = 6000;
 export const CSRF_COOKIE_NAME = window.csrfCookieName || 'sc';
 
 export const ALL_ENVIRONMENTS_KEY = '__all_environments__';
+
+// See http://fusejs.io/ for more information
+export const DEFAULT_FUSE_OPTIONS = {
+  includeScore: true,
+  includeMatches: true,
+  threshold: 0.4,
+  location: 0,
+  distance: 75,
+  maxPatternLength: 24,
+  minMatchCharLength: 1,
+  // tokenize: true,
+  // findAllMatches: true,
+};
diff --git a/src/sentry/static/sentry/app/main.jsx b/src/sentry/static/sentry/app/main.jsx
index 3e0155f513..2ced32a982 100644
--- a/src/sentry/static/sentry/app/main.jsx
+++ b/src/sentry/static/sentry/app/main.jsx
@@ -2,7 +2,7 @@ import React from 'react';
 import {Router, browserHistory} from 'react-router';
 import routes from './routes';
 
-export default class App extends React.Component {
+export default class Main extends React.Component {
   render() {
     return <Router history={browserHistory}>{routes()}</Router>;
   }
diff --git a/src/sentry/static/sentry/app/stores/formSearchStore.jsx b/src/sentry/static/sentry/app/stores/formSearchStore.jsx
index 27beebfa28..aa7c4fac0d 100644
--- a/src/sentry/static/sentry/app/stores/formSearchStore.jsx
+++ b/src/sentry/static/sentry/app/stores/formSearchStore.jsx
@@ -7,7 +7,7 @@ import FormSearchActions from '../actions/formSearchActions';
 const FormSearchStore = Reflux.createStore({
   init() {
     this.reset();
-    this.listenTo(FormSearchActions.addSearchMap, this.onAddSearchMap);
+    this.listenTo(FormSearchActions.loadSearchMap, this.onLoadSearchMap);
   },
 
   getInitialState() {
@@ -22,14 +22,13 @@ const FormSearchStore = Reflux.createStore({
   /**
    * Adds to search map
    *
-   * @param Object searchIndex Map of search index -> object that includes route + field object
+   * @param Array searchMap array of objects: {route, field}
    */
-  onAddSearchMap(searchMap) {
-    this.searchMap = {
-      ...(this.searchMap || {}),
-      ...searchMap,
-    };
+  onLoadSearchMap(searchMap) {
+    // Only load once
+    if (this.searchMap !== null) return;
 
+    this.searchMap = searchMap;
     this.trigger(this.searchMap);
   },
 });
diff --git a/src/sentry/static/sentry/app/utils/addForm.jsx b/src/sentry/static/sentry/app/utils/addForm.jsx
deleted file mode 100644
index 6e7ed4f82e..0000000000
--- a/src/sentry/static/sentry/app/utils/addForm.jsx
+++ /dev/null
@@ -1,52 +0,0 @@
-import {fromPairs, flatMap} from 'lodash';
-
-import {addSearchMap} from '../actionCreators/formSearch';
-
-// Create a simple search index for a field
-const createSearchIndex = field => {
-  let fields = [field.name, field.label, field.help];
-
-  return fields
-    .join('')
-    .toLowerCase()
-    .replace(' ', '');
-};
-
-// need to associate index -> form group -> route
-// so when we search for a term we need to find:
-//   * what field(s) it matches:
-//     * what form group it belongs to
-//     * what route that belongs to
-const createSearchMap = ({route, formGroups, fields, ...other}) => {
-  let listOfFields = formGroups
-    ? flatMap(formGroups, formGroup => formGroup.fields)
-    : Object.keys(fields).map(fieldName => fields[fieldName]);
-
-  return fromPairs(
-    listOfFields.map(field => [
-      createSearchIndex(field),
-      {
-        ...other,
-        route,
-        field,
-      },
-    ])
-  );
-};
-
-/**
- * Given a `formGroup` ({ title: string, fields: Array<FormField> }) (or just `fields`)
- * and `route` where form exists, create a search index for fields.
- *
- * Adds to a global search store.
- *
- * returns formGroup
- */
-export default function addForm({formGroups, route, ...other}) {
-  if (route) {
-    // Only create searchMap if route is defined
-    addSearchMap(createSearchMap({route, formGroups, ...other}));
-  }
-
-  return formGroups;
-}
diff --git a/src/sentry/static/sentry/app/utils/createFuzzySearch.jsx b/src/sentry/static/sentry/app/utils/createFuzzySearch.jsx
new file mode 100644
index 0000000000..98a3b100b1
--- /dev/null
+++ b/src/sentry/static/sentry/app/utils/createFuzzySearch.jsx
@@ -0,0 +1,19 @@
+import {DEFAULT_FUSE_OPTIONS} from '../constants';
+
+export function loadFuzzySearch() {
+  return import('fuse.js');
+}
+
+export function createFuzzySearch(objects, options = {}) {
+  if (!options.keys) {
+    throw new Error('You need to define `options.keys`');
+  }
+
+  return loadFuzzySearch().then(
+    Fuse =>
+      new Fuse(objects, {
+        ...DEFAULT_FUSE_OPTIONS,
+        ...options,
+      })
+  );
+}
diff --git a/src/sentry/static/sentry/app/utils/highlightFuseMatches.jsx b/src/sentry/static/sentry/app/utils/highlightFuseMatches.jsx
new file mode 100644
index 0000000000..ee4c55af33
--- /dev/null
+++ b/src/sentry/static/sentry/app/utils/highlightFuseMatches.jsx
@@ -0,0 +1,77 @@
+import React from 'react';
+
+/**
+ * Parses matches from fuse.js library
+ *
+ * Example `match` would be
+ * {
+ *  value: 'Authentication tokens allow you to perform actions',
+ *  indices: [[4, 6], [12, 13], [15, 16]],
+ * }
+ *
+ * So:
+ *  0-3 -> not highlighted,
+ *  4-6 -> highlighted,
+ *  7-11 -> not highlighted,
+ *  12-13 -> highlighted,
+ *  ...etc
+ *
+ * @param {Object} match The match object from fuse
+ * @param {String} match.value The entire string that has matches
+ * @param {Array<Number>} match.indices Array of indices that represent matches
+ * @return {Array<{highlight: Boolean, text: String}>} Returns an array of {highlight, text} objects.
+ */
+const getFuseMatches = ({value, indices}) => {
+  if (!indices.length) return [];
+  let strLength = value.length;
+  let result = [];
+  let prev = [0, -1];
+
+  indices.forEach(([start, end]) => {
+    // Unhighlighted string before the match
+    let stringBeforeMatch = value.substring(prev[1] + 1, start);
+
+    // Only add to result if non-empty string
+    if (!!stringBeforeMatch) {
+      result.push({
+        highlight: false,
+        text: stringBeforeMatch,
+      });
+    }
+
+    // This is the matched string, which should be highlighted
+    let matchedString = value.substring(start, end + 1);
+    result.push({
+      highlight: true,
+      text: matchedString,
+    });
+
+    prev = [start, end];
+  });
+
+  // The rest of the string starting from the last match index
+  let restOfString = value.substring(prev[1] + 1, strLength);
+  // Only add to result if non-empty string
+  if (!!restOfString) {
+    result.push({highlight: false, text: restOfString});
+  }
+
+  return result;
+};
+
+/**
+ * Given a match object from fuse.js, returns an array of components with "highlighted" (bold) substrings.
+ */
+const highlightFuseMatches = matchObj => {
+  return getFuseMatches(matchObj).map(({highlight, text}, index) => {
+    if (!text) return null;
+    if (highlight) {
+      return <strong key={index}>{text}</strong>;
+    }
+
+    return <span key={index}>{text}</span>;
+  });
+};
+
+export {getFuseMatches};
+export default highlightFuseMatches;
diff --git a/src/sentry/static/sentry/app/views/app.jsx b/src/sentry/static/sentry/app/views/app.jsx
index a269db890a..1f3b3692a8 100644
--- a/src/sentry/static/sentry/app/views/app.jsx
+++ b/src/sentry/static/sentry/app/views/app.jsx
@@ -6,21 +6,23 @@ import Cookies from 'js-cookie';
 import PropTypes from 'prop-types';
 import React from 'react';
 import createReactClass from 'create-react-class';
+import keydown from 'react-keydown';
 
+import {openCommandPalette} from '../actionCreators/modal';
 import {t} from '../locale';
 import AlertActions from '../actions/alertActions';
 import Alerts from '../components/alerts';
 import ApiMixin from '../mixins/apiMixin';
+import AssistantHelper from '../components/assistant/helper';
 import ConfigStore from '../stores/configStore';
+import ErrorBoundary from '../components/errorBoundary';
+import GlobalModal from '../components/globalModal';
 import Indicators from '../components/indicators';
 import InstallWizard from './installWizard';
-import AssistantHelper from '../components/assistant/helper';
 import LoadingIndicator from '../components/loadingIndicator';
 import OrganizationsLoader from '../components/organizations/organizationsLoader';
 import OrganizationsStore from '../stores/organizationsStore';
-import GlobalModal from '../components/globalModal';
 import theme from '../utils/theme';
-import ErrorBoundary from '../components/errorBoundary';
 
 if (window.globalStaticUrl) __webpack_public_path__ = window.globalStaticUrl; // defined in layout.html
 
@@ -134,6 +136,13 @@ const App = createReactClass({
     OrganizationsStore.load([]);
   },
 
+  @keydown('cmd+shift+p')
+  openCommandPalette(e) {
+    openCommandPalette();
+    e.preventDefault();
+    e.stopPropagation();
+  },
+
   onConfigured() {
     this.setState({needsUpgrade: false});
   },
diff --git a/src/sentry/static/sentry/app/views/settings/account/navigationConfiguration.jsx b/src/sentry/static/sentry/app/views/settings/account/navigationConfiguration.jsx
index fad65de269..5ba40cb680 100644
--- a/src/sentry/static/sentry/app/views/settings/account/navigationConfiguration.jsx
+++ b/src/sentry/static/sentry/app/views/settings/account/navigationConfiguration.jsx
@@ -9,7 +9,9 @@ const accountNavigation = [
       {
         path: `${pathPrefix}/details/`,
         title: t('Account Details'),
-        description: t('Change your account details and preferences'),
+        description: t(
+          'Change your account details and preferences (e.g. timezone/clock, avatar, language)'
+        ),
       },
       {
         path: `${pathPrefix}/security/`,
diff --git a/src/sentry/static/sentry/app/views/settings/components/settingsSearch.jsx b/src/sentry/static/sentry/app/views/settings/components/settingsSearch.jsx
deleted file mode 100644
index df5c9c5ce6..0000000000
--- a/src/sentry/static/sentry/app/views/settings/components/settingsSearch.jsx
+++ /dev/null
@@ -1,343 +0,0 @@
-import {Flex} from 'grid-emotion';
-import {Link} from 'react-router';
-import {css} from 'emotion';
-import PropTypes from 'prop-types';
-import React from 'react';
-import styled from 'react-emotion';
-
-import {loadSearchMap} from '../../../actionCreators/formSearch';
-import {navigateTo} from '../../../actionCreators/navigation';
-import {t} from '../../../locale';
-import ApiSearch from '../../../components/search/apiSearch';
-import AutoComplete from '../../../components/autoComplete';
-import Avatar from '../../../components/avatar';
-import FormFieldSearch from '../../../components/search/formFieldSearch';
-import InlineSvg from '../../../components/inlineSvg';
-import LoadingIndicator from '../../../components/loadingIndicator';
-import SentryTypes from '../../../proptypes';
-import UserBadge from '../../../components/userBadge';
-import replaceRouterParams from '../../../utils/replaceRouterParams';
-
-const MIN_SEARCH_LENGTH = 2;
-
-class SearchResult extends React.Component {
-  static propTypes = {
-    /**
-     * The source of the search result (i.e. a model type)
-     */
-    sourceType: PropTypes.oneOf(['organization', 'project', 'team', 'member', 'field']),
-    /**
-     * The type of result this is, for example:
-     * - can be a setting route,
-     * - an application route (e.g. org dashboard)
-     * - form field
-     */
-    resultType: PropTypes.oneOf(['settings', 'route', 'field']),
-    title: PropTypes.string,
-    description: PropTypes.string,
-    model: PropTypes.oneOfType([
-      SentryTypes.Organization,
-      SentryTypes.Project,
-      SentryTypes.Team,
-      SentryTypes.Member,
-    ]),
-  };
-
-  renderContent() {
-    let {sourceType, resultType, title, description, model, params} = this.props;
-
-    let isSettings = resultType === 'settings';
-
-    if (sourceType === 'team') {
-      return (
-        <div>
-          <TeamAvatar team={model} size={32} />
-          #{model.slug}
-        </div>
-      );
-    }
-
-    if (sourceType === 'member') {
-      return (
-        <UserBadge useLink={false} orgId={params.orgId} user={model} avatarSize={32} />
-      );
-    }
-
-    if (sourceType === 'organization') {
-      return (
-        <React.Fragment>
-          {model.slug}{' '}
-          <SearchDetail>
-            Organization {isSettings ? ' Settings' : ' Dashboard'}
-          </SearchDetail>
-        </React.Fragment>
-      );
-    }
-
-    if (sourceType === 'project') {
-      return (
-        <React.Fragment>
-          {model.slug}{' '}
-          <SearchDetail>Project {isSettings ? ' Settings' : ' Issues'}</SearchDetail>
-        </React.Fragment>
-      );
-    }
-
-    if (sourceType === 'field' || sourceType === 'route') {
-      return (
-        <React.Fragment>
-          <div>
-            <span>{title}</span>
-          </div>
-
-          <SearchDetail>{description}</SearchDetail>
-        </React.Fragment>
-      );
-    }
-
-    return null;
-  }
-
-  renderResultType() {
-    let {resultType} = this.props;
-
-    // let isRoute = resultType === 'route';
-    let isSettings = resultType === 'settings';
-    let isField = resultType === 'field';
-
-    if (isSettings) {
-      return <ResultTypeIcon src="icon-settings" />;
-    }
-
-    if (isField) {
-      return <ResultTypeIcon src="icon-input" />;
-    }
-
-    return <ResultTypeIcon src="icon-location" />;
-  }
-
-  render() {
-    return (
-      <Flex justify="space-between" align="center">
-        <Content>{this.renderContent()}</Content>
-        {this.renderResultType()}
-      </Flex>
-    );
-  }
-}
-
-class SettingsSearch extends React.Component {
-  static propTypes = {
-    route: PropTypes.object,
-    router: PropTypes.object,
-  };
-
-  componentDidMount() {
-    loadSearchMap();
-  }
-
-  handleSelect = (item, state) => {
-    if (!item) return;
-
-    let {to} = item;
-    if (!to) return;
-
-    let {params, router} = this.props;
-    let nextPath = replaceRouterParams(to, params);
-
-    navigateTo(nextPath, router);
-  };
-
-  render() {
-    let {params} = this.props;
-
-    return (
-      <AutoComplete
-        defaultHighlightedIndex={0}
-        itemToString={() => ''}
-        onSelect={this.handleSelect}
-        onStateChange={this.handleStateChange}
-      >
-        {({
-          getInputProps,
-          getItemProps,
-          isOpen,
-          inputValue,
-          selectedItem,
-          highlightedIndex,
-          onChange,
-        }) => {
-          let searchQuery = inputValue.toLowerCase();
-          let isValidSearch = inputValue.length > MIN_SEARCH_LENGTH;
-
-          return (
-            <SettingsSearchWrapper>
-              <SearchInputWrapper>
-                <SearchInputIcon size="14px" />
-                <SearchInput
-                  {...getInputProps({
-                    type: 'text',
-                    placeholder: t('Search settings'),
-                  })}
-                />
-              </SearchInputWrapper>
-
-              {isValidSearch && isOpen ? (
-                <ApiSearch query={searchQuery}>
-                  {({isLoading: apiIsLoading, results: apiResults}) => {
-                    return (
-                      <FormFieldSearch params={params} query={searchQuery}>
-                        {({isLoading: fieldIsLoading, results: fieldResults}) => {
-                          let isLoading =
-                            apiIsLoading ||
-                            fieldIsLoading ||
-                            apiResults === null ||
-                            fieldResults === null;
-                          let hasApiResults =
-                            !isLoading && apiResults && !!apiResults.length;
-                          let hasFieldResults =
-                            !isLoading && fieldResults && !!fieldResults.length;
-                          let hasAnyResults = hasFieldResults || hasApiResults;
-                          let results = !isLoading
-                            ? (fieldResults || []).concat(apiResults || [])
-                            : [];
-
-                          return (
-                            <DropdownBox>
-                              {isLoading && (
-                                <Flex justify="center" align="center" p={1}>
-                                  <LoadingIndicator mini hideMessage relative />
-                                </Flex>
-                              )}
-                              {results.map((item, index) => {
-                                return (
-                                  <SearchItem
-                                    {...getItemProps({
-                                      item,
-                                    })}
-                                    highlighted={index === highlightedIndex}
-                                    key={`${item.searchIndex}:${item.sourceType}:${item.resultType}`}
-                                  >
-                                    <SearchResult {...item} {...this.props} />
-                                  </SearchItem>
-                                );
-                              })}
-
-                              {!isLoading &&
-                                !hasAnyResults && (
-                                  <EmptyItem>{t('No results found')}</EmptyItem>
-                                )}
-                            </DropdownBox>
-                          );
-                        }}
-                      </FormFieldSearch>
-                    );
-                  }}
-                </ApiSearch>
-              ) : null}
-            </SettingsSearchWrapper>
-          );
-        }}
-      </AutoComplete>
-    );
-  }
-}
-
-export default SettingsSearch;
-
-const SearchInputWrapper = styled.div`
-  position: relative;
-`;
-
-const SearchInputIcon = styled(props => <InlineSvg src="icon-search" {...props} />)`
-  color: ${p => p.theme.gray2}
-  position: absolute;
-  left: 10px;
-  top: 8px;
-`;
-
-const SearchInput = styled.input`
-  transition: border-color 0.15s ease;
-  font-size: 14px;
-  width: 260px;
-  line-height: 1;
-  padding: 5px 8px 4px 28px;
-  border: 1px solid ${p => p.theme.borderDark};
-  border-radius: 30px;
-  height: 28px;
-
-  box-shadow: inset ${p => p.theme.dropShadowLight};
-
-  &:focus {
-    outline: none;
-    border: 1px solid ${p => p.theme.gray1};
-  }
-
-  &::placeholder {
-    color: ${p => p.theme.gray2};
-  }
-`;
-
-const DropdownBox = styled.div`
-  background: #fff;
-  border: 1px solid ${p => p.theme.borderDark};
-  box-shadow: ${p => p.theme.dropShadowHeavy};
-  position: absolute;
-  top: 36px;
-  right: 0;
-  width: 400px;
-  border-radius: 5px;
-`;
-
-const SettingsSearchWrapper = styled.div`
-  position: relative;
-`;
-
-const SearchItem = styled(({highlighted, ...props}) => <Link {...props} />)`
-  display: block;
-  color: ${p => p.theme.gray5};
-  padding: 10px;
-  border-bottom: 1px solid ${p => p.theme.borderLight};
-
-  ${p =>
-    p.highlighted &&
-    css`
-      color: ${p.theme.purpleDarkest};
-      background: ${p.theme.offWhite};
-    `};
-
-  &:first-child {
-    border-radius: 5px 5px 0 0;
-  }
-
-  &:last-child {
-    border-bottom: 0;
-    border-radius: 0 0 5px 5px;
-  }
-`;
-
-const EmptyItem = styled(SearchItem)`
-  text-align: center;
-  padding: 16px;
-  opacity: 0.5;
-`;
-
-const SearchDetail = styled.div`
-  font-size: 0.8em;
-  line-height: 1.3;
-  margin-top: 4px;
-  opacity: 0.9;
-  color: ${p => p.theme.gray3};
-`;
-
-const Content = styled(props => <Flex direction="column" {...props} />)``;
-
-const ResultTypeIcon = styled(InlineSvg)`
-  color: ${p => p.theme.gray1};
-  font-size: 1.2em;
-  flex-shrink: 0;
-`;
-
-const TeamAvatar = styled(Avatar)`
-  margin-right: 0.5em;
-`;
diff --git a/src/sentry/static/sentry/app/views/settings/components/settingsSearch/index.jsx b/src/sentry/static/sentry/app/views/settings/components/settingsSearch/index.jsx
new file mode 100644
index 0000000000..83d73a4830
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/settings/components/settingsSearch/index.jsx
@@ -0,0 +1,78 @@
+import React from 'react';
+import keydown from 'react-keydown';
+import styled from 'react-emotion';
+
+import {t} from '../../../../locale';
+import InlineSvg from '../../../../components/inlineSvg';
+import Search from '../../../../components/search';
+
+const MIN_SEARCH_LENGTH = 1;
+const MAX_RESULTS = 10;
+
+class SettingsSearch extends React.Component {
+  @keydown('/')
+  handleFocusSearch(e) {
+    if (!this.searchInput) return;
+    if (e.target === this.searchInput) return;
+
+    e.preventDefault();
+    this.searchInput.focus();
+  }
+
+  render() {
+    return (
+      <Search
+        {...this.props}
+        minSearch={MIN_SEARCH_LENGTH}
+        maxResults={MAX_RESULTS}
+        renderInput={({getInputProps}) => (
+          <SearchInputWrapper>
+            <SearchInputIcon size="14px" />
+            <SearchInput
+              innerRef={ref => (this.searchInput = ref)}
+              {...getInputProps({
+                type: 'text',
+                placeholder: t('Search'),
+              })}
+            />
+          </SearchInputWrapper>
+        )}
+      />
+    );
+  }
+}
+
+export default SettingsSearch;
+
+const SearchInputWrapper = styled.div`
+  position: relative;
+`;
+
+const SearchInputIcon = styled(props => <InlineSvg src="icon-search" {...props} />)`
+  color: ${p => p.theme.gray2}
+  position: absolute;
+  left: 10px;
+  top: 8px;
+`;
+
+const SearchInput = styled.input`
+  transition: border-color 0.15s ease;
+  font-size: 14px;
+  width: 260px;
+  line-height: 1;
+  padding: 5px 8px 4px 28px;
+  border: 1px solid ${p => p.theme.borderDark};
+  border-radius: 30px;
+  height: 28px;
+
+  box-shadow: inset ${p => p.theme.dropShadowLight};
+
+  &:focus {
+    outline: none;
+    border: 1px solid ${p => p.theme.gray1};
+  }
+
+  &::placeholder {
+    color: ${p => p.theme.gray2};
+  }
+`;
diff --git a/src/sentry/static/sentry/app/views/settings/settingsLayout.jsx b/src/sentry/static/sentry/app/views/settings/settingsLayout.jsx
index 970d2bc124..75a4c08038 100644
--- a/src/sentry/static/sentry/app/views/settings/settingsLayout.jsx
+++ b/src/sentry/static/sentry/app/views/settings/settingsLayout.jsx
@@ -102,7 +102,7 @@ class SettingsLayout extends React.Component {
     let childRoutes = childProps.routes || routes || [];
     let childRoute = childProps.route || route || {};
     return (
-      <div>
+      <React.Fragment>
         <SettingsHeader>
           <SettingsSubheader>
             <Container>
@@ -132,7 +132,7 @@ class SettingsLayout extends React.Component {
           </Content>
         </Container>
         <Footer />
-      </div>
+      </React.Fragment>
     );
   }
 }
diff --git a/src/sentry/static/sentry/less/shared-components.less b/src/sentry/static/sentry/less/shared-components.less
index 2b251ab00f..2fe9c0f98d 100644
--- a/src/sentry/static/sentry/less/shared-components.less
+++ b/src/sentry/static/sentry/less/shared-components.less
@@ -2730,6 +2730,14 @@ ul.radio-inputs {
   }
 }
 
+// Command Palette
+.command-palette.modal {
+  .modal-content {
+    padding: 0;
+    overflow: visible;
+  }
+}
+
 .create-ownership-rule-modal {
   @media (min-width: 767px) {
     .modal-dialog {
diff --git a/tests/js/spec/components/__snapshots__/settingsLayout.spec.jsx.snap b/tests/js/spec/components/__snapshots__/settingsLayout.spec.jsx.snap
index 3007b5435c..9a7c646757 100644
--- a/tests/js/spec/components/__snapshots__/settingsLayout.spec.jsx.snap
+++ b/tests/js/spec/components/__snapshots__/settingsLayout.spec.jsx.snap
@@ -1,7 +1,7 @@
 // Jest Snapshot v1, https://goo.gl/fbAQLP
 
 exports[`SettingsLayout renders 1`] = `
-<div>
+<React.Fragment>
   <SettingsHeader>
     <SettingsSubheader>
       <Container>
@@ -35,5 +35,5 @@ exports[`SettingsLayout renders 1`] = `
     </Content>
   </Container>
   <Footer />
-</div>
+</React.Fragment>
 `;
diff --git a/tests/js/spec/components/modals/commandPaletteModal.spec.jsx b/tests/js/spec/components/modals/commandPaletteModal.spec.jsx
new file mode 100644
index 0000000000..ade78e3453
--- /dev/null
+++ b/tests/js/spec/components/modals/commandPaletteModal.spec.jsx
@@ -0,0 +1,118 @@
+import React from 'react';
+
+import {mount} from 'enzyme';
+import {openCommandPalette} from 'app/actionCreators/modal';
+import App from 'app/views/app';
+import ConfigStore from 'app/stores/configStore';
+import FormSearchStore from 'app/stores/formSearchStore';
+
+import {navigateTo} from 'app/actionCreators/navigation';
+
+jest.mock('jquery');
+jest.mock('lodash/debounce', () => jest.fn(fn => fn));
+jest.mock('app/actionCreators/formSearch');
+jest.mock('app/actionCreators/navigation');
+
+describe('Command Palette Modal', function() {
+  let orgsMock;
+
+  beforeEach(function() {
+    ConfigStore.set('messages', []);
+    FormSearchStore.onLoadSearchMap([]);
+
+    MockApiClient.clearMockResponses();
+
+    orgsMock = MockApiClient.addMockResponse({
+      url: '/organizations/',
+      body: [TestStubs.Organization({slug: 'billy-org', name: 'billy org'})],
+    });
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/projects/',
+      query: 'foo',
+      body: [TestStubs.Project({slug: 'foo-project'})],
+    });
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/teams/',
+      query: 'foo',
+      body: [TestStubs.Team({slug: 'foo-team'})],
+    });
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/members/',
+      query: 'foo',
+      body: TestStubs.Members(),
+    });
+
+    MockApiClient.addMockResponse({
+      url: '/internal/health/',
+      body: {
+        problems: [],
+      },
+    });
+    MockApiClient.addMockResponse({
+      url: '/assistant/',
+      body: [],
+    });
+  });
+
+  afterEach(function() {
+    // trigger.mockReset();
+    ConfigStore.set('messages', []);
+  });
+
+  it('can open command palette modal and search', async function() {
+    let wrapper = mount(
+      <App params={{orgId: 'org-slug'}}>{<div>placeholder content</div>}</App>
+    );
+
+    // No Modal
+    expect(wrapper.find('ModalDialog')).toHaveLength(0);
+
+    openCommandPalette({params: {orgId: 'org-slug'}});
+    await tick();
+    await tick();
+    wrapper.update();
+
+    // Should have Modal + input
+    expect(wrapper.find('ModalDialog')).toHaveLength(1);
+    wrapper.find('ModalDialog input').simulate('change', {target: {value: 'bil'}});
+
+    await tick();
+    wrapper.update();
+
+    expect(orgsMock).toHaveBeenCalledWith(
+      expect.anything(),
+      expect.objectContaining({
+        // This nested 'query' is correct
+        query: {query: 'bil'},
+      })
+    );
+
+    expect(
+      wrapper
+        .find('ModalDialog SearchResult SearchTitle')
+        .first()
+        .text()
+    ).toBe('billy-org Settings');
+
+    expect(
+      wrapper
+        .find('ModalDialog CommandPaletteSearchResultWrapper')
+        .first()
+        .prop('highlighted')
+    ).toBe(true);
+
+    expect(
+      wrapper
+        .find('ModalDialog CommandPaletteSearchResultWrapper')
+        .at(1)
+        .prop('highlighted')
+    ).toBe(false);
+
+    wrapper
+      .find('ModalDialog SearchResult')
+      .first()
+      .simulate('click');
+
+    expect(navigateTo).toHaveBeenCalledWith('/settings/billy-org/', undefined);
+  });
+});
diff --git a/tests/js/spec/components/search/apiSearch.spec.jsx b/tests/js/spec/components/search/apiSearch.spec.jsx
deleted file mode 100644
index 0ea3c08a0e..0000000000
--- a/tests/js/spec/components/search/apiSearch.spec.jsx
+++ /dev/null
@@ -1,238 +0,0 @@
-import React from 'react';
-import {mount} from 'enzyme';
-
-import {ApiSearch} from 'app/components/search/apiSearch';
-
-jest.mock('lodash/debounce', () => jest.fn(fn => fn));
-
-describe('ApiSearch', function() {
-  let wrapper;
-  let org = TestStubs.Organization();
-  let orgsMock;
-  let projectsMock;
-  let teamsMock;
-  let membersMock;
-
-  beforeEach(function() {
-    orgsMock = MockApiClient.addMockResponse({
-      url: '/organizations/',
-      query: 'foo',
-      body: [TestStubs.Organization({slug: 'foo-org'})],
-    });
-    projectsMock = MockApiClient.addMockResponse({
-      url: '/organizations/org-slug/projects/',
-      query: 'foo',
-      body: [TestStubs.Project({slug: 'foo-project'})],
-    });
-    teamsMock = MockApiClient.addMockResponse({
-      url: '/organizations/org-slug/teams/',
-      query: 'foo',
-      body: [TestStubs.Team({slug: 'foo-team'})],
-    });
-    membersMock = MockApiClient.addMockResponse({
-      url: '/organizations/org-slug/members/',
-      query: 'foo',
-      body: TestStubs.Members(),
-    });
-  });
-
-  afterEach(function() {
-    MockApiClient.clearMockResponses();
-  });
-
-  it('queries all API endpoints', function() {
-    let mock = jest.fn().mockReturnValue(null);
-    wrapper = mount(
-      <ApiSearch params={{orgId: org.slug}} query="foo">
-        {mock}
-      </ApiSearch>,
-      TestStubs.routerContext()
-    );
-
-    expect(orgsMock).toHaveBeenCalled();
-    expect(projectsMock).toHaveBeenCalled();
-    expect(teamsMock).toHaveBeenCalled();
-    expect(membersMock).toHaveBeenCalled();
-  });
-
-  it('only queries org endpoint if there is no org in context', function() {
-    let mock = jest.fn().mockReturnValue(null);
-    wrapper = mount(
-      <ApiSearch params={{}} query="foo">
-        {mock}
-      </ApiSearch>,
-      TestStubs.routerContext()
-    );
-
-    expect(orgsMock).toHaveBeenCalled();
-    expect(projectsMock).not.toHaveBeenCalled();
-    expect(teamsMock).not.toHaveBeenCalled();
-    expect(membersMock).not.toHaveBeenCalled();
-  });
-
-  it('render function is called with correct results', async function() {
-    let mock = jest.fn().mockReturnValue(null);
-    wrapper = mount(
-      <ApiSearch params={{orgId: org.slug}} query="foo">
-        {mock}
-      </ApiSearch>,
-      TestStubs.routerContext()
-    );
-
-    await tick();
-    wrapper.update();
-    expect(mock).toHaveBeenLastCalledWith({
-      isLoading: false,
-      allResults: expect.anything(),
-      results: expect.arrayContaining([
-        expect.objectContaining({
-          searchIndex: 'foo-org',
-          model: expect.objectContaining({
-            slug: 'foo-org',
-          }),
-          sourceType: 'organization',
-          resultType: 'settings',
-          to: '/settings/foo-org/',
-        }),
-        expect.objectContaining({
-          searchIndex: 'foo-org Dashboard',
-          model: expect.objectContaining({
-            slug: 'foo-org',
-          }),
-          sourceType: 'organization',
-          resultType: 'route',
-          to: '/foo-org/',
-        }),
-        expect.objectContaining({
-          searchIndex: 'foo-project',
-          model: expect.objectContaining({
-            slug: 'foo-project',
-          }),
-          sourceType: 'project',
-          resultType: 'settings',
-          to: '/settings/org-slug/foo-project/',
-        }),
-        expect.objectContaining({
-          searchIndex: 'foo-project Dashboard',
-          model: expect.objectContaining({
-            slug: 'foo-project',
-          }),
-          sourceType: 'project',
-          resultType: 'route',
-          to: '/org-slug/foo-project/',
-        }),
-        expect.objectContaining({
-          searchIndex: 'foo-team',
-          model: expect.objectContaining({
-            slug: 'foo-team',
-          }),
-          sourceType: 'team',
-          resultType: 'settings',
-          to: '/settings/org-slug/teams/foo-team/',
-        }),
-      ]),
-    });
-
-    // There are no members that match
-    expect(mock.mock.calls[1][0].results.length).toBe(5);
-  });
-
-  it('render function is called with correct results when API requests partially succeed', async function() {
-    let mock = jest.fn().mockReturnValue(null);
-
-    teamsMock = MockApiClient.addMockResponse({
-      url: '/organizations/org-slug/projects/',
-      query: 'foo',
-      statusCode: 500,
-    });
-    wrapper = mount(
-      <ApiSearch params={{orgId: org.slug}} query="foo">
-        {mock}
-      </ApiSearch>,
-      TestStubs.routerContext()
-    );
-
-    await tick();
-    wrapper.update();
-    expect(mock).toHaveBeenLastCalledWith({
-      isLoading: false,
-      allResults: expect.anything(),
-      results: expect.arrayContaining([
-        expect.objectContaining({
-          model: expect.objectContaining({
-            slug: 'foo-org',
-          }),
-        }),
-        expect.objectContaining({
-          model: expect.objectContaining({
-            slug: 'foo-org',
-          }),
-        }),
-        expect.objectContaining({
-          model: expect.objectContaining({
-            slug: 'foo-team',
-          }),
-        }),
-      ]),
-    });
-
-    // There are no members that match
-    expect(mock.mock.calls[1][0].results.length).toBe(3);
-  });
-
-  it('render function is updated as query changes', async function() {
-    let mock = jest.fn().mockReturnValue(null);
-    wrapper = mount(
-      <ApiSearch params={{orgId: org.slug}} query="foo">
-        {mock}
-      </ApiSearch>,
-      TestStubs.routerContext()
-    );
-
-    await tick();
-    wrapper.update();
-    expect(mock).toHaveBeenLastCalledWith({
-      isLoading: false,
-      allResults: expect.anything(),
-      results: expect.arrayContaining([
-        expect.objectContaining({
-          model: expect.objectContaining({
-            slug: 'foo-org',
-          }),
-        }),
-        expect.objectContaining({
-          model: expect.objectContaining({
-            slug: 'foo-project',
-          }),
-        }),
-        expect.objectContaining({
-          model: expect.objectContaining({
-            slug: 'foo-team',
-          }),
-        }),
-      ]),
-    });
-
-    // There are no members that match
-    expect(mock.mock.calls[1][0].results.length).toBe(5);
-
-    mock.mockClear();
-    wrapper.setProps({query: 'foo-t'});
-    await tick();
-    wrapper.update();
-    expect(mock).toHaveBeenLastCalledWith({
-      isLoading: false,
-      allResults: expect.anything(),
-      results: [
-        expect.objectContaining({
-          model: expect.objectContaining({
-            slug: 'foo-team',
-          }),
-        }),
-      ],
-    });
-
-    // Should have two calls, first call is setLoading
-    expect(mock.mock.calls[1][0].results.length).toBe(1);
-  });
-});
diff --git a/tests/js/spec/components/search/formFieldSearch.spec.jsx b/tests/js/spec/components/search/formFieldSearch.spec.jsx
deleted file mode 100644
index 8cc4150656..0000000000
--- a/tests/js/spec/components/search/formFieldSearch.spec.jsx
+++ /dev/null
@@ -1,66 +0,0 @@
-import React from 'react';
-import {mount} from 'enzyme';
-
-import FormFieldSearch from 'app/components/search/formFieldSearch';
-import {addSearchMap} from 'app/actionCreators/formSearch';
-
-describe('FormFieldSearch', function() {
-  let wrapper;
-  let searchMap = {
-    test: {
-      route: '/route/',
-      field: {
-        name: 'test-field',
-      },
-    },
-    foo: {
-      route: '/foo/',
-      field: {
-        name: 'foo-field',
-      },
-    },
-  };
-
-  beforeEach(function() {
-    addSearchMap(searchMap);
-  });
-
-  it('can find a form field', function(done) {
-    let mock = jest.fn().mockReturnValue(null);
-    wrapper = mount(<FormFieldSearch query="te">{mock}</FormFieldSearch>);
-
-    setTimeout(() => {
-      wrapper.update();
-      expect(mock).toHaveBeenCalledWith({
-        isLoading: false,
-        allResults: searchMap,
-        results: [
-          {
-            field: {name: 'test-field'},
-            resultType: 'field',
-            route: '/route/',
-            sourceType: 'field',
-            to: '/route/#test-field',
-            searchIndex: '/route/#test-field',
-          },
-        ],
-      });
-      done();
-    });
-  });
-
-  it('does not find any form field ', function(done) {
-    let mock = jest.fn().mockReturnValue(null);
-    wrapper = mount(<FormFieldSearch query="invalid">{mock}</FormFieldSearch>);
-
-    setTimeout(() => {
-      wrapper.update();
-      expect(mock).toHaveBeenCalledWith({
-        isLoading: false,
-        allResults: searchMap,
-        results: [],
-      });
-      done();
-    });
-  });
-});
diff --git a/tests/js/spec/components/search/sources/apiSource.spec.jsx b/tests/js/spec/components/search/sources/apiSource.spec.jsx
new file mode 100644
index 0000000000..efa3e001e1
--- /dev/null
+++ b/tests/js/spec/components/search/sources/apiSource.spec.jsx
@@ -0,0 +1,285 @@
+import React from 'react';
+import {mount} from 'enzyme';
+
+import {ApiSource} from 'app/components/search/sources/apiSource';
+
+jest.mock('lodash/debounce', () => jest.fn(fn => fn));
+
+describe('ApiSource', function() {
+  let wrapper;
+  let org = TestStubs.Organization();
+  let orgsMock;
+  let projectsMock;
+  let teamsMock;
+  let membersMock;
+
+  beforeEach(function() {
+    MockApiClient.clearMockResponses();
+    orgsMock = MockApiClient.addMockResponse({
+      url: '/organizations/',
+      query: 'foo',
+      body: [TestStubs.Organization({slug: 'foo-org'})],
+    });
+    projectsMock = MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/projects/',
+      query: 'foo',
+      body: [TestStubs.Project({slug: 'foo-project'})],
+    });
+    teamsMock = MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/teams/',
+      query: 'foo',
+      body: [TestStubs.Team({slug: 'foo-team'})],
+    });
+    membersMock = MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/members/',
+      query: 'foo',
+      body: TestStubs.Members(),
+    });
+  });
+
+  it('queries all API endpoints', function() {
+    let mock = jest.fn().mockReturnValue(null);
+    wrapper = mount(
+      <ApiSource params={{orgId: org.slug}} query="foo">
+        {mock}
+      </ApiSource>,
+      TestStubs.routerContext()
+    );
+
+    expect(orgsMock).toHaveBeenCalled();
+    expect(projectsMock).toHaveBeenCalled();
+    expect(teamsMock).toHaveBeenCalled();
+    expect(membersMock).toHaveBeenCalled();
+  });
+
+  it('only queries org endpoint if there is no org in context', function() {
+    let mock = jest.fn().mockReturnValue(null);
+    wrapper = mount(
+      <ApiSource params={{}} query="foo">
+        {mock}
+      </ApiSource>,
+      TestStubs.routerContext()
+    );
+
+    expect(orgsMock).toHaveBeenCalled();
+    expect(projectsMock).not.toHaveBeenCalled();
+    expect(teamsMock).not.toHaveBeenCalled();
+    expect(membersMock).not.toHaveBeenCalled();
+  });
+
+  it('render function is called with correct results', async function() {
+    let mock = jest.fn().mockReturnValue(null);
+    wrapper = mount(
+      <ApiSource params={{orgId: org.slug}} query="foo">
+        {mock}
+      </ApiSource>,
+      TestStubs.routerContext()
+    );
+
+    await tick();
+    wrapper.update();
+    expect(mock).toHaveBeenLastCalledWith({
+      isLoading: false,
+      allResults: expect.anything(),
+      results: expect.arrayContaining([
+        expect.objectContaining({
+          item: expect.objectContaining({
+            model: expect.objectContaining({
+              slug: 'foo-org',
+            }),
+            sourceType: 'organization',
+            resultType: 'settings',
+            to: '/settings/foo-org/',
+          }),
+          matches: expect.anything(),
+          score: expect.anything(),
+        }),
+        expect.objectContaining({
+          item: expect.objectContaining({
+            model: expect.objectContaining({
+              slug: 'foo-org',
+            }),
+            sourceType: 'organization',
+            resultType: 'route',
+            to: '/foo-org/',
+          }),
+          matches: expect.anything(),
+          score: expect.anything(),
+        }),
+        expect.objectContaining({
+          item: expect.objectContaining({
+            model: expect.objectContaining({
+              slug: 'foo-project',
+            }),
+            sourceType: 'project',
+            resultType: 'settings',
+            to: '/settings/org-slug/foo-project/',
+          }),
+          matches: expect.anything(),
+          score: expect.anything(),
+        }),
+        expect.objectContaining({
+          item: expect.objectContaining({
+            model: expect.objectContaining({
+              slug: 'foo-project',
+            }),
+            sourceType: 'project',
+            resultType: 'route',
+            to: '/org-slug/foo-project/',
+          }),
+          matches: expect.anything(),
+          score: expect.anything(),
+        }),
+        expect.objectContaining({
+          item: expect.objectContaining({
+            model: expect.objectContaining({
+              slug: 'foo-team',
+            }),
+            sourceType: 'team',
+            resultType: 'settings',
+            to: '/settings/org-slug/teams/foo-team/',
+          }),
+          matches: expect.anything(),
+          score: expect.anything(),
+        }),
+      ]),
+    });
+
+    // There are no members that match
+    expect(mock.mock.calls[1][0].results).toHaveLength(5);
+  });
+
+  it('render function is called with correct results when API requests partially succeed', async function() {
+    let mock = jest.fn().mockReturnValue(null);
+
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/projects/',
+      query: 'foo',
+      statusCode: 500,
+    });
+    wrapper = mount(
+      <ApiSource params={{orgId: org.slug}} query="foo">
+        {mock}
+      </ApiSource>,
+      TestStubs.routerContext()
+    );
+
+    await tick();
+    wrapper.update();
+    expect(mock).toHaveBeenLastCalledWith({
+      isLoading: false,
+      allResults: expect.anything(),
+      results: expect.arrayContaining([
+        expect.objectContaining({
+          item: expect.objectContaining({
+            model: expect.objectContaining({
+              slug: 'foo-org',
+            }),
+          }),
+        }),
+        expect.objectContaining({
+          item: expect.objectContaining({
+            model: expect.objectContaining({
+              slug: 'foo-org',
+            }),
+          }),
+        }),
+        expect.objectContaining({
+          item: expect.objectContaining({
+            model: expect.objectContaining({
+              slug: 'foo-team',
+            }),
+          }),
+        }),
+      ]),
+    });
+
+    // There are no members that match
+    expect(mock.mock.calls[1][0].results).toHaveLength(3);
+  });
+
+  it('render function is updated as query changes', async function() {
+    let mock = jest.fn().mockReturnValue(null);
+    wrapper = mount(
+      <ApiSource params={{orgId: org.slug}} query="foo">
+        {mock}
+      </ApiSource>,
+      TestStubs.routerContext()
+    );
+
+    await tick();
+    wrapper.update();
+
+    // There are no members that match
+    expect(mock.mock.calls[1][0].results).toHaveLength(5);
+    expect(mock.mock.calls[1][0].results[0].item.model.slug).toBe('foo-org');
+
+    mock.mockClear();
+    wrapper.setProps({query: 'foo-t'});
+    await tick();
+    wrapper.update();
+
+    // Still have 5 results, but is re-ordered
+    expect(mock.mock.calls[0][0].results).toHaveLength(5);
+    expect(mock.mock.calls[0][0].results[0].item.model.slug).toBe('foo-team');
+  });
+
+  describe('API queries', function() {
+    let mock;
+    beforeAll(function() {
+      mock = jest.fn().mockReturnValue(null);
+      wrapper = mount(
+        <ApiSource params={{orgId: org.slug}} query="">
+          {mock}
+        </ApiSource>,
+        TestStubs.routerContext()
+      );
+    });
+
+    it('does not call API with empty query string', function() {
+      expect(projectsMock).not.toHaveBeenCalled();
+    });
+
+    it('calls API when query string length is 1 char', function() {
+      wrapper.setProps({query: 'f'});
+      wrapper.update();
+      expect(projectsMock).toHaveBeenCalledTimes(1);
+    });
+
+    it('calls API when query string length increases from 1 -> 2', function() {
+      wrapper.setProps({query: 'fo'});
+      wrapper.update();
+      expect(projectsMock).toHaveBeenCalledTimes(1);
+    });
+
+    it('does not query API when query string > 2 chars', function() {
+      // Should not query API when query is > 2 chars
+      wrapper.setProps({query: 'foo'});
+      wrapper.update();
+      expect(projectsMock).toHaveBeenCalledTimes(0);
+    });
+    it('does not query API when query string 3 -> 4 chars', function() {
+      wrapper.setProps({query: 'foob'});
+      wrapper.update();
+      expect(projectsMock).toHaveBeenCalledTimes(0);
+    });
+
+    it('re-queries API if first 2 characters are different', function() {
+      wrapper.setProps({query: 'ba'});
+      wrapper.update();
+      expect(projectsMock).toHaveBeenCalledTimes(1);
+    });
+
+    it('does not requery if query string is the same', function() {
+      wrapper.setProps({query: 'ba'});
+      wrapper.update();
+      expect(projectsMock).toHaveBeenCalledTimes(0);
+    });
+
+    it('queries if we go from 2 chars -> 1 char', function() {
+      wrapper.setProps({query: 'b'});
+      wrapper.update();
+      expect(projectsMock).toHaveBeenCalledTimes(1);
+    });
+  });
+});
diff --git a/tests/js/spec/components/search/sources/formSource.spec.jsx b/tests/js/spec/components/search/sources/formSource.spec.jsx
new file mode 100644
index 0000000000..3c41542940
--- /dev/null
+++ b/tests/js/spec/components/search/sources/formSource.spec.jsx
@@ -0,0 +1,65 @@
+import React from 'react';
+import {mount} from 'enzyme';
+
+import FormSource from 'app/components/search/sources/formSource';
+import FormSearchActions from 'app/actions/formSearchActions';
+
+describe('FormSource', function() {
+  let wrapper;
+  let searchMap = [
+    {
+      route: '/route/',
+      field: {
+        name: 'test-field',
+        label: 'Test Field',
+        help: 'test-help',
+      },
+    },
+    {
+      route: '/foo/',
+      field: {
+        name: 'foo-field',
+        label: 'Foo Field',
+        help: 'foo-help',
+      },
+    },
+  ];
+
+  beforeEach(function() {
+    FormSearchActions.loadSearchMap(searchMap);
+  });
+
+  it('can find a form field', async function() {
+    let mock = jest.fn().mockReturnValue(null);
+    wrapper = mount(<FormSource query="te">{mock}</FormSource>);
+
+    await tick();
+    await tick();
+    wrapper.update();
+    let calls = mock.mock.calls;
+    expect(calls[calls.length - 1][0].results[0].item).toEqual({
+      field: {
+        label: 'Test Field',
+        name: 'test-field',
+        help: 'test-help',
+      },
+      route: '/route/',
+      resultType: 'field',
+      sourceType: 'field',
+      to: '/route/#test-field',
+    });
+  });
+
+  it('does not find any form field ', async function() {
+    let mock = jest.fn().mockReturnValue(null);
+    wrapper = mount(<FormSource query="invalid">{mock}</FormSource>);
+
+    await tick();
+    wrapper.update();
+    expect(mock).toHaveBeenCalledWith({
+      isLoading: false,
+      allResults: searchMap,
+      results: [],
+    });
+  });
+});
diff --git a/tests/js/spec/components/search/sources/routeSource.spec.jsx b/tests/js/spec/components/search/sources/routeSource.spec.jsx
new file mode 100644
index 0000000000..175f8b4444
--- /dev/null
+++ b/tests/js/spec/components/search/sources/routeSource.spec.jsx
@@ -0,0 +1,38 @@
+import React from 'react';
+import {mount} from 'enzyme';
+
+import RouteSource from 'app/components/search/sources/routeSource';
+
+describe('RouteSource', function() {
+  let wrapper;
+
+  it('can find a route', async function() {
+    let mock = jest.fn().mockReturnValue(null);
+    wrapper = mount(<RouteSource query="password">{mock}</RouteSource>);
+
+    await tick();
+    wrapper.update();
+    let calls = mock.mock.calls;
+    expect(calls[calls.length - 1][0].results[0].item).toEqual({
+      description: 'Change your account password and/or two factor authentication',
+      path: '/settings/account/security/',
+      resultType: 'route',
+      sourceType: 'route',
+      title: 'Security',
+      to: '/settings/account/security/',
+    });
+  });
+
+  it('does not find any form field ', async function() {
+    let mock = jest.fn().mockReturnValue(null);
+    wrapper = mount(<RouteSource query="invalid">{mock}</RouteSource>);
+
+    await tick();
+    wrapper.update();
+    expect(mock).toHaveBeenCalledWith(
+      expect.objectContaining({
+        results: [],
+      })
+    );
+  });
+});
diff --git a/tests/js/spec/utils/__snapshots__/highlightFuseMatches.spec.jsx.snap b/tests/js/spec/utils/__snapshots__/highlightFuseMatches.spec.jsx.snap
new file mode 100644
index 0000000000..becc78171e
--- /dev/null
+++ b/tests/js/spec/utils/__snapshots__/highlightFuseMatches.spec.jsx.snap
@@ -0,0 +1,35 @@
+// Jest Snapshot v1, https://goo.gl/fbAQLP
+
+exports[`highlightFuseMatches matches whole word 1`] = `
+Array [
+  <strong>
+    foo
+  </strong>,
+]
+`;
+
+exports[`highlightFuseMatches renders a highlighted string 1`] = `
+Array [
+  <span>
+    Auth
+  </span>,
+  <strong>
+    ent
+  </strong>,
+  <span>
+    icati
+  </span>,
+  <strong>
+    on
+  </strong>,
+  <span>
+     
+  </span>,
+  <strong>
+    to
+  </strong>,
+  <span>
+    kens allow you to perform actions
+  </span>,
+]
+`;
diff --git a/tests/js/spec/utils/highlightFuseMatches.spec.jsx b/tests/js/spec/utils/highlightFuseMatches.spec.jsx
new file mode 100644
index 0000000000..73962d2e8a
--- /dev/null
+++ b/tests/js/spec/utils/highlightFuseMatches.spec.jsx
@@ -0,0 +1,53 @@
+import highlightFuseMatches, {getFuseMatches} from 'app/utils/highlightFuseMatches';
+
+describe('highlightFuseMatches', function() {
+  let matchObj = {
+    value: 'Authentication tokens allow you to perform actions',
+    indices: [[4, 6], [12, 13], [15, 16]],
+  };
+
+  it('handles no matches', function() {
+    expect(getFuseMatches({value: 'My long string', indices: []})).toEqual([]);
+  });
+
+  it('gets the correct tokens', function() {
+    expect(getFuseMatches(matchObj)).toEqual([
+      {
+        highlight: false,
+        text: 'Auth',
+      },
+      {
+        highlight: true,
+        text: 'ent',
+      },
+      {
+        highlight: false,
+        text: 'icati',
+      },
+      {
+        highlight: true,
+        text: 'on',
+      },
+      {
+        highlight: false,
+        text: ' ',
+      },
+      {
+        highlight: true,
+        text: 'to',
+      },
+      {
+        highlight: false,
+        text: 'kens allow you to perform actions',
+      },
+    ]);
+  });
+
+  it('renders a highlighted string', function() {
+    expect(highlightFuseMatches(matchObj)).toMatchSnapshot();
+  });
+
+  it('matches whole word', function() {
+    expect(highlightFuseMatches({value: 'foo', indices: [[0, 2]]})).toMatchSnapshot();
+  });
+});
diff --git a/tests/js/spec/views/__snapshots__/providerItem.spec.jsx.snap b/tests/js/spec/views/__snapshots__/providerItem.spec.jsx.snap
new file mode 100644
index 0000000000..4d26f63a67
--- /dev/null
+++ b/tests/js/spec/views/__snapshots__/providerItem.spec.jsx.snap
@@ -0,0 +1,51 @@
+// Jest Snapshot v1, https://goo.gl/fbAQLP
+
+exports[`ProviderItem renders 1`] = `
+<PanelItem
+  align="center"
+  p={2}
+>
+  <Flex
+    flex="1"
+  >
+    <ProviderLogo
+      className="provider-logo dummy"
+    />
+    <Flex
+      direction="column"
+      flex="1"
+      justify="space-around"
+    >
+      <ProviderName>
+        Dummy
+      </ProviderName>
+      <div>
+        <span
+          key="4"
+        >
+          <span
+            key="0"
+          >
+            Enable your organization to sign in with 
+          </span>
+          <span
+            key="2"
+          >
+            Dummy
+          </span>
+        </span>
+        .
+      </div>
+    </Flex>
+  </Flex>
+  <Button
+    disabled={false}
+    name="provider"
+    onClick={[Function]}
+    type="submit"
+    value="dummy"
+  >
+    Configure
+  </Button>
+</PanelItem>
+`;
diff --git a/tests/js/spec/views/providerItem.jsx b/tests/js/spec/views/providerItem.spec.jsx
similarity index 67%
rename from tests/js/spec/views/providerItem.jsx
rename to tests/js/spec/views/providerItem.spec.jsx
index 5afbbf6dee..27bcc80c2d 100644
--- a/tests/js/spec/views/providerItem.jsx
+++ b/tests/js/spec/views/providerItem.spec.jsx
@@ -14,8 +14,11 @@ describe('ProviderItem', function() {
 
   it('calls configure callback', function() {
     let mock = jest.fn();
-    mount(<ProviderItem providerKey="dummy" providerName="Dummy" onConfigure={mock} />);
+    let wrapper = mount(
+      <ProviderItem providerKey="dummy" providerName="Dummy" onConfigure={mock} />
+    );
 
-    expect(mock).toHaveBeenCalledWith('dummy');
+    wrapper.find('Button').simulate('click');
+    expect(mock).toHaveBeenCalledWith('dummy', expect.anything());
   });
 });
diff --git a/tests/js/spec/views/settings/components/settingsSearch/index.spec.jsx b/tests/js/spec/views/settings/components/settingsSearch/index.spec.jsx
new file mode 100644
index 0000000000..2c63fcec27
--- /dev/null
+++ b/tests/js/spec/views/settings/components/settingsSearch/index.spec.jsx
@@ -0,0 +1,120 @@
+import React from 'react';
+import {mount} from 'enzyme';
+
+import SettingsSearch from 'app/views/settings/components/settingsSearch';
+import FormSearchStore from 'app/stores/formSearchStore';
+
+import {navigateTo} from 'app/actionCreators/navigation';
+
+jest.mock('jquery');
+jest.mock('lodash/debounce', () => jest.fn(fn => fn));
+jest.mock('app/actionCreators/formSearch');
+jest.mock('app/actionCreators/navigation');
+
+const SETTINGS_SEARCH_PLACEHOLDER = 'Search';
+describe('SettingsSearch', function() {
+  let orgsMock;
+
+  beforeEach(function() {
+    FormSearchStore.onLoadSearchMap([]);
+    MockApiClient.clearMockResponses();
+    orgsMock = MockApiClient.addMockResponse({
+      url: '/organizations/',
+      body: [TestStubs.Organization({slug: 'billy-org', name: 'billy org'})],
+    });
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/projects/',
+      query: 'foo',
+      body: [TestStubs.Project({slug: 'foo-project'})],
+    });
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/teams/',
+      query: 'foo',
+      body: [TestStubs.Team({slug: 'foo-team'})],
+    });
+    MockApiClient.addMockResponse({
+      url: '/organizations/org-slug/members/',
+      query: 'foo',
+      body: TestStubs.Members(),
+    });
+  });
+
+  it('renders', async function() {
+    let wrapper = mount(<SettingsSearch params={{orgId: 'org-slug'}} />);
+
+    // renders input
+    expect(wrapper.find('SearchInput')).toHaveLength(1);
+    expect(wrapper.find('input').prop('placeholder')).toBe(SETTINGS_SEARCH_PLACEHOLDER);
+  });
+
+  it('can focus when `handleFocusSearch` is called and target is not search input', function() {
+    let wrapper = mount(<SettingsSearch params={{orgId: 'org-slug'}} />);
+    let searchInput = wrapper.instance().searchInput;
+    let focusSpy = jest.spyOn(searchInput, 'focus');
+
+    wrapper.instance().handleFocusSearch({
+      preventDefault: () => {},
+      target: null,
+    });
+
+    expect(focusSpy).toHaveBeenCalled();
+  });
+
+  it('does not focus search input if it is current target and `handleFocusSearch` is called', function() {
+    let wrapper = mount(<SettingsSearch params={{orgId: 'org-slug'}} />);
+    let searchInput = wrapper.instance().searchInput;
+    let focusSpy = jest.spyOn(searchInput, 'focus');
+
+    wrapper.instance().handleFocusSearch({
+      preventDefault: () => {},
+      target: searchInput,
+    });
+
+    expect(focusSpy).not.toHaveBeenCalled();
+  });
+
+  it('can search', async function() {
+    let wrapper = mount(<SettingsSearch params={{orgId: 'org-slug'}} />);
+
+    wrapper.find('input').simulate('change', {target: {value: 'bil'}});
+
+    await tick();
+    wrapper.update();
+
+    expect(orgsMock).toHaveBeenCalledWith(
+      expect.anything(),
+      expect.objectContaining({
+        // This nested 'query' is correct
+        query: {query: 'bil'},
+      })
+    );
+
+    expect(
+      wrapper
+        .find('SearchResult SearchTitle')
+        .first()
+        .text()
+    ).toBe('billy-org Settings');
+
+    expect(
+      wrapper
+        .find('SearchResultWrapper')
+        .first()
+        .prop('highlighted')
+    ).toBe(true);
+
+    expect(
+      wrapper
+        .find('SearchResultWrapper')
+        .at(1)
+        .prop('highlighted')
+    ).toBe(false);
+
+    wrapper
+      .find('SearchResult')
+      .first()
+      .simulate('click');
+
+    expect(navigateTo).toHaveBeenCalledWith('/settings/billy-org/', undefined);
+  });
+});
diff --git a/yarn.lock b/yarn.lock
index 3782f590ea..2b6be06210 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -4029,7 +4029,7 @@ functional-red-black-tree@^1.0.1:
   version "1.0.1"
   resolved "https://registry.yarnpkg.com/functional-red-black-tree/-/functional-red-black-tree-1.0.1.tgz#1b0ab3bd553b2a0d6399d29c0e3ea0b252078327"
 
-fuse.js@^3.0.1:
+fuse.js@^3.0.1, fuse.js@^3.2.0:
   version "3.2.0"
   resolved "https://registry.yarnpkg.com/fuse.js/-/fuse.js-3.2.0.tgz#f0448e8069855bf2a3e683cdc1d320e7e2a07ef4"
 
@@ -7474,6 +7474,12 @@ react-inspector@^2.2.1:
     babel-runtime "^6.26.0"
     is-dom "^1.0.9"
 
+react-keydown@^1.9.7:
+  version "1.9.7"
+  resolved "https://registry.yarnpkg.com/react-keydown/-/react-keydown-1.9.7.tgz#cd168d4b0194b6ef71bca47e5c1cbc5d24ab5498"
+  dependencies:
+    core-js "^2.5.0"
+
 react-lazy-load@3.0.13:
   version "3.0.13"
   resolved "https://registry.yarnpkg.com/react-lazy-load/-/react-lazy-load-3.0.13.tgz#3b0a92d336d43d3f0d73cbe6f35b17050b08b824"

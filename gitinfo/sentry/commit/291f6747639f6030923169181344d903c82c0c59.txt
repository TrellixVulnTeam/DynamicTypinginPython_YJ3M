commit 291f6747639f6030923169181344d903c82c0c59
Author: ted kaemming <ted@kaemming.com>
Date:   Tue May 8 10:11:01 2018 -0700

    ref(tagstore): Use standard types for Snuba backend read methods (#8306)

diff --git a/src/sentry/tagstore/snuba/backend.py b/src/sentry/tagstore/snuba/backend.py
index c1f5389138..86bd8e86f7 100644
--- a/src/sentry/tagstore/snuba/backend.py
+++ b/src/sentry/tagstore/snuba/backend.py
@@ -8,12 +8,13 @@ sentry.tagstore.snuba.backend
 
 from __future__ import absolute_import
 
+import functools
 from collections import defaultdict
 from datetime import timedelta
+from dateutil.parser import parse as parse_datetime
 from django.utils import timezone
 import six
 
-from sentry.api.serializers import Serializer, register
 from sentry.tagstore import TagKeyStatus
 from sentry.tagstore.base import TagStorage
 from sentry.tagstore.exceptions import (
@@ -22,22 +23,24 @@ from sentry.tagstore.exceptions import (
     TagKeyNotFound,
     TagValueNotFound,
 )
+from sentry.tagstore.types import TagKey, TagValue, GroupTagKey, GroupTagValue
 from sentry.utils import snuba
 
 
 SEEN_COLUMN = 'timestamp'
 
 
-class ObjectWrapper(object):
-    def __init__(self, dictionary):
-        dictionary['id'] = 0
-        self.__dict__ = dictionary
+tag_value_data_transformers = {
+    'first_seen': parse_datetime,
+    'last_seen': parse_datetime,
+}
 
 
-@register(ObjectWrapper)
-class ObjectWrapperSerializer(Serializer):
-    def serialize(self, obj, attrs, user):
-        return self.__dict__
+def fix_tag_value_data(data):
+    for key, transformer in tag_value_data_transformers.items():
+        if key in data:
+            data[key] = transformer(data[key])
+    return data
 
 
 class SnubaTagStorage(TagStorage):
@@ -51,25 +54,7 @@ class SnubaTagStorage(TagStorage):
         end = timezone.now()
         return (end - timedelta(days=days), end)
 
-    def get_tag_key(self, project_id, environment_id, key, status=TagKeyStatus.VISIBLE):
-        try:
-            return self.get_group_tag_key(project_id, None, environment_id, key)
-        except GroupTagKeyNotFound:
-            raise TagKeyNotFound
-
-    def get_tag_keys(self, project_id, environment_id, status=TagKeyStatus.VISIBLE):
-        return self.get_group_tag_keys(project_id, None, environment_id)
-
-    def get_tag_value(self, project_id, environment_id, key, value):
-        try:
-            return self.get_group_tag_value(project_id, None, environment_id, key, value)
-        except GroupTagValueNotFound:
-            raise TagValueNotFound
-
-    def get_tag_values(self, project_id, environment_id, key):
-        return self.get_group_tag_values(project_id, None, environment_id, key)
-
-    def get_group_tag_key(self, project_id, group_id, environment_id, key):
+    def __get_tag_key(self, project_id, group_id, environment_id, key):
         start, end = self.get_time_range()
         tag = 'tags[{}]'.format(key)
         filters = {
@@ -79,19 +64,22 @@ class SnubaTagStorage(TagStorage):
         if group_id is not None:
             filters['issue'] = [group_id]
         conditions = [[tag, '!=', '']]
-        aggregations = [['count()', '', 'count']]
+        aggregations = [['uniq', tag, 'unique_values']]
 
         result = snuba.query(start, end, [], conditions, filters, aggregations)
         if result == 0:
-            raise GroupTagKeyNotFound
+            raise TagKeyNotFound if group_id is None else GroupTagKeyNotFound
         else:
-            return ObjectWrapper({
-                'times_seen': result,
+            data = {
                 'key': key,
-                'group_id': group_id,
-            })
-
-    def get_group_tag_keys(self, project_id, group_id, environment_id, limit=1000):
+                'values_seen': result,
+            }
+            if group_id is None:
+                return TagKey(**data)
+            else:
+                return GroupTagKey(group_id=group_id, **data)
+
+    def __get_tag_keys(self, project_id, group_id, environment_id, limit=1000):
         start, end = self.get_time_range()
         filters = {
             'project_id': [project_id],
@@ -99,19 +87,20 @@ class SnubaTagStorage(TagStorage):
         }
         if group_id is not None:
             filters['issue'] = [group_id]
-        aggregations = [['count()', '', 'count']]
+        aggregations = [['uniq', 'tags_value', 'values_seen']]
+
+        result = snuba.query(start, end, ['tags_key'], [], filters,
+                             aggregations, limit=limit, orderby='-values_seen')
 
-        result = snuba.query(start, end, ['tags.key'], [], filters, aggregations,
-                             limit=limit, orderby='-count', arrayjoin='tags')
+        if group_id is None:
+            ctor = TagKey
+        else:
+            ctor = functools.partial(GroupTagKey, group_id=group_id)
 
-        return [ObjectWrapper({
-            'times_seen': count,
-            'key': name,
-            'group_id': group_id,
-        }) for name, count in six.iteritems(result)]
+        return set([ctor(key=key, values_seen=values_seen)
+                    for key, values_seen in six.iteritems(result) if values_seen])
 
-    def get_group_tag_value(self, project_id, group_id, environment_id, key, value):
-        from sentry.tagstore.exceptions import GroupTagValueNotFound
+    def __get_tag_value(self, project_id, group_id, environment_id, key, value):
         start, end = self.get_time_range()
         tag = 'tags[{}]'.format(key)
         filters = {
@@ -120,24 +109,27 @@ class SnubaTagStorage(TagStorage):
         }
         if group_id is not None:
             filters['issue'] = [group_id]
-        conditions = [
-            [tag, '=', value]
+        conditions = [[tag, '=', value]]
+        aggregations = [
+            ['count()', '', 'times_seen'],
+            ['min', SEEN_COLUMN, 'first_seen'],
+            ['max', SEEN_COLUMN, 'last_seen'],
         ]
-        aggregations = [['count()', '', 'count']]
-
-        result = snuba.query(start, end, [], conditions, filters, aggregations)
 
-        if result == 0:
-            raise GroupTagValueNotFound
+        data = snuba.query(start, end, [], conditions, filters, aggregations)
+        if not data['times_seen'] > 0:
+            raise TagValueNotFound if group_id is None else GroupTagValueNotFound
         else:
-            return ObjectWrapper({
-                'times_seen': result,
+            data.update({
                 'key': key,
                 'value': value,
-                'group_id': group_id,
             })
+            if group_id is None:
+                return TagValue(**fix_tag_value_data(data))
+            else:
+                return GroupTagValue(group_id=group_id, **fix_tag_value_data(data))
 
-    def get_group_tag_values(self, project_id, group_id, environment_id, key):
+    def __get_tag_values(self, project_id, group_id, environment_id, key):
         start, end = self.get_time_range()
         tag = 'tags[{}]'.format(key)
         filters = {
@@ -148,22 +140,46 @@ class SnubaTagStorage(TagStorage):
             filters['issue'] = [group_id]
         conditions = [[tag, '!=', '']]
         aggregations = [
-            ['count()', '', 'count'],
+            ['count()', '', 'times_seen'],
             ['min', SEEN_COLUMN, 'first_seen'],
             ['max', SEEN_COLUMN, 'last_seen'],
         ]
 
-        result = snuba.query(start, end, [tag], conditions, filters,
-                             aggregations)
+        result = snuba.query(start, end, [tag], conditions, filters, aggregations)
+
+        if group_id is None:
+            ctor = TagValue
+        else:
+            ctor = functools.partial(GroupTagValue, group_id=group_id)
+
+        return set([ctor(key=key, value=value, **fix_tag_value_data(data))
+                    for value, data in result.items()])
+
+    def get_tag_key(self, project_id, environment_id, key, status=TagKeyStatus.VISIBLE):
+        assert status is TagKeyStatus.VISIBLE
+        return self.__get_tag_key(project_id, None, environment_id, key)
 
-        return [ObjectWrapper({
-            'times_seen': val['count'],
-            'first_seen': val['first_seen'],
-            'last_seen': val['last_seen'],
-            'key': key,
-            'value': name,
-            'group_id': group_id,
-        }) for name, val in six.iteritems(result)]
+    def get_tag_keys(self, project_id, environment_id, status=TagKeyStatus.VISIBLE):
+        assert status is TagKeyStatus.VISIBLE
+        return self.__get_tag_keys(project_id, None, environment_id)
+
+    def get_tag_value(self, project_id, environment_id, key, value):
+        return self.__get_tag_value(project_id, None, environment_id, key, value)
+
+    def get_tag_values(self, project_id, environment_id, key):
+        return self.__get_tag_values(project_id, None, environment_id, key)
+
+    def get_group_tag_key(self, project_id, group_id, environment_id, key):
+        return self.__get_tag_key(project_id, group_id, environment_id, key)
+
+    def get_group_tag_keys(self, project_id, group_id, environment_id, limit=None):
+        return self.__get_tag_keys(project_id, group_id, environment_id, limit=limit)
+
+    def get_group_tag_value(self, project_id, group_id, environment_id, key, value):
+        return self.__get_tag_value(project_id, group_id, environment_id, key, value)
+
+    def get_group_tag_values(self, project_id, group_id, environment_id, key):
+        return self.__get_tag_values(project_id, group_id, environment_id, key)
 
     def get_group_list_tag_value(self, project_id, group_ids, environment_id, key, value):
         start, end = self.get_time_range()
@@ -177,7 +193,7 @@ class SnubaTagStorage(TagStorage):
             [tag, '=', value]
         ]
         aggregations = [
-            ['count()', '', 'count'],
+            ['count()', '', 'times_seen'],
             ['min', SEEN_COLUMN, 'first_seen'],
             ['max', SEEN_COLUMN, 'last_seen'],
         ]
@@ -185,14 +201,13 @@ class SnubaTagStorage(TagStorage):
         result = snuba.query(start, end, ['issue'], conditions, filters, aggregations)
 
         return {
-            issue: ObjectWrapper({
-                'times_seen': val['count'],
-                'first_seen': val['first_seen'],
-                'last_seen': val['last_seen'],
-                'key': key,
-                'value': value,
-                'group_id': issue,
-            }) for issue, val in six.iteritems(result)}
+            issue: GroupTagValue(
+                group_id=issue,
+                key=key,
+                value=value,
+                **fix_tag_value_data(data)
+            ) for issue, data in six.iteritems(result)
+        }
 
     def get_group_tag_value_count(self, project_id, group_id, environment_id, key):
         start, end = self.get_time_range()
@@ -217,60 +232,28 @@ class SnubaTagStorage(TagStorage):
         }
         conditions = [[tag, '!=', '']]
         aggregations = [
-            ['count()', '', 'count'],
+            ['count()', '', 'times_seen'],
             ['min', SEEN_COLUMN, 'first_seen'],
             ['max', SEEN_COLUMN, 'last_seen'],
         ]
 
         result = snuba.query(start, end, [tag], conditions, filters,
-                             aggregations, limit=limit, orderby='-count')
-
-        return [ObjectWrapper({
-            'times_seen': val['count'],
-            'first_seen': val['first_seen'],
-            'last_seen': val['last_seen'],
-            'key': key,
-            'value': name,
-            'group_id': group_id,
-        }) for name, val in six.iteritems(result)]
-
-    def get_group_tag_keys_and_top_values(self, project_id, group_id, environment_id, user=None):
-        from sentry import tagstore
-        start, end = self.get_time_range()
-        filters = {
-            'project_id': [project_id],
-            'environment': [environment_id],
-            'issue': [group_id],
-        }
-        aggregations = [
-            ['count()', '', 'count'],
-            ['topK(10)', 'tags_value', 'top'],
-            ['uniq', 'tags_value', 'uniq'],
-        ]
-        conditions = [
-            ['tags_value', 'IS NOT NULL', None],
+                             aggregations, limit=limit, orderby='-times_seen')
+        return [
+            GroupTagValue(
+                group_id=group_id,
+                key=key,
+                value=value,
+                **fix_tag_value_data(data)
+            ) for value, data in six.iteritems(result)
         ]
-        results = snuba.query(start, end, ['tags_key'], conditions, filters, aggregations)
-
-        return [{
-            'id': key,
-            'name': tagstore.get_tag_key_label(key),
-            'key': tagstore.get_standardized_key(key),
-            'uniqueValues': res['uniq'],
-            'totalValues': res['count'],
-            'topValues': [{
-                'id': val,
-                'name': tagstore.get_tag_value_label(key, val),
-                'key': tagstore.get_standardized_key(key),
-                'value': val,
-            } for val in res['top']],
-        } for key, res in six.iteritems(results)]
-
-    def get_release(self, project_id, group_id, first=True):
+
+    def __get_release(self, project_id, group_id, first=True):
         start, end = self.get_time_range()
         filters = {
             'project_id': [project_id],
         }
+        # XXX: This should be `sentry:release`?
         conditions = [['release', 'IS NOT NULL', None]]
         if group_id is not None:
             filters['issue'] = [group_id]
@@ -285,10 +268,10 @@ class SnubaTagStorage(TagStorage):
             return result.keys()[0]
 
     def get_first_release(self, project_id, group_id):
-        return self.get_release(project_id, group_id, True)
+        return self.__get_release(project_id, group_id, True)
 
     def get_last_release(self, project_id, group_id):
-        return self.get_release(project_id, group_id, False)
+        return self.__get_release(project_id, group_id, False)
 
     def get_release_tags(self, project_ids, environment_id, versions):
         start, end = self.get_time_range()
@@ -299,22 +282,29 @@ class SnubaTagStorage(TagStorage):
         # NB we add release as a condition rather than a filter because
         # this method is already dealing with version strings rather than
         # release ids which would need to be translated by the snuba util.
-        conditions = [['release', 'IN', versions]]
+        # XXX: This should also be `sentry:release`
+        key = 'release'
+        conditions = [[key, 'IN', versions]]
         aggregations = [
-            ['count()', '', 'count'],
+            ['count()', '', 'times_seen'],
             ['min', SEEN_COLUMN, 'first_seen'],
             ['max', SEEN_COLUMN, 'last_seen'],
         ]
 
-        result = snuba.query(start, end, ['release'], conditions, filters, aggregations)
+        result = snuba.query(start, end, ['project_id', key], conditions, filters, aggregations)
+
+        values = []
+        for project_data in six.itervalues(result):
+            for value, data in six.iteritems(project_data):
+                values.append(
+                    TagValue(
+                        key=key,
+                        value=value,
+                        **fix_tag_value_data(data)
+                    )
+                )
 
-        return [ObjectWrapper({
-            'times_seen': val['count'],
-            'first_seen': val['first_seen'],
-            'last_seen': val['last_seen'],
-            'key': 'release',
-            'value': name,
-        }) for name, val in six.iteritems(result)]
+        return set(values)
 
     def get_group_event_ids(self, project_id, group_id, environment_id, tags):
         start, end = self.get_time_range()
@@ -330,7 +320,7 @@ class SnubaTagStorage(TagStorage):
         conditions = [or_conditions]
 
         events = snuba.query(start, end, ['event_id'], conditions, filters)
-        return events.keys()
+        return set(events.keys())
 
     def get_group_ids_for_users(self, project_ids, event_users, limit=100):
         start, end = self.get_time_range()
@@ -363,21 +353,26 @@ class SnubaTagStorage(TagStorage):
         ] if cond[2] != []]
         conditions = [or_conditions]
         aggregations = [
-            ['count()', '', 'count'],
+            ['count()', '', 'times_seen'],
             ['min', SEEN_COLUMN, 'first_seen'],
             ['max', SEEN_COLUMN, 'last_seen'],
         ]
 
-        result = snuba.query(start, end, ['user_id'], conditions, filters,
+        result = snuba.query(start, end, ['issue', 'user_id'], conditions, filters,
                              aggregations, orderby='-last_seen', limit=limit)
 
-        return [ObjectWrapper({
-            'times_seen': val['count'],
-            'first_seen': val['first_seen'],
-            'last_seen': val['last_seen'],
-            'key': 'sentry:user',
-            'value': name,
-        }) for name, val in six.iteritems(result)]
+        values = []
+        for issue, users in six.iteritems(result):
+            for name, data in six.iteritems(users):
+                values.append(
+                    GroupTagValue(
+                        group_id=issue,
+                        key='sentry:user',
+                        value=name,
+                        **fix_tag_value_data(data)
+                    )
+                )
+        return values
 
     def get_groups_user_counts(self, project_id, group_ids, environment_id):
         start, end = self.get_time_range()
@@ -389,105 +384,8 @@ class SnubaTagStorage(TagStorage):
         aggregations = [['uniq', 'user_id', 'count']]
 
         result = snuba.query(start, end, ['issue'], None, filters, aggregations)
-        return defaultdict(int, result.items())
+        return defaultdict(int, {k: v for k, v in result.items() if v})
 
     def get_group_ids_for_search_filter(
             self, project_id, environment_id, tags, candidates=None, limit=1000):
         raise NotImplementedError
-
-    # Everything from here down is basically no-ops
-    def create_tag_key(self, project_id, environment_id, key, **kwargs):
-        return ObjectWrapper({
-            'times_seen': 0,
-            'key': key,
-            'update': lambda *args, **kwargs: None
-        })
-
-    def get_or_create_tag_key(self, project_id, environment_id, key, **kwargs):
-        try:
-            return self.get_tag_key(project_id, environment_id, key)
-        except TagKeyNotFound:
-            return (self.create_tag_key(project_id, environment_id, key, **kwargs), True)
-
-    def create_tag_value(self, project_id, environment_id, key, value, **kwargs):
-        return ObjectWrapper({
-            'times_seen': 0,
-            'key': key,
-            'value': value,
-            'update': lambda *args, **kwargs: None
-        })
-
-    def get_or_create_tag_value(self, project_id, environment_id, key, value, **kwargs):
-        try:
-            return self.get_tag_value(project_id, environment_id, key, value)
-        except TagValueNotFound:
-            return (self.create_tag_value(project_id, environment_id, key, value, **kwargs), True)
-
-    def create_group_tag_key(self, project_id, group_id, environment_id, key, **kwargs):
-        return ObjectWrapper({
-            'times_seen': 0,
-            'key': key,
-            'group_id': group_id,
-            'update': lambda *args, **kwargs: None
-        })
-
-    def get_or_create_group_tag_key(self, project_id, group_id, environment_id, key, **kwargs):
-        try:
-            return self.get_group_tag_key(project_id, group_id, environment_id, key)
-        except GroupTagKeyNotFound:
-            return (self.create_group_tag_key(
-                project_id, group_id, environment_id, key, **kwargs), True)
-
-    def create_group_tag_value(self, project_id, group_id, environment_id,
-                               key, value, **kwargs):
-        return ObjectWrapper({
-            'times_seen': 0,
-            'key': key,
-            'value': value,
-            'group_id': group_id,
-            'update': lambda *args, **kwargs: None
-        })
-
-    def get_or_create_group_tag_value(self, project_id, group_id,
-                                      environment_id, key, value, **kwargs):
-        try:
-            return self.get_group_tag_value(project_id, group_id, environment_id, key, value)
-        except GroupTagValueNotFound:
-            return (self.create_group_tag_value(project_id, group_id,
-                                                environment_id, key, value, **kwargs), True)
-
-    def create_event_tags(self, project_id, group_id, environment_id,
-                          event_id, tags, date_added=None):
-        pass
-
-    def delete_tag_key(self, project_id, key):
-        return []
-
-    def delete_all_group_tag_keys(self, project_id, group_id):
-        pass
-
-    def delete_all_group_tag_values(self, project_id, group_id):
-        pass
-
-    def incr_tag_value_times_seen(self, project_id, environment_id,
-                                  key, value, extra=None, count=1):
-        pass
-
-    def incr_group_tag_value_times_seen(self, project_id, group_id, environment_id,
-                                        key, value, extra=None, count=1):
-        pass
-
-    def update_group_for_events(self, project_id, event_ids, destination_id):
-        pass
-
-    def update_group_tag_key_values_seen(self, project_id, group_ids):
-        pass
-
-    def get_tag_value_qs(self, project_id, environment_id, key, query=None):
-        raise NotImplementedError
-
-    def get_group_tag_value_qs(self, project_id, group_id, environment_id, key, value=None):
-        raise NotImplementedError
-
-    def get_event_tag_qs(self, project_id, environment_id, key, value):
-        raise NotImplementedError
diff --git a/tests/snuba/tagstore/test_tagstore_backend.py b/tests/snuba/tagstore/test_tagstore_backend.py
index d60b813f57..b4b4531f32 100644
--- a/tests/snuba/tagstore/test_tagstore_backend.py
+++ b/tests/snuba/tagstore/test_tagstore_backend.py
@@ -1,13 +1,14 @@
 from __future__ import absolute_import
 
 import calendar
-from datetime import datetime, timedelta
+from datetime import timedelta
 import json
 import pytest
 import requests
 import six
 
 from django.conf import settings
+from django.utils import timezone
 
 from sentry.models import GroupHash, EventUser
 from sentry.tagstore.exceptions import (
@@ -37,7 +38,7 @@ class TagStorage(TestCase):
         GroupHash.objects.create(project=self.proj1, group=self.proj1group1, hash=hash1)
         GroupHash.objects.create(project=self.proj1, group=self.proj1group2, hash=hash2)
 
-        self.now = datetime.utcnow().replace(microsecond=0)
+        self.now = timezone.now().replace(microsecond=0)
         data = json.dumps([{
             'event_id': six.text_type(r) * 32,
             'primary_hash': hash1,
@@ -80,24 +81,28 @@ class TagStorage(TestCase):
         assert requests.post(settings.SENTRY_SNUBA + '/tests/insert', data=data).status_code == 200
 
     def test_get_group_tag_keys_and_top_values(self):
+        # TODO: `release` should be `sentry:release`
         result = self.ts.get_group_tag_keys_and_top_values(
             self.proj1.id,
             self.proj1group1.id,
             self.proj1env1.id,
         )
-        tags = [r['id'] for r in result]
+        tags = [r['key'] for r in result]
         assert set(tags) == set(['foo', 'baz', 'environment', 'release'])
 
-        result.sort(key=lambda r: r['id'])
-        assert result[0]['id'] == 'baz'
+        result.sort(key=lambda r: r['key'])
+        assert result[0]['key'] == 'baz'
         assert result[0]['uniqueValues'] == 1
         assert result[0]['totalValues'] == 2
         assert result[0]['topValues'][0]['value'] == 'quux'
 
-        assert result[3]['id'] == 'release'
+        assert result[3]['key'] == 'release'
         assert result[3]['uniqueValues'] == 2
         assert result[3]['totalValues'] == 2
-        assert result[3]['topValues'][0]['value'] == '100'
+        top_release_values = result[3]['topValues']
+        assert len(top_release_values) == 2
+        assert set(v['value'] for v in top_release_values) == set(['100', '200'])
+        assert all(v['count'] == 1 for v in top_release_values)
 
     def test_get_top_group_tag_values(self):
         resp = self.ts.get_top_group_tag_values(
@@ -137,17 +142,19 @@ class TagStorage(TestCase):
             key='foo',
         ).key == 'foo'
 
-        keys = self.ts.get_group_tag_keys(
-            project_id=self.proj1.id,
-            group_id=self.proj1group1.id,
-            environment_id=self.proj1env1.id,
-        )
-        keys.sort(key=lambda x: x.key)
-        assert len(keys) == 2
-        assert keys[0].key == 'baz'
-        assert keys[0].times_seen == 2
-        assert keys[1].key == 'foo'
-        assert keys[1].times_seen == 2
+        keys = {
+            k.key: k for k in self.ts.get_group_tag_keys(
+                project_id=self.proj1.id,
+                group_id=self.proj1group1.id,
+                environment_id=self.proj1env1.id,
+            )
+        }
+        assert len(keys) == 4
+        assert set(keys) == set(['baz', 'environment', 'foo', 'sentry:release'])
+        for k in keys.values():
+            if k.key != 'sentry:release':
+                assert k.values_seen == 1, 'expected {!r} to have 1 unique value'.format(k.key)
+        assert keys['sentry:release'].values_seen == 2
 
     def test_get_group_tag_value(self):
         with pytest.raises(GroupTagValueNotFound):
@@ -164,14 +171,14 @@ class TagStorage(TestCase):
             group_id=self.proj1group1.id,
             environment_id=self.proj1env1.id,
             key='notreal',
-        ) == []
+        ) == set([])
 
-        assert self.ts.get_group_tag_values(
+        assert list(self.ts.get_group_tag_values(
             project_id=self.proj1.id,
             group_id=self.proj1group1.id,
             environment_id=self.proj1env1.id,
             key='foo',
-        )[0].value == 'bar'
+        ))[0].value == 'bar'
 
         assert self.ts.get_group_tag_value(
             project_id=self.proj1.id,
@@ -244,18 +251,22 @@ class TagStorage(TestCase):
         result = self.ts.get_group_tag_values_for_users(
             [EventUser(project_id=self.proj1.id, ident='user1')]
         )
-        one_second_ago = (self.now - timedelta(seconds=1)).strftime('%Y-%m-%dT%H:%M:%S+00:00')
-        assert len(result) == 1
-        assert result[0].value == 'user1'
-        assert result[0].last_seen == one_second_ago
+        assert len(result) == 2
+        assert set(v.group_id for v in result) == set([
+            self.proj1group1.id,
+            self.proj1group2.id,
+        ])
+        assert result[0].last_seen == self.now - timedelta(seconds=1)
+        assert result[1].last_seen == self.now - timedelta(seconds=2)
+        for v in result:
+            assert v.value == 'user1'
 
         result = self.ts.get_group_tag_values_for_users(
             [EventUser(project_id=self.proj1.id, ident='user2')]
         )
-        two_seconds_ago = (self.now - timedelta(seconds=2)).strftime('%Y-%m-%dT%H:%M:%S+00:00')
         assert len(result) == 1
         assert result[0].value == 'user2'
-        assert result[0].last_seen == two_seconds_ago
+        assert result[0].last_seen == self.now - timedelta(seconds=2)
 
         # Test that users identified by different means are collected.
         # (effectively tests OR conditions in snuba API)
@@ -263,38 +274,39 @@ class TagStorage(TestCase):
             EventUser(project_id=self.proj1.id, email='user1@sentry.io'),
             EventUser(project_id=self.proj1.id, ident='user2')
         ])
-        two_seconds_ago = (self.now - timedelta(seconds=2)).strftime('%Y-%m-%dT%H:%M:%S+00:00')
         assert len(result) == 2
         result.sort(key=lambda x: x.value)
         assert result[0].value == 'user1'
-        assert result[0].last_seen == one_second_ago
+        assert result[0].last_seen == self.now - timedelta(seconds=1)
         assert result[1].value == 'user2'
-        assert result[1].last_seen == two_seconds_ago
+        assert result[1].last_seen == self.now - timedelta(seconds=2)
 
     def test_get_release_tags(self):
-        tags = self.ts.get_release_tags(
-            [self.proj1.id],
-            None,
-            ['100']
+        tags = list(
+            self.ts.get_release_tags(
+                [self.proj1.id],
+                None,
+                ['100']
+            )
         )
 
         assert len(tags) == 1
-        one_second_ago = (self.now - timedelta(seconds=1)).strftime('%Y-%m-%dT%H:%M:%S+00:00')
+        one_second_ago = self.now - timedelta(seconds=1)
         assert tags[0].last_seen == one_second_ago
         assert tags[0].first_seen == one_second_ago
         assert tags[0].times_seen == 1
 
     def test_get_group_event_ids(self):
-        assert sorted(self.ts.get_group_event_ids(
+        assert set(self.ts.get_group_event_ids(
             self.proj1.id,
             self.proj1group1.id,
             self.proj1env1.id,
             {
                 'foo': 'bar',
             }
-        )) == ["1" * 32, "2" * 32]
+        )) == set(["1" * 32, "2" * 32])
 
-        assert sorted(self.ts.get_group_event_ids(
+        assert set(self.ts.get_group_event_ids(
             self.proj1.id,
             self.proj1group1.id,
             self.proj1env1.id,
@@ -302,22 +314,22 @@ class TagStorage(TestCase):
                 'foo': 'bar',  # OR
                 'release': '200'
             }
-        )) == ["1" * 32, "2" * 32]
+        )) == set(["1" * 32, "2" * 32])
 
-        assert self.ts.get_group_event_ids(
+        assert set(self.ts.get_group_event_ids(
             self.proj1.id,
             self.proj1group2.id,
             self.proj1env1.id,
             {
                 'browser': 'chrome'
             }
-        ) == ["3" * 32]
+        )) == set(["3" * 32])
 
-        assert self.ts.get_group_event_ids(
+        assert set(self.ts.get_group_event_ids(
             self.proj1.id,
             self.proj1group2.id,
             self.proj1env1.id,
             {
                 'browser': 'ie'
             }
-        ) == []
+        )) == set([])

commit 1610a677dd1b4385c7ea7375920717b0061d0c29
Author: Stephen Cefali <scefali@sentry.io>
Date:   Wed Jun 24 15:47:59 2020 -0700

    feat(vercel): generate release from deployment webhook (#19513)

diff --git a/src/sentry/integrations/vercel/webhook.py b/src/sentry/integrations/vercel/webhook.py
index da79e55dd9..5eb2b06947 100644
--- a/src/sentry/integrations/vercel/webhook.py
+++ b/src/sentry/integrations/vercel/webhook.py
@@ -1,14 +1,24 @@
 from __future__ import absolute_import
 
-import six
-import hmac
 import hashlib
+import hmac
 import logging
+import six
 
-from django.utils.crypto import constant_time_compare
 from django.views.decorators.csrf import csrf_exempt
-from sentry import options
+from django.utils.crypto import constant_time_compare
+from requests.exceptions import RequestException
+from sentry import http, options
 from sentry.api.base import Endpoint
+from sentry.models import (
+    OrganizationIntegration,
+    SentryAppInstallationForProvider,
+    SentryAppInstallationToken,
+    Project,
+)
+from sentry.shared_integrations.exceptions import IntegrationError
+from sentry.utils.http import absolute_uri
+from sentry.utils.compat import filter
 from sentry.web.decorators import transaction_start
 
 logger = logging.getLogger("sentry.integrations.vercel.webhooks")
@@ -27,11 +37,62 @@ def verify_signature(request):
 class VercelWebhookEndpoint(Endpoint):
     authentication_classes = ()
     permission_classes = ()
+    provider = "vercel"
 
     @csrf_exempt
     def dispatch(self, request, *args, **kwargs):
         return super(VercelWebhookEndpoint, self).dispatch(request, *args, **kwargs)
 
+    # given the webhook payload and sentry_project_id, return
+    # the payload we use for generating the release with the token
+    def get_payload_and_token(self, payload, organization_id, sentry_project_id):
+        meta = payload["deployment"]["meta"]
+
+        # look up the project so we can get the slug
+        project = Project.objects.get(id=sentry_project_id)
+
+        # find the connected sentry app installation
+        installation_for_provider = SentryAppInstallationForProvider.objects.select_related(
+            "sentry_app_installation"
+        ).get(organization_id=organization_id, provider=self.provider)
+        sentry_app_installation = installation_for_provider.sentry_app_installation
+
+        # find a token associated with the installation so we can use it for authentication
+        sentry_app_installation_token = (
+            SentryAppInstallationToken.objects.select_related("api_token")
+            .filter(sentry_app_installation=sentry_app_installation)
+            .first()
+        )
+        if not sentry_app_installation_token:
+            raise SentryAppInstallationToken.DoesNotExist()
+
+        # find the commmit sha so we can  use it as as the release
+        commit_sha = (
+            meta.get("githubCommitSha")
+            or meta.get("gitlabCommitSha")
+            or meta.get("bitbucketCommitSha")
+        )
+
+        # contruct the repo depeding what provider we use
+        if meta.get("githubCommitSha"):
+            # we use these instead of githubOrg and githubRepo since it's the repo the user has access to
+            repository = u"%s/%s" % (meta["githubCommitOrg"], meta["githubCommitRepo"])
+        elif meta.get("gitlabCommitSha"):
+            # gitlab repos are formatted with a space for some reason
+            repository = u"%s / %s" % (meta["gitlabProjectNamespace"], meta["gitlabProjectName"],)
+        elif meta.get("bitbucketCommitSha"):
+            repository = u"%s/%s" % (meta["bitbucketRepoOwner"], meta["bitbucketRepoName"])
+        else:
+            # this should really never happen
+            raise IntegrationError("No commit found")
+
+        release_payload = {
+            "version": commit_sha,
+            "projects": [project.slug],
+            "refs": [{"repository": repository, "commit": commit_sha}],
+        }
+        return [release_payload, sentry_app_installation_token.api_token.token]
+
     @transaction_start("VercelWebhookEndpoint")
     def post(self, request):
         if not request.META.get("HTTP_X_ZEIT_SIGNATURE"):
@@ -44,4 +105,102 @@ class VercelWebhookEndpoint(Endpoint):
             logger.error("vercel.webhook.invalid-signature")
             return self.respond(status=401)
 
-        return self.respond(status=200)
+        data = request.data
+        payload = data["payload"]
+        external_id = data.get("teamId") or data["userId"]
+        vercel_project_id = payload["projectId"]
+
+        logging_params = {"external_id": external_id, "vercel_project_id": vercel_project_id}
+
+        if payload["target"] != "production":
+            logger.info(
+                "Ignoring deployment for environment: %s" % payload["target"], extra=logging_params
+            )
+            return self.respond(status=202)
+
+        # Steps:
+        # 1. Find all org integrations that match the external id
+        # 2. Search the configs to find one that matches the vercel project of the webhook
+        # 3. Look up the Sentry project that matches
+        # 4. Look up the connected internal integration
+        # 5. Find the token associated with that installation
+        # 6. Determine the commit sha and repo based on what provider is used
+        # 7. Create the release using the token WITHOUT refs
+        # 8. Update the release with refs
+
+        # find all org integrations that match the external id
+        org_integrations = OrganizationIntegration.objects.select_related("organization").filter(
+            integration__external_id=external_id, integration__provider=self.provider
+        )
+        if not org_integrations:
+            logger.info("Integration not found", extra=logging_params)
+            return self.respond({"detail": "Integration not found"}, status=404)
+
+        # for each org integration, search the configs to find one that matches the vercel project of the webhook
+        for org_integration in org_integrations:
+            project_mappings = org_integration.config.get("project_mappings") or []
+            matched_mappings = filter(lambda x: x[1] == vercel_project_id, project_mappings)
+            if matched_mappings:
+                organization = org_integration.organization
+                sentry_project_id = matched_mappings[0][0]
+
+                logging_params["organization_id"] = organization.id
+                logging_params["project_id"] = sentry_project_id
+
+                try:
+                    [release_payload, token] = self.get_payload_and_token(
+                        payload, organization.id, sentry_project_id
+                    )
+                except Project.DoesNotExist:
+                    logger.info("Project not found", extra=logging_params)
+                    return self.respond({"detail": "Project not found"}, status=404)
+                except SentryAppInstallationForProvider.DoesNotExist:
+                    logger.info("Installation not found", extra=logging_params)
+                    return self.respond({"detail": "Installation not found"}, status=404)
+                except SentryAppInstallationToken.DoesNotExist:
+                    logger.info("Token not found", extra=logging_params)
+                    return self.respond({"detail": "Token not found"}, status=404)
+
+                session = http.build_session()
+                url = absolute_uri("/api/0/organizations/%s/releases/" % organization.slug)
+                headers = {
+                    "Accept": "application/json",
+                    "Authorization": "Bearer %s" % token,
+                }
+                json_error = None
+
+                # create the basic release payload without refs
+                no_ref_payload = release_payload.copy()
+                del no_ref_payload["refs"]
+                try:
+                    resp = session.post(url, json=no_ref_payload, headers=headers)
+                    json_error = resp.json()
+                    resp.raise_for_status()
+                except RequestException as e:
+                    # errors here should be uncommon but we should be aware of them
+                    logger.error(
+                        "Error creating release: %s - %s" % (e, json_error),
+                        extra=logging_params,
+                        exc_info=True,
+                    )
+                    # 400 probably isn't the right status code but oh well
+                    return self.respond({"detail": "Error creating release: %s" % e}, status=400)
+
+                # set the refs
+                try:
+                    resp = session.post(url, json=release_payload, headers=headers,)
+                    json_error = resp.json()
+                    resp.raise_for_status()
+                except RequestException as e:
+                    # errors will probably be common if the user doesn't have repos set up
+                    logger.info(
+                        "Error setting refs: %s - %s" % (e, json_error),
+                        extra=logging_params,
+                        exc_info=True,
+                    )
+                    # 400 probably isn't the right status code but oh well
+                    return self.respond({"detail": "Error setting refs: %s" % e}, status=400)
+
+                # we are going to quit after the first project match as there shouldn't be multiple matches
+                return self.respond(status=201)
+        return self.respond(status=202)
diff --git a/src/sentry/static/sentry/app/views/settings/components/forms/projectMapperField.tsx b/src/sentry/static/sentry/app/views/settings/components/forms/projectMapperField.tsx
index f25e8b60e8..9a4934df31 100644
--- a/src/sentry/static/sentry/app/views/settings/components/forms/projectMapperField.tsx
+++ b/src/sentry/static/sentry/app/views/settings/components/forms/projectMapperField.tsx
@@ -62,7 +62,8 @@ export class RenderField extends React.Component<RenderProps> {
     const renderItem = (itemTuple: [number, any]) => {
       const [projectId, mappedValue] = itemTuple;
       const {slug} = sentryProjectsById[projectId];
-      const {label: itemLabel} = mappedItemsByValue[mappedValue];
+      // TODO: add special formatting if deleted
+      const {label: itemLabel} = mappedItemsByValue[mappedValue] || {label: 'Deleted'};
       return (
         <Item key={projectId}>
           <ItemValue>{slug}</ItemValue> <ItemValue>{itemLabel}</ItemValue>
diff --git a/tests/sentry/integrations/vercel/test_webhook.py b/tests/sentry/integrations/vercel/test_webhook.py
index ec1083130c..1d6619fff5 100644
--- a/tests/sentry/integrations/vercel/test_webhook.py
+++ b/tests/sentry/integrations/vercel/test_webhook.py
@@ -1,7 +1,19 @@
 from __future__ import absolute_import
 
+import responses
+
+
+from sentry.models import (
+    Integration,
+    OrganizationIntegration,
+    SentryAppInstallationForProvider,
+    SentryAppInstallation,
+    SentryAppInstallationToken,
+)
 from sentry.testutils import APITestCase
 from sentry.testutils.helpers import override_options
+from sentry.utils import json
+from sentry.utils.http import absolute_uri
 
 from .testutils import EXAMPLE_DEPLOYMENT_WEBHOOK_RESPONSE
 
@@ -9,32 +21,241 @@ signature = "74b587857986545361e8a4253b74cd6224d34869"
 secret = "AiK52QASLJXmCXX3X9gO2Zyh"
 
 
-class VercelWebhookTest(APITestCase):
-    def setUp(self):
-        self.url = "/extensions/vercel/webhook/"
+webhook_url = "/extensions/vercel/webhook/"
 
+
+class SignatureVercelTest(APITestCase):
     def test_get(self):
-        response = self.client.get(self.url)
+        response = self.client.get(webhook_url)
         assert response.status_code == 405
 
-    def test_valid_signature(self):
+    def test_invalid_signature(self):
         with override_options({"vercel.client-secret": secret}):
             response = self.client.post(
-                path=self.url,
+                path=webhook_url,
+                data=EXAMPLE_DEPLOYMENT_WEBHOOK_RESPONSE,
+                content_type="application/json",
+                HTTP_X_ZEIT_SIGNATURE="xxxinvalidsignaturexxx",
+            )
+
+            assert response.status_code == 401
+
+
+class VercelReleasesTest(APITestCase):
+    def setUp(self):
+        super(VercelReleasesTest, self).setUp()
+        self.project = self.create_project(organization=self.organization)
+        self.integration = Integration.objects.create(
+            provider="vercel",
+            external_id="cstd1xKmLGVMed0z0f3SHlD2",
+            metadata={"access_token": "my_token"},
+        )
+
+        self.org_integration = OrganizationIntegration.objects.create(
+            organization=self.organization,
+            integration=self.integration,
+            config={
+                "project_mappings": [
+                    [self.project.id, "QmQPfU4xn5APjEsSje4ccPcSJCmVAByA8CDKfZRhYyVPAg"]
+                ]
+            },
+        )
+
+        self.sentry_app = self.create_internal_integration(
+            webhook_url=None, name="Vercel Internal Integration", organization=self.organization,
+        )
+        sentry_app_installation = SentryAppInstallation.objects.get(sentry_app=self.sentry_app)
+        self.installation_for_provider = SentryAppInstallationForProvider.objects.create(
+            organization=self.organization,
+            provider="vercel",
+            sentry_app_installation=sentry_app_installation,
+        )
+
+    @responses.activate
+    def test_create_release(self):
+        responses.add(
+            responses.POST,
+            absolute_uri("/api/0/organizations/%s/releases/" % self.organization.slug),
+            json={},
+        )
+
+        with override_options({"vercel.client-secret": secret}):
+            response = self.client.post(
+                path=webhook_url,
                 data=EXAMPLE_DEPLOYMENT_WEBHOOK_RESPONSE,
                 content_type="application/json",
                 HTTP_X_ZEIT_SIGNATURE=signature,
             )
 
-            assert response.status_code == 200
+            assert response.status_code == 201
+
+            assert len(responses.calls) == 2
+            release_body = json.loads(responses.calls[0].request.body)
+            set_refs_body = json.loads(responses.calls[1].request.body)
+            assert release_body == {
+                "projects": [self.project.slug],
+                "version": "7488658dfcf24d9b735e015992b316e2a8340d9d",
+            }
+            assert set_refs_body == {
+                "projects": [self.project.slug],
+                "version": "7488658dfcf24d9b735e015992b316e2a8340d9d",
+                "refs": [
+                    {
+                        "commit": "7488658dfcf24d9b735e015992b316e2a8340d9d",
+                        "repository": "MeredithAnya/nextjsblog-demo",
+                    }
+                ],
+            }
+
+    @responses.activate
+    def test_no_match(self):
+        responses.add(
+            responses.POST,
+            absolute_uri("/api/0/organizations/%s/releases/" % self.organization.slug),
+            json={},
+        )
+
+        self.org_integration.config = {}
+        self.org_integration.save()
 
-    def test_invalid_signature(self):
         with override_options({"vercel.client-secret": secret}):
             response = self.client.post(
-                path=self.url,
+                path=webhook_url,
                 data=EXAMPLE_DEPLOYMENT_WEBHOOK_RESPONSE,
                 content_type="application/json",
-                HTTP_X_ZEIT_SIGNATURE="xxxinvalidsignaturexxx",
+                HTTP_X_ZEIT_SIGNATURE=signature,
             )
 
-            assert response.status_code == 401
+            assert len(responses.calls) == 0
+            assert response.status_code == 202
+
+    @responses.activate
+    def test_no_integration(self):
+        responses.add(
+            responses.POST,
+            absolute_uri("/api/0/organizations/%s/releases/" % self.organization.slug),
+            json={},
+        )
+        self.integration.delete()
+
+        with override_options({"vercel.client-secret": secret}):
+            response = self.client.post(
+                path=webhook_url,
+                data=EXAMPLE_DEPLOYMENT_WEBHOOK_RESPONSE,
+                content_type="application/json",
+                HTTP_X_ZEIT_SIGNATURE=signature,
+            )
+
+            assert len(responses.calls) == 0
+            assert response.status_code == 404
+            assert response.data["detail"] == "Integration not found"
+
+    @responses.activate
+    def test_no_project(self):
+        responses.add(
+            responses.POST,
+            absolute_uri("/api/0/organizations/%s/releases/" % self.organization.slug),
+            json={},
+        )
+        self.project.delete()
+
+        with override_options({"vercel.client-secret": secret}):
+            response = self.client.post(
+                path=webhook_url,
+                data=EXAMPLE_DEPLOYMENT_WEBHOOK_RESPONSE,
+                content_type="application/json",
+                HTTP_X_ZEIT_SIGNATURE=signature,
+            )
+
+            assert len(responses.calls) == 0
+            assert response.status_code == 404
+            assert response.data["detail"] == "Project not found"
+
+    @responses.activate
+    def test_no_installation(self):
+        responses.add(
+            responses.POST,
+            absolute_uri("/api/0/organizations/%s/releases/" % self.organization.slug),
+            json={},
+        )
+        self.installation_for_provider.delete()
+
+        with override_options({"vercel.client-secret": secret}):
+            response = self.client.post(
+                path=webhook_url,
+                data=EXAMPLE_DEPLOYMENT_WEBHOOK_RESPONSE,
+                content_type="application/json",
+                HTTP_X_ZEIT_SIGNATURE=signature,
+            )
+
+            assert len(responses.calls) == 0
+            assert response.status_code == 404
+            assert response.data["detail"] == "Installation not found"
+
+    @responses.activate
+    def test_no_token(self):
+        responses.add(
+            responses.POST,
+            absolute_uri("/api/0/organizations/%s/releases/" % self.organization.slug),
+            json={},
+        )
+
+        SentryAppInstallationToken.objects.filter().delete()
+
+        with override_options({"vercel.client-secret": secret}):
+            response = self.client.post(
+                path=webhook_url,
+                data=EXAMPLE_DEPLOYMENT_WEBHOOK_RESPONSE,
+                content_type="application/json",
+                HTTP_X_ZEIT_SIGNATURE=signature,
+            )
+
+            assert len(responses.calls) == 0
+            assert response.status_code == 404
+            assert response.data["detail"] == "Token not found"
+
+    @responses.activate
+    def test_create_release_fails(self):
+        responses.add(
+            responses.POST,
+            absolute_uri("/api/0/organizations/%s/releases/" % self.organization.slug),
+            json={},
+            status=400,
+        )
+
+        with override_options({"vercel.client-secret": secret}):
+            response = self.client.post(
+                path=webhook_url,
+                data=EXAMPLE_DEPLOYMENT_WEBHOOK_RESPONSE,
+                content_type="application/json",
+                HTTP_X_ZEIT_SIGNATURE=signature,
+            )
+
+            assert len(responses.calls) == 1
+            assert response.status_code == 400
+            assert "Error creating release" in response.data["detail"]
+
+    @responses.activate
+    def test_set_refs_failed(self):
+        def request_callback(request):
+            payload = json.loads(request.body)
+            status_code = 400 if payload.get("refs") else 200
+            return (status_code, {}, {})
+
+        responses.add_callback(
+            responses.POST,
+            absolute_uri("/api/0/organizations/%s/releases/" % self.organization.slug),
+            callback=request_callback,
+        )
+
+        with override_options({"vercel.client-secret": secret}):
+            response = self.client.post(
+                path=webhook_url,
+                data=EXAMPLE_DEPLOYMENT_WEBHOOK_RESPONSE,
+                content_type="application/json",
+                HTTP_X_ZEIT_SIGNATURE=signature,
+            )
+
+            assert len(responses.calls) == 2
+            assert response.status_code == 400
+            assert "Error setting refs" in response.data["detail"]

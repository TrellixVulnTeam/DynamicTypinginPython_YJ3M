commit eddf1323cf71b4b18ec3138c2a8842cddaa8fdec
Author: David Cramer <dcramer@gmail.com>
Date:   Sat Apr 19 19:55:22 2014 -0700

    Remove plugin.is_rate_limited behavior

diff --git a/CHANGES b/CHANGES
index 82e7c5db19..5857b6e3a9 100644
--- a/CHANGES
+++ b/CHANGES
@@ -3,6 +3,7 @@ Version 7.0.0
 
 - The buffer API has been rewritten and the Redis buffer has had its performance greatly improved.
 - The UDP server has been removed. Threaded/async models are the preferred replacement.
+- The ``is_rate_limited`` plugin hook has been removed in favor of singular quota managers.
 
 Version 6.4.0
 -------------
diff --git a/src/sentry/plugins/base.py b/src/sentry/plugins/base.py
index 7f7fc2ee21..a191f3ff2a 100644
--- a/src/sentry/plugins/base.py
+++ b/src/sentry/plugins/base.py
@@ -16,7 +16,6 @@ from django.http import HttpResponseRedirect, HttpResponse
 
 from sentry.utils.managers import InstanceManager
 from sentry.utils.safe import safe_execute
-from sentry.quotas.base import NotRateLimited
 from threading import local
 
 
@@ -427,14 +426,6 @@ class IPlugin(local):
 
     # Server side signals which do not have request context
 
-    def is_rate_limited(self, project, **kwargs):
-        """
-        Return a ``RateLimit`` object which indicates if this project
-        (or the system) is over any defined quotas, and specifies how
-        long until the quota has expired so it's safe to try again.
-        """
-        return NotRateLimited
-
     def has_perm(self, user, perm, *objects, **kwargs):
         """
         Given a user, a permission name, and an optional list of objects
diff --git a/src/sentry/web/api.py b/src/sentry/web/api.py
index 9236795197..0262f00ce3 100644
--- a/src/sentry/web/api.py
+++ b/src/sentry/web/api.py
@@ -313,19 +313,8 @@ class StoreView(APIView):
         if isinstance(rate_limit, bool):
             rate_limit = RateLimit(is_limited=rate_limit, retry_after=None)
 
-        rate_limits = [rate_limit]
-        for plugin in plugins.all():
-            rate_limit = safe_execute(plugin.is_rate_limited, project=project)
-            if rate_limit is None:
-                continue
-
-            # We must handle the case of plugins not returning new RateLimit objects
-            if isinstance(rate_limit, bool):
-                rate_limit = RateLimit(is_limited=rate_limit, retry_after=None)
-            rate_limits.append(rate_limit)
-
-        if any(limit.is_limited for limit in rate_limits):
-            raise APIRateLimited(max(limit.retry_after for limit in rate_limits))
+        if rate_limit.is_limited:
+            raise APIRateLimited(rate_limit.retry_after)
 
         result = plugins.first('has_perm', request.user, 'create_event', project)
         if result is False:

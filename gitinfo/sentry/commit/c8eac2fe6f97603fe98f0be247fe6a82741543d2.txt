commit c8eac2fe6f97603fe98f0be247fe6a82741543d2
Author: Ted Kaemming <ted@kaemming.com>
Date:   Wed Feb 24 15:58:32 2016 -0800

    Ensure that rollups exist and satisfy range constraints.

diff --git a/src/sentry/api/base.py b/src/sentry/api/base.py
index b389bac396..715e371b4b 100644
--- a/src/sentry/api/base.py
+++ b/src/sentry/api/base.py
@@ -194,7 +194,7 @@ class StatsMixin(object):
         if resolution:
             resolution = self._parse_resolution(resolution)
 
-            assert any(r for r in tsdb.rollups if r[0] == resolution)
+            assert any(r for r in tsdb.rollups.items() if r[0] == resolution)
 
         end = request.GET.get('until')
         if end:
diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index a29f27217a..f3f75d47b2 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -761,7 +761,6 @@ SENTRY_SEARCH_OPTIONS = {}
 SENTRY_TSDB = 'sentry.tsdb.dummy.DummyTSDB'
 SENTRY_TSDB_OPTIONS = {}
 
-# rollups must be ordered from highest granularity to lowest
 SENTRY_TSDB_ROLLUPS = (
     # (time in seconds, samples to keep)
     (10, 360),  # 60 minutes at 10 seconds
diff --git a/src/sentry/tsdb/base.py b/src/sentry/tsdb/base.py
index 257f016229..e12738e558 100644
--- a/src/sentry/tsdb/base.py
+++ b/src/sentry/tsdb/base.py
@@ -7,6 +7,8 @@ sentry.tsdb.base
 """
 from __future__ import absolute_import
 
+from collections import OrderedDict
+from datetime import timedelta
 from django.conf import settings
 from django.utils import timezone
 from enum import Enum
@@ -67,7 +69,7 @@ class BaseTSDB(object):
     models = TSDBModel
 
     def __init__(self, rollups=settings.SENTRY_TSDB_ROLLUPS):
-        self.rollups = rollups
+        self.rollups = OrderedDict(sorted(rollups, key=lambda (duration, samples): duration))
 
     def validate(self):
         """
@@ -106,18 +108,25 @@ class BaseTSDB(object):
         """
         return int(epoch / seconds)
 
-    def get_optimal_rollup(self, start_timestamp, end_timestamp):
+    def get_optimal_rollup(self, start_timestamp, end_timestamp, rollup=None):
         """
-        Identify the lowest granularity rollup available within the given time
-        range.
         """
-        num_seconds = int(to_timestamp(end_timestamp)) - int(to_timestamp(start_timestamp))
+        now = timezone.now()
 
-        # calculate the highest rollup within time range
-        for rollup, samples in self.rollups:
-            if rollup * samples >= num_seconds:
-                return rollup
-        return self.rollups[-1][0]
+        def satisfies_range((duration, samples)):
+            retention = timedelta(seconds=duration * samples)
+            return start_timestamp >= (now - retention)
+
+        if rollup is None:
+            rollups = filter(satisfies_range, self.rollups.items())
+            assert rollups, 'could not find rollup that satisfies range'
+            rollup = rollups[0][0]
+        else:
+            samples = self.rollups.get(rollup)
+            assert samples is not None, 'invalid rollup: {}'.format(rollup)
+            assert satisfies_range((rollup, samples))
+
+        return rollup
 
     def get_optimal_rollup_series(self, start, end=None, rollup=None):
         if end is None:
@@ -125,8 +134,7 @@ class BaseTSDB(object):
 
         # NOTE: "optimal" here means "able to most closely reflect the upper
         # and lower bounds", not "able to construct the most efficient query"
-        if rollup is None:
-            rollup = self.get_optimal_rollup(start, end)
+        rollup = self.get_optimal_rollup(start, end, rollup)
 
         series = [self.normalize_to_epoch(start, rollup)]
         end_ts = int(to_timestamp(end))
diff --git a/src/sentry/tsdb/inmemory.py b/src/sentry/tsdb/inmemory.py
index 65c760004e..95a5978022 100644
--- a/src/sentry/tsdb/inmemory.py
+++ b/src/sentry/tsdb/inmemory.py
@@ -29,7 +29,7 @@ class InMemoryTSDB(BaseTSDB):
         if timestamp is None:
             timestamp = timezone.now()
 
-        for rollup, max_values in self.rollups:
+        for rollup, max_values in self.rollups.items():
             norm_epoch = self.normalize_to_rollup(timestamp, rollup)
             self.data[model][key][norm_epoch] += count
 
@@ -37,8 +37,7 @@ class InMemoryTSDB(BaseTSDB):
         normalize_to_epoch = self.normalize_to_epoch
         normalize_to_rollup = self.normalize_to_rollup
 
-        if rollup is None:
-            rollup = self.get_optimal_rollup(start, end)
+        rollup = self.get_optimal_rollup(start, end, rollup)
 
         results = []
         timestamp = end
@@ -64,7 +63,7 @@ class InMemoryTSDB(BaseTSDB):
         if timestamp is None:
             timestamp = timezone.now()
 
-        for rollup, max_values in self.rollups:
+        for rollup, max_values in self.rollups.items():
             r = self.normalize_to_rollup(timestamp, rollup)
             self.sets[model][key][r].update(values)
 
@@ -125,7 +124,7 @@ class InMemoryTSDB(BaseTSDB):
             for key, items in request.items():
                 items = {k: float(v) for k, v in items.items()}
                 source = self.frequencies[model][key]
-                for rollup, _ in self.rollups:
+                for rollup, _ in self.rollups.items():
                     source[self.normalize_to_rollup(timestamp, rollup)].update(items)
 
     def get_most_frequent(self, model, keys, start, end=None, rollup=None, limit=None):
diff --git a/src/sentry/tsdb/redis.py b/src/sentry/tsdb/redis.py
index 5724fc6b19..59fd6d1e62 100644
--- a/src/sentry/tsdb/redis.py
+++ b/src/sentry/tsdb/redis.py
@@ -155,7 +155,7 @@ class RedisTSDB(BaseTSDB):
             timestamp = timezone.now()
 
         with self.cluster.map() as client:
-            for rollup, max_values in self.rollups:
+            for rollup, max_values in self.rollups.items():
                 norm_rollup = normalize_to_rollup(timestamp, rollup)
                 for model, key in items:
                     model_key = self.get_model_key(key)
@@ -181,8 +181,7 @@ class RedisTSDB(BaseTSDB):
         normalize_to_rollup = self.normalize_to_rollup
         make_key = self.make_counter_key
 
-        if rollup is None:
-            rollup = self.get_optimal_rollup(start, end)
+        rollup = self.get_optimal_rollup(start, end, rollup)
 
         results = []
         timestamp = end
@@ -222,7 +221,7 @@ class RedisTSDB(BaseTSDB):
         with self.cluster.fanout() as client:
             for model, key, values in items:
                 c = client.target_key(key)
-                for rollup, max_values in self.rollups:
+                for rollup, max_values in self.rollups.items():
                     k = self.make_key(
                         model,
                         rollup,
@@ -310,7 +309,7 @@ class RedisTSDB(BaseTSDB):
 
                 # Figure out all of the keys we need to be incrementing, as
                 # well as their expiration policies.
-                for rollup, max_values in self.rollups:
+                for rollup, max_values in self.rollups.items():
                     chunk = self.make_frequency_table_keys(model, rollup, ts, key)
                     keys.extend(chunk)
 
diff --git a/tests/sentry/test_event_manager.py b/tests/sentry/test_event_manager.py
index c6770d5b7a..7095a04630 100644
--- a/tests/sentry/test_event_manager.py
+++ b/tests/sentry/test_event_manager.py
@@ -400,7 +400,9 @@ class EventManagerTest(TransactionTestCase):
 
     def test_record_frequencies(self):
         project = self.project
-        manager = EventManager(self.make_event())
+        manager = EventManager(self.make_event(
+            timestamp=time(),
+        ))
         event = manager.save(project)
 
         assert tsdb.get_most_frequent(
@@ -425,6 +427,7 @@ class EventManagerTest(TransactionTestCase):
 
     def test_event_user(self):
         manager = EventManager(self.make_event(**{
+            'timestamp': time(),
             'sentry.interfaces.User': {
                 'id': '1',
             }
diff --git a/tests/sentry/tsdb/test_redis.py b/tests/sentry/tsdb/test_redis.py
index 735c61006b..682969ff58 100644
--- a/tests/sentry/tsdb/test_redis.py
+++ b/tests/sentry/tsdb/test_redis.py
@@ -56,7 +56,7 @@ class RedisTSDBTest(TestCase):
             (TSDBModel.project, 2),
         ], dts[3], count=4)
 
-        results = self.db.get_range(TSDBModel.project, [1], dts[0], dts[-1])
+        results = self.db.get_range(TSDBModel.project, [1], dts[0], dts[-1], rollup=3600)
         assert results == {
             1: [
                 (timestamp(dts[0]), 1),
@@ -65,7 +65,8 @@ class RedisTSDBTest(TestCase):
                 (timestamp(dts[3]), 4),
             ],
         }
-        results = self.db.get_range(TSDBModel.project, [2], dts[0], dts[-1])
+
+        results = self.db.get_range(TSDBModel.project, [2], dts[0], dts[-1], rollup=3600)
         assert results == {
             2: [
                 (timestamp(dts[0]), 0),
@@ -125,7 +126,7 @@ class RedisTSDBTest(TestCase):
             dts[3],
         )
 
-        assert self.db.get_distinct_counts_series(model, [1], dts[0], dts[-1]) == {
+        assert self.db.get_distinct_counts_series(model, [1], dts[0], dts[-1], rollup=3600) == {
             1: [
                 (timestamp(dts[0]), 2),
                 (timestamp(dts[1]), 1),
@@ -134,7 +135,7 @@ class RedisTSDBTest(TestCase):
             ],
         }
 
-        assert self.db.get_distinct_counts_series(model, [2], dts[0], dts[-1]) == {
+        assert self.db.get_distinct_counts_series(model, [2], dts[0], dts[-1], rollup=3600) == {
             2: [
                 (timestamp(dts[0]), 0),
                 (timestamp(dts[1]), 0),

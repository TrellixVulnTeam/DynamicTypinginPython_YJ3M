commit a85d41573e822e3e242bf67f21f564d7e6cb6a34
Author: David Cramer <dcramer@gmail.com>
Date:   Mon Aug 6 15:18:44 2018 -0700

    Remove dead form code

diff --git a/src/sentry/web/forms/fields.py b/src/sentry/web/forms/fields.py
index c1fdb83c6f..6b1e6e0590 100644
--- a/src/sentry/web/forms/fields.py
+++ b/src/sentry/web/forms/fields.py
@@ -9,11 +9,10 @@ from __future__ import absolute_import
 
 import six
 
-from django.core.validators import URLValidator
 from django.forms.widgets import RadioFieldRenderer, TextInput, Widget
 from django.forms.util import flatatt
 from django.forms import (
-    Field, CharField, Textarea, TypedChoiceField, ValidationError
+    Field, CharField, TypedChoiceField, ValidationError
 )
 from django.utils.encoding import force_text
 from django.utils.html import format_html
@@ -21,7 +20,6 @@ from django.utils.safestring import mark_safe
 from django.utils.translation import ugettext_lazy as _
 
 from sentry.models import User
-from sentry.utils.http import parse_uri_match
 
 
 class CustomTypedChoiceField(TypedChoiceField):
@@ -43,10 +41,6 @@ class CustomTypedChoiceField(TypedChoiceField):
             )
 
 
-class RangeInput(TextInput):
-    input_type = 'range'
-
-
 class RadioFieldRenderer(RadioFieldRenderer):
     """
     This is identical to Django's builtin widget, except that
@@ -104,36 +98,3 @@ class ReadOnlyTextField(Field):
         # Always return initial because the widget doesn't
         # render an input field.
         return initial
-
-
-class OriginsField(CharField):
-    # Special case origins that don't fit the normal regex pattern, but are valid
-    WHITELIST_ORIGINS = ('*')
-
-    _url_validator = URLValidator()
-    widget = Textarea(
-        attrs={
-            'placeholder': mark_safe(_('e.g. example.com or https://example.com')),
-            'class': 'span8',
-        },
-    )
-
-    def clean(self, value):
-        if not value:
-            return []
-        values = [v for v in (v.strip() for v in value.split('\n')) if v]
-        for value in values:
-            if not self.is_valid_origin(value):
-                raise ValidationError('%r is not an acceptable value' % value)
-        return values
-
-    def is_valid_origin(self, value):
-        if value in self.WHITELIST_ORIGINS:
-            return True
-
-        bits = parse_uri_match(value)
-        # ports are not supported on matching expressions (yet)
-        if ':' in bits.domain:
-            return False
-
-        return True

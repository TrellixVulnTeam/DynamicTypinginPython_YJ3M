commit e66622da970734bbd0e7e4f3ec7a0eef86566673
Author: David Cramer <dcramer@gmail.com>
Date:   Mon Jan 26 14:49:33 2015 -0800

    Refactor Rules
    
    - Move logic into RuleProcessor
    - Rule.after API change to expect futures
    - Add deduplication for NotifyEvent and NotifyEventService
    
    Fixes GH-1401

diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index b2d11450da..7b7441a003 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -400,6 +400,10 @@ LOGGING = {
             'handlers': ['console'],
             'propagate': False,
         },
+        'sentry.rules': {
+            'handlers': ['console'],
+            'propagate': False,
+        },
         'static_compiler': {
             'level': 'INFO',
         },
diff --git a/src/sentry/plugins/base/structs.py b/src/sentry/plugins/base/structs.py
index 8241230f3b..96e60fff42 100644
--- a/src/sentry/plugins/base/structs.py
+++ b/src/sentry/plugins/base/structs.py
@@ -10,6 +10,8 @@ from __future__ import absolute_import, print_function
 
 __all__ = ('Annotation', 'Notification')
 
+import warnings
+
 
 class Annotation(object):
     __slots__ = ['label', 'url', 'description']
@@ -21,8 +23,17 @@ class Annotation(object):
 
 
 class Notification(object):
-    __slots__ = ['event', 'rule']
+    __slots__ = ['event', 'rule', 'rules']
+
+    def __init__(self, event, rule=None, rules=None):
+        if rule and not rules:
+            rules = [rule]
 
-    def __init__(self, event, rule=None):
         self.event = event
-        self.rule = rule
+        self.rules = rules or []
+
+    @property
+    def rule(self):
+        warnings.warn('Notification.rule is deprecated. Switch to Notification.rules.',
+                      DeprecationWarning)
+        return self.rules[0]
diff --git a/src/sentry/plugins/bases/notify.py b/src/sentry/plugins/bases/notify.py
index b7cf1a25d8..56831d5310 100644
--- a/src/sentry/plugins/bases/notify.py
+++ b/src/sentry/plugins/bases/notify.py
@@ -13,7 +13,7 @@ from django import forms
 from django.utils.translation import ugettext_lazy as _
 
 from sentry.app import ratelimiter
-from sentry.plugins import Plugin
+from sentry.plugins import Notification, Plugin
 from sentry.models import UserOption, AccessGroup
 
 
@@ -47,6 +47,17 @@ class NotificationPlugin(Plugin):
         event = notification.event
         return self.notify_users(event.group, event)
 
+    def rule_notify(self, event, futures):
+        rules = []
+        for future in futures:
+            rules.append(future.rule)
+            if not futures.kwargs:
+                continue
+            raise NotImplementedError('The default behavior for notification de-duplication does not support args')
+
+        notification = Notification(event=event, rules=rules)
+        self.notify(notification)
+
     def notify_users(self, group, event, fail_silently=False):
         raise NotImplementedError
 
diff --git a/src/sentry/plugins/sentry_mail/models.py b/src/sentry/plugins/sentry_mail/models.py
index 274f457a1e..1c7cfa7d1b 100644
--- a/src/sentry/plugins/sentry_mail/models.py
+++ b/src/sentry/plugins/sentry_mail/models.py
@@ -153,13 +153,12 @@ class MailPlugin(NotificationPlugin):
         template = 'sentry/emails/error.txt'
         html_template = 'sentry/emails/error.html'
 
-        rule = notification.rule
-        if rule:
+        rules = []
+        for rule in notification.rules:
             rule_link = reverse('sentry-edit-project-rule', args=[
                 group.organization.slug, project.slug, rule.id
             ])
-        else:
-            rule_link = None
+            rules.append((rule.label, rule_link))
 
         context = {
             'group': group,
@@ -167,8 +166,7 @@ class MailPlugin(NotificationPlugin):
             'tags': event.get_tags(),
             'link': link,
             'interfaces': interface_list,
-            'rule': rule,
-            'rule_link': rule_link,
+            'rules': rules,
         }
 
         headers = {
diff --git a/src/sentry/queue/routers.py b/src/sentry/queue/routers.py
index 68a4f94189..354a25b80f 100644
--- a/src/sentry/queue/routers.py
+++ b/src/sentry/queue/routers.py
@@ -12,7 +12,6 @@ COUNTER_TASKS = set([
 
 TRIGGER_TASKS = set([
     'sentry.tasks.post_process.post_process_group',
-    'sentry.tasks.post_process.execute_rule',
     'sentry.tasks.post_process.plugin_post_process_group',
     'sentry.tasks.post_process.record_affected_user',
     'sentry.tasks.post_process.record_affected_code',
diff --git a/src/sentry/rules/actions/base.py b/src/sentry/rules/actions/base.py
index 250707487c..154a2e8a0f 100644
--- a/src/sentry/rules/actions/base.py
+++ b/src/sentry/rules/actions/base.py
@@ -15,4 +15,20 @@ class EventAction(RuleBase):
     rule_type = 'action/event'
 
     def after(self, event, state):
-        pass
+        """
+        Executed after a Rule matches.
+
+        Should yield CallBackFuture instances which will then be passed into
+        the given callback.
+
+        See the notification implementation for example usage.
+
+        >>> def after(self, event, state):
+        >>>     yield self.future(self.print_results)
+        >>>
+        >>> def print_results(self, event, futures):
+        >>>     print('Got futures for Event {}'.format(event.id))
+        >>>     for future in futures:
+        >>>         print(future)
+        """
+        raise NotImplementedError
diff --git a/src/sentry/rules/actions/notify_event.py b/src/sentry/rules/actions/notify_event.py
index 047d92889b..fc486ba25c 100644
--- a/src/sentry/rules/actions/notify_event.py
+++ b/src/sentry/rules/actions/notify_event.py
@@ -8,7 +8,7 @@ sentry.rules.actions.notify_event
 
 from __future__ import absolute_import
 
-from sentry.plugins import Notification, plugins
+from sentry.plugins import plugins
 from sentry.rules.actions.base import EventAction
 from sentry.utils.safe import safe_execute
 
@@ -34,9 +34,8 @@ class NotifyEventAction(EventAction):
     def after(self, event, state):
         group = event.group
 
-        notification = Notification(event=event, rule=self.rule)
         for plugin in self.get_plugins():
             if not safe_execute(plugin.should_notify, group=group, event=event):
                 continue
 
-            safe_execute(plugin.notify, notification)
+            yield self.future(plugin.rule_notify)
diff --git a/src/sentry/rules/actions/notify_event_service.py b/src/sentry/rules/actions/notify_event_service.py
index 5682cdd3e3..57fc6fe723 100644
--- a/src/sentry/rules/actions/notify_event_service.py
+++ b/src/sentry/rules/actions/notify_event_service.py
@@ -10,7 +10,7 @@ from __future__ import absolute_import
 
 from django import forms
 
-from sentry.plugins import Notification, plugins
+from sentry.plugins import plugins
 from sentry.rules.actions.base import EventAction
 from sentry.utils.safe import safe_execute
 
@@ -52,8 +52,7 @@ class NotifyEventServiceAction(EventAction):
             self.logger.info('Rule failed should_notify check')
             return
 
-        notification = Notification(event=event, rule=self.rule)
-        plugin.notify(notification)
+        yield self.future(plugin.rule_notify)
 
     def get_plugins(self):
         from sentry.plugins.bases.notify import NotificationPlugin
diff --git a/src/sentry/rules/base.py b/src/sentry/rules/base.py
index ab39d2be59..30bb576114 100644
--- a/src/sentry/rules/base.py
+++ b/src/sentry/rules/base.py
@@ -40,10 +40,14 @@ from __future__ import absolute_import
 import logging
 import re
 
+from collections import namedtuple
 from django.utils.html import escape
 from django.utils.safestring import mark_safe
 
 
+CallbackFuture = namedtuple('CallbackFuture', ['callback', 'kwargs'])
+
+
 class RuleDescriptor(type):
     def __new__(cls, *args, **kwargs):
         new_cls = super(RuleDescriptor, cls).__new__(cls, *args, **kwargs)
@@ -95,6 +99,12 @@ class RuleBase(object):
 
         return form.is_valid()
 
+    def future(self, callback, **kwargs):
+        return CallbackFuture(
+            callback=callback,
+            kwargs=kwargs,
+        )
+
 
 class EventState(object):
     def __init__(self, is_new, is_regression, is_sample, rule_is_active,
diff --git a/src/sentry/rules/processor.py b/src/sentry/rules/processor.py
new file mode 100644
index 0000000000..78c874817e
--- /dev/null
+++ b/src/sentry/rules/processor.py
@@ -0,0 +1,144 @@
+from __future__ import absolute_import
+
+import logging
+
+from collections import defaultdict, namedtuple
+from django.utils import timezone
+
+from sentry.models import GroupRuleStatus, Rule
+from sentry.rules import EventState, rules
+from sentry.utils.cache import cache
+from sentry.utils.safe import safe_execute
+
+RuleFuture = namedtuple('RuleFuture', ['rule', 'kwargs'])
+
+
+class RuleProcessor(object):
+    logger = logging.getLogger('sentry.rules')
+
+    def __init__(self, event):
+        self.event = event
+        self.group = event.group
+        self.project = event.project
+
+        # these should be more or less correct, though
+        # we may want to make them explicit in the future
+        self.is_sample = event.id is None
+        self.is_new = event.group.times_seen == 1
+        self.is_regression = event.group.times_seen != 1
+
+        self.futures_by_cb = defaultdict(list)
+
+    def get_rules(self):
+        cache_key = 'project:%d:rules' % (self.project.id,)
+        rules_list = cache.get(cache_key)
+        if rules_list is None:
+            rules_list = list(Rule.objects.filter(project=self.project))
+            cache.set(cache_key, rules_list, 60)
+        return rules_list
+
+    def get_rule_status(self, rule):
+        # TODO(dcramer): this isnt the most efficient query pattern for this
+        rule_status, _ = GroupRuleStatus.objects.get_or_create(
+            rule=rule,
+            group=self.group,
+            defaults={
+                'project': self.project,
+                'status': GroupRuleStatus.INACTIVE,
+            },
+        )
+
+        return rule_status
+
+    def condition_matches(self, condition, state, rule):
+        condition_cls = rules.get(condition['id'])
+        if condition_cls is None:
+            self.logger.warn('Unregistered condition %r', condition['id'])
+            return
+
+        condition_inst = condition_cls(self.project, data=condition, rule=rule)
+        return safe_execute(condition_inst.passes, self.event, state)
+
+    def get_state(self, rule_status):
+        return EventState(
+            is_new=self.is_new,
+            is_regression=self.is_regression,
+            is_sample=self.is_sample,
+            rule_is_active=rule_status.status == GroupRuleStatus.ACTIVE,
+            rule_last_active=rule_status.last_active,
+        )
+
+    def apply_rule(self, rule):
+        match = rule.data.get('action_match', 'all')
+        condition_list = rule.data.get('conditions', ())
+
+        # XXX(dcramer): if theres no condition should we really skip it,
+        # or should we just apply it blindly?
+        if not condition_list:
+            return
+
+        rule_status = self.get_rule_status(rule)
+        state = self.get_state(rule_status)
+
+        condition_iter = (
+            self.condition_matches(c, state, rule)
+            for c in condition_list
+        )
+
+        if match == 'all':
+            passed = all(condition_iter)
+        elif match == 'any':
+            passed = any(condition_iter)
+        elif match == 'none':
+            passed = not any(condition_iter)
+        else:
+            self.logger.error('Unsupported action_match %r for rule %d',
+                              match, rule.id)
+            return
+
+        if passed and rule_status.status == GroupRuleStatus.INACTIVE:
+            # we only fire if we're able to say that the state has changed
+            GroupRuleStatus.objects.filter(
+                id=rule_status.id,
+                status=GroupRuleStatus.INACTIVE,
+            ).update(
+                status=GroupRuleStatus.ACTIVE,
+                last_active=timezone.now(),
+            )
+        elif not passed and rule_status.status == GroupRuleStatus.ACTIVE:
+            # update the state to suggest this rule can fire again
+            GroupRuleStatus.objects.filter(
+                id=rule_status.id,
+                status=GroupRuleStatus.ACTIVE,
+            ).update(status=GroupRuleStatus.INACTIVE)
+        elif passed:
+            GroupRuleStatus.objects.filter(
+                id=rule_status.id,
+                status=GroupRuleStatus.ACTIVE,
+            ).update(last_active=timezone.now())
+
+        if not passed:
+            return
+
+        for action in rule.data.get('actions', ()):
+            action_cls = rules.get(action['id'])
+            if action_cls is None:
+                self.logger.warn('Unregistered action %r', action['id'])
+                continue
+
+            action_inst = action_cls(self.project, data=action, rule=rule)
+            results = safe_execute(action_inst.after, event=self.event, state=state)
+            if results is None:
+                self.logger.warn('Action %s did not return any futures', action['id'])
+                continue
+
+            for future in results:
+                self.futures_by_cb[future.callback].append(
+                    RuleFuture(rule=rule, kwargs=future.kwargs)
+                )
+
+    def apply(self):
+        self.futures_by_cb = defaultdict(list)
+        for rule in self.get_rules():
+            self.apply_rule(rule)
+        return self.futures_by_cb.items()
diff --git a/src/sentry/tasks/post_process.py b/src/sentry/tasks/post_process.py
index 36cb3de683..22bb6a6f6b 100644
--- a/src/sentry/tasks/post_process.py
+++ b/src/sentry/tasks/post_process.py
@@ -11,47 +11,24 @@ from __future__ import absolute_import, print_function
 import logging
 
 from django.conf import settings
-from django.utils import timezone
 from hashlib import md5
 
 from sentry.plugins import plugins
-from sentry.rules import EventState, rules
 from sentry.tasks.base import instrumented_task
-from sentry.utils.cache import cache
 from sentry.utils.safe import safe_execute
 
 
 rules_logger = logging.getLogger('sentry.errors')
 
 
-def condition_matches(project, condition, event, state, rule):
-    condition_cls = rules.get(condition['id'])
-    if condition_cls is None:
-        rules_logger.error('Unregistered condition %r', condition['id'])
-        return
-
-    condition_inst = condition_cls(project, data=condition, rule=rule)
-    return safe_execute(condition_inst.passes, event, state)
-
-
-def get_rules(project):
-    from sentry.models import Rule
-
-    cache_key = 'project:%d:rules' % (project.id,)
-    rules_list = cache.get(cache_key)
-    if rules_list is None:
-        rules_list = list(Rule.objects.filter(project=project))
-        cache.set(cache_key, rules_list, 60)
-    return rules_list
-
-
 @instrumented_task(
     name='sentry.tasks.post_process.post_process_group')
 def post_process_group(event, is_new, is_regression, is_sample, **kwargs):
     """
     Fires post processing hooks for a group.
     """
-    from sentry.models import GroupRuleStatus, Project
+    from sentry.models import Project
+    from sentry.rules.processor import RuleProcessor
 
     project = Project.objects.get_from_cache(id=event.group.project_id)
 
@@ -73,96 +50,11 @@ def post_process_group(event, is_new, is_regression, is_sample, **kwargs):
             expires=300,
         )
 
-    for rule in get_rules(project):
-        match = rule.data.get('action_match', 'all')
-        condition_list = rule.data.get('conditions', ())
-
-        if not condition_list:
-            continue
-
-        # TODO(dcramer): this might not make sense for other rule actions
-        # so we should find a way to abstract this into actions
-        # TODO(dcramer): this isnt the most efficient query pattern for this
-        rule_status, _ = GroupRuleStatus.objects.get_or_create(
-            rule=rule,
-            group=event.group,
-            defaults={
-                'project': project,
-                'status': GroupRuleStatus.INACTIVE,
-            },
-        )
-
-        state = EventState(
-            is_new=is_new,
-            is_regression=is_regression,
-            is_sample=is_sample,
-            rule_is_active=rule_status.status == GroupRuleStatus.ACTIVE,
-            rule_last_active=rule_status.last_active,
-        )
-
-        condition_iter = (
-            condition_matches(project, c, event, state, rule)
-            for c in condition_list
-        )
-
-        if match == 'all':
-            passed = all(condition_iter)
-        elif match == 'any':
-            passed = any(condition_iter)
-        elif match == 'none':
-            passed = not any(condition_iter)
-        else:
-            rules_logger.error('Unsupported action_match %r for rule %d',
-                               match, rule.id)
-            continue
-
-        if passed and rule_status.status == GroupRuleStatus.INACTIVE:
-            # we only fire if we're able to say that the state has changed
-            GroupRuleStatus.objects.filter(
-                id=rule_status.id,
-                status=GroupRuleStatus.INACTIVE,
-                last_active=timezone.now(),
-            ).update(status=GroupRuleStatus.ACTIVE)
-        elif not passed and rule_status.status == GroupRuleStatus.ACTIVE:
-            # update the state to suggest this rule can fire again
-            GroupRuleStatus.objects.filter(
-                id=rule_status.id,
-                status=GroupRuleStatus.ACTIVE,
-                last_active=timezone.now(),
-            ).update(status=GroupRuleStatus.INACTIVE)
-
-        if passed:
-            execute_rule.apply_async(
-                kwargs={
-                    'rule_id': rule.id,
-                    'event': event,
-                    'state': state,
-                },
-                expires=120,
-            )
-
-
-@instrumented_task(
-    name='sentry.tasks.post_process.execute_rule')
-def execute_rule(rule_id, event, state):
-    """
-    Fires post processing hooks for a rule.
-    """
-    from sentry.models import Project, Rule
-
-    rule = Rule.objects.get(id=rule_id)
-    project = Project.objects.get_from_cache(id=event.project_id)
-    event.project = project
-    event.group.project = project
-
-    for action in rule.data.get('actions', ()):
-        action_cls = rules.get(action['id'])
-        if action_cls is None:
-            rules_logger.error('Unregistered action %r', action['id'])
-            continue
-
-        action_inst = action_cls(project, data=action, rule=rule)
-        safe_execute(action_inst.after, event=event, state=state)
+    rp = RuleProcessor(event)
+    # TODO(dcramer): ideally this would fanout, but serializing giant
+    # objects back and forth isn't super efficient
+    for callback, futures in rp.apply():
+        callback(event, futures)
 
 
 @instrumented_task(
diff --git a/src/sentry/templates/sentry/emails/error.html b/src/sentry/templates/sentry/emails/error.html
index 256c9bf109..971285dd8e 100644
--- a/src/sentry/templates/sentry/emails/error.html
+++ b/src/sentry/templates/sentry/emails/error.html
@@ -39,7 +39,12 @@
     </div>
     {% endfor %}
 
-    {% if rule %}
-        <p class="via">You are receiving this email due to rule: <a href="{% absolute_uri rule_link %}">{{ rule.label }}</a></p>
+    {% if rules %}
+        <p class="via">
+            You are receiving this email due to matching rules:
+            {% for rule_label, rule_link in rules %}
+                <a href="{% absolute_uri rule_link %}">{{ rule_label }}</a>{% if not forloop.last %}, {% endif %}
+            {% endfor %}
+        </p>
     {% endif %}
 {% endblock %}
diff --git a/tests/sentry/rules/test_processor.py b/tests/sentry/rules/test_processor.py
new file mode 100644
index 0000000000..db1ac84fbf
--- /dev/null
+++ b/tests/sentry/rules/test_processor.py
@@ -0,0 +1,39 @@
+# -*- coding: utf-8 -*-
+
+from __future__ import absolute_import
+
+from sentry.models import Rule
+from sentry.plugins import plugins
+from sentry.testutils import TestCase
+from sentry.rules.processor import RuleProcessor
+
+
+class RuleProcessorTest(TestCase):
+    # this test relies on a few other tests passing
+    def test_integrated(self):
+        event = self.create_event()
+
+        action_data = {
+            'id': 'sentry.rules.actions.notify_event.NotifyEventAction',
+        }
+        condition_data = {
+            'id': 'sentry.rules.conditions.every_event.EveryEventCondition',
+        }
+
+        Rule.objects.filter(project=event.project).delete()
+        rule = Rule.objects.create(
+            project=event.project,
+            data={
+                'conditions': [condition_data],
+                'actions': [action_data],
+            }
+        )
+
+        rp = RuleProcessor(event)
+        results = list(rp.apply())
+        assert len(results) == 1
+        callback, futures = results[0]
+        assert callback == plugins.get('mail').rule_notify
+        assert len(futures) == 1
+        assert futures[0].rule == rule
+        assert futures[0].kwargs == {}
diff --git a/tests/sentry/tasks/post_process/tests.py b/tests/sentry/tasks/post_process/tests.py
index 068326fbc6..f553b0f320 100644
--- a/tests/sentry/tasks/post_process/tests.py
+++ b/tests/sentry/tasks/post_process/tests.py
@@ -4,18 +4,16 @@ from __future__ import absolute_import
 
 from mock import Mock, patch
 
-from sentry.models import Group, Rule
-from sentry.rules import EventState
+from sentry.models import Group
 from sentry.testutils import TestCase
 from sentry.tasks.post_process import (
-    execute_rule, post_process_group, record_affected_user,
-    record_affected_code
+    post_process_group, record_affected_user, record_affected_code
 )
 
 
 class PostProcessGroupTest(TestCase):
     @patch('sentry.tasks.post_process.record_affected_code')
-    @patch('sentry.tasks.post_process.get_rules', Mock(return_value=[]))
+    @patch('sentry.rules.processor.RuleProcessor.apply', Mock(return_value=[]))
     def test_record_affected_code(self, mock_record_affected_code):
         group = self.create_group(project=self.project)
         event = self.create_event(group=group)
@@ -43,7 +41,8 @@ class PostProcessGroupTest(TestCase):
         )
 
     @patch('sentry.tasks.post_process.record_affected_user')
-    @patch('sentry.tasks.post_process.get_rules', Mock(return_value=[]))
+    @patch('sentry.tasks.post_process.record_affected_code', Mock())
+    @patch('sentry.rules.processor.RuleProcessor.apply', Mock(return_value=[]))
     def test_record_affected_user(self, mock_record_affected_user):
         group = self.create_group(project=self.project)
         event = self.create_event(group=group)
@@ -70,64 +69,19 @@ class PostProcessGroupTest(TestCase):
             event=event,
         )
 
-    @patch('sentry.tasks.post_process.execute_rule')
-    @patch('sentry.tasks.post_process.get_rules')
-    def test_execute_rule(self, mock_get_rules, mock_execute_rule):
-        action_id = 'sentry.rules.actions.notify_event.NotifyEventAction'
-        condition_id = 'sentry.rules.conditions.first_seen_event.FirstSeenEventCondition'
-
+    @patch('sentry.tasks.post_process.record_affected_user', Mock())
+    @patch('sentry.tasks.post_process.record_affected_code', Mock())
+    @patch('sentry.rules.processor.RuleProcessor')
+    def test_rule_processor(self, mock_processor):
         group = self.create_group(project=self.project)
         event = self.create_event(group=group)
 
-        mock_get_rules.return_value = [
-            Rule(
-                id=1,
-                data={
-                    'actions': [{
-                        'id': 'sentry.rules.actions.notify_event.NotifyEventAction',
-                    }],
-                    'conditions': [{
-                        'id': 'sentry.rules.conditions.first_seen_event.FirstSeenEventCondition',
-                    }],
-                }
-            ),
-            Rule(
-                id=2,
-                data={
-                    'actions': [{
-                        'id': 'sentry.rules.actions.notify_event_service.NotifyEventAction',
-                        'service': 'mail',
-                    }],
-                    'conditions': [{
-                        'id': 'sentry.rules.conditions.every_event.EveryEventCondition',
-                    }],
-                }
-            ),
-        ]
-
-        post_process_group(
-            event=event,
-            is_new=False,
-            is_regression=False,
-            is_sample=False,
-        )
-
-        mock_get_rules.assert_called_once_with(self.project)
-
-        assert len(mock_execute_rule.apply_async.mock_calls) == 1
-
-        mock_execute_rule.apply_async.reset_mock()
-
-        post_process_group(
-            event=event,
-            is_new=True,
-            is_regression=False,
-            is_sample=False,
-        )
-
-        assert len(mock_execute_rule.apply_async.mock_calls) == 2
+        mock_callback = Mock()
+        mock_futures = [Mock()]
 
-        mock_execute_rule.apply_async.reset_mock()
+        mock_processor.return_value.apply.return_value = [
+            (mock_callback, mock_futures),
+        ]
 
         post_process_group(
             event=event,
@@ -136,45 +90,10 @@ class PostProcessGroupTest(TestCase):
             is_sample=False,
         )
 
-        assert len(mock_execute_rule.apply_async.mock_calls) == 2
+        mock_processor.assert_called_once_with(event)
+        mock_processor.return_value.apply.assert_called_once_with()
 
-
-class ExecuteRuleTest(TestCase):
-    @patch('sentry.tasks.post_process.rules')
-    def test_simple(self, mock_rules):
-        group = self.create_group(project=self.project)
-        event = self.create_event(group=group)
-        action_data = {'id': 'a.rule.id', 'foo': 'bar'}
-        rule = Rule.objects.create(
-            project=event.project,
-            data={
-                'actions': [
-                    action_data,
-                ],
-            }
-        )
-
-        state = EventState(
-            is_new=True,
-            is_regression=False,
-            is_sample=True,
-            rule_is_active=False,
-            rule_last_active=None,
-        )
-
-        execute_rule(
-            rule_id=rule.id,
-            event=event,
-            state=state,
-        )
-
-        mock_rules.get.assert_called_once_with('a.rule.id')
-        mock_rule_inst = mock_rules.get.return_value
-        mock_rule_inst.assert_called_once_with(self.project, data=action_data, rule=rule)
-        mock_rule_inst.return_value.after.assert_called_once_with(
-            event=event,
-            state=state,
-        )
+        mock_callback.assert_called_once_with(event, mock_futures)
 
 
 class RecordAffectedUserTest(TestCase):

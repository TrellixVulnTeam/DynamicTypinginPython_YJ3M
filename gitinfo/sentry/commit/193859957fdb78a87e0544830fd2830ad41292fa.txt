commit 193859957fdb78a87e0544830fd2830ad41292fa
Author: Alberto Leal <mail4alberto@gmail.com>
Date:   Thu Dec 5 18:09:08 2019 -0500

    feat(apm): Fuzzy search on spans (#15846)

diff --git a/package.json b/package.json
index 70a72629fc..0dac76d38c 100644
--- a/package.json
+++ b/package.json
@@ -64,7 +64,7 @@
     "emotion-theming": "9.2.9",
     "file-loader": "^3.0.1",
     "focus-visible": "^5.0.2",
-    "fuse.js": "^3.2.0",
+    "fuse.js": "^3.4.6",
     "gettext-parser": "1.3.1",
     "grid-emotion": "^2.1.0",
     "intersection-observer": "^0.7.0",
diff --git a/src/sentry/static/sentry/app/components/events/interfaces/spans/index.tsx b/src/sentry/static/sentry/app/components/events/interfaces/spans/index.tsx
index 71ae0a3d4b..6980e45bb0 100644
--- a/src/sentry/static/sentry/app/components/events/interfaces/spans/index.tsx
+++ b/src/sentry/static/sentry/app/components/events/interfaces/spans/index.tsx
@@ -1,6 +1,8 @@
 import React from 'react';
 import SentryTypes from 'app/sentryTypes';
+import SearchBar from 'app/components/searchBar';
 
+import {t} from 'app/locale';
 import {Panel} from 'app/components/panels';
 
 import {SentryTransactionEvent} from './types';
@@ -10,17 +12,41 @@ type PropType = {
   event: SentryTransactionEvent;
 };
 
-class SpansInterface extends React.Component<PropType> {
+type State = {
+  searchQuery: string | undefined;
+};
+
+class SpansInterface extends React.Component<PropType, State> {
   static propTypes = {
     event: SentryTypes.Event.isRequired,
   };
+
+  state: State = {
+    searchQuery: undefined,
+  };
+
+  handleSpanFilter = (searchQuery: string) => {
+    this.setState({
+      searchQuery: searchQuery || undefined,
+    });
+  };
+
   render() {
     const {event} = this.props;
 
     return (
-      <Panel>
-        <TraceView event={event} />
-      </Panel>
+      <div>
+        <SearchBar
+          defaultQuery=""
+          query={this.state.searchQuery || ''}
+          placeholder={t('Filter on spans')}
+          onSearch={this.handleSpanFilter}
+        />
+        <br />
+        <Panel>
+          <TraceView event={event} searchQuery={this.state.searchQuery} />
+        </Panel>
+      </div>
     );
   }
 }
diff --git a/src/sentry/static/sentry/app/components/events/interfaces/spans/spanBar.tsx b/src/sentry/static/sentry/app/components/events/interfaces/spans/spanBar.tsx
index 22153fc4b7..b51ab7ba11 100644
--- a/src/sentry/static/sentry/app/components/events/interfaces/spans/spanBar.tsx
+++ b/src/sentry/static/sentry/app/components/events/interfaces/spans/spanBar.tsx
@@ -176,6 +176,7 @@ type SpanBarProps = {
   isLast?: boolean;
   isRoot?: boolean;
   toggleSpanTree: () => void;
+  isCurrentSpanFilteredOut: boolean;
 };
 
 type SpanBarState = {
@@ -727,14 +728,16 @@ class SpanBar extends React.Component<SpanBarProps, SpanBarState> {
   };
 
   render() {
+    const {isCurrentSpanFilteredOut} = this.props;
     const bounds = this.getBounds();
 
     const isSpanVisibleInView = bounds.isSpanVisibleInView;
+    const isSpanVisible = isSpanVisibleInView && !isCurrentSpanFilteredOut;
 
     return (
       <SpanRow
         innerRef={this.spanRowDOMRef}
-        visible={isSpanVisibleInView}
+        visible={isSpanVisible}
         showBorder={this.state.showDetail}
         onClick={() => {
           this.toggleDisplayDetail();
@@ -747,7 +750,7 @@ class SpanBar extends React.Component<SpanBarProps, SpanBarState> {
             return this.renderHeader(dividerHandlerChildrenProps);
           }}
         </DividerHandlerManager.Consumer>
-        {this.renderDetail({isVisible: isSpanVisibleInView})}
+        {this.renderDetail({isVisible: isSpanVisible})}
       </SpanRow>
     );
   }
diff --git a/src/sentry/static/sentry/app/components/events/interfaces/spans/spanGroup.tsx b/src/sentry/static/sentry/app/components/events/interfaces/spans/spanGroup.tsx
index 29486b7274..e7df69ad5d 100644
--- a/src/sentry/static/sentry/app/components/events/interfaces/spans/spanGroup.tsx
+++ b/src/sentry/static/sentry/app/components/events/interfaces/spans/spanGroup.tsx
@@ -16,6 +16,7 @@ type PropType = {
   spanNumber: number;
   isLast: boolean;
   isRoot?: boolean;
+  isCurrentSpanFilteredOut: boolean;
 };
 
 type State = {
@@ -55,6 +56,7 @@ class SpanGroup extends React.Component<PropType, State> {
       generateBounds,
       treeDepth,
       spanNumber,
+      isCurrentSpanFilteredOut,
     } = this.props;
 
     return (
@@ -72,6 +74,7 @@ class SpanGroup extends React.Component<PropType, State> {
           spanNumber={spanNumber}
           isLast={isLast}
           isRoot={isRoot}
+          isCurrentSpanFilteredOut={isCurrentSpanFilteredOut}
         />
         {this.renderSpanChildren()}
       </React.Fragment>
diff --git a/src/sentry/static/sentry/app/components/events/interfaces/spans/spanTree.tsx b/src/sentry/static/sentry/app/components/events/interfaces/spans/spanTree.tsx
index 59e96c4e30..cc307a9380 100644
--- a/src/sentry/static/sentry/app/components/events/interfaces/spans/spanTree.tsx
+++ b/src/sentry/static/sentry/app/components/events/interfaces/spans/spanTree.tsx
@@ -10,21 +10,25 @@ import {
   SpanBoundsType,
   SpanGeneratedBoundsType,
   pickSpanBarColour,
+  generateRootSpan,
 } from './utils';
 import {DragManagerChildrenProps} from './dragManager';
 import SpanGroup from './spanGroup';
 import {SpanRowMessage} from './styles';
 import * as DividerHandlerManager from './dividerHandlerManager';
+import {FilterSpans} from './traceView';
 
 type RenderedSpanTree = {
   spanTree: JSX.Element | null;
   nextSpanNumber: number;
-  numOfHiddenSpansAbove: number;
+  numOfSpansOutOfViewAbove: number;
+  numOfFilteredSpansAbove: number;
 };
 
 type PropType = {
   trace: ParsedTraceType;
   dragProps: DragManagerChildrenProps;
+  filterSpans: FilterSpans | undefined;
 };
 
 class SpanTree extends React.Component<PropType> {
@@ -38,13 +42,69 @@ class SpanTree extends React.Component<PropType> {
     return true;
   }
 
+  generateInfoMessage(input: {
+    isCurrentSpanHidden: boolean;
+    numOfSpansOutOfViewAbove: number;
+    isCurrentSpanFilteredOut: boolean;
+    numOfFilteredSpansAbove: number;
+  }): React.ReactNode {
+    const {
+      isCurrentSpanHidden,
+      numOfSpansOutOfViewAbove,
+      isCurrentSpanFilteredOut,
+      numOfFilteredSpansAbove,
+    } = input;
+
+    const messages: React.ReactNode[] = [];
+
+    const showHiddenSpansMessage = !isCurrentSpanHidden && numOfSpansOutOfViewAbove > 0;
+
+    if (showHiddenSpansMessage) {
+      messages.push(
+        <span key="spans-out-of-view">
+          <strong>{numOfSpansOutOfViewAbove}</strong> {t('spans out of view')}
+        </span>
+      );
+    }
+
+    const showFilteredSpansMessage =
+      !isCurrentSpanFilteredOut && numOfFilteredSpansAbove > 0;
+
+    if (showFilteredSpansMessage) {
+      if (!isCurrentSpanHidden) {
+        messages.push(
+          <span key="spans-filtered">
+            <strong>{numOfFilteredSpansAbove}</strong> {t('spans filtered out')}
+          </span>
+        );
+      }
+    }
+
+    if (messages.length <= 0) {
+      return null;
+    }
+
+    return <SpanRowMessage>{messages}</SpanRowMessage>;
+  }
+
+  isSpanFilteredOut(span: Readonly<SpanType>): boolean {
+    const {filterSpans} = this.props;
+
+    if (!filterSpans) {
+      return false;
+    }
+
+    return !filterSpans.spanIDs.has(span.span_id);
+  }
+
   renderSpan = ({
     spanNumber,
     isRoot,
     isLast,
     treeDepth,
     continuingTreeDepths,
-    numOfHiddenSpansAbove,
+    numOfSpansOutOfViewAbove,
+    numOfFilteredSpansAbove,
     childSpans,
     span,
     generateBounds,
@@ -54,7 +114,8 @@ class SpanTree extends React.Component<PropType> {
     continuingTreeDepths: Array<number>;
     isLast: boolean;
     isRoot?: boolean;
-    numOfHiddenSpansAbove: number;
+    numOfSpansOutOfViewAbove: number;
+    numOfFilteredSpansAbove: number;
     span: Readonly<SpanType>;
     childSpans: Readonly<SpanChildrenLookupType>;
     generateBounds: (bounds: SpanBoundsType) => SpanGeneratedBoundsType;
@@ -68,11 +129,13 @@ class SpanTree extends React.Component<PropType> {
     });
 
     const isCurrentSpanHidden = !bounds.isSpanVisibleInView;
+    const isCurrentSpanFilteredOut = this.isSpanFilteredOut(span);
 
     type AccType = {
       renderedSpanChildren: Array<JSX.Element>;
       nextSpanNumber: number;
-      numOfHiddenSpansAbove: number;
+      numOfSpansOutOfViewAbove: number;
+      numOfFilteredSpansAbove: number;
     };
 
     const treeArr = isLast ? continuingTreeDepths : [...continuingTreeDepths, treeDepth];
@@ -86,7 +149,8 @@ class SpanTree extends React.Component<PropType> {
           isLast: index + 1 === spanChildren.length,
           continuingTreeDepths: treeArr,
           treeDepth: treeDepth + 1,
-          numOfHiddenSpansAbove: acc.numOfHiddenSpansAbove,
+          numOfSpansOutOfViewAbove: acc.numOfSpansOutOfViewAbove,
+          numOfFilteredSpansAbove: acc.numOfFilteredSpansAbove,
           span: spanChild,
           childSpans,
           generateBounds,
@@ -96,7 +160,8 @@ class SpanTree extends React.Component<PropType> {
           <React.Fragment key={key}>{results.spanTree}</React.Fragment>
         );
 
-        acc.numOfHiddenSpansAbove = results.numOfHiddenSpansAbove;
+        acc.numOfSpansOutOfViewAbove = results.numOfSpansOutOfViewAbove;
+        acc.numOfFilteredSpansAbove = results.numOfFilteredSpansAbove;
 
         acc.nextSpanNumber = results.nextSpanNumber;
 
@@ -105,26 +170,29 @@ class SpanTree extends React.Component<PropType> {
       {
         renderedSpanChildren: [],
         nextSpanNumber: spanNumber + 1,
-        numOfHiddenSpansAbove: isCurrentSpanHidden ? numOfHiddenSpansAbove + 1 : 0,
+        numOfSpansOutOfViewAbove: isCurrentSpanHidden ? numOfSpansOutOfViewAbove + 1 : 0,
+        numOfFilteredSpansAbove: isCurrentSpanFilteredOut
+          ? numOfFilteredSpansAbove + 1
+          : isCurrentSpanHidden
+          ? numOfFilteredSpansAbove
+          : 0,
       }
     );
 
-    const showHiddenSpansMessage = !isCurrentSpanHidden && numOfHiddenSpansAbove > 0;
-
-    const hiddenSpansMessage = showHiddenSpansMessage ? (
-      <SpanRowMessage>
-        <span>
-          {t('Number of hidden spans:')} {numOfHiddenSpansAbove}
-        </span>
-      </SpanRowMessage>
-    ) : null;
+    const infoMessage = this.generateInfoMessage({
+      isCurrentSpanHidden,
+      numOfSpansOutOfViewAbove,
+      isCurrentSpanFilteredOut,
+      numOfFilteredSpansAbove,
+    });
 
     return {
-      numOfHiddenSpansAbove: reduced.numOfHiddenSpansAbove,
+      numOfSpansOutOfViewAbove: reduced.numOfSpansOutOfViewAbove,
+      numOfFilteredSpansAbove: reduced.numOfFilteredSpansAbove,
       nextSpanNumber: reduced.nextSpanNumber,
       spanTree: (
         <React.Fragment>
-          {hiddenSpansMessage}
+          {infoMessage}
           <SpanGroup
             spanNumber={spanNumber}
             isLast={isLast}
@@ -137,6 +205,7 @@ class SpanTree extends React.Component<PropType> {
             numOfSpanChildren={spanChildren.length}
             renderedSpanChildren={reduced.renderedSpanChildren}
             spanBarColour={spanBarColour}
+            isCurrentSpanFilteredOut={isCurrentSpanFilteredOut}
           />
         </React.Fragment>
       ),
@@ -146,15 +215,7 @@ class SpanTree extends React.Component<PropType> {
   renderRootSpan = (): RenderedSpanTree => {
     const {dragProps, trace} = this.props;
 
-    const rootSpan: SpanType = {
-      trace_id: trace.traceID,
-      span_id: trace.rootSpanID,
-      parent_span_id: trace.parentSpanID,
-      start_timestamp: trace.traceStartTimestamp,
-      timestamp: trace.traceEndTimestamp,
-      op: trace.op,
-      data: {},
-    };
+    const rootSpan: SpanType = generateRootSpan(trace);
 
     const generateBounds = boundsGenerator({
       traceStartTimestamp: trace.traceStartTimestamp,
@@ -169,7 +230,8 @@ class SpanTree extends React.Component<PropType> {
       spanNumber: 1,
       treeDepth: 0,
       continuingTreeDepths: [],
-      numOfHiddenSpansAbove: 0,
+      numOfSpansOutOfViewAbove: 0,
+      numOfFilteredSpansAbove: 0,
       span: rootSpan,
       childSpans: trace.childSpans,
       generateBounds,
@@ -177,22 +239,24 @@ class SpanTree extends React.Component<PropType> {
   };
 
   render() {
-    const {spanTree, numOfHiddenSpansAbove} = this.renderRootSpan();
+    const {
+      spanTree,
+      numOfSpansOutOfViewAbove,
+      numOfFilteredSpansAbove,
+    } = this.renderRootSpan();
 
-    const hiddenSpansMessage =
-      numOfHiddenSpansAbove > 0 ? (
-        <SpanRowMessage>
-          <span>
-            {t('Number of hidden spans:')} {numOfHiddenSpansAbove}
-          </span>
-        </SpanRowMessage>
-      ) : null;
+    const infoMessage = this.generateInfoMessage({
+      isCurrentSpanHidden: false,
+      numOfSpansOutOfViewAbove,
+      isCurrentSpanFilteredOut: false,
+      numOfFilteredSpansAbove,
+    });
 
     return (
       <DividerHandlerManager.Provider interactiveLayerRef={this.traceViewRef}>
         <TraceViewContainer innerRef={this.traceViewRef}>
           {spanTree}
-          {hiddenSpansMessage}
+          {infoMessage}
         </TraceViewContainer>
       </DividerHandlerManager.Provider>
     );
diff --git a/src/sentry/static/sentry/app/components/events/interfaces/spans/styles.tsx b/src/sentry/static/sentry/app/components/events/interfaces/spans/styles.tsx
index b296c142e7..d9ab598e33 100644
--- a/src/sentry/static/sentry/app/components/events/interfaces/spans/styles.tsx
+++ b/src/sentry/static/sentry/app/components/events/interfaces/spans/styles.tsx
@@ -5,6 +5,7 @@ import theme from 'app/utils/theme';
 
 export const zIndex = {
   minimapContainer: theme.zIndex.traceView.minimapContainer,
+  rowInfoMessage: theme.zIndex.traceView.rowInfoMessage,
   dividerLine: theme.zIndex.traceView.dividerLine,
   spanTreeToggler: theme.zIndex.traceView.spanTreeToggler,
 };
@@ -46,5 +47,10 @@ export const SpanRowMessage = styled(SpanRow)`
   background-color: ${p => p.theme.offWhiteLight};
   outline: 1px solid ${p => p.theme.borderDark};
   font-size: ${p => p.theme.fontSizeSmall};
-  z-index: 99999;
+
+  z-index: ${zIndex.rowInfoMessage};
+
+  > * + * {
+    margin-left: ${space(2)};
+  }
 `;
diff --git a/src/sentry/static/sentry/app/components/events/interfaces/spans/traceView.tsx b/src/sentry/static/sentry/app/components/events/interfaces/spans/traceView.tsx
index e1cfb9999f..f2f8dd554d 100644
--- a/src/sentry/static/sentry/app/components/events/interfaces/spans/traceView.tsx
+++ b/src/sentry/static/sentry/app/components/events/interfaces/spans/traceView.tsx
@@ -1,15 +1,17 @@
 import React from 'react';
 import get from 'lodash/get';
 import set from 'lodash/set';
+import pick from 'lodash/pick';
 import isNumber from 'lodash/isNumber';
 
 import {t} from 'app/locale';
 import EmptyStateWarning from 'app/components/emptyStateWarning';
+import {createFuzzySearch} from 'app/utils/createFuzzySearch';
 
 import DragManager, {DragManagerChildrenProps} from './dragManager';
 import SpanTree from './spanTree';
 import {SpanType, SpanEntry, SentryTransactionEvent, ParsedTraceType} from './types';
-import {isValidSpanID} from './utils';
+import {isValidSpanID, generateRootSpan} from './utils';
 import TraceViewHeader from './header';
 import * as CursorGuideHandler from './cursorGuideHandler';
 
@@ -21,134 +23,179 @@ type TraceContextType = {
   parent_span_id?: string;
 };
 
-type PropType = {
+type IndexedFusedSpan = {
+  span: SpanType;
+  indexed: string[];
+  tagKeys: string[];
+  tagValues: string[];
+  dataKeys: string[];
+  dataValues: string[];
+};
+
+type FuseResult = {
+  item: IndexedFusedSpan;
+  score: number;
+};
+
+export type FilterSpans = {
+  results: FuseResult[];
+  spanIDs: Set<string>;
+};
+
+type Props = {
   event: Readonly<SentryTransactionEvent>;
+  searchQuery: string | undefined;
 };
 
-class TraceView extends React.Component<PropType> {
-  minimapInteractiveRef = React.createRef<HTMLDivElement>();
+type State = {
+  parsedTrace: ParsedTraceType;
+  filterSpans: FilterSpans | undefined;
+};
 
-  renderHeader = (dragProps: DragManagerChildrenProps, parsedTrace: ParsedTraceType) => {
-    return (
-      <TraceViewHeader
-        minimapInteractiveRef={this.minimapInteractiveRef}
-        dragProps={dragProps}
-        trace={parsedTrace}
-      />
-    );
-  };
+class TraceView extends React.PureComponent<Props, State> {
+  minimapInteractiveRef = React.createRef<HTMLDivElement>();
 
-  getTraceContext = () => {
-    const {event} = this.props;
+  constructor(props: Props) {
+    super(props);
 
-    const traceContext: TraceContextType | undefined = get(event, 'contexts.trace');
+    this.state = {
+      parsedTrace: parseTrace(props.event),
+      filterSpans: undefined,
+    };
 
-    return traceContext;
-  };
+    this.filterOnSpans(props.searchQuery);
+  }
 
-  parseTrace = (): ParsedTraceType => {
-    const {event} = this.props;
+  static getDerivedStateFromProps(props: Props, state: State): State {
+    return {
+      parsedTrace: parseTrace(props.event),
+      ...state,
+    };
+  }
 
-    const spanEntry: SpanEntry | undefined = event.entries.find(
-      (entry: {type: string}) => entry.type === 'spans'
-    );
+  componentDidUpdate(prevProps) {
+    if (prevProps.searchQuery !== this.props.searchQuery) {
+      this.filterOnSpans(this.props.searchQuery);
+    }
+  }
 
-    const spans: Array<SpanType> = get(spanEntry, 'data', []);
-
-    const traceContext = this.getTraceContext();
-    const traceID = (traceContext && traceContext.trace_id) || '';
-    const rootSpanID = (traceContext && traceContext.span_id) || '';
-    const rootSpanOpName = (traceContext && traceContext.op) || 'transaction';
-    const parentSpanID = traceContext && traceContext.parent_span_id;
-
-    if (!spanEntry || spans.length <= 0) {
-      return {
-        op: rootSpanOpName,
-        childSpans: {},
-        traceStartTimestamp: event.startTimestamp,
-        traceEndTimestamp: event.endTimestamp,
-        traceID,
-        rootSpanID,
-        parentSpanID,
-        numOfSpans: 0,
-      };
+  async filterOnSpans(searchQuery: string | undefined) {
+    if (!searchQuery) {
+      // reset
+      if (this.state.filterSpans !== undefined) {
+        this.setState({
+          filterSpans: undefined,
+        });
+      }
+      return;
     }
 
-    // we reduce spans to become an object mapping span ids to their children
+    const {parsedTrace} = this.state;
 
-    const init: ParsedTraceType = {
-      op: rootSpanOpName,
-      childSpans: {},
-      traceStartTimestamp: event.startTimestamp,
-      traceEndTimestamp: event.endTimestamp,
-      traceID,
-      rootSpanID,
-      parentSpanID,
-      numOfSpans: spans.length,
-    };
+    const {spans} = parsedTrace;
 
-    const reduced: ParsedTraceType = spans.reduce((acc, span) => {
-      if (!isValidSpanID(span.parent_span_id)) {
-        return acc;
-      }
+    const transformed: IndexedFusedSpan[] = [generateRootSpan(parsedTrace), ...spans].map(
+      (span): IndexedFusedSpan => {
+        const indexed: string[] = [];
 
-      const spanChildren: Array<SpanType> = get(acc.childSpans, span.parent_span_id!, []);
+        // basic properties
 
-      spanChildren.push(span);
+        const pickedSpan = pick(span, [
+          // TODO: do we want this?
+          // 'trace_id',
+          'span_id',
+          'start_timestamp',
+          'timestamp',
+          'op',
+          'description',
+        ]);
 
-      set(acc.childSpans, span.parent_span_id!, spanChildren);
+        const basicValues: string[] = Object.values(pickedSpan)
+          .filter(value => {
+            return !!value;
+          })
+          .map(value => {
+            return String(value);
+          });
 
-      if (!acc.traceStartTimestamp || span.start_timestamp < acc.traceStartTimestamp) {
-        acc.traceStartTimestamp = span.start_timestamp;
-      }
+        indexed.push(...basicValues);
 
-      // establish trace end timestamp
+        // tags
 
-      const hasEndTimestamp = isNumber(span.timestamp);
+        let tagKeys: string[] = [];
+        let tagValues: string[] = [];
+        const tags: {[tag_name: string]: string} | undefined = get(span, 'tags');
 
-      if (!acc.traceEndTimestamp) {
-        if (hasEndTimestamp) {
-          acc.traceEndTimestamp = span.timestamp;
-          return acc;
+        if (tags) {
+          tagKeys = Object.keys(tags);
+          tagValues = Object.values(tags);
         }
 
-        acc.traceEndTimestamp = span.start_timestamp;
-        return acc;
-      }
+        const data: {[data_name: string]: any} | undefined = get(span, 'data', {});
 
-      if (hasEndTimestamp && span.timestamp! > acc.traceEndTimestamp) {
-        acc.traceEndTimestamp = span.timestamp;
-        return acc;
-      }
+        let dataKeys: string[] = [];
+        let dataValues: string[] = [];
+        if (data) {
+          dataKeys = Object.keys(data);
+          dataValues = Object.values(data).map(value => {
+            return JSON.stringify(value, null, 4) || '';
+          });
+        }
 
-      if (span.start_timestamp > acc.traceEndTimestamp) {
-        acc.traceEndTimestamp = span.start_timestamp;
+        return {
+          span,
+          indexed,
+          tagKeys,
+          tagValues,
+          dataKeys,
+          dataValues,
+        };
       }
+    );
 
-      return acc;
-    }, init);
+    const fuse = await createFuzzySearch(transformed, {
+      keys: ['indexed', 'tagKeys', 'tagValues', 'dataKeys', 'dataValues'],
+      includeMatches: false,
+      threshold: 0.6,
+      location: 0,
+      distance: 100,
+      maxPatternLength: 32,
+    });
 
-    // sort span children by their start timestamps in ascending order
+    const results = fuse.search<FuseResult>(searchQuery);
 
-    Object.values(reduced.childSpans).forEach(spanChildren => {
-      spanChildren.sort((firstSpan, secondSpan) => {
-        if (firstSpan.start_timestamp < secondSpan.start_timestamp) {
-          return -1;
-        }
+    const spanIDs: Set<string> = results.reduce((setOfSpanIDs: Set<string>, result) => {
+      const spanID = result.item.span.span_id;
 
-        if (firstSpan.start_timestamp === secondSpan.start_timestamp) {
-          return 0;
-        }
+      if (spanID) {
+        setOfSpanIDs.add(spanID);
+      }
 
-        return 1;
-      });
+      return setOfSpanIDs;
+    }, new Set<string>());
+
+    this.setState({
+      filterSpans: {
+        results,
+        spanIDs,
+      },
     });
+  }
 
-    return reduced;
+  renderHeader = (dragProps: DragManagerChildrenProps, parsedTrace: ParsedTraceType) => {
+    return (
+      <TraceViewHeader
+        minimapInteractiveRef={this.minimapInteractiveRef}
+        dragProps={dragProps}
+        trace={parsedTrace}
+      />
+    );
   };
 
   render() {
-    if (!this.getTraceContext()) {
+    const {event} = this.props;
+
+    if (!getTraceContext(event)) {
       return (
         <EmptyStateWarning>
           <p>{t('There is no trace for this transaction')}</p>
@@ -156,7 +203,7 @@ class TraceView extends React.Component<PropType> {
       );
     }
 
-    const parsedTrace = this.parseTrace();
+    const parsedTrace = this.state.parsedTrace;
 
     return (
       <DragManager interactiveLayerRef={this.minimapInteractiveRef}>
@@ -168,7 +215,11 @@ class TraceView extends React.Component<PropType> {
               trace={parsedTrace}
             >
               {this.renderHeader(dragProps, parsedTrace)}
-              <SpanTree trace={parsedTrace} dragProps={dragProps} />
+              <SpanTree
+                trace={parsedTrace}
+                dragProps={dragProps}
+                filterSpans={this.state.filterSpans}
+              />
             </CursorGuideHandler.Provider>
           );
         }}
@@ -177,4 +228,113 @@ class TraceView extends React.Component<PropType> {
   }
 }
 
+function getTraceContext(
+  event: Readonly<SentryTransactionEvent>
+): TraceContextType | undefined {
+  const traceContext: TraceContextType | undefined = get(event, 'contexts.trace');
+
+  return traceContext;
+}
+
+function parseTrace(event: Readonly<SentryTransactionEvent>): ParsedTraceType {
+  const spanEntry: SpanEntry | undefined = event.entries.find(
+    (entry: {type: string}) => entry.type === 'spans'
+  );
+
+  const spans: Array<SpanType> = get(spanEntry, 'data', []);
+
+  const traceContext = getTraceContext(event);
+  const traceID = (traceContext && traceContext.trace_id) || '';
+  const rootSpanID = (traceContext && traceContext.span_id) || '';
+  const rootSpanOpName = (traceContext && traceContext.op) || 'transaction';
+  const parentSpanID = traceContext && traceContext.parent_span_id;
+
+  if (!spanEntry || spans.length <= 0) {
+    return {
+      op: rootSpanOpName,
+      childSpans: {},
+      traceStartTimestamp: event.startTimestamp,
+      traceEndTimestamp: event.endTimestamp,
+      traceID,
+      rootSpanID,
+      parentSpanID,
+      numOfSpans: 0,
+      spans: [],
+    };
+  }
+
+  // we reduce spans to become an object mapping span ids to their children
+
+  const init: ParsedTraceType = {
+    op: rootSpanOpName,
+    childSpans: {},
+    traceStartTimestamp: event.startTimestamp,
+    traceEndTimestamp: event.endTimestamp,
+    traceID,
+    rootSpanID,
+    parentSpanID,
+    numOfSpans: spans.length,
+    spans,
+  };
+
+  const reduced: ParsedTraceType = spans.reduce((acc, span) => {
+    if (!isValidSpanID(span.parent_span_id)) {
+      return acc;
+    }
+
+    const spanChildren: Array<SpanType> = get(acc.childSpans, span.parent_span_id!, []);
+
+    spanChildren.push(span);
+
+    set(acc.childSpans, span.parent_span_id!, spanChildren);
+
+    if (!acc.traceStartTimestamp || span.start_timestamp < acc.traceStartTimestamp) {
+      acc.traceStartTimestamp = span.start_timestamp;
+    }
+
+    // establish trace end timestamp
+
+    const hasEndTimestamp = isNumber(span.timestamp);
+
+    if (!acc.traceEndTimestamp) {
+      if (hasEndTimestamp) {
+        acc.traceEndTimestamp = span.timestamp;
+        return acc;
+      }
+
+      acc.traceEndTimestamp = span.start_timestamp;
+      return acc;
+    }
+
+    if (hasEndTimestamp && span.timestamp! > acc.traceEndTimestamp) {
+      acc.traceEndTimestamp = span.timestamp;
+      return acc;
+    }
+
+    if (span.start_timestamp > acc.traceEndTimestamp) {
+      acc.traceEndTimestamp = span.start_timestamp;
+    }
+
+    return acc;
+  }, init);
+
+  // sort span children by their start timestamps in ascending order
+
+  Object.values(reduced.childSpans).forEach(spanChildren => {
+    spanChildren.sort((firstSpan, secondSpan) => {
+      if (firstSpan.start_timestamp < secondSpan.start_timestamp) {
+        return -1;
+      }
+
+      if (firstSpan.start_timestamp === secondSpan.start_timestamp) {
+        return 0;
+      }
+
+      return 1;
+    });
+  });
+
+  return reduced;
+}
+
 export default TraceView;
diff --git a/src/sentry/static/sentry/app/components/events/interfaces/spans/types.tsx b/src/sentry/static/sentry/app/components/events/interfaces/spans/types.tsx
index 93bd653d53..746c226db5 100644
--- a/src/sentry/static/sentry/app/components/events/interfaces/spans/types.tsx
+++ b/src/sentry/static/sentry/app/components/events/interfaces/spans/types.tsx
@@ -8,6 +8,7 @@ export type SpanType = {
   op?: string;
   description?: string;
   data: Object;
+  tags?: {[key: string]: string};
 };
 
 export type SpanEntry = {
@@ -32,6 +33,7 @@ export type ParsedTraceType = {
   traceStartTimestamp: number;
   traceEndTimestamp: number;
   numOfSpans: number;
+  spans: SpanType[];
 };
 
 export enum TickAlignment {
diff --git a/src/sentry/static/sentry/app/components/events/interfaces/spans/utils.tsx b/src/sentry/static/sentry/app/components/events/interfaces/spans/utils.tsx
index 16a6a9fcc9..09ef76b01e 100644
--- a/src/sentry/static/sentry/app/components/events/interfaces/spans/utils.tsx
+++ b/src/sentry/static/sentry/app/components/events/interfaces/spans/utils.tsx
@@ -1,5 +1,6 @@
 import isString from 'lodash/isString';
 import CHART_PALETTE from 'app/constants/chartPalette';
+import {ParsedTraceType, SpanType} from './types';
 
 type Rect = {
   // x and y are left/top coords respectively
@@ -299,3 +300,17 @@ export const setBodyUserSelect = (nextValues: UserSelectValues): UserSelectValue
 
   return previousValues;
 };
+
+export function generateRootSpan(trace: ParsedTraceType): SpanType {
+  const rootSpan: SpanType = {
+    trace_id: trace.traceID,
+    span_id: trace.rootSpanID,
+    parent_span_id: trace.parentSpanID,
+    start_timestamp: trace.traceStartTimestamp,
+    timestamp: trace.traceEndTimestamp,
+    op: trace.op,
+    data: {},
+  };
+
+  return rootSpan;
+}
diff --git a/src/sentry/static/sentry/app/utils/createFuzzySearch.jsx b/src/sentry/static/sentry/app/utils/createFuzzySearch.tsx
similarity index 70%
rename from src/sentry/static/sentry/app/utils/createFuzzySearch.jsx
rename to src/sentry/static/sentry/app/utils/createFuzzySearch.tsx
index 31e1e77498..37277361df 100644
--- a/src/sentry/static/sentry/app/utils/createFuzzySearch.jsx
+++ b/src/sentry/static/sentry/app/utils/createFuzzySearch.tsx
@@ -4,7 +4,10 @@ export function loadFuzzySearch() {
   return import(/* webpackChunkName: "Fuse" */ 'fuse.js');
 }
 
-export function createFuzzySearch(objects, options = {}) {
+export function createFuzzySearch<
+  T = string,
+  Options extends Fuse.FuseOptions<T> = Fuse.FuseOptions<T>
+>(objects: any[], options: Options): Promise<Fuse<T, Options>> {
   if (!options.keys) {
     throw new Error('You need to define `options.keys`');
   }
diff --git a/src/sentry/static/sentry/app/utils/theme.tsx b/src/sentry/static/sentry/app/utils/theme.tsx
index 17caef0331..f850229883 100644
--- a/src/sentry/static/sentry/app/utils/theme.tsx
+++ b/src/sentry/static/sentry/app/utils/theme.tsx
@@ -192,6 +192,7 @@ const theme = {
   zIndex: {
     traceView: {
       spanTreeToggler: 900,
+      rowInfoMessage: 900,
       dividerLine: 909,
       minimapContainer: 999,
     },
diff --git a/yarn.lock b/yarn.lock
index 6bc5218638..9c453baa3a 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -6226,11 +6226,16 @@ functions-have-names@^1.1.1:
   resolved "https://registry.yarnpkg.com/functions-have-names/-/functions-have-names-1.2.0.tgz#83da7583e4ea0c9ac5ff530f73394b033e0bf77d"
   integrity sha512-zKXyzksTeaCSw5wIX79iCA40YAa6CJMJgNg9wdkU/ERBrIdPSimPICYiLp65lRbSBqtiHql/HZfS2DyI/AH6tQ==
 
-fuse.js@^3.0.1, fuse.js@^3.2.0, fuse.js@^3.3.0:
+fuse.js@^3.0.1, fuse.js@^3.3.0:
   version "3.4.5"
   resolved "https://registry.yarnpkg.com/fuse.js/-/fuse.js-3.4.5.tgz#8954fb43f9729bd5dbcb8c08f251db552595a7a6"
   integrity sha512-s9PGTaQIkT69HaeoTVjwGsLfb8V8ScJLx5XGFcKHg0MqLUH/UZ4EKOtqtXX9k7AFqCGxD1aJmYb8Q5VYDibVRQ==
 
+fuse.js@^3.4.6:
+  version "3.4.6"
+  resolved "https://registry.yarnpkg.com/fuse.js/-/fuse.js-3.4.6.tgz#545c3411fed88bf2e27c457cab6e73e7af697a45"
+  integrity sha512-H6aJY4UpLFwxj1+5nAvufom5b2BT2v45P1MkPvdGIK8fWjQx/7o6tTT1+ALV0yawQvbmvCF0ufl2et8eJ7v7Cg==
+
 gauge@~2.7.3:
   version "2.7.4"
   resolved "https://registry.yarnpkg.com/gauge/-/gauge-2.7.4.tgz#2c03405c7538c39d7eb37b317022e325fb018bf7"

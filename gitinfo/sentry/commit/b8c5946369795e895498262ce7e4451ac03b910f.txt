commit b8c5946369795e895498262ce7e4451ac03b910f
Author: David Cramer <dcramer@gmail.com>
Date:   Thu Mar 16 11:38:56 2017 -0700

    [quotas] support soft-quotas (unenforced) (#5081)
    
    This adds a flag to RedisQuota (``enforce``) which can be used to track soft quotas, which are not always enforced but are always counted.

diff --git a/src/sentry/quotas/redis.py b/src/sentry/quotas/redis.py
index 1b1a22256d..5bd8e3d977 100644
--- a/src/sentry/quotas/redis.py
+++ b/src/sentry/quotas/redis.py
@@ -19,13 +19,19 @@ is_rate_limited = load_script('quotas/is_rate_limited.lua')
 
 
 class BasicRedisQuota(object):
-    __slots__ = ['key', 'limit', 'window', 'reason_code']
+    __slots__ = ['key', 'limit', 'window', 'reason_code', 'enforce']
 
-    def __init__(self, key, limit=0, window=60, reason_code=None):
+    def __init__(self, key, limit=0, window=60, reason_code=None,
+                 enforce=True):
         self.key = key
+        # maximum number of events in the given window
         self.limit = limit
+        # time in seconds that this quota reflects
         self.window = window
+        # a machine readable string
         self.reason_code = reason_code
+        # should this quota be hard-enforced (or just tracked)
+        self.enforce = enforce
 
 
 class RedisQuota(Quota):
@@ -95,16 +101,19 @@ class RedisQuota(Quota):
         client = self.cluster.get_local_client_for_key(six.text_type(project.organization.pk))
         rejections = is_rate_limited(client, keys, args)
         if any(rejections):
+            enforce = False
             worst_case = (0, None)
             for quota, rejected in zip(quotas, rejections):
                 if not rejected:
                     continue
-                delay = get_next_period_start(quota.window) - timestamp
-                if delay > worst_case[0]:
-                    worst_case = (delay, quota.reason_code)
-            return RateLimited(
-                retry_after=worst_case[0],
-                reason_code=worst_case[1],
-            )
-        else:
-            return NotRateLimited()
+                if quota.enforce:
+                    enforce = True
+                    delay = get_next_period_start(quota.window) - timestamp
+                    if delay > worst_case[0]:
+                        worst_case = (delay, quota.reason_code)
+            if enforce:
+                return RateLimited(
+                    retry_after=worst_case[0],
+                    reason_code=worst_case[1],
+                )
+        return NotRateLimited()
diff --git a/tests/sentry/quotas/redis/tests.py b/tests/sentry/quotas/redis/tests.py
index a19410c650..090f38310e 100644
--- a/tests/sentry/quotas/redis/tests.py
+++ b/tests/sentry/quotas/redis/tests.py
@@ -10,6 +10,7 @@ from exam import fixture, patcher
 
 from sentry.quotas.redis import (
     is_rate_limited,
+    BasicRedisQuota,
     RedisQuota,
 )
 from sentry.testutils import TestCase
@@ -88,3 +89,49 @@ class RedisQuotaTest(TestCase):
         self.get_organization_quota.return_value = (100, 60)
         self.get_project_quota.return_value = (200, 60)
         assert self.quota.is_rate_limited(self.project).is_limited
+
+    @mock.patch.object(RedisQuota, 'get_quotas')
+    @mock.patch('sentry.quotas.redis.is_rate_limited', return_value=(True, False))
+    def test_not_limited_without_enforce(self, mock_is_rate_limited,
+                                         mock_get_quotas):
+        mock_get_quotas.return_value = (
+            BasicRedisQuota(
+                key='p:1',
+                limit=1,
+                window=1,
+                reason_code='project_quota',
+                enforce=False,
+            ),
+            BasicRedisQuota(
+                key='p:2',
+                limit=1,
+                window=1,
+                reason_code='project_quota',
+                enforce=True,
+            ),
+        )
+
+        assert not self.quota.is_rate_limited(self.project).is_limited
+
+    @mock.patch.object(RedisQuota, 'get_quotas')
+    @mock.patch('sentry.quotas.redis.is_rate_limited', return_value=(True, True))
+    def test_limited_without_enforce(self, mock_is_rate_limited,
+                                     mock_get_quotas):
+        mock_get_quotas.return_value = (
+            BasicRedisQuota(
+                key='p:1',
+                limit=1,
+                window=1,
+                reason_code='project_quota',
+                enforce=False,
+            ),
+            BasicRedisQuota(
+                key='p:2',
+                limit=1,
+                window=1,
+                reason_code='project_quota',
+                enforce=True,
+            ),
+        )
+
+        assert self.quota.is_rate_limited(self.project).is_limited

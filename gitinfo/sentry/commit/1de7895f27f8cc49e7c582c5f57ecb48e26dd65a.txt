commit 1de7895f27f8cc49e7c582c5f57ecb48e26dd65a
Author: Danny Lee <leedongwei@gmail.com>
Date:   Mon Sep 23 19:27:30 2019 -0700

    ref(discover-v2): Minor changes and file rename

diff --git a/src/sentry/static/sentry/app/components/gridEditable/grid.tsx b/src/sentry/static/sentry/app/components/gridEditable/grid.tsx
deleted file mode 100644
index 1c0251ad45..0000000000
--- a/src/sentry/static/sentry/app/components/gridEditable/grid.tsx
+++ /dev/null
@@ -1,304 +0,0 @@
-import React from 'react';
-
-import {t} from 'app/locale';
-import {openModal} from 'app/actionCreators/modal';
-
-import Alert from 'app/components/alert';
-import EmptyStateWarning from 'app/components/emptyStateWarning';
-import InlineSvg from 'app/components/inlineSvg';
-import LoadingContainer from 'app/components/loading/loadingContainer';
-import ToolTip from 'app/components/tooltip';
-
-import {GridColumn, GridColumnOrder, GridColumnSortBy} from './gridTypes';
-import GridHeadCell from './gridHeadCell';
-import GridModalEditColumn from './gridModalEditColumn';
-import {
-  GridPanel,
-  GridPanelBody,
-  Grid,
-  GridRow,
-  GridHead,
-  GridBody,
-  GridBodyCell,
-  GridBodyCellSpan,
-  GridBodyCellLoading,
-  GridEditGroup,
-  GridEditGroupButton,
-} from './styles';
-
-export type GridEditableProps<DataRow, ColumnKey extends keyof DataRow> = {
-  isEditable?: boolean;
-  isLoading?: boolean;
-  error?: React.ReactNode | null;
-
-  /**
-   * GridEditable (mostly) do not maintain any internal state and relies on the
-   * parent component to tell it how/what to render and will mutate the view
-   * based on this 3 main props.
-   *
-   * - `columnOrder` determines the columns to show, from left to right
-   * - `columnSortBy` is not used at the moment, however it might be better to
-   *   move sorting into Grid for performance
-   */
-  columnOrder: GridColumnOrder<ColumnKey>[];
-  columnSortBy: GridColumnSortBy<ColumnKey>[];
-  data: DataRow[];
-
-  /**
-   * GridEditable allows the parent component to determine how to display the
-   * data within it. Note that this is optional.
-   */
-  grid: {
-    renderHeaderCell?: (column: GridColumnOrder<ColumnKey>) => React.ReactNode;
-    renderBodyCell?: (
-      column: GridColumnOrder<ColumnKey>,
-      dataRow: DataRow
-    ) => React.ReactNode;
-  };
-
-  /**
-   * As GridEditable is unopinionated about the structure of GridColumn,
-   * ModalEditColumn relies on the parent component to provide the form layout
-   * and logic to create/update the columns
-   */
-  modalEditColumn: {
-    renderBodyWithForm: (
-      indexOfColumnOrder?: number,
-      column?: GridColumn<ColumnKey>
-    ) => React.ReactNode;
-    renderFooter: () => React.ReactNode;
-  };
-
-  /**
-   * As there is no internal state being maintained, the parent component will
-   * have to provide functions to move/delete the columns
-   */
-  actions: {
-    moveColumn: (fromIndex: number, toIndex: number) => void;
-    deleteColumn: (index: number) => void;
-  };
-};
-export type GridEditableState = {
-  isEditing: boolean;
-  numColumn: number;
-};
-
-class GridEditable<DataRow extends Object> extends React.Component<
-  GridEditableProps<DataRow, keyof DataRow>,
-  GridEditableState
-> {
-  static defaultProps = {
-    isEditable: false,
-  };
-
-  state = {
-    numColumn: 0,
-    isEditing: false,
-  };
-
-  // Static methods do not allow the use of generics bounded to the parent class
-  // For more info: https://github.com/microsoft/TypeScript/issues/14600
-  static getDerivedStateFromProps(
-    props: GridEditableProps<Object, keyof Object>,
-    prevState: GridEditableState
-  ): GridEditableState {
-    return {
-      ...prevState,
-      numColumn: props.columnOrder.length,
-    };
-  }
-
-  toggleEdit = () => {
-    this.setState({isEditing: !this.state.isEditing});
-  };
-
-  toggleModalEditColumn = (
-    indexOfColumnOrder?: number,
-    column?: GridColumn<keyof DataRow>
-  ) => {
-    if (this.state.isEditing) {
-      const {modalEditColumn} = this.props;
-
-      openModal(openModalProps => (
-        <GridModalEditColumn
-          {...openModalProps}
-          indexOfColumnOrder={indexOfColumnOrder}
-          column={column}
-          renderBody={modalEditColumn.renderBodyWithForm}
-          renderFooter={modalEditColumn.renderFooter}
-        />
-      ));
-    }
-  };
-
-  renderError = () => {
-    const {error} = this.props;
-
-    return (
-      <React.Fragment>
-        <Alert type="error" icon="icon-circle-exclamation">
-          {error}
-        </Alert>
-        <GridPanel>
-          <Grid numColumn={this.state.numColumn}>
-            {this.renderGridHead()}
-            <GridBody>
-              <GridBodyCellSpan>{error}</GridBodyCellSpan>
-            </GridBody>
-          </Grid>
-        </GridPanel>
-      </React.Fragment>
-    );
-  };
-
-  renderLoading = () => {
-    return (
-      <GridBody>
-        <GridBodyCellSpan>
-          <GridBodyCellLoading>
-            <LoadingContainer isLoading={true} />
-          </GridBodyCellLoading>
-        </GridBodyCellSpan>
-      </GridBody>
-    );
-  };
-
-  renderEmptyData = () => {
-    return (
-      <GridBody>
-        <GridBodyCellSpan>
-          <EmptyStateWarning>
-            <p>{t('No results found')}</p>
-          </EmptyStateWarning>
-        </GridBodyCellSpan>
-      </GridBody>
-    );
-  };
-
-  renderGridHead = () => {
-    const {isEditable, columnOrder, actions, grid} = this.props;
-    const {isEditing} = this.state;
-
-    // Ensure that the last column cannot be removed
-    const enableEdit = isEditing && columnOrder.length > 1;
-
-    return (
-      <GridHead>
-        <GridRow>
-          {/* GridHeadEdit must come first.
-
-              It is a <th> that uses `position: absolute` to set its placement.
-              The CSS selectors captures the last GridHeadCell and put a
-              padding-right to provide space for GridHeadEdit to be displayed.
-
-              FAQ:
-              Instead of using `position: absolute`, why can't we just put
-              GridHeadEdit at the end so it appears on the right?
-              Because CSS Grids need to have the same number of Head/Body cells
-              for everything to align properly. Sub-grids are new and may not be
-              well supported in older browsers/
-
-              Why can't we just put GridHeadEdit somewhere else?
-              Because HTML rules mandate that <div> cannot be a nested child of
-              a <table>. This seems the best way to make it correct to satisfy
-              HTML semantics. */
-          isEditable && this.renderGridHeadEditButtons()}
-
-          {columnOrder.map((column, i) => (
-            <GridHeadCell
-              key={`${column.key}${i}`}
-              isPrimary={column.isPrimary}
-              isEditing={enableEdit}
-              actions={{
-                deleteColumn: () => actions.deleteColumn(i),
-                toggleModalEditColumn: () => this.toggleModalEditColumn(i, column),
-              }}
-            >
-              {grid.renderHeaderCell ? grid.renderHeaderCell(column) : column.name}
-            </GridHeadCell>
-          ))}
-        </GridRow>
-      </GridHead>
-    );
-  };
-
-  renderGridHeadEditButtons = () => {
-    if (!this.props.isEditable) {
-      return null;
-    }
-
-    if (!this.state.isEditing) {
-      return (
-        <GridEditGroup>
-          <GridEditGroupButton onClick={this.toggleEdit}>
-            <ToolTip title={t('Edit Columns')}>
-              <InlineSvg src="icon-edit-pencil" />
-            </ToolTip>
-          </GridEditGroupButton>
-        </GridEditGroup>
-      );
-    }
-
-    return (
-      <GridEditGroup>
-        <GridEditGroupButton onClick={() => this.toggleModalEditColumn()}>
-          <ToolTip title={t('Add Columns')}>
-            <InlineSvg src="icon-circle-add" />
-          </ToolTip>
-        </GridEditGroupButton>
-        <GridEditGroupButton onClick={this.toggleEdit}>
-          <ToolTip title={t('Cancel Edit')}>
-            <InlineSvg src="icon-close" />
-          </ToolTip>
-        </GridEditGroupButton>
-      </GridEditGroup>
-    );
-  };
-
-  renderGridBody = () => {
-    const {data} = this.props;
-
-    if (!data || data.length === 0) {
-      return this.renderEmptyData();
-    }
-
-    return <GridBody>{data.map(this.renderGridBodyRow)}</GridBody>;
-  };
-
-  renderGridBodyRow = (dataRow: DataRow, row: number) => {
-    const {grid} = this.props;
-
-    return (
-      <GridRow key={row}>
-        {this.props.columnOrder.map((col, i) => (
-          <GridBodyCell key={`${col.key}${i}`}>
-            {grid.renderBodyCell ? grid.renderBodyCell(col, dataRow) : dataRow[col.key]}
-          </GridBodyCell>
-        ))}
-      </GridRow>
-    );
-  };
-
-  render() {
-    if (this.props.error) {
-      return this.renderError();
-    }
-
-    return (
-      <GridPanel>
-        <GridPanelBody>
-          <Grid
-            isEditable={this.props.isEditable}
-            isEditing={this.state.isEditing}
-            numColumn={this.state.numColumn}
-          >
-            {this.renderGridHead()}
-            {this.props.isLoading ? this.renderLoading() : this.renderGridBody()}
-          </Grid>
-        </GridPanelBody>
-      </GridPanel>
-    );
-  }
-}
-
-export default GridEditable;
diff --git a/src/sentry/static/sentry/app/components/gridEditable/gridHeadCell.tsx b/src/sentry/static/sentry/app/components/gridEditable/gridHeadCell.tsx
index 1ff52f42f6..8954e71313 100644
--- a/src/sentry/static/sentry/app/components/gridEditable/gridHeadCell.tsx
+++ b/src/sentry/static/sentry/app/components/gridEditable/gridHeadCell.tsx
@@ -14,14 +14,18 @@ import {
   GridHeadCellResizer,
 } from './styles';
 
-export type GridHeadCellProps = {
+export type GridHeadCellProps<Column> = {
   isEditing: boolean;
   isPrimary: boolean;
+
+  indexColumnOrder: number;
+  column: Column;
   children: React.ReactNode | React.ReactChild;
 
   actions: {
-    deleteColumn: () => void;
-    toggleModalEditColumn: () => void;
+    moveColumn: (indexFrom: number, indexTo: number) => void;
+    deleteColumn: (index: number) => void;
+    toggleModalEditColumn: (index?: number, column?: Column) => void;
   };
 };
 export type GridHeadCellState = {
@@ -33,7 +37,10 @@ export type GridHeadCellState = {
  * states that are only specific to the header. This component aims to abstract
  * the complexity of GridHeadCell away.
  */
-class GridHeadCell extends React.Component<GridHeadCellProps, GridHeadCellState> {
+class GridHeadCell<Column> extends React.Component<
+  GridHeadCellProps<Column>,
+  GridHeadCellState
+> {
   static defaultProps = {
     isEditing: false,
     isPrimary: false,
@@ -47,9 +54,17 @@ class GridHeadCell extends React.Component<GridHeadCellProps, GridHeadCellState>
     this.setState({isHovering});
   };
 
-  renderButtonHoverDraggable(children: React.ReactNode) {
-    const {actions} = this.props;
+  deleteColumn = () => {
+    const {actions, indexColumnOrder} = this.props;
+    actions.deleteColumn(indexColumnOrder);
+  };
 
+  toggleModal = () => {
+    const {actions, indexColumnOrder, column} = this.props;
+    actions.toggleModalEditColumn(indexColumnOrder, column);
+  };
+
+  renderButtonHoverDraggable(children: React.ReactNode) {
     return (
       <React.Fragment>
         {/* Ensure that background is always at the top. The background must be
@@ -63,10 +78,10 @@ class GridHeadCell extends React.Component<GridHeadCellProps, GridHeadCellState>
           )}
 
           <GridHeadCellButtonHoverButtonGroup isFlagged={FLAG_GRID_DRAGGABLE}>
-            <GridHeadCellButtonHoverButton onClick={actions.toggleModalEditColumn}>
+            <GridHeadCellButtonHoverButton onClick={this.toggleModal}>
               <InlineSvg src="icon-edit-pencil" />
             </GridHeadCellButtonHoverButton>
-            <GridHeadCellButtonHoverButton onClick={actions.deleteColumn}>
+            <GridHeadCellButtonHoverButton onClick={this.deleteColumn}>
               <InlineSvg src="icon-trash" />
             </GridHeadCellButtonHoverButton>
           </GridHeadCellButtonHoverButtonGroup>
diff --git a/src/sentry/static/sentry/app/components/gridEditable/gridModalEditColumn.tsx b/src/sentry/static/sentry/app/components/gridEditable/gridModalEditColumn.tsx
index f117f40c7c..2eb1a3db48 100644
--- a/src/sentry/static/sentry/app/components/gridEditable/gridModalEditColumn.tsx
+++ b/src/sentry/static/sentry/app/components/gridEditable/gridModalEditColumn.tsx
@@ -3,10 +3,16 @@ import React from 'react';
 import {t} from 'app/locale';
 
 export type GridModalEditColumnProps<Column> = {
-  indexOfColumnOrder?: number;
+  indexColumnOrder?: number;
   column?: Column;
 
-  renderBody: (indexOfColumnOrder?: number, column?: Column) => React.ReactNode;
+  renderBodyWithForm: (
+    indexColumnOrder?: number,
+    column?: Column,
+    onSubmit?: (column: Column) => void,
+    onSuccess?: () => void,
+    onError?: () => void
+  ) => React.ReactNode;
   renderFooter: () => React.ReactNode;
 
   /**
@@ -36,16 +42,17 @@ class GridModalEditColumn<Column> extends React.Component<
       Header,
       Body,
       Footer,
-      indexOfColumnOrder,
+      closeModal,
+      indexColumnOrder,
       column,
-      renderBody,
+      renderBodyWithForm,
       renderFooter,
     } = this.props;
 
     return (
       <React.Fragment>
         <Header>{this.renderHeader()}</Header>
-        <Body>{renderBody(indexOfColumnOrder, column)}</Body>
+        <Body>{renderBodyWithForm(indexColumnOrder, column, undefined, closeModal)}</Body>
         <Footer>{renderFooter()}</Footer>
       </React.Fragment>
     );
diff --git a/src/sentry/static/sentry/app/components/gridEditable/index.tsx b/src/sentry/static/sentry/app/components/gridEditable/index.tsx
index ec0e3d4efa..295cf1a89f 100644
--- a/src/sentry/static/sentry/app/components/gridEditable/index.tsx
+++ b/src/sentry/static/sentry/app/components/gridEditable/index.tsx
@@ -1,12 +1,328 @@
-import Grid from './grid';
-import gridModalEditColumn from './gridModalEditColumn';
+import React from 'react';
 
-export default Grid;
+import {t} from 'app/locale';
+import {openModal} from 'app/actionCreators/modal';
+
+import Alert from 'app/components/alert';
+import EmptyStateWarning from 'app/components/emptyStateWarning';
+import InlineSvg from 'app/components/inlineSvg';
+import LoadingContainer from 'app/components/loading/loadingContainer';
+import ToolTip from 'app/components/tooltip';
+
+import {GridColumn, GridColumnHeader, GridColumnOrder, GridColumnSortBy} from './types';
+import GridHeadCell from './gridHeadCell';
+import GridModalEditColumn from './gridModalEditColumn';
+import {
+  GridPanel,
+  GridPanelBody,
+  Grid,
+  GridRow,
+  GridHead,
+  GridBody,
+  GridBodyCell,
+  GridBodyCellSpan,
+  GridBodyCellLoading,
+  GridEditGroup,
+  GridEditGroupButton,
+} from './styles';
+
+type GridEditableProps<DataRow, ColumnKey extends keyof DataRow> = {
+  isEditable?: boolean;
+  isLoading?: boolean;
+  error?: React.ReactNode | null;
+
+  /**
+   * GridEditable (mostly) do not maintain any internal state and relies on the
+   * parent component to tell it how/what to render and will mutate the view
+   * based on this 3 main props.
+   *
+   * - `columnOrder` determines the columns to show, from left to right
+   * - `columnSortBy` is not used at the moment, however it might be better to
+   *   move sorting into Grid for performance
+   */
+  columnOrder: GridColumnOrder<ColumnKey>[];
+  columnSortBy: GridColumnSortBy<ColumnKey>[];
+  data: DataRow[];
+
+  /**
+   * GridEditable allows the parent component to determine how to display the
+   * data within it. Note that this is optional.
+   */
+  grid: {
+    renderHeaderCell?: (column: GridColumnOrder<ColumnKey>) => React.ReactNode;
+    renderBodyCell?: (
+      column: GridColumnOrder<ColumnKey>,
+      dataRow: DataRow
+    ) => React.ReactNode;
+  };
+
+  /**
+   * As GridEditable is unopinionated about the structure of GridColumn,
+   * ModalEditColumn relies on the parent component to provide the form layout
+   * and logic to create/update the columns
+   */
+  modalEditColumn: {
+    renderBodyWithForm: (
+      indexColumnOrder?: number,
+      column?: GridColumn<ColumnKey>,
+      onSubmit?: (column: GridColumn<ColumnKey>) => void,
+      onSuccess?: () => void,
+      onError?: () => void
+    ) => React.ReactNode;
+    renderFooter: () => React.ReactNode;
+  };
+
+  /**
+   * As there is no internal state being maintained, the parent component will
+   * have to provide functions to move/delete the columns
+   */
+  actions: {
+    moveColumn: (indexFrom: number, indexTo: number) => void;
+    deleteColumn: (index: number) => void;
+  };
+};
+
+type GridEditableState = {
+  isEditing: boolean;
+  numColumn: number;
+};
+
+class GridEditable<
+  DataRow extends Object,
+  ColumnKey extends keyof DataRow
+> extends React.Component<GridEditableProps<DataRow, ColumnKey>, GridEditableState> {
+  static defaultProps = {
+    isEditable: false,
+  };
+
+  state = {
+    numColumn: 0,
+    isEditing: false,
+  };
+
+  // Static methods do not allow the use of generics bounded to the parent class
+  // For more info: https://github.com/microsoft/TypeScript/issues/14600
+  static getDerivedStateFromProps(
+    props: GridEditableProps<Object, keyof Object>,
+    prevState: GridEditableState
+  ): GridEditableState {
+    return {
+      ...prevState,
+      numColumn: props.columnOrder.length,
+    };
+  }
+
+  toggleEdit = () => {
+    this.setState({isEditing: !this.state.isEditing});
+  };
+
+  toggleModalEditColumn = (
+    indexColumnOrder?: number,
+    column?: GridColumn<ColumnKey>
+  ): void => {
+    if (this.state.isEditing) {
+      const {modalEditColumn} = this.props;
+
+      openModal(openModalProps => (
+        <GridModalEditColumn
+          {...openModalProps}
+          indexColumnOrder={indexColumnOrder}
+          column={column}
+          renderBodyWithForm={modalEditColumn.renderBodyWithForm}
+          renderFooter={modalEditColumn.renderFooter}
+        />
+      ));
+    }
+  };
+
+  renderError = () => {
+    const {error} = this.props;
+
+    return (
+      <React.Fragment>
+        <Alert type="error" icon="icon-circle-exclamation">
+          {error}
+        </Alert>
+        <GridPanel>
+          <Grid
+            isEditable={this.props.isEditable}
+            isEditing={this.state.isEditing}
+            numColumn={this.state.numColumn}
+          >
+            {this.renderGridHead()}
+            <GridBody>
+              <GridRow>
+                <GridBodyCellSpan>{error}</GridBodyCellSpan>
+              </GridRow>
+            </GridBody>
+          </Grid>
+        </GridPanel>
+      </React.Fragment>
+    );
+  };
+
+  renderLoading = () => {
+    return (
+      <GridBody>
+        <GridRow>
+          <GridBodyCellSpan>
+            <GridBodyCellLoading>
+              <LoadingContainer isLoading={true} />
+            </GridBodyCellLoading>
+          </GridBodyCellSpan>
+        </GridRow>
+      </GridBody>
+    );
+  };
+
+  renderEmptyData = () => {
+    return (
+      <GridBody>
+        <GridRow>
+          <GridBodyCellSpan>
+            <EmptyStateWarning>
+              <p>{t('No results found')}</p>
+            </EmptyStateWarning>
+          </GridBodyCellSpan>
+        </GridRow>
+      </GridBody>
+    );
+  };
+
+  renderGridHead = () => {
+    const {isEditable, columnOrder, actions, grid} = this.props;
+    const {isEditing} = this.state;
+
+    // Ensure that the last column cannot be removed
+    const enableEdit = isEditing && columnOrder.length > 1;
+
+    return (
+      <GridHead>
+        <GridRow>
+          {/* GridHeadEdit must come first.
+
+              It is a <th> that uses `position: absolute` to set its placement.
+              The CSS selectors captures the last GridHeadCell and put a
+              padding-right to provide space for GridHeadEdit to be displayed.
+
+              FAQ:
+              Instead of using `position: absolute`, why can't we just put
+              GridHeadEdit at the end so it appears on the right?
+              Because CSS Grids need to have the same number of Head/Body cells
+              for everything to align properly. Sub-grids are new and may not be
+              well supported in older browsers/
+
+              Why can't we just put GridHeadEdit somewhere else?
+              Because HTML rules mandate that <div> cannot be a nested child of
+              a <table>. This seems the best way to make it correct to satisfy
+              HTML semantics. */
+          isEditable && this.renderGridHeadEditButtons()}
+
+          {columnOrder.map((column, i) => (
+            <GridHeadCell
+              key={`${i}.${column.key}`}
+              isPrimary={column.isPrimary}
+              isEditing={enableEdit}
+              indexColumnOrder={i}
+              column={column}
+              actions={{
+                moveColumn: actions.moveColumn,
+                deleteColumn: actions.deleteColumn,
+                toggleModalEditColumn: this.toggleModalEditColumn,
+              }}
+            >
+              {grid.renderHeaderCell ? grid.renderHeaderCell(column) : column.name}
+            </GridHeadCell>
+          ))}
+        </GridRow>
+      </GridHead>
+    );
+  };
+
+  renderGridHeadEditButtons = () => {
+    if (!this.props.isEditable) {
+      return null;
+    }
+
+    if (!this.state.isEditing) {
+      return (
+        <GridEditGroup>
+          <GridEditGroupButton onClick={this.toggleEdit}>
+            <ToolTip title={t('Edit Columns')}>
+              <InlineSvg src="icon-edit-pencil" />
+            </ToolTip>
+          </GridEditGroupButton>
+        </GridEditGroup>
+      );
+    }
+
+    return (
+      <GridEditGroup>
+        <GridEditGroupButton onClick={() => this.toggleModalEditColumn()}>
+          <ToolTip title={t('Add Columns')}>
+            <InlineSvg src="icon-circle-add" />
+          </ToolTip>
+        </GridEditGroupButton>
+        <GridEditGroupButton onClick={this.toggleEdit}>
+          <ToolTip title={t('Cancel Edit')}>
+            <InlineSvg src="icon-close" />
+          </ToolTip>
+        </GridEditGroupButton>
+      </GridEditGroup>
+    );
+  };
+
+  renderGridBody = () => {
+    const {data} = this.props;
+
+    if (!data || data.length === 0) {
+      return this.renderEmptyData();
+    }
+
+    return <GridBody>{data.map(this.renderGridBodyRow)}</GridBody>;
+  };
+
+  renderGridBodyRow = (dataRow: DataRow, row: number) => {
+    const {grid} = this.props;
+
+    return (
+      <GridRow key={row}>
+        {this.props.columnOrder.map((col, i) => (
+          <GridBodyCell key={`${col.key}${i}`}>
+            {grid.renderBodyCell ? grid.renderBodyCell(col, dataRow) : dataRow[col.key]}
+          </GridBodyCell>
+        ))}
+      </GridRow>
+    );
+  };
+
+  render() {
+    if (this.props.error) {
+      return this.renderError();
+    }
+
+    return (
+      <GridPanel>
+        <GridPanelBody>
+          <Grid
+            isEditable={this.props.isEditable}
+            isEditing={this.state.isEditing}
+            numColumn={this.state.numColumn}
+          >
+            {this.renderGridHead()}
+            {this.props.isLoading ? this.renderLoading() : this.renderGridBody()}
+          </Grid>
+        </GridPanelBody>
+      </GridPanel>
+    );
+  }
+}
+
+export default GridEditable;
 export {
   GridColumn,
   GridColumnHeader,
   GridColumnOrder,
   GridColumnSortBy,
-} from './gridTypes';
-export {GridEditableProps} from './grid';
-export {gridModalEditColumn};
+  GridModalEditColumn,
+};
diff --git a/src/sentry/static/sentry/app/components/gridEditable/styles.tsx b/src/sentry/static/sentry/app/components/gridEditable/styles.tsx
index fb118f81ba..34e3f5c646 100644
--- a/src/sentry/static/sentry/app/components/gridEditable/styles.tsx
+++ b/src/sentry/static/sentry/app/components/gridEditable/styles.tsx
@@ -64,7 +64,7 @@ export const Grid = styled('table')<GridEditableProps>`
   th:last-child {
     ${p => {
       if (!p.isEditable) {
-        return '0px';
+        return 'padding-right: 0px';
       }
       if (!p.isEditing) {
         return `padding-right: ${GRID_EDIT_WIDTH};`;
diff --git a/src/sentry/static/sentry/app/components/gridEditable/gridTypes.tsx b/src/sentry/static/sentry/app/components/gridEditable/types.tsx
similarity index 100%
rename from src/sentry/static/sentry/app/components/gridEditable/gridTypes.tsx
rename to src/sentry/static/sentry/app/components/gridEditable/types.tsx

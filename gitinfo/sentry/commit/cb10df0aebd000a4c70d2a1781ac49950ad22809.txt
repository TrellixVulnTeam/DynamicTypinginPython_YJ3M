commit cb10df0aebd000a4c70d2a1781ac49950ad22809
Author: ted kaemming <t.kaemming+github@gmail.com>
Date:   Fri Aug 12 14:12:13 2016 -0700

    Add unique user frequency condition. (#3849)

diff --git a/src/sentry/constants.py b/src/sentry/constants.py
index 25e67114ed..2332efe6e7 100644
--- a/src/sentry/constants.py
+++ b/src/sentry/constants.py
@@ -128,6 +128,7 @@ SENTRY_RULES = (
     'sentry.rules.conditions.regression_event.RegressionEventCondition',
     'sentry.rules.conditions.tagged_event.TaggedEventCondition',
     'sentry.rules.conditions.event_frequency.EventFrequencyCondition',
+    'sentry.rules.conditions.event_frequency.EventUniqueUserFrequencyCondition',
     'sentry.rules.conditions.event_attribute.EventAttributeCondition',
     'sentry.rules.conditions.level.LevelCondition',
 )
diff --git a/src/sentry/rules/conditions/event_frequency.py b/src/sentry/rules/conditions/event_frequency.py
index 7bf99bc80d..8ef77100a6 100644
--- a/src/sentry/rules/conditions/event_frequency.py
+++ b/src/sentry/rules/conditions/event_frequency.py
@@ -8,9 +8,8 @@ sentry.rules.conditions.event_frequency
 
 from __future__ import absolute_import
 
-from datetime import datetime, timedelta
+from datetime import timedelta
 from django import forms
-from pytz import utc
 
 from django.utils import timezone
 from sentry.rules.conditions.base import EventCondition
@@ -34,16 +33,16 @@ class EventFrequencyForm(forms.Form):
     }))
 
 
-class EventFrequencyCondition(EventCondition):
+class BaseEventFrequencyCondition(EventCondition):
     form_cls = EventFrequencyForm
-    label = 'An event is seen more than {value} times in {interval}'
+    label = NotImplemented  # subclass must implement
 
     def __init__(self, *args, **kwargs):
         from sentry.app import tsdb
 
         self.tsdb = kwargs.pop('tsdb', tsdb)
 
-        super(EventFrequencyCondition, self).__init__(*args, **kwargs)
+        super(BaseEventFrequencyCondition, self).__init__(*args, **kwargs)
 
     def passes(self, event, state):
         # when a rule is not active (i.e. it hasnt gone from inactive -> active)
@@ -74,13 +73,18 @@ class EventFrequencyCondition(EventCondition):
     def clear_cache(self, event):
         event._rate_cache = {}
 
+    def query(self, event, start, end):
+        """
+        """
+        raise NotImplementedError  # subclass must implement
+
     def get_rate(self, event, interval):
         if not hasattr(event, '_rate_cache'):
             event._rate_cache = {}
 
         result = event._rate_cache.get(interval)
         if result is None:
-            end = datetime.utcnow().replace(tzinfo=utc)
+            end = timezone.now()
             if interval == Interval.ONE_MINUTE:
                 start = end - timedelta(minutes=1)
             elif interval == Interval.ONE_HOUR:
@@ -90,12 +94,34 @@ class EventFrequencyCondition(EventCondition):
             else:
                 raise ValueError(interval)
 
-            result = self.tsdb.get_sums(
-                model=self.tsdb.models.group,
-                keys=[event.group_id],
-                start=start,
-                end=end,
-            )[event.group_id]
-            event._rate_cache[interval] = result
+            event._rate_cache[interval] = result = self.query(
+                event,
+                start,
+                end,
+            )
 
         return result
+
+
+class EventFrequencyCondition(BaseEventFrequencyCondition):
+    label = 'An event is seen more than {value} times in {interval}'
+
+    def query(self, event, start, end):
+        return self.tsdb.get_sums(
+            model=self.tsdb.models.group,
+            keys=[event.group_id],
+            start=start,
+            end=end,
+        )[event.group_id]
+
+
+class EventUniqueUserFrequencyCondition(BaseEventFrequencyCondition):
+    label = 'An event is seen by more than {value} users in {interval}'
+
+    def query(self, event, start, end):
+        return self.tsdb.get_distinct_counts_totals(
+            model=self.tsdb.models.users_affected_by_group,
+            keys=[event.group_id],
+            start=start,
+            end=end,
+        )[event.group_id]
diff --git a/tests/sentry/rules/conditions/test_event_frequency.py b/tests/sentry/rules/conditions/test_event_frequency.py
index de6ba7a7ad..2b85c24bcc 100644
--- a/tests/sentry/rules/conditions/test_event_frequency.py
+++ b/tests/sentry/rules/conditions/test_event_frequency.py
@@ -1,19 +1,27 @@
 from __future__ import absolute_import
 
-import six
+import itertools
+import pytz
+from datetime import datetime, timedelta
 
-from datetime import timedelta
-from django.utils import timezone
+import mock
+import six
 
 from sentry.app import tsdb
+from sentry.rules.conditions.event_frequency import (
+    EventFrequencyCondition, EventUniqueUserFrequencyCondition, Interval
+)
 from sentry.testutils.cases import RuleTestCase
-from sentry.rules.conditions.event_frequency import EventFrequencyCondition, Interval
 
 
-class EventFrequencyConditionTest(RuleTestCase):
-    rule_cls = EventFrequencyCondition
+class FrequencyConditionMixin(object):
+    def increment(self, event, count, timestamp=None):
+        raise NotImplementedError
+
+    @mock.patch('django.utils.timezone.now')
+    def test_one_minute(self, now):
+        now.return_value = datetime(2016, 8, 1, 0, 0, 0, 0, tzinfo=pytz.utc)
 
-    def test_one_minute(self):
         event = self.get_event()
         value = 10
         rule = self.get_rule({
@@ -21,23 +29,26 @@ class EventFrequencyConditionTest(RuleTestCase):
             'value': six.text_type(value),
         })
 
-        tsdb.incr(
-            tsdb.models.group,
-            event.group_id,
-            count=value + 1,
-            timestamp=timezone.now() - timedelta(minutes=5),
+        self.increment(
+            event,
+            value + 1,
+            timestamp=now() - timedelta(minutes=5),
         )
         self.assertDoesNotPass(rule, event)
 
         rule.clear_cache(event)
-        tsdb.incr(tsdb.models.group, event.group_id, count=value)
+        self.increment(event, value)
         self.assertDoesNotPass(rule, event)
 
         rule.clear_cache(event)
-        tsdb.incr(tsdb.models.group, event.group_id, count=1)
+        self.increment(event, 1)
+
         self.assertPasses(rule, event)
 
-    def test_one_hour(self):
+    @mock.patch('django.utils.timezone.now')
+    def test_one_hour(self, now):
+        now.return_value = datetime(2016, 8, 1, 0, 0, 0, 0, tzinfo=pytz.utc)
+
         event = self.get_event()
         value = 10
         rule = self.get_rule({
@@ -45,23 +56,26 @@ class EventFrequencyConditionTest(RuleTestCase):
             'value': six.text_type(value),
         })
 
-        tsdb.incr(
-            tsdb.models.group,
-            event.group_id,
-            count=value + 1,
-            timestamp=timezone.now() - timedelta(minutes=90),
+        self.increment(
+            event,
+            value + 1,
+            timestamp=now() - timedelta(minutes=90),
         )
         self.assertDoesNotPass(rule, event)
 
         rule.clear_cache(event)
-        tsdb.incr(tsdb.models.group, event.group_id, count=value)
+        self.increment(event, value)
         self.assertDoesNotPass(rule, event)
 
         rule.clear_cache(event)
-        tsdb.incr(tsdb.models.group, event.group_id, count=1)
+        self.increment(event, 1)
+
         self.assertPasses(rule, event)
 
-    def test_one_day(self):
+    @mock.patch('django.utils.timezone.now')
+    def test_one_day(self, now):
+        now.return_value = datetime(2016, 8, 1, 0, 0, 0, 0, tzinfo=pytz.utc)
+
         event = self.get_event()
         value = 10
         rule = self.get_rule({
@@ -69,23 +83,26 @@ class EventFrequencyConditionTest(RuleTestCase):
             'value': six.text_type(value),
         })
 
-        tsdb.incr(
-            tsdb.models.group,
-            event.group_id,
-            count=value + 1,
-            timestamp=timezone.now() - timedelta(hours=36),
+        self.increment(
+            event,
+            value + 1,
+            timestamp=now() - timedelta(hours=36),
         )
         self.assertDoesNotPass(rule, event)
 
         rule.clear_cache(event)
-        tsdb.incr(tsdb.models.group, event.group_id, count=value)
+        self.increment(event, value)
         self.assertDoesNotPass(rule, event)
 
         rule.clear_cache(event)
-        tsdb.incr(tsdb.models.group, event.group_id, count=1)
+        self.increment(event, 1)
+
         self.assertPasses(rule, event)
 
-    def test_doesnt_send_consecutive(self):
+    @mock.patch('django.utils.timezone.now')
+    def test_doesnt_send_consecutive(self, now):
+        now.return_value = datetime(2016, 8, 1, 0, 0, 0, 0, tzinfo=pytz.utc)
+
         event = self.get_event()
         value = 10
         rule = self.get_rule({
@@ -96,20 +113,46 @@ class EventFrequencyConditionTest(RuleTestCase):
         self.assertDoesNotPass(rule, event)
 
         rule.clear_cache(event)
-        tsdb.incr(tsdb.models.group, event.group_id, count=value + 1)
+        self.increment(event, value + 1)
+
         self.assertPasses(rule, event)
 
-        self.assertDoesNotPass(rule, event, rule_last_active=timezone.now())
+        self.assertDoesNotPass(rule, event, rule_last_active=now())
+
+    @mock.patch('django.utils.timezone.now')
+    def test_more_than_zero(self, now):
+        now.return_value = datetime(2016, 8, 1, 0, 0, 0, 0, tzinfo=pytz.utc)
 
-    def test_more_than_zero(self):
         event = self.get_event()
         rule = self.get_rule({
             'interval': Interval.ONE_MINUTE,
-            'value': '0',
+            'value': six.text_type('0'),
         })
 
         self.assertDoesNotPass(rule, event)
 
         rule.clear_cache(event)
-        tsdb.incr(tsdb.models.group, event.group_id, count=1)
+        self.increment(event, 1)
+
         self.assertPasses(rule, event)
+
+
+class EventFrequencyConditionTestCase(FrequencyConditionMixin, RuleTestCase):
+    rule_cls = EventFrequencyCondition
+
+    def increment(self, event, count, timestamp=None):
+        tsdb.incr(tsdb.models.group, event.group_id, count=count, timestamp=timestamp)
+
+
+class EventUniqueUserFrequencyConditionTestCase(FrequencyConditionMixin, RuleTestCase):
+    rule_cls = EventUniqueUserFrequencyCondition
+
+    sequence = itertools.count()  # generates unique values, class scope doesn't matter
+
+    def increment(self, event, count, timestamp=None):
+        tsdb.record(
+            tsdb.models.users_affected_by_group,
+            event.group_id,
+            [next(self.sequence) for _ in xrange(0, count)],
+            timestamp=timestamp
+        )

commit e5fa99ea74bd3f5c896d9c402f4212b13daa4eb1
Author: Danny Lee <dlee@sentry.io>
Date:   Wed Jun 10 15:06:55 2020 -0700

    feat(store): Add store for Releases and Deploys (#19129)

diff --git a/src/sentry/static/sentry/app/actionCreators/release.tsx b/src/sentry/static/sentry/app/actionCreators/release.tsx
new file mode 100644
index 0000000000..0c80335d82
--- /dev/null
+++ b/src/sentry/static/sentry/app/actionCreators/release.tsx
@@ -0,0 +1,72 @@
+import * as Sentry from '@sentry/browser';
+
+import ReleaseActions from 'app/actions/releaseActions';
+import {Client} from 'app/api';
+import ReleaseStore, {getReleaseStoreKey} from 'app/stores/releaseStore';
+import {Deploy, Release} from 'app/types';
+
+type ParamsGet = {
+  orgSlug: string;
+  projectSlug: string;
+  releaseVersion: string;
+};
+
+export function getProjectRelease(api: Client, params: ParamsGet) {
+  const {orgSlug, projectSlug, releaseVersion} = params;
+  const path = `/projects/${orgSlug}/${projectSlug}/releases/${encodeURIComponent(
+    releaseVersion
+  )}/`;
+  // HACK(leedongwei): Actions fired by the ActionCreators are queued to
+  // the back of the event loop, allowing another getRelease for the same
+  // release to be fired before the loading state is updated in store.
+  // This hack short-circuits that and update the state immediately.
+  ReleaseStore.state.releaseLoading[
+    getReleaseStoreKey(projectSlug, releaseVersion)
+  ] = true;
+  ReleaseActions.loadRelease(orgSlug, projectSlug, releaseVersion);
+
+  return api
+    .requestPromise(path, {
+      method: 'GET',
+    })
+    .then((res: Release) => {
+      ReleaseActions.loadReleaseSuccess(projectSlug, releaseVersion, res);
+    })
+    .catch(err => {
+      ReleaseActions.loadReleaseError(projectSlug, releaseVersion, err);
+      Sentry.withScope(scope => {
+        scope.setLevel(Sentry.Severity.Warning);
+        scope.setFingerprint(['getRelease-action-creator']);
+        Sentry.captureException(err);
+      });
+    });
+}
+
+export function getReleaseDeploys(api: Client, params: ParamsGet) {
+  const {orgSlug, projectSlug, releaseVersion} = params;
+  const path = `/organizations/${orgSlug}/releases/${encodeURIComponent(
+    releaseVersion
+  )}/deploys/`;
+
+  // HACK(leedongwei): Same as above
+  ReleaseStore.state.deploysLoading[
+    getReleaseStoreKey(projectSlug, releaseVersion)
+  ] = true;
+  ReleaseActions.loadDeploys(orgSlug, projectSlug, releaseVersion);
+
+  return api
+    .requestPromise(path, {
+      method: 'GET',
+    })
+    .then((res: Deploy[]) => {
+      ReleaseActions.loadDeploysSuccess(projectSlug, releaseVersion, res);
+    })
+    .catch(err => {
+      ReleaseActions.loadDeploysError(projectSlug, releaseVersion, err);
+      Sentry.withScope(scope => {
+        scope.setLevel(Sentry.Severity.Warning);
+        scope.setFingerprint(['getReleaseDeploys-action-creator']);
+        Sentry.captureException(err);
+      });
+    });
+}
diff --git a/src/sentry/static/sentry/app/actions/releaseActions.tsx b/src/sentry/static/sentry/app/actions/releaseActions.tsx
index 3a5de980c8..5b2f6326b8 100644
--- a/src/sentry/static/sentry/app/actions/releaseActions.tsx
+++ b/src/sentry/static/sentry/app/actions/releaseActions.tsx
@@ -1,7 +1,10 @@
 import Reflux from 'reflux';
 
 export default Reflux.createActions([
-  'fetchReleases',
-  'fetchReleasesError',
-  'fetchReleasesSuccess',
+  'loadRelease', // Singular as it loads 1 release
+  'loadReleaseError',
+  'loadReleaseSuccess',
+  'loadDeploys', // Plural as it loads all deploys related to a release
+  'loadDeploysError',
+  'loadDeploysSuccess',
 ]);
diff --git a/src/sentry/static/sentry/app/stores/releaseStore.tsx b/src/sentry/static/sentry/app/stores/releaseStore.tsx
new file mode 100644
index 0000000000..0960f78021
--- /dev/null
+++ b/src/sentry/static/sentry/app/stores/releaseStore.tsx
@@ -0,0 +1,226 @@
+import Reflux from 'reflux';
+
+import ReleaseActions from 'app/actions/releaseActions';
+import OrganizationActions from 'app/actions/organizationActions';
+import {Deploy, Organization, Release} from 'app/types';
+
+type StoreRelease = Map<string, Release>;
+type StoreDeploys = Map<string, Array<Deploy>>;
+type StoreLoading = Map<string, boolean>;
+type StoreError = Map<string, Error>;
+
+type ReleaseStoreInterface = {
+  get(
+    projectSlug: string,
+    releaseVersion: string
+  ): {
+    release: Release | undefined;
+    releaseLoading: boolean | undefined;
+    releaseError: Error | undefined;
+    deploys: Array<Deploy> | undefined;
+    deploysLoading: boolean | undefined;
+    deploysError: Error | undefined;
+  };
+
+  state: {
+    orgSlug: string | undefined;
+    release: StoreRelease;
+    releaseLoading: StoreLoading;
+    releaseError: StoreError;
+    deploys: StoreDeploys;
+    deploysLoading: StoreLoading;
+    deploysError: StoreError;
+  };
+
+  updateOrganization(org: Organization): void;
+  loadRelease(orgSlug: string, projectSlug: string, releaseVersion: string): void;
+  loadReleaseSuccess(projectSlug: string, releaseVersion: string, data: Release): void;
+  loadReleaseError(projectSlug: string, releaseVersion: string, error: Error): void;
+  loadDeploys(orgSlug: string, projectSlug: string, releaseVersion: string): void;
+  loadDeploysSuccess(projectSlug: string, releaseVersion: string, data: Release): void;
+  loadDeploysError(projectSlug: string, releaseVersion: string, error: Error): void;
+};
+
+export const getReleaseStoreKey = (projectSlug: string, releaseVersion: string) =>
+  `${projectSlug}${releaseVersion}`;
+
+const ReleaseStoreConfig: Reflux.StoreDefinition & ReleaseStoreInterface = {
+  state: {
+    orgSlug: undefined,
+    release: new Map() as StoreRelease,
+    releaseLoading: new Map() as StoreLoading,
+    releaseError: new Map() as StoreError,
+    deploys: new Map() as StoreDeploys,
+    deploysLoading: new Map() as StoreLoading,
+    deploysError: new Map() as StoreError,
+  },
+
+  listenables: ReleaseActions,
+
+  init() {
+    this.listenTo(OrganizationActions.update, this.updateOrganization);
+    this.reset();
+  },
+
+  reset() {
+    this.state = {
+      orgSlug: undefined,
+      release: new Map() as StoreRelease,
+      releaseLoading: new Map() as StoreLoading,
+      releaseError: new Map() as StoreError,
+      deploys: new Map() as StoreDeploys,
+      deploysLoading: new Map() as StoreLoading,
+      deploysError: new Map() as StoreError,
+    };
+    this.trigger(this.state);
+  },
+
+  updateOrganization(org: Organization) {
+    this.reset();
+    this.state.orgSlug = org.slug;
+    this.trigger(this.state);
+  },
+
+  loadRelease(orgSlug: string, projectSlug: string, releaseVersion: string) {
+    // Wipe entire store if the user switched organizations
+    if (!this.orgSlug || this.orgSlug !== orgSlug) {
+      this.reset();
+      this.orgSlug = orgSlug;
+    }
+
+    const releaseKey = getReleaseStoreKey(projectSlug, releaseVersion);
+    const {releaseLoading, releaseError, ...state} = this.state;
+
+    this.state = {
+      ...state,
+      releaseLoading: {
+        ...releaseLoading,
+        [releaseKey]: true,
+      },
+      releaseError: {
+        ...releaseError,
+        [releaseKey]: undefined,
+      },
+    };
+    this.trigger(this.state);
+  },
+
+  loadReleaseError(projectSlug: string, releaseVersion: string, error: Error) {
+    const releaseKey = getReleaseStoreKey(projectSlug, releaseVersion);
+    const {releaseLoading, releaseError, ...state} = this.state;
+
+    this.state = {
+      ...state,
+      releaseLoading: {
+        ...releaseLoading,
+        [releaseKey]: false,
+      },
+      releaseError: {
+        ...releaseError,
+        [releaseKey]: error,
+      },
+    };
+    this.trigger(this.state);
+  },
+
+  loadReleaseSuccess(projectSlug: string, releaseVersion: string, data: Release) {
+    const releaseKey = getReleaseStoreKey(projectSlug, releaseVersion);
+    const {release, releaseLoading, releaseError, ...state} = this.state;
+    this.state = {
+      ...state,
+      release: {
+        ...release,
+        [releaseKey]: data,
+      },
+      releaseLoading: {
+        ...releaseLoading,
+        [releaseKey]: false,
+      },
+      releaseError: {
+        ...releaseError,
+        [releaseKey]: undefined,
+      },
+    };
+    this.trigger(this.state);
+  },
+
+  loadDeploys(orgSlug: string, projectSlug: string, releaseVersion: string) {
+    // Wipe entire store if the user switched organizations
+    if (!this.orgSlug || this.orgSlug !== orgSlug) {
+      this.reset();
+      this.orgSlug = orgSlug;
+    }
+
+    const releaseKey = getReleaseStoreKey(projectSlug, releaseVersion);
+    const {deploysLoading, deploysError, ...state} = this.state;
+
+    this.state = {
+      ...state,
+      deploysLoading: {
+        ...deploysLoading,
+        [releaseKey]: true,
+      },
+      deploysError: {
+        ...deploysError,
+        [releaseKey]: undefined,
+      },
+    };
+    this.trigger(this.state);
+  },
+
+  loadDeploysError(projectSlug: string, releaseVersion: string, error: Error) {
+    const releaseKey = getReleaseStoreKey(projectSlug, releaseVersion);
+    const {deploysLoading, deploysError, ...state} = this.state;
+
+    this.state = {
+      ...state,
+      deploysLoading: {
+        ...deploysLoading,
+        [releaseKey]: false,
+      },
+      deploysError: {
+        ...deploysError,
+        [releaseKey]: error,
+      },
+    };
+    this.trigger(this.state);
+  },
+
+  loadDeploysSuccess(projectSlug: string, releaseVersion: string, data: Release) {
+    const releaseKey = getReleaseStoreKey(projectSlug, releaseVersion);
+    const {deploys, deploysLoading, deploysError, ...state} = this.state;
+
+    this.state = {
+      ...state,
+      deploys: {
+        ...deploys,
+        [releaseKey]: data,
+      },
+      deploysLoading: {
+        ...deploysLoading,
+        [releaseKey]: false,
+      },
+      deploysError: {
+        ...deploysError,
+        [releaseKey]: undefined,
+      },
+    };
+    this.trigger(this.state);
+  },
+
+  get(projectSlug: string, releaseVersion: string) {
+    const releaseKey = getReleaseStoreKey(projectSlug, releaseVersion);
+
+    return {
+      release: this.state.release[releaseKey],
+      releaseLoading: this.state.releaseLoading[releaseKey],
+      releaseError: this.state.releaseError[releaseKey],
+      deploys: this.state.deploys[releaseKey],
+      deploysLoading: this.state.deploysLoading[releaseKey],
+      deploysError: this.state.deploysError[releaseKey],
+    };
+  },
+};
+
+type ReleaseStore = Reflux.Store & ReleaseStoreInterface;
+export default Reflux.createStore(ReleaseStoreConfig) as ReleaseStore;
diff --git a/src/sentry/static/sentry/app/utils/withRelease.tsx b/src/sentry/static/sentry/app/utils/withRelease.tsx
new file mode 100644
index 0000000000..f49ff21971
--- /dev/null
+++ b/src/sentry/static/sentry/app/utils/withRelease.tsx
@@ -0,0 +1,83 @@
+import React from 'react';
+import Reflux from 'reflux';
+import createReactClass from 'create-react-class';
+
+import {Client} from 'app/api';
+import {Deploy, Release} from 'app/types';
+import getDisplayName from 'app/utils/getDisplayName';
+import ReleaseStore from 'app/stores/releaseStore';
+import {getProjectRelease, getReleaseDeploys} from 'app/actionCreators/release';
+
+type DependentProps = {
+  api: Client;
+  orgSlug: string;
+  projectSlug: string;
+  releaseVersion: string;
+};
+
+type InjectedProps = {
+  release?: Release;
+  releaseLoading?: boolean;
+  releaseError?: Error;
+  deploys?: Array<Deploy>;
+  deploysLoading?: boolean;
+  deploysError?: Error;
+};
+
+const withRelease = <P extends InjectedProps>(WrappedComponent: React.ComponentType<P>) =>
+  createReactClass<
+    Omit<P, keyof InjectedProps> & Partial<InjectedProps> & DependentProps,
+    InjectedProps
+  >({
+    displayName: `withRelease(${getDisplayName(WrappedComponent)})`,
+    mixins: [Reflux.listenTo(ReleaseStore, 'onStoreUpdate') as any],
+
+    getInitialState() {
+      const {projectSlug, releaseVersion} = this.props as P & DependentProps;
+      const releaseData = ReleaseStore.get(projectSlug, releaseVersion);
+      return {...releaseData};
+    },
+
+    componentDidMount() {
+      this.fetchRelease();
+      this.fetchDeploys();
+    },
+
+    fetchRelease() {
+      const {api, orgSlug, projectSlug, releaseVersion} = this.props as P &
+        DependentProps;
+      const releaseData = ReleaseStore.get(projectSlug, releaseVersion);
+
+      if (!releaseData.release && !releaseData.releaseLoading) {
+        getProjectRelease(api, {orgSlug, projectSlug, releaseVersion});
+      }
+    },
+
+    fetchDeploys() {
+      const {api, orgSlug, projectSlug, releaseVersion} = this.props as P &
+        DependentProps;
+      const releaseData = ReleaseStore.get(projectSlug, releaseVersion);
+
+      if (!releaseData.deploys && !releaseData.deploysLoading) {
+        getReleaseDeploys(api, {orgSlug, projectSlug, releaseVersion});
+      }
+    },
+
+    onStoreUpdate() {
+      const {projectSlug, releaseVersion} = this.props as P & DependentProps;
+      const releaseData = ReleaseStore.get(projectSlug, releaseVersion);
+
+      this.setState({...releaseData});
+    },
+
+    render() {
+      return (
+        <WrappedComponent
+          {...(this.props as P & DependentProps)}
+          {...(this.state as InjectedProps)}
+        />
+      );
+    },
+  });
+
+export default withRelease;
diff --git a/tests/js/spec/actionCreators/release.spec.jsx b/tests/js/spec/actionCreators/release.spec.jsx
new file mode 100644
index 0000000000..24418715bf
--- /dev/null
+++ b/tests/js/spec/actionCreators/release.spec.jsx
@@ -0,0 +1,123 @@
+import {getProjectRelease, getReleaseDeploys} from 'app/actionCreators/release';
+import ReleaseActions from 'app/actions/releaseActions';
+import ReleaseStore, {getReleaseStoreKey} from 'app/stores/releaseStore';
+
+describe('ReleaseActionCreator', function() {
+  const orgSlug = 'myOrg';
+  const projectSlug = 'myProject';
+  const releaseVersion = 'myRelease';
+  const releaseKey = getReleaseStoreKey(projectSlug, releaseVersion);
+
+  const api = new MockApiClient();
+  const mockData = {id: '1'};
+  let mockReponse;
+
+  describe('getProjectRelease', () => {
+    const releaseUrl = `/projects/${orgSlug}/${projectSlug}/releases/${encodeURIComponent(
+      releaseVersion
+    )}/`;
+
+    beforeEach(() => {
+      MockApiClient.clearMockResponses();
+      mockReponse = MockApiClient.addMockResponse({
+        url: releaseUrl,
+        body: mockData,
+      });
+
+      ReleaseStore.reset();
+
+      jest.restoreAllMocks();
+      jest.spyOn(ReleaseActions, 'loadRelease');
+      jest.spyOn(ReleaseActions, 'loadReleaseSuccess');
+
+      // XXX(leedongwei): We cannot spy on ReleaseStore at all
+      // See repositories.spec.jsx beforeEach method for the reason
+    });
+
+    it('fetches a Release and emits actions', async () => {
+      getProjectRelease(api, {orgSlug, projectSlug, releaseVersion});
+      expect(ReleaseActions.loadRelease).toHaveBeenCalledWith(
+        orgSlug,
+        projectSlug,
+        releaseVersion
+      );
+      expect(ReleaseActions.loadReleaseSuccess).not.toHaveBeenCalled();
+
+      await tick(); // Run Store.loadRelease and fire Action.loadReleaseSuccess
+      await tick(); // Run Store.loadReleaseSuccess
+
+      expect(mockReponse).toHaveBeenCalledWith(releaseUrl, expect.anything());
+      expect(ReleaseActions.loadReleaseSuccess).toHaveBeenCalledWith(
+        projectSlug,
+        releaseVersion,
+        mockData
+      );
+
+      expect(ReleaseStore.state.release[releaseKey]).toEqual(mockData);
+      expect(ReleaseStore.state.releaseLoading[releaseKey]).toEqual(false);
+      expect(ReleaseStore.state.releaseError[releaseKey]).toEqual(undefined);
+    });
+
+    it('short-circuits the JS event loop when fetching Release', async () => {
+      expect(ReleaseStore.state.releaseLoading[releaseKey]).toEqual(undefined);
+
+      getProjectRelease(api, {orgSlug, projectSlug, releaseVersion});
+      expect(ReleaseActions.loadRelease).toHaveBeenCalled();
+      // expect(ReleaseStore.loadRelease).not.toHaveBeenCalled(); // See above for comment on ReleaseStore
+      expect(ReleaseStore.state.releaseLoading[releaseKey]).toEqual(true);
+    });
+  });
+
+  describe('getReleaseDeploys', () => {
+    const deploysUrl = `/organizations/${orgSlug}/releases/${encodeURIComponent(
+      releaseVersion
+    )}/deploys/`;
+
+    beforeEach(() => {
+      MockApiClient.clearMockResponses();
+      mockReponse = MockApiClient.addMockResponse({
+        url: deploysUrl,
+        body: [mockData],
+      });
+
+      ReleaseStore.reset();
+
+      jest.restoreAllMocks();
+      jest.spyOn(ReleaseActions, 'loadDeploys');
+      jest.spyOn(ReleaseActions, 'loadDeploysSuccess');
+    });
+
+    it('fetch Deploys and emit an action', async () => {
+      getReleaseDeploys(api, {orgSlug, projectSlug, releaseVersion});
+      expect(ReleaseActions.loadDeploys).toHaveBeenCalledWith(
+        orgSlug,
+        projectSlug,
+        releaseVersion
+      );
+      expect(ReleaseActions.loadDeploysSuccess).not.toHaveBeenCalled();
+
+      await tick(); // Run Store.loadDeploys and fire Action.loadDeploysSuccess
+      await tick(); // Run Store.loadDeploysSuccess
+
+      expect(mockReponse).toHaveBeenCalledWith(deploysUrl, expect.anything());
+      expect(ReleaseActions.loadDeploysSuccess).toHaveBeenCalledWith(
+        projectSlug,
+        releaseVersion,
+        [mockData]
+      );
+
+      expect(ReleaseStore.state.deploys[releaseKey]).toEqual([mockData]);
+      expect(ReleaseStore.state.deploysLoading[releaseKey]).toEqual(false);
+      expect(ReleaseStore.state.deploysError[releaseKey]).toEqual(undefined);
+    });
+
+    it('short-circuits the JS event loop when fetching Deploys', async () => {
+      expect(ReleaseStore.state.deploysLoading[releaseKey]).toEqual(undefined);
+
+      getReleaseDeploys(api, {orgSlug, projectSlug, releaseVersion});
+      expect(ReleaseActions.loadDeploys).toHaveBeenCalled();
+      // expect(ReleaseStore.loadDeploys).not.toHaveBeenCalled(); // See above for comment on ReleaseStore
+      expect(ReleaseStore.state.deploysLoading[releaseKey]).toEqual(true);
+    });
+  });
+});
diff --git a/tests/js/spec/utils/withRelease.spec.jsx b/tests/js/spec/utils/withRelease.spec.jsx
new file mode 100644
index 0000000000..0b8acd5bd2
--- /dev/null
+++ b/tests/js/spec/utils/withRelease.spec.jsx
@@ -0,0 +1,112 @@
+import React from 'react';
+
+import {mount} from 'sentry-test/enzyme';
+
+import ReleaseStore from 'app/stores/releaseStore';
+import withRelease from 'app/utils/withRelease';
+
+describe('withRelease HoC', function() {
+  const orgSlug = 'myOrg';
+  const projectSlug = 'myProject';
+  const releaseVersion = 'myRelease';
+
+  const releaseUrl = `/projects/${orgSlug}/${projectSlug}/releases/${encodeURIComponent(
+    releaseVersion
+  )}/`;
+  const deployUrl = `/organizations/${orgSlug}/releases/${encodeURIComponent(
+    releaseVersion
+  )}/deploys/`;
+
+  const api = new MockApiClient();
+  const mockData = {id: '1'};
+
+  beforeEach(() => {
+    MockApiClient.clearMockResponses();
+    MockApiClient.addMockResponse({
+      url: releaseUrl,
+      body: mockData,
+    });
+    MockApiClient.addMockResponse({
+      url: deployUrl,
+      body: [mockData],
+    });
+
+    jest.restoreAllMocks();
+    ReleaseStore.reset();
+  });
+
+  it('adds release/deploys prop', async () => {
+    const Component = () => null;
+    const Container = withRelease(Component);
+    const wrapper = mount(
+      <Container
+        api={api}
+        orgSlug={orgSlug}
+        projectSlug={projectSlug}
+        releaseVersion={releaseVersion}
+      />
+    );
+
+    await tick(); // Run Store.loadEtc
+    await tick(); // Run Store.loadEtcSuccess
+    wrapper.update();
+
+    const mountedComponent = wrapper.find(Component);
+    expect(mountedComponent.prop('release')).toEqual(mockData);
+    expect(mountedComponent.prop('releaseLoading')).toEqual(false);
+    expect(mountedComponent.prop('releaseError')).toEqual(undefined);
+    expect(mountedComponent.prop('deploys')).toEqual([mockData]);
+    expect(mountedComponent.prop('deploysLoading')).toEqual(false);
+    expect(mountedComponent.prop('deploysError')).toEqual(undefined);
+  });
+
+  it('prevents repeated calls', async () => {
+    const Component = () => null;
+    const Container = withRelease(Component);
+
+    // XXX(leedongwei): We cannot spy on `fetchRelease` as Jest can't
+    // replace the function in the prototype due to createReactClass.
+    // As such, I'm using `componentDidMount` as a proxy.
+    jest.spyOn(api, 'requestPromise');
+    jest.spyOn(Container.prototype, 'componentDidMount');
+    // jest.spyOn(Container.prototype, 'fetchRelease');
+    // jest.spyOn(Container.prototype, 'fetchDeploys');
+
+    // Mount and run component
+    mount(
+      <Container
+        api={api}
+        orgSlug={orgSlug}
+        projectSlug={projectSlug}
+        releaseVersion={releaseVersion}
+      />
+    );
+    await tick();
+    await tick();
+
+    // Mount and run duplicates
+    mount(
+      <Container
+        api={api}
+        orgSlug={orgSlug}
+        projectSlug={projectSlug}
+        releaseVersion={releaseVersion}
+      />
+    );
+    await tick();
+    mount(
+      <Container
+        api={api}
+        orgSlug={orgSlug}
+        projectSlug={projectSlug}
+        releaseVersion={releaseVersion}
+      />
+    );
+    await tick();
+
+    expect(api.requestPromise).toHaveBeenCalledTimes(2); // 1 for fetchRelease, 1 for fetchDeploys
+    expect(Container.prototype.componentDidMount).toHaveBeenCalledTimes(3);
+    // expect(Container.prototype.fetchRelease).toHaveBeenCalledTimes(3);
+    // expect(Container.prototype.fetchDeploys).toHaveBeenCalledTimes(3);
+  });
+});

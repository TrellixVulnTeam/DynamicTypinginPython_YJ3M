commit 00cba7baf5f097a1152a47203a2f0856fd9a11a7
Author: Mark Story <mark@sentry.io>
Date:   Thu Mar 12 13:58:24 2020 -0400

    ref(discover) Simplify column abstractions in discover (#17581)
    
    Reduce the amount of duplication we maintain for column structures and
    use types that make the kind of column being worked on easier to
    understand and better leverage typescript features.
    
    The `Field` type now contains the URL name and width. While the `Column`
    type contains more metadata about the field. Lastly the `TableColumn`
    type contains the width and the `Column` but does not duplicate the
    column attributes like it did before.
    
    I've also refactored the resize action handler to use a simpler
    eventView function that only handles resizing.

diff --git a/src/sentry/static/sentry/app/utils/queryString.tsx b/src/sentry/static/sentry/app/utils/queryString.tsx
index cee7e3d926..d5a781f997 100644
--- a/src/sentry/static/sentry/app/utils/queryString.tsx
+++ b/src/sentry/static/sentry/app/utils/queryString.tsx
@@ -33,12 +33,12 @@ type QueryValue = string | string[] | undefined | null;
 export function appendTagCondition(
   query: QueryValue,
   key: string,
-  value: string
+  value: null | string
 ): string {
   let currentQuery = Array.isArray(query) ? query.pop() : isString(query) ? query : '';
 
   // The user key values have additional key data inside them.
-  if (key === 'user' && value.includes(':')) {
+  if (key === 'user' && isString(value) && value.includes(':')) {
     const parts = value.split(':', 2);
     key = [key, parts[0]].join('.');
     value = parts[1];
diff --git a/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx b/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
index 267584dcb9..ab8f8ecced 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
@@ -21,6 +21,7 @@ import {
   decodeColumnOrder,
   decodeScalar,
 } from './utils';
+import {Aggregation, AggregationRefinement} from './eventQueryParams';
 import {TableColumn, TableColumnSort} from './table/types';
 
 type LocationQuery = {
@@ -48,16 +49,26 @@ const reverseSort = (sort: Sort): Sort => ({
   field: sort.field,
 });
 
+// Contains the URL field value & the related table column width.
+// Can be parsed into a Column using explodeField()
 export type Field = {
   field: string;
   width?: number;
 };
-export type Column = {
-  aggregation: string;
-  field: string;
-  refinement?: string;
-  width?: number;
-};
+
+// The parsed result of a Field.
+// Functions and Fields are handled as subtypes to enable other
+// code to work more simply.
+// This type can be converted into a Field.field using generateFieldAsString()
+export type Column =
+  | {
+      kind: 'field';
+      field: string;
+    }
+  | {
+      kind: 'function';
+      function: [Aggregation, string, AggregationRefinement];
+    };
 
 const isSortEqualToField = (
   sort: Sort,
@@ -85,18 +96,18 @@ function getSortKeyFromField(
   field: Field,
   tableMeta: MetaType | undefined
 ): string | null {
-  const column = getAggregateAlias(field.field);
-  if (SPECIAL_FIELDS.hasOwnProperty(column)) {
-    return SPECIAL_FIELDS[column as keyof typeof SPECIAL_FIELDS].sortField;
+  const alias = getAggregateAlias(field.field);
+  if (SPECIAL_FIELDS.hasOwnProperty(alias)) {
+    return SPECIAL_FIELDS[alias as keyof typeof SPECIAL_FIELDS].sortField;
   }
 
   if (!tableMeta) {
-    return column;
+    return alias;
   }
 
-  if (FIELD_FORMATTERS.hasOwnProperty(tableMeta[column])) {
-    return FIELD_FORMATTERS[tableMeta[column] as keyof typeof FIELD_FORMATTERS].sortField
-      ? column
+  if (FIELD_FORMATTERS.hasOwnProperty(tableMeta[alias])) {
+    return FIELD_FORMATTERS[tableMeta[alias] as keyof typeof FIELD_FORMATTERS].sortField
+      ? alias
       : null;
   }
 
@@ -108,12 +119,13 @@ export function isFieldSortable(field: Field, tableMeta: MetaType | undefined):
 }
 
 const generateFieldAsString = (col: Column): string => {
-  const {aggregation, field, refinement} = col;
-  const parameters = [field, refinement].filter(i => i);
-  if (aggregation) {
-    return `${aggregation}(${parameters.join(',')})`;
+  if (col.kind === 'field') {
+    return col.field;
   }
-  return field;
+
+  const aggregation = col.function[0];
+  const parameters = col.function.slice(1).filter(i => i);
+  return `${aggregation}(${parameters.join(',')})`;
 };
 
 const decodeFields = (location: Location): Array<Field> => {
@@ -575,7 +587,11 @@ class EventView {
   withColumns(columns: Column[]): EventView {
     const newEventView = this.clone();
     const fields: Field[] = columns
-      .filter(col => col.field || col.aggregation)
+      .filter(
+        col =>
+          (col.kind === 'field' && col.field) ||
+          (col.kind === 'function' && col.function[0])
+      )
       .map(col => generateFieldAsString(col))
       .map((field, i) => {
         // newly added field
@@ -617,7 +633,7 @@ class EventView {
     const fieldAsString = generateFieldAsString(newColumn);
     const newField: Field = {
       field: fieldAsString,
-      width: newColumn.width || COL_WIDTH_UNDEFINED,
+      width: COL_WIDTH_UNDEFINED,
     };
     const newEventView = this.clone();
     newEventView.fields = [...newEventView.fields, newField];
@@ -625,6 +641,26 @@ class EventView {
     return newEventView;
   }
 
+  withResizedColumn(columnIndex: number, newWidth: number) {
+    const field = this.fields[columnIndex];
+    const newEventView = this.clone();
+    if (!field) {
+      return newEventView;
+    }
+
+    const updateWidth = field.width !== newWidth;
+    if (updateWidth) {
+      const fields = [...newEventView.fields];
+      fields[columnIndex] = {
+        ...field,
+        width: newWidth,
+      };
+      newEventView.fields = fields;
+    }
+
+    return newEventView;
+  }
+
   withUpdatedColumn(
     columnIndex: number,
     updatedColumn: Column,
@@ -634,9 +670,7 @@ class EventView {
     const fieldAsString = generateFieldAsString(updatedColumn);
 
     const updateField = columnToBeUpdated.field !== fieldAsString;
-    const updateWidth = columnToBeUpdated.width !== updatedColumn.width;
-
-    if (!updateField && !updateWidth) {
+    if (!updateField) {
       return this;
     }
 
@@ -647,7 +681,7 @@ class EventView {
 
     const updatedField: Field = {
       field: fieldAsString,
-      width: updatedColumn.width || COL_WIDTH_UNDEFINED,
+      width: COL_WIDTH_UNDEFINED,
     };
 
     const fields = [...newEventView.fields];
diff --git a/src/sentry/static/sentry/app/views/eventsV2/sortLink.tsx b/src/sentry/static/sentry/app/views/eventsV2/sortLink.tsx
index fddfd0703e..7d1a3f57b2 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/sortLink.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/sortLink.tsx
@@ -3,7 +3,7 @@ import styled from '@emotion/styled';
 import {LocationDescriptorObject} from 'history';
 import omit from 'lodash/omit';
 
-import InlineSvg from 'app/components/inlineSvg';
+import {IconChevron} from 'app/icons';
 import Link from 'app/components/links/link';
 
 import EventView, {Field, Sort, isFieldSortable} from './eventView';
@@ -37,10 +37,9 @@ class SortLink extends React.Component<Props> {
     }
 
     if (currentSort.kind === 'desc') {
-      return <InlineSvg src="icon-chevron-down" />;
+      return <IconChevron size="xs" direction="down" />;
     }
-
-    return <InlineSvg src="icon-chevron-up" />;
+    return <IconChevron size="xs" direction="up" />;
   }
 
   render() {
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditCollection.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditCollection.tsx
index e70e1bc3c9..683097a09e 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditCollection.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditCollection.tsx
@@ -148,6 +148,13 @@ class ColumnEditCollection extends React.Component<Props, State> {
     this.setState({fieldOptions});
   }
 
+  keyForColumn(column: Column, isGhost: boolean): string {
+    if (column.kind === 'function') {
+      return [...column.function, isGhost].join(':');
+    }
+    return [...column.field, isGhost].join(':');
+  }
+
   cleanUpListeners() {
     if (this.state.isDragging) {
       window.removeEventListener('mousemove', this.onDragMove);
@@ -157,11 +164,8 @@ class ColumnEditCollection extends React.Component<Props, State> {
 
   // Signal to the parent that a new column has been added.
   handleAddColumn = () => {
-    const newColumns = [
-      ...this.props.columns,
-      {aggregation: '', field: '', refinement: undefined},
-    ];
-    this.props.onChange(newColumns);
+    const newColumn: Column = {kind: 'field', field: ''};
+    this.props.onChange([...this.props.columns, newColumn]);
   };
 
   handleUpdateColumn = (index: number, column: Column) => {
@@ -305,7 +309,7 @@ class ColumnEditCollection extends React.Component<Props, State> {
     if (isDragging && isGhost === false && draggingTargetIndex === i) {
       placeholder = (
         <DragPlaceholder
-          key={`placeholder:${col.aggregation}:${col.field}:${col.refinement}`}
+          key={`placeholder:${this.keyForColumn(col, isGhost)}`}
           className={DRAG_CLASS}
         />
       );
@@ -323,9 +327,7 @@ class ColumnEditCollection extends React.Component<Props, State> {
         : PlaceholderPosition.BOTTOM;
 
     return (
-      <React.Fragment
-        key={`${i}:${col.aggregation}:${col.field}:${col.refinement}:${isGhost}`}
-      >
+      <React.Fragment key={`${i}:${this.keyForColumn(col, isGhost)}`}>
         {position === PlaceholderPosition.TOP && placeholder}
         <RowContainer className={isGhost ? '' : DRAG_CLASS}>
           {canDelete ? (
@@ -369,7 +371,9 @@ class ColumnEditCollection extends React.Component<Props, State> {
     // Get the longest number of columns so we can layout the rows.
     // We always want at least 2 columns.
     const gridColumns = Math.max(
-      ...columns.map(col => (col.field && col.refinement !== undefined ? 3 : 2))
+      ...columns.map(col =>
+        col.kind === 'function' && col.function[2] !== undefined ? 3 : 2
+      )
     );
 
     return (
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditRow.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditRow.tsx
index f9559f5d74..8b521a3aac 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditRow.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditRow.tsx
@@ -1,6 +1,7 @@
 import React from 'react';
 import styled from '@emotion/styled';
 import {components} from 'react-select';
+import cloneDeep from 'lodash/cloneDeep';
 
 import Badge from 'app/components/badge';
 import SelectControl from 'app/components/forms/selectControl';
@@ -9,7 +10,12 @@ import {t} from 'app/locale';
 import space from 'app/styles/space';
 
 import {FieldValueKind, FieldValue} from './types';
-import {FIELD_ALIASES, ColumnType, AggregateParameter} from '../eventQueryParams';
+import {
+  FIELD_ALIASES,
+  ColumnType,
+  Aggregation,
+  AggregateParameter,
+} from '../eventQueryParams';
 import {Column} from '../eventView';
 
 type FieldOptions = StringMap<SelectValue<FieldValue>>;
@@ -42,23 +48,31 @@ type Props = {
 
 class ColumnEditRow extends React.Component<Props> {
   handleFieldChange = ({value}) => {
-    const {column} = this.props;
-    let currentParams: [string, string, string | undefined] = [
-      column.aggregation,
-      column.field,
-      column.refinement,
-    ];
+    const current = this.props.column;
+    let column: Column = cloneDeep(this.props.column);
 
     switch (value.kind) {
       case FieldValueKind.TAG:
       case FieldValueKind.FIELD:
-        currentParams = ['', value.meta.name, undefined];
+        column = {kind: 'field', field: value.meta.name};
         break;
       case FieldValueKind.FUNCTION:
-        currentParams[0] = value.meta.name;
+        if (current.kind === 'field') {
+          column = {kind: 'function', function: [value.meta.name, '', undefined]};
+        } else if (current.kind === 'function') {
+          column = {
+            kind: 'function',
+            function: [value.meta.name, current.function[1], current.function[2]],
+          };
+        }
         // Backwards compatibility for field alias versions of functions.
-        if (currentParams[1] && FIELD_ALIASES.includes(currentParams[1])) {
-          currentParams = [currentParams[0], '', undefined];
+        if (
+          current.kind === 'function' &&
+          column.kind === 'function' &&
+          current.function[1] &&
+          FIELD_ALIASES.includes(current.function[1])
+        ) {
+          column.function = [column.function[1] as Aggregation, '', undefined];
         }
         break;
       default:
@@ -67,52 +81,57 @@ class ColumnEditRow extends React.Component<Props> {
 
     if (value.kind === FieldValueKind.FUNCTION) {
       value.meta.parameters.forEach((param: AggregateParameter, i: number) => {
+        if (column.kind !== 'function') {
+          return;
+        }
         if (param.kind === 'column') {
-          const field = this.getFieldOrTagValue(currentParams[i + 1]);
+          const field = this.getFieldOrTagValue(column.function[i + 1]);
           if (field === null) {
-            currentParams[i + 1] = param.defaultValue || '';
+            column.function[i + 1] = param.defaultValue || '';
           } else if (
             (field.kind === FieldValueKind.FIELD || field.kind === FieldValueKind.TAG) &&
             param.columnTypes.includes(field.meta.dataType)
           ) {
             // New function accepts current field.
-            currentParams[i + 1] = field.meta.name;
+            column.function[i + 1] = field.meta.name;
           } else {
             // field does not fit within new function requirements, use the default.
-            currentParams[i + 1] = param.defaultValue || '';
-            currentParams[i + 2] = '';
+            column.function[i + 1] = param.defaultValue || '';
+            column.function[i + 2] = undefined;
           }
         }
         if (param.kind === 'value') {
-          currentParams[i + 1] = param.defaultValue;
+          column.function[i + 1] = param.defaultValue;
         }
       });
 
-      if (value.meta.parameters.length === 0) {
-        currentParams = [currentParams[0], '', undefined];
+      if (column.kind === 'function' && value.meta.parameters.length === 0) {
+        column.function = [column.function[0], '', undefined];
       }
     }
 
-    this.triggerChange(...currentParams);
+    this.triggerChange(column);
   };
 
   handleFieldParameterChange = ({value}) => {
-    const {column} = this.props;
-    this.triggerChange(column.aggregation, value.meta.name, column.refinement);
+    const newColumn = cloneDeep(this.props.column);
+    if (newColumn.kind === 'function') {
+      newColumn.function[1] = value.meta.name;
+    }
+    this.triggerChange(newColumn);
   };
 
   handleRefinementChange = (value: string) => {
-    const {column} = this.props;
-    this.triggerChange(column.aggregation, column.field, value);
+    const newColumn = cloneDeep(this.props.column);
+    if (newColumn.kind === 'function') {
+      newColumn.function[2] = value;
+    }
+    this.triggerChange(newColumn);
   };
 
-  triggerChange(aggregation: string, field: string, refinement?: string) {
+  triggerChange(column: Column) {
     const {parentIndex} = this.props;
-    this.props.onChange(parentIndex, {
-      aggregation,
-      field,
-      refinement,
-    });
+    this.props.onChange(parentIndex, column);
   }
 
   getFieldOrTagValue(name: string | undefined): FieldValue | null {
@@ -151,20 +170,24 @@ class ColumnEditRow extends React.Component<Props> {
 
     const {column} = this.props;
     let {fieldOptions} = this.props;
-    const funcName = `function:${column.aggregation}`;
-
-    if (fieldOptions[funcName] !== undefined) {
-      field = fieldOptions[funcName].value;
-      // TODO move this closer to where it is used.
-      fieldParameter = this.getFieldOrTagValue(column.field);
-    } else if (!column.aggregation && FIELD_ALIASES.includes(column.field)) {
-      // Handle backwards compatible field aliases.
-      const aliasName = `function:${column.field}`;
-      if (fieldOptions[aliasName] !== undefined) {
-        field = fieldOptions[aliasName].value;
+
+    if (column.kind === 'function') {
+      const funcName = `function:${column.function[0]}`;
+      if (fieldOptions[funcName] !== undefined) {
+        field = fieldOptions[funcName].value;
+        // TODO move this closer to where it is used.
+        fieldParameter = this.getFieldOrTagValue(column.function[1]);
+      }
+    } else if (column.kind === 'field') {
+      if (FIELD_ALIASES.includes(column.field)) {
+        // Handle backwards compatible field aliases.
+        const aliasName = `function:${column.field}`;
+        if (fieldOptions[aliasName] !== undefined) {
+          field = fieldOptions[aliasName].value;
+        }
+      } else {
+        field = this.getFieldOrTagValue(column.field);
       }
-    } else {
-      field = this.getFieldOrTagValue(column.field);
     }
 
     // If our current field, or columnParameter is a virtual tag, add it to the option list.
@@ -195,7 +218,10 @@ class ColumnEditRow extends React.Component<Props> {
           }
           return {
             kind: 'value',
-            value: column.refinement || param.defaultValue || '',
+            value:
+              (column.kind === 'function' && column.function[2]) ||
+              param.defaultValue ||
+              '',
             dataType: param.dataType,
             required: param.required,
           };
@@ -368,17 +394,17 @@ type InputState = {value: string};
  * constraints better.
  */
 class BufferedInput extends React.Component<InputProps, InputState> {
+  constructor(props: InputProps) {
+    super(props);
+    this.input = React.createRef();
+  }
+
   state = {
     value: this.props.value,
   };
 
   private input: React.RefObject<HTMLInputElement>;
 
-  constructor(props: InputProps) {
-    super(props);
-    this.input = React.createRef();
-  }
-
   get isValid() {
     if (!this.input.current) {
       return true;
@@ -418,6 +444,8 @@ class BufferedInput extends React.Component<InputProps, InputState> {
 // Set a min-width to allow shrinkage in grid.
 const StyledInput = styled('input')`
   min-width: 50px;
+  /* Match the height of the select boxes */
+  height: 37px;
 
   &:not([disabled='true']):invalid {
     border-color: ${p => p.theme.red};
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/headerCell.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/headerCell.tsx
index 5224c168f8..d5fe96d988 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/headerCell.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/headerCell.tsx
@@ -18,8 +18,6 @@ type Props = {
 function HeaderCell(props: Props) {
   const {children, column, tableData} = props;
 
-  const field = column.eventViewField;
-
   // establish alignment based on the type
   const alignedTypes: ColumnValueType[] = ['number', 'duration', 'integer'];
   let align: Alignments = alignedTypes.includes(column.type) ? 'right' : 'left';
@@ -28,7 +26,7 @@ function HeaderCell(props: Props) {
     // fallback to align the column based on the table metadata
     const maybeType =
       tableData && tableData.meta
-        ? tableData.meta[getAggregateAlias(field.field)]
+        ? tableData.meta[getAggregateAlias(column.name)]
         : undefined;
 
     if (maybeType === 'integer' || maybeType === 'number') {
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
index 08656efb00..95f9cbd770 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
@@ -18,7 +18,6 @@ import {
   getFieldRenderer,
   getExpandedResults,
   pushEventViewToLocation,
-  explodeField,
   MetaType,
 } from '../utils';
 import EventView, {Column, pickRelevantLocationQueryStrings} from '../eventView';
@@ -44,52 +43,33 @@ export type TableViewProps = {
 /**
  * The `TableView` is marked with leading _ in its method names. It consumes
  * the EventView object given in its props to generate new EventView objects
- * for actions such as creating new columns, updating columns, sorting columns,
- * and re-ordering columns.
+ * for actions like resizing column.
+
+ * The entire state of the table view (or event view) is co-located within
+ * the EventView object. This object is fed from the props.
+ *
+ * Attempting to modify the state, and therefore, modifying the given EventView
+ * object given from its props, will generate new instances of EventView objects.
+ *
+ * In most cases, the new EventView object differs from the previous EventView
+ * object. The new EventView object is pushed to the location object.
  */
 class TableView extends React.Component<TableViewProps> {
   /**
-   * The entire state of the table view (or event view) is co-located within
-   * the EventView object. This object is fed from the props.
-   *
-   * Attempting to modify the state, and therefore, modifying the given EventView
-   * object given from its props, will generate new instances of EventView objects.
-   *
-   * In most cases, the new EventView object differs from the previous EventView
-   * object. The new EventView object is pushed to the location object.
+   * Updates a column on resizing
    */
-  _updateColumn = (columnIndex: number, nextColumn: TableColumn<keyof TableDataRow>) => {
-    const {location, eventView, tableData, organization} = this.props;
-
-    const payload = {
-      aggregation: String(nextColumn.aggregation),
-      field: String(nextColumn.field),
-      width: nextColumn.width ? Number(nextColumn.width) : COL_WIDTH_UNDEFINED,
-      refinement: nextColumn.refinement,
-    };
+  _resizeColumn = (columnIndex: number, nextColumn: TableColumn<keyof TableDataRow>) => {
+    const {location, eventView, organization} = this.props;
 
-    const tableMeta = (tableData && tableData.meta) || undefined;
-    const nextEventView = eventView.withUpdatedColumn(columnIndex, payload, tableMeta);
+    const newWidth = nextColumn.width ? Number(nextColumn.width) : COL_WIDTH_UNDEFINED;
+    const nextEventView = eventView.withResizedColumn(columnIndex, newWidth);
 
     if (nextEventView !== eventView) {
       const changed: string[] = [];
 
-      const prevField = explodeField(eventView.fields[columnIndex]);
-      const nextField = explodeField(nextEventView.fields[columnIndex]);
-
-      const aggregationChanged = prevField.aggregation !== nextField.aggregation;
-      const fieldChanged = prevField.field !== nextField.field;
-      const widthChanged = prevField.width !== nextField.width;
-
-      if (aggregationChanged) {
-        changed.push('aggregate');
-      }
-
-      if (fieldChanged) {
-        changed.push('field');
-      }
-
-      if (widthChanged) {
+      const prevField = eventView.fields[columnIndex];
+      const nextField = nextEventView.fields[columnIndex];
+      if (prevField.width !== nextField.width) {
         changed.push('width');
       }
 
@@ -99,7 +79,6 @@ class TableView extends React.Component<TableViewProps> {
         updated_at_index: columnIndex,
         changed,
         organization_id: parseInt(organization.id, 10),
-        ...payload,
       });
     }
 
@@ -148,10 +127,9 @@ class TableView extends React.Component<TableViewProps> {
     return (
       <HeaderCell column={column} tableData={tableData}>
         {({align}) => {
-          const field = column.eventViewField;
-
           const tableDataMeta = tableData && tableData.meta ? tableData.meta : undefined;
 
+          const field = {field: column.name, width: column.width};
           function generateSortLink(): LocationDescriptorObject | undefined {
             if (!tableDataMeta) {
               return undefined;
@@ -225,7 +203,7 @@ class TableView extends React.Component<TableViewProps> {
         {...modalProps}
         organization={organization}
         tagKeys={tagKeys}
-        columns={eventView.getColumns()}
+        columns={eventView.getColumns().map(col => col.column)}
         onApply={this.handleUpdateColumns}
       />
     ));
@@ -275,7 +253,7 @@ class TableView extends React.Component<TableViewProps> {
         grid={{
           renderHeadCell: this._renderGridHeaderCell as any,
           renderBodyCell: this._renderGridBodyCell as any,
-          onResizeColumn: this._updateColumn as any,
+          onResizeColumn: this._resizeColumn as any,
           renderPrependColumns: this._renderPrependColumns as any,
           prependColumnWidths: ['40px'],
         }}
@@ -297,10 +275,8 @@ const ExpandAggregateRow = (props: {
   tableMeta: MetaType;
 }) => {
   const {children, column, dataRow, eventView, location} = props;
-  const {eventViewField} = column;
-
-  const exploded = explodeField(eventViewField);
-  const {aggregation} = exploded;
+  const aggregation =
+    column.column.kind === 'function' ? column.column.function[0] : undefined;
 
   // count(column) drilldown
   if (aggregation === 'count') {
@@ -318,8 +294,8 @@ const ExpandAggregateRow = (props: {
   if (aggregation === 'count_unique') {
     // Drilldown into each distinct value and get a count() for each value.
     const nextView = getExpandedResults(eventView, {}, dataRow).withNewColumn({
-      field: '',
-      aggregation: 'count',
+      kind: 'function',
+      function: ['count', '', undefined],
     });
 
     const target = {
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/types.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/types.tsx
index e926c809f9..28fa275b2d 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/types.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/types.tsx
@@ -1,14 +1,7 @@
 import {GridColumnOrder, GridColumnSortBy} from 'app/components/gridEditable';
 
-import {
-  ColumnType,
-  ColumnValueType,
-  AggregateParameter,
-  Aggregation,
-  Field,
-  AggregationRefinement,
-} from '../eventQueryParams';
-import {Field as FieldType} from '../eventView';
+import {ColumnType, ColumnValueType, AggregateParameter} from '../eventQueryParams';
+import {Column} from '../eventView';
 import {MetaType} from '../utils';
 
 /**
@@ -17,10 +10,8 @@ import {MetaType} from '../utils';
 export type TableColumn<K> = GridColumnOrder<K> & {
   // key: K                     From GridColumn
   // name: string               From GridColumnHeader
-  aggregation: Aggregation;
-  field: Field;
-  refinement: AggregationRefinement;
-  eventViewField: Readonly<FieldType>;
+  column: Readonly<Column>;
+  width?: number;
 
   type: ColumnValueType;
   isSortable: boolean;
diff --git a/src/sentry/static/sentry/app/views/eventsV2/utils.tsx b/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
index 878915d3f8..671b2a5516 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
@@ -25,11 +25,10 @@ import {
   ALL_VIEWS,
   TRANSACTION_VIEWS,
 } from './data';
-import EventView, {Field as FieldType, Column} from './eventView';
+import EventView, {Field, Column} from './eventView';
 import {
   Aggregation,
   AggregationRefinement,
-  Field,
   AGGREGATIONS,
   FIELDS,
 } from './eventQueryParams';
@@ -49,27 +48,28 @@ function explodeFieldString(field: string): Column {
   const results = field.match(AGGREGATE_PATTERN);
 
   if (results && results.length >= 3) {
-    return {aggregation: results[1], field: results[2], refinement: results[3]};
+    return {
+      kind: 'function',
+      function: [
+        results[1] as Aggregation,
+        results[2],
+        results[3] as AggregationRefinement,
+      ],
+    };
   }
 
-  return {aggregation: '', field};
+  return {kind: 'field', field};
 }
 
-export function explodeField(field: FieldType): Column {
+export function explodeField(field: Field): Column {
   const results = explodeFieldString(field.field);
 
-  return {
-    aggregation: results.aggregation,
-    field: results.field,
-    refinement: results.refinement,
-    width: field.width || COL_WIDTH_UNDEFINED,
-  };
+  return results;
 }
 
 /**
  * Takes a view and determines if there are any aggregate fields in it.
  *
- *
  * @param {Object} view
  * @returns {Boolean}
  */
@@ -145,9 +145,7 @@ export function fetchTotalCount(
     .then((res: Response) => res.count);
 }
 
-export type MetaType = {
-  [key: string]: FieldTypes;
-};
+export type MetaType = StringMap<FieldTypes>;
 
 /**
  * Get the field renderer for the named field and metadata
@@ -195,51 +193,40 @@ export type QueryWithColumnState =
 
 const TEMPLATE_TABLE_COLUMN: TableColumn<React.ReactText> = {
   key: '',
-  aggregation: '',
-  field: '',
-  refinement: undefined,
   name: '',
-  width: COL_WIDTH_UNDEFINED,
 
   type: 'never',
   isSortable: false,
 
-  eventViewField: Object.freeze({field: '', width: COL_WIDTH_UNDEFINED}),
+  column: Object.freeze({kind: 'field', field: ''}),
+  width: COL_WIDTH_UNDEFINED,
 };
 
 export function decodeColumnOrder(
-  fields: Readonly<FieldType[]>
+  fields: Readonly<Field[]>
 ): TableColumn<React.ReactText>[] {
-  return fields.map((f: FieldType) => {
+  return fields.map((f: Field) => {
     const column: TableColumn<React.ReactText> = {...TEMPLATE_TABLE_COLUMN};
-    const col = explodeField(f);
 
-    if (col.aggregation) {
-      column.aggregation = col.aggregation as Aggregation;
-    }
-    if (col.field) {
-      column.field = col.field as Field;
-    }
-    if (col.refinement) {
-      column.refinement = col.refinement as AggregationRefinement;
-    }
+    const col = explodeField(f);
     column.key = f.field;
-
-    // Aggregations can have a strict outputType or they can inherit from their field.
-    // Otherwise use the FIELDS data to infer types.
-    const aggregate = AGGREGATIONS[column.aggregation];
-    if (aggregate && aggregate.outputType) {
-      column.type = aggregate.outputType;
-    } else {
-      column.type = FIELDS[column.field];
+    column.name = f.field;
+    column.width = f.width || COL_WIDTH_UNDEFINED;
+
+    if (col.kind === 'function') {
+      // Aggregations can have a strict outputType or they can inherit from their field.
+      // Otherwise use the FIELDS data to infer types.
+      const aggregate = AGGREGATIONS[col.function[0]];
+      if (aggregate && aggregate.outputType) {
+        column.type = aggregate.outputType;
+      } else if (FIELDS.hasOwnProperty(col.function[1])) {
+        column.type = FIELDS[col.function[1]];
+      }
+      column.isSortable = aggregate && aggregate.isSortable;
+    } else if (col.kind === 'field') {
+      column.type = FIELDS[col.field];
     }
-    column.width = col.width;
-
-    column.name = column.key;
-    column.isSortable = AGGREGATIONS[column.aggregation]
-      ? AGGREGATIONS[column.aggregation].isSortable
-      : false;
-    column.eventViewField = f;
+    column.column = col;
 
     return column;
   });
@@ -251,9 +238,7 @@ export function pushEventViewToLocation(props: {
   extraQuery?: Query;
 }) {
   const {location, nextEventView} = props;
-
   const extraQuery = props.extraQuery || {};
-
   const queryStringObject = nextEventView.generateQueryStringObject();
 
   browserHistory.push({
@@ -274,11 +259,9 @@ export function generateTitle({eventView, event}: {eventView: EventView; event?:
   }
 
   const eventTitle = event ? getTitle(event).title : undefined;
-
   if (eventTitle) {
     titles.push(eventTitle);
   }
-
   titles.reverse();
 
   return titles.join(' - ');
@@ -337,20 +320,16 @@ export function downloadAsCsv(tableData, columnOrder, filename) {
   link.remove();
 }
 
-// transform a given aggregated field to its un-aggregated form.
-// the given field can be transformed into another field, or undefined if it'll need to be dropped.
-type AggregateTransformer = (field: string) => string | undefined;
-
-// a map between a field alias to a transform function to convert the aggregated field alias into
+// A map between a field alias to a transform function to convert the aggregated field alias into
 // its un-aggregated form
-const TRANSFORM_AGGREGATES: {[field: string]: AggregateTransformer} = {
-  p99: () => 'transaction.duration',
-  p95: () => 'transaction.duration',
-  p75: () => 'transaction.duration',
-  last_seen: () => 'timestamp',
-  latest_event: () => 'id',
-  apdex: () => undefined,
-  impact: () => undefined,
+const TRANSFORM_AGGREGATES: {[field: string]: string | undefined} = {
+  p99: 'transaction.duration',
+  p95: 'transaction.duration',
+  p75: 'transaction.duration',
+  last_seen: 'timestamp',
+  latest_event: 'id',
+  apdex: undefined,
+  impact: undefined,
 };
 
 /**
@@ -366,9 +345,12 @@ export function getExpandedResults(
 ): EventView {
   // Find aggregate fields and flag them for updates.
   const fieldsToUpdate: number[] = [];
-  eventView.fields.forEach((field: FieldType, index: number) => {
+  eventView.fields.forEach((field: Field, index: number) => {
     const column = explodeField(field);
-    if (column.aggregation || AGGREGATE_ALIASES.includes(column.field)) {
+    if (
+      column.kind === 'function' ||
+      (column.kind === 'field' && AGGREGATE_ALIASES.includes(column.field))
+    ) {
       fieldsToUpdate.push(index);
     }
   });
@@ -379,20 +361,18 @@ export function getExpandedResults(
 
   // make a best effort to replace aggregated columns with their non-aggregated form
   fieldsToUpdate.forEach((indexToUpdate: number) => {
-    const currentField: FieldType = nextView.fields[indexToUpdate];
+    const currentField: Field = nextView.fields[indexToUpdate];
     const exploded = explodeField(currentField);
 
-    // check if we can use an aggregated transform function
-    const fieldNameAlias = TRANSFORM_AGGREGATES[exploded.aggregation]
-      ? exploded.aggregation
-      : TRANSFORM_AGGREGATES[exploded.field]
-      ? exploded.field
-      : undefined;
-
-    const transform = fieldNameAlias && TRANSFORM_AGGREGATES[fieldNameAlias];
+    let fieldNameAlias: string = '';
+    if (exploded.kind === 'function' && TRANSFORM_AGGREGATES[exploded.function[0]]) {
+      fieldNameAlias = exploded.function[0];
+    } else if (exploded.kind === 'field') {
+      fieldNameAlias = exploded.field;
+    }
 
-    if (fieldNameAlias && transform) {
-      const nextFieldName = transform(fieldNameAlias);
+    if (fieldNameAlias && TRANSFORM_AGGREGATES.hasOwnProperty(fieldNameAlias)) {
+      const nextFieldName = TRANSFORM_AGGREGATES[fieldNameAlias];
 
       if (!nextFieldName || transformedFields.has(nextFieldName)) {
         // this field is either duplicated in another column, or nextFieldName is undefined.
@@ -400,39 +380,40 @@ export function getExpandedResults(
         fieldsToDelete.push(indexToUpdate);
         return;
       }
+      transformedFields.add(nextFieldName);
 
-      const updatedColumn = {
-        aggregation: '',
+      const updatedColumn: Column = {
+        kind: 'field',
         field: nextFieldName,
-        width: exploded.width,
       };
-
-      transformedFields.add(nextFieldName);
       nextView = nextView.withUpdatedColumn(indexToUpdate, updatedColumn, undefined);
 
       return;
     }
 
-    // edge case: transform count() into id
-    if (exploded.aggregation === 'count') {
-      exploded.field = 'id';
-    }
-
-    if (!exploded.field || transformedFields.has(exploded.field)) {
-      // If we don't have a field, or already have it, remove the current column
+    if (
+      (exploded.kind === 'field' && transformedFields.has(exploded.field)) ||
+      (exploded.kind === 'function' && transformedFields.has(exploded.function[1]))
+    ) {
+      // If we already have this field we can delete the new instance.
       fieldsToDelete.push(indexToUpdate);
       return;
     }
 
-    transformedFields.add(exploded.field);
-
-    const updatedColumn = {
-      aggregation: '',
-      field: exploded.field,
-      width: exploded.width,
-    };
+    if (exploded.kind === 'function') {
+      let field = exploded.function[1];
+      // edge case: transform count() into id
+      if (exploded.function[0] === 'count') {
+        field = 'id';
+      }
+      transformedFields.add(field);
 
-    nextView = nextView.withUpdatedColumn(indexToUpdate, updatedColumn, undefined);
+      const updatedColumn: Column = {
+        kind: 'field',
+        field,
+      };
+      nextView = nextView.withUpdatedColumn(indexToUpdate, updatedColumn, undefined);
+    }
   });
 
   // delete any columns marked for deletion
@@ -460,11 +441,14 @@ function generateAdditionalConditions(
     return conditions;
   }
 
-  eventView.fields.forEach((field: FieldType) => {
+  eventView.fields.forEach((field: Field) => {
     const column = explodeField(field);
 
     // Skip aggregate fields
-    if (column.aggregation || AGGREGATE_ALIASES.includes(column.field)) {
+    if (
+      column.kind === 'function' ||
+      (column.kind === 'field' && AGGREGATE_ALIASES.includes(column.field))
+    ) {
       return;
     }
 
@@ -511,7 +495,7 @@ function generateExpandedConditions(
   // otherwise, it'll lead to an invalid query result.
   for (const key in parsedQuery) {
     const column = explodeFieldString(key);
-    if (column.aggregation) {
+    if (column.kind === 'function') {
       delete parsedQuery[key];
     }
   }
@@ -534,7 +518,7 @@ function generateExpandedConditions(
     }
     const column = explodeFieldString(key);
     // Skip aggregates as they will be invalid.
-    if (column.aggregation) {
+    if (column.kind === 'function') {
       continue;
     }
     // Skip project name
diff --git a/src/sentry/static/sentry/app/views/performance/table.tsx b/src/sentry/static/sentry/app/views/performance/table.tsx
index 93315ab1e6..96e6e2efd4 100644
--- a/src/sentry/static/sentry/app/views/performance/table.tsx
+++ b/src/sentry/static/sentry/app/views/performance/table.tsx
@@ -208,12 +208,10 @@ class Table extends React.Component<Props, State> {
 
     const tableDataMeta = tableData && tableData.meta ? tableData.meta : undefined;
 
-    const columnOrder = eventView.getColumns();
-
-    return columnOrder.map((column, index) => (
+    return eventView.getColumns().map((column, index) => (
       <HeaderCell column={column} tableData={tableData} key={index}>
         {({align}) => {
-          const field = column.eventViewField;
+          const field = eventView.fields[index];
 
           function generateSortLink(): LocationDescriptorObject | undefined {
             if (!tableDataMeta) {
diff --git a/tests/js/spec/views/eventsV2/eventView.spec.jsx b/tests/js/spec/views/eventsV2/eventView.spec.jsx
index 3a33a703ea..80bb72cf16 100644
--- a/tests/js/spec/views/eventsV2/eventView.spec.jsx
+++ b/tests/js/spec/views/eventsV2/eventView.spec.jsx
@@ -1080,10 +1080,10 @@ describe('EventView.withColumns()', function() {
 
   it('adds new columns, and replaces existing ones', function() {
     const newView = eventView.withColumns([
-      {field: 'title', aggregation: ''},
-      {field: '', aggregation: 'count'},
-      {field: 'project.id', aggregation: ''},
-      {field: 'culprit', aggregation: ''},
+      {kind: 'field', field: 'title'},
+      {kind: 'function', function: ['count', '']},
+      {kind: 'field', field: 'project.id'},
+      {kind: 'field', field: 'culprit'},
     ]);
     // Views should be different.
     expect(newView.isEqualTo(eventView)).toBe(false);
@@ -1097,9 +1097,11 @@ describe('EventView.withColumns()', function() {
 
   it('drops empty columns', function() {
     const newView = eventView.withColumns([
-      {field: 'issue', aggregation: ''},
-      {field: '', aggregation: 'count'},
-      {field: '', aggregation: ''},
+      {kind: 'field', field: 'issue'},
+      {kind: 'function', function: ['count', '']},
+      {kind: 'field', field: ''},
+      {kind: 'function', function: ['', '']},
+      {kind: 'function', function: ['', '', undefined]},
     ]);
     expect(newView.fields).toEqual([
       {field: 'issue', width: COL_WIDTH_UNDEFINED},
@@ -1109,10 +1111,10 @@ describe('EventView.withColumns()', function() {
 
   it('inherits widths from existing columns when names match', function() {
     const newView = eventView.withColumns([
-      {field: '', aggregation: 'count'},
-      {field: 'project.id', aggregation: ''},
-      {field: 'title', aggregation: ''},
-      {field: 'time', aggregation: ''},
+      {kind: 'function', function: ['count', '']},
+      {kind: 'field', field: 'project.id'},
+      {kind: 'field', field: 'title'},
+      {kind: 'field', field: 'time'},
     ]);
 
     expect(newView.fields).toEqual([
@@ -1125,8 +1127,8 @@ describe('EventView.withColumns()', function() {
 
   it('retains sorts when sorted field is included', function() {
     const newView = eventView.withColumns([
-      {field: 'title', aggregation: ''},
-      {field: '', aggregation: 'count'},
+      {kind: 'field', field: 'title'},
+      {kind: 'function', function: ['count', '']},
     ]);
     expect(newView.fields).toEqual([
       {field: 'title', width: COL_WIDTH_UNDEFINED},
@@ -1136,14 +1138,14 @@ describe('EventView.withColumns()', function() {
   });
 
   it('updates sorts when sorted field is removed', function() {
-    const newView = eventView.withColumns([{field: 'title', aggregation: ''}]);
+    const newView = eventView.withColumns([{kind: 'field', field: 'title'}]);
     expect(newView.fields).toEqual([{field: 'title', width: COL_WIDTH_UNDEFINED}]);
     // Should pick a sortable field.
     expect(newView.sorts).toEqual([{field: 'title', kind: 'desc'}]);
   });
 
   it('has no sort if no sortable fields remain', function() {
-    const newView = eventView.withColumns([{field: 'issue', aggregation: ''}]);
+    const newView = eventView.withColumns([{kind: 'field', field: 'issue'}]);
     expect(newView.fields).toEqual([{field: 'issue', width: COL_WIDTH_UNDEFINED}]);
     expect(newView.sorts).toEqual([]);
   });
@@ -1169,7 +1171,7 @@ describe('EventView.withNewColumn()', function() {
   it('adds a field', function() {
     const eventView = new EventView(state);
     const newColumn = {
-      aggregation: '',
+      kind: 'field',
       field: 'title',
     };
     const eventView2 = eventView.withNewColumn(newColumn);
@@ -1186,8 +1188,8 @@ describe('EventView.withNewColumn()', function() {
   it('adds an aggregate function with no arguments', function() {
     const eventView = new EventView(state);
     const newColumn = {
-      aggregation: 'count',
-      field: '',
+      kind: 'function',
+      function: ['count', ''],
     };
 
     const eventView2 = eventView.withNewColumn(newColumn);
@@ -1204,8 +1206,8 @@ describe('EventView.withNewColumn()', function() {
   it('add an aggregate function with field', function() {
     const eventView = new EventView(state);
     const newColumn = {
-      aggregation: 'avg',
-      field: 'transaction.duration',
+      kind: 'function',
+      function: ['avg', 'transaction.duration'],
     };
     const eventView2 = eventView.withNewColumn(newColumn);
     expect(eventView2 !== eventView).toBeTruthy();
@@ -1221,9 +1223,8 @@ describe('EventView.withNewColumn()', function() {
   it('add an aggregate function with field & refinement', function() {
     const eventView = new EventView(state);
     const newColumn = {
-      aggregation: 'percentile',
-      field: 'transaction.duration',
-      refinement: '0.5',
+      kind: 'function',
+      function: ['percentile', 'transaction.duration', '0.5'],
     };
     const updated = eventView.withNewColumn(newColumn);
     expect(updated.fields).toEqual([
@@ -1233,6 +1234,33 @@ describe('EventView.withNewColumn()', function() {
   });
 });
 
+describe('EventView.withResizedColumn()', function() {
+  const state = {
+    id: '1234',
+    name: 'best query',
+    fields: [{field: 'count()'}, {field: 'project.id'}],
+    sorts: generateSorts(['count']),
+    query: 'event.type:error',
+    project: [42],
+    start: '2019-10-01T00:00:00',
+    end: '2019-10-02T00:00:00',
+    statsPeriod: '14d',
+    environment: ['staging'],
+  };
+  const view = new EventView(state);
+
+  it('updates a column that exists', function() {
+    const newView = view.withResizedColumn(0, 99);
+    expect(view.fields[0].width).toBeUndefined();
+    expect(newView.fields[0].width).toEqual(99);
+  });
+
+  it('ignores columns that do not exist', function() {
+    const newView = view.withResizedColumn(100, 99);
+    expect(view.fields).toEqual(newView.fields);
+  });
+});
+
 describe('EventView.withUpdatedColumn()', function() {
   const state = {
     id: '1234',
@@ -1256,8 +1284,8 @@ describe('EventView.withUpdatedColumn()', function() {
     const eventView = new EventView(state);
 
     const newColumn = {
-      aggregation: 'count',
-      field: '',
+      kind: 'function',
+      function: ['count', ''],
     };
 
     const eventView2 = eventView.withUpdatedColumn(0, newColumn, meta);
@@ -1270,14 +1298,13 @@ describe('EventView.withUpdatedColumn()', function() {
     const eventView = new EventView(state);
 
     const newColumn = {
-      aggregation: '',
+      kind: 'field',
       field: 'title',
     };
 
     const eventView2 = eventView.withUpdatedColumn(1, newColumn, meta);
 
     expect(eventView2 !== eventView).toBeTruthy();
-
     expect(eventView).toMatchObject(state);
 
     const nextState = {
@@ -1292,8 +1319,8 @@ describe('EventView.withUpdatedColumn()', function() {
     const eventView = new EventView(state);
 
     const newColumn = {
-      aggregation: 'count',
-      field: '',
+      kind: 'function',
+      function: ['count', ''],
     };
 
     const eventView2 = eventView.withUpdatedColumn(1, newColumn, meta);
@@ -1312,8 +1339,8 @@ describe('EventView.withUpdatedColumn()', function() {
     const eventView = new EventView(state);
 
     const newColumn = {
-      aggregation: 'avg',
-      field: 'transaction.duration',
+      kind: 'function',
+      function: ['avg', 'transaction.duration'],
     };
 
     const eventView2 = eventView.withUpdatedColumn(1, newColumn, meta);
@@ -1332,9 +1359,8 @@ describe('EventView.withUpdatedColumn()', function() {
     const eventView = new EventView(state);
 
     const newColumn = {
-      aggregation: 'percentile',
-      field: 'transaction.duration',
-      refinement: '0.5',
+      kind: 'function',
+      function: ['percentile', 'transaction.duration', '0.5'],
     };
 
     const newView = eventView.withUpdatedColumn(1, newColumn, meta);
@@ -1349,7 +1375,7 @@ describe('EventView.withUpdatedColumn()', function() {
       const eventView = new EventView(state);
 
       const newColumn = {
-        aggregation: '',
+        kind: 'field',
         field: 'title',
       };
 
@@ -1375,7 +1401,7 @@ describe('EventView.withUpdatedColumn()', function() {
       const eventView = new EventView(modifiedState);
 
       const newColumn = {
-        aggregation: '',
+        kind: 'field',
         field: 'title',
       };
 
@@ -1404,7 +1430,7 @@ describe('EventView.withUpdatedColumn()', function() {
       };
 
       const newColumn = {
-        aggregation: '',
+        kind: 'field',
         field: 'title',
       };
 
@@ -1430,7 +1456,7 @@ describe('EventView.withUpdatedColumn()', function() {
 
       // this column is expected to be non-sortable
       const newColumn = {
-        aggregation: '',
+        kind: 'field',
         field: 'project.id',
       };
 
@@ -1459,7 +1485,7 @@ describe('EventView.withUpdatedColumn()', function() {
 
       // this column is expected to be non-sortable
       const newColumn = {
-        aggregation: '',
+        kind: 'field',
         field: 'project.id',
       };
 
@@ -2205,8 +2231,8 @@ describe('isAPIPayloadSimilar', function() {
       const thisAPIPayload = thisEventView.getEventsAPIPayload(location);
 
       const newColumn = {
-        aggregation: 'count',
-        field: '',
+        kind: 'function',
+        function: ['count', ''],
       };
 
       const otherEventView = thisEventView.withUpdatedColumn(0, newColumn, meta);
@@ -2224,7 +2250,7 @@ describe('isAPIPayloadSimilar', function() {
       const thisAPIPayload = thisEventView.getEventsAPIPayload(location);
 
       const newColumn = {
-        aggregation: '',
+        kind: 'field',
         field: 'title',
       };
 
@@ -2243,8 +2269,8 @@ describe('isAPIPayloadSimilar', function() {
       const thisAPIPayload = thisEventView.getEventsAPIPayload(location);
 
       const newColumn = {
-        aggregation: 'avg',
-        field: '',
+        kind: 'function',
+        function: ['avg', ''],
       };
 
       const otherEventView = thisEventView.withUpdatedColumn(0, newColumn, meta);
@@ -2262,8 +2288,8 @@ describe('isAPIPayloadSimilar', function() {
       const thisAPIPayload = thisEventView.getEventsAPIPayload(location);
 
       const newColumn = {
-        aggregation: 'count',
-        field: '',
+        kind: 'function',
+        function: ['count', ''],
       };
 
       const otherEventView = thisEventView.withUpdatedColumn(0, newColumn, meta);
@@ -2325,8 +2351,8 @@ describe('isAPIPayloadSimilar', function() {
       const thisAPIPayload = thisEventView.getFacetsAPIPayload(location);
 
       const newColumn = {
-        aggregation: 'count',
-        field: '',
+        kind: 'function',
+        function: ['count', ''],
       };
 
       const otherEventView = thisEventView.withUpdatedColumn(0, newColumn, meta);
diff --git a/tests/js/spec/views/eventsV2/table/columnEditModal.spec.jsx b/tests/js/spec/views/eventsV2/table/columnEditModal.spec.jsx
index fc195ae956..8ff209215e 100644
--- a/tests/js/spec/views/eventsV2/table/columnEditModal.spec.jsx
+++ b/tests/js/spec/views/eventsV2/table/columnEditModal.spec.jsx
@@ -30,30 +30,32 @@ describe('EventsV2 -> ColumnEditModal', function() {
   const tagKeys = ['browser.name', 'custom-field'];
   const columns = [
     {
+      kind: 'field',
       field: 'event.type',
     },
     {
+      kind: 'field',
       field: 'browser.name',
     },
     {
-      field: 'id',
-      aggregation: 'count',
+      kind: 'function',
+      function: ['count', 'id'],
     },
     {
-      field: 'title',
-      aggregation: 'count_unique',
+      kind: 'function',
+      function: ['count_unique', 'title'],
     },
     {
-      field: '',
-      aggregation: 'p95',
+      kind: 'function',
+      function: ['p95', ''],
     },
     {
+      kind: 'field',
       field: 'issue.id',
-      aggregation: '',
     },
     {
-      field: 'issue.id',
-      aggregation: 'count_unique',
+      kind: 'function',
+      function: ['count_unique', 'issue.id'],
     },
   ];
 
@@ -89,8 +91,8 @@ describe('EventsV2 -> ColumnEditModal', function() {
     const wrapper = mountModal(
       {
         columns: [
-          {aggregation: 'count_unique', field: 'user-defined'},
-          {aggregation: '', field: 'user-def'},
+          {kind: 'function', function: ['count_unique', 'user-defined']},
+          {kind: 'field', field: 'user-def'},
         ],
         onApply: () => void 0,
         tagKeys,
@@ -119,9 +121,9 @@ describe('EventsV2 -> ColumnEditModal', function() {
     const wrapper = mountModal(
       {
         columns: [
-          {aggregation: 'count', field: 'id'},
-          {aggregation: 'count_unique', field: 'title'},
-          {aggregation: 'apdex', field: 'transaction.duration', refinement: 200},
+          {kind: 'function', function: ['count', 'id']},
+          {kind: 'function', function: ['count_unique', 'title']},
+          {kind: 'function', function: ['apdex', 'transaction.duration', 200]},
         ],
         onApply: () => void 0,
         tagKeys,
@@ -147,7 +149,7 @@ describe('EventsV2 -> ColumnEditModal', function() {
     const onApply = jest.fn();
     const wrapper = mountModal(
       {
-        columns: [{aggregation: '', field: 'p95'}],
+        columns: [{kind: 'field', field: 'p95'}],
         onApply,
         tagKeys,
       },
@@ -165,7 +167,7 @@ describe('EventsV2 -> ColumnEditModal', function() {
       selectByLabel(wrapper, 'p99()', {name: 'field', at: 0, control: true});
       wrapper.find('button[aria-label="Apply"]').simulate('click');
       expect(onApply).toHaveBeenCalledWith([
-        {aggregation: 'p99', field: '', refinement: undefined},
+        {kind: 'function', function: ['p99', '', undefined]},
       ]);
     });
   });
@@ -264,10 +266,7 @@ describe('EventsV2 -> ColumnEditModal', function() {
 
       wrapper.find('button[aria-label="Apply"]').simulate('click');
 
-      expect(onApply).toHaveBeenCalledWith([
-        columns[1],
-        {field: 'title', aggregation: '', refinement: undefined},
-      ]);
+      expect(onApply).toHaveBeenCalledWith([columns[1], {kind: 'field', field: 'title'}]);
     });
   });
 });
diff --git a/tests/js/spec/views/eventsV2/utils.spec.jsx b/tests/js/spec/views/eventsV2/utils.spec.jsx
index 406cb64263..7be3be6c1c 100644
--- a/tests/js/spec/views/eventsV2/utils.spec.jsx
+++ b/tests/js/spec/views/eventsV2/utils.spec.jsx
@@ -150,14 +150,11 @@ describe('decodeColumnOrder', function() {
     expect(results[0]).toEqual({
       key: 'title',
       name: 'title',
-      aggregation: '',
-      refinement: undefined,
-      field: 'title',
-      width: 123,
-      eventViewField: {
+      column: {
+        kind: 'field',
         field: 'title',
-        width: 123,
       },
+      width: 123,
       isSortable: false,
       type: 'string',
     });
@@ -170,14 +167,11 @@ describe('decodeColumnOrder', function() {
     expect(results[0]).toEqual({
       key: 'count()',
       name: 'count()',
-      aggregation: 'count',
-      field: '',
-      refinement: undefined,
-      width: 123,
-      eventViewField: {
-        field: 'count()',
-        width: 123,
+      column: {
+        kind: 'function',
+        function: ['count', '', undefined],
       },
+      width: 123,
       isSortable: true,
       type: 'number',
     });
@@ -197,11 +191,11 @@ describe('decodeColumnOrder', function() {
     expect(results[0]).toEqual({
       key: 'avg(transaction.duration)',
       name: 'avg(transaction.duration)',
-      aggregation: 'avg',
-      field: 'transaction.duration',
-      refinement: undefined,
+      column: {
+        kind: 'function',
+        function: ['avg', 'transaction.duration', undefined],
+      },
       width: COL_WIDTH_UNDEFINED,
-      eventViewField: {field: 'avg(transaction.duration)'},
       isSortable: true,
       type: 'duration',
     });
@@ -217,11 +211,11 @@ describe('decodeColumnOrder', function() {
     expect(results[0]).toEqual({
       key: 'percentile(transaction.duration, 0.65)',
       name: 'percentile(transaction.duration, 0.65)',
-      aggregation: 'percentile',
-      field: 'transaction.duration',
-      refinement: '0.65',
+      column: {
+        kind: 'function',
+        function: ['percentile', 'transaction.duration', '0.65'],
+      },
       width: COL_WIDTH_UNDEFINED,
-      eventViewField: {field: 'percentile(transaction.duration, 0.65)'},
       isSortable: true,
       type: 'duration',
     });
@@ -341,8 +335,8 @@ describe('getExpandedResults()', function() {
 
   it('preserves aggregated fields', () => {
     let view = new EventView(state);
-    let result = getExpandedResults(view, {}, {});
 
+    let result = getExpandedResults(view, {}, {});
     expect(result.fields).toEqual([
       {field: 'id', width: -1}, // expect count() to be converted to id
       {field: 'timestamp', width: -1},
@@ -364,7 +358,6 @@ describe('getExpandedResults()', function() {
     });
 
     result = getExpandedResults(view, {}, {});
-
     expect(result.fields).toEqual([
       {field: 'id', width: -1}, // expect count() to be converted to id
       {field: 'timestamp', width: -1},
@@ -397,7 +390,6 @@ describe('getExpandedResults()', function() {
     });
 
     result = getExpandedResults(view, {}, {});
-
     expect(result.fields).toEqual([
       {field: 'timestamp', width: -1},
       {field: 'id', width: -1},
@@ -525,37 +517,32 @@ describe('getDiscoverLandingUrl', function() {
 describe('explodeField', function() {
   it('explodes fields', function() {
     expect(explodeField({field: 'foobar'})).toEqual({
-      aggregation: '',
+      kind: 'field',
       field: 'foobar',
-      width: -1,
     });
 
     // has width
     expect(explodeField({field: 'foobar', width: 123})).toEqual({
-      aggregation: '',
+      kind: 'field',
       field: 'foobar',
-      width: 123,
     });
 
     // has aggregation
     expect(explodeField({field: 'count(foobar)', width: 123})).toEqual({
-      aggregation: 'count',
-      field: 'foobar',
-      width: 123,
+      kind: 'function',
+      function: ['count', 'foobar', undefined],
     });
 
     // custom tag
     expect(explodeField({field: 'foo.bar.is-Enterprise_42', width: 123})).toEqual({
-      aggregation: '',
+      kind: 'field',
       field: 'foo.bar.is-Enterprise_42',
-      width: 123,
     });
 
     // custom tag with aggregation
     expect(explodeField({field: 'count(foo.bar.is-Enterprise_42)', width: 123})).toEqual({
-      aggregation: 'count',
-      field: 'foo.bar.is-Enterprise_42',
-      width: 123,
+      kind: 'function',
+      function: ['count', 'foo.bar.is-Enterprise_42', undefined],
     });
   });
 });

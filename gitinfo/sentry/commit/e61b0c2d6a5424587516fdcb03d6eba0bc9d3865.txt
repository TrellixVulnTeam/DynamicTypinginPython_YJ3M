commit e61b0c2d6a5424587516fdcb03d6eba0bc9d3865
Author: Jess MacQueen <macqueen@users.noreply.github.com>
Date:   Mon Oct 29 11:27:29 2018 -0700

    feat(events): Add basic grammar for parsing search queries (#10242)

diff --git a/src/sentry/api/event_search.py b/src/sentry/api/event_search.py
new file mode 100644
index 0000000000..50fd7937bf
--- /dev/null
+++ b/src/sentry/api/event_search.py
@@ -0,0 +1,167 @@
+from __future__ import absolute_import
+
+from collections import namedtuple
+from parsimonious.grammar import Grammar, NodeVisitor
+
+from sentry.search.utils import parse_datetime_string, InvalidQuery
+
+event_search_grammar = Grammar(r"""
+# raw_search must come at the end, otherwise other
+# search_terms will be treated as a raw query
+search          = search_term* raw_search?
+search_term     = space? (time_filter / basic_filter) space?
+raw_search      = ~r".+$"
+
+# standard key:val filter
+basic_filter    = search_key sep search_value
+# filter specifically for the timestamp
+time_filter     = "timestamp" operator date_formats
+
+search_key      = ~r"[a-z]*\.?[a-z]*"
+search_value    = ~r"\S*"
+
+date_formats    = date_time_micro / date_time / date
+date            = ~r"\d{4}-\d{2}-\d{2}"
+date_time       = ~r"\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}"
+date_time_micro = ~r"\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{1,6}"
+
+# NOTE: the order in which these operators are listed matters
+# because for example, if < comes before <= it will match that
+# even if the operator is <=
+operator        = ">=" / "<=" / ">" / "<" / "=" / "!="
+sep             = ":"
+space           = ~r"\s"
+"""
+)
+
+FIELD_LOOKUP = {
+    'user.id': {
+        'snuba_name': 'user_id',
+        'type': 'string',
+    },
+    'user.email': {
+        'snuba_name': 'email',
+        'type': 'string',
+    },
+    'release': {
+        'snuba_name': 'sentry:release',
+        'type': 'string',
+    },
+    'message': {
+        'snuba_name': 'message',
+        'type': 'string',
+    },
+    'timestamp': {
+        'snuba_name': 'timestamp',
+        'type': 'timestamp',
+    }
+}
+
+
+class InvalidSearchQuery(Exception):
+    pass
+
+
+class SearchFilter(namedtuple('SearchFilter', 'key operator value')):
+    pass
+
+
+class SearchKey(namedtuple('SearchKey', 'name')):
+
+    @property
+    def snuba_name(self):
+        return FIELD_LOOKUP[self.name]['snuba_name']
+
+
+class SearchValue(namedtuple('SearchValue', 'raw_value type')):
+    pass
+
+
+class SearchVisitor(NodeVisitor):
+
+    unwrapped_exceptions = (InvalidSearchQuery,)
+
+    def visit_search(self, node, children):
+        # there is a list from search_term and one from raw_search, so flatten them
+        children = [child for group in children for child in group]
+        return filter(None, children)
+
+    def visit_search_term(self, node, children):
+        _, search_term, _ = children
+        # search_term is a list because of group
+        return search_term[0]
+
+    def visit_raw_search(self, node, children):
+        return SearchFilter(
+            SearchKey('message'),
+            "=",
+            SearchValue(node.text, FIELD_LOOKUP['message']['type']),
+        )
+
+    def visit_time_filter(self, node, children):
+        search_key_node, operator, search_value = children
+        search_key = search_key_node.text
+        try:
+            search_value = parse_datetime_string(search_value)
+        except InvalidQuery as exc:
+            raise InvalidSearchQuery(exc.message)
+
+        try:
+            return SearchFilter(
+                SearchKey(search_key),
+                operator,
+                SearchValue(search_value, FIELD_LOOKUP[search_key]['type']),
+            )
+        except KeyError:
+            raise InvalidSearchQuery('Unsupported search term: %s' % (search_key,))
+
+    def visit_operator(self, node, children):
+        return node.text
+
+    def visit_date_formats(self, node, children):
+        return node.text
+
+    def visit_basic_filter(self, node, children):
+        search_key, _, search_value = children
+        try:
+            return SearchFilter(
+                SearchKey(search_key),
+                "=",
+                SearchValue(search_value, FIELD_LOOKUP[search_key]['type']),
+            )
+        except KeyError:
+            raise InvalidSearchQuery('Unsupported search term: %s' % (search_key,))
+
+    def visit_search_key(self, node, children):
+        return node.text
+
+    def visit_search_value(self, node, children):
+        return node.text
+
+    def generic_visit(self, node, children):
+        return children or node
+
+
+def parse_search_query(query):
+    tree = event_search_grammar.parse(query)
+    return SearchVisitor().visit(tree)
+
+
+def get_snuba_query_args(query):
+    parsed_filters = parse_search_query(query)
+    conditions = []
+    for _filter in parsed_filters:
+        if _filter.key.snuba_name == 'message':
+            # make message search case insensitive
+            conditions.append(
+                [['positionCaseInsensitive', ['message', "'%s'" %
+                                              (_filter.value.raw_value,)]], '!=', 0]
+            )
+        else:
+            conditions.append([
+                _filter.key.snuba_name,
+                _filter.operator,
+                _filter.value.raw_value,
+            ])
+
+    return {'conditions': conditions}
diff --git a/tests/sentry/api/test_event_search.py b/tests/sentry/api/test_event_search.py
new file mode 100644
index 0000000000..c5eb1de595
--- /dev/null
+++ b/tests/sentry/api/test_event_search.py
@@ -0,0 +1,110 @@
+from __future__ import absolute_import
+
+import datetime
+
+from django.utils import timezone
+
+from sentry.api.event_search import (
+    get_snuba_query_args, parse_search_query, InvalidSearchQuery, SearchFilter, SearchKey, SearchValue
+)
+from sentry.testutils import TestCase
+
+
+class EventSearchTest(TestCase):
+    def test_parse_search_query(self):
+        # test with raw search query at the end
+        assert parse_search_query('user.email:foo@example.com release:1.2.1 hello') == [
+            SearchFilter(
+                key=SearchKey(name='user.email'),
+                operator="=",
+                value=SearchValue(raw_value='foo@example.com', type='string'),
+            ),
+            SearchFilter(
+                key=SearchKey(name='release'),
+                operator="=",
+                value=SearchValue(raw_value='1.2.1', type='string'),
+            ),
+            SearchFilter(
+                key=SearchKey(name='message'),
+                operator='=',
+                value=SearchValue(raw_value='hello', type='string'),
+            )
+        ]
+
+        # if the search query starts with the raw query, assume the whole thing is a raw string
+        assert parse_search_query('hello user.email:foo@example.com release:1.2.1') == [
+            SearchFilter(
+                key=SearchKey(name='message'),
+                operator='=',
+                value=SearchValue(
+                    raw_value='hello user.email:foo@example.com release:1.2.1',
+                    type='string'),
+            ),
+        ]
+
+    def test_parse_search_query_timestamp(self):
+        # test date format
+        assert parse_search_query('timestamp>2015-05-18') == [
+            SearchFilter(
+                key=SearchKey(name='timestamp'),
+                operator=">",
+                value=SearchValue(
+                    raw_value=datetime.datetime(
+                        2015,
+                        5,
+                        18,
+                        0,
+                        0,
+                        tzinfo=timezone.utc),
+                    type='timestamp'),
+            ),
+        ]
+        # test date time format
+        assert parse_search_query('timestamp>2015-05-18T10:15:01') == [
+            SearchFilter(
+                key=SearchKey(name='timestamp'),
+                operator=">",
+                value=SearchValue(
+                    raw_value=datetime.datetime(
+                        2015,
+                        5,
+                        18,
+                        10,
+                        15,
+                        1,
+                        tzinfo=timezone.utc),
+                    type='timestamp'),
+            ),
+        ]
+
+        # test date time format w microseconds
+        assert parse_search_query('timestamp>2015-05-18T10:15:01.103') == [
+            SearchFilter(
+                key=SearchKey(name='timestamp'),
+                operator=">",
+                value=SearchValue(
+                    raw_value=datetime.datetime(
+                        2015,
+                        5,
+                        18,
+                        10,
+                        15,
+                        1,
+                        103000,
+                        tzinfo=timezone.utc),
+                    type='timestamp'),
+            ),
+        ]
+
+    def test_parse_search_query_invalid(self):
+        with self.assertRaises(InvalidSearchQuery):
+            parse_search_query('fruit:apple release:1.2.1')
+
+    def test_get_snuba_query_args(self):
+        assert get_snuba_query_args('user.email:foo@example.com release:1.2.1 hello') == {
+            'conditions': [
+                ['email', '=', 'foo@example.com'],
+                ['sentry:release', '=', '1.2.1'],
+                [['positionCaseInsensitive', ['message', "'hello'"]], '!=', 0],
+            ]
+        }

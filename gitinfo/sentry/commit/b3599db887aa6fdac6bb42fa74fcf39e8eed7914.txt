commit b3599db887aa6fdac6bb42fa74fcf39e8eed7914
Author: Radu Woinaroski <5281987+RaduW@users.noreply.github.com>
Date:   Wed Jun 12 16:40:03 2019 +0200

    ref(store): Create relay configuration (#13564)
    
    * feat: Add flag to run under debuggable wsgi server
    
    * feat(config): WIP relay config
    
    * feat(config): WIP relay config
    
    Removed code for getting Rate Limit (it is complicated and needs to
    be redone at a latter stage)
    
    * WIP before merging master in
    
    * WIP remove access to project from Store and EventManager
    
    * Get the project options upfront (preparation for relay)
    
    * Get the project options upfront (preparation for relay)

diff --git a/src/sentry/event_manager.py b/src/sentry/event_manager.py
index 29b023f477..f5e8b46baf 100644
--- a/src/sentry/event_manager.py
+++ b/src/sentry/event_manager.py
@@ -21,12 +21,14 @@ from django.utils.encoding import force_text
 from sentry import buffer, eventtypes, eventstream, features, tagstore, tsdb, filters
 from sentry.constants import (
     DEFAULT_STORE_NORMALIZER_ARGS, LOG_LEVELS, LOG_LEVELS_MAP,
-    MAX_TAG_VALUE_LENGTH, MAX_SECS_IN_FUTURE, MAX_SECS_IN_PAST
+    MAX_TAG_VALUE_LENGTH, MAX_SECS_IN_FUTURE, MAX_SECS_IN_PAST,
+)
+from sentry.grouping.api import (
+    get_grouping_config_dict_for_project,
+    get_grouping_config_dict_for_event_data, load_grouping_config,
+    apply_server_fingerprinting, get_fingerprinting_config_for_project,
+    GroupingConfigNotFound,
 )
-from sentry.grouping.api import get_grouping_config_dict_for_project, \
-    get_grouping_config_dict_for_event_data, load_grouping_config, \
-    apply_server_fingerprinting, get_fingerprinting_config_for_project, \
-    GroupingConfigNotFound
 from sentry.coreapi import (
     APIError,
     APIForbidden,
@@ -41,7 +43,7 @@ from sentry.models import (
     Activity, Environment, Event, EventDict, EventError, EventMapping, EventUser, Group,
     GroupEnvironment, GroupHash, GroupLink, GroupRelease, GroupResolution, GroupStatus,
     Project, Release, ReleaseEnvironment, ReleaseProject,
-    ReleaseProjectEnvironment, UserReport, Organization, EventAttachment
+    ReleaseProjectEnvironment, UserReport, Organization, EventAttachment,
 )
 from sentry.plugins import plugins
 from sentry.signals import event_discarded, event_saved, first_event_received
@@ -62,10 +64,8 @@ from sentry.utils.safe import safe_execute, trim, get_path, setdefault_path
 from sentry.stacktraces.processing import normalize_stacktraces_for_grouping
 from sentry.culprit import generate_culprit
 
-
 logger = logging.getLogger("sentry.events")
 
-
 SECURITY_REPORT_INTERFACES = (
     "csp",
     "hpkp",
@@ -270,11 +270,17 @@ class EventManager(object):
         key=None,
         content_encoding=None,
         is_renormalize=False,
-        remove_other=None
+        remove_other=None,
+        relay_config=None
     ):
         self._data = _decode_event(data, content_encoding=content_encoding)
         self.version = version
         self._project = project
+        # if not explicitly specified try to get the grouping from relay_config
+        if grouping_config is None and relay_config is not None:
+            config = relay_config.config
+            grouping_config = config.get('grouping_config')
+        # if we still don't have a grouping also try the project
         if grouping_config is None and project is not None:
             grouping_config = get_grouping_config_dict_for_project(self._project)
         self._grouping_config = grouping_config
diff --git a/src/sentry/quotas/base.py b/src/sentry/quotas/base.py
index 0622afb7b1..6f086a8149 100644
--- a/src/sentry/quotas/base.py
+++ b/src/sentry/quotas/base.py
@@ -28,6 +28,20 @@ class RateLimit(object):
         # machine readable description
         self.reason_code = reason_code
 
+    def to_dict(self):
+        """
+        Converts the object into a plain dictionary
+        :return: a dict containing the non None elm of the RateLimit
+
+        >>> x = RateLimit(is_limited = False, retry_after = 33)
+        >>> x.to_dict() == {'is_limited': False, 'retry_after': 33}
+        True
+
+        """
+        return {
+            name: getattr(self, name, None) for name in self.__slots__ if getattr(self, name, None) is not None
+        }
+
 
 class NotRateLimited(RateLimit):
     def __init__(self, **kwargs):
diff --git a/src/sentry/web/api.py b/src/sentry/web/api.py
index 924295ac72..3a6b181dfa 100644
--- a/src/sentry/web/api.py
+++ b/src/sentry/web/api.py
@@ -28,7 +28,7 @@ from functools import wraps
 from querystring_parser import parser
 from symbolic import ProcessMinidumpError, Unreal4Error
 
-from sentry import features, quotas, options
+from sentry import features, quotas
 from sentry.attachments import CachedAttachment
 from sentry.constants import ObjectStatus
 from sentry.coreapi import (
@@ -42,11 +42,12 @@ from sentry.lang.native.unreal import (
     process_unreal_crash, merge_apple_crash_report,
     unreal_attachment_type, merge_unreal_context_event, merge_unreal_logs_event,
 )
+
 from sentry.lang.native.minidump import (
     merge_attached_event, merge_attached_breadcrumbs, write_minidump_placeholder,
     MINIDUMP_ATTACHMENT_TYPE,
 )
-from sentry.models import Project, OrganizationOption, Organization, File, EventAttachment, Event
+from sentry.models import Project, File, EventAttachment, Event
 from sentry.signals import (
     event_accepted, event_dropped, event_filtered, event_received,
 )
@@ -64,6 +65,7 @@ from sentry.utils.outcomes import Outcome, track_outcome
 from sentry.utils.pubsub import QueuedPublisherService, KafkaPublisher
 from sentry.utils.safe import safe_execute
 from sentry.web.helpers import render_to_response
+from sentry.web.relay_config import get_full_relay_config
 
 logger = logging.getLogger('sentry')
 minidumps_logger = logging.getLogger('sentry.minidumps')
@@ -88,8 +90,10 @@ def allow_cors_options(func):
     """
     Decorator that adds automatic handling of OPTIONS requests for CORS
 
-    If the request is OPTIONS (i.e. pre flight CORS) construct a NO Content (204) response
+    If the request is OPTIONS (i.e. pre flight CORS) construct a OK (200) response
     in which we explicitly enable the caller and add the custom headers that we support
+    For other requests just add the appropriate CORS headers
+
     :param func: the original request handler
     :return: a request handler that shortcuts OPTIONS requests and just returns an OK (CORS allowed)
     """
@@ -107,7 +111,7 @@ def allow_cors_options(func):
         response['Allow'] = allow
         response['Access-Control-Allow-Methods'] = allow
         response['Access-Control-Allow-Headers'] = 'X-Sentry-Auth, X-Requested-With, Origin, Accept, ' \
-            'Content-Type, Authentication'
+                                                   'Content-Type, Authentication'
         response['Access-Control-Expose-Headers'] = 'X-Sentry-Error, Retry-After'
 
         if request.META.get('HTTP_ORIGIN') == 'null':
@@ -142,7 +146,27 @@ def api(func):
     return wrapped
 
 
-def process_event(event_manager, project, key, remote_addr, helper, attachments):
+def _get_project_id_from_request(project_id, request, auth_helper_cls, helper):
+    """
+    Tries to return the project id (as a string) from the request params or from the auth info
+
+    :param project_id: the project id from the url (or None if not specified)
+    :param request: the HTTP request
+    :param auth_helper_cls: Authentication helper class (from APIView)
+    :param helper: client API helper
+    :return: the project id (as string) if found raises if not found
+
+    :raises APIUnauthorized if bad Authorization header detected or the key is not usable (e.g. disabled)
+    """
+    if project_id is not None:
+        # we have an explicit project id, just return it
+        return six.text_type(project_id)
+    else:  # look in the authentication information for the project id
+        auth = auth_helper_cls.auth_from_request(request)
+        return helper.project_id_from_auth(auth)
+
+
+def process_event(event_manager, project, key, remote_addr, helper, attachments, relay_config):
     event_received.send_robust(ip=remote_addr, project=project, sender=process_event)
 
     start_time = time()
@@ -155,8 +179,8 @@ def process_event(event_manager, project, key, remote_addr, helper, attachments)
 
     if should_filter:
         track_outcome(
-            project.organization_id,
-            project.id,
+            relay_config.organization_id,
+            relay_config.project_id,
             key.id,
             Outcome.FILTERED,
             filter_reason,
@@ -187,8 +211,8 @@ def process_event(event_manager, project, key, remote_addr, helper, attachments)
 
         reason = rate_limit.reason_code if rate_limit else None
         track_outcome(
-            project.organization_id,
-            project.id,
+            relay_config.organization_id,
+            relay_config.project_id,
             key.id,
             Outcome.RATE_LIMITED,
             reason,
@@ -210,17 +234,14 @@ def process_event(event_manager, project, key, remote_addr, helper, attachments)
         if rate_limit is not None:
             raise APIRateLimited(rate_limit.retry_after)
 
-    org_options = OrganizationOption.objects.get_all_values(
-        project.organization_id)
-
     # TODO(dcramer): ideally we'd only validate this if the event_id was
     # supplied by the user
-    cache_key = 'ev:%s:%s' % (project.id, event_id,)
+    cache_key = 'ev:%s:%s' % (relay_config.project_id, event_id,)
 
     if cache.get(cache_key) is not None:
         track_outcome(
-            project.organization_id,
-            project.id,
+            relay_config.organization_id,
+            relay_config.project_id,
             key.id,
             Outcome.INVALID,
             'duplicate',
@@ -229,27 +250,18 @@ def process_event(event_manager, project, key, remote_addr, helper, attachments)
         raise APIForbidden(
             'An event with the same ID already exists (%s)' % (event_id,))
 
-    scrub_ip_address = (org_options.get('sentry:require_scrub_ip_address', False) or
-                        project.get_option('sentry:scrub_ip_address', False))
-    scrub_data = (org_options.get('sentry:require_scrub_data', False) or
-                  project.get_option('sentry:scrub_data', True))
+    config = relay_config.config
+    scrub_ip_address = config.get('scrub_ip_addresses')
+
+    scrub_data = config.get('scrub_data')
 
     if scrub_data:
         # We filter data immediately before it ever gets into the queue
-        sensitive_fields_key = 'sentry:sensitive_fields'
-        sensitive_fields = (
-            org_options.get(sensitive_fields_key, []) +
-            project.get_option(sensitive_fields_key, [])
-        )
+        sensitive_fields = config.get('sensitive_fields')
 
-        exclude_fields_key = 'sentry:safe_fields'
-        exclude_fields = (
-            org_options.get(exclude_fields_key, []) +
-            project.get_option(exclude_fields_key, [])
-        )
+        exclude_fields = config.get('exclude_fields')
 
-        scrub_defaults = (org_options.get('sentry:require_scrub_defaults', False) or
-                          project.get_option('sentry:scrub_defaults', True))
+        scrub_defaults = config.get('scrub_defaults')
 
         SensitiveDataFilter(
             fields=sensitive_fields,
@@ -298,13 +310,13 @@ class APIView(BaseView):
                 raise APIError('Invalid project_id: %r' % project_id)
             return project
 
-    def _parse_header(self, request, helper, project):
+    def _parse_header(self, request, relay_config):
         auth = self.auth_helper_cls.auth_from_request(request)
 
         if auth.version not in PROTOCOL_VERSIONS:
             track_outcome(
-                project.organization_id,
-                project.id,
+                relay_config.organization_id,
+                relay_config.project_id,
                 None,
                 Outcome.INVALID,
                 "auth_version")
@@ -314,12 +326,12 @@ class APIView(BaseView):
             )
 
         if not auth.client:
-            track_outcome(project.organization_id, project.id, None, Outcome.INVALID, "auth_client")
+            track_outcome(relay_config.organization_id, relay_config.project_id, None, Outcome.INVALID, "auth_client")
             raise APIError("Client did not send 'client' identifier")
 
         return auth
 
-    def _publish_to_kafka(self, request):
+    def _publish_to_kafka(self, request, relay_config):
         """
         Sends raw event data to Kafka for later offline processing.
         """
@@ -327,11 +339,15 @@ class APIView(BaseView):
             # This may fail when we e.g. send a multipart form. We ignore those errors for now.
             data = request.body
 
-            if not data or len(data) > options.get('kafka-publisher.max-event-size'):
+            config = relay_config.config
+
+            max_event_size = config.get('kafka_max_event_size')
+            if not data or max_event_size is None or len(data) > max_event_size:
                 return
 
             # Sampling
-            if random.random() >= options.get('kafka-publisher.raw-event-sample-rate'):
+            raw_event_sample_rate = config.get('kafka_raw_event_sample_rate')
+            if raw_event_sample_rate is None or random.random() >= raw_event_sample_rate:
                 return
 
             # We want to send only serializable items from request.META
@@ -356,21 +372,27 @@ class APIView(BaseView):
     @never_cache
     @allow_cors_options
     def dispatch(self, request, project_id=None, *args, **kwargs):
-        helper = ClientApiHelper(
-            agent=request.META.get('HTTP_USER_AGENT'),
-            project_id=project_id,
-            ip_address=request.META['REMOTE_ADDR'],
-        )
+        helper = None
+        try:
+            helper = ClientApiHelper(
+                agent=request.META.get('HTTP_USER_AGENT'),
+                project_id=project_id,
+                ip_address=request.META['REMOTE_ADDR'],
+            )
 
-        if kafka_publisher is not None:
-            self._publish_to_kafka(request)
+            # if the project id is not directly specified get it from the authentication information
+            project_id = _get_project_id_from_request(project_id, request, self.auth_helper_cls, helper)
+
+            relay_config = get_full_relay_config(project_id)
+
+            helper.context.bind_project(relay_config.project)
+
+            if kafka_publisher is not None:
+                self._publish_to_kafka(request, relay_config)
 
-        try:
             origin = self.auth_helper_cls.origin_from_request(request)
 
-            response = self._dispatch(
-                request, helper, project_id=project_id, origin=origin, *args, **kwargs
-            )
+            response = self._dispatch(request, helper, relay_config, origin=origin, *args, **kwargs)
         except APIError as e:
             context = {
                 'error': force_bytes(e.msg, errors='replace'),
@@ -408,7 +430,7 @@ class APIView(BaseView):
             skip_internal=False,
         )
 
-        if helper.context.version:
+        if helper is not None and helper.context is not None and helper.context.version:
             metrics.incr(
                 'client-api.v%s.requests' % (helper.context.version,),
                 skip_internal=False,
@@ -425,50 +447,37 @@ class APIView(BaseView):
 
         return response
 
-    def _dispatch(self, request, helper, project_id=None, origin=None, *args, **kwargs):
+    def _dispatch(self, request, helper, relay_config, origin=None, *args, **kwargs):
         request.user = AnonymousUser()
 
-        project = self._get_project_from_id(project_id)
-        if project:
-            helper.context.bind_project(project)
+        project = relay_config.project
+        config = relay_config.config
+        allowed = config.get('allowed_domains')
 
         if origin is not None:
-            # This check is specific for clients who need CORS support
-            if not project:
-                raise APIError('Client must be upgraded for CORS support')
-            if not is_valid_origin(origin, project):
+            if not is_valid_origin(origin, allowed=allowed):
                 track_outcome(
-                    project.organization_id,
-                    project.id,
+                    relay_config.organization_id,
+                    relay_config.project_id,
                     None,
                     Outcome.INVALID,
                     FilterStatKeys.CORS)
                 raise APIForbidden('Invalid origin: %s' % (origin,))
 
-        auth = self._parse_header(request, helper, project)
+        auth = self._parse_header(request, relay_config)
 
         key = helper.project_key_from_auth(auth)
 
         # Legacy API was /api/store/ and the project ID was only available elsewhere
-        if not project:
-            project = Project.objects.get_from_cache(id=key.project_id)
-            helper.context.bind_project(project)
-        elif key.project_id != project.id:
+        if six.text_type(key.project_id) != six.text_type(relay_config.project_id):
             raise APIError('Two different projects were specified')
 
         helper.context.bind_auth(auth)
 
-        # Explicitly bind Organization so we don't implicitly query it later
-        # this just allows us to comfortably assure that `project.organization` is safe.
-        # This also allows us to pull the object from cache, instead of being
-        # implicitly fetched from database.
-        project.organization = Organization.objects.get_from_cache(
-            id=project.organization_id)
-
         response = super(APIView, self).dispatch(
-            request=request, project=project, auth=auth, helper=helper, key=key, **kwargs
+            request=request, project=project, auth=auth, helper=helper, key=key,
+            relay_config=relay_config, **kwargs
         )
-
         return response
 
     # XXX: backported from Django 1.5
@@ -551,11 +560,14 @@ class StoreView(APIView):
         """Mutate the given EventManager. Hook for subtypes of StoreView (CSP)"""
         pass
 
-    def process(self, request, project, key, auth, helper, data, attachments=None, **kwargs):
+    def process(self, request, project, key, auth, helper, data, relay_config, attachments=None, **kwargs):
         metrics.incr('events.total', skip_internal=False)
 
+        project_id = relay_config.project_id
+        organization_id = relay_config.organization_id
+
         if not data:
-            track_outcome(project.organization_id, project.id, key.id, Outcome.INVALID, "no_data")
+            track_outcome(organization_id, project_id, key.id, Outcome.INVALID, "no_data")
             raise APIError('No JSON data was found')
 
         remote_addr = request.META['REMOTE_ADDR']
@@ -582,8 +594,8 @@ class StoreView(APIView):
         if data_size > 10000000:
             metrics.timing('events.size.rejected', data_size)
             track_outcome(
-                project.organization_id,
-                project.id,
+                organization_id,
+                project_id,
                 key.id,
                 Outcome.INVALID,
                 'too_large',
@@ -594,20 +606,22 @@ class StoreView(APIView):
         metrics.timing(
             'events.size.data.post_storeendpoint',
             data_size,
-            tags={'project_id': project.id}
+            tags={'project_id': project_id}
         )
 
         return process_event(event_manager, project,
-                             key, remote_addr, helper, attachments)
+                             key, remote_addr, helper, attachments, relay_config)
 
 
 class EventAttachmentStoreView(StoreView):
 
-    def post(self, request, project, event_id, **kwargs):
+    def post(self, request, project, event_id, relay_config, **kwargs):
         if not features.has('organizations:event-attachments',
                             project.organization, actor=request.user):
             raise APIForbidden("Event attachments are not enabled for this organization.")
 
+        project_id = relay_config.project_id
+
         if len(request.FILES) == 0:
             return HttpResponse(status=400)
 
@@ -622,7 +636,7 @@ class EventAttachmentStoreView(StoreView):
             # To avoid a race with EventManager which tries to set the group_id on attachments received before
             # the event, first insert the attachment, then lookup for the event for its group.
             event_attachment = EventAttachment.objects.create(
-                project_id=project.id,
+                project_id=project_id,
                 event_id=event_id,
                 name=uploaded_file.name,
                 file=file,
@@ -630,7 +644,7 @@ class EventAttachmentStoreView(StoreView):
 
             try:
                 event = Event.objects.get(
-                    project_id=project.id,
+                    project_id=project_id,
                     event_id=event_id,
                 )
             except Event.DoesNotExist:
@@ -653,7 +667,9 @@ class MinidumpView(StoreView):
     dump_types = ('application/octet-stream', 'application/x-dmp')
     content_types = ('multipart/form-data',) + dump_types
 
-    def _dispatch(self, request, helper, project_id=None, origin=None, *args, **kwargs):
+    def _dispatch(self, request, helper, relay_config, origin=None, config_flags=None, *args,
+                  **kwargs):
+
         # TODO(ja): Refactor shared code with CspReportView. Especially, look at
         # the sentry_key override and test it.
 
@@ -674,8 +690,8 @@ class MinidumpView(StoreView):
 
         request.user = AnonymousUser()
 
-        project = self._get_project_from_id(project_id)
-        helper.context.bind_project(project)
+        project_id = relay_config.project_id
+        project = relay_config.project
 
         # This is yanking the auth from the querystring since it's not
         # in the POST body. This means we expect a `sentry_key` and
@@ -683,10 +699,10 @@ class MinidumpView(StoreView):
         auth = self.auth_helper_cls.auth_from_request(request)
 
         key = helper.project_key_from_auth(auth)
-        if key.project_id != project.id:
+        if key.project_id != project_id:
             track_outcome(
-                project.organization_id,
-                project.id,
+                relay_config.organization_id,
+                project_id,
                 None,
                 Outcome.INVALID,
                 "multi_project_id")
@@ -695,10 +711,10 @@ class MinidumpView(StoreView):
         helper.context.bind_auth(auth)
 
         return super(APIView, self).dispatch(
-            request=request, project=project, auth=auth, helper=helper, key=key, **kwargs
+            request=request, project=project, auth=auth, helper=helper, key=key, relay_config=relay_config, **kwargs
         )
 
-    def post(self, request, project, **kwargs):
+    def post(self, request, project, relay_config, **kwargs):
         # Minidump request payloads do not have the same structure as usual
         # events from other SDKs. The minidump can either be transmitted as
         # request body, or as `upload_file_minidump` in a multipart formdata
@@ -737,8 +753,8 @@ class MinidumpView(StoreView):
 
         if not minidump:
             track_outcome(
-                project.organization_id,
-                project.id,
+                relay_config.organization_id,
+                relay_config.project_id,
                 None,
                 Outcome.INVALID,
                 "missing_minidump_upload")
@@ -776,8 +792,8 @@ class MinidumpView(StoreView):
                 minidump_name = minidump.name
             except KeyError:
                 track_outcome(
-                    project.organization_id,
-                    project.id,
+                    relay_config.organization_id,
+                    relay_config.project_id,
                     None,
                     Outcome.INVALID,
                     "missing_minidump_upload")
@@ -786,8 +802,8 @@ class MinidumpView(StoreView):
         minidump.seek(0)
         if minidump.read(4) != 'MDMP':
             track_outcome(
-                project.organization_id,
-                project.id,
+                relay_config.organization_id,
+                relay_config.project_id,
                 None,
                 Outcome.INVALID,
                 "invalid_minidump")
@@ -810,10 +826,8 @@ class MinidumpView(StoreView):
             type=MINIDUMP_ATTACHMENT_TYPE,
         ))
 
-        # Append all other files as generic attachments. We can skip this if the
-        # feature is disabled since they won't be saved.
-        has_event_attachments = features.has('organizations:event-attachments',
-                                             project.organization, actor=request.user)
+        # Append all other files as generic attachments.
+        # RaduW 4 Jun 2019 always sent attachments for minidump (does not use event-attachments feature)
         for name, file in six.iteritems(request_files):
             if name == 'upload_file_minidump':
                 continue
@@ -827,8 +841,7 @@ class MinidumpView(StoreView):
                 continue
 
             # Add any other file as attachment
-            if has_event_attachments:
-                attachments.append(CachedAttachment.from_upload(file))
+            attachments.append(CachedAttachment.from_upload(file))
 
         # Assign our own UUID so we can track this minidump. We cannot trust
         # the uploaded filename, and if reading the minidump fails there is
@@ -848,6 +861,7 @@ class MinidumpView(StoreView):
             attachments=attachments,
             data=data,
             project=project,
+            relay_config=relay_config,
             **kwargs)
 
         # Return the formatted UUID of the generated event. This is
@@ -863,7 +877,8 @@ class MinidumpView(StoreView):
 class UnrealView(StoreView):
     content_types = ('application/octet-stream',)
 
-    def _dispatch(self, request, helper, sentry_key, project_id=None, origin=None, *args, **kwargs):
+    def _dispatch(self, request, helper, relay_config, sentry_key, origin=None,
+                  config_flags=None, *args, **kwargs):
         if request.method != 'POST':
             track_outcome(0, 0, None, Outcome.INVALID, "disallowed_method")
             return HttpResponseNotAllowed(['POST'])
@@ -875,17 +890,17 @@ class UnrealView(StoreView):
 
         request.user = AnonymousUser()
 
-        project = self._get_project_from_id(project_id)
-        helper.context.bind_project(project)
+        project = relay_config.project
+        project_id = relay_config.project_id
 
         auth = Auth(public_key=sentry_key, is_public=False)
         auth.client = 'sentry.unreal_engine'
 
         key = helper.project_key_from_auth(auth)
-        if key.project_id != project.id:
+        if key.project_id != project_id:
             track_outcome(
-                project.organization_id,
-                project.id,
+                relay_config.organization_id,
+                project_id,
                 None,
                 Outcome.INVALID,
                 "multi_project_id")
@@ -893,10 +908,10 @@ class UnrealView(StoreView):
 
         helper.context.bind_auth(auth)
         return super(APIView, self).dispatch(
-            request=request, project=project, auth=auth, helper=helper, key=key, **kwargs
+            request=request, project=project, auth=auth, helper=helper, key=key, relay_config=relay_config, **kwargs
         )
 
-    def post(self, request, project, **kwargs):
+    def post(self, request, project, relay_config, **kwargs):
         attachments_enabled = features.has('organizations:event-attachments',
                                            project.organization, actor=request.user)
 
@@ -915,8 +930,8 @@ class UnrealView(StoreView):
         except (ProcessMinidumpError, Unreal4Error) as e:
             minidumps_logger.exception(e)
             track_outcome(
-                project.organization_id,
-                project.id,
+                relay_config.organization_id,
+                relay_config.project_id,
                 None,
                 Outcome.INVALID,
                 "process_minidump_unreal")
@@ -970,6 +985,7 @@ class UnrealView(StoreView):
             attachments=attachments,
             data=event,
             project=project,
+            relay_config=relay_config,
             **kwargs)
 
         # The return here is only useful for consistency
@@ -995,7 +1011,8 @@ class SecurityReportView(StoreView):
         'application/expect-staple-report',
     )
 
-    def _dispatch(self, request, helper, project_id=None, origin=None, *args, **kwargs):
+    def _dispatch(self, request, helper, relay_config, origin=None,
+                  config_flags=None, *args, **kwargs):
         # A CSP report is sent as a POST request with no Origin or Referer
         # header. What we're left with is a 'document-uri' key which is
         # inside of the JSON body of the request. This 'document-uri' value
@@ -1012,8 +1029,8 @@ class SecurityReportView(StoreView):
 
         request.user = AnonymousUser()
 
-        project = self._get_project_from_id(project_id)
-        helper.context.bind_project(project)
+        project = relay_config.project
+        project_id = relay_config.project_id
 
         # This is yanking the auth from the querystring since it's not
         # in the POST body. This means we expect a `sentry_key` and
@@ -1021,7 +1038,7 @@ class SecurityReportView(StoreView):
         auth = self.auth_helper_cls.auth_from_request(request)
 
         key = helper.project_key_from_auth(auth)
-        if key.project_id != project.id:
+        if key.project_id != project_id:
             track_outcome(
                 project.organization_id,
                 project.id,
@@ -1033,16 +1050,16 @@ class SecurityReportView(StoreView):
         helper.context.bind_auth(auth)
 
         return super(APIView, self).dispatch(
-            request=request, project=project, auth=auth, helper=helper, key=key, **kwargs
+            request=request, project=project, auth=auth, helper=helper, key=key, relay_config=relay_config, **kwargs
         )
 
-    def post(self, request, project, helper, key, **kwargs):
+    def post(self, request, project, helper, key, relay_config, **kwargs):
         json_body = safely_load_json_string(request.body)
         report_type = self.security_report_type(json_body)
         if report_type is None:
             track_outcome(
-                project.organization_id,
-                project.id,
+                relay_config.organization_id,
+                relay_config.project_id,
                 key.id,
                 Outcome.INVALID,
                 "security_report_type")
@@ -1053,8 +1070,8 @@ class SecurityReportView(StoreView):
             instance = interface.from_raw(json_body)
         except jsonschema.ValidationError as e:
             track_outcome(
-                project.organization_id,
-                project.id,
+                relay_config.organization_id,
+                relay_config.project_id,
                 key.id,
                 Outcome.INVALID,
                 "security_report")
@@ -1063,13 +1080,12 @@ class SecurityReportView(StoreView):
         # Do origin check based on the `document-uri` key as explained in `_dispatch`.
         origin = instance.get_origin()
         if not is_valid_origin(origin, project):
-            if project:
-                track_outcome(
-                    project.organization_id,
-                    project.id,
-                    key.id,
-                    Outcome.INVALID,
-                    FilterStatKeys.CORS)
+            track_outcome(
+                relay_config.organization_id,
+                relay_config.project_id,
+                key.id,
+                Outcome.INVALID,
+                FilterStatKeys.CORS)
             raise APIForbidden('Invalid origin')
 
         data = {
@@ -1079,7 +1095,14 @@ class SecurityReportView(StoreView):
             'environment': request.GET.get('sentry_environment'),
         }
 
-        self.process(request, project=project, helper=helper, data=data, key=key, **kwargs)
+        self.process(request,
+                     project=project,
+                     helper=helper,
+                     data=data,
+                     key=key,
+                     relay_config=relay_config,
+                     **kwargs)
+
         return HttpResponse(content_type='application/javascript', status=201)
 
     def security_report_type(self, body):
diff --git a/src/sentry/web/relay_config.py b/src/sentry/web/relay_config.py
new file mode 100644
index 0000000000..aed19d39ca
--- /dev/null
+++ b/src/sentry/web/relay_config.py
@@ -0,0 +1,270 @@
+from __future__ import absolute_import
+import json
+
+import six
+import logging
+
+from copy import copy
+
+from sentry.coreapi import APIError
+from sentry.models.organizationoption import OrganizationOption
+from sentry.models.project import Project
+from sentry.models.organization import Organization
+from sentry import options
+from sentry.utils.data_filters import FilterTypes
+from sentry.utils.http import get_origins
+from sentry.utils.outcomes import Outcome, track_outcome
+from sentry.grouping.api import get_grouping_config_dict_for_project
+from sentry import filters
+
+logger = logging.getLogger('sentry')
+
+# a list of all the properties available in restricted config
+_restricted_config_properties = frozenset([
+    'project_id',
+
+    'kafka_max_event_size',
+    'kafka_raw_event_sample_rate'
+])
+
+
+class _ConfigBase(object):
+    """
+    Base class for configuration objects
+
+    Offers a readonly configuration class that can be serialized to json and viewed as a simple dictionary
+
+    >>> x = _ConfigBase( a= 1, b="The b", c= _ConfigBase(x=33, y = _ConfigBase(m=3.14159 , w=[1,2,3], z={'t':1})))
+    >>> x.a
+    1
+    >>> x.b
+    'The b'
+    >>> x.something is None # accessing non-existing elements
+    True
+    >>> x.c.y.w
+    [1, 2, 3]
+
+    """
+
+    def __init__(self, **kwargs):
+        data = {}
+        object.__setattr__(self, "data", data)
+        for (key, val) in six.iteritems(kwargs):
+            if val is not None:
+                data[key] = val
+
+    def __setattr__(self, key, value):
+        raise Exception("Trying to change read only RelayConfig object")
+
+    def __getattr__(self, name):
+        data = self.__get_data()
+        return data.get(name)
+
+    def to_dict(self):
+        """
+        Converts the config object into a dictionary
+
+        :return: A dictionary containing the object properties, with config properties also converted in dictionaries
+
+        >>> x = _ConfigBase( a= 1, b="The b", c= _ConfigBase(x=33, y = _ConfigBase(m=3.14159 , w=[1,2,3], z={'t':1})))
+        >>> x.to_dict() == {'a': 1, 'c': {'y': {'m': 3.14159, 'w': [1, 2, 3], 'z':{'t': 1}}, 'x': 33}, 'b': 'The b'}
+        True
+        """
+        data = self.__get_data()
+        cp = copy(data)  # copy so that we don't override inner RelayConfig objects
+
+        for (key, val) in six.iteritems(cp):
+            if isinstance(val, _ConfigBase):
+                cp[key] = val.to_dict()
+        return cp
+
+    def to_json_string(self):
+        """
+        >>> x = _ConfigBase( a = _ConfigBase(b = _ConfigBase( w=[1,2,3])))
+        >>> x.to_json_string()
+        '{"a": {"b": {"w": [1, 2, 3]}}}'
+
+        :return:
+        """
+        data = self.to_dict()
+        return json.dumps(data)
+
+    def get_at_path(self, *args):
+        """
+        Gets an element at the specified path returning None if the element or the path doesn't exists
+
+        :param args: the path to follow ( a list of strings)
+        :return: the element if present at specified path or None otherwise)
+
+        >>> x = _ConfigBase( a= 1, b="The b", c= _ConfigBase(x=33, y = _ConfigBase(m=3.14159 , w=[1,2,3], z={'t':1})))
+        >>> x.get_at_path('c','y','m')
+        3.14159
+        >>> x.get_at_path('bb') is None # property not set
+        True
+        >>> x.get_at_path('a', 'something') is None # trying to go past existing Config paths
+        True
+        >>> x.get_at_path('c','y','z')
+        {'t': 1}
+        >>> x.get_at_path('c','y','z','t') is None # only navigates in ConfigBase does not try to go into normal
+        dictionaries
+        True
+
+        """
+        if len(args) == 0:
+            return self
+
+        data = self.__get_data()
+        val = data.get(args[0])
+
+        if len(args) == 1:
+            return val
+
+        if isinstance(val, _ConfigBase):
+            return val.get_at_path(*args[1:])
+
+        return None  # property not set or path goes beyond the Config defined valid path
+
+    def __get_data(self):
+        return object.__getattribute__(self, 'data')
+
+    def __str__(self):
+        try:
+            return json.dumps(self.to_dict(), sort_keys=True)
+        except Exception as e:
+            return "Content Error:{}".format(e)
+
+    def __repr__(self):
+        return "({0}){1}".format(self.__class__.__name__, self)
+
+
+class RestrictedConfig(_ConfigBase):
+    """
+    Represents the full configuration available to a trusted Relay processor
+    """
+
+    def to_restricted(self):
+        return self
+
+
+class FullRelayConfig(_ConfigBase):
+    """
+    Represents the restricted configuration available to an untrusted
+    """
+
+    def __init__(self, project, **kwargs):
+        # TODO RaduW 20.05.2019 (ideally we would like to get rid of the project object), it is
+        #   quite messy at the moment (it is added to the helper context so I don't really know where it ends up)
+        #   For now just add it as a property (will not be serialized to JSON since it is not in the 'data' dictionary)
+        object.__setattr__(self, "project", project)
+
+        super(FullRelayConfig, self).__init__(**kwargs)
+
+    def to_restricted(self):
+        """
+        Constructs a restricted Relay configuration for use on external (untrusted relay pipes)
+
+        :return: a RestrictedConfig
+        """
+        all = self.to_dict()
+        # keep only whitelisted properties for the Restricted conf
+        restricted = {key: value for key, value in six.iteritems(all) if key in _restricted_config_properties}
+        return RestrictedConfig(**restricted)
+
+
+def get_full_relay_config(project_id):
+    """
+    Constructs the internal (big) RelayConfig
+
+    :param project_id: the project id as int or string
+    :return: FullRelayConfig the relay configuration
+    """
+
+    cfg = {}
+    project = _get_project_from_id(six.text_type(project_id))
+
+    if project is None:
+        raise APIError("Invalid project id:{}".format(project_id))
+
+    cfg['project_id'] = project.id
+    cfg['organization_id'] = project.organization_id
+
+    # Explicitly bind Organization so we don't implicitly query it later
+    # this just allows us to comfortably assure that `project.organization` is safe.
+    # This also allows us to pull the object from cache, instead of being
+    # implicitly fetched from database.
+    project.organization = Organization.objects.get_from_cache(
+        id=project.organization_id)
+
+    if project.organization is not None:
+        org_options = OrganizationOption.objects.get_all_values(
+            project.organization_id)
+    else:
+        org_options = {}
+
+    # get the project options
+    project_cfg = {}
+    cfg['config'] = project_cfg
+
+    # getting kafka info
+    try:
+        project_cfg['kafka_max_event_size'] = options.get('kafka-publisher.max-event-size')
+        project_cfg['kafka_raw_event_sample_rate'] = options.get('kafka-publisher.raw-event-sample-rate')
+    except Exception:
+        pass  # should we log ?
+
+    invalid_releases = project.get_option(u'sentry:{}'.format(FilterTypes.RELEASES))
+    if invalid_releases is not None:
+        project_cfg['invalid_releases'] = invalid_releases
+
+    # get the filters enabled for the current project
+    enabled_filters = [filter_class.id for filter_class in filters.all()
+                       if filter_class(project).is_enabled()]
+
+    project_cfg['enabled_filters'] = enabled_filters
+
+    scrub_ip_address = (org_options.get('sentry:require_scrub_ip_address', False) or
+                        project.get_option('sentry:scrub_ip_address', False))
+
+    project_cfg['scrub_ip_addresses'] = scrub_ip_address
+
+    scrub_data = (org_options.get('sentry:require_scrub_data', False) or
+                  project.get_option('sentry:scrub_data', True))
+
+    project_cfg['scrub_data'] = scrub_data
+    project_cfg['grouping_config'] = get_grouping_config_dict_for_project(project)
+    project_cfg['allowed_domains'] = list(get_origins(project))
+
+    if scrub_data:
+        # We filter data immediately before it ever gets into the queue
+        sensitive_fields_key = 'sentry:sensitive_fields'
+        sensitive_fields = (
+            org_options.get(sensitive_fields_key, []) +
+            project.get_option(sensitive_fields_key, [])
+        )
+        project_cfg['sensitive_fields'] = sensitive_fields
+
+        exclude_fields_key = 'sentry:safe_fields'
+        exclude_fields = (
+            org_options.get(exclude_fields_key, []) +
+            project.get_option(exclude_fields_key, [])
+        )
+        project_cfg['exclude_fields'] = exclude_fields
+
+        scrub_defaults = (org_options.get('sentry:require_scrub_defaults', False) or
+                          project.get_option('sentry:scrub_defaults', True))
+        project_cfg['scrub_defaults'] = scrub_defaults
+
+    return FullRelayConfig(project, **cfg)
+
+
+def _get_project_from_id(project_id):
+    if not project_id:
+        return None
+    if not project_id.isdigit():
+        track_outcome(0, 0, None, Outcome.INVALID, "project_id")
+        raise APIError('Invalid project_id: %r' % project_id)
+    try:
+        return Project.objects.get_from_cache(id=project_id)
+    except Project.DoesNotExist:
+        track_outcome(0, 0, None, Outcome.INVALID, "project_id")
+        raise APIError('Invalid project_id: %r' % project_id)

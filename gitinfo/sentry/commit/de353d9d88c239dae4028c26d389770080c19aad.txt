commit de353d9d88c239dae4028c26d389770080c19aad
Author: Manu <manu@sentry.io>
Date:   Mon Oct 28 13:02:04 2019 -0700

    feat(outcomes): Support 10s granularity (#15280)
    
    Here's the query it produces for a 10s granularity in Snuba for `organization_total_received`:
    ```
    SELECT org_id, (toDateTime(intDiv(toUInt32(timestamp), 10) * 10) AS time), (count() AS aggregate) FROM test_outcomes_raw_local PREWHERE org_id IN (1) WHERE outcome != 3 AND timestamp >= toDateTime('2019-10-14T15:47:00') AND timestamp < toDateTime('2019-10-14T15:48:10') AND org_id = 1 GROUP BY (org_id, time) LIMIT 0, 7
    ```

diff --git a/src/sentry/tsdb/snuba.py b/src/sentry/tsdb/snuba.py
index d3ca46f8ec..1b153baef9 100644
--- a/src/sentry/tsdb/snuba.py
+++ b/src/sentry/tsdb/snuba.py
@@ -104,6 +104,41 @@ class SnubaTSDB(BaseTSDB):
         ),
     }
 
+    # The Outcomes dataset aggregates outcomes into chunks of an hour. So, for rollups less than an hour, we want to
+    # query the raw outcomes dataset, with a few different settings (defined in lower_rollup_query_settings).
+    lower_rollup_query_settings = {
+        TSDBModel.organization_total_received: SnubaModelQuerySettings(
+            snuba.Dataset.OutcomesRaw, "org_id", None, [["outcome", "!=", outcomes.Outcome.INVALID]]
+        ),
+        TSDBModel.organization_total_rejected: SnubaModelQuerySettings(
+            snuba.Dataset.OutcomesRaw,
+            "org_id",
+            None,
+            [["outcome", "=", outcomes.Outcome.RATE_LIMITED]],
+        ),
+        TSDBModel.organization_total_blacklisted: SnubaModelQuerySettings(
+            snuba.Dataset.OutcomesRaw, "org_id", None, [["outcome", "=", outcomes.Outcome.FILTERED]]
+        ),
+        TSDBModel.project_total_received: SnubaModelQuerySettings(
+            snuba.Dataset.OutcomesRaw,
+            "project_id",
+            None,
+            [["outcome", "!=", outcomes.Outcome.INVALID]],
+        ),
+        TSDBModel.project_total_rejected: SnubaModelQuerySettings(
+            snuba.Dataset.OutcomesRaw,
+            "project_id",
+            None,
+            [["outcome", "=", outcomes.Outcome.RATE_LIMITED]],
+        ),
+        TSDBModel.project_total_blacklisted: SnubaModelQuerySettings(
+            snuba.Dataset.OutcomesRaw,
+            "project_id",
+            None,
+            [["outcome", "=", outcomes.Outcome.FILTERED]],
+        ),
+    }
+
     all_model_query_settings = dict(
         model_columns.items() + model_being_upgraded_query_settings.items()
     )
@@ -129,7 +164,11 @@ class SnubaTSDB(BaseTSDB):
         `group_on_time`: whether to add a GROUP BY clause on the 'time' field.
         `group_on_model`: whether to add a GROUP BY clause on the primary model.
         """
-        model_query_settings = self.all_model_query_settings.get(model)
+        # 10s is the only rollup under an hour that we support
+        if rollup and rollup == 10 and model in self.lower_rollup_query_settings.keys():
+            model_query_settings = self.lower_rollup_query_settings.get(model)
+        else:
+            model_query_settings = self.all_model_query_settings.get(model)
 
         if model_query_settings is None:
             raise Exception(u"Unsupported TSDBModel: {}".format(model.name))
@@ -229,7 +268,11 @@ class SnubaTSDB(BaseTSDB):
                         del result[rk]
 
     def get_range(self, model, keys, start, end, rollup=None, environment_ids=None):
-        model_query_settings = self.all_model_query_settings.get(model)
+        # 10s is the only rollup under an hour that we support
+        if rollup and rollup == 10 and model in self.lower_rollup_query_settings.keys():
+            model_query_settings = self.lower_rollup_query_settings.get(model)
+        else:
+            model_query_settings = self.all_model_query_settings.get(model)
 
         assert model_query_settings is not None, u"Unsupported TSDBModel: {}".format(model.name)
 
diff --git a/src/sentry/utils/snuba.py b/src/sentry/utils/snuba.py
index 6cae5df4a2..a687c2159a 100644
--- a/src/sentry/utils/snuba.py
+++ b/src/sentry/utils/snuba.py
@@ -63,6 +63,7 @@ class Dataset(Enum):
     Events = "events"
     Transactions = "transactions"
     Outcomes = "outcomes"
+    OutcomesRaw = "outcomes_raw"
 
 
 DATASETS = {Dataset.Events: SENTRY_SNUBA_MAP, Dataset.Transactions: TRANSACTIONS_SENTRY_SNUBA_MAP}
@@ -605,7 +606,7 @@ def _prepare_query_params(query_params):
 
     if query_params.dataset in [Dataset.Events, Dataset.Transactions]:
         (organization_id, params_to_update) = get_query_params_to_update_for_projects(query_params)
-    elif query_params.dataset == Dataset.Outcomes:
+    elif query_params.dataset in [Dataset.Outcomes, Dataset.OutcomesRaw]:
         (organization_id, params_to_update) = get_query_params_to_update_for_organizations(
             query_params
         )
diff --git a/tests/sentry/tsdb/test_snuba.py b/tests/sentry/tsdb/test_snuba.py
index 6c42d18b8d..4d5cb4d309 100644
--- a/tests/sentry/tsdb/test_snuba.py
+++ b/tests/sentry/tsdb/test_snuba.py
@@ -15,6 +15,14 @@ def floor_to_hour_epoch(value):
     return int(to_timestamp(value))
 
 
+def floor_to_10s_epoch(value):
+    seconds = value.second
+    floored_second = 10 * (seconds / 10)
+
+    value = value.replace(second=floored_second, microsecond=0)
+    return int(to_timestamp(value))
+
+
 class SnubaTSDBTest(OutcomesSnubaTest):
     def setUp(self):
         super(SnubaTSDBTest, self).setUp()
@@ -29,12 +37,7 @@ class SnubaTSDBTest(OutcomesSnubaTest):
     def test_organization_outcomes(self):
         other_organization = self.create_organization()
 
-        for tsdb_model, outcome in [
-            (TSDBModel.organization_total_received, Outcome.ACCEPTED),
-            (TSDBModel.organization_total_rejected, Outcome.RATE_LIMITED),
-            (TSDBModel.organization_total_blacklisted, Outcome.FILTERED),
-        ]:
-            # Create all the outcomes we will be querying
+        for outcome in [Outcome.ACCEPTED, Outcome.RATE_LIMITED, Outcome.FILTERED]:
             self.store_outcomes(
                 self.organization.id, self.project.id, outcome.value, self.start_time, 3
             )
@@ -50,34 +53,34 @@ class SnubaTSDBTest(OutcomesSnubaTest):
                 self.organization.id, self.project.id, outcome.value, self.day_before_start_time, 6
             )
 
+        for tsdb_model, granularity, floor_func, start_time_count, day_later_count in [
+            (TSDBModel.organization_total_received, 3600, floor_to_hour_epoch, 3 * 3, 4 * 3),
+            (TSDBModel.organization_total_rejected, 3600, floor_to_hour_epoch, 3, 4),
+            (TSDBModel.organization_total_blacklisted, 3600, floor_to_hour_epoch, 3, 4),
+            (TSDBModel.organization_total_received, 10, floor_to_10s_epoch, 3 * 3, 4 * 3),
+            (TSDBModel.organization_total_rejected, 10, floor_to_10s_epoch, 3, 4),
+            (TSDBModel.organization_total_blacklisted, 10, floor_to_10s_epoch, 3, 4),
+        ]:
             # Query SnubaTSDB
             response = self.db.get_range(
-                tsdb_model, [self.organization.id], self.start_time, self.now, 3600, None
+                tsdb_model, [self.organization.id], self.start_time, self.now, granularity, None
             )
 
             # Assert that the response has values set for the times we expect, and nothing more
             assert self.organization.id in response.keys()
             response_dict = {k: v for (k, v) in response[self.organization.id]}
 
-            assert response_dict[floor_to_hour_epoch(self.start_time)] == 3
-            assert response_dict[floor_to_hour_epoch(self.one_day_later)] == 4
+            assert response_dict[floor_func(self.start_time)] == start_time_count
+            assert response_dict[floor_func(self.one_day_later)] == day_later_count
 
             for time, count in response[self.organization.id]:
-                if time not in [
-                    floor_to_hour_epoch(self.start_time),
-                    floor_to_hour_epoch(self.one_day_later),
-                ]:
+                if time not in [floor_func(self.start_time), floor_func(self.one_day_later)]:
                     assert count == 0
 
     def test_project_outcomes(self):
         other_project = self.create_project(organization=self.organization)
 
-        for tsdb_model, outcome in [
-            (TSDBModel.project_total_received, Outcome.ACCEPTED),
-            (TSDBModel.project_total_rejected, Outcome.RATE_LIMITED),
-            (TSDBModel.project_total_blacklisted, Outcome.FILTERED),
-        ]:
-            # Create all the outcomes we will be querying
+        for outcome in [Outcome.ACCEPTED, Outcome.RATE_LIMITED, Outcome.FILTERED]:
             self.store_outcomes(
                 self.organization.id, self.project.id, outcome.value, self.start_time, 3
             )
@@ -93,21 +96,25 @@ class SnubaTSDBTest(OutcomesSnubaTest):
                 self.organization.id, self.project.id, outcome.value, self.day_before_start_time, 6
             )
 
-            # Query SnubaTSDB
+        for tsdb_model, granularity, floor_func, start_time_count, day_later_count in [
+            (TSDBModel.project_total_received, 3600, floor_to_hour_epoch, 3 * 3, 4 * 3),
+            (TSDBModel.project_total_rejected, 3600, floor_to_hour_epoch, 3, 4),
+            (TSDBModel.project_total_blacklisted, 3600, floor_to_hour_epoch, 3, 4),
+            (TSDBModel.project_total_received, 10, floor_to_10s_epoch, 3 * 3, 4 * 3),
+            (TSDBModel.project_total_rejected, 10, floor_to_10s_epoch, 3, 4),
+            (TSDBModel.project_total_blacklisted, 10, floor_to_10s_epoch, 3, 4),
+        ]:
             response = self.db.get_range(
-                tsdb_model, [self.project.id], self.start_time, self.now, 3600, None
+                tsdb_model, [self.project.id], self.start_time, self.now, granularity, None
             )
 
             # Assert that the response has values set for the times we expect, and nothing more
             assert self.project.id in response.keys()
             response_dict = {k: v for (k, v) in response[self.project.id]}
 
-            assert response_dict[floor_to_hour_epoch(self.start_time)] == 3
-            assert response_dict[floor_to_hour_epoch(self.one_day_later)] == 4
+            assert response_dict[floor_func(self.start_time)] == start_time_count
+            assert response_dict[floor_func(self.one_day_later)] == day_later_count
 
             for time, count in response[self.project.id]:
-                if time not in [
-                    floor_to_hour_epoch(self.start_time),
-                    floor_to_hour_epoch(self.one_day_later),
-                ]:
+                if time not in [floor_func(self.start_time), floor_func(self.one_day_later)]:
                     assert count == 0

commit 97706b5443557e07368b5b71dbeafbeef5d20c09
Author: Colleen O'Rourke <colleen@sentry.io>
Date:   Fri Jun 12 09:50:08 2020 -0700

    ref(Sentry apps): Change error capturing and retry logic (#19298)
    
    * feat(sentry apps): Change error capturing and retry logic
    
    * Don't send sentry errors for not published apps
    
    * Remove extra exception classes, lowercase exception names, edit fn args
    
    * Pass RETRY_OPTIONS, use from_request
    
    * Update destroyer to catch IgnorableSentryAppError
    
    * Add decorator to check the app's status, update test
    
    * Update test
    
    * Change deco name, rm unnecessary except

diff --git a/src/sentry/shared_integrations/exceptions.py b/src/sentry/shared_integrations/exceptions.py
index 076f0e464a..492eb875fc 100644
--- a/src/sentry/shared_integrations/exceptions.py
+++ b/src/sentry/shared_integrations/exceptions.py
@@ -2,6 +2,8 @@ from __future__ import absolute_import
 
 from bs4 import BeautifulSoup
 from collections import OrderedDict
+from requests.exceptions import RequestException
+
 from simplejson.decoder import JSONDecodeError
 from six.moves.urllib.parse import urlparse
 from sentry.utils import json
@@ -91,3 +93,7 @@ class IntegrationFormError(IntegrationError):
     def __init__(self, field_errors):
         super(IntegrationFormError, self).__init__("Invalid integration action")
         self.field_errors = field_errors
+
+
+class IgnorableSentryAppError(RequestException):
+    pass
diff --git a/src/sentry/tasks/base.py b/src/sentry/tasks/base.py
index aae1b2ef66..fd855abefa 100644
--- a/src/sentry/tasks/base.py
+++ b/src/sentry/tasks/base.py
@@ -54,9 +54,9 @@ def instrumented_task(name, stat_suffix=None, **kwargs):
     return wrapped
 
 
-def retry(func=None, on=(Exception,), exclude=()):
+def retry(func=None, on=(Exception,), exclude=(), ignore=()):
     """
-    >>> @retry(on=(Exception,), exclude=(AnotherException,))
+    >>> @retry(on=(Exception,), exclude=(AnotherException,), ignore=(IgnorableException,))
     >>> def my_task():
     >>>     ...
     """
@@ -69,6 +69,8 @@ def retry(func=None, on=(Exception,), exclude=()):
         def wrapped(*args, **kwargs):
             try:
                 return func(*args, **kwargs)
+            except ignore:
+                return
             except exclude:
                 raise
             except on as exc:
diff --git a/src/sentry/tasks/sentry_apps.py b/src/sentry/tasks/sentry_apps.py
index 728228c70b..988d30c0cb 100644
--- a/src/sentry/tasks/sentry_apps.py
+++ b/src/sentry/tasks/sentry_apps.py
@@ -4,7 +4,11 @@ import logging
 
 from celery.task import current
 from django.core.urlresolvers import reverse
-from requests.exceptions import RequestException, Timeout
+from requests.exceptions import (
+    ConnectionError,
+    Timeout,
+    RequestException,
+)
 
 from sentry.eventstore.models import Event
 from sentry.http import safe_urlopen
@@ -23,6 +27,11 @@ from sentry.models import (
     ServiceHookProject,
     SentryApp,
 )
+from sentry.shared_integrations.exceptions import (
+    IgnorableSentryAppError,
+    ApiHostError,
+    ApiTimeoutError,
+)
 from sentry.models.sentryapp import VALID_EVENTS, track_response_code
 from sentry.utils.compat import filter
 from sentry.constants import SentryAppInstallationStatus
@@ -35,6 +44,11 @@ TASK_OPTIONS = {
     "max_retries": 3,
 }
 
+RETRY_OPTIONS = {
+    "on": (RequestException, ApiHostError, ApiTimeoutError),
+    "ignore": (IgnorableSentryAppError),
+}
+
 # We call some models by a different name, publicly, than their class name.
 # For example the model Group is called "Issue" in the UI. We want the Service
 # Hook events to match what we externally call these primitives.
@@ -70,7 +84,7 @@ def _webhook_event_data(event, group_id, project_id):
 
 
 @instrumented_task(name="sentry.tasks.sentry_apps.send_alert_event", **TASK_OPTIONS)
-@retry(on=(RequestException,))
+@retry(**RETRY_OPTIONS)
 def send_alert_event(event, rule, sentry_app_id):
     group = event.group
     project = Project.objects.get_from_cache(id=group.project_id)
@@ -177,24 +191,23 @@ def _process_resource_change(action, sender, instance_id, retryer=None, *args, *
 
 
 @instrumented_task("sentry.tasks.process_resource_change", **TASK_OPTIONS)
-@retry()
+@retry(**RETRY_OPTIONS)
 def process_resource_change(action, sender, instance_id, *args, **kwargs):
     _process_resource_change(action, sender, instance_id, *args, **kwargs)
 
 
 @instrumented_task("sentry.tasks.process_resource_change_bound", bind=True, **TASK_OPTIONS)
-@retry()
+@retry(**RETRY_OPTIONS)
 def process_resource_change_bound(self, action, sender, instance_id, *args, **kwargs):
     _process_resource_change(action, sender, instance_id, retryer=self, *args, **kwargs)
 
 
 @instrumented_task(name="sentry.tasks.sentry_apps.installation_webhook", **TASK_OPTIONS)
-@retry(on=(RequestException,))
+@retry(**RETRY_OPTIONS)
 def installation_webhook(installation_id, user_id, *args, **kwargs):
     from sentry.mediators.sentry_app_installations import InstallationNotifier
 
     extra = {"installation_id": installation_id, "user_id": user_id}
-
     try:
         # we should send the webhook for pending installations on the install event in case that's part of the workflow
         install = SentryAppInstallation.objects.get(id=installation_id)
@@ -212,7 +225,7 @@ def installation_webhook(installation_id, user_id, *args, **kwargs):
 
 
 @instrumented_task(name="sentry.tasks.sentry_apps.workflow_notification", **TASK_OPTIONS)
-@retry(on=(RequestException,))
+@retry(**RETRY_OPTIONS)
 def workflow_notification(installation_id, issue_id, type, user_id, *args, **kwargs):
     extra = {"installation_id": installation_id, "issue_id": issue_id}
 
@@ -292,12 +305,25 @@ def send_webhooks(installation, event, **kwargs):
         kwargs["install"] = installation
 
         request_data = AppPlatformEvent(**kwargs)
-
         send_and_save_webhook_request(
             servicehook.sentry_app.webhook_url, installation.sentry_app, request_data
         )
 
 
+def ignore_unpublished_app_errors(func):
+    def wrapper(url, sentry_app, app_platform_event):
+        try:
+            return func(url, sentry_app, app_platform_event)
+        except Exception:
+            if sentry_app.is_published:
+                raise
+            else:
+                raise IgnorableSentryAppError("unpublished or internal app")
+
+    return wrapper
+
+
+@ignore_unpublished_app_errors
 def send_and_save_webhook_request(url, sentry_app, app_platform_event):
     buffer = SentryAppWebhookRequestsBuffer(sentry_app)
 
@@ -310,8 +336,8 @@ def send_and_save_webhook_request(url, sentry_app, app_platform_event):
             url=url, data=app_platform_event.body, headers=app_platform_event.headers, timeout=5
         )
 
-    except Timeout:
-        track_response_code("timeout", slug, event)
+    except (Timeout, ConnectionError) as e:
+        track_response_code(e.__class__.__name__.lower(), slug, event)
         # Response code of 0 represents timeout
         buffer.add_request(response_code=0, org_id=org_id, event=event, url=url)
         # Re-raise the exception because some of these tasks might retry on the exception
@@ -327,5 +353,13 @@ def send_and_save_webhook_request(url, sentry_app, app_platform_event):
             error_id=resp.headers.get("Sentry-Hook-Error"),
             project_id=resp.headers.get("Sentry-Hook-Project"),
         )
+
+        if resp.status_code == 503:
+            raise ApiHostError.from_request(resp.request)
+
+        elif resp.status_code == 504:
+            raise ApiTimeoutError.from_request(resp.request)
+
         resp.raise_for_status()
+
         return resp
diff --git a/tests/sentry/mediators/sentry_app_installations/test_destroyer.py b/tests/sentry/mediators/sentry_app_installations/test_destroyer.py
index 5e4d9fcc34..c1246031af 100644
--- a/tests/sentry/mediators/sentry_app_installations/test_destroyer.py
+++ b/tests/sentry/mediators/sentry_app_installations/test_destroyer.py
@@ -143,7 +143,11 @@ class TestDestroyer(TestCase):
 
     @responses.activate
     def test_fail_on_other_error(self):
+        from sentry.constants import SentryAppStatus
+
         install = self.install
+        self.sentry_app.update(status=SentryAppStatus.PUBLISHED)
+        # we don't log errors for unpublished and internal apps
         try:
             responses.add(
                 responses.POST, "https://example.com/webhook", body=Exception("Other error")
diff --git a/tests/sentry/tasks/test_sentry_apps.py b/tests/sentry/tasks/test_sentry_apps.py
index 1a4e8e3fb0..6d0be5b9a2 100644
--- a/tests/sentry/tasks/test_sentry_apps.py
+++ b/tests/sentry/tasks/test_sentry_apps.py
@@ -9,6 +9,7 @@ from django.core.urlresolvers import reverse
 from sentry.utils.compat.mock import patch
 from requests.exceptions import Timeout
 
+from sentry.constants import SentryAppStatus
 from sentry.models import Rule, SentryApp, SentryAppInstallation
 from sentry.testutils import TestCase
 from sentry.testutils.helpers import with_feature
@@ -430,7 +431,8 @@ class TestWebhookRequests(TestCase):
     @patch("sentry.tasks.sentry_apps.safe_urlopen", side_effect=Timeout)
     def test_saves_error_for_request_timeout(self, safe_urlopen):
         data = {"issue": serialize(self.issue)}
-
+        self.sentry_app.update(status=SentryAppStatus.PUBLISHED)
+        # we don't log errors for unpublished and internal apps
         with self.assertRaises(Timeout):
             send_webhooks(
                 installation=self.install, event="issue.assigned", data=data, actor=self.user

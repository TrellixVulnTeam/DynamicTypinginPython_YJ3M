commit fa896f169638a5110618accc1a5d3f65efdd3e20
Author: Lauryn Brown <lauryndbrown@gmail.com>
Date:   Mon May 20 11:09:51 2019 -0700

    feat(search): Allow grouping of boolean search terms in the parser (#13139)
    
    * Got groups to parse now need to add them to the boolean tree.
    
    * Got simple tests working.
    
    * working for nested example.
    
    * Everything looks like it's working. Not sure what to do with malformed groups.
    
    * throw Invalidsearchquery when parens unmatched.
    
    * Added additional tests for malformed groups and badly user inputted data.

diff --git a/src/sentry/api/event_search.py b/src/sentry/api/event_search.py
index cd4895eb4e..7c796f85c9 100644
--- a/src/sentry/api/event_search.py
+++ b/src/sentry/api/event_search.py
@@ -6,7 +6,8 @@ from datetime import datetime
 
 import six
 from django.utils.functional import cached_property
-from parsimonious.exceptions import ParseError
+from parsimonious.expressions import Optional
+from parsimonious.exceptions import IncompleteParseError, ParseError
 from parsimonious.nodes import Node
 from parsimonious.grammar import Grammar, NodeVisitor
 
@@ -81,15 +82,15 @@ def translate(pat):
 # ?              // allow to be empty (allow empty quotes)
 # "              // quote literal
 
-
 event_search_grammar = Grammar(r"""
-search               = (boolean_term / search_term)*
-boolean_term         = search_term (boolean_operator search_term)+
+search               = (boolean_term / paren_term / search_term)*
+boolean_term         = (paren_term / search_term) space? (boolean_operator space? (paren_term / search_term) space?)+
+paren_term           = space? open_paren space? (paren_term / boolean_term)+ space? closed_paren space?
 search_term          = key_val_term / quoted_raw_search / raw_search
 key_val_term         = space? (time_filter / rel_time_filter / specific_time_filter
                        / numeric_filter / has_filter / is_filter / basic_filter)
                        space?
-raw_search           = (!key_val_term ~r"\ *([^\ ^\n]+)\ *" )*
+raw_search           = (!key_val_term ~r"\ *([^\ ^\n ()]+)\ *" )*
 quoted_raw_search    = spaces quoted_value spaces
 
 # standard key:val filter
@@ -109,7 +110,7 @@ is_filter            = negation? "is" sep search_value
 
 search_key           = key / quoted_key
 search_value         = quoted_value / value
-value                = ~r"\S*"
+value                = ~r"[^()\s]*"
 quoted_value         = ~r"\"((?:[^\"]|(?<=\\)[\"])*)?\""s
 key                  = ~r"[a-zA-Z0-9_\.-]+"
 # only allow colons in quoted keys
@@ -123,6 +124,8 @@ rel_date_format      = ~r"[\+\-][0-9]+[wdhm](?=\s|$)"
 # even if the operator is <=
 boolean_operator     = "OR" / "AND"
 operator             = ">=" / "<=" / ">" / "<" / "=" / "!="
+open_paren           = "("
+closed_paren         = ")"
 sep                  = ":"
 space                = " "
 negation             = "!"
@@ -248,6 +251,16 @@ class SearchVisitor(NodeVisitor):
 
         return children
 
+    def remove_optional_nodes(self, children):
+        def is_not_optional(child):
+            return not(isinstance(child, Node) and isinstance(child.expr, Optional))
+        return filter(is_not_optional, children)
+
+    def remove_space(self, children):
+        def is_not_space(child):
+            return not(isinstance(child, Node) and child.text == ' ')
+        return filter(is_not_space, children)
+
     def visit_search(self, node, children):
         return self.flatten(children)
 
@@ -300,8 +313,18 @@ class SearchVisitor(NodeVisitor):
             return result
 
         children = self.flatten(children)
+        children = self.remove_optional_nodes(children)
+        children = self.remove_space(children)
+
         return [build_boolean_tree(children, 0, len(children))]
 
+    def visit_paren_term(self, node, children):
+        children = self.flatten(children)
+        children = self.remove_optional_nodes(children)
+        children = self.remove_space(children)
+
+        return self.flatten(children[1])
+
     def visit_numeric_filter(self, node, children):
         (search_key, _, operator, search_value) = children
         operator = operator[0] if not isinstance(operator, Node) else '='
@@ -436,6 +459,12 @@ class SearchVisitor(NodeVisitor):
     def visit_search_value(self, node, children):
         return SearchValue(children[0])
 
+    def visit_closed_paren(self, node, children):
+        return node.text
+
+    def visit_open_paren(self, node, children):
+        return node.text
+
     def visit_boolean_operator(self, node, children):
         return node.text
 
@@ -558,6 +587,11 @@ def get_snuba_query_args(query=None, params=None):
             raise InvalidSearchQuery(
                 u'Parse error: %r (column %d)' % (e.expr.name, e.column())
             )
+        except IncompleteParseError as e:
+            raise InvalidSearchQuery(
+                'Parse error: Search did not parse completely. This is commonly caused by unmatched-parenthesis. '
+                + six.text_type(e)
+            )
 
     # Keys included as url params take precedent if same key is included in search
     if params is not None:
diff --git a/tests/sentry/api/test_event_search.py b/tests/sentry/api/test_event_search.py
index d2187b275a..3cedc505b5 100644
--- a/tests/sentry/api/test_event_search.py
+++ b/tests/sentry/api/test_event_search.py
@@ -1,6 +1,8 @@
 from __future__ import absolute_import
 
 import datetime
+import pytest
+import six
 from datetime import timedelta
 
 from django.utils import timezone
@@ -708,6 +710,16 @@ class ParseBooleanSearchQueryTest(TestCase):
             operator="=",
             value=SearchValue(raw_value='foobar@example.com'),
         )
+        self.term4 = SearchFilter(
+            key=SearchKey(name='user.email'),
+            operator="=",
+            value=SearchValue(raw_value='hello@example.com'),
+        )
+        self.term5 = SearchFilter(
+            key=SearchKey(name='user.email'),
+            operator="=",
+            value=SearchValue(raw_value='hi@example.com'),
+        )
 
     def test_simple(self):
         assert parse_search_query(
@@ -770,12 +782,6 @@ class ParseBooleanSearchQueryTest(TestCase):
             )
         )]
 
-        term4 = SearchFilter(
-            key=SearchKey(name='user.email'),
-            operator="=",
-            value=SearchValue(raw_value='hello@example.com'),
-        )
-
         # longer even number of terms
         assert parse_search_query(
             'user.email:foo@example.com AND user.email:bar@example.com OR user.email:foobar@example.com AND user.email:hello@example.com'
@@ -789,16 +795,10 @@ class ParseBooleanSearchQueryTest(TestCase):
             right_term=SearchBoolean(
                 left_term=self.term3,
                 operator='AND',
-                right_term=term4
+                right_term=self.term4
             )
         )]
 
-        term5 = SearchFilter(
-            key=SearchKey(name='user.email'),
-            operator="=",
-            value=SearchValue(raw_value='hi@example.com'),
-        )
-
         # longer odd number of terms
         assert parse_search_query(
             'user.email:foo@example.com AND user.email:bar@example.com OR user.email:foobar@example.com AND user.email:hello@example.com AND user.email:hi@example.com'
@@ -814,9 +814,9 @@ class ParseBooleanSearchQueryTest(TestCase):
                     left_term=self.term3,
                     operator='AND',
                     right_term=SearchBoolean(
-                        left_term=term4,
+                        left_term=self.term4,
                         operator='AND',
-                        right_term=term5
+                        right_term=self.term5
                     )
                 )
             )]
@@ -835,9 +835,9 @@ class ParseBooleanSearchQueryTest(TestCase):
                     left_term=self.term3,
                     operator='AND',
                     right_term=SearchBoolean(
-                        left_term=term4,
+                        left_term=self.term4,
                         operator='AND',
-                        right_term=term5)),
+                        right_term=self.term5)),
                 operator='OR',
                 right_term=SearchBoolean(
                     left_term=SearchBoolean(
@@ -849,15 +849,113 @@ class ParseBooleanSearchQueryTest(TestCase):
                         left_term=self.term3,
                         operator='AND',
                         right_term=SearchBoolean(
-                            left_term=term4,
+                            left_term=self.term4,
                             operator='AND',
-                            right_term=term5
+                            right_term=self.term5
                         )
                     )
                 )
             )
         )]
 
+    def test_grouping_simple(self):
+        result = parse_search_query(
+            '(user.email:foo@example.com OR user.email:bar@example.com)'
+        )
+        assert result == [SearchBoolean(left_term=self.term1, operator="OR", right_term=self.term2)]
+        result = parse_search_query(
+            '(user.email:foo@example.com OR user.email:bar@example.com) AND user.email:foobar@example.com'
+        )
+        assert result == [SearchBoolean(
+            left_term=SearchBoolean(
+                left_term=self.term1,
+                operator='OR',
+                right_term=self.term2),
+            operator='AND',
+            right_term=self.term3)]
+
+        result = parse_search_query(
+            'user.email:foo@example.com AND (user.email:bar@example.com OR user.email:foobar@example.com)'
+        )
+        assert result == [SearchBoolean(
+            left_term=self.term1,
+            operator='AND',
+            right_term=SearchBoolean(
+                left_term=self.term2,
+                operator='OR',
+                right_term=self.term3))]
+
+    def test_nested_grouping(self):
+        result = parse_search_query(
+            '(user.email:foo@example.com OR (user.email:bar@example.com OR user.email:foobar@example.com))'
+        )
+        assert result == [SearchBoolean(
+            left_term=self.term1,
+            operator="OR",
+            right_term=SearchBoolean(
+                left_term=self.term2,
+                operator="OR",
+                right_term=self.term3))
+        ]
+        result = parse_search_query(
+            '(user.email:foo@example.com OR (user.email:bar@example.com OR (user.email:foobar@example.com AND user.email:hello@example.com OR user.email:hi@example.com)))'
+        )
+        assert result == [SearchBoolean(
+            left_term=self.term1,
+            operator="OR",
+            right_term=SearchBoolean(
+                left_term=self.term2,
+                operator="OR",
+                right_term=SearchBoolean(
+                    left_term=SearchBoolean(
+                        left_term=self.term3,
+                        operator="AND",
+                        right_term=self.term4
+                    ),
+                    operator="OR",
+                    right_term=self.term5,
+                )
+            )
+        )]
+
+    def test_malformed_groups(self):
+        error_text = "Rule 'search' matched in its entirety, but it didn't consume all the text. The non-matching portion of the text begins with"
+        with pytest.raises(IncompleteParseError) as error:
+            parse_search_query(
+                '(user.email:foo@example.com OR user.email:bar@example.com'
+            )
+        assert six.text_type(error.value) == '%s %s' % (
+            error_text, "'(user.email:foo@exam' (line 1, column 1).")
+        with pytest.raises(IncompleteParseError) as error:
+            parse_search_query(
+                '((user.email:foo@example.com OR user.email:bar@example.com AND  user.email:bar@example.com)'
+            )
+        assert six.text_type(error.value) == '%s %s' % (
+            error_text, "'((user.email:foo@exa' (line 1, column 1).")
+        with pytest.raises(IncompleteParseError) as error:
+            parse_search_query(
+                'user.email:foo@example.com OR user.email:bar@example.com)'
+            )
+        assert six.text_type(error.value) == '%s %s' % (error_text, "')' (line 1, column 57).")
+        with pytest.raises(IncompleteParseError) as error:
+            parse_search_query(
+                '(user.email:foo@example.com OR user.email:bar@example.com AND  user.email:bar@example.com))'
+            )
+        assert six.text_type(error.value) == '%s %s' % (error_text, "')' (line 1, column 91).")
+
+    def test_grouping_without_boolean_terms(self):
+        with pytest.raises(IncompleteParseError) as error:
+            parse_search_query(
+                'undefined is not an object (evaluating \'function.name\')'
+            ) == [SearchFilter(
+                key=SearchKey(name='message'),
+                operator='=',
+                value=SearchValue(
+                    raw_value='undefined is not an object (evaluating "function.name")'),
+            )]
+        assert six.text_type(
+            error.value) == "Rule 'search' matched in its entirety, but it didn't consume all the text. The non-matching portion of the text begins with '(evaluating 'functio' (line 1, column 28)."
+
 
 class GetSnubaQueryArgsTest(TestCase):
     def test_simple(self):
@@ -964,6 +1062,10 @@ class GetSnubaQueryArgsTest(TestCase):
             ]]
         }
 
+    def test_malformed_groups(self):
+        with pytest.raises(InvalidSearchQuery):
+            get_snuba_query_args('(user.email:foo@example.com OR user.email:bar@example.com')
+
 
 class ConvertEndpointParamsTests(TestCase):
     def test_simple(self):

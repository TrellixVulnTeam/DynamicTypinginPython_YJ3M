commit 0c27304df4601bb83fadf71e246efb43b5285e26
Author: David Cramer <dcramer@gmail.com>
Date:   Fri Feb 27 15:19:54 2015 -0800

    Redirect members missing SSO links to auth page
    
    - Refactor base views to inherit from OrganizationView
    - Change member lists to always return invalid members

diff --git a/src/sentry/models/organization.py b/src/sentry/models/organization.py
index 3ba20d7dd2..95e5efe208 100644
--- a/src/sentry/models/organization.py
+++ b/src/sentry/models/organization.py
@@ -61,11 +61,6 @@ class OrganizationManager(BaseManager):
                     has_global_access=True,
                 )
 
-            qs = qs.filter(
-                models.Q(organization__authprovider__isnull=True) |
-                models.Q(flags=getattr(OrganizationMember.flags, 'sso:linked'))
-            )
-
             for om in qs:
                 org = om.organization
                 org.member_type = om.type
diff --git a/src/sentry/models/organizationmember.py b/src/sentry/models/organizationmember.py
index 6b96017968..3c9db288fb 100644
--- a/src/sentry/models/organizationmember.py
+++ b/src/sentry/models/organizationmember.py
@@ -129,7 +129,6 @@ class OrganizationMember(Model):
             'organization_name': self.organization.name,
             'url': absolute_uri(reverse('sentry-auth-link-identity', kwargs={
                 'organization_slug': self.organization.slug,
-                'token': self.token,
             })),
         }
 
diff --git a/src/sentry/models/project.py b/src/sentry/models/project.py
index 93cd9cdd60..b89d9dbc46 100644
--- a/src/sentry/models/project.py
+++ b/src/sentry/models/project.py
@@ -199,15 +199,19 @@ class Project(Model):
         from sentry.models import OrganizationMember
 
         return OrganizationMember.objects.filter(
-            (Q(teams=self.team) | Q(has_global_access=True)),
-            (Q(organization__authprovider__isnull=True) |
-             Q(flags=getattr(OrganizationMember.flags, 'sso:linked'))),
+            Q(teams=self.team) | Q(has_global_access=True),
             user__is_active=True,
             organization=self.organization,
         )
 
     def has_access(self, user, access=None):
-        queryset = self.member_set.filter(user=user)
+        from sentry.models import OrganizationMember
+
+        queryset = self.member_set.filter(
+            (Q(organization__authprovider__isnull=True) |
+             Q(flags=getattr(OrganizationMember.flags, 'sso:linked'))),
+            user=user)
+
         if access is not None:
             queryset = queryset.filter(type__lte=access)
 
diff --git a/src/sentry/models/team.py b/src/sentry/models/team.py
index 5d6d540b25..f47ff95e10 100644
--- a/src/sentry/models/team.py
+++ b/src/sentry/models/team.py
@@ -170,17 +170,19 @@ class Team(Model):
 
     @property
     def member_set(self):
-        from sentry.models import OrganizationMember
-
         return self.organization.member_set.filter(
-            (Q(teams=self) | Q(has_global_access=True)),
-            (Q(organization__authprovider__isnull=True) |
-             Q(flags=getattr(OrganizationMember.flags, 'sso:linked'))),
+            Q(teams=self) | Q(has_global_access=True),
             user__is_active=True,
         )
 
     def has_access(self, user, access=None):
-        queryset = self.member_set.filter(user=user)
+        from sentry.models import OrganizationMember
+
+        queryset = self.member_set.filter(
+            (Q(organization__authprovider__isnull=True) |
+             Q(flags=getattr(OrganizationMember.flags, 'sso:linked'))),
+            user=user,
+        )
         if access is not None:
             queryset = queryset.filter(type__lte=access)
 
diff --git a/src/sentry/web/frontend/auth_link_identity.py b/src/sentry/web/frontend/auth_link_identity.py
index 6f8d2c6e48..3457e1f242 100644
--- a/src/sentry/web/frontend/auth_link_identity.py
+++ b/src/sentry/web/frontend/auth_link_identity.py
@@ -8,13 +8,13 @@ from sentry.auth.helper import AuthHelper
 from sentry.models import AuthProvider, Organization, OrganizationMember
 from sentry.web.frontend.base import BaseView
 
-ERR_INVITE_INVALID = _('The invite link you followed is not valid.')
+ERR_LINK_INVALID = _('Either you are not a member of the given organization or it does not exist.')
 
 
 class AuthLinkIdentityView(BaseView):
     # TODO(dcramer): ideally we could show a login form here if they were auth'd
     # as an invalid account
-    def handle(self, request, organization_slug, token):
+    def handle(self, request, organization_slug):
         try:
             organization = Organization.objects.get(
                 slug=organization_slug
@@ -22,7 +22,7 @@ class AuthLinkIdentityView(BaseView):
         except Organization.DoesNotExist:
             messages.add_message(
                 request, messages.ERROR,
-                ERR_INVITE_INVALID,
+                ERR_LINK_INVALID,
             )
             return self.redirect(reverse('sentry'))
 
@@ -34,18 +34,10 @@ class AuthLinkIdentityView(BaseView):
         except OrganizationMember.DoesNotExist():
             messages.add_message(
                 request, messages.ERROR,
-                ERR_INVITE_INVALID,
+                ERR_LINK_INVALID,
             )
             return self.redirect(reverse('sentry'))
 
-        if om.token != token:
-            messages.add_message(
-                request, messages.ERROR,
-                ERR_INVITE_INVALID,
-            )
-            return self.redirect(reverse('sentry-organization-home',
-                                         args=[organization.slug]))
-
         try:
             auth_provider = AuthProvider.objects.get(
                 organization=organization
@@ -53,7 +45,7 @@ class AuthLinkIdentityView(BaseView):
         except AuthProvider.DoesNotExist:
             messages.add_message(
                 request, messages.ERROR,
-                ERR_INVITE_INVALID,
+                ERR_LINK_INVALID,
             )
             return self.redirect(reverse('sentry-organization-home',
                                          args=[organization.slug]))
diff --git a/src/sentry/web/frontend/base.py b/src/sentry/web/frontend/base.py
index 4d8d547ce0..09c5a79966 100644
--- a/src/sentry/web/frontend/base.py
+++ b/src/sentry/web/frontend/base.py
@@ -2,39 +2,128 @@ from __future__ import absolute_import
 
 import logging
 
+from django.contrib import messages
 from django.core.context_processors import csrf
 from django.core.urlresolvers import reverse
 from django.http import HttpResponseRedirect
 from django.utils.decorators import method_decorator
+from django.utils.translation import ugettext_lazy as _
 from django.views.decorators.csrf import csrf_protect
 from django.views.generic import View
 from sudo.views import redirect_to_sudo
 
 from sentry.models import (
-    Organization, OrganizationMember, OrganizationMemberType,
+    AuthProvider, Organization, OrganizationMember, OrganizationMemberType,
     OrganizationStatus, Project, Team
 )
 from sentry.web.helpers import get_login_url, render_to_response
 
 
+ERR_MISSING_SSO_LINK = _('You need to link your account with the SSO provider to continue.')
+
+
+class NoAccess(object):
+    is_global = False
+    is_sso_valid = False
+
+    def has_access(self, type):
+        return False
+
+    def has_team_access(self, team):
+        return False
+
+
 class Access(object):
-    def __init__(self, is_global, type):
-        self.is_global = is_global
-        self.type = type
+    # TODO(dcramer): this is still a little gross, and ideally backend access
+    # would be based on the same scopes as API access so theres clarity in
+    # what things mean
+    def __init__(self, type, is_global=False, is_sso_valid=False, teams=()):
+        self._is_global = is_global
+        self._is_sso_valid = is_sso_valid
+        self._teams = teams
+        self._type = type
 
     def has_access(self, type):
-        return self.type <= type
+        if self._type is None:
+            return False
+        return self._type <= type
+
+    def has_team_access(self, team):
+        if self._type is None:
+            return False
+        if self._is_global:
+            return True
+        return team in self._teams
 
     @property
     def is_admin(self):
+        if self._type is None:
+            return False
         return self.has_access(OrganizationMemberType.ADMIN)
 
+    @property
+    def is_global(self):
+        return self._is_global
+
     @property
     def is_owner(self):
+        if self._type is None:
+            return False
         return self.has_access(OrganizationMemberType.OWNER)
 
+    @property
+    def is_sso_valid(self):
+        return self._is_sso_valid
+
+    @classmethod
+    def from_user(cls, user, organization):
+        if user.is_superuser:
+            return cls(
+                is_global=True,
+                is_sso_valid=True,
+                type=OrganizationMemberType.OWNER,
+            )
+
+        if not organization:
+            return NoAccess()
+
+        try:
+            om = OrganizationMember.objects.get(
+                user=user, organization=organization
+            )
+        except OrganizationMember.DoesNotExist:
+            return cls(type=None)
+
+        return cls.from_member(om)
+
+    @classmethod
+    def from_member(cls, member):
+        if member.has_global_access:
+            teams = ()
+        else:
+            teams = member.teams.all()
+
+        try:
+            auth_provider = AuthProvider.objects.get(
+                organization=member.organization_id,
+            )
+        except AuthProvider.DoesNotExist:
+            is_sso_valid = True
+        else:
+            is_sso_valid = auth_provider.member_is_valid(member)
+
+        return cls(
+            is_global=member.has_global_access,
+            is_sso_valid=is_sso_valid,
+            type=member.type,
+            teams=teams,
+        )
+
 
 class OrganizationMixin(object):
+    # TODO(dcramer): move the implicit organization logic into its own class
+    # as it's only used in a single location and over complicates the rest of
+    # the code
     def get_active_organization(self, request, organization_slug=None,
                                 access=None):
         """
@@ -127,17 +216,6 @@ class OrganizationMixin(object):
 
         return project
 
-    def get_access(self, user, organization):
-        if user.is_superuser:
-            access = Access(is_global=True, type=OrganizationMemberType.OWNER)
-        else:
-            om = OrganizationMember.objects.get(
-                user=user, organization=organization
-            )
-            access = Access(is_global=om.has_global_access, type=om.type)
-
-        return access
-
 
 class BaseView(View, OrganizationMixin):
     auth_required = True
@@ -146,41 +224,61 @@ class BaseView(View, OrganizationMixin):
 
     @method_decorator(csrf_protect)
     def dispatch(self, request, *args, **kwargs):
-        if self.auth_required and not request.user.is_authenticated():
-            request.session['_next'] = request.get_full_path()
-            if 'organization_slug' in kwargs:
-                redirect_to = reverse('sentry-auth-organization',
-                                      args=[kwargs['organization_slug']])
-            else:
-                redirect_to = get_login_url()
-            return self.redirect(redirect_to)
-
-        if self.sudo_required and not request.is_sudo():
-            return redirect_to_sudo(request.get_full_path())
+        if self.is_auth_required(request):
+            return self.handle_auth_required(request)
+
+        if self.is_sudo_required(request):
+            return self.handle_sudo_required(request)
 
         args, kwargs = self.convert_args(request, *args, **kwargs)
 
+        request.access = self.get_access(request, *args, **kwargs)
+
         if not self.has_permission(request, *args, **kwargs):
-            redirect_uri = self.get_no_permission_url(request, *args, **kwargs)
-            return self.redirect(redirect_uri)
+            return self.handle_permission_required(request, *args, **kwargs)
 
         self.request = request
         self.default_context = self.get_context_data(request, *args, **kwargs)
 
         return self.handle(request, *args, **kwargs)
 
+    def get_access(self, request, *args, **kwargs):
+        return NoAccess()
+
     def convert_args(self, request, *args, **kwargs):
         return (args, kwargs)
 
     def handle(self, request, *args, **kwargs):
         return super(BaseView, self).dispatch(request, *args, **kwargs)
 
-    def get_no_permission_url(request, *args, **kwargs):
-        return reverse('sentry')
+    def is_auth_required(self, request, *args, **kwargs):
+        return self.auth_required and not request.user.is_authenticated()
+
+    def handle_auth_required(self, request, *args, **kwargs):
+        request.session['_next'] = request.get_full_path()
+        if 'organization_slug' in kwargs:
+            redirect_to = reverse('sentry-auth-organization',
+                                  args=[kwargs['organization_slug']])
+        else:
+            redirect_to = get_login_url()
+        return self.redirect(redirect_to)
+
+    def is_sudo_required(self, request, *args, **kwargs):
+        return self.sudo_required and not request.is_sudo()
+
+    def handle_sudo_required(self, request, *args, **kwargs):
+        return redirect_to_sudo(request.get_full_path())
 
     def has_permission(self, request, *args, **kwargs):
         return True
 
+    def handle_permission_required(self, request, *args, **kwargs):
+        redirect_uri = self.get_no_permission_url(request, *args, **kwargs)
+        return self.redirect(redirect_uri)
+
+    def get_no_permission_url(request, *args, **kwargs):
+        return reverse('sentry')
+
     def get_context_data(self, request, **kwargs):
         context = csrf(request)
         return context
@@ -212,22 +310,38 @@ class OrganizationView(BaseView):
     resulting dispatch.
     """
     required_access = None
+    valid_sso_required = True
+
+    def get_access(self, request, organization, *args, **kwargs):
+        return Access.from_user(request.user, organization)
 
     def get_context_data(self, request, organization, **kwargs):
         context = super(OrganizationView, self).get_context_data(request)
         context['organization'] = organization
         context['TEAM_LIST'] = self.get_team_list(request.user, organization)
-        context['ACCESS'] = self.get_access(request.user, organization)
+        context['ACCESS'] = request.access
         return context
 
     def has_permission(self, request, organization, *args, **kwargs):
-        return organization is not None
+        if organization is None:
+            return False
+        if self.valid_sso_required and not request.access.is_sso_valid:
+            return False
+        return True
 
-    def convert_args(self, request, organization_slug=None, *args, **kwargs):
-        # TODO:
-        # if access is MEMBER_OWNER:
-        #     _wrapped = login_required(sudo_required(_wrapped))
+    def handle_permission_required(self, request, organization, *args, **kwargs):
+        if organization and self.valid_sso_required and not request.access.is_sso_valid:
+            messages.add_message(
+                request, messages.ERROR,
+                ERR_MISSING_SSO_LINK,
+            )
+            redirect_uri = reverse('sentry-auth-link-identity',
+                                   args=[organization.slug])
+        else:
+            redirect_uri = self.get_no_permission_url(request, *args, **kwargs)
+        return self.redirect(redirect_uri)
 
+    def convert_args(self, request, organization_slug=None, *args, **kwargs):
         active_organization = self.get_active_organization(
             request=request,
             access=self.required_access,
@@ -239,7 +353,7 @@ class OrganizationView(BaseView):
         return (args, kwargs)
 
 
-class TeamView(BaseView):
+class TeamView(OrganizationView):
     """
     Any view acting on behalf of a team should inherit from this base and the
     matching URL pattern must pass 'team_slug'.
@@ -249,17 +363,15 @@ class TeamView(BaseView):
     - organization
     - team
     """
-    required_access = None
-
     def get_context_data(self, request, organization, team, **kwargs):
-        context = super(TeamView, self).get_context_data(request)
-        context['organization'] = organization
+        context = super(TeamView, self).get_context_data(request, organization)
         context['team'] = team
-        context['TEAM_LIST'] = self.get_team_list(request.user, organization)
-        context['ACCESS'] = self.get_access(request.user, organization)
         return context
 
     def has_permission(self, request, organization, team, *args, **kwargs):
+        rv = super(TeamView, self).has_permission(request, organization)
+        if not rv:
+            return rv
         return team is not None
 
     def convert_args(self, request, organization_slug, team_slug, *args, **kwargs):
@@ -284,7 +396,7 @@ class TeamView(BaseView):
         return (args, kwargs)
 
 
-class ProjectView(BaseView):
+class ProjectView(TeamView):
     """
     Any view acting on behalf of a project should inherit from this base and the
     matching URL pattern must pass 'team_slug' as well as 'project_slug'.
@@ -295,18 +407,15 @@ class ProjectView(BaseView):
     - team
     - project
     """
-    required_access = None
-
     def get_context_data(self, request, organization, team, project, **kwargs):
-        context = super(ProjectView, self).get_context_data(request)
-        context['organization'] = organization
+        context = super(ProjectView, self).get_context_data(request, organization, team)
         context['project'] = project
-        context['team'] = team
-        context['TEAM_LIST'] = self.get_team_list(request.user, organization)
-        context['ACCESS'] = self.get_access(request.user, organization)
         return context
 
     def has_permission(self, request, organization, team, project, *args, **kwargs):
+        rv = super(ProjectView, self).has_permission(request, organization, team)
+        if not rv:
+            return rv
         return project is not None
 
     def convert_args(self, request, organization_slug, project_slug, *args, **kwargs):
diff --git a/src/sentry/web/urls.py b/src/sentry/web/urls.py
index 5afb430926..780ad9801f 100644
--- a/src/sentry/web/urls.py
+++ b/src/sentry/web/urls.py
@@ -104,7 +104,7 @@ urlpatterns += patterns('',
         name='sentry-mailgun-inbound-hook'),
 
     # Auth
-    url(r'^auth/link/(?P<organization_slug>[^/]+)/(?P<token>\w+)/$', AuthLinkIdentityView.as_view(),
+    url(r'^auth/link/(?P<organization_slug>[^/]+)/$', AuthLinkIdentityView.as_view(),
         name='sentry-auth-link-identity'),
     url(r'^auth/login/$', AuthLoginView.as_view(),
         name='sentry-login'),
diff --git a/tests/sentry/web/frontend/test_organization_home.py b/tests/sentry/web/frontend/test_organization_home.py
index 7041523f8c..97e809e38f 100644
--- a/tests/sentry/web/frontend/test_organization_home.py
+++ b/tests/sentry/web/frontend/test_organization_home.py
@@ -2,6 +2,7 @@ from __future__ import absolute_import
 
 from django.core.urlresolvers import reverse
 
+from sentry.models import AuthProvider
 from sentry.testutils import TestCase, PermissionTestCase
 
 
@@ -21,6 +22,26 @@ class OrganizationHomePermissionTest(PermissionTestCase):
 
 
 class OrganizationHomeTest(TestCase):
+    # this test isn't really specific to OrganizationHome, but it needs to
+    # guarantee this behavior so we stuff it here
+    def test_redirects_unlinked_sso_member(self):
+        user = self.create_user('not-a-superuser@example.com')
+        organization = self.create_organization(name='foo', owner=user)
+        team = self.create_team(organization=organization)
+        project = self.create_project(team=team)
+        auth_provider = AuthProvider.objects.create(organization=organization)
+
+        path = reverse('sentry-organization-home', args=[organization.slug])
+
+        self.login_as(user)
+
+        resp = self.client.get(path)
+
+        assert resp.status_code == 302
+        assert resp['Location'] == 'http://testserver{}'.format(
+            reverse('sentry-auth-link-identity', args=[organization.slug]),
+        )
+
     def test_renders_with_context(self):
         organization = self.create_organization(name='foo', owner=self.user)
         team = self.create_team(organization=organization)

commit 0b077295b264d0e5243f801d1959ab1b7b827867
Author: Stephen Cefali <scefali@sentry.io>
Date:   Tue Aug 27 21:06:39 2019 +0000

    Feat(app-platform) 3rd party initiated installation (#14459)

diff --git a/src/sentry/static/sentry/app/components/modals/sentryAppDetailsModal.jsx b/src/sentry/static/sentry/app/components/modals/sentryAppDetailsModal.jsx
index 39ed969086..c7edeb3fe9 100644
--- a/src/sentry/static/sentry/app/components/modals/sentryAppDetailsModal.jsx
+++ b/src/sentry/static/sentry/app/components/modals/sentryAppDetailsModal.jsx
@@ -42,6 +42,11 @@ export default class SentryAppDetailsModal extends AsyncComponent {
     onInstall: PropTypes.func.isRequired,
     isInstalled: PropTypes.bool.isRequired,
     closeModal: PropTypes.func.isRequired,
+    closeOnInstall: PropTypes.bool.isRequired,
+  };
+
+  static defaultProps = {
+    closeOnInstall: true,
   };
 
   getEndpoints() {
@@ -61,9 +66,10 @@ export default class SentryAppDetailsModal extends AsyncComponent {
   }
 
   onInstall() {
-    const {onInstall, closeModal} = this.props;
+    const {onInstall, closeModal, closeOnInstall} = this.props;
     onInstall();
-    closeModal();
+    // let onInstall handle redirection post install when onCloseInstall is false
+    closeOnInstall && closeModal();
   }
 
   renderPermissions() {
diff --git a/src/sentry/static/sentry/app/routes.jsx b/src/sentry/static/sentry/app/routes.jsx
index 428819d6cc..1d5058084b 100644
--- a/src/sentry/static/sentry/app/routes.jsx
+++ b/src/sentry/static/sentry/app/routes.jsx
@@ -705,6 +705,14 @@ function routes() {
         }
       />
 
+      <Route
+        path="/sentry-apps/:sentryAppSlug/external-install/"
+        componentPromise={() =>
+          import(/* webpackChunkName: "AcceptProjectTransfer" */ 'app/views/sentryAppExternalInstallation')
+        }
+        component={errorHandler(LazyLoad)}
+      />
+
       {EXPERIMENTAL_SPA && (
         <Route path="/auth/login/" component={errorHandler(AuthLayout)}>
           <IndexRoute
diff --git a/src/sentry/static/sentry/app/views/sentryAppExternalInstallation.jsx b/src/sentry/static/sentry/app/views/sentryAppExternalInstallation.jsx
new file mode 100644
index 0000000000..24fcbe7904
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/sentryAppExternalInstallation.jsx
@@ -0,0 +1,276 @@
+import React from 'react';
+import styled from 'react-emotion';
+
+import {t, tct} from 'app/locale';
+import Alert from 'app/components/alert';
+import AsyncView from 'app/views/asyncView';
+import Field from 'app/views/settings/components/forms/field';
+import IndicatorStore from 'app/stores/indicatorStore';
+import NarrowLayout from 'app/components/narrowLayout';
+import SelectControl from 'app/components/forms/selectControl';
+import Avatar from 'app/components/avatar';
+import SentryAppDetailsModal from 'app/components/modals/sentryAppDetailsModal';
+import {installSentryApp} from 'app/actionCreators/sentryAppInstallations';
+import {addQueryParamsToExistingUrl} from 'app/utils/queryString';
+
+export default class SentryAppExternalInstallation extends AsyncView {
+  state = {
+    selectedOrgSlug: null,
+    organization: null,
+    reloading: false,
+  };
+
+  getEndpoints() {
+    return [
+      ['organizations', '/organizations/'],
+      ['sentryApp', `/sentry-apps/${this.sentryAppSlug}/`],
+    ];
+  }
+
+  getTitle() {
+    return t('Choose Installation Organization');
+  }
+
+  get sentryAppSlug() {
+    return this.props.params.sentryAppSlug;
+  }
+
+  get isSingleOrg() {
+    return this.state.organizations.length === 1;
+  }
+
+  get isSentryAppInternal() {
+    const {sentryApp} = this.state;
+    return sentryApp && sentryApp.status === 'internal';
+  }
+
+  get isSentryAppUnavailableForOrg() {
+    const {sentryApp, selectedOrgSlug} = this.state;
+    //if the app is unpublished for a different org
+    return (
+      selectedOrgSlug &&
+      sentryApp.owner.slug !== selectedOrgSlug &&
+      sentryApp.status === 'unpublished'
+    );
+  }
+
+  get disableInstall() {
+    const {reloading, isInstalled} = this.state;
+    return isInstalled || reloading || this.isSentryAppUnavailableForOrg;
+  }
+
+  hasAccess = org => org.access.includes('org:integrations');
+
+  onClose = () => {
+    //if we came from somewhere, go back there. Otherwise, back to the integrations page
+    const {selectedOrgSlug} = this.state;
+    const newUrl = document.referrer || `/settings/${selectedOrgSlug}/integrations/`;
+    window.location.assign(newUrl);
+  };
+
+  onInstall = async () => {
+    const {organization, sentryApp} = this.state;
+    const install = await installSentryApp(this.api, organization.slug, sentryApp);
+    if (sentryApp.redirectUrl) {
+      const queryParams = {
+        installationId: install.uuid,
+        code: install.code,
+        orgSlug: organization.slug,
+      };
+      const redirectUrl = addQueryParamsToExistingUrl(sentryApp.redirectUrl, queryParams);
+      return window.location.assign(redirectUrl);
+    }
+    return this.onClose();
+  };
+
+  onSelectOrg = async orgSlug => {
+    this.setState({selectedOrgSlug: orgSlug, reloading: true});
+
+    try {
+      const [organization, installations] = await Promise.all([
+        this.api.requestPromise(`/organizations/${orgSlug}/`),
+        this.api.requestPromise(`/organizations/${orgSlug}/sentry-app-installations/`),
+      ]);
+      const isInstalled = installations
+        .map(install => install.app.slug)
+        .includes(this.sentryAppSlug);
+      this.setState({organization, isInstalled});
+    } catch (err) {
+      IndicatorStore.addError(
+        t('Failed to retrieve organization or integration details')
+      );
+    }
+    this.setState({reloading: false});
+  };
+
+  onRequestSuccess = ({stateKey, data}) => {
+    //if only one org, we can immediately update our selected org
+    if (stateKey === 'organizations' && data.length === 1) {
+      this.onSelectOrg(data[0].slug);
+    }
+  };
+
+  getOptions() {
+    return this.state.organizations.map(org => [
+      org.slug,
+      <div key={org.slug}>
+        <Avatar organization={org} />
+        <OrgNameHolder>{org.slug}</OrgNameHolder>
+      </div>,
+    ]);
+  }
+
+  renderInternalAppError() {
+    const {sentryApp} = this.state;
+    return (
+      <Alert type="error" icon="icon-circle-exclamation">
+        {tct(
+          'Integration [sentryAppName] is an internal integration. Internal integrations are automatically installed',
+          {
+            sentryAppName: <strong>{sentryApp.name}</strong>,
+          }
+        )}
+      </Alert>
+    );
+  }
+
+  checkAndRenderError() {
+    const {organization, selectedOrgSlug, isInstalled, sentryApp} = this.state;
+    if (selectedOrgSlug && organization && !this.hasAccess(organization)) {
+      return (
+        <Alert type="error" icon="icon-circle-exclamation">
+          <p>
+            {tct(
+              `You do not have permission to install integrations in
+          [organization]. Ask an organization owner or manager to
+          visit this page to finish installing this integration.`,
+              {organization: <strong>{organization.slug}</strong>}
+            )}
+          </p>
+          <InstallLink>{window.location.href}</InstallLink>
+        </Alert>
+      );
+    }
+    if (isInstalled) {
+      return (
+        <Alert type="error" icon="icon-circle-exclamation">
+          {tct('Integration [sentryAppName] already installed for [organization]', {
+            organization: <strong>{organization.name}</strong>,
+            sentryAppName: <strong>{sentryApp.name}</strong>,
+          })}
+        </Alert>
+      );
+    }
+
+    if (this.isSentryAppUnavailableForOrg) {
+      return (
+        <Alert type="error" icon="icon-circle-exclamation">
+          {tct(
+            'Integration [sentryAppName] is an unpublished integration for [otherOrg]. An unpublished integration can only be installed on the organization which created it.',
+            {
+              sentryAppName: <strong>{sentryApp.name}</strong>,
+              otherOrg: <strong>{sentryApp.owner.slug}</strong>,
+            }
+          )}
+        </Alert>
+      );
+    }
+
+    return null;
+  }
+
+  renderMultiOrgView() {
+    const {selectedOrgSlug, sentryApp} = this.state;
+    return (
+      <div>
+        <p>
+          {tct(
+            'Please pick a specific [organization:organization] to install [sentryAppName]',
+            {
+              organization: <strong />,
+              sentryAppName: <strong>{sentryApp.name}</strong>,
+            }
+          )}
+        </p>
+        <Field label={t('Organization')} inline={false} stacked required>
+          {() => (
+            <SelectControl
+              onChange={({value}) => this.onSelectOrg(value)}
+              value={selectedOrgSlug}
+              placeholder={t('Select an organization')}
+              choices={this.getOptions()}
+            />
+          )}
+        </Field>
+      </div>
+    );
+  }
+
+  renderSingleOrgView() {
+    const {organizations, sentryApp} = this.state;
+    //pull the name out of organizations since state.organization won't be loaded initially
+    const organizationName = organizations[0].name;
+    return (
+      <div>
+        <p>
+          {tct('You are installing [sentryAppName] for organization [organization]', {
+            organization: <strong>{organizationName}</strong>,
+            sentryAppName: <strong>{sentryApp.name}</strong>,
+          })}
+        </p>
+      </div>
+    );
+  }
+
+  renderMainContent() {
+    const {organization, sentryApp} = this.state;
+    return (
+      <div>
+        <OrgViewHolder>
+          {this.isSingleOrg ? this.renderSingleOrgView() : this.renderMultiOrgView()}
+        </OrgViewHolder>
+        {this.checkAndRenderError()}
+        {organization && (
+          <SentryAppDetailsModal
+            sentryApp={sentryApp}
+            organization={organization}
+            onInstall={this.onInstall}
+            closeModal={this.onClose}
+            isInstalled={this.disableInstall}
+            closeOnInstall={false}
+          />
+        )}
+      </div>
+    );
+  }
+
+  renderBody() {
+    return (
+      <NarrowLayout>
+        <Content>
+          <h3>{t('Finish integration installation')}</h3>
+          {this.isSentryAppInternal
+            ? this.renderInternalAppError()
+            : this.renderMainContent()}
+        </Content>
+      </NarrowLayout>
+    );
+  }
+}
+
+const InstallLink = styled('pre')`
+  margin-bottom: 0;
+  background: #fbe3e1;
+`;
+
+const OrgNameHolder = styled('span')`
+  margin-left: 5px;
+`;
+
+const Content = styled('div')`
+  margin-bottom: 40px;
+`;
+
+const OrgViewHolder = styled('div')`
+  margin-bottom: 20px;
+`;
diff --git a/tests/js/spec/views/sentryAppExternalInstallation.spec.jsx b/tests/js/spec/views/sentryAppExternalInstallation.spec.jsx
new file mode 100644
index 0000000000..9479840aea
--- /dev/null
+++ b/tests/js/spec/views/sentryAppExternalInstallation.spec.jsx
@@ -0,0 +1,167 @@
+import React from 'react';
+import _ from 'lodash';
+
+import {mount} from 'enzyme';
+
+import SentryAppExternalInstallation from 'app/views/sentryAppExternalInstallation';
+
+describe('SentryAppExternalInstallation', () => {
+  let sentryApp,
+    wrapper,
+    getOrgsMock,
+    getOrgMock,
+    getAppMock,
+    getInstalltionsMock,
+    getFeaturesMock,
+    getMountedComponent,
+    org1,
+    org1Lite,
+    org2,
+    org2Lite;
+  beforeEach(() => {
+    MockApiClient.clearMockResponses();
+    org1 = TestStubs.Organization({
+      slug: 'org1',
+      name: 'Organization 1',
+    });
+
+    org2 = TestStubs.Organization({
+      slug: 'org2',
+      name: 'Organization 2',
+    });
+
+    org1Lite = _.pick(org1, ['slug', 'name', 'id']);
+    org2Lite = _.pick(org2, ['slug', 'name', 'id']);
+
+    sentryApp = TestStubs.SentryApp({
+      owner: org2,
+      status: 'published',
+      redirectUrl: 'https://google.com',
+    });
+    getAppMock = MockApiClient.addMockResponse({
+      url: `/sentry-apps/${sentryApp.slug}/`,
+      body: sentryApp,
+    });
+    getFeaturesMock = MockApiClient.addMockResponse({
+      url: `/sentry-apps/${sentryApp.slug}/features/`,
+      body: [],
+    });
+
+    getMountedComponent = () =>
+      mount(
+        <SentryAppExternalInstallation params={{sentryAppSlug: sentryApp.slug}} />,
+        TestStubs.routerContext()
+      );
+  });
+
+  describe('single organization', () => {
+    beforeEach(() => {
+      getOrgsMock = MockApiClient.addMockResponse({
+        url: '/organizations/',
+        body: [org1Lite],
+      });
+      getOrgMock = MockApiClient.addMockResponse({
+        url: `/organizations/${org1.slug}/`,
+        body: org1,
+      });
+      getInstalltionsMock = MockApiClient.addMockResponse({
+        url: `/organizations/${org1.slug}/sentry-app-installations/`,
+        body: [],
+      });
+    });
+    it('sets the org automatically', async () => {
+      wrapper = getMountedComponent();
+      await tick();
+
+      expect(getAppMock).toHaveBeenCalled();
+      expect(getOrgsMock).toHaveBeenCalled();
+      expect(getOrgMock).toHaveBeenCalled();
+      expect(getInstalltionsMock).toHaveBeenCalled();
+      expect(getFeaturesMock).toHaveBeenCalled();
+      expect(wrapper.state('organization')).toBe(org1);
+      expect(wrapper.find('.Select-multi-value-wrapper')).toHaveLength(0);
+    });
+
+    it('installs and redirects', async () => {
+      const installUrl = `/organizations/${org1.slug}/sentry-app-installations/`;
+      const install = {
+        uuid: 'fake-id',
+        code: 'some-code',
+      };
+      const installMock = MockApiClient.addMockResponse({
+        url: installUrl,
+        method: 'POST',
+        body: install,
+      });
+
+      window.location.assign = jest.fn();
+
+      wrapper = getMountedComponent();
+      await tick();
+      wrapper.update();
+
+      const button = wrapper.find('Button[data-test-id="install"]');
+      button.simulate('click');
+      await tick();
+
+      expect(installMock).toHaveBeenCalledWith(
+        installUrl,
+        expect.objectContaining({
+          data: {slug: sentryApp.slug},
+        })
+      );
+
+      expect(window.location.assign).toHaveBeenCalledWith(
+        `https://google.com/?code=${install.code}&installationId=${
+          install.uuid
+        }&orgSlug=${org1.slug}`
+      );
+      window.location.assign.mockRestore();
+    });
+  });
+  describe('multiple organizations', () => {
+    beforeEach(() => {
+      getOrgsMock = MockApiClient.addMockResponse({
+        url: '/organizations/',
+        body: [org1Lite, org2Lite],
+      });
+    });
+    it('renders org dropdown', async () => {
+      wrapper = getMountedComponent();
+      await tick();
+
+      expect(getAppMock).toHaveBeenCalled();
+      expect(getOrgsMock).toHaveBeenCalled();
+      expect(wrapper.state('organization')).toBeNull();
+      expect(wrapper.find('.Select-multi-value-wrapper')).toHaveLength(1);
+    });
+    it('selecting org from dropdown loads the org through the API', async () => {
+      getOrgMock = MockApiClient.addMockResponse({
+        url: `/organizations/${org2.slug}/`,
+        body: org2,
+      });
+
+      getInstalltionsMock = MockApiClient.addMockResponse({
+        url: `/organizations/${org2.slug}/sentry-app-installations/`,
+        body: [],
+      });
+
+      wrapper = getMountedComponent();
+      await tick();
+      wrapper.update();
+
+      const input = wrapper.find('input');
+      input.simulate('change', {target: {value: org2.slug}});
+      input.simulate('keyDown', {keyCode: 13}); //need to simulate keyDown so onChange is triggered
+
+      await tick();
+      wrapper.update();
+
+      expect(wrapper.state('selectedOrgSlug')).toBe(org2.slug);
+      expect(wrapper.state('organization')).toBe(org2);
+      expect(getOrgMock).toHaveBeenCalled();
+      expect(getInstalltionsMock).toHaveBeenCalled();
+      expect(getFeaturesMock).toHaveBeenCalled();
+    });
+  });
+});

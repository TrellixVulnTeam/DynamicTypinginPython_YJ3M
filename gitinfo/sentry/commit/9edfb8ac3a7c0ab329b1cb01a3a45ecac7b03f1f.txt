commit 9edfb8ac3a7c0ab329b1cb01a3a45ecac7b03f1f
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Thu Aug 23 14:35:13 2018 -0700

    feat(health): Move data transform to `<HealthRequest>` (#9365)
    
    * Adds `getCategory` getter prop to return the category name of a dataset
    * Adds transforms for time and non-time series

diff --git a/src/sentry/static/sentry/app/views/organizationHealth/util/healthRequest.jsx b/src/sentry/static/sentry/app/views/organizationHealth/util/healthRequest.jsx
index 9444300554..877737fdbb 100644
--- a/src/sentry/static/sentry/app/views/organizationHealth/util/healthRequest.jsx
+++ b/src/sentry/static/sentry/app/views/organizationHealth/util/healthRequest.jsx
@@ -12,18 +12,21 @@ import HealthContext from './healthContext';
 class HealthRequestWithParams extends React.Component {
   static propTypes = {
     /**
-     * Health tag (this will use a BASE_URL defined in health actionCreators
+     * API client instance
      */
-    tag: PropTypes.string.isRequired,
+    api: PropTypes.object.isRequired,
 
     organization: SentryTypes.Organization.isRequired,
 
-    api: PropTypes.object,
+    /**
+     * Health tag (this will use a BASE_URL defined in health actionCreators
+     */
+    tag: PropTypes.string.isRequired,
 
     /**
      * List of project ids to query
      */
-    projects: PropTypes.arrayOf(PropTypes.number),
+    projects: PropTypes.arrayOf(PropTypes.string),
 
     /**
      * List of environments to query
@@ -37,6 +40,13 @@ class HealthRequestWithParams extends React.Component {
      */
     period: PropTypes.string,
 
+    /**
+     * Interval to group results in
+     *
+     * e.g. 1d, 1h, 1m, 1s
+     */
+    interval: PropTypes.string,
+
     /**
      * Include data for previous period
      */
@@ -51,12 +61,19 @@ class HealthRequestWithParams extends React.Component {
      * topK value
      */
     topk: PropTypes.number,
+
+    /**
+     * Callback function to process category
+     */
+    getCategory: PropTypes.func,
   };
 
   static defaultProps = {
     period: '7d',
     includePrevious: true,
     timeseries: true,
+    interval: '1d',
+    getCategory: i => i,
   };
 
   constructor(props) {
@@ -85,13 +102,52 @@ class HealthRequestWithParams extends React.Component {
     });
   }
 
+  transformTimeseriesData = () => {
+    let {tag, getCategory} = this.props;
+    let {data} = this.state;
+
+    const categorySet = new Set();
+    const timestampMap = new Map();
+
+    data.forEach(([timestamp, resultsForTimestamp]) => {
+      resultsForTimestamp &&
+        !!resultsForTimestamp.length &&
+        resultsForTimestamp.forEach(({count, [tag]: name}) => {
+          categorySet.add(getCategory(name));
+          timestampMap.set(`${timestamp}-${getCategory(name)}`, count);
+        });
+    });
+
+    return Array.from(categorySet).map(seriesName => {
+      return {
+        seriesName,
+        data: data.map(([timestamp]) => ({
+          name: timestamp * 1000,
+          value: timestampMap.get(`${timestamp}-${seriesName}`) || 0,
+        })),
+      };
+    });
+  };
+
+  transformData = () => {
+    let {timeseries, tag} = this.props;
+    let {data} = this.state;
+    if (!data) return null;
+
+    return timeseries
+      ? this.transformTimeseriesData()
+      : data.map(({[tag]: name, count}) => [name, count]);
+  };
+
   render() {
     let {children} = this.props;
     let {data} = this.state;
+
     return children({
       // Loading if data is null
       loading: data === null,
-      data,
+      data: this.transformData(data),
+      originalData: data,
     });
   }
 }
diff --git a/tests/js/spec/views/organizationHealth/util/healthRequest.spec.jsx b/tests/js/spec/views/organizationHealth/util/healthRequest.spec.jsx
index 0a4dbb830e..540269d4fb 100644
--- a/tests/js/spec/views/organizationHealth/util/healthRequest.spec.jsx
+++ b/tests/js/spec/views/organizationHealth/util/healthRequest.spec.jsx
@@ -6,7 +6,11 @@ import {HealthRequestWithParams} from 'app/views/organizationHealth/util/healthR
 
 jest.mock('app/actionCreators/health', () => {
   return {
-    doHealthRequest: jest.fn(() => Promise.resolve({data: {foo: 'bar'}})),
+    doHealthRequest: jest.fn(() =>
+      Promise.resolve({
+        data: [[new Date(), [{count: 123, release: {slug: 'release-slug'}}]]],
+      })
+    ),
   };
 });
 
@@ -14,75 +18,163 @@ describe('HealthRequest', function() {
   const project = TestStubs.Project();
   const organization = TestStubs.Organization();
   const mock = jest.fn(() => null);
-  const wrapper = mount(
-    <HealthRequestWithParams
-      api={{}}
-      projects={[project.id]}
-      environments={[]}
-      period="24h"
-      organization={organization}
-      tag="release"
-    >
-      {mock}
-    </HealthRequestWithParams>
-  );
-
-  it('makes requests', async function() {
-    expect(mock).toHaveBeenCalledWith({loading: true, data: null});
+  let wrapper;
 
-    expect(mock).toHaveBeenLastCalledWith({
-      loading: false,
-      data: {foo: 'bar'},
+  describe('with props changes', function() {
+    beforeAll(function() {
+      doHealthRequest.mockImplementation(() =>
+        Promise.resolve({
+          data: [[new Date(), [{count: 123, release: 'release-name'}]]],
+        })
+      );
+      wrapper = mount(
+        <HealthRequestWithParams
+          api={{}}
+          projects={[project.id]}
+          environments={[]}
+          period="24h"
+          organization={organization}
+          tag="release"
+        >
+          {mock}
+        </HealthRequestWithParams>
+      );
     });
 
-    expect(doHealthRequest).toHaveBeenCalled();
-  });
+    it('makes requests', async function() {
+      expect(mock).toHaveBeenCalledWith({loading: true, data: null, originalData: null});
 
-  it('makes a new request if projects prop changes', async function() {
-    doHealthRequest.mockClear();
+      expect(mock).toHaveBeenLastCalledWith({
+        loading: false,
+        data: [
+          {
+            seriesName: 'release-name',
+            data: [
+              expect.objectContaining({
+                name: expect.anything(),
+                value: 123,
+              }),
+            ],
+          },
+        ],
+        originalData: [[expect.anything(), expect.anything()]],
+      });
 
-    wrapper.setProps({projects: [123]});
-    expect(doHealthRequest).toHaveBeenCalledWith(
-      expect.anything(),
-      expect.objectContaining({
-        projects: [123],
-      })
-    );
-  });
+      expect(doHealthRequest).toHaveBeenCalled();
+    });
 
-  it('makes a new request if environments prop changes', async function() {
-    doHealthRequest.mockClear();
+    it('makes a new request if projects prop changes', async function() {
+      doHealthRequest.mockClear();
 
-    wrapper.setProps({environments: ['dev']});
-    expect(doHealthRequest).toHaveBeenCalledWith(
-      expect.anything(),
-      expect.objectContaining({
-        environments: ['dev'],
-      })
-    );
-  });
+      wrapper.setProps({projects: ['123']});
+      expect(doHealthRequest).toHaveBeenCalledWith(
+        expect.anything(),
+        expect.objectContaining({
+          projects: ['123'],
+        })
+      );
+    });
+
+    it('makes a new request if environments prop changes', async function() {
+      doHealthRequest.mockClear();
+
+      wrapper.setProps({environments: ['dev']});
+      expect(doHealthRequest).toHaveBeenCalledWith(
+        expect.anything(),
+        expect.objectContaining({
+          environments: ['dev'],
+        })
+      );
+    });
 
-  it('makes a new request if period prop changes', async function() {
-    doHealthRequest.mockClear();
+    it('makes a new request if period prop changes', async function() {
+      doHealthRequest.mockClear();
 
-    wrapper.setProps({period: '7d'});
-    expect(doHealthRequest).toHaveBeenCalledWith(
-      expect.anything(),
-      expect.objectContaining({
-        period: '7d',
+      wrapper.setProps({period: '7d'});
+      expect(doHealthRequest).toHaveBeenCalledWith(
+        expect.anything(),
+        expect.objectContaining({
+          period: '7d',
+        })
+      );
+    });
+
+    it('makes a new request if timeseries prop changes', async function() {
+      doHealthRequest.mockClear();
+
+      wrapper.setProps({timeseries: false});
+      expect(doHealthRequest).toHaveBeenCalledWith(
+        expect.anything(),
+        expect.objectContaining({
+          timeseries: false,
+        })
+      );
+    });
+  });
+
+  it('defines a category name getter', async function() {
+    doHealthRequest.mockImplementation(() =>
+      Promise.resolve({
+        data: [[new Date(), [{count: 123, release: {slug: 'release-slug'}}]]],
       })
     );
+    wrapper = mount(
+      <HealthRequestWithParams
+        api={{}}
+        projects={[project.id]}
+        environments={[]}
+        period="24h"
+        organization={organization}
+        tag="release"
+        getCategory={release => release && release.slug}
+      >
+        {mock}
+      </HealthRequestWithParams>
+    );
+    await tick();
+    wrapper.update();
+    expect(mock).toHaveBeenLastCalledWith({
+      loading: false,
+      data: [
+        {
+          seriesName: 'release-slug',
+          data: [
+            expect.objectContaining({
+              name: expect.anything(),
+              value: 123,
+            }),
+          ],
+        },
+      ],
+      originalData: [[expect.anything(), expect.anything()]],
+    });
   });
 
-  it('makes a new request if timeseries prop changes', async function() {
-    doHealthRequest.mockClear();
-
-    wrapper.setProps({timeseries: false});
-    expect(doHealthRequest).toHaveBeenCalledWith(
-      expect.anything(),
-      expect.objectContaining({
-        timeseries: false,
+  it('transforms data for non-timeseries response', async function() {
+    doHealthRequest.mockImplementation(() =>
+      Promise.resolve({
+        data: [{count: 123, release: 'release-name'}],
       })
     );
+    wrapper = mount(
+      <HealthRequestWithParams
+        api={{}}
+        projects={[project.id]}
+        environments={[]}
+        period="24h"
+        organization={organization}
+        tag="release"
+        timeseries={false}
+      >
+        {mock}
+      </HealthRequestWithParams>
+    );
+    await tick();
+    wrapper.update();
+    expect(mock).toHaveBeenLastCalledWith({
+      loading: false,
+      data: [['release-name', 123]],
+      originalData: [{count: 123, release: 'release-name'}],
+    });
   });
 });

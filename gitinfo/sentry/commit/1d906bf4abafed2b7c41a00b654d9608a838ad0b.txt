commit 1d906bf4abafed2b7c41a00b654d9608a838ad0b
Author: Dan Fuller <dfuller@Dans-MacBook-Pro.local>
Date:   Fri Nov 30 12:06:46 2018 -0800

    fix(api): Fix bug where issues feed doesn't update counts on single issue
    
    Fixes a case we've seen with the issues feed where we have an issue at
    the top of the feed that receives new events but doesn't have its event
    count updated.
    
    This occurs because Paginator doesn't expect that the same row that
    generated a cursor could appear on the next page, but this can happen
    if you're sorting on `Group.last_seen` since it is frequently updated. To
    resolve this, instead of just assuming that we always want to increment
    the offset by one for a prev cursor, we instead compare the cursor value
    to the key value from the result, and only drop the result if they're equal.
    
    Fixes GH-5920

diff --git a/src/sentry/api/paginator.py b/src/sentry/api/paginator.py
index 13d316814a..39da459219 100644
--- a/src/sentry/api/paginator.py
+++ b/src/sentry/api/paginator.py
@@ -125,16 +125,32 @@ class BasePaginator(object):
             hits = None
 
         offset = cursor.offset
+        # The extra amount is needed so we can decide in the ResultCursor if there is
+        # more on the next page.
+        extra = 1
         # this effectively gets us the before row, and the current (after) row
         # every time. Do not offset if the provided cursor value was empty since
         # there is nothing to traverse past.
+        # We need to actually fetch the before row so that we can compare it to the
+        # cursor value. This allows us to handle an edge case where the first row
+        # for a given cursor is the same row that generated the cursor on the
+        # previous page, but we want to display since it has had its its sort value
+        # updated.
         if cursor.is_prev and cursor.value:
-            offset += 1
+            extra += 1
 
-        # The + 1 is needed so we can decide in the ResultCursor if there is
-        # more on the next page.
-        stop = offset + limit + 1
+        stop = offset + limit + extra
         results = list(queryset[offset:stop])
+
+        if cursor.is_prev and cursor.value:
+            # If the first result is equal to the cursor_value then it's safe to filter
+            # it out, since the value hasn't been updated
+            if results and self.get_item_key(results[0], for_prev=True) == cursor.value:
+                results = results[1:]
+            # Otherwise we may have fetched an extra row, just drop it off the end if so.
+            elif len(results) == offset + limit + extra:
+                results = results[:-1]
+
         if cursor.is_prev:
             results.reverse()
 
diff --git a/tests/sentry/api/test_paginator.py b/tests/sentry/api/test_paginator.py
index 229ed62489..bd0bbb41d7 100644
--- a/tests/sentry/api/test_paginator.py
+++ b/tests/sentry/api/test_paginator.py
@@ -216,7 +216,7 @@ class DateTimePaginatorTest(TestCase):
         assert len(result4) == 0, result4
 
     @pytest.mark.skipif(is_mysql(), reason='MySQL does not support above second accuracy')
-    def test_roudning_offset(self):
+    def test_rounding_offset(self):
         joined = timezone.now()
 
         res1 = self.create_user('foo@example.com', date_joined=joined)
@@ -249,6 +249,60 @@ class DateTimePaginatorTest(TestCase):
         result5 = paginator.get_result(limit=10, cursor=result4.prev)
         assert len(result5) == 0, list(result5)
 
+    def test_same_row_updated(self):
+        joined = timezone.now()
+        res1 = self.create_user('foo@example.com', date_joined=joined)
+        queryset = User.objects.all()
+
+        paginator = DateTimePaginator(queryset, '-date_joined')
+        result1 = paginator.get_result(limit=3, cursor=None)
+        assert len(result1) == 1, result1
+        assert result1[0] == res1
+
+        # Prev page should return no results
+        result2 = paginator.get_result(limit=3, cursor=result1.prev)
+        assert len(result2) == 0, result2
+
+        # If the same row has an updated join date then it should
+        # show up on the prev page
+        res1.update(date_joined=joined + timedelta(seconds=1))
+        result3 = paginator.get_result(limit=3, cursor=result1.prev)
+        assert len(result3) == 1, result3
+        assert result3[0] == res1
+
+        # Make sure updates work as expected with extra rows
+        res1.update(date_joined=res1.date_joined + timedelta(seconds=1))
+        res2 = self.create_user(
+            'bar@example.com',
+            date_joined=res1.date_joined + timedelta(seconds=1),
+        )
+        res3 = self.create_user(
+            'baz@example.com',
+            date_joined=res1.date_joined + timedelta(seconds=2),
+        )
+        res4 = self.create_user(
+            'bat@example.com',
+            date_joined=res1.date_joined + timedelta(seconds=3),
+        )
+        result4 = paginator.get_result(limit=1, cursor=result3.prev)
+        assert len(result4) == 1, result4
+        assert result4[0] == res1
+
+        result5 = paginator.get_result(limit=3, cursor=result3.prev)
+        assert len(result5) == 3, result5
+        assert result5[0] == res3
+        assert result5[1] == res2
+        assert result5[2] == res1
+
+        result6 = paginator.get_result(limit=3, cursor=result5.prev)
+        assert len(result6) == 1, result6
+        assert result6[0] == res4
+
+        res4.update(date_joined=res4.date_joined + timedelta(seconds=1))
+        result7 = paginator.get_result(limit=3, cursor=result6.prev)
+        assert len(result7) == 1, result7
+        assert result7[0] == res4
+
 
 def test_reverse_bisect_left():
     assert reverse_bisect_left([], 0) == 0

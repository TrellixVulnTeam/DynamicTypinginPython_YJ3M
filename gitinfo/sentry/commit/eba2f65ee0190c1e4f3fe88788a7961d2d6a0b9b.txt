commit eba2f65ee0190c1e4f3fe88788a7961d2d6a0b9b
Author: Armin Ronacher <armin.ronacher@active-4.com>
Date:   Sat Mar 4 09:06:53 2017 +0100

    Added symbolserver support to cocoa symbolication

diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index fe9f68ff95..949893dfde 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -1112,6 +1112,9 @@ def get_raven_config():
         ],
     }
 
+SYMBOL_SERVER_ENABLED = True
+SYMBOL_SERVER_URL = 'http://127.0.0.1:3000/'
+
 RAVEN_CONFIG = get_raven_config()
 
 # Config options that are explicitly disabled from Django
diff --git a/src/sentry/interfaces/debug_meta.py b/src/sentry/interfaces/debug_meta.py
index 3315f03e14..126b452667 100644
--- a/src/sentry/interfaces/debug_meta.py
+++ b/src/sentry/interfaces/debug_meta.py
@@ -98,6 +98,7 @@ class DebugMeta(Interface):
                 'version_major': sdk_info['version_major'],
                 'version_minor': sdk_info['version_minor'],
                 'version_patchlevel': sdk_info.get('version_patchlevel') or 0,
+                'build': sdk_info.get('build'),
             }
         except KeyError as e:
             raise InterfaceValidationError('Missing value for sdk_info: %s'
diff --git a/src/sentry/lang/native/plugin.py b/src/sentry/lang/native/plugin.py
index a29ae3f9ec..262a8be0fa 100644
--- a/src/sentry/lang/native/plugin.py
+++ b/src/sentry/lang/native/plugin.py
@@ -7,17 +7,21 @@ import time
 import logging
 import posixpath
 
+from django.conf import settings
+
 from symsynd.demangle import demangle_symbol
 from symsynd.heuristics import find_best_instruction
 from symsynd.utils import parse_addr
 
 from sentry.models import Project, EventError
 from sentry.plugins import Plugin2
+from sentry.http import safe_urlopen
 from sentry.lang.native.symbolizer import Symbolizer, SymbolicationFailed, \
     ImageLookup
 from sentry.lang.native.utils import \
     find_apple_crash_report_referenced_images, get_sdk_from_event, \
-    get_sdk_from_apple_system_info, cpu_name_from_data, APPLE_SDK_MAPPING
+    get_sdk_from_apple_system_info, cpu_name_from_data, APPLE_SDK_MAPPING, \
+    rebase_addr
 from sentry.stacktraces import StacktraceProcessor
 from sentry.reprocessing import report_processing_issue
 from sentry.constants import NATIVE_UNKNOWN_STRING
@@ -347,6 +351,21 @@ def preprocess_apple_crash_event(data):
     return data
 
 
+def sdk_info_to_sdk_id(sdk_info):
+    if sdk_info is None:
+        return None
+    rv = '%s_%d.%d.%d' % (
+        sdk_info['sdk_name'],
+        sdk_info['version_major'],
+        sdk_info['version_minor'],
+        sdk_info['version_patchlevel'],
+    )
+    build = sdk_info.get('build')
+    if build is not None:
+        rv = '%s_%s' % (rv, build)
+    return rv
+
+
 class NativeStacktraceProcessor(StacktraceProcessor):
 
     def __init__(self, *args, **kwargs):
@@ -412,7 +431,9 @@ class NativeStacktraceProcessor(StacktraceProcessor):
 
         processable_frame.data = {
             'instruction_addr': instr_addr,
+            'image': img,
             'image_uuid': img['uuid'] if img is not None else None,
+            'symbolserver_match': None,
         }
 
         if img is not None:
@@ -421,8 +442,7 @@ class NativeStacktraceProcessor(StacktraceProcessor):
                 # Because the images can move around, we want to rebase
                 # the address for the cache key to be within the image
                 # the same way as we do it in the symbolizer.
-                (parse_addr(img['image_vmaddr']) +
-                 instr_addr - parse_addr(img['image_addr'])),
+                rebase_addr(instr_addr, img),
                 img['uuid'].lower(),
                 img['cpu_type'],
                 img['cpu_subtype'],
@@ -445,7 +465,43 @@ class NativeStacktraceProcessor(StacktraceProcessor):
         # The symbolizer gets a reference to the debug meta's images so
         # when it resolves the missing vmaddrs it changes them in the data
         # dict.
-        return self.sym.resolve_missing_vmaddrs()
+        data = self.sym.resolve_missing_vmaddrs()
+
+        if settings.SYMBOL_SERVER_ENABLED:
+            self.fetch_system_symbols(processing_task)
+
+        return data
+
+    def fetch_system_symbols(self, processing_task):
+        to_lookup = []
+        pf_list = []
+        for pf in processing_task.iter_processable_frames(self):
+            img = pf.data['image']
+            if pf.cache_value is not None or img is None or \
+               self.sym.is_frame_from_app_bundle(pf.frame, img):
+                continue
+            to_lookup.append({
+                'object_uuid': img['uuid'],
+                'object_name': img['name'],
+                'addr': '0x%x' % rebase_addr(pf.data['instruction_addr'], img)
+            })
+            pf_list.append(pf)
+
+        if not to_lookup:
+            return
+
+        symbol_query = {
+            'sdk_id': sdk_info_to_sdk_id(self.sdk_info),
+            'cpu_name': self.sym.cpu_name,
+            'symbols': to_lookup,
+        }
+        rv = safe_urlopen('%s/lookup' % settings.SYMBOL_SERVER_URL.rstrip('/'),
+                          method='POST', json=symbol_query)
+        if rv.status_code == 200:
+            for symrv, pf in zip(rv.json()['symbols'], pf_list):
+                if symrv is None:
+                    continue
+                pf.data['symbolserver_match'] = symrv
 
     def process_frame(self, processable_frame, processing_task):
         frame = processable_frame.frame
@@ -465,7 +521,9 @@ class NativeStacktraceProcessor(StacktraceProcessor):
             raw_frame['in_app'] = in_app
             try:
                 symbolicated_frames = self.sym.symbolize_frame(
-                    sym_input_frame, self.sdk_info, symbolize_inlined=True)
+                    sym_input_frame, self.sdk_info,
+                    symbolserver_match=processable_frame.data['symbolserver_match'],
+                    symbolize_inlined=True)
                 if not symbolicated_frames:
                     return None, [raw_frame], []
             except SymbolicationFailed as e:
diff --git a/src/sentry/lang/native/symbolizer.py b/src/sentry/lang/native/symbolizer.py
index 127b884be4..1dd4b52c90 100644
--- a/src/sentry/lang/native/symbolizer.py
+++ b/src/sentry/lang/native/symbolizer.py
@@ -9,8 +9,6 @@ from symsynd.report import ReportSymbolizer
 from symsynd.macho.arch import get_cpu_name, get_macho_vmaddr
 from symsynd.utils import parse_addr
 
-from django.core.cache import cache
-
 from sentry.lang.native.dsymcache import dsymcache
 from sentry.utils.safe import trim
 from sentry.utils.compat import implements_to_string
@@ -236,7 +234,7 @@ class Symbolizer(object):
             return obj_name
         return img['name']
 
-    def _is_frame_from_app_bundle(self, frame, img):
+    def is_frame_from_app_bundle(self, frame, img):
         fn = self._get_frame_package(frame, img)
         if not (fn.startswith(APP_BUNDLE_PATHS) or
                 (SIM_PATH in fn and SIM_APP_PATH in fn)):
@@ -259,7 +257,7 @@ class Symbolizer(object):
         """Given a frame derives the value of `in_app` by discarding the
         original value of the frame.
         """
-        if not self._is_frame_from_app_bundle(frame, img):
+        if not self.is_frame_from_app_bundle(frame, img):
             return False
         return not self._is_app_bundled_framework(frame, img)
 
@@ -267,7 +265,7 @@ class Symbolizer(object):
         """Checks if this is a dsym that is optional."""
         # Frames that are not in the app are not considered optional.  In
         # theory we should never reach this anyways.
-        if not self._is_frame_from_app_bundle(frame, img):
+        if not self.is_frame_from_app_bundle(frame, img):
             return False
 
         # If we're dealing with an app bundled framework that is also
@@ -326,48 +324,30 @@ class Symbolizer(object):
         return self._process_frame(rv, img)
 
     def symbolize_system_frame(self, frame, img, sdk_info,
-                               symbolize_inlined=False):
+                               symbolize_inlined=False,
+                               symbolserver_match=None):
         """Symbolizes a frame with system symbols only."""
-        # This is most likely a good enough cache match even though we are
-        # ignoring the image here since we cache by instruction address.
-        #
-        # In some cases old clients might not send an sdk_info with it
-        # in which case the caching won't work.
-        if sdk_info is not None:
-            cache_key = 'ssym:%s:%s:%s:%s:%s:%s:%s' % (
-                frame['instruction_addr'],
-                get_cpu_name(img['cpu_type'], img['cpu_subtype']),
-                sdk_info['sdk_name'],
-                sdk_info['dsym_type'],
-                sdk_info['version_major'],
-                sdk_info['version_minor'],
-                sdk_info['version_patchlevel'],
-            )
-            symbol = cache.get(cache_key)
+        if symbolserver_match is not None:
+            rv = self._process_frame(dict(frame,
+                symbol_name=symbolserver_match['symbol'], filename=None,
+                line=0, column=0,
+                object_name=symbolserver_match['object_name']), img)
         else:
-            cache_key = None
-            symbol = None
-
-        if symbol is None:
             symbol = find_system_symbol(
                 img, frame['instruction_addr'], sdk_info, self.cpu_name)
-
-        if symbol is None:
-            # Simulator frames cannot be symbolicated
-            if self._is_simulator_frame(frame, img):
-                type = EventError.NATIVE_SIMULATOR_FRAME
-            else:
-                type = EventError.NATIVE_MISSING_SYSTEM_DSYM
-            raise SymbolicationFailed(
-                type=type,
-                image=img
-            )
-        elif cache_key is not None:
-            cache.set(cache_key, symbol, 3600)
-
-        rv = self._process_frame(dict(frame,
-            symbol_name=symbol, filename=None, line=0, column=0,
-            object_name=img['name']), img)
+            if symbol is None:
+                # Simulator frames cannot be symbolicated
+                if self._is_simulator_frame(frame, img):
+                    type = EventError.NATIVE_SIMULATOR_FRAME
+                else:
+                    type = EventError.NATIVE_MISSING_SYSTEM_DSYM
+                raise SymbolicationFailed(
+                    type=type,
+                    image=img
+                )
+            rv = self._process_frame(dict(frame,
+                symbol_name=symbol, filename=None, line=0, column=0,
+                object_name=img['name']), img)
 
         # We actually do not support inline symbolication for system
         # frames, so we just only ever return a single frame here.  Maybe
@@ -376,7 +356,17 @@ class Symbolizer(object):
             return [rv]
         return rv
 
-    def symbolize_frame(self, frame, sdk_info=None, symbolize_inlined=False):
+    def symbolize_symbolserver_match(self, frame, img, match,
+                                     symbolize_inlined=False):
+        rv = self._process_frame(dict(frame,
+            symbol_name=match['symbol'], filename=None, line=0, column=0,
+            object_name=match['object_name']), img)
+        if symbolize_inlined:
+            return [rv]
+        return rv
+
+    def symbolize_frame(self, frame, sdk_info=None, symbolserver_match=None,
+                        symbolize_inlined=False):
         # If we do not have a CPU name we fail.  We currently only support
         # a single cpu architecture.
         if self.cpu_name is None:
@@ -394,9 +384,10 @@ class Symbolizer(object):
         # If we are dealing with a frame that is not bundled with the app
         # we look at system symbols.  If that fails, we go to looking for
         # app symbols explicitly.
-        if not self._is_frame_from_app_bundle(frame, img):
+        if not self.is_frame_from_app_bundle(frame, img):
             return self.symbolize_system_frame(frame, img, sdk_info,
-                                               symbolize_inlined)
+                                               symbolize_inlined,
+                                               symbolserver_match)
 
         return self.symbolize_app_frame(frame, img, symbolize_inlined)
 
diff --git a/src/sentry/lang/native/utils.py b/src/sentry/lang/native/utils.py
index 9382399403..10cbf16448 100644
--- a/src/sentry/lang/native/utils.py
+++ b/src/sentry/lang/native/utils.py
@@ -4,6 +4,7 @@ import six
 import logging
 
 from symsynd.macho.arch import get_cpu_name
+from symsynd.utils import parse_addr
 
 from sentry.interfaces.contexts import DeviceContextType
 
@@ -105,6 +106,7 @@ def get_sdk_from_os(data):
         'version_major': system_version[0],
         'version_minor': system_version[1],
         'version_patchlevel': system_version[2],
+        'build': data.get('build'),
     }
 
 
@@ -152,3 +154,8 @@ def cpu_name_from_data(data):
             break
 
     return unique_cpu_name
+
+
+def rebase_addr(instr_addr, img):
+    return parse_addr(img['image_vmaddr']) + \
+        parse_addr(instr_addr) - parse_addr(img['image_addr'])

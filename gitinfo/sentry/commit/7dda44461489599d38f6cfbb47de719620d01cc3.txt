commit 7dda44461489599d38f6cfbb47de719620d01cc3
Author: Jan Michael Auer <account@jauer.org>
Date:   Tue Jan 2 09:26:57 2018 +0100

    feat(minidump): Allow to pass event data in minidump request (#6844)
    
    * feat(minidump): Allow to pass event data in minidump request
    
    * fix(minidump): Map Breakpad's CPU family names

diff --git a/requirements-base.txt b/requirements-base.txt
index 49fac9f377..30cb2480e3 100644
--- a/requirements-base.txt
+++ b/requirements-base.txt
@@ -37,6 +37,7 @@ python-dateutil>=2.0.0,<3.0.0
 python-memcached>=1.53,<2.0.0
 python-openid>=2.2
 PyYAML>=3.11,<3.12
+querystring_parser>=1.2.3,<2.0.0
 raven>=5.29.0,<6.0.0
 redis>=2.10.3,<2.10.6
 requests[security]>=2.18.4,<2.19.0
diff --git a/src/sentry/coreapi.py b/src/sentry/coreapi.py
index abf29a129e..38eb59e81c 100644
--- a/src/sentry/coreapi.py
+++ b/src/sentry/coreapi.py
@@ -27,7 +27,6 @@ from sentry import filters
 from sentry.cache import default_cache
 from sentry.interfaces.csp import Csp
 from sentry.event_manager import EventManager
-from sentry.lang.native.utils import merge_minidump_event
 from sentry.models import ProjectKey
 from sentry.tasks.store import preprocess_event, \
     preprocess_event_from_reprocessing
@@ -382,50 +381,6 @@ class MinidumpApiHelper(ClientApiHelper):
         auth.client = 'sentry-minidump'
         return auth
 
-    def validate_data(self, data):
-        try:
-            release = data.pop('release')
-        except KeyError:
-            release = None
-
-        # Minidump request payloads do not have the same structure as
-        # usual events from other SDKs. Most importantly, all parameters
-        # passed in the POST body are only "extra" information. The
-        # actual information is in the "upload_file_minidump" field.
-
-        # At this point, we only extract the bare minimum information
-        # needed to continue processing. If all validations pass, the
-        # event will be inserted into the database, at which point we
-        # can process the minidump and extract a little more information.
-
-        validated = {
-            'platform': 'native',
-            'extra': data,
-            'errors': [],
-            'sentry.interfaces.User': {
-                'ip_address': self.context.ip_address,
-            },
-        }
-
-        # Copy/pasted from above in ClientApiHelper.validate_data
-        if release:
-            release = six.text_type(release)
-
-        return validated
-
-    def insert_data_to_database(self, data, start_time=None, from_reprocessing=False):
-        # Seems like the event is valid and we can do some more expensive
-        # work on the minidump. We process the minidump to extract some more
-        # information to populate the initial callstacks and exception
-        # information.
-        minidump = data['extra'].pop('upload_file_minidump')
-        merge_minidump_event(data, minidump.temporary_file_path())
-
-        # Continue with persisting the event in the usual manner and
-        # schedule default preprocessing tasks
-        super(MinidumpApiHelper, self).insert_data_to_database(
-            data, start_time, from_reprocessing)
-
 
 class CspApiHelper(ClientApiHelper):
     def origin_from_request(self, request):
diff --git a/src/sentry/lang/native/utils.py b/src/sentry/lang/native/utils.py
index 06d132a387..b5b33ee9d2 100644
--- a/src/sentry/lang/native/utils.py
+++ b/src/sentry/lang/native/utils.py
@@ -7,7 +7,6 @@ import logging
 from collections import namedtuple
 from symbolic import parse_addr, arch_from_macho, arch_is_known, ProcessState
 
-from sentry.constants import LOG_LEVELS_MAP
 from sentry.interfaces.contexts import DeviceContextType
 
 logger = logging.getLogger(__name__)
@@ -27,6 +26,11 @@ MINIDUMP_OS_TYPES = {
     'Mac OS X': 'macOS',
 }
 
+# Mapping of well-known minidump CPU families to our internal names
+MINIDUMP_CPU_FAMILIES = {
+    'amd64': 'x86_64',
+}
+
 AppInfo = namedtuple('AppInfo', ['id', 'version', 'build', 'name'])
 
 
@@ -155,23 +159,21 @@ def sdk_info_to_sdk_id(sdk_info):
 def merge_minidump_event(data, minidump_path):
     state = ProcessState.from_minidump(minidump_path)
 
-    data['level'] = LOG_LEVELS_MAP['fatal'] if state.crashed else LOG_LEVELS_MAP['info']
+    data['level'] = 'fatal' if state.crashed else 'info'
     data['message'] = 'Assertion Error: %s' % state.assertion if state.assertion \
         else 'Fatal Error: %s' % state.crash_reason
 
     if state.timestamp:
         data['timestamp'] = float(state.timestamp)
 
-    # Extract as much system information as we can. TODO: We should create
-    # a custom context and implement a specific minidump view in the event
-    # UI.
+    # Extract as much context information as we can.
     info = state.system_info
     context = data.setdefault('contexts', {})
     os = context.setdefault('os', {})
     device = context.setdefault('device', {})
     os['type'] = 'os'  # Required by "get_sdk_from_event"
     os['name'] = MINIDUMP_OS_TYPES.get(info.os_name, info.os_name)
-    device['arch'] = info.cpu_family
+    device['arch'] = MINIDUMP_CPU_FAMILIES.get(info.cpu_family, info.cpu_family)
 
     # Breakpad reports the version and build number always in one string,
     # but a version number is guaranteed even on certain linux distros.
@@ -186,7 +188,7 @@ def merge_minidump_event(data, minidump_path):
     # resort to stack scanning which yields low-quality results. If
     # the user provides us with debug symbols, we could reprocess this
     # minidump and add improved stacktraces later.
-    threads = [{
+    data['threads'] = [{
         'id': thread.thread_id,
         'crashed': False,
         'stacktrace': {
@@ -196,14 +198,13 @@ def merge_minidump_event(data, minidump_path):
             } for frame in thread.frames()],
         },
     } for thread in state.threads()]
-    data.setdefault('threads', {})['values'] = threads
 
     # Mark the crashed thread and add its stacktrace to the exception
-    crashed_thread = threads[state.requesting_thread]
+    crashed_thread = data['threads'][state.requesting_thread]
     crashed_thread['crashed'] = True
 
     # Extract the crash reason and infos
-    exception = {
+    data['exception'] = {
         'value': data['message'],
         'thread_id': crashed_thread['id'],
         'type': state.crash_reason,
@@ -211,10 +212,6 @@ def merge_minidump_event(data, minidump_path):
         'stacktrace': crashed_thread.pop('stacktrace'),
     }
 
-    data.setdefault('sentry.interfaces.Exception', {}) \
-        .setdefault('values', []) \
-        .append(exception)
-
     # Extract referenced (not all loaded) images
     images = [{
         'type': 'apple',  # Required by interface
diff --git a/src/sentry/web/api.py b/src/sentry/web/api.py
index 9dd89b2ed7..1f1e9b2c9b 100644
--- a/src/sentry/web/api.py
+++ b/src/sentry/web/api.py
@@ -17,6 +17,7 @@ from django.views.decorators.cache import never_cache, cache_control
 from django.views.decorators.csrf import csrf_exempt
 from django.views.generic.base import View as BaseView
 from functools import wraps
+from querystring_parser import parser
 from raven.contrib.django.models import client as Raven
 
 from sentry import quotas, tsdb
@@ -25,6 +26,7 @@ from sentry.coreapi import (
     MinidumpApiHelper,
 )
 from sentry.interfaces import schemas
+from sentry.lang.native.utils import merge_minidump_event
 from sentry.models import Project, OrganizationOption, Organization
 from sentry.signals import (
     event_accepted, event_dropped, event_filtered, event_received)
@@ -563,12 +565,28 @@ class MinidumpView(StoreView):
         )
 
     def post(self, request, **kwargs):
+        # Minidump request payloads do not have the same structure as
+        # usual events from other SDKs. Most notably, the event needs
+        # to be transfered in the `sentry` form field. All other form
+        # fields are assumed "extra" information. The only exception
+        # to this is `upload_file_minidump`, which contains the minidump.
+        extra = parser.parse(request.POST.urlencode())
+        data = extra.pop('sentry', {})
+        extra.update(data.get('extra', {}))
+        data['extra'] = extra
+        data['platform'] = 'native'
+
+        # At this point, we only extract the bare minimum information
+        # needed to continue processing. This requires to process the
+        # minidump without symbols and CFI to obtain an initial stack
+        # trace (most likely via stack scanning). If all validations
+        # pass, the event will be inserted into the database.
         try:
-            data = request.POST
-            data['upload_file_minidump'] = request.FILES['upload_file_minidump']
+            minidump = request.FILES['upload_file_minidump']
         except KeyError:
             raise APIError('Missing minidump upload')
 
+        merge_minidump_event(data, minidump.temporary_file_path())
         response_or_event_id = self.process(request, data=data, **kwargs)
         if isinstance(response_or_event_id, HttpResponse):
             return response_or_event_id

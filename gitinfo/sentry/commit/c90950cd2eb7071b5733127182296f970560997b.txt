commit c90950cd2eb7071b5733127182296f970560997b
Author: Alex Hofsteede <alex@hofsteede.com>
Date:   Thu Jan 18 15:42:06 2018 +1300

    fix: sort ANY tag searches last. (#6972)
    
    * fix: sort ANY tag searches last.
    
    The existing code did not appear to do what it was supposed to, which is
    to put {'tag': ANY} filters at the end of the list.
    
    Also add test.

diff --git a/src/sentry/tagstore/legacy/backend.py b/src/sentry/tagstore/legacy/backend.py
index c01fbad7e5..1231754aa5 100644
--- a/src/sentry/tagstore/legacy/backend.py
+++ b/src/sentry/tagstore/legacy/backend.py
@@ -528,14 +528,14 @@ class LegacyTagStorage(TagStorage):
             key='sentry:user',
         ).order_by('-last_seen')[:limit])
 
-    def get_group_ids_for_search_filter(self, project_id, environment_id, tags):
+    def get_group_ids_for_search_filter(self, project_id, environment_id, tags, limit=1000):
         from sentry.search.base import ANY, EMPTY
         # Django doesnt support union, so we limit results and try to find
         # reasonable matches
 
         # ANY matches should come last since they're the least specific and
         # will provide the largest range of matches
-        tag_lookups = sorted(six.iteritems(tags), key=lambda x: x != ANY)
+        tag_lookups = sorted(six.iteritems(tags), key=lambda (k, v): v == ANY)
 
         # get initial matches to start the filter
         matches = None
@@ -565,7 +565,7 @@ class LegacyTagStorage(TagStorage):
                 # restrict matches to only the most recently seen issues
                 base_qs = base_qs.order_by('-last_seen')
 
-            matches = list(base_qs.values_list('group_id', flat=True)[:1000])
+            matches = list(base_qs.values_list('group_id', flat=True)[:limit])
 
             if not matches:
                 return None
diff --git a/src/sentry/tagstore/v2/backend.py b/src/sentry/tagstore/v2/backend.py
index 7adb8c3635..3f79ffd7c7 100644
--- a/src/sentry/tagstore/v2/backend.py
+++ b/src/sentry/tagstore/v2/backend.py
@@ -643,14 +643,14 @@ class V2TagStorage(TagStorage):
             _key__key='sentry:user',
         ).order_by('-last_seen')[:limit])
 
-    def get_group_ids_for_search_filter(self, project_id, environment_id, tags):
+    def get_group_ids_for_search_filter(self, project_id, environment_id, tags, limit=1000):
         from sentry.search.base import ANY, EMPTY
         # Django doesnt support union, so we limit results and try to find
         # reasonable matches
 
         # ANY matches should come last since they're the least specific and
         # will provide the largest range of matches
-        tag_lookups = sorted(six.iteritems(tags), key=lambda x: x != ANY)
+        tag_lookups = sorted(six.iteritems(tags), key=lambda (k, v): v == ANY)
 
         # get initial matches to start the filter
         matches = None
@@ -682,7 +682,7 @@ class V2TagStorage(TagStorage):
                 # restrict matches to only the most recently seen issues
                 base_qs = base_qs.order_by('-last_seen')
 
-            matches = list(base_qs.values_list('group_id', flat=True)[:1000])
+            matches = list(base_qs.values_list('group_id', flat=True)[:limit])
 
             if not matches:
                 return None
diff --git a/tests/sentry/tagstore/v2/test_backend.py b/tests/sentry/tagstore/v2/test_backend.py
index f17c73da5b..2b4a7fb73d 100644
--- a/tests/sentry/tagstore/v2/test_backend.py
+++ b/tests/sentry/tagstore/v2/test_backend.py
@@ -2,8 +2,10 @@ from __future__ import absolute_import
 
 import pytest
 
+from collections import OrderedDict
 from datetime import datetime
 
+from sentry.search.base import ANY
 from sentry.testutils import TestCase
 from sentry.tagstore import TagKeyStatus
 from sentry.tagstore.v2.backend import V2TagStorage
@@ -628,6 +630,35 @@ class TagStorage(TestCase):
         assert self.ts.get_group_ids_for_search_filter(
             self.proj1.id, self.proj1env1.id, tags) == [self.proj1group1.id]
 
+    def test_get_group_ids_for_search_filter_predicate_order(self):
+        """
+            Since each tag-matching filter returns limited results, and each
+            filter returns a subset of the previous filter's matches, we
+            attempt to match more selective predicates first.
+
+            This tests that we filter by a more selective "divides == even"
+            predicate before filtering by an ANY predicate and therefore return
+            all matching groups instead of the partial set that would be returned
+            if we had filtered and limited using the ANY predicate first.
+        """
+        for i in range(3):
+            self.ts.get_or_create_group_tag_value(
+                self.proj1.id, i, self.proj1env1.id,
+                'foo', 'bar'
+            )
+
+            self.ts.get_or_create_group_tag_value(
+                self.proj1.id, i, self.proj1env1.id,
+                'divides', 'even' if i % 2 == 0 else 'odd'
+            )
+
+        assert len(self.ts.get_group_ids_for_search_filter(
+            self.proj1.id,
+            self.proj1env1.id,
+            OrderedDict([('foo', ANY), ('divides', 'even')]),
+            limit=2
+        )) == 2
+
     def test_update_group_for_events(self):
         v1, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k1', 'v1')
         v2, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k2', 'v2')

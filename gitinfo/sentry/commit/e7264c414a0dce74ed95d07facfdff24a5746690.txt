commit e7264c414a0dce74ed95d07facfdff24a5746690
Author: Markus Unterwaditzer <markus@unterwaditzer.net>
Date:   Wed Apr 22 23:56:22 2020 +0200

    feat: reverse_proxy binds 8000 on-demand with devserver, lazy image pulls, and stop instead of destroy on down (#18362)

diff --git a/.travis.yml b/.travis.yml
index 5cf167b54d..631393f298 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -228,7 +228,7 @@ matrix:
         - redis-server
       install:
         - python setup.py install_egg_info
-        - pip install -U -e .
+        - pip install -U -e ".[dev]"
       before_script:
         - psql -c 'create database sentry;' -U postgres
 
diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index 256dec0df9..c54d0b9090 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -1479,6 +1479,10 @@ SENTRY_DEVSERVICES = {
         "ports": {"80/tcp": SENTRY_REVERSE_PROXY_PORT},
         "volumes": {REVERSE_PROXY_CONFIG: {"bind": "/etc/nginx/nginx.conf"}},
         "only_if": lambda settings, options: settings.SENTRY_USE_RELAY,
+        # This directive tells `devservices up` that the reverse_proxy is not to be
+        # started up, only pulled and made available for `devserver` which will start
+        # it with `devservices attach --is-devserver reverse_proxy`.
+        "with_devserver": True,
     },
     "relay": {
         "image": "us.gcr.io/sentryio/relay:latest",
diff --git a/src/sentry/runner/commands/devserver.py b/src/sentry/runner/commands/devserver.py
index 1c99f990d3..60364a269d 100644
--- a/src/sentry/runner/commands/devserver.py
+++ b/src/sentry/runner/commands/devserver.py
@@ -19,6 +19,7 @@ _DEFAULT_DAEMONS = {
     "ingest": ["sentry", "run", "ingest-consumer", "--all-consumer-types"],
     "server": ["sentry", "run", "web"],
     "storybook": ["./bin/yarn", "storybook"],
+    "reverse_proxy": ["sentry", "devservices", "attach", "--is-devserver", "reverse_proxy"],
 }
 
 
@@ -207,7 +208,7 @@ def devserver(
             daemons += [_get_daemon("post-process-forwarder")]
 
     if settings.SENTRY_USE_RELAY:
-        daemons += [_get_daemon("ingest")]
+        daemons += [_get_daemon("ingest"), _get_daemon("reverse_proxy")]
 
     if needs_https and has_https:
         https_port = six.text_type(parsed_url.port)
diff --git a/src/sentry/runner/commands/devservices.py b/src/sentry/runner/commands/devservices.py
index 9fde621c5a..c5dbe5a127 100644
--- a/src/sentry/runner/commands/devservices.py
+++ b/src/sentry/runner/commands/devservices.py
@@ -1,15 +1,17 @@
 from __future__ import absolute_import, print_function
 
+import atexit
+import signal
 import os
 import click
 from six import text_type
 from itertools import chain
+
 from sentry.utils.compat import map
+import docker
 
 
 def get_docker_client():
-    import docker
-
     client = docker.from_env()
     try:
         client.ping()
@@ -19,8 +21,6 @@ def get_docker_client():
 
 
 def get_or_create(client, thing, name):
-    import docker
-
     try:
         return getattr(client, thing + "s").get(name)
     except docker.errors.NotFound:
@@ -48,11 +48,58 @@ def devservices():
     """
 
 
+@devservices.command()
+@click.option("--project", default="sentry")
+@click.option("--is-devserver", is_flag=True, default=False)
+@click.argument("service", nargs=1)
+def attach(project, is_devserver, service):
+    """
+    Run a single devservice in foreground, as opposed to `up` which runs all of
+    them in the background.
+
+    Accepts a single argument, the name of the service to spawn. The service
+    will run with output printed to your terminal, and the ability to kill it
+    with ^C. This is used in devserver.
+
+    Note: This does not update images, you will have to use `devservices up`
+    for that.
+    """
+
+    os.environ["SENTRY_SKIP_BACKEND_VALIDATION"] = "1"
+
+    from sentry.runner import configure
+
+    configure()
+
+    client = get_docker_client()
+    containers = _prepare_containers(project)
+    container = _start_service(
+        client, service, containers, project, devserver_override=is_devserver
+    )
+
+    def exit_handler(*_):
+        click.echo("Shutting down {}".format(service))
+        try:
+            container.stop()
+        except KeyboardInterrupt:
+            pass
+
+    atexit.register(exit_handler)
+    signal.signal(signal.SIGINT, exit_handler)
+    signal.signal(signal.SIGTERM, exit_handler)
+
+    for line in container.logs(stream=True):
+        click.echo(line, nl=False)
+
+
 @devservices.command()
 @click.option("--project", default="sentry")
 @click.option("--exclude", multiple=True, help="Services to ignore and not run.")
 def up(project, exclude):
-    "Run/update dependent services."
+    """
+    Run/update dependent services.
+    """
+
     os.environ["SENTRY_SKIP_BACKEND_VALIDATION"] = "1"
 
     exclude = set(chain.from_iterable(x.split(",") for x in exclude))
@@ -62,20 +109,31 @@ def up(project, exclude):
     configure()
 
     from django.conf import settings
-    from sentry import options as sentry_options
-
-    import docker
 
     client = get_docker_client()
 
     get_or_create(client, "network", project)
 
-    containers = {}
+    containers = _prepare_containers(project)
+
     for name, options in settings.SENTRY_DEVSERVICES.items():
         if name in exclude:
             continue
-        options = options.copy()
 
+        if name not in containers:
+            continue
+
+        _start_service(client, name, containers, project)
+
+
+def _prepare_containers(project):
+    from django.conf import settings
+    from sentry import options as sentry_options
+
+    containers = {}
+
+    for name, options in settings.SENTRY_DEVSERVICES.items():
+        options = options.copy()
         test_fn = options.pop("only_if", None)
         if test_fn and not test_fn(settings, sentry_options):
             click.secho("! Skipping {} due to only_if condition".format(name), err=True, fg="cyan")
@@ -90,40 +148,90 @@ def up(project, exclude):
         options["ports"] = ensure_interface(options["ports"])
         containers[name] = options
 
-    pulled = set()
-    for name, options in containers.items():
-        # HACK(mattrobenolt): special handle snuba backend because it needs to
-        # handle different values based on the eventstream backend
-        # For snuba, we can't run the full suite of devserver, but can only
-        # run the api.
-        if name == "snuba" and "snuba" in settings.SENTRY_EVENTSTREAM:
-            options["environment"].pop("DEFAULT_BROKERS", None)
-            options["command"] = ["devserver", "--no-workers"]
-
-        for key, value in options["environment"].items():
-            options["environment"][key] = value.format(containers=containers)
-        if options.pop("pull", False) and options["image"] not in pulled:
-            click.secho("> Pulling image '%s'" % options["image"], err=True, fg="green")
-            client.images.pull(options["image"])
-            pulled.add(options["image"])
-        for mount in options.get("volumes", {}).keys():
-            if "/" not in mount:
-                get_or_create(client, "volume", project + "_" + mount)
-                options["volumes"][project + "_" + mount] = options["volumes"].pop(mount)
+    return containers
+
+
+def _start_service(client, name, containers, project, devserver_override=False):
+    from django.conf import settings
+
+    options = containers[name]
+
+    # HACK(mattrobenolt): special handle snuba backend because it needs to
+    # handle different values based on the eventstream backend
+    # For snuba, we can't run the full suite of devserver, but can only
+    # run the api.
+    if name == "snuba" and "snuba" in settings.SENTRY_EVENTSTREAM:
+        options["environment"].pop("DEFAULT_BROKERS", None)
+        options["command"] = ["devserver", "--no-workers"]
+
+    for key, value in options["environment"].items():
+        options["environment"][key] = value.format(containers=containers)
+
+    pull = options.pop("pull", False)
+    if pull:
+        click.secho("> Pulling image '%s'" % options["image"], err=True, fg="green")
+        client.images.pull(options["image"])
+    else:
+        # We want make sure to pull everything on the first time,
+        # (the image doesn't exist), regardless of pull=True.
         try:
-            container = client.containers.get(options["name"])
+            client.images.get(options["image"])
         except docker.errors.NotFound:
-            pass
-        else:
-            container.stop()
-            container.remove()
-        listening = ""
-        if options["ports"]:
-            listening = " (listening: %s)" % ", ".join(map(text_type, options["ports"].values()))
+            click.secho("> Pulling image '%s'" % options["image"], err=True, fg="green")
+            client.images.pull(options["image"])
+
+    for mount in options.get("volumes", {}).keys():
+        if "/" not in mount:
+            get_or_create(client, "volume", project + "_" + mount)
+            options["volumes"][project + "_" + mount] = options["volumes"].pop(mount)
+
+    listening = ""
+    if options["ports"]:
+        listening = " (listening: %s)" % ", ".join(map(text_type, options["ports"].values()))
+
+    # If a service is associated with the devserver, then do not run the created container.
+    # This was mainly added since it was not desirable for reverse_proxy to occupy port 8000 on the
+    # first "devservices up".
+    # See https://github.com/getsentry/sentry/pull/18362#issuecomment-616785458
+    with_devserver = options.pop("with_devserver", False)
+
+    try:
+        container = client.containers.get(options["name"])
+    except docker.errors.NotFound:
+        pass
+    else:
+        if not pull and not with_devserver:
+            # devservices which are marked with pull True will need their containers
+            # to be recreated with the freshly pulled image.
+            click.secho(
+                "> Starting existing '%s' container%s" % (options["name"], listening),
+                err=True,
+                fg="yellow",
+            )
+            container.start()
+            return container
+
+        container.stop()
+        container.remove()
+
+    click.secho("> Creating '%s' container%s" % (options["name"], listening), err=True, fg="yellow")
+    container = client.containers.create(**options)
+
+    # Two things call _start_service.
+    # devservices up, and devservices attach.
+    # Containers that should be started on-demand with devserver, should ONLY be started via the latter.
+    # So devserver calls devservices attach --is-devserver reverse_proxy, which sets devserver_override.
+    # This additional logic is needed because devservices up also makes sure the necessary images are downloaded.
+    if with_devserver and not devserver_override:
         click.secho(
-            "> Creating '%s' container%s" % (options["name"], listening), err=True, fg="yellow"
+            "> Not starting container '%s' because it should be started on-demand with devserver."
+            % options["name"],
+            fg="yellow",
         )
-        client.containers.run(**options)
+        return container
+
+    container.start()
+    return container
 
 
 @devservices.command()
@@ -138,9 +246,8 @@ def down(project, service):
     for container in client.containers.list(all=True):
         if container.name.startswith(prefix):
             if not service or container.name[len(prefix) :] in service:
-                click.secho("> Removing '%s' container" % container.name, err=True, fg="red")
+                click.secho("> Stopping '%s' container" % container.name, err=True, fg="red")
                 container.stop()
-                container.remove()
 
 
 @devservices.command()
@@ -154,8 +261,6 @@ def rm(project, service):
         abort=True,
     )
 
-    import docker
-
     client = get_docker_client()
 
     prefix = project + "_"

commit f485905a1d4736c42ecc536c446fd2eba71d9ed7
Author: Brett Hoerner <brett@bretthoerner.com>
Date:   Fri Sep 29 12:01:52 2017 -0500

    ref: Drop -last_seen sort in ProjectTagKeyValuesEndpoint (#6224)
    
    This endpoint is used by the sidebar filters to return all (or matching)
    values of a specific tag. We have historically ordered by "-times_seen",
    which requires incrementing the counter in Postgres.
    
    For Tags 2.0 (tagstore) we'd like to remove as many counters as possible
    and move others into Redis. We can't support paginating an unconstrained
    set of values (especially when user search is added to the mix) by
    storing a huge top-k in Redis. This commit changes us to to order by
    the TagValue's "-last_seen" datetime instead.

diff --git a/src/sentry/api/endpoints/project_tagkey_values.py b/src/sentry/api/endpoints/project_tagkey_values.py
index 8af2d68a33..dd8eb79d20 100644
--- a/src/sentry/api/endpoints/project_tagkey_values.py
+++ b/src/sentry/api/endpoints/project_tagkey_values.py
@@ -3,9 +3,9 @@ from __future__ import absolute_import
 from sentry.api.base import DocSection
 from sentry.api.bases.project import ProjectEndpoint
 from sentry.api.exceptions import ResourceDoesNotExist
+from sentry.api.paginator import DateTimePaginator
 from sentry.api.serializers import serialize
 from sentry.models import TagKey, TagKeyStatus, TagValue
-from sentry.utils.db import is_postgres
 
 
 class ProjectTagKeyValuesEndpoint(ProjectEndpoint):
@@ -17,7 +17,7 @@ class ProjectTagKeyValuesEndpoint(ProjectEndpoint):
         ```````````````````
 
         Return a list of values associated with this key.  The `query`
-        parameter can be used to to perform a "starts with" match on
+        parameter can be used to to perform a "contains" match on
         values.
 
         :pparam string organization_slug: the slug of the organization.
@@ -39,32 +39,19 @@ class ProjectTagKeyValuesEndpoint(ProjectEndpoint):
         except TagKey.DoesNotExist:
             raise ResourceDoesNotExist
 
-        base_queryset = TagValue.objects.filter(
+        queryset = TagValue.objects.filter(
             project_id=project.id,
             key=tagkey.key,
         )
 
         query = request.GET.get('query')
         if query:
-            if is_postgres():
-                # not quite optimal, but best we can do with ORM
-                queryset = TagValue.objects.filter(
-                    id__in=base_queryset.order_by('-times_seen')[:10000]
-                )
-            else:
-                # MySQL can't handle an `IN` with a `LIMIT` clause
-                queryset = base_queryset
             queryset = queryset.filter(value__contains=query)
 
-        else:
-            queryset = TagValue.objects.filter(
-                project_id=project.id,
-                key=tagkey.key,
-            )
-
         return self.paginate(
             request=request,
             queryset=queryset,
-            order_by='-times_seen',
+            order_by='-last_seen',
+            paginator_cls=DateTimePaginator,
             on_results=lambda x: serialize(x, request.user),
         )

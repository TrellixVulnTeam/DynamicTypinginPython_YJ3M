commit e9631df35e84113c6e7d2957e0c0e96c1707058e
Author: Chris Fuller <cfuller@sentry.io>
Date:   Wed Nov 20 17:33:37 2019 -0500

    ref(search): Refactor backend to use QueryExecutor composition method (#15708)
    
    * Refactor SnubaSearchBackend to use QueryExecutor composition method

diff --git a/src/sentry/search/snuba/backend.py b/src/sentry/search/snuba/backend.py
index 1befaaf3c7..db3bd9ec36 100644
--- a/src/sentry/search/snuba/backend.py
+++ b/src/sentry/search/snuba/backend.py
@@ -56,17 +56,59 @@ issue_only_fields = set(
 )
 
 
-class QuerySetBuilder(object):
-    def __init__(self, conditions):
-        self.conditions = conditions
+def assigned_to_filter(actor, projects):
+    from sentry.models import OrganizationMember, OrganizationMemberTeam, Team
 
-    def build(self, queryset, search_filters):
-        for search_filter in search_filters:
-            name = search_filter.key.name
-            if name in self.conditions:
-                condition = self.conditions[name]
-                queryset = condition.apply(queryset, search_filter)
-        return queryset
+    if isinstance(actor, Team):
+        return Q(assignee_set__team=actor)
+
+    teams = Team.objects.filter(
+        id__in=OrganizationMemberTeam.objects.filter(
+            organizationmember__in=OrganizationMember.objects.filter(
+                user=actor, organization_id=projects[0].organization_id
+            ),
+            is_active=True,
+        ).values("team")
+    )
+
+    return Q(
+        Q(assignee_set__user=actor, assignee_set__project__in=projects)
+        | Q(assignee_set__team__in=teams)
+    )
+
+
+def unassigned_filter(unassigned, projects):
+    from sentry.models.groupassignee import GroupAssignee
+
+    query = Q(
+        id__in=GroupAssignee.objects.filter(project_id__in=[p.id for p in projects]).values_list(
+            "group_id", flat=True
+        )
+    )
+    if unassigned:
+        query = ~query
+    return query
+
+
+def get_search_filter(search_filters, name, operator):
+    """
+    Finds the value of a search filter with the passed name and operator. If
+    multiple values are found, returns the most restrictive value
+    :param search_filters: collection of `SearchFilter` objects
+    :param name: Name of the field to find
+    :param operator: '<' or '>'
+    :return: The value of the field if found, else None
+    """
+    assert operator in ("<", ">")
+    comparator = max if operator.startswith(">") else min
+    found_val = None
+    for search_filter in search_filters:
+        # Note that we check operator with `startswith` here so that we handle
+        # <, <=, >, >=
+        if search_filter.key.name == name and search_filter.operator.startswith(operator):
+            val = search_filter.value.raw_value
+            found_val = comparator(val, found_val) if found_val else val
+    return found_val
 
 
 class Condition(object):
@@ -124,150 +166,47 @@ class ScalarCondition(Condition):
         return qs_method(**q_dict)
 
 
-def assigned_to_filter(actor, projects):
-    from sentry.models import OrganizationMember, OrganizationMemberTeam, Team
-
-    if isinstance(actor, Team):
-        return Q(assignee_set__team=actor)
-
-    teams = Team.objects.filter(
-        id__in=OrganizationMemberTeam.objects.filter(
-            organizationmember__in=OrganizationMember.objects.filter(
-                user=actor, organization_id=projects[0].organization_id
-            ),
-            is_active=True,
-        ).values("team")
-    )
-
-    return Q(
-        Q(assignee_set__user=actor, assignee_set__project__in=projects)
-        | Q(assignee_set__team__in=teams)
-    )
-
-
-def unassigned_filter(unassigned, projects):
-    from sentry.models.groupassignee import GroupAssignee
+class QuerySetBuilder(object):
+    def __init__(self, conditions):
+        self.conditions = conditions
 
-    query = Q(
-        id__in=GroupAssignee.objects.filter(project_id__in=[p.id for p in projects]).values_list(
-            "group_id", flat=True
-        )
-    )
-    if unassigned:
-        query = ~query
-    return query
+    def build(self, queryset, search_filters):
+        for search_filter in search_filters:
+            name = search_filter.key.name
+            if name in self.conditions:
+                condition = self.conditions[name]
+                queryset = condition.apply(queryset, search_filter)
+        return queryset
 
 
-def get_search_filter(search_filters, name, operator):
+# This
+class AbstractQueryExecutor:
+    """This class serves as a template for Query Executors.
+    We subclass it in order to implement query methods (we use it to implement two classes: joined Postgres+Snuba queries, and Snuba only queries)
+    It's used to keep the query logic out of the actual search backend,
+    which can now just build query parameters and use the appropriate query executor to run the query
     """
-    Finds the value of a search filter with the passed name and operator. If
-    multiple values are found, returns the most restrictive value
-    :param search_filters: collection of `SearchFilter` objects
-    :param name: Name of the field to find
-    :param operator: '<' or '>'
-    :return: The value of the field if found, else None
-    """
-    assert operator in ("<", ">")
-    comparator = max if operator.startswith(">") else min
-    found_val = None
-    for search_filter in search_filters:
-        # Note that we check operator with `startswith` here so that we handle
-        # <, <=, >, >=
-        if search_filter.key.name == name and search_filter.operator.startswith(operator):
-            val = search_filter.value.raw_value
-            found_val = comparator(val, found_val) if found_val else val
-    return found_val
 
-
-class SnubaSearchBackend(SearchBackend):
     def query(
         self,
         projects,
-        environments=None,
-        sort_by="date",
-        limit=100,
-        cursor=None,
-        count_hits=False,
-        paginator_options=None,
-        search_filters=None,
-        date_from=None,
-        date_to=None,
+        retention_window_start,
+        group_queryset,
+        environments,
+        sort_by,
+        limit,
+        cursor,
+        count_hits,
+        paginator_options,
+        search_filters,
+        date_from,
+        date_to,
     ):
-        from sentry.models import Group, GroupStatus, GroupSubscription
-
-        search_filters = search_filters if search_filters is not None else []
-
-        # ensure projects are from same org
-        if len({p.organization_id for p in projects}) != 1:
-            raise RuntimeError("Cross organization search not supported")
-
-        if paginator_options is None:
-            paginator_options = {}
-
-        group_queryset = Group.objects.filter(project__in=projects).exclude(
-            status__in=[
-                GroupStatus.PENDING_DELETION,
-                GroupStatus.DELETION_IN_PROGRESS,
-                GroupStatus.PENDING_MERGE,
-            ]
-        )
-
-        qs_builder_conditions = {
-            "status": QCallbackCondition(lambda status: Q(status=status)),
-            "bookmarked_by": QCallbackCondition(
-                lambda user: Q(bookmark_set__project__in=projects, bookmark_set__user=user)
-            ),
-            "assigned_to": QCallbackCondition(
-                functools.partial(assigned_to_filter, projects=projects)
-            ),
-            "unassigned": QCallbackCondition(
-                functools.partial(unassigned_filter, projects=projects)
-            ),
-            "subscribed_by": QCallbackCondition(
-                lambda user: Q(
-                    id__in=GroupSubscription.objects.filter(
-                        project__in=projects, user=user, is_active=True
-                    ).values_list("group")
-                )
-            ),
-            "active_at": ScalarCondition("active_at"),
-        }
+        raise NotImplementedError
 
-        group_queryset = QuerySetBuilder(qs_builder_conditions).build(
-            group_queryset, search_filters
-        )
-        # filter out groups which are beyond the retention period
-        retention = quotas.get_event_retention(organization=projects[0].organization)
-        if retention:
-            retention_window_start = timezone.now() - timedelta(days=retention)
-        else:
-            retention_window_start = None
-        # TODO: This could be optimized when building querysets to identify
-        # criteria that are logically impossible (e.g. if the upper bound
-        # for last seen is before the retention window starts, no results
-        # exist.)
-        if retention_window_start:
-            group_queryset = group_queryset.filter(last_seen__gte=retention_window_start)
 
-        # This is a punt because the SnubaSearchBackend (a subclass) shares so much that it
-        # seemed better to handle all the shared initialization and then handoff to the
-        # actual backend.
-        return self._query(
-            projects,
-            retention_window_start,
-            group_queryset,
-            environments,
-            sort_by,
-            limit,
-            cursor,
-            count_hits,
-            paginator_options,
-            search_filters,
-            date_from,
-            date_to,
-        )
-
-    def _query(
+class PostgresSnubaQueryExecutor(AbstractQueryExecutor):
+    def query(
         self,
         projects,
         retention_window_start,
@@ -283,61 +222,6 @@ class SnubaSearchBackend(SearchBackend):
         date_to,
     ):
 
-        # TODO: It's possible `first_release` could be handled by Snuba.
-        if environments is not None:
-            environment_ids = [environment.id for environment in environments]
-            group_queryset = group_queryset.filter(
-                groupenvironment__environment_id__in=environment_ids
-            )
-            group_queryset = QuerySetBuilder(
-                {
-                    "first_release": QCallbackCondition(
-                        lambda version: Q(
-                            # if environment(s) are selected, we just filter on the group
-                            # environment's first_release attribute.
-                            groupenvironment__first_release__organization_id=projects[
-                                0
-                            ].organization_id,
-                            groupenvironment__first_release__version=version,
-                            groupenvironment__environment_id__in=environment_ids,
-                        )
-                    ),
-                    "first_seen": ScalarCondition(
-                        "groupenvironment__first_seen",
-                        {"groupenvironment__environment_id__in": environment_ids},
-                    ),
-                }
-            ).build(group_queryset, search_filters)
-        else:
-            group_queryset = QuerySetBuilder(
-                {
-                    "first_release": QCallbackCondition(
-                        lambda release_version: Q(
-                            # if no specific environments are supplied, we either choose any
-                            # groups/issues whose first release matches the given release_version,
-                            Q(
-                                first_release_id__in=Release.objects.filter(
-                                    version=release_version,
-                                    organization_id=projects[0].organization_id,
-                                )
-                            )
-                            |
-                            # or we choose any groups whose first occurrence in any environment and the latest release at
-                            # the time of the groups' first occurrence matches the given
-                            # release_version
-                            Q(
-                                id__in=GroupEnvironment.objects.filter(
-                                    first_release__version=release_version,
-                                    first_release__organization_id=projects[0].organization_id,
-                                    environment__organization_id=projects[0].organization_id,
-                                ).values_list("group_id")
-                            )
-                        )
-                    ),
-                    "first_seen": ScalarCondition("first_seen"),
-                }
-            ).build(group_queryset, search_filters)
-
         now = timezone.now()
         end = None
         end_params = filter(None, [date_to, get_search_filter(search_filters, "date", "<")])
@@ -596,6 +480,10 @@ class SnubaSearchBackend(SearchBackend):
         return paginator_results
 
 
+class SnubaOnlyQueryExecutor(AbstractQueryExecutor):
+    pass
+
+
 def snuba_search(
     start,
     end,
@@ -696,3 +584,151 @@ def snuba_search(
         metrics.timing("snuba.search.num_result_groups", len(rows))
 
     return [(row["issue"], row[sort_field]) for row in rows], total
+
+
+class SnubaSearchBackend(SearchBackend):
+    def query(
+        self,
+        projects,
+        environments=None,
+        sort_by="date",
+        limit=100,
+        cursor=None,
+        count_hits=False,
+        paginator_options=None,
+        search_filters=None,
+        date_from=None,
+        date_to=None,
+    ):
+        from sentry.models import Group, GroupStatus, GroupSubscription
+
+        search_filters = search_filters if search_filters is not None else []
+
+        # ensure projects are from same org
+        if len({p.organization_id for p in projects}) != 1:
+            raise RuntimeError("Cross organization search not supported")
+
+        if paginator_options is None:
+            paginator_options = {}
+
+        group_queryset = Group.objects.filter(project__in=projects).exclude(
+            status__in=[
+                GroupStatus.PENDING_DELETION,
+                GroupStatus.DELETION_IN_PROGRESS,
+                GroupStatus.PENDING_MERGE,
+            ]
+        )
+
+        qs_builder_conditions = {
+            "status": QCallbackCondition(lambda status: Q(status=status)),
+            "bookmarked_by": QCallbackCondition(
+                lambda user: Q(bookmark_set__project__in=projects, bookmark_set__user=user)
+            ),
+            "assigned_to": QCallbackCondition(
+                functools.partial(assigned_to_filter, projects=projects)
+            ),
+            "unassigned": QCallbackCondition(
+                functools.partial(unassigned_filter, projects=projects)
+            ),
+            "subscribed_by": QCallbackCondition(
+                lambda user: Q(
+                    id__in=GroupSubscription.objects.filter(
+                        project__in=projects, user=user, is_active=True
+                    ).values_list("group")
+                )
+            ),
+            "active_at": ScalarCondition("active_at"),
+        }
+
+        group_queryset = QuerySetBuilder(qs_builder_conditions).build(
+            group_queryset, search_filters
+        )
+        # filter out groups which are beyond the retention period
+        retention = quotas.get_event_retention(organization=projects[0].organization)
+        if retention:
+            retention_window_start = timezone.now() - timedelta(days=retention)
+        else:
+            retention_window_start = None
+        # TODO: This could be optimized when building querysets to identify
+        # criteria that are logically impossible (e.g. if the upper bound
+        # for last seen is before the retention window starts, no results
+        # exist.)
+        if retention_window_start:
+            group_queryset = group_queryset.filter(last_seen__gte=retention_window_start)
+
+        # TODO: It's possible `first_release` could be handled by Snuba.
+        if environments is not None:
+            environment_ids = [environment.id for environment in environments]
+            group_queryset = group_queryset.filter(
+                groupenvironment__environment_id__in=environment_ids
+            )
+            group_queryset = QuerySetBuilder(
+                {
+                    "first_release": QCallbackCondition(
+                        lambda version: Q(
+                            # if environment(s) are selected, we just filter on the group
+                            # environment's first_release attribute.
+                            groupenvironment__first_release__organization_id=projects[
+                                0
+                            ].organization_id,
+                            groupenvironment__first_release__version=version,
+                            groupenvironment__environment_id__in=environment_ids,
+                        )
+                    ),
+                    "first_seen": ScalarCondition(
+                        "groupenvironment__first_seen",
+                        {"groupenvironment__environment_id__in": environment_ids},
+                    ),
+                }
+            ).build(group_queryset, search_filters)
+        else:
+            group_queryset = QuerySetBuilder(
+                {
+                    "first_release": QCallbackCondition(
+                        lambda release_version: Q(
+                            # if no specific environments are supplied, we either choose any
+                            # groups/issues whose first release matches the given release_version,
+                            Q(
+                                first_release_id__in=Release.objects.filter(
+                                    version=release_version,
+                                    organization_id=projects[0].organization_id,
+                                )
+                            )
+                            |
+                            # or we choose any groups whose first occurrence in any environment and the latest release at
+                            # the time of the groups' first occurrence matches the given
+                            # release_version
+                            Q(
+                                id__in=GroupEnvironment.objects.filter(
+                                    first_release__version=release_version,
+                                    first_release__organization_id=projects[0].organization_id,
+                                    environment__organization_id=projects[0].organization_id,
+                                ).values_list("group_id")
+                            )
+                        )
+                    ),
+                    "first_seen": ScalarCondition("first_seen"),
+                }
+            ).build(group_queryset, search_filters)
+
+        query_executor = PostgresSnubaQueryExecutor()
+
+        return query_executor.query(
+            projects,
+            retention_window_start,
+            group_queryset,
+            environments,
+            sort_by,
+            limit,
+            cursor,
+            count_hits,
+            paginator_options,
+            search_filters,
+            date_from,
+            date_to,
+        )
+
+
+# This class will have logic to use the groups dataset, and to also determine which QueryBackend to use.
+class SnubaGroupsSearchBackend(SearchBackend):
+    pass

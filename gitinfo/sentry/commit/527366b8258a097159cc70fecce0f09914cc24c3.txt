commit 527366b8258a097159cc70fecce0f09914cc24c3
Author: Alberto Leal <mail4alberto@gmail.com>
Date:   Tue Dec 3 17:37:09 2019 -0500

    feat(discover2): Expand an aggregated row (#15793)

diff --git a/src/sentry/static/sentry/app/utils/tokenizeSearch.tsx b/src/sentry/static/sentry/app/utils/tokenizeSearch.tsx
index 09c9f6de92..b55bcc7665 100644
--- a/src/sentry/static/sentry/app/utils/tokenizeSearch.tsx
+++ b/src/sentry/static/sentry/app/utils/tokenizeSearch.tsx
@@ -1,6 +1,6 @@
 import flatMap from 'lodash/flatMap';
 
-type QueryResults = {
+export type QueryResults = {
   /**
    * The text portion of the string query
    */
diff --git a/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx b/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
index 379d154183..a84df805fe 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
@@ -702,9 +702,21 @@ class EventView {
       // of it in the table.
 
       if (numOfColumns <= 1) {
-        const sorts = [...newEventView.sorts];
-        sorts.splice(needleSortIndex, 1);
-        newEventView.sorts = [...new Set(sorts)];
+        if (isFieldSortable(updatedField, tableMeta)) {
+          // use the current updated field as the sort key
+          const sort = fieldToSort(updatedField, tableMeta)!;
+
+          // preserve the sort kind
+          sort.kind = needleSort.kind;
+
+          const sorts = [...newEventView.sorts];
+          sorts[needleSortIndex] = sort;
+          newEventView.sorts = sorts;
+        } else {
+          const sorts = [...newEventView.sorts];
+          sorts.splice(needleSortIndex, 1);
+          newEventView.sorts = [...new Set(sorts)];
+        }
       }
 
       if (newEventView.sorts.length <= 0 && newEventView.fields.length > 0) {
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
index 7fdd4012c7..3c19554b8e 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
@@ -4,14 +4,24 @@ import {Location} from 'history';
 import {Organization} from 'app/types';
 import {trackAnalyticsEvent} from 'app/utils/analytics';
 import GridEditable from 'app/components/gridEditable';
+import Tooltip from 'app/components/tooltip';
+import {t} from 'app/locale';
+import {
+  tokenizeSearch,
+  stringifyQueryObject,
+  QueryResults,
+} from 'app/utils/tokenizeSearch';
+import {assert} from 'app/types/utils';
+import Link from 'app/components/links/link';
 
 import {
   getFieldRenderer,
   getAggregateAlias,
   pushEventViewToLocation,
   explodeField,
+  MetaType,
 } from '../utils';
-import EventView, {pickRelevantLocationQueryStrings} from '../eventView';
+import EventView, {pickRelevantLocationQueryStrings, Field} from '../eventView';
 import SortLink from '../sortLink';
 import renderTableModalEditColumnFactory from './tableModalEditColumn';
 import {TableColumn, TableData, TableDataRow} from './types';
@@ -19,6 +29,7 @@ import {ColumnValueType} from '../eventQueryParams';
 import DraggableColumns, {
   DRAGGABLE_COLUMN_CLASSNAME_IDENTIFIER,
 } from './draggableColumns';
+import {AGGREGATE_ALIASES} from '../data';
 
 export type TableViewProps = {
   location: Location;
@@ -257,12 +268,42 @@ class TableView extends React.Component<TableViewProps> {
       return dataRow[column.key];
     }
 
-    const hasLinkField = eventView.hasAutolinkField();
-    const forceLink =
-      !hasLinkField && eventView.getFields().indexOf(String(column.field)) === 0;
+    return (
+      <ExpandAggregateRow
+        eventView={eventView}
+        column={column}
+        dataRow={dataRow}
+        location={location}
+        tableMeta={tableData.meta}
+      >
+        {({willExpand}) => {
+          // NOTE: TypeScript cannot detect that tableData.meta is truthy here
+          //       since there was a condition guard to handle it whenever it is
+          //       falsey. So we assert it here.
+          assert(tableData.meta);
+
+          if (!willExpand) {
+            const hasLinkField = eventView.hasAutolinkField();
+            const forceLink =
+              !hasLinkField && eventView.getFields().indexOf(String(column.field)) === 0;
+
+            const fieldRenderer = getFieldRenderer(
+              String(column.key),
+              tableData.meta,
+              forceLink
+            );
+            return fieldRenderer(dataRow, {organization, location});
+          }
 
-    const fieldRenderer = getFieldRenderer(String(column.key), tableData.meta, forceLink);
-    return fieldRenderer(dataRow, {organization, location});
+          const fieldRenderer = getFieldRenderer(
+            String(column.key),
+            tableData.meta,
+            false
+          );
+          return fieldRenderer(dataRow, {organization, location});
+        }}
+      </ExpandAggregateRow>
+    );
   };
 
   generateColumnOrder = ({
@@ -398,4 +439,103 @@ class TableView extends React.Component<TableViewProps> {
   }
 }
 
+const UNSEARCHABLE_FIELDS: string[] = [...AGGREGATE_ALIASES];
+
+const ExpandAggregateRow = (props: {
+  children: ({willExpand: boolean}) => React.ReactNode;
+  eventView: EventView;
+  column: TableColumn<keyof TableDataRow>;
+  dataRow: TableDataRow;
+  location: Location;
+  tableMeta: MetaType;
+}) => {
+  const {children, column, dataRow, eventView, location, tableMeta} = props;
+
+  const {eventViewField} = column;
+
+  const exploded = explodeField(eventViewField);
+  const {aggregation} = exploded;
+
+  if (aggregation === 'count') {
+    let nextEventView = eventView.clone();
+
+    const additionalSearchConditions: {[key: string]: string[]} = {};
+
+    const indicesToUpdate: number[] = [];
+    nextEventView.fields.forEach((field: Field, index: number) => {
+      if (eventViewField.field === field.field) {
+        // invariant: this is count(exploded.field)
+        // convert all instances of count(exploded.field) to exploded.field
+        indicesToUpdate.push(index);
+        return;
+      }
+
+      const currentExplodedField = explodeField(field);
+      if (currentExplodedField.aggregation) {
+        // this is a column with an aggregation; we skip this
+        return;
+      }
+
+      if (UNSEARCHABLE_FIELDS.includes(currentExplodedField.field)) {
+        return;
+      }
+
+      // add this field to the search conditions
+
+      const dataKey = getAggregateAlias(field.field);
+      const value = dataRow[dataKey];
+
+      if (value) {
+        additionalSearchConditions[currentExplodedField.field] = [String(value).trim()];
+      }
+    });
+
+    nextEventView = indicesToUpdate.reduce(
+      (currentEventView: EventView, indexToUpdate: number) => {
+        const updatedColumn = {
+          aggregation: '',
+          field: exploded.field,
+          fieldname: exploded.field,
+        };
+
+        return currentEventView.withUpdatedColumn(
+          indexToUpdate,
+          updatedColumn,
+          tableMeta
+        );
+      },
+      nextEventView
+    );
+
+    const tokenized: QueryResults = tokenizeSearch(nextEventView.query);
+
+    // merge tokenized and additionalSearchConditions together
+    Object.keys(additionalSearchConditions).forEach(key => {
+      const hasCommonKey =
+        Array.isArray(tokenized[key]) && Array.isArray(additionalSearchConditions[key]);
+      if (hasCommonKey) {
+        tokenized[key] = [...tokenized[key], ...additionalSearchConditions[key]];
+        return;
+      }
+
+      tokenized[key] = additionalSearchConditions[key];
+    });
+
+    nextEventView.query = stringifyQueryObject(tokenized);
+
+    const target = {
+      pathname: location.pathname,
+      query: nextEventView.generateQueryStringObject(),
+    };
+
+    return (
+      <Tooltip title={t('Expand aggregated row')} containerDisplayMode="block">
+        <Link to={target}>{children({willExpand: true})}</Link>
+      </Tooltip>
+    );
+  }
+
+  return <React.Fragment>{children({willExpand: false})}</React.Fragment>;
+};
+
 export default TableView;

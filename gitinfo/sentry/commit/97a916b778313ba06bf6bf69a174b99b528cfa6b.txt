commit 97a916b778313ba06bf6bf69a174b99b528cfa6b
Author: Chris Fuller <chris@iprogramstuff.com>
Date:   Mon Sep 30 15:06:49 2019 -0400

    feat(api): Make message queries use Snuba instead of Postgres (#14844)
    
    * Removing PostgreSQL query filter on message +  Making explicit test for long message

diff --git a/src/sentry/search/snuba/backend.py b/src/sentry/search/snuba/backend.py
index 29400670ba..fa7a211d06 100644
--- a/src/sentry/search/snuba/backend.py
+++ b/src/sentry/search/snuba/backend.py
@@ -16,7 +16,6 @@ from sentry.constants import ALLOWED_FUTURE_DELTA
 from sentry.models import Group, Release, GroupEnvironment
 from sentry.search.base import SearchBackend
 from sentry.utils import snuba, metrics
-from sentry.utils.db import is_postgres
 
 logger = logging.getLogger("sentry.search.snuba")
 datetime_format = "%Y-%m-%dT%H:%M:%S+00:00"
@@ -159,19 +158,6 @@ def unassigned_filter(unassigned, projects):
     return query
 
 
-def message_regex_filter(queryset, message):
-    operator = ("!" if message.operator == "!=" else "") + "~*"
-
-    # XXX: We translate these to a regex like '^<pattern>$'. Since we want to
-    # search anywhere in the string, drop those characters.
-    message_value = message.value.value[1:-1]
-
-    return queryset.extra(
-        where=["message {0} %s OR view {0} %s".format(operator)],
-        params=[message_value, message_value],
-    )
-
-
 def get_search_filter(search_filters, name, operator):
     """
     Finds the value of a search filter with the passed name and operator. If
@@ -247,20 +233,6 @@ class SnubaSearchBackend(SearchBackend):
             "active_at": ScalarCondition("active_at"),
         }
 
-        message = [
-            search_filter for search_filter in search_filters if search_filter.key.name == "message"
-        ]
-        if message and message[0].value.raw_value:
-            message = message[0]
-            # We only support full wildcard matching in postgres
-            if is_postgres() and message.value.is_wildcard():
-                group_queryset = message_regex_filter(group_queryset, message)
-            else:
-                # Otherwise, use the standard LIKE query
-                qs_builder_conditions["message"] = QCallbackCondition(
-                    lambda message: Q(Q(message__icontains=message) | Q(culprit__icontains=message))
-                )
-
         group_queryset = QuerySetBuilder(qs_builder_conditions).build(
             group_queryset, search_filters
         )
@@ -389,7 +361,7 @@ class SnubaSearchBackend(SearchBackend):
                 not [
                     sf
                     for sf in search_filters
-                    if sf.key.name not in issue_only_fields.union(["date", "message"])
+                    if sf.key.name not in issue_only_fields.union(["date"])
                 ]
             ):
                 group_queryset = group_queryset.order_by("-last_seen")
diff --git a/tests/snuba/search/test_backend.py b/tests/snuba/search/test_backend.py
index 69adfc98f6..bb14d5fd97 100644
--- a/tests/snuba/search/test_backend.py
+++ b/tests/snuba/search/test_backend.py
@@ -40,7 +40,7 @@ class SnubaSearchTest(TestCase, SnubaTestCase):
             data={
                 "fingerprint": ["put-me-in-group1"],
                 "event_id": "a" * 32,
-                "message": "foo",
+                "message": "foo. Also,this message is intended to be greater than 256 characters so that we can put some unique string identifier after that point in the string. The purpose of this is in order to verify we are using snuba to search messsages instead of Postgres (postgres truncates at 256 characters and clickhouse does not). santryrox.",
                 "environment": "production",
                 "tags": {"server": "example.com"},
                 "timestamp": event1_timestamp,
@@ -163,6 +163,7 @@ class SnubaSearchTest(TestCase, SnubaTestCase):
             search_filters = self.build_search_filter(
                 search_filter_query, projects, environments=environments
             )
+
         kwargs = {}
         if limit is not None:
             kwargs["limit"] = limit
@@ -206,6 +207,15 @@ class SnubaSearchTest(TestCase, SnubaTestCase):
         )
         assert set(results) == set([self.group2])
 
+    def test_query_for_text_in_long_message(self):
+        results = self.make_query(
+            [self.project],
+            environments=[self.environments["production"]],
+            search_filter_query="santryrox",
+        )
+
+        assert set(results) == set([self.group1])
+
     def test_multi_environments(self):
         self.set_up_multi_project()
         results = self.make_query(
@@ -848,12 +858,12 @@ class SnubaSearchTest(TestCase, SnubaTestCase):
 
     @mock.patch("sentry.utils.snuba.raw_query")
     def test_snuba_not_called_optimization(self, query_mock):
-        assert self.make_query(search_filter_query="foo").results == [self.group1]
+        assert self.make_query(search_filter_query="status:unresolved").results == [self.group1]
         assert not query_mock.called
 
         assert (
             self.make_query(
-                search_filter_query="last_seen:>%s foo" % date_to_query_format(timezone.now()),
+                search_filter_query="last_seen:>%s" % date_to_query_format(timezone.now()),
                 sort_by="date",
             ).results
             == []
@@ -880,7 +890,10 @@ class SnubaSearchTest(TestCase, SnubaTestCase):
         common_args = {
             "start": Any(datetime),
             "end": Any(datetime),
-            "filter_keys": {"project_id": [self.project.id], "issue": [self.group1.id]},
+            "filter_keys": {
+                "project_id": [self.project.id],
+                "issue": [self.group1.id, self.group2.id],
+            },
             "referrer": "search",
             "groupby": ["issue"],
             "conditions": [[["positionCaseInsensitive", ["message", "'foo'"]], "!=", 0]],
@@ -892,7 +905,7 @@ class SnubaSearchTest(TestCase, SnubaTestCase):
             "sample": 1,
         }
 
-        self.make_query(search_filter_query="foo")
+        self.make_query(search_filter_query="status:unresolved")
         assert not query_mock.called
 
         self.make_query(

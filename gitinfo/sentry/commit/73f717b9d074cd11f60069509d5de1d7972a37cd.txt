commit 73f717b9d074cd11f60069509d5de1d7972a37cd
Author: David Cramer <dcramer@gmail.com>
Date:   Mon Mar 27 11:52:38 2017 -0700

    Initial support for running newer versions of Django (#4868)

diff --git a/.travis.yml b/.travis.yml
index fb7e3621dd..686fd3e331 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -39,6 +39,9 @@ after_failure:
 # each attribute in the matrix will override the global attribute
 matrix:
   fast_finish: true
+  allow_failures:
+    - python: 2.7
+      env: TEST_SUITE=django-18
   include:
     - language: ruby
       rvm: 2.2
@@ -80,3 +83,9 @@ matrix:
         - postgresql
     - python: 2.7
       env: TEST_SUITE=dist
+    - python: 2.7
+      env: TEST_SUITE=django-18
+      services:
+        - memcached
+        - redis-server
+        - postgresql
diff --git a/Makefile b/Makefile
index ba90eb48fe..74e077cbc4 100644
--- a/Makefile
+++ b/Makefile
@@ -179,6 +179,8 @@ travis-install-acceptance: install-yarn travis-install-postgres
 travis-install-js: travis-upgrade-pip install-python install-python-tests install-yarn
 travis-install-cli: travis-install-postgres
 travis-install-dist: travis-upgrade-pip install-python install-python-tests install-yarn
+travis-install-django-18: travis-install-postgres
+	pip install "Django>=1.8,<1.9"
 
 .PHONY: travis-install-danger travis-install-sqlite travis-install-postgres travis-install-js travis-install-cli travis-install-dist
 
@@ -191,6 +193,7 @@ travis-lint-acceptance: travis-noop
 travis-lint-js: lint-js
 travis-lint-cli: travis-noop
 travis-lint-dist: travis-noop
+travis-lint-django-18: travis-lint-postgres
 
 .PHONY: travis-lint-danger travis-lint-sqlite travis-lint-postgres travis-lint-mysql travis-lint-js travis-lint-cli travis-lint-dist
 
@@ -206,5 +209,6 @@ travis-test-cli: test-cli
 travis-test-dist:
 	SENTRY_BUILD=$(TRAVIS_COMMIT) SENTRY_LIGHT_BUILD=0 python setup.py sdist bdist_wheel
 	@ls -lh dist/
+travis-test-django-18: travis-test-postgres
 
 .PHONY: travis-test-danger travis-test-sqlite travis-test-postgres travis-test-mysql travis-test-js travis-test-cli travis-test-dist
diff --git a/setup.cfg b/setup.cfg
index 868d2ae3e2..d76c66724d 100644
--- a/setup.cfg
+++ b/setup.cfg
@@ -2,7 +2,7 @@
 python_files = test*.py
 addopts = --tb=native -p no:doctest
 norecursedirs = bin dist docs htmlcov script hooks node_modules .* {args}
-looponfailroots = src/sentry tests
+looponfailroots = src tests
 selenium_driver = phantomjs
 phantomjs_path = node_modules/phantomjs-prebuilt/bin/phantomjs
 
diff --git a/setup.py b/setup.py
index 084b4072d6..08f940018e 100755
--- a/setup.py
+++ b/setup.py
@@ -94,14 +94,13 @@ install_requires = [
     # 'cryptography>=1.3,<1.4',
     'cssutils>=0.9.9,<0.10.0',
     'Django>=1.6.0,<1.7',
-    'django-bitfield>=1.7.0,<1.8.0',
     'django-crispy-forms>=1.4.0,<1.5.0',
     'django-debug-toolbar>=1.3.2,<1.4.0',
     'django-jsonfield>=0.9.13,<0.9.14',
     'django-picklefield>=0.3.0,<0.4.0',
     'django-sudo>=2.1.0,<3.0.0',
     'django-templatetag-sugar>=0.1.0',
-    'djangorestframework>=2.3.8,<2.4.0',
+    'djangorestframework>=2.4.8,<2.5.0',
     'email-reply-parser>=0.2.0,<0.3.0',
     'enum34>=0.9.18,<1.2.0',
     'exam>=0.5.1',
@@ -113,6 +112,7 @@ install_requires = [
 
     'ipaddress>=1.0.16,<1.1.0',
     'libsourcemap>=0.5.0,<0.6.0',
+    'loremipsum>=1.0.5,<1.1.0',
     'mock>=0.8.0,<1.1',
     'mmh3>=2.3.1,<2.4',
     'oauth2>=1.5.167',
diff --git a/src/bitfield/LICENSE b/src/bitfield/LICENSE
new file mode 100644
index 0000000000..880b1df83c
--- /dev/null
+++ b/src/bitfield/LICENSE
@@ -0,0 +1,202 @@
+
+                              Apache License
+                        Version 2.0, January 2004
+                     http://www.apache.org/licenses/
+
+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+1. Definitions.
+
+   "License" shall mean the terms and conditions for use, reproduction,
+   and distribution as defined by Sections 1 through 9 of this document.
+
+   "Licensor" shall mean the copyright owner or entity authorized by
+   the copyright owner that is granting the License.
+
+   "Legal Entity" shall mean the union of the acting entity and all
+   other entities that control, are controlled by, or are under common
+   control with that entity. For the purposes of this definition,
+   "control" means (i) the power, direct or indirect, to cause the
+   direction or management of such entity, whether by contract or
+   otherwise, or (ii) ownership of fifty percent (50%) or more of the
+   outstanding shares, or (iii) beneficial ownership of such entity.
+
+   "You" (or "Your") shall mean an individual or Legal Entity
+   exercising permissions granted by this License.
+
+   "Source" form shall mean the preferred form for making modifications,
+   including but not limited to software source code, documentation
+   source, and configuration files.
+
+   "Object" form shall mean any form resulting from mechanical
+   transformation or translation of a Source form, including but
+   not limited to compiled object code, generated documentation,
+   and conversions to other media types.
+
+   "Work" shall mean the work of authorship, whether in Source or
+   Object form, made available under the License, as indicated by a
+   copyright notice that is included in or attached to the work
+   (an example is provided in the Appendix below).
+
+   "Derivative Works" shall mean any work, whether in Source or Object
+   form, that is based on (or derived from) the Work and for which the
+   editorial revisions, annotations, elaborations, or other modifications
+   represent, as a whole, an original work of authorship. For the purposes
+   of this License, Derivative Works shall not include works that remain
+   separable from, or merely link (or bind by name) to the interfaces of,
+   the Work and Derivative Works thereof.
+
+   "Contribution" shall mean any work of authorship, including
+   the original version of the Work and any modifications or additions
+   to that Work or Derivative Works thereof, that is intentionally
+   submitted to Licensor for inclusion in the Work by the copyright owner
+   or by an individual or Legal Entity authorized to submit on behalf of
+   the copyright owner. For the purposes of this definition, "submitted"
+   means any form of electronic, verbal, or written communication sent
+   to the Licensor or its representatives, including but not limited to
+   communication on electronic mailing lists, source code control systems,
+   and issue tracking systems that are managed by, or on behalf of, the
+   Licensor for the purpose of discussing and improving the Work, but
+   excluding communication that is conspicuously marked or otherwise
+   designated in writing by the copyright owner as "Not a Contribution."
+
+   "Contributor" shall mean Licensor and any individual or Legal Entity
+   on behalf of whom a Contribution has been received by Licensor and
+   subsequently incorporated within the Work.
+
+2. Grant of Copyright License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   copyright license to reproduce, prepare Derivative Works of,
+   publicly display, publicly perform, sublicense, and distribute the
+   Work and such Derivative Works in Source or Object form.
+
+3. Grant of Patent License. Subject to the terms and conditions of
+   this License, each Contributor hereby grants to You a perpetual,
+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+   (except as stated in this section) patent license to make, have made,
+   use, offer to sell, sell, import, and otherwise transfer the Work,
+   where such license applies only to those patent claims licensable
+   by such Contributor that are necessarily infringed by their
+   Contribution(s) alone or by combination of their Contribution(s)
+   with the Work to which such Contribution(s) was submitted. If You
+   institute patent litigation against any entity (including a
+   cross-claim or counterclaim in a lawsuit) alleging that the Work
+   or a Contribution incorporated within the Work constitutes direct
+   or contributory patent infringement, then any patent licenses
+   granted to You under this License for that Work shall terminate
+   as of the date such litigation is filed.
+
+4. Redistribution. You may reproduce and distribute copies of the
+   Work or Derivative Works thereof in any medium, with or without
+   modifications, and in Source or Object form, provided that You
+   meet the following conditions:
+
+   (a) You must give any other recipients of the Work or
+       Derivative Works a copy of this License; and
+
+   (b) You must cause any modified files to carry prominent notices
+       stating that You changed the files; and
+
+   (c) You must retain, in the Source form of any Derivative Works
+       that You distribute, all copyright, patent, trademark, and
+       attribution notices from the Source form of the Work,
+       excluding those notices that do not pertain to any part of
+       the Derivative Works; and
+
+   (d) If the Work includes a "NOTICE" text file as part of its
+       distribution, then any Derivative Works that You distribute must
+       include a readable copy of the attribution notices contained
+       within such NOTICE file, excluding those notices that do not
+       pertain to any part of the Derivative Works, in at least one
+       of the following places: within a NOTICE text file distributed
+       as part of the Derivative Works; within the Source form or
+       documentation, if provided along with the Derivative Works; or,
+       within a display generated by the Derivative Works, if and
+       wherever such third-party notices normally appear. The contents
+       of the NOTICE file are for informational purposes only and
+       do not modify the License. You may add Your own attribution
+       notices within Derivative Works that You distribute, alongside
+       or as an addendum to the NOTICE text from the Work, provided
+       that such additional attribution notices cannot be construed
+       as modifying the License.
+
+   You may add Your own copyright statement to Your modifications and
+   may provide additional or different license terms and conditions
+   for use, reproduction, or distribution of Your modifications, or
+   for any such Derivative Works as a whole, provided Your use,
+   reproduction, and distribution of the Work otherwise complies with
+   the conditions stated in this License.
+
+5. Submission of Contributions. Unless You explicitly state otherwise,
+   any Contribution intentionally submitted for inclusion in the Work
+   by You to the Licensor shall be under the terms and conditions of
+   this License, without any additional terms or conditions.
+   Notwithstanding the above, nothing herein shall supersede or modify
+   the terms of any separate license agreement you may have executed
+   with Licensor regarding such Contributions.
+
+6. Trademarks. This License does not grant permission to use the trade
+   names, trademarks, service marks, or product names of the Licensor,
+   except as required for reasonable and customary use in describing the
+   origin of the Work and reproducing the content of the NOTICE file.
+
+7. Disclaimer of Warranty. Unless required by applicable law or
+   agreed to in writing, Licensor provides the Work (and each
+   Contributor provides its Contributions) on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+   implied, including, without limitation, any warranties or conditions
+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+   PARTICULAR PURPOSE. You are solely responsible for determining the
+   appropriateness of using or redistributing the Work and assume any
+   risks associated with Your exercise of permissions under this License.
+
+8. Limitation of Liability. In no event and under no legal theory,
+   whether in tort (including negligence), contract, or otherwise,
+   unless required by applicable law (such as deliberate and grossly
+   negligent acts) or agreed to in writing, shall any Contributor be
+   liable to You for damages, including any direct, indirect, special,
+   incidental, or consequential damages of any character arising as a
+   result of this License or out of the use or inability to use the
+   Work (including but not limited to damages for loss of goodwill,
+   work stoppage, computer failure or malfunction, or any and all
+   other commercial damages or losses), even if such Contributor
+   has been advised of the possibility of such damages.
+
+9. Accepting Warranty or Additional Liability. While redistributing
+   the Work or Derivative Works thereof, You may choose to offer,
+   and charge a fee for, acceptance of support, warranty, indemnity,
+   or other liability obligations and/or rights consistent with this
+   License. However, in accepting such obligations, You may act only
+   on Your own behalf and on Your sole responsibility, not on behalf
+   of any other Contributor, and only if You agree to indemnify,
+   defend, and hold each Contributor harmless for any liability
+   incurred by, or claims asserted against, such Contributor by reason
+   of your accepting any such warranty or additional liability.
+
+END OF TERMS AND CONDITIONS
+
+APPENDIX: How to apply the Apache License to your work.
+
+   To apply the Apache License to your work, attach the following
+   boilerplate notice, with the fields enclosed by brackets "[]"
+   replaced with your own identifying information. (Don't include
+   the brackets!)  The text should be enclosed in the appropriate
+   comment syntax for the file format. We also recommend that a
+   file or class name and description of purpose be included on the
+   same "printed page" as the copyright notice for easier
+   identification within third-party archives.
+
+Copyright 2010 DISQUS
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
\ No newline at end of file
diff --git a/src/bitfield/__init__.py b/src/bitfield/__init__.py
new file mode 100644
index 0000000000..5425137a19
--- /dev/null
+++ b/src/bitfield/__init__.py
@@ -0,0 +1,15 @@
+"""
+django-bitfield
+~~~~~~~~~~~~~~~
+"""
+from __future__ import absolute_import
+
+from bitfield.models import Bit, BitHandler, CompositeBitField, BitField  # NOQA
+
+default_app_config = 'bitfield.apps.BitFieldAppConfig'
+
+try:
+    VERSION = __import__('pkg_resources') \
+        .get_distribution('bitfield').version
+except Exception:
+    VERSION = 'unknown'
diff --git a/src/bitfield/admin.py b/src/bitfield/admin.py
new file mode 100644
index 0000000000..f6866b58fd
--- /dev/null
+++ b/src/bitfield/admin.py
@@ -0,0 +1,49 @@
+from __future__ import absolute_import
+
+import six
+from django.contrib.admin import FieldListFilter
+from django.contrib.admin.options import IncorrectLookupParameters
+from django.core.exceptions import ValidationError
+from django.db.models import F
+from django.utils.translation import ugettext_lazy as _
+
+from bitfield import Bit
+from bitfield.compat import bitor
+
+
+class BitFieldListFilter(FieldListFilter):
+    """
+    BitField list filter.
+    """
+
+    def __init__(self, field, request, params, model, model_admin, field_path):
+        self.lookup_kwarg = field_path
+        self.lookup_val = int(request.GET.get(self.lookup_kwarg, 0))
+        self.flags = field.flags
+        self.labels = field.labels
+        super(BitFieldListFilter, self).__init__(
+            field, request, params, model, model_admin, field_path)
+
+    def queryset(self, request, queryset):
+        filter = dict((p, bitor(F(p), v)) for p, v in six.iteritems(self.used_parameters))
+        try:
+            return queryset.filter(**filter)
+        except ValidationError as e:
+            raise IncorrectLookupParameters(e)
+
+    def expected_parameters(self):
+        return [self.lookup_kwarg]
+
+    def choices(self, cl):
+        yield {
+            'selected': self.lookup_val == 0,
+            'query_string': cl.get_query_string({}, [self.lookup_kwarg]),
+            'display': _('All'),
+        }
+        for number, flag in enumerate(self.flags):
+            bit_mask = Bit(number).mask
+            yield {
+                'selected': self.lookup_val == bit_mask,
+                'query_string': cl.get_query_string({self.lookup_kwarg: bit_mask}),
+                'display': self.labels[number],
+            }
diff --git a/src/bitfield/apps.py b/src/bitfield/apps.py
new file mode 100644
index 0000000000..d6af169147
--- /dev/null
+++ b/src/bitfield/apps.py
@@ -0,0 +1,8 @@
+from __future__ import absolute_import
+
+from django.apps import AppConfig
+
+
+class BitFieldAppConfig(AppConfig):
+    name = 'bitfield'
+    verbose_name = "Bit Field"
diff --git a/src/bitfield/compat.py b/src/bitfield/compat.py
new file mode 100644
index 0000000000..fb8f69b216
--- /dev/null
+++ b/src/bitfield/compat.py
@@ -0,0 +1,27 @@
+from __future__ import absolute_import
+
+__all__ = ('bitand', 'bitor')
+
+
+def bitand(a, b):
+    return a.bitand(b)
+
+
+def bitor(a, b):
+    return a.bitor(b)
+
+
+try:
+    from django.db.models.expressions import ExpressionNode
+    ExpressionNode.BITAND  # noqa
+    del ExpressionNode
+except ImportError:
+    # Django >= 1.8
+    pass
+except AttributeError:
+    # Django < 1.5
+    def bitand(a, b):  # NOQA
+        return a & b
+
+    def bitor(a, b):  # NOQA
+        return a | b
diff --git a/src/bitfield/forms.py b/src/bitfield/forms.py
new file mode 100644
index 0000000000..59794041e8
--- /dev/null
+++ b/src/bitfield/forms.py
@@ -0,0 +1,68 @@
+from __future__ import absolute_import
+
+import six
+
+from django.forms import CheckboxSelectMultiple, IntegerField, ValidationError
+
+from bitfield.types import BitHandler
+
+try:
+    from django.utils.encoding import force_text
+except ImportError:
+    from django.utils.encoding import force_unicode as force_text
+
+
+class BitFieldCheckboxSelectMultiple(CheckboxSelectMultiple):
+    def render(self, name, value, attrs=None, choices=()):
+        if isinstance(value, BitHandler):
+            value = [k for k, v in value if v]
+        elif isinstance(value, int):
+            real_value = []
+            div = 2
+            for (k, v) in self.choices:
+                if value % div != 0:
+                    real_value.append(k)
+                    value -= (value % div)
+                div *= 2
+            value = real_value
+        return super(BitFieldCheckboxSelectMultiple, self).render(
+            name, value, attrs=attrs)
+
+    def _has_changed(self, initial, data):
+        if initial is None:
+            initial = []
+        if data is None:
+            data = []
+        if initial != data:
+            return True
+        initial_set = set([force_text(value) for value in initial])
+        data_set = set([force_text(value) for value in data])
+        return data_set != initial_set
+
+
+class BitFormField(IntegerField):
+    def __init__(self, choices=(), widget=BitFieldCheckboxSelectMultiple, *args,
+                 **kwargs):
+        if isinstance(kwargs['initial'], int):
+            iv = kwargs['initial']
+            l = []
+            for i in range(0, 63):
+                if (1 << i) & iv > 0:
+                    l += [choices[i][0]]
+            kwargs['initial'] = l
+        self.widget = widget
+        super(BitFormField, self).__init__(widget=widget, *args, **kwargs)
+        self.choices = self.widget.choices = choices
+
+    def clean(self, value):
+        if not value:
+            return 0
+
+        # Assume an iterable which contains an item per flag that's enabled
+        result = BitHandler(0, [k for k, v in self.choices])
+        for k in value:
+            try:
+                setattr(result, six.text_type(k), True)
+            except AttributeError:
+                raise ValidationError('Unknown choice: %r' % (k,))
+        return int(result)
diff --git a/src/bitfield/models.py b/src/bitfield/models.py
new file mode 100644
index 0000000000..b9867c63f7
--- /dev/null
+++ b/src/bitfield/models.py
@@ -0,0 +1,262 @@
+from __future__ import absolute_import
+
+import six
+
+from django.db.models import signals
+from django.db.models.fields import BigIntegerField, Field
+
+from bitfield.forms import BitFormField
+from bitfield.query import BitQueryLookupWrapper
+from bitfield.types import Bit, BitHandler
+
+# Count binary capacity. Truncate "0b" prefix from binary form.
+# Twice faster than bin(i)[2:] or math.floor(math.log(i))
+MAX_FLAG_COUNT = int(len(bin(BigIntegerField.MAX_BIGINT)) - 2)
+
+
+class BitFieldFlags(object):
+    def __init__(self, flags):
+        if len(flags) > MAX_FLAG_COUNT:
+            raise ValueError('Too many flags')
+        self._flags = flags
+
+    def __repr__(self):
+        return repr(self._flags)
+
+    def __iter__(self):
+        for flag in self._flags:
+            yield flag
+
+    def __getattr__(self, key):
+        if key not in self._flags:
+            raise AttributeError
+        return Bit(self._flags.index(key))
+
+    def iteritems(self):
+        for flag in self._flags:
+            yield flag, Bit(self._flags.index(flag))
+
+    def iterkeys(self):
+        for flag in self._flags:
+            yield flag
+
+    def itervalues(self):
+        for flag in self._flags:
+            yield Bit(self._flags.index(flag))
+
+    def items(self):
+        return list(self.iteritems())  # NOQA
+
+    def keys(self):
+        return list(self.iterkeys())  # NOQA
+
+    def values(self):
+        return list(self.itervalues())  # NOQA
+
+
+class BitFieldCreator(object):
+    """
+    A placeholder class that provides a way to set the attribute on the model.
+    Descriptor for BitFields.  Checks to make sure that all flags of the
+    instance match the class.  This is to handle the case when caching
+    an older version of the instance and a newer version of the class is
+    available (usually during deploys).
+    """
+    def __init__(self, field):
+        self.field = field
+
+    def __set__(self, obj, value):
+        obj.__dict__[self.field.name] = self.field.to_python(value)
+
+    def __get__(self, obj, type=None):
+        if obj is None:
+            return BitFieldFlags(self.field.flags)
+        retval = obj.__dict__[self.field.name]
+        if self.field.__class__ is BitField:
+            # Update flags from class in case they've changed.
+            retval._keys = self.field.flags
+        return retval
+
+
+class BitField(BigIntegerField):
+
+    def contribute_to_class(self, cls, name, **kwargs):
+        super(BitField, self).contribute_to_class(cls, name, **kwargs)
+        setattr(cls, self.name, BitFieldCreator(self))
+
+    def __init__(self, flags, default=None, *args, **kwargs):
+        if isinstance(flags, dict):
+            # Get only integer keys in correct range
+            valid_keys = (k for k in flags.keys() if isinstance(k, int) and (0 <= k < MAX_FLAG_COUNT))
+            if not valid_keys:
+                raise ValueError('Wrong keys or empty dictionary')
+            # Fill list with values from dict or with empty values
+            flags = [flags.get(i, '') for i in range(max(valid_keys) + 1)]
+
+        if len(flags) > MAX_FLAG_COUNT:
+            raise ValueError('Too many flags')
+
+        self._arg_flags = flags
+        flags = list(flags)
+        labels = []
+        for num, flag in enumerate(flags):
+            if isinstance(flag, (tuple, list)):
+                flags[num] = flag[0]
+                labels.append(flag[1])
+            else:
+                labels.append(flag)
+
+        if isinstance(default, (list, tuple, set, frozenset)):
+            new_value = 0
+            for flag in default:
+                new_value |= Bit(flags.index(flag))
+            default = new_value
+
+        BigIntegerField.__init__(self, default=default, *args, **kwargs)
+        self.flags = flags
+        self.labels = labels
+
+    def south_field_triple(self):
+        "Returns a suitable description of this field for South."
+        from south.modelsinspector import introspector
+        field_class = "django.db.models.fields.BigIntegerField"
+        args, kwargs = introspector(self)
+        return (field_class, args, kwargs)
+
+    def formfield(self, form_class=BitFormField, **kwargs):
+        choices = [(k, self.labels[self.flags.index(k)]) for k in self.flags]
+        return Field.formfield(self, form_class, choices=choices, **kwargs)
+
+    def pre_save(self, instance, add):
+        value = getattr(instance, self.attname)
+        return value
+
+    def get_prep_value(self, value):
+        if value is None:
+            return None
+        if isinstance(value, (BitHandler, Bit)):
+            value = value.mask
+        return int(value)
+
+    # def get_db_prep_save(self, value, connection):
+    #     if isinstance(value, Bit):
+    #         return BitQuerySaveWrapper(self.model._meta.db_table, self.name, value)
+    #     return super(BitField, self).get_db_prep_save(value, connection=connection)
+
+    def get_db_prep_lookup(self, lookup_type, value, connection, prepared=False):
+        if isinstance(getattr(value, 'expression', None), Bit):
+            value = value.expression
+        if isinstance(value, (BitHandler, Bit)):
+            if hasattr(self, 'class_lookups'):
+                # Django 1.7+
+                return [value.mask]
+            else:
+                return BitQueryLookupWrapper(self.model._meta.db_table, self.db_column or self.name, value)
+        return BigIntegerField.get_db_prep_lookup(self, lookup_type=lookup_type, value=value,
+                                                  connection=connection, prepared=prepared)
+
+    def get_prep_lookup(self, lookup_type, value):
+        if isinstance(getattr(value, 'expression', None), Bit):
+            value = value.expression
+        if isinstance(value, Bit):
+            if lookup_type in ('exact',):
+                return value
+            raise TypeError('Lookup type %r not supported with `Bit` type.' % lookup_type)
+        return BigIntegerField.get_prep_lookup(self, lookup_type, value)
+
+    def to_python(self, value):
+        if isinstance(value, Bit):
+            value = value.mask
+        if not isinstance(value, BitHandler):
+            # Regression for #1425: fix bad data that was created resulting
+            # in negative values for flags.  Compute the value that would
+            # have been visible ot the application to preserve compatibility.
+            if isinstance(value, six.integer_types) and value < 0:
+                new_value = 0
+                for bit_number, _ in enumerate(self.flags):
+                    new_value |= (value & (2 ** bit_number))
+                value = new_value
+
+            value = BitHandler(value, self.flags, self.labels)
+        else:
+            # Ensure flags are consistent for unpickling
+            value._keys = self.flags
+        return value
+
+    def deconstruct(self):
+        name, path, args, kwargs = super(BitField, self).deconstruct()
+        args.insert(0, self._arg_flags)
+        return name, path, args, kwargs
+
+
+try:
+    BitField.register_lookup(BitQueryLookupWrapper)
+except AttributeError:
+    pass
+
+
+class CompositeBitFieldWrapper(object):
+    def __init__(self, fields):
+        self.fields = fields
+
+    def __getattr__(self, attr):
+        if attr == 'fields':
+            return super(CompositeBitFieldWrapper, self).__getattr__(attr)
+
+        for field in self.fields:
+            if hasattr(field, attr):
+                return getattr(field, attr)
+        raise AttributeError('%s is not a valid flag' % attr)
+
+    def __hasattr__(self, attr):
+        if attr == 'fields':
+            return super(CompositeBitFieldWrapper, self).__hasattr__(attr)
+
+        for field in self.fields:
+            if hasattr(field, attr):
+                return True
+        return False
+
+    def __setattr__(self, attr, value):
+        if attr == 'fields':
+            super(CompositeBitFieldWrapper, self).__setattr__(attr, value)
+            return
+
+        for field in self.fields:
+            if hasattr(field, attr):
+                setattr(field, attr, value)
+                return
+        raise AttributeError('%s is not a valid flag' % attr)
+
+
+class CompositeBitField(object):
+    is_relation = False
+    many_to_many = False
+    concrete = False
+
+    def __init__(self, fields):
+        self.fields = fields
+
+    def contribute_to_class(self, cls, name):
+        self.name = name
+        self.model = cls
+        cls._meta.virtual_fields.append(self)
+
+        signals.class_prepared.connect(self.validate_fields, sender=cls)
+
+        setattr(cls, name, self)
+
+    def validate_fields(self, sender, **kwargs):
+        cls = sender
+        model_fields = dict([
+            (f.name, f) for f in cls._meta.fields if f.name in self.fields])
+        all_flags = sum([model_fields[f].flags for f in self.fields], [])
+        if len(all_flags) != len(set(all_flags)):
+            raise ValueError('BitField flags must be unique.')
+
+    def __get__(self, instance, instance_type=None):
+        fields = [getattr(instance, f) for f in self.fields]
+        return CompositeBitFieldWrapper(fields)
+
+    def __set__(self, *args, **kwargs):
+        raise NotImplementedError('CompositeBitField cannot be set.')
diff --git a/src/bitfield/query.py b/src/bitfield/query.py
new file mode 100644
index 0000000000..7721f08f48
--- /dev/null
+++ b/src/bitfield/query.py
@@ -0,0 +1,72 @@
+from __future__ import absolute_import
+
+from bitfield.types import Bit, BitHandler
+
+
+class BitQueryLookupWrapper(object):
+    def __init__(self, alias, column, bit):
+        self.table_alias = alias
+        self.column = column
+        self.bit = bit
+
+    def as_sql(self, qn, connection=None):
+        """
+        Create the proper SQL fragment. This inserts something like
+        "(T0.flags & value) != 0".
+
+        This will be called by Where.as_sql()
+        """
+        if self.bit:
+            return ("(%s.%s | %d)" % (qn(self.table_alias), qn(self.column), self.bit.mask),
+                    [])
+        return ("(%s.%s & %d)" % (qn(self.table_alias), qn(self.column), self.bit.mask),
+                [])
+
+
+try:
+    # Django 1.7+
+    from django.db.models.lookups import Exact
+
+    class BitQueryLookupWrapper(Exact):  # NOQA
+        def process_lhs(self, qn, connection, lhs=None):
+            lhs_sql, params = super(BitQueryLookupWrapper, self).process_lhs(
+                qn, connection, lhs)
+            if self.rhs:
+                lhs_sql = lhs_sql + ' & %s'
+            else:
+                lhs_sql = lhs_sql + ' | %s'
+            params.extend(self.get_db_prep_lookup(self.rhs, connection)[1])
+            return lhs_sql, params
+
+        def get_db_prep_lookup(self, value, connection, prepared=False):
+            v = value.mask if isinstance(value, (BitHandler, Bit)) else value
+            return super(BitQueryLookupWrapper, self).get_db_prep_lookup(v, connection)
+
+        def get_prep_lookup(self):
+            return self.rhs
+
+except ImportError:
+    pass
+
+
+class BitQuerySaveWrapper(BitQueryLookupWrapper):
+    def as_sql(self, qn, connection):
+        """
+        Create the proper SQL fragment. This inserts something like
+        "(T0.flags & value) != 0".
+
+        This will be called by Where.as_sql()
+        """
+        engine = connection.settings_dict['ENGINE'].rsplit('.', -1)[-1]
+        if engine.startswith('postgres'):
+            XOR_OPERATOR = '#'
+        elif engine.startswith('sqlite'):
+            raise NotImplementedError
+        else:
+            XOR_OPERATOR = '^'
+
+        if self.bit:
+            return ("%s.%s | %d" % (qn(self.table_alias), qn(self.column), self.bit.mask),
+                    [])
+        return ("%s.%s %s %d" % (qn(self.table_alias), qn(self.column), XOR_OPERATOR, self.bit.mask),
+                [])
diff --git a/src/bitfield/types.py b/src/bitfield/types.py
new file mode 100644
index 0000000000..43b7edb114
--- /dev/null
+++ b/src/bitfield/types.py
@@ -0,0 +1,270 @@
+from __future__ import absolute_import
+
+import django
+import six
+
+from six import string_types
+from sentry.utils.compat import implements_to_string
+
+
+def cmp(a, b):
+    return (a > b) - (a < b)
+
+
+class Bit(object):
+    """
+    Represents a single Bit.
+    """
+    def __init__(self, number, is_set=True):
+        self.number = number
+        self.is_set = bool(is_set)
+        self.mask = 2 ** int(number)
+        self.children = []
+        if not self.is_set:
+            self.mask = ~self.mask
+
+    def __repr__(self):
+        return '<%s: number=%d, is_set=%s>' % (self.__class__.__name__, self.number, self.is_set)
+
+    # def __str__(self):
+    #     if self.is_set:
+    #         return 'Yes'
+    #     return 'No'
+
+    def __int__(self):
+        return self.mask
+
+    def __bool__(self):
+        return self.is_set
+
+    __nonzero__ = __bool__
+
+    def __eq__(self, value):
+        if isinstance(value, Bit):
+            return value.number == self.number and value.is_set == self.is_set
+        elif isinstance(value, bool):
+            return value == self.is_set
+        elif isinstance(value, int):
+            return value == self.mask
+        return value == self.is_set
+
+    def __ne__(self, value):
+        return not self == value
+
+    def __coerce__(self, value):
+        return (self.is_set, bool(value))
+
+    def __invert__(self):
+        return self.__class__(self.number, not self.is_set)
+
+    def __and__(self, value):
+        if isinstance(value, Bit):
+            value = value.mask
+        return value & self.mask
+
+    def __rand__(self, value):
+        if isinstance(value, Bit):
+            value = value.mask
+        return self.mask & value
+
+    def __or__(self, value):
+        if isinstance(value, Bit):
+            value = value.mask
+        return value | self.mask
+
+    def __ror__(self, value):
+        if isinstance(value, Bit):
+            value = value.mask
+        return self.mask | value
+
+    def __lshift__(self, value):
+        if isinstance(value, Bit):
+            value = value.mask
+        return value << self.mask
+
+    def __rlshift__(self, value):
+        if isinstance(value, Bit):
+            value = value.mask
+        return self.mask << value
+
+    def __rshift__(self, value):
+        if isinstance(value, Bit):
+            value = value.mask
+        return value >> self.mask
+
+    def __rrshift__(self, value):
+        if isinstance(value, Bit):
+            value = value.mask
+        return self.mask >> value
+
+    def __xor__(self, value):
+        if isinstance(value, Bit):
+            value = value.mask
+        return value ^ self.mask
+
+    def __rxor__(self, value):
+        if isinstance(value, Bit):
+            value = value.mask
+        return self.mask ^ value
+
+    def __sentry__(self):
+        return repr(self)
+
+    def evaluate(self, evaluator, qn, connection):
+        return self.mask, []
+
+    def prepare(self, evaluator, query, allow_joins):
+        return evaluator.prepare_node(self, query, allow_joins)
+
+
+@implements_to_string
+class BitHandler(object):
+    """
+    Represents an array of bits, each as a ``Bit`` object.
+    """
+    def __init__(self, value, keys, labels=None):
+        # TODO: change to bitarray?
+        if value:
+            self._value = int(value)
+        else:
+            self._value = 0
+        self._keys = keys
+        self._labels = labels is not None and labels or keys
+
+    def __eq__(self, other):
+        if not isinstance(other, BitHandler):
+            return False
+        return self._value == other._value
+
+    def __lt__(self, other):
+        return int(self._value) < other
+
+    def __le__(self, other):
+        return int(self._value) <= other
+
+    def __gt__(self, other):
+        return int(self._value) > other
+
+    def __ge__(self, other):
+        return int(self._value) >= other
+
+    def __cmp__(self, other):
+        return cmp(self._value, other)
+
+    def __repr__(self):
+        return '<%s: %s>' % (self.__class__.__name__, ', '.join('%s=%s' % (k, self.get_bit(n).is_set) for n, k in enumerate(self._keys)),)
+
+    def __str__(self):
+        return six.texzt_type(self._value)
+
+    def __int__(self):
+        return self._value
+
+    def __bool__(self):
+        return bool(self._value)
+
+    __nonzero__ = __bool__
+
+    def __and__(self, value):
+        return BitHandler(self._value & int(value), self._keys)
+
+    def __or__(self, value):
+        return BitHandler(self._value | int(value), self._keys)
+
+    def __add__(self, value):
+        return BitHandler(self._value + int(value), self._keys)
+
+    def __sub__(self, value):
+        return BitHandler(self._value - int(value), self._keys)
+
+    def __lshift__(self, value):
+        return BitHandler(self._value << int(value), self._keys)
+
+    def __rshift__(self, value):
+        return BitHandler(self._value >> int(value), self._keys)
+
+    def __xor__(self, value):
+        return BitHandler(self._value ^ int(value), self._keys)
+
+    def __contains__(self, key):
+        bit_number = self._keys.index(key)
+        return bool(self.get_bit(bit_number))
+
+    def __getattr__(self, key):
+        if key.startswith('_'):
+            return object.__getattribute__(self, key)
+        if key not in self._keys:
+            raise AttributeError('%s is not a valid flag' % key)
+        return self.get_bit(self._keys.index(key))
+
+    def __setattr__(self, key, value):
+        if key.startswith('_'):
+            return object.__setattr__(self, key, value)
+        if key not in self._keys:
+            raise AttributeError('%s is not a valid flag' % key)
+        self.set_bit(self._keys.index(key), value)
+
+    def __iter__(self):
+        return self.iteritems()  # NOQA
+
+    def __sentry__(self):
+        return repr(self)
+
+    def _get_mask(self):
+        return self._value
+    mask = property(_get_mask)
+
+    def evaluate(self, evaluator, qn, connection):
+        return self.mask, []
+
+    def get_bit(self, bit_number):
+        mask = 2 ** int(bit_number)
+        return Bit(bit_number, self._value & mask != 0)
+
+    def set_bit(self, bit_number, true_or_false):
+        mask = 2 ** int(bit_number)
+        if true_or_false:
+            self._value |= mask
+        else:
+            self._value &= (~mask)
+        return Bit(bit_number, self._value & mask != 0)
+
+    def keys(self):
+        return self._keys
+
+    def iterkeys(self):
+        return iter(self._keys)
+
+    def items(self):
+        return list(self.iteritems())  # NOQA
+
+    def iteritems(self):
+        for k in self._keys:
+            yield (k, getattr(self, k).is_set)
+
+    def get_label(self, flag):
+        if isinstance(flag, string_types):
+            flag = self._keys.index(flag)
+        if isinstance(flag, Bit):
+            flag = flag.number
+        return self._labels[flag]
+
+
+if django.VERSION[:2] >= (1, 8):
+    from django.core.exceptions import ImproperlyConfigured
+
+    # We need to register adapters in Django 1.8 in order to prevent
+    # "ProgrammingError: can't adapt type"
+    try:
+        from django.db.backends.sqlite3.base import Database
+        Database.register_adapter(Bit, lambda x: int(x))
+        Database.register_adapter(BitHandler, lambda x: int(x))
+    except ImproperlyConfigured:
+        pass
+
+    try:
+        from django.db.backends.postgresql_psycopg2.base import Database
+        Database.extensions.register_adapter(Bit, lambda x: Database.extensions.AsIs(int(x)))
+        Database.extensions.register_adapter(BitHandler, lambda x: Database.extensions.AsIs(int(x)))
+    except ImproperlyConfigured:
+        pass
diff --git a/src/sentry/api/endpoints/event_apple_crash_report.py b/src/sentry/api/endpoints/event_apple_crash_report.py
index 8b1c3160fa..ab7107621e 100644
--- a/src/sentry/api/endpoints/event_apple_crash_report.py
+++ b/src/sentry/api/endpoints/event_apple_crash_report.py
@@ -2,7 +2,13 @@ from __future__ import absolute_import
 
 import six
 
-from django.http import HttpResponse, CompatibleStreamingHttpResponse
+try:
+    from django.http import (
+        HttpResponse,
+        CompatibleStreamingHttpResponse as StreamingHttpResponse
+    )
+except ImportError:
+    from django.http import HttpResponse, StreamingHttpResponse
 
 from sentry.api.base import Endpoint
 from sentry.api.bases.group import GroupPermission
@@ -71,7 +77,7 @@ class EventAppleCrashReportEndpoint(Endpoint):
                 event.event_id,
                 symbolicated and '-symbolicated' or ''
             )
-            response = CompatibleStreamingHttpResponse(
+            response = StreamingHttpResponse(
                 apple_crash_report_string,
                 content_type='text/plain',
             )
diff --git a/src/sentry/api/endpoints/group_details.py b/src/sentry/api/endpoints/group_details.py
index a7d30df128..c73ce65cdb 100644
--- a/src/sentry/api/endpoints/group_details.py
+++ b/src/sentry/api/endpoints/group_details.py
@@ -101,6 +101,7 @@ class GroupDetailsEndpoint(GroupEndpoint):
                 activity.append(item)
 
         activity.append(Activity(
+            id=0,
             project=group.project,
             group=group,
             type=Activity.FIRST_SEEN,
diff --git a/src/sentry/api/endpoints/organization_release_file_details.py b/src/sentry/api/endpoints/organization_release_file_details.py
index 2e7347127e..ec7b42f2d8 100644
--- a/src/sentry/api/endpoints/organization_release_file_details.py
+++ b/src/sentry/api/endpoints/organization_release_file_details.py
@@ -10,7 +10,12 @@ from sentry.api.bases.organization import OrganizationReleasesBaseEndpoint
 from sentry.api.exceptions import ResourceDoesNotExist
 from sentry.api.serializers import serialize
 from sentry.models import Release, ReleaseFile
-from django.http import CompatibleStreamingHttpResponse
+try:
+    from django.http import (
+        CompatibleStreamingHttpResponse as StreamingHttpResponse
+    )
+except ImportError:
+    from django.http import StreamingHttpResponse
 
 
 class ReleaseFileSerializer(serializers.Serializer):
@@ -23,7 +28,7 @@ class OrganizationReleaseFileDetailsEndpoint(OrganizationReleasesBaseEndpoint):
     def download(self, releasefile):
         file = releasefile.file
         fp = file.getfile()
-        response = CompatibleStreamingHttpResponse(
+        response = StreamingHttpResponse(
             iter(lambda: fp.read(4096), b''),
             content_type=file.headers.get('content-type', 'application/octet-stream'),
         )
diff --git a/src/sentry/api/endpoints/project_release_file_details.py b/src/sentry/api/endpoints/project_release_file_details.py
index e88e9377ee..708d8698e5 100644
--- a/src/sentry/api/endpoints/project_release_file_details.py
+++ b/src/sentry/api/endpoints/project_release_file_details.py
@@ -10,7 +10,12 @@ from sentry.api.exceptions import ResourceDoesNotExist
 from sentry.api.serializers import serialize
 from sentry.models import Release, ReleaseFile
 from sentry.utils.apidocs import scenario, attach_scenarios
-from django.http import CompatibleStreamingHttpResponse
+try:
+    from django.http import (
+        CompatibleStreamingHttpResponse as StreamingHttpResponse
+    )
+except ImportError:
+    from django.http import StreamingHttpResponse
 
 
 @scenario('RetrieveReleaseFile')
@@ -75,7 +80,7 @@ class ProjectReleaseFileDetailsEndpoint(ProjectEndpoint):
     def download(self, releasefile):
         file = releasefile.file
         fp = file.getfile()
-        response = CompatibleStreamingHttpResponse(
+        response = StreamingHttpResponse(
             iter(lambda: fp.read(4096), b''),
             content_type=file.headers.get('content-type', 'application/octet-stream'),
         )
diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index cc24806e34..4aa270c28f 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -293,10 +293,13 @@ INSTALLED_APPS = (
     'sentry.plugins.sentry_useragents',
     'sentry.plugins.sentry_webhooks',
     'social_auth',
-    'south',
     'sudo',
 )
 
+import django
+if django.VERSION < (1, 7):
+    INSTALLED_APPS += ('south',)
+
 STATIC_ROOT = os.path.realpath(os.path.join(PROJECT_ROOT, 'static'))
 STATIC_URL = '/_static/{version}/'
 
@@ -606,7 +609,7 @@ LOGGING = {
     'disable_existing_loggers': True,
     'handlers': {
         'null': {
-            'class': 'django.utils.log.NullHandler',
+            'class': 'logging.NullHandler',
         },
         'console': {
             'class': 'sentry.logging.handlers.StructLogHandler',
diff --git a/src/sentry/db/models/fields/array.py b/src/sentry/db/models/fields/array.py
index 345b3b3629..1969121a15 100644
--- a/src/sentry/db/models/fields/array.py
+++ b/src/sentry/db/models/fields/array.py
@@ -12,7 +12,6 @@ SOUTH = 'south' in settings.INSTALLED_APPS
 
 # Adapted from django-pgfields
 # https://github.com/lukesneeringer/django-pgfields/blob/master/django_pg/models/fields/array.py
-@six.add_metaclass(models.SubfieldBase)
 class ArrayField(models.Field):
     def __init__(self, of=models.TextField, **kwargs):
         # The `of` argument is a bit tricky once we need compatibility
@@ -102,3 +101,6 @@ class ArrayField(models.Field):
                 ),
             },
         )
+
+if hasattr(models, 'SubfieldBase'):
+    ArrayField = six.add_metaclass(models.SubfieldBase)(ArrayField)
diff --git a/src/sentry/db/models/fields/bounded.py b/src/sentry/db/models/fields/bounded.py
index 12fabf52c0..94d57732db 100644
--- a/src/sentry/db/models/fields/bounded.py
+++ b/src/sentry/db/models/fields/bounded.py
@@ -11,7 +11,6 @@ from __future__ import absolute_import
 from django.conf import settings
 from django.db import models
 from django.utils.translation import ugettext_lazy as _
-from south.modelsinspector import add_introspection_rules
 
 __all__ = (
     'BoundedAutoField', 'BoundedBigAutoField', 'BoundedIntegerField',
@@ -104,8 +103,11 @@ else:
         pass
 
 
-add_introspection_rules([], ["^sentry\.db\.models\.fields\.bounded\.BoundedAutoField"])
-add_introspection_rules([], ["^sentry\.db\.models\.fields\.bounded\.BoundedBigAutoField"])
-add_introspection_rules([], ["^sentry\.db\.models\.fields\.bounded\.BoundedIntegerField"])
-add_introspection_rules([], ["^sentry\.db\.models\.fields\.bounded\.BoundedBigIntegerField"])
-add_introspection_rules([], ["^sentry\.db\.models\.fields\.bounded\.BoundedPositiveIntegerField"])
+if 'south' in settings.INSTALLED_APPS:
+    from south.modelsinspector import add_introspection_rules
+
+    add_introspection_rules([], ["^sentry\.db\.models\.fields\.bounded\.BoundedAutoField"])
+    add_introspection_rules([], ["^sentry\.db\.models\.fields\.bounded\.BoundedBigAutoField"])
+    add_introspection_rules([], ["^sentry\.db\.models\.fields\.bounded\.BoundedIntegerField"])
+    add_introspection_rules([], ["^sentry\.db\.models\.fields\.bounded\.BoundedBigIntegerField"])
+    add_introspection_rules([], ["^sentry\.db\.models\.fields\.bounded\.BoundedPositiveIntegerField"])
diff --git a/src/sentry/db/models/fields/encrypted.py b/src/sentry/db/models/fields/encrypted.py
index 798a070760..d551e05bc4 100644
--- a/src/sentry/db/models/fields/encrypted.py
+++ b/src/sentry/db/models/fields/encrypted.py
@@ -9,15 +9,14 @@ __all__ = (
 
 import six
 
+from django.conf import settings
 from django.db import models
 from django.db.models import CharField, TextField
 from jsonfield import JSONField
 from picklefield.fields import PickledObjectField
 from sentry.utils.encryption import decrypt, encrypt
-from south.modelsinspector import add_introspection_rules
 
 
-@six.add_metaclass(models.SubfieldBase)
 class EncryptedCharField(CharField):
     def get_db_prep_value(self, value, *args, **kwargs):
         value = super(EncryptedCharField, self).get_db_prep_value(
@@ -74,7 +73,6 @@ class EncryptedPickledObjectField(PickledObjectField):
         ))
 
 
-@six.add_metaclass(models.SubfieldBase)
 class EncryptedTextField(TextField):
     def get_db_prep_value(self, value, *args, **kwargs):
         value = super(EncryptedTextField, self).get_db_prep_value(
@@ -93,7 +91,14 @@ class EncryptedTextField(TextField):
         ))
 
 
-add_introspection_rules([], ["^sentry\.db\.models\.fields\.encrypted\.EncryptedPickledObjectField"])
-add_introspection_rules([], ["^sentry\.db\.models\.fields\.encrypted\.EncryptedCharField"])
-add_introspection_rules([], ["^sentry\.db\.models\.fields\.encrypted\.EncryptedJsonField"])
-add_introspection_rules([], ["^sentry\.db\.models\.fields\.encrypted\.EncryptedTextField"])
+if hasattr(models, 'SubfieldBase'):
+    EncryptedCharField = six.add_metaclass(models.SubfieldBase)(EncryptedCharField)
+    EncryptedTextField = six.add_metaclass(models.SubfieldBase)(EncryptedTextField)
+
+if 'south' in settings.INSTALLED_APPS:
+    from south.modelsinspector import add_introspection_rules
+
+    add_introspection_rules([], ["^sentry\.db\.models\.fields\.encrypted\.EncryptedPickledObjectField"])
+    add_introspection_rules([], ["^sentry\.db\.models\.fields\.encrypted\.EncryptedCharField"])
+    add_introspection_rules([], ["^sentry\.db\.models\.fields\.encrypted\.EncryptedJsonField"])
+    add_introspection_rules([], ["^sentry\.db\.models\.fields\.encrypted\.EncryptedTextField"])
diff --git a/src/sentry/db/models/fields/foreignkey.py b/src/sentry/db/models/fields/foreignkey.py
index 68c3e0fbb5..565a8bab9c 100644
--- a/src/sentry/db/models/fields/foreignkey.py
+++ b/src/sentry/db/models/fields/foreignkey.py
@@ -8,8 +8,8 @@ sentry.db.models.fields.foreignkey
 
 from __future__ import absolute_import
 
+from django.conf import settings
 from django.db.models import ForeignKey
-from south.modelsinspector import add_introspection_rules
 
 __all__ = ('FlexibleForeignKey',)
 
@@ -23,7 +23,10 @@ class FlexibleForeignKey(ForeignKey):
         return super(FlexibleForeignKey, self).db_type(connection)
 
 
-add_introspection_rules([], [
-    "^sentry\.db\.models\.fields\.FlexibleForeignKey",
-    "^sentry\.db\.models\.fields\.foreignkey\.FlexibleForeignKey",
-])
+if 'south' in settings.INSTALLED_APPS:
+    from south.modelsinspector import add_introspection_rules
+
+    add_introspection_rules([], [
+        "^sentry\.db\.models\.fields\.FlexibleForeignKey",
+        "^sentry\.db\.models\.fields\.foreignkey\.FlexibleForeignKey",
+    ])
diff --git a/src/sentry/db/models/fields/gzippeddict.py b/src/sentry/db/models/fields/gzippeddict.py
index 57d789fca7..af849b3518 100644
--- a/src/sentry/db/models/fields/gzippeddict.py
+++ b/src/sentry/db/models/fields/gzippeddict.py
@@ -11,8 +11,8 @@ from __future__ import absolute_import, print_function
 import logging
 import six
 
+from django.conf import settings
 from django.db import models
-from south.modelsinspector import add_introspection_rules
 
 from sentry.utils.compat import pickle
 from sentry.utils.strings import decompress, compress
@@ -22,7 +22,6 @@ __all__ = ('GzippedDictField',)
 logger = logging.getLogger('sentry')
 
 
-@six.add_metaclass(models.SubfieldBase)
 class GzippedDictField(models.TextField):
     """
     Slightly different from a JSONField in the sense that the default
@@ -54,4 +53,10 @@ class GzippedDictField(models.TextField):
         return self.get_prep_value(value)
 
 
-add_introspection_rules([], ["^sentry\.db\.models\.fields\.gzippeddict\.GzippedDictField"])
+if hasattr(models, 'SubfieldBase'):
+    GzippedDictField = six.add_metaclass(models.SubfieldBase)(GzippedDictField)
+
+if 'south' in settings.INSTALLED_APPS:
+    from south.modelsinspector import add_introspection_rules
+
+    add_introspection_rules([], ["^sentry\.db\.models\.fields\.gzippeddict\.GzippedDictField"])
diff --git a/src/sentry/db/models/fields/node.py b/src/sentry/db/models/fields/node.py
index 0a7dc7b858..59ea3ce80e 100644
--- a/src/sentry/db/models/fields/node.py
+++ b/src/sentry/db/models/fields/node.py
@@ -16,7 +16,6 @@ import warnings
 from django.conf import settings
 from django.db import models
 from django.db.models.signals import post_delete
-from south.modelsinspector import add_introspection_rules
 
 from sentry import nodestore
 from sentry.utils.cache import memoize
@@ -111,7 +110,6 @@ class NodeData(collections.MutableMapping):
             self.data['_ref_version'] = self.field.ref_version
 
 
-@six.add_metaclass(models.SubfieldBase)
 class NodeField(GzippedDictField):
     """
     Similar to the gzippedictfield except that it stores a reference
@@ -171,5 +169,10 @@ class NodeField(GzippedDictField):
             'node_id': value.id
         }))
 
+if hasattr(models, 'SubfieldBase'):
+    NodeField = six.add_metaclass(models.SubfieldBase)(NodeField)
 
-add_introspection_rules([], ["^sentry\.db\.models\.fields\.node\.NodeField"])
+if 'south' in settings.INSTALLED_APPS:
+    from south.modelsinspector import add_introspection_rules
+
+    add_introspection_rules([], ["^sentry\.db\.models\.fields\.node\.NodeField"])
diff --git a/src/sentry/db/models/fields/pickle.py b/src/sentry/db/models/fields/pickle.py
index f2a06fee82..e030a86ac5 100644
--- a/src/sentry/db/models/fields/pickle.py
+++ b/src/sentry/db/models/fields/pickle.py
@@ -2,8 +2,8 @@ from __future__ import absolute_import
 
 import six
 
+from django.conf import settings
 from picklefield.fields import PickledObjectField
-from south.modelsinspector import add_introspection_rules
 
 
 class UnicodePickledObjectField(PickledObjectField):
@@ -14,4 +14,7 @@ class UnicodePickledObjectField(PickledObjectField):
             value, *args, **kwargs)
 
 
-add_introspection_rules([], ["^sentry\.db\.models\.fields\.pickle\.UnicodePickledObjectField"])
+if 'south' in settings.INSTALLED_APPS:
+    from south.modelsinspector import add_introspection_rules
+
+    add_introspection_rules([], ["^sentry\.db\.models\.fields\.pickle\.UnicodePickledObjectField"])
diff --git a/src/sentry/db/models/manager.py b/src/sentry/db/models/manager.py
index 6f23b15d7b..527909a16f 100644
--- a/src/sentry/db/models/manager.py
+++ b/src/sentry/db/models/manager.py
@@ -31,16 +31,6 @@ __all__ = ('BaseManager',)
 logger = logging.getLogger('sentry')
 
 
-class ImmutableDict(dict):
-    def __setitem__(self, key, value):
-        raise TypeError
-
-    def __delitem__(self, key):
-        raise TypeError
-
-UNSAVED = ImmutableDict()
-
-
 def __prep_value(model, key, value):
     if isinstance(value, Model):
         value = value.pk
@@ -135,8 +125,6 @@ class BaseManager(Manager):
                 f: self.__value_for_field(instance, f)
                 for f in self.cache_fields
             }
-        else:
-            self.__cache[instance] = UNSAVED
 
     def __post_init(self, instance, **kwargs):
         """
diff --git a/src/sentry/db/models/query.py b/src/sentry/db/models/query.py
index 340c2732cb..7d94428b86 100644
--- a/src/sentry/db/models/query.py
+++ b/src/sentry/db/models/query.py
@@ -13,11 +13,10 @@ import six
 
 from django.db import IntegrityError, router, transaction
 from django.db.models import Model, Q
-from django.db.models.expressions import ExpressionNode
 from django.db.models.signals import post_save
 from six.moves import reduce
 
-from .utils import resolve_expression_node
+from .utils import ExpressionNode, resolve_expression_node
 
 __all__ = ('update', 'create_or_update')
 
diff --git a/src/sentry/db/models/utils.py b/src/sentry/db/models/utils.py
index a9724fa0f0..441dc7f472 100644
--- a/src/sentry/db/models/utils.py
+++ b/src/sentry/db/models/utils.py
@@ -13,7 +13,10 @@ import operator
 from uuid import uuid4
 
 from django.db.models import F
-from django.db.models.expressions import ExpressionNode
+try:
+    from django.db.models.expressions import ExpressionNode
+except ImportError:
+    from django.db.models.expressions import Combinable as ExpressionNode
 from django.utils.crypto import get_random_string
 from django.template.defaultfilters import slugify
 
diff --git a/src/sentry/models/__init__.py b/src/sentry/models/__init__.py
index 97706700f0..6b49af3c97 100644
--- a/src/sentry/models/__init__.py
+++ b/src/sentry/models/__init__.py
@@ -7,9 +7,13 @@ sentry.models
 """
 from __future__ import absolute_import
 
+from django.conf import settings
+
 from sentry.utils.imports import import_submodules
-from south.modelsinspector import add_introspection_rules
 
 import_submodules(globals(), __name__, __path__)
 
-add_introspection_rules([], ["^social_auth\.fields\.JSONField"])
+if 'south' in settings.INSTALLED_APPS:
+    from south.modelsinspector import add_introspection_rules
+
+    add_introspection_rules([], ["^social_auth\.fields\.JSONField"])
diff --git a/src/sentry/models/counter.py b/src/sentry/models/counter.py
index e8ad0b2623..453b65b674 100644
--- a/src/sentry/models/counter.py
+++ b/src/sentry/models/counter.py
@@ -8,7 +8,9 @@ sentry.models.counter
 
 from __future__ import absolute_import
 
-from django.db import connection
+from django.conf import settings
+from django.db import connection, connections
+from django.db.models.signals import post_syncdb
 
 from sentry.db.models import (
     FlexibleForeignKey, Model, sane_repr, BoundedBigIntegerField
@@ -17,7 +19,7 @@ from sentry.utils import db
 
 
 class Counter(Model):
-    __core__ = False
+    __core__ = True
 
     project = FlexibleForeignKey('sentry.Project', unique=True)
     value = BoundedBigIntegerField()
@@ -80,3 +82,46 @@ def increment_project_counter(project, delta=1):
             raise AssertionError("Not implemented database engine path")
     finally:
         cur.close()
+
+
+# this must be idempotent because it seems to execute twice
+# (at least during test runs)
+def create_counter_function(db, created_models, **kwargs):
+    if 'postgres' not in settings.DATABASES[db]['ENGINE']:
+        return
+
+    if Counter not in created_models:
+        return
+
+    cursor = connections[db].cursor()
+    cursor.execute('''
+        create or replace function sentry_increment_project_counter(
+            project bigint, delta int) returns int as $$
+        declare
+          new_val int;
+        begin
+          loop
+            update sentry_projectcounter set value = value + delta
+             where project_id = project
+               returning value into new_val;
+            if found then
+              return new_val;
+            end if;
+            begin
+              insert into sentry_projectcounter(project_id, value)
+                   values (project, delta)
+                returning value into new_val;
+              return new_val;
+            exception when unique_violation then
+            end;
+          end loop;
+        end
+        $$ language plpgsql;
+    ''')
+
+
+post_syncdb.connect(
+    create_counter_function,
+    dispatch_uid='create_counter_function',
+    weak=False,
+)
diff --git a/src/sentry/receivers/users.py b/src/sentry/receivers/users.py
index fd3c3a8af3..f84d2f1a55 100644
--- a/src/sentry/receivers/users.py
+++ b/src/sentry/receivers/users.py
@@ -9,8 +9,12 @@ from sentry.models import User
 def create_first_user(app, created_models, verbosity, db, **kwargs):
     if User not in created_models:
         return
-    if not router.allow_syncdb(db, User):
-        return
+    if hasattr(router, 'allow_migrate'):
+        if not router.allow_migrate(db, User):
+            return
+    else:
+        if not router.allow_syncdb(db, User):
+            return
     if not kwargs.get('interactive', True):
         return
 
diff --git a/src/sentry/runner/initializer.py b/src/sentry/runner/initializer.py
index dfd727c9f0..b70aa2539c 100644
--- a/src/sentry/runner/initializer.py
+++ b/src/sentry/runner/initializer.py
@@ -242,7 +242,8 @@ def initialize_app(config, skip_backend_validation=False):
 
     configure_structlog()
 
-    fix_south(settings)
+    if 'south' in settings.INSTALLED_APPS:
+        fix_south(settings)
 
     apply_legacy_settings(settings)
 
@@ -483,5 +484,6 @@ def on_configure(config):
     """
     settings = config['settings']
 
-    skip_migration_if_applied(
-        settings, 'social_auth', 'social_auth_association')
+    if 'south' in settings.INSTALLED_APPS:
+        skip_migration_if_applied(
+            settings, 'social_auth', 'social_auth_association')
diff --git a/src/sentry/south_migrations/0241_auto__add_counter__add_unique_counter_project_ident__add_field_group_s.py b/src/sentry/south_migrations/0241_auto__add_counter__add_unique_counter_project_ident__add_field_group_s.py
index c09b993562..a123e54407 100644
--- a/src/sentry/south_migrations/0241_auto__add_counter__add_unique_counter_project_ident__add_field_group_s.py
+++ b/src/sentry/south_migrations/0241_auto__add_counter__add_unique_counter_project_ident__add_field_group_s.py
@@ -3,7 +3,6 @@ from south.utils import datetime_utils as datetime
 from south.db import db
 from south.v2 import SchemaMigration
 from django.db import models
-from django.conf import settings
 
 
 class Migration(SchemaMigration):
@@ -25,34 +24,6 @@ class Migration(SchemaMigration):
         # Adding unique constraint on 'Group', fields ['project', 'short_id']
         db.create_unique('sentry_groupedmessage', ['project_id', 'short_id'])
 
-        if 'postgres' in settings.DATABASES['default']['ENGINE']:
-            db.execute('''
-                create function sentry_increment_project_counter(
-                    project bigint, delta int) returns int as $$
-                declare
-                  new_val int;
-                begin
-                  loop
-                    update sentry_projectcounter set value = value + delta
-                     where project_id = project
-                       returning value into new_val;
-                    if found then
-                      return new_val;
-                    end if;
-                    begin
-                      insert into sentry_projectcounter(project_id, value)
-                           values (project, delta)
-                        returning value into new_val;
-                      return new_val;
-                    exception when unique_violation then
-                    end;
-                  end loop;
-                end
-                $$ language plpgsql;
-            ''')
-
-
-
     def backwards(self, orm):
         # Removing unique constraint on 'Group', fields ['project', 'short_id']
         db.delete_unique('sentry_groupedmessage', ['project_id', 'short_id'])
@@ -63,12 +34,6 @@ class Migration(SchemaMigration):
         # Deleting field 'Group.short_id'
         db.delete_column('sentry_groupedmessage', 'short_id')
 
-        if 'postgres' in settings.DATABASES['default']['ENGINE']:
-            db.execute('''
-                drop function sentry_increment_project_counter(
-                    bigint, int);
-            ''')
-
 
     models = {
         'sentry.activity': {
diff --git a/src/sentry/tasks/email.py b/src/sentry/tasks/email.py
index 827fa7fd03..a9913e723b 100644
--- a/src/sentry/tasks/email.py
+++ b/src/sentry/tasks/email.py
@@ -42,7 +42,7 @@ def process_inbound_email(mailfrom, group_id, payload):
     from sentry.web.forms import NewNoteForm
 
     try:
-        group = Group.objects.select_related('project', 'team').get(pk=group_id)
+        group = Group.objects.select_related('project').get(pk=group_id)
     except Group.DoesNotExist:
         logger.warning('Group does not exist: %d', group_id)
         return
diff --git a/src/sentry/utils/auth.py b/src/sentry/utils/auth.py
index d6115106be..5de478ba05 100644
--- a/src/sentry/utils/auth.py
+++ b/src/sentry/utils/auth.py
@@ -9,13 +9,13 @@ from __future__ import absolute_import
 
 import six
 import logging
-from time import time
 
 from django.conf import settings
 from django.contrib.auth import login as _login
 from django.contrib.auth.backends import ModelBackend
 from django.core.urlresolvers import reverse, resolve
 from sudo.utils import is_safe_url
+from time import time
 
 from sentry.models import User, Authenticator
 
@@ -87,6 +87,8 @@ def get_login_url(reset=False):
 
         if _LOGIN_URL is None:
             _LOGIN_URL = reverse('sentry-login')
+        # ensure type is coerced to string (to avoid lazy proxies)
+        _LOGIN_URL = six.text_type(_LOGIN_URL)
     return _LOGIN_URL
 
 
diff --git a/src/sentry/web/frontend/debug/mail.py b/src/sentry/web/frontend/debug/mail.py
index 4936a43963..84a1dbb66a 100644
--- a/src/sentry/web/frontend/debug/mail.py
+++ b/src/sentry/web/frontend/debug/mail.py
@@ -2,19 +2,19 @@ from __future__ import absolute_import, print_function
 
 import itertools
 import logging
+import six
 import time
 import traceback
 import uuid
-from datetime import datetime, timedelta
-from random import Random
 
-import six
-from django.contrib.webdesign.lorem_ipsum import WORDS
+from datetime import datetime, timedelta
 from django.core.urlresolvers import reverse
 from django.template.defaultfilters import slugify
 from django.utils import timezone
 from django.utils.safestring import mark_safe
 from django.views.generic import View
+from loremipsum import Generator
+from random import Random
 
 from sentry.app import tsdb
 from sentry.constants import LOG_LEVELS
@@ -36,6 +36,8 @@ from sentry.web.helpers import render_to_response, render_to_string
 
 logger = logging.getLogger(__name__)
 
+loremipsum = Generator()
+
 
 def get_random(request):
     seed = request.GET.get('seed', six.text_type(time.time()))
@@ -45,17 +47,17 @@ def get_random(request):
 def make_message(random, length=None):
     if length is None:
         length = int(random.weibullvariate(8, 3))
-    return ' '.join(random.choice(WORDS) for _ in range(length))
+    return ' '.join(random.choice(loremipsum.words) for _ in range(length))
 
 
 def make_culprit(random):
     def make_module_path_components(min, max):
         for _ in range(random.randint(min, max)):
-            yield ''.join(random.sample(WORDS, random.randint(1, int(random.paretovariate(2.2)))))
+            yield ''.join(random.sample(loremipsum.words, random.randint(1, int(random.paretovariate(2.2)))))
 
     return '{module} in {function}'.format(
         module='.'.join(make_module_path_components(1, 4)),
-        function=random.choice(WORDS)
+        function=random.choice(loremipsum.words,)
     )
 
 
@@ -64,7 +66,7 @@ def make_group_metadata(random, group):
         'type': 'error',
         'metadata': {
             'type': '{}Error'.format(
-                ''.join(word.title() for word in random.sample(WORDS, random.randint(1, 3))),
+                ''.join(word.title() for word in random.sample(loremipsum.words, random.randint(1, 3))),
             ),
             'value': make_message(random),
         }
@@ -411,10 +413,7 @@ def report(request):
     projects = []
     for i in xrange(0, random.randint(1, 8)):
         name = ' '.join(
-            random.sample(
-                WORDS,
-                random.randint(1, 4)
-            )
+            random.sample(loremipsum.words, random.randint(1, 4))
         )
         projects.append(
             Project(
diff --git a/src/sentry/web/frontend/group_event_json.py b/src/sentry/web/frontend/group_event_json.py
index 152579b865..3c80b02666 100644
--- a/src/sentry/web/frontend/group_event_json.py
+++ b/src/sentry/web/frontend/group_event_json.py
@@ -32,4 +32,5 @@ class GroupEventJsonView(ProjectView):
         Event.objects.bind_nodes([event], 'data')
         GroupMeta.objects.populate_cache([group])
 
-        return HttpResponse(json.dumps(event.as_dict()), mimetype='application/json')
+        return HttpResponse(json.dumps(event.as_dict()),
+                            content_type='application/json')
diff --git a/src/social_auth/backends/bitbucket.py b/src/social_auth/backends/bitbucket.py
index 4cb4e5150c..f0b22bdd2c 100644
--- a/src/social_auth/backends/bitbucket.py
+++ b/src/social_auth/backends/bitbucket.py
@@ -12,13 +12,8 @@ extend it.
 """
 from __future__ import absolute_import
 
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
+import simplejson
+
 from social_auth.backends import ConsumerBasedOAuth, OAuthBackend
 from social_auth.utils import dsa_urlopen
 
diff --git a/src/social_auth/backends/github.py b/src/social_auth/backends/github.py
index e88c6d72aa..898ef94381 100644
--- a/src/social_auth/backends/github.py
+++ b/src/social_auth/backends/github.py
@@ -16,13 +16,7 @@ field, check OAuthBackend class for details on how to extend it.
 """
 from __future__ import absolute_import
 
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
+import simplejson
 
 from django.conf import settings
 from six.moves.urllib.error import HTTPError
diff --git a/src/social_auth/backends/trello.py b/src/social_auth/backends/trello.py
index e6d9364abd..e38e353e45 100644
--- a/src/social_auth/backends/trello.py
+++ b/src/social_auth/backends/trello.py
@@ -14,13 +14,7 @@ into settings.py
 """
 from __future__ import absolute_import
 
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
+import simplejson
 
 from six.moves.urllib.parse import urlencode
 from social_auth.backends import ConsumerBasedOAuth, OAuthBackend
diff --git a/src/social_auth/backends/utils.py b/src/social_auth/backends/utils.py
index c140810a93..15bff57f0a 100644
--- a/src/social_auth/backends/utils.py
+++ b/src/social_auth/backends/utils.py
@@ -5,13 +5,7 @@ from oauth2 import (
     SignatureMethod_HMAC_SHA1, HTTP_METHOD
 )
 
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
+import simplejson
 
 from social_auth.models import UserSocialAuth
 from social_auth.utils import dsa_urlopen
diff --git a/src/social_auth/fields.py b/src/social_auth/fields.py
index 9016707c4f..1b2f2b033b 100644
--- a/src/social_auth/fields.py
+++ b/src/social_auth/fields.py
@@ -1,11 +1,11 @@
 from __future__ import absolute_import
 
+import simplejson
 import six
 
 from django.core.exceptions import ValidationError
 from django.db import models
 from django.utils.encoding import smart_text
-from django.utils import simplejson
 
 
 @six.add_metaclass(models.SubfieldBase)
diff --git a/tests/bitfield/__init__.py b/tests/bitfield/__init__.py
new file mode 100644
index 0000000000..c3961685ab
--- /dev/null
+++ b/tests/bitfield/__init__.py
@@ -0,0 +1 @@
+from __future__ import absolute_import
diff --git a/tests/bitfield/forms.py b/tests/bitfield/forms.py
new file mode 100644
index 0000000000..aa6263f2c7
--- /dev/null
+++ b/tests/bitfield/forms.py
@@ -0,0 +1,11 @@
+from __future__ import absolute_import
+
+from django import forms
+
+from bitfield.tests.models import BitFieldTestModel
+
+
+class BitFieldTestModelForm(forms.ModelForm):
+    class Meta:
+        model = BitFieldTestModel
+        exclude = tuple()
diff --git a/tests/bitfield/models.py b/tests/bitfield/models.py
new file mode 100644
index 0000000000..66f3002d53
--- /dev/null
+++ b/tests/bitfield/models.py
@@ -0,0 +1,33 @@
+from __future__ import absolute_import
+
+from django.db import models
+
+from bitfield import BitField, CompositeBitField
+
+
+class BitFieldTestModel(models.Model):
+    flags = BitField(flags=(
+        'FLAG_0',
+        'FLAG_1',
+        'FLAG_2',
+        'FLAG_3',
+    ), default=3, db_column='another_name')
+
+
+class CompositeBitFieldTestModel(models.Model):
+    flags_1 = BitField(flags=(
+        'FLAG_0',
+        'FLAG_1',
+        'FLAG_2',
+        'FLAG_3',
+    ), default=0)
+    flags_2 = BitField(flags=(
+        'FLAG_4',
+        'FLAG_5',
+        'FLAG_6',
+        'FLAG_7',
+    ), default=0)
+    flags = CompositeBitField((
+        'flags_1',
+        'flags_2',
+    ))
diff --git a/tests/bitfield/tests.py b/tests/bitfield/tests.py
new file mode 100644
index 0000000000..d2b72ed6f5
--- /dev/null
+++ b/tests/bitfield/tests.py
@@ -0,0 +1,391 @@
+from __future__ import absolute_import
+
+import pickle
+import six
+
+from django.db import connection, models
+from django.db.models import F
+from django.test import TestCase
+
+from bitfield import Bit, BitField, BitHandler
+from bitfield.compat import bitand, bitor
+
+from .forms import BitFieldTestModelForm
+from .models import BitFieldTestModel, CompositeBitFieldTestModel
+
+
+class BitHandlerTest(TestCase):
+    def test_comparison(self):
+        bithandler_1 = BitHandler(0, ('FLAG_0', 'FLAG_1', 'FLAG_2', 'FLAG_3'))
+        bithandler_2 = BitHandler(1, ('FLAG_0', 'FLAG_1', 'FLAG_2', 'FLAG_3'))
+        bithandler_3 = BitHandler(0, ('FLAG_0', 'FLAG_1', 'FLAG_2', 'FLAG_3'))
+        assert bithandler_1 == bithandler_1
+        assert bithandler_1 != bithandler_2
+        assert bithandler_1 == bithandler_3
+
+    def test_defaults(self):
+        bithandler = BitHandler(0, ('FLAG_0', 'FLAG_1', 'FLAG_2', 'FLAG_3'))
+        # Default value of 0.
+        self.assertEquals(int(bithandler), 0)
+        # Test bit numbers.
+        self.assertEquals(int(bithandler.FLAG_0.number), 0)
+        self.assertEquals(int(bithandler.FLAG_1.number), 1)
+        self.assertEquals(int(bithandler.FLAG_2.number), 2)
+        self.assertEquals(int(bithandler.FLAG_3.number), 3)
+        # Negative test non-existant key.
+        self.assertRaises(AttributeError, lambda: bithandler.FLAG_4)
+        # Test bool().
+        self.assertEquals(bool(bithandler.FLAG_0), False)
+        self.assertEquals(bool(bithandler.FLAG_1), False)
+        self.assertEquals(bool(bithandler.FLAG_2), False)
+        self.assertEquals(bool(bithandler.FLAG_3), False)
+
+    def test_nonzero_default(self):
+        bithandler = BitHandler(1, ('FLAG_0', 'FLAG_1', 'FLAG_2', 'FLAG_3'))
+        self.assertEquals(bool(bithandler.FLAG_0), True)
+        self.assertEquals(bool(bithandler.FLAG_1), False)
+        self.assertEquals(bool(bithandler.FLAG_2), False)
+        self.assertEquals(bool(bithandler.FLAG_3), False)
+
+        bithandler = BitHandler(2, ('FLAG_0', 'FLAG_1', 'FLAG_2', 'FLAG_3'))
+        self.assertEquals(bool(bithandler.FLAG_0), False)
+        self.assertEquals(bool(bithandler.FLAG_1), True)
+        self.assertEquals(bool(bithandler.FLAG_2), False)
+        self.assertEquals(bool(bithandler.FLAG_3), False)
+
+        bithandler = BitHandler(3, ('FLAG_0', 'FLAG_1', 'FLAG_2', 'FLAG_3'))
+        self.assertEquals(bool(bithandler.FLAG_0), True)
+        self.assertEquals(bool(bithandler.FLAG_1), True)
+        self.assertEquals(bool(bithandler.FLAG_2), False)
+        self.assertEquals(bool(bithandler.FLAG_3), False)
+
+        bithandler = BitHandler(4, ('FLAG_0', 'FLAG_1', 'FLAG_2', 'FLAG_3'))
+        self.assertEquals(bool(bithandler.FLAG_0), False)
+        self.assertEquals(bool(bithandler.FLAG_1), False)
+        self.assertEquals(bool(bithandler.FLAG_2), True)
+        self.assertEquals(bool(bithandler.FLAG_3), False)
+
+    def test_mutation(self):
+        bithandler = BitHandler(0, ('FLAG_0', 'FLAG_1', 'FLAG_2', 'FLAG_3'))
+        self.assertEquals(bool(bithandler.FLAG_0), False)
+        self.assertEquals(bool(bithandler.FLAG_1), False)
+        self.assertEquals(bool(bithandler.FLAG_2), False)
+        self.assertEquals(bool(bithandler.FLAG_3), False)
+
+        bithandler = BitHandler(bithandler | 1, bithandler._keys)
+        self.assertEquals(bool(bithandler.FLAG_0), True)
+        self.assertEquals(bool(bithandler.FLAG_1), False)
+        self.assertEquals(bool(bithandler.FLAG_2), False)
+        self.assertEquals(bool(bithandler.FLAG_3), False)
+
+        bithandler ^= 3
+        self.assertEquals(int(bithandler), 2)
+
+        self.assertEquals(bool(bithandler & 1), False)
+
+        bithandler.FLAG_0 = False
+        self.assertEquals(bithandler.FLAG_0, False)
+
+        bithandler.FLAG_1 = True
+        self.assertEquals(bithandler.FLAG_0, False)
+        self.assertEquals(bithandler.FLAG_1, True)
+
+        bithandler.FLAG_2 = False
+        self.assertEquals(bithandler.FLAG_0, False)
+        self.assertEquals(bithandler.FLAG_1, True)
+        self.assertEquals(bithandler.FLAG_2, False)
+
+
+class BitTest(TestCase):
+    def test_int(self):
+        bit = Bit(0)
+        self.assertEquals(int(bit), 1)
+        self.assertEquals(bool(bit), True)
+        self.assertFalse(not bit)
+
+    def test_comparison(self):
+        self.assertEquals(Bit(0), Bit(0))
+        self.assertNotEquals(Bit(1), Bit(0))
+        self.assertNotEquals(Bit(0, 0), Bit(0, 1))
+        self.assertEquals(Bit(0, 1), Bit(0, 1))
+        self.assertEquals(Bit(0), 1)
+
+    def test_and(self):
+        self.assertEquals(1 & Bit(2), 0)
+        self.assertEquals(1 & Bit(0), 1)
+        self.assertEquals(1 & ~Bit(0), 0)
+        self.assertEquals(Bit(0) & Bit(2), 0)
+        self.assertEquals(Bit(0) & Bit(0), 1)
+        self.assertEquals(Bit(0) & ~Bit(0), 0)
+
+    def test_or(self):
+        self.assertEquals(1 | Bit(2), 5)
+        self.assertEquals(1 | Bit(5), 33)
+        self.assertEquals(1 | ~Bit(2), -5)
+        self.assertEquals(Bit(0) | Bit(2), 5)
+        self.assertEquals(Bit(0) | Bit(5), 33)
+        self.assertEquals(Bit(0) | ~Bit(2), -5)
+
+    def test_xor(self):
+        self.assertEquals(1 ^ Bit(2), 5)
+        self.assertEquals(1 ^ Bit(0), 0)
+        self.assertEquals(1 ^ Bit(1), 3)
+        self.assertEquals(1 ^ Bit(5), 33)
+        self.assertEquals(1 ^ ~Bit(2), -6)
+        self.assertEquals(Bit(0) ^ Bit(2), 5)
+        self.assertEquals(Bit(0) ^ Bit(0), 0)
+        self.assertEquals(Bit(0) ^ Bit(1), 3)
+        self.assertEquals(Bit(0) ^ Bit(5), 33)
+        self.assertEquals(Bit(0) ^ ~Bit(2), -6)
+
+
+class BitFieldTest(TestCase):
+    def test_basic(self):
+        # Create instance and make sure flags are working properly.
+        instance = BitFieldTestModel.objects.create(flags=1)
+        self.assertTrue(instance.flags.FLAG_0)
+        self.assertFalse(instance.flags.FLAG_1)
+        self.assertFalse(instance.flags.FLAG_2)
+        self.assertFalse(instance.flags.FLAG_3)
+
+    def test_regression_1425(self):
+        # Creating new instances shouldn't allow negative values.
+        instance = BitFieldTestModel.objects.create(flags=-1)
+        self.assertEqual(instance.flags._value, 15)
+        self.assertTrue(instance.flags.FLAG_0)
+        self.assertTrue(instance.flags.FLAG_1)
+        self.assertTrue(instance.flags.FLAG_2)
+        self.assertTrue(instance.flags.FLAG_3)
+
+        cursor = connection.cursor()
+        flags_field = BitFieldTestModel._meta.get_field('flags')
+        flags_db_column = flags_field.db_column or flags_field.name
+        cursor.execute("INSERT INTO %s (%s) VALUES (-1)" % (BitFieldTestModel._meta.db_table, flags_db_column))
+        # There should only be the one row we inserted through the cursor.
+        instance = BitFieldTestModel.objects.get(flags=-1)
+        self.assertTrue(instance.flags.FLAG_0)
+        self.assertTrue(instance.flags.FLAG_1)
+        self.assertTrue(instance.flags.FLAG_2)
+        self.assertTrue(instance.flags.FLAG_3)
+        instance.save()
+
+        self.assertEqual(BitFieldTestModel.objects.filter(flags=15).count(), 2)
+        self.assertEqual(BitFieldTestModel.objects.filter(flags__lt=0).count(), 0)
+
+    def test_select(self):
+        BitFieldTestModel.objects.create(flags=3)
+        self.assertTrue(BitFieldTestModel.objects.filter(flags=BitFieldTestModel.flags.FLAG_1).exists())
+        self.assertTrue(BitFieldTestModel.objects.filter(flags=BitFieldTestModel.flags.FLAG_0).exists())
+        self.assertFalse(BitFieldTestModel.objects.exclude(flags=BitFieldTestModel.flags.FLAG_0).exists())
+        self.assertFalse(BitFieldTestModel.objects.exclude(flags=BitFieldTestModel.flags.FLAG_1).exists())
+
+    def test_update(self):
+        instance = BitFieldTestModel.objects.create(flags=0)
+        self.assertFalse(instance.flags.FLAG_0)
+
+        BitFieldTestModel.objects.filter(pk=instance.pk).update(flags=bitor(F('flags'), BitFieldTestModel.flags.FLAG_1))
+        instance = BitFieldTestModel.objects.get(pk=instance.pk)
+        self.assertTrue(instance.flags.FLAG_1)
+
+        BitFieldTestModel.objects.filter(pk=instance.pk).update(flags=bitor(F('flags'), ((~BitFieldTestModel.flags.FLAG_0 | BitFieldTestModel.flags.FLAG_3))))
+        instance = BitFieldTestModel.objects.get(pk=instance.pk)
+        self.assertFalse(instance.flags.FLAG_0)
+        self.assertTrue(instance.flags.FLAG_1)
+        self.assertTrue(instance.flags.FLAG_3)
+        self.assertFalse(BitFieldTestModel.objects.filter(flags=BitFieldTestModel.flags.FLAG_0).exists())
+
+        BitFieldTestModel.objects.filter(pk=instance.pk).update(flags=bitand(F('flags'), ~BitFieldTestModel.flags.FLAG_3))
+        instance = BitFieldTestModel.objects.get(pk=instance.pk)
+        self.assertFalse(instance.flags.FLAG_0)
+        self.assertTrue(instance.flags.FLAG_1)
+        self.assertFalse(instance.flags.FLAG_3)
+
+    def test_update_with_handler(self):
+        instance = BitFieldTestModel.objects.create(flags=0)
+        self.assertFalse(instance.flags.FLAG_0)
+
+        instance.flags.FLAG_1 = True
+
+        BitFieldTestModel.objects.filter(pk=instance.pk).update(flags=bitor(F('flags'), instance.flags))
+        instance = BitFieldTestModel.objects.get(pk=instance.pk)
+        self.assertTrue(instance.flags.FLAG_1)
+
+    def test_negate(self):
+        BitFieldTestModel.objects.create(flags=BitFieldTestModel.flags.FLAG_0 | BitFieldTestModel.flags.FLAG_1)
+        BitFieldTestModel.objects.create(flags=BitFieldTestModel.flags.FLAG_1)
+        self.assertEqual(BitFieldTestModel.objects.filter(flags=~BitFieldTestModel.flags.FLAG_0).count(), 1)
+        self.assertEqual(BitFieldTestModel.objects.filter(flags=~BitFieldTestModel.flags.FLAG_1).count(), 0)
+        self.assertEqual(BitFieldTestModel.objects.filter(flags=~BitFieldTestModel.flags.FLAG_2).count(), 2)
+
+    def test_default_value(self):
+        instance = BitFieldTestModel.objects.create()
+        self.assertTrue(instance.flags.FLAG_0)
+        self.assertTrue(instance.flags.FLAG_1)
+        self.assertFalse(instance.flags.FLAG_2)
+        self.assertFalse(instance.flags.FLAG_3)
+
+    def test_binary_capacity(self):
+        import math
+        from django.db.models.fields import BigIntegerField
+        # Local maximum value, slow canonical algorithm
+        MAX_COUNT = int(math.floor(math.log(BigIntegerField.MAX_BIGINT, 2)))
+
+        # Big flags list
+        flags = ['f' + six.text_type(i) for i in range(100)]
+
+        try:
+            BitField(flags=flags[:MAX_COUNT])
+        except ValueError:
+            self.fail("It should work well with these flags")
+
+        self.assertRaises(ValueError, BitField, flags=flags[:(MAX_COUNT + 1)])
+
+    def test_dictionary_init(self):
+        flags = {
+            0: 'zero',
+            1: 'first',
+            10: 'tenth',
+            2: 'second',
+
+            'wrongkey': 'wrongkey',
+            100: 'bigkey',
+            -100: 'smallkey',
+        }
+
+        try:
+            bf = BitField(flags)
+        except ValueError:
+            self.fail("It should work well with these flags")
+
+        self.assertEquals(bf.flags, ['zero', 'first', 'second', '', '', '', '', '', '', '', 'tenth'])
+        self.assertRaises(ValueError, BitField, flags={})
+        self.assertRaises(ValueError, BitField, flags={'wrongkey': 'wrongkey'})
+        self.assertRaises(ValueError, BitField, flags={'1': 'non_int_key'})
+
+    def test_defaults_as_key_names(self):
+        class TestModel(models.Model):
+            flags = BitField(flags=(
+                'FLAG_0',
+                'FLAG_1',
+                'FLAG_2',
+                'FLAG_3',
+            ), default=('FLAG_1', 'FLAG_2'))
+        field = TestModel._meta.get_field('flags')
+        self.assertEquals(field.default, TestModel.flags.FLAG_1 | TestModel.flags.FLAG_2)
+
+
+class BitFieldSerializationTest(TestCase):
+    def test_can_unserialize_bithandler(self):
+        bf = BitFieldTestModel()
+        bf.flags.FLAG_0 = 1
+        bf.flags.FLAG_1 = 0
+        data = pickle.dumps(bf)
+        inst = pickle.loads(data)
+        self.assertTrue(inst.flags.FLAG_0)
+        self.assertFalse(inst.flags.FLAG_1)
+
+    def test_pickle_integration(self):
+        inst = BitFieldTestModel.objects.create(flags=1)
+        data = pickle.dumps(inst)
+        inst = pickle.loads(data)
+        self.assertEquals(type(inst.flags), BitHandler)
+        self.assertEquals(int(inst.flags), 1)
+
+    def test_added_field(self):
+        bf = BitFieldTestModel()
+        bf.flags.FLAG_0 = 1
+        bf.flags.FLAG_1 = 0
+        bf.flags.FLAG_3 = 0
+        data = pickle.dumps(bf)
+        inst = pickle.loads(data)
+        self.assertTrue('FLAG_3' in inst.flags.keys())
+
+
+class CompositeBitFieldTest(TestCase):
+    def test_get_flag(self):
+        inst = CompositeBitFieldTestModel()
+        self.assertEqual(inst.flags.FLAG_0, inst.flags_1.FLAG_0)
+        self.assertEqual(inst.flags.FLAG_4, inst.flags_2.FLAG_4)
+        self.assertRaises(AttributeError, lambda: inst.flags.flag_NA)
+
+    def test_set_flag(self):
+        inst = CompositeBitFieldTestModel()
+
+        flag_0_original = bool(inst.flags.FLAG_0)
+        self.assertEqual(bool(inst.flags_1.FLAG_0), flag_0_original)
+        flag_4_original = bool(inst.flags.FLAG_4)
+        self.assertEqual(bool(inst.flags_2.FLAG_4), flag_4_original)
+
+        # flip flags' bits
+        inst.flags.FLAG_0 = not flag_0_original
+        inst.flags.FLAG_4 = not flag_4_original
+
+        # check to make sure the bit flips took effect
+        self.assertNotEqual(bool(inst.flags.FLAG_0), flag_0_original)
+        self.assertNotEqual(bool(inst.flags_1.FLAG_0), flag_0_original)
+        self.assertNotEqual(bool(inst.flags.FLAG_4), flag_4_original)
+        self.assertNotEqual(bool(inst.flags_2.FLAG_4), flag_4_original)
+
+        def set_flag():
+            inst.flags.flag_NA = False
+        self.assertRaises(AttributeError, set_flag)
+
+    def test_hasattr(self):
+        inst = CompositeBitFieldTestModel()
+        self.assertEqual(hasattr(inst.flags, 'flag_0'),
+            hasattr(inst.flags_1, 'flag_0'))
+        self.assertEqual(hasattr(inst.flags, 'flag_4'),
+            hasattr(inst.flags_2, 'flag_4'))
+
+
+class BitFormFieldTest(TestCase):
+    def test_form_new_invalid(self):
+        invalid_data_dicts = [
+            {'flags': ['FLAG_0', 'FLAG_FLAG']},
+            {'flags': ['FLAG_4']},
+            {'flags': [1, 2]}
+        ]
+        for invalid_data in invalid_data_dicts:
+            form = BitFieldTestModelForm(data=invalid_data)
+            self.assertFalse(form.is_valid())
+
+    def test_form_new(self):
+        data_dicts = [
+            {'flags': ['FLAG_0', 'FLAG_1']},
+            {'flags': ['FLAG_3']},
+            {'flags': []},
+            {}
+        ]
+        for data in data_dicts:
+            form = BitFieldTestModelForm(data=data)
+            self.failUnless(form.is_valid())
+            instance = form.save()
+            flags = data['flags'] if 'flags' in data else []
+            for k in BitFieldTestModel.flags:
+                self.assertEquals(bool(getattr(instance.flags, k)), k in flags)
+
+    def test_form_update(self):
+        instance = BitFieldTestModel.objects.create(flags=0)
+        for k in BitFieldTestModel.flags:
+            self.assertFalse(bool(getattr(instance.flags, k)))
+
+        data = {'flags': ['FLAG_0', 'FLAG_1']}
+        form = BitFieldTestModelForm(data=data, instance=instance)
+        self.failUnless(form.is_valid())
+        instance = form.save()
+        for k in BitFieldTestModel.flags:
+            self.assertEquals(bool(getattr(instance.flags, k)), k in data['flags'])
+
+        data = {'flags': ['FLAG_2', 'FLAG_3']}
+        form = BitFieldTestModelForm(data=data, instance=instance)
+        self.failUnless(form.is_valid())
+        instance = form.save()
+        for k in BitFieldTestModel.flags:
+            self.assertEquals(bool(getattr(instance.flags, k)), k in data['flags'])
+
+        data = {'flags': []}
+        form = BitFieldTestModelForm(data=data, instance=instance)
+        self.failUnless(form.is_valid())
+        instance = form.save()
+        for k in BitFieldTestModel.flags:
+            self.assertFalse(bool(getattr(instance.flags, k)))

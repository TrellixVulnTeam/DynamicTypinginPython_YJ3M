commit 62cda005010a7a4405f806ed84d8298359d6df0f
Author: David Cramer <dcramer@gmail.com>
Date:   Thu Dec 29 02:50:03 2011 -0800

    Refactor to services.
    
    Cleans up the daemon code as well as improves upon the start command.

diff --git a/docs/cli/index.rst b/docs/cli/index.rst
index 6d11ea2154..c9064f1e3e 100644
--- a/docs/cli/index.rst
+++ b/docs/cli/index.rst
@@ -10,7 +10,7 @@ for help on a specific command.
 Builtin Commands
 ----------------
 
-.. data:: sentry.commands.start
+.. data:: start
 
     Starts all background services.
 
@@ -18,23 +18,19 @@ Builtin Commands
 
         sentry start --daemon
 
-.. data:: sentry.commands.stop
+.. data:: stop
 
     Stops all background services.
 
-.. data:: sentry.commands.restart
-
-    Restarts all background services
-
-.. data:: sentry.commands.upgrade
+.. data:: upgrade
 
     Performs any needed database migrations.
 
-.. data:: sentry.commands.cleanup
+.. data:: cleanup
 
     Performs all trim operations based on your configuration.
 
-.. data:: sentry.commands.manage
+.. data:: manage
 
     A wrapper around ``django-admin.py`` (aka ``manage.py``).
 
diff --git a/sentry/commands/__init__.py b/sentry/commands/__init__.py
index fddff3e2a6..948662d53a 100644
--- a/sentry/commands/__init__.py
+++ b/sentry/commands/__init__.py
@@ -7,7 +7,5 @@ sentry.commands
 """
 from sentry.commands.cleanup import cleanup
 from sentry.commands.manage import manage
-from sentry.commands.restart import restart
-from sentry.commands.start import start
-from sentry.commands.stop import stop
+from sentry.commands.control import start, stop
 from sentry.commands.upgrade import upgrade
diff --git a/sentry/commands/control.py b/sentry/commands/control.py
new file mode 100644
index 0000000000..e17c16add1
--- /dev/null
+++ b/sentry/commands/control.py
@@ -0,0 +1,86 @@
+"""
+sentry.commands.control
+~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+from sentry.commands.utils import options, opt, consume_args
+from sentry.services import http, worker, daemon
+import os
+import os.path
+
+
+services = {
+    'http': http.SentryHTTPServer,
+    'worker': worker.SentryWorker,
+}
+
+
+def get_service_from_args(args):
+    if len(args) == 2:
+        service = args[1]
+    else:
+        service = 'http'
+
+    if service not in services:
+        raise ValueError(service)
+
+    return service
+
+
+def get_daemon_for_service(service, daemonize=True, **options):
+    from sentry.conf import settings
+
+    service_class = services[service]
+
+    app = service_class(**options)
+
+    kwargs = {
+        'app': app,
+        'detach_process': daemonize,
+    }
+    if daemonize:
+        log = open(os.path.join(settings.LOG_DIR, '%s.log' % (service,)), 'w+')
+        kwargs.update({
+            'pidfile': os.path.join(settings.RUN_DIR, '%s.pid' % (service,)),
+            'stderr': log,
+            'stdout': log,
+        })
+
+    proc = daemon.Daemon(**kwargs)
+
+    return proc
+
+
+@options(
+    opt('--daemon', '-d', action='store_true', default=False, dest='daemonize'),
+    opt('--no-daemon', '-f', action='store_false', default=False, dest='daemonize'),
+    opt('--debug', action='store_true', default=False, dest='debug'),
+)
+@consume_args
+def start(args, daemonize=False, debug=False):
+    from sentry.conf import settings
+
+    service = get_service_from_args(args)
+
+    if not os.path.exists(settings.LOG_DIR):
+        os.makedirs(settings.LOG_DIR)
+
+    if not os.path.exists(settings.RUN_DIR):
+        os.makedirs(settings.RUN_DIR)
+
+    proc = get_daemon_for_service(service, daemonize, debug=debug)
+
+    proc.start()
+
+
+@consume_args
+def stop(args):
+    # TODO: we should improve upon this so it just discovers the PID
+    # for an app and sends the signal
+    service = get_service_from_args(args)
+
+    proc = get_daemon_for_service(service)
+
+    proc.stop()
diff --git a/sentry/commands/restart.py b/sentry/commands/restart.py
deleted file mode 100644
index e3077e1844..0000000000
--- a/sentry/commands/restart.py
+++ /dev/null
@@ -1,14 +0,0 @@
-"""
-sentry.commands.restart
-~~~~~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-
-
-def restart():
-    from sentry.utils.server import SentryServer
-
-    app = SentryServer()
-    app.execute('restart')
diff --git a/sentry/commands/start.py b/sentry/commands/start.py
deleted file mode 100644
index 7d93c9a09c..0000000000
--- a/sentry/commands/start.py
+++ /dev/null
@@ -1,57 +0,0 @@
-"""
-sentry.commands.start
-~~~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-from sentry.commands.utils import options, opt
-
-
-class SentryWorker(object):
-    def __init__(self, **kwargs):
-        pass
-
-    def execute(self, command):
-        assert command in ('start',)
-
-        getattr(self, command)()
-
-    def start(self):
-        from sentry.queue.client import broker
-        from sentry.queue.worker import Worker
-
-        from kombu.utils.debug import setup_logging
-        setup_logging(loglevel="INFO")
-
-        from sentry.queue.tasks import test
-        broker.delay(test, args=('foo',), kwargs={'bar': 'baz'})
-        broker.delay(test, args=('foo',), kwargs={'bar': 'baz'})
-        broker.delay(test, args=('foo',), kwargs={'bar': 'baz'})
-        broker.delay(test, args=('foo',), kwargs={'bar': 'baz'})
-
-        try:
-            Worker(broker.connection).run()
-        except KeyboardInterrupt:
-            print("bye bye")
-
-
-@options(
-    opt('--background', action='store_true', default=False, dest='daemonize'),
-    opt('--foreground', action='store_false', default=False, dest='daemonize'),
-    opt('--debug', action='store_true', default=False, dest='debug'),
-    opt('--service', dest='service', default='http', choices=['http', 'worker']),
-)
-def start(daemonize=False, debug=False, service='http'):
-    from sentry.utils import server
-    app_class = {
-        'http': server.SentryHTTPServer,
-        'worker': SentryWorker,
-    }[service]
-
-    # TODO: daemonize should generically daemonize any subproc
-    app = app_class(
-        daemonize=daemonize,
-        debug=debug,
-    )
-    app.execute('start')
diff --git a/sentry/commands/stop.py b/sentry/commands/stop.py
deleted file mode 100644
index 3f3f0c1eb2..0000000000
--- a/sentry/commands/stop.py
+++ /dev/null
@@ -1,20 +0,0 @@
-"""
-sentry.commands.stop
-~~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-from sentry.commands.utils import options, opt
-
-
-@options(
-    opt('--pidfile', dest='pidfile'),
-)
-def stop(pidfile=None):
-    from sentry.utils.server import SentryServer
-
-    app = SentryServer(
-        pidfile=options.pidfile,
-    )
-    app.execute('stop')
diff --git a/sentry/conf/defaults.py b/sentry/conf/defaults.py
index 9d1c1257b3..aa4ca0356b 100644
--- a/sentry/conf/defaults.py
+++ b/sentry/conf/defaults.py
@@ -70,18 +70,20 @@ MAIL_EXCLUDE_LOGGERS = []
 # accuracy provided.
 MINUTE_NORMALIZATION = 15
 
+# The number of events to display per page
+MESSAGES_PER_PAGE = 15
+
+# Directory to stash log files in
+LOG_DIR = os.path.join(ROOT, 'log')
+
+# Directory to stash pid files in
+RUN_DIR = os.path.join(ROOT, 'run')
+
+# Web Service
 WEB_HOST = 'localhost'
 WEB_PORT = 9000
-WEB_LOG_FILE = os.path.join(ROOT, 'sentry.log')
-WEB_PID_FILE = os.path.join(ROOT, 'sentry.pid')
-
-MESSAGES_PER_PAGE = 15
 
+# Queue (Kombu)
 QUEUE = {
     'transport': 'djkombu.transport.DatabaseTransport',
-# BROKER_HOST = 'localhost',
-# BROKER_PORT = 5672
-# BROKER_USER = "guest"
-# BROKER_PASSWORD = "guest"
-# BROKER_VHOST = "/"
 }
diff --git a/sentry/core/__init__.py b/sentry/core/__init__.py
new file mode 100644
index 0000000000..83285d237b
--- /dev/null
+++ b/sentry/core/__init__.py
@@ -0,0 +1,7 @@
+"""
+sentry.core
+~~~~~~~~~~~
+
+:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
diff --git a/sentry/services/__init__.py b/sentry/services/__init__.py
new file mode 100644
index 0000000000..cb43fe9904
--- /dev/null
+++ b/sentry/services/__init__.py
@@ -0,0 +1,7 @@
+"""
+sentry.services
+~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
diff --git a/sentry/services/base.py b/sentry/services/base.py
new file mode 100644
index 0000000000..a7e7083b8e
--- /dev/null
+++ b/sentry/services/base.py
@@ -0,0 +1,14 @@
+"""
+sentry.services.base
+~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+
+class Service(object):
+    name = ''
+
+    def __init__(self, debug=False):
+        self.debug = debug
diff --git a/sentry/services/daemon.py b/sentry/services/daemon.py
new file mode 100644
index 0000000000..6e9a7c11b8
--- /dev/null
+++ b/sentry/services/daemon.py
@@ -0,0 +1,112 @@
+"""
+sentry.servers.daemon
+~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+from __future__ import absolute_import
+
+from daemon.daemon import DaemonContext
+from daemon.runner import is_pidfile_stale, DaemonRunnerStartFailureError, \
+  emit_message, DaemonRunnerStopFailureError, make_pidlockfile
+import lockfile
+import os
+import signal
+import sys
+
+
+class Daemon(object):
+    """
+    Controller for a callable running in a separate background process.
+
+    The first command-line argument is the action to take:
+
+    * 'start': Become a daemon and call `app.run()`.
+    * 'stop': Exit the daemon process specified in the PID file.
+    * 'restart': Stop, then start.
+    """
+
+    start_message = u"started with pid {0}"
+
+    def __init__(self, app, pidfile=None, stdout=sys.stdout, stderr=sys.stderr, **options):
+        """
+        Set up the parameters of a new runner.
+
+        The `app` argument must have the following attributes:
+
+        * `run`: Callable that will be invoked when the daemon is
+          started.
+        """
+        self.app = app
+        if pidfile:
+            self.pidfile = make_pidlockfile(pidfile, 5)
+        else:
+            self.pidfile = None
+
+        self.daemon_context = DaemonContext(
+            stdout=stdout,
+            stderr=stderr,
+            pidfile=self.pidfile,
+            **options
+        )
+
+    def start(self):
+        """
+        Open the daemon context and run the application.
+        """
+        if self.pidfile and is_pidfile_stale(self.pidfile):
+            self.pidfile.break_lock()
+
+        try:
+            self.daemon_context.open()
+        except lockfile.AlreadyLocked:
+            raise DaemonRunnerStartFailureError(
+                u"PID file %(pidfile_path)r already locked".format(
+                  self.pidfile.path))
+
+        pid = os.getpid()
+        message = self.start_message.format(pid)
+
+        emit_message(message)
+        signal.signal(signal.SIGHUP, self.restart)
+
+        self.app.run()
+
+    def stop(self):
+        """
+        Exit the daemon process specified in the current PID file.
+        """
+        if not self.pidfile:
+            self.daemon_context.close()
+
+        if not self.pidfile.is_locked():
+            raise DaemonRunnerStopFailureError(
+                u"PID file {0} not locked".format(self.pidfile.path))
+
+        if is_pidfile_stale(self.pidfile):
+            self.pidfile.break_lock()
+        else:
+            self._terminate_daemon_process()
+
+    def restart(self, *args):
+        """
+        Stop, then start.
+        """
+        print "stopping"
+        self.daemon_context.close()
+        print "starting"
+        self.start()
+
+    def _terminate_daemon_process(self):
+        """
+        Terminate the daemon process specified in the current PID file.
+        """
+
+        pid = self.pidfile.read_pid()
+        try:
+            os.kill(pid, signal.SIGTERM)
+        except OSError, exc:
+            raise DaemonRunnerStopFailureError(
+                u"Failed to terminate {0}: {1}".format(pid, exc))
+
diff --git a/sentry/services/http.py b/sentry/services/http.py
new file mode 100644
index 0000000000..f85527fa5f
--- /dev/null
+++ b/sentry/services/http.py
@@ -0,0 +1,40 @@
+"""
+sentry.services.http
+~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+import eventlet
+
+from eventlet import wsgi, patcher
+
+from sentry.services.base import Service
+
+
+class SentryHTTPServer(Service):
+    name = 'http'
+
+    def __init__(self, host=None, port=None, debug=False):
+        from sentry.conf import settings
+
+        self.debug = debug
+
+        self.host = host or settings.WEB_HOST
+        self.port = port or settings.WEB_PORT
+
+    def run(self):
+        from sentry.wsgi import application
+
+        def inner_run():
+            # Install eventlet patches after everything else has been run,
+            # and inside our server thread
+            patcher.monkey_patch()
+
+            wsgi.server(eventlet.listen((self.host, self.port)), application)
+
+        if self.debug:
+            from django.utils import autoreload
+            autoreload.main(inner_run)
+        else:
+            inner_run()
diff --git a/sentry/services/worker.py b/sentry/services/worker.py
new file mode 100644
index 0000000000..19cf86c4d7
--- /dev/null
+++ b/sentry/services/worker.py
@@ -0,0 +1,24 @@
+"""
+sentry.services.worker
+~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+from sentry.services.base import Service
+
+
+class SentryWorker(Service):
+    name = 'worker'
+
+    def run(self):
+        from sentry.queue.client import broker
+        from sentry.queue.worker import Worker
+
+        from kombu.utils.debug import setup_logging
+        setup_logging(loglevel="INFO")
+
+        try:
+            Worker(broker.connection).run()
+        except KeyboardInterrupt:
+            print("bye bye")
diff --git a/sentry/utils/server.py b/sentry/utils/server.py
deleted file mode 100644
index be323e487b..0000000000
--- a/sentry/utils/server.py
+++ /dev/null
@@ -1,75 +0,0 @@
-"""
-sentry.utils.server
-~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-import eventlet
-import os
-import os.path
-
-from daemon.daemon import DaemonContext
-from daemon.runner import DaemonRunner, make_pidlockfile
-from eventlet import wsgi, patcher
-
-
-class SentryServer(DaemonRunner):
-    pidfile_timeout = 10
-    start_message = u"started with pid %(pid)d"
-
-    def __init__(self, host=None, port=None, pidfile=None,
-                 logfile=None, daemonize=False, debug=False):
-        from sentry.conf import settings
-
-        if not logfile:
-            logfile = settings.WEB_LOG_FILE
-
-        logfile = os.path.realpath(logfile)
-        pidfile = os.path.realpath(pidfile or settings.WEB_PID_FILE)
-
-        if daemonize:
-            detach_process = True
-        else:
-            detach_process = False
-
-        self.daemon_context = DaemonContext(detach_process=detach_process)
-        self.daemon_context.stdout = open(logfile, 'w+')
-        self.daemon_context.stderr = open(logfile, 'w+', buffering=0)
-
-        self.debug = debug
-        self.pidfile = make_pidlockfile(pidfile, self.pidfile_timeout)
-
-        self.daemon_context.pidfile = self.pidfile
-
-        self.host = host or settings.WEB_HOST
-        self.port = port or settings.WEB_PORT
-
-        # HACK: set app to self so self.app.run() works
-        self.app = self
-
-    def execute(self, action):
-        self.action = action
-
-        if self.daemon_context.detach_process is False and self.action == 'start':
-            # HACK:
-            self.run()
-        else:
-            self.do_action()
-
-class SentryHTTPServer(SentryServer):
-    def run(self):
-        from sentry.wsgi import application
-
-        def inner_run():
-            # Install eventlet patches after everything else has been run,
-            # and inside our server thread
-            patcher.monkey_patch()
-
-            wsgi.server(eventlet.listen((self.host, self.port)), application)
-
-        if self.debug:
-            from django.utils import autoreload
-            autoreload.main(inner_run)
-        else:
-            inner_run()

commit 752c2d81c1c9d95fa5ed6f58b9bfb6b98a0a5d69
Author: Lyn Nagara <lyn.nagara@gmail.com>
Date:   Tue May 21 10:23:23 2019 -0700

    feat(events-v2): Add events V2 API (#13288)
    
    First pass at an events V2 API. This supports most of the existing
    parameters used in the current events API (i.e. - start, end, period,
    projects, environment, search query).
    
    It adds support for the following:
    "fields" - a custom list of columns to be returned,
    "groupby" - groups results according to the column names
    "orderby" - custom ordering of results
    
    This API is used instead of the existing events API if the organization has
    the "events-v2" flag activated.

diff --git a/src/sentry/api/bases/organization_events.py b/src/sentry/api/bases/organization_events.py
index deb5a95da8..3162de91cb 100644
--- a/src/sentry/api/bases/organization_events.py
+++ b/src/sentry/api/bases/organization_events.py
@@ -40,3 +40,35 @@ class OrganizationEventsEndpointBase(OrganizationEndpoint):
             raise OrganizationEventsError(
                 'Boolean search operator OR and AND not allowed in this search.')
         return snuba_args
+
+    def get_snuba_query_args_v2(self, request, organization):
+        params = self.get_filter_params(request, organization)
+
+        query = request.GET.get('query')
+        try:
+            snuba_args = get_snuba_query_args(query=query, params=params)
+        except InvalidSearchQuery as exc:
+            raise OrganizationEventsError(exc.message)
+
+        fields = request.GET.getlist('fields')
+        if fields:
+            snuba_args['selected_columns'] = fields
+
+        groupby = request.GET.getlist('groupby')
+        if groupby:
+            snuba_args['groupby'] = groupby
+
+        orderby = request.GET.get('orderby')
+        if orderby:
+            snuba_args['orderby'] = orderby
+
+        # TODO(lb): remove once boolean search is fully functional
+        has_boolean_op_flag = features.has(
+            'organizations:boolean-search',
+            organization,
+            actor=request.user
+        )
+        if snuba_args.pop('has_boolean_terms', False) and not has_boolean_op_flag:
+            raise OrganizationEventsError(
+                'Boolean search operator OR and AND not allowed in this search.')
+        return snuba_args
diff --git a/src/sentry/api/endpoints/organization_events.py b/src/sentry/api/endpoints/organization_events.py
index 60a05d4396..da33a276ec 100644
--- a/src/sentry/api/endpoints/organization_events.py
+++ b/src/sentry/api/endpoints/organization_events.py
@@ -14,13 +14,18 @@ from sentry.models import SnubaEvent
 from sentry.utils.dates import parse_stats_period
 from sentry.utils.snuba import (
     raw_query,
+    transform_aliases_and_query,
     SnubaTSResult,
 )
+from sentry import features
 
 
 class OrganizationEventsEndpoint(OrganizationEventsEndpointBase):
 
     def get(self, request, organization):
+        if features.has('organizations:events-v2', organization, actor=request.user):
+            return self.get_v2(request, organization)
+
         # Check for a direct hit on event ID
         query = request.GET.get('query', '').strip()
 
@@ -65,6 +70,27 @@ class OrganizationEventsEndpoint(OrganizationEventsEndpointBase):
             paginator=GenericOffsetPaginator(data_fn=data_fn)
         )
 
+    def get_v2(self, request, organization):
+        try:
+            snuba_args = self.get_snuba_query_args_v2(request, organization)
+        except OrganizationEventsError as exc:
+            return Response({'detail': exc.message}, status=400)
+        except NoProjects:
+            # return empty result if org doesn't have projects
+            # or user doesn't have access to projects in org
+            data_fn = lambda *args, **kwargs: []
+        else:
+            data_fn = partial(
+                lambda *args, **kwargs: transform_aliases_and_query(*args, **kwargs)['data'],
+                referrer='api.organization-events-v2',
+                **snuba_args
+            )
+
+            return self.paginate(
+                request=request,
+                paginator=GenericOffsetPaginator(data_fn=data_fn)
+            )
+
 
 class OrganizationEventsStatsEndpoint(OrganizationEventsEndpointBase):
 
diff --git a/src/sentry/utils/snuba.py b/src/sentry/utils/snuba.py
index ac3138609c..599ad80f90 100644
--- a/src/sentry/utils/snuba.py
+++ b/src/sentry/utils/snuba.py
@@ -276,6 +276,11 @@ def get_snuba_column_name(name):
     the column is assumed to be a tag. If name is falsy or name is a quoted literal
     (e.g. "'name'"), leave unchanged.
     """
+    no_conversion = set(['project_id', 'start', 'end'])
+
+    if name in no_conversion:
+        return name
+
     if not name or QUOTED_LITERAL_RE.match(name):
         return name
 
@@ -366,7 +371,7 @@ def get_arrayjoin(column):
         return match.groups()[0]
 
 
-def transform_aliases_and_query(**kwargs):
+def transform_aliases_and_query(*args, **kwargs):
     """
     Convert aliases in selected_columns, groupby, aggregation, conditions,
     orderby and arrayjoin fields to their internal Snuba format and post the
@@ -382,34 +387,39 @@ def transform_aliases_and_query(**kwargs):
     translated_columns = {}
     derived_columns = set()
 
-    selected_columns = kwargs['selected_columns']
-    groupby = kwargs['groupby']
-    aggregations = kwargs['aggregations']
-    conditions = kwargs['conditions'] or []
+    selected_columns = kwargs.get('selected_columns')
+    groupby = kwargs.get('groupby')
+    aggregations = kwargs.get('aggregations')
+    conditions = kwargs.get('conditions')
     filter_keys = kwargs['filter_keys']
+    arrayjoin = kwargs.get('arrayjoin')
+    rollup = kwargs.get('rollup')
+    orderby = kwargs.get('orderby')
+
+    if selected_columns:
+        for (idx, col) in enumerate(selected_columns):
+            if isinstance(col, list):
+                # if list, means there are potentially nested functions and need to
+                # iterate and translate potential columns
+                parse_columns_in_functions(col)
+                selected_columns[idx] = col
+                translated_columns[col[2]] = col[2]
+                derived_columns.add(col[2])
+            else:
+                name = get_snuba_column_name(col)
+                selected_columns[idx] = name
+                translated_columns[name] = col
+
+    if groupby:
+        for (idx, col) in enumerate(groupby):
+            if col not in derived_columns:
+                name = get_snuba_column_name(col)
+            else:
+                name = col
 
-    for (idx, col) in enumerate(selected_columns):
-        if isinstance(col, list):
-            # if list, means there are potentially nested functions and need to
-            # iterate and translate potential columns
-            parse_columns_in_functions(col)
-            selected_columns[idx] = col
-            translated_columns[col[2]] = col[2]
-            derived_columns.add(col[2])
-        else:
-            name = get_snuba_column_name(col)
-            selected_columns[idx] = name
+            groupby[idx] = name
             translated_columns[name] = col
 
-    for (idx, col) in enumerate(groupby):
-        if col not in derived_columns:
-            name = get_snuba_column_name(col)
-        else:
-            name = col
-
-        groupby[idx] = name
-        translated_columns[name] = col
-
     for aggregation in aggregations or []:
         derived_columns.add(aggregation[2])
         aggregation[1] = get_snuba_column_name(aggregation[1])
@@ -430,18 +440,20 @@ def transform_aliases_and_query(**kwargs):
                 cond[1][0] = get_snuba_column_name(cond[1][0])
         return cond
 
-    kwargs['conditions'] = [handle_condition(condition) for condition in conditions]
+    if conditions:
+        kwargs['conditions'] = [handle_condition(condition) for condition in conditions]
 
-    order_by_column = kwargs['orderby'].lstrip('-')
-    kwargs['orderby'] = u'{}{}'.format(
-        '-' if kwargs['orderby'].startswith('-') else '',
-        order_by_column if order_by_column in derived_columns else get_snuba_column_name(
-            order_by_column)
-    ) or None
+    if orderby:
+        order_by_column = orderby.lstrip('-')
+        kwargs['orderby'] = u'{}{}'.format(
+            '-' if orderby.startswith('-') else '',
+            order_by_column if order_by_column in derived_columns else get_snuba_column_name(
+                order_by_column)
+        ) or None
 
-    kwargs['arrayjoin'] = arrayjoin_map.get(kwargs['arrayjoin'], kwargs['arrayjoin'])
+    kwargs['arrayjoin'] = arrayjoin_map.get(arrayjoin, arrayjoin)
 
-    result = raw_query(**kwargs)
+    result = raw_query(*args, **kwargs)
 
     # Translate back columns that were converted to snuba format
     for col in result['meta']:
@@ -452,7 +464,7 @@ def transform_aliases_and_query(**kwargs):
 
     if len(translated_columns):
         result['data'] = [get_row(row) for row in result['data']]
-        if kwargs['rollup'] > 0:
+        if rollup and rollup > 0:
             result['data'] = zerofill(
                 result['data'],
                 kwargs['start'],
diff --git a/tests/snuba/api/endpoints/test_organization_events_v2.py b/tests/snuba/api/endpoints/test_organization_events_v2.py
new file mode 100644
index 0000000000..bb9ed32f4d
--- /dev/null
+++ b/tests/snuba/api/endpoints/test_organization_events_v2.py
@@ -0,0 +1,161 @@
+from __future__ import absolute_import
+
+
+from datetime import timedelta
+from django.utils import timezone
+from django.core.urlresolvers import reverse
+
+from sentry.models import Group
+from sentry.testutils import APITestCase, SnubaTestCase
+
+
+class OrganizationEventsTestBase(APITestCase, SnubaTestCase):
+    def setUp(self):
+        super(OrganizationEventsTestBase, self).setUp()
+        self.min_ago = (timezone.now() - timedelta(minutes=1)).isoformat()[:19]
+        self.two_min_ago = (timezone.now() - timedelta(minutes=2)).isoformat()[:19]
+        self.url = reverse(
+            'sentry-api-0-organization-events',
+            kwargs={
+                'organization_slug': self.organization.slug,
+            }
+        )
+
+
+class OrganizationEventsV2EndpointTest(OrganizationEventsTestBase):
+    def test_raw_data(self):
+        self.login_as(user=self.user)
+        project = self.create_project()
+        project2 = self.create_project()
+        self.store_event(
+            data={
+                'event_id': 'a' * 32,
+                'environment': 'staging',
+                'timestamp': self.two_min_ago,
+                'user': {
+                    'ip_address': '127.0.0.1',
+                    'email': 'foo@example.com',
+                },
+            },
+            project_id=project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'b' * 32,
+                'environment': 'staging',
+                'timestamp': self.min_ago,
+                'user': {
+                    'ip_address': '127.0.0.1',
+                    'email': 'foo@example.com',
+                },
+            },
+            project_id=project2.id,
+        )
+
+        with self.feature('organizations:events-v2'):
+            response = self.client.get(
+                self.url,
+                format='json',
+                data={
+                    'fields': ['id', 'project.id', 'user.email', 'user.ip', 'time'],
+                    'orderby': '-timestamp',
+                },
+            )
+
+        assert response.status_code == 200, response.content
+        assert len(response.data) == 2
+        assert response.data[0]['id'] == 'b' * 32
+        assert response.data[0]['project.id'] == project2.id
+        assert response.data[0]['user.email'] == 'foo@example.com'
+
+    def test_groupby(self):
+        self.login_as(user=self.user)
+        project = self.create_project()
+        self.store_event(
+            data={
+                'event_id': 'a' * 32,
+                'environment': 'staging',
+                'timestamp': self.min_ago,
+            },
+            project_id=project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'b' * 32,
+                'environment': 'staging',
+                'timestamp': self.min_ago,
+            },
+            project_id=project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'c' * 32,
+                'environment': 'production',
+                'timestamp': self.min_ago,
+            },
+            project_id=project.id,
+        )
+
+        with self.feature('organizations:events-v2'):
+            response = self.client.get(
+                self.url,
+                format='json',
+                data={
+                    'fields': ['project.id', 'environment'],
+                    'groupby': ['project.id', 'environment'],
+                    'orderby': 'environment',
+                },
+            )
+
+        assert response.status_code == 200, response.content
+        assert len(response.data) == 2
+        assert response.data[0]['project.id'] == project.id
+        assert response.data[0]['environment'] == 'production'
+        assert response.data[1]['project.id'] == project.id
+        assert response.data[1]['environment'] == 'staging'
+
+    def test_event_count(self):
+        self.login_as(user=self.user)
+        project = self.create_project()
+        self.store_event(
+            data={
+                'event_id': 'a' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_1'],
+            },
+            project_id=project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'b' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_1'],
+            },
+            project_id=project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'c' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group_2'],
+            },
+            project_id=project.id,
+        )
+
+        groups = Group.objects.all()
+
+        with self.feature('organizations:events-v2'):
+            response = self.client.get(
+                self.url,
+                format='json',
+                data={
+                    'fields': ['issue.id'],
+                    'groupby': ['issue.id'],
+                    'orderby': 'issue.id'
+                },
+            )
+
+        assert response.status_code == 200, response.content
+        assert len(response.data) == 2
+        assert response.data[0]['issue.id'] == groups[0].id
+        assert response.data[1]['issue.id'] == groups[1].id

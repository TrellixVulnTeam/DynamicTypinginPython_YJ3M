commit 188a2a3e8ab9fb213d78338c861413d78ad7c0cd
Author: David Cramer <dcramer@gmail.com>
Date:   Mon Feb 1 15:53:55 2016 -0800

    Add event.timestamp with improved range queries

diff --git a/src/sentry/search/django/backend.py b/src/sentry/search/django/backend.py
index 95b2831728..4af253cda4 100644
--- a/src/sentry/search/django/backend.py
+++ b/src/sentry/search/django/backend.py
@@ -22,9 +22,12 @@ from sentry.utils.db import get_db_engine
 class DjangoSearchBackend(SearchBackend):
     def query(self, project, query=None, status=None, tags=None,
               bookmarked_by=None, assigned_to=None, first_release=None,
-              sort_by='date', age_from=None, age_to=None,
-              unassigned=None, date_from=None, date_to=None, cursor=None,
-              limit=100):
+              sort_by='date', unassigned=None,
+              age_from=None, age_from_inclusive=True,
+              age_to=None, age_to_inclusive=True,
+              date_from=None, date_from_inclusive=True,
+              date_to=None, date_to_inclusive=True,
+              cursor=None, limit=100):
         from sentry.models import Event, Group, GroupStatus
 
         queryset = Group.objects.filter(project=project)
@@ -86,33 +89,35 @@ class DjangoSearchBackend(SearchBackend):
                     )
             queryset = queryset.distinct()
 
-        if age_from and age_to:
-            queryset = queryset.filter(
-                first_seen__gte=age_from,
-                first_seen__lte=age_to,
-            )
-        elif age_from:
-            queryset = queryset.filter(first_seen__gte=age_from)
-        elif age_to:
-            queryset = queryset.filter(first_seen__lte=age_to)
+        if age_from or age_to:
+            params = {}
+            if age_from:
+                if age_from_inclusive:
+                    params['first_seen__gte'] = age_from
+                else:
+                    params['first_seen__gt'] = age_from
+            if age_to:
+                if age_to_inclusive:
+                    params['first_seen__lte'] = age_to
+                else:
+                    params['first_seen__lt'] = age_to
+            queryset = queryset.filter(**params)
 
         if date_from or date_to:
-            if date_from and date_to:
-                event_queryset = Event.objects.filter(
-                    project_id=project.id,
-                    datetime__gte=date_from,
-                    datetime__lte=date_to,
-                )
-            elif date_from:
-                event_queryset = Event.objects.filter(
-                    project_id=project.id,
-                    datetime__gte=date_from,
-                )
-            elif date_to:
-                event_queryset = Event.objects.filter(
-                    project_id=project.id,
-                    datetime__lte=date_to,
-                )
+            params = {
+                'project_id': project.id,
+            }
+            if date_from:
+                if date_from_inclusive:
+                    params['datetime__gte'] = date_from
+                else:
+                    params['datetime__gt'] = date_from
+            if date_to:
+                if date_to_inclusive:
+                    params['datetime__lte'] = date_to
+                else:
+                    params['datetime__lt'] = date_to
+            event_queryset = Event.objects.filter(**params)
             # limit to the first 1000 results
             group_ids = event_queryset.distinct().values_list(
                 'group_id',
diff --git a/src/sentry/search/utils.py b/src/sentry/search/utils.py
index b9f1a6c270..14f60decc2 100644
--- a/src/sentry/search/utils.py
+++ b/src/sentry/search/utils.py
@@ -1,7 +1,7 @@
 from __future__ import absolute_import, division, print_function
 
 from collections import defaultdict
-from datetime import timedelta
+from datetime import datetime, timedelta
 from django.utils import timezone
 
 from sentry.constants import STATUS_CHOICES
@@ -28,26 +28,107 @@ def get_user_tag(project, key, value):
     return euser.tag_value
 
 
-def parse_simple_range(value):
+def parse_datetime_range(value):
     try:
         flag, count, interval = value[0], int(value[1:-1]), value[-1]
     except (ValueError, TypeError):
-        # TODO(dcramer): propagate errors
-        raise InvalidQuery('{} is not a valid range query'.format(value))
+        raise InvalidQuery('{} is not a valid datetime query'.format(value))
 
     if flag not in ('+', '-'):
-        raise InvalidQuery('{} is not a valid range query'.format(value))
+        raise InvalidQuery('{} is not a valid datetime query'.format(value))
 
     if interval == 'h':
-        return flag, timedelta(hours=count)
+        delta = timedelta(hours=count)
     elif interval == 'w':
-        return flag, timedelta(days=count * 7)
+        delta = timedelta(days=count * 7)
     elif interval == 'd':
-        return flag, timedelta(days=count)
+        delta = timedelta(days=count)
     elif interval == 'm':
-        return flag, timedelta(minutes=count)
+        delta = timedelta(minutes=count)
     else:
-        raise InvalidQuery('{} is not a valid range query'.format(value))
+        raise InvalidQuery('{} is not a valid datetime query'.format(value))
+
+    if flag == '-':
+        return (timezone.now() - delta, None)
+    else:
+        return (None, timezone.now() - delta)
+
+
+def parse_datetime_comparison(value):
+    # TODO(dcramer): currently inclusitivity is not controllable by the query
+    # as from date is always inclusive, and to date is always exclusive
+    if value[:2] in ('>=', '=>'):
+        return (parse_datetime_value(value[2:])[0], None)
+    if value[:2] in ('<=', '=<'):
+        return (None, parse_datetime_value(value[2:])[0])
+    if value[:1] in ('>'):
+        return (parse_datetime_value(value[1:])[0], None)
+    if value[:1] in ('<'):
+        return (None, parse_datetime_value(value[1:])[0])
+    if value[0] == '=':
+        return parse_datetime_value(value[1:])
+    raise InvalidQuery('{} is not a valid datetime query'.format(value))
+
+
+def parse_datetime_value(value):
+    try:
+        return _parse_datetime_value(value)
+    except ValueError:
+        raise InvalidQuery('{} is not a valid datetime query'.format(value))
+
+
+def _parse_datetime_value(value):
+    # timezones are not supported and are assumed UTC
+    if value[-1] == 'Z':
+        value = value[:-1]
+
+    value_len = len(value)
+    if value_len in (8, 10):
+        value = datetime.strptime(value, '%Y-%m-%d').replace(
+            tzinfo=timezone.utc,
+        )
+        return [value, value + timedelta(days=1)]
+    elif value[4] == '-':
+        try:
+            value = datetime.strptime(value, '%Y-%m-%dT%H:%M:%S').replace(
+                tzinfo=timezone.utc,
+            )
+        except ValueError:
+            value = datetime.strptime(value, '%Y-%m-%dT%H:%M:%S.%f').replace(
+                tzinfo=timezone.utc,
+            )
+    else:
+        value = datetime.utcfromtimestamp(float(value)).replace(
+            tzinfo=timezone.utc,
+        )
+    return [value - timedelta(minutes=5), value + timedelta(minutes=6)]
+
+
+def parse_datetime_expression(value):
+    # result must be (from inclusive, to exclusive)
+    if value.startswith(('-', '+')):
+        return parse_datetime_range(value)
+
+    if value.startswith(('>', '<', '=', '<=', '>=')):
+        return parse_datetime_comparison(value)
+
+    return parse_datetime_value(value)
+
+
+def get_date_params(value, from_field, to_field):
+    date_from, date_to = parse_datetime_expression(value)
+    result = {}
+    if date_from:
+        result.update({
+            from_field: date_from,
+            '{}_inclusive'.format(from_field): True,
+        })
+    if date_to:
+        result.update({
+            to_field: date_to,
+            '{}_inclusive'.format(to_field): False,
+        })
+    return result
 
 
 def tokenize_query(query):
@@ -155,15 +236,12 @@ def parse_query(project, query, user):
                     value = 'sentry:release'
                 results['tags'][value] = ANY
             elif key == 'age':
-                flag, offset = parse_simple_range(value)
-                date_value = timezone.now() - offset
-                if flag == '+':
-                    results['age_to'] = date_value
-                elif flag == '-':
-                    results['age_from'] = date_value
+                results.update(get_date_params(value, 'age_from', 'age_to'))
             elif key.startswith('user.'):
                 results['tags']['sentry:user'] = get_user_tag(
                     project, key.split('.', 1)[1], value)
+            elif key == 'event.timestamp':
+                results.update(get_date_params(value, 'date_from', 'date_to'))
             else:
                 results['tags'][key] = value
 
diff --git a/tests/sentry/search/test_utils.py b/tests/sentry/search/test_utils.py
index 0c8cd39043..7662458f73 100644
--- a/tests/sentry/search/test_utils.py
+++ b/tests/sentry/search/test_utils.py
@@ -1,6 +1,6 @@
 from __future__ import absolute_import
 
-from datetime import timedelta
+from datetime import datetime, timedelta
 from django.utils import timezone
 
 from sentry.models import EventUser, GroupStatus
@@ -142,6 +142,29 @@ class ParseQueryTest(TestCase):
         assert result['age_to'] > timezone.now() - timedelta(hours=13)
         assert result['age_to'] < timezone.now() - timedelta(hours=11)
 
+    def test_date_range(self):
+        result = self.parse_query('event.timestamp:>2016-01-01 event.timestamp:<2016-01-02')
+        assert result['date_from'] == datetime(2016, 01, 01, 0, 0, 0, 0, timezone.utc)
+        assert result['date_from_inclusive']
+        assert result['date_to'] == datetime(2016, 01, 02, 0, 0, 0, 0, timezone.utc)
+        assert not result['date_to_inclusive']
+
+    def test_date_approx_day(self):
+        date_value = datetime(2016, 01, 01, 0, 0, 0, 0, timezone.utc)
+        result = self.parse_query('event.timestamp:2016-01-01')
+        assert result['date_from'] == date_value
+        assert result['date_from_inclusive']
+        assert result['date_to'] == date_value + timedelta(days=1)
+        assert not result['date_to_inclusive']
+
+    def test_date_approx_precise(self):
+        date_value = datetime(2016, 01, 01, 0, 0, 0, 0, timezone.utc)
+        result = self.parse_query('event.timestamp:2016-01-01T00:00:00')
+        assert result['date_from'] == date_value - timedelta(minutes=5)
+        assert result['date_from_inclusive']
+        assert result['date_to'] == date_value + timedelta(minutes=6)
+        assert not result['date_to_inclusive']
+
     def test_has_tag(self):
         result = self.parse_query('has:foo')
         assert result['tags']['foo'] == ANY

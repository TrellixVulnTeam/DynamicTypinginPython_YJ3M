commit 9a649b0096b565d5c0c5991b8411380faf909068
Author: Brett Hoerner <brett@bretthoerner.com>
Date:   Mon Dec 11 09:17:44 2017 -0600

    feat(tags): Rest of v2 backend methods (#6698)

diff --git a/src/sentry/api/endpoints/group_tagkey_details.py b/src/sentry/api/endpoints/group_tagkey_details.py
index 5dbc01f741..187e8ff83a 100644
--- a/src/sentry/api/endpoints/group_tagkey_details.py
+++ b/src/sentry/api/endpoints/group_tagkey_details.py
@@ -58,9 +58,10 @@ class GroupTagKeyDetailsEndpoint(GroupEndpoint, EnvironmentMixin):
         except tagstore.GroupTagKeyNotFound:
             raise ResourceDoesNotExist
 
-        total_values = tagstore.get_group_tag_value_count(group.id, environment_id, lookup_key)
+        total_values = tagstore.get_group_tag_value_count(
+            group.project_id, group.id, environment_id, lookup_key)
         top_values = tagstore.get_top_group_tag_values(
-            group.id, environment_id, lookup_key, limit=9)
+            group.project_id, group.id, environment_id, lookup_key, limit=9)
 
         data = {
             'id': six.text_type(tag_key.id),
diff --git a/src/sentry/api/endpoints/group_tagkey_values.py b/src/sentry/api/endpoints/group_tagkey_values.py
index 51d192c470..bbfca41842 100644
--- a/src/sentry/api/endpoints/group_tagkey_values.py
+++ b/src/sentry/api/endpoints/group_tagkey_values.py
@@ -50,7 +50,8 @@ class GroupTagKeyValuesEndpoint(GroupEndpoint, EnvironmentMixin):
         except tagstore.TagKeyNotFound:
             raise ResourceDoesNotExist
 
-        queryset = tagstore.get_group_tag_value_qs(group.id, environment_id, lookup_key)
+        queryset = tagstore.get_group_tag_value_qs(
+            group.project_id, group.id, environment_id, lookup_key)
 
         sort = request.GET.get('sort')
         if sort == 'date':
diff --git a/src/sentry/api/endpoints/group_tags.py b/src/sentry/api/endpoints/group_tags.py
index 2c25b9afeb..7577ef5aaf 100644
--- a/src/sentry/api/endpoints/group_tags.py
+++ b/src/sentry/api/endpoints/group_tags.py
@@ -27,9 +27,9 @@ class GroupTagsEndpoint(GroupEndpoint, EnvironmentMixin):
         all_top_values = []
         for group_tag_key in group_tag_keys:
             total_values = tagstore.get_group_tag_value_count(
-                group.id, environment_id, group_tag_key.key)
+                group.project_id, group.id, environment_id, group_tag_key.key)
             top_values = tagstore.get_top_group_tag_values(
-                group.id, environment_id, group_tag_key.key, limit=10)
+                group.project_id, group.id, environment_id, group_tag_key.key, limit=10)
 
             all_top_values.extend(top_values)
 
diff --git a/src/sentry/api/endpoints/project_group_index.py b/src/sentry/api/endpoints/project_group_index.py
index f0bbac1cee..7739135cd8 100644
--- a/src/sentry/api/endpoints/project_group_index.py
+++ b/src/sentry/api/endpoints/project_group_index.py
@@ -11,7 +11,7 @@ from rest_framework import serializers
 from rest_framework.response import Response
 
 from sentry import features, search
-from sentry.api.base import DocSection
+from sentry.api.base import DocSection, EnvironmentMixin
 from sentry.api.bases.project import ProjectEndpoint, ProjectEventPermission
 from sentry.api.fields import UserField
 from sentry.api.serializers import serialize
@@ -20,7 +20,7 @@ from sentry.api.serializers.models.group import (
 from sentry.constants import DEFAULT_SORT_OPTION
 from sentry.db.models.query import create_or_update
 from sentry.models import (
-    Activity, Group, GroupAssignee, GroupBookmark, GroupHash, GroupResolution,
+    Activity, Environment, Group, GroupAssignee, GroupBookmark, GroupHash, GroupResolution,
     GroupSeen, GroupShare, GroupSnooze, GroupStatus, GroupSubscription, GroupSubscriptionReason,
     GroupTombstone, Release, TOMBSTONE_FIELDS_FROM_GROUP, UserOption
 )
@@ -176,7 +176,7 @@ class GroupValidator(serializers.Serializer):
         return attrs
 
 
-class ProjectGroupIndexEndpoint(ProjectEndpoint):
+class ProjectGroupIndexEndpoint(ProjectEndpoint, EnvironmentMixin):
     doc_section = DocSection.EVENTS
 
     permission_classes = (ProjectEventPermission, )
@@ -319,7 +319,16 @@ class ProjectGroupIndexEndpoint(ProjectEndpoint):
         except ValidationError as exc:
             return Response({'detail': six.text_type(exc)}, status=400)
 
-        cursor_result = search.query(count_hits=True, **query_kwargs)
+        try:
+            environment_id = self._get_environment_id_from_request(
+                request, project.organization_id)
+        except Environment.DoesNotExist:
+            cursor_result = []
+        else:
+            cursor_result = search.query(
+                count_hits=True,
+                environment_id=environment_id,
+                **query_kwargs)
 
         results = list(cursor_result)
 
diff --git a/src/sentry/api/endpoints/project_tagkey_values.py b/src/sentry/api/endpoints/project_tagkey_values.py
index 7150855b0a..6595a20a3c 100644
--- a/src/sentry/api/endpoints/project_tagkey_values.py
+++ b/src/sentry/api/endpoints/project_tagkey_values.py
@@ -43,7 +43,8 @@ class ProjectTagKeyValuesEndpoint(ProjectEndpoint, EnvironmentMixin):
             project.id,
             environment_id,
             tagkey.key,
-            query=request.GET.get('query'))
+            query=request.GET.get('query'),
+        )
 
         return self.paginate(
             request=request,
diff --git a/src/sentry/api/serializers/models/group.py b/src/sentry/api/serializers/models/group.py
index a070b34926..b3a84905cf 100644
--- a/src/sentry/api/serializers/models/group.py
+++ b/src/sentry/api/serializers/models/group.py
@@ -141,8 +141,9 @@ class GroupSerializer(Serializer):
             ).select_related('user')
         )
 
-        user_counts = tagstore.get_group_values_seen(
-            [g.id for g in item_list], environment_id=None, key='sentry:user')
+        # TODO(brett): support environment in this serializer
+        user_counts = tagstore.get_groups_user_counts(
+            item_list[0].project_id, [g.id for g in item_list], environment_id=None)
 
         ignore_items = {g.group_id: g for g in GroupSnooze.objects.filter(
             group__in=item_list,
diff --git a/src/sentry/models/group.py b/src/sentry/models/group.py
index 0322f45db6..192cdaf085 100644
--- a/src/sentry/models/group.py
+++ b/src/sentry/models/group.py
@@ -370,12 +370,12 @@ class Group(Model):
 
     def get_first_release(self):
         if self.first_release_id is None:
-            return tagstore.get_first_release(self.id)
+            return tagstore.get_first_release(self.project_id, self.id)
 
         return self.first_release.version
 
     def get_last_release(self):
-        return tagstore.get_last_release(self.id)
+        return tagstore.get_last_release(self.project_id, self.id)
 
     def get_event_type(self):
         """
@@ -437,5 +437,5 @@ class Group(Model):
         )
 
     def count_users_seen(self):
-        return tagstore.get_group_values_seen(
-            self.id, environment_id=None, key='sentry:user')[self.id]
+        return tagstore.get_groups_user_counts(
+            self.project_id, [self.id], environment_id=None)[self.id]
diff --git a/src/sentry/search/django/backend.py b/src/sentry/search/django/backend.py
index cdbb343c36..71e42369fb 100644
--- a/src/sentry/search/django/backend.py
+++ b/src/sentry/search/django/backend.py
@@ -56,7 +56,8 @@ class DjangoSearchBackend(SearchBackend):
         times_seen_upper=None,
         times_seen_upper_inclusive=True,
         cursor=None,
-        limit=None
+        limit=None,
+        environment_id=None,
     ):
         from sentry.models import Event, Group, GroupSubscription, GroupStatus
 
@@ -115,7 +116,7 @@ class DjangoSearchBackend(SearchBackend):
             )
 
         if tags:
-            matches = tagstore.get_tags_for_search_filter(project.id, tags)
+            matches = tagstore.get_group_ids_for_search_filter(project.id, environment_id, tags)
             if not matches:
                 return queryset.none()
             queryset = queryset.filter(
diff --git a/src/sentry/tagstore/base.py b/src/sentry/tagstore/base.py
index da07a9c88e..4cdcfdd636 100644
--- a/src/sentry/tagstore/base.py
+++ b/src/sentry/tagstore/base.py
@@ -62,7 +62,7 @@ class TagStorage(Service):
         'delete_all_group_tag_keys',
         'delete_all_group_tag_values',
 
-        'get_group_values_seen',
+        'get_groups_user_counts',
         'get_group_event_ids',
         'get_group_tag_value_count',
         'get_top_group_tag_values',
@@ -75,12 +75,12 @@ class TagStorage(Service):
         'incr_group_tag_value_times_seen',
         'get_group_ids_for_users',
         'get_group_tag_values_for_users',
-        'get_tags_for_search_filter',
+        'get_group_ids_for_search_filter',
         'update_group_tag_key_values_seen',
+        'update_group_for_events',
 
         'get_tag_value_qs',
         'get_group_tag_value_qs',
-        'get_event_tag_qs',
     )
 
     def setup_deletions(self, tagkey_model, tagvalue_model, grouptagkey_model,
@@ -218,7 +218,8 @@ class TagStorage(Service):
         """
         raise NotImplementedError
 
-    def get_or_create_tag_value(self, project_id, environment_id, key, value, **kwargs):
+    def get_or_create_tag_value(self, project_id, environment_id,
+                                key, value, key_id=None, **kwargs):
         """
         >>> get_or_create_tag_key(1, 2, "key1", "value1")
         """
@@ -309,15 +310,15 @@ class TagStorage(Service):
         """
         raise NotImplementedError
 
-    def delete_all_group_tag_keys(self, group_id):
+    def delete_all_group_tag_keys(self, project_id, group_id):
         """
-        >>> delete_all_group_tag_keys(1)
+        >>> delete_all_group_tag_keys(1, 2)
         """
         raise NotImplementedError
 
-    def delete_all_group_tag_values(self, group_id):
+    def delete_all_group_tag_values(self, project_id, group_id):
         """
-        >>> delete_all_group_tag_values(1)
+        >>> delete_all_group_tag_values(1, 2)
         """
         raise NotImplementedError
 
@@ -359,39 +360,39 @@ class TagStorage(Service):
         """
         raise NotImplementedError
 
-    def get_group_tag_value_qs(self, group_id, environment_id, key):
+    def get_group_tag_value_qs(self, project_id, group_id, environment_id, key):
         """
-        >>> get_group_tag_value_qs(1, 2, 'environment')
+        >>> get_group_tag_value_qs(1, 2, 3, 'environment')
         """
         raise NotImplementedError
 
-    def get_group_values_seen(self, group_ids, environment_id, key):
+    def get_groups_user_counts(self, project_id, group_ids, environment_id):
         """
-        >>> get_group_values_seen([1, 2], 3, 'key1')
+        >>> get_groups_user_counts(1, [2, 3], 4)
         """
         raise NotImplementedError
 
-    def get_group_tag_value_count(self, group_id, environment_id, key):
+    def get_group_tag_value_count(self, project_id, group_id, environment_id, key):
         """
-        >>> get_group_tag_value_count(1, 2, 'key1')
+        >>> get_group_tag_value_count(1, 2, 3, 'key1')
         """
         raise NotImplementedError
 
-    def get_top_group_tag_values(self, group_id, environment_id, key, limit=3):
+    def get_top_group_tag_values(self, project_id, group_id, environment_id, key, limit=3):
         """
-        >>> get_top_group_tag_values(1, 2, 'key1')
+        >>> get_top_group_tag_values(1, 2, 3, 'key1')
         """
         raise NotImplementedError
 
-    def get_first_release(self, group_id):
+    def get_first_release(self, project_id, group_id):
         """
-        >>> get_first_release(1)
+        >>> get_first_release(1, 2)
         """
         raise NotImplementedError
 
-    def get_last_release(self, group_id):
+    def get_last_release(self, project_id, group_id):
         """
-        >>> get_last_release(1)
+        >>> get_last_release(1, 2)
         """
         raise NotImplementedError
 
@@ -413,15 +414,15 @@ class TagStorage(Service):
         """
         raise NotImplementedError
 
-    def get_tags_for_search_filter(self, project_id, tags):
+    def get_group_ids_for_search_filter(self, project_id, environment_id, tags):
         """
-        >>> get_tags_for_search_filter(1, [('key1', 'value1'), ('key2', 'value2')])
+        >>> get_group_ids_for_search_filter(1, 2, [('key1', 'value1'), ('key2', 'value2')])
         """
         raise NotImplementedError
 
-    def get_event_tag_qs(self, **kwargs):
+    def update_group_for_events(self, project_id, event_ids, destination_id):
         """
-        >>> get_event_tag_qs(event_id=1, key_id=2)
+        >>> update_group_for_events(1, [2, 3], 4)
         """
         raise NotImplementedError
 
diff --git a/src/sentry/tagstore/legacy/backend.py b/src/sentry/tagstore/legacy/backend.py
index 21bbfeccd6..fb315f471c 100644
--- a/src/sentry/tagstore/legacy/backend.py
+++ b/src/sentry/tagstore/legacy/backend.py
@@ -126,7 +126,8 @@ class LegacyTagStorage(TagStorage):
     def create_tag_value(self, project_id, environment_id, key, value, **kwargs):
         return TagValue.objects.create(project_id=project_id, key=key, value=value, **kwargs)
 
-    def get_or_create_tag_value(self, project_id, environment_id, key, value, **kwargs):
+    def get_or_create_tag_value(self, project_id, environment_id,
+                                key, value, key_id=None, **kwargs):
         return TagValue.objects.get_or_create(
             project_id=project_id, key=key, value=value, **kwargs)
 
@@ -271,12 +272,12 @@ class LegacyTagStorage(TagStorage):
 
         return deleted
 
-    def delete_all_group_tag_keys(self, group_id):
+    def delete_all_group_tag_keys(self, project_id, group_id):
         GroupTagKey.objects.filter(
             group_id=group_id,
         ).delete()
 
-    def delete_all_group_tag_values(self, group_id):
+    def delete_all_group_tag_values(self, project_id, group_id):
         GroupTagValue.objects.filter(
             group_id=group_id,
         ).delete()
@@ -384,17 +385,16 @@ class LegacyTagStorage(TagStorage):
 
         return matches
 
-    def get_group_values_seen(self, group_ids, environment_id, key):
-        if isinstance(group_ids, six.integer_types):
-            qs = GroupTagKey.objects.filter(group_id=group_ids)
-        else:
-            qs = GroupTagKey.objects.filter(group_id__in=group_ids)
+    def get_groups_user_counts(self, project_id, group_ids, environment_id):
+        qs = GroupTagKey.objects.filter(
+            project_id=project_id,
+            group_id__in=group_ids,
+            key='sentry:user'
+        )
 
-        return defaultdict(int, qs.filter(
-            key=key,
-        ).values_list('group_id', 'values_seen'))
+        return defaultdict(int, qs.values_list('group_id', 'values_seen'))
 
-    def get_group_tag_value_count(self, group_id, environment_id, key):
+    def get_group_tag_value_count(self, project_id, group_id, environment_id, key):
         if db.is_postgres():
             # This doesnt guarantee percentage is accurate, but it does ensure
             # that the query has a maximum cost
@@ -422,7 +422,7 @@ class LegacyTagStorage(TagStorage):
             last_seen__gte=cutoff,
         ).aggregate(t=Sum('times_seen'))['t']
 
-    def get_top_group_tag_values(self, group_id, environment_id, key, limit=3):
+    def get_top_group_tag_values(self, project_id, group_id, environment_id, key, limit=3):
         if db.is_postgres():
             # This doesnt guarantee percentage is accurate, but it does ensure
             # that the query has a maximum cost
@@ -453,9 +453,10 @@ class LegacyTagStorage(TagStorage):
             ).order_by('-times_seen')[:limit]
         )
 
-    def get_first_release(self, group_id):
+    def get_first_release(self, project_id, group_id):
         try:
             first_release = GroupTagValue.objects.filter(
+                project_id=project_id,
                 group_id=group_id,
                 key__in=('sentry:release', 'release'),
             ).order_by('first_seen')[0]
@@ -464,9 +465,10 @@ class LegacyTagStorage(TagStorage):
         else:
             return first_release.value
 
-    def get_last_release(self, group_id):
+    def get_last_release(self, project_id, group_id):
         try:
             last_release = GroupTagValue.objects.filter(
+                project_id=project_id,
                 group_id=group_id,
                 key__in=('sentry:release', 'release'),
             ).order_by('-last_seen')[0]
@@ -496,7 +498,7 @@ class LegacyTagStorage(TagStorage):
             key='sentry:user',
         ).order_by('-last_seen')[:limit])
 
-    def get_tags_for_search_filter(self, project_id, tags):
+    def get_group_ids_for_search_filter(self, project_id, environment_id, tags):
         from sentry.search.base import ANY, EMPTY
         # Django doesnt support union, so we limit results and try to find
         # reasonable matches
@@ -566,11 +568,14 @@ class LegacyTagStorage(TagStorage):
 
         return queryset
 
-    def get_group_tag_value_qs(self, group_id, environment_id, key):
+    def get_group_tag_value_qs(self, project_id, group_id, environment_id, key):
         return GroupTagValue.objects.filter(
             group_id=group_id,
             key=key,
         )
 
-    def get_event_tag_qs(self, **kwargs):
-        return EventTag.objects.filter(**kwargs)
+    def update_group_for_events(self, project_id, event_ids, destination_id):
+        return EventTag.objects.filter(
+            project_id=project_id,
+            event_id__in=event_ids,
+        ).update(group_id=destination_id)
diff --git a/src/sentry/tagstore/south_migrations/0002_auto__del_tagkey__del_unique_tagkey_project_id_environment_id_key__del.py b/src/sentry/tagstore/south_migrations/0002_auto__del_tagkey__del_unique_tagkey_project_id_environment_id_key__del.py
new file mode 100644
index 0000000000..9669d78f63
--- /dev/null
+++ b/src/sentry/tagstore/south_migrations/0002_auto__del_tagkey__del_unique_tagkey_project_id_environment_id_key__del.py
@@ -0,0 +1,168 @@
+# -*- coding: utf-8 -*-
+from south.utils import datetime_utils as datetime
+from south.db import db
+from south.v2 import SchemaMigration
+from django.db import models
+
+
+class Migration(SchemaMigration):
+
+    # Flag to indicate if this migration is too risky
+    # to run online and needs to be coordinated for offline
+    is_dangerous = True
+
+    def forwards(self, orm):
+        # Removing unique constraint on 'GroupTagValue', fields ['project_id',
+        # 'group_id', 'environment_id', '_key', '_value']
+        db.delete_unique(
+            u'tagstore_grouptagvalue', [
+                'project_id', 'group_id', 'environment_id', 'key', 'value'])
+
+        # Removing unique constraint on 'EventTag', fields ['event_id', 'key', 'value']
+        db.delete_unique(u'tagstore_eventtag', ['event_id', 'key', 'value'])
+
+        # Removing unique constraint on 'GroupTagKey', fields ['project_id',
+        # 'group_id', 'environment_id', '_key']
+        db.delete_unique(
+            u'tagstore_grouptagkey', [
+                'project_id', 'group_id', 'environment_id', 'key'])
+
+        # Removing unique constraint on 'TagValue', fields ['project_id',
+        # 'environment_id', '_key', 'value']
+        db.delete_unique(u'tagstore_tagvalue', ['project_id', 'environment_id', 'key', 'value'])
+
+        # Removing unique constraint on 'TagKey', fields ['project_id', 'environment_id', 'key']
+        db.delete_unique(u'tagstore_tagkey', ['project_id', 'environment_id', 'key'])
+
+        # Deleting model 'TagKey'
+        db.delete_table(u'tagstore_tagkey')
+
+        # Deleting model 'TagValue'
+        db.delete_table(u'tagstore_tagvalue')
+
+        # Deleting model 'GroupTagKey'
+        db.delete_table(u'tagstore_grouptagkey')
+
+        # Deleting model 'EventTag'
+        db.delete_table(u'tagstore_eventtag')
+
+        # Deleting model 'GroupTagValue'
+        db.delete_table(u'tagstore_grouptagvalue')
+
+    def backwards(self, orm):
+        # Adding model 'TagKey'
+        db.create_table(u'tagstore_tagkey', (
+            ('status', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(default=0)),
+            ('environment_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(null=True)),
+            ('values_seen', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(default=0)),
+            ('key', self.gf('django.db.models.fields.CharField')(max_length=32)),
+            ('project_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('id', self.gf('sentry.db.models.fields.bounded.BoundedBigAutoField')(primary_key=True)),
+        ))
+        db.send_create_signal('tagstore', ['TagKey'])
+
+        # Adding unique constraint on 'TagKey', fields ['project_id', 'environment_id', 'key']
+        db.create_unique(u'tagstore_tagkey', ['project_id', 'environment_id', 'key'])
+
+        # Adding model 'TagValue'
+        db.create_table(u'tagstore_tagvalue', (
+            ('times_seen', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(default=0)),
+            ('environment_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(null=True)),
+            ('_key', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagKey'], db_column='key')),
+            ('first_seen', self.gf('django.db.models.fields.DateTimeField')(
+                default=datetime.datetime.now, null=True, db_index=True)),
+            ('project_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('data', self.gf('sentry.db.models.fields.gzippeddict.GzippedDictField')(null=True, blank=True)),
+            ('id', self.gf('sentry.db.models.fields.bounded.BoundedBigAutoField')(primary_key=True)),
+            ('value', self.gf('django.db.models.fields.CharField')(max_length=200)),
+            ('last_seen', self.gf('django.db.models.fields.DateTimeField')(
+                default=datetime.datetime.now, null=True, db_index=True)),
+        ))
+        db.send_create_signal('tagstore', ['TagValue'])
+
+        # Adding unique constraint on 'TagValue', fields ['project_id',
+        # 'environment_id', '_key', 'value']
+        db.create_unique(u'tagstore_tagvalue', ['project_id', 'environment_id', 'key', 'value'])
+
+        # Adding model 'GroupTagKey'
+        db.create_table(u'tagstore_grouptagkey', (
+            ('environment_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(null=True)),
+            ('values_seen', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(default=0)),
+            ('_key', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagKey'], db_column='key')),
+            ('id', self.gf('sentry.db.models.fields.bounded.BoundedBigAutoField')(primary_key=True)),
+            ('project_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('group_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+        ))
+        db.send_create_signal('tagstore', ['GroupTagKey'])
+
+        # Adding unique constraint on 'GroupTagKey', fields ['project_id',
+        # 'group_id', 'environment_id', '_key']
+        db.create_unique(
+            u'tagstore_grouptagkey', [
+                'project_id', 'group_id', 'environment_id', 'key'])
+
+        # Adding model 'EventTag'
+        db.create_table(u'tagstore_eventtag', (
+            ('project_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')()),
+            ('environment_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')()),
+            ('key', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagKey'], db_column='key')),
+            ('event_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')()),
+            ('date_added', self.gf('django.db.models.fields.DateTimeField')(
+                default=datetime.datetime.now, db_index=True)),
+            ('group_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')()),
+            ('id', self.gf('sentry.db.models.fields.bounded.BoundedBigAutoField')(primary_key=True)),
+            ('value', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagValue'], db_column='value')),
+        ))
+        db.send_create_signal('tagstore', ['EventTag'])
+
+        # Adding unique constraint on 'EventTag', fields ['event_id', 'key', 'value']
+        db.create_unique(u'tagstore_eventtag', ['event_id', 'key', 'value'])
+
+        # Adding model 'GroupTagValue'
+        db.create_table(u'tagstore_grouptagvalue', (
+            ('_value', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagValue'], db_column='value')),
+            ('project_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('environment_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(null=True)),
+            ('times_seen', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(default=0)),
+            ('_key', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagKey'], db_column='key')),
+            ('first_seen', self.gf('django.db.models.fields.DateTimeField')(
+                default=datetime.datetime.now, null=True, db_index=True)),
+            ('group_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('id', self.gf('sentry.db.models.fields.bounded.BoundedBigAutoField')(primary_key=True)),
+            ('last_seen', self.gf('django.db.models.fields.DateTimeField')(
+                default=datetime.datetime.now, null=True, db_index=True)),
+        ))
+        db.send_create_signal('tagstore', ['GroupTagValue'])
+
+        # Adding unique constraint on 'GroupTagValue', fields ['project_id',
+        # 'group_id', 'environment_id', '_key', '_value']
+        db.create_unique(
+            u'tagstore_grouptagvalue', [
+                'project_id', 'group_id', 'environment_id', 'key', 'value'])
+
+        # Adding index on 'GroupTagValue', fields ['project_id', '_key', '_value', 'last_seen']
+        db.create_index(u'tagstore_grouptagvalue', ['project_id', 'key', 'value', 'last_seen'])
+
+        # Adding index on 'EventTag', fields ['environment_id', 'key', 'value']
+        db.create_index(u'tagstore_eventtag', ['environment_id', 'key', 'value'])
+
+        # Adding index on 'EventTag', fields ['group_id', 'key', 'value']
+        db.create_index(u'tagstore_eventtag', ['group_id', 'key', 'value'])
+
+        # Adding index on 'EventTag', fields ['project_id', 'key', 'value']
+        db.create_index(u'tagstore_eventtag', ['project_id', 'key', 'value'])
+
+        # Adding index on 'TagValue', fields ['project_id', '_key', 'last_seen']
+        db.create_index(u'tagstore_tagvalue', ['project_id', 'key', 'last_seen'])
+
+    models = {
+
+    }
+
+    complete_apps = ['tagstore']
diff --git a/src/sentry/tagstore/south_migrations/0003_auto__add_tagkey__add_unique_tagkey_project_id_environment_id_key__add.py b/src/sentry/tagstore/south_migrations/0003_auto__add_tagkey__add_unique_tagkey_project_id_environment_id_key__add.py
new file mode 100644
index 0000000000..71291cd73e
--- /dev/null
+++ b/src/sentry/tagstore/south_migrations/0003_auto__add_tagkey__add_unique_tagkey_project_id_environment_id_key__add.py
@@ -0,0 +1,239 @@
+# -*- coding: utf-8 -*-
+from south.utils import datetime_utils as datetime
+from south.db import db
+from south.v2 import SchemaMigration
+from django.db import models
+
+
+class Migration(SchemaMigration):
+
+    # Flag to indicate if this migration is too risky
+    # to run online and needs to be coordinated for offline
+    is_dangerous = True
+
+    def forwards(self, orm):
+        # Adding model 'TagKey'
+        db.create_table(u'tagstore_tagkey', (
+            ('id', self.gf('sentry.db.models.fields.bounded.BoundedBigAutoField')(primary_key=True)),
+            ('project_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('environment_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(null=True)),
+            ('key', self.gf('django.db.models.fields.CharField')(max_length=32)),
+            ('values_seen', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(default=0)),
+            ('status', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(default=0)),
+        ))
+        db.send_create_signal('tagstore', ['TagKey'])
+
+        # Adding unique constraint on 'TagKey', fields ['project_id', 'environment_id', 'key']
+        db.create_unique(u'tagstore_tagkey', ['project_id', 'environment_id', 'key'])
+
+        # Adding model 'GroupTagValue'
+        db.create_table(u'tagstore_grouptagvalue', (
+            ('id', self.gf('sentry.db.models.fields.bounded.BoundedBigAutoField')(primary_key=True)),
+            ('project_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('group_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('environment_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(null=True)),
+            ('times_seen', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(default=0)),
+            ('_key', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagKey'], db_column='key_id')),
+            ('_value', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagValue'], db_column='value_id')),
+            ('last_seen', self.gf('django.db.models.fields.DateTimeField')(
+                default=datetime.datetime.now, null=True, db_index=True)),
+            ('first_seen', self.gf('django.db.models.fields.DateTimeField')(
+                default=datetime.datetime.now, null=True, db_index=True)),
+        ))
+        db.send_create_signal('tagstore', ['GroupTagValue'])
+
+        # Adding unique constraint on 'GroupTagValue', fields ['project_id',
+        # 'group_id', 'environment_id', '_key', '_value']
+        db.create_unique(
+            u'tagstore_grouptagvalue', [
+                'project_id', 'group_id', 'environment_id', 'key_id', 'value_id'])
+
+        # Adding index on 'GroupTagValue', fields ['project_id', '_key', '_value', 'last_seen']
+        db.create_index(
+            u'tagstore_grouptagvalue', [
+                'project_id', 'key_id', 'value_id', 'last_seen'])
+
+        # Adding model 'GroupTagKey'
+        db.create_table(u'tagstore_grouptagkey', (
+            ('id', self.gf('sentry.db.models.fields.bounded.BoundedBigAutoField')(primary_key=True)),
+            ('project_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('group_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('environment_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(null=True)),
+            ('_key', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagKey'], db_column='key_id')),
+            ('values_seen', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(default=0)),
+        ))
+        db.send_create_signal('tagstore', ['GroupTagKey'])
+
+        # Adding unique constraint on 'GroupTagKey', fields ['project_id',
+        # 'group_id', 'environment_id', '_key']
+        db.create_unique(
+            u'tagstore_grouptagkey', [
+                'project_id', 'group_id', 'environment_id', 'key_id'])
+
+        # Adding model 'EventTag'
+        db.create_table(u'tagstore_eventtag', (
+            ('id', self.gf('sentry.db.models.fields.bounded.BoundedBigAutoField')(primary_key=True)),
+            ('project_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')()),
+            ('environment_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')()),
+            ('group_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')()),
+            ('event_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')()),
+            ('key', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagKey'], db_column='key_id')),
+            ('value', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagValue'], db_column='value_id')),
+            ('date_added', self.gf('django.db.models.fields.DateTimeField')(
+                default=datetime.datetime.now, db_index=True)),
+        ))
+        db.send_create_signal('tagstore', ['EventTag'])
+
+        # Adding unique constraint on 'EventTag', fields ['event_id', 'key', 'value']
+        db.create_unique(u'tagstore_eventtag', ['event_id', 'key_id', 'value_id'])
+
+        # Adding index on 'EventTag', fields ['project_id', 'key', 'value']
+        db.create_index(u'tagstore_eventtag', ['project_id', 'key_id', 'value_id'])
+
+        # Adding index on 'EventTag', fields ['group_id', 'key', 'value']
+        db.create_index(u'tagstore_eventtag', ['group_id', 'key_id', 'value_id'])
+
+        # Adding index on 'EventTag', fields ['environment_id', 'key', 'value']
+        db.create_index(u'tagstore_eventtag', ['environment_id', 'key_id', 'value_id'])
+
+        # Adding model 'TagValue'
+        db.create_table(u'tagstore_tagvalue', (
+            ('id', self.gf('sentry.db.models.fields.bounded.BoundedBigAutoField')(primary_key=True)),
+            ('project_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(db_index=True)),
+            ('environment_id', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(null=True)),
+            ('_key', self.gf('sentry.db.models.fields.foreignkey.FlexibleForeignKey')(
+                to=orm['tagstore.TagKey'], db_column='key_id')),
+            ('value', self.gf('django.db.models.fields.CharField')(max_length=200)),
+            ('data', self.gf('sentry.db.models.fields.gzippeddict.GzippedDictField')(null=True, blank=True)),
+            ('times_seen', self.gf('sentry.db.models.fields.bounded.BoundedPositiveIntegerField')(default=0)),
+            ('last_seen', self.gf('django.db.models.fields.DateTimeField')(
+                default=datetime.datetime.now, null=True, db_index=True)),
+            ('first_seen', self.gf('django.db.models.fields.DateTimeField')(
+                default=datetime.datetime.now, null=True, db_index=True)),
+        ))
+        db.send_create_signal('tagstore', ['TagValue'])
+
+        # Adding unique constraint on 'TagValue', fields ['project_id',
+        # 'environment_id', '_key', 'value']
+        db.create_unique(u'tagstore_tagvalue', ['project_id', 'environment_id', 'key_id', 'value'])
+
+        # Adding index on 'TagValue', fields ['project_id', '_key', 'last_seen']
+        db.create_index(u'tagstore_tagvalue', ['project_id', 'key_id', 'last_seen'])
+
+    def backwards(self, orm):
+        # Removing index on 'TagValue', fields ['project_id', '_key', 'last_seen']
+        db.delete_index(u'tagstore_tagvalue', ['project_id', 'key_id', 'last_seen'])
+
+        # Removing unique constraint on 'TagValue', fields ['project_id',
+        # 'environment_id', '_key', 'value']
+        db.delete_unique(u'tagstore_tagvalue', ['project_id', 'environment_id', 'key_id', 'value'])
+
+        # Removing index on 'EventTag', fields ['environment_id', 'key', 'value']
+        db.delete_index(u'tagstore_eventtag', ['environment_id', 'key_id', 'value_id'])
+
+        # Removing index on 'EventTag', fields ['group_id', 'key', 'value']
+        db.delete_index(u'tagstore_eventtag', ['group_id', 'key_id', 'value_id'])
+
+        # Removing index on 'EventTag', fields ['project_id', 'key', 'value']
+        db.delete_index(u'tagstore_eventtag', ['project_id', 'key_id', 'value_id'])
+
+        # Removing unique constraint on 'EventTag', fields ['event_id', 'key', 'value']
+        db.delete_unique(u'tagstore_eventtag', ['event_id', 'key_id', 'value_id'])
+
+        # Removing unique constraint on 'GroupTagKey', fields ['project_id',
+        # 'group_id', 'environment_id', '_key']
+        db.delete_unique(
+            u'tagstore_grouptagkey', [
+                'project_id', 'group_id', 'environment_id', 'key_id'])
+
+        # Removing index on 'GroupTagValue', fields ['project_id', '_key', '_value', 'last_seen']
+        db.delete_index(
+            u'tagstore_grouptagvalue', [
+                'project_id', 'key_id', 'value_id', 'last_seen'])
+
+        # Removing unique constraint on 'GroupTagValue', fields ['project_id',
+        # 'group_id', 'environment_id', '_key', '_value']
+        db.delete_unique(
+            u'tagstore_grouptagvalue', [
+                'project_id', 'group_id', 'environment_id', 'key_id', 'value_id'])
+
+        # Removing unique constraint on 'TagKey', fields ['project_id', 'environment_id', 'key']
+        db.delete_unique(u'tagstore_tagkey', ['project_id', 'environment_id', 'key'])
+
+        # Deleting model 'TagKey'
+        db.delete_table(u'tagstore_tagkey')
+
+        # Deleting model 'GroupTagValue'
+        db.delete_table(u'tagstore_grouptagvalue')
+
+        # Deleting model 'GroupTagKey'
+        db.delete_table(u'tagstore_grouptagkey')
+
+        # Deleting model 'EventTag'
+        db.delete_table(u'tagstore_eventtag')
+
+        # Deleting model 'TagValue'
+        db.delete_table(u'tagstore_tagvalue')
+
+    models = {
+        'tagstore.eventtag': {
+            'Meta': {'unique_together': "(('event_id', 'key', 'value'),)", 'object_name': 'EventTag', 'index_together': "(('project_id', 'key', 'value'), ('group_id', 'key', 'value'), ('environment_id', 'key', 'value'))"},
+            'date_added': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
+            'environment_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {}),
+            'event_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {}),
+            'group_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {}),
+            'id': ('sentry.db.models.fields.bounded.BoundedBigAutoField', [], {'primary_key': 'True'}),
+            'key': ('sentry.db.models.fields.foreignkey.FlexibleForeignKey', [], {'to': "orm['tagstore.TagKey']", 'db_column': "'key_id'"}),
+            'project_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {}),
+            'value': ('sentry.db.models.fields.foreignkey.FlexibleForeignKey', [], {'to': "orm['tagstore.TagValue']", 'db_column': "'value_id'"})
+        },
+        'tagstore.grouptagkey': {
+            'Meta': {'unique_together': "(('project_id', 'group_id', 'environment_id', '_key'),)", 'object_name': 'GroupTagKey'},
+            '_key': ('sentry.db.models.fields.foreignkey.FlexibleForeignKey', [], {'to': "orm['tagstore.TagKey']", 'db_column': "'key_id'"}),
+            'environment_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'null': 'True'}),
+            'group_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'db_index': 'True'}),
+            'id': ('sentry.db.models.fields.bounded.BoundedBigAutoField', [], {'primary_key': 'True'}),
+            'project_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'db_index': 'True'}),
+            'values_seen': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'default': '0'})
+        },
+        'tagstore.grouptagvalue': {
+            'Meta': {'unique_together': "(('project_id', 'group_id', 'environment_id', '_key', '_value'),)", 'object_name': 'GroupTagValue', 'index_together': "(('project_id', '_key', '_value', 'last_seen'),)"},
+            '_key': ('sentry.db.models.fields.foreignkey.FlexibleForeignKey', [], {'to': "orm['tagstore.TagKey']", 'db_column': "'key_id'"}),
+            '_value': ('sentry.db.models.fields.foreignkey.FlexibleForeignKey', [], {'to': "orm['tagstore.TagValue']", 'db_column': "'value_id'"}),
+            'environment_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'null': 'True'}),
+            'first_seen': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'db_index': 'True'}),
+            'group_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'db_index': 'True'}),
+            'id': ('sentry.db.models.fields.bounded.BoundedBigAutoField', [], {'primary_key': 'True'}),
+            'last_seen': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'db_index': 'True'}),
+            'project_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'db_index': 'True'}),
+            'times_seen': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'default': '0'})
+        },
+        'tagstore.tagkey': {
+            'Meta': {'unique_together': "(('project_id', 'environment_id', 'key'),)", 'object_name': 'TagKey'},
+            'environment_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'null': 'True'}),
+            'id': ('sentry.db.models.fields.bounded.BoundedBigAutoField', [], {'primary_key': 'True'}),
+            'key': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
+            'project_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'db_index': 'True'}),
+            'status': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'default': '0'}),
+            'values_seen': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'default': '0'})
+        },
+        'tagstore.tagvalue': {
+            'Meta': {'unique_together': "(('project_id', 'environment_id', '_key', 'value'),)", 'object_name': 'TagValue', 'index_together': "(('project_id', '_key', 'last_seen'),)"},
+            '_key': ('sentry.db.models.fields.foreignkey.FlexibleForeignKey', [], {'to': "orm['tagstore.TagKey']", 'db_column': "'key_id'"}),
+            'data': ('sentry.db.models.fields.gzippeddict.GzippedDictField', [], {'null': 'True', 'blank': 'True'}),
+            'environment_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'null': 'True'}),
+            'first_seen': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'db_index': 'True'}),
+            'id': ('sentry.db.models.fields.bounded.BoundedBigAutoField', [], {'primary_key': 'True'}),
+            'last_seen': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'db_index': 'True'}),
+            'project_id': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'db_index': 'True'}),
+            'times_seen': ('sentry.db.models.fields.bounded.BoundedPositiveIntegerField', [], {'default': '0'}),
+            'value': ('django.db.models.fields.CharField', [], {'max_length': '200'})
+        }
+    }
+
+    complete_apps = ['tagstore']
diff --git a/src/sentry/tagstore/v2/backend.py b/src/sentry/tagstore/v2/backend.py
index 638a3304f7..6570f1bdff 100644
--- a/src/sentry/tagstore/v2/backend.py
+++ b/src/sentry/tagstore/v2/backend.py
@@ -8,18 +8,27 @@ sentry.tagstore.v2.backend
 
 from __future__ import absolute_import
 
-from django.db import IntegrityError, transaction
+import six
 
+from collections import defaultdict
+from datetime import timedelta
+from django.db import connections, router, IntegrityError, transaction
+from django.db.models import Q, Sum
+from django.utils import timezone
+from operator import or_
+from six.moves import reduce
+
+from sentry import buffer
 from sentry.tagstore import TagKeyStatus
 from sentry.tagstore.base import TagStorage
+from sentry.utils import db
 
 from .models import EventTag, GroupTagKey, GroupTagValue, TagKey, TagValue
 
 
 class TagStorage(TagStorage):
     """\
-    The v2 tagstore backend stores and respects ``environment_id`` arguments and stores
-    ``times_seen`` and ``values_seen`` in Redis for cheap incr/decrs.
+    The v2 tagstore backend stores and respects ``environment_id``.
 
     An ``environment_id`` value of ``None`` is used to keep track of the aggregate value across
     all environments.
@@ -84,14 +93,17 @@ class TagStorage(TagStorage):
             **kwargs
         )
 
-    def get_or_create_tag_value(self, project_id, environment_id, key, value, **kwargs):
-        tag_key, _ = self.get_or_create_tag_key(
-            project_id, environment_id, key, **kwargs)
+    def get_or_create_tag_value(self, project_id, environment_id,
+                                key, value, key_id=None, **kwargs):
+        if key_id is None:
+            tag_key, _ = self.get_or_create_tag_key(
+                project_id, environment_id, key, **kwargs)
+            key_id = tag_key.id
 
         return TagValue.objects.get_or_create(
             project_id=project_id,
             environment_id=environment_id,
-            _key_id=tag_key.id,
+            _key_id=key_id,
             value=value,
             **kwargs
         )
@@ -298,16 +310,357 @@ class TagStorage(TagStorage):
 
         return deleted
 
-    def delete_all_group_tag_keys(self, group_id):
+    def delete_all_group_tag_keys(self, project_id, group_id):
         GroupTagKey.objects.filter(
+            project_id=project_id,
             group_id=group_id,
         ).delete()
 
-    def delete_all_group_tag_values(self, group_id):
+    def delete_all_group_tag_values(self, project_id, group_id):
         GroupTagValue.objects.filter(
+            project_id=project_id,
             group_id=group_id,
         ).delete()
 
+    def incr_tag_key_values_seen(self, project_id, environment_id, key, count=1):
+        buffer.incr(TagKey,
+                    columns={
+                        'values_seen': count,
+                    },
+                    filters={
+                        'project_id': project_id,
+                        'environment_id': environment_id,
+                        'key': key,
+                    })
+
+    def incr_tag_value_times_seen(self, project_id, environment_id,
+                                  key, value, extra=None, count=1):
+        buffer.incr(TagValue,
+                    columns={
+                        'times_seen': count,
+                    },
+                    filters={
+                        'project_id': project_id,
+                        'environment_id': environment_id,
+                        'key': key,
+                        'value': value,
+                    },
+                    extra=extra)
+
+    def incr_group_tag_key_values_seen(self, project_id, group_id, environment_id, key, count=1):
+        buffer.incr(GroupTagKey,
+                    columns={
+                        'values_seen': count,
+                    },
+                    filters={
+                        'project_id': project_id,
+                        'group_id': group_id,
+                        'environment_id': environment_id,
+                        'key': key,
+                    })
+
+    def incr_group_tag_value_times_seen(self, project_id, group_id, environment_id,
+                                        key, value, extra=None, count=1):
+        buffer.incr(GroupTagValue,
+                    columns={
+                        'times_seen': count,
+                    },
+                    filters={
+                        'project_id': project_id,
+                        'group_id': group_id,
+                        'environment_id': environment_id,
+                        'key': key,
+                        'value': value,
+                    },
+                    extra=extra)
+
+    def get_group_event_ids(self, project_id, group_id, environment_id, tags):
+        tagkeys = dict(
+            TagKey.objects.filter(
+                project_id=project_id,
+                key__in=tags.keys(),
+                status=TagKeyStatus.VISIBLE,
+                **self._get_environment_filter(environment_id)
+            ).values_list('key', 'id')
+        )
+
+        tagvalues = {
+            (t[1], t[2]): t[0]
+            for t in TagValue.objects.filter(
+                reduce(or_, (Q(_key__key=k, value=v)
+                             for k, v in six.iteritems(tags))),
+                project_id=project_id,
+                **self._get_environment_filter(environment_id)
+            ).values_list('id', '_key__key', 'value')
+        }
+
+        try:
+            tag_lookups = [(tagkeys[k], tagvalues[(k, v)])
+                           for k, v in six.iteritems(tags)]
+            # [(1, 10), ...]
+        except KeyError:
+            # one or more tags were invalid, thus the result should be an empty
+            # set
+            return []
+
+        # Django doesnt support union, so we limit results and try to find
+        # reasonable matches
+
+        # get initial matches to start the filter
+        k, v = tag_lookups.pop()
+        matches = list(
+            EventTag.objects.filter(
+                project_id=project_id,
+                group_id=group_id,
+                key_id=k,
+                value_id=v,
+                **self._get_environment_filter(environment_id)
+            ).values_list('event_id', flat=True)[:1000]
+        )
+
+        # for each remaining tag, find matches contained in our
+        # existing set, pruning it down each iteration
+        for k, v in tag_lookups:
+            matches = list(
+                EventTag.objects.filter(
+                    project_id=project_id,
+                    group_id=group_id,
+                    event_id__in=matches,
+                    key_id=k,
+                    value_id=v,
+                    **self._get_environment_filter(environment_id)
+                ).values_list('event_id', flat=True)[:1000]
+            )
+            if not matches:
+                return []
+
+        return matches
+
+    def get_groups_user_counts(self, project_id, group_ids, environment_id):
+        qs = GroupTagKey.objects.filter(
+            project_id=project_id,
+            group_id__in=group_ids,
+            _key__key='sentry:user',
+            **self._get_environment_filter(environment_id)
+        )
+
+        return defaultdict(int, qs.values_list('group_id', 'values_seen'))
+
+    def get_group_tag_value_count(self, project_id, group_id, environment_id, key):
+        if db.is_postgres():
+            # This doesnt guarantee percentage is accurate, but it does ensure
+            # that the query has a maximum cost
+            using = router.db_for_read(GroupTagValue)
+            cursor = connections[using].cursor()
+            cursor.execute(
+                """
+                SELECT SUM(t)
+                FROM (
+                    SELECT times_seen as t
+                    FROM tagstore_grouptagvalue
+                    INNER JOIN tagstore_tagkey
+                    ON (tagstore_grouptagvalue.key_id = tagstore_tagkey.id)
+                    WHERE tagstore_grouptagvalue.group_id = %s
+                    AND tagstore_grouptagvalue.environment_id = %s
+                    AND tagstore_tagkey.key = %s
+                    ORDER BY last_seen DESC
+                    LIMIT 10000
+                ) as a
+            """, [group_id, environment_id, key]
+            )
+            return cursor.fetchone()[0] or 0
+
+        cutoff = timezone.now() - timedelta(days=7)
+        return GroupTagValue.objects.filter(
+            group_id=group_id,
+            _key__key=key,
+            last_seen__gte=cutoff,
+            **self._get_environment_filter(environment_id)
+        ).aggregate(t=Sum('times_seen'))['t']
+
+    def get_top_group_tag_values(self, project_id, group_id, environment_id, key, limit=3):
+        if db.is_postgres():
+            # This doesnt guarantee percentage is accurate, but it does ensure
+            # that the query has a maximum cost
+            return list(
+                GroupTagValue.objects.raw(
+                    """
+                SELECT *
+                FROM (
+                    SELECT tagstore_grouptagvalue.id,
+                           tagstore_grouptagvalue.project_id,
+                           tagstore_grouptagvalue.group_id,
+                           tagstore_grouptagvalue.environment_id,
+                           tagstore_grouptagvalue.times_seen,
+                           tagstore_grouptagvalue.key_id,
+                           tagstore_grouptagvalue.value_id,
+                           tagstore_grouptagvalue.last_seen,
+                           tagstore_grouptagvalue.first_seen
+                    FROM tagstore_grouptagvalue
+                    INNER JOIN tagstore_tagkey
+                    ON (tagstore_grouptagvalue.key_id = tagstore_tagkey.id)
+                    WHERE tagstore_grouptagvalue.group_id = %%s
+                    AND tagstore_grouptagvalue.environment_id = %%s
+                    AND tagstore_tagkey.key = %%s
+                    ORDER BY last_seen DESC
+                    LIMIT 10000
+                ) as a
+                ORDER BY times_seen DESC
+                LIMIT %d
+            """ % limit, [group_id, environment_id, key]
+                )
+            )
+
+        cutoff = timezone.now() - timedelta(days=7)
+        return list(
+            GroupTagValue.objects.filter(
+                group_id=group_id,
+                _key__key=key,
+                last_seen__gte=cutoff,
+                **self._get_environment_filter(environment_id)
+            ).order_by('-times_seen')[:limit]
+        )
+
+    def get_first_release(self, project_id, group_id):
+        try:
+            first_release = GroupTagValue.objects.filter(
+                project_id=project_id,
+                group_id=group_id,
+                _key__key__in=('sentry:release', 'release'),
+            ).order_by('first_seen')[0]
+        except IndexError:
+            return None
+        else:
+            return first_release.value
+
+    def get_last_release(self, project_id, group_id):
+        try:
+            last_release = GroupTagValue.objects.filter(
+                project_id=project_id,
+                group_id=group_id,
+                _key__key__in=('sentry:release', 'release'),
+            ).order_by('-last_seen')[0]
+        except IndexError:
+            return None
+
+        return last_release.value
+
+    def get_release_tags(self, project_ids, environment_id, versions):
+        return list(TagValue.objects.filter(
+            project_id__in=project_ids,
+            _key__key='sentry:release',
+            value__in=versions,
+            **self._get_environment_filter(environment_id)
+        ))
+
+    def get_group_ids_for_users(self, project_ids, event_users, limit=100):
+        return list(GroupTagValue.objects.filter(
+            project_id__in=project_ids,
+            environment_id__isnull=True,
+            _key__key='sentry:user',
+            _value__value__in=[eu.tag_value for eu in event_users],
+        ).order_by('-last_seen').values_list('group_id', flat=True)[:limit])
+
+    def get_group_tag_values_for_users(self, event_users, limit=100):
+        tag_filters = [
+            Q(_value__value=eu.tag_value, project_id=eu.project_id)
+            for eu in event_users
+        ]
+
+        return list(GroupTagValue.objects.filter(
+            reduce(or_, tag_filters),
+            environment_id__isnull=True,
+            _key__key='sentry:user',
+        ).order_by('-last_seen')[:limit])
+
+    def get_group_ids_for_search_filter(self, project_id, environment_id, tags):
+        from sentry.search.base import ANY, EMPTY
+        # Django doesnt support union, so we limit results and try to find
+        # reasonable matches
+
+        # ANY matches should come last since they're the least specific and
+        # will provide the largest range of matches
+        tag_lookups = sorted(six.iteritems(tags), key=lambda x: x != ANY)
+
+        # get initial matches to start the filter
+        matches = None
+
+        # for each remaining tag, find matches contained in our
+        # existing set, pruning it down each iteration
+        for k, v in tag_lookups:
+            if v is EMPTY:
+                return None
+
+            elif v != ANY:
+                base_qs = GroupTagValue.objects.filter(
+                    project_id=project_id,
+                    _key__key=k,
+                    _value__value=v,
+                    **self._get_environment_filter(environment_id)
+                )
+
+            else:
+                base_qs = GroupTagValue.objects.filter(
+                    project_id=project_id,
+                    _key__key=k,
+                    **self._get_environment_filter(environment_id)
+                ).distinct()
+
+            if matches:
+                base_qs = base_qs.filter(group_id__in=matches)
+            else:
+                # restrict matches to only the most recently seen issues
+                base_qs = base_qs.order_by('-last_seen')
+
+            matches = list(base_qs.values_list('group_id', flat=True)[:1000])
+
+            if not matches:
+                return None
+
+        return matches
+
+    def update_group_tag_key_values_seen(self, project_id, group_ids):
+        gtk_qs = GroupTagKey.objects.filter(
+            project_id=project_id,
+            group_id__in=group_ids
+        )
+
+        for instance in gtk_qs:
+            instance.update(
+                values_seen=GroupTagValue.objects.filter(
+                    project_id=instance.project_id,
+                    group_id=instance.group_id,
+                    environment_id=instance.environment_id,
+                    key=instance.key,
+                ).count(),
+            )
+
+    def get_tag_value_qs(self, project_id, environment_id, key, query=None):
+        queryset = TagValue.objects.filter(
+            project_id=project_id,
+            key=key,
+            **self._get_environment_filter(environment_id)
+        )
+
+        if query:
+            queryset = queryset.filter(value__contains=query)
+
+        return queryset
+
+    def get_group_tag_value_qs(self, project_id, group_id, environment_id, key):
+        return GroupTagValue.objects.filter(
+            project_id=project_id,
+            group_id=group_id,
+            key=key,
+            **self._get_environment_filter(environment_id)
+        )
+
+    def update_group_for_events(self, project_id, event_ids, destination_id):
+        return EventTag.objects.filter(
+            project_id=project_id,
+            event_id__in=event_ids,
+        ).update(group_id=destination_id)
+
     def _get_environment_filter(self, environment_id):
         if environment_id is None:
             return {'environment_id__isnull': True}
diff --git a/src/sentry/tagstore/v2/models/eventtag.py b/src/sentry/tagstore/v2/models/eventtag.py
index f8596208ad..443fe353e6 100644
--- a/src/sentry/tagstore/v2/models/eventtag.py
+++ b/src/sentry/tagstore/v2/models/eventtag.py
@@ -20,8 +20,8 @@ class EventTag(Model):
     environment_id = BoundedPositiveIntegerField()
     group_id = BoundedPositiveIntegerField()
     event_id = BoundedPositiveIntegerField()
-    key = FlexibleForeignKey('tagstore.TagKey', db_column='key')
-    value = FlexibleForeignKey('tagstore.TagValue', db_column='value')
+    key = FlexibleForeignKey('tagstore.TagKey', db_column='key_id')
+    value = FlexibleForeignKey('tagstore.TagValue', db_column='value_id')
     date_added = models.DateTimeField(default=timezone.now, db_index=True)
 
     class Meta:
diff --git a/src/sentry/tagstore/v2/models/grouptagkey.py b/src/sentry/tagstore/v2/models/grouptagkey.py
index c98086b515..4d14c22a4d 100644
--- a/src/sentry/tagstore/v2/models/grouptagkey.py
+++ b/src/sentry/tagstore/v2/models/grouptagkey.py
@@ -28,7 +28,7 @@ class GroupTagKey(Model):
     project_id = BoundedPositiveIntegerField(db_index=True)
     group_id = BoundedPositiveIntegerField(db_index=True)
     environment_id = BoundedPositiveIntegerField(null=True)
-    _key = FlexibleForeignKey('tagstore.TagKey', db_column='key')
+    _key = FlexibleForeignKey('tagstore.TagKey', db_column='key_id')
     values_seen = BoundedPositiveIntegerField(default=0)
 
     objects = BaseManager()
diff --git a/src/sentry/tagstore/v2/models/grouptagvalue.py b/src/sentry/tagstore/v2/models/grouptagvalue.py
index decfd94328..b651f7be65 100644
--- a/src/sentry/tagstore/v2/models/grouptagvalue.py
+++ b/src/sentry/tagstore/v2/models/grouptagvalue.py
@@ -29,8 +29,8 @@ class GroupTagValue(Model):
     group_id = BoundedPositiveIntegerField(db_index=True)
     environment_id = BoundedPositiveIntegerField(null=True)
     times_seen = BoundedPositiveIntegerField(default=0)
-    _key = FlexibleForeignKey('tagstore.TagKey', db_column='key')
-    _value = FlexibleForeignKey('tagstore.TagValue', db_column='value')
+    _key = FlexibleForeignKey('tagstore.TagKey', db_column='key_id')
+    _value = FlexibleForeignKey('tagstore.TagValue', db_column='value_id')
     last_seen = models.DateTimeField(
         default=timezone.now, db_index=True, null=True)
     first_seen = models.DateTimeField(
diff --git a/src/sentry/tagstore/v2/models/tagvalue.py b/src/sentry/tagstore/v2/models/tagvalue.py
index e8b6c72eee..b9db389d89 100644
--- a/src/sentry/tagstore/v2/models/tagvalue.py
+++ b/src/sentry/tagstore/v2/models/tagvalue.py
@@ -27,7 +27,7 @@ class TagValue(Model):
 
     project_id = BoundedPositiveIntegerField(db_index=True)
     environment_id = BoundedPositiveIntegerField(null=True)
-    _key = FlexibleForeignKey('tagstore.TagKey', db_column='key')
+    _key = FlexibleForeignKey('tagstore.TagKey', db_column='key_id')
     value = models.CharField(max_length=MAX_TAG_VALUE_LENGTH)
     data = GzippedDictField(blank=True, null=True)
     times_seen = BoundedPositiveIntegerField(default=0)
diff --git a/src/sentry/tasks/post_process.py b/src/sentry/tasks/post_process.py
index f0abcd7241..fb069afa5a 100644
--- a/src/sentry/tasks/post_process.py
+++ b/src/sentry/tasks/post_process.py
@@ -136,9 +136,8 @@ def index_event_tags(organization_id, project_id, event_id, tags,
     tag_ids = []
     for key, value in tags:
         tagkey, _ = tagstore.get_or_create_tag_key(project_id, environment_id, key)
-        # TODO(brett): optimization to hand `get_or_create_tag_value` the key_id
-        # so it doesn't have to hit the database for something we just had on hand
-        tagvalue, _ = tagstore.get_or_create_tag_value(project_id, environment_id, key, value)
+        tagvalue, _ = tagstore.get_or_create_tag_value(
+            project_id, environment_id, key, value, key_id=tagkey.id)
         tag_ids.append((tagkey.id, tagvalue.id))
 
     tagstore.create_event_tags(
diff --git a/src/sentry/tasks/unmerge.py b/src/sentry/tasks/unmerge.py
index 0b9d9abfe7..6a08aeec02 100644
--- a/src/sentry/tasks/unmerge.py
+++ b/src/sentry/tasks/unmerge.py
@@ -220,10 +220,11 @@ def migrate_events(caches, project, source_id, destination_id, fingerprints, eve
     for event in events:
         event.group = destination
 
-    tagstore.get_event_tag_qs(
+    tagstore.update_group_for_events(
         project_id=project.id,
-        event_id__in=event_id_set,
-    ).update(group_id=destination_id)
+        event_ids=event_id_set,
+        destination_id=destination_id
+    )
 
     event_event_id_set = set(event.event_id for event in events)
 
@@ -241,8 +242,8 @@ def migrate_events(caches, project, source_id, destination_id, fingerprints, eve
 
 
 def truncate_denormalizations(group):
-    tagstore.delete_all_group_tag_keys(group.id)
-    tagstore.delete_all_group_tag_values(group.id)
+    tagstore.delete_all_group_tag_keys(group.project_id, group.id)
+    tagstore.delete_all_group_tag_values(group.project_id, group.id)
 
     GroupRelease.objects.filter(
         group_id=group.id,
diff --git a/src/sentry/web/frontend/group_tag_export.py b/src/sentry/web/frontend/group_tag_export.py
index 0dd27a6f6c..35cdb88cfb 100644
--- a/src/sentry/web/frontend/group_tag_export.py
+++ b/src/sentry/web/frontend/group_tag_export.py
@@ -92,7 +92,7 @@ class GroupTagExportView(ProjectView, CsvMixin, EnvironmentMixin):
             callbacks = []
 
         queryset = RangeQuerySetWrapper(
-            tagstore.get_group_tag_value_qs(group.id, environment_id, lookup_key),
+            tagstore.get_group_tag_value_qs(group.project_id, group.id, environment_id, lookup_key),
             callbacks=callbacks,
         )
 
diff --git a/tests/sentry/deletions/test_group.py b/tests/sentry/deletions/test_group.py
index cf1e8ab106..d47e1dfa00 100644
--- a/tests/sentry/deletions/test_group.py
+++ b/tests/sentry/deletions/test_group.py
@@ -3,6 +3,7 @@ from __future__ import absolute_import
 from uuid import uuid4
 
 from sentry import tagstore
+from sentry.tagstore.models import EventTag
 from sentry.models import (
     Event, EventMapping, Group, GroupAssignee, GroupHash, GroupMeta, GroupRedirect,
     ScheduledDeletion
@@ -63,7 +64,7 @@ class DeleteGroupTest(TestCase):
             event_id='a' * 32,
             group_id=group.id,
         ).exists()
-        assert not tagstore.get_event_tag_qs(event_id=event.id).exists()
+        assert not EventTag.objects.filter(event_id=event.id).exists()
         assert not GroupRedirect.objects.filter(group_id=group.id).exists()
         assert not GroupHash.objects.filter(group_id=group.id).exists()
         assert not Group.objects.filter(id=group.id).exists()
diff --git a/tests/sentry/deletions/test_tagkey.py b/tests/sentry/deletions/test_tagkey.py
index e1e51727d5..a0a957a4ff 100644
--- a/tests/sentry/deletions/test_tagkey.py
+++ b/tests/sentry/deletions/test_tagkey.py
@@ -1,6 +1,7 @@
 from __future__ import absolute_import
 
 from sentry import tagstore
+from sentry.tagstore.models import EventTag
 from sentry.models import ScheduledDeletion
 from sentry.tasks.deletion import run_deletion
 from sentry.testutils import TestCase
@@ -92,5 +93,5 @@ class DeleteTagKeyTest(TestCase):
         assert tagstore.get_group_tag_key(group2.project_id, group2.id, None, key) is not None
         assert tagstore.get_group_tag_value(
             group2.project_id, group2.id, None, key, value) is not None
-        assert tagstore.get_event_tag_qs(key_id=tk.id).exists()
-        assert tagstore.get_event_tag_qs(key_id=tk2.id).exists()
+        assert EventTag.objects.filter(key_id=tk.id).exists()
+        assert EventTag.objects.filter(key_id=tk2.id).exists()
diff --git a/tests/sentry/tagstore/v2/test_backend.py b/tests/sentry/tagstore/v2/test_backend.py
index a3b6822d3f..ebe0510f53 100644
--- a/tests/sentry/tagstore/v2/test_backend.py
+++ b/tests/sentry/tagstore/v2/test_backend.py
@@ -2,6 +2,8 @@ from __future__ import absolute_import
 
 import pytest
 
+from datetime import datetime
+
 from sentry.testutils import TestCase
 from sentry.tagstore import TagKeyStatus
 from sentry.tagstore.v2.backend import TagStorage
@@ -15,9 +17,12 @@ class V2TagStorage(TestCase):
 
         self.proj1 = self.create_project()
         self.proj1group1 = self.create_group(self.proj1)
+        self.proj1group2 = self.create_group(self.proj1)
         self.proj1env1 = self.create_environment(project=self.proj1)
         self.proj1env2 = self.create_environment(project=self.proj1)
         self.proj1group1event1 = self.create_event(project=self.proj1, group=self.proj1group1)
+        self.proj1group1event2 = self.create_event(project=self.proj1, group=self.proj1group1)
+        self.proj1group1event3 = self.create_event(project=self.proj1, group=self.proj1group1)
 
         self.proj2 = self.create_project()
         self.proj2group1 = self.create_group(self.proj2)
@@ -375,7 +380,7 @@ class V2TagStorage(TestCase):
 
         assert GroupTagKey.objects.count() == 1
 
-        self.ts.delete_all_group_tag_keys(self.proj1group1.id)
+        self.ts.delete_all_group_tag_keys(self.proj1.id, self.proj1group1.id)
 
         assert GroupTagKey.objects.count() == 0
 
@@ -392,6 +397,267 @@ class V2TagStorage(TestCase):
 
         assert GroupTagValue.objects.count() == 1
 
-        self.ts.delete_all_group_tag_values(self.proj1group1.id)
+        self.ts.delete_all_group_tag_values(self.proj1.id, self.proj1group1.id)
 
         assert GroupTagValue.objects.count() == 0
+
+    def test_get_group_event_ids(self):
+        tags = {
+            'abc': 'xyz',
+            'foo': 'bar',
+            'baz': 'quux',
+        }
+
+        def _create_tags_for_dict(tags):
+            ids = []
+            for k, v in tags.items():
+                key, _ = self.ts.get_or_create_tag_key(self.proj1.id, self.proj1env1.id, k)
+                value, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, k, v)
+                ids.append((key.id, value.id))
+            return ids
+
+        tags_ids = _create_tags_for_dict(tags)
+
+        # 2 events with the same tags
+        for event in (self.proj1group1event1, self.proj1group1event2):
+            self.ts.create_event_tags(
+                project_id=self.proj1.id,
+                group_id=self.proj1group1.id,
+                environment_id=self.proj1env1.id,
+                event_id=event.id,
+                tags=tags_ids,
+            )
+
+        different_tags = {
+            'abc': 'DIFFERENT',
+            'foo': 'bar',
+            'baz': 'quux',
+        }
+
+        different_tags_ids = _create_tags_for_dict(different_tags)
+
+        # 1 event with different tags
+        self.ts.create_event_tags(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            event_id=self.proj1group1event3.id,
+            tags=different_tags_ids,
+        )
+
+        assert len(
+            self.ts.get_group_event_ids(
+                self.proj1.id,
+                self.proj1group1.id,
+                self.proj1env1.id,
+                tags)) == 2
+
+    def test_get_groups_user_counts(self):
+        k1, _ = self.ts.get_or_create_group_tag_key(
+            self.proj1.id,
+            self.proj1group1.id,
+            self.proj1env1.id,
+            'sentry:user')
+        k1.values_seen = 7
+        k1.save()
+
+        k2, _ = self.ts.get_or_create_group_tag_key(
+            self.proj1.id,
+            self.proj1group2.id,
+            self.proj1env1.id,
+            'sentry:user')
+        k2.values_seen = 11
+        k2.save()
+
+        assert dict(
+            self.ts.get_groups_user_counts(
+                self.proj1.id,
+                [self.proj1group1.id, self.proj1group2.id],
+                self.proj1env1.id).items()) == {self.proj1group1.id: 7, self.proj1group2.id: 11}
+
+    def test_get_group_tag_value_count(self):
+        v1, _ = self.ts.get_or_create_group_tag_value(
+            self.proj1.id,
+            self.proj1group1.id,
+            self.proj1env1.id,
+            self.key1,
+            'value1')
+        v1.times_seen = 7
+        v1.save()
+
+        v2, _ = self.ts.get_or_create_group_tag_value(
+            self.proj1.id,
+            self.proj1group1.id,
+            self.proj1env1.id,
+            self.key1,
+            'value2')
+        v2.times_seen = 11
+        v2.save()
+
+        assert self.ts.get_group_tag_value_count(
+            self.proj1.id,
+            self.proj1group1.id,
+            self.proj1env1.id,
+            self.key1,
+        ) == 18
+
+    def test_get_top_group_tag_values(self):
+        v1, _ = self.ts.get_or_create_group_tag_value(
+            self.proj1.id,
+            self.proj1group1.id,
+            self.proj1env1.id,
+            self.key1,
+            'value1')
+        v1.times_seen = 7
+        v1.save()
+
+        v2, _ = self.ts.get_or_create_group_tag_value(
+            self.proj1.id,
+            self.proj1group1.id,
+            self.proj1env1.id,
+            self.key1,
+            'value2')
+        v2.times_seen = 11
+        v2.save()
+
+        resp = self.ts.get_top_group_tag_values(
+            self.proj1.id,
+            self.proj1group1.id,
+            self.proj1env1.id,
+            self.key1,
+        )
+
+        assert resp[0].times_seen == 11
+        assert resp[0].key == self.key1
+        assert resp[0].group_id == self.proj1group1.id
+
+        assert resp[1].times_seen == 7
+        assert resp[1].key == self.key1
+        assert resp[1].group_id == self.proj1group1.id
+
+    def test_get_first_release(self):
+        v1, _ = self.ts.get_or_create_group_tag_value(
+            self.proj1.id,
+            self.proj1group1.id,
+            self.proj1env1.id,
+            'sentry:release',
+            '1.0')
+        v1.first_seen = datetime(2000, 1, 1)
+        v1.save()
+
+        v2, _ = self.ts.get_or_create_group_tag_value(
+            self.proj1.id,
+            self.proj1group1.id,
+            self.proj1env1.id,
+            'sentry:release',
+            '2.0')
+        v2.first_seen = datetime(2000, 1, 2)
+        v2.save()
+
+        assert self.ts.get_first_release(
+            self.proj1.id,
+            self.proj1group1.id,
+        ) == '1.0'
+
+    def test_get_last_release(self):
+        v1, _ = self.ts.get_or_create_group_tag_value(
+            self.proj1.id,
+            self.proj1group1.id,
+            self.proj1env1.id,
+            'sentry:release',
+            '1.0')
+        v1.last_seen = datetime(2000, 1, 1)
+        v1.save()
+
+        v2, _ = self.ts.get_or_create_group_tag_value(
+            self.proj1.id,
+            self.proj1group1.id,
+            self.proj1env1.id,
+            'sentry:release',
+            '2.0')
+        v2.last_seen = datetime(2000, 1, 2)
+        v2.save()
+
+        assert self.ts.get_last_release(
+            self.proj1.id,
+            self.proj1group1.id,
+        ) == '2.0'
+
+    def test_get_release_tags(self):
+        tv, _ = self.ts.get_or_create_tag_value(
+            self.proj1.id,
+            self.proj1env1.id,
+            'sentry:release',
+            '1.0'
+        )
+
+        assert self.ts.get_release_tags([self.proj1.id], self.proj1env1.id, ['1.0']) == [tv]
+
+    def test_get_group_ids_for_users(self):
+        from sentry.models import EventUser
+
+        v1, _ = self.ts.get_or_create_group_tag_value(
+            self.proj1.id,
+            self.proj1group1.id,
+            None,
+            'sentry:user',
+            'email:user@sentry.io')
+
+        eu = EventUser(project_id=self.proj1.id, email='user@sentry.io')
+
+        assert self.ts.get_group_ids_for_users(
+            [self.proj1.id],
+            [eu]) == [self.proj1group1.id]
+
+    def test_get_group_tag_values_for_users(self):
+        from sentry.models import EventUser
+
+        v1, _ = self.ts.get_or_create_group_tag_value(
+            self.proj1.id,
+            self.proj1group1.id,
+            None,
+            'sentry:user',
+            'email:user@sentry.io')
+
+        eu = EventUser(project_id=self.proj1.id, email='user@sentry.io')
+
+        assert self.ts.get_group_tag_values_for_users([eu]) == [v1]
+
+    def test_get_group_ids_for_search_filter(self):
+        tags = {
+            'foo': 'bar',
+            'baz': 'quux',
+        }
+
+        for k, v in tags.items():
+            v1, _ = self.ts.get_or_create_group_tag_value(
+                self.proj1.id,
+                self.proj1group1.id,
+                self.proj1env1.id,
+                k,
+                v)
+
+        assert self.ts.get_group_ids_for_search_filter(
+            self.proj1.id, self.proj1env1.id, tags) == [self.proj1group1.id]
+
+    def test_update_group_for_events(self):
+        v1, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k1', 'v1')
+        v2, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k2', 'v2')
+        v3, _ = self.ts.get_or_create_tag_value(self.proj1.id, self.proj1env1.id, 'k3', 'v3')
+
+        tags = [(v1._key.id, v1.id), (v2._key.id, v2.id), (v3._key.id, v3.id)]
+        self.ts.create_event_tags(
+            project_id=self.proj1.id,
+            group_id=self.proj1group1.id,
+            environment_id=self.proj1env1.id,
+            event_id=self.proj1group1event1.id,
+            tags=tags
+        )
+
+        assert EventTag.objects.filter(group_id=self.proj1group2.id).count() == 0
+
+        self.ts.update_group_for_events(
+            self.proj1.id, [
+                self.proj1group1event1.id], self.proj1group2.id)
+
+        assert EventTag.objects.filter(group_id=self.proj1group2.id).count() == 3
diff --git a/tests/sentry/tasks/post_process/tests.py b/tests/sentry/tasks/post_process/tests.py
index f1ac2649d5..8227886328 100644
--- a/tests/sentry/tasks/post_process/tests.py
+++ b/tests/sentry/tasks/post_process/tests.py
@@ -7,6 +7,7 @@ from django.utils import timezone
 from mock import Mock, patch
 
 from sentry import tagstore
+from sentry.tagstore.models import EventTag
 from sentry.models import Group, GroupSnooze, GroupStatus
 from sentry.testutils import TestCase
 from sentry.tasks.merge import merge_group
@@ -125,7 +126,7 @@ class IndexEventTagsTest(TestCase):
                 tags=[('foo', 'bar'), ('biz', 'baz')],
             )
 
-        tags = list(tagstore.get_event_tag_qs(
+        tags = list(EventTag.objects.filter(
             event_id=event.id,
         ).values_list('key_id', 'value_id'))
         assert len(tags) == 2
@@ -167,7 +168,7 @@ class IndexEventTagsTest(TestCase):
                 tags=[('foo', 'bar'), ('biz', 'baz')],
             )
 
-        queryset = tagstore.get_event_tag_qs(
+        queryset = EventTag.objects.filter(
             event_id=event.id,
         )
         assert queryset.count() == 2
diff --git a/tests/sentry/tasks/test_deletion.py b/tests/sentry/tasks/test_deletion.py
index 7b28f076bd..b7ca1126c6 100644
--- a/tests/sentry/tasks/test_deletion.py
+++ b/tests/sentry/tasks/test_deletion.py
@@ -7,6 +7,7 @@ from uuid import uuid4
 import pytest
 
 from sentry import tagstore
+from sentry.tagstore.models import EventTag
 from sentry.constants import ObjectStatus
 from sentry.exceptions import DeleteAborted
 from sentry.models import (
@@ -243,7 +244,7 @@ class DeleteTagKeyTest(TestCase):
         with self.tasks():
             delete_tag_key_task(object_id=tk.id)
 
-            assert tagstore.get_event_tag_qs(key_id=tk.id).exists()
+            assert EventTag.objects.filter(key_id=tk.id).exists()
             try:
                 tagstore.get_group_tag_value(group.project_id, group.id, None, key, value)
                 assert False  # verify exception thrown
@@ -269,7 +270,7 @@ class DeleteTagKeyTest(TestCase):
         assert tagstore.get_group_tag_key(group2.project_id, group2.id, None, key) is not None
         assert tagstore.get_group_tag_value(
             group2.project_id, group2.id, None, key, value) is not None
-        assert tagstore.get_event_tag_qs(key_id=tk2.id).exists()
+        assert EventTag.objects.filter(key_id=tk2.id).exists()
 
 
 class DeleteGroupTest(TestCase):
@@ -322,7 +323,7 @@ class DeleteGroupTest(TestCase):
             event_id='a' * 32,
             group_id=group.id,
         ).exists()
-        assert not tagstore.get_event_tag_qs(event_id=event.id).exists()
+        assert not EventTag.objects.filter(event_id=event.id).exists()
         assert not GroupRedirect.objects.filter(group_id=group.id).exists()
         assert not GroupHash.objects.filter(group_id=group.id).exists()
         assert not Group.objects.filter(id=group.id).exists()

commit bea256b0308406e2908ebbc9ee4312bd46a812bd
Author: David Cramer <dcramer@gmail.com>
Date:   Thu Jun 14 22:28:11 2012 -0700

    Clean up and separate some logic in NotificationPlugin and expand (and fix) test coverage

diff --git a/sentry/plugins/bases/notify.py b/sentry/plugins/bases/notify.py
index c75a60eaee..11240a9f5d 100644
--- a/sentry/plugins/bases/notify.py
+++ b/sentry/plugins/bases/notify.py
@@ -11,6 +11,7 @@ from django.utils.translation import ugettext_lazy as _
 from sentry.conf import settings
 from sentry.plugins import Plugin
 from sentry.models import UserOption
+from sentry.utils.cache import cache
 from sentry.web.helpers import get_project_list
 
 
@@ -79,6 +80,39 @@ class NotificationPlugin(Plugin):
     def notify_users(self, group, event, fail_silently=False):
         raise NotImplementedError
 
+    def get_sendable_users(self, project):
+        conf_key = self.get_conf_key()
+
+        disabled = set(UserOption.objects.filter(
+            project=project,
+            key='%s:alert' % conf_key,
+            value=0,
+        ).values_list('user', flat=True))
+
+        # fetch remaining users
+        member_set = set(project.team.member_set.exclude(user__in=disabled).values_list('user', flat=True))
+
+        return member_set
+
+    def get_emails_for_users(self, user_ids):
+        email_list = set()
+        user_ids = set(user_ids)
+
+        # we cant use values on alert_queryset as the value field gets encoded
+        alert_queryset = UserOption.objects.filter(
+            user__in=user_ids,
+            key='alert_email',
+        )
+        for option in alert_queryset:
+            user_ids.remove(option.user_id)
+            email_list.add(option.value)
+
+        # if any didnt exist, grab their default email
+        if user_ids:
+            email_list |= set(User.objects.filter(pk__in=user_ids).values_list('email', flat=True))
+
+        return email_list
+
     def get_send_to(self, project=None):
         """
         Returns a list of email addresses for the users that should be notified of alerts.
@@ -88,45 +122,34 @@ class NotificationPlugin(Plugin):
         - Includes admins if ``send_to_admins`` is enabled.
         - Includes members if ``send_to_members`` is enabled **and** the user has not disabled alerts
           for this project
+
+        The results of this call can be fairly expensive to calculate, so the send_to list gets cached
+        for 60 seconds.
         """
-        # TODO: this method is pretty expensive, and users is a small enough amount of data that we should
-        # be able to keep most of this in memory constantly
-        send_to_list = set()
-
-        send_to_admins = self.get_option('send_to_admins', project)
-
-        if send_to_admins:
-            send_to_list |= set(settings.ADMINS)
-
-        send_to_members = self.get_option('send_to_members', project)
-        if send_to_members and project and project.team:
-            # fetch users whom have disabled alerts for this plugin
-            disabled = set(UserOption.objects.filter(
-                project=project,
-                key='%s:alert' % self.get_conf_key,
-                value=0,
-            ).values_list('user', flat=True))
-
-            # fetch remaining users
-            member_set = set(project.team.member_set.exclude(user__in=disabled).values_list('user', flat=True))
-
-            # we need to first fetch their specified alert email address
-            alert_queryset = UserOption.objects.filter(
-                user__in=member_set,
-                key='alert_email',
-            ).values_list(
-                'user',
-                'alert_email',
-            )
-            for user_id, email in alert_queryset:
-                member_set.remove(user_id)
-                send_to_list.add(email)
-
-            # if any didnt exist, grab their default email
-            if member_set:
-                send_to_list |= set(User.objects.filter(pk__in=member_set).values_list('email', flat=True))
-
-        return filter(bool, send_to_list)
+        if project:
+            project_id = project.pk
+        else:
+            project_id = ''
+        conf_key = self.get_conf_key()
+        cache_key = '%s:send_to:%s' % (conf_key, project_id)
+
+        send_to_list = cache.get(cache_key)
+        if send_to_list is None:
+            send_to_list = set()
+
+            send_to_admins = self.get_option('send_to_admins', project)
+
+            if send_to_admins:
+                send_to_list |= set(settings.ADMINS)
+
+            send_to_members = self.get_option('send_to_members', project)
+            if send_to_members and project and project.team:
+                member_set = self.get_sendable_users(project)
+                send_to_list |= set(self.get_emails_for_users(member_set))
+
+            send_to_list = filter(bool, send_to_list)
+            cache.set(cache_key, send_to_list, 60)  # 1 minute cache
+        return send_to_list
 
     def should_notify(self, group, event):
         project = group.project
diff --git a/tests/sentry/plugins/mail/tests.py b/tests/sentry/plugins/mail/tests.py
index 9dba5a72fc..ce772a9010 100644
--- a/tests/sentry/plugins/mail/tests.py
+++ b/tests/sentry/plugins/mail/tests.py
@@ -185,55 +185,87 @@ class MailProcessorTest(TestCase):
         args, kwargs = _send_mail.call_args
         self.assertEquals(kwargs.get('subject'), u"[Project Name] ERROR: hello world")
 
-    def test_send_to(self):
-        Mock = mock.Mock
-        with mock.patch('sentry.models.ProjectOption.objects.get_value') as get_value:
-            opts = {}
-            get_value.side_effect = lambda p, k, d: opts.get(k, d)
-
-            admins = ['admin@fake.com']
-            member_emails = ['test@fake.com', 'member@fake.com']
-            project_emails = ['member@fake.com', 'new@fake.com']
-
-            project = Mock()
-            project.team.member_set = Mock()
-            project.team.member_set.values_list.return_value = member_emails
-
-            with self.Settings(SENTRY_ADMINS=admins):
-                # member emails without admins
-                p = MailProcessor()
-                self.assertEqual(sorted(set(member_emails)),
-                                 sorted(p.get_send_to(project)))
-
-                # member emails with members
-                p = MailProcessor()
-                opts = {'mail:send_to_admins': True}
-                p._send_mail('', '', project=project)
-                self.assertEqual(sorted(set(member_emails + admins)),
-                                 sorted(p.get_send_to(project)))
-
-                # project emails without members
-                p = MailProcessor()
-                opts = {'mail:send_to': ','.join(project_emails),
-                        'mail:send_to_members': False}
-                p._send_mail('', '', project=project)
-                self.assertEqual(sorted(set(project_emails)),
-                                 sorted(p.get_send_to(project)))
-
-                # project emails with members
-                p = MailProcessor()
-                opts = {'mail:send_to': ','.join(project_emails),
-                        'mail:send_to_members': False,
-                        'mail:send_to_admins': True}
-                p._send_mail('', '', project=project)
-                self.assertEqual(sorted(set(project_emails + admins)),
-                                 sorted(p.get_send_to(project)))
-
-                # project emails with members and admins
-                p = MailProcessor()
-                opts = {'mail:send_to': ','.join(project_emails),
-                        'mail:send_to_members': True,
-                        'mail:send_to_admins': True}
-                p._send_mail('', '', project=project)
-                self.assertEqual(sorted(set(project_emails + admins + member_emails)),
-                                 sorted(p.get_send_to(project)))
+    @mock.patch('sentry.utils.cache.cache.get', mock.Mock(return_value=None))
+    @mock.patch('sentry.models.ProjectOption.objects.get_value')
+    @mock.patch('sentry.plugins.sentry_mail.models.MailProcessor.get_sendable_users')
+    @mock.patch('sentry.plugins.sentry_mail.models.MailProcessor.get_emails_for_users')
+    def test_send_to(self, get_emails_for_users, get_sendable_users, get_value):
+        opts = {}
+
+        admins = ['1']
+        member_emails = ['2', '3']
+        project_emails = ['2', '4']
+
+        get_value.side_effect = lambda p, k, d: opts.get(k, d)
+        get_emails_for_users.side_effect = lambda x: x
+        get_sendable_users.return_value = member_emails
+
+        project = mock.Mock()
+
+        with self.Settings(SENTRY_ADMINS=admins):
+            p = MailProcessor()
+            # member emails without admins
+            self.assertEqual(sorted(set(member_emails)),
+                             sorted(p.get_send_to(project)))
+
+            # member emails with members
+            opts = {'mail:send_to_admins': True}
+            self.assertEqual(sorted(set(member_emails + admins)),
+                             sorted(p.get_send_to(project)))
+
+            # project emails without members
+            opts = {'mail:send_to': ','.join(project_emails),
+                    'mail:send_to_members': False}
+            self.assertEqual(sorted(set(project_emails)),
+                             sorted(p.get_send_to(project)))
+
+            # project emails with members
+            opts = {'mail:send_to': ','.join(project_emails),
+                    'mail:send_to_members': False,
+                    'mail:send_to_admins': True}
+            self.assertEqual(sorted(set(project_emails + admins)),
+                             sorted(p.get_send_to(project)))
+
+            # project emails with members and admins
+            opts = {'mail:send_to': ','.join(project_emails),
+                    'mail:send_to_members': True,
+                    'mail:send_to_admins': True}
+            self.assertEqual(sorted(set(project_emails + admins + member_emails)),
+                             sorted(p.get_send_to(project)))
+
+    def test_get_emails_for_users(self):
+        from django.contrib.auth.models import User
+        from sentry.models import UserOption
+
+        user = User.objects.create(username='foo', email='foo@example.com')
+        user2 = User.objects.create(username='baz', email='baz@example.com')
+
+        p = MailProcessor()
+
+        self.assertEquals(sorted(p.get_emails_for_users([user.pk, user2.pk])),
+                          sorted([user.email, user2.email]))
+        UserOption.objects.create(key='alert_email', value='foobaz@example.com', user=user2)
+
+        self.assertEquals(sorted(p.get_emails_for_users([user.pk, user2.pk])),
+                          sorted([user.email, 'foobaz@example.com']))
+
+    def test_get_sendable_users(self):
+        from django.contrib.auth.models import User
+        from sentry.models import Project, UserOption
+
+        user = User.objects.create(username='foo', email='foo@example.com')
+        user2 = User.objects.create(username='baz', email='baz@example.com')
+        project = Project.objects.create(name='Test', slug='test', owner=user)
+        project.team.member_set.get_or_create(user=user)
+        project.team.member_set.get_or_create(user=user2)
+
+        p = MailProcessor()
+
+        # all members
+        self.assertEqual(sorted(set([user.pk, user2.pk])),
+                         sorted(p.get_sendable_users(project)))
+
+        # disabled user2
+        UserOption.objects.create(key='mail:alert', value=0, project=project, user=user2)
+        self.assertEqual(sorted(set([user.pk])),
+                         sorted(p.get_sendable_users(project)))

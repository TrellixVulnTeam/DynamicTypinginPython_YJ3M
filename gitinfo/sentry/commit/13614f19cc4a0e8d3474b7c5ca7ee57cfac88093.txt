commit 13614f19cc4a0e8d3474b7c5ca7ee57cfac88093
Author: Victor Perron <victor@iso3103.net>
Date:   Wed Nov 5 18:15:23 2014 +0100

    Replace urllib2 with python-requests

diff --git a/setup.py b/setup.py
index 7aef202625..5c7238a3fb 100755
--- a/setup.py
+++ b/setup.py
@@ -99,6 +99,10 @@ install_requires = [
     'toronado>=0.0.4,<0.1.0',
     'ua-parser>=0.3.5',
     'urllib3>=1.7.1,<1.8.0',
+    'ndg-httpsclient>=0.3.2',
+    'pyOpenSSL>=0.14',
+    'pyasn1>=0.1.7',
+    'requests>=2.4.3',
 ]
 
 postgres_requires = [
diff --git a/src/sentry/http.py b/src/sentry/http.py
index 3a2be7dc27..33a39ab9dc 100644
--- a/src/sentry/http.py
+++ b/src/sentry/http.py
@@ -10,7 +10,7 @@ from __future__ import absolute_import
 import re
 import sentry
 import socket
-import urllib2
+import requests
 import zlib
 
 from django.conf import settings
@@ -31,13 +31,6 @@ DEFAULT_USER_AGENT = 'sentry/%s' % sentry.VERSION
 DISALLOWED_IPS = set((IPNetwork(i) for i in settings.SENTRY_DISALLOWED_IPS))
 
 
-class NoRedirectionHandler(urllib2.HTTPErrorProcessor):
-    def http_response(self, request, response):
-        return response
-
-    https_response = http_response
-
-
 def is_valid_url(url):
     """
     Tests a URL to ensure it doesn't appear to be a blacklisted IP range.
@@ -69,22 +62,15 @@ def safe_urlopen(url, data=None, headers=DEFAULT_HEADERS,
     if not is_valid_url(url):
         raise SuspiciousOperation('%s matches the URL blacklist' % (url,))
 
-    req = urllib2.Request(url, data)
-    req.add_header('User-Agent', user_agent)
-    for key, value in headers:
-        req.add_header(key, value)
-
-    handlers = []
-    if not allow_redirects:
-        handlers.append(NoRedirectionHandler)
-
-    opener = urllib2.build_opener(*handlers)
+    all_headers = {header[0]: header[1] for header in headers}
+    all_headers.update({'User-Agent': user_agent})
 
-    return opener.open(req, timeout=timeout)
+    return requests.get(url, headers=all_headers, data=data, stream=True,
+                        allow_redirects=allow_redirects, timeout=timeout)
 
 
 def safe_urlread(request):
-    body = request.read()
+    body = request.raw.read()
 
     if request.headers.get('content-encoding') == 'gzip':
         # Content doesn't *have* to respect the Accept-Encoding header

commit 9486374c0c37aa58a112bd4c0cc15774840547db
Author: Matt Robenolt <matt@ydekproductions.com>
Date:   Mon Oct 17 13:54:43 2016 -0700

    sourcemaps: abstract out sourcemap parsing into a View to encapsulate logic (#4365)
    
    This will allow a smooth transition into libsourcemap

diff --git a/src/sentry/lang/javascript/processor.py b/src/sentry/lang/javascript/processor.py
index 44bd5bc2a1..e2e7699fa9 100644
--- a/src/sentry/lang/javascript/processor.py
+++ b/src/sentry/lang/javascript/processor.py
@@ -37,7 +37,7 @@ from sentry.utils.strings import truncatechars
 from sentry.utils import metrics
 
 from .cache import SourceCache, SourceMapCache
-from .sourcemaps import sourcemap_to_index, find_source, get_inline_content_sources
+from .sourcemaps import from_json as view_from_json
 
 
 # number of surrounding lines (on each side) to fetch
@@ -494,6 +494,8 @@ def fetch_sourcemap(url, project=None, release=None, allow_scraping=True):
     if is_data_uri(url):
         body = base64.b64decode(url[BASE64_PREAMBLE_LENGTH:])
     else:
+        # TODO(mattrobenolt): this is returning unicodes, and there's no
+        # reason we need to do this. We operate on this payload as bytes.
         result = fetch_file(url, project=project, release=release,
                             allow_scraping=allow_scraping)
         body = result.body
@@ -505,8 +507,7 @@ def fetch_sourcemap(url, project=None, release=None, allow_scraping=True):
         # [2] http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-xssi
         if body.startswith((u")]}'\n", u")]}\n")):
             body = body.split(u'\n', 1)[1]
-
-        return sourcemap_to_index(body)
+        return view_from_json(body)
     except Exception as exc:
         # This is in debug because the product shows an error already.
         logger.debug(six.text_type(exc), exc_info=True)
@@ -700,8 +701,8 @@ class SourceProcessor(object):
                 frame.module = generate_module(frame.abs_path)
 
     def expand_frames(self, frames, release):
-        last_state = None
-        state = None
+        last_token = None
+        token = None
 
         cache = self.cache
         sourcemaps = self.sourcemaps
@@ -722,14 +723,14 @@ class SourceProcessor(object):
                 logger.debug('No source found for %s', frame.abs_path)
                 continue
 
-            sourcemap_url, sourcemap_idx = sourcemaps.get_link(frame.abs_path)
-            if sourcemap_idx and frame.colno is None:
+            sourcemap_url, sourcemap_view = sourcemaps.get_link(frame.abs_path)
+            if sourcemap_view and frame.colno is None:
                 all_errors.append({
                     'type': EventError.JS_NO_COLUMN,
                     'url': expose_url(frame.abs_path),
                 })
-            elif sourcemap_idx:
-                last_state = state
+            elif sourcemap_view:
+                last_token = token
 
                 if is_data_uri(sourcemap_url):
                     sourcemap_label = frame.abs_path
@@ -739,9 +740,12 @@ class SourceProcessor(object):
                 sourcemap_label = expose_url(sourcemap_label)
 
                 try:
-                    state = find_source(sourcemap_idx, frame.lineno, frame.colno)
+                    # Errors are 1-indexed in the frames, so we need to -1 to get
+                    # zero-indexed value from tokens.
+                    assert frame.lineno > 0, "line numbers are 1-indexed"
+                    token = sourcemap_view.lookup_token(frame.lineno - 1, frame.colno)
                 except Exception:
-                    state = None
+                    token = None
                     all_errors.append({
                         'type': EventError.JS_INVALID_SOURCEMAP_LOCATION,
                         'column': frame.colno,
@@ -761,8 +765,8 @@ class SourceProcessor(object):
 
                 sourcemap_applied = True
 
-                if state is not None:
-                    abs_path = urljoin(sourcemap_url, state.src)
+                if token is not None:
+                    abs_path = urljoin(sourcemap_url, token.src)
 
                     logger.debug('Mapping compressed source %r to mapping in %r', frame.abs_path, abs_path)
                     source = self.get_source(abs_path, release)
@@ -777,18 +781,18 @@ class SourceProcessor(object):
                             'url': expose_url(abs_path),
                         })
 
-                if state is not None:
-                    # SourceMap's return zero-indexed lineno's
-                    frame.lineno = state.src_line + 1
-                    frame.colno = state.src_col
+                if token is not None:
+                    # Token's return zero-indexed lineno's
+                    frame.lineno = token.src_line + 1
+                    frame.colno = token.src_col
                     # The offending function is always the previous function in the stack
                     # Honestly, no idea what the bottom most frame is, so we're ignoring that atm
-                    if last_state:
-                        frame.function = last_state.name or frame.function
+                    if last_token:
+                        frame.function = last_token.name or frame.function
                     else:
-                        frame.function = state.name or frame.function
+                        frame.function = token.name or frame.function
 
-                    filename = state.src
+                    filename = token.src
                     # special case webpack support
                     # abs_path will always be the full path with webpack:/// prefix.
                     # filename will be relative to that
@@ -879,7 +883,7 @@ class SourceProcessor(object):
 
         # pull down sourcemap
         try:
-            sourcemap_idx = fetch_sourcemap(
+            sourcemap_view = fetch_sourcemap(
                 sourcemap_url,
                 project=self.project,
                 release=release,
@@ -889,12 +893,17 @@ class SourceProcessor(object):
             cache.add_error(filename, exc.data)
             return
 
-        sourcemaps.add(sourcemap_url, sourcemap_idx)
+        sourcemaps.add(sourcemap_url, sourcemap_view)
 
         # cache any inlined sources
-        inline_sources = get_inline_content_sources(sourcemap_idx, sourcemap_url)
-        for source in inline_sources:
-            self.cache.add(*source)
+        # inline_sources = sourcemap_view.get_inline_content_sources(sourcemap_url)
+        for src_id, source in sourcemap_view.iter_sources():
+            # TODO(mattrobenolt): This is slightly less than ideal,
+            # but it's the simplest path for now.
+            # Ideally, we would do this lazily.
+            content = sourcemap_view.get_source_contents(src_id)
+            if content is not None:
+                self.cache.add(urljoin(sourcemap_url, source), content)
 
     def populate_source_cache(self, frames, release):
         """
diff --git a/src/sentry/lang/javascript/sourcemaps.py b/src/sentry/lang/javascript/sourcemaps.py
deleted file mode 100644
index 5cd37d02cc..0000000000
--- a/src/sentry/lang/javascript/sourcemaps.py
+++ /dev/null
@@ -1,231 +0,0 @@
-"""
-sentry.utils.sourcemaps
-~~~~~~~~~~~~~~~~~~~~~~~
-
-Originally based on https://github.com/martine/python-sourcemap
-
-Sentry implements the Source Map Revision 3 protocol. Specification:
-https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit
-
-Sentry supports both "standard" source maps, and has partial support for "indexed" source
-maps. Specifically, it supports indexed source maps with the "map" section property as
-output by the React Native bundler. It does NOT support indexed source maps with the "url"
-section property.
-
-:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-from __future__ import absolute_import
-
-import bisect
-
-from collections import namedtuple
-from six.moves.urllib.parse import urljoin
-
-from sentry.utils import json
-
-
-SourceMap = namedtuple('SourceMap', ['dst_line', 'dst_col', 'src', 'src_line', 'src_col', 'name'])
-SourceMapIndex = namedtuple('SourceMapIndex', ['states', 'keys', 'sources', 'content'])
-IndexedSourceMapIndex = namedtuple('IndexedSourceMapIndex', ['offsets', 'maps'])
-
-# Mapping of base64 letter -> integer value.
-B64 = dict(
-    (c, i) for i, c in
-    enumerate('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/')
-)
-
-
-def parse_vlq(segment):
-    """
-    Parse a string of VLQ-encoded data.
-
-    Returns:
-      a list of integers.
-    """
-
-    values = []
-
-    cur, shift = 0, 0
-    for c in segment:
-        val = B64[c]
-        # Each character is 6 bits:
-        # 5 of value and the high bit is the continuation.
-        val, cont = val & 0b11111, val >> 5
-        cur += val << shift
-        shift += 5
-
-        if not cont:
-            # The low bit of the unpacked value is the sign.
-            cur, sign = cur >> 1, cur & 1
-            if sign:
-                cur = -cur
-            values.append(cur)
-            cur, shift = 0, 0
-
-    if cur or shift:
-        raise Exception('leftover cur/shift in vlq decode')
-
-    return values
-
-
-def parse_sourcemap(smap):
-    """
-    Given a sourcemap json object, yield SourceMap objects as they are read from it.
-    """
-    sources = smap['sources']
-    sourceRoot = smap.get('sourceRoot')
-    names = smap.get('names', [])
-    mappings = smap['mappings']
-    lines = mappings.split(';')
-
-    if sourceRoot:
-        # turn /foo/bar into /foo/bar/ so urljoin doesnt strip the last path
-        if not sourceRoot.endswith('/'):
-            sourceRoot = sourceRoot + '/'
-
-        sources = [
-            urljoin(sourceRoot, src)
-            for src in sources
-        ]
-
-    dst_col, src_id, src_line, src_col, name_id = 0, 0, 0, 0, 0
-    for dst_line, line in enumerate(lines):
-        segments = line.split(',')
-        dst_col = 0
-        for segment in segments:
-            if not segment:
-                continue
-            parse = parse_vlq(segment)
-            dst_col += parse[0]
-
-            src = None
-            name = None
-            if len(parse) > 1:
-                src_id += parse[1]
-                src = sources[src_id]
-                src_line += parse[2]
-                src_col += parse[3]
-
-                if len(parse) > 4:
-                    name_id += parse[4]
-                    name = names[name_id]
-
-            assert dst_line >= 0
-            assert dst_col >= 0
-            assert src_line >= 0
-            assert src_col >= 0
-
-            yield SourceMap(dst_line, dst_col, src, src_line, src_col, name)
-
-
-def _sourcemap_to_index(smap):
-    state_list = []
-    key_list = []
-    src_list = set()
-    content = {}
-    sourceRoot = smap.get('sourceRoot')
-
-    # turn /foo/bar into /foo/bar/ so urljoin doesnt strip the last path
-    if sourceRoot and not sourceRoot.endswith('/'):
-        sourceRoot = sourceRoot + '/'
-
-    if smap.get('sourcesContent'):
-        for idx, source in enumerate(smap['sources']):
-            # Ensure we handle null files that may be specified outside of
-            # sourcesContent
-            try:
-                value = smap['sourcesContent'][idx]
-            except IndexError:
-                continue
-
-            if value is None:
-                continue
-
-            # Apply the root to the source before shoving into the index
-            # so we can look it up correctly later
-            source = urljoin(sourceRoot, source)
-            content[source] = value.split('\n')
-
-    for state in parse_sourcemap(smap):
-        state_list.append(state)
-        key_list.append((state.dst_line, state.dst_col))
-
-        # Apparently it's possible to not have a src
-        # specified in the vlq segments
-        if state.src is not None:
-            src_list.add(state.src)
-
-    return SourceMapIndex(state_list, key_list, src_list, content)
-
-
-def sourcemap_to_index(sourcemap):
-    """
-    Converts a raw sourcemap string to either a SourceMapIndex (basic source map)
-    or IndexedSourceMapIndex (indexed source map w/ "sections")
-    """
-    smap = json.loads(sourcemap)
-
-    if smap.get('sections'):
-        # indexed source map
-        offsets = []
-        maps = []
-        for section in smap.get('sections'):
-            offset = section.get('offset')
-
-            offsets.append((offset.get('line'), offset.get('column')))
-            maps.append(_sourcemap_to_index(section.get('map')))
-
-        return IndexedSourceMapIndex(offsets, maps)
-    else:
-        # standard source map
-        return _sourcemap_to_index(smap)
-
-
-def get_inline_content_sources(sourcemap_index, sourcemap_url):
-    """
-    Returns a list of tuples of (filename, content) for each inline
-    content found in the given source map index. Note that `content`
-    itself is a list of code lines.
-    """
-    out = []
-    if isinstance(sourcemap_index, IndexedSourceMapIndex):
-        for smap in sourcemap_index.maps:
-            out += get_inline_content_sources(smap, sourcemap_url)
-    else:
-        for source in sourcemap_index.sources:
-            next_filename = urljoin(sourcemap_url, source)
-            if source in sourcemap_index.content:
-                out.append((next_filename, sourcemap_index.content[source]))
-    return out
-
-
-def find_source(sourcemap_index, lineno, colno):
-    """
-    Given a SourceMapIndex and a transformed lineno/colno position,
-    return the SourceMap object (which contains original file, line,
-    column, and token name)
-    """
-
-    # error says "line no 1, column no 56"
-    assert lineno > 0, 'line numbers are 1-indexed'
-
-    if isinstance(sourcemap_index, IndexedSourceMapIndex):
-        map_index = bisect.bisect_right(sourcemap_index.offsets, (lineno - 1, colno)) - 1
-        offset = sourcemap_index.offsets[map_index]
-        col_offset = 0 if lineno != offset[0] else offset[1]
-        state = find_source(
-            sourcemap_index.maps[map_index],
-            lineno - offset[0],
-            colno - col_offset,
-        )
-        return SourceMap(
-            state.dst_line + offset[0],
-            state.dst_col + col_offset,
-            state.src,
-            state.src_line,
-            state.src_col,
-            state.name
-        )
-    else:
-        return sourcemap_index.states[bisect.bisect_right(sourcemap_index.keys, (lineno - 1, colno)) - 1]
diff --git a/src/sentry/lang/javascript/sourcemaps/__init__.py b/src/sentry/lang/javascript/sourcemaps/__init__.py
new file mode 100644
index 0000000000..c81da2e126
--- /dev/null
+++ b/src/sentry/lang/javascript/sourcemaps/__init__.py
@@ -0,0 +1,3 @@
+from __future__ import absolute_import
+
+from .native import from_json  # NOQA
diff --git a/src/sentry/lang/javascript/sourcemaps/native.py b/src/sentry/lang/javascript/sourcemaps/native.py
new file mode 100644
index 0000000000..d78b3d5649
--- /dev/null
+++ b/src/sentry/lang/javascript/sourcemaps/native.py
@@ -0,0 +1,247 @@
+"""
+sentry.utils.sourcemaps
+~~~~~~~~~~~~~~~~~~~~~~~
+
+Originally based on https://github.com/martine/python-sourcemap
+
+Sentry implements the Source Map Revision 3 protocol. Specification:
+https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit
+
+Sentry supports both "standard" source maps, and has partial support for "indexed" source
+maps. Specifically, it supports indexed source maps with the "map" section property as
+output by the React Native bundler. It does NOT support indexed source maps with the "url"
+section property.
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+from __future__ import absolute_import
+
+from bisect import bisect_right
+
+from collections import namedtuple
+from six import text_type
+from six.moves.urllib.parse import urljoin
+
+from sentry.utils import json
+
+
+Token = namedtuple('Token', ['dst_line', 'dst_col', 'src', 'src_line', 'src_col', 'src_id', 'name'])
+SourceMapIndex = namedtuple('SourceMapIndex', ['tokens', 'keys', 'sources', 'content'])
+IndexedSourceMapIndex = namedtuple('IndexedSourceMapIndex', ['offsets', 'maps'])
+
+# Mapping of base64 letter -> integer value.
+B64 = dict(
+    (c, i) for i, c in
+    enumerate('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/')
+)
+
+
+def parse_vlq(segment):
+    """
+    Parse a string of VLQ-encoded data.
+
+    Returns:
+      a list of integers.
+    """
+
+    values = []
+
+    cur, shift = 0, 0
+    for c in segment:
+        val = B64[c]
+        # Each character is 6 bits:
+        # 5 of value and the high bit is the continuation.
+        val, cont = val & 0b11111, val >> 5
+        cur += val << shift
+        shift += 5
+
+        if not cont:
+            # The low bit of the unpacked value is the sign.
+            cur, sign = cur >> 1, cur & 1
+            if sign:
+                cur = -cur
+            values.append(cur)
+            cur, shift = 0, 0
+
+    if cur or shift:
+        raise Exception('leftover cur/shift in vlq decode')
+
+    return values
+
+
+def parse_sourcemap(smap):
+    """
+    Given a sourcemap json object, yield SourceMap objects as they are read from it.
+    """
+    sources = smap['sources']
+    names = smap.get('names', [])
+    mappings = smap['mappings']
+    lines = mappings.split(';')
+    sourceRoot = smap.get('sourceRoot')
+
+    # turn /foo/bar into /foo/bar/ so urljoin doesnt strip the last path
+    if sourceRoot:
+        if not sourceRoot[-1:] == '/':
+            sourceRoot = sourceRoot + '/'
+
+        sources = [
+            urljoin(sourceRoot, src)
+            for src in sources
+        ]
+
+    dst_col, src_id, src_line, src_col, name_id = 0, 0, 0, 0, 0
+    for dst_line, line in enumerate(lines):
+        segments = line.split(',')
+        dst_col = 0
+        for segment in segments:
+            if not segment:
+                continue
+            parse = parse_vlq(segment)
+
+            # Must be either 4 or 5 long
+            assert len(parse) in (4, 5)
+
+            dst_col += parse[0]
+
+            src_id += parse[1]
+            src = sources[src_id]
+            src_line += parse[2]
+            src_col += parse[3]
+
+            if len(parse) == 5:
+                name_id += parse[4]
+                name = names[name_id]
+            else:
+                name = None
+
+            assert dst_line >= 0
+            assert dst_col >= 0
+            assert src_line >= 0
+            assert src_col >= 0
+
+            yield Token(dst_line, dst_col, src, src_line, src_col, src_id, name)
+
+
+def _sourcemap_to_index(smap):
+    token_list = []
+    key_list = []
+    content = {}
+    sourceRoot = smap.get('sourceRoot')
+
+    # turn /foo/bar into /foo/bar/ so urljoin doesnt strip the last path
+    if sourceRoot:
+        if not sourceRoot[-1:] == '/':
+            sourceRoot = sourceRoot + '/'
+
+        smap['sources'] = [
+            urljoin(sourceRoot, src)
+            for src in smap['sources']
+        ]
+
+        # Pop off the sourceRoot key to prevent applying this again
+        # inside parse_sourcemap
+        smap.pop('sourceRoot')
+
+    if smap.get('sourcesContent'):
+        for src_id, source in enumerate(smap['sources']):
+            # Ensure we handle null files that may be specified outside of
+            # sourcesContent
+            try:
+                value = smap['sourcesContent'][src_id]
+            except IndexError:
+                continue
+
+            if value is None:
+                continue
+
+            content[src_id] = value.split('\n')
+
+    for token in parse_sourcemap(smap):
+        token_list.append(token)
+        key_list.append((token.dst_line, token.dst_col))
+
+    return SourceMapIndex(token_list, key_list, smap['sources'], content)
+
+
+class View(object):
+    def __init__(self, index):
+        self.index = index
+
+    @staticmethod
+    def from_json(sourcemap):
+        """
+        Converts a raw sourcemap string to either a SourceMapIndex (basic source map)
+        or IndexedSourceMapIndex (indexed source map w/ "sections")
+        """
+        if isinstance(sourcemap, text_type):
+            sourcemap = sourcemap.encode('utf-8')
+        smap = json.loads(sourcemap)
+
+        if smap.get('sections'):
+            # indexed source map
+            offsets = []
+            maps = []
+            for section in smap.get('sections'):
+                offset = section.get('offset')
+
+                offsets.append((offset.get('line'), offset.get('column')))
+                maps.append(_sourcemap_to_index(section.get('map')))
+        else:
+            # standard source map
+            offsets = [(0, 0)]
+            maps = [_sourcemap_to_index(smap)]
+
+        return View(IndexedSourceMapIndex(offsets, maps))
+
+    def iter_sources(self):
+        for map_id, smap in enumerate(self.index.maps):
+            for src_id, source in enumerate(smap.sources):
+                yield (map_id, src_id), source
+
+    def get_source_contents(self, (map_id, src_id)):
+        try:
+            return self.index.maps[map_id].content[src_id]
+        except LookupError:
+            return None
+
+    def lookup_token(self, lineno, colno):
+        """
+        Given a SourceMapIndex and a transformed lineno/colno position,
+        return the SourceMap object (which contains original file, line,
+        column, and token name)
+        """
+        if lineno < 0 or colno < 0:
+            return None
+
+        smap_index = self.index
+
+        # Optimize for the case where we only have 1 map which is
+        # most common.
+        if len(smap_index.maps) == 1:
+            smap = smap_index.maps[0]
+            line_offset = 0
+            col_offset = 0
+        else:
+            map_index = bisect_right(smap_index.offsets, (lineno, colno)) - 1
+            offset = smap_index.offsets[map_index]
+            smap = smap_index.maps[map_index]
+            line_offset = offset[0]
+            col_offset = 0 if lineno != offset[0] else offset[1]
+            lineno -= line_offset
+            colno -= col_offset
+
+        token = smap.tokens[bisect_right(smap.keys, (lineno, colno)) - 1]
+        return Token(
+            token.dst_line + line_offset,
+            token.dst_col + col_offset,
+            token.src,
+            token.src_line,
+            token.src_col,
+            token.src_id,
+            token.name,
+        )
+
+
+# For API Compatibility with libsourcemap
+from_json = View.from_json
diff --git a/tests/sentry/lang/javascript/test_processor.py b/tests/sentry/lang/javascript/test_processor.py
index bfdc31a7a5..bb4126d532 100644
--- a/tests/sentry/lang/javascript/test_processor.py
+++ b/tests/sentry/lang/javascript/test_processor.py
@@ -14,7 +14,7 @@ from sentry.lang.javascript.processor import (
     BadSource, discover_sourcemap, fetch_sourcemap, fetch_file, generate_module,
     SourceProcessor, trim_line, UrlResult, fetch_release_file
 )
-from sentry.lang.javascript.sourcemaps import SourceMap, SourceMapIndex
+from sentry.lang.javascript.sourcemaps.native import Token, SourceMapIndex, IndexedSourceMapIndex
 from sentry.lang.javascript.errormapping import (
     rewrite_exception, REACT_MAPPING_URL
 )
@@ -247,13 +247,13 @@ class GenerateModuleTest(TestCase):
 
 class FetchBase64SourcemapTest(TestCase):
     def test_simple(self):
-        index = fetch_sourcemap(base64_sourcemap)
-        states = [SourceMap(1, 0, '/test.js', 0, 0, None)]
-        sources = set(['/test.js'])
+        smap_view = fetch_sourcemap(base64_sourcemap)
+        tokens = [Token(1, 0, '/test.js', 0, 0, 0, None)]
+        sources = ['/test.js']
         keys = [(1, 0)]
-        content = {'/test.js': ['console.log("hello, World!")']}
+        content = {0: ['console.log("hello, World!")']}
 
-        assert index == SourceMapIndex(states, keys, sources, content)
+        assert smap_view.index == IndexedSourceMapIndex([(0, 0)], [SourceMapIndex(tokens, keys, sources, content)])
 
 
 class TrimLineTest(TestCase):
diff --git a/tests/sentry/lang/javascript/test_sourcemaps.py b/tests/sentry/lang/javascript/test_sourcemaps.py
index f597558d8a..e4d99cf7e2 100644
--- a/tests/sentry/lang/javascript/test_sourcemaps.py
+++ b/tests/sentry/lang/javascript/test_sourcemaps.py
@@ -2,8 +2,8 @@
 
 from __future__ import absolute_import
 
-from sentry.lang.javascript.sourcemaps import (
-    SourceMap, parse_vlq, parse_sourcemap, sourcemap_to_index, find_source, get_inline_content_sources
+from sentry.lang.javascript.sourcemaps.native import (
+    parse_vlq, parse_sourcemap, View as NativeView, Token,
 )
 from sentry.testutils import TestCase
 
@@ -85,44 +85,50 @@ class ParseVlqTest(TestCase):
 
 class FindSourceTest(TestCase):
     def test_simple(self):
-        indexed_sourcemap = sourcemap_to_index(sourcemap)
+        smap_view = NativeView.from_json(sourcemap)
 
-        result = find_source(indexed_sourcemap, 1, 56)
-        assert result == SourceMap(dst_line=0, dst_col=50, src='foo/file2.js', src_line=0, src_col=9, name='multiply')
+        result = smap_view.lookup_token(0, 56)
+        assert result == Token(dst_line=0, dst_col=50, src='foo/file2.js', src_line=0, src_col=9, src_id=1, name='multiply')
 
         # Start of minified file (exact match first line/col tuple)
-        result = find_source(indexed_sourcemap, 1, 0)
-        assert result == SourceMap(dst_line=0, dst_col=0, src='foo/file1.js', src_line=0, src_col=0, name=None)
+        result = smap_view.lookup_token(0, 0)
+        assert result == Token(dst_line=0, dst_col=0, src='foo/file1.js', src_line=0, src_col=0, src_id=0, name=None)
 
         # Last character in mapping
-        result = find_source(indexed_sourcemap, 1, 36)
-        assert result == SourceMap(dst_line=0, dst_col=30, src='foo/file1.js', src_line=2, src_col=1, name=None)
+        result = smap_view.lookup_token(0, 36)
+        assert result == Token(dst_line=0, dst_col=30, src='foo/file1.js', src_line=2, src_col=1, src_id=0, name=None)
 
         # First character in mapping (exact match line/col tuple)
-        result = find_source(indexed_sourcemap, 1, 37)
-        assert result == SourceMap(dst_line=0, dst_col=37, src='foo/file1.js', src_line=2, src_col=8, name='a')
+        result = smap_view.lookup_token(0, 37)
+        assert result == Token(dst_line=0, dst_col=37, src='foo/file1.js', src_line=2, src_col=8, src_id=0, name='a')
 
         # End of minified file (character *beyond* last line/col tuple)
-        result = find_source(indexed_sourcemap, 1, 192)
-        assert result == SourceMap(dst_line=0, dst_col=191, src='foo/file2.js', src_line=9, src_col=25, name='e')
+        result = smap_view.lookup_token(0, 192)
+        assert result == Token(dst_line=0, dst_col=191, src='foo/file2.js', src_line=9, src_col=25, src_id=1, name='e')
 
 
-class GetInlineContentSourcesTest(TestCase):
+class IterSourcesTest(TestCase):
+    def test_basic(self):
+        smap_view = NativeView.from_json(sourcemap)
+        assert list(smap_view.iter_sources()) == [
+            ((0, 0), 'foo/file1.js'),
+            ((0, 1), 'foo/file2.js'),
+        ]
+
+
+class GetSourceContentsTest(TestCase):
     def test_no_inline(self):
-        # basic sourcemap fixture has no inlined sources, so expect an empty list
-        indexed_sourcemap = sourcemap_to_index(sourcemap)
+        # basic sourcemap fixture has no inlined sources, so expect None
+        smap_view = NativeView.from_json(sourcemap)
 
-        sources = get_inline_content_sources(indexed_sourcemap, 'https://example.com/static/')
-        assert sources == []
+        source = smap_view.get_source_contents((0, 0))
+        assert source is None
 
     def test_indexed_inline(self):
-        indexed_sourcemap = sourcemap_to_index(indexed_sourcemap_example)
+        smap_view = NativeView.from_json(indexed_sourcemap_example)
 
-        sources = get_inline_content_sources(indexed_sourcemap, 'https://example.com/static/')
-        assert sources == [
-            ('https://example.com/the/root/one.js', [' ONE.foo = function (bar) {', '   return baz(bar);', ' };']),
-            ('https://example.com/the/root/two.js', [' TWO.inc = function (n) {', '   return n + 1;', ' };'])
-        ]
+        assert smap_view.get_source_contents((0, 0)) == [' ONE.foo = function (bar) {', '   return baz(bar);', ' };']
+        assert smap_view.get_source_contents((1, 0)) == [' TWO.inc = function (n) {', '   return n + 1;', ' };']
 
 
 class ParseSourcemapTest(TestCase):
@@ -131,41 +137,41 @@ class ParseSourcemapTest(TestCase):
         states = list(parse_sourcemap(smap))
 
         assert states == [
-            SourceMap(dst_line=0, dst_col=0, src='foo/file1.js', src_line=0, src_col=0, name=None),
-            SourceMap(dst_line=0, dst_col=8, src='foo/file1.js', src_line=0, src_col=9, name='add'),
-            SourceMap(dst_line=0, dst_col=13, src='foo/file1.js', src_line=0, src_col=13, name='a'),
-            SourceMap(dst_line=0, dst_col=15, src='foo/file1.js', src_line=0, src_col=16, name='b'),
-            SourceMap(dst_line=0, dst_col=18, src='foo/file1.js', src_line=1, src_col=1, name=None),
-            SourceMap(dst_line=0, dst_col=30, src='foo/file1.js', src_line=2, src_col=1, name=None),
-            SourceMap(dst_line=0, dst_col=37, src='foo/file1.js', src_line=2, src_col=8, name='a'),
-            SourceMap(dst_line=0, dst_col=40, src='foo/file1.js', src_line=2, src_col=12, name='b'),
-            SourceMap(dst_line=0, dst_col=42, src='foo/file2.js', src_line=0, src_col=0, name=None),
-            SourceMap(dst_line=0, dst_col=50, src='foo/file2.js', src_line=0, src_col=9, name='multiply'),
-            SourceMap(dst_line=0, dst_col=60, src='foo/file2.js', src_line=0, src_col=18, name='a'),
-            SourceMap(dst_line=0, dst_col=62, src='foo/file2.js', src_line=0, src_col=21, name='b'),
-            SourceMap(dst_line=0, dst_col=65, src='foo/file2.js', src_line=1, src_col=1, name=None),
-            SourceMap(dst_line=0, dst_col=77, src='foo/file2.js', src_line=2, src_col=1, name=None),
-            SourceMap(dst_line=0, dst_col=84, src='foo/file2.js', src_line=2, src_col=8, name='a'),
-            SourceMap(dst_line=0, dst_col=87, src='foo/file2.js', src_line=2, src_col=12, name='b'),
-            SourceMap(dst_line=0, dst_col=89, src='foo/file2.js', src_line=4, src_col=0, name=None),
-            SourceMap(dst_line=0, dst_col=97, src='foo/file2.js', src_line=4, src_col=9, name='divide'),
-            SourceMap(dst_line=0, dst_col=105, src='foo/file2.js', src_line=4, src_col=16, name='a'),
-            SourceMap(dst_line=0, dst_col=107, src='foo/file2.js', src_line=4, src_col=19, name='b'),
-            SourceMap(dst_line=0, dst_col=110, src='foo/file2.js', src_line=5, src_col=1, name=None),
-            SourceMap(dst_line=0, dst_col=122, src='foo/file2.js', src_line=6, src_col=1, name=None),
-            SourceMap(dst_line=0, dst_col=127, src='foo/file2.js', src_line=7, src_col=2, name=None),
-            SourceMap(dst_line=0, dst_col=133, src='foo/file2.js', src_line=7, src_col=9, name='multiply'),
-            SourceMap(dst_line=0, dst_col=143, src='foo/file2.js', src_line=7, src_col=18, name='add'),
-            SourceMap(dst_line=0, dst_col=147, src='foo/file2.js', src_line=7, src_col=22, name='a'),
-            SourceMap(dst_line=0, dst_col=149, src='foo/file2.js', src_line=7, src_col=25, name='b'),
-            SourceMap(dst_line=0, dst_col=152, src='foo/file2.js', src_line=7, src_col=29, name='a'),
-            SourceMap(dst_line=0, dst_col=154, src='foo/file2.js', src_line=7, src_col=32, name='b'),
-            SourceMap(dst_line=0, dst_col=157, src='foo/file2.js', src_line=7, src_col=37, name='c'),
-            SourceMap(dst_line=0, dst_col=159, src='foo/file2.js', src_line=8, src_col=3, name=None),
-            SourceMap(dst_line=0, dst_col=165, src='foo/file2.js', src_line=8, src_col=10, name='e'),
-            SourceMap(dst_line=0, dst_col=168, src='foo/file2.js', src_line=9, src_col=2, name='Raven'),
-            SourceMap(dst_line=0, dst_col=174, src='foo/file2.js', src_line=9, src_col=8, name='captureException'),
-            SourceMap(dst_line=0, dst_col=191, src='foo/file2.js', src_line=9, src_col=25, name='e'),
+            Token(dst_line=0, dst_col=0, src='foo/file1.js', src_line=0, src_col=0, src_id=0, name=None),
+            Token(dst_line=0, dst_col=8, src='foo/file1.js', src_line=0, src_col=9, src_id=0, name='add'),
+            Token(dst_line=0, dst_col=13, src='foo/file1.js', src_line=0, src_col=13, src_id=0, name='a'),
+            Token(dst_line=0, dst_col=15, src='foo/file1.js', src_line=0, src_col=16, src_id=0, name='b'),
+            Token(dst_line=0, dst_col=18, src='foo/file1.js', src_line=1, src_col=1, src_id=0, name=None),
+            Token(dst_line=0, dst_col=30, src='foo/file1.js', src_line=2, src_col=1, src_id=0, name=None),
+            Token(dst_line=0, dst_col=37, src='foo/file1.js', src_line=2, src_col=8, src_id=0, name='a'),
+            Token(dst_line=0, dst_col=40, src='foo/file1.js', src_line=2, src_col=12, src_id=0, name='b'),
+            Token(dst_line=0, dst_col=42, src='foo/file2.js', src_line=0, src_col=0, src_id=1, name=None),
+            Token(dst_line=0, dst_col=50, src='foo/file2.js', src_line=0, src_col=9, src_id=1, name='multiply'),
+            Token(dst_line=0, dst_col=60, src='foo/file2.js', src_line=0, src_col=18, src_id=1, name='a'),
+            Token(dst_line=0, dst_col=62, src='foo/file2.js', src_line=0, src_col=21, src_id=1, name='b'),
+            Token(dst_line=0, dst_col=65, src='foo/file2.js', src_line=1, src_col=1, src_id=1, name=None),
+            Token(dst_line=0, dst_col=77, src='foo/file2.js', src_line=2, src_col=1, src_id=1, name=None),
+            Token(dst_line=0, dst_col=84, src='foo/file2.js', src_line=2, src_col=8, src_id=1, name='a'),
+            Token(dst_line=0, dst_col=87, src='foo/file2.js', src_line=2, src_col=12, src_id=1, name='b'),
+            Token(dst_line=0, dst_col=89, src='foo/file2.js', src_line=4, src_col=0, src_id=1, name=None),
+            Token(dst_line=0, dst_col=97, src='foo/file2.js', src_line=4, src_col=9, src_id=1, name='divide'),
+            Token(dst_line=0, dst_col=105, src='foo/file2.js', src_line=4, src_col=16, src_id=1, name='a'),
+            Token(dst_line=0, dst_col=107, src='foo/file2.js', src_line=4, src_col=19, src_id=1, name='b'),
+            Token(dst_line=0, dst_col=110, src='foo/file2.js', src_line=5, src_col=1, src_id=1, name=None),
+            Token(dst_line=0, dst_col=122, src='foo/file2.js', src_line=6, src_col=1, src_id=1, name=None),
+            Token(dst_line=0, dst_col=127, src='foo/file2.js', src_line=7, src_col=2, src_id=1, name=None),
+            Token(dst_line=0, dst_col=133, src='foo/file2.js', src_line=7, src_col=9, src_id=1, name='multiply'),
+            Token(dst_line=0, dst_col=143, src='foo/file2.js', src_line=7, src_col=18, src_id=1, name='add'),
+            Token(dst_line=0, dst_col=147, src='foo/file2.js', src_line=7, src_col=22, src_id=1, name='a'),
+            Token(dst_line=0, dst_col=149, src='foo/file2.js', src_line=7, src_col=25, src_id=1, name='b'),
+            Token(dst_line=0, dst_col=152, src='foo/file2.js', src_line=7, src_col=29, src_id=1, name='a'),
+            Token(dst_line=0, dst_col=154, src='foo/file2.js', src_line=7, src_col=32, src_id=1, name='b'),
+            Token(dst_line=0, dst_col=157, src='foo/file2.js', src_line=7, src_col=37, src_id=1, name='c'),
+            Token(dst_line=0, dst_col=159, src='foo/file2.js', src_line=8, src_col=3, src_id=1, name=None),
+            Token(dst_line=0, dst_col=165, src='foo/file2.js', src_line=8, src_col=10, src_id=1, name='e'),
+            Token(dst_line=0, dst_col=168, src='foo/file2.js', src_line=9, src_col=2, src_id=1, name='Raven'),
+            Token(dst_line=0, dst_col=174, src='foo/file2.js', src_line=9, src_col=8, src_id=1, name='captureException'),
+            Token(dst_line=0, dst_col=191, src='foo/file2.js', src_line=9, src_col=25, src_id=1, name='e'),
         ]
 
 
@@ -173,33 +179,33 @@ class ParseIndexedSourcemapTest(TestCase):
     # Tests lookups that fall exactly on source map token boundaries
     # https://github.com/mozilla/source-map/blob/master/test/test-source-map-consumer.js#138
     def test_exact_mappings(self):
-        indexed_sourcemap = sourcemap_to_index(indexed_sourcemap_example)
+        smap_view = NativeView.from_json(indexed_sourcemap_example)
 
         # one.js
-        assert find_source(indexed_sourcemap, 1, 1) == \
-            SourceMap(dst_line=0, dst_col=1, src='/the/root/one.js', src_line=0, src_col=1, name=None)
-        assert find_source(indexed_sourcemap, 1, 18) == \
-            SourceMap(dst_line=0, dst_col=18, src='/the/root/one.js', src_line=0, src_col=21, name='bar')
-        assert find_source(indexed_sourcemap, 1, 28) == \
-            SourceMap(dst_line=0, dst_col=28, src='/the/root/one.js', src_line=1, src_col=10, name='baz')
+        assert smap_view.lookup_token(0, 1) == \
+            Token(dst_line=0, dst_col=1, src='/the/root/one.js', src_line=0, src_col=1, src_id=0, name=None)
+        assert smap_view.lookup_token(0, 18) == \
+            Token(dst_line=0, dst_col=18, src='/the/root/one.js', src_line=0, src_col=21, src_id=0, name='bar')
+        assert smap_view.lookup_token(0, 28) == \
+            Token(dst_line=0, dst_col=28, src='/the/root/one.js', src_line=1, src_col=10, src_id=0, name='baz')
 
         # two.js
-        assert find_source(indexed_sourcemap, 2, 18) == \
-            SourceMap(dst_line=1, dst_col=18, src='/the/root/two.js', src_line=0, src_col=21, name='n')
-        assert find_source(indexed_sourcemap, 2, 21) == \
-            SourceMap(dst_line=1, dst_col=21, src='/the/root/two.js', src_line=1, src_col=3, name=None)
-        assert find_source(indexed_sourcemap, 2, 21) == \
-            SourceMap(dst_line=1, dst_col=21, src='/the/root/two.js', src_line=1, src_col=3, name=None)
+        assert smap_view.lookup_token(1, 18) == \
+            Token(dst_line=1, dst_col=18, src='/the/root/two.js', src_line=0, src_col=21, src_id=0, name='n')
+        assert smap_view.lookup_token(1, 21) == \
+            Token(dst_line=1, dst_col=21, src='/the/root/two.js', src_line=1, src_col=3, src_id=0, name=None)
+        assert smap_view.lookup_token(1, 21) == \
+            Token(dst_line=1, dst_col=21, src='/the/root/two.js', src_line=1, src_col=3, src_id=0, name=None)
 
     # Tests lookups that fall inside source map token boundaries
     # https://github.com/mozilla/source-map/blob/master/test/test-source-map-consumer.js#181
     def test_fuzzy_mapping(self):
-        indexed_sourcemap = sourcemap_to_index(indexed_sourcemap_example)
+        smap_view = NativeView.from_json(indexed_sourcemap_example)
 
         # one.js
-        assert find_source(indexed_sourcemap, 1, 20) == \
-            SourceMap(dst_line=0, dst_col=18, src='/the/root/one.js', src_line=0, src_col=21, name='bar')
-        assert find_source(indexed_sourcemap, 1, 30) == \
-            SourceMap(dst_line=0, dst_col=28, src='/the/root/one.js', src_line=1, src_col=10, name='baz')
-        assert find_source(indexed_sourcemap, 2, 12) == \
-            SourceMap(dst_line=1, dst_col=9, src='/the/root/two.js', src_line=0, src_col=11, name=None)
+        assert smap_view.lookup_token(0, 20) == \
+            Token(dst_line=0, dst_col=18, src='/the/root/one.js', src_line=0, src_col=21, src_id=0, name='bar')
+        assert smap_view.lookup_token(0, 30) == \
+            Token(dst_line=0, dst_col=28, src='/the/root/one.js', src_line=1, src_col=10, src_id=0, name='baz')
+        assert smap_view.lookup_token(1, 12) == \
+            Token(dst_line=1, dst_col=9, src='/the/root/two.js', src_line=0, src_col=11, src_id=0, name=None)

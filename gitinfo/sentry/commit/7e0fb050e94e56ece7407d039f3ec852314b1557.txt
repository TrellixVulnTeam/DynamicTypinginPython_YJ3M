commit 7e0fb050e94e56ece7407d039f3ec852314b1557
Author: ted kaemming <t.kaemming+github@gmail.com>
Date:   Tue Aug 9 14:49:59 2016 -0700

    Fix date partitioning in report generation. (#3891)

diff --git a/src/sentry/tasks/reports.py b/src/sentry/tasks/reports.py
index 456972a2a8..9d64acb6fc 100644
--- a/src/sentry/tasks/reports.py
+++ b/src/sentry/tasks/reports.py
@@ -6,6 +6,7 @@ import logging
 import operator
 from collections import namedtuple
 from datetime import timedelta
+from six.moves import reduce
 
 from django.utils import timezone
 
@@ -148,24 +149,43 @@ def prepare_project_series((start, stop), project, rollup=60 * 60 * 24):
     )
 
 
-def prepare_project_aggregates((start, stop), project):
-    # TODO: This needs to return ``None`` for periods that don't have any data
-    # (because the project is not old enough) and possibly extrapolate for
-    # periods that only have partial periods.
-    period = timedelta(days=7 * 4)
-    start = stop - period
+def time_series_collector(function, segments, start, stop):
+    """
+    Return a function can be used in a ``reduce`` operation to collect
+    ``datetime`` objects into N equally sized buckets. The object collected
+    into must support item assignment, such as a mutable mapping or sequence.
+    """
+    period = (stop - start) / segments
+
+    def collect(results, value):
+        key = int((value - start).total_seconds() / period.total_seconds())
+        results[key] = function(results[key], value)
+        return results
 
-    resolutions = project.group_set.filter(
-        status=GroupStatus.RESOLVED,
-        resolved_at__gte=start,
-        resolved_at__lt=stop,
-    ).values_list('resolved_at', flat=True)
+    return collect
 
-    periods = [0] * 4
-    for resolution in resolutions:
-        periods[int((resolution - start).total_seconds() / period.total_seconds())] += 1
 
-    return periods
+def prepare_project_aggregates((_, stop), project):
+    # TODO: This needs to return ``None`` for periods that don't have any data
+    # (because the project is not old enough) and possibly extrapolate for
+    # periods that only have partial periods.
+    segments = 4
+    period = timedelta(days=7)
+    start = stop - (period * segments)
+    return reduce(
+        time_series_collector(
+            lambda x, y: x + 1,
+            segments,
+            start,
+            stop,
+        ),
+        project.group_set.filter(
+            status=GroupStatus.RESOLVED,
+            resolved_at__gte=start,
+            resolved_at__lt=stop,
+        ).values_list('resolved_at', flat=True),
+        [0] * segments,
+    )
 
 
 def trim_issue_list(value):
diff --git a/tests/sentry/tasks/test_reports.py b/tests/sentry/tasks/test_reports.py
index 7cd3387867..b87483a2cd 100644
--- a/tests/sentry/tasks/test_reports.py
+++ b/tests/sentry/tasks/test_reports.py
@@ -3,11 +3,12 @@ from __future__ import absolute_import
 import pytest
 import mock
 from django.core import mail
+from six.moves import reduce
 
 from sentry.models import Project
 from sentry.tasks.reports import (
     change, clean_series, merge_mappings, merge_sequences, merge_series,
-    safe_add, prepare_reports,
+    safe_add, prepare_reports, time_series_collector,
 )
 from sentry.testutils.cases import TestCase
 from sentry.utils.dates import to_datetime
@@ -152,6 +153,38 @@ def test_clean_series_rejects_offset_timestamp():
         )
 
 
+def test_time_series_collector():
+    def datetime_range(*args):
+        return [to_datetime(i) for i in range(*args)]
+
+    assert reduce(
+        time_series_collector(
+            lambda x, y: x + 1,
+            4,
+            to_datetime(0),
+            to_datetime(60),
+        ),
+        datetime_range(60),
+        [0] * 4,
+    ) == [15] * 4
+
+    assert reduce(
+        time_series_collector(
+            lambda x, y: x + [y],
+            4,
+            to_datetime(0),
+            to_datetime(60),
+        ),
+        datetime_range(60),
+        [[] for _ in range(4)]
+    ) == [
+        datetime_range(0, 15),
+        datetime_range(15, 30),
+        datetime_range(30, 45),
+        datetime_range(45, 60),
+    ]
+
+
 class ReportTestCase(TestCase):
     @mock.patch('sentry.features.has')
     def test_integration(self, has_feature):

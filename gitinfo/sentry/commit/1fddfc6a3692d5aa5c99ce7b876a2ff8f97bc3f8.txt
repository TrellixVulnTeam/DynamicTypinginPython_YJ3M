commit 1fddfc6a3692d5aa5c99ce7b876a2ff8f97bc3f8
Author: Ted Kaemming <ted@kaemming.com>
Date:   Wed Oct 7 15:44:28 2015 -0700

    Cleanup, move interval calculation onto base.

diff --git a/src/sentry/tsdb/base.py b/src/sentry/tsdb/base.py
index 600736656d..6a5ea600ce 100644
--- a/src/sentry/tsdb/base.py
+++ b/src/sentry/tsdb/base.py
@@ -103,6 +103,19 @@ class BaseTSDB(object):
                 return rollup
         return self.rollups[-1][0]
 
+    def get_optimal_rollup_intervals(self, start, end, rollup=None):
+        # NOTE: "optimal" here means "able to most closely reflect the upper
+        # and lower bounds", not "able to construct the most efficient query"
+        if rollup is None:
+            rollup = self.get_optimal_rollup(start, end)
+
+        intervals = [self.normalize_to_epoch(start, rollup)]
+        end_ts = int(end.strftime('%s'))  # XXX: HACK
+        while intervals[-1] + rollup < end_ts:
+            intervals.append(intervals[-1] + rollup)
+
+        return rollup, intervals
+
     def calculate_expiry(self, rollup, samples, timestamp):
         """
         Calculate the expiration time for a rollup.
@@ -172,3 +185,21 @@ class BaseTSDB(object):
                     result[key].append([new_ts, count])
                     last_new_ts = new_ts
         return result
+
+    def record_multi(self, items, timestamp=None):
+        """
+        Record an occurence of an item in a distinct counter.
+        """
+        raise NotImplementedError
+
+    def get_distinct_counts_series(self, model, keys, start, end, rollup=None):
+        """
+        Fetch counts of distinct items for each rollup interval within the range.
+        """
+        raise NotImplementedError
+
+    def get_distinct_counts_totals(self, model, keys, start, end, rollup=None):
+        """
+        Count distinct items during a time range.
+        """
+        raise NotImplementedError
diff --git a/src/sentry/tsdb/redis.py b/src/sentry/tsdb/redis.py
index 7bd6ea4016..de84ed982d 100644
--- a/src/sentry/tsdb/redis.py
+++ b/src/sentry/tsdb/redis.py
@@ -196,21 +196,11 @@ class RedisTSDB(BaseTSDB):
         # TODO: Check to make sure these operations didn't fail, so we can
         # raise an error if there were issues.
 
-    def _get_intervals(self, start, end, rollup=None):
-        # NOTE: "optimal" here means "able to most closely reflect the upper
-        # and lower bounds", not "able to construct the most efficient query"
-        if rollup is None:
-            rollup = self.get_optimal_rollup(start, end)
-
-        intervals = [self.normalize_to_epoch(start, rollup)]
-        end_ts = int(end.strftime('%s'))  # XXX: HACK
-        while intervals[-1] + rollup < end_ts:
-            intervals.append(intervals[-1] + rollup)
-
-        return rollup, intervals
-
     def get_distinct_counts_series(self, model, keys, start, end, rollup=None):
-        rollup, intervals = self._get_intervals(start, end, rollup)
+        """
+        Fetch counts of distinct items for each rollup interval within the range.
+        """
+        rollup, intervals = self.get_optimal_rollup_intervals(start, end, rollup)
 
         def get_key(key, timestamp):
             return self.make_key(
@@ -232,7 +222,7 @@ class RedisTSDB(BaseTSDB):
         """
         Count distinct items during a time range.
         """
-        rollup, intervals = self._get_intervals(start, end, rollup)
+        rollup, intervals = self.get_optimal_rollup_intervals(start, end, rollup)
 
         def get_key(key, timestamp):
             return self.make_key(

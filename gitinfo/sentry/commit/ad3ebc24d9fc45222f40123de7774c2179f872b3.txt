commit ad3ebc24d9fc45222f40123de7774c2179f872b3
Author: Ted Kaemming <ted@kaemming.com>
Date:   Tue Oct 13 14:21:19 2015 -0700

    Make digest generation into this weird pipeline-ish thing.

diff --git a/src/sentry/digests/notifications.py b/src/sentry/digests/notifications.py
index 98a2142627..38125a54c5 100644
--- a/src/sentry/digests/notifications.py
+++ b/src/sentry/digests/notifications.py
@@ -1,13 +1,21 @@
 from __future__ import absolute_import
 
+import functools
+import itertools
 import logging
-from collections import namedtuple
-
-from django.utils import timezone
+from collections import (
+    OrderedDict,
+    defaultdict,
+    namedtuple,
+)
 
 from sentry.app import tsdb
 from sentry.digests import Record
-from sentry.models import Project
+from sentry.models import (
+    Project,
+    Group,
+    Rule,
+)
 from sentry.utils.dates import to_timestamp
 
 
@@ -32,77 +40,113 @@ def strip_for_serialization(instance):
     return cls(**{field.attname: getattr(instance, field.attname) for field in cls._meta.fields})
 
 
-def event_to_record(event, rules, clean=strip_for_serialization):
+def event_to_record(event, rules):
     if not rules:
         logger.warning('Creating record for %r that does not contain any rules!', event)
 
     return Record(
         event.event_id,
-        Notification(clean(event), [rule.id for rule in rules]),
+        Notification(strip_for_serialization(event), [rule.id for rule in rules]),
         to_timestamp(event.datetime),
     )
 
 
-Digest = namedtuple('Digest', 'start end rules')
-Summary = namedtuple('Summary', 'records events users')
+def fetch_state(project, records):
+    # This reads a little strange, but remember that records are returned in
+    # reverse chronological order, and we query the database in chronological
+    # order.
+    # NOTE: This doesn't account for any issues that are filtered out later.
+    start = records[-1].datetime
+    end = records[0].datetime
 
+    groups = Group.objects.in_bulk(record.value.event.group_id for record in records)
+    return {
+        'project': project,
+        'groups': groups,
+        'rules': Rule.objects.in_bulk(itertools.chain.from_iterable(record.value.rules for record in records)),
+        'event_counts': tsdb.get_sums(tsdb.models.group, groups.keys(), start, end),
+        'user_counts': tsdb.get_distinct_counts_totals(tsdb.models.users_affected_by_group, groups.keys(), start, end),
+    }
 
-def build_digest(project, records):
-    # Extract all groups from the records.
-    groups = set()
-    for record in records:
-        groups.add(record.value.event.group_id)
 
-    start = records[-1].datetime
-    end = timezone.now()
-
-    # Fetch the event counts for all groups.
-    events = tsdb.get_sums(
-        tsdb.models.group,
-        groups,
-        start,
-        end,
-    )
+def attach_state(project, groups, rules, event_counts, user_counts):
+    for id, group in groups.iteritems():
+        assert group.project_id == project.id, 'Group must belong to Project'
+        group.project = project
+
+    for id, rule in rules.iteritems():
+        assert rule.project_id == project.id, 'Rule must belong to Project'
+        rule.project = project
+
+    for id, event_count in event_counts.iteritems():
+        groups[id].event_count = event_count
+
+    for id, user_count in user_counts.iteritems():
+        groups[id].user_count = user_count
 
-    # Fetch the user counts for all groups.
-    users = tsdb.get_distinct_counts_totals(
-        tsdb.models.users_affected_by_group,
-        groups,
-        start,
-        end,
+    return {
+        'project': project,
+        'groups': groups,
+        'rules': rules,
+    }
+
+
+def rewrite_record(record, project, groups, rules):
+    event = record.value.event
+    group = groups.get(event.group_id)
+    if group is None:
+        return
+
+    event.group = group
+
+    return Record(
+        record.key,
+        Notification(
+            event,
+            filter(None, [rules.get(id) for id in record.value.rules]),
+        ),
+        record.timestamp,
     )
 
-    # Group the records by [rule][group].
-    groups_by_rule = {}
+
+def group_records(records):
+    results = defaultdict(lambda: defaultdict(list))
     for record in records:
+        group = record.value.event.group
         for rule in record.value.rules:
-            group = record.value.event.group
-            summary = groups_by_rule.setdefault(rule, {}).get(group)
-            if summary is None:
-                summary = groups_by_rule[rule][group] = Summary(
-                    [],
-                    events[group.id],
-                    users[group.id],
-                )
-            summary.records.append(record)
-
-    # TODO: Filter out any groups that are muted or resolved?
-
-    results = sorted(
-        [
-            (
-                rule,
-                sorted(
-                    summaries.items(),
-                    key=lambda (group, summary): summary.events,
-                    reverse=True,
-                )
-            )
-            for rule, summaries in
-            groups_by_rule.items()
-        ],
-        key=lambda (rule, groups): len(groups),
-        reverse=True,
-    )
-
-    return Digest(start, end, results)
+            results[rule][group].append(record)
+
+    return results
+
+
+def sort_groups(grouped):
+    def sort_by_events(groups):
+        return OrderedDict(
+            sorted(
+                groups.items(),
+                key=lambda (group, records): (group.event_count, group.user_count),
+                reverse=True,
+            ),
+        )
+
+    def sort_by_groups(rules):
+        return OrderedDict(
+            sorted(
+                rules.items(),
+                key=lambda (rule, groups): len(groups),
+                reverse=True,
+            ),
+        )
+
+    return sort_by_groups({rule: sort_by_events(groups) for rule, groups in grouped.iteritems()})
+
+
+def build_digest(project, records, state=None):
+    # XXX: This is a hack to allow generating a mock digest without actually
+    # doing any real IO!
+    if state is None:
+        state = fetch_state(project, records)
+
+    state = attach_state(**state)
+    records = map(functools.partial(rewrite_record, **state), records)
+    return sort_groups(group_records(records))
diff --git a/src/sentry/plugins/sentry_mail/models.py b/src/sentry/plugins/sentry_mail/models.py
index b5e98dbf3d..7d77831467 100644
--- a/src/sentry/plugins/sentry_mail/models.py
+++ b/src/sentry/plugins/sentry_mail/models.py
@@ -196,6 +196,7 @@ class MailPlugin(NotificationPlugin):
 
     def notify_digest(self, project, digest):
         context = {
+            'project': project,
             'digest': digest,
         }
 
diff --git a/src/sentry/templates/sentry/emails/digests/body.html b/src/sentry/templates/sentry/emails/digests/body.html
index f6a9a6b049..64db88744c 100644
--- a/src/sentry/templates/sentry/emails/digests/body.html
+++ b/src/sentry/templates/sentry/emails/digests/body.html
@@ -6,7 +6,7 @@
 
 <h2>{{ project.name }}</h2>
 
-{% for rule, groups in digest.rules %}
+{% for rule, groups in digest.iteritems %}
 
     <h3>{{ rule.label }}</h3>
 
@@ -16,17 +16,17 @@
             <th>Events</th>
             <th>Users</th>
         </tr>
-        {% for group, summary in groups %}
+        {% for group, records in groups.iteritems %}
             <tr>
                 <th>
                     {% url 'sentry-group' group.organization.slug group.project.slug group.id as group_link %}
                     <a href="{% absolute_uri group_link %}">{{ group.title }}</a>
                 </th>
                 <td>
-                    {{ summary.events }}
+                    {{ group.event_count }}
                 </td>
                 <td>
-                    {{ summary.users }}
+                    {{ group.user_count }}
                 </td>
             </tr>
         {% endfor %}
diff --git a/src/sentry/templates/sentry/emails/digests/subject.txt b/src/sentry/templates/sentry/emails/digests/subject.txt
index a6aa213b1d..245907bfe2 100644
--- a/src/sentry/templates/sentry/emails/digests/subject.txt
+++ b/src/sentry/templates/sentry/emails/digests/subject.txt
@@ -1 +1 @@
-[{digest.project}] Notifications from {digest.start} to {digest.end}]
+Notifications for {{ project.name }}
diff --git a/src/sentry/web/frontend/debug/mail.py b/src/sentry/web/frontend/debug/mail.py
index 1fee37297e..7434164e41 100644
--- a/src/sentry/web/frontend/debug/mail.py
+++ b/src/sentry/web/frontend/debug/mail.py
@@ -4,6 +4,7 @@ import itertools
 import logging
 import time
 import traceback
+import uuid
 from datetime import (
     datetime,
     timedelta,
@@ -15,13 +16,15 @@ import pytz
 from django.core.urlresolvers import reverse
 from django.utils.safestring import mark_safe
 
+from sentry.digests import Record
 from sentry.digests.notifications import (
+    Notification,
     build_digest,
-    event_to_record,
 )
 from sentry.models import (
     Activity, Event, Group, Organization, Project, Rule, Team,
 )
+from sentry.utils.dates import to_timestamp
 from sentry.utils.samples import load_data
 from sentry.utils.email import inline_css
 from sentry.utils.http import absolute_uri
@@ -170,21 +173,24 @@ def new_note(request):
 def digest(request):
     seed = request.GET.get('seed', str(time.time()))
     logger.debug('Using random seed value: %s')
-
     random = Random(seed)
 
+    now = datetime.utcnow().replace(tzinfo=pytz.utc)
+
     # TODO: Refactor all of these into something more manageable.
     org = Organization(
         id=1,
         slug='example',
         name='Example Organization',
     )
+
     team = Team(
         id=1,
         slug='example',
         name='Example Team',
         organization=org,
     )
+
     project = Project(
         id=1,
         slug='example',
@@ -193,43 +199,60 @@ def digest(request):
         organization=org,
     )
 
-    now = datetime.utcnow().replace(tzinfo=pytz.utc)
-
-    rules = [
-        Rule(id=1, label="First Rule"),
-        Rule(id=2, label="Second Rule"),
-        Rule(id=3, label="Third Rule"),
-    ]
+    state = {
+        'project': project,
+        'groups': {},
+        'rules': {
+            1: Rule(id=1, project=project, label="First Rule"),
+            2: Rule(id=2, project=project, label="Second Rule"),
+            3: Rule(id=3, project=project, label="Third Rule"),
+        },
+        'event_counts': {},
+        'user_counts': {},
+    }
 
     records = []
 
+    group_sequence = itertools.count(1)
     event_sequence = itertools.count(1)
+
     for i in xrange(random.randint(1, 4)):
-        group = Group(
-            id=i + 1,
+        group_id = next(group_sequence)
+
+        group = state['groups'][group_id] = Group(
+            id=group_id,
             project=project,
-            message='This is example event #%s' % (i + 1),
+            message='This is example event #%s' % (group_id,),
         )
 
         offset = timedelta(seconds=0)
         for i in xrange(random.randint(1, 10)):
             offset += timedelta(seconds=random.random() * 120)
+            event = Event(
+                id=next(event_sequence),
+                event_id=uuid.uuid4().hex,
+                project=project,
+                group=group,
+                message=group.message,
+                data=load_data('python'),
+                datetime=now - offset,
+            )
+
             records.append(
-                event_to_record(
-                    Event(
-                        id=next(event_sequence),
-                        project=project,
-                        group=group,
-                        message=group.message,
-                        data=load_data('python'),
-                        datetime=now - offset,
+                Record(
+                    event.event_id,
+                    Notification(
+                        event,
+                        random.sample(state['rules'], random.randint(1, len(state['rules']))),
                     ),
-                    random.sample(rules, random.randint(1, len(rules))),
-                    clean=lambda i: i,
+                    to_timestamp(event.datetime),
                 )
             )
 
-    digest = build_digest(project, records)
+            state['event_counts'][group_id] = random.randint(10, 1e4)
+            state['user_counts'][group_id] = random.randint(10, 1e4)
+
+    digest = build_digest(project, records, state)
 
     return MailPreview(
         html_template='sentry/emails/digests/body.html',

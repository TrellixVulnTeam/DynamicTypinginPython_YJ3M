commit 4572523acd716afcd725377379f1bca3ca320462
Author: Alberto Leal <mail4alberto@gmail.com>
Date:   Wed Oct 23 15:27:35 2019 -0400

    feat(discover2): Add draggable columns on discover2 table (#14980)
    
    Closes SEN-1126

diff --git a/src/sentry/static/sentry/app/components/gridEditable/flags.tsx b/src/sentry/static/sentry/app/components/gridEditable/flags.tsx
index 95f92f2315..d8cd2b7c1c 100644
--- a/src/sentry/static/sentry/app/components/gridEditable/flags.tsx
+++ b/src/sentry/static/sentry/app/components/gridEditable/flags.tsx
@@ -7,4 +7,3 @@
  * 3. Allow drag-to-rearrage columns
  */
 export const FLAG_GRID_RESIZABLE = false;
-export const FLAG_GRID_DRAGGABLE = false;
diff --git a/src/sentry/static/sentry/app/components/gridEditable/gridHeadCell.tsx b/src/sentry/static/sentry/app/components/gridEditable/gridHeadCell.tsx
index 8954e71313..9f8820e057 100644
--- a/src/sentry/static/sentry/app/components/gridEditable/gridHeadCell.tsx
+++ b/src/sentry/static/sentry/app/components/gridEditable/gridHeadCell.tsx
@@ -2,19 +2,22 @@ import React from 'react';
 
 import InlineSvg from 'app/components/inlineSvg';
 
-import {FLAG_GRID_RESIZABLE, FLAG_GRID_DRAGGABLE} from './flags';
+import {FLAG_GRID_RESIZABLE} from './flags';
 import {
   GridHeadCell as GridHeadCellWrapper,
   GridHeadCellButton,
   GridHeadCellButtonHover,
   GridHeadCellButtonHoverBackground,
-  GridHeadCellButtonHoverButtonGroup,
   GridHeadCellButtonHoverButton,
   GridHeadCellButtonHoverDraggable,
   GridHeadCellResizer,
 } from './styles';
+import {GridColumnHeader} from './types';
 
 export type GridHeadCellProps<Column> = {
+  isColumnDragging: boolean;
+  gridHeadCellButtonProps: {[prop: string]: any};
+
   isEditing: boolean;
   isPrimary: boolean;
 
@@ -23,7 +26,11 @@ export type GridHeadCellProps<Column> = {
   children: React.ReactNode | React.ReactChild;
 
   actions: {
-    moveColumn: (indexFrom: number, indexTo: number) => void;
+    moveColumnCommit: (indexFrom: number, indexTo: number) => void;
+    onDragStart: (
+      event: React.MouseEvent<SVGSVGElement, MouseEvent>,
+      indexFrom: number
+    ) => void;
     deleteColumn: (index: number) => void;
     toggleModalEditColumn: (index?: number, column?: Column) => void;
   };
@@ -37,7 +44,7 @@ export type GridHeadCellState = {
  * states that are only specific to the header. This component aims to abstract
  * the complexity of GridHeadCell away.
  */
-class GridHeadCell<Column> extends React.Component<
+class GridHeadCell<Column extends GridColumnHeader> extends React.Component<
   GridHeadCellProps<Column>,
   GridHeadCellState
 > {
@@ -64,7 +71,22 @@ class GridHeadCell<Column> extends React.Component<
     actions.toggleModalEditColumn(indexColumnOrder, column);
   };
 
+  onDragStart = (event: React.MouseEvent<SVGSVGElement, MouseEvent>) => {
+    // hide hovers when dragging
+    this.setHovering(false);
+
+    const fromColumn = this.props.indexColumnOrder;
+    this.props.actions.onDragStart(event, fromColumn);
+  };
+
   renderButtonHoverDraggable(children: React.ReactNode) {
+    const {isHovering} = this.state;
+    const {isEditing, isColumnDragging} = this.props;
+
+    if (!isEditing || !isHovering || isColumnDragging) {
+      return null;
+    }
+
     return (
       <React.Fragment>
         {/* Ensure that background is always at the top. The background must be
@@ -73,39 +95,45 @@ class GridHeadCell<Column> extends React.Component<
         <GridHeadCellButtonHoverBackground>{children}</GridHeadCellButtonHoverBackground>
 
         <GridHeadCellButtonHover>
-          {FLAG_GRID_DRAGGABLE && (
-            <GridHeadCellButtonHoverDraggable src="icon-grabbable" />
-          )}
+          <GridHeadCellButtonHoverDraggable
+            src="icon-grabbable"
+            onMouseDown={this.onDragStart}
+          />
 
-          <GridHeadCellButtonHoverButtonGroup isFlagged={FLAG_GRID_DRAGGABLE}>
+          <div>
             <GridHeadCellButtonHoverButton onClick={this.toggleModal}>
               <InlineSvg src="icon-edit-pencil" />
             </GridHeadCellButtonHoverButton>
             <GridHeadCellButtonHoverButton onClick={this.deleteColumn}>
               <InlineSvg src="icon-trash" />
             </GridHeadCellButtonHoverButton>
-          </GridHeadCellButtonHoverButtonGroup>
+          </div>
 
-          {FLAG_GRID_DRAGGABLE && (
-            <GridHeadCellButtonHoverDraggable src="icon-grabbable" />
-          )}
+          <GridHeadCellButtonHoverDraggable
+            src="icon-grabbable"
+            onMouseDown={this.onDragStart}
+          />
         </GridHeadCellButtonHover>
       </React.Fragment>
     );
   }
 
   render() {
-    const {isEditing, children} = this.props;
-    const {isHovering} = this.state;
+    const {isEditing, children, column, gridHeadCellButtonProps} = this.props;
 
     return (
       <GridHeadCellWrapper
         onMouseEnter={() => this.setHovering(true)}
+        onMouseMove={() => this.setHovering(true)}
         onMouseLeave={() => this.setHovering(false)}
       >
-        <GridHeadCellButton isEditing={isEditing}>
+        <GridHeadCellButton
+          isDragging={column.isDragging}
+          isEditing={isEditing}
+          {...gridHeadCellButtonProps}
+        >
           {children}
-          {isEditing && isHovering && this.renderButtonHoverDraggable(children)}
+          {this.renderButtonHoverDraggable(children)}
         </GridHeadCellButton>
 
         {/* Keep the Resizer at the bottom to ensure that it is will always
diff --git a/src/sentry/static/sentry/app/components/gridEditable/index.tsx b/src/sentry/static/sentry/app/components/gridEditable/index.tsx
index 67660d2ef8..062453bfb4 100644
--- a/src/sentry/static/sentry/app/components/gridEditable/index.tsx
+++ b/src/sentry/static/sentry/app/components/gridEditable/index.tsx
@@ -9,7 +9,13 @@ import InlineSvg from 'app/components/inlineSvg';
 import LoadingContainer from 'app/components/loading/loadingContainer';
 import ToolTip from 'app/components/tooltip';
 
-import {GridColumn, GridColumnHeader, GridColumnOrder, GridColumnSortBy} from './types';
+import {
+  GridColumn,
+  GridColumnHeader,
+  GridColumnOrder,
+  GridColumnSortBy,
+  ObjectKey,
+} from './types';
 import GridHeadCell from './gridHeadCell';
 import GridModalEditColumn from './gridModalEditColumn';
 import {
@@ -26,9 +32,12 @@ import {
   GridEditGroupButton,
 } from './styles';
 
-type GridEditableProps<DataRow, ColumnKey extends keyof DataRow> = {
+type GridEditableProps<DataRow, ColumnKey> = {
+  gridHeadCellButtonProps?: {[prop: string]: any};
+
   isEditable?: boolean;
   isLoading?: boolean;
+  isColumnDragging: boolean;
   error?: React.ReactNode | null;
 
   /**
@@ -80,7 +89,11 @@ type GridEditableProps<DataRow, ColumnKey extends keyof DataRow> = {
    * have to provide functions to move/delete the columns
    */
   actions: {
-    moveColumn: (indexFrom: number, indexTo: number) => void;
+    moveColumnCommit: (indexFrom: number, indexTo: number) => void;
+    onDragStart: (
+      event: React.MouseEvent<SVGSVGElement, MouseEvent>,
+      indexFrom: number
+    ) => void;
     deleteColumn: (index: number) => void;
   };
 };
@@ -91,8 +104,8 @@ type GridEditableState = {
 };
 
 class GridEditable<
-  DataRow extends Object,
-  ColumnKey extends keyof DataRow
+  DataRow extends {[key: string]: any},
+  ColumnKey extends ObjectKey
 > extends React.Component<GridEditableProps<DataRow, ColumnKey>, GridEditableState> {
   static defaultProps = {
     isEditable: false,
@@ -224,12 +237,15 @@ class GridEditable<
           {columnOrder.map((column, columnIndex) => (
             <GridHeadCell
               key={`${columnIndex}.${column.key}`}
+              isColumnDragging={this.props.isColumnDragging}
               isPrimary={column.isPrimary}
               isEditing={enableEdit}
               indexColumnOrder={columnIndex}
               column={column}
+              gridHeadCellButtonProps={this.props.gridHeadCellButtonProps || {}}
               actions={{
-                moveColumn: actions.moveColumn,
+                moveColumnCommit: actions.moveColumnCommit,
+                onDragStart: actions.onDragStart,
                 deleteColumn: actions.deleteColumn,
                 toggleModalEditColumn: this.toggleModalEditColumn,
               }}
diff --git a/src/sentry/static/sentry/app/components/gridEditable/styles.tsx b/src/sentry/static/sentry/app/components/gridEditable/styles.tsx
index 34e3f5c646..d025e21460 100644
--- a/src/sentry/static/sentry/app/components/gridEditable/styles.tsx
+++ b/src/sentry/static/sentry/app/components/gridEditable/styles.tsx
@@ -21,7 +21,7 @@ type GridEditableProps = {
   isEditable?: boolean;
   isEditing?: boolean;
   isPrimary?: boolean;
-  isFlagged?: boolean;
+  isDragging?: boolean;
 };
 
 export const GridPanel = styled(Panel)`
@@ -107,7 +107,13 @@ export const GridHeadCellButton = styled('div')<GridEditableProps>`
   padding: ${space(1)} ${space(1.5)};
   border-radius: ${p => p.theme.borderRadius};
 
-  color: ${p => p.theme.gray2};
+  color: ${p => {
+    if (p.isDragging) {
+      return p.theme.offWhite2;
+    }
+
+    return p.theme.gray2;
+  }};
   font-size: 13px;
   font-weight: 600;
   line-height: 1;
@@ -116,19 +122,50 @@ export const GridHeadCellButton = styled('div')<GridEditableProps>`
   text-overflow: ellipsis;
   overflow: hidden;
 
-  background: ${p => (p.isEditing ? p.theme.offWhite2 : 'none')};
+  background: ${p => {
+    if (p.isDragging) {
+      return p.theme.gray2;
+    }
+
+    if (p.isEditing) {
+      return p.theme.offWhite2;
+    }
+
+    return 'none';
+  }};
 
   a {
-    color: ${p => p.theme.gray2};
+    color: ${p => {
+      if (p.isDragging) {
+        return p.theme.offWhite2;
+      }
+
+      return p.theme.gray2;
+    }};
   }
 
   &:hover,
   &:active {
-    color: ${p => p.theme.gray3};
+    color: ${p => {
+      if (p.isDragging) {
+        return p.theme.offWhite2;
+      }
+
+      return p.theme.gray2;
+    }};
+
     a {
-      color: ${p => p.theme.gray3};
+      color: ${p => {
+        if (p.isDragging) {
+          return p.theme.offWhite2;
+        }
+
+        return p.theme.gray2;
+      }};
     }
   }
+
+  user-select: none;
 `;
 export const GridHeadCellResizer = styled('span')<GridEditableProps>`
   position: absolute;
@@ -195,9 +232,7 @@ export const GridHeadCellButtonHoverBackground = styled(GridHeadCellButton)`
     color: ${p => p.theme.gray1} !important;
   }
 `;
-export const GridHeadCellButtonHoverButtonGroup = styled('div')<GridEditableProps>`
-  ${p => !p.isFlagged && 'margin: 0 auto;'}
-`;
+
 export const GridHeadCellButtonHoverButton = styled('div')`
   display: inline-flex;
   justify-content: center;
diff --git a/src/sentry/static/sentry/app/components/gridEditable/types.tsx b/src/sentry/static/sentry/app/components/gridEditable/types.tsx
index d3e204fad3..130e91a21c 100644
--- a/src/sentry/static/sentry/app/components/gridEditable/types.tsx
+++ b/src/sentry/static/sentry/app/components/gridEditable/types.tsx
@@ -5,7 +5,7 @@
  *   - columnKey should have the same set of values as K
  */
 
-type ObjectKey = React.ReactText;
+export type ObjectKey = React.ReactText;
 
 export type GridColumn<K = ObjectKey> = {
   key: K;
@@ -13,6 +13,7 @@ export type GridColumn<K = ObjectKey> = {
 
 export type GridColumnHeader<K = ObjectKey> = GridColumn<K> & {
   name: string;
+  isDragging: boolean;
   isPrimary?: boolean;
 };
 
diff --git a/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx b/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
index a66f0d7d90..1f068f4a8b 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
@@ -496,6 +496,7 @@ class EventView {
     return decodeColumnOrder({
       field: this.getFields(),
       fieldnames: this.getFieldNames(),
+      fields: this.fields,
     });
   }
 
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/draggableColumns.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/draggableColumns.tsx
new file mode 100644
index 0000000000..696386dd06
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/draggableColumns.tsx
@@ -0,0 +1,265 @@
+import React from 'react';
+import ReactDOM from 'react-dom';
+import styled from 'react-emotion';
+import {debounce} from 'lodash';
+
+import space from 'app/styles/space';
+import {
+  UserSelectValues,
+  setBodyUserSelect,
+} from 'app/components/events/interfaces/spans/utils';
+
+import {TableColumn} from './types';
+
+export const DRAGGABLE_COLUMN_CLASSNAME_IDENTIFIER = 'grid-head-cell-button';
+
+export type DraggableColumnsChildrenProps = {
+  isColumnDragging: boolean;
+  startColumnDrag: (
+    event: React.MouseEvent<SVGSVGElement, MouseEvent>,
+    initialColumnIndex: number
+  ) => void;
+  draggingColumnIndex: undefined | number;
+  destinationColumnIndex: undefined | number;
+};
+
+type Props = {
+  children: (props: DraggableColumnsChildrenProps) => JSX.Element;
+  columnOrder: TableColumn<React.ReactText>[];
+  onDragDone: (props: {
+    draggingColumnIndex: undefined | number;
+    destinationColumnIndex: undefined | number;
+  }) => void;
+};
+
+type State = {
+  isDragging: boolean;
+  left: undefined | number;
+  top: undefined | number;
+
+  draggingColumnIndex: undefined | number;
+  destinationColumnIndex: undefined | number;
+};
+
+class DraggableColumns extends React.Component<Props, State> {
+  state: State = {
+    isDragging: false,
+
+    // initial coordinates for when the drag began
+    left: void 0,
+    top: void 0,
+
+    draggingColumnIndex: void 0,
+    destinationColumnIndex: void 0,
+  };
+
+  previousUserSelect: UserSelectValues | null = null;
+  portal: HTMLElement | null = null;
+  dragGhostRef = React.createRef<HTMLDivElement>();
+
+  startColumnDrag = (
+    event: React.MouseEvent<SVGSVGElement, MouseEvent>,
+    initialColumnIndex: number
+  ) => {
+    const isDragging = this.state.isDragging;
+
+    if (isDragging || event.type !== 'mousedown') {
+      return;
+    }
+
+    // prevent the user from selecting things when dragging a column.
+    this.previousUserSelect = setBodyUserSelect({
+      userSelect: 'none',
+      MozUserSelect: 'none',
+      msUserSelect: 'none',
+    });
+
+    // attach event listeners so that the mouse cursor can drag anywhere
+    window.addEventListener('mousemove', this.onDragMove);
+    window.addEventListener('mouseup', this.onDragEnd);
+
+    this.setState({
+      isDragging: true,
+      draggingColumnIndex: initialColumnIndex,
+      destinationColumnIndex: initialColumnIndex,
+      left: event.pageX,
+      top: event.pageY,
+    });
+  };
+
+  onDragMove = (event: MouseEvent) => {
+    if (!this.state.isDragging || event.type !== 'mousemove') {
+      return;
+    }
+
+    if (this.dragGhostRef.current) {
+      // move the ghosted column title
+      const ghostDOM = this.dragGhostRef.current;
+      ghostDOM.style.left = `${event.pageX}px`;
+      ghostDOM.style.top = `${event.pageY}px`;
+    }
+
+    const gridHeadCellButtons = document.querySelectorAll(
+      `.${DRAGGABLE_COLUMN_CLASSNAME_IDENTIFIER}`
+    );
+
+    const destinationColumnIndex = Array.from(gridHeadCellButtons).findIndex(
+      headerElement => {
+        const rects = headerElement.getBoundingClientRect();
+
+        const left = event.pageX;
+
+        const thresholdStart = rects.left;
+        const thresholdEnd = rects.left + rects.width;
+
+        return left >= thresholdStart && left <= thresholdEnd;
+      }
+    );
+
+    if (destinationColumnIndex >= 0) {
+      if (this.state.destinationColumnIndex !== destinationColumnIndex) {
+        this.setDestinationColumnIndex(destinationColumnIndex);
+      }
+    }
+  };
+
+  setDestinationColumnIndex = debounce((destinationColumnIndex: number) => {
+    this.setState({
+      destinationColumnIndex,
+    });
+  }, 100);
+
+  onDragEnd = (event: MouseEvent) => {
+    if (!this.state.isDragging || event.type !== 'mouseup') {
+      return;
+    }
+
+    // remove listeners that were attached in startColumnDrag
+
+    this.cleanUpListeners();
+
+    // restore body styles
+
+    if (this.previousUserSelect) {
+      setBodyUserSelect(this.previousUserSelect);
+      this.previousUserSelect = null;
+    }
+
+    // indicate drag has ended
+
+    const destinationColumnIndex = this.state.destinationColumnIndex;
+    const draggingColumnIndex = this.state.draggingColumnIndex;
+
+    this.setState({
+      isDragging: false,
+      left: undefined,
+      top: undefined,
+      draggingColumnIndex: undefined,
+      destinationColumnIndex: undefined,
+    });
+
+    this.props.onDragDone({draggingColumnIndex, destinationColumnIndex});
+  };
+
+  cleanUpListeners = () => {
+    if (this.state.isDragging) {
+      window.removeEventListener('mousemove', this.onDragMove);
+      window.removeEventListener('mouseup', this.onDragEnd);
+    }
+  };
+
+  componentDidMount() {
+    if (!this.portal) {
+      const portal = document.createElement('div');
+
+      portal.style.position = 'absolute';
+      portal.style.top = '0';
+      portal.style.left = '0';
+      portal.style.zIndex = '9999';
+
+      this.portal = portal;
+
+      document.body.appendChild(this.portal);
+    }
+  }
+
+  componentWillUnmount() {
+    if (this.portal) {
+      document.body.removeChild(this.portal);
+    }
+    this.cleanUpListeners();
+  }
+
+  renderChildren = () => {
+    const childrenProps = {
+      isColumnDragging: this.state.isDragging,
+      startColumnDrag: this.startColumnDrag,
+      draggingColumnIndex: this.state.draggingColumnIndex,
+      destinationColumnIndex: this.state.destinationColumnIndex,
+    };
+
+    return this.props.children(childrenProps);
+  };
+
+  activeDragPlaceholder = () => {
+    if (
+      this.portal &&
+      this.state.isDragging &&
+      typeof this.state.draggingColumnIndex === 'number'
+    ) {
+      const columnBeingDragged = this.props.columnOrder[this.state.draggingColumnIndex];
+
+      const top = `${this.state.top}px`;
+      const left = `${this.state.left}px`;
+
+      const ghost = (
+        <GhostPlacement
+          innerRef={this.dragGhostRef}
+          style={{display: 'block', top, left}}
+        >
+          <GhostContentBox>{columnBeingDragged.name}</GhostContentBox>
+        </GhostPlacement>
+      );
+
+      return ReactDOM.createPortal(ghost, this.portal);
+    }
+
+    return null;
+  };
+
+  render() {
+    return (
+      <React.Fragment>
+        {this.activeDragPlaceholder()}
+        {this.renderChildren()}
+      </React.Fragment>
+    );
+  }
+}
+
+const GhostPlacement = styled('div')`
+  position: absolute;
+  top: 0;
+  bottom: 0;
+  display: none;
+
+  user-select: none;
+`;
+
+const GhostContentBox = styled('div')`
+  padding: ${space(1)} ${space(1.5)};
+  border-radius: ${p => p.theme.borderRadius};
+
+  color: ${p => p.theme.gray2};
+  font-size: 13px;
+  font-weight: 600;
+  line-height: 1;
+  text-transform: uppercase;
+  white-space: nowrap;
+  text-overflow: ellipsis;
+  overflow: hidden;
+
+  background: ${p => p.theme.offWhite2};
+`;
+
+export default DraggableColumns;
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
index 350151a297..6fa8193dfc 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
@@ -11,6 +11,9 @@ import SortLink from '../sortLink';
 import renderTableModalEditColumnFactory from './tableModalEditColumn';
 import {TableColumn, TableData, TableDataRow} from './types';
 import {ColumnValueType} from '../eventQueryParams';
+import DraggableColumns, {
+  DRAGGABLE_COLUMN_CLASSNAME_IDENTIFIER,
+} from './draggableColumns';
 
 export type TableViewProps = {
   location: Location;
@@ -31,7 +34,6 @@ export type TableViewProps = {
  * and re-ordering columns.
  */
 class TableView extends React.Component<TableViewProps> {
-  // TODO: update this docs
   /**
    * The entire state of the table view (or event view) is co-located within
    * the EventView object. This object is fed from the props.
@@ -107,7 +109,7 @@ class TableView extends React.Component<TableViewProps> {
   /**
    * Please read the comment on `_createColumn`
    */
-  _moveColumn = (fromIndex: number, toIndex: number) => {
+  _moveColumnCommit = (fromIndex: number, toIndex: number) => {
     const {location, eventView} = this.props;
 
     const nextEventView = eventView.withMovedColumn({fromIndex, toIndex});
@@ -119,22 +121,21 @@ class TableView extends React.Component<TableViewProps> {
     });
   };
 
-  _renderGridHeaderCell = (
-    column: TableColumn<keyof TableDataRow>,
-    columnIndex: number
-  ): React.ReactNode => {
+  _renderGridHeaderCell = (column: TableColumn<keyof TableDataRow>): React.ReactNode => {
     const {eventView, location, tableData} = this.props;
+
     if (!tableData) {
       return column.name;
     }
 
-    const field = eventView.fields[columnIndex];
+    const field = column.eventViewField;
 
+    // establish alignment based on the type
     const alignedTypes: ColumnValueType[] = ['number', 'duration'];
     let align: 'right' | 'left' = alignedTypes.includes(column.type) ? 'right' : 'left';
 
-    // TODO(alberto): clean this
     if (column.type === 'never' || column.type === '*') {
+      // fallback to align the column based on the table metadata
       const maybeType = tableData.meta[getAggregateAlias(field.field)];
 
       if (maybeType === 'integer' || maybeType === 'number') {
@@ -169,6 +170,51 @@ class TableView extends React.Component<TableViewProps> {
     return fieldRenderer(dataRow, {organization, location});
   };
 
+  generateColumnOrder = ({
+    initialColumnIndex,
+    destinationColumnIndex,
+  }: {
+    initialColumnIndex: undefined | number;
+    destinationColumnIndex: undefined | number;
+  }) => {
+    const {eventView} = this.props;
+    const columnOrder = eventView.getColumns();
+
+    if (
+      typeof destinationColumnIndex !== 'number' ||
+      typeof initialColumnIndex !== 'number'
+    ) {
+      return columnOrder;
+    }
+
+    if (destinationColumnIndex === initialColumnIndex) {
+      const currentDraggingColumn: TableColumn<keyof TableDataRow> = {
+        ...columnOrder[destinationColumnIndex],
+        isDragging: true,
+      };
+
+      columnOrder[destinationColumnIndex] = currentDraggingColumn;
+
+      return columnOrder;
+    }
+
+    const nextColumnOrder = [...columnOrder];
+
+    nextColumnOrder.splice(
+      destinationColumnIndex,
+      0,
+      nextColumnOrder.splice(initialColumnIndex, 1)[0]
+    );
+
+    const currentDraggingColumn: TableColumn<keyof TableDataRow> = {
+      ...nextColumnOrder[destinationColumnIndex],
+      isDragging: true,
+    };
+    nextColumnOrder[destinationColumnIndex] = currentDraggingColumn;
+
+    return nextColumnOrder;
+  };
+
   render() {
     const {organization, isLoading, error, tableData, eventView} = this.props;
 
@@ -184,26 +230,54 @@ class TableView extends React.Component<TableViewProps> {
     });
 
     return (
-      <GridEditable
-        isEditable
-        isLoading={isLoading}
-        error={error}
-        data={tableData ? tableData.data : []}
+      <DraggableColumns
         columnOrder={columnOrder}
-        columnSortBy={columnSortBy}
-        grid={{
-          renderHeaderCell: this._renderGridHeaderCell as any,
-          renderBodyCell: this._renderGridBodyCell as any,
+        onDragDone={({draggingColumnIndex, destinationColumnIndex}) => {
+          if (
+            typeof draggingColumnIndex === 'number' &&
+            typeof destinationColumnIndex === 'number' &&
+            draggingColumnIndex !== destinationColumnIndex
+          ) {
+            this._moveColumnCommit(draggingColumnIndex, destinationColumnIndex);
+          }
         }}
-        modalEditColumn={{
-          renderBodyWithForm: renderModalBodyWithForm as any,
-          renderFooter: renderModalFooter,
+      >
+        {({
+          isColumnDragging,
+          startColumnDrag,
+          draggingColumnIndex,
+          destinationColumnIndex,
+        }) => {
+          return (
+            <GridEditable
+              isEditable
+              isColumnDragging={isColumnDragging}
+              gridHeadCellButtonProps={{className: DRAGGABLE_COLUMN_CLASSNAME_IDENTIFIER}}
+              isLoading={isLoading}
+              error={error}
+              data={tableData ? tableData.data : []}
+              columnOrder={this.generateColumnOrder({
+                initialColumnIndex: draggingColumnIndex,
+                destinationColumnIndex,
+              })}
+              columnSortBy={columnSortBy}
+              grid={{
+                renderHeaderCell: this._renderGridHeaderCell as any,
+                renderBodyCell: this._renderGridBodyCell as any,
+              }}
+              modalEditColumn={{
+                renderBodyWithForm: renderModalBodyWithForm as any,
+                renderFooter: renderModalFooter,
+              }}
+              actions={{
+                deleteColumn: this._deleteColumn,
+                moveColumnCommit: this._moveColumnCommit,
+                onDragStart: startColumnDrag,
+              }}
+            />
+          );
         }}
-        actions={{
-          deleteColumn: this._deleteColumn,
-          moveColumn: this._moveColumn,
-        }}
-      />
+      </DraggableColumns>
     );
   }
 }
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/types.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/types.tsx
index 02fd3746e7..18cb2f1671 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/types.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/types.tsx
@@ -1,6 +1,7 @@
 import {GridColumnOrder, GridColumnSortBy} from 'app/components/gridEditable';
 
 import {ColumnValueType, Aggregation, Field} from '../eventQueryParams';
+import {Field as FieldType} from '../eventView';
 import {MetaType} from '../utils';
 
 /**
@@ -11,6 +12,7 @@ export type TableColumn<K> = GridColumnOrder<K> & {
   // name: string               From GridColumnHeader
   aggregation: Aggregation;
   field: Field;
+  eventViewField: Readonly<FieldType>;
 
   type: ColumnValueType;
   isSortable: boolean;
diff --git a/src/sentry/static/sentry/app/views/eventsV2/utils.tsx b/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
index b6dd9b2f0d..4d3029798e 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
@@ -14,7 +14,7 @@ import {
   FieldTypes,
   FieldFormatterRenderFunctionPartial,
 } from './data';
-import EventView from './eventView';
+import EventView, {Field as FieldType} from './eventView';
 import {
   Aggregation,
   Field,
@@ -228,6 +228,8 @@ const TEMPLATE_TABLE_COLUMN: TableColumn<React.ReactText> = {
   name: '',
   aggregation: '',
   field: '',
+  eventViewField: Object.freeze({field: '', title: ''}),
+  isDragging: false,
 
   type: 'never',
   isSortable: false,
@@ -237,8 +239,9 @@ const TEMPLATE_TABLE_COLUMN: TableColumn<React.ReactText> = {
 export function decodeColumnOrder(props: {
   fieldnames: string[];
   field: string[];
+  fields: Readonly<FieldType[]>;
 }): TableColumn<React.ReactText>[] {
-  const {fieldnames, field} = props;
+  const {fieldnames, field, fields} = props;
 
   return field.map((f: string, index: number) => {
     const col = {aggregationField: f, name: fieldnames[index]};
@@ -267,6 +270,11 @@ export function decodeColumnOrder(props: {
       : false;
     column.isPrimary = column.field === 'title';
 
+    column.eventViewField = {
+      title: fields[index].title,
+      field: fields[index].field,
+    };
+
     return column;
   });
 }
diff --git a/tests/js/spec/views/eventsV2/utils.spec.jsx b/tests/js/spec/views/eventsV2/utils.spec.jsx
index 23722a84f1..f2e2813b07 100644
--- a/tests/js/spec/views/eventsV2/utils.spec.jsx
+++ b/tests/js/spec/views/eventsV2/utils.spec.jsx
@@ -260,15 +260,21 @@ describe('decodeColumnOrder', function() {
     const results = decodeColumnOrder({
       field: ['title'],
       fieldnames: ['Event title'],
+      fields: [{field: 'title', title: 'Event title'}],
     });
 
     expect(Array.isArray(results)).toBeTruthy();
 
-    expect(results[0]).toMatchObject({
+    expect(results[0]).toEqual({
       key: 'title',
       name: 'Event title',
       aggregation: '',
       field: 'title',
+      eventViewField: {field: 'title', title: 'Event title'},
+      isDragging: false,
+      isPrimary: true,
+      isSortable: false,
+      type: 'string',
     });
   });
 
@@ -276,15 +282,21 @@ describe('decodeColumnOrder', function() {
     const results = decodeColumnOrder({
       field: ['count()'],
       fieldnames: ['projects'],
+      fields: [{field: 'count()', title: 'projects'}],
     });
 
     expect(Array.isArray(results)).toBeTruthy();
 
-    expect(results[0]).toMatchObject({
+    expect(results[0]).toEqual({
       key: 'count()',
       name: 'projects',
       aggregation: 'count',
       field: '',
+      eventViewField: {field: 'count()', title: 'projects'},
+      isDragging: false,
+      isPrimary: false,
+      isSortable: true,
+      type: 'never',
     });
   });
 
@@ -292,15 +304,21 @@ describe('decodeColumnOrder', function() {
     const results = decodeColumnOrder({
       field: ['avg(transaction.duration)'],
       fieldnames: ['average'],
+      fields: [{field: 'avg(transaction.duration)', title: 'average'}],
     });
 
     expect(Array.isArray(results)).toBeTruthy();
 
-    expect(results[0]).toMatchObject({
+    expect(results[0]).toEqual({
       key: 'avg(transaction.duration)',
       name: 'average',
       aggregation: 'avg',
       field: 'transaction.duration',
+      eventViewField: {field: 'avg(transaction.duration)', title: 'average'},
+      isDragging: false,
+      isPrimary: false,
+      isSortable: true,
+      type: 'duration',
     });
   });
 });

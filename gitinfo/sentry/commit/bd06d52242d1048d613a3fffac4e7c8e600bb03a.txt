commit bd06d52242d1048d613a3fffac4e7c8e600bb03a
Author: David Cramer <dcramer@gmail.com>
Date:   Tue Sep 10 14:25:59 2013 -0700

    Refactor large amount of db utils and place them in sentry.db

diff --git a/src/sentry/db/__init__.py b/src/sentry/db/__init__.py
new file mode 100644
index 0000000000..841163213a
--- /dev/null
+++ b/src/sentry/db/__init__.py
@@ -0,0 +1,9 @@
+"""
+sentry.db
+~~~~~~~~~
+
+:copyright: (c) 2010-2013 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from __future__ import division
diff --git a/src/sentry/db/exceptions.py b/src/sentry/db/exceptions.py
new file mode 100644
index 0000000000..a931cc4831
--- /dev/null
+++ b/src/sentry/db/exceptions.py
@@ -0,0 +1,17 @@
+"""
+sentry.db.exceptions
+~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2013 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from __future__ import absolute_import
+
+
+class QueryError(Exception):
+    pass
+
+
+class CannotResolveExpression(Exception):
+    pass
diff --git a/src/sentry/db/models/__init__.py b/src/sentry/db/models/__init__.py
new file mode 100644
index 0000000000..48d9df345d
--- /dev/null
+++ b/src/sentry/db/models/__init__.py
@@ -0,0 +1,14 @@
+"""
+sentry.db.models
+~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2013 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from __future__ import absolute_import
+
+from .base import *  # NOQA
+from .fields import *  # NOQA
+from .manager import *  # NOQA
+from .query import *  # NOQA
diff --git a/src/sentry/db/models/base.py b/src/sentry/db/models/base.py
new file mode 100644
index 0000000000..35fdcc8efc
--- /dev/null
+++ b/src/sentry/db/models/base.py
@@ -0,0 +1,104 @@
+"""
+sentry.db.models
+~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2013 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from __future__ import absolute_import
+
+from django.db import models
+from django.db.models import signals
+
+from .fields.bounded import BoundedAutoField
+from .manager import BaseManager
+from .query import update
+
+__all__ = ('BaseModel', 'Model', 'sane_repr')
+
+UNSAVED = object()
+
+
+def sane_repr(*attrs):
+    if 'id' not in attrs and 'pk' not in attrs:
+        attrs = ('id',) + attrs
+
+    def _repr(self):
+        cls = type(self).__name__
+
+        pairs = (
+            '%s=%s' % (a, repr(getattr(self, a, None)))
+            for a in attrs)
+
+        return u'<%s at 0x%x: %s>' % (cls, id(self), ', '.join(pairs))
+
+    return _repr
+
+
+class BaseModel(models.Model):
+    class Meta:
+        abstract = True
+
+    objects = BaseManager()
+
+    update = update
+
+    def __init__(self, *args, **kwargs):
+        super(BaseModel, self).__init__(*args, **kwargs)
+        self._update_tracked_data()
+
+    def __getstate__(self):
+        d = self.__dict__.copy()
+        # we cant serialize weakrefs
+        d.pop('_Model__data', None)
+        return d
+
+    def __reduce__(self):
+        (model_unpickle, stuff, _) = super(BaseModel, self).__reduce__()
+        return (model_unpickle, stuff, self.__getstate__())
+
+    def __setstate__(self, state):
+        self.__dict__.update(state)
+        self._update_tracked_data()
+
+    def __get_field_value(self, field):
+        if isinstance(field, models.ForeignKey):
+            return getattr(self, field.column)
+        return getattr(self, field.name)
+
+    def _update_tracked_data(self):
+        "Updates a local copy of attributes values"
+        if self.id:
+            self.__data = dict((f.column, self.__get_field_value(f)) for f in self._meta.fields)
+        else:
+            self.__data = UNSAVED
+
+    def has_changed(self, field_name):
+        "Returns ``True`` if ``field`` has changed since initialization."
+        if self.__data is UNSAVED:
+            return False
+        field = self._meta.get_field(field_name)
+        return self.__data.get(field_name) != self.__get_field_value(field)
+
+    def old_value(self, field_name):
+        "Returns the previous value of ``field``"
+        if self.__data is UNSAVED:
+            return None
+        return self.__data.get(field_name)
+
+
+def __model_post_save(instance, **kwargs):
+    if not isinstance(instance, BaseModel):
+        return
+    instance._update_tracked_data()
+
+
+class Model(BaseModel):
+    id = BoundedAutoField(primary_key=True)
+
+    class Meta:
+        abstract = True
+
+
+signals.post_save.connect(__model_post_save)
diff --git a/src/sentry/db/models/fields/__init__.py b/src/sentry/db/models/fields/__init__.py
new file mode 100644
index 0000000000..ed17cb9bdd
--- /dev/null
+++ b/src/sentry/db/models/fields/__init__.py
@@ -0,0 +1,12 @@
+"""
+sentry.db.models.fields
+~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2013 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from __future__ import absolute_import
+
+from .bounded import *  # NOQA
+from .gzippeddict import *  # NOQA
diff --git a/src/sentry/db/models/fields/bounded.py b/src/sentry/db/models/fields/bounded.py
new file mode 100644
index 0000000000..afdf97cdfc
--- /dev/null
+++ b/src/sentry/db/models/fields/bounded.py
@@ -0,0 +1,83 @@
+"""
+sentry.db.models.fields.bounded
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2013 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from __future__ import absolute_import
+from django.db import models
+
+
+__all__ = (
+    'BoundedAutoField', 'BoundedIntegerField', 'BoundedBigIntegerField',
+    'BoundedPositiveIntegerField')
+
+
+class BoundedAutoField(models.AutoField):
+    MAX_VALUE = 2147483647
+
+    def get_prep_value(self, value):
+        if value:
+            value = int(value)
+            assert value <= self.MAX_VALUE
+        return super(BoundedAutoField, self).get_prep_value(value)
+
+    def south_field_triple(self):
+        "Returns a suitable description of this field for South."
+        from south.modelsinspector import introspector
+        field_class = "django.db.models.fields.AutoField"
+        args, kwargs = introspector(self)
+        return (field_class, args, kwargs)
+
+
+class BoundedIntegerField(models.IntegerField):
+    MAX_VALUE = 2147483647
+
+    def get_prep_value(self, value):
+        if value:
+            value = int(value)
+            assert value <= self.MAX_VALUE
+        return super(BoundedIntegerField, self).get_prep_value(value)
+
+    def south_field_triple(self):
+        "Returns a suitable description of this field for South."
+        from south.modelsinspector import introspector
+        field_class = "django.db.models.fields.IntegerField"
+        args, kwargs = introspector(self)
+        return (field_class, args, kwargs)
+
+
+class BoundedBigIntegerField(models.BigIntegerField):
+    MAX_VALUE = 9223372036854775807
+
+    def get_prep_value(self, value):
+        if value:
+            value = int(value)
+            assert value <= self.MAX_VALUE
+        return super(BoundedBigIntegerField, self).get_prep_value(value)
+
+    def south_field_triple(self):
+        "Returns a suitable description of this field for South."
+        from south.modelsinspector import introspector
+        field_class = "django.db.models.fields.BigIntegerField"
+        args, kwargs = introspector(self)
+        return (field_class, args, kwargs)
+
+
+class BoundedPositiveIntegerField(models.PositiveIntegerField):
+    MAX_VALUE = 2147483647
+
+    def get_prep_value(self, value):
+        if value:
+            value = int(value)
+            assert value <= self.MAX_VALUE
+        return super(BoundedPositiveIntegerField, self).get_prep_value(value)
+
+    def south_field_triple(self):
+        "Returns a suitable description of this field for South."
+        from south.modelsinspector import introspector
+        field_class = "django.db.models.fields.PositiveIntegerField"
+        args, kwargs = introspector(self)
+        return (field_class, args, kwargs)
diff --git a/src/sentry/db/models/fields/gzippeddict.py b/src/sentry/db/models/fields/gzippeddict.py
new file mode 100644
index 0000000000..42e91ddb69
--- /dev/null
+++ b/src/sentry/db/models/fields/gzippeddict.py
@@ -0,0 +1,56 @@
+"""
+sentry.db.models.fields.gzippeddict
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2013 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from __future__ import absolute_import
+
+import logging
+
+from django.db import models
+
+from sentry.utils.compat import pickle
+from sentry.utils.strings import decompress, compress
+
+__all__ = ('GzippedDictField',)
+
+logger = logging.getLogger('sentry.errors')
+
+
+class GzippedDictField(models.TextField):
+    """
+    Slightly different from a JSONField in the sense that the default
+    value is a dictionary.
+    """
+    __metaclass__ = models.SubfieldBase
+
+    def to_python(self, value):
+        if isinstance(value, basestring) and value:
+            try:
+                value = pickle.loads(decompress(value))
+            except Exception, e:
+                logger.exception(e)
+                return {}
+        elif not value:
+            return {}
+        return value
+
+    def get_prep_value(self, value):
+        if not value and self.null:
+            # save ourselves some storage
+            return None
+        return compress(pickle.dumps(value))
+
+    def value_to_string(self, obj):
+        value = self._get_val_from_obj(obj)
+        return self.get_prep_value(value)
+
+    def south_field_triple(self):
+        "Returns a suitable description of this field for South."
+        from south.modelsinspector import introspector
+        field_class = "django.db.models.fields.TextField"
+        args, kwargs = introspector(self)
+        return (field_class, args, kwargs)
diff --git a/src/sentry/db/models/manager.py b/src/sentry/db/models/manager.py
new file mode 100644
index 0000000000..2fbbc6325b
--- /dev/null
+++ b/src/sentry/db/models/manager.py
@@ -0,0 +1,226 @@
+"""
+sentry.db.models.manager
+~~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2013 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from __future__ import with_statement
+
+import hashlib
+import logging
+import threading
+import weakref
+
+from django.conf import settings
+from django.db import router
+from django.db.models import Manager, Model
+from django.db.models.signals import (
+    post_save, post_delete, post_init, class_prepared)
+from django.utils.encoding import smart_str
+
+from sentry.utils.cache import cache
+
+from .query import create_or_update
+
+__all__ = ('BaseManager',)
+
+logger = logging.getLogger('sentry.errors')
+
+
+class ImmutableDict(dict):
+    def __setitem__(self, key, value):
+        raise TypeError
+
+    def __delitem__(self, key):
+        raise TypeError
+
+UNSAVED = ImmutableDict()
+
+
+def __prep_value(model, key, value):
+    if isinstance(value, Model):
+        value = value.pk
+    else:
+        value = unicode(value)
+    return value
+
+
+def __prep_key(model, key):
+    if key == 'pk':
+        return model._meta.pk.name
+    return key
+
+
+def make_key(model, prefix, kwargs):
+    kwargs_bits = []
+    for k, v in sorted(kwargs.iteritems()):
+        k = __prep_key(model, k)
+        v = smart_str(__prep_value(model, k, v))
+        kwargs_bits.append('%s=%s' % (k, v))
+    kwargs_bits = ':'.join(kwargs_bits)
+
+    return '%s:%s:%s' % (prefix, model.__name__, hashlib.md5(kwargs_bits).hexdigest())
+
+
+class BaseManager(Manager):
+    lookup_handlers = {
+        'iexact': lambda x: x.upper(),
+    }
+    use_for_related_fields = True
+
+    def __init__(self, *args, **kwargs):
+        self.cache_fields = kwargs.pop('cache_fields', [])
+        self.cache_ttl = kwargs.pop('cache_ttl', 60 * 5)
+        self.__local_cache = threading.local()
+        super(BaseManager, self).__init__(*args, **kwargs)
+
+    def _get_cache(self):
+        if not hasattr(self.__local_cache, 'value'):
+            self.__local_cache.value = weakref.WeakKeyDictionary()
+        return self.__local_cache.value
+
+    def _set_cache(self, value):
+        self.__local_cache.value = value
+
+    __cache = property(_get_cache, _set_cache)
+
+    def __getstate__(self):
+        d = self.__dict__.copy()
+        # we cant serialize weakrefs
+        d.pop('_BaseManager__cache', None)
+        d.pop('_BaseManager__local_cache', None)
+        return d
+
+    def __setstate__(self, state):
+        self.__dict__.update(state)
+        self.__local_cache = weakref.WeakKeyDictionary()
+
+    def __class_prepared(self, sender, **kwargs):
+        """
+        Given the cache is configured, connects the required signals for invalidation.
+        """
+        if not self.cache_fields:
+            return
+        post_init.connect(self.__post_init, sender=sender, weak=False)
+        post_save.connect(self.__post_save, sender=sender, weak=False)
+        post_delete.connect(self.__post_delete, sender=sender, weak=False)
+
+    def __cache_state(self, instance):
+        """
+        Updates the tracked state of an instance.
+        """
+        if instance.pk:
+            self.__cache[instance] = dict((f, getattr(instance, f)) for f in self.cache_fields)
+        else:
+            self.__cache[instance] = UNSAVED
+
+    def __post_init(self, instance, **kwargs):
+        """
+        Stores the initial state of an instance.
+        """
+        self.__cache_state(instance)
+
+    def __post_save(self, instance, **kwargs):
+        """
+        Pushes changes to an instance into the cache, and removes invalid (changed)
+        lookup values.
+        """
+        pk_name = instance._meta.pk.name
+        pk_names = ('pk', pk_name)
+        pk_val = instance.pk
+        for key in self.cache_fields:
+            if key in pk_names:
+                continue
+            # store pointers
+            cache.set(self.__get_lookup_cache_key(**{key: getattr(instance, key)}), pk_val, self.cache_ttl)  # 1 hour
+
+        # Ensure we don't serialize the database into the cache
+        db = instance._state.db
+        instance._state.db = None
+        # store actual object
+        try:
+            cache.set(self.__get_lookup_cache_key(**{pk_name: pk_val}), instance, self.cache_ttl)
+        except Exception as e:
+            logger.error(e, exc_info=True)
+        instance._state.db = db
+
+        # Kill off any keys which are no longer valid
+        if instance in self.__cache:
+            for key in self.cache_fields:
+                if key not in self.__cache[instance]:
+                    continue
+                value = self.__cache[instance][key]
+                if value != getattr(instance, key):
+                    cache.delete(self.__get_lookup_cache_key(**{key: value}))
+
+        self.__cache_state(instance)
+
+    def __post_delete(self, instance, **kwargs):
+        """
+        Drops instance from all cache storages.
+        """
+        pk_name = instance._meta.pk.name
+        for key in self.cache_fields:
+            if key in ('pk', pk_name):
+                continue
+            # remove pointers
+            cache.delete(self.__get_lookup_cache_key(**{key: getattr(instance, key)}))
+        # remove actual object
+        cache.delete(self.__get_lookup_cache_key(**{pk_name: instance.pk}))
+
+    def __get_lookup_cache_key(self, **kwargs):
+        return make_key(self.model, 'modelcache', kwargs)
+
+    def contribute_to_class(self, model, name):
+        super(BaseManager, self).contribute_to_class(model, name)
+        class_prepared.connect(self.__class_prepared, sender=model)
+
+    def get_from_cache(self, **kwargs):
+        """
+        Wrapper around QuerySet.get which supports caching of the
+        intermediate value.  Callee is responsible for making sure
+        the cache key is cleared on save.
+        """
+        if not self.cache_fields or len(kwargs) > 1:
+            return self.get(**kwargs)
+
+        key, value = kwargs.items()[0]
+        pk_name = self.model._meta.pk.name
+        if key == 'pk':
+            key = pk_name
+
+        # Kill __exact since it's the default behavior
+        if key.endswith('__exact'):
+            key = key.split('__exact', 1)[0]
+
+        if key in self.cache_fields or key == pk_name:
+            cache_key = self.__get_lookup_cache_key(**{key: value})
+
+            retval = cache.get(cache_key)
+            if retval is None:
+                result = self.get(**kwargs)
+                # Ensure we're pushing it into the cache
+                self.__post_save(instance=result)
+                return result
+
+            # If we didn't look up by pk we need to hit the reffed
+            # key
+            if key != pk_name:
+                return self.get_from_cache(**{pk_name: retval})
+
+            if type(retval) != self.model:
+                if settings.DEBUG:
+                    raise ValueError('Unexpected value type returned from cache')
+                logger.error('Cache response returned invalid value %r', retval)
+                return self.get(**kwargs)
+
+            retval._state.db = router.db_for_read(self.model, **kwargs)
+
+            return retval
+        else:
+            return self.get(**kwargs)
+
+    def create_or_update(self, **kwargs):
+        return create_or_update(self.model, **kwargs)
diff --git a/src/sentry/db/models/query.py b/src/sentry/db/models/query.py
new file mode 100644
index 0000000000..d1754f25cb
--- /dev/null
+++ b/src/sentry/db/models/query.py
@@ -0,0 +1,90 @@
+"""
+sentry.db.query
+~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2013 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from __future__ import absolute_import
+
+from django.db import router, transaction, IntegrityError
+from django.db.models.expressions import ExpressionNode
+from django.db.models.signals import post_save
+
+from sentry.db.exceptions import QueryError
+
+from .utils import resolve_expression_node
+
+__all__ = ('update', 'create_or_update')
+
+
+def update(self, using=None, **kwargs):
+    """
+    Updates specified attributes on the current instance.
+    """
+    assert self.pk, "Cannot update an instance that has not yet been created."
+
+    using = using or router.db_for_write(self.__class__, instance=self)
+
+    for field in self._meta.fields:
+        if getattr(field, 'auto_now', False) and field.name not in kwargs:
+            kwargs[field.name] = field.pre_save(self, False)
+
+    affected = self.__class__._base_manager.using(using).filter(pk=self.pk).update(**kwargs)
+    for k, v in kwargs.iteritems():
+        if isinstance(v, ExpressionNode):
+            v = resolve_expression_node(self, v)
+        setattr(self, k, v)
+    if affected == 1:
+        post_save.send(sender=self.__class__, instance=self, created=False)
+        return True
+    elif affected == 0:
+        return False
+    elif affected < 0:
+        raise ValueError("Somehow we have updated a negative amount of rows, you seem to have a problem with your db backend.")
+    else:
+        raise ValueError("Somehow we have updated multiple rows, and you are now royally fucked.")
+
+update.alters_data = True
+
+
+def create_or_update(model, using=None, **kwargs):
+    """
+    Similar to get_or_create, either updates a row or creates it.
+
+    The result will be (rows affected, False), if the row was not created,
+    or (instance, True) if the object is new.
+
+    >>> create_or_update(MyModel, key='value', defaults={
+    >>>     'value': F('value') + 1,
+    >>> })
+    """
+    defaults = kwargs.pop('defaults', {})
+
+    if not using:
+        using = router.db_for_write(model)
+
+    objects = model.objects.using(using)
+
+    affected = objects.filter(**kwargs).update(**defaults)
+    if affected:
+        return affected, False
+
+    create_kwargs = kwargs.copy()
+    inst = objects.model()
+    for k, v in defaults.iteritems():
+        if isinstance(v, ExpressionNode):
+            create_kwargs[k] = resolve_expression_node(inst, v)
+        else:
+            create_kwargs[k] = v
+    try:
+        return objects.create(**create_kwargs), True
+    except IntegrityError:
+        transaction.rollback_unless_managed(using=using)
+        affected = objects.filter(**kwargs).update(**defaults)
+
+    if not affected:
+        raise QueryError('No rows updated or created for kwargs: %r' % kwargs)
+
+    return affected, False
diff --git a/src/sentry/db/models/utils.py b/src/sentry/db/models/utils.py
new file mode 100644
index 0000000000..5f580ff4f1
--- /dev/null
+++ b/src/sentry/db/models/utils.py
@@ -0,0 +1,50 @@
+"""
+sentry.db.utils
+~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2013 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from __future__ import absolute_import
+
+import operator
+
+from django.db.models import F
+from django.db.models.expressions import ExpressionNode
+
+from sentry.db.exceptions import CannotResolveExpression
+
+
+EXPRESSION_NODE_CALLBACKS = {
+    ExpressionNode.ADD: operator.add,
+    ExpressionNode.SUB: operator.sub,
+    ExpressionNode.MUL: operator.mul,
+    ExpressionNode.DIV: operator.div,
+    ExpressionNode.MOD: operator.mod,
+}
+try:
+    EXPRESSION_NODE_CALLBACKS[ExpressionNode.AND] = operator.and_
+except AttributeError:
+    EXPRESSION_NODE_CALLBACKS[ExpressionNode.BITAND] = operator.and_
+try:
+    EXPRESSION_NODE_CALLBACKS[ExpressionNode.OR] = operator.or_
+except AttributeError:
+    EXPRESSION_NODE_CALLBACKS[ExpressionNode.BITOR] = operator.or_
+
+
+def resolve_expression_node(instance, node):
+    def _resolve(instance, node):
+        if isinstance(node, F):
+            return getattr(instance, node.name)
+        elif isinstance(node, ExpressionNode):
+            return resolve_expression_node(instance, node)
+        return node
+
+    op = EXPRESSION_NODE_CALLBACKS.get(node.connector, None)
+    if not op:
+        raise CannotResolveExpression
+    runner = _resolve(instance, node.children[0])
+    for n in node.children[1:]:
+        runner = op(runner, _resolve(instance, n))
+    return runner
diff --git a/src/sentry/management/commands/repair.py b/src/sentry/management/commands/repair.py
index d691075fbe..d4c947022f 100644
--- a/src/sentry/management/commands/repair.py
+++ b/src/sentry/management/commands/repair.py
@@ -19,7 +19,7 @@ class Command(BaseCommand):
     def handle(self, **options):
         from django.template.defaultfilters import slugify
         from sentry.models import Project, Team, ProjectKey, User
-        from sentry.utils.models import update
+        from sentry.db.models import update
 
         if options.get('owner'):
             owner = User.objects.get(username__iexact=options.get('owner'))
diff --git a/src/sentry/manager.py b/src/sentry/manager.py
index bb790468a1..52855e8f74 100644
--- a/src/sentry/manager.py
+++ b/src/sentry/manager.py
@@ -14,19 +14,16 @@ import hashlib
 import itertools
 import logging
 import re
-import threading
 import time
 import warnings
-import weakref
 import uuid
 
 from celery.signals import task_postrun
 from django.conf import settings
 from django.contrib.auth.models import UserManager
 from django.core.signals import request_finished
-from django.db import models, router, transaction, IntegrityError
+from django.db import models, transaction, IntegrityError
 from django.db.models import Sum
-from django.db.models.signals import post_save, post_delete, post_init, class_prepared
 from django.utils import timezone
 from django.utils.datastructures import SortedDict
 from django.utils.encoding import force_unicode
@@ -37,13 +34,13 @@ from sentry.constants import (
     STATUS_RESOLVED, STATUS_UNRESOLVED, MINUTE_NORMALIZATION,
     MAX_EXTRA_VARIABLE_SIZE, LOG_LEVELS, DEFAULT_LOGGER_NAME,
     MAX_CULPRIT_LENGTH)
+from sentry.db.models import BaseManager
 from sentry.processors.base import send_group_processors
 from sentry.signals import regression_signal
 from sentry.tasks.index import index_event
 from sentry.utils.cache import cache, memoize
 from sentry.utils.dates import get_sql_date_trunc, normalize_datetime
 from sentry.utils.db import get_db_engine, has_charts, attach_foreignkey
-from sentry.utils.models import create_or_update, make_key
 from sentry.utils.safe import safe_execute, trim, trim_dict
 from sentry.utils.strings import strip
 
@@ -65,168 +62,6 @@ def get_checksum_from_event(event):
     return hashlib.md5(to_string(event.message)).hexdigest()
 
 
-class BaseManager(models.Manager):
-    lookup_handlers = {
-        'iexact': lambda x: x.upper(),
-    }
-    use_for_related_fields = True
-
-    def __init__(self, *args, **kwargs):
-        self.cache_fields = kwargs.pop('cache_fields', [])
-        self.cache_ttl = kwargs.pop('cache_ttl', 60 * 5)
-        self.__local_cache = threading.local()
-        super(BaseManager, self).__init__(*args, **kwargs)
-
-    def _get_cache(self):
-        if not hasattr(self.__local_cache, 'value'):
-            self.__local_cache.value = weakref.WeakKeyDictionary()
-        return self.__local_cache.value
-
-    def _set_cache(self, value):
-        self.__local_cache.value = value
-
-    __cache = property(_get_cache, _set_cache)
-
-    def __getstate__(self):
-        d = self.__dict__.copy()
-        # we cant serialize weakrefs
-        d.pop('_BaseManager__cache', None)
-        d.pop('_BaseManager__local_cache', None)
-        return d
-
-    def __setstate__(self, state):
-        self.__dict__.update(state)
-        self.__local_cache = weakref.WeakKeyDictionary()
-
-    def __class_prepared(self, sender, **kwargs):
-        """
-        Given the cache is configured, connects the required signals for invalidation.
-        """
-        if not self.cache_fields:
-            return
-        post_init.connect(self.__post_init, sender=sender, weak=False)
-        post_save.connect(self.__post_save, sender=sender, weak=False)
-        post_delete.connect(self.__post_delete, sender=sender, weak=False)
-
-    def __cache_state(self, instance):
-        """
-        Updates the tracked state of an instance.
-        """
-        if instance.pk:
-            self.__cache[instance] = dict((f, getattr(instance, f)) for f in self.cache_fields)
-        else:
-            self.__cache[instance] = UNSAVED
-
-    def __post_init(self, instance, **kwargs):
-        """
-        Stores the initial state of an instance.
-        """
-        self.__cache_state(instance)
-
-    def __post_save(self, instance, **kwargs):
-        """
-        Pushes changes to an instance into the cache, and removes invalid (changed)
-        lookup values.
-        """
-        pk_name = instance._meta.pk.name
-        pk_names = ('pk', pk_name)
-        pk_val = instance.pk
-        for key in self.cache_fields:
-            if key in pk_names:
-                continue
-            # store pointers
-            cache.set(self.__get_lookup_cache_key(**{key: getattr(instance, key)}), pk_val, self.cache_ttl)  # 1 hour
-
-        # Ensure we don't serialize the database into the cache
-        db = instance._state.db
-        instance._state.db = None
-        # store actual object
-        try:
-            cache.set(self.__get_lookup_cache_key(**{pk_name: pk_val}), instance, self.cache_ttl)
-        except Exception as e:
-            logger.error(e, exc_info=True)
-        instance._state.db = db
-
-        # Kill off any keys which are no longer valid
-        if instance in self.__cache:
-            for key in self.cache_fields:
-                if key not in self.__cache[instance]:
-                    continue
-                value = self.__cache[instance][key]
-                if value != getattr(instance, key):
-                    cache.delete(self.__get_lookup_cache_key(**{key: value}))
-
-        self.__cache_state(instance)
-
-    def __post_delete(self, instance, **kwargs):
-        """
-        Drops instance from all cache storages.
-        """
-        pk_name = instance._meta.pk.name
-        for key in self.cache_fields:
-            if key in ('pk', pk_name):
-                continue
-            # remove pointers
-            cache.delete(self.__get_lookup_cache_key(**{key: getattr(instance, key)}))
-        # remove actual object
-        cache.delete(self.__get_lookup_cache_key(**{pk_name: instance.pk}))
-
-    def __get_lookup_cache_key(self, **kwargs):
-        return make_key(self.model, 'modelcache', kwargs)
-
-    def contribute_to_class(self, model, name):
-        super(BaseManager, self).contribute_to_class(model, name)
-        class_prepared.connect(self.__class_prepared, sender=model)
-
-    def get_from_cache(self, **kwargs):
-        """
-        Wrapper around QuerySet.get which supports caching of the
-        intermediate value.  Callee is responsible for making sure
-        the cache key is cleared on save.
-        """
-        if not self.cache_fields or len(kwargs) > 1:
-            return self.get(**kwargs)
-
-        key, value = kwargs.items()[0]
-        pk_name = self.model._meta.pk.name
-        if key == 'pk':
-            key = pk_name
-
-        # Kill __exact since it's the default behavior
-        if key.endswith('__exact'):
-            key = key.split('__exact', 1)[0]
-
-        if key in self.cache_fields or key == pk_name:
-            cache_key = self.__get_lookup_cache_key(**{key: value})
-
-            retval = cache.get(cache_key)
-            if retval is None:
-                result = self.get(**kwargs)
-                # Ensure we're pushing it into the cache
-                self.__post_save(instance=result)
-                return result
-
-            # If we didn't look up by pk we need to hit the reffed
-            # key
-            if key != pk_name:
-                return self.get_from_cache(**{pk_name: retval})
-
-            if type(retval) != self.model:
-                if settings.DEBUG:
-                    raise ValueError('Unexpected value type returned from cache')
-                logger.error('Cache response returned invalid value %r', retval)
-                return self.get(**kwargs)
-
-            retval._state.db = router.db_for_read(self.model, **kwargs)
-
-            return retval
-        else:
-            return self.get(**kwargs)
-
-    def create_or_update(self, **kwargs):
-        return create_or_update(self.model, **kwargs)
-
-
 class ScoreClause(object):
     def __init__(self, group):
         self.group = group
diff --git a/src/sentry/migrations/0047_migrate_project_slugs.py b/src/sentry/migrations/0047_migrate_project_slugs.py
index a40fd1d390..da98db288a 100644
--- a/src/sentry/migrations/0047_migrate_project_slugs.py
+++ b/src/sentry/migrations/0047_migrate_project_slugs.py
@@ -9,7 +9,7 @@ class Migration(DataMigration):
 
     def forwards(self, orm):
         from django.template.defaultfilters import slugify
-        from sentry.utils.models import update
+        from sentry.db.models import update
 
         for project in orm['sentry.Project'].objects.all():
             if project.slug:
diff --git a/src/sentry/migrations/0048_migrate_project_keys.py b/src/sentry/migrations/0048_migrate_project_keys.py
index 7abd7393c8..b105a982ed 100644
--- a/src/sentry/migrations/0048_migrate_project_keys.py
+++ b/src/sentry/migrations/0048_migrate_project_keys.py
@@ -7,7 +7,7 @@ from django.db import models
 class Migration(DataMigration):
 
     def forwards(self, orm):
-        from sentry.utils.models import update
+        from sentry.db.models import update
 
         for pm in orm['sentry.ProjectMember'].objects.all():
             orm['sentry.ProjectKey'].objects.get_or_create(
diff --git a/src/sentry/migrations/0083_migrate_dupe_groups.py b/src/sentry/migrations/0083_migrate_dupe_groups.py
index 85c5bf3e07..230dde284f 100644
--- a/src/sentry/migrations/0083_migrate_dupe_groups.py
+++ b/src/sentry/migrations/0083_migrate_dupe_groups.py
@@ -9,7 +9,7 @@ class Migration(DataMigration):
     def forwards(self, orm):
         from django.db.models import F
         from collections import defaultdict
-        from sentry.utils.models import create_or_update
+        from sentry.db.models import create_or_update
         from sentry.utils.query import RangeQuerySetWrapper
 
         # We don't fully merge results because it's simply not worth it
diff --git a/src/sentry/models.py b/src/sentry/models.py
index 93056d526a..9cb6ca626b 100644
--- a/src/sentry/models.py
+++ b/src/sentry/models.py
@@ -38,6 +38,9 @@ from sentry.constants import (
     STATUS_UNRESOLVED, STATUS_RESOLVED, STATUS_VISIBLE, STATUS_HIDDEN,
     MINUTE_NORMALIZATION, STATUS_MUTED, RESERVED_TEAM_SLUGS,
     LOG_LEVELS, MAX_CULPRIT_LENGTH, MAX_TAG_KEY_LENGTH, MAX_TAG_VALUE_LENGTH)
+from sentry.db.models import (
+    Model, GzippedDictField, BoundedIntegerField, BoundedPositiveIntegerField,
+    update, sane_repr)
 from sentry.manager import (
     GroupManager, ProjectManager,
     MetaManager, InstanceMetaManager, SearchDocumentManager, BaseManager,
@@ -46,9 +49,6 @@ from sentry.signals import buffer_incr_complete, regression_signal
 from sentry.utils.cache import memoize
 from sentry.utils.db import has_trending
 from sentry.utils.http import absolute_uri
-from sentry.utils.models import (
-    Model, GzippedDictField, BoundedIntegerField, BoundedPositiveIntegerField,
-    update)
 from sentry.utils.imports import import_string
 from sentry.utils.safe import safe_execute
 from sentry.utils.strings import truncatechars, strip
@@ -70,27 +70,29 @@ def slugify_instance(inst, label, reserved=(), **kwargs):
         inst.slug = base_slug + '-' + str(n)
 
 
-def sane_repr(*attrs):
-    if 'id' not in attrs and 'pk' not in attrs:
-        attrs = ('id',) + attrs
-
-    def _repr(self):
-        cls = type(self).__name__
-
-        pairs = (
-            '%s=%s' % (a, repr(getattr(self, a, None)))
-            for a in attrs)
-
-        return u'<%s at 0x%x: %s>' % (cls, id(self), ', '.join(pairs))
-
-    return _repr
-
-
 class User(Model, AbstractUser):
     class Meta:
         db_table = 'auth_user'
         app_label = 'auth'
 
+    def merge_to(from_user, to_user):
+        # TODO: we could discover relations automatically and make this useful
+        from sentry.models import (
+            GroupBookmark, Project, ProjectKey, Team, TeamMember, UserOption)
+
+        for obj in ProjectKey.objects.filter(user=from_user):
+            obj.update(user=to_user)
+        for obj in TeamMember.objects.filter(user=from_user):
+            obj.update(user=to_user)
+        for obj in Project.objects.filter(owner=from_user):
+            obj.update(owner=to_user)
+        for obj in Team.objects.filter(owner=from_user):
+            obj.update(owner=to_user)
+        for obj in GroupBookmark.objects.filter(user=from_user):
+            obj.update(user=to_user)
+        for obj in UserOption.objects.filter(user=from_user):
+            obj.update(user=to_user)
+
 
 User.add_to_class('objects', UserManager(cache_fields=['pk']))
 
diff --git a/src/sentry/utils/db.py b/src/sentry/utils/db.py
index bf253fe9a9..3bca55e240 100644
--- a/src/sentry/utils/db.py
+++ b/src/sentry/utils/db.py
@@ -7,35 +7,12 @@ sentry.utils.db
 """
 
 import django
-import operator
 
 from django.conf import settings
 from django.db import connections, DEFAULT_DB_ALIAS
-from django.db.models.expressions import ExpressionNode, F
 from django.db.models.fields.related import SingleRelatedObjectDescriptor
 
 
-EXPRESSION_NODE_CALLBACKS = {
-    ExpressionNode.ADD: operator.add,
-    ExpressionNode.SUB: operator.sub,
-    ExpressionNode.MUL: operator.mul,
-    ExpressionNode.DIV: operator.div,
-    ExpressionNode.MOD: operator.mod,
-}
-try:
-    EXPRESSION_NODE_CALLBACKS[ExpressionNode.AND] = operator.and_
-except AttributeError:
-    EXPRESSION_NODE_CALLBACKS[ExpressionNode.BITAND] = operator.and_
-try:
-    EXPRESSION_NODE_CALLBACKS[ExpressionNode.OR] = operator.or_
-except AttributeError:
-    EXPRESSION_NODE_CALLBACKS[ExpressionNode.BITOR] = operator.or_
-
-
-class CannotResolve(Exception):
-    pass
-
-
 def get_db_engine(alias='default'):
     has_multidb = django.VERSION >= (1, 2)
     if has_multidb:
@@ -59,23 +36,6 @@ def has_charts(db):
     return True
 
 
-def resolve_expression_node(instance, node):
-    def _resolve(instance, node):
-        if isinstance(node, F):
-            return getattr(instance, node.name)
-        elif isinstance(node, ExpressionNode):
-            return resolve_expression_node(instance, node)
-        return node
-
-    op = EXPRESSION_NODE_CALLBACKS.get(node.connector, None)
-    if not op:
-        raise CannotResolve
-    runner = _resolve(instance, node.children[0])
-    for n in node.children[1:]:
-        runner = op(runner, _resolve(instance, n))
-    return runner
-
-
 def attach_foreignkey(objects, field, related=[], database=None):
     """
     Shortcut method which handles a pythonic LEFT OUTER JOIN.
diff --git a/src/sentry/web/frontend/groups.py b/src/sentry/web/frontend/groups.py
index 3a77d64c3f..3ea8a2afc0 100644
--- a/src/sentry/web/frontend/groups.py
+++ b/src/sentry/web/frontend/groups.py
@@ -29,6 +29,7 @@ from sentry.constants import (
     ORACLE_SORT_CLAUSES, ORACLE_SCORE_CLAUSES,
     MSSQL_SORT_CLAUSES, MSSQL_SCORE_CLAUSES, DEFAULT_SORT_OPTION,
     SEARCH_DEFAULT_SORT_OPTION, MAX_JSON_RESULTS)
+from sentry.db.models import create_or_update
 from sentry.filters import get_filters
 from sentry.models import (
     Project, Group, Event, SearchDocument, Activity, EventMapping, TagKey,
@@ -38,7 +39,6 @@ from sentry.plugins import plugins
 from sentry.utils import json
 from sentry.utils.dates import parse_date
 from sentry.utils.db import has_trending, get_db_engine
-from sentry.utils.models import create_or_update
 from sentry.web.decorators import has_access, has_group_access, login_required
 from sentry.web.helpers import render_to_response, group_is_public
 
diff --git a/tests/sentry/utils/models/tests.py b/tests/sentry/utils/models/tests.py
index f066b8129d..5abe1e2e70 100644
--- a/tests/sentry/utils/models/tests.py
+++ b/tests/sentry/utils/models/tests.py
@@ -1,7 +1,7 @@
 from __future__ import absolute_import
 
 from django.db import models
-from sentry.utils.models import (
+from sentry.db.models import (
     Model, BoundedIntegerField, BoundedBigIntegerField,
     BoundedPositiveIntegerField)
 from sentry.testutils import TestCase

commit 99afeb0d261e5ada0c65f65691434dade2e0dfd5
Author: Jan Michael Auer <account@jauer.org>
Date:   Fri Jul 27 18:19:54 2018 +0200

    feat(minidump): Support gzipped crashpad requests (#9208)
    
    * fix(minidump): Persist minidump after unpacking breakpad request
    
    * feat(proxy): Add a middleware to decompress gzip requests
    
    * fix(proxy): Remove the Content-Encoding header after decompressing
    
    * ref(proxy): Decompress lazily

diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index bc981fd231..5b1042d9d8 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -211,6 +211,7 @@ TEMPLATE_LOADERS = (
 
 MIDDLEWARE_CLASSES = (
     'sentry.middleware.proxy.ChunkedMiddleware',
+    'sentry.middleware.proxy.DecompressBodyMiddleware',
     'sentry.middleware.proxy.ContentLengthHeaderMiddleware',
     'sentry.middleware.security.SecurityHeadersMiddleware',
     'sentry.middleware.maintenance.ServicesUnavailableMiddleware',
diff --git a/src/sentry/middleware/proxy.py b/src/sentry/middleware/proxy.py
index cb01b6c810..7bb63c961f 100644
--- a/src/sentry/middleware/proxy.py
+++ b/src/sentry/middleware/proxy.py
@@ -1,7 +1,10 @@
 from __future__ import absolute_import
 
 import io
+import logging
 import six
+import zlib
+
 try:
     import uwsgi
     has_uwsgi = True
@@ -10,6 +13,9 @@ except ImportError:
 
 from django.conf import settings
 
+logger = logging.getLogger(__name__)
+Z_CHUNK = 1024 * 8
+
 
 if has_uwsgi:
     class UWsgiChunkedInput(io.RawIOBase):
@@ -31,6 +37,74 @@ if has_uwsgi:
             return n
 
 
+class ZDecoder(io.RawIOBase):
+    """
+    Base class for HTTP content decoders based on zlib
+    See: https://github.com/eBay/wextracto/blob/9c789b1c98d95a1e87dbedfd1541a8688d128f5c/wex/http_decoder.py
+    """
+
+    def __init__(self, fp, z=None):
+        self.fp = fp
+        self.z = z
+        self.flushed = None
+
+    def readable(self):
+        return True
+
+    def readinto(self, buf):
+        if self.z is None:
+            self.z = zlib.decompressobj()
+            retry = True
+        else:
+            retry = False
+
+        n = 0
+        max_length = len(buf)
+
+        while max_length > 0:
+            if self.flushed is None:
+                chunk = self.fp.read(Z_CHUNK)
+                compressed = (self.z.unconsumed_tail + chunk)
+                try:
+                    decompressed = self.z.decompress(compressed, max_length)
+                except zlib.error:
+                    if not retry:
+                        raise
+                    self.z = zlib.decompressobj(-zlib.MAX_WBITS)
+                    retry = False
+                    decompressed = self.z.decompress(compressed, max_length)
+
+                if not chunk:
+                    self.flushed = self.z.flush()
+            else:
+                if not self.flushed:
+                    return n
+
+                decompressed = self.flushed[:max_length]
+                self.flushed = self.flushed[max_length:]
+
+            buf[n:n + len(decompressed)] = decompressed
+            n += len(decompressed)
+            max_length = len(buf) - n
+
+        return n
+
+
+class DeflateDecoder(ZDecoder):
+    """
+    Decoding for "content-encoding: deflate"
+    """
+
+
+class GzipDecoder(ZDecoder):
+    """
+    Decoding for "content-encoding: gzip"
+    """
+
+    def __init__(self, fp):
+        ZDecoder.__init__(self, fp, zlib.decompressobj(16 + zlib.MAX_WBITS))
+
+
 class SetRemoteAddrFromForwardedFor(object):
     def __init__(self):
         if not getattr(settings, 'SENTRY_USE_X_FORWARDED_FOR', True):
@@ -72,6 +146,24 @@ class ChunkedMiddleware(object):
             request.META['CONTENT_LENGTH'] = '4294967295'  # 0xffffffff
 
 
+class DecompressBodyMiddleware(object):
+    def process_request(self, request):
+        decode = False
+        encoding = request.META.get('HTTP_CONTENT_ENCODING', '').lower()
+
+        if encoding == 'gzip':
+            request._stream = GzipDecoder(request._stream)
+            decode = True
+
+        if encoding == 'deflate':
+            request._stream = DeflateDecoder(request._stream)
+            decode = True
+
+        if decode:
+            request.META['CONTENT_LENGTH'] = '4294967295'  # 0xffffffff
+            del request.META['HTTP_CONTENT_ENCODING']
+
+
 class ContentLengthHeaderMiddleware(object):
     """
     Ensure that we have a proper Content-Length/Transfer-Encoding header
diff --git a/src/sentry/web/api.py b/src/sentry/web/api.py
index 202154731a..398453aa04 100644
--- a/src/sentry/web/api.py
+++ b/src/sentry/web/api.py
@@ -584,14 +584,6 @@ class MinidumpView(StoreView):
         except KeyError:
             raise APIError('Missing minidump upload')
 
-        if settings.SENTRY_MINIDUMP_CACHE:
-            if not os.path.exists(settings.SENTRY_MINIDUMP_PATH):
-                os.mkdir(settings.SENTRY_MINIDUMP_PATH, 0o744)
-
-            with open('%s/%s.dmp' % (settings.SENTRY_MINIDUMP_PATH, event_id), 'wb') as out:
-                for chunk in minidump.chunks():
-                    out.write(chunk)
-
         # Breakpad on linux sometimes stores the entire HTTP request body as
         # dump file instead of just the minidump. The Electron SDK then for
         # example uploads a multipart formdata body inside the minidump file.
@@ -624,6 +616,14 @@ class MinidumpView(StoreView):
             except KeyError:
                 raise APIError('Missing minidump upload')
 
+        if settings.SENTRY_MINIDUMP_CACHE:
+            if not os.path.exists(settings.SENTRY_MINIDUMP_PATH):
+                os.mkdir(settings.SENTRY_MINIDUMP_PATH, 0o744)
+
+            with open('%s/%s.dmp' % (settings.SENTRY_MINIDUMP_PATH, event_id), 'wb') as out:
+                for chunk in minidump.chunks():
+                    out.write(chunk)
+
         try:
             merge_minidump_event(data, minidump)
         except ProcessMinidumpError as e:

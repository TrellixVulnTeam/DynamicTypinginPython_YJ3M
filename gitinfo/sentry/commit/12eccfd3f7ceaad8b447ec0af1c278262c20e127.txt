commit 12eccfd3f7ceaad8b447ec0af1c278262c20e127
Author: Ryan Skonnord <ryan.skonnord@sentry.io>
Date:   Tue May 12 13:40:46 2020 -0700

    feat(features): Replace plugin-based FeatureHandlers (#18750)
    
    Previously, FeatureManager was able to receive feature handlers from
    plugins, which was used as a way to inject arbitrary handlers but not to
    associate them significantly with plugins. It entailed extra performance
    overhead in retrieving all other plugins, or an extra layer of
    abstraction to avoid doing so. For those reasons, replace it with a
    single, global registry of FeatureHandler objects.
    
    In ProjectSerializer, roll back use of the FeatureChecker abstraction
    because we now expect direct calls to `features.has` to be equally
    performant. Also some incidental cleanup in ProjectSerializer.

diff --git a/src/sentry/api/serializers/models/project.py b/src/sentry/api/serializers/models/project.py
index 9e930cc4ea..c6adcd323c 100644
--- a/src/sentry/api/serializers/models/project.py
+++ b/src/sentry/api/serializers/models/project.py
@@ -51,6 +51,8 @@ STATS_PERIOD_CHOICES = {
     "24h": StatsPeriod(24, timedelta(hours=1)),
 }
 
+_PROJECT_SCOPE_PREFIX = "projects:"
+
 
 @register(Project)
 class ProjectSerializer(Serializer):
@@ -156,38 +158,37 @@ class ProjectSerializer(Serializer):
             result = self.get_access_by_project(item_list, user)
 
         with measure_span("features"):
-            project_features = features.all(feature_type=ProjectFeature).keys()
-            feature_checker = features.build_checker()
-            for item in item_list:
-                result[item]["features"] = self.get_feature_list(
-                    item, user, project_features, feature_checker
-                )
+            project_features = [
+                feature_name
+                for feature_name in features.all(feature_type=ProjectFeature).keys()
+                if feature_name.startswith(_PROJECT_SCOPE_PREFIX)
+            ]
+            for project, serialized in result.items():
+                serialized["features"] = self._get_feature_list(project, user, project_features)
 
         with measure_span("other"):
-            for item in item_list:
-                result[item].update(
+            for project, serialized in result.items():
+                serialized.update(
                     {
-                        "is_bookmarked": item.id in bookmarks,
+                        "is_bookmarked": project.id in bookmarks,
                         "is_subscribed": bool(
-                            user_options.get((item.id, "mail:alert"), default_subscribe)
+                            user_options.get((project.id, "mail:alert"), default_subscribe)
                         ),
-                        "avatar": avatars.get(item.id),
-                        "platforms": platforms_by_project[item.id],
+                        "avatar": avatars.get(project.id),
+                        "platforms": platforms_by_project[project.id],
                     }
                 )
                 if stats:
-                    result[item]["stats"] = stats[item.id]
+                    serialized["stats"] = stats[project.id]
         return result
 
-    def get_feature_list(self, obj, user, project_features, feature_checker):
-        feature_list = set()
-
-        for feature_name in project_features:
-            if not feature_name.startswith("projects:"):
-                continue
-            if feature_checker.has(feature_name, obj, actor=user):
-                # Remove the project scope prefix
-                feature_list.add(feature_name[len("projects:") :])
+    @staticmethod
+    def _get_feature_list(obj, user, project_features):
+        feature_list = set(
+            feature_name[len(_PROJECT_SCOPE_PREFIX) :]  # Remove the project scope prefix
+            for feature_name in project_features
+            if features.has(feature_name, obj, actor=user)
+        )
 
         if obj.flags.has_releases:
             feature_list.add("releases")
diff --git a/src/sentry/features/__init__.py b/src/sentry/features/__init__.py
index 906b3a3917..e637ddf795 100644
--- a/src/sentry/features/__init__.py
+++ b/src/sentry/features/__init__.py
@@ -131,4 +131,4 @@ add = default_manager.add
 get = default_manager.get
 has = default_manager.has
 all = default_manager.all
-build_checker = default_manager.build_checker
+add_handler = default_manager.add_handler
diff --git a/src/sentry/features/manager.py b/src/sentry/features/manager.py
index cb77e37c3d..a40606e005 100644
--- a/src/sentry/features/manager.py
+++ b/src/sentry/features/manager.py
@@ -2,26 +2,24 @@ from __future__ import absolute_import
 
 __all__ = ["FeatureManager"]
 
-import itertools
-
+from collections import defaultdict
 from django.conf import settings
 
-from sentry.utils.safe import safe_execute
-
 from .base import Feature
 from .exceptions import FeatureNotRegistered
 
 
 class FeatureManager(object):
     def __init__(self):
-        self._registry = {}
+        self._feature_registry = {}
+        self._handler_registry = defaultdict(list)
 
     def all(self, feature_type=Feature):
         """
         Get a mapping of feature name -> feature class, optionally specific to a
         particular feature type.
         """
-        return {k: v for k, v in self._registry.items() if v == feature_type}
+        return {k: v for k, v in self._feature_registry.items() if v == feature_type}
 
     def add(self, name, cls=Feature):
         """
@@ -32,7 +30,7 @@ class FeatureManager(object):
 
         >>> FeatureManager.has('my:feature', actor=request.user)
         """
-        self._registry[name] = cls
+        self._feature_registry[name] = cls
 
     def get(self, name, *args, **kwargs):
         """
@@ -41,24 +39,34 @@ class FeatureManager(object):
         >>> FeatureManager.get('my:feature', actor=request.user)
         """
         try:
-            cls = self._registry[name]
+            cls = self._feature_registry[name]
         except KeyError:
             raise FeatureNotRegistered(name)
         return cls(name, *args, **kwargs)
 
+    def add_handler(self, handler):
+        """
+        Register a feature handler.
+
+        The passed object is a FeatureHandler that is associated with all
+        features defined in the ``handler.features`` property.
+        """
+        for feature_name in handler.features:
+            self._handler_registry[feature_name].append(handler)
+
     def has(self, name, *args, **kwargs):
         """
         Determine if a feature is enabled.
 
         Features are checked in the following order:
 
-        1. Execute Plugin feature handlers. Any plugin which returns a list of
-           instantiated ``feature.handler.FeatureHandler`` objects will have
-           each of their handlers executed in the order they are declared.
+        1. Execute registered feature handlers. Any
+           ``feature.handler.FeatureHandler`` objects that have been registered
+           with ``add_handler` will be executed in the order they are declared.
 
-           When each handler is executed should the handler return None instead
-           of True or False (feature enabled / disabled), the next registered
-           plugin feature handler will be executed.
+           When each handler is executed, should the handler return None
+           instead of True or False (feature enabled / disabled), the
+           next registered feature handler will be executed.
 
         2. The default configuration of the feature. This can be located in
            sentry.conf.server.SENTRY_FEATURES.
@@ -67,41 +75,13 @@ class FeatureManager(object):
         provided to assign organization or project context to the feature.
 
         >>> FeatureManager.has('organizations:feature', organization, actor=request.user)
-        """
-        return self.build_checker().has(name, *args, **kwargs)
 
-    def build_checker(self):
         """
-        Set up for a delayed execution of ``has``.
-
-        Successive calls to the returned checker have better performance than
-        repeatedly calling ``FeatureManager.has``, because it retains the set
-        of ``feature.handler.FeatureHandler`` objects. An instance of the
-        checker should be kept only in a short-lived context, because any
-        dynamic changes to plugins' feature handlers are not reflected in its
-        behavior.
-        """
-        return FeatureChecker(self)
-
-
-class FeatureChecker(object):
-    def __init__(self, manager):
-        from sentry.plugins.base import plugins
-
-        self.manager = manager
-
-        handlers_per_plugin = [
-            safe_execute(plugin.get_feature_hooks, _with_transaction=False) or ()
-            for plugin in plugins.all(version=2)
-        ]
-        self.handlers = tuple(itertools.chain(*handlers_per_plugin))
-
-    def has(self, name, *args, **kwargs):
         actor = kwargs.pop("actor", None)
-        feature = self.manager.get(name, *args, **kwargs)
+        feature = self.get(name, *args, **kwargs)
 
-        # Check plugin feature handlers
-        rv = self._get_plugin_value(feature, actor)
+        # Check registered feature handlers
+        rv = self._get_handler(feature, actor)
         if rv is not None:
             return rv
 
@@ -112,8 +92,8 @@ class FeatureChecker(object):
         # Features are by default disabled if no plugin or default enables them
         return False
 
-    def _get_plugin_value(self, feature, actor):
-        for handler in self.handlers:
+    def _get_handler(self, feature, actor):
+        for handler in self._handler_registry[feature.name]:
             rv = handler(feature, actor)
             if rv is not None:
                 return rv

commit 1da40418f018a26d7aa4498faa97c2818f9d3815
Author: Armin Ronacher <armin.ronacher@active-4.com>
Date:   Sun Jun 12 20:26:55 2016 +0200

    Initial support for password expiration handling

diff --git a/src/sentry/middleware/auth.py b/src/sentry/middleware/auth.py
index 971ca258ad..8f85b74670 100644
--- a/src/sentry/middleware/auth.py
+++ b/src/sentry/middleware/auth.py
@@ -3,6 +3,7 @@ from __future__ import absolute_import
 from django.contrib.auth import middleware
 
 from sentry.utils.linksign import process_signature
+from sentry.utils import auth
 
 
 class AuthenticationMiddleware(middleware.AuthenticationMiddleware):
@@ -17,3 +18,8 @@ class AuthenticationMiddleware(middleware.AuthenticationMiddleware):
         if user is not None:
             request.user = user
             request.user_from_signed_request = True
+
+    def process_exception(self, request, exception):
+        if isinstance(exception, auth.AuthUserPasswordExpired):
+            from sentry.web.frontend.accounts import expired
+            return expired(request, exception.user)
diff --git a/src/sentry/models/user.py b/src/sentry/models/user.py
index c9895d76f6..1d977f435f 100644
--- a/src/sentry/models/user.py
+++ b/src/sentry/models/user.py
@@ -46,6 +46,13 @@ class User(BaseModel, AbstractBaseUser):
         help_text=_('Designates whether this user should be treated as '
                     'managed. Select this to disallow the user from '
                     'modifying their account (username, password, etc).'))
+    is_password_expired = models.BooleanField(
+        _('password expired'), default=False,
+        help_text=_('If set to true then the user needs to change the '
+                    'password on next sign in.'))
+    last_password_change = models.DateTimeField(
+        _('date of last password change'), null=True,
+        help_text=_('The date the password was changed last.'))
 
     date_joined = models.DateTimeField(_('date joined'), default=timezone.now)
 
@@ -170,3 +177,7 @@ class User(BaseModel, AbstractBaseUser):
         AuthIdentity.objects.filter(
             user=from_user,
         ).update(user=to_user)
+
+    def set_password(self, raw_password):
+        super(User, self).set_password(raw_password)
+        self.last_password_change = timezone.now()
diff --git a/src/sentry/templates/sentry/account/recover/sent.html b/src/sentry/templates/sentry/account/recover/sent.html
index a0de9428d0..9360941cfe 100644
--- a/src/sentry/templates/sentry/account/recover/sent.html
+++ b/src/sentry/templates/sentry/account/recover/sent.html
@@ -8,5 +8,9 @@
 {% block auth_main %}
 	<h2>{% trans "Recover Account" %}</h2>
 
+  {% if expired %}
+  <p>{% blocktrans %}The password on your account expired.  We sent you a link to reset your password to the address registered with this account containing further instructions.{% endblocktrans %}</p>
+  {% endif %}
+
 	<p>{% blocktrans %}We have sent an email to the address registered with this account containing further instructions to reset your password.{% endblocktrans %}</p>
 {% endblock %}
diff --git a/src/sentry/utils/auth.py b/src/sentry/utils/auth.py
index c50950603f..22caecc1f5 100644
--- a/src/sentry/utils/auth.py
+++ b/src/sentry/utils/auth.py
@@ -20,6 +20,12 @@ from sentry.models import User, Authenticator
 logger = logging.getLogger('sentry.auth')
 
 
+class AuthUserPasswordExpired(Exception):
+
+    def __init__(self, user):
+        self.user = user
+
+
 def _make_key_value(val):
     return val.strip().split('=', 1)
 
@@ -115,6 +121,9 @@ def login(request, user, passed_2fa=False, after_2fa=None):
     Optionally `after_2fa` can be set to a URL which will be used to override
     the regular session redirect target directly after the 2fa flow.
     """
+    if user.is_password_expired:
+        raise AuthUserPasswordExpired(user)
+
     has_2fa = Authenticator.objects.user_has_2fa(user)
     if has_2fa and not passed_2fa:
         request.session['_pending_2fa'] = [user.id, time.time()]
diff --git a/src/sentry/web/frontend/accounts.py b/src/sentry/web/frontend/accounts.py
index 9520d97d51..8859f8f3ba 100644
--- a/src/sentry/web/frontend/accounts.py
+++ b/src/sentry/web/frontend/accounts.py
@@ -33,30 +33,42 @@ from sentry.utils.auth import get_auth_providers, get_login_redirect
 from sentry.utils.safe import safe_execute
 
 
+def send_password_recovery_mail(user):
+    password_hash, created = LostPasswordHash.objects.get_or_create(
+        user=user
+    )
+    if not password_hash.is_valid():
+        password_hash.date_added = timezone.now()
+        password_hash.set_hash()
+        password_hash.save()
+    password_hash.send_recover_mail()
+    return password_hash
+
+
 @login_required
 def login_redirect(request):
     login_url = get_login_redirect(request)
     return HttpResponseRedirect(login_url)
 
 
+def expired(request, user):
+    password_hash = send_password_recovery_mail(user)
+    return render_to_response('sentry/account/recover/sent.html', {
+        'email': password_hash.user.email,
+        'expired': True,
+    }, request)
+
+
 def recover(request):
     form = RecoverPasswordForm(request.POST or None,
                                captcha=bool(request.session.get('needs_captcha')))
     if form.is_valid():
-        password_hash, created = LostPasswordHash.objects.get_or_create(
-            user=form.cleaned_data['user']
-        )
-        if not password_hash.is_valid():
-            password_hash.date_added = timezone.now()
-            password_hash.set_hash()
-            password_hash.save()
-
-        password_hash.send_recover_mail()
-
+        password_hash = send_password_recovery_mail(form.cleaned_data['user'])
         request.session.pop('needs_captcha', None)
 
         return render_to_response('sentry/account/recover/sent.html', {
             'email': password_hash.user.email,
+            'expired': False,
         }, request)
 
     elif request.POST and not request.session.get('needs_captcha'):

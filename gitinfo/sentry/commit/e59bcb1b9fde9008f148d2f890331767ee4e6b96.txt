commit e59bcb1b9fde9008f148d2f890331767ee4e6b96
Author: Dan Fuller <dfuller@sentry.io>
Date:   Tue Jul 30 16:28:07 2019 -0700

    feat(api): Build api to update an individual alert rule (SEN-824)
    
    Implements an api to update a single alert rule

diff --git a/src/sentry/incidents/endpoints/project_alert_rule_details.py b/src/sentry/incidents/endpoints/project_alert_rule_details.py
index a0b5f431af..f44ba8515f 100644
--- a/src/sentry/incidents/endpoints/project_alert_rule_details.py
+++ b/src/sentry/incidents/endpoints/project_alert_rule_details.py
@@ -1,10 +1,12 @@
 from __future__ import absolute_import
 
+from rest_framework import status
 from rest_framework.response import Response
 
 from sentry.api.serializers import serialize
 from sentry.api.serializers.models.alert_rule import AlertRuleSerializer
 from sentry.incidents.endpoints.bases import ProjectAlertRuleEndpoint
+from sentry.incidents.endpoints.serializers import AlertRuleSerializer as DrfAlertRuleSerializer
 
 
 class ProjectAlertRuleDetailsEndpoint(ProjectAlertRuleEndpoint):
@@ -16,3 +18,17 @@ class ProjectAlertRuleDetailsEndpoint(ProjectAlertRuleEndpoint):
         """
         data = serialize(alert_rule, request.user, AlertRuleSerializer())
         return Response(data)
+
+    def put(self, request, project, alert_rule):
+        serializer = DrfAlertRuleSerializer(
+            context={'project': project},
+            instance=alert_rule,
+            data=request.data,
+            partial=True,
+        )
+
+        if serializer.is_valid():
+            alert_rule = serializer.save()
+            return Response(serialize(alert_rule, request.user), status=status.HTTP_200_OK)
+
+        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
diff --git a/src/sentry/incidents/endpoints/serializers.py b/src/sentry/incidents/endpoints/serializers.py
index 04488eadc6..a51fc6d702 100644
--- a/src/sentry/incidents/endpoints/serializers.py
+++ b/src/sentry/incidents/endpoints/serializers.py
@@ -2,6 +2,8 @@ from __future__ import absolute_import
 
 from datetime import timedelta
 
+import six
+from enum import Enum
 from rest_framework import serializers
 
 from sentry.api.serializers.rest_framework.base import CamelSnakeModelSerializer
@@ -13,6 +15,7 @@ from sentry.incidents.models import (
 from sentry.incidents.logic import (
     AlertRuleNameAlreadyUsedError,
     create_alert_rule,
+    update_alert_rule,
 )
 
 
@@ -62,3 +65,18 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
             return create_alert_rule(project=self.context['project'], **validated_data)
         except AlertRuleNameAlreadyUsedError:
             raise serializers.ValidationError('This name is already in use for this project')
+
+    def _remove_unchanged_fields(self, instance, validated_data):
+        for field_name, value in list(six.iteritems(validated_data)):
+            # Remove any fields that haven't actually changed
+            if isinstance(value, Enum):
+                value = value.value
+            elif field_name == 'aggregations':
+                value = [item.value for item in value]
+            if getattr(instance, field_name) == value:
+                validated_data.pop(field_name)
+        return validated_data
+
+    def update(self, instance, validated_data):
+        validated_data = self._remove_unchanged_fields(instance, validated_data)
+        return update_alert_rule(instance, **validated_data)
diff --git a/src/sentry/incidents/logic.py b/src/sentry/incidents/logic.py
index 9a2ed3ad49..28e8929371 100644
--- a/src/sentry/incidents/logic.py
+++ b/src/sentry/incidents/logic.py
@@ -540,6 +540,91 @@ def create_alert_rule(
     return alert_rule
 
 
+def update_alert_rule(
+    alert_rule,
+    name=None,
+    threshold_type=None,
+    query=None,
+    aggregations=None,
+    time_window=None,
+    alert_threshold=None,
+    resolve_threshold=None,
+    threshold_period=None,
+):
+    """
+    Updates an alert rule.
+
+    :param alert_rule: The alert rule to update
+    :param name: Name for the alert rule. This will be used as part of the
+    incident name, and must be unique per project.
+    :param threshold_type: An AlertRuleThresholdType
+    :param query: An event search query to subscribe to and monitor for alerts
+    :param aggregations: A list of AlertRuleAggregations that we want to fetch
+    for this alert rule
+    :param time_window: Time period to aggregate over, in minutes.
+    :param alert_threshold: Value that the subscription needs to reach to
+    trigger the alert
+    :param resolve_threshold: Value that the subscription needs to reach to
+    resolve the alert
+    :param threshold_period: How many update periods the value of the
+    subscription needs to exceed the threshold before triggering
+    :return: The updated `AlertRule`
+    """
+    if name and alert_rule.name != name and AlertRule.objects.filter(
+        project=alert_rule.project,
+        name=name,
+    ).exists():
+        raise AlertRuleNameAlreadyUsedError()
+
+    old_subscription_id = None
+    subscription_id = None
+    updated_fields = {}
+    if name:
+        updated_fields['name'] = name
+    if threshold_type:
+        updated_fields['threshold_type'] = threshold_type.value
+    if query is not None:
+        validate_alert_rule_query(query)
+        updated_fields['query'] = query
+    if aggregations:
+        updated_fields['aggregations'] = [a.value for a in aggregations]
+    if time_window:
+        updated_fields['time_window'] = time_window
+    if alert_threshold:
+        updated_fields['alert_threshold'] = alert_threshold
+    if resolve_threshold:
+        updated_fields['resolve_threshold'] = resolve_threshold
+    if threshold_period:
+        updated_fields['threshold_period'] = threshold_period
+
+    if query or aggregations or time_window:
+        old_subscription_id = alert_rule.subscription_id
+        # If updating any details of the query, create a new subscription
+        subscription_id = create_snuba_subscription(
+            alert_rule.dataset,
+            query,
+            aggregations,
+            time_window,
+            DEFAULT_ALERT_RULE_RESOLUTION,
+        )
+        updated_fields['subscription_id'] = subscription_id
+
+    try:
+        alert_rule.update(**updated_fields)
+    except Exception:
+        # If we error for some reason and have a valid subscription_id then
+        # attempt to delete from snuba to avoid orphaned subscriptions.
+        if subscription_id:
+            delete_snuba_subscription(subscription_id)
+        raise
+    finally:
+        if old_subscription_id:
+            # Once we're set up correctly, remove the previous subscription id.
+            delete_snuba_subscription(old_subscription_id)
+
+    return alert_rule
+
+
 def validate_alert_rule_query(query):
     # TODO: We should add more validation here to reject queries that include
     # fields that are invalid in alert rules. For now this will just make sure
diff --git a/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py b/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
index ee71f686a2..268f927431 100644
--- a/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
+++ b/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
@@ -5,13 +5,14 @@ from exam import fixture
 from sentry.api.serializers import serialize
 from sentry.incidents.logic import create_alert_rule
 from sentry.incidents.models import (
+    AlertRule,
     AlertRuleAggregations,
     AlertRuleThresholdType,
 )
 from sentry.testutils import APITestCase
 
 
-class AlertRuleDetailsEndpointTest(APITestCase):
+class AlertRuleDetailsGetEndpointTest(APITestCase):
     endpoint = 'sentry-api-0-project-alert-rule-details'
 
     @fixture
@@ -85,3 +86,125 @@ class AlertRuleDetailsEndpointTest(APITestCase):
             self.alert_rule.id,
         )
         assert resp.status_code == 404
+
+
+class AlertRuleDetailsPutEndpointTest(APITestCase):
+    method = 'put'
+    endpoint = 'sentry-api-0-project-alert-rule-details'
+
+    @fixture
+    def organization(self):
+        return self.create_organization()
+
+    @fixture
+    def project(self):
+        return self.create_project(organization=self.organization)
+
+    @fixture
+    def user(self):
+        return self.create_user()
+
+    @fixture
+    def alert_rule(self):
+        return create_alert_rule(
+            self.project,
+            'hello',
+            AlertRuleThresholdType.ABOVE,
+            'level:error',
+            [AlertRuleAggregations.TOTAL],
+            10,
+            1000,
+            400,
+            1,
+        )
+
+    def test_invalid_rule_id(self):
+        self.create_member(
+            user=self.user,
+            organization=self.organization,
+            role='owner',
+            teams=[self.team],
+        )
+        self.login_as(self.user)
+        with self.feature('organizations:incidents'):
+            resp = self.get_response(
+                self.organization.slug,
+                self.project.slug,
+                1234,
+            )
+
+        assert resp.status_code == 404
+
+    def test_simple(self):
+        self.create_member(
+            user=self.user,
+            organization=self.organization,
+            role='owner',
+            teams=[self.team],
+        )
+
+        self.login_as(self.user)
+        with self.feature('organizations:incidents'):
+            resp = self.get_valid_response(
+                self.organization.slug,
+                self.project.slug,
+                self.alert_rule.id,
+                name='what',
+            )
+
+        self.alert_rule.name = 'what'
+        assert resp.data == serialize(self.alert_rule)
+        assert resp.data['name'] == 'what'
+
+    def test_not_updated_fields(self):
+        self.create_member(
+            user=self.user,
+            organization=self.organization,
+            role='owner',
+            teams=[self.team],
+        )
+
+        self.login_as(self.user)
+        with self.feature('organizations:incidents'):
+            resp = self.get_valid_response(
+                self.organization.slug,
+                self.project.slug,
+                self.alert_rule.id,
+                aggregations=self.alert_rule.aggregations,
+            )
+
+        # Alert rule should be exactly the same
+        assert resp.data == serialize(self.alert_rule)
+        # If the aggregation changed we'd have a new subscription, validate that
+        # it hasn't changed explicitly
+        updated_alert_rule = AlertRule.objects.get(id=self.alert_rule.id)
+        assert updated_alert_rule.subscription_id == self.alert_rule.subscription_id
+
+    def test_permissions(self):
+        self.create_team(organization=self.organization, members=[self.user])
+        self.login_as(self.create_user())
+        with self.feature('organizations:incidents'):
+            resp = self.get_response(
+                self.organization.slug,
+                self.project.slug,
+                self.alert_rule.id,
+                name='what',
+            )
+
+        assert resp.status_code == 403
+
+    def test_no_feature(self):
+        self.create_member(
+            user=self.user,
+            organization=self.organization,
+            role='owner',
+            teams=[self.team],
+        )
+        self.login_as(self.user)
+        resp = self.get_response(
+            self.organization.slug,
+            self.project.slug,
+            self.alert_rule.id,
+            name='what',
+        )
+        assert resp.status_code == 404
diff --git a/tests/sentry/incidents/endpoints/test_serializers.py b/tests/sentry/incidents/endpoints/test_serializers.py
index 5a8cdc14d2..f100d49144 100644
--- a/tests/sentry/incidents/endpoints/test_serializers.py
+++ b/tests/sentry/incidents/endpoints/test_serializers.py
@@ -4,6 +4,7 @@ from exam import fixture
 
 from sentry.incidents.endpoints.serializers import AlertRuleSerializer
 from sentry.incidents.models import (
+    AlertRule,
     AlertRuleAggregations,
     AlertRuleThresholdType,
 )
@@ -21,6 +22,7 @@ class TestAlertRuleSerializer(TestCase):
             'resolve_threshold': 1,
             'alert_threshold': 0,
             'aggregations': [0],
+            'threshold_period': 1,
         }
 
     def run_fail_validation_test(self, params, errors):
@@ -83,3 +85,33 @@ class TestAlertRuleSerializer(TestCase):
             {'aggregations': [50]},
             {'aggregations': invalid_values},
         )
+
+    def _run_changed_fields_test(self, alert_rule, params, expected):
+        serializer = AlertRuleSerializer(
+            context={'project': self.project},
+            instance=alert_rule,
+            data=params,
+            partial=True,
+        )
+        serializer.is_valid()
+        assert serializer._remove_unchanged_fields(
+            alert_rule,
+            serializer.validated_data,
+        ) == expected
+
+    def test_remove_unchanged_fields(self):
+        alert_rule = AlertRule(**self.valid_params)
+        self._run_changed_fields_test(alert_rule, self.valid_params, {})
+        self._run_changed_fields_test(alert_rule, {'name': 'a name'}, {'name': 'a name'})
+        self._run_changed_fields_test(alert_rule, {'aggregations': [0]}, {})
+        self._run_changed_fields_test(
+            alert_rule,
+            {'aggregations': [1]},
+            {'aggregations': [AlertRuleAggregations.UNIQUE_USERS]},
+        )
+        self._run_changed_fields_test(alert_rule, {'threshold_type': 0}, {})
+        self._run_changed_fields_test(
+            alert_rule,
+            {'threshold_type': 1},
+            {'threshold_type': AlertRuleThresholdType.BELOW},
+        )
diff --git a/tests/sentry/incidents/test_logic.py b/tests/sentry/incidents/test_logic.py
index 3f345e09c1..f451b1d561 100644
--- a/tests/sentry/incidents/test_logic.py
+++ b/tests/sentry/incidents/test_logic.py
@@ -39,6 +39,7 @@ from sentry.incidents.logic import (
     get_incident_suspects,
     subscribe_to_incident,
     StatusAlreadyChangedError,
+    update_alert_rule,
     update_incident_status,
 )
 from sentry.incidents.models import (
@@ -848,3 +849,78 @@ class CreateAlertRuleTest(TestCase, BaseIncidentsTest):
                 1,
                 1,
             )
+
+
+class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
+    @fixture
+    def alert_rule(self):
+        return create_alert_rule(
+            self.project,
+            'hello',
+            AlertRuleThresholdType.ABOVE,
+            'level:error',
+            [AlertRuleAggregations.TOTAL],
+            10,
+            1000,
+            400,
+            1,
+        )
+
+    def test(self):
+        name = 'uh oh'
+        threshold_type = AlertRuleThresholdType.BELOW
+        query = 'level:warning'
+        aggregations = [AlertRuleAggregations.UNIQUE_USERS]
+        time_window = 50
+        alert_threshold = 2000
+        resolve_threshold = 800
+        threshold_period = 2
+
+        update_alert_rule(
+            self.alert_rule,
+            name=name,
+            threshold_type=threshold_type,
+            query=query,
+            aggregations=aggregations,
+            time_window=time_window,
+            alert_threshold=alert_threshold,
+            resolve_threshold=resolve_threshold,
+            threshold_period=threshold_period,
+        )
+        assert self.alert_rule.name == name
+        assert self.alert_rule.threshold_type == threshold_type.value
+        assert self.alert_rule.query == query
+        assert self.alert_rule.aggregations == [a.value for a in aggregations]
+        assert self.alert_rule.time_window == time_window
+        assert self.alert_rule.alert_threshold == alert_threshold
+        assert self.alert_rule.resolve_threshold == resolve_threshold
+        assert self.alert_rule.threshold_period == threshold_period
+
+    def test_update_subscription(self):
+        old_subscription_id = self.alert_rule.subscription_id
+        alert_rule = update_alert_rule(self.alert_rule, query='some new query')
+        assert old_subscription_id != alert_rule.subscription_id
+
+    def test_empty_query(self):
+        alert_rule = update_alert_rule(self.alert_rule, query='')
+        assert alert_rule.query == ''
+
+    def test_name_used(self):
+        used_name = 'uh oh'
+        create_alert_rule(
+            self.project,
+            used_name,
+            AlertRuleThresholdType.ABOVE,
+            'level:error',
+            [AlertRuleAggregations.TOTAL],
+            10,
+            1000,
+            400,
+            1,
+        )
+        with self.assertRaises(AlertRuleNameAlreadyUsedError):
+            update_alert_rule(self.alert_rule, name=used_name)
+
+    def test_invalid_query(self):
+        with self.assertRaises(InvalidSearchQuery):
+            update_alert_rule(self.alert_rule, query='has:')

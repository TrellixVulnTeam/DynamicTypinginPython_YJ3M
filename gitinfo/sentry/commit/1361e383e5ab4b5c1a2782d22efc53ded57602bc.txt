commit 1361e383e5ab4b5c1a2782d22efc53ded57602bc
Author: David Cramer <dcramer@gmail.com>
Date:   Mon Apr 30 13:35:33 2018 -0700

    fix(auth): Handle passwordless SSO flows
    
    This changes SSO auto-link behavior to:
    
    - Remove the Sentry-verified check. This exposes the ability for accounts to be auto merged on typos, but is considered a low risk tradeoff.
    - Remove login checks if the user doesn't have a password (and thus could never authenticate).
    - Send verification email as part of SSO creation
    
    Note: we'll likely need to revisit the "has_usable_password" check to become "can_login_at_all" if/when we support "login with Google"

diff --git a/src/sentry/auth/helper.py b/src/sentry/auth/helper.py
index 7b321166c1..af220cb244 100644
--- a/src/sentry/auth/helper.py
+++ b/src/sentry/auth/helper.py
@@ -405,6 +405,8 @@ class AuthHelper(object):
                 data=identity.get('data', {}),
             )
 
+        user.send_confirm_emails(is_new_user=True)
+
         self._handle_new_membership(auth_identity)
 
         return auth_identity
@@ -468,12 +470,14 @@ class AuthHelper(object):
         Flow is activated upon a user logging in to where an AuthIdentity is
         not present.
 
+        XXX(dcramer): this docstring is out of date
+
         The flow will attempt to answer the following:
 
         - Is there an existing user with the same email address? Should they be
           merged?
 
-        - Is there an existing user (via authentication) that shoudl be merged?
+        - Is there an existing user (via authentication) that should be merged?
 
         - Should I create a new user based on this identity?
         """
@@ -490,16 +494,13 @@ class AuthHelper(object):
         else:
             acting_user = request.user
 
-        verified_email = acting_user and acting_user.emails.filter(
-            is_verified=True,
-            email__iexact=identity['email'],
-        ).exists()
-
         # If they already have an SSO account and the identity provider says
         # the email matches we go ahead and let them merge it. This is the
         # only way to prevent them having duplicate accounts, and because
         # we trust identity providers, its considered safe.
-        if acting_user and identity.get('email_verified') and verified_email:
+        # Note: we do not trust things like SAML, so the SSO implementation needs
+        # to consider if 'email_verified' can be trusted or not
+        if acting_user and identity.get('email_verified'):
             # we only allow this flow to happen if the existing user has
             # membership, otherwise we short circuit because it might be
             # an attempt to hijack membership of another organization
@@ -514,12 +515,19 @@ class AuthHelper(object):
                     after_2fa=request.build_absolute_uri(),
                     organization_id=self.organization.id
                 ):
-                    return HttpResponseRedirect(auth.get_login_redirect(self.request))
-                # assume they've confirmed they want to attach the identity
-                op = 'confirm'
+                    if acting_user.has_usable_password():
+                        return HttpResponseRedirect(auth.get_login_redirect(self.request))
+                    else:
+                        acting_user = None
+                else:
+                    # assume they've confirmed they want to attach the identity
+                    op = 'confirm'
             else:
                 # force them to create a new account
                 acting_user = None
+        # without a usable password they cant login, so let's clear the acting_user
+        elif acting_user and not acting_user.has_usable_password():
+            acting_user = None
 
         if op == 'confirm' and request.user.is_authenticated():
             auth_identity = self._handle_attach_identity(identity)
diff --git a/src/sentry/testutils/fixtures.py b/src/sentry/testutils/fixtures.py
index 6a75fb5e3a..7d28813044 100644
--- a/src/sentry/testutils/fixtures.py
+++ b/src/sentry/testutils/fixtures.py
@@ -429,7 +429,8 @@ class Fixtures(object):
         kwargs.setdefault('is_superuser', False)
 
         user = User(email=email, **kwargs)
-        user.set_password('admin')
+        if not kwargs.get('password'):
+            user.set_password('admin')
         user.save()
 
         # UserEmail is created by a signal
diff --git a/tests/sentry/web/frontend/test_auth_organization_login.py b/tests/sentry/web/frontend/test_auth_organization_login.py
index 5f960c0ab0..9d30375394 100644
--- a/tests/sentry/web/frontend/test_auth_organization_login.py
+++ b/tests/sentry/web/frontend/test_auth_organization_login.py
@@ -599,6 +599,47 @@ class OrganizationAuthLoginTest(AuthProviderTestCase):
         # there should be no prompt as we auto merge the identity
         assert resp.status_code == 200
 
+    def test_flow_authenticated_without_verified_without_password(self):
+        """
+        Given an existing authenticated user, and an updated identity (e.g.
+        the ident changed from the SSO provider), we should be re-linking
+        the identity automatically as they dont have a password.
+
+        This is specifically testing an unauthenticated flow.
+        """
+        organization = self.create_organization(name='foo', owner=self.user)
+        AuthProvider.objects.create(
+            organization=organization,
+            provider='dummy',
+        )
+
+        # setup a 'previous' identity, such as when we migrated Google from
+        # the old idents to the new
+        user = self.create_user(
+            'bar@example.com',
+            is_managed=False,
+            password='',
+        )
+        UserEmail.objects.filter(user=user, email='bar@example.com').update(is_verified=False)
+        self.create_member(
+            organization=organization,
+            user=user,
+        )
+
+        path = reverse('sentry-auth-organization', args=[organization.slug])
+
+        resp = self.client.post(path, {'init': True})
+
+        assert resp.status_code == 200
+        assert self.provider.TEMPLATE in resp.content.decode('utf-8')
+
+        path = reverse('sentry-auth-sso')
+
+        resp = self.client.post(path, {'email': 'bar@example.com'})
+        self.assertTemplateUsed(resp, 'sentry/auth-confirm-identity.html')
+        assert resp.status_code == 200
+        assert resp.context['existing_user'] == user
+
     def test_flow_managed_duplicate_users_without_membership(self):
         """
         Given an existing authenticated user, and an updated identity (e.g.

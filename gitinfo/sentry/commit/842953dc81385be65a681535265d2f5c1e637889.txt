commit 842953dc81385be65a681535265d2f5c1e637889
Author: Matte Noble <me@mattenoble.com>
Date:   Fri Jul 27 12:09:05 2018 -0700

    feat(integrations): GitHub post-install migration (#9175)
    
    Updates existing Repositories that are accessible by the newly installed Integration, to be associated with it.

diff --git a/src/sentry/integrations/base.py b/src/sentry/integrations/base.py
index a0d3e24641..636346e01f 100644
--- a/src/sentry/integrations/base.py
+++ b/src/sentry/integrations/base.py
@@ -92,6 +92,9 @@ class IntegrationProvider(PipelineProvider):
     def get_logger(self):
         return logging.getLogger('sentry.integration.%s' % (self.key, ))
 
+    def post_install(self, integration, organization):
+        pass
+
     def get_pipeline_views(self):
         """
         Return a list of ``View`` instances describing this integration's
diff --git a/src/sentry/integrations/github/integration.py b/src/sentry/integrations/github/integration.py
index 8b19f960de..15063870be 100644
--- a/src/sentry/integrations/github/integration.py
+++ b/src/sentry/integrations/github/integration.py
@@ -9,6 +9,7 @@ from sentry.integrations import Integration, IntegrationFeatures, IntegrationPro
 from sentry.integrations.exceptions import ApiError
 from sentry.integrations.constants import ERR_INTERNAL, ERR_UNAUTHORIZED
 from sentry.integrations.repositories import RepositoryMixin
+from sentry.models import Repository
 from sentry.pipeline import NestedPipelineView, PipelineView
 from sentry.utils.http import absolute_uri
 
@@ -65,6 +66,20 @@ class GitHubIntegration(Integration, GitHubIssueBasic, RepositoryMixin):
             data.append({'name': repo['name'], 'identifier': repo['full_name']})
         return data
 
+    def get_unmigratable_repositories(self):
+        accessible_repos = self.get_repositories()
+        accessible_repo_names = [r['identifier'] for r in accessible_repos]
+
+        existing_repos = Repository.objects.filter(
+            organization_id=self.organization_id,
+            provider='github',
+        )
+
+        return filter(
+            lambda repo: repo.name not in accessible_repo_names,
+            existing_repos,
+        )
+
     def reinstall(self):
         self.reinstall_repositories()
 
@@ -98,6 +113,19 @@ class GitHubIntegrationProvider(IntegrationProvider):
         'height': 1000,
     }
 
+    def post_install(self, integration, organization):
+        repos = Repository.objects.filter(
+            organization_id=organization.id,
+            provider='github',
+        )
+
+        unmigratable_repos = self \
+            .get_installation(integration, organization.id) \
+            .get_unmigratable_repositories()
+
+        for repo in filter(lambda r: r not in unmigratable_repos, repos):
+            repo.update(integration_id=integration.id)
+
     def get_pipeline_views(self):
         identity_pipeline_config = {
             'oauth_scopes': (),
diff --git a/src/sentry/integrations/github_enterprise/integration.py b/src/sentry/integrations/github_enterprise/integration.py
index edcc207d0a..c842c70081 100644
--- a/src/sentry/integrations/github_enterprise/integration.py
+++ b/src/sentry/integrations/github_enterprise/integration.py
@@ -193,6 +193,9 @@ class GitHubEnterpriseIntegrationProvider(GitHubIntegrationProvider):
                 # available from the installation config view.
                 lambda: self._make_identity_pipeline_view()]
 
+    def post_install(self, integration, organization):
+        pass
+
     def get_installation_info(self, installation_data, access_token, installation_id):
         session = http.build_session()
         resp = session.get(
diff --git a/src/sentry/integrations/pipeline.py b/src/sentry/integrations/pipeline.py
index 0629666545..ed243cac39 100644
--- a/src/sentry/integrations/pipeline.py
+++ b/src/sentry/integrations/pipeline.py
@@ -56,25 +56,26 @@ class IntegrationPipeline(Pipeline):
             return self.error(e.message)
 
         response = self._finish_pipeline(data)
+        self.provider.post_install(self.integration, self.organization)
         self.clear_session()
         return response
 
     def _finish_pipeline(self, data):
         if 'reinstall_id' in data:
-            integration = Integration.objects.get(
+            self.integration = Integration.objects.get(
                 provider=self.provider.key,
                 id=data['reinstall_id'],
             )
-            integration.update(external_id=data['external_id'], status=ObjectStatus.VISIBLE)
-            integration.get_installation(self.organization.id).reinstall()
+            self.integration.update(external_id=data['external_id'], status=ObjectStatus.VISIBLE)
+            self.integration.get_installation(self.organization.id).reinstall()
 
         elif 'expect_exists' in data:
-            integration = Integration.objects.get(
+            self.integration = Integration.objects.get(
                 provider=self.provider.key,
                 external_id=data['external_id'],
             )
         else:
-            integration = ensure_integration(self.provider.key, data)
+            self.integration = ensure_integration(self.provider.key, data)
 
         # Does this integration provide a user identity for the user setting up
         # the integration?
@@ -150,7 +151,8 @@ class IntegrationPipeline(Pipeline):
                 raise NotImplementedError('Integration requires an identity')
             org_integration_args = {'default_auth_id': identity_model.id}
 
-        org_integration = integration.add_organization(self.organization.id, **org_integration_args)
+        org_integration = self.integration.add_organization(
+            self.organization.id, **org_integration_args)
 
         return self._dialog_response(serialize(org_integration, self.request.user), True)
 
diff --git a/tests/sentry/integrations/github/test_integration.py b/tests/sentry/integrations/github/test_integration.py
index dc30513e8c..6c0d4a380c 100644
--- a/tests/sentry/integrations/github/test_integration.py
+++ b/tests/sentry/integrations/github/test_integration.py
@@ -2,13 +2,16 @@ from __future__ import absolute_import
 
 import responses
 import six
-from mock import patch
+import sentry
+
+from mock import MagicMock
 from six.moves.urllib.parse import parse_qs, urlencode, urlparse
 
 from sentry.constants import ObjectStatus
 from sentry.integrations.github import GitHubIntegrationProvider
 from sentry.models import (
     Identity, IdentityProvider, IdentityStatus, Integration, OrganizationIntegration,
+    Repository,
 )
 from sentry.testutils import IntegrationTestCase
 
@@ -16,57 +19,77 @@ from sentry.testutils import IntegrationTestCase
 class GitHubIntegrationTest(IntegrationTestCase):
     provider = GitHubIntegrationProvider
 
-    @patch('sentry.integrations.github.integration.get_jwt', return_value='jwt_token_1')
-    def assert_setup_flow(self, get_jwt, installation_id='install_id_1',
-                          app_id='app_1', user_id='user_id_1'):
-        responses.reset()
+    def setUp(self):
+        super(GitHubIntegrationTest, self).setUp()
 
-        resp = self.client.get(self.init_path)
-        assert resp.status_code == 302
-        redirect = urlparse(resp['Location'])
-        assert redirect.scheme == 'https'
-        assert redirect.netloc == 'github.com'
-        assert redirect.path == '/apps/sentry-test-app'
+        self.installation_id = 'install_1'
+        self.user_id = 'user_1'
+        self.app_id = 'app_1'
+        self.access_token = 'xxxxx-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx'
+        self.expires_at = '3000-01-01T00:00:00Z'
 
-        # App installation ID is provided, mveo thr
-        resp = self.client.get('{}?{}'.format(
-            self.setup_path,
-            urlencode({'installation_id': installation_id})
-        ))
+        self._stub_github()
 
-        assert resp.status_code == 302
-        redirect = urlparse(resp['Location'])
-        assert redirect.scheme == 'https'
-        assert redirect.netloc == 'github.com'
-        assert redirect.path == '/login/oauth/authorize'
+    def _stub_github(self):
+        responses.reset()
 
-        params = parse_qs(redirect.query)
-        assert params['state']
-        assert params['redirect_uri'] == ['http://testserver/extensions/github/setup/']
-        assert params['response_type'] == ['code']
-        assert params['client_id'] == ['github-client-id']
-        # once we've asserted on it, switch to a singular values to make life
-        # easier
-        authorize_params = {k: v[0] for k, v in six.iteritems(params)}
+        sentry.integrations.github.integration.get_jwt = MagicMock(
+            return_value='jwt_token_1',
+        )
+        sentry.integrations.github.client.get_jwt = MagicMock(
+            return_value='jwt_token_1',
+        )
 
-        access_token = 'xxxxx-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx'
+        responses.add(
+            responses.POST,
+            'https://github.com/login/oauth/access_token',
+            json={'access_token': self.access_token}
+        )
 
         responses.add(
-            responses.POST, 'https://github.com/login/oauth/access_token',
-            json={'access_token': access_token}
+            responses.POST,
+            'https://api.github.com/installations/{}/access_tokens'.format(
+                self.installation_id,
+            ),
+            json={
+                'token': self.access_token,
+                'expires_at': self.expires_at,
+            }
         )
 
         responses.add(
-            responses.GET, 'https://api.github.com/user',
-            json={'id': user_id}
+            responses.GET,
+            'https://api.github.com/user',
+            json={'id': self.user_id}
+        )
+
+        responses.add(
+            responses.GET,
+            u'https://api.github.com/installation/repositories',
+            json={
+                'repositories': [
+                    {
+                        'id': 1296269,
+                        'name': 'foo',
+                        'full_name': 'Test-Organization/foo',
+                    },
+                    {
+                        'id': 9876574,
+                        'name': 'bar',
+                        'full_name': 'Test-Organization/bar',
+                    },
+                ],
+            }
         )
 
         responses.add(
             responses.GET,
-            u'https://api.github.com/app/installations/{}'.format(installation_id),
+            u'https://api.github.com/app/installations/{}'.format(
+                self.installation_id,
+            ),
             json={
-                'id': installation_id,
-                'app_id': app_id,
+                'id': self.installation_id,
+                'app_id': self.app_id,
                 'account': {
                     'login': 'Test Organization',
                     'avatar_url': 'http://example.com/avatar.png',
@@ -77,12 +100,44 @@ class GitHubIntegrationTest(IntegrationTestCase):
         )
 
         responses.add(
-            responses.GET, u'https://api.github.com/user/installations',
+            responses.GET,
+            u'https://api.github.com/user/installations',
             json={
-                'installations': [{'id': installation_id}],
+                'installations': [{'id': self.installation_id}],
             }
         )
 
+    def assert_setup_flow(self):
+        resp = self.client.get(self.init_path)
+        assert resp.status_code == 302
+        redirect = urlparse(resp['Location'])
+        assert redirect.scheme == 'https'
+        assert redirect.netloc == 'github.com'
+        assert redirect.path == '/apps/sentry-test-app'
+
+        # App installation ID is provided
+        resp = self.client.get('{}?{}'.format(
+            self.setup_path,
+            urlencode({'installation_id': self.installation_id})
+        ))
+
+        redirect = urlparse(resp['Location'])
+
+        assert resp.status_code == 302
+        assert redirect.scheme == 'https'
+        assert redirect.netloc == 'github.com'
+        assert redirect.path == '/login/oauth/authorize'
+
+        params = parse_qs(redirect.query)
+
+        assert params['state']
+        assert params['redirect_uri'] == ['http://testserver/extensions/github/setup/']
+        assert params['response_type'] == ['code']
+        assert params['client_id'] == ['github-client-id']
+
+        # Compact list values into singular values, since there's only ever one.
+        authorize_params = {k: v[0] for k, v in six.iteritems(params)}
+
         resp = self.client.get('{}?{}'.format(
             self.setup_path,
             urlencode({
@@ -91,15 +146,16 @@ class GitHubIntegrationTest(IntegrationTestCase):
             })
         ))
 
-        mock_access_token_request = responses.calls[0].request
-        req_params = parse_qs(mock_access_token_request.body)
+        oauth_exchange = responses.calls[0]
+        req_params = parse_qs(oauth_exchange.request.body)
+
         assert req_params['grant_type'] == ['authorization_code']
         assert req_params['code'] == ['oauth-code']
         assert req_params['redirect_uri'] == ['http://testserver/extensions/github/setup/']
         assert req_params['client_id'] == ['github-client-id']
         assert req_params['client_secret'] == ['github-client-secret']
 
-        assert resp.status_code == 200
+        assert oauth_exchange.response.status_code == 200
 
         auth_header = responses.calls[2].request.headers['Authorization']
         assert auth_header == 'Bearer jwt_token_1'
@@ -107,17 +163,50 @@ class GitHubIntegrationTest(IntegrationTestCase):
         self.assertDialogSuccess(resp)
         return resp
 
+    @responses.activate
+    def test_plugin_migration(self):
+        accessible_repo = Repository.objects.create(
+            organization_id=self.organization.id,
+            name='Test-Organization/foo',
+            url='https://github.com/Test-Organization/foo',
+            provider='github',
+            external_id=123,
+        )
+
+        inaccessible_repo = Repository.objects.create(
+            organization_id=self.organization.id,
+            name='Not-My-Org/other',
+            provider='github',
+            external_id=321,
+        )
+
+        self.assert_setup_flow()
+
+        integration = Integration.objects.get(provider=self.provider.key)
+
+        # Updates the existing Repository to belong to the new Integration
+        assert Repository.objects.get(
+            id=accessible_repo.id,
+        ).integration_id == integration.id
+
+        # Doesn't touch Repositories not accessible by the new Integration
+        assert Repository.objects.get(
+            id=inaccessible_repo.id,
+        ).integration_id is None
+
     @responses.activate
     def test_basic_flow(self):
         self.assert_setup_flow()
 
         integration = Integration.objects.get(provider=self.provider.key)
 
-        assert integration.external_id == 'install_id_1'
+        assert integration.external_id == self.installation_id
         assert integration.name == 'Test Organization'
         assert integration.metadata == {
-            'access_token': None,
-            'expires_at': None,
+            'access_token': self.access_token,
+            # The metadata doesn't get saved with the timezone "Z" character
+            # for some reason, so just compare everything but that.
+            'expires_at': self.expires_at[:-1],
             'icon': 'http://example.com/avatar.png',
             'domain_name': 'github.com/Test-Organization',
             'account_type': 'Organization',
@@ -132,11 +221,11 @@ class GitHubIntegrationTest(IntegrationTestCase):
         identity = Identity.objects.get(
             idp=idp,
             user=self.user,
-            external_id='user_id_1',
+            external_id=self.user_id,
         )
         assert identity.status == IdentityStatus.VALID
         assert identity.data == {
-            'access_token': 'xxxxx-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx'
+            'access_token': self.access_token,
         }
 
     @responses.activate
@@ -161,16 +250,14 @@ class GitHubIntegrationTest(IntegrationTestCase):
         assert 'The provided Github account is linked to a different user' in resp.content
 
     @responses.activate
-    @patch('sentry.integrations.github.integration.get_jwt', return_value='jwt_token_1')
-    def test_reinstall_flow(self, get_jwt, installation_id='install_id_2',
-                            app_id='app_1', user_id='user_id_1'):
+    def test_reinstall_flow(self):
+        self._stub_github()
         self.assert_setup_flow()
-        responses.reset()
 
         integration = Integration.objects.get(provider=self.provider.key)
         integration.update(status=ObjectStatus.DISABLED)
         assert integration.status == ObjectStatus.DISABLED
-        assert integration.external_id == 'install_id_1'
+        assert integration.external_id == self.installation_id
 
         resp = self.client.get('{}?{}'.format(
             self.init_path,
@@ -183,59 +270,32 @@ class GitHubIntegrationTest(IntegrationTestCase):
         assert redirect.netloc == 'github.com'
         assert redirect.path == '/apps/sentry-test-app'
 
+        # New Installation
+        self.installation_id = 'install_2'
+
         resp = self.client.get('{}?{}'.format(
             self.setup_path,
-            urlencode({'installation_id': installation_id})
+            urlencode({'installation_id': self.installation_id})
         ))
 
-        assert resp.status_code == 302
         redirect = urlparse(resp['Location'])
+
+        assert resp.status_code == 302
         assert redirect.scheme == 'https'
         assert redirect.netloc == 'github.com'
         assert redirect.path == '/login/oauth/authorize'
 
         params = parse_qs(redirect.query)
+
         assert params['state']
         assert params['redirect_uri'] == ['http://testserver/extensions/github/setup/']
         assert params['response_type'] == ['code']
         assert params['client_id'] == ['github-client-id']
-        # once we've asserted on it, switch to a singular values to make life
-        # easier
-        authorize_params = {k: v[0] for k, v in six.iteritems(params)}
-
-        access_token = 'xxxxx-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx'
-
-        responses.add(
-            responses.POST, 'https://github.com/login/oauth/access_token',
-            json={'access_token': access_token}
-        )
-
-        responses.add(
-            responses.GET, 'https://api.github.com/user',
-            json={'id': user_id}
-        )
 
-        responses.add(
-            responses.GET,
-            u'https://api.github.com/app/installations/{}'.format(installation_id),
-            json={
-                'id': installation_id,
-                'app_id': app_id,
-                'account': {
-                    'login': 'Test Organization',
-                    'avatar_url': 'http://example.com/avatar.png',
-                    'html_url': 'https://github.com/Test-Organization',
-                    'type': 'Organization',
-                },
-            }
-        )
+        # Compact list values to make the rest of this easier
+        authorize_params = {k: v[0] for k, v in six.iteritems(params)}
 
-        responses.add(
-            responses.GET, u'https://api.github.com/user/installations',
-            json={
-                'installations': [{'id': installation_id}],
-            }
-        )
+        self._stub_github()
 
         resp = self.client.get('{}?{}'.format(
             self.setup_path,
@@ -260,4 +320,4 @@ class GitHubIntegrationTest(IntegrationTestCase):
 
         integration = Integration.objects.get(provider=self.provider.key)
         assert integration.status == ObjectStatus.VISIBLE
-        assert integration.external_id == 'install_id_2'
+        assert integration.external_id == self.installation_id
diff --git a/tests/sentry/integrations/github_enterprise/test_integration.py b/tests/sentry/integrations/github_enterprise/test_integration.py
index d7c792d860..b1c08499c0 100644
--- a/tests/sentry/integrations/github_enterprise/test_integration.py
+++ b/tests/sentry/integrations/github_enterprise/test_integration.py
@@ -25,7 +25,8 @@ class GitHubEnterpriseIntegrationTest(IntegrationTestCase):
     }
 
     @patch('sentry.integrations.github_enterprise.integration.get_jwt', return_value='jwt_token_1')
-    def assert_setup_flow(self, get_jwt, installation_id='install_id_1',
+    @patch('sentry.integrations.github.client.get_jwt', return_value='jwt_token_1')
+    def assert_setup_flow(self, get_jwt, _, installation_id='install_id_1',
                           app_id='app_1', user_id='user_id_1'):
         responses.reset()
         resp = self.client.get(self.init_path)
@@ -65,6 +66,16 @@ class GitHubEnterpriseIntegrationTest(IntegrationTestCase):
             json={'access_token': access_token}
         )
 
+        responses.add(
+            responses.POST, 'https://35.232.149.196/api/v3/installations/{}/access_tokens'.format(
+                installation_id,
+            ),
+            json={
+                'token': access_token,
+                'expires_at': '3000-01-01 00:00:00Z',
+            },
+        )
+
         responses.add(
             responses.GET, 'https://35.232.149.196/api/v3/user',
             json={'id': user_id}

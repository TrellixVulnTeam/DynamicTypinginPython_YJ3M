commit 89f99a2fcc12d14b40d6c81cd7d785d9347489fd
Author: ted kaemming <ted@kaemming.com>
Date:   Mon Apr 16 13:09:24 2018 -0700

    ref(services): Make worker pool initialization threadsafe (#8053)
    
    This corrects an incorrect (and dumb, in retrospect) assuption I made
    about how we run our processes in production.
    
    Fixes SENTRY-6DP.

diff --git a/src/sentry/utils/concurrent.py b/src/sentry/utils/concurrent.py
index dff1edce39..1dca585ef2 100644
--- a/src/sentry/utils/concurrent.py
+++ b/src/sentry/utils/concurrent.py
@@ -100,31 +100,34 @@ class ThreadedExecutor(object):
         self.__workers = set([])
         self.__started = False
         self.__queue = PriorityQueue(maxsize)
+        self.__lock = threading.Lock()
+
+    def __worker(self):
+        queue = self.__queue
+        while True:
+            priority, (function, future) = queue.get(True)
+            if not future.set_running_or_notify_cancel():
+                continue
+            try:
+                result = function()
+            except Exception as error:
+                future.set_exception(error)
+            else:
+                future.set_result(result)
+            queue.task_done()
 
     def start(self):
-        assert not self.__started
-
-        def worker():
-            queue = self.__queue
-            while True:
-                priority, (function, future) = queue.get(True)
-                if not future.set_running_or_notify_cancel():
-                    continue
-                try:
-                    result = function()
-                except Exception as error:
-                    future.set_exception(error)
-                else:
-                    future.set_result(result)
-                queue.task_done()
-
-        for i in xrange(self.__worker_count):
-            t = threading.Thread(target=worker)
-            t.daemon = True
-            t.start()
-            self.__workers.add(t)
-
-        self.__started = True
+        with self.__lock:
+            if self.__started:
+                return
+
+            for i in xrange(self.__worker_count):
+                t = threading.Thread(target=self.__worker)
+                t.daemon = True
+                t.start()
+                self.__workers.add(t)
+
+            self.__started = True
 
     def submit(self, callable, priority=0, block=True, timeout=None):
         """\

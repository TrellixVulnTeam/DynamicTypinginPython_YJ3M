commit 6ac589de84c8a36f7c1dbafe483588f706523506
Author: Alex Hofsteede <alex@hofsteede.com>
Date:   Tue Nov 7 17:15:23 2017 -0800

    ref: Change QueuedPublisher to be reusable (#6525)
    
    QueuedPublisher can now be a wrapper providing safe async (but lossy)
    publishing for any class that implements the publish(channel, data)
    interface.

diff --git a/src/sentry/utils/pubsub.py b/src/sentry/utils/pubsub.py
index efe2f442a5..3969351363 100644
--- a/src/sentry/utils/pubsub.py
+++ b/src/sentry/utils/pubsub.py
@@ -9,42 +9,31 @@ from threading import Thread
 from six.moves.queue import Queue
 
 
-class PubSub():
+class QueuedPublisher():
     """
-    Poster for a redis pubsub instance.
+    A publisher that queues items locally and publishes them to a
+    remote pubsub service on a background thread.
 
-    put(channel, data) to send data to a redis pubsub
-    channel. Maintains an internal queue for posting, will discard the
-    value if the queue is full or not immediately available.
+    Maintains a lossy internal queue for posting, will discard the
+    value if the queue is full or not immediately available. Will also
+    drop items if the publish operation to the remote service fails.
     """
 
-    def __init__(self):
+    def __init__(self, publisher):
         self._started = False
+        self.publisher = publisher
 
     def _start(self):
         if self._started:
             return True
 
-        connection = getattr(settings, 'PUBSUB_CONNECTION', None)
-        try:
-            host, port, db = connection
-        except (TypeError, ValueError):
-            return False
-        self.rds = redis.StrictRedis(
-            host=host,
-            port=port,
-            db=db,
-            socket_timeout=0.2,
-            socket_connect_timeout=1,
-        )
-
         self.q = q = Queue(maxsize=100)
 
         def worker():
             while True:
-                (channel, data) = q.get()
+                (channel, item) = q.get()
                 try:
-                    self.rds.publish(channel, data)
+                    self.publisher.publish(channel, item)
                 except Exception:
                     logger = logging.getLogger('sentry.errors')
                     logger.debug('could not submit event to pubsub')
@@ -58,15 +47,22 @@ class PubSub():
         self._started = True
         return True
 
-    def put(self, channel, data):
+    def publish(self, channel, item):
         if not self._start():
             return
 
-        sample_channel = getattr(settings, 'PUBSUB_SAMPLING', {}).get(channel, 1.0)
+        sample_channel = getattr(settings, 'PUBSUB_SAMPLING', 1.0)
         if random.random() <= sample_channel:
             try:
-                self.q.put((channel, data), block=False)
+                self.q.put((channel, item), block=False)
             except Queue.Full:
                 return
 
-pubsub = PubSub()
+
+class RedisPublisher():
+    def __init__(self, connection):
+        self.rds = None if connection is None else redis.StrictRedis(**connection)
+
+    def publish(self, channel, item):
+        if self.rds is not None:
+            self.rds.publish(channel, item)
diff --git a/src/sentry/web/api.py b/src/sentry/web/api.py
index 5116000811..2b3f48c5e5 100644
--- a/src/sentry/web/api.py
+++ b/src/sentry/web/api.py
@@ -37,7 +37,7 @@ from sentry.utils.http import (
     get_origins,
     is_same_domain,
 )
-from sentry.utils.pubsub import pubsub
+from sentry.utils.pubsub import QueuedPublisher, RedisPublisher
 from sentry.utils.safe import safe_execute
 from sentry.web.helpers import render_to_response
 
@@ -49,7 +49,9 @@ PIXEL = base64.b64decode('R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=')
 
 PROTOCOL_VERSIONS = frozenset(('2.0', '3', '4', '5', '6', '7'))
 
-PUBSUB_ENABLED = getattr(settings, 'PUBSUB_ENABLED', False)
+pubsub = QueuedPublisher(
+    RedisPublisher(getattr(settings, 'REQUESTS_PUBSUB_CONNECTION', None))
+) if getattr(settings, 'REQUESTS_PUBSUB_ENABLED', False) else None
 
 
 def api(func):
@@ -312,8 +314,8 @@ class StoreView(APIView):
             # bubble up as an APIError.
             data = None
 
-        if PUBSUB_ENABLED and data is not None:
-            pubsub.put('requests', data)
+        if pubsub is not None and data is not None:
+            pubsub.publish('requests', data)
 
         response_or_event_id = self.process(request, data=data, **kwargs)
         if isinstance(response_or_event_id, HttpResponse):

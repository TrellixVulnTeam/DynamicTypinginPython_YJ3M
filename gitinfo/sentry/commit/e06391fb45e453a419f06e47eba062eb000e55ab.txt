commit e06391fb45e453a419f06e47eba062eb000e55ab
Author: MeredithAnya <meredith.a.heller@gmail.com>
Date:   Tue Apr 14 19:33:11 2020 -0700

    fix(slack): Re-add ui handling of async channel lookup (#18198)
    
    * fix(slack): Re-add ui handling of async channel lookup

diff --git a/src/sentry/static/sentry/app/views/settings/projectAlerts/issueEditor/index.tsx b/src/sentry/static/sentry/app/views/settings/projectAlerts/issueEditor/index.tsx
index 8387f2958b..2cc88f8368 100644
--- a/src/sentry/static/sentry/app/views/settings/projectAlerts/issueEditor/index.tsx
+++ b/src/sentry/static/sentry/app/views/settings/projectAlerts/issueEditor/index.tsx
@@ -65,9 +65,17 @@ const defaultRule: UnsavedIssueAlertRule = {
   environment: ALL_ENVIRONMENTS_KEY,
 };
 
+const POLLING_MAX_TIME_LIMIT = 3 * 60000;
+
 // TODO(ts): I can't get this to work if I'm specific -- should be: 'condition' | 'action';
 type ConditionOrAction = string;
 
+type RuleTaskResponse = {
+  status: 'pending' | 'failed' | 'succes';
+  rule?: IssueAlertRule;
+  error?: string;
+};
+
 type Props = {
   project: Project;
   organization: Organization;
@@ -83,6 +91,7 @@ type State = AsyncView['state'] & {
     actions: IssueAlertRuleActionTemplate[];
     conditions: IssueAlertRuleConditionTemplate[];
   } | null;
+  uuid: null | string;
 };
 
 function isSavedAlertRule(
@@ -99,6 +108,7 @@ class IssueRuleEditor extends AsyncView<Props, State> {
       detailedError: null,
       rule: {...defaultRule},
       environments: [],
+      uuid: null,
     };
   }
 
@@ -122,6 +132,76 @@ class IssueRuleEditor extends AsyncView<Props, State> {
     return endpoints as [string, string][];
   }
 
+  pollHandler = async (quitTime: number) => {
+    if (Date.now() > quitTime) {
+      addErrorMessage(t('Looking for that channel took too long :('));
+      this.setState({loading: false});
+      return;
+    }
+
+    const {organization, project} = this.props;
+    const {uuid} = this.state;
+    const origRule = this.state.rule;
+
+    try {
+      const response: RuleTaskResponse = await this.api.requestPromise(
+        `/projects/${organization.slug}/${project.slug}/rule-task/${uuid}/`
+      );
+
+      const {status, rule, error} = response;
+
+      if (status === 'pending') {
+        setTimeout(() => {
+          this.pollHandler(quitTime);
+        }, 1000);
+        return;
+      }
+
+      if (status === 'failed') {
+        this.setState({
+          detailedError: {actions: [error ? error : t('An error occurred')]},
+          loading: false,
+        });
+        addErrorMessage(t('An error occurred'));
+      }
+      if (rule) {
+        const ruleId = isSavedAlertRule(origRule) ? `${origRule.id}/` : '';
+        const isNew = !ruleId;
+        this.handleRuleSuccess(isNew, rule);
+      }
+    } catch {
+      addErrorMessage(t('An error occurred'));
+      this.setState({loading: false});
+    }
+  };
+
+  fetchStatus() {
+    // pollHander calls itself until it gets either a sucesss
+    // or failed status but we don't want to poll forever so we pass
+    // in a hard stop time of 3 minutes before we bail.
+    const quitTime = Date.now() + POLLING_MAX_TIME_LIMIT;
+    setTimeout(() => {
+      this.pollHandler(quitTime);
+    }, 1000);
+  }
+
+  handleRuleSuccess = (isNew: boolean, rule: IssueAlertRule) => {
+    const {organization} = this.props;
+    this.setState({detailedError: null, loading: false, rule});
+
+    // The onboarding task will be completed on the server side when the alert
+    // is created
+    updateOnboardingTask(null, organization, {
+      task: OnboardingTaskKey.ALERT_RULE,
+      status: 'complete',
+    });
+
+    // When editing, there is an extra route to move back from
+    const stepBack = isNew ? -1 : -2;
+    browserHistory.replace(recreateRoute('', {...this.props, stepBack}));
+    addSuccessMessage(isNew ? t('Created alert rule') : t('Updated alert rule'));
+  };
+
   handleSubmit = async () => {
     const {rule} = this.state;
     const ruleId = isSavedAlertRule(rule) ? `${rule.id}/` : '';
@@ -137,24 +217,21 @@ class IssueRuleEditor extends AsyncView<Props, State> {
     addLoadingMessage();
 
     try {
-      const resp = await this.api.requestPromise(endpoint, {
+      const [resp, , xhr] = await this.api.requestPromise(endpoint, {
+        includeAllArgs: true,
         method: isNew ? 'POST' : 'PUT',
         data: rule,
       });
-      this.setState({detailedError: null, rule: resp});
 
-      // The onboarding task will be completed on the server side when the alert
-      // is created
-      updateOnboardingTask(null, organization, {
-        task: OnboardingTaskKey.ALERT_RULE,
-        status: 'complete',
-      });
-
-      addSuccessMessage(isNew ? t('Created alert rule') : t('Updated alert rule'));
-
-      // When editing, there is an extra route to move back from
-      const stepBack = isNew ? -1 : -2;
-      browserHistory.replace(recreateRoute('', {...this.props, stepBack}));
+      // if we get a 202 back it means that we have an async task
+      // running to lookup and verfity the channel id for Slack.
+      if (xhr && xhr.status === 202) {
+        this.setState({detailedError: null, loading: true, uuid: resp.uuid});
+        this.fetchStatus();
+        addLoadingMessage(t('Looking through all your channels...'));
+      } else {
+        this.handleRuleSuccess(isNew, resp);
+      }
     } catch (err) {
       this.setState({
         detailedError: err.responseJSON || {__all__: 'Unknown error'},
diff --git a/tests/js/spec/views/settings/projectAlerts/issueEditor.spec.jsx b/tests/js/spec/views/settings/projectAlerts/issueEditor.spec.jsx
index f14f458610..b97acc4250 100644
--- a/tests/js/spec/views/settings/projectAlerts/issueEditor.spec.jsx
+++ b/tests/js/spec/views/settings/projectAlerts/issueEditor.spec.jsx
@@ -154,4 +154,83 @@ describe('ProjectAlerts -> IssueEditor', function() {
       expect(updateOnboardingTask).toHaveBeenCalled();
     });
   });
+
+  describe('Edit Rule: Slack Channel Look Up', function() {
+    const uuid = 'xxxx-xxxx-xxxx';
+
+    beforeEach(async function() {
+      jest.useFakeTimers();
+    });
+
+    afterEach(function() {
+      jest.clearAllTimers();
+      MockApiClient.clearMockResponses();
+    });
+
+    it('pending status keeps loading true', async function() {
+      const endpoint = `/projects/org-slug/project-slug/rule-task/${uuid}/`;
+      MockApiClient.addMockResponse({
+        url: endpoint,
+        body: {status: 'pending'},
+      });
+      const {wrapper} = createWrapper();
+      const ruleEditor = wrapper.find('IssueRuleEditor').last();
+
+      ruleEditor.setState({uuid, loading: true});
+      await Promise.resolve();
+      ruleEditor.update();
+
+      ruleEditor.instance().fetchStatus();
+      jest.runOnlyPendingTimers();
+
+      await Promise.resolve();
+      ruleEditor.update();
+      expect(ruleEditor.state('loading')).toBe(true);
+    });
+
+    it('failed status renders error message', async function() {
+      const endpoint = `/projects/org-slug/project-slug/rule-task/${uuid}/`;
+      MockApiClient.addMockResponse({
+        url: endpoint,
+        body: {status: 'failed'},
+      });
+      const {wrapper} = createWrapper();
+      const ruleEditor = wrapper.find('IssueRuleEditor').last();
+
+      ruleEditor.setState({uuid, loading: true});
+      await Promise.resolve();
+      ruleEditor.update();
+
+      ruleEditor.instance().fetchStatus();
+      jest.runAllTimers();
+
+      await Promise.resolve();
+      ruleEditor.update();
+
+      expect(ruleEditor.state('loading')).toBe(false);
+      expect(ruleEditor.state('detailedError')).toEqual({actions: ['An error occurred']});
+    });
+
+    it('success status updates the rule', async function() {
+      const endpoint = `/projects/org-slug/project-slug/rule-task/${uuid}/`;
+      MockApiClient.addMockResponse({
+        url: endpoint,
+        body: {status: 'success', rule: TestStubs.ProjectAlertRule({name: 'Slack Rule'})},
+      });
+      const {wrapper} = createWrapper();
+      const ruleEditor = wrapper.find('IssueRuleEditor').last();
+
+      ruleEditor.setState({uuid, loading: true});
+      await Promise.resolve();
+      ruleEditor.update();
+
+      ruleEditor.instance().fetchStatus();
+      jest.runOnlyPendingTimers();
+
+      await Promise.resolve();
+      ruleEditor.update();
+      expect(ruleEditor.state('loading')).toBe(false);
+      expect(ruleEditor.state('rule').name).toBe('Slack Rule');
+    });
+  });
 });

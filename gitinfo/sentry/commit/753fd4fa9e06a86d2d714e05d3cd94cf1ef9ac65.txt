commit 753fd4fa9e06a86d2d714e05d3cd94cf1ef9ac65
Author: Ted Kaemming <ted@kaemming.com>
Date:   Wed Sep 23 13:02:41 2015 -0700

    Add tests for Redis scripts (add to timeline, truncate timeline.)

diff --git a/tests/sentry/digests/test_redis.py b/tests/sentry/digests/test_redis.py
index 8f990fe343..e1b535a46d 100644
--- a/tests/sentry/digests/test_redis.py
+++ b/tests/sentry/digests/test_redis.py
@@ -5,6 +5,7 @@ from datetime import datetime
 
 import pytz
 from exam import fixture
+from redis.client import StrictRedis
 
 from sentry.digests.base import (
     Record,
@@ -12,10 +13,12 @@ from sentry.digests.base import (
 from sentry.digests.redis import (
     SCHEDULE_STATE_WAITING,
     RedisBackend,
+    add_to_schedule,
     make_iteration_key,
-    make_timeline_key,
-    make_schedule_key,
     make_record_key,
+    make_schedule_key,
+    make_timeline_key,
+    truncate_timeline,
 )
 from sentry.testutils import TestCase
 
@@ -24,6 +27,73 @@ def to_timestamp(value):
     return (value - datetime(1970, 1, 1, tzinfo=pytz.utc)).total_seconds()
 
 
+class RedisScriptTestCase(TestCase):
+
+    @fixture
+    def records(self):
+        for i in itertools.count():
+            yield Record(i, i, i)
+
+    def test_add_to_schedule_script(self):
+        client = StrictRedis(db=9)
+
+        timeline = 'timeline'
+        timestamp = 100.0
+
+        waiting_set_size = functools.partial(client.zcard, 'waiting')
+        ready_set_size = functools.partial(client.zcard, 'ready')
+        timeline_score_in_waiting_set = functools.partial(client.zscore, 'waiting', timeline)
+        timeline_score_in_ready_set = functools.partial(client.zscore, 'ready', timeline)
+
+        # The first addition should cause the timeline to be added to the waiting set.
+        with self.assertChanges(waiting_set_size, before=0, after=1), \
+                self.assertChanges(timeline_score_in_waiting_set, before=None, after=timestamp):
+            add_to_schedule(('waiting', 'ready'), (timeline, timestamp), client)
+
+        # Adding it again with a timestamp in the future should not change the schedule time.
+        with self.assertDoesNotChange(waiting_set_size), \
+                self.assertDoesNotChange(timeline_score_in_waiting_set):
+            add_to_schedule(('waiting', 'ready'), (timeline, timestamp + 50), client)
+
+        # If we see a record with a timestamp earlier than the schedule time,
+        # we should change the schedule.
+        with self.assertDoesNotChange(waiting_set_size), \
+                self.assertChanges(timeline_score_in_waiting_set, before=timestamp, after=timestamp - 50):
+            add_to_schedule(('waiting', 'ready'), (timeline, timestamp - 50), client)
+
+        # Move the timeline from the waiting set to the ready set.
+        client.zrem('waiting', timeline)
+        client.zadd('ready', timestamp, timeline)
+
+        # Nothing should change.
+        with self.assertDoesNotChange(waiting_set_size), \
+                self.assertDoesNotChange(ready_set_size), \
+                self.assertDoesNotChange(timeline_score_in_ready_set):
+            add_to_schedule(('waiting', 'ready'), (timeline, timestamp - 50), client)
+
+    def test_truncate_timeline_script(self):
+        client = StrictRedis(db=9)
+
+        timeline = 'timeline'
+
+        # Preload some fake records (the contents don't matter.)
+        records = list(itertools.islice(self.records, 10))
+        for record in records:
+            client.zadd(timeline, record.timestamp, record.key)
+            client.set(make_record_key(timeline, record.key), 'data')
+
+        with self.assertChanges(lambda: client.zcard(timeline), before=10, after=5):
+            truncate_timeline((timeline,), (5,), client)
+
+            # Ensure the early records don't exist.
+            for record in records[:5]:
+                assert not client.exists(make_record_key(timeline, record.key))
+
+            # Ensure the later records do exist.
+            for record in records[-5:]:
+                assert client.exists(make_record_key(timeline, record.key))
+
+
 class RedisBackendTestCase(TestCase):
     defaults = {
         'cluster': {

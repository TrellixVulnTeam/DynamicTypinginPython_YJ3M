commit 3ab034db07729546de14aa4e89d9da17905bc04d
Author: Lyn Nagara <lyn.nagara@gmail.com>
Date:   Wed Mar 20 16:07:39 2019 -0700

     feat: Implement next_event and prev_event for SnubaEvent  (#12404)
    
    The Snuba implementation also allows searching for a next and previous
    event with an environment filter. This will help enable navigating through
    events in a subset of environments on the issue details page in future.
    
    Required for SEN-238

diff --git a/src/sentry/api/endpoints/event_details.py b/src/sentry/api/endpoints/event_details.py
index c1930e6939..329be6ee46 100644
--- a/src/sentry/api/endpoints/event_details.py
+++ b/src/sentry/api/endpoints/event_details.py
@@ -1,7 +1,5 @@
 from __future__ import absolute_import
 
-import six
-
 from rest_framework.response import Response
 
 from sentry.api.base import Endpoint
@@ -33,9 +31,7 @@ class EventDetailsEndpoint(Endpoint):
 
         data = serialize(event, request.user, DetailedEventSerializer())
 
-        next_event = event.next_event
-        prev_event = event.prev_event
-        data['nextEventID'] = next_event and six.text_type(next_event.id)
-        data['previousEventID'] = prev_event and six.text_type(prev_event.id)
+        data['nextEventID'] = event.next_event_id()
+        data['previousEventID'] = event.prev_event_id()
 
         return Response(data)
diff --git a/src/sentry/api/endpoints/project_event_details.py b/src/sentry/api/endpoints/project_event_details.py
index ccd8102f44..dd1dc3776c 100644
--- a/src/sentry/api/endpoints/project_event_details.py
+++ b/src/sentry/api/endpoints/project_event_details.py
@@ -1,13 +1,13 @@
 from __future__ import absolute_import
 
-import six
-
 from rest_framework.response import Response
 
+from sentry import options
 from sentry.api.base import DocSection
 from sentry.api.bases.project import ProjectEndpoint
 from sentry.api.serializers import DetailedEventSerializer, serialize
-from sentry.models import Event
+from sentry.models import Event, SnubaEvent
+
 from sentry.utils.apidocs import scenario, attach_scenarios
 
 
@@ -41,6 +41,30 @@ class ProjectEventDetailsEndpoint(ProjectEndpoint):
         :auth: required
         """
 
+        use_snuba = request.GET.get('enable_snuba') == '1' and \
+            options.get('snuba.events-queries.enabled')
+
+        if not use_snuba:
+            return self.get_legacy(request, project, event_id)
+
+        snuba_event = SnubaEvent.objects.from_event_id(event_id, project.id)
+
+        if snuba_event is None:
+            return Response({'detail': 'Event not found'}, status=404)
+
+        data = serialize(snuba_event)
+
+        requested_environments = set(request.GET.getlist('environment'))
+
+        next_event_id = snuba_event.next_event_id(environments=requested_environments)
+        prev_event_id = snuba_event.prev_event_id(environments=requested_environments)
+
+        data['nextEventID'] = next_event_id
+        data['previousEventID'] = prev_event_id
+
+        return Response(data)
+
+    def get_legacy(self, request, project, event_id):
         event = Event.objects.from_event_id(event_id, project.id)
         if event is None:
             return Response({'detail': 'Event not found'}, status=404)
@@ -48,12 +72,11 @@ class ProjectEventDetailsEndpoint(ProjectEndpoint):
         Event.objects.bind_nodes([event], 'data')
 
         data = serialize(event, request.user, DetailedEventSerializer())
-
-        next_event = event.next_event
-        prev_event = event.prev_event
+        next_event_id = event.next_event_id()
+        prev_event_id = event.prev_event_id()
         # TODO this is inconsistent with the event_details API which uses the
         # `id` instead of the `event_id`
-        data['nextEventID'] = next_event and six.text_type(next_event.event_id)
-        data['previousEventID'] = prev_event and six.text_type(prev_event.event_id)
+        data['nextEventID'] = next_event_id
+        data['previousEventID'] = prev_event_id
 
         return Response(data)
diff --git a/src/sentry/db/models/manager.py b/src/sentry/db/models/manager.py
index 11cd325133..f4c862ef3e 100644
--- a/src/sentry/db/models/manager.py
+++ b/src/sentry/db/models/manager.py
@@ -317,6 +317,32 @@ class BaseManager(Manager):
         return self._queryset_class(self.model, using=self._db)
 
 
+class SnubaEventManager(BaseManager):
+    def from_event_id(self, id_or_event_id, project_id):
+        """
+        Get a SnubaEvent by either its id primary key or its hex event_id.
+
+        Returns None if the event cannot be found under either scheme.
+
+        Log any attempt to fetch a SnubaEvent by primary key and eventually remove.
+        """
+        from sentry.models import SnubaEvent, Event
+
+        if not is_event_id(id_or_event_id):
+            logger.warning('Attempt to fetch SnubaEvent by primary key', exc_info=True, extra={
+                'stack': True
+            })
+
+            event = Event.objects.from_event_id(id_or_event_id, project_id)
+
+            if not event:
+                return None
+
+            id_or_event_id = event.event_id
+
+        return SnubaEvent.get_event(project_id, id_or_event_id)
+
+
 class EventManager(BaseManager):
 
     def bind_nodes(self, object_list, *node_names):
diff --git a/src/sentry/models/event.py b/src/sentry/models/event.py
index 85146144fb..cff810be9c 100644
--- a/src/sentry/models/event.py
+++ b/src/sentry/models/event.py
@@ -32,7 +32,7 @@ from sentry.db.models import (
     NodeField,
     sane_repr
 )
-from sentry.db.models.manager import EventManager
+from sentry.db.models.manager import EventManager, SnubaEventManager
 from sentry.interfaces.base import get_interfaces
 from sentry.utils import metrics
 from sentry.utils.cache import memoize
@@ -439,6 +439,8 @@ class SnubaEvent(EventCommon):
         'email',
     ]
 
+    objects = SnubaEventManager()
+
     __repr__ = sane_repr('project_id', 'group_id')
 
     @classmethod
@@ -538,13 +540,63 @@ class SnubaEvent(EventCommon):
         # have to reference the row id anyway.
         return self.event_id
 
-    @property
-    def next_event(self):
-        return None
+    def next_event_id(self, environments=[]):
+        from sentry.utils import snuba
 
-    @property
-    def prev_event(self):
-        return None
+        conditions = [
+            ['timestamp', '>=', self.timestamp],
+            [['timestamp', '>', self.timestamp], ['event_id', '>', self.event_id]]
+        ]
+
+        if len(environments) > 0:
+            conditions.append(['environment', 'IN', environments])
+
+        result = snuba.raw_query(
+            start=self.datetime,  # gte current event
+            end=datetime.utcnow(),  # will be clamped to project retention
+            selected_columns=['event_id'],
+            conditions=conditions,
+            filter_keys={
+                'project_id': [self.project_id],
+                'issue': [self.group_id],
+            },
+            orderby=['timestamp', 'event_id'],
+            limit=1
+        )
+
+        if 'error' in result or len(result['data']) == 0:
+            return None
+
+        return six.text_type(result['data'][0]['event_id'])
+
+    def prev_event_id(self, environments=None):
+        from sentry.utils import snuba
+
+        conditions = [
+            ['timestamp', '<=', self.timestamp],
+            [['timestamp', '<', self.timestamp], ['event_id', '<', self.event_id]]
+        ]
+
+        if len(environments) > 0:
+            conditions.append(['environment', 'IN', environments])
+
+        result = snuba.raw_query(
+            start=datetime.utcfromtimestamp(0),  # will be clamped to project retention
+            end=self.datetime,  # lte current event
+            selected_columns=['event_id'],
+            conditions=conditions,
+            filter_keys={
+                'project_id': [self.project_id],
+                'issue': [self.group_id],
+            },
+            orderby=['-timestamp', '-event_id'],
+            limit=1
+        )
+
+        if 'error' in result or len(result['data']) == 0:
+            return None
+
+        return six.text_type(result['data'][0]['event_id'])
 
     def save(self):
         raise NotImplementedError
@@ -603,8 +655,7 @@ class Event(EventCommon, Model):
     # get the next/prev events. Given that timestamps only have 1-second
     # granularity, this will be inaccurate if there are more than 5 events
     # in a given second.
-    @property
-    def next_event(self):
+    def next_event_id(self, environments=None):
         events = self.__class__.objects.filter(
             datetime__gte=self.datetime,
             group_id=self.group_id,
@@ -613,10 +664,9 @@ class Event(EventCommon, Model):
         events = [e for e in events if e.datetime == self.datetime and e.id > self.id or
                   e.datetime > self.datetime]
         events.sort(key=EVENT_ORDERING_KEY)
-        return events[0] if events else None
+        return six.text_type(events[0].event_id) if events else None
 
-    @property
-    def prev_event(self):
+    def prev_event_id(self, environments=None):
         events = self.__class__.objects.filter(
             datetime__lte=self.datetime,
             group_id=self.group_id,
@@ -625,7 +675,7 @@ class Event(EventCommon, Model):
         events = [e for e in events if e.datetime == self.datetime and e.id < self.id or
                   e.datetime < self.datetime]
         events.sort(key=EVENT_ORDERING_KEY, reverse=True)
-        return events[0] if events else None
+        return six.text_type(events[0].event_id) if events else None
 
 
 class EventSubjectTemplate(string.Template):
diff --git a/tests/sentry/api/endpoints/test_project_event_details.py b/tests/sentry/api/endpoints/test_project_event_details.py
deleted file mode 100644
index 1d49e85cb6..0000000000
--- a/tests/sentry/api/endpoints/test_project_event_details.py
+++ /dev/null
@@ -1,97 +0,0 @@
-from __future__ import absolute_import
-
-import six
-
-from datetime import datetime
-from django.core.urlresolvers import reverse
-
-from sentry.testutils import APITestCase
-
-
-class ProjectEventDetailsTest(APITestCase):
-    def test_simple(self):
-        self.login_as(user=self.user)
-
-        group = self.create_group()
-        prev_event = self.create_event(
-            event_id='a' * 32,
-            group=group,
-            datetime=datetime(2013, 8, 13, 3, 8, 24),
-        )
-        cur_event = self.create_event(
-            event_id='b' * 32,
-            group=group,
-            datetime=datetime(2013, 8, 13, 3, 8, 25),
-        )
-        next_event = self.create_event(
-            event_id='c' * 32,
-            group=group,
-            datetime=datetime(2013, 8, 13, 3, 8, 26),
-        )
-
-        url = reverse(
-            'sentry-api-0-project-event-details',
-            kwargs={
-                'event_id': cur_event.event_id,
-                'project_slug': cur_event.project.slug,
-                'organization_slug': cur_event.project.organization.slug,
-            }
-        )
-        response = self.client.get(url, format='json')
-
-        assert response.status_code == 200, response.content
-        assert response.data['id'] == six.text_type(cur_event.id)
-        assert response.data['nextEventID'] == six.text_type(next_event.event_id)
-        assert response.data['previousEventID'] == six.text_type(prev_event.event_id)
-        assert response.data['groupID'] == six.text_type(group.id)
-
-        # Same event can be looked up by primary key
-        url = reverse(
-            'sentry-api-0-project-event-details',
-            kwargs={
-                'event_id': cur_event.id,
-                'project_slug': cur_event.project.slug,
-                'organization_slug': cur_event.project.organization.slug,
-            }
-        )
-        response = self.client.get(url, format='json')
-
-        assert response.status_code == 200, response.content
-        assert response.data['id'] == six.text_type(cur_event.id)
-        assert response.data['nextEventID'] == six.text_type(next_event.event_id)
-        assert response.data['previousEventID'] == six.text_type(prev_event.event_id)
-        assert response.data['groupID'] == six.text_type(group.id)
-
-    def test_prev_has_no_prev(self):
-        # Test that the "previous" event does not itself have a "previousEventID"
-        # pointing back to the current event. i.e. test that there is not a redirect
-        # loop between next and previous events that occur within the same second.
-        self.login_as(user=self.user)
-
-        group = self.create_group()
-        prev_event = self.create_event(
-            event_id='a' * 32,
-            group=group,
-            datetime=datetime(2013, 8, 13, 3, 8, 24),
-        )
-        cur_event = self.create_event(
-            event_id='b' * 32,
-            group=group,
-            datetime=datetime(2013, 8, 13, 3, 8, 24),
-        )
-
-        url = reverse(
-            'sentry-api-0-project-event-details',
-            kwargs={
-                'event_id': prev_event.event_id,
-                'project_slug': prev_event.project.slug,
-                'organization_slug': prev_event.project.organization.slug,
-            }
-        )
-        response = self.client.get(url, format='json')
-
-        assert response.status_code == 200, response.content
-        assert response.data['id'] == six.text_type(prev_event.id)
-        assert response.data['previousEventID'] is None
-        assert response.data['nextEventID'] == cur_event.event_id
-        assert response.data['groupID'] == six.text_type(group.id)
diff --git a/tests/sentry/api/endpoints/test_event_details.py b/tests/snuba/api/endpoints/test_event_details.py
similarity index 68%
rename from tests/sentry/api/endpoints/test_event_details.py
rename to tests/snuba/api/endpoints/test_event_details.py
index 8ec7c2bb23..7ddc35a6ed 100644
--- a/tests/sentry/api/endpoints/test_event_details.py
+++ b/tests/snuba/api/endpoints/test_event_details.py
@@ -1,36 +1,53 @@
 from __future__ import absolute_import
 
 import six
-import pytest
 
-from datetime import datetime
+from datetime import timedelta
+from django.utils import timezone
 from django.core.urlresolvers import reverse
 
-from sentry.models import UserReport
-from sentry.testutils import APITestCase
+from sentry.models import UserReport, Group
+from sentry.testutils import APITestCase, SnubaTestCase
 
 
-class EventDetailsTest(APITestCase):
+class EventDetailsTest(APITestCase, SnubaTestCase):
+    def setUp(self):
+        super(EventDetailsTest, self).setUp()
+        self.project = self.create_project()
+        self.min_ago = (timezone.now() - timedelta(minutes=1)).isoformat()[:19]
+        self.two_min_ago = (timezone.now() - timedelta(minutes=2)).isoformat()[:19]
+        self.three_min_ago = (timezone.now() - timedelta(minutes=3)).isoformat()[:19]
+
     def test_simple(self):
         self.login_as(user=self.user)
 
-        group = self.create_group()
-        prev_event = self.create_event(
-            event_id='a',
-            group=group,
-            datetime=datetime(2013, 8, 13, 3, 8, 24),
+        prev_event = self.store_event(
+            data={
+                'event_id': 'a' * 32,
+                'timestamp': self.three_min_ago,
+                'fingerprint': ['group-1'],
+            },
+            project_id=self.project.id
         )
-        cur_event = self.create_event(
-            event_id='b',
-            group=group,
-            datetime=datetime(2013, 8, 13, 3, 8, 25),
+        cur_event = self.store_event(
+            data={
+                'event_id': 'b' * 32,
+                'timestamp': self.two_min_ago,
+                'fingerprint': ['group-1'],
+            },
+            project_id=self.project.id
         )
-        next_event = self.create_event(
-            event_id='c',
-            group=group,
-            datetime=datetime(2013, 8, 13, 3, 8, 26),
+        next_event = self.store_event(
+            data={
+                'event_id': 'c' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group-1'],
+            },
+            project_id=self.project.id
         )
 
+        group = Group.objects.first()
+
         url = reverse(
             'sentry-api-0-event-details', kwargs={
                 'event_id': cur_event.id,
@@ -40,8 +57,8 @@ class EventDetailsTest(APITestCase):
 
         assert response.status_code == 200, response.content
         assert response.data['id'] == six.text_type(cur_event.id)
-        assert response.data['nextEventID'] == six.text_type(next_event.id)
-        assert response.data['previousEventID'] == six.text_type(prev_event.id)
+        assert response.data['nextEventID'] == six.text_type(next_event.event_id)
+        assert response.data['previousEventID'] == six.text_type(prev_event.event_id)
         assert response.data['groupID'] == six.text_type(group.id)
         assert not response.data['userReport']
 
@@ -54,7 +71,7 @@ class EventDetailsTest(APITestCase):
 
         assert response.status_code == 200, response.content
         assert response.data['id'] == six.text_type(prev_event.id)
-        assert response.data['nextEventID'] == six.text_type(cur_event.id)
+        assert response.data['nextEventID'] == six.text_type(cur_event.event_id)
         assert response.data['previousEventID'] is None
         assert response.data['groupID'] == six.text_type(group.id)
         assert not response.data['userReport']
@@ -69,41 +86,26 @@ class EventDetailsTest(APITestCase):
         assert response.status_code == 200, response.content
         assert response.data['id'] == six.text_type(next_event.id)
         assert response.data['nextEventID'] is None
-        assert response.data['previousEventID'] == six.text_type(cur_event.id)
+        assert response.data['previousEventID'] == six.text_type(cur_event.event_id)
         assert response.data['groupID'] == six.text_type(group.id)
         assert not response.data['userReport']
 
     def test_identical_datetime(self):
         self.login_as(user=self.user)
 
-        group = self.create_group()
-        created = datetime(2013, 8, 13, 3, 8, 24)
         events = []
-        events.append(self.create_event(
-            event_id='a',
-            group=group,
-            datetime=created,
-        ))
-        events.append(self.create_event(
-            event_id='b',
-            group=group,
-            datetime=created,
-        ))
-        events.append(self.create_event(
-            event_id='c',
-            group=group,
-            datetime=created,
-        ))
-        events.append(self.create_event(
-            event_id='d',
-            group=group,
-            datetime=created,
-        ))
-        events.append(self.create_event(
-            event_id='e',
-            group=group,
-            datetime=created,
-        ))
+
+        for eid in 'abcde':
+            events.append(self.store_event(
+                data={
+                    'event_id': eid * 32,
+                    'timestamp': self.min_ago,
+                    'fingerprint': ['group-1'],
+                },
+                project_id=self.project.id
+            ))
+
+            group = Group.objects.first()
 
         # First event, no prev
         url = reverse(
@@ -115,7 +117,7 @@ class EventDetailsTest(APITestCase):
 
         assert response.status_code == 200, response.content
         assert response.data['id'] == six.text_type(events[0].id)
-        assert response.data['nextEventID'] == six.text_type(events[1].id)
+        assert response.data['nextEventID'] == six.text_type(events[1].event_id)
         assert response.data['previousEventID'] is None
         assert response.data['groupID'] == six.text_type(group.id)
         assert not response.data['userReport']
@@ -130,8 +132,8 @@ class EventDetailsTest(APITestCase):
 
         assert response.status_code == 200, response.content
         assert response.data['id'] == six.text_type(events[1].id)
-        assert response.data['nextEventID'] == six.text_type(events[2].id)
-        assert response.data['previousEventID'] == six.text_type(events[0].id)
+        assert response.data['nextEventID'] == six.text_type(events[2].event_id)
+        assert response.data['previousEventID'] == six.text_type(events[0].event_id)
         assert response.data['groupID'] == six.text_type(group.id)
         assert not response.data['userReport']
 
@@ -145,8 +147,8 @@ class EventDetailsTest(APITestCase):
 
         assert response.status_code == 200, response.content
         assert response.data['id'] == six.text_type(events[2].id)
-        assert response.data['nextEventID'] == six.text_type(events[3].id)
-        assert response.data['previousEventID'] == six.text_type(events[1].id)
+        assert response.data['nextEventID'] == six.text_type(events[3].event_id)
+        assert response.data['previousEventID'] == six.text_type(events[1].event_id)
         assert response.data['groupID'] == six.text_type(group.id)
         assert not response.data['userReport']
 
@@ -160,8 +162,8 @@ class EventDetailsTest(APITestCase):
 
         assert response.status_code == 200, response.content
         assert response.data['id'] == six.text_type(events[3].id)
-        assert response.data['nextEventID'] == six.text_type(events[4].id)
-        assert response.data['previousEventID'] == six.text_type(events[2].id)
+        assert response.data['nextEventID'] == six.text_type(events[4].event_id)
+        assert response.data['previousEventID'] == six.text_type(events[2].event_id)
         assert response.data['groupID'] == six.text_type(group.id)
         assert not response.data['userReport']
 
@@ -176,30 +178,40 @@ class EventDetailsTest(APITestCase):
         assert response.status_code == 200, response.content
         assert response.data['id'] == six.text_type(events[4].id)
         assert response.data['nextEventID'] is None
-        assert response.data['previousEventID'] == six.text_type(events[3].id)
+        assert response.data['previousEventID'] == six.text_type(events[3].event_id)
         assert response.data['groupID'] == six.text_type(group.id)
         assert not response.data['userReport']
 
     def test_timestamps_out_of_order(self):
         self.login_as(user=self.user)
 
-        group = self.create_group()
-        cur_event = self.create_event(
-            event_id='b',
-            group=group,
-            datetime=datetime(2013, 8, 13, 3, 8, 25),
+        cur_event = self.store_event(
+            data={
+                'event_id': 'b' * 32,
+                'timestamp': self.two_min_ago,
+                'fingerprint': ['group-1'],
+            },
+            project_id=self.project.id
         )
-        next_event = self.create_event(
-            event_id='c',
-            group=group,
-            datetime=datetime(2013, 8, 13, 3, 8, 26),
+        next_event = self.store_event(
+            data={
+                'event_id': 'c' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group-1'],
+            },
+            project_id=self.project.id
         )
-        prev_event = self.create_event(
-            event_id='a',
-            group=group,
-            datetime=datetime(2013, 8, 13, 3, 8, 24),
+        prev_event = self.store_event(
+            data={
+                'event_id': 'a' * 32,
+                'timestamp': self.three_min_ago,
+                'fingerprint': ['group-1'],
+            },
+            project_id=self.project.id
         )
 
+        group = Group.objects.first()
+
         url = reverse(
             'sentry-api-0-event-details', kwargs={
                 'event_id': cur_event.id,
@@ -209,8 +221,8 @@ class EventDetailsTest(APITestCase):
 
         assert response.status_code == 200, response.content
         assert response.data['id'] == six.text_type(cur_event.id)
-        assert response.data['nextEventID'] == six.text_type(next_event.id)
-        assert response.data['previousEventID'] == six.text_type(prev_event.id)
+        assert response.data['nextEventID'] == six.text_type(next_event.event_id)
+        assert response.data['previousEventID'] == six.text_type(prev_event.event_id)
         assert response.data['groupID'] == six.text_type(group.id)
         assert not response.data['userReport']
 
@@ -223,7 +235,7 @@ class EventDetailsTest(APITestCase):
 
         assert response.status_code == 200, response.content
         assert response.data['id'] == six.text_type(prev_event.id)
-        assert response.data['nextEventID'] == six.text_type(cur_event.id)
+        assert response.data['nextEventID'] == six.text_type(cur_event.event_id)
         assert response.data['previousEventID'] is None
         assert response.data['groupID'] == six.text_type(group.id)
         assert not response.data['userReport']
@@ -238,20 +250,23 @@ class EventDetailsTest(APITestCase):
         assert response.status_code == 200, response.content
         assert response.data['id'] == six.text_type(next_event.id)
         assert response.data['nextEventID'] is None
-        assert response.data['previousEventID'] == six.text_type(cur_event.id)
+        assert response.data['previousEventID'] == six.text_type(cur_event.event_id)
         assert response.data['groupID'] == six.text_type(group.id)
         assert not response.data['userReport']
 
     def test_user_report(self):
         self.login_as(user=self.user)
 
-        group = self.create_group()
-        cur_event = self.create_event(
-            event_id='a',
-            group=group,
-            datetime=datetime(2013, 8, 13, 3, 8, 24),
+        cur_event = self.store_event(
+            data={
+                'event_id': 'a' * 32,
+                'timestamp': self.min_ago,
+            },
+            project_id=self.project.id
         )
 
+        group = Group.objects.first()
+
         user_report = UserReport.objects.create(
             event_id=cur_event.event_id,
             project=group.project,
@@ -271,32 +286,38 @@ class EventDetailsTest(APITestCase):
         assert response.data['id'] == six.text_type(cur_event.id)
         assert response.data['userReport']['id'] == six.text_type(user_report.id)
 
-    @pytest.mark.xfail
     def test_event_ordering(self):
         # Test that a real "prev" event that happened at an earlier time is not
         # masked by multiple subsequent events in the same second.
         self.login_as(user=self.user)
 
-        group = self.create_group()
-
-        before = self.create_event(
-            event_id='a',
-            group=group,
-            datetime=datetime(2013, 8, 13, 3, 8, 23),
+        before = self.store_event(
+            data={
+                'event_id': 'a' * 32,
+                'timestamp': self.two_min_ago,
+                'fingerprint': ['group-1'],
+            },
+            project_id=self.project.id
         )
 
-        event = self.create_event(
-            event_id='b',
-            group=group,
-            datetime=datetime(2013, 8, 13, 3, 8, 24),
+        event = self.store_event(
+            data={
+                'event_id': 'b' * 32,
+                'timestamp': self.min_ago,
+                'fingerprint': ['group-1'],
+            },
+            project_id=self.project.id
         )
 
         # Masking events: same time as event, but higher ids
-        for eid in 'cdefg':
-            self.create_event(
-                event_id=eid,
-                group=group,
-                datetime=datetime(2013, 8, 13, 3, 8, 24),
+        for eid in 'cdef':
+            self.store_event(
+                data={
+                    'event_id': eid * 32,
+                    'timestamp': self.min_ago,
+                    'fingerprint': ['group-1'],
+                },
+                project_id=self.project.id
             )
 
         url = reverse(
@@ -308,4 +329,4 @@ class EventDetailsTest(APITestCase):
 
         assert response.status_code == 200, response.content
         assert response.data['id'] == six.text_type(event.id)
-        assert response.data['previousEventID'] == six.text_type(before.id)
+        assert response.data['previousEventID'] == six.text_type(before.event_id)
diff --git a/tests/snuba/api/endpoints/test_project_event_details.py b/tests/snuba/api/endpoints/test_project_event_details.py
new file mode 100644
index 0000000000..1bd18df6ac
--- /dev/null
+++ b/tests/snuba/api/endpoints/test_project_event_details.py
@@ -0,0 +1,182 @@
+from __future__ import absolute_import
+
+import six
+
+from datetime import timedelta
+from django.utils import timezone
+from django.core.urlresolvers import reverse
+from sentry import options
+from sentry.testutils import APITestCase, SnubaTestCase
+
+
+class ProjectEventDetailsTest(APITestCase, SnubaTestCase):
+    def setUp(self):
+        super(ProjectEventDetailsTest, self).setUp()
+        self.login_as(user=self.user)
+        project = self.create_project()
+
+        one_min_ago = (timezone.now() - timedelta(minutes=1)).isoformat()[:19]
+        two_min_ago = (timezone.now() - timedelta(minutes=2)).isoformat()[:19]
+        three_min_ago = (timezone.now() - timedelta(minutes=3)).isoformat()[:19]
+
+        self.prev_event = self.store_event(
+            data={
+                'event_id': 'a' * 32,
+                'timestamp': three_min_ago,
+                'fingerprint': ['group-1']
+            },
+            project_id=project.id
+        )
+        self.cur_event = self.store_event(
+            data={
+                'event_id': 'b' * 32,
+                'timestamp': two_min_ago,
+                'fingerprint': ['group-1']
+            },
+            project_id=project.id
+        )
+        self.next_event = self.store_event(
+            data={
+                'event_id': 'c' * 32,
+                'timestamp': one_min_ago,
+                'fingerprint': ['group-1'],
+                'environment': 'production',
+                'tags': {'environment': 'production'}
+            },
+            project_id=project.id
+        )
+
+    def test_simple(self):
+        url = reverse(
+            'sentry-api-0-project-event-details',
+            kwargs={
+                'event_id': self.cur_event.event_id,
+                'project_slug': self.cur_event.project.slug,
+                'organization_slug': self.cur_event.project.organization.slug,
+            }
+        )
+        response = self.client.get(url, format='json')
+
+        assert response.status_code == 200, response.content
+        assert response.data['id'] == six.text_type(self.cur_event.id)
+        assert response.data['nextEventID'] == six.text_type(self.next_event.event_id)
+        assert response.data['previousEventID'] == six.text_type(self.prev_event.event_id)
+        assert response.data['groupID'] == six.text_type(self.cur_event.group.id)
+
+        # Same event can be looked up by primary key
+        url = reverse(
+            'sentry-api-0-project-event-details',
+            kwargs={
+                'event_id': self.cur_event.id,
+                'project_slug': self.cur_event.project.slug,
+                'organization_slug': self.cur_event.project.organization.slug,
+            }
+        )
+        response = self.client.get(url, format='json')
+
+        assert response.status_code == 200, response.content
+        assert response.data['id'] == six.text_type(self.cur_event.id)
+        assert response.data['nextEventID'] == six.text_type(self.next_event.event_id)
+        assert response.data['previousEventID'] == six.text_type(self.prev_event.event_id)
+        assert response.data['groupID'] == six.text_type(self.cur_event.group.id)
+
+    def test_prev_has_no_prev(self):
+        # Test that the "previous" event does not itself have a "previousEventID"
+        # pointing back to the current event. i.e. test that there is not a redirect
+        # loop between next and previous events that occur within the same second.
+
+        url = reverse(
+            'sentry-api-0-project-event-details',
+            kwargs={
+                'event_id': self.prev_event.event_id,
+                'project_slug': self.prev_event.project.slug,
+                'organization_slug': self.prev_event.project.organization.slug,
+            }
+        )
+        response = self.client.get(url, format='json')
+
+        assert response.status_code == 200, response.content
+        assert response.data['id'] == six.text_type(self.prev_event.id)
+        assert response.data['previousEventID'] is None
+        assert response.data['nextEventID'] == self.cur_event.event_id
+        assert response.data['groupID'] == six.text_type(self.prev_event.group.id)
+
+    def test_snuba(self):
+        options.set('snuba.events-queries.enabled', True)
+        url = reverse(
+            'sentry-api-0-project-event-details',
+            kwargs={
+                'event_id': self.cur_event.event_id,
+                'project_slug': self.cur_event.project.slug,
+                'organization_slug': self.cur_event.project.organization.slug,
+            }
+        )
+        response = self.client.get(url, format='json', data={
+            'enable_snuba': '1',
+        })
+
+        assert response.status_code == 200, response.content
+        assert response.data['id'] == six.text_type(self.cur_event.event_id)
+        assert response.data['nextEventID'] == six.text_type(self.next_event.event_id)
+        assert response.data['previousEventID'] == six.text_type(self.prev_event.event_id)
+        assert response.data['groupID'] == six.text_type(self.cur_event.group.id)
+
+        # Same event can be looked up by primary key
+        url = reverse(
+            'sentry-api-0-project-event-details',
+            kwargs={
+                'event_id': self.cur_event.id,
+                'project_slug': self.cur_event.project.slug,
+                'organization_slug': self.cur_event.project.organization.slug,
+            }
+        )
+        response = self.client.get(url, format='json', data={
+            'enable_snuba': '1',
+        })
+
+        assert response.status_code == 200, response.content
+        assert response.data['id'] == six.text_type(self.cur_event.event_id)
+        assert response.data['nextEventID'] == six.text_type(self.next_event.event_id)
+        assert response.data['previousEventID'] == six.text_type(self.prev_event.event_id)
+        assert response.data['groupID'] == six.text_type(self.cur_event.group.id)
+
+    def test_snuba_no_prev(self):
+        options.set('snuba.events-queries.enabled', True)
+        url = reverse(
+            'sentry-api-0-project-event-details',
+            kwargs={
+                'event_id': self.prev_event.event_id,
+                'project_slug': self.prev_event.project.slug,
+                'organization_slug': self.prev_event.project.organization.slug,
+            }
+        )
+        response = self.client.get(url, format='json', data={
+            'enable_snuba': '1'
+        })
+
+        assert response.status_code == 200, response.content
+        assert response.data['id'] == six.text_type(self.prev_event.event_id)
+        assert response.data['previousEventID'] is None
+        assert response.data['nextEventID'] == self.cur_event.event_id
+        assert response.data['groupID'] == six.text_type(self.prev_event.group.id)
+
+    def test_snuba_with_environment(self):
+        options.set('snuba.events-queries.enabled', True)
+        url = reverse(
+            'sentry-api-0-project-event-details',
+            kwargs={
+                'event_id': self.cur_event.event_id,
+                'project_slug': self.cur_event.project.slug,
+                'organization_slug': self.cur_event.project.organization.slug,
+            }
+        )
+        response = self.client.get(url, format='json', data={
+            'enable_snuba': '1',
+            'environment': ['production', 'staging']
+        })
+
+        assert response.status_code == 200, response.content
+        assert response.data['id'] == six.text_type(self.cur_event.event_id)
+        assert response.data['previousEventID'] is None
+        assert response.data['nextEventID'] == self.next_event.event_id
+        assert response.data['groupID'] == six.text_type(self.prev_event.group.id)

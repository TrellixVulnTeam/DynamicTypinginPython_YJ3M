commit 6d5fd832bbe36cec12842cf86e48cda7506b5fde
Author: ted kaemming <ted@kaemming.com>
Date:   Tue Apr 17 14:48:33 2018 -0700

    ref(services): Handle reentrant service calls without delegation (#8074)

diff --git a/src/sentry/utils/services.py b/src/sentry/utils/services.py
index e58a9c532b..2c55eda5a3 100644
--- a/src/sentry/utils/services.py
+++ b/src/sentry/utils/services.py
@@ -4,7 +4,7 @@ import functools
 import inspect
 import itertools
 import logging
-import operator
+import threading
 
 from django.utils.functional import empty, LazyObject
 
@@ -177,6 +177,12 @@ class ServiceDelegator(Service):
         function.
         """
 
+    class ServiceState(threading.local):
+        def __init__(self):
+            self.backends = {}
+
+    state = ServiceState()
+
     def __init__(self, backend_base, backends, selector_func, callback_func=None):
         self.__backend_base = import_string(backend_base)
 
@@ -228,6 +234,12 @@ class ServiceDelegator(Service):
             return base_value
 
         def execute(*args, **kwargs):
+            # If this thread already has an active backend for this base class,
+            # we can safely call that backend synchronously without delegating.
+            if self in self.state.backends:
+                backend = type(self).state.backends[self.__backend_base]
+                return getattr(backend, attribute_name)(*args, **kwargs)
+
             # Binding the call arguments to named arguments has two benefits:
             # 1. These values always be passed in the same form to the selector
             #    function and callback, regardless of how they were passed to
@@ -250,7 +262,23 @@ class ServiceDelegator(Service):
                     '{!r} is not a registered backend.'.format(
                         selected_backend_names[0]))
 
-            call_backend_method = operator.methodcaller(attribute_name, *args, **kwargs)
+            def call_backend_method(backend):
+                base = self.__backend_base
+                active_backends = type(self).state.backends
+
+                # Ensure that we haven't somehow accidentally entered a context
+                # where the backend we're calling has already been marked as
+                # active (or worse, some other backend is already active.)
+                assert base not in active_backends
+
+                # Mark the backend as active.
+                active_backends[base] = backend
+                try:
+                    return getattr(backend, attribute_name)(*args, **kwargs)
+                finally:
+                    # Unmark the backend as active.
+                    assert active_backends[base] is backend
+                    del active_backends[base]
 
             # Enqueue all of the secondary backend requests first since these
             # are non-blocking queue insertions. (Since the primary backend

commit 9d8387faafecb23e5daafe904f47d5945a33657a
Author: Armin Ronacher <armin.ronacher@active-4.com>
Date:   Wed May 3 13:43:22 2017 +0200

    Kill legacy apple reports

diff --git a/src/sentry/lang/native/plugin.py b/src/sentry/lang/native/plugin.py
index 00510b3820..35534d38b7 100644
--- a/src/sentry/lang/native/plugin.py
+++ b/src/sentry/lang/native/plugin.py
@@ -1,9 +1,5 @@
 from __future__ import absolute_import
 
-import os
-import re
-import six
-import time
 import logging
 import posixpath
 
@@ -14,13 +10,11 @@ from symsynd.images import ImageLookup
 
 from sentry import options
 from django.db import transaction, IntegrityError
-from sentry.models import Project, EventError, VersionDSymFile, DSymPlatform, \
-    DSymApp
+from sentry.models import VersionDSymFile, DSymPlatform, DSymApp
 from sentry.plugins import Plugin2
 from sentry.lang.native.symbolizer import Symbolizer, SymbolicationFailed
 from sentry.lang.native.utils import \
-    find_apple_crash_report_referenced_images, get_sdk_from_event, \
-    get_sdk_from_apple_system_info, cpu_name_from_data, APPLE_SDK_MAPPING, \
+    get_sdk_from_event, cpu_name_from_data, \
     rebase_addr, version_build_from_data
 from sentry.lang.native.systemsymbols import lookup_system_symbols
 from sentry.utils import metrics
@@ -33,324 +27,6 @@ logger = logging.getLogger(__name__)
 
 
 FRAME_CACHE_VERSION = 4
-model_re = re.compile(r'^(\S+?)\d')
-
-APP_BUNDLE_PATHS = (
-    '/var/containers/Bundle/Application/',
-    '/private/var/containers/Bundle/Application/',
-)
-SIM_PATH = '/Developer/CoreSimulator/Devices/'
-SIM_APP_PATH = '/Containers/Bundle/Application/'
-
-NON_APP_FRAMEWORKS = (
-    '/Frameworks/libswiftCore.dylib',
-)
-
-SIGNAL_NAMES = {
-    1: 'SIGHUP',
-    2: 'SIGINT',
-    3: 'SIGQUIT',
-    4: 'SIGILL',
-    5: 'SIGTRAP',
-    6: 'SIGABRT',
-    7: 'SIGEMT',
-    8: 'SIGFPE',
-    9: 'SIGKILL',
-    10: 'SIGBUS',
-    11: 'SIGSEGV',
-    12: 'SIGSYS',
-    13: 'SIGPIPE',
-    14: 'SIGALRM',
-    15: 'SIGTERM',
-    16: 'SIGURG',
-    17: 'SIGSTOP',
-    18: 'SIGTSTP',
-    19: 'SIGCONT',
-    20: 'SIGCHLD',
-    21: 'SIGTTIN',
-    22: 'SIGTTOU',
-    24: 'SIGXCPU',
-    25: 'SIGXFSZ',
-    26: 'SIGVTALRM',
-    27: 'SIGPROF',
-    28: 'SIGWINCH',
-    29: 'SIGINFO',
-    31: 'SIGUSR2',
-}
-
-
-def append_error(data, err):
-    data.setdefault('errors', []).append(err)
-
-
-def process_posix_signal(data):
-    # XXX: kill me
-    signal = data.get('signal', -1)
-    signal_name = data.get('name')
-    if signal_name is None:
-        signal_name = SIGNAL_NAMES.get(signal)
-    return {
-        'signal': signal,
-        'name': signal_name,
-        'code': data.get('code'),
-        'code_name': data.get('code_name'),
-    }
-
-
-def exception_from_apple_error_or_diagnosis(error, diagnosis=None):
-    # XXX: kill me
-    rv = {}
-    error = error or {}
-
-    mechanism = {}
-    if 'mach' in error:
-        mechanism['mach_exception'] = error['mach']
-    if 'signal' in error:
-        mechanism['posix_signal'] = process_posix_signal(error['signal'])
-    if mechanism:
-        mechanism.setdefault('type', 'cocoa')
-        rv['mechanism'] = mechanism
-
-    # Start by getting the error from nsexception
-    if error:
-        nsexception = error.get('nsexception')
-        if nsexception:
-            rv['type'] = nsexception['name']
-            if 'value' in nsexception:
-                rv['value'] = nsexception['value']
-
-    # If we don't have an error yet, try to build one from reason and
-    # diagnosis
-    if 'value' not in rv:
-        if 'reason' in error:
-            rv['value'] = error['reason']
-        elif 'diagnosis' in error:
-            rv['value'] = error['diagnosis']
-        elif 'mach_exception' in mechanism:
-            rv['value'] = mechanism['mach_exception'] \
-                .get('exception_name') or 'Mach Exception'
-        elif 'posix_signal' in mechanism:
-            rv['value'] = mechanism['posix_signal'] \
-                .get('name') or 'Posix Signal'
-        else:
-            rv['value'] = 'Unknown'
-
-    # Figure out a reasonable type
-    if 'type' not in rv:
-        if 'mach_exception' in mechanism:
-            rv['type'] = 'MachException'
-        elif 'posix_signal' in mechanism:
-            rv['type'] = 'Signal'
-        else:
-            rv['type'] = 'Unknown'
-
-    if rv:
-        return rv
-
-
-def is_in_app(frame, app_uuid=None):
-    # XXX: kill me
-    if app_uuid is not None:
-        frame_uuid = frame.get('uuid')
-        if frame_uuid == app_uuid:
-            return True
-    fn = frame.get('package') or ''
-    if not (fn.startswith(APP_BUNDLE_PATHS) or
-            (SIM_PATH in fn and SIM_APP_PATH in fn)):
-        return False
-    if fn.endswith(NON_APP_FRAMEWORKS):
-        return False
-    return True
-
-
-def convert_stacktrace(frames, system=None, notable_addresses=None):
-    # XXX: kill me
-    app_uuid = None
-    if system:
-        app_uuid = system.get('app_uuid')
-        if app_uuid is not None:
-            app_uuid = app_uuid.lower()
-
-    converted_frames = []
-    for frame in reversed(frames):
-        fn = frame.get('filename')
-
-        # We only record the offset if we found a symbol but we did not
-        # find a line number.  In that case it's the offset in bytes from
-        # the beginning of the symbol.
-        function = frame.get('symbol_name') or NATIVE_UNKNOWN_STRING
-        lineno = frame.get('line')
-
-        cframe = {
-            'abs_path': fn,
-            'filename': fn and posixpath.basename(fn) or None,
-            # This can come back as `None` from the symbolizer, in which
-            # case we need to fill something else in or we will fail
-            # later fulfill the interface requirements which say that a
-            # function needs to be provided.
-            'function': function,
-            'package': frame.get('object_name'),
-            'symbol_addr': '0x%x' % frame['symbol_addr'],
-            'instruction_addr': '0x%x' % frame['instruction_addr'],
-            'lineno': lineno,
-        }
-        cframe['in_app'] = is_in_app(cframe, app_uuid)
-        converted_frames.append(cframe)
-
-    if converted_frames and notable_addresses:
-        converted_frames[-1]['vars'] = notable_addresses
-
-    if converted_frames:
-        return {'frames': converted_frames}
-
-
-def inject_apple_backtrace(data, frames, diagnosis=None, error=None,
-                           system=None, notable_addresses=None,
-                           thread_id=None):
-    stacktrace = convert_stacktrace(frames, system, notable_addresses)
-
-    if error or diagnosis:
-        error = error or {}
-        exc = exception_from_apple_error_or_diagnosis(error, diagnosis)
-        if exc is not None:
-            exc['stacktrace'] = stacktrace
-            exc['thread_id'] = thread_id
-            data['sentry.interfaces.Exception'] = {'values': [exc]}
-            # Since we inject the exception late we need to make sure that
-            # we set the event type to error as it would be set to
-            # 'default' otherwise.
-            data['type'] = 'error'
-            return True
-
-    data['sentry.interfaces.Stacktrace'] = stacktrace
-    return False
-
-
-def inject_apple_device_data(data, system):
-    contexts = data.setdefault('contexts', {})
-
-    device = contexts.setdefault('device', {})
-    os = contexts.setdefault('os', {})
-
-    try:
-        os['name'] = APPLE_SDK_MAPPING[system['system_name']]
-    except LookupError:
-        os['name'] = system.get('system_name') or 'Generic Apple'
-
-    if 'system_version' in system:
-        os['version'] = system['system_version']
-    if 'os_version' in system:
-        os['build'] = system['os_version']
-    if 'kernel_version' in system:
-        os['kernel_version'] = system['kernel_version']
-    if 'jailbroken' in system:
-        os['rooted'] = system['jailbroken']
-
-    if 'cpu_arch' in system:
-        device['arch'] = system['cpu_arch']
-    if 'model' in system:
-        device['model_id'] = system['model']
-    if 'machine' in system:
-        device['model'] = system['machine']
-        match = model_re.match(system['machine'])
-        if match is not None:
-            device['family'] = match.group(1)
-
-
-def dump_crash_report(report):
-    import json
-    with open('/tmp/sentry-apple-crash-report-%s.json' % time.time(), 'w') as f:
-        json.dump(report, f, indent=2)
-
-
-def preprocess_apple_crash_event(data):
-    """This processes the "legacy" AppleCrashReport."""
-    crash_report = data['sentry.interfaces.AppleCrashReport']
-
-    if os.environ.get('SENTRY_DUMP_APPLE_CRASH_REPORT') == '1':
-        dump_crash_report(crash_report)
-
-    project = Project.objects.get_from_cache(
-        id=data['project'],
-    )
-
-    system = None
-    errors = []
-    threads = []
-    crash = crash_report['crash']
-    crashed_thread = None
-
-    threads = {}
-    raw_threads = {}
-    for raw_thread in crash['threads']:
-        if raw_thread['crashed'] and raw_thread.get('backtrace'):
-            crashed_thread = raw_thread
-        raw_threads[raw_thread['index']] = raw_thread
-        threads[raw_thread['index']] = {
-            'id': raw_thread['index'],
-            'name': raw_thread.get('name'),
-            'current': raw_thread.get('current_thread', False),
-            'crashed': raw_thread.get('crashed', False),
-        }
-
-    sdk_info = get_sdk_from_apple_system_info(system)
-    referenced_images = find_apple_crash_report_referenced_images(
-        crash_report['binary_images'], raw_threads.values())
-    sym = Symbolizer(project, crash_report['binary_images'],
-                     cpu_name=cpu_name_from_data(data),
-                     referenced_images=referenced_images)
-
-    try:
-        if crashed_thread is None:
-            append_error(data, {
-                'type': EventError.NATIVE_NO_CRASHED_THREAD,
-            })
-        else:
-            system = crash_report.get('system')
-            try:
-                bt, errors = sym.symbolize_backtrace(
-                    crashed_thread['backtrace']['contents'], sdk_info)
-                for error in errors:
-                    append_error(data, error)
-                if inject_apple_backtrace(data, bt, crash.get('diagnosis'),
-                                          crash.get('error'), system,
-                                          crashed_thread.get('notable_addresses'),
-                                          crashed_thread['index']):
-                    # We recorded an exception, so in this case we can
-                    # skip having the stacktrace.
-                    threads[crashed_thread['index']]['stacktrace'] = None
-            except Exception:
-                logger.exception('Failed to symbolicate')
-                errors.append({
-                    'type': EventError.NATIVE_INTERNAL_FAILURE,
-                    'error': 'The symbolicator encountered an internal failure',
-                })
-
-        for thread in six.itervalues(threads):
-            # If we were told to skip the stacktrace, skip it indeed
-            if thread.get('stacktrace', Ellipsis) is None:
-                continue
-            raw_thread = raw_threads.get(thread['id'])
-            if raw_thread is None or not raw_thread.get('backtrace'):
-                continue
-            bt, errors = sym.symbolize_backtrace(
-                raw_thread['backtrace']['contents'], sdk_info)
-            for error in errors:
-                append_error(data, error)
-            thread['stacktrace'] = convert_stacktrace(
-                bt, system, raw_thread.get('notable_addresses'))
-    finally:
-        sym.close()
-
-    if threads:
-        data['threads'] = {
-            'values': sorted(threads.values(), key=lambda x: x['id']),
-        }
-
-    if system:
-        inject_apple_device_data(data, system)
-
-    return data
 
 
 class NativeStacktraceProcessor(StacktraceProcessor):
@@ -613,12 +289,6 @@ class NativeStacktraceProcessor(StacktraceProcessor):
 class NativePlugin(Plugin2):
     can_disable = False
 
-    def get_event_preprocessors(self, data, **kwargs):
-        rv = []
-        if data.get('sentry.interfaces.AppleCrashReport'):
-            rv.append(preprocess_apple_crash_event)
-        return rv
-
     def get_stacktrace_processors(self, data, stacktrace_infos,
                                   platforms, **kwargs):
         if 'cocoa' in platforms:
diff --git a/src/sentry/lang/native/utils.py b/src/sentry/lang/native/utils.py
index 98625244ac..5fa71fd508 100644
--- a/src/sentry/lang/native/utils.py
+++ b/src/sentry/lang/native/utils.py
@@ -13,13 +13,6 @@ from sentry.interfaces.contexts import DeviceContextType
 logger = logging.getLogger(__name__)
 
 
-APPLE_SDK_MAPPING = {
-    'iPhone OS': 'iOS',
-    'tvOS': 'tvOS',
-    'Mac OS': 'macOS',
-    'watchOS': 'watchOS',
-}
-
 KNOWN_DSYM_TYPES = {
     'iOS': 'macho',
     'tvOS': 'macho',
@@ -30,24 +23,6 @@ KNOWN_DSYM_TYPES = {
 AppInfo = namedtuple('AppInfo', ['id', 'version', 'build', 'name'])
 
 
-def find_apple_crash_report_referenced_images(binary_images, threads):
-    """Given some binary images from an apple crash report and a thread
-    list this returns a list of image UUIDs to load.
-    """
-    image_map = {}
-    for image in binary_images:
-        image_map[image['image_addr']] = image['uuid']
-    to_load = set()
-    for thread in threads:
-        if 'backtrace' not in thread:
-            continue
-        for frame in thread['backtrace']['contents']:
-            img_uuid = image_map.get(frame['object_addr'])
-            if img_uuid is not None:
-                to_load.add(img_uuid)
-    return list(to_load)
-
-
 def find_all_stacktraces(data):
     """Given a data dictionary from an event this returns all
     relevant stacktraces in a list.  If a frame contains a raw_stacktrace
@@ -113,29 +88,6 @@ def get_sdk_from_os(data):
     }
 
 
-def get_sdk_from_apple_system_info(info):
-    if not info:
-        return None
-    try:
-        # Support newer mapping in old format.
-        if info['system_name'] in KNOWN_DSYM_TYPES:
-            sdk_name = info['system_name']
-        else:
-            sdk_name = APPLE_SDK_MAPPING[info['system_name']]
-        system_version = tuple(int(x) for x in (
-            info['system_version'] + '.0' * 3).split('.')[:3])
-    except (ValueError, LookupError):
-        return None
-
-    return {
-        'dsym_type': 'macho',
-        'sdk_name': sdk_name,
-        'version_major': system_version[0],
-        'version_minor': system_version[1],
-        'version_patchlevel': system_version[2],
-    }
-
-
 def cpu_name_from_data(data):
     """Returns the CPU name from the given data if it exists."""
     device = DeviceContextType.primary_value_for_data(data)

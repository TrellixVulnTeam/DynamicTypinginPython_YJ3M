commit 91a4d494d2bd60576b61bf2b9873fa604be3b5fb
Author: David Cramer <dcramer@gmail.com>
Date:   Thu Feb 5 08:17:15 2015 -0800

    Clean up origin parsing abstraction

diff --git a/src/sentry/utils/http.py b/src/sentry/utils/http.py
index caefc275a9..f5344122b7 100644
--- a/src/sentry/utils/http.py
+++ b/src/sentry/utils/http.py
@@ -10,10 +10,14 @@ from __future__ import absolute_import
 import six
 import urllib
 
+from collections import namedtuple
 from django.conf import settings
 from urlparse import urlparse, urljoin
 
 
+ParsedUriMatch = namedtuple('ParsedUriMatch', ['scheme', 'domain', 'path'])
+
+
 def absolute_uri(url=None):
     if not url:
         return settings.SENTRY_URL_PREFIX
@@ -78,6 +82,20 @@ def get_origins(project=None):
     return frozenset(filter(bool, map(lambda x: x.lower().rstrip('/'), result)))
 
 
+def parse_uri_match(value):
+    if '://' in value:
+        scheme, value = value.split('://', 1)
+    else:
+        scheme = '*'
+
+    if '/' in value:
+        domain, path = value.split('/', 1)
+    else:
+        domain, path = value, '*'
+
+    return ParsedUriMatch(scheme, domain, path)
+
+
 def is_valid_origin(origin, project=None):
     """
     Given an ``origin`` which matches a base URI (e.g. http://example.com)
@@ -115,30 +133,27 @@ def is_valid_origin(origin, project=None):
     if parsed.hostname is None:
         return False
 
-    for valid in allowed:
-        if '://' in valid:
-            scheme, valid = valid.split('://', 1)
-            if parsed.scheme != scheme:
-                continue
+    for value in allowed:
+        bits = parse_uri_match(value)
 
-        # Support partial uri matches that may include path
-        if '/' in valid and origin.startswith(valid):
-            return True
-
-        if valid == '*':
-            return True
-
-        # Support matches ending with glob
-        if valid.endswith('*'):
-            valid = valid[:-1]
+        # scheme supports exact and any match
+        if bits.scheme not in ('*', parsed.scheme):
+            continue
 
-        if valid[:2] == '*.':
-            # check foo.domain.com and domain.com
-            if parsed.hostname.endswith(valid[1:]) or parsed.hostname == valid[2:]:
+        # domain supports exact, any, and prefix match
+        if bits.domain[:2] == '*.':
+            if parsed.hostname.endswith(bits.domain[1:]) or parsed.hostname == bits.domain[2:]:
                 return True
             continue
+        elif bits.domain not in ('*', parsed.hostname):
+            continue
 
-        if parsed.hostname == valid:
+        # path supports exact, any, and suffix match (with or without *)
+        path = bits.path
+        if path == '*':
+            return True
+        if path.endswith('*'):
+            path = path[:-1]
+        if parsed.path.startswith(path):
             return True
-
     return False

commit 604a84c04b4197cdfd69a93959c2a4526279346a
Author: Radu Woinaroski <5281987+RaduW@users.noreply.github.com>
Date:   Thu Jun 25 15:40:50 2020 +0200

    feat(settings): Update organization relay-keys to new structure (#19445)
    
    Update relay-keys structure to enable key management by external organizations

diff --git a/src/sentry/api/endpoints/organization_details.py b/src/sentry/api/endpoints/organization_details.py
index 1ded72dcbf..67eb841fd5 100644
--- a/src/sentry/api/endpoints/organization_details.py
+++ b/src/sentry/api/endpoints/organization_details.py
@@ -3,6 +3,9 @@ from __future__ import absolute_import
 import logging
 import six
 
+from datetime import datetime
+
+from dateutil.tz import UTC
 from rest_framework import serializers, status
 from uuid import uuid4
 
@@ -14,8 +17,12 @@ from sentry.api.fields import AvatarField
 from sentry.api.fields.empty_integer import EmptyIntegerField
 from sentry.api.serializers import serialize
 from sentry.api.serializers.models import organization as org_serializers
+from sentry.api.serializers.models.organization import TrustedRelaySerializer
 from sentry.api.serializers.rest_framework import ListField
-from sentry.constants import LEGACY_RATE_LIMIT_OPTIONS, RESERVED_ORGANIZATION_SLUGS
+from sentry.constants import (
+    LEGACY_RATE_LIMIT_OPTIONS,
+    RESERVED_ORGANIZATION_SLUGS,
+)
 from sentry.datascrubbing import validate_pii_config_update
 from sentry.lang.native.utils import STORE_CRASH_REPORTS_DEFAULT, convert_crashreport_count
 from sentry.models import (
@@ -90,7 +97,6 @@ ORG_OPTIONS = (
         org_serializers.REQUIRE_SCRUB_IP_ADDRESS_DEFAULT,
     ),
     ("relayPiiConfig", "sentry:relay_pii_config", six.text_type, None),
-    ("trustedRelays", "sentry:trusted-relays", list, org_serializers.TRUSTED_RELAYS_DEFAULT),
     ("allowJoinRequests", "sentry:join_requests", bool, org_serializers.JOIN_REQUESTS_DEFAULT),
 )
 
@@ -146,7 +152,7 @@ class OrganizationSerializer(serializers.Serializer):
     scrapeJavaScript = serializers.BooleanField(required=False)
     isEarlyAdopter = serializers.BooleanField(required=False)
     require2FA = serializers.BooleanField(required=False)
-    trustedRelays = ListField(child=serializers.CharField(), required=False)
+    trustedRelays = ListField(child=TrustedRelaySerializer(), required=False)
     allowJoinRequests = serializers.BooleanField(required=False)
     relayPiiConfig = serializers.CharField(required=False, allow_blank=True, allow_null=True)
 
@@ -220,6 +226,18 @@ class OrganizationSerializer(serializers.Serializer):
             raise serializers.ValidationError(
                 "Organization does not have the relay feature enabled"
             )
+
+        # make sure we don't have multiple instances of one public key
+        public_keys = set()
+        if value is not None:
+            for key_info in value:
+                key = key_info.get("public_key")
+                if key in public_keys:
+                    raise serializers.ValidationError(
+                        "Duplicated key in Trusted Relays: '{}'".format(key)
+                    )
+                public_keys.add(key)
+
         return value
 
     def validate_accountRateLimit(self, value):
@@ -248,6 +266,57 @@ class OrganizationSerializer(serializers.Serializer):
                 )
         return attrs
 
+    def save_trusted_relays(self, incoming, changed_data, organization):
+        timestamp_now = datetime.utcnow().replace(tzinfo=UTC).isoformat()
+        option_key = "sentry:trusted-relays"
+        try:
+            # get what we already have
+            existing = OrganizationOption.objects.get(organization=organization, key=option_key)
+
+            key_dict = {val.get("public_key"): val for val in existing.value}
+            original_number_of_keys = len(existing.value)
+        except OrganizationOption.DoesNotExist:
+            key_dict = {}  # we don't have anything set
+            original_number_of_keys = 0
+            existing = None
+
+        modified = False
+        for option in incoming:
+            public_key = option.get("public_key")
+            existing_info = key_dict.get(public_key, {})
+
+            option["created"] = existing_info.get("created", timestamp_now)
+            option["last_modified"] = existing_info.get("last_modified")
+
+            # check if we modified the current public_key info and update last_modified if we did
+            if (
+                not existing_info
+                or existing_info.get("name") != option.get("name")
+                or existing_info.get("description") != option.get("description")
+            ):
+                option["last_modified"] = timestamp_now
+                modified = True
+
+        # check to see if the only modifications were some deletions (which are not captured in the loop above)
+        if len(incoming) != original_number_of_keys:
+            modified = True
+
+        if modified:
+            # we have some modifications create a log message
+            if existing is not None:
+                # generate an update log message
+                changed_data["trustedRelays"] = u"from {} to {}".format(existing, incoming)
+                existing.value = incoming
+                existing.save()
+            else:
+                # first time we set trusted relays, generate a create log message
+                changed_data["trustedRelays"] = u"to {}".format(incoming)
+                OrganizationOption.objects.set_value(
+                    organization=organization, key=option_key, value=incoming
+                )
+
+        return incoming
+
     def save(self):
         org = self.context["organization"]
         changed_data = {}
@@ -272,6 +341,10 @@ class OrganizationSerializer(serializers.Serializer):
                     changed_data[key] = u"from {} to {}".format(old_val, option_inst.value)
                 option_inst.save()
 
+        trusted_realy_info = self.validated_data.get("trustedRelays")
+        if trusted_realy_info is not None:
+            self.save_trusted_relays(trusted_realy_info, changed_data, org)
+
         if "openMembership" in self.initial_data:
             org.flags.allow_joinleave = self.initial_data["openMembership"]
         if "allowSharedIssues" in self.initial_data:
@@ -364,6 +437,7 @@ class OrganizationDetailsEndpoint(OrganizationEndpoint):
             else org_serializers.DetailedOrganizationSerializer
         )
         context = serialize(organization, request.user, serializer(), access=request.access)
+
         return self.respond(context)
 
     @attach_scenarios([update_organization_scenario])
@@ -418,14 +492,14 @@ class OrganizationDetailsEndpoint(OrganizationEndpoint):
                     data=changed_data,
                 )
 
-            return self.respond(
-                serialize(
-                    organization,
-                    request.user,
-                    org_serializers.DetailedOrganizationSerializerWithProjectsAndTeams(),
-                    access=request.access,
-                )
+            context = serialize(
+                organization,
+                request.user,
+                org_serializers.DetailedOrganizationSerializerWithProjectsAndTeams(),
+                access=request.access,
             )
+
+            return self.respond(context)
         return self.respond(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
 
     def handle_delete(self, request, organization):
diff --git a/src/sentry/api/serializers/models/organization.py b/src/sentry/api/serializers/models/organization.py
index fc33e9a37d..336e6210f0 100644
--- a/src/sentry/api/serializers/models/organization.py
+++ b/src/sentry/api/serializers/models/organization.py
@@ -1,6 +1,10 @@
 from __future__ import absolute_import
 
 import six
+from rest_framework import serializers
+
+from sentry_relay.auth import PublicKey
+from sentry_relay.exceptions import RelayError
 
 from sentry import roles
 from sentry.app import quotas
@@ -17,7 +21,6 @@ from sentry.constants import (
     ATTACHMENTS_ROLE_DEFAULT,
     REQUIRE_SCRUB_IP_ADDRESS_DEFAULT,
     SCRAPE_JAVASCRIPT_DEFAULT,
-    TRUSTED_RELAYS_DEFAULT,
     JOIN_REQUESTS_DEFAULT,
     EVENTS_MEMBER_ADMIN_DEFAULT,
 )
@@ -38,6 +41,58 @@ from sentry.models import (
 )
 
 
+class TrustedRelaySerializer(serializers.Serializer):
+    internal_external = (
+        (u"name", u"name"),
+        (u"description", u"description"),
+        (u"public_key", u"publicKey"),
+        (u"created", u"created"),
+        (u"last_modified", u"lastModified"),
+    )
+
+    def to_representation(self, instance):
+        ret_val = {}
+        for internal_key, external_key in TrustedRelaySerializer.internal_external:
+            val = instance.get(internal_key)
+            if val is not None:
+                ret_val[external_key] = val
+        return ret_val
+
+    def to_internal_value(self, data):
+        try:
+            key_name = data.get(u"name")
+            public_key = data.get(u"publicKey") or ""
+            description = data.get(u"description")
+        except AttributeError:
+            raise serializers.ValidationError("Bad structure received for Trusted Relays")
+
+        if key_name is None:
+            raise serializers.ValidationError("Relay key info with missing name in Trusted Relays")
+
+        key_name = key_name.strip()
+
+        if len(key_name) == 0:
+            raise serializers.ValidationError("Relay key info with empty name in Trusted Relays")
+
+        if len(public_key) == 0:
+            raise serializers.ValidationError(
+                "Missing public key for relay key info with name:'{}' in Trusted Relays".format(
+                    key_name
+                )
+            )
+
+        try:
+            PublicKey.parse(public_key)
+        except RelayError:
+            raise serializers.ValidationError(
+                "Invalid public key for relay key info with name:'{}' in Trusted Relays".format(
+                    key_name
+                )
+            )
+
+        return {u"public_key": public_key, u"name": key_name, u"description": description}
+
+
 @register(Organization)
 class OrganizationSerializer(Serializer):
     def get_attrs(self, item_list, user):
@@ -204,8 +259,6 @@ class DetailedOrganizationSerializer(OrganizationSerializer):
                 "scrapeJavaScript": bool(
                     obj.get_option("sentry:scrape_javascript", SCRAPE_JAVASCRIPT_DEFAULT)
                 ),
-                "trustedRelays": obj.get_option("sentry:trusted-relays", TRUSTED_RELAYS_DEFAULT)
-                or [],
                 "allowJoinRequests": bool(
                     obj.get_option("sentry:join_requests", JOIN_REQUESTS_DEFAULT)
                 ),
@@ -213,6 +266,11 @@ class DetailedOrganizationSerializer(OrganizationSerializer):
                 or None,
             }
         )
+
+        trusted_relays_raw = obj.get_option("sentry:trusted-relays") or []
+        # serialize trusted relays info into their external form
+        context["trustedRelays"] = [TrustedRelaySerializer(raw).data for raw in trusted_relays_raw]
+
         context["access"] = access.scopes
         if access.role is not None:
             context["role"] = access.role
diff --git a/src/sentry/models/relay.py b/src/sentry/models/relay.py
index 30a2a99b67..e9e19e13b8 100644
--- a/src/sentry/models/relay.py
+++ b/src/sentry/models/relay.py
@@ -31,5 +31,19 @@ class Relay(Model):
         # Internal relays always have access
         if self.is_internal:
             return True
-        # Use the normalized form of the public key for the check
-        return six.text_type(self.public_key_object) in org.get_option("sentry:trusted-relays", [])
+
+        trusted_relays = org.get_option("sentry:trusted-relays", [])
+        key = six.text_type(self.public_key_object)
+
+        for relay_info in trusted_relays:
+            if relay_info is not None and relay_info.get(u"public_key") == key:
+                return True
+
+        return False
+
+    @staticmethod
+    def for_keys(keys):
+        """
+        Returns all the relays that are configured with one of the specified keys
+        """
+        return Relay.objects.filter(public_key__in=keys)
diff --git a/src/sentry/relay/config.py b/src/sentry/relay/config.py
index 9df49e763c..d6cb124a0e 100644
--- a/src/sentry/relay/config.py
+++ b/src/sentry/relay/config.py
@@ -119,7 +119,9 @@ def get_project_config(project, org_options=None, full_config=True, project_keys
             "publicKeys": public_keys,
             "config": {
                 "allowedDomains": list(get_origins(project)),
-                "trustedRelays": org_options.get("sentry:trusted-relays", []),
+                "trustedRelays": [
+                    r["public_key"] for r in org_options.get("sentry:trusted-relays", []) if r
+                ],
                 "piiConfig": _get_pii_config(project),
                 "datascrubbingSettings": _get_datascrubbing_settings(project, org_options),
             },
diff --git a/tests/sentry/api/endpoints/test_organization_details.py b/tests/sentry/api/endpoints/test_organization_details.py
index 3386856733..eb5263f69c 100644
--- a/tests/sentry/api/endpoints/test_organization_details.py
+++ b/tests/sentry/api/endpoints/test_organization_details.py
@@ -1,5 +1,9 @@
 from __future__ import absolute_import
 
+from datetime import datetime
+
+import dateutil
+import dateutil.tz
 import six
 
 from base64 import b64encode
@@ -8,6 +12,7 @@ from django.core import mail
 from sentry.utils.compat.mock import patch
 from exam import fixture
 from pprint import pprint
+import json
 
 from sentry.api.endpoints.organization_details import ERR_NO_2FA, ERR_SSO_ENABLED
 from sentry.constants import RESERVED_ORGANIZATION_SLUGS
@@ -24,7 +29,15 @@ from sentry.models import (
     TotpInterface,
 )
 from sentry.signals import project_created
-from sentry.testutils import APITestCase, TwoFactorAPITestCase
+from sentry.testutils import APITestCase, TwoFactorAPITestCase, pytest
+
+# some relay keys
+_VALID_RELAY_KEYS = [
+    u"IbXZDWy8DcGLVoT_Z6-ODALEnsyhKiC_i-0r3azaztQ",
+    u"CZa3eDblYqBVoxK3O_4fr5WBbUmUVwc6FrRXbOQTPfk",
+    u"gyKnK-__yfEOweJ95sB1JoqAh6VlS4c_uIwsrrQ4G7E",
+    u"kSdr7ozq2T3gLg7FehJro2PH_NnNMJrrCslleKGZQd8",
+]
 
 
 class OrganizationDetailsTest(APITestCase):
@@ -133,6 +146,51 @@ class OrganizationDetailsTest(APITestCase):
         assert len(response.data["onboardingTasks"]) == 1
         assert response.data["onboardingTasks"][0]["task"] == "create_project"
 
+    def test_trusted_relays_info(self):
+        org = self.create_organization(owner=self.user)
+        AuditLogEntry.objects.filter(organization=org).delete()
+        self.login_as(user=self.user)
+        url = reverse("sentry-api-0-organization-details", kwargs={"organization_slug": org.slug})
+
+        trusted_relays = [
+            {
+                u"publicKey": _VALID_RELAY_KEYS[0],
+                u"name": u"name1",
+                u"description": u"description1",
+            },
+            {
+                u"publicKey": _VALID_RELAY_KEYS[1],
+                u"name": u"name2",
+                u"description": u"description2",
+            },
+        ]
+
+        data = {"trustedRelays": trusted_relays}
+
+        with self.feature("organizations:relay"):
+            start_time = datetime.utcnow().replace(tzinfo=dateutil.tz.UTC)
+            response = self.client.put(url, data=data)
+            end_time = datetime.utcnow().replace(tzinfo=dateutil.tz.UTC)
+            assert response.status_code == 200
+            response = self.client.get(url)
+            assert response.status_code == 200
+
+        response_data = response.data.get("trustedRelays")
+
+        assert response_data is not None
+        assert len(response_data) == len(trusted_relays)
+
+        for i in range(len(trusted_relays)):
+            assert response_data[i][u"publicKey"] == trusted_relays[i][u"publicKey"]
+            assert response_data[i][u"name"] == trusted_relays[i][u"name"]
+            assert response_data[i][u"description"] == trusted_relays[i][u"description"]
+            # check that last_modified is in the correct range
+            last_modified = dateutil.parser.parse(response_data[i][u"lastModified"])
+            assert start_time < last_modified < end_time
+            # check that created is in the correct range
+            created = dateutil.parser.parse(response_data[i][u"created"])
+            assert start_time < created < end_time
+
 
 class OrganizationUpdateTest(APITestCase):
     def test_simple(self):
@@ -263,29 +321,252 @@ class OrganizationUpdateTest(APITestCase):
         self.login_as(user=self.user)
         url = reverse("sentry-api-0-organization-details", kwargs={"organization_slug": org.slug})
 
-        data = {"trustedRelays": [u"key1", u"key2"]}
+        data = {
+            "trustedRelays": [
+                {u"publicKey": _VALID_RELAY_KEYS[0], u"name": "name1"},
+                {u"publicKey": _VALID_RELAY_KEYS[1], u"name": "name2"},
+            ]
+        }
 
         response = self.client.put(url, data=data)
         assert response.status_code == 400
         assert b"feature" in response.content
 
-    def test_setting_trusted_relays(self):
+    def test_setting_duplicate_trusted_keys(self):
+        """
+        Test that you cannot set duplicated keys
+
+        Try to put the same key twice and check we get an error
+        """
         org = self.create_organization(owner=self.user)
         AuditLogEntry.objects.filter(organization=org).delete()
         self.login_as(user=self.user)
         url = reverse("sentry-api-0-organization-details", kwargs={"organization_slug": org.slug})
 
-        data = {"trustedRelays": [u"key1", u"key2"]}
+        trusted_relays = [
+            {
+                u"publicKey": _VALID_RELAY_KEYS[0],
+                u"name": u"name1",
+                u"description": u"description1",
+            },
+            {
+                u"publicKey": _VALID_RELAY_KEYS[1],
+                u"name": u"name2",
+                u"description": u"description2",
+            },
+            {
+                u"publicKey": _VALID_RELAY_KEYS[0],
+                u"name": u"name1 2",
+                u"description": u"description1 2",
+            },
+        ]
+
+        data = {"trustedRelays": trusted_relays}
 
         with self.feature("organizations:relay"):
             response = self.client.put(url, data=data)
+
+        assert response.status_code == 400
+        response_data = response.data.get("trustedRelays")
+        assert response_data is not None
+        resp_str = json.dumps(response_data)
+        # check that we have the duplicate key specified somewhere in the error message
+        assert resp_str.find(_VALID_RELAY_KEYS[0]) >= 0
+
+    def test_creating_trusted_relays(self):
+        org = self.create_organization(owner=self.user)
+        AuditLogEntry.objects.filter(organization=org).delete()
+        self.login_as(user=self.user)
+        url = reverse("sentry-api-0-organization-details", kwargs={"organization_slug": org.slug})
+
+        trusted_relays = [
+            {
+                u"publicKey": _VALID_RELAY_KEYS[0],
+                u"name": u"name1",
+                u"description": u"description1",
+            },
+            {
+                u"publicKey": _VALID_RELAY_KEYS[1],
+                u"name": u"name2",
+                u"description": u"description2",
+            },
+        ]
+
+        data = {"trustedRelays": trusted_relays}
+
+        with self.feature("organizations:relay"):
+            start_time = datetime.utcnow().replace(tzinfo=dateutil.tz.UTC)
+            response = self.client.put(url, data=data)
+            end_time = datetime.utcnow().replace(tzinfo=dateutil.tz.UTC)
+
             assert response.status_code == 200
+            response_data = response.data.get("trustedRelays")
 
         (option,) = OrganizationOption.objects.filter(organization=org, key="sentry:trusted-relays")
 
-        assert option.value == data["trustedRelays"]
+        actual = option.value
+
+        assert len(actual) == len(trusted_relays)
+        assert len(response_data) == len(trusted_relays)
+
+        for i in range(len(actual)):
+            assert actual[i][u"public_key"] == trusted_relays[i][u"publicKey"]
+            assert actual[i][u"name"] == trusted_relays[i][u"name"]
+            assert actual[i][u"description"] == trusted_relays[i][u"description"]
+            assert response_data[i][u"publicKey"] == trusted_relays[i][u"publicKey"]
+            assert response_data[i][u"name"] == trusted_relays[i][u"name"]
+            assert response_data[i][u"description"] == trusted_relays[i][u"description"]
+            # check that last_modified is in the correct range
+            last_modified = dateutil.parser.parse(actual[i][u"last_modified"])
+            assert start_time < last_modified < end_time
+            assert response_data[i][u"lastModified"] == actual[i][u"last_modified"]
+            # check that created is in the correct range
+            created = dateutil.parser.parse(actual[i][u"created"])
+            assert start_time < created < end_time
+            assert response_data[i][u"created"] == actual[i][u"created"]
+
         log = AuditLogEntry.objects.get(organization=org)
-        assert "to {}".format(data["trustedRelays"]) in log.data["trustedRelays"]
+        trusted_relay_log = log.data["trustedRelays"]
+
+        assert trusted_relay_log is not None
+        # check that we log a new trusted-relays entry
+        assert trusted_relay_log.startswith("to ")
+        # check that we have the public keys somewhere in the log message
+        assert trusted_relays[0][u"publicKey"] in trusted_relay_log
+        assert trusted_relays[1][u"publicKey"] in trusted_relay_log
+
+    def test_modifying_trusted_relays(self):
+        org = self.create_organization(owner=self.user)
+        AuditLogEntry.objects.filter(organization=org).delete()
+        self.login_as(user=self.user)
+        url = reverse("sentry-api-0-organization-details", kwargs={"organization_slug": org.slug})
+
+        initial_trusted_relays = [
+            {
+                u"publicKey": _VALID_RELAY_KEYS[0],
+                u"name": u"name1",
+                u"description": u"description1",
+            },
+            {
+                u"publicKey": _VALID_RELAY_KEYS[1],
+                u"name": u"name2",
+                u"description": u"description2",
+            },
+            {
+                u"publicKey": _VALID_RELAY_KEYS[2],
+                u"name": u"name3",
+                u"description": u"description3",
+            },
+        ]
+
+        modified_trusted_relays = [
+            # key1 was removed
+            # key2 is not modified
+            {
+                u"publicKey": _VALID_RELAY_KEYS[1],
+                u"name": u"name2",
+                u"description": u"description2",
+            },
+            # key3 modified name & desc
+            {
+                u"publicKey": _VALID_RELAY_KEYS[2],
+                u"name": u"name3 modified",
+                u"description": u"description3 modified",
+            },
+            # key4 is new
+            {
+                u"publicKey": _VALID_RELAY_KEYS[3],
+                u"name": u"name4",
+                u"description": u"description4",
+            },
+        ]
+
+        initial_settings = {"trustedRelays": initial_trusted_relays}
+        changed_settings = {"trustedRelays": modified_trusted_relays}
+
+        with self.feature("organizations:relay"):
+            start_time = datetime.utcnow().replace(tzinfo=dateutil.tz.UTC)
+            self.client.put(url, data=initial_settings)
+            after_initial = datetime.utcnow().replace(tzinfo=dateutil.tz.UTC)
+            response = self.client.put(url, data=changed_settings)
+            after_final = datetime.utcnow().replace(tzinfo=dateutil.tz.UTC)
+
+            assert response.status_code == 200
+
+        (option,) = OrganizationOption.objects.filter(organization=org, key="sentry:trusted-relays")
+
+        actual = option.value
+
+        assert len(actual) == len(modified_trusted_relays)
+
+        for i in range(len(actual)):
+            assert actual[i][u"public_key"] == modified_trusted_relays[i][u"publicKey"]
+            assert actual[i][u"name"] == modified_trusted_relays[i][u"name"]
+            assert actual[i][u"description"] == modified_trusted_relays[i][u"description"]
+
+            last_modified = dateutil.parser.parse(actual[i][u"last_modified"])
+            created = dateutil.parser.parse(actual[i][u"created"])
+            key = modified_trusted_relays[i][u"publicKey"]
+
+            if key == _VALID_RELAY_KEYS[1]:
+                # key2 should have not been modified
+                assert start_time < created < after_initial
+                assert start_time < last_modified < after_initial
+            elif key == _VALID_RELAY_KEYS[2]:
+                # key3 should have been updated
+                assert start_time < created < after_initial
+                assert after_initial < last_modified < after_final
+            elif key == _VALID_RELAY_KEYS[3]:
+                # key4 is new
+                assert after_initial < created < after_final
+                assert after_initial < last_modified < after_final
+
+        # we should have 2 log messages from the two calls
+        (first_log, second_log) = AuditLogEntry.objects.filter(organization=org)
+        log_str_1 = first_log.data["trustedRelays"]
+        log_str_2 = second_log.data["trustedRelays"]
+
+        assert log_str_1 is not None
+        assert log_str_2 is not None
+
+        if log_str_1.startswith("to "):
+            modif_log = log_str_2
+        else:
+            modif_log = log_str_1
+
+        assert modif_log.startswith("from ")
+        # check that we have the new public keys somewhere in the modify operation log message
+        for i in range(len(modified_trusted_relays)):
+            assert modified_trusted_relays[i][u"publicKey"] in modif_log
+
+    def test_deleting_trusted_relays(self):
+        org = self.create_organization(owner=self.user)
+        AuditLogEntry.objects.filter(organization=org).delete()
+        self.login_as(user=self.user)
+        url = reverse("sentry-api-0-organization-details", kwargs={"organization_slug": org.slug})
+
+        initial_trusted_relays = [
+            {
+                u"publicKey": _VALID_RELAY_KEYS[0],
+                u"name": u"name1",
+                u"description": u"description1",
+            },
+        ]
+
+        initial_settings = {"trustedRelays": initial_trusted_relays}
+
+        with self.feature("organizations:relay"):
+            self.client.put(url, data=initial_settings)
+            response = self.client.put(url, data={"trustedRelays": []})
+
+            assert response.status_code == 200
+            response_data = response.data.get("trustedRelays")
+
+        (option,) = OrganizationOption.objects.filter(organization=org, key="sentry:trusted-relays")
+        actual = option.value
+
+        assert len(actual) == 0
+        assert len(response_data) == 0
 
     def test_setting_legacy_rate_limits(self):
         org = self.create_organization(owner=self.user)
@@ -613,3 +894,87 @@ class OrganizationSettings2FATest(TwoFactorAPITestCase):
         user = self.create_user(is_superuser=True)
         self.login_as(user, superuser=True)
         self.assert_can_access_org_details(self.path)
+
+
+from sentry.api.endpoints.organization_details import TrustedRelaySerializer
+
+
+def test_trusted_relays_option_serialization():
+    # incoming raw data
+    data = {
+        u"publicKey": _VALID_RELAY_KEYS[0],
+        u"name": u"Relay1",
+        u"description": u"the description",
+        u"lastModified": u"2020-05-20T20:21:22",
+        u"created": u"2020-01-17T11:12:13",
+    }
+    serializer = TrustedRelaySerializer(data=data)
+    assert serializer.is_valid()
+
+    expected_incoming = {
+        u"public_key": _VALID_RELAY_KEYS[0],
+        u"name": u"Relay1",
+        u"description": u"the description",
+    }
+
+    # check incoming deserialization (data will be further completed with date info the by server)
+    assert serializer.validated_data == expected_incoming
+
+
+invalid_payloads = [
+    {
+        u"publicKey": _VALID_RELAY_KEYS[0],
+        # no name
+        u"description": u"the description",
+    },
+    {
+        u"publicKey": _VALID_RELAY_KEYS[0],
+        u"name": "  ",  # empty name
+        u"description": u"the description",
+    },
+    {
+        u"publicKey": _VALID_RELAY_KEYS[0],
+        u"name": None,  # null name
+        u"description": u"the description",
+    },
+    {u"publicKey": "Bad Key", u"name": u"name", u"description": u"the description"},  # invalid key
+    {
+        # missing key
+        u"name": u"name",
+        u"description": u"the description",
+    },
+    {u"publicKey": None, u"name": u"name", u"description": u"the description"},  # null key
+    "Bad input",  # not an object
+]
+
+
+@pytest.mark.parametrize("invalid_data", invalid_payloads)
+def test_trusted_relay_serializer_validation(invalid_data):
+    """
+        Tests that the public key is validated
+    """
+    # incoming raw data
+    serializer = TrustedRelaySerializer(data=invalid_data)
+    assert not serializer.is_valid()
+
+
+def test_trusted_relays_option_deserialization():
+    # internal data
+    instance = {
+        u"public_key": u"key1",
+        u"name": u"Relay1",
+        u"description": u"the description",
+        u"last_modified": u"2020-05-20T20:21:22Z",
+        u"created": u"2020-01-17T11:12:13Z",
+    }
+    serializer = TrustedRelaySerializer(instance)
+
+    expected_outgoing = {
+        u"publicKey": u"key1",
+        u"name": u"Relay1",
+        u"description": u"the description",
+        u"lastModified": u"2020-05-20T20:21:22Z",
+        u"created": u"2020-01-17T11:12:13Z",
+    }
+    # check outgoing deserialization (all info in camelCase)
+    assert serializer.data == expected_outgoing
diff --git a/tests/sentry/api/endpoints/test_relay_projectconfigs.py b/tests/sentry/api/endpoints/test_relay_projectconfigs.py
index 3157edb14a..c360b17067 100644
--- a/tests/sentry/api/endpoints/test_relay_projectconfigs.py
+++ b/tests/sentry/api/endpoints/test_relay_projectconfigs.py
@@ -91,7 +91,9 @@ def call_endpoint(client, relay, private_key, default_project):
 
 @pytest.fixture
 def add_org_key(default_organization, relay):
-    default_organization.update_option("sentry:trusted-relays", [relay.public_key])
+    default_organization.update_option(
+        "sentry:trusted-relays", [{"public_key": relay.public_key, "name": "main-relay"}]
+    )
 
 
 @pytest.mark.django_db
@@ -228,7 +230,6 @@ def test_trusted_external_relays_should_receive_minimal_configs(
     assert safe.get_path(cfg, "projectId") == default_project.id
     assert safe.get_path(cfg, "slug") == default_project.slug
     assert safe.get_path(cfg, "rev") is not None
-
     assert safe.get_path(cfg, "config", "trustedRelays") == [relay.public_key]
     assert safe.get_path(cfg, "config", "filterSettings") is None
     assert safe.get_path(cfg, "config", "groupingConfig") is None
diff --git a/tests/sentry/api/endpoints/test_relay_projectids.py b/tests/sentry/api/endpoints/test_relay_projectids.py
index a6937d8327..abb72eff9e 100644
--- a/tests/sentry/api/endpoints/test_relay_projectids.py
+++ b/tests/sentry/api/endpoints/test_relay_projectids.py
@@ -48,7 +48,10 @@ class RelayProjectIdsEndpointTest(APITestCase):
         org = self.project.organization
 
         if add_org_key:
-            org.update_option("sentry:trusted-relays", [self.relay.public_key])
+            org.update_option(
+                "sentry:trusted-relays",
+                [{"public_key": self.relay.public_key, "name": "main-relay"}],
+            )
 
     def _call_endpoint(self, public_key):
         raw_json, signature = self.private_key.pack({"publicKeys": [public_key]})

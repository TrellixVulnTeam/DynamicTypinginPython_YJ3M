commit 4f251c15bb74107802bacb51316478af481c859f
Author: David Cramer <dcramer@gmail.com>
Date:   Tue Jun 3 22:08:11 2014 -0700

    Refactor rule notification intelligence

diff --git a/src/sentry/rules/actions/base.py b/src/sentry/rules/actions/base.py
index 51dde3cb3b..76809bccb9 100644
--- a/src/sentry/rules/actions/base.py
+++ b/src/sentry/rules/actions/base.py
@@ -14,5 +14,5 @@ from sentry.rules.base import RuleBase
 class EventAction(RuleBase):
     rule_type = 'action/event'
 
-    def after(self, event, is_new, is_regression, is_sample, **kwargs):
+    def after(self, event, state):
         pass
diff --git a/src/sentry/rules/actions/notify_event.py b/src/sentry/rules/actions/notify_event.py
index 95c33941b9..baff0b9b30 100644
--- a/src/sentry/rules/actions/notify_event.py
+++ b/src/sentry/rules/actions/notify_event.py
@@ -16,7 +16,7 @@ from sentry.utils.safe import safe_execute
 class NotifyEventAction(EventAction):
     label = 'Send a notification'
 
-    def after(self, event, **kwargs):
+    def after(self, event, state):
         from sentry.plugins.bases.notify import NotificationPlugin
 
         group = event.group
diff --git a/src/sentry/rules/base.py b/src/sentry/rules/base.py
index 8d03a6ebd9..7a39dc92cf 100644
--- a/src/sentry/rules/base.py
+++ b/src/sentry/rules/base.py
@@ -89,3 +89,11 @@ class RuleBase(object):
         )
 
         return form.is_valid()
+
+
+class EventState(object):
+    def __init__(self, is_new, is_regression, is_sample, rule_is_active):
+        self.is_new = is_new
+        self.is_regression = is_regression
+        self.is_sample = is_sample,
+        self.rule_is_active = rule_is_active
diff --git a/src/sentry/rules/conditions/base.py b/src/sentry/rules/conditions/base.py
index 0798a9bbe3..c12633afb2 100644
--- a/src/sentry/rules/conditions/base.py
+++ b/src/sentry/rules/conditions/base.py
@@ -12,5 +12,5 @@ from sentry.rules.base import RuleBase
 class EventCondition(RuleBase):
     rule_type = 'condition/event'
 
-    def passes(self, event, is_new, is_regression, is_sample, **kwargs):
+    def passes(self, event, state):
         raise NotImplementedError
diff --git a/src/sentry/rules/conditions/event_frequency.py b/src/sentry/rules/conditions/event_frequency.py
index 90c17a5af7..fd2cf41a06 100644
--- a/src/sentry/rules/conditions/event_frequency.py
+++ b/src/sentry/rules/conditions/event_frequency.py
@@ -42,7 +42,13 @@ class EventFrequencyCondition(EventCondition):
 
         super(EventFrequencyCondition, self).__init__(*args, **kwargs)
 
-    def passes(self, event, is_regression, **kwargs):
+    def passes(self, event, state):
+        # when a rule is not active (i.e. it hasnt gone from inactive -> active)
+        # it means that we already notified the user about this condition and
+        # shouldn't spam them again
+        if state.rule_is_active:
+            return False
+
         interval = self.get_option('interval')
         value = int(self.get_option('value'))
 
diff --git a/src/sentry/rules/conditions/every_event.py b/src/sentry/rules/conditions/every_event.py
index 8b87b24f9c..372d4da364 100644
--- a/src/sentry/rules/conditions/every_event.py
+++ b/src/sentry/rules/conditions/every_event.py
@@ -14,5 +14,5 @@ from sentry.rules.conditions.base import EventCondition
 class EveryEventCondition(EventCondition):
     label = 'An event is seen'
 
-    def passes(self, event, is_new, **kwargs):
+    def passes(self, event, state):
         return True
diff --git a/src/sentry/rules/conditions/first_seen_event.py b/src/sentry/rules/conditions/first_seen_event.py
index cbb6678784..eb962b8912 100644
--- a/src/sentry/rules/conditions/first_seen_event.py
+++ b/src/sentry/rules/conditions/first_seen_event.py
@@ -14,5 +14,5 @@ from sentry.rules.conditions.base import EventCondition
 class FirstSeenEventCondition(EventCondition):
     label = 'An event is first seen'
 
-    def passes(self, event, is_new, **kwargs):
-        return is_new
+    def passes(self, event, state):
+        return state.is_new
diff --git a/src/sentry/rules/conditions/regression_event.py b/src/sentry/rules/conditions/regression_event.py
index cfcfe0e78f..2c4a9a1ef2 100644
--- a/src/sentry/rules/conditions/regression_event.py
+++ b/src/sentry/rules/conditions/regression_event.py
@@ -14,5 +14,5 @@ from sentry.rules.conditions.base import EventCondition
 class RegressionEventCondition(EventCondition):
     label = 'An event changes state from resolved to unresolved'
 
-    def passes(self, event, is_regression, **kwargs):
-        return is_regression
+    def passes(self, event, state):
+        return state.is_regression
diff --git a/src/sentry/tasks/post_process.py b/src/sentry/tasks/post_process.py
index b129ac44b2..d635856936 100644
--- a/src/sentry/tasks/post_process.py
+++ b/src/sentry/tasks/post_process.py
@@ -15,7 +15,7 @@ from hashlib import md5
 
 from sentry.constants import STATUS_ACTIVE, STATUS_INACTIVE
 from sentry.plugins import plugins
-from sentry.rules import rules
+from sentry.rules import EventState, rules
 from sentry.tasks.base import instrumented_task
 from sentry.utils.cache import cache
 from sentry.utils.safe import safe_execute
@@ -24,14 +24,14 @@ from sentry.utils.safe import safe_execute
 rules_logger = logging.getLogger('sentry.errors.rules')
 
 
-def condition_matches(project, condition, **kwargs):
+def condition_matches(project, condition, event, state):
     condition_cls = rules.get(condition['id'])
     if condition_cls is None:
         rules_logger.error('Unregistered condition %r', condition['id'])
         return
 
     condition_inst = condition_cls(project)
-    return safe_execute(condition_inst.passes, **kwargs)
+    return safe_execute(condition_inst.passes, event, state)
 
 
 def get_rules(project):
@@ -80,63 +80,70 @@ def post_process_group(group, event, is_new, is_regression, is_sample, **kwargs)
         if not condition_list:
             continue
 
+        # TODO(dcramer): this might not make sense for other rule actions
+        # so we should find a way to abstract this into actions
+        # TODO(dcramer): this isnt the most efficient query pattern for this
+        rule_status, _ = GroupRuleStatus.objects.get_or_create(
+            rule=rule,
+            group=group,
+            defaults={
+                'project': group.project,
+                'status': STATUS_INACTIVE,
+            },
+        )
+
+        state = EventState(
+            is_new=is_new,
+            is_regression=is_regression,
+            is_sample=is_sample,
+            rule_is_active=rule_status.status == STATUS_ACTIVE,
+        )
+
+        condition_iter = (
+            condition_matches(project, c, event, state)
+            for c in condition_list
+        )
+
         passed = True
         if match == 'all':
-            if not all(condition_matches(project, c, **child_kwargs) for c in condition_list):
+            if not all(condition_iter):
                 passed = False
         elif match == 'any':
-            if not any(condition_matches(project, c, **child_kwargs) for c in condition_list):
+            if not any(condition_iter):
                 passed = False
         elif match == 'none':
-            if any(condition_matches(project, c, **child_kwargs) for c in condition_list):
+            if any(condition_iter):
                 passed = False
         else:
             rules_logger.error('Unsupported action_match %r for rule %d',
                                match, rule.id)
             continue
 
-        # TODO(dcramer): this might not make sense for other rule actions
-        # so we should find a way to abstract this into actions
-        # TODO(dcramer): this isnt the most efficient query pattern for this
-        rule_status, created = GroupRuleStatus.objects.get_or_create(
-            rule=rule,
-            group=group,
-            defaults={
-                'project': group.project,
-                'status': STATUS_ACTIVE if passed else STATUS_INACTIVE,
-            },
-        )
+        if passed and rule_status.status == STATUS_INACTIVE:
+            # we only fire if we're able to say that the state has changed
+            GroupRuleStatus.objects.filter(
+                id=rule.id,
+                status=STATUS_INACTIVE,
+            ).update(status=STATUS_ACTIVE)
+        elif not passed and rule_status.status == STATUS_ACTIVE:
+            # update the state to suggest this rule can fire again
+            GroupRuleStatus.objects.filter(
+                id=rule.id,
+                status=STATUS_ACTIVE,
+            ).update(status=STATUS_INACTIVE)
 
         if passed:
-            if rule_status.status == STATUS_INACTIVE:
-                # we only fire if we're able to say that the state has changed
-                should_fire = GroupRuleStatus.objects.filter(
-                    status=STATUS_INACTIVE,
-                    id=rule_status.id,
-                ).update(status=STATUS_ACTIVE)
-            else:
-                should_fire = False
-
-        else:
-            should_fire = False
-            if rule_status.status == STATUS_ACTIVE:
-                # update the state to suggest this rule can fire again
-                GroupRuleStatus.objects.filter(
-                    status=STATUS_ACTIVE,
-                    id=rule_status.id,
-                ).update(status=STATUS_INACTIVE)
-
-        if should_fire:
             execute_rule.delay(
                 rule_id=rule.id,
-                **child_kwargs
+                event=event,
+                state=state,
             )
 
 
 @instrumented_task(
     name='sentry.tasks.post_process.execute_rule',
     queue='triggers')
-def execute_rule(rule_id, event, **kwargs):
+def execute_rule(rule_id, event, state):
     """
     Fires post processing hooks for a rule.
     """
@@ -154,7 +161,7 @@ def execute_rule(rule_id, event, **kwargs):
             continue
 
         action_inst = action_cls(project)
-        safe_execute(action_inst.after, event=event, **kwargs)
+        safe_execute(action_inst.after, event=event, state=state)
 
 
 @instrumented_task(
diff --git a/src/sentry/testutils/cases.py b/src/sentry/testutils/cases.py
index c7bdce4d8e..8bd54852ad 100644
--- a/src/sentry/testutils/cases.py
+++ b/src/sentry/testutils/cases.py
@@ -30,6 +30,7 @@ from rest_framework.test import APITestCase as BaseAPITestCase
 
 from sentry.constants import MODULE_ROOT
 from sentry.models import ProjectOption
+from sentry.rules import EventState
 from sentry.utils import json
 
 from .fixtures import Fixtures
@@ -237,11 +238,17 @@ class RuleTestCase(TestCase):
             event = self.event
         kwargs.setdefault('is_new', True)
         kwargs.setdefault('is_regression', True)
-        assert rule.passes(event, **kwargs) is True
+        kwargs.setdefault('is_sample', True)
+        kwargs.setdefault('rule_is_active', False)
+        state = EventState(**kwargs)
+        assert rule.passes(event, state) is True
 
     def assertDoesNotPass(self, rule, event=None, **kwargs):
         if event is None:
             event = self.event
         kwargs.setdefault('is_new', True)
         kwargs.setdefault('is_regression', True)
-        assert rule.passes(event, **kwargs) is False
+        kwargs.setdefault('is_sample', True)
+        kwargs.setdefault('rule_is_active', False)
+        state = EventState(**kwargs)
+        assert rule.passes(event, state) is False
diff --git a/tests/sentry/tasks/post_process/tests.py b/tests/sentry/tasks/post_process/tests.py
index 94c000d8a9..ccdf68f5d4 100644
--- a/tests/sentry/tasks/post_process/tests.py
+++ b/tests/sentry/tasks/post_process/tests.py
@@ -5,6 +5,7 @@ from __future__ import absolute_import
 from mock import Mock, patch
 
 from sentry.models import Group, Rule
+from sentry.rules import EventState
 from sentry.testutils import TestCase
 from sentry.tasks.post_process import (
     execute_rule, post_process_group, record_affected_user,
@@ -102,6 +103,8 @@ class PostProcessGroupTest(TestCase):
             is_sample=False,
         )
 
+        mock_get_rules.assert_called_once_with(self.project)
+
         assert not mock_execute_rule.delay.called
 
         post_process_group(
@@ -112,15 +115,8 @@ class PostProcessGroupTest(TestCase):
             is_sample=False,
         )
 
-        mock_execute_rule.delay.assert_called_once_with(
-            rule_id=1,
-            event=event,
-            is_new=True,
-            is_regression=False,
-            is_sample=False,
-        )
+        assert len(mock_execute_rule.delay.mock_calls) == 1
 
-        # ensure we dont execute again since the object hasnt changed state
         post_process_group(
             group=group,
             event=event,
@@ -129,24 +125,7 @@ class PostProcessGroupTest(TestCase):
             is_sample=False,
         )
 
-        assert len(mock_execute_rule.mock_calls) == 1
-
-        # and finally test the behavior of cycling back to new
-        post_process_group(
-            group=group,
-            event=event,
-            is_new=False,
-            is_regression=False,
-            is_sample=False,
-        )
-        post_process_group(
-            group=group,
-            event=event,
-            is_new=True,
-            is_regression=False,
-            is_sample=False,
-        )
-        assert len(mock_execute_rule.mock_calls) == 2
+        assert len(mock_execute_rule.delay.mock_calls) == 2
 
 
 class ExecuteRuleTest(TestCase):
@@ -163,12 +142,17 @@ class ExecuteRuleTest(TestCase):
             }
         )
 
-        execute_rule(
-            rule_id=rule.id,
-            event=event,
+        state = EventState(
             is_new=True,
             is_regression=False,
             is_sample=True,
+            rule_is_active=False,
+        )
+
+        execute_rule(
+            rule_id=rule.id,
+            event=event,
+            state=state,
         )
 
         mock_rules.get.assert_called_once_with('a.rule.id')
@@ -176,9 +160,7 @@ class ExecuteRuleTest(TestCase):
         mock_rule_inst.assert_called_once_with(self.project)
         mock_rule_inst.return_value.after.assert_called_once_with(
             event=event,
-            is_new=True,
-            is_regression=False,
-            is_sample=True,
+            state=state,
         )
 
 

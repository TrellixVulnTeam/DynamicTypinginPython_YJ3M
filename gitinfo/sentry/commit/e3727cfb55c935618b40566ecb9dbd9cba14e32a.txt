commit e3727cfb55c935618b40566ecb9dbd9cba14e32a
Author: Ted Kaemming <ted@kaemming.com>
Date:   Wed Nov 25 15:12:26 2015 -0800

    Add `digests.delete` method.

diff --git a/src/sentry/digests/backends/base.py b/src/sentry/digests/backends/base.py
index 2bc7fe675e..3fff3d49d8 100644
--- a/src/sentry/digests/backends/base.py
+++ b/src/sentry/digests/backends/base.py
@@ -195,3 +195,9 @@ class Backend(object):
         increased) or both.
         """
         raise NotImplementedError
+
+    def delete(self, key):
+        """
+        Delete a timeline and all of it's contents from the database.
+        """
+        raise NotImplementedError
diff --git a/src/sentry/digests/backends/redis.py b/src/sentry/digests/backends/redis.py
index 83d6ea3c04..636ec376eb 100644
--- a/src/sentry/digests/backends/redis.py
+++ b/src/sentry/digests/backends/redis.py
@@ -134,11 +134,12 @@ return true
 # Trims a timeline to a maximum number of records.
 # Returns the number of keys that were deleted.
 # KEYS: {TIMELINE}
-# ARGV: {LIMIT}
+# ARGV: {LIMIT, PREFIX}
 TRUNCATE_TIMELINE_SCRIPT = """\
 local keys = redis.call('ZREVRANGE', KEYS[1], ARGV[1], -1)
+local prefix = ARGV[2] or KEYS[1]
 for i, record in pairs(keys) do
-    redis.call('DEL', KEYS[1] .. ':{TIMELINE_RECORD_PATH_COMPONENT}:' .. record)
+    redis.call('DEL', prefix .. ':{TIMELINE_RECORD_PATH_COMPONENT}:' .. record)
     redis.call('ZREM', KEYS[1], record)
 end
 return table.getn(keys)
@@ -561,3 +562,16 @@ class RedisBackend(Backend):
                 except WatchError:
                     logger.debug('Could not remove timeline from schedule, rescheduling instead')
                     reschedule()
+
+    def delete(self, key):
+        timeline_key = make_timeline_key(self.namespace, key)
+
+        connection = self.cluster.get_local_client_for_key(timeline_key)
+        with Lock(timeline_key, nowait=True, timeout=30), \
+                connection.pipeline() as pipeline:
+            truncate_timeline((timeline_key,), (0,), pipeline)
+            truncate_timeline((make_digest_key(timeline_key),), (0, timeline_key), pipeline)
+            pipeline.delete(make_last_processed_timestamp_key(timeline_key))
+            pipeline.zrem(make_schedule_key(self.namespace, SCHEDULE_STATE_READY), key)
+            pipeline.zrem(make_schedule_key(self.namespace, SCHEDULE_STATE_WAITING), key)
+            pipeline.execute()
diff --git a/src/sentry/tasks/digests.py b/src/sentry/tasks/digests.py
index 46f5d931a5..256a09ebff 100644
--- a/src/sentry/tasks/digests.py
+++ b/src/sentry/tasks/digests.py
@@ -50,6 +50,7 @@ def deliver_digest(key, schedule_timestamp=None):
         plugin, project = split_key(key)
     except Project.DoesNotExist as error:
         logger.info('Cannot deliver digest %r due to error: %s', key, error)
+        digests.delete(key)
         return
 
     minimum_delay = ProjectOption.objects.get_value(
diff --git a/tests/sentry/digests/backends/test_redis.py b/tests/sentry/digests/backends/test_redis.py
index a2c8362dad..e8050ad3e5 100644
--- a/tests/sentry/digests/backends/test_redis.py
+++ b/tests/sentry/digests/backends/test_redis.py
@@ -206,6 +206,38 @@ class RedisBackendTestCase(BaseRedisBackendTestCase):
                 assert entry.key == 'timelines:{0}'.format(i)
                 assert entry.timestamp == float(i)
 
+    def test_delete(self):
+        timeline = 'timeline'
+        backend = self.get_backend()
+
+        timeline_key = make_timeline_key(backend.namespace, timeline)
+        digest_key = make_digest_key(timeline_key)
+        waiting_set_key = make_schedule_key(backend.namespace, SCHEDULE_STATE_WAITING)
+        ready_set_key = make_schedule_key(backend.namespace, SCHEDULE_STATE_READY)
+
+        connection = backend.cluster.get_local_client_for_key(timeline_key)
+        connection.zadd(waiting_set_key, 0, timeline)
+        connection.zadd(ready_set_key, 0, timeline)
+        connection.zadd(timeline_key, 0, '1')
+        connection.set(make_record_key(timeline_key, '1'), 'data')
+        connection.zadd(digest_key, 0, '2')
+        connection.set(make_record_key(timeline_key, '2'), 'data')
+
+        keys = (
+            waiting_set_key,
+            ready_set_key,
+            digest_key,
+            timeline_key,
+            make_record_key(timeline_key, '1'),
+            make_record_key(timeline_key, '2')
+        )
+
+        def check_keys_exist():
+            return map(connection.exists, keys)
+
+        with self.assertChanges(check_keys_exist, before=[True] * len(keys), after=[False] * len(keys)):
+            backend.delete(timeline)
+
 
 class ExpectedError(Exception):
     pass

commit 9f02edcc78d7d69d72847572b0892e0f77a20864
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Mon May 6 14:30:34 2019 -0700

    ref(ui): Decouple NoteInput from issues (#13049)
    
    * move GroupActivityItem into its own file
    * refactor + fix up tests

diff --git a/src/sentry/static/sentry/app/actionCreators/group.jsx b/src/sentry/static/sentry/app/actionCreators/group.jsx
index 7118197797..87c34e8906 100644
--- a/src/sentry/static/sentry/app/actionCreators/group.jsx
+++ b/src/sentry/static/sentry/app/actionCreators/group.jsx
@@ -1,9 +1,10 @@
 import * as Sentry from '@sentry/browser';
 
 import {Client} from 'app/api';
-import GroupActions from 'app/actions/groupActions';
 import {buildUserId, buildTeamId} from 'app/utils';
 import {uniqueId} from 'app/utils/guid';
+import GroupActions from 'app/actions/groupActions';
+import GroupStore from 'app/stores/groupStore';
 
 export function assignToUser(params) {
   const api = new Client();
@@ -105,3 +106,44 @@ export function assignToActor({id, actor}) {
       GroupActions.assignToError(guid, id, data);
     });
 }
+
+export function deleteNote(api, group, item) {
+  const index = GroupStore.removeActivity(group.id, item.id);
+  if (index === -1) {
+    // I dunno, the id wasn't found in the GroupStore
+    return Promise.reject(new Error('Group was not found in store'));
+  }
+
+  const promise = api.requestPromise(`/issues/${group.id}/comments/${item.id}/`, {
+    method: 'DELETE',
+  });
+
+  promise.catch(() => GroupStore.addActivity(group.id, item, index));
+
+  return promise;
+}
+
+export function createNote(api, group, note) {
+  const promise = api.requestPromise(`/issues/${group.id}/comments/`, {
+    method: 'POST',
+    data: note,
+  });
+
+  promise.then(data => GroupStore.addActivity(group.id, data));
+
+  return promise;
+}
+
+export function updateNote(api, group, item, note) {
+  const oldNote = item.data.text;
+  GroupStore.updateActivity(group.id, item.id, {text: note.text});
+
+  const promise = api.requestPromise(`/issues/${group.id}/comments/${item.id}/`, {
+    method: 'PUT',
+    data: note,
+  });
+
+  promise.catch(() => GroupStore.updateActivity(group.id, item.id, {text: oldNote}));
+
+  return promise;
+}
diff --git a/src/sentry/static/sentry/app/components/activity/note/header.jsx b/src/sentry/static/sentry/app/components/activity/note/header.jsx
index ca0fcfd61e..dbf68eaafe 100644
--- a/src/sentry/static/sentry/app/components/activity/note/header.jsx
+++ b/src/sentry/static/sentry/app/components/activity/note/header.jsx
@@ -46,13 +46,14 @@ class NoteHeader extends React.Component {
   }
 }
 
-const EditorAction = styled('a')`
+const getActionStyle = p => `
   padding: 0 7px;
-  color: ${p => p.theme.gray1};
+  color: ${p.theme.gray1};
   font-weight: normal;
 `;
 
-const Edit = styled(EditorAction)`
+const Edit = styled('a')`
+  ${getActionStyle};
   margin-left: 7px;
 
   &:hover {
@@ -60,7 +61,8 @@ const Edit = styled(EditorAction)`
   }
 `;
 
-const Remove = styled(EditorAction)`
+const Remove = styled('span')`
+  ${getActionStyle};
   border-left: 1px solid ${p => p.theme.borderLight};
 
   &:hover {
diff --git a/src/sentry/static/sentry/app/components/activity/note/index.jsx b/src/sentry/static/sentry/app/components/activity/note/index.jsx
index 9aad7a492e..2cef0df20e 100644
--- a/src/sentry/static/sentry/app/components/activity/note/index.jsx
+++ b/src/sentry/static/sentry/app/components/activity/note/index.jsx
@@ -3,6 +3,7 @@ import React from 'react';
 import styled from 'react-emotion';
 
 import ActivityItem from 'app/components/activity/item';
+import SentryTypes from 'app/sentryTypes';
 import space from 'app/styles/space';
 
 import EditorTools from './editorTools';
@@ -12,12 +13,14 @@ import NoteInput from './input';
 
 class Note extends React.Component {
   static propTypes = {
-    group: PropTypes.object.isRequired,
-    item: PropTypes.object.isRequired,
     author: PropTypes.object.isRequired,
-    onDelete: PropTypes.func.isRequired,
-    sessionUser: PropTypes.object.isRequired,
+    item: PropTypes.object.isRequired,
     memberList: PropTypes.array.isRequired,
+    teams: PropTypes.arrayOf(SentryTypes.Team).isRequired,
+
+    onDelete: PropTypes.func,
+    onCreate: PropTypes.func,
+    onUpdate: PropTypes.func,
   };
 
   constructor(...args) {
@@ -27,20 +30,35 @@ class Note extends React.Component {
     };
   }
 
-  onEdit = () => {
+  handleEdit = () => {
     this.setState({editing: true});
   };
 
-  onFinish = () => {
+  handleEditFinish = () => {
     this.setState({editing: false});
   };
 
-  onDelete = () => {
-    this.props.onDelete(this.props.item);
+  handleDelete = () => {
+    const {item, onDelete} = this.props;
+
+    onDelete(item);
+  };
+
+  handleCreate = note => {
+    const {onCreate} = this.props;
+
+    onCreate(note);
+  };
+
+  handleUpdate = note => {
+    const {item, onUpdate} = this.props;
+
+    onUpdate(note, item);
+    this.setState({editing: false});
   };
 
   render() {
-    const {group, item, author, sessionUser, memberList} = this.props;
+    const {item, author, teams, memberList} = this.props;
 
     const activityItemProps = {
       id: `activity-item-${item.id}`,
@@ -56,8 +74,8 @@ class Note extends React.Component {
             <NoteHeader
               author={author}
               user={item.user}
-              onEdit={this.onEdit}
-              onDelete={this.onDelete}
+              onEdit={this.handleEdit}
+              onDelete={this.handleDelete}
             />
           }
         >
@@ -72,11 +90,12 @@ class Note extends React.Component {
       <StyledActivityItem {...activityItemProps}>
         {() => (
           <NoteInput
-            group={group}
             item={item}
-            onFinish={this.onFinish}
-            sessionUser={sessionUser}
+            onEditFinish={this.handleEditFinish}
+            onUpdate={this.handleUpdate}
+            onCreate={this.handleCreate}
             memberList={memberList}
+            teams={teams}
           />
         )}
       </StyledActivityItem>
diff --git a/src/sentry/static/sentry/app/components/activity/note/input.jsx b/src/sentry/static/sentry/app/components/activity/note/input.jsx
index 8acbc38c3d..124e2b1c0f 100644
--- a/src/sentry/static/sentry/app/components/activity/note/input.jsx
+++ b/src/sentry/static/sentry/app/components/activity/note/input.jsx
@@ -1,315 +1,193 @@
 import {MentionsInput, Mention} from 'react-mentions';
 import PropTypes from 'prop-types';
 import React from 'react';
-import _ from 'lodash';
-import createReactClass from 'create-react-class';
 import marked from 'marked';
 import styled, {css} from 'react-emotion';
 
-import {logException} from 'app/utils/logging';
 import {t} from 'app/locale';
 import Button from 'app/components/button';
-import GroupStore from 'app/stores/groupStore';
-import IndicatorStore from 'app/stores/indicatorStore';
 import NavTabs from 'app/components/navTabs';
-import OrganizationState from 'app/mixins/organizationState';
-import ProjectsStore from 'app/stores/projectsStore';
-import localStorage from 'app/utils/localStorage';
+import SentryTypes from 'app/sentryTypes';
 import mentionsStyle from 'app/../styles/mentions-styles';
 import space from 'app/styles/space';
 import textStyles from 'app/styles/text';
 import withApi from 'app/utils/withApi';
 
-const localStorageKey = 'noteinput:latest';
-
-function makeDefaultErrorJson() {
-  return {detail: t('Unknown error. Please try again.')};
-}
-
 const buildUserId = id => `user:${id}`;
 const buildTeamId = id => `team:${id}`;
 
-const NoteInput = createReactClass({
-  displayName: 'NoteInput',
-
-  propTypes: {
-    api: PropTypes.object,
-    item: PropTypes.object,
-    group: PropTypes.object.isRequired,
-    onFinish: PropTypes.func,
+class NoteInput extends React.Component {
+  static propTypes = {
+    teams: PropTypes.arrayOf(SentryTypes.Team).isRequired,
     memberList: PropTypes.array.isRequired,
-    sessionUser: PropTypes.object.isRequired,
-  },
-
-  mixins: [OrganizationState],
-
-  getInitialState() {
-    const {item, group} = this.props;
-    const updating = !!item;
-    let defaultText = '';
 
-    if (updating) {
-      defaultText = item.data.text;
-    } else {
-      const storage = localStorage.getItem(localStorageKey);
-      if (storage) {
-        const {groupId, value} = JSON.parse(storage);
-        if (groupId === group.id) {
-          defaultText = value;
-        }
-      }
-    }
-
-    return {
-      loading: false,
-      error: false,
-      errorJSON: null,
-      expanded: false,
+    item: PropTypes.shape({
+      data: PropTypes.shape({
+        text: PropTypes.string,
+      }),
+    }),
+    defaultText: PropTypes.string,
+    error: PropTypes.bool,
+    errorJSON: PropTypes.shape({
+      detail: PropTypes.shape({
+        message: PropTypes.string,
+        code: PropTypes.number,
+        extra: PropTypes.any,
+      }),
+    }),
+    placeholder: PropTypes.string,
+    busy: PropTypes.bool,
+
+    onEditFinish: PropTypes.func,
+    onUpdate: PropTypes.func,
+    onCreate: PropTypes.func,
+    onChange: PropTypes.func,
+  };
+
+  static defaultProps = {
+    placeholder: t('Add a comment.\nTag users with @, or teams with #'),
+    defaultText: '',
+    busy: false,
+  };
+
+  constructor(props) {
+    super(props);
+
+    const {item} = props;
+    const existing = !!item;
+    const defaultText = existing ? item.data.text || '' : props.defaultText;
+
+    this.memberMentions = [];
+    this.teamMentions = [];
+
+    this.state = {
       preview: false,
-      updating,
       value: defaultText,
       memberMentions: [],
       teamMentions: [],
-      mentionableUsers: this.mentionableUsers(),
-      mentionableTeams: this.mentionableTeams(),
     };
-  },
+  }
 
-  componentWillUpdate(nextProps, nextState) {
-    if (!_.isEqual(nextProps.memberList, this.props.memberList)) {
-      this.setState({
-        mentionableUsers: this.mentionableUsers(),
-        mentionableTeams: this.mentionableTeams(),
-      });
-    }
+  cleanMarkdown(text) {
+    return text
+      .replace(/\[sentry\.strip:member\]/g, '@')
+      .replace(/\[sentry\.strip:team\]/g, '');
+  }
+
+  mentionableUsers() {
+    const {memberList} = this.props;
+    return memberList.map(member => ({
+      id: buildUserId(member.id),
+      display: member.name,
+      email: member.email,
+    }));
+  }
 
-    // We can't support this when editing an existing Note since it'll
-    // clobber the other storages
-    if (this.state.updating) {
-      return;
+  mentionableTeams() {
+    const {teams} = this.props;
+    return teams.map(team => ({
+      id: buildTeamId(team.id),
+      display: `#${team.slug}`,
+      email: team.id,
+    }));
+  }
+
+  submitForm = () => {
+    if (!!this.props.item) {
+      this.update();
+    } else {
+      this.create();
     }
+  };
 
-    // Nothing changed
-    if (this.state.value === nextState.value) {
-      return;
+  create = () => {
+    const {onCreate} = this.props;
+
+    if (onCreate) {
+      onCreate({
+        text: this.cleanMarkdown(this.state.value),
+        mentions: this.finalizeMentions(),
+      });
     }
+  };
+
+  update = () => {
+    const {onUpdate} = this.props;
 
-    try {
-      localStorage.setItem(
-        localStorageKey,
-        JSON.stringify({
-          groupId: this.props.group.id,
-          value: nextState.value,
-        })
+    if (onUpdate) {
+      onUpdate(
+        {
+          text: this.state.value,
+        },
+        this.props.item
       );
-    } catch (ex) {
-      logException(ex);
     }
-  },
+  };
+
+  finish = () => {
+    this.props.onEditFinish && this.props.onEditFinish();
+  };
+
+  finalizeMentions = () => {
+    const {memberMentions, teamMentions} = this.state;
+
+    // each mention looks like [id, display]
+    return [...memberMentions, ...teamMentions]
+      .filter(mention => this.state.value.indexOf(mention[1]) !== -1)
+      .map(mention => mention[0]);
+  };
 
-  toggleEdit() {
+  handleToggleEdit = () => {
     this.setState({preview: false});
-  },
+  };
 
-  togglePreview() {
+  handleTogglePreview = () => {
     this.setState({preview: true});
-  },
+  };
 
-  onSubmit(e) {
+  handleSubmit = e => {
     e.preventDefault();
     this.submitForm();
-  },
+  };
 
-  submitForm() {
-    this.setState({
-      loading: true,
-      error: false,
-      errorJSON: null,
-    });
+  handleChange = e => {
+    this.setState({value: e.target.value});
 
-    if (this.state.updating) {
-      this.update();
-    } else {
-      this.create();
+    if (this.props.onChange) {
+      this.props.onChange(e, {updating: !!this.props.item});
     }
-  },
+  };
 
-  cleanMarkdown(text) {
-    return text
-      .replace(/\[sentry\.strip:member\]/g, '@')
-      .replace(/\[sentry\.strip:team\]/g, '');
-  },
-
-  create() {
-    const {group} = this.props;
-
-    const loadingIndicator = IndicatorStore.add(t('Posting comment..'));
-
-    this.props.api.request('/issues/' + group.id + '/comments/', {
-      method: 'POST',
-      data: {
-        text: this.cleanMarkdown(this.state.value),
-        mentions: this.finalizeMentions(),
-      },
-      error: error => {
-        this.setState({
-          loading: false,
-          preview: false,
-          error: true,
-          errorJSON: error.responseJSON || makeDefaultErrorJson(),
-        });
-      },
-      success: data => {
-        this.setState({
-          value: '',
-          preview: false,
-          expanded: false,
-          loading: false,
-          mentions: [],
-        });
-        GroupStore.addActivity(group.id, data);
-        this.finish();
-      },
-      complete: () => {
-        IndicatorStore.remove(loadingIndicator);
-      },
-    });
-  },
-
-  update() {
-    const {group, item} = this.props;
-
-    const loadingIndicator = IndicatorStore.add(t('Updating comment..'));
-
-    this.props.api.request('/issues/' + group.id + '/comments/' + item.id + '/', {
-      method: 'PUT',
-      data: {
-        text: this.state.value,
-      },
-      error: error => {
-        this.setState({
-          loading: false,
-          preview: false,
-          error: true,
-          errorJSON: error.responseJSON || makeDefaultErrorJson(),
-        });
-        IndicatorStore.remove(loadingIndicator);
-      },
-      success: data => {
-        this.setState({
-          preview: false,
-          expanded: false,
-          loading: false,
-        });
-        GroupStore.updateActivity(group.id, item.id, {text: this.state.value});
-        IndicatorStore.remove(loadingIndicator);
-        this.finish();
-      },
-    });
-  },
-
-  onChange(e) {
-    this.setState({value: e.target.value});
-  },
-
-  onKeyDown(e) {
+  handleKeyDown = e => {
     // Auto submit the form on [meta] + Enter
     if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
       this.submitForm();
     }
-  },
+  };
 
-  onCancel(e) {
+  handleCancel = e => {
     e.preventDefault();
     this.finish();
-  },
+  };
 
-  onAddMember(id, display) {
+  handleAddMember = (id, display) => {
     this.setState(({memberMentions}) => ({
       memberMentions: [...memberMentions, [id, display]],
     }));
-  },
+  };
 
-  onAddTeam(id, display) {
+  handleAddTeam = (id, display) => {
     this.setState(({teamMentions}) => ({
       teamMentions: [...teamMentions, [id, display]],
     }));
-  },
-
-  finish() {
-    this.props.onFinish && this.props.onFinish();
-  },
-
-  finalizeMentions() {
-    const {memberMentions, teamMentions} = this.state;
-
-    // each mention looks like [id, display]
-    return [...memberMentions, ...teamMentions]
-      .filter(mention => this.state.value.indexOf(mention[1]) !== -1)
-      .map(mention => mention[0]);
-  },
-
-  expand(e) {
-    this.setState({expanded: true});
-
-    // HACK: Move cursor to end of text after autoFocus
-    // we do this my making sure this is only done on the first
-    // onFocus event
-    if (!this.state._hasFocused) {
-      this.setState({_hasFocused: true});
-      const value = e.target.value;
-      e.target.value = '';
-      e.target.value = value;
-    }
-  },
-
-  maybeCollapse() {
-    if (this.state.value === '') {
-      this.setState({expanded: false});
-    }
-  },
-
-  mentionableUsers() {
-    const {memberList, sessionUser} = this.props;
-    return _.uniqBy(memberList, ({id}) => id)
-      .filter(member => sessionUser.id !== member.id)
-      .map(member => ({
-        id: buildUserId(member.id),
-        display: member.name,
-        email: member.email,
-      }));
-  },
-
-  mentionableTeams() {
-    const {group} = this.props;
-    return (
-      ProjectsStore.getBySlug(group.project.slug) || {
-        teams: [],
-      }
-    ).teams.map(team => ({
-      id: buildTeamId(team.id),
-      display: `#${team.slug}`,
-      email: team.id,
-    }));
-  },
+  };
 
   render() {
-    const {
-      error,
-      errorJSON,
-      loading,
-      preview,
-      updating,
-      value,
-      mentionableUsers,
-      mentionableTeams,
-    } = this.state;
-
-    const placeHolderText = t(
-      'Add details or updates to this event. \nTag users with @, or teams with #'
-    );
+    const {preview, value} = this.state;
+    const {busy, item, error, placeholder, errorJSON} = this.props;
 
-    const btnText = updating ? t('Save Comment') : t('Post Comment');
+    const existingItem = !!item;
+    const btnText = existingItem ? t('Save Comment') : t('Post Comment');
 
     const errorMessage =
       (errorJSON &&
@@ -324,16 +202,16 @@ const NoteInput = createReactClass({
         data-test-id="note-input-form"
         noValidate
         error={error}
-        onSubmit={this.onSubmit}
+        onSubmit={this.handleSubmit}
       >
         <NoteInputNavTabs>
           <NoteInputNavTab className={!preview ? 'active' : ''}>
-            <NoteInputNavTabLink onClick={this.toggleEdit}>
-              {updating ? t('Edit') : t('Write')}
+            <NoteInputNavTabLink onClick={this.handleToggleEdit}>
+              {existingItem ? t('Edit') : t('Write')}
             </NoteInputNavTabLink>
           </NoteInputNavTab>
           <NoteInputNavTab className={preview ? 'active' : ''}>
-            <NoteInputNavTabLink onClick={this.togglePreview}>
+            <NoteInputNavTabLink onClick={this.handleTogglePreview}>
               {t('Preview')}
             </NoteInputNavTabLink>
           </NoteInputNavTab>
@@ -351,14 +229,14 @@ const NoteInput = createReactClass({
           ) : (
             <MentionsInput
               style={mentionsStyle}
-              placeholder={placeHolderText}
-              onChange={this.onChange}
-              onBlur={this.onBlur}
-              onKeyDown={this.onKeyDown}
+              placeholder={placeholder}
+              onChange={this.handleChange}
+              onBlur={this.handleBlur}
+              onKeyDown={this.handleKeyDown}
               value={value}
               required={true}
               autoFocus={true}
-              displayTransform={(id, display, type) =>
+              displayTransform={(_id, display, type) =>
                 `${type === 'member' ? '@' : ''}${display}`
               }
               markup="**[sentry.strip:__type__]__display__**"
@@ -366,15 +244,15 @@ const NoteInput = createReactClass({
               <Mention
                 type="member"
                 trigger="@"
-                data={mentionableUsers}
-                onAdd={this.onAddMember}
+                data={this.mentionableUsers()}
+                onAdd={this.handleAddMember}
                 appendSpaceOnAdd={true}
               />
               <Mention
                 type="team"
                 trigger="#"
-                data={mentionableTeams}
-                onAdd={this.onAddTeam}
+                data={this.mentionableTeams()}
+                onAdd={this.handleAddTeam}
                 appendSpaceOnAdd={true}
               />
             </MentionsInput>
@@ -384,20 +262,20 @@ const NoteInput = createReactClass({
         <Footer>
           <div>{errorMessage && <ErrorMessage>{errorMessage}</ErrorMessage>}</div>
           <div>
-            {updating && (
-              <FooterButton priority="danger" type="button" onClick={this.onCancel}>
+            {existingItem && (
+              <FooterButton priority="danger" type="button" onClick={this.handleCancel}>
                 {t('Cancel')}
               </FooterButton>
             )}
-            <FooterButton error={errorMessage} type="submit" disabled={loading}>
+            <FooterButton error={errorMessage} type="submit" disabled={busy}>
               {btnText}
             </FooterButton>
           </div>
         </Footer>
       </NoteInputForm>
     );
-  },
-});
+  }
+}
 
 export {NoteInput};
 
diff --git a/src/sentry/static/sentry/app/components/activity/note/inputWithStorage.jsx b/src/sentry/static/sentry/app/components/activity/note/inputWithStorage.jsx
new file mode 100644
index 0000000000..5440c866ae
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/activity/note/inputWithStorage.jsx
@@ -0,0 +1,133 @@
+import _ from 'lodash';
+import PropTypes from 'prop-types';
+import React from 'react';
+import * as Sentry from '@sentry/browser';
+
+import NoteInput from 'app/components/activity/note/input';
+import localStorage from 'app/utils/localStorage';
+
+class NoteInputWithStorage extends React.Component {
+  static propTypes = {
+    storageKey: PropTypes.string.isRequired,
+    itemKey: PropTypes.string.isRequired,
+    onLoad: PropTypes.func.isRequired,
+    onSave: PropTypes.func.isRequired,
+    onChange: PropTypes.func,
+    onCreate: PropTypes.func,
+  };
+
+  static defaultProps = {
+    onSave: i => i,
+    onLoad: i => i,
+  };
+
+  fetchFromStorage = () => {
+    const {storageKey} = this.props;
+
+    const storage = localStorage.getItem(storageKey);
+    if (!storage) {
+      return null;
+    }
+
+    try {
+      return JSON.parse(storage);
+    } catch (err) {
+      Sentry.withScope(scope => {
+        scope.setExtra('storage', storage);
+        Sentry.captureException(err);
+      });
+      return null;
+    }
+  };
+
+  saveToStorage = obj => {
+    const {storageKey} = this.props;
+
+    try {
+      localStorage.setItem(storageKey, JSON.stringify(obj));
+    } catch (err) {
+      Sentry.captureException(err);
+      Sentry.withScope(scope => {
+        scope.setExtra('storage', obj);
+        Sentry.captureException(err);
+      });
+    }
+  };
+
+  getValue = () => {
+    const {itemKey, onLoad} = this.props;
+
+    const storageObj = this.fetchFromStorage();
+
+    if (!storageObj) {
+      return '';
+    }
+
+    if (!storageObj.hasOwnProperty(itemKey)) {
+      return '';
+    }
+
+    return onLoad(storageObj[itemKey]);
+  };
+
+  save = _.debounce(value => {
+    const {itemKey, onSave} = this.props;
+
+    const currentObj = this.fetchFromStorage() || {};
+    this.saveToStorage({...currentObj, [itemKey]: onSave(value)});
+  }, 150);
+
+  handleChange = (e, options = {}) => {
+    const {onChange} = this.props;
+
+    if (onChange) {
+      onChange(e, options);
+    }
+
+    if (options.updating) {
+      return;
+    }
+
+    this.save(e.target.value);
+  };
+
+  /**
+   * Handler when note is created.
+   *
+   * Remove in progress item from local storage if it exists
+   */
+  handleCreate = (...args) => {
+    const {itemKey, onCreate} = this.props;
+
+    if (onCreate) {
+      onCreate(...args);
+    }
+
+    // Remove from local storage
+    const storageObj = this.fetchFromStorage() || {};
+
+    // Nothing from this `itemKey` is saved to storage, do nothing
+    if (!storageObj.hasOwnProperty(itemKey)) {
+      return;
+    }
+
+    // Remove `itemKey` from stored object and save to storage
+    // eslint-disable-next-line no-unused-vars
+    const {[itemKey]: _oldItem, ...newStorageObj} = storageObj;
+    this.saveToStorage(newStorageObj);
+  };
+
+  render() {
+    // Make sure `this.props` does not override `onChange` and `onCreate`
+    return (
+      <NoteInput
+        defaultText={this.getValue()}
+        {...this.props}
+        onCreate={this.handleCreate}
+        onChange={this.handleChange}
+      />
+    );
+  }
+}
+
+export default NoteInputWithStorage;
diff --git a/src/sentry/static/sentry/app/utils/__mocks__/localStorage.jsx b/src/sentry/static/sentry/app/utils/__mocks__/localStorage.jsx
index 8839003455..a50ff82387 100644
--- a/src/sentry/static/sentry/app/utils/__mocks__/localStorage.jsx
+++ b/src/sentry/static/sentry/app/utils/__mocks__/localStorage.jsx
@@ -1,15 +1,15 @@
 const localStorageMock = function() {
   let store = {};
   return {
-    getItem: function(key) {
+    getItem: jest.fn(key => {
       return store[key];
-    },
-    setItem: function(key, value) {
+    }),
+    setItem: jest.fn((key, value) => {
       store[key] = value.toString();
-    },
-    clear: function() {
+    }),
+    clear: jest.fn(() => {
       store = {};
-    },
+    }),
   };
 };
 
diff --git a/src/sentry/static/sentry/app/views/groupDetails/shared/groupActivity.jsx b/src/sentry/static/sentry/app/views/groupDetails/shared/groupActivity.jsx
index 0f944efac2..3a5f7a2303 100644
--- a/src/sentry/static/sentry/app/views/groupDetails/shared/groupActivity.jsx
+++ b/src/sentry/static/sentry/app/views/groupDetails/shared/groupActivity.jsx
@@ -1,314 +1,211 @@
 import PropTypes from 'prop-types';
 import React from 'react';
-import createReactClass from 'create-react-class';
+import _ from 'lodash';
 
 import {
   addErrorMessage,
   addLoadingMessage,
-  removeIndicator,
+  clearIndicators,
 } from 'app/actionCreators/indicator';
-import {t, tct, tn} from 'app/locale';
+import {createNote, deleteNote, updateNote} from 'app/actionCreators/group';
+import {t} from 'app/locale';
+import {uniqueId} from 'app/utils/guid';
 import ActivityAuthor from 'app/components/activity/author';
 import ActivityItem from 'app/components/activity/item';
 import Avatar from 'app/components/avatar';
-import CommitLink from 'app/components/commitLink';
 import ConfigStore from 'app/stores/configStore';
-import Duration from 'app/components/duration';
 import ErrorBoundary from 'app/components/errorBoundary';
-import GroupStore from 'app/stores/groupStore';
+import GroupActivityItem from 'app/views/groupDetails/shared/groupActivityItem';
 import MemberListStore from 'app/stores/memberListStore';
 import Note from 'app/components/activity/note';
-import NoteInput from 'app/components/activity/note/input';
-import PullRequestLink from 'app/components/pullRequestLink';
+import NoteInputWithStorage from 'app/components/activity/note/inputWithStorage';
+import ProjectsStore from 'app/stores/projectsStore';
 import SentryTypes from 'app/sentryTypes';
-import TeamStore from 'app/stores/teamStore';
-import Version from 'app/components/version';
 import withApi from 'app/utils/withApi';
 import withOrganization from 'app/utils/withOrganization';
 
-class GroupActivityItem extends React.Component {
+function makeDefaultErrorJson() {
+  return {detail: t('Unknown error. Please try again.')};
+}
+
+class GroupActivity extends React.Component {
+  // TODO(dcramer): only re-render on group/activity change
   static propTypes = {
+    api: PropTypes.object,
     organization: SentryTypes.Organization.isRequired,
-    author: PropTypes.node,
-    item: PropTypes.object,
-    orgId: PropTypes.string,
-    projectId: PropTypes.string,
+    group: SentryTypes.Group,
   };
 
-  render() {
-    const {organization, author, item, orgId, projectId} = this.props;
-    const {data} = item;
-
-    const hasSentry10 = new Set(organization.features).has('sentry10');
-
-    const issuesLink = hasSentry10
-      ? `/organizations/${orgId}/issues/`
-      : `/${orgId}/${projectId}/issues/`;
+  state = {
+    createBusy: false,
+    preview: false,
+    error: false,
+    inputId: uniqueId(),
+  };
 
-    switch (item.type) {
-      case 'note':
-        return t('%s left a comment', author);
-      case 'set_resolved':
-        return t('%s marked this issue as resolved', author);
-      case 'set_resolved_by_age':
-        return t('%(author)s marked this issue as resolved due to inactivity', {
-          author,
-        });
-      case 'set_resolved_in_release':
-        return data.version
-          ? t('%(author)s marked this issue as resolved in %(version)s', {
-              author,
-              version: (
-                <Version version={data.version} orgId={orgId} projectId={projectId} />
-              ),
-            })
-          : t('%s marked this issue as resolved in the upcoming release', author);
-      case 'set_resolved_in_commit':
-        return t('%(author)s marked this issue as resolved in %(version)s', {
-          author,
-          version: (
-            <CommitLink
-              inline={true}
-              commitId={data.commit && data.commit.id}
-              repository={data.commit && data.commit.repository}
-            />
-          ),
-        });
-      case 'set_resolved_in_pull_request':
-        return t('%(author)s marked this issue as resolved in %(version)s', {
-          author,
-          version: (
-            <PullRequestLink
-              inline={true}
-              pullRequest={data.pullRequest}
-              repository={data.pullRequest && data.pullRequest.repository}
-            />
-          ),
-        });
-      case 'set_unresolved':
-        return t('%s marked this issue as unresolved', author);
-      case 'set_ignored':
-        if (data.ignoreDuration) {
-          return t('%(author)s ignored this issue for %(duration)s', {
-            author,
-            duration: <Duration seconds={data.ignoreDuration * 60} />,
-          });
-        } else if (data.ignoreCount && data.ignoreWindow) {
-          return tct(
-            '[author] ignored this issue until it happens [count] time(s) in [duration]',
-            {
-              author,
-              count: data.ignoreCount,
-              duration: <Duration seconds={data.ignoreWindow * 60} />,
-            }
-          );
-        } else if (data.ignoreCount) {
-          return tct('[author] ignored this issue until it happens [count] time(s)', {
-            author,
-            count: data.ignoreCount,
-          });
-        } else if (data.ignoreUserCount && data.ignoreUserWindow) {
-          return tct(
-            '[author] ignored this issue until it affects [count] user(s) in [duration]',
-            {
-              author,
-              count: data.ignoreUserCount,
-              duration: <Duration seconds={data.ignoreUserWindow * 60} />,
-            }
-          );
-        } else if (data.ignoreUserCount) {
-          return tct('[author] ignored this issue until it affects [count] user(s)', {
-            author,
-            count: data.ignoreUserCount,
-          });
-        }
-        return t('%s ignored this issue', author);
-      case 'set_public':
-        return t('%s made this issue public', author);
-      case 'set_private':
-        return t('%s made this issue private', author);
-      case 'set_regression':
-        return data.version
-          ? t('%(author)s marked this issue as a regression in %(version)s', {
-              author,
-              version: (
-                <Version version={data.version} orgId={orgId} projectId={projectId} />
-              ),
-            })
-          : t('%s marked this issue as a regression', author);
-      case 'create_issue':
-        return t('%(author)s created an issue on %(provider)s titled %(title)s', {
-          author,
-          provider: data.provider,
-          title: <a href={data.location}>{data.title}</a>,
-        });
-      case 'unmerge_source':
-        return tn(
-          '%2$s migrated %1$s fingerprint to %3$s',
-          '%2$s migrated %1$s fingerprints to %3$s',
-          data.fingerprints.length,
-          author,
-          data.destination ? (
-            <a href={`${issuesLink}${data.destination.id}`}>{data.destination.shortId}</a>
-          ) : (
-            t('a group')
-          )
-        );
-      case 'unmerge_destination':
-        return tn(
-          '%2$s migrated %1$s fingerprint from %3$s',
-          '%2$s migrated %1$s fingerprints from %3$s',
-          data.fingerprints.length,
-          author,
-          data.source ? (
-            <a href={`${issuesLink}${data.source.id}`}>{data.source.shortId}</a>
-          ) : (
-            t('a group')
-          )
-        );
-      case 'first_seen':
-        return t('%s first saw this issue', author);
-      case 'assigned':
-        let assignee;
+  getMemberList = (memberList, sessionUser) =>
+    _.uniqBy(memberList, ({id}) => id).filter(({id}) => sessionUser.id !== id);
 
-        if (data.assigneeType == 'team') {
-          const team = TeamStore.getById(data.assignee);
-          assignee = team ? team.slug : '<unknown-team>';
+  handleNoteDelete = async item => {
+    const {api, group} = this.props;
 
-          return t('%(author)s assigned this issue to #%(assignee)s', {
-            author,
-            assignee,
-          });
-        }
+    addLoadingMessage(t('Removing comment...'));
 
-        if (item.user && data.assignee === item.user.id) {
-          return t('%s assigned this issue to themselves', author);
-        } else {
-          assignee = MemberListStore.getById(data.assignee);
-          if (assignee && assignee.email) {
-            return t('%(author)s assigned this issue to %(assignee)s', {
-              author,
-              assignee: assignee.email,
-            });
-          } else {
-            return t('%s assigned this issue to an unknown user', author);
-          }
-        }
-      case 'unassigned':
-        return t('%s unassigned this issue', author);
-      case 'merge':
-        return tn(
-          '%2$s merged %1$s issue into this issue',
-          '%2$s merged %1$s issues into this issue',
-          data.issues.length,
-          author
-        );
-      default:
-        return ''; // should never hit (?)
+    try {
+      await deleteNote(api, group, item);
+      clearIndicators();
+    } catch (_err) {
+      addErrorMessage(t('Failed to delete comment'));
     }
-  }
-}
+  };
 
-const GroupActivity = createReactClass({
-  displayName: 'GroupActivity',
+  handleNoteCreate = async note => {
+    const {api, group} = this.props;
 
-  // TODO(dcramer): only re-render on group/activity change
-  propTypes: {
-    api: PropTypes.object,
-    organization: SentryTypes.Organization.isRequired,
-    group: SentryTypes.Group,
-  },
-
-  onNoteDelete(item) {
-    const {group} = this.props;
+    this.setState({
+      createBusy: true,
+    });
 
-    // Optimistically remove from UI
-    const index = GroupStore.removeActivity(group.id, item.id);
-    if (index === -1) {
-      // I dunno, the id wasn't found in the GroupStore
-      return;
+    addLoadingMessage(t('Posting comment...'));
+
+    try {
+      await createNote(api, group, note);
+
+      this.setState({
+        createBusy: false,
+        preview: false,
+        mentions: [],
+
+        // This is used as a `key` to Note Input so that after successful post
+        // we reset the value of the input
+        inputId: uniqueId(),
+      });
+      clearIndicators();
+    } catch (error) {
+      this.setState({
+        createBusy: false,
+        preview: false,
+        error: true,
+        errorJSON: error.responseJSON || makeDefaultErrorJson(),
+      });
+      addErrorMessage(t('Unable to post comment'));
     }
+  };
 
-    addLoadingMessage(t('Removing comment...'));
+  handleNoteUpdate = async (note, item) => {
+    const {api, group} = this.props;
 
-    this.props.api.request('/issues/' + group.id + '/comments/' + item.id + '/', {
-      method: 'DELETE',
-      success: () => {
-        removeIndicator();
-      },
-      error: error => {
-        GroupStore.addActivity(group.id, item, index);
-        removeIndicator();
-        addErrorMessage(t('Failed to delete comment'));
-      },
+    this.setState({
+      updateBusy: true,
     });
-  },
+    addLoadingMessage(t('Updating comment...'));
+
+    try {
+      await updateNote(api, group, item, note);
+      this.setState({
+        updateBusy: false,
+        preview: false,
+      });
+      clearIndicators();
+    } catch (error) {
+      this.setState({
+        updateBusy: false,
+        preview: false,
+        error: true,
+        errorJSON: error.responseJSON || makeDefaultErrorJson(),
+      });
+      addErrorMessage(t('Unable to update comment'));
+    }
+  };
+
+  getMentionableTeams = projectSlug => {
+    return (
+      ProjectsStore.getBySlug(projectSlug) || {
+        teams: [],
+      }
+    ).teams;
+  };
 
   render() {
     const {organization, group} = this.props;
     const me = ConfigStore.get('user');
-    const memberList = MemberListStore.getAll();
-
-    const children = group.activity.map((item, itemIdx) => {
-      const authorName = item.user ? item.user.name : 'Sentry';
-
-      if (item.type === 'note') {
-        return (
-          <Note
-            group={group}
-            item={item}
-            key={`note-${item.id}`}
-            id={`note-${item.id}`}
-            author={{
-              name: authorName,
-              avatar: <Avatar user={item.user} size={38} />,
-            }}
-            onDelete={this.onNoteDelete}
-            sessionUser={me}
-            memberList={memberList}
-          />
-        );
-      } else {
-        const author = {
-          name: authorName,
-        };
-
-        return (
-          <ActivityItem
-            item={item}
-            key={`group-activity-item-${item.id}`}
-            author={{type: item.user ? 'user' : 'system', user: item.user}}
-            date={item.dateCreated}
-            header={
-              <ErrorBoundary mini>
-                <GroupActivityItem
-                  organization={organization}
-                  author={<ActivityAuthor>{author.name}</ActivityAuthor>}
-                  item={item}
-                  orgId={this.props.params.orgId}
-                  projectId={group.project.slug}
-                />
-              </ErrorBoundary>
-            }
-          />
-        );
-      }
-    });
+    const memberList = this.getMemberList(MemberListStore.getAll(), me);
+    const teams = this.getMentionableTeams(group && group.project && group.project.slug);
+    const noteProps = {
+      group,
+      memberList,
+      teams,
+      placeholder: t(
+        'Add details or updates to this event. \nTag users with @, or teams with #'
+      ),
+    };
 
     return (
       <div className="row">
         <div className="col-md-9">
           <div>
             <ActivityItem author={{type: 'user', user: me}}>
-              {() => <NoteInput group={group} memberList={memberList} sessionUser={me} />}
+              {() => (
+                <NoteInputWithStorage
+                  key={this.state.inputId}
+                  storageKey="groupinput:latest"
+                  itemKey={group.id}
+                  onCreate={this.handleNoteCreate}
+                  busy={this.state.createBusy}
+                  error={this.state.error}
+                  errorJSON={this.state.errorJSON}
+                  {...noteProps}
+                />
+              )}
             </ActivityItem>
-            {children}
+
+            {group.activity.map(item => {
+              const authorName = item.user ? item.user.name : 'Sentry';
+
+              if (item.type === 'note') {
+                return (
+                  <ErrorBoundary mini key={`note-${item.id}`}>
+                    <Note
+                      item={item}
+                      id={`note-${item.id}`}
+                      author={{
+                        name: authorName,
+                        avatar: <Avatar user={item.user} size={38} />,
+                      }}
+                      onDelete={this.handleNoteDelete}
+                      onUpdate={this.handleNoteUpdate}
+                      busy={this.state.updateBusy}
+                      {...noteProps}
+                    />
+                  </ErrorBoundary>
+                );
+              } else {
+                return (
+                  <ErrorBoundary mini key={`item-${item.id}`}>
+                    <ActivityItem
+                      item={item}
+                      author={{type: item.user ? 'user' : 'system', user: item.user}}
+                      date={item.dateCreated}
+                      header={
+                        <GroupActivityItem
+                          organization={organization}
+                          author={<ActivityAuthor>{authorName}</ActivityAuthor>}
+                          item={item}
+                          orgId={this.props.params.orgId}
+                          projectId={group.project.slug}
+                        />
+                      }
+                    />
+                  </ErrorBoundary>
+                );
+              }
+            })}
           </div>
         </div>
       </div>
     );
-  },
-});
+  }
+}
 
 export {GroupActivity};
 export default withApi(withOrganization(GroupActivity));
diff --git a/src/sentry/static/sentry/app/views/groupDetails/shared/groupActivityItem.jsx b/src/sentry/static/sentry/app/views/groupDetails/shared/groupActivityItem.jsx
new file mode 100644
index 0000000000..2dceab449e
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/groupDetails/shared/groupActivityItem.jsx
@@ -0,0 +1,196 @@
+import PropTypes from 'prop-types';
+import React from 'react';
+
+import {t, tct, tn} from 'app/locale';
+import CommitLink from 'app/components/commitLink';
+import Duration from 'app/components/duration';
+import MemberListStore from 'app/stores/memberListStore';
+import PullRequestLink from 'app/components/pullRequestLink';
+import SentryTypes from 'app/sentryTypes';
+import TeamStore from 'app/stores/teamStore';
+import Version from 'app/components/version';
+
+class GroupActivityItem extends React.Component {
+  static propTypes = {
+    organization: SentryTypes.Organization.isRequired,
+    author: PropTypes.node,
+    item: PropTypes.object,
+    orgId: PropTypes.string,
+    projectId: PropTypes.string,
+  };
+
+  render() {
+    const {organization, author, item, orgId, projectId} = this.props;
+    const {data} = item;
+
+    const hasSentry10 = new Set(organization.features).has('sentry10');
+
+    const issuesLink = hasSentry10
+      ? `/organizations/${orgId}/issues/`
+      : `/${orgId}/${projectId}/issues/`;
+
+    switch (item.type) {
+      case 'note':
+        return t('%s left a comment', author);
+      case 'set_resolved':
+        return t('%s marked this issue as resolved', author);
+      case 'set_resolved_by_age':
+        return t('%(author)s marked this issue as resolved due to inactivity', {
+          author,
+        });
+      case 'set_resolved_in_release':
+        return data.version
+          ? t('%(author)s marked this issue as resolved in %(version)s', {
+              author,
+              version: (
+                <Version version={data.version} orgId={orgId} projectId={projectId} />
+              ),
+            })
+          : t('%s marked this issue as resolved in the upcoming release', author);
+      case 'set_resolved_in_commit':
+        return t('%(author)s marked this issue as resolved in %(version)s', {
+          author,
+          version: (
+            <CommitLink
+              inline={true}
+              commitId={data.commit && data.commit.id}
+              repository={data.commit && data.commit.repository}
+            />
+          ),
+        });
+      case 'set_resolved_in_pull_request':
+        return t('%(author)s marked this issue as resolved in %(version)s', {
+          author,
+          version: (
+            <PullRequestLink
+              inline={true}
+              pullRequest={data.pullRequest}
+              repository={data.pullRequest && data.pullRequest.repository}
+            />
+          ),
+        });
+      case 'set_unresolved':
+        return t('%s marked this issue as unresolved', author);
+      case 'set_ignored':
+        if (data.ignoreDuration) {
+          return t('%(author)s ignored this issue for %(duration)s', {
+            author,
+            duration: <Duration seconds={data.ignoreDuration * 60} />,
+          });
+        } else if (data.ignoreCount && data.ignoreWindow) {
+          return tct(
+            '[author] ignored this issue until it happens [count] time(s) in [duration]',
+            {
+              author,
+              count: data.ignoreCount,
+              duration: <Duration seconds={data.ignoreWindow * 60} />,
+            }
+          );
+        } else if (data.ignoreCount) {
+          return tct('[author] ignored this issue until it happens [count] time(s)', {
+            author,
+            count: data.ignoreCount,
+          });
+        } else if (data.ignoreUserCount && data.ignoreUserWindow) {
+          return tct(
+            '[author] ignored this issue until it affects [count] user(s) in [duration]',
+            {
+              author,
+              count: data.ignoreUserCount,
+              duration: <Duration seconds={data.ignoreUserWindow * 60} />,
+            }
+          );
+        } else if (data.ignoreUserCount) {
+          return tct('[author] ignored this issue until it affects [count] user(s)', {
+            author,
+            count: data.ignoreUserCount,
+          });
+        }
+        return t('%s ignored this issue', author);
+      case 'set_public':
+        return t('%s made this issue public', author);
+      case 'set_private':
+        return t('%s made this issue private', author);
+      case 'set_regression':
+        return data.version
+          ? t('%(author)s marked this issue as a regression in %(version)s', {
+              author,
+              version: (
+                <Version version={data.version} orgId={orgId} projectId={projectId} />
+              ),
+            })
+          : t('%s marked this issue as a regression', author);
+      case 'create_issue':
+        return t('%(author)s created an issue on %(provider)s titled %(title)s', {
+          author,
+          provider: data.provider,
+          title: <a href={data.location}>{data.title}</a>,
+        });
+      case 'unmerge_source':
+        return tn(
+          '%2$s migrated %1$s fingerprint to %3$s',
+          '%2$s migrated %1$s fingerprints to %3$s',
+          data.fingerprints.length,
+          author,
+          data.destination ? (
+            <a href={`${issuesLink}${data.destination.id}`}>{data.destination.shortId}</a>
+          ) : (
+            t('a group')
+          )
+        );
+      case 'unmerge_destination':
+        return tn(
+          '%2$s migrated %1$s fingerprint from %3$s',
+          '%2$s migrated %1$s fingerprints from %3$s',
+          data.fingerprints.length,
+          author,
+          data.source ? (
+            <a href={`${issuesLink}${data.source.id}`}>{data.source.shortId}</a>
+          ) : (
+            t('a group')
+          )
+        );
+      case 'first_seen':
+        return t('%s first saw this issue', author);
+      case 'assigned':
+        let assignee;
+
+        if (data.assigneeType == 'team') {
+          const team = TeamStore.getById(data.assignee);
+          assignee = team ? team.slug : '<unknown-team>';
+
+          return t('%(author)s assigned this issue to #%(assignee)s', {
+            author,
+            assignee,
+          });
+        }
+
+        if (item.user && data.assignee === item.user.id) {
+          return t('%s assigned this issue to themselves', author);
+        } else {
+          assignee = MemberListStore.getById(data.assignee);
+          if (assignee && assignee.email) {
+            return t('%(author)s assigned this issue to %(assignee)s', {
+              author,
+              assignee: assignee.email,
+            });
+          } else {
+            return t('%s assigned this issue to an unknown user', author);
+          }
+        }
+      case 'unassigned':
+        return t('%s unassigned this issue', author);
+      case 'merge':
+        return tn(
+          '%2$s merged %1$s issue into this issue',
+          '%2$s merged %1$s issues into this issue',
+          data.issues.length,
+          author
+        );
+      default:
+        return ''; // should never hit (?)
+    }
+  }
+}
+
+export default GroupActivityItem;
diff --git a/tests/js/helpers/changeReactMentionsInput.js b/tests/js/helpers/changeReactMentionsInput.js
new file mode 100644
index 0000000000..35c014b8a9
--- /dev/null
+++ b/tests/js/helpers/changeReactMentionsInput.js
@@ -0,0 +1,18 @@
+const changeReactMentionsInput = (wrapper, value) => {
+  // Need to do this because of how react-mentions works,
+  // checks that event object is === document.activeElement
+  let el = wrapper.find('textarea').getDOMNode();
+
+  // We need a non-zero width selection for `react-mentions`
+  el.selectionStart = 2;
+  el.selectionEnd = 3;
+  wrapper.find('textarea').simulate('select', {target: el});
+
+  // Finally update element value
+  el = wrapper.find('textarea').getDOMNode();
+  el.value = value;
+  el.selectionEnd = value.length;
+  wrapper.find('textarea').simulate('change', {target: el});
+};
+
+export default changeReactMentionsInput;
diff --git a/tests/js/spec/components/activity/note/input.spec.jsx b/tests/js/spec/components/activity/note/input.spec.jsx
new file mode 100644
index 0000000000..bcded3f6bb
--- /dev/null
+++ b/tests/js/spec/components/activity/note/input.spec.jsx
@@ -0,0 +1,132 @@
+import React from 'react';
+import {mount} from 'enzyme';
+
+import changeReactMentionsInput from 'app-test/helpers/changeReactMentionsInput';
+
+import NoteInput from 'app/components/activity/note/input';
+
+describe('NoteInput', function() {
+  const routerContext = TestStubs.routerContext();
+
+  describe('New item', function() {
+    const props = {
+      group: {project: {}, id: 'groupId'},
+      memberList: [],
+      teams: [],
+    };
+
+    it('renders', function() {
+      mount(<NoteInput {...props} />, routerContext);
+    });
+
+    it('submits when meta + enter is pressed', function() {
+      const onCreate = jest.fn();
+      const wrapper = mount(<NoteInput {...props} onCreate={onCreate} />, routerContext);
+
+      const input = wrapper.find('textarea');
+
+      input.simulate('keyDown', {key: 'Enter', metaKey: true});
+      expect(onCreate).toHaveBeenCalled();
+    });
+
+    it('submits when ctrl + enter is pressed', function() {
+      const onCreate = jest.fn();
+      const wrapper = mount(<NoteInput {...props} onCreate={onCreate} />, routerContext);
+
+      const input = wrapper.find('textarea');
+
+      input.simulate('keyDown', {key: 'Enter', ctrlKey: true});
+      expect(onCreate).toHaveBeenCalled();
+    });
+
+    it('handles errors', async function() {
+      const errorJSON = {detail: {message: '', code: 401, extra: ''}};
+      const wrapper = mount(
+        <NoteInput {...props} error={!!errorJSON} errorJSON={errorJSON} />,
+        routerContext
+      );
+
+      const input = wrapper.find('textarea');
+
+      input.simulate('keyDown', {key: 'Enter', ctrlKey: true});
+      wrapper.update();
+      expect(wrapper.find('ErrorMessage')).toHaveLength(1);
+    });
+  });
+
+  describe('Existing Item', function() {
+    const defaultProps = {
+      group: {project: {}, id: 'groupId'},
+      item: {
+        data: {
+          text: 'an existing item',
+        },
+      },
+      memberList: [],
+      teams: [],
+    };
+
+    const createWrapper = props => {
+      return mount(<NoteInput {...defaultProps} {...props} />, routerContext);
+    };
+
+    it('edits existing message', async function() {
+      const onUpdate = jest.fn();
+      const wrapper = createWrapper({onUpdate});
+
+      expect(
+        wrapper
+          .find('NoteInputNavTabLink')
+          .first()
+          .text()
+      ).toBe('Edit');
+
+      // Switch to preview
+      wrapper
+        .find('NoteInputNavTabLink')
+        .last()
+        .simulate('click');
+
+      expect(wrapper.find('NotePreview').text()).toBe('an existing item\n');
+
+      // Switch to edit
+      wrapper
+        .find('NoteInputNavTabLink')
+        .first()
+        .simulate('click');
+
+      expect(wrapper.find('textarea').prop('value')).toBe('an existing item');
+
+      // Can edit text
+      changeReactMentionsInput(wrapper, 'new item');
+
+      wrapper.find('textarea').simulate('keyDown', {key: 'Enter', ctrlKey: true});
+
+      expect(onUpdate).toHaveBeenCalledWith(
+        {text: 'new item'},
+        {data: {text: 'an existing item'}}
+      );
+    });
+
+    it('canels editing and moves to preview mode', async function() {
+      const onEditFinish = jest.fn();
+      const wrapper = createWrapper({onEditFinish});
+
+      changeReactMentionsInput(wrapper, 'new value');
+
+      expect(
+        wrapper
+          .find('FooterButton')
+          .first()
+          .text()
+      ).toBe('Cancel');
+
+      wrapper
+        .find('FooterButton')
+        .first()
+        .simulate('click');
+
+      expect(onEditFinish).toHaveBeenCalled();
+    });
+  });
+});
diff --git a/tests/js/spec/components/activity/note/inputWithStorage.spec.jsx b/tests/js/spec/components/activity/note/inputWithStorage.spec.jsx
new file mode 100644
index 0000000000..4768668add
--- /dev/null
+++ b/tests/js/spec/components/activity/note/inputWithStorage.spec.jsx
@@ -0,0 +1,60 @@
+import React from 'react';
+import {mount} from 'enzyme';
+
+import changeReactMentionsInput from 'app-test/helpers/changeReactMentionsInput';
+
+import NoteInputWithStorage from 'app/components/activity/note/inputWithStorage';
+import localStorage from 'app/utils/localStorage';
+
+jest.mock('app/utils/localStorage');
+
+describe('NoteInputWithStorage', function() {
+  const defaultProps = {
+    storageKey: 'storage',
+    itemKey: 'item1',
+    group: {project: {}, id: 'groupId'},
+    memberList: [],
+    teams: [],
+  };
+  const routerContext = TestStubs.routerContext();
+
+  const createWrapper = props => {
+    return mount(<NoteInputWithStorage {...defaultProps} {...props} />, routerContext);
+  };
+
+  it('loads draft item from local storage when mounting', function() {
+    localStorage.getItem.mockImplementation(() => JSON.stringify({item1: 'saved item'}));
+
+    const wrapper = createWrapper();
+
+    expect(localStorage.getItem).toHaveBeenCalledWith('storage');
+    expect(wrapper.find('textarea').prop('value')).toBe('saved item');
+  });
+
+  it('saves draft when input changes', function() {
+    const wrapper = createWrapper();
+
+    changeReactMentionsInput(wrapper, 'WIP COMMENT');
+
+    expect(localStorage.setItem).toHaveBeenCalledWith(
+      'storage',
+      JSON.stringify({item1: 'WIP COMMENT'})
+    );
+  });
+
+  it('removes draft item after submitting', function() {
+    localStorage.getItem.mockImplementation(() =>
+      JSON.stringify({item1: 'draft item', item2: 'item2', item3: 'item3'})
+    );
+
+    const wrapper = createWrapper();
+
+    changeReactMentionsInput(wrapper, 'new comment');
+
+    wrapper.find('textarea').simulate('keyDown', {key: 'Enter', ctrlKey: true});
+    expect(localStorage.setItem).toHaveBeenLastCalledWith(
+      'storage',
+      JSON.stringify({item2: 'item2', item3: 'item3'})
+    );
+  });
+});
diff --git a/tests/js/spec/components/noteInput.spec.jsx b/tests/js/spec/components/noteInput.spec.jsx
deleted file mode 100644
index b76ce251d7..0000000000
--- a/tests/js/spec/components/noteInput.spec.jsx
+++ /dev/null
@@ -1,73 +0,0 @@
-import React from 'react';
-import {mount} from 'enzyme';
-
-import NoteInput from 'app/components/activity/note/input';
-import {Client} from 'app/api';
-
-jest.mock('app/api');
-
-describe('NoteInput', function() {
-  let spy;
-
-  beforeAll(function() {
-    spy = Client.addMockResponse({
-      url: '/issues/groupId/comments/',
-      method: 'POST',
-    });
-  });
-
-  beforeEach(function() {
-    spy.mockReset();
-  });
-
-  it('renders', function() {
-    mount(
-      <NoteInput group={{project: {}}} memberList={[]} sessionUser={{}} />,
-      TestStubs.routerContext()
-    );
-  });
-
-  it('submits when meta + enter is pressed', function() {
-    const wrapper = mount(
-      <NoteInput group={{project: {}, id: 'groupId'}} memberList={[]} sessionUser={{}} />,
-      TestStubs.routerContext()
-    );
-
-    const input = wrapper.find('textarea');
-
-    input.simulate('keyDown', {key: 'Enter', metaKey: true});
-    expect(spy).toHaveBeenCalled();
-  });
-
-  it('submits when ctrl + enter is pressed', function() {
-    const wrapper = mount(
-      <NoteInput group={{project: {}, id: 'groupId'}} memberList={[]} sessionUser={{}} />,
-      TestStubs.routerContext()
-    );
-
-    const input = wrapper.find('textarea');
-
-    input.simulate('keyDown', {key: 'Enter', ctrlKey: true});
-    expect(spy).toHaveBeenCalled();
-  });
-
-  it('handles 401 error objects', async function() {
-    spy = Client.addMockResponse({
-      url: '/issues/groupId/comments/',
-      method: 'POST',
-      body: {detail: {message: '', code: 401, extra: ''}},
-      statusCode: 401,
-    });
-    const wrapper = mount(
-      <NoteInput group={{project: {}, id: 'groupId'}} memberList={[]} sessionUser={{}} />,
-      TestStubs.routerContext()
-    );
-
-    const input = wrapper.find('textarea');
-
-    input.simulate('keyDown', {key: 'Enter', ctrlKey: true});
-    wrapper.update();
-    expect(wrapper.find('ErrorMessage')).toHaveLength(1);
-    expect(spy).toHaveBeenCalled();
-  });
-});
diff --git a/tests/js/spec/views/groupActivity/index.spec.jsx b/tests/js/spec/views/groupDetails/shared/groupActivity.spec.jsx
similarity index 56%
rename from tests/js/spec/views/groupActivity/index.spec.jsx
rename to tests/js/spec/views/groupDetails/shared/groupActivity.spec.jsx
index 68f5c9d64d..e5a7af2bef 100644
--- a/tests/js/spec/views/groupActivity/index.spec.jsx
+++ b/tests/js/spec/views/groupDetails/shared/groupActivity.spec.jsx
@@ -1,5 +1,5 @@
 import React from 'react';
-import {mount, shallow} from 'enzyme';
+import {mount} from 'enzyme';
 
 import {initializeOrg} from 'app-test/helpers/initializeOrg';
 import {GroupActivity} from 'app/views/groupDetails/shared/groupActivity';
@@ -8,6 +8,16 @@ import ConfigStore from 'app/stores/configStore';
 import GroupStore from 'app/stores/groupStore';
 
 describe('GroupActivity', function() {
+  const group = TestStubs.Group({
+    id: '1337',
+    activity: [
+      {type: 'note', id: 'note-1', data: {text: 'Test Note'}, user: TestStubs.User()},
+    ],
+    project: TestStubs.Project(),
+  });
+  const {organization, routerContext} = initializeOrg({
+    group,
+  });
   beforeEach(function() {
     jest.spyOn(ConfigStore, 'get').mockImplementation(key => {
       if (key === 'user') {
@@ -22,14 +32,6 @@ describe('GroupActivity', function() {
   afterEach(function() {});
 
   it('renders a NoteInput', function() {
-    const group = TestStubs.Group({
-      id: '1337',
-      activity: [],
-      project: TestStubs.Project(),
-    });
-    const {organization, routerContext} = initializeOrg({
-      group,
-    });
     const wrapper = mount(
       <GroupActivity
         api={new MockApiClient()}
@@ -41,44 +43,41 @@ describe('GroupActivity', function() {
     expect(wrapper.find(NoteInput)).toHaveLength(1);
   });
 
-  describe('onNoteDelete()', function() {
-    let instance;
+  describe('Delete', function() {
+    let wrapper;
+    let deleteMock;
 
     beforeEach(function() {
-      instance = shallow(
+      deleteMock = MockApiClient.addMockResponse({
+        url: '/issues/1337/comments/note-1/',
+        method: 'DELETE',
+      });
+      wrapper = mount(
         <GroupActivity
           api={new MockApiClient()}
-          group={{id: '1337', activity: []}}
-          organization={TestStubs.Organization()}
+          group={group}
+          organization={organization}
         />,
-        {
-          context: {
-            group: {id: '1337'},
-            project: TestStubs.Project(),
-            team: {id: '1'},
-            organization: {id: 'bar'},
-          },
-        }
-      ).instance();
+        routerContext
+      );
     });
 
     it('should do nothing if not present in GroupStore', function() {
       jest.spyOn(GroupStore, 'removeActivity').mockImplementation(() => -1); // not found
-      const request = jest.spyOn(instance.props.api, 'request');
 
-      instance.onNoteDelete({id: 1});
-      expect(request.calledOnce).not.toBeTruthy();
+      // Would rather call simulate on the actual component but it's in a styled component
+      // that is only visible on hover
+      wrapper.find('NoteHeader').prop('onDelete')();
+      expect(deleteMock).not.toHaveBeenCalled();
     });
 
     it('should remove remove the item from the GroupStore make a DELETE API request', function() {
-      const mock = MockApiClient.addMockResponse({
-        url: '/issues/1337/comments/1/',
-        method: 'DELETE',
-      });
       jest.spyOn(GroupStore, 'removeActivity').mockImplementation(() => 1);
 
-      instance.onNoteDelete({id: 1});
-      expect(mock).toHaveBeenCalledTimes(1);
+      // Would rather call simulate on the actual component but it's in a styled component
+      // that is only visible on hover
+      wrapper.find('NoteHeader').prop('onDelete')();
+      expect(deleteMock).toHaveBeenCalledTimes(1);
     });
   });
 });

commit 71d0adac75133ed05053264a903505cc8b368e4a
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Thu Apr 18 14:13:54 2019 -0700

    feat(dashboard): Change release widget to include all release data [SEN-237] (#12393)
    
    * Adds an additional query field `condition_fields` to discover query endpoint that current only
     supports an "if" clause when selecting a column. i.e. we can do a query like
     "select [if <condition> is true, use <column> value, else use literal value] as alias"
    
     * adds support for a "<column> is in <list>" condition
    
    * Updates release widget to use releases that the rest of the dashboard has access to
      and fetches event stats for each of those releases (and group into "Other" category otherwise)
    
    
    Fixes SEN-237

diff --git a/src/sentry/api/endpoints/organization_discover_query.py b/src/sentry/api/endpoints/organization_discover_query.py
index 93d4b74203..d49156372e 100644
--- a/src/sentry/api/endpoints/organization_discover_query.py
+++ b/src/sentry/api/endpoints/organization_discover_query.py
@@ -42,6 +42,11 @@ class DiscoverQuerySerializer(serializers.Serializer):
         allow_null=True,
         default=[],
     )
+    conditionFields = ListField(
+        child=ListField(),
+        required=False,
+        allow_null=True,
+    )
     limit = serializers.IntegerField(min_value=0, max_value=10000, required=False)
     rollup = serializers.IntegerField(required=False)
     orderby = serializers.CharField(required=False, default="")
@@ -307,7 +312,8 @@ class OrganizationDiscoverQueryEndpoint(OrganizationEndpoint):
 
         has_aggregations = len(serialized.get('aggregations')) > 0
 
-        selected_columns = [] if has_aggregations else serialized.get('fields')
+        selected_columns = serialized.get(
+            'conditionFields', []) + [] if has_aggregations else serialized.get('fields', [])
 
         projects_map = {}
         for project in projects:
diff --git a/src/sentry/static/sentry/app/views/organizationDashboard/data/queries/eventsByRelease.jsx b/src/sentry/static/sentry/app/views/organizationDashboard/data/queries/eventsByRelease.jsx
index 96ede33eb8..c3f158f7c5 100644
--- a/src/sentry/static/sentry/app/views/organizationDashboard/data/queries/eventsByRelease.jsx
+++ b/src/sentry/static/sentry/app/views/organizationDashboard/data/queries/eventsByRelease.jsx
@@ -6,12 +6,13 @@ import {t} from 'app/locale';
 const eventsByRelease = {
   name: t('Events by Release'),
   fields: ['release'],
+  constraints: ['recentReleases'],
   conditions: [],
   aggregations: [['count()', null, 'Events']],
-  limit: 2000,
+  limit: 5000,
 
   orderby: '-time',
-  groupby: ['time'],
+  groupby: ['time', 'release'],
   rollup: 86400,
 };
 
diff --git a/src/sentry/static/sentry/app/views/organizationDashboard/discoverQuery.jsx b/src/sentry/static/sentry/app/views/organizationDashboard/discoverQuery.jsx
index e309443a14..165872e18c 100644
--- a/src/sentry/static/sentry/app/views/organizationDashboard/discoverQuery.jsx
+++ b/src/sentry/static/sentry/app/views/organizationDashboard/discoverQuery.jsx
@@ -9,6 +9,14 @@ import {parsePeriodToHours} from 'app/utils';
 import SentryTypes from 'app/sentryTypes';
 import createQueryBuilder from 'app/views/organizationDiscover/queryBuilder';
 
+const createReleaseFieldCondition = releases => [
+  [
+    'if',
+    [['in', ['release', 'tuple', releases.map(r => `'${r}'`)]], 'release', "'other'"],
+    'release',
+  ],
+];
+
 class DiscoverQuery extends React.Component {
   static propTypes = {
     compareToPeriod: PropTypes.shape({
@@ -19,6 +27,7 @@ class DiscoverQuery extends React.Component {
     organization: SentryTypes.Organization,
     selection: SentryTypes.GlobalSelection,
     queries: PropTypes.arrayOf(SentryTypes.DiscoverQuery),
+    releases: PropTypes.arrayOf(SentryTypes.Release),
   };
 
   constructor(props) {
@@ -31,11 +40,10 @@ class DiscoverQuery extends React.Component {
 
     // Query builders based on `queries`
     this.queryBuilders = [];
-
-    this.createQueryBuilders();
   }
 
   componentDidMount() {
+    this.createQueryBuilders();
     this.fetchData();
   }
 
@@ -44,6 +52,10 @@ class DiscoverQuery extends React.Component {
       return true;
     }
 
+    if (this.props.releases !== nextProps.releases) {
+      return true;
+    }
+
     if (
       this.props.organization === nextProps.organization &&
       this.props.selection === nextProps.selection
@@ -60,7 +72,11 @@ class DiscoverQuery extends React.Component {
       return;
     }
 
-    this.fetchData();
+    if (this.props.releases !== prevProps.releases) {
+      this.createQueryBuilders();
+    } else {
+      this.fetchData();
+    }
   }
 
   componentWillUnmount() {
@@ -69,8 +85,25 @@ class DiscoverQuery extends React.Component {
 
   createQueryBuilders() {
     const {organization, queries} = this.props;
-    queries.forEach(query => {
-      this.queryBuilders.push(createQueryBuilder(this.getQuery(query), organization));
+    queries.forEach(({constraints, ...query}) => {
+      if (constraints && constraints.includes('recentReleases')) {
+        if (!this.props.releases) {
+          return;
+        }
+        const newQuery = {
+          ...query,
+          fields: [],
+          conditionFields:
+            this.props.releases &&
+            createReleaseFieldCondition(this.props.releases.map(({version}) => version)),
+        };
+        this.queryBuilders.push(
+          createQueryBuilder(this.getQuery(newQuery), organization)
+        );
+        this.fetchData();
+      } else {
+        this.queryBuilders.push(createQueryBuilder(this.getQuery(query), organization));
+      }
     });
   }
 
@@ -114,9 +147,6 @@ class DiscoverQuery extends React.Component {
   }
 
   async fetchData() {
-    // Reset query builder
-    this.resetQueries();
-
     // Fetch
     this.setState({reloading: true});
     const promises = this.queryBuilders.map(builder => builder.fetchWithoutLimit());
diff --git a/src/sentry/static/sentry/app/views/organizationDashboard/widget.jsx b/src/sentry/static/sentry/app/views/organizationDashboard/widget.jsx
index 55df4e4dd4..f13bd99f96 100644
--- a/src/sentry/static/sentry/app/views/organizationDashboard/widget.jsx
+++ b/src/sentry/static/sentry/app/views/organizationDashboard/widget.jsx
@@ -32,6 +32,7 @@ class Widget extends React.Component {
     return (
       <ErrorBoundary customComponent={<ErrorCard>{t('Error loading widget')}</ErrorCard>}>
         <DiscoverQuery
+          releases={releases}
           organization={organization}
           selection={selection}
           queries={widget.queries.discover}
diff --git a/src/sentry/utils/snuba.py b/src/sentry/utils/snuba.py
index 56550fa4a1..1caae544d1 100644
--- a/src/sentry/utils/snuba.py
+++ b/src/sentry/utils/snuba.py
@@ -26,6 +26,10 @@ from sentry.utils.dates import to_timestamp
 MAX_ISSUES = 500
 MAX_HASHES = 5000
 
+SAFE_FUNCTION_RE = re.compile(r'-?[a-zA-Z_][a-zA-Z0-9_]*$')
+QUOTED_LITERAL_RE = re.compile(r"^'.*'$")
+
+
 # Global Snuba request option override dictionary. Only intended
 # to be used with the `options_override` contextmanager below.
 # NOT THREAD SAFE!
@@ -263,13 +267,93 @@ def zerofill(data, start, end, rollup, orderby):
 def get_snuba_column_name(name):
     """
     Get corresponding Snuba column name from Sentry snuba map, if not found
-    the column is assumed to be a tag. If name is falsy, leave unchanged.
+    the column is assumed to be a tag. If name is falsy or name is a quoted literal
+    (e.g. "'name'"), leave unchanged.
     """
-    if not name:
+    if not name or QUOTED_LITERAL_RE.match(name):
         return name
+
     return SENTRY_SNUBA_MAP.get(name, u'tags[{}]'.format(name))
 
 
+def get_function_index(column_expr, depth=0):
+    """
+    If column_expr list contains a function, returns the index of its function name
+    within column_expr (and assumption is that index + 1 is the list of arguments),
+    otherwise None.
+
+     A function expression is of the form:
+         [func, [arg1, arg2]]  => func(arg1, arg2)
+     If a string argument is followed by list arg, the pair of them is assumed
+    to be a nested function call, with extra args to the outer function afterward.
+         [func1, [func2, [arg1, arg2], arg3]]  => func1(func2(arg1, arg2), arg3)
+     Although at the top level, there is no outer function call, and the optional
+    3rd argument is interpreted as an alias for the entire expression.
+         [func, [arg1], alias] => function(arg1) AS alias
+     You can also have a function part of an argument list:
+         [func1, [arg1, func2, [arg2, arg3]]] => func1(arg1, func2(arg2, arg3))
+     """
+    index = None
+    if isinstance(column_expr, (tuple, list)):
+        i = 0
+        while i < len(column_expr) - 1:
+            # The assumption here is that a list that follows a string means
+            # the string is a function name
+            if isinstance(column_expr[i], six.string_types) and isinstance(
+                    column_expr[i + 1], (tuple, list)):
+                assert SAFE_FUNCTION_RE.match(column_expr[i])
+                index = i
+                break
+            else:
+                i = i + 1
+
+        return index
+    else:
+        return None
+
+
+def parse_columns_in_functions(col, context=None, index=None):
+    """
+    Checks expressions for arguments that should be considered a column while
+    ignoring strings that represent clickhouse function names
+
+    if col is a list, means the expression has functions and we need
+    to parse for arguments that should be considered column names.
+
+    Assumptions here:
+     * strings that represent clickhouse function names are always followed by a list or tuple
+     * strings that are quoted with single quotes are used as string literals for CH
+     * otherwise we should attempt to get the snuba column name (or custom tag)
+    """
+
+    function_name_index = get_function_index(col)
+
+    if function_name_index is not None:
+        # if this is non zero, that means there are strings before this index
+        # that should be converted to snuba column names
+        # e.g. ['func1', ['column', 'func2', ['arg1']]]
+        if function_name_index > 0:
+            for i in xrange(0, function_name_index):
+                if context is not None:
+                    context[i] = get_snuba_column_name(col[i])
+
+        args = col[function_name_index + 1]
+
+        # check for nested functions in args
+        if get_function_index(args):
+            # look for columns
+            return parse_columns_in_functions(args, args)
+
+        # check each argument for column names
+        else:
+            for (i, arg) in enumerate(args):
+                parse_columns_in_functions(arg, args, i)
+    else:
+        # probably a column name
+        if context is not None and index is not None:
+            context[index] = get_snuba_column_name(col)
+
+
 def get_arrayjoin(column):
     match = re.match(r'^(exception_stacks|exception_frames|contexts)\..+$', column)
     if match:
@@ -299,12 +383,24 @@ def transform_aliases_and_query(**kwargs):
     filter_keys = kwargs['filter_keys']
 
     for (idx, col) in enumerate(selected_columns):
-        name = get_snuba_column_name(col)
-        selected_columns[idx] = name
-        translated_columns[name] = col
+        if isinstance(col, list):
+            # if list, means there are potentially nested functions and need to
+            # iterate and translate potential columns
+            parse_columns_in_functions(col)
+            selected_columns[idx] = col
+            translated_columns[col[2]] = col[2]
+            derived_columns.add(col[2])
+        else:
+            name = get_snuba_column_name(col)
+            selected_columns[idx] = name
+            translated_columns[name] = col
 
     for (idx, col) in enumerate(groupby):
-        name = get_snuba_column_name(col)
+        if col not in derived_columns:
+            name = get_snuba_column_name(col)
+        else:
+            name = col
+
         groupby[idx] = name
         translated_columns[name] = col
 
diff --git a/tests/js/spec/views/organizationDashboard/discoverQuery.spec.jsx b/tests/js/spec/views/organizationDashboard/discoverQuery.spec.jsx
index bde3b426ad..67d66b071e 100644
--- a/tests/js/spec/views/organizationDashboard/discoverQuery.spec.jsx
+++ b/tests/js/spec/views/organizationDashboard/discoverQuery.spec.jsx
@@ -153,4 +153,62 @@ describe('DiscoverQuery', function() {
       })
     );
   });
+
+  it('queries using "recentReleases" constraint', function() {
+    const release = TestStubs.Release();
+    renderMock.mockClear();
+    wrapper = mount(
+      <DiscoverQuery
+        selection={{datetime: {period: '12h'}}}
+        organization={organization}
+        releases={[release]}
+        queries={[
+          {
+            name: 'Events by Release',
+            fields: ['release'],
+            constraints: ['recentReleases'],
+            conditions: [],
+            aggregations: [['count()', null, 'Events']],
+            limit: 5000,
+
+            orderby: '-time',
+            groupby: ['time', 'release'],
+            rollup: 86400,
+          },
+        ]}
+      >
+        {renderMock}
+      </DiscoverQuery>,
+      routerContext
+    );
+
+    mockRouterPush(wrapper, router);
+
+    expect(discoverMock).toHaveBeenLastCalledWith(
+      '/organizations/org-slug/discover/query/',
+      expect.objectContaining({
+        data: expect.objectContaining({
+          aggregations: [['count()', null, 'Events']],
+          conditionFields: [
+            [
+              'if',
+              [
+                ['in', ['release', 'tuple', [`'${release.version}'`]]],
+                'release',
+                "'other'",
+              ],
+              'release',
+            ],
+          ],
+          fields: [],
+          groupby: ['time', 'release'],
+          conditions: [],
+          limit: 5000,
+          name: 'Events by Release',
+          orderby: '-time',
+        }),
+        method: 'POST',
+      })
+    );
+  });
 });
diff --git a/tests/snuba/api/endpoints/test_organization_discover_query.py b/tests/snuba/api/endpoints/test_organization_discover_query.py
index 121079cdf6..09da54353b 100644
--- a/tests/snuba/api/endpoints/test_organization_discover_query.py
+++ b/tests/snuba/api/endpoints/test_organization_discover_query.py
@@ -30,7 +30,7 @@ class OrganizationDiscoverQueryTest(APITestCase, SnubaTestCase):
             group=self.group,
             platform="python",
             datetime=one_second_ago,
-            tags={'environment': 'production'},
+            tags={'environment': 'production', 'sentry:release': 'foo'},
             data={
                 'message': 'message!',
                 'exception': {
@@ -121,6 +121,71 @@ class OrganizationDiscoverQueryTest(APITestCase, SnubaTestCase):
 
         assert response.status_code == 400, response.content
 
+    def test_conditional_fields(self):
+        with self.feature('organizations:discover'):
+            one_second_ago = self.now - timedelta(seconds=1)
+            self.create_event(
+                group=self.group,
+                platform="javascript",
+                datetime=one_second_ago,
+                tags={'environment': 'production', 'sentry:release': 'bar'},
+                data={
+                },
+            )
+
+            self.create_event(
+                group=self.group,
+                platform="javascript",
+                datetime=one_second_ago,
+                tags={'environment': 'production', 'sentry:release': 'baz'},
+                data={
+                },
+            )
+
+            url = reverse('sentry-api-0-organization-discover-query', args=[self.org.slug])
+            response = self.client.post(url, {
+                'projects': [self.project.id],
+                'aggregations': [['count()', None, 'count']],
+                'conditionFields': [
+                    [
+                        'if',
+                        [
+                            [
+                                'in',
+                                [
+                                    'release',
+                                    'tuple',
+                                    ["'foo'"],
+                                ],
+                            ],
+                            'release',
+                            "'other'",
+                        ],
+                        'release',
+                    ],
+                ],
+                'start': (datetime.now() - timedelta(seconds=10)).strftime('%Y-%m-%dT%H:%M:%S'),
+                'end': (datetime.now()).strftime('%Y-%m-%dT%H:%M:%S'),
+                'groupby': ['time', 'release'],
+                'rollup': 86400,
+                'limit': 1000,
+                'orderby': '-time',
+                'range': None,
+            })
+
+        assert response.status_code == 200, response.content
+
+        # rollup is by one day and diff of start/end is 10 seconds, so we only have one day
+        assert len(response.data['data']) == 2
+
+        for data in response.data['data']:
+            # note this "release" key represents the alias for the column condition
+            # and is also used in `groupby`, it is NOT the release tag
+            if data['release'] == 'foo':
+                assert data['count'] == 1
+            elif data['release'] == 'other':
+                assert data['count'] == 2
+
     def test_invalid_range_value(self):
         with self.feature('organizations:discover'):
             url = reverse('sentry-api-0-organization-discover-query', args=[self.org.slug])

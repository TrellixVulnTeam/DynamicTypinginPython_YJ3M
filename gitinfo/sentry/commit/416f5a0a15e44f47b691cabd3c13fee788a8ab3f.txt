commit 416f5a0a15e44f47b691cabd3c13fee788a8ab3f
Author: Ben Vinegar <ben@benv.ca>
Date:   Tue Sep 8 19:51:05 2015 -0700

    Attempt to parse HTTP bodies as JSON always, ignoring Content-Type (fixes #1914)

diff --git a/src/sentry/static/sentry/app/components/events/interfaces/richHttpContent.jsx b/src/sentry/static/sentry/app/components/events/interfaces/richHttpContent.jsx
index e0c66dccd3..b439ee03ac 100644
--- a/src/sentry/static/sentry/app/components/events/interfaces/richHttpContent.jsx
+++ b/src/sentry/static/sentry/app/components/events/interfaces/richHttpContent.jsx
@@ -32,25 +32,27 @@ var RichHttpContent = React.createClass({
   },
 
   getBodySection(data) {
+    /*eslint no-empty:0*/
     let contentType = data.headers.find(h => h[0] === 'Content-Type');
     contentType = contentType && contentType[1].split(';')[0].toLowerCase();
 
-    switch (contentType) {
-      case 'application/x-www-form-urlencoded':
-        return this.getQueryStringOrRaw(data.data);
-      case 'application/json':
-        // falls through
-      default:
-        // Even if Content-Type isn't JSON, attempt to serialize it as JSON
-        // anyways. Many HTTP requests contains JSON bodies, despite not having
-        // matching Content-Type.
-        return this.getJsonOrRaw(data.data);
+    // Ignoring Content-Type, we immediately just check if the body is parseable
+    // as JSON. Why? Because many applications don't set proper Content-Type values,
+    // e.g. x-www-form-urlencoded  actually contains JSON.
+    try {
+      return <ContextData data={JSON.parse(data.data)} />;
+    } catch (e) {}
+
+    if (contentType === 'application/x-www-form-urlencoded') {
+      return this.getQueryStringOrRaw(data.data);
+    } else {
+      return <pre>{data}</pre>
     }
   },
 
   getQueryStringOrRaw(data) {
     try {
-      // Sentry API abbreviates long query stirng values, sometimes resulting in
+      // Sentry API abbreviates long query string values, sometimes resulting in
       // an un-parsable querystring ... stay safe kids
       return <DefinitionList data={this.objectToSortedTupleArray(queryString.parse(data))}/>
     } catch (e) {
@@ -58,16 +60,6 @@ var RichHttpContent = React.createClass({
     }
   },
 
-  getJsonOrRaw(data) {
-    try {
-      // Sentry API abbreviates long JSON strings, resulting in an un-parsable
-      // JSON string ... stay safe kids
-      return <ContextData data={JSON.parse(data)} />;
-    } catch (e) {
-      return <pre>{data}</pre>
-    }
-  },
-
   render(){
     let data = this.props.data;
     return (
diff --git a/tests/js/spec/components/events/interfaces/richHttpContent.spec.jsx b/tests/js/spec/components/events/interfaces/richHttpContent.spec.jsx
index 5529d78e52..dfe865aae2 100644
--- a/tests/js/spec/components/events/interfaces/richHttpContent.spec.jsx
+++ b/tests/js/spec/components/events/interfaces/richHttpContent.spec.jsx
@@ -110,7 +110,7 @@ describe("RichHttpContent", function () {
     it("should return a ContextData element when content is JSON, ignoring Content-Type", function () {
       var out = this.elem.getBodySection({
         headers: [
-          ['Content-Type', 'text/plain']
+          ['Content-Type', 'application/x-www-form-urlencoded']
         ], // no content-type header,
         data: JSON.stringify({foo: 'bar'})
       });

commit 98da33412e280eccfd0dbc07f0c6d6a6ae468bb5
Author: David Cramer <dcramer@gmail.com>
Date:   Sat Jan 19 16:01:59 2013 -0800

    Move create_or_update into helper function

diff --git a/src/sentry/manager.py b/src/sentry/manager.py
index 2390a3aa99..49d13aa332 100644
--- a/src/sentry/manager.py
+++ b/src/sentry/manager.py
@@ -23,7 +23,6 @@ from django.conf import settings as dj_settings
 from django.core.signals import request_finished
 from django.db import models, transaction, IntegrityError
 from django.db.models import Sum
-from django.db.models.expressions import ExpressionNode
 from django.db.models.signals import post_save, post_delete, post_init, class_prepared
 from django.utils import timezone
 from django.utils.datastructures import SortedDict
@@ -39,7 +38,8 @@ from sentry.tasks.index import index_event
 from sentry.tasks.fetch_source import fetch_javascript_source
 from sentry.utils.cache import cache, Lock
 from sentry.utils.dates import get_sql_date_trunc
-from sentry.utils.db import get_db_engine, has_charts, resolve_expression_node
+from sentry.utils.db import get_db_engine, has_charts
+from sentry.utils.models import create_or_update
 from sentry.utils.queue import maybe_delay
 
 logger = logging.getLogger('sentry.errors')
@@ -96,7 +96,7 @@ class BaseManager(models.Manager):
             return self.model._meta.pk.name
         return key
 
-    def __make_key(self, prefix, kwargs):
+    def make_key(self, prefix, kwargs):
         kwargs_bits = []
         for k, v in sorted(kwargs.iteritems()):
             k = self.__prep_key(k)
@@ -177,7 +177,7 @@ class BaseManager(models.Manager):
         cache.delete(self.__get_lookup_cache_key(**{pk_name: instance.pk}))
 
     def __get_lookup_cache_key(self, **kwargs):
-        return self.__make_key('modelcache', kwargs)
+        return self.make_key('modelcache', kwargs)
 
     def contribute_to_class(self, model, name):
         super(BaseManager, self).contribute_to_class(model, name)
@@ -240,7 +240,7 @@ class BaseManager(models.Manager):
             return self.get(**kwargs), False
         except self.model.DoesNotExist:
             pass
-        lock_key = self.__make_key('lock', kwargs)
+        lock_key = self.make_key('lock', kwargs)
 
         # instance not found, lets grab a lock and attempt to create it
         with Lock(lock_key):
@@ -253,30 +253,7 @@ class BaseManager(models.Manager):
         return instance, created
 
     def create_or_update(self, **kwargs):
-        """
-        Similar to get_or_create, either updates a row or creates it.
-
-        The result will be (rows affected, False), if the row was not created,
-        or (instance, True) if the object is new.
-        """
-        defaults = kwargs.pop('defaults', {})
-
-        # before locking attempt to fetch the instance
-        affected = self.filter(**kwargs).update(**defaults)
-        if affected:
-            return affected, False
-        lock_key = self.__make_key('lock', kwargs)
-
-        # instance not found, lets grab a lock and attempt to create it
-        with Lock(lock_key) as lock:
-            if lock.was_locked:
-                affected = self.filter(**kwargs).update(**defaults)
-                return affected, False
-
-            for k, v in defaults.iteritems():
-                if isinstance(v, ExpressionNode):
-                    kwargs[k] = resolve_expression_node(self.model(), v)
-            return self.create(**kwargs), True
+        return create_or_update(self.model, **kwargs)
 
 
 class ScoreClause(object):
diff --git a/src/sentry/utils/models.py b/src/sentry/utils/models.py
index 8c3b1ec336..60641481ba 100644
--- a/src/sentry/utils/models.py
+++ b/src/sentry/utils/models.py
@@ -13,6 +13,7 @@ from django.db import models, router
 from django.db.models import signals
 from django.db.models.expressions import ExpressionNode
 
+from sentry.utils.cache import Lock
 from sentry.utils.compat import pickle
 from sentry.utils.db import resolve_expression_node
 
@@ -68,6 +69,35 @@ def update(self, using=None, **kwargs):
 update.alters_data = True
 
 
+def create_or_update(model, **kwargs):
+    """
+    Similar to get_or_create, either updates a row or creates it.
+
+    The result will be (rows affected, False), if the row was not created,
+    or (instance, True) if the object is new.
+    """
+    defaults = kwargs.pop('defaults', {})
+
+    objects = model.objects
+
+    # before locking attempt to fetch the instance
+    affected = objects.filter(**kwargs).update(**defaults)
+    if affected:
+        return affected, False
+    lock_key = objects.make_key('lock', kwargs)
+
+    # instance not found, lets grab a lock and attempt to create it
+    with Lock(lock_key) as lock:
+        if lock.was_locked:
+            affected = objects.filter(**kwargs).update(**defaults)
+            return affected, False
+
+        for k, v in defaults.iteritems():
+            if isinstance(v, ExpressionNode):
+                kwargs[k] = resolve_expression_node(objects.model(), v)
+        return objects.create(**kwargs), True
+
+
 class Model(models.Model):
     class Meta:
         abstract = True

commit 5e231f514d99fe9ea539205c2bbdc57db9941bba
Author: David Cramer <dcramer@gmail.com>
Date:   Sat Aug 24 17:24:55 2013 -0700

    More system level fixes and updated docs

diff --git a/docs/throttling/index.rst b/docs/throttling/index.rst
index f250c5e078..b1ae8ee942 100644
--- a/docs/throttling/index.rst
+++ b/docs/throttling/index.rst
@@ -6,47 +6,96 @@ too much inbound traffic without a good way to drop excess messages. There's a
 few solutions to this, and you'll likely want to employ them all if you are
 faced with this problem.
 
+Enabling Quotas
+---------------
+
+Sentry provides a built-in quota mechanism to limit on per-project and system-wide basis.
+
+By default, quotas are not enabled. To enable them, you'll need to configure a Redis instance:
+
+.. code-block:: python
+
+   SENTRY_QUOTAS = 'sentry.quotas.redis.RedisQuota'
+   SENTRY_QUOTA_OPTIONS = {
+       'hosts': {
+           0: {
+               'host': 'localhost',
+               'port': 6379
+           }
+       }
+   }
+
+You can now additional configure system-wide maximums, and a default value for all projects:
+
+ .. code-block:: python
+
+    SENTRY_DEFAULT_MAX_EVENTS_PER_MINUTE = '90%'
+    SENTRY_SYSTEM_MAX_EVENTS_PER_MINUTE = 500
+
+If you have additional needs, you're freely available to extend the base Quota class just as the
+Redis implementation does.
 
 Rate Limiting with IPTables
 ---------------------------
 
-One of your first (and most efficient) options is to rate limit with your system's
+One of your most effective options is to rate limit with your system's
 firewall, in our case, IPTables. If you're not sure how IPTables works, take a
 look at `Ubuntu's IPTables How-to <https://help.ubuntu.com/community/IptablesHowTo>`_.
 
 A sampe configuration, which will limit a single IP from bursting more than 5
-messages in a 10 second period might look like this::
-
-	# create a new chain for rate limiting
-	-N LIMITED
-	 
-	# rate limit individual ips to prevent stupidity
-	-I INPUT -p tcp --dport 80 -m state --state NEW -m recent --set
-	-I INPUT -p tcp --dport 443 -m state --state NEW -m recent --set
-	-I INPUT -p tcp --dport 80 -m state --state NEW -m recent --update --seconds 10 --hitcount 5 -j LIMITED
-	-I INPUT -p tcp --dport 443 -m state --state NEW -m recent --update --seconds 10 --hitcount 5 -j LIMITED
-	 
-	# log rejected ips
-	-A LIMITED -p tcp -m limit --limit 5/min -j LOG --log-prefix "Rejected TCP: " --log-level 7
-	-A LIMITED -j REJECT
+messages in a 10 second period might look like this:
 
+::
 
-Enabling Quotas
----------------
+    # create a new chain for rate limiting
+    -N LIMITED
+
+    # rate limit individual ips to prevent stupidity
+    -I INPUT -p tcp --dport 80 -m state --state NEW -m recent --set
+    -I INPUT -p tcp --dport 443 -m state --state NEW -m recent --set
+    -I INPUT -p tcp --dport 80 -m state --state NEW -m recent --update --seconds 10 --hitcount 5 -j LIMITED
+    -I INPUT -p tcp --dport 443 -m state --state NEW -m recent --update --seconds 10 --hitcount 5 -j LIMITED
+
+    # log rejected ips
+    -A LIMITED -p tcp -m limit --limit 5/min -j LOG --log-prefix "Rejected TCP: " --log-level 7
+    -A LIMITED -j REJECT
+
+Rate Limiting with Nginx
+------------------------
+
+While IPTables will help prevent DDOS they don't effectively communicate to the client that it's being rate
+limited. This can be important depending on how the client chooses to respond to the situation.
+
+An alternative (or rather, an addition) is to use something like `ngx_http_limit_conn_module <http://nginx.org/en/docs/http/ngx_http_limit_conn_module.html>`_.
+
+An example configuration looks something like this:
+
+::
+
+    limit_req_zone  $binary_remote_addr  zone=one:100m   rate=3r/s;
+    limit_req_zone  $projectid  zone=two:100m   rate=6r/s;
+    limit_req_status 429;
+    limit_req_log_level warn;
+
+    server {
+      listen   80;
 
-The Sentry Team maintains a plugin which enforces project level quotas (using Redis),
-which will help to discard events without giving a hard "connection refused" error
-like you'd get with your firewall. This is slightly less efficient, as the server
-still has to do processing (and more importantly, has to have connections available).
+      location / {
+        proxy_pass        http://internal;
+      }
 
-The quota plugin is quite easy to get started with, and you'll find detailed
-instructions in the `README <https://github.com/getsentry/sentry-quotas>`_.
+      location ~* /api/(?P<projectid>\d+/)?store/ {
+        proxy_pass        http://internal;
 
+        limit_req   zone=one  burst=3  nodelay;
+        limit_req   zone=two  burst=10  nodelay;
+      }
+    }
 
 Using Cyclops (Client Proxy)
 ----------------------------
 
-A third option for rate limiting is to do it on the client side. `Cyclops <https://github.com/heynemann/cyclops>`_
+An additional option for rate limiting is to do it on the client side. `Cyclops <https://github.com/heynemann/cyclops>`_
 is a third-party proxy written in Python (using Tornado) which aims to solve this.
 
 It's not officially supported, however it is used in production by several large
diff --git a/src/sentry/quotas/base.py b/src/sentry/quotas/base.py
index 94c17109cc..6303682468 100644
--- a/src/sentry/quotas/base.py
+++ b/src/sentry/quotas/base.py
@@ -26,8 +26,9 @@ class Quota(object):
         quotas = filter(bool, [
             self.get_project_quota(project),
             self.get_team_quota(project.team),
-            self.get_system_quota(),
         ])
+        if not quotas:
+            return 0
         return min(quotas)
 
     def translate_quota(self, quota, parent_quota):
diff --git a/src/sentry/quotas/redis.py b/src/sentry/quotas/redis.py
index 62ab10c91d..0639442c5c 100644
--- a/src/sentry/quotas/redis.py
+++ b/src/sentry/quotas/redis.py
@@ -31,11 +31,20 @@ class RedisQuota(Quota):
 
     def is_rate_limited(self, project):
         quota = self.get_active_quota(project)
-        if not quota:
+        system_quota = self.get_system_quota()
+
+        if not (quota or system_quota):
             return False
 
         sys_result, proj_result = self._incr_project(project)
-        return sys_result > quota or proj_result > quota
+
+        if quota and proj_result > quota:
+            return True
+
+        if system_quota and sys_result > system_quota:
+            return True
+
+        return False
 
     def _get_system_key(self, project):
         return 'sentry_quotas:system:%s' % (int(time.time() / 60),)
diff --git a/src/sentry/templates/sentry/projects/quotas.html b/src/sentry/templates/sentry/projects/quotas.html
index 76bec6b181..c1a87a6f0c 100644
--- a/src/sentry/templates/sentry/projects/quotas.html
+++ b/src/sentry/templates/sentry/projects/quotas.html
@@ -15,7 +15,9 @@
 
         <p>{% blocktrans %}Quotas limit on a per-minute basis, which means that they rollover at the start of a new minute. When you attempt to send an event and the project is over it's quota, the client will receive an HTTP 429 (Too Many Requests) response.{% endblocktrans %}</p>
 
-        {% if team_quota %}
+        {% if no_quotas %}
+            <p>{% blocktrans %}The system is not configured to manage quotas.{% endblocktrans %}</p>
+        {% elif team_quota %}
             <p>{% blocktrans %}Your team has <strong>{{ team_quota }} events per minute</strong> allocated collectively among projects.{% endblocktrans %}</p>
         {% elif system_quota %}
             <p>{% blocktrans %}The Sentry system has <strong>{{ system_quota }} events per minute</strong> allocated collectively among projects.{% endblocktrans %}</p>
diff --git a/src/sentry/web/frontend/projects.py b/src/sentry/web/frontend/projects.py
index 43ce54d5c9..23cd26e4c4 100644
--- a/src/sentry/web/frontend/projects.py
+++ b/src/sentry/web/frontend/projects.py
@@ -263,6 +263,8 @@ def notification_settings(request, team, project):
 
 @has_access(MEMBER_OWNER)
 def manage_project_quotas(request, team, project):
+    from sentry.quotas.base import Quota
+
     form = ProjectQuotasForm(project, request.POST or None)
 
     if form and form.is_valid():
@@ -277,6 +279,8 @@ def manage_project_quotas(request, team, project):
     context = {
         'team': team,
         'page': 'quotas',
+        # TODO(dcramer): has_quotas is an awful hack
+        'has_quotas': type(app.quotas) != Quota,
         'system_quota': app.quotas.get_system_quota(),
         'team_quota': app.quotas.get_team_quota(team),
         'project': project,
diff --git a/tests/sentry/quotas/redis/tests.py b/tests/sentry/quotas/redis/tests.py
index 5d2b3a590a..f7f226e8df 100644
--- a/tests/sentry/quotas/redis/tests.py
+++ b/tests/sentry/quotas/redis/tests.py
@@ -20,9 +20,11 @@ class RedisQuotaTest(TestCase):
         self.assertEquals(len(quota.conn.hosts), 1)
         self.assertEquals(quota.conn.hosts[0].host, 'localhost')
 
+    @mock.patch.object(RedisQuota, 'get_system_quota')
     @mock.patch.object(RedisQuota, 'get_project_quota')
     @mock.patch.object(RedisQuota, '_incr_project')
-    def test_bails_immediately_without_quota(self, incr, get_project_quota):
+    def test_bails_immediately_without_quota(self, incr, get_project_quota, get_system_quota):
+        get_system_quota.return_value = 0
         get_project_quota.return_value = 0
         incr.return_value = (0, 0)
 
@@ -32,22 +34,26 @@ class RedisQuotaTest(TestCase):
         assert not incr.called
         assert result is False
 
+    @mock.patch.object(RedisQuota, 'get_system_quota')
     @mock.patch.object(RedisQuota, 'get_project_quota')
     @mock.patch.object(RedisQuota, '_incr_project')
-    def test_over_quota(self, incr, get_project_quota):
+    def test_over_quota(self, incr, get_project_quota, get_system_quota):
         get_project_quota.return_value = 100
-        incr.return_value = (101, 0)
+        get_system_quota.return_value = 0
+        incr.return_value = (0, 101)
 
         result = self.quota.is_rate_limited(self.project)
 
         incr.assert_called_once_with(self.project)
         assert result is True
 
+    @mock.patch.object(RedisQuota, 'get_system_quota')
     @mock.patch.object(RedisQuota, 'get_project_quota')
     @mock.patch.object(RedisQuota, '_incr_project')
-    def test_under_quota(self, incr, get_project_quota):
+    def test_under_quota(self, incr, get_project_quota, get_system_quota):
         get_project_quota.return_value = 100
-        incr.return_value = (99, 0)
+        get_system_quota.return_value = 0
+        incr.return_value = (0, 99)
 
         result = self.quota.is_rate_limited(self.project)
 

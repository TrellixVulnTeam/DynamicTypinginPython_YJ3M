commit 7f8ed8078381d69703396213ffd7b327664144e7
Author: ted kaemming <ted@kaemming.com>
Date:   Tue Jul 10 13:23:28 2018 -0700

     fix(search): Improve date/time expression handling (#8988)

diff --git a/src/sentry/search/utils.py b/src/sentry/search/utils.py
index 0436068136..26ab6cbece 100644
--- a/src/sentry/search/utils.py
+++ b/src/sentry/search/utils.py
@@ -51,74 +51,126 @@ def parse_datetime_range(value):
         raise InvalidQuery(u'{} is not a valid datetime query'.format(value))
 
     if flag == '-':
-        return (timezone.now() - delta, None)
+        return (
+            (timezone.now() - delta, True),
+            None,
+        )
     else:
-        return (None, timezone.now() - delta)
+        return (
+            None,
+            (timezone.now() - delta, True),
+        )
 
 
-def parse_datetime_comparison(value):
-    # TODO(dcramer): currently inclusitivity is not controllable by the query
-    # as from date is always inclusive, and to date is always exclusive
-    if value[:2] in ('>=', '=>'):
-        return (parse_datetime_value(value[2:])[0], None)
-    if value[:2] in ('<=', '=<'):
-        return (None, parse_datetime_value(value[2:])[0])
-    if value[:1] in ('>'):
-        return (parse_datetime_value(value[1:])[0], None)
-    if value[:1] in ('<'):
-        return (None, parse_datetime_value(value[1:])[0])
-    if value[0] == '=':
-        return parse_datetime_value(value[1:])
-    raise InvalidQuery(u'{} is not a valid datetime query'.format(value))
+DATE_FORMAT = '%Y-%m-%d'
+DATETIME_FORMAT = '%Y-%m-%dT%H:%M:%S'
+DATETIME_FORMAT_MICROSECONDS = '%Y-%m-%dT%H:%M:%S.%f'
 
 
-def parse_datetime_value(value):
+def parse_unix_timestamp(value):
+    return datetime.utcfromtimestamp(float(value)).replace(tzinfo=timezone.utc)
+
+
+def parse_datetime_string(value):
+    # timezones are not supported and are assumed UTC
+    if value[-1] == 'Z':
+        value = value[:-1]
+
+    for format in [DATETIME_FORMAT_MICROSECONDS, DATETIME_FORMAT, DATE_FORMAT]:
+        try:
+            return datetime.strptime(value, format).replace(tzinfo=timezone.utc)
+        except ValueError:
+            pass
+
     try:
-        return _parse_datetime_value(value)
-    except (ValueError, IndexError):
-        raise InvalidQuery(u'{} is not a valid datetime query'.format(value))
+        return parse_unix_timestamp(value)
+    except ValueError:
+        pass
 
+    raise InvalidQuery(u'{} is not a valid datetime query'.format(value))
 
-def _parse_datetime_value(value):
-    # this one is fuzzy, and not entirely correct
-    if value.startswith(('-', '+')):
-        return parse_datetime_range(value)
 
+def parse_datetime_comparison(value):
+    if value[:2] == '>=':
+        return (
+            (parse_datetime_string(value[2:]), True),
+            None,
+        )
+    if value[:2] == '<=':
+        return (
+            None,
+            (parse_datetime_string(value[2:]), True),
+        )
+    if value[:1] == '>':
+        return (
+            (parse_datetime_string(value[1:]), False),
+            None,
+        )
+    if value[:1] == '<':
+        return (
+            None,
+            (parse_datetime_string(value[1:]), False),
+        )
+
+    raise InvalidQuery(u'{} is not a valid datetime query'.format(value))
+
+
+def parse_datetime_value(value):
     # timezones are not supported and are assumed UTC
     if value[-1] == 'Z':
         value = value[:-1]
 
-    value_len = len(value)
-    if value_len in (8, 10):
-        value = datetime.strptime(value, '%Y-%m-%d').replace(
+    # A value that only specifies the date (without a time component) should be
+    # expanded to an interval that spans the entire day.
+    if len(value) in (8, 10):
+        value = datetime.strptime(value, DATE_FORMAT).replace(
             tzinfo=timezone.utc,
         )
-        return [value, value + timedelta(days=1)]
-    elif value[4] == '-':
+        return (
+            (value, True),
+            (value + timedelta(days=1), False),
+        )
+
+    # A value that contains the time should converted to an interval.
+    if value[4] == '-':
         try:
-            value = datetime.strptime(value, '%Y-%m-%dT%H:%M:%S').replace(
-                tzinfo=timezone.utc,
-            )
+            value = datetime.strptime(value, DATETIME_FORMAT).replace(tzinfo=timezone.utc)
         except ValueError:
-            value = datetime.strptime(value, '%Y-%m-%dT%H:%M:%S.%f').replace(
-                tzinfo=timezone.utc,
-            )
+            value = datetime.strptime(value, DATETIME_FORMAT_MICROSECONDS).replace(tzinfo=timezone.utc)
     else:
-        value = datetime.utcfromtimestamp(float(value)).replace(
-            tzinfo=timezone.utc,
-        )
-    return [value - timedelta(minutes=5), value + timedelta(minutes=6)]
+        value = parse_unix_timestamp(value)
+
+    return (
+        (value - timedelta(minutes=5), True),
+        (value + timedelta(minutes=6), False),
+    )
 
 
 def parse_datetime_expression(value):
-    # result must be (from inclusive, to exclusive)
     if value.startswith(('-', '+')):
         return parse_datetime_range(value)
-
-    if value.startswith(('>', '<', '=', '<=', '>=')):
+    elif value.startswith(('>', '<', '<=', '>=')):
         return parse_datetime_comparison(value)
+    else:
+        return parse_datetime_value(value)
 
-    return parse_datetime_value(value)
+
+def get_date_params(value, from_field, to_field):
+    date_from, date_to = parse_datetime_expression(value)
+    result = {}
+    if date_from is not None:
+        date_from_value, date_from_inclusive = date_from
+        result.update({
+            from_field: date_from_value,
+            '{}_inclusive'.format(from_field): date_from_inclusive,
+        })
+    if date_to is not None:
+        date_to_value, date_to_inclusive = date_to
+        result.update({
+            to_field: date_to_value,
+            '{}_inclusive'.format(to_field): date_to_inclusive,
+        })
+    return result
 
 
 def parse_team_value(project, value, user):
@@ -146,22 +198,6 @@ def parse_user_value(value, user):
         return User(id=0)
 
 
-def get_date_params(value, from_field, to_field):
-    date_from, date_to = parse_datetime_expression(value)
-    result = {}
-    if date_from:
-        result.update({
-            from_field: date_from,
-            '{}_inclusive'.format(from_field): True,
-        })
-    if date_to:
-        result.update({
-            to_field: date_to,
-            '{}_inclusive'.format(to_field): False,
-        })
-    return result
-
-
 numeric_modifiers = [
     (
         '>=', lambda field, value: {
diff --git a/tests/sentry/search/test_utils.py b/tests/sentry/search/test_utils.py
index e45788b966..ad0112cae2 100644
--- a/tests/sentry/search/test_utils.py
+++ b/tests/sentry/search/test_utils.py
@@ -98,7 +98,7 @@ class ParseQueryTest(TestCase):
         now.return_value = start
         expected = start - timedelta(hours=12)
         result = self.parse_query('age:+12h')
-        assert result == {'tags': {}, 'query': '', 'age_to': expected, 'age_to_inclusive': False}
+        assert result == {'tags': {}, 'query': '', 'age_to': expected, 'age_to_inclusive': True}
 
     @mock.patch('django.utils.timezone.now')
     def test_age_tag_weeks(self, now):
@@ -106,7 +106,7 @@ class ParseQueryTest(TestCase):
         now.return_value = start
         expected = start - timedelta(days=35)
         result = self.parse_query('age:+5w')
-        assert result == {'tags': {}, 'query': '', 'age_to': expected, 'age_to_inclusive': False}
+        assert result == {'tags': {}, 'query': '', 'age_to': expected, 'age_to_inclusive': True}
 
     @mock.patch('django.utils.timezone.now')
     def test_age_tag_days(self, now):
@@ -114,7 +114,7 @@ class ParseQueryTest(TestCase):
         now.return_value = start
         expected = start - timedelta(days=10)
         result = self.parse_query('age:+10d')
-        assert result == {'tags': {}, 'query': '', 'age_to': expected, 'age_to_inclusive': False}
+        assert result == {'tags': {}, 'query': '', 'age_to': expected, 'age_to_inclusive': True}
 
     @mock.patch('django.utils.timezone.now')
     def test_age_tag_hours(self, now):
@@ -122,7 +122,7 @@ class ParseQueryTest(TestCase):
         now.return_value = start
         expected = start - timedelta(hours=10)
         result = self.parse_query('age:+10h')
-        assert result == {'tags': {}, 'query': '', 'age_to': expected, 'age_to_inclusive': False}
+        assert result == {'tags': {}, 'query': '', 'age_to': expected, 'age_to_inclusive': True}
 
     @mock.patch('django.utils.timezone.now')
     def test_age_tag_minutes(self, now):
@@ -130,7 +130,7 @@ class ParseQueryTest(TestCase):
         now.return_value = start
         expected = start - timedelta(minutes=30)
         result = self.parse_query('age:+30m')
-        assert result == {'tags': {}, 'query': '', 'age_to': expected, 'age_to_inclusive': False}
+        assert result == {'tags': {}, 'query': '', 'age_to': expected, 'age_to_inclusive': True}
 
     @mock.patch('django.utils.timezone.now')
     def test_two_age_tags(self, now):
@@ -144,8 +144,8 @@ class ParseQueryTest(TestCase):
             'query': '',
             'age_to': expected_to,
             'age_from': expected_from,
-            'age_to_inclusive': False,
-            'age_from_inclusive': True
+            'age_to_inclusive': True,
+            'age_from_inclusive': True,
         }
 
     def test_event_timestamp_syntax(self):
@@ -382,9 +382,16 @@ class ParseQueryTest(TestCase):
     def test_date_range(self):
         result = self.parse_query('event.timestamp:>2016-01-01 event.timestamp:<2016-01-02')
         assert result['date_from'] == datetime(2016, 1, 1, tzinfo=timezone.utc)
-        assert result['date_from_inclusive']
+        assert result['date_from_inclusive'] is False
         assert result['date_to'] == datetime(2016, 1, 2, tzinfo=timezone.utc)
-        assert not result['date_to_inclusive']
+        assert result['date_to_inclusive'] is False
+
+    def test_date_range_inclusive(self):
+        result = self.parse_query('event.timestamp:>=2016-01-01 event.timestamp:<=2016-01-02')
+        assert result['date_from'] == datetime(2016, 1, 1, tzinfo=timezone.utc)
+        assert result['date_from_inclusive'] is True
+        assert result['date_to'] == datetime(2016, 1, 2, tzinfo=timezone.utc)
+        assert result['date_to_inclusive'] is True
 
     def test_date_approx_day(self):
         date_value = datetime(2016, 1, 1, tzinfo=timezone.utc)

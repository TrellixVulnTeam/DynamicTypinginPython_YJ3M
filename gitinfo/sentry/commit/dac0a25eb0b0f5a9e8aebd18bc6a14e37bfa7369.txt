commit dac0a25eb0b0f5a9e8aebd18bc6a14e37bfa7369
Author: Ted Kaemming <ted@kaemming.com>
Date:   Wed Sep 23 11:20:28 2015 -0700

    Add test for capacity/truncation.

diff --git a/tests/sentry/digests/test_redis.py b/tests/sentry/digests/test_redis.py
index 3217d25217..8f990fe343 100644
--- a/tests/sentry/digests/test_redis.py
+++ b/tests/sentry/digests/test_redis.py
@@ -1,7 +1,10 @@
 import functools
+import itertools
+import mock
 from datetime import datetime
 
 import pytz
+from exam import fixture
 
 from sentry.digests.base import (
     Record,
@@ -22,23 +25,33 @@ def to_timestamp(value):
 
 
 class RedisBackendTestCase(TestCase):
-    def setUp(self):
-        self.backend = RedisBackend(
-            cluster={
-                'hosts': {
-                    0: {'db': 9},
-                },
+    defaults = {
+        'cluster': {
+            'hosts': {
+                0: {'db': 9},
             },
-        )
+        },
+    }
+
+    @fixture
+    def records(self):
+        for i in itertools.count():
+            yield Record(i, i, i)
+
+    def get_backend(self, options={}):
+        kwargs = self.defaults.copy()
+        kwargs.update(options)
+        return RedisBackend(**kwargs)
 
     def test_add_record(self):
-        record = Record('00000000000010008080808080808080', 'value', 0)
         timeline = 'timeline'
+        backend = self.get_backend()
 
-        timeline_key = make_timeline_key(self.backend.namespace, timeline)
-        connection = self.backend.cluster.get_local_client_for_key(timeline_key)
+        timeline_key = make_timeline_key(backend.namespace, timeline)
+        connection = backend.cluster.get_local_client_for_key(timeline_key)
 
-        waiting_set_key = make_schedule_key(self.backend.namespace, SCHEDULE_STATE_WAITING)
+        record = next(self.records)
+        waiting_set_key = make_schedule_key(backend.namespace, SCHEDULE_STATE_WAITING)
         record_key = make_record_key(timeline_key, record.key)
 
         get_timeline_score_in_waiting_set = functools.partial(connection.zscore, waiting_set_key, timeline)
@@ -47,10 +60,34 @@ class RedisBackendTestCase(TestCase):
 
         def get_record_value():
             value = connection.get(record_key)
-            return self.backend.codec.decode(value) if value is not None else None
+            return backend.codec.decode(value) if value is not None else None
 
         with self.assertChanges(get_timeline_score_in_waiting_set, before=None, after=record.timestamp), \
                 self.assertChanges(get_timeline_iteration_counter, before=None, after='0'), \
                 self.assertChanges(get_record_score_in_timeline_set, before=None, after=record.timestamp), \
                 self.assertChanges(get_record_value, before=None, after=record.value):
-            self.backend.add(timeline, record)
+            backend.add(timeline, record)
+
+    def test_truncation(self):
+        timeline = 'timeline'
+        capacity = 5
+        backend = self.get_backend({
+            'capacity': capacity,
+            'truncation_chance': 0.5,
+        })
+
+        timeline_key = make_timeline_key(backend.namespace, timeline)
+        connection = backend.cluster.get_local_client_for_key(timeline_key)
+
+        get_timeline_size = functools.partial(connection.zcard, timeline_key)
+
+        fill = 10
+
+        with mock.patch('random.random', return_value=1.0):
+            with self.assertChanges(get_timeline_size, before=0, after=fill):
+                for _ in xrange(fill):
+                    backend.add(timeline, next(self.records))
+
+        with mock.patch('random.random', return_value=0.0):
+            with self.assertChanges(get_timeline_size, before=fill, after=capacity):
+                backend.add(timeline, next(self.records))

commit a15da554c66d44fc55c061b682e2f0c9523c952b
Author: David Cramer <dcramer@gmail.com>
Date:   Thu Oct 4 21:19:33 2012 -0700

    Add notes on scrubbing data/processors

diff --git a/docs/developer/client/index.rst b/docs/developer/client/index.rst
index 41058ec639..ed762736fb 100644
--- a/docs/developer/client/index.rst
+++ b/docs/developer/client/index.rst
@@ -74,41 +74,6 @@ Ruby example::
 
     rake raven:test http://public_key:secret_key@example.com/default
 
-Tags
-----
-
-Tags are key/value pairs that describe an event. They should be configurable in the following contexts:
-
-* Environment (client-level)
-* Thread (block-level)
-* Event (as part of capture)
-
-Each of these should inherit it's parent. So for example, if you configure your client as so::
-
-    client = Client(..., {
-        'tags': {'foo': 'bar'},
-    })
-
-And then you capture an event::
-
-    client.captureMessage('test', {
-        'tags': {'foo': 'baz'},
-    })
-
-The client should send the following usptream for ``tags``::
-
-    {
-        "tags": [
-            ["foo", "bar"],
-            ["foo", "baz"]
-        ],
-    }
-
-If your platform supports it, block level context should also be available::
-
-    with client.context({'tags': {'foo': 'bar'}}):
-        # ...
-
 Parsing the DSN
 ---------------
 
@@ -410,3 +375,75 @@ It will also only retry every few seconds, based on how many consecutive failure
             return True
 
         return False
+
+Scrubbing Data
+--------------
+
+Clients should provide some mechanism for scrubbing data. Ideally through an extensible interface that the user
+can customize the behavior of.
+
+This is generally done as part of the client configuration::
+
+    client = Client(..., {
+        'processors': ['processor.className'],
+    })
+
+Each processor listed would be some sort of extensible class or a function callback. It would have a single designated
+method that is passed the data (after it's been populated), and would then return the data fully intact, or modified
+with various bits filtered out.
+
+For example, if you simply supported callbacks for processors, it might look like this::
+
+    function my_processor($data) {
+        foreach ($data['extra'] as $key => $value) {
+            if (strpos($value, 'password')) {
+                $data[$key] = '********';
+            }
+        }
+    }
+
+We recommend scrubbing the following values::
+
+* Values where the keyname matches 'password', 'passwd', or 'secret'.
+* Values that match the regular expression of ``r'^\d{16}$'`` (credit card-like).
+* Session cookies.
+* The Authentication header (HTTP).
+
+Keep in mind, that if your client is passing extra interface data (e.g. HTTP POST variables) you will also
+want to scrub those interfaces. Given that, it is a good idea to simply recursively scrub most variables
+other than predefined things (like HTTP headers).
+
+Tags
+----
+
+Tags are key/value pairs that describe an event. They should be configurable in the following contexts:
+
+* Environment (client-level)
+* Thread (block-level)
+* Event (as part of capture)
+
+Each of these should inherit it's parent. So for example, if you configure your client as so::
+
+    client = Client(..., {
+        'tags': {'foo': 'bar'},
+    })
+
+And then you capture an event::
+
+    client.captureMessage('test', {
+        'tags': {'foo': 'baz'},
+    })
+
+The client should send the following usptream for ``tags``::
+
+    {
+        "tags": [
+            ["foo", "bar"],
+            ["foo", "baz"]
+        ],
+    }
+
+If your platform supports it, block level context should also be available::
+
+    with client.context({'tags': {'foo': 'bar'}}):
+        # ...

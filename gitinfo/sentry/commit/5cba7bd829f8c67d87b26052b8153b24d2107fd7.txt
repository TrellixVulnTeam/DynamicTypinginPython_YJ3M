commit 5cba7bd829f8c67d87b26052b8153b24d2107fd7
Author: David Cramer <dcramer@gmail.com>
Date:   Tue Sep 27 01:21:41 2011 -0700

    Add project to client and server signatures to handle new api keys

diff --git a/sentry/client/base.py b/sentry/client/base.py
index e12c5574e2..942a8c1af2 100644
--- a/sentry/client/base.py
+++ b/sentry/client/base.py
@@ -49,7 +49,7 @@ class SentryClient(object):
     def check_throttle(self, checksum):
         if not (settings.THRASHING_TIMEOUT and settings.THRASHING_LIMIT):
             return (False, None)
-        
+
         cache_key = 'sentry:%s' % (checksum,)
         # We MUST do a get first to avoid re-setting the timeout when doing .add
         added = cache.get(cache_key) is None
@@ -59,7 +59,7 @@ class SentryClient(object):
 
         if added:
             return (False, None)
-        
+
         try:
             thrash_count = cache.incr(cache_key)
         except (KeyError, ValueError):
@@ -76,16 +76,16 @@ class SentryClient(object):
     @fail_silently()
     def get_last_message_id(self, checksum):
         cache_key = 'sentry:%s:last_message_id' % (checksum,)
-        
+
         return cache.get(cache_key)
 
     @fail_silently()
     def set_last_message_id(self, checksum, message_id):
         if settings.THRASHING_TIMEOUT and settings.THRASHING_LIMIT:
             cache_key = 'sentry:%s:last_message_id' % (checksum,)
-        
+
             cache.set(cache_key, message_id, settings.THRASHING_LIMIT + 5)
-        
+
     def process(self, **kwargs):
         "Processes the message before passing it on to the server"
         from sentry.utils import get_filters
@@ -113,7 +113,7 @@ class SentryClient(object):
                 GET=request.GET,
                 COOKIES=request.COOKIES,
             ))
-            
+
             if hasattr(request, 'user'):
                 if request.user.is_authenticated():
                     user_info = {
@@ -150,13 +150,13 @@ class SentryClient(object):
             modules = get_installed_apps()
             if settings.INCLUDE_PATHS:
                 modules = set(list(modules) + settings.INCLUDE_PATHS)
-        
+
             def contains(iterator, value):
                 for k in iterator:
                     if value.startswith(k):
                         return True
                 return False
-            
+
             # We iterate through each frame looking for an app in INSTALLED_APPS
             # When one is found, we mark it as last "best guess" (best_guess) and then
             # check it against SENTRY_EXCLUDE_PATHS. If it isnt listed, then we
@@ -175,7 +175,7 @@ class SentryClient(object):
                     break
             if best_guess:
                 view = best_guess
-        
+
             if view:
                 kwargs['view'] = view
 
@@ -212,12 +212,12 @@ class SentryClient(object):
                     'id': message_id,
                     'thrashed': True,
                 }
-            
+
             return message_id
-            
+
         for filter_ in get_filters():
             kwargs = filter_(None).process(kwargs) or kwargs
-        
+
         # create ID client-side so that it can be passed to application
         message_id = uuid.uuid4().hex
         kwargs['message_id'] = message_id
@@ -228,18 +228,21 @@ class SentryClient(object):
         if 'timestamp' not in kwargs:
             kwargs['timestamp'] = datetime.datetime.now()
 
+        # add project id
+        kwargs['project'] = settings.PROJECT
+
         self.send(**kwargs)
-        
+
         if request:
             # attach the sentry object to the request
             request.sentry = {
                 'id': message_id,
                 'thrashed': False,
             }
-        
+
         # store the last message_id incase we hit thrashing limits
         self.set_last_message_id(checksum, message_id)
-        
+
         return message_id
 
     def send_remote(self, url, data, headers={}):
@@ -261,7 +264,7 @@ class SentryClient(object):
                     'Authorization': get_auth_header(signature, timestamp, '%s/%s' % (self.__class__.__name__, sentry.VERSION)),
                     'Content-Type': 'application/octet-stream',
                 }
-                
+
                 try:
                     return self.send_remote(url=url, data=message, headers=headers)
                 except urllib2.HTTPError, e:
@@ -275,7 +278,7 @@ class SentryClient(object):
                     logger.log(kwargs.pop('level', None) or logging.ERROR, kwargs.pop('message', None))
         else:
             from sentry.models import GroupedMessage
-            
+
             return GroupedMessage.objects.from_kwargs(**kwargs)
 
     def create_from_record(self, record, **kwargs):
@@ -285,20 +288,20 @@ class SentryClient(object):
         for k in ('url', 'view', 'request', 'data'):
             if not kwargs.get(k):
                 kwargs[k] = record.__dict__.get(k)
-        
+
         kwargs.update({
             'logger': record.name,
             'level': record.levelno,
             'message': force_unicode(record.msg),
             'server_name': settings.NAME,
         })
-        
+
         # construct the checksum with the unparsed message
         kwargs['checksum'] = construct_checksum(**kwargs)
-        
+
         # save the message with included formatting
         kwargs['message'] = record.getMessage()
-        
+
         # If there's no exception being processed, exc_info may be a 3-tuple of None
         # http://docs.python.org/library/sys.html#sys.exc_info
         if record.exc_info and all(record.exc_info):
@@ -348,7 +351,7 @@ class SentryClient(object):
             exc_info = sys.exc_info()
 
         data = kwargs.pop('data', {}) or {}
-        
+
         try:
             exc_type, exc_value, exc_traceback = exc_info
 
@@ -363,14 +366,14 @@ class SentryClient(object):
             data['__sentry__']['frames'] = frames
             data['__sentry__']['exception'] = [exc_module, exc_value.args]
 
-            # As of r16833 (Django) all exceptions may contain a ``django_template_source`` attribute (rather than the 
+            # As of r16833 (Django) all exceptions may contain a ``django_template_source`` attribute (rather than the
             # legacy ``TemplateSyntaxError.source`` check) which describes template information.
             if hasattr(exc_value, 'django_template_source') or ((isinstance(exc_value, TemplateSyntaxError) and \
                 isinstance(getattr(exc_value, 'source', None), (tuple, list)) and isinstance(exc_value.source[0], LoaderOrigin))):
                 origin, (start, end) = getattr(exc_value, 'django_template_source', exc_value.source)
                 data['__sentry__']['template'] = (origin.reload(), start, end, origin.name)
                 kwargs['view'] = origin.loadname
-        
+
             tb_message = '\n'.join(traceback.format_exception(exc_type, exc_value, exc_traceback))
 
             kwargs.setdefault('message', transform(force_unicode(exc_value)))
diff --git a/sentry/utils/__init__.py b/sentry/utils/__init__.py
index b42f1e836e..6b19ac568e 100644
--- a/sentry/utils/__init__.py
+++ b/sentry/utils/__init__.py
@@ -302,14 +302,19 @@ def is_float(var):
         return False
     return True
 
-def get_signature(message, timestamp):
-    return hmac.new(settings.KEY, '%s %s' % (timestamp, message), sha_constructor).hexdigest()
+def get_signature(message, timestamp, project=None):
+    if project:
+        key = project.api_key
+    else:
+        key = settings.KEY
+    return hmac.new(key, '%s %s' % (timestamp, message), sha_constructor).hexdigest()
 
 def get_auth_header(signature, timestamp, client):
-    return 'Sentry sentry_signature=%s, sentry_timestamp=%s, sentry_client=%s' % (
+    return 'Sentry sentry_signature=%s, sentry_timestamp=%s, sentry_client=%s, sentry_project=%s' % (
         signature,
         timestamp,
         sentry.VERSION,
+        settings.PROJECT,
     )
 
 def parse_auth_header(header):
diff --git a/sentry/utils/manager.py b/sentry/utils/manager.py
index f73e2ce5e8..7e4cc8b3c4 100644
--- a/sentry/utils/manager.py
+++ b/sentry/utils/manager.py
@@ -59,11 +59,11 @@ def count_limit(count):
         return 50
     if count <= 1000000: # 3000
         return 300
-    if count <= 10000000: # 4500 
+    if count <= 10000000: # 4500
         return 2000
     return 10000
 
-def time_limit(silence): # ~ 3600 per hour  
+def time_limit(silence): # ~ 3600 per hour
     if silence >= 3600:
         return 1
     if silence >= 360:
@@ -93,6 +93,7 @@ class SentryManager(models.Manager):
         url = kwargs.pop('url', None)
         server_name = kwargs.pop('server_name', settings.CLIENT)
         site = kwargs.pop('site', None)
+        project = kwargs.pop('project', settings.PROJECT)
         data = kwargs.pop('data', {}) or {}
         message_id = kwargs.pop('message_id', None)
 
@@ -122,6 +123,7 @@ class SentryManager(models.Manager):
             })
 
             group, created = GroupedMessage.objects.get_or_create(
+                project=project,
                 view=view,
                 logger=logger_name,
                 checksum=checksum,
diff --git a/sentry/web/views.py b/sentry/web/views.py
index d35d235fd7..1a82346845 100644
--- a/sentry/web/views.py
+++ b/sentry/web/views.py
@@ -516,6 +516,13 @@ def store(request):
 
         signature = auth_vars.get('sentry_signature')
         timestamp = auth_vars.get('sentry_timestamp')
+        project = auth_vars.get('sentry_project')
+
+        if project:
+            try:
+                project = Project.objects.get(pk=project)
+            except Project.DoesNotExist:
+                return HttpResponseForbidden('Invalid signature')
 
         format = 'json'
 
@@ -531,7 +538,7 @@ def store(request):
             if timestamp < time.time() - 3600: # 1 hour
                 return HttpResponseGone('Message has expired')
 
-            sig_hmac = get_signature(data, timestamp)
+            sig_hmac = get_signature(data, timestamp, project)
             if sig_hmac != signature:
                 return HttpResponseForbidden('Invalid signature')
         else:

commit 870253c48282b41a36d72f976ba8cb14f083db21
Author: David Cramer <dcramer@gmail.com>
Date:   Wed Jun 26 15:35:58 2013 -0700

    Switch to mocha-phantom

diff --git a/Makefile b/Makefile
index 05f1816657..15902275ab 100644
--- a/Makefile
+++ b/Makefile
@@ -1,10 +1,13 @@
 VERSION = 2.0.0
-NPM_ROOT = node_modules
+NPM_ROOT = ./node_modules
 STATIC_DIR = src/sentry/static/sentry
 BOOTSTRAP_JS = ${STATIC_DIR}/scripts/lib/bootstrap.js
 BOOTSTRAP_JS_MIN = ${STATIC_DIR}/scripts/lib/bootstrap.min.js
 UGLIFY_JS ?= node_modules/uglify-js/bin/uglifyjs
 
+JS_TESTS = tests/js/index.html
+JS_REPORTER = dot
+
 develop: update-submodules
 	npm install -q
 	pip install -q "file://`pwd`#egg=sentry[dev]" --use-mirrors
@@ -63,7 +66,7 @@ test-cli:
 
 test-js:
 	@echo "Running JavaScript tests"
-	${NPM_ROOT}/phantomjs/bin/phantomjs runtests.js tests/js/index.html
+	${NPM_ROOT}/.bin/mocha-phantomjs -p ${NPM_ROOT}/phantomjs/bin/phantomjs -R ${JS_REPORTER} ${JS_TESTS}
 	@echo ""
 
 test-python:
@@ -80,7 +83,7 @@ lint-python:
 
 lint-js:
 	@echo "Linting JavaScript files"
-	@${NPM_ROOT}/jshint/bin/hint src/sentry/ || exit 1
+	@{NPM_ROOT}/.bin/jshint src/sentry/ || exit 1
 	@echo ""
 
 coverage: install-test-requirements
diff --git a/package.json b/package.json
index 9d3292cf41..f570c8b129 100644
--- a/package.json
+++ b/package.json
@@ -1,10 +1,18 @@
 {
     "name": "Sentry",
-    "version": "0.1.0",
+    "version": "0.0.0",
+    "repository": {
+        "type": "git",
+        "url": "git://github.com/getsentry/sentry.git"
+    },
     "dependencies": {
         "less": "1.3.3",
-        "phantomjs": "0.2.x",
+        "phantomjs": "*",
+        "chai": "1.7.x",
+        "mocha": "1.9.x",
+        "mocha-phantomjs": "*",
         "jshint": "0.9.x",
         "uglify-js": "2.2.4"
-    }
+    },
+    "private": true
 }
diff --git a/tests/js/index.html b/tests/js/index.html
index 52a2e140ae..ceec3e596c 100644
--- a/tests/js/index.html
+++ b/tests/js/index.html
@@ -1,58 +1,67 @@
-<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
-  "http://www.w3.org/TR/html4/loose.dtd">
+<!doctype html>
 <html>
-<head>
-  <title>Jasmine Spec Runner</title>
-
-  <link rel="shortcut icon" type="image/png" href="lib/jasmine-1.2.0/jasmine_favicon.png">
-  <link rel="stylesheet" type="text/css" href="lib/jasmine-1.2.0/jasmine.css">
-  <script type="text/javascript" src="lib/jasmine-1.2.0/jasmine.js"></script>
-  <script type="text/javascript" src="lib/jasmine-1.2.0/jasmine-html.js"></script>
-  <script type="text/javascript" src="lib/sinon-1.5.0.js"></script>
-  <script type="text/javascript" src="lib/console-runner.js"></script>
-
-  <!-- include source files here... -->
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/jquery.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/jquery.animate-colors-min.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/jquery.clippy.min.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/jquery.flot.min.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/jquery.sparkline.min.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/json2.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/underscore.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/backbone.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/select2/select2.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/bootstrap.js"></script>
-
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/core.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/models.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/templates.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/utils.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/collections.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/charts.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/views.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/app.js"></script>
-
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/sentry.core.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/sentry.charts.js"></script>
-  <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/sentry.stream.js"></script>
-
-  <!-- include spec files here... -->
-  <script type="text/javascript" src="spec/OrderedElementsViewSpec.js"></script>
-  <script type="text/javascript" src="spec/floatFormat.js"></script>
-  <script type="text/javascript" src="spec/formatNumber.js"></script>
-
-</head>
-
-<body>
-  <div id="dummy" style="display:none"></div>
-
-  <script type="text/javascript">
-  var console_reporter = new jasmine.ConsoleReporter()
-  $(function(){
-    jasmine.getEnv().addReporter(new jasmine.TrivialReporter());
-    jasmine.getEnv().addReporter(console_reporter);
-    jasmine.getEnv().execute();
-  });
-  </script>
-</body>
+  <head>
+    <meta charset="utf-8">
+    <link rel="stylesheet" href="lib/mocha/mocha.css" />
+  </head>
+  <body>
+    <div id="dummy" style="display:none"></div>
+    <div id="mocha"></div>
+
+    <!-- Mocha -->
+    <script src="lib/mocha/mocha.js"></script>
+    <script src="lib/chai/chai.js"></script>
+    <script>
+      mocha.ui('bdd');
+      mocha.reporter('html');
+      var expect = chai.expect;
+      var assert = chai.assert;
+    </script>
+
+    <!-- Mocking -->
+    <script src="lib/sinon-1.7.3.js"></script>
+    <script>
+    beforeEach(function() {
+        this.sinon = sinon.sandbox.create();
+    });
+
+    afterEach(function() {
+        this.sinon.restore();
+    });
+    </script>
+
+    <!-- Sentry Source -->
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/jquery.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/jquery.animate-colors.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/jquery.clippy.min.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/jquery.flot.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/json2.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/underscore.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/backbone.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/select2/select2.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/lib/bootstrap.js"></script>
+
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/core.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/models.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/templates.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/utils.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/collections.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/charts.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/views.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/app.js"></script>
+
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/sentry.core.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/sentry.charts.js"></script>
+    <script type="text/javascript" src="../../src/sentry/static/sentry/scripts/sentry.stream.js"></script>
+
+    <!-- Test Specs -->
+    <script type="text/javascript" src="spec/OrderedElementsViewSpec.js"></script>
+    <script type="text/javascript" src="spec/floatFormat.js"></script>
+    <script type="text/javascript" src="spec/formatNumber.js"></script>
+
+    <script>
+      if (window.mochaPhantomJS) { mochaPhantomJS.run(); }
+      else { mocha.run(); }
+    </script>
+  </body>
 </html>
diff --git a/tests/js/lib/chai b/tests/js/lib/chai
new file mode 120000
index 0000000000..1833eb21be
--- /dev/null
+++ b/tests/js/lib/chai
@@ -0,0 +1 @@
+../../../node_modules/chai
\ No newline at end of file
diff --git a/tests/js/lib/mocha b/tests/js/lib/mocha
new file mode 120000
index 0000000000..c051314722
--- /dev/null
+++ b/tests/js/lib/mocha
@@ -0,0 +1 @@
+../../../node_modules/mocha
\ No newline at end of file
diff --git a/tests/js/lib/sinon-1.5.0.js b/tests/js/lib/sinon-1.7.3.js
similarity index 83%
rename from tests/js/lib/sinon-1.5.0.js
rename to tests/js/lib/sinon-1.7.3.js
index 9b339352f7..26c4bd9c46 100644
--- a/tests/js/lib/sinon-1.5.0.js
+++ b/tests/js/lib/sinon-1.7.3.js
@@ -1,12 +1,12 @@
 /**
- * Sinon.JS 1.5.0, 2012/10/19
+ * Sinon.JS 1.7.3, 2013/06/20
  *
  * @author Christian Johansen (christian@cjohansen.no)
  * @author Contributors: https://github.com/cjohansen/Sinon.JS/blob/master/AUTHORS
  *
  * (The BSD License)
  * 
- * Copyright (c) 2010-2012, Christian Johansen, christian@cjohansen.no
+ * Copyright (c) 2010-2013, Christian Johansen, christian@cjohansen.no
  * All rights reserved.
  * 
  * Redistribution and use in source and binary forms, with or without modification,
@@ -33,9 +33,7 @@
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-var sinon = (function () {
-"use strict";
-
+this.sinon = (function () {
 var buster = (function (setTimeout, B) {
     var isNode = typeof require == "function" && typeof module == "object";
     var div = typeof document != "undefined" && document.createElement("div");
@@ -463,7 +461,7 @@ if (typeof module != "undefined") {
  * @author Christian Johansen (christian@cjohansen.no)
  * @license BSD
  *
- * Copyright (c) 2010-2011 Christian Johansen
+ * Copyright (c) 2010-2013 Christian Johansen
  */
 
 var sinon = (function (buster) {
@@ -494,7 +492,7 @@ var sinon = (function (buster) {
     }
 
     function isFunction(obj) {
-        return !!(obj && obj.constructor && obj.call && obj.apply);
+        return typeof obj === "function" || !!(obj && obj.constructor && obj.call && obj.apply);
     }
 
     function mirrorProperties(target, source) {
@@ -505,6 +503,10 @@ var sinon = (function (buster) {
         }
     }
 
+    function isRestorable (obj) {
+        return typeof obj === "function" && typeof obj.restore === "function" && obj.restore.sinon;
+    }
+
     var sinon = {
         wrapMethod: function wrapMethod(object, property, method) {
             if (!object) {
@@ -594,6 +596,10 @@ var sinon = (function (buster) {
                 return true;
             }
 
+            if ((a === null && b !== null) || (a !== null && b === null)) {
+                return false;
+            }
+
             var aString = Object.prototype.toString.call(a);
             if (aString != Object.prototype.toString.call(b)) {
                 return false;
@@ -613,6 +619,10 @@ var sinon = (function (buster) {
                 return true;
             }
 
+            if (aString == "[object Date]") {
+                return a.valueOf() === b.valueOf();
+            }
+
             var prop, aLength = 0, bLength = 0;
 
             for (prop in a) {
@@ -627,11 +637,7 @@ var sinon = (function (buster) {
                 bLength += 1;
             }
 
-            if (aLength != bLength) {
-                return false;
-            }
-
-            return true;
+            return aLength == bLength;
         },
 
         functionName: function functionName(func) {
@@ -702,7 +708,7 @@ var sinon = (function (buster) {
 
         calledInOrder: function (spies) {
             for (var i = 1, l = spies.length; i < l; i++) {
-                if (!spies[i - 1].calledBefore(spies[i])) {
+                if (!spies[i - 1].calledBefore(spies[i]) || !spies[i].called) {
                     return false;
                 }
             }
@@ -737,10 +743,33 @@ var sinon = (function (buster) {
 
         typeOf: function (value) {
             if (value === null) {
-              return "null";
+                return "null";
+            }
+            else if (value === undefined) {
+                return "undefined";
             }
             var string = Object.prototype.toString.call(value);
             return string.substring(8, string.length - 1).toLowerCase();
+        },
+
+        createStubInstance: function (constructor) {
+            if (typeof constructor !== "function") {
+                throw new TypeError("The constructor should be a function.");
+            }
+            return sinon.stub(sinon.create(constructor.prototype));
+        },
+
+        restore: function (object) {
+            if (object !== null && typeof object === "object") {
+                for (var prop in object) {
+                    if (isRestorable(object[prop])) {
+                        object[prop].restore();
+                    }
+                }
+            }
+            else if (isRestorable(object)) {
+                object.restore();
+            }
         }
     };
 
@@ -1024,530 +1053,574 @@ var sinon = (function (buster) {
 }(typeof sinon == "object" && sinon || null));
 
 /**
- * @depend ../sinon.js
- * @depend match.js
- */
+  * @depend ../sinon.js
+  * @depend match.js
+  */
 /*jslint eqeqeq: false, onevar: false, plusplus: false*/
 /*global module, require, sinon*/
 /**
- * Spy functions
- *
- * @author Christian Johansen (christian@cjohansen.no)
- * @license BSD
- *
- * Copyright (c) 2010-2011 Christian Johansen
- */
+  * Spy calls
+  *
+  * @author Christian Johansen (christian@cjohansen.no)
+  * @author Maximilian Antoni (mail@maxantoni.de)
+  * @license BSD
+  *
+  * Copyright (c) 2010-2013 Christian Johansen
+  * Copyright (c) 2013 Maximilian Antoni
+  */
+
+var commonJSModule = typeof module == "object" && typeof require == "function";
+
+if (!this.sinon && commonJSModule) {
+    var sinon = require("../sinon");
+}
 
 (function (sinon) {
-    var commonJSModule = typeof module == "object" && typeof require == "function";
-    var spyCall;
-    var callId = 0;
-    var push = [].push;
-    var slice = Array.prototype.slice;
-
-    if (!sinon && commonJSModule) {
-        sinon = require("../sinon");
-    }
-
-    if (!sinon) {
-        return;
-    }
-
-    function spy(object, property) {
-        if (!property && typeof object == "function") {
-            return spy.create(object);
-        }
-
-        if (!object && !property) {
-            return spy.create(function () {});
+    function throwYieldError(proxy, text, args) {
+        var msg = sinon.functionName(proxy) + text;
+        if (args.length) {
+            msg += " Received [" + slice.call(args).join(", ") + "]";
         }
-
-        var method = object[property];
-        return sinon.wrapMethod(object, property, spy.create(method));
+        throw new Error(msg);
     }
 
-    sinon.extend(spy, (function () {
+    var slice = Array.prototype.slice;
 
-        function delegateToCalls(api, method, matchAny, actual, notCalled) {
-            api[method] = function () {
-                if (!this.called) {
-                    if (notCalled) {
-                        return notCalled.apply(this, arguments);
-                    }
+    var callProto = {
+        calledOn: function calledOn(thisValue) {
+            if (sinon.match && sinon.match.isMatcher(thisValue)) {
+                return thisValue.test(this.thisValue);
+            }
+            return this.thisValue === thisValue;
+        },
+
+        calledWith: function calledWith() {
+            for (var i = 0, l = arguments.length; i < l; i += 1) {
+                if (!sinon.deepEqual(arguments[i], this.args[i])) {
                     return false;
                 }
+            }
 
-                var currentCall;
-                var matches = 0;
-
-                for (var i = 0, l = this.callCount; i < l; i += 1) {
-                    currentCall = this.getCall(i);
-
-                    if (currentCall[actual || method].apply(currentCall, arguments)) {
-                        matches += 1;
+            return true;
+        },
 
-                        if (matchAny) {
-                            return true;
-                        }
-                    }
+        calledWithMatch: function calledWithMatch() {
+            for (var i = 0, l = arguments.length; i < l; i += 1) {
+                var actual = this.args[i];
+                var expectation = arguments[i];
+                if (!sinon.match || !sinon.match(expectation).test(actual)) {
+                    return false;
                 }
-
-                return matches === this.callCount;
-            };
-        }
-
-        function matchingFake(fakes, args, strict) {
-            if (!fakes) {
-                return;
             }
+            return true;
+        },
 
-            var alen = args.length;
+        calledWithExactly: function calledWithExactly() {
+            return arguments.length == this.args.length &&
+                this.calledWith.apply(this, arguments);
+        },
 
-            for (var i = 0, l = fakes.length; i < l; i++) {
-                if (fakes[i].matches(args, strict)) {
-                    return fakes[i];
-                }
-            }
-        }
+        notCalledWith: function notCalledWith() {
+            return !this.calledWith.apply(this, arguments);
+        },
 
-        function incrementCallCount() {
-            this.called = true;
-            this.callCount += 1;
-            this.notCalled = false;
-            this.calledOnce = this.callCount == 1;
-            this.calledTwice = this.callCount == 2;
-            this.calledThrice = this.callCount == 3;
-        }
+        notCalledWithMatch: function notCalledWithMatch() {
+            return !this.calledWithMatch.apply(this, arguments);
+        },
 
-        function createCallProperties() {
-            this.firstCall = this.getCall(0);
-            this.secondCall = this.getCall(1);
-            this.thirdCall = this.getCall(2);
-            this.lastCall = this.getCall(this.callCount - 1);
-        }
+        returned: function returned(value) {
+            return sinon.deepEqual(value, this.returnValue);
+        },
 
-        var vars = "a,b,c,d,e,f,g,h,i,j,k,l";
-        function createProxy(func) {
-            // Retain the function length:
-            if (func.length) {
-                return eval("(function proxy(" + vars.substring(0, func.length * 2 - 1) +
-                  ") { return proxy.invoke(func, this, slice.call(arguments)); })");
+        threw: function threw(error) {
+            if (typeof error === "undefined" || !this.exception) {
+                return !!this.exception;
             }
-            return function proxy() {
-                return proxy.invoke(func, this, slice.call(arguments));
-            };
-        }
 
-        var uuid = 0;
-
-        // Public API
-        var spyApi = {
-            reset: function () {
-                this.called = false;
-                this.notCalled = true;
-                this.calledOnce = false;
-                this.calledTwice = false;
-                this.calledThrice = false;
-                this.callCount = 0;
-                this.firstCall = null;
-                this.secondCall = null;
-                this.thirdCall = null;
-                this.lastCall = null;
-                this.args = [];
-                this.returnValues = [];
-                this.thisValues = [];
-                this.exceptions = [];
-                this.callIds = [];
-                if (this.fakes) {
-                    for (var i = 0; i < this.fakes.length; i++) {
-                        this.fakes[i].reset();
-                    }
-                }
-            },
+            return this.exception === error || this.exception.name === error;
+        },
 
-            create: function create(func) {
-                var name;
+        calledWithNew: function calledWithNew(thisValue) {
+            return this.thisValue instanceof this.proxy;
+        },
 
-                if (typeof func != "function") {
-                    func = function () {};
-                } else {
-                    name = sinon.functionName(func);
-                }
+        calledBefore: function (other) {
+            return this.callId < other.callId;
+        },
 
-                var proxy = createProxy(func);
+        calledAfter: function (other) {
+            return this.callId > other.callId;
+        },
 
-                sinon.extend(proxy, spy);
-                delete proxy.create;
-                sinon.extend(proxy, func);
+        callArg: function (pos) {
+            this.args[pos]();
+        },
 
-                proxy.reset();
-                proxy.prototype = func.prototype;
-                proxy.displayName = name || "spy";
-                proxy.toString = sinon.functionToString;
-                proxy._create = sinon.spy.create;
-                proxy.id = "spy#" + uuid++;
+        callArgOn: function (pos, thisValue) {
+            this.args[pos].apply(thisValue);
+        },
 
-                return proxy;
-            },
+        callArgWith: function (pos) {
+            this.callArgOnWith.apply(this, [pos, null].concat(slice.call(arguments, 1)));
+        },
 
-            invoke: function invoke(func, thisValue, args) {
-                var matching = matchingFake(this.fakes, args);
-                var exception, returnValue;
+        callArgOnWith: function (pos, thisValue) {
+            var args = slice.call(arguments, 2);
+            this.args[pos].apply(thisValue, args);
+        },
 
-                incrementCallCount.call(this);
-                push.call(this.thisValues, thisValue);
-                push.call(this.args, args);
-                push.call(this.callIds, callId++);
+        "yield": function () {
+            this.yieldOn.apply(this, [null].concat(slice.call(arguments, 0)));
+        },
 
-                try {
-                    if (matching) {
-                        returnValue = matching.invoke(func, thisValue, args);
-                    } else {
-                        returnValue = (this.func || func).apply(thisValue, args);
-                    }
-                } catch (e) {
-                    push.call(this.returnValues, undefined);
-                    exception = e;
-                    throw e;
-                } finally {
-                    push.call(this.exceptions, exception);
+        yieldOn: function (thisValue) {
+            var args = this.args;
+            for (var i = 0, l = args.length; i < l; ++i) {
+                if (typeof args[i] === "function") {
+                    args[i].apply(thisValue, slice.call(arguments, 1));
+                    return;
                 }
+            }
+            throwYieldError(this.proxy, " cannot yield since no callback was passed.", args);
+        },
 
-                push.call(this.returnValues, returnValue);
+        yieldTo: function (prop) {
+            this.yieldToOn.apply(this, [prop, null].concat(slice.call(arguments, 1)));
+        },
 
-                createCallProperties.call(this);
+        yieldToOn: function (prop, thisValue) {
+            var args = this.args;
+            for (var i = 0, l = args.length; i < l; ++i) {
+                if (args[i] && typeof args[i][prop] === "function") {
+                    args[i][prop].apply(thisValue, slice.call(arguments, 2));
+                    return;
+                }
+            }
+            throwYieldError(this.proxy, " cannot yield to '" + prop +
+                "' since no callback was passed.", args);
+        },
 
-                return returnValue;
-            },
+        toString: function () {
+            var callStr = this.proxy.toString() + "(";
+            var args = [];
 
-            getCall: function getCall(i) {
-                if (i < 0 || i >= this.callCount) {
-                    return null;
-                }
+            for (var i = 0, l = this.args.length; i < l; ++i) {
+                args.push(sinon.format(this.args[i]));
+            }
 
-                return spyCall.create(this, this.thisValues[i], this.args[i],
-                                      this.returnValues[i], this.exceptions[i],
-                                      this.callIds[i]);
-            },
+            callStr = callStr + args.join(", ") + ")";
 
-            calledBefore: function calledBefore(spyFn) {
-                if (!this.called) {
-                    return false;
-                }
+            if (typeof this.returnValue != "undefined") {
+                callStr += " => " + sinon.format(this.returnValue);
+            }
 
-                if (!spyFn.called) {
-                    return true;
+            if (this.exception) {
+                callStr += " !" + this.exception.name;
+
+                if (this.exception.message) {
+                    callStr += "(" + this.exception.message + ")";
                 }
+            }
 
-                return this.callIds[0] < spyFn.callIds[spyFn.callIds.length - 1];
-            },
+            return callStr;
+        }
+    };
 
-            calledAfter: function calledAfter(spyFn) {
-                if (!this.called || !spyFn.called) {
-                    return false;
-                }
+    callProto.invokeCallback = callProto.yield;
 
-                return this.callIds[this.callCount - 1] > spyFn.callIds[spyFn.callCount - 1];
-            },
+    function createSpyCall(spy, thisValue, args, returnValue, exception, id) {
+        if (typeof id !== "number") {
+            throw new TypeError("Call id is not a number");
+        }
+        var proxyCall = sinon.create(callProto);
+        proxyCall.proxy = spy;
+        proxyCall.thisValue = thisValue;
+        proxyCall.args = args;
+        proxyCall.returnValue = returnValue;
+        proxyCall.exception = exception;
+        proxyCall.callId = id;
+
+        return proxyCall;
+    };
+    createSpyCall.toString = callProto.toString; // used by mocks
 
-            withArgs: function () {
-                var args = slice.call(arguments);
+    sinon.spyCall = createSpyCall;
+}(typeof sinon == "object" && sinon || null));
 
-                if (this.fakes) {
-                    var match = matchingFake(this.fakes, args, true);
+/**
+  * @depend ../sinon.js
+  */
+/*jslint eqeqeq: false, onevar: false, plusplus: false*/
+/*global module, require, sinon*/
+/**
+  * Spy functions
+  *
+  * @author Christian Johansen (christian@cjohansen.no)
+  * @license BSD
+  *
+  * Copyright (c) 2010-2013 Christian Johansen
+  */
 
-                    if (match) {
-                        return match;
-                    }
-                } else {
-                    this.fakes = [];
-                }
+(function (sinon) {
+    var commonJSModule = typeof module == "object" && typeof require == "function";
+    var push = Array.prototype.push;
+    var slice = Array.prototype.slice;
+    var callId = 0;
 
-                var original = this;
-                var fake = this._create();
-                fake.matchingAguments = args;
-                push.call(this.fakes, fake);
+    function spy(object, property) {
+        if (!property && typeof object == "function") {
+            return spy.create(object);
+        }
 
-                fake.withArgs = function () {
-                    return original.withArgs.apply(original, arguments);
-                };
+        if (!object && !property) {
+            return spy.create(function () { });
+        }
 
-                for (var i = 0; i < this.args.length; i++) {
-                    if (fake.matches(this.args[i])) {
-                        incrementCallCount.call(fake);
-                        push.call(fake.thisValues, this.thisValues[i]);
-                        push.call(fake.args, this.args[i]);
-                        push.call(fake.returnValues, this.returnValues[i]);
-                        push.call(fake.exceptions, this.exceptions[i]);
-                        push.call(fake.callIds, this.callIds[i]);
-                    }
-                }
-                createCallProperties.call(fake);
+        var method = object[property];
+        return sinon.wrapMethod(object, property, spy.create(method));
+    }
 
-                return fake;
-            },
+    function matchingFake(fakes, args, strict) {
+        if (!fakes) {
+            return;
+        }
 
-            matches: function (args, strict) {
-                var margs = this.matchingAguments;
+        var alen = args.length;
 
-                if (margs.length <= args.length &&
-                    sinon.deepEqual(margs, args.slice(0, margs.length))) {
-                    return !strict || margs.length == args.length;
-                }
-            },
+        for (var i = 0, l = fakes.length; i < l; i++) {
+            if (fakes[i].matches(args, strict)) {
+                return fakes[i];
+            }
+        }
+    }
 
-            printf: function (format) {
-                var spy = this;
-                var args = slice.call(arguments, 1);
-                var formatter;
+    function incrementCallCount() {
+        this.called = true;
+        this.callCount += 1;
+        this.notCalled = false;
+        this.calledOnce = this.callCount == 1;
+        this.calledTwice = this.callCount == 2;
+        this.calledThrice = this.callCount == 3;
+    }
 
-                return (format || "").replace(/%(.)/g, function (match, specifyer) {
-                    formatter = spyApi.formatters[specifyer];
+    function createCallProperties() {
+        this.firstCall = this.getCall(0);
+        this.secondCall = this.getCall(1);
+        this.thirdCall = this.getCall(2);
+        this.lastCall = this.getCall(this.callCount - 1);
+    }
 
-                    if (typeof formatter == "function") {
-                        return formatter.call(null, spy, args);
-                    } else if (!isNaN(parseInt(specifyer), 10)) {
-                        return sinon.format(args[specifyer - 1]);
-                    }
+    var vars = "a,b,c,d,e,f,g,h,i,j,k,l";
+    function createProxy(func) {
+        // Retain the function length:
+        var p;
+        if (func.length) {
+            eval("p = (function proxy(" + vars.substring(0, func.length * 2 - 1) +
+                ") { return p.invoke(func, this, slice.call(arguments)); });");
+        }
+        else {
+            p = function proxy() {
+                return p.invoke(func, this, slice.call(arguments));
+            };
+        }
+        return p;
+    }
 
-                    return "%" + specifyer;
-                });
+    var uuid = 0;
+
+    // Public API
+    var spyApi = {
+        reset: function () {
+            this.called = false;
+            this.notCalled = true;
+            this.calledOnce = false;
+            this.calledTwice = false;
+            this.calledThrice = false;
+            this.callCount = 0;
+            this.firstCall = null;
+            this.secondCall = null;
+            this.thirdCall = null;
+            this.lastCall = null;
+            this.args = [];
+            this.returnValues = [];
+            this.thisValues = [];
+            this.exceptions = [];
+            this.callIds = [];
+            if (this.fakes) {
+                for (var i = 0; i < this.fakes.length; i++) {
+                    this.fakes[i].reset();
+                }
             }
-        };
+        },
 
-        delegateToCalls(spyApi, "calledOn", true);
-        delegateToCalls(spyApi, "alwaysCalledOn", false, "calledOn");
-        delegateToCalls(spyApi, "calledWith", true);
-        delegateToCalls(spyApi, "calledWithMatch", true);
-        delegateToCalls(spyApi, "alwaysCalledWith", false, "calledWith");
-        delegateToCalls(spyApi, "alwaysCalledWithMatch", false, "calledWithMatch");
-        delegateToCalls(spyApi, "calledWithExactly", true);
-        delegateToCalls(spyApi, "alwaysCalledWithExactly", false, "calledWithExactly");
-        delegateToCalls(spyApi, "neverCalledWith", false, "notCalledWith",
-            function () { return true; });
-        delegateToCalls(spyApi, "neverCalledWithMatch", false, "notCalledWithMatch",
-            function () { return true; });
-        delegateToCalls(spyApi, "threw", true);
-        delegateToCalls(spyApi, "alwaysThrew", false, "threw");
-        delegateToCalls(spyApi, "returned", true);
-        delegateToCalls(spyApi, "alwaysReturned", false, "returned");
-        delegateToCalls(spyApi, "calledWithNew", true);
-        delegateToCalls(spyApi, "alwaysCalledWithNew", false, "calledWithNew");
-        delegateToCalls(spyApi, "callArg", false, "callArgWith", function () {
-            throw new Error(this.toString() + " cannot call arg since it was not yet invoked.");
-        });
-        spyApi.callArgWith = spyApi.callArg;
-        delegateToCalls(spyApi, "yield", false, "yield", function () {
-            throw new Error(this.toString() + " cannot yield since it was not yet invoked.");
-        });
-        // "invokeCallback" is an alias for "yield" since "yield" is invalid in strict mode.
-        spyApi.invokeCallback = spyApi.yield;
-        delegateToCalls(spyApi, "yieldTo", false, "yieldTo", function (property) {
-            throw new Error(this.toString() + " cannot yield to '" + property +
-                "' since it was not yet invoked.");
-        });
+        create: function create(func) {
+            var name;
 
-        spyApi.formatters = {
-            "c": function (spy) {
-                return sinon.timesInWords(spy.callCount);
-            },
+            if (typeof func != "function") {
+                func = function () { };
+            } else {
+                name = sinon.functionName(func);
+            }
 
-            "n": function (spy) {
-                return spy.toString();
-            },
+            var proxy = createProxy(func);
 
-            "C": function (spy) {
-                var calls = [];
+            sinon.extend(proxy, spy);
+            delete proxy.create;
+            sinon.extend(proxy, func);
 
-                for (var i = 0, l = spy.callCount; i < l; ++i) {
-                    push.call(calls, "    " + spy.getCall(i).toString());
-                }
+            proxy.reset();
+            proxy.prototype = func.prototype;
+            proxy.displayName = name || "spy";
+            proxy.toString = sinon.functionToString;
+            proxy._create = sinon.spy.create;
+            proxy.id = "spy#" + uuid++;
 
-                return calls.length > 0 ? "\n" + calls.join("\n") : "";
-            },
+            return proxy;
+        },
+
+        invoke: function invoke(func, thisValue, args) {
+            var matching = matchingFake(this.fakes, args);
+            var exception, returnValue;
 
-            "t": function (spy) {
-                var objects = [];
+            incrementCallCount.call(this);
+            push.call(this.thisValues, thisValue);
+            push.call(this.args, args);
+            push.call(this.callIds, callId++);
 
-                for (var i = 0, l = spy.callCount; i < l; ++i) {
-                    push.call(objects, sinon.format(spy.thisValues[i]));
+            try {
+                if (matching) {
+                    returnValue = matching.invoke(func, thisValue, args);
+                } else {
+                    returnValue = (this.func || func).apply(thisValue, args);
                 }
+            } catch (e) {
+                push.call(this.returnValues, undefined);
+                exception = e;
+                throw e;
+            } finally {
+                push.call(this.exceptions, exception);
+            }
 
-                return objects.join(", ");
-            },
+            push.call(this.returnValues, returnValue);
 
-            "*": function (spy, args) {
-                var formatted = [];
+            createCallProperties.call(this);
 
-                for (var i = 0, l = args.length; i < l; ++i) {
-                    push.call(formatted, sinon.format(args[i]));
-                }
+            return returnValue;
+        },
 
-                return formatted.join(", ");
+        getCall: function getCall(i) {
+            if (i < 0 || i >= this.callCount) {
+                return null;
             }
-        };
 
-        return spyApi;
-    }()));
-
-    spyCall = (function () {
+            return sinon.spyCall(this, this.thisValues[i], this.args[i],
+                                    this.returnValues[i], this.exceptions[i],
+                                    this.callIds[i]);
+        },
 
-        function throwYieldError(proxy, text, args) {
-            var msg = sinon.functionName(proxy) + text;
-            if (args.length) {
-                msg += " Received [" + slice.call(args).join(", ") + "]";
+        calledBefore: function calledBefore(spyFn) {
+            if (!this.called) {
+                return false;
             }
-            throw new Error(msg);
-        }
 
-        var callApi = {
-            create: function create(spy, thisValue, args, returnValue, exception, id) {
-                var proxyCall = sinon.create(spyCall);
-                delete proxyCall.create;
-                proxyCall.proxy = spy;
-                proxyCall.thisValue = thisValue;
-                proxyCall.args = args;
-                proxyCall.returnValue = returnValue;
-                proxyCall.exception = exception;
-                proxyCall.callId = typeof id == "number" && id || callId++;
-
-                return proxyCall;
-            },
+            if (!spyFn.called) {
+                return true;
+            }
 
-            calledOn: function calledOn(thisValue) {
-                if (sinon.match && sinon.match.isMatcher(thisValue)) {
-                    return thisValue.test(this.thisValue);
-                }
-                return this.thisValue === thisValue;
-            },
+            return this.callIds[0] < spyFn.callIds[spyFn.callIds.length - 1];
+        },
 
-            calledWith: function calledWith() {
-                for (var i = 0, l = arguments.length; i < l; i += 1) {
-                    if (!sinon.deepEqual(arguments[i], this.args[i])) {
-                        return false;
-                    }
-                }
+        calledAfter: function calledAfter(spyFn) {
+            if (!this.called || !spyFn.called) {
+                return false;
+            }
 
-                return true;
-            },
+            return this.callIds[this.callCount - 1] > spyFn.callIds[spyFn.callCount - 1];
+        },
 
-            calledWithMatch: function calledWithMatch() {
-              for (var i = 0, l = arguments.length; i < l; i += 1) {
-                  var actual = this.args[i];
-                  var expectation = arguments[i];
-                  if (!sinon.match || !sinon.match(expectation).test(actual)) {
-                      return false;
-                  }
-              }
-              return true;
-            },
+        withArgs: function () {
+            var args = slice.call(arguments);
 
-            calledWithExactly: function calledWithExactly() {
-                return arguments.length == this.args.length &&
-                    this.calledWith.apply(this, arguments);
-            },
+            if (this.fakes) {
+                var match = matchingFake(this.fakes, args, true);
 
-            notCalledWith: function notCalledWith() {
-                return !this.calledWith.apply(this, arguments);
-            },
+                if (match) {
+                    return match;
+                }
+            } else {
+                this.fakes = [];
+            }
 
-            notCalledWithMatch: function notCalledWithMatch() {
-              return !this.calledWithMatch.apply(this, arguments);
-            },
+            var original = this;
+            var fake = this._create();
+            fake.matchingAguments = args;
+            push.call(this.fakes, fake);
 
-            returned: function returned(value) {
-                return sinon.deepEqual(value, this.returnValue);
-            },
+            fake.withArgs = function () {
+                return original.withArgs.apply(original, arguments);
+            };
 
-            threw: function threw(error) {
-                if (typeof error == "undefined" || !this.exception) {
-                    return !!this.exception;
+            for (var i = 0; i < this.args.length; i++) {
+                if (fake.matches(this.args[i])) {
+                    incrementCallCount.call(fake);
+                    push.call(fake.thisValues, this.thisValues[i]);
+                    push.call(fake.args, this.args[i]);
+                    push.call(fake.returnValues, this.returnValues[i]);
+                    push.call(fake.exceptions, this.exceptions[i]);
+                    push.call(fake.callIds, this.callIds[i]);
                 }
+            }
+            createCallProperties.call(fake);
 
-                if (typeof error == "string") {
-                    return this.exception.name == error;
-                }
+            return fake;
+        },
 
-                return this.exception === error;
-            },
+        matches: function (args, strict) {
+            var margs = this.matchingAguments;
 
-            calledWithNew: function calledWithNew(thisValue) {
-                return this.thisValue instanceof this.proxy;
-            },
+            if (margs.length <= args.length &&
+                sinon.deepEqual(margs, args.slice(0, margs.length))) {
+                return !strict || margs.length == args.length;
+            }
+        },
 
-            calledBefore: function (other) {
-                return this.callId < other.callId;
-            },
+        printf: function (format) {
+            var spy = this;
+            var args = slice.call(arguments, 1);
+            var formatter;
 
-            calledAfter: function (other) {
-                return this.callId > other.callId;
-            },
+            return (format || "").replace(/%(.)/g, function (match, specifyer) {
+                formatter = spyApi.formatters[specifyer];
 
-            callArg: function (pos) {
-                this.args[pos]();
-            },
+                if (typeof formatter == "function") {
+                    return formatter.call(null, spy, args);
+                } else if (!isNaN(parseInt(specifyer), 10)) {
+                    return sinon.format(args[specifyer - 1]);
+                }
 
-            callArgWith: function (pos) {
-                var args = slice.call(arguments, 1);
-                this.args[pos].apply(null, args);
-            },
+                return "%" + specifyer;
+            });
+        }
+    };
 
-            "yield": function () {
-                var args = this.args;
-                for (var i = 0, l = args.length; i < l; ++i) {
-                    if (typeof args[i] === "function") {
-                        args[i].apply(null, slice.call(arguments));
-                        return;
-                    }
+    function delegateToCalls(method, matchAny, actual, notCalled) {
+        spyApi[method] = function () {
+            if (!this.called) {
+                if (notCalled) {
+                    return notCalled.apply(this, arguments);
                 }
-                throwYieldError(this.proxy, " cannot yield since no callback was passed.", args);
-            },
+                return false;
+            }
+
+            var currentCall;
+            var matches = 0;
+
+            for (var i = 0, l = this.callCount; i < l; i += 1) {
+                currentCall = this.getCall(i);
+
+                if (currentCall[actual || method].apply(currentCall, arguments)) {
+                    matches += 1;
 
-            yieldTo: function (prop) {
-                var args = this.args;
-                for (var i = 0, l = args.length; i < l; ++i) {
-                    if (args[i] && typeof args[i][prop] === "function") {
-                        args[i][prop].apply(null, slice.call(arguments, 1));
-                        return;
+                    if (matchAny) {
+                        return true;
                     }
                 }
-                throwYieldError(this.proxy, " cannot yield to '" + prop +
-                    "' since no callback was passed.", args);
-            },
+            }
 
-            toString: function () {
-                var callStr = this.proxy.toString() + "(";
-                var args = [];
+            return matches === this.callCount;
+        };
+    }
 
-                for (var i = 0, l = this.args.length; i < l; ++i) {
-                    push.call(args, sinon.format(this.args[i]));
-                }
+    delegateToCalls("calledOn", true);
+    delegateToCalls("alwaysCalledOn", false, "calledOn");
+    delegateToCalls("calledWith", true);
+    delegateToCalls("calledWithMatch", true);
+    delegateToCalls("alwaysCalledWith", false, "calledWith");
+    delegateToCalls("alwaysCalledWithMatch", false, "calledWithMatch");
+    delegateToCalls("calledWithExactly", true);
+    delegateToCalls("alwaysCalledWithExactly", false, "calledWithExactly");
+    delegateToCalls("neverCalledWith", false, "notCalledWith",
+        function () { return true; });
+    delegateToCalls("neverCalledWithMatch", false, "notCalledWithMatch",
+        function () { return true; });
+    delegateToCalls("threw", true);
+    delegateToCalls("alwaysThrew", false, "threw");
+    delegateToCalls("returned", true);
+    delegateToCalls("alwaysReturned", false, "returned");
+    delegateToCalls("calledWithNew", true);
+    delegateToCalls("alwaysCalledWithNew", false, "calledWithNew");
+    delegateToCalls("callArg", false, "callArgWith", function () {
+        throw new Error(this.toString() + " cannot call arg since it was not yet invoked.");
+    });
+    spyApi.callArgWith = spyApi.callArg;
+    delegateToCalls("callArgOn", false, "callArgOnWith", function () {
+        throw new Error(this.toString() + " cannot call arg since it was not yet invoked.");
+    });
+    spyApi.callArgOnWith = spyApi.callArgOn;
+    delegateToCalls("yield", false, "yield", function () {
+        throw new Error(this.toString() + " cannot yield since it was not yet invoked.");
+    });
+    // "invokeCallback" is an alias for "yield" since "yield" is invalid in strict mode.
+    spyApi.invokeCallback = spyApi.yield;
+    delegateToCalls("yieldOn", false, "yieldOn", function () {
+        throw new Error(this.toString() + " cannot yield since it was not yet invoked.");
+    });
+    delegateToCalls("yieldTo", false, "yieldTo", function (property) {
+        throw new Error(this.toString() + " cannot yield to '" + property +
+            "' since it was not yet invoked.");
+    });
+    delegateToCalls("yieldToOn", false, "yieldToOn", function (property) {
+        throw new Error(this.toString() + " cannot yield to '" + property +
+            "' since it was not yet invoked.");
+    });
 
-                callStr = callStr + args.join(", ") + ")";
+    spyApi.formatters = {
+        "c": function (spy) {
+            return sinon.timesInWords(spy.callCount);
+        },
 
-                if (typeof this.returnValue != "undefined") {
-                    callStr += " => " + sinon.format(this.returnValue);
-                }
+        "n": function (spy) {
+            return spy.toString();
+        },
 
-                if (this.exception) {
-                    callStr += " !" + this.exception.name;
+        "C": function (spy) {
+            var calls = [];
 
-                    if (this.exception.message) {
-                        callStr += "(" + this.exception.message + ")";
-                    }
+            for (var i = 0, l = spy.callCount; i < l; ++i) {
+                var stringifiedCall = "    " + spy.getCall(i).toString();
+                if (/\n/.test(calls[i - 1])) {
+                    stringifiedCall = "\n" + stringifiedCall;
                 }
+                push.call(calls, stringifiedCall);
+            }
+
+            return calls.length > 0 ? "\n" + calls.join("\n") : "";
+        },
+
+        "t": function (spy) {
+            var objects = [];
 
-                return callStr;
+            for (var i = 0, l = spy.callCount; i < l; ++i) {
+                push.call(objects, sinon.format(spy.thisValues[i]));
             }
-        };
-        callApi.invokeCallback = callApi.yield;
-        return callApi;
-    }());
 
-    spy.spyCall = spyCall;
+            return objects.join(", ");
+        },
+
+        "*": function (spy, args) {
+            var formatted = [];
+
+            for (var i = 0, l = args.length; i < l; ++i) {
+                push.call(formatted, sinon.format(args[i]));
+            }
+
+            return formatted.join(", ");
+        }
+    };
 
-    // This steps outside the module sandbox and will be removed
-    sinon.spyCall = spyCall;
+    sinon.extend(spy, spyApi);
+
+    spy.spyCall = sinon.spyCall;
 
     if (commonJSModule) {
         module.exports = spy;
@@ -1568,7 +1641,7 @@ var sinon = (function (buster) {
  * @author Christian Johansen (christian@cjohansen.no)
  * @license BSD
  *
- * Copyright (c) 2010-2011 Christian Johansen
+ * Copyright (c) 2010-2013 Christian Johansen
  */
 
 (function (sinon) {
@@ -1614,7 +1687,8 @@ var sinon = (function (buster) {
 
     function getChangingValue(stub, property) {
         var index = stub.callCount - 1;
-        var prop = index in stub[property] ? stub[property][index] : stub[property + "Last"];
+        var values = stub[property];
+        var prop = index in values ? values[index] : values[values.length - 1];
         stub[property + "Last"] = prop;
 
         return prop;
@@ -1671,8 +1745,6 @@ var sinon = (function (buster) {
     var nextTick = (function () {
         if (typeof process === "object" && typeof process.nextTick === "function") {
             return process.nextTick;
-        } else if (typeof msSetImmediate === "function") {
-            return msSetImmediate.bind(window);
         } else if (typeof setImmediate === "function") {
             return setImmediate;
         } else {
@@ -1690,8 +1762,6 @@ var sinon = (function (buster) {
                 throw new TypeError(getCallbackError(stub, func, args));
             }
 
-            var index = stub.callCount - 1;
-
             var callbackArguments = getChangingValue(stub, "callbackArguments");
             var callbackContext = getChangingValue(stub, "callbackContexts");
 
@@ -1757,6 +1827,25 @@ var sinon = (function (buster) {
                 return functionStub;
             },
 
+            resetBehavior: function () {
+                var i;
+
+                this.callArgAts = [];
+                this.callbackArguments = [];
+                this.callbackContexts = [];
+                this.callArgProps = [];
+
+                delete this.returnValue;
+                delete this.returnArgAt;
+                this.returnThis = false;
+
+                if (this.fakes) {
+                    for (i = 0; i < this.fakes.length; i++) {
+                        this.fakes[i].resetBehavior();
+                    }
+                }
+            },
+
             returns: function returns(value) {
                 this.returnValue = value;
 
@@ -1923,7 +2012,7 @@ var sinon = (function (buster) {
  * @author Christian Johansen (christian@cjohansen.no)
  * @license BSD
  *
- * Copyright (c) 2010-2011 Christian Johansen
+ * Copyright (c) 2010-2013 Christian Johansen
  */
 
 (function (sinon) {
@@ -2212,24 +2301,24 @@ var sinon = (function (buster) {
 
                 if (!args) {
                     sinon.expectation.fail(this.method + " received no arguments, expected " +
-                        this.expectedArguments.join());
+                        sinon.format(this.expectedArguments));
                 }
 
                 if (args.length < this.expectedArguments.length) {
-                    sinon.expectation.fail(this.method + " received too few arguments (" + args.join() +
-                        "), expected " + this.expectedArguments.join());
+                    sinon.expectation.fail(this.method + " received too few arguments (" + sinon.format(args) +
+                        "), expected " + sinon.format(this.expectedArguments));
                 }
 
                 if (this.expectsExactArgCount &&
                     args.length != this.expectedArguments.length) {
-                    sinon.expectation.fail(this.method + " received too many arguments (" + args.join() +
-                        "), expected " + this.expectedArguments.join());
+                    sinon.expectation.fail(this.method + " received too many arguments (" + sinon.format(args) +
+                        "), expected " + sinon.format(this.expectedArguments));
                 }
 
                 for (var i = 0, l = this.expectedArguments.length; i < l; i += 1) {
                     if (!sinon.deepEqual(this.expectedArguments[i], args[i])) {
-                        sinon.expectation.fail(this.method + " received wrong arguments (" + args.join() +
-                            "), expected " + this.expectedArguments.join());
+                        sinon.expectation.fail(this.method + " received wrong arguments " + sinon.format(args) +
+                            ", expected " + sinon.format(this.expectedArguments));
                     }
                 }
             },
@@ -2291,7 +2380,8 @@ var sinon = (function (buster) {
                 }
 
                 var callStr = sinon.spyCall.toString.call({
-                    proxy: this.method, args: args
+                    proxy: this.method || "anonymous mock expectation",
+                    args: args
                 });
 
                 var message = callStr.replace(", [...", "[, ...") + " " +
@@ -2347,7 +2437,7 @@ var sinon = (function (buster) {
  * @author Christian Johansen (christian@cjohansen.no)
  * @license BSD
  *
- * Copyright (c) 2010-2011 Christian Johansen
+ * Copyright (c) 2010-2013 Christian Johansen
  */
 
 (function (sinon) {
@@ -2504,7 +2594,7 @@ var sinon = (function (buster) {
  * @author Christian Johansen (christian@cjohansen.no)
  * @license BSD
  *
- * Copyright (c) 2010-2011 Christian Johansen
+ * Copyright (c) 2010-2013 Christian Johansen
  */
 
 if (typeof sinon == "undefined") {
@@ -2645,6 +2735,8 @@ if (typeof sinon == "undefined") {
             if (firstException) {
               throw firstException;
             }
+
+            return this.now;
         },
 
         firstTimerInRange: function (from, to) {
@@ -2858,15 +2950,16 @@ if (typeof sinon == "undefined") {
 (function () {
     var push = [].push;
 
-    sinon.Event = function Event(type, bubbles, cancelable) {
-        this.initEvent(type, bubbles, cancelable);
+    sinon.Event = function Event(type, bubbles, cancelable, target) {
+        this.initEvent(type, bubbles, cancelable, target);
     };
 
     sinon.Event.prototype = {
-        initEvent: function(type, bubbles, cancelable) {
+        initEvent: function(type, bubbles, cancelable, target) {
             this.type = type;
             this.bubbles = bubbles;
             this.cancelable = cancelable;
+            this.target = target;
         },
 
         stopPropagation: function () {},
@@ -2922,7 +3015,7 @@ if (typeof sinon == "undefined") {
  * @author Christian Johansen (christian@cjohansen.no)
  * @license BSD
  *
- * Copyright (c) 2010-2011 Christian Johansen
+ * Copyright (c) 2010-2013 Christian Johansen
  */
 
 if (typeof sinon == "undefined") {
@@ -2970,6 +3063,23 @@ sinon.xhr = { XMLHttpRequest: this.XMLHttpRequest };
         this.status = 0;
         this.statusText = "";
 
+        var xhr = this;
+        var events = ["loadstart", "load", "abort", "loadend"];
+
+        function addEventListener(eventName) {
+            xhr.addEventListener(eventName, function (event) {
+                var listener = xhr["on" + eventName];
+
+                if (listener && typeof listener == "function") {
+                    listener(event);
+                }
+            });
+        }
+
+        for (var i = events.length - 1; i >= 0; i--) {
+            addEventListener(events[i]);
+        }
+
         if (typeof FakeXMLHttpRequest.onCreate == "function") {
             FakeXMLHttpRequest.onCreate(this);
         }
@@ -3123,6 +3233,13 @@ sinon.xhr = { XMLHttpRequest: this.XMLHttpRequest };
             }
 
             this.dispatchEvent(new sinon.Event("readystatechange"));
+
+            switch (this.readyState) {
+                case FakeXMLHttpRequest.DONE:
+                    this.dispatchEvent(new sinon.Event("load", false, false, this));
+                    this.dispatchEvent(new sinon.Event("loadend", false, false, this));
+                    break;
+            }
         },
 
         setRequestHeader: function setRequestHeader(header, value) {
@@ -3151,6 +3268,8 @@ sinon.xhr = { XMLHttpRequest: this.XMLHttpRequest };
 
             if (this.async) {
                 this.readyStateChange(FakeXMLHttpRequest.HEADERS_RECEIVED);
+            } else {
+                this.readyState = FakeXMLHttpRequest.HEADERS_RECEIVED;
             }
         },
 
@@ -3176,6 +3295,8 @@ sinon.xhr = { XMLHttpRequest: this.XMLHttpRequest };
             if (typeof this.onSend == "function") {
                 this.onSend(this);
             }
+
+            this.dispatchEvent(new sinon.Event("loadstart", false, false, this));
         },
 
         abort: function abort() {
@@ -3190,6 +3311,11 @@ sinon.xhr = { XMLHttpRequest: this.XMLHttpRequest };
             }
 
             this.readyState = sinon.FakeXMLHttpRequest.UNSENT;
+
+            this.dispatchEvent(new sinon.Event("abort", false, false, this));
+            if (typeof this.onerror === "function") {
+                this.onerror();
+            }
         },
 
         getResponseHeader: function getResponseHeader(header) {
@@ -3270,6 +3396,10 @@ sinon.xhr = { XMLHttpRequest: this.XMLHttpRequest };
             this.status = typeof status == "number" ? status : 200;
             this.statusText = FakeXMLHttpRequest.statusCodes[this.status];
             this.setResponseBody(body || "");
+            if (typeof this.onload === "function"){
+                this.onload();
+            }
+
         }
     });
 
@@ -3396,7 +3526,7 @@ if (typeof module == "object" && typeof require == "function") {
  * @author Christian Johansen (christian@cjohansen.no)
  * @license BSD
  *
- * Copyright (c) 2010-2011 Christian Johansen
+ * Copyright (c) 2010-2013 Christian Johansen
  */
 
 if (typeof sinon == "undefined") {
@@ -3460,6 +3590,15 @@ sinon.fakeServer = (function () {
         return false;
     }
 
+    function log(response, request) {
+        var str;
+
+        str =  "Request:\n"  + sinon.format(request)  + "\n\n";
+        str += "Response:\n" + sinon.format(response) + "\n\n";
+
+        sinon.log(str);
+    }
+
     return {
         create: function () {
             var server = create(this);
@@ -3566,6 +3705,8 @@ sinon.fakeServer = (function () {
                 }
 
                 if (request.readyState != 4) {
+                    log(response, request);
+
                     request.respond(response[0], response[1], response[2]);
                 }
             } catch (e) {
@@ -3601,7 +3742,7 @@ if (typeof module == "object" && typeof require == "function") {
  * @author Christian Johansen (christian@cjohansen.no)
  * @license BSD
  *
- * Copyright (c) 2010-2011 Christian Johansen
+ * Copyright (c) 2010-2013 Christian Johansen
  */
 
 (function () {
@@ -3681,7 +3822,7 @@ if (typeof module == "object" && typeof require == "function") {
  * @author Christian Johansen (christian@cjohansen.no)
  * @license BSD
  *
- * Copyright (c) 2010-2011 Christian Johansen
+ * Copyright (c) 2010-2013 Christian Johansen
  */
 
 if (typeof module == "object" && typeof require == "function") {
@@ -3805,7 +3946,7 @@ if (typeof module == "object" && typeof require == "function") {
  * @author Christian Johansen (christian@cjohansen.no)
  * @license BSD
  *
- * Copyright (c) 2010-2011 Christian Johansen
+ * Copyright (c) 2010-2013 Christian Johansen
  */
 
 (function (sinon) {
@@ -3878,7 +4019,7 @@ if (typeof module == "object" && typeof require == "function") {
  * @author Christian Johansen (christian@cjohansen.no)
  * @license BSD
  *
- * Copyright (c) 2010-2011 Christian Johansen
+ * Copyright (c) 2010-2013 Christian Johansen
  */
 
 (function (sinon) {
@@ -3975,7 +4116,7 @@ if (typeof module == "object" && typeof require == "function") {
  * @author Christian Johansen (christian@cjohansen.no)
  * @license BSD
  *
- * Copyright (c) 2010-2011 Christian Johansen
+ * Copyright (c) 2010-2013 Christian Johansen
  */
 
 (function (sinon, global) {
@@ -4068,7 +4209,14 @@ if (typeof module == "object" && typeof require == "function") {
             if (!sinon.calledInOrder(arguments)) {
                 try {
                     expected = [].join.call(arguments, ", ");
-                    actual = sinon.orderByFirstCall(slice.call(arguments)).join(", ");
+                    var calls = slice.call(arguments);
+                    var i = calls.length;
+                    while (i) {
+                        if (!calls[--i].called) {
+                            calls.splice(i, 1);
+                        }
+                    }
+                    actual = sinon.orderByFirstCall(calls).join(", ");
                 } catch (e) {
                     // If this fails, we'll just fall back to the blank string
                 }
@@ -4137,6 +4285,6 @@ if (typeof module == "object" && typeof require == "function") {
     } else {
         sinon.assert = assert;
     }
-}(typeof sinon == "object" && sinon || null, typeof window != "undefined" ? window : global));
+}(typeof sinon == "object" && sinon || null, typeof window != "undefined" ? window : (typeof self != "undefined") ? self : global));
 
-return sinon;}.call(typeof window != 'undefined' && window || {}));
\ No newline at end of file
+return sinon;}.call(typeof window != 'undefined' && window || {}));
diff --git a/tests/js/spec/OrderedElementsViewSpec.js b/tests/js/spec/OrderedElementsViewSpec.js
index 2c1ff02e3a..6d5044ee52 100644
--- a/tests/js/spec/OrderedElementsViewSpec.js
+++ b/tests/js/spec/OrderedElementsViewSpec.js
@@ -1,7 +1,7 @@
 function make_group(data) {
   data = data || {};
 
-  return new app.models.Group({
+  return {
     id: data.id || 1,
     score: data.score || 5,
     count: 1,
@@ -14,8 +14,9 @@ function make_group(data) {
     canResolve: false,
     logger: 'root',
     versions: [],
-    tags: []
-  });
+    tags: [],
+    version: 0
+  };
 }
 
 describe("OrderedElementsView", function() {
@@ -34,11 +35,11 @@ describe("OrderedElementsView", function() {
     });
 
     it("should suggest its not loaded", function() {
-      expect(view.loaded).toBe(false);
+      assert.isFalse(view.loaded);
     });
 
     it("has status text to loading", function() {
-      expect(view.$empty.html()).toBe(view.loadingMessage);
+      assert.equal(view.$empty.html(), view.loadingMessage);
     });
   });
 
@@ -52,11 +53,11 @@ describe("OrderedElementsView", function() {
     });
 
     it("should suggest its loaded", function() {
-      expect(view.loaded).toBe(true);
+      assert.isTrue(view.loaded);
     });
 
     it("has status text to loading", function() {
-      expect(view.$empty.html()).not.toBe(view.loadingMessage);
+      assert.notEqual(view.$empty.html(), view.loadingMessage);
     });
   });
 
@@ -68,21 +69,20 @@ describe("OrderedElementsView", function() {
         view = new app.OrderedElementsView({
             id: 'foo'
         });
-        view.collection.reset = sinon.spy();
+        view.collection.reset = this.sinon.spy();
         view.reset([group1]);
       });
 
       it("calls collection.reset with data", function() {
-        expect(view.collection.reset.called).toBe(true);
-        expect(view.collection.reset.calledWithExactly([group1])).toBe(true);
+        assert.isTrue(view.collection.reset.calledOnce);
       });
 
       it("suggests its loaded", function() {
-        expect(view.loaded).toBe(true);
+        assert.isTrue(view.loaded);
       });
 
       it("changes status text to empty", function() {
-        expect(view.$empty.html()).toBe(view.emptyMessage);
+        assert.equal(view.$empty.html(), view.emptyMessage);
       });
     });
 
@@ -92,21 +92,21 @@ describe("OrderedElementsView", function() {
             id: 'foo'
         });
         group1 = make_group({id: 1, score: 3});
-        view.collection.reset = sinon.spy();
+        view.collection.reset = this.sinon.spy();
         view.reset([]);
       });
 
       it("calls collection.reset with data", function() {
-        expect(view.collection.reset.called).toBe(true);
-        expect(view.collection.reset.calledWithExactly([])).toBe(true);
+        assert.isTrue(view.collection.reset.called);
+        assert.isTrue(view.collection.reset.calledWithExactly([]));
       });
 
       it("suggests its loaded", function() {
-        expect(view.loaded).toBe(true);
+        assert.isTrue(view.loaded);
       });
 
       it("changes status text to empty", function() {
-        expect(view.$empty.html()).toBe(view.emptyMessage);
+        assert.equal(view.$empty.html(), view.emptyMessage);
       });
     });
 
@@ -116,21 +116,21 @@ describe("OrderedElementsView", function() {
             id: 'foo'
         });
         group1 = make_group({id: 1, score: 3});
-        view.collection.reset = sinon.spy();
+        view.collection.reset = this.sinon.spy();
         view.reset();
       });
 
       it("calls collection.reset with no value", function() {
-        expect(view.collection.reset.called).toBe(true);
-        expect(view.collection.reset.calledWithExactly()).toBe(true);
+        assert.isTrue(view.collection.reset.called);
+        assert.isTrue(view.collection.reset.calledWithExactly());
       });
 
       it("suggests its not loaded", function() {
-        expect(view.loaded).toBe(false);
+        assert.isFalse(view.loaded);
       });
 
       it("changes status text to loading", function() {
-        expect(view.$empty.html()).toBe(view.loadingMessage);
+        assert.equal(view.$empty.html(), view.loadingMessage);
       });
     });
   });
@@ -140,7 +140,7 @@ describe("OrderedElementsView", function() {
       view = new app.OrderedElementsView({
           id: 'foo'
       });
-      view.addMember = sinon.spy();
+      view.addMember = this.sinon.spy();
     });
 
     it("calls addMember for each item", function() {
@@ -148,9 +148,9 @@ describe("OrderedElementsView", function() {
       group2 = make_group({id: 2, score: 5});
 
       view.extend([group1, group2]);
-      expect(view.addMember.callCount).toBe(2);
-      expect(view.addMember.calledWithExactly(group1)).toBe(true);
-      expect(view.addMember.calledWithExactly(group2)).toBe(true);
+      assert.equal(view.addMember.callCount, 2);
+      assert.isTrue(view.addMember.calledWithExactly(group1));
+      assert.isTrue(view.addMember.calledWithExactly(group2));
     });
   });
 
@@ -165,7 +165,7 @@ describe("OrderedElementsView", function() {
     it("adds to collection", function() {
       group = make_group();
       view.addMember(group);
-      expect(view.collection.models[0].get('id')).toBe(group.id);
+      assert.strictEqual(view.collection.models[0].get('id'), group.id);
     });
 
     it("replaces in collection", function() {
@@ -173,7 +173,7 @@ describe("OrderedElementsView", function() {
       view.addMember(group);
       view.addMember(group);
       view.addMember(group);
-      expect(view.collection.length).toBe(1);
+      assert.strictEqual(view.collection.length, 1);
     });
 
     it("truncated to max items", function(){
@@ -187,15 +187,15 @@ describe("OrderedElementsView", function() {
       view.addMember(group3);
       view.addMember(group4);
 
-      expect(view.collection.length).toBe(3);
+      assert.strictEqual(view.collection.length, 3);
     });
 
     it("sorts members by score after insert", function(){
       view.addMember(make_group({id: 1, score: 3}));
       view.addMember(make_group({id: 2, score: 5}));
 
-      expect(view.collection.models[0].get('id')).toBe(2);
-      expect(view.collection.models[1].get('id')).toBe(1);
+      assert.strictEqual(view.collection.models[0].get('id'), 2);
+      assert.strictEqual(view.collection.models[1].get('id'), 1);
     });
 
     it("doesnt move members that didnt re-rank", function(){
@@ -205,9 +205,9 @@ describe("OrderedElementsView", function() {
       // change the score, but keep it in the same rank
       view.addMember(make_group({id: 2, score: 50}));
 
-      expect(view.collection.models[0].get('id')).toBe(3);
-      expect(view.collection.models[1].get('id')).toBe(2);
-      expect(view.collection.models[2].get('id')).toBe(1);
+      assert.strictEqual(view.collection.models[0].get('id'), 3);
+      assert.strictEqual(view.collection.models[1].get('id'), 2);
+      assert.strictEqual(view.collection.models[2].get('id'), 1);
     });
 
     it("resorts members when they change", function(){
@@ -217,9 +217,9 @@ describe("OrderedElementsView", function() {
       // change the score so it should be at the top
       view.addMember(make_group({id: 1, score: 1000}));
 
-      expect(view.collection.models[0].get('id')).toBe(1);
-      expect(view.collection.models[1].get('id')).toBe(3);
-      expect(view.collection.models[2].get('id')).toBe(2);
+      assert.strictEqual(view.collection.models[0].get('id'), 1);
+      assert.strictEqual(view.collection.models[1].get('id'), 3);
+      assert.strictEqual(view.collection.models[2].get('id'), 2);
     });
 
     it("correctly handles truncating lowest score values", function(){
@@ -230,10 +230,10 @@ describe("OrderedElementsView", function() {
       view.addMember(make_group({id: 5, score: 51}));
       view.addMember(make_group({id: 2, score: 50}));
 
-      expect(view.collection.length).toBe(3);
-      expect(view.collection.models[0].get('id')).toBe(3);
-      expect(view.collection.models[1].get('id')).toBe(4);
-      expect(view.collection.models[2].get('id')).toBe(5);
+      assert.strictEqual(view.collection.length, 3);
+      assert.strictEqual(view.collection.models[0].get('id'), 3);
+      assert.strictEqual(view.collection.models[1].get('id'), 4);
+      assert.strictEqual(view.collection.models[2].get('id'), 5);
     });
 
   });
@@ -255,22 +255,22 @@ describe("OrderedElementsView", function() {
     });
 
     it("pushes highest scored elements to the top on change", function(){
-      group3.set('score', 100);
+      group3.score = 100;
       view.addMember(group3);
       group4 = make_group({id: 4, score: 500});
       view.addMember(group4);
-      expect(view.$parent.find('li').length).toBe(view.collection.models.length);
+      assert.strictEqual(view.$parent.find('li').length, view.collection.models.length);
     });
 
 
     it("has the correct number of elements", function(){
-      expect(view.$parent.find('li').length).toBe(view.collection.models.length);
+      assert.strictEqual(view.$parent.find('li').length, view.collection.models.length);
     });
 
     it("has list elements sorted correctly", function(){
       view.$parent.find('li').each(function(_, el){
-        expect(this.id).toBe('dummy' + view.collection.models[_].id);
+        assert.strictEqual(this.id, 'dummy' + view.collection.models[_].id);
       });
     });
   });
-});
\ No newline at end of file
+});
diff --git a/tests/js/spec/floatFormat.js b/tests/js/spec/floatFormat.js
index e301d19dae..0aac5ed857 100644
--- a/tests/js/spec/floatFormat.js
+++ b/tests/js/spec/floatFormat.js
@@ -1,9 +1,9 @@
 describe("floatFormat", function() {
   it("does format two decimal places", function() {
-    expect(app.utils.floatFormat(1.134, 2)).toBe(1.13);
+    assert.strictEqual(app.utils.floatFormat(1.134, 2), 1.13);
   });
 
   it("does format one decimal places", function() {
-    expect(app.utils.floatFormat(1.134, 1)).toBe(1.1);
+    assert.strictEqual(app.utils.floatFormat(1.134, 1), 1.1);
   });
-});
\ No newline at end of file
+});
diff --git a/tests/js/spec/formatNumber.js b/tests/js/spec/formatNumber.js
index 6ba0189a09..53d7a47e7b 100644
--- a/tests/js/spec/formatNumber.js
+++ b/tests/js/spec/formatNumber.js
@@ -1,22 +1,22 @@
 describe("formatNumber", function() {
   it("handles billions", function() {
-    expect(app.utils.formatNumber(1134134134)).toBe('1.1b');
+    assert.strictEqual(app.utils.formatNumber(1134134134), '1.1b');
   });
 
   it("handles millions", function() {
-    expect(app.utils.formatNumber(1234134)).toBe('1.2m');
+    assert.strictEqual(app.utils.formatNumber(1234134), '1.2m');
   });
 
   it("handles thousands", function() {
-    expect(app.utils.formatNumber(5334)).toBe('5.3k');
+    assert.strictEqual(app.utils.formatNumber(5334), '5.3k');
   });
 
   it("removes decimals on large numbers", function() {
-    expect(app.utils.formatNumber(533334)).toBe('533k');
-    expect(app.utils.formatNumber(53334)).toBe('53k');
+    assert.strictEqual(app.utils.formatNumber(533334), '533k');
+    assert.strictEqual(app.utils.formatNumber(53334), '53k');
   });
 
   it("doesnt format small numbers", function() {
-    expect(app.utils.formatNumber(15)).toBe('15');
+    assert.strictEqual(app.utils.formatNumber(15), '15');
   });
 });

commit fc261490c8acac64cceea2062439056f798a0a24
Author: David Cramer <dcramer@gmail.com>
Date:   Thu Apr 24 23:32:56 2014 -0700

    Move TSDB backend into proper abstraction

diff --git a/src/sentry/tsdb/base.py b/src/sentry/tsdb/base.py
new file mode 100644
index 0000000000..0f675902ff
--- /dev/null
+++ b/src/sentry/tsdb/base.py
@@ -0,0 +1,88 @@
+"""
+sentry.tsdb.base
+~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from enum import Enum
+
+ONE_MINUTE = 60
+ONE_HOUR = ONE_MINUTE * 60
+ONE_DAY = ONE_HOUR * 24
+
+
+ROLLUPS = (
+    # time in seconds, samples to keep
+    # (10, 30),  # 5 minutes at 10 seconds
+    # (ONE_MINUTE, 120),  # 2 hours at 1 minute
+    (ONE_HOUR, 24),  # 1 days at 1 hour
+    (ONE_DAY, 30),  # 30 days at 1 day
+)
+
+
+class TSDBModel(Enum):
+    project = 1
+    project_tag_key = 2
+    project_tag_value = 3
+    group = 4
+    group_tag_key = 5
+    group_tag_value = 6
+
+
+class BaseTSDB(object):
+    def __init__(self, rollups=ROLLUPS):
+        self.rollups = rollups
+
+    def normalize_to_epoch(self, timestamp, seconds):
+        """
+        Given a ``timestamp`` (datetime object) normalize the datetime object
+        ``timestamp`` to an epoch timestmap (integer).
+
+        i.e. if the rollup is minutes, the resulting timestamp would have
+        the seconds and microseconds rounded down.
+        """
+        epoch = int(timestamp.strftime('%s'))
+        return epoch - (epoch % seconds)
+
+    def get_optimal_rollup(self, start_timestamp, end_timestamp):
+        """
+        Identify the lowest granularity rollup available within the given time
+        range.
+        """
+        num_seconds = int(end_timestamp.strftime('%s')) - int(start_timestamp.strftime('%s'))
+
+        # calculate the highest rollup within time range
+        for rollup, samples in self.rollups:
+            if rollup * samples >= num_seconds:
+                return rollup
+        return self.rollups[-1][0]
+
+    def incr(self, model, key, timestamp=None, count=1):
+        """
+        Increment project ID=1:
+
+        >>> incr(TimeSeriesModel.project, 1)
+        """
+        raise NotImplementedError
+
+    def incr_multi(self, items, timestamp=None, count=1):
+        """
+        Increment project ID=1 and group ID=5:
+
+        >>> incr_multi([(TimeSeriesModel.project, 1), (TimeSeriesModel.group, 5)])
+        """
+        for model, key in items:
+            self.incr(model, key, timestamp, count)
+
+    def get_range(self, model, keys, start, end, rollup=None):
+        """
+        To get a range of data for group ID=[1, 2, 3]:
+
+        >>> now = timezone.now()
+        >>> get_keys(TimeSeriesModel.group, [1, 2, 3],
+        >>>          start=now - timedelta(days=1),
+        >>>          end=now)
+        """
+        raise NotImplementedError
diff --git a/src/sentry/tsdb/backend.py b/src/sentry/tsdb/redis.py
similarity index 62%
rename from src/sentry/tsdb/backend.py
rename to src/sentry/tsdb/redis.py
index a231655799..033538fef7 100644
--- a/src/sentry/tsdb/backend.py
+++ b/src/sentry/tsdb/redis.py
@@ -1,41 +1,21 @@
 """
-sentry.tsdb.backend
-~~~~~~~~~~~~~~~~~~~
+sentry.tsdb.redis
+~~~~~~~~~~~~~~~~~
 
 :copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
 :license: BSD, see LICENSE for more details.
 """
+from __future__ import absolute_import
 
 from collections import defaultdict
 from django.conf import settings
 from django.utils import timezone
-from enum import Enum
 from nydus.db import create_cluster
 
-ONE_MINUTE = 60
-ONE_HOUR = ONE_MINUTE * 60
-ONE_DAY = ONE_HOUR * 24
+from sentry.tsdb.base import BaseTSDB
 
 
-ROLLUPS = (
-    # time in seconds, samples to keep
-    # (10, 30),  # 5 minutes at 10 seconds
-    # (ONE_MINUTE, 120),  # 2 hours at 1 minute
-    (ONE_HOUR, 24),  # 1 days at 1 hour
-    (ONE_DAY, 30),  # 30 days at 1 day
-)
-
-
-class TSDBModel(Enum):
-    project = 1
-    project_tag_key = 2
-    project_tag_value = 3
-    group = 4
-    group_tag_key = 5
-    group_tag_value = 6
-
-
-class RedisTSDB(object):
+class RedisTSDB(BaseTSDB):
     """
     A time series storage implementation which maps types + normalized epochs
     to hash buckets.
@@ -58,42 +38,23 @@ class RedisTSDB(object):
         }
     }
     """
-    def __init__(self, rollups=ROLLUPS, **options):
-        if not options:
-            # inherit default options from REDIS_OPTIONS
-            options = settings.SENTRY_REDIS_OPTIONS
+    def __init__(self, hosts=None, router=None, prefix='ts:', **kwargs):
+        # inherit default options from REDIS_OPTIONS
+        defaults = settings.SENTRY_REDIS_OPTIONS
+
+        if hosts is None:
+            hosts = defaults.get('hosts', {0: {}})
+
+        if router is None:
+            router = defaults.get('router', 'nydus.db.routers.keyvalue.PartitionRouter')
 
-        options.setdefault('hosts', {
-            0: {},
-        })
-        options.setdefault('router', 'nydus.db.routers.keyvalue.PartitionRouter')
         self.conn = create_cluster({
             'engine': 'nydus.db.backends.redis.Redis',
-            'router': options['router'],
-            'hosts': options['hosts'],
+            'router': router,
+            'hosts': hosts,
         })
-        self.rollups = rollups
-        self.prefix = options.get('prefix', 'ts:')
-
-    def normalize_to_epoch(self, timestamp, seconds):
-        """
-        Given a ``timestamp`` (datetime object) normalize the datetime object
-        ``timestamp`` to an epoch timestmap (integer).
-
-        i.e. if the rollup is minutes, the resulting timestamp would have
-        the seconds and microseconds rounded down.
-        """
-        epoch = int(timestamp.strftime('%s'))
-        return epoch - (epoch % seconds)
-
-    def get_optimal_rollup(self, start_timestamp, end_timestamp):
-        num_seconds = int(end_timestamp.strftime('%s')) - int(start_timestamp.strftime('%s'))
-
-        # calculate the highest rollup within time range
-        for rollup, samples in self.rollups:
-            if rollup * samples >= num_seconds:
-                return rollup
-        return self.rollups[-1][0]
+        self.prefix = prefix
+        super(RedisTSDB, self).__init__(**kwargs)
 
     def make_key(self, model, epoch):
         return '{0}:{1}:{2}'.format(self.prefix, model.value, epoch)
diff --git a/tests/sentry/tsdb/test_backend.py b/tests/sentry/tsdb/test_redis.py
similarity index 94%
rename from tests/sentry/tsdb/test_backend.py
rename to tests/sentry/tsdb/test_redis.py
index 68f2e8582a..e6a9764e20 100644
--- a/tests/sentry/tsdb/test_backend.py
+++ b/tests/sentry/tsdb/test_redis.py
@@ -3,9 +3,8 @@ import pytz
 from datetime import datetime, timedelta
 
 from sentry.testutils import TestCase
-from sentry.tsdb.backend import (
-    RedisTSDB, TSDBModel, ONE_MINUTE, ONE_HOUR, ONE_DAY
-)
+from sentry.tsdb.base import TSDBModel, ONE_MINUTE, ONE_HOUR, ONE_DAY
+from sentry.tsdb.redis import RedisTSDB
 
 
 class RedisTSDBTest(TestCase):

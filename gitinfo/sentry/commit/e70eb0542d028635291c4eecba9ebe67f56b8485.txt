commit e70eb0542d028635291c4eecba9ebe67f56b8485
Author: Jay Soffian <jaysoffian@gmail.com>
Date:   Fri Aug 22 22:09:57 2014 -0400

    Implement is_regression plugin check
    
    Add a plugin call, "is_regression", called on new events when
    the group's status is STATUS_RESOLVED. The call may return
    True if this event is a regression, False if it is not, None
    to defer to other plugins.
    
    For example, a plugin may wish to examine a tag's values on a
    group and only consider the event a regression if it is
    contributing a new tag value.

diff --git a/src/sentry/event_manager.py b/src/sentry/event_manager.py
index 2a2b22aa48..9766bef0f2 100644
--- a/src/sentry/event_manager.py
+++ b/src/sentry/event_manager.py
@@ -84,6 +84,15 @@ else:
         return True
 
 
+def plugin_is_regression(group, event):
+    project = event.project
+    for plugin in plugins.for_project(project):
+        result = safe_execute(plugin.is_regression, group, event)
+        if result is not None:
+            return result
+    return True
+
+
 class ScoreClause(object):
     def __init__(self, group):
         self.group = group
@@ -464,7 +473,8 @@ class EventManager(object):
         if group.culprit != data['culprit']:
             extra['culprit'] = data['culprit']
 
-        if group.status == STATUS_RESOLVED or group.is_over_resolve_age():
+        is_regression = False
+        if group.is_resolved() and plugin_is_regression(group, event):
             # Making things atomic
             is_regression = bool(Group.objects.filter(
                 id=group.id,
@@ -477,8 +487,6 @@ class EventManager(object):
 
             group.active_at = date
             group.status = STATUS_UNRESOLVED
-        else:
-            is_regression = False
 
         group.last_seen = extra['last_seen']
 
diff --git a/src/sentry/plugins/base.py b/src/sentry/plugins/base.py
index 4c71d6d2f4..80f8797f51 100644
--- a/src/sentry/plugins/base.py
+++ b/src/sentry/plugins/base.py
@@ -477,6 +477,22 @@ class IPlugin(local):
         >>>     print alert.get_absolute_url()
         """
 
+    def is_regression(self, group, event, **kwargs):
+        """
+        Called on new events when the group's status is STATUS_RESOLVED.
+        Return True if this event is a regression, False if it is not,
+        None to defer to other plugins.
+
+        :param group: an instance of ``Group``
+        :param event: an instance of ``Event``
+
+        >>> def is_regression(self, group, event, **kwargs):
+        >>>     # regression if 'version' tag has a value we haven't seen before
+        >>>     seen_versions = set(t[0] for t in group.get_unique_tags("version"))
+        >>>     event_version = dict(event.get_tags()).get("version")
+        >>>     return event_version not in seen_versions
+        """
+
     def post_process(self, group, event, is_new, is_sample, **kwargs):
         """
         Post processes an event after it has been saved.
diff --git a/tests/sentry/test_event_manager.py b/tests/sentry/test_event_manager.py
index ff9436b1ab..e2c712e4ba 100644
--- a/tests/sentry/test_event_manager.py
+++ b/tests/sentry/test_event_manager.py
@@ -8,7 +8,7 @@ from mock import patch
 
 from django.conf import settings
 
-from sentry.constants import MAX_CULPRIT_LENGTH
+from sentry.constants import MAX_CULPRIT_LENGTH, STATUS_RESOLVED
 from sentry.event_manager import EventManager, get_hashes_for_event
 from sentry.models import Event, Group, EventMapping
 from sentry.testutils import TestCase
@@ -103,6 +103,58 @@ class EventManagerTest(TestCase):
         assert group.last_seen.replace(microsecond=0) == event.datetime.replace(microsecond=0)
         assert group.message == event2.message
 
+    def test_unresolves_group(self):
+        # N.B. EventManager won't unresolve the group unless the event2 has a
+        # later timestamp than event1. MySQL doesn't support microseconds.
+        manager = EventManager(self.make_event(
+            event_id='a' * 32, checksum='a' * 32,
+            timestamp=1403007314,
+        ))
+        event = manager.save(1)
+        print(event)
+
+        group = Group.objects.get(id=event.group_id)
+        group.status = STATUS_RESOLVED
+        group.save()
+        assert group.is_resolved()
+
+        manager = EventManager(self.make_event(
+            event_id='b' * 32, checksum='a' * 32,
+            timestamp=1403007315,
+        ))
+        event2 = manager.save(1)
+        assert event.group_id == event2.group_id
+
+        group = Group.objects.get(id=group.id)
+        assert not group.is_resolved()
+
+    @patch('sentry.event_manager.plugin_is_regression')
+    def test_does_not_unresolve_group(self, plugin_is_regression):
+        # N.B. EventManager won't unresolve the group unless the event2 has a
+        # later timestamp than event1. MySQL doesn't support microseconds.
+        plugin_is_regression.return_value = False
+
+        manager = EventManager(self.make_event(
+            event_id='a' * 32, checksum='a' * 32,
+            timestamp=1403007314,
+        ))
+        event = manager.save(1)
+
+        group = Group.objects.get(id=event.group_id)
+        group.status = STATUS_RESOLVED
+        group.save()
+        assert group.is_resolved()
+
+        manager = EventManager(self.make_event(
+            event_id='b' * 32, checksum='a' * 32,
+            timestamp=1403007315,
+        ))
+        event2 = manager.save(1)
+        assert event.group_id == event2.group_id
+
+        group = Group.objects.get(id=group.id)
+        assert group.is_resolved()
+
     def test_long_culprit(self):
         manager = EventManager(self.make_event(
             culprit='x' * (MAX_CULPRIT_LENGTH + 1),

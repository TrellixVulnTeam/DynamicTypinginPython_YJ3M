commit 83434271f3e899e27eb81920b37918a7d9b90503
Author: Mark Story <mark@sentry.io>
Date:   Mon Sep 10 10:05:48 2018 -0400

    feat(docs) Add markdown templates and cli flag
    
    Add separate markdown templates and a new CLI flag to generate either
    markdown, json or both output formats.
    
    Use docutils and text munging to parse parameter annotations similar to
    how sphinx did it. Unfortunately without using sphinx we can't easily
    access the full parse tree of the parameter annotations.

diff --git a/api-docs/generator.py b/api-docs/generator.py
index eb3d4e7fa1..5dfbc20a45 100644
--- a/api-docs/generator.py
+++ b/api-docs/generator.py
@@ -24,8 +24,11 @@ from django.conf import settings
 # Fair game from here
 from django.core.management import call_command
 
-from sentry.utils.apidocs import Runner, MockUtils, iter_scenarios, \
+from sentry.utils.apidocs import (
+    Runner, MockUtils, iter_scenarios,
     iter_endpoints, get_sections
+)
+from sentry.web.helpers import render_to_string
 
 
 OUTPUT_PATH = os.path.join(HERE, 'cache')
@@ -233,12 +236,22 @@ def output_markdown(sections, scenarios, section_mapping):
         for endpoint in section_mapping.get(section, []):
             i += 1
             path = u"{}/{}.md".format(section, endpoint['endpoint_name'])
-
-            endpoint['sidebar_order'] = i
-            endpoint['example'] = format_example(endpoint, scenarios)
-            endpoint['text'] = "\n".join(endpoint['text'])
-
-            dump_markdown(path, endpoint)
+            auth = ''
+            if len(endpoint['params'].get('auth', [])):
+                auth = endpoint['params']['auth'][0]['description']
+            payload = dict(
+                title=title,
+                sidebar_order=i,
+                description=''.join(endpoint['text']),
+                method=endpoint['method'],
+                query_parameters=endpoint['params'].get('query'),
+                path_parameters=endpoint['params'].get('path'),
+                parameters=endpoint['params'].get('params'),
+                authentication=auth,
+                example_request=format_request(endpoint, scenarios),
+                example_response=format_response(endpoint, scenarios)
+            )
+            dump_markdown(path, payload)
 
             links.append({'title': endpoint['title'], 'path': path})
         dump_index_markdown(section, title, links)
@@ -262,19 +275,10 @@ def dump_index_markdown(section, title, links):
     except OSError:
         pass
     with open(path, 'w') as f:
-        document = """
----
-title: {title}
----
-
-{links}
-"""
-        link_text = '\n'.join([
-            u'- [{title}]({{%- link _documentation/api/{path} -%}})'.format(**item)
-            for item in links
-        ])
-        document = document.format(title=title, links=link_text)
-        f.write(document)
+        contents = render_to_string(
+            'sentry/apidocs/index.md',
+            dict(title=title, links=links))
+        f.write(contents)
 
 
 def dump_markdown(path, data):
@@ -284,87 +288,68 @@ def dump_markdown(path, data):
     except OSError:
         pass
     with open(path, 'w') as f:
-        document = """
+        template = u"""---
+{}
 ---
-title: {title}
-sidebar_order: {sidebar_order}
----
-
-{method} {path}
-
-: {text}
-
-## Example
-
-{example}
 """
-        document = document.format(**data)
-        f.write(document)
+        contents = template.format(json.dumps(data, sort_keys=True, indent=2))
+        f.write(contents)
 
 
-def dump_markdown_index(path, data):
-    path = os.path.join(OUTPUT_PATH, path)
-    try:
-        os.makedirs(os.path.dirname(path))
-    except OSError:
-        pass
-    with open(path, 'w') as f:
-        document = """
----
-title: %(title)s
----
-
-%(links)s
-"""
-        document = document.format(data)
-        f.write(document)
+def find_first_scenario(endpoint, scenario_map):
+    for scene in endpoint['scenarios']:
+        if scene not in scenario_map:
+            continue
+        try:
+            return scenario_map[scene]['requests'][0]
+        except IndexError:
+            return None
+    return None
 
 
-def format_headers(headers):
-    if not headers:
+def format_request(endpoint, scenario_map):
+    scene = find_first_scenario(endpoint, scenario_map)
+    if not scene:
         return ''
-    headers = [
-        u"{}:{}".format(key, value)
-        for key, value in headers.items()
+    request = scene['request']
+    lines = [
+        u"{} {} HTTP/1.1".format(request['method'], request['path']),
+        'Host: sentry.io',
+        'Authorization: Bearer {base64-encoded-key-here}',
     ]
-    return '\n'.join(headers)
+    lines.extend(format_headers(request['headers']))
+    if request['data']:
+        lines.append('')
+        lines.append(json.dumps(request['data'],
+                                sort_keys=True,
+                                indent=2))
+    return "\n".join(lines)
+
+
+def format_response(endpoint, scenario_map):
+    scene = find_first_scenario(endpoint, scenario_map)
+    if not scene:
+        return ''
+    response = scene['response']
+    lines = [
+        u"HTTP/1.1 {} {}".format(response['status'], response['reason']),
+    ]
+    lines.extend(format_headers(response['headers']))
+    if response['data']:
+        lines.append('')
+        lines.append(json.dumps(response['data'],
+                                sort_keys=True,
+                                indent=2))
+    return "\n".join(lines)
 
 
-def format_example(endpoint, scenario_map):
-    example = u''
-    for scene in endpoint['scenarios']:
-        if scene not in scenario_map:
-            continue
-        scene_data = scenario_map[scene]
-        for scenario in scene_data['requests']:
-            template_data = {
-                'status': scenario['response']['status'],
-                'reason': scenario['response']['reason'],
-                'method': scenario['request']['method'],
-                'path': scenario['request']['path'],
-                'request_headers': format_headers(scenario['request']['headers']),
-                'request_data': json.dumps(scenario['request']['data'], sort_keys=True, indent=2),
-                'response_headers': format_headers(scenario['response']['headers']),
-                'response_data': json.dumps(scenario['response']['data'], sort_keys=True, indent=2),
-            }
-            example += """
-```http
-{method} {path} HTTP/1.1
-Authorization: Bearer {{base64-encoded-key-here}}
-{request_headers}
-Host: sentry.io
-
-{request_data}
-```
-
-```http
-HTTP/1.1 {status} {reason}
-{response_headers}
-
-{response_data}
-```
-""".format(**template_data)
-    return example
+def format_headers(headers):
+    """Format headers into a list."""
+    return [
+        u'{}: {}'.format(key, value)
+        for key, value
+        in headers.items()
+    ]
 
 
 if __name__ == '__main__':
diff --git a/src/sentry/templates/sentry/apidocs/index.md b/src/sentry/templates/sentry/apidocs/index.md
new file mode 100644
index 0000000000..ea1fb5f79a
--- /dev/null
+++ b/src/sentry/templates/sentry/apidocs/index.md
@@ -0,0 +1,6 @@
+---
+title: {{ title }}
+---
+
+{% for link in links %}
+- [{{ link.title }}]({% templatetag openblock %}- link _documentation/api/{{ link.path }} -{% templatetag closeblock %}){% endfor %}
diff --git a/src/sentry/utils/apidocs.py b/src/sentry/utils/apidocs.py
index 9ae84937d8..fc5061e4e1 100644
--- a/src/sentry/utils/apidocs.py
+++ b/src/sentry/utils/apidocs.py
@@ -8,10 +8,12 @@ import inspect
 import requests
 import mimetypes
 
+from collections import defaultdict
 from contextlib import contextmanager
 from datetime import datetime, timedelta
 from django.conf import settings
 from django.db import transaction
+from docutils.core import publish_doctree
 from pytz import utc
 from random import randint
 from six import StringIO
@@ -79,10 +81,12 @@ def get_endpoint_path(internal_endpoint):
     return '%s.%s' % (internal_endpoint.__module__, internal_endpoint.__name__, )
 
 
-def extract_title_and_text(doc):
+def parse_doc_string(doc):
     title = None
+    current_param = ''
+    param_lines = []
+    lines = []
     iterable = iter((doc or u'').splitlines())
-    clean_end = False
 
     for line in iterable:
         line = line.strip()
@@ -90,21 +94,75 @@ def extract_title_and_text(doc):
             if not line:
                 continue
             title = line
-        elif line[0] * len(line) == line:
-            clean_end = True
-            break
-        else:
-            break
-
-    lines = []
-    if clean_end:
-        for line in iterable:
-            if line.strip():
-                lines.append(line)
-                break
-    lines.extend(iterable)
+        elif line and line[0] * len(line) == line:
+            # is an RST underline
+            continue
+        elif line and line.startswith(':'):
+            # Is a new parameter or other annotation
+            if current_param:
+                param_lines.append(current_param)
+            current_param = line
+        elif current_param:
+            # Adding to an existing parameter annotation
+            current_param = current_param + ' ' + line.strip()
+        elif line:
+            lines.append(line)
+
+    if current_param:
+        param_lines.append(current_param)
+
+    return title, lines, parse_params(param_lines)
+
+
+def get_node_text(nodes):
+    """Recursively read text from a node tree."""
+    text = []
+    for node in nodes:
+        if node.nodeType == node.TEXT_NODE:
+            text.append(node.data)
+        if node.nodeType == node.ELEMENT_NODE:
+            text.append(get_node_text(node.childNodes))
+    return ''.join(text)
+
+
+def parse_params(params):
+    """
+    Parse parameter annotations.
 
-    return title, lines
+    docutils doesn't give us much to work with, but
+    we can get a DomDocument and traverse that for path parameters
+    and query parameters, and layer on some text munging to get
+    enough data to make the output we need.
+    """
+    parsed = defaultdict(list)
+    param_tree = publish_doctree('\n'.join(params)).asdom()
+    field_names = param_tree.getElementsByTagName('field_name')
+    field_values = param_tree.getElementsByTagName('field_body')
+
+    for i, field in enumerate(field_names):
+        name = get_node_text(field.childNodes)
+        value = ''
+        field_value = field_values.item(i)
+        if field_value:
+            value = get_node_text(field_value.childNodes)
+        field_type = 'param'
+        if name.startswith('pparam'):
+            field_type = 'path'
+            name = name[7:]
+        elif name.startswith('qparam'):
+            field_type = 'query'
+            name = name[7:]
+        elif name.startswith('auth'):
+            field_type = 'auth'
+            name = ''
+
+        # Split out the parameter type
+        param_type = ''
+        if ' ' in name:
+            param_type, name = name.split(' ', 1)
+        parsed[field_type].append(dict(name=name, type=param_type,
+                                       description=value))
+    return parsed
 
 
 def camelcase_to_dashes(string):
@@ -138,12 +196,13 @@ def extract_endpoint_info(pattern, internal_endpoint):
         if endpoint_name.endswith('Endpoint'):
             endpoint_name = endpoint_name[:-8]
         endpoint_name = camelcase_to_dashes(endpoint_name)
-        title, text = extract_title_and_text(doc)
+        title, text, params = parse_doc_string(doc)
         yield dict(
             path=API_PREFIX + path.lstrip('/'),
             method=method_name,
             title=title,
             text=text,
+            params=params,
             scenarios=getattr(method, 'api_scenarios', None) or [],
             section=section.name.lower(),
             internal_path='%s:%s' % (get_endpoint_path(internal_endpoint), method.__name__),
@@ -495,10 +554,11 @@ class Runner(object):
         """Convert the current scenario into a dict
         """
         doc = extract_documentation(self.func)
-        title, text = extract_title_and_text(doc)
+        title, text, params = parse_doc_string(doc)
         return {
             'ident': self.ident,
             'requests': self.requests,
             'title': title,
             'text': text,
+            'params': params,
         }

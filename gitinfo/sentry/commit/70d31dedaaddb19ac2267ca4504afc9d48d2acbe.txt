commit 70d31dedaaddb19ac2267ca4504afc9d48d2acbe
Author: ted kaemming <ted@kaemming.com>
Date:   Thu Apr 12 14:03:34 2018 -0700

    ref(services): Add timing to asynchronous method execution (#8017)

diff --git a/src/sentry/utils/concurrent.py b/src/sentry/utils/concurrent.py
index cff2da9ae1..dff1edce39 100644
--- a/src/sentry/utils/concurrent.py
+++ b/src/sentry/utils/concurrent.py
@@ -4,11 +4,80 @@ import logging
 import threading
 from Queue import Full, PriorityQueue
 from concurrent.futures import Future
+from concurrent.futures._base import RUNNING, FINISHED
+from time import time
 
 
 logger = logging.getLogger(__name__)
 
 
+class TimedFuture(Future):
+    def __init__(self, *args, **kwargs):
+        self.__timing = [None, None]  # [started, finished/cancelled]
+        super(TimedFuture, self).__init__(*args, **kwargs)
+
+    def get_timing(self):
+        """\
+        Return the timing data for this future in the form ``(started, finished)``.
+
+        The ``started`` value can be either a timestamp or ``None`` (if the
+        future has not been started.) The ``finished`` value can also be either
+        a timestamp or ``None`` (if the future has not been either completed or
+        cancelled.)
+
+        There are some idiosyncracies with the way the timings are recorded:
+
+        - The ``started`` value will generally not be ``None`` if the
+          ``finished`` value is also not ``None``. However, for a future that
+          was marked as cancelled and has yet to be attempted to be executed,
+          the ``finished`` value may be set while the ``started`` value is
+          ``None``.
+        - Similarly, the ``started`` value will generally be equal to or less
+          than the ``finished`` value (ignoring non-monotonic clock phenomena.)
+          However, for a future was is marked as cancelled prior to execution,
+          the ``finished`` time (when the future was cancelled) may be before
+          the ``started`` time (when the future was attempted to be executed.)
+        """
+        return tuple(self.__timing)
+
+    def set_running_or_notify_cancel(self, *args, **kwargs):
+        result = super(TimedFuture, self).set_running_or_notify_cancel(*args, **kwargs)
+        # This method can only be called once (the second invocation will raise
+        # a ``RuntimeError``) so if we've gotten this far we can be reasonably
+        # confident that the start time hasn't been set.
+        self.__timing[0] = time()
+        return result
+
+    def cancel(self, *args, **kwargs):
+        with self._condition:
+            # Futures can only be marked as cancelled if they are neither
+            # running or finished (we have to duplicate this check that is also
+            # performed in the superclass to ensure the timing is set before
+            # callbacks are invoked.) As long as the future is in the correct
+            # state, this call is guaranteed to succeed. This method can be
+            # called multiple times, but we only record the first time the
+            # future was cancelled.
+            if self._state not in [RUNNING, FINISHED] and self.__timing[1] is None:
+                self.__timing[1] = time()
+            return super(TimedFuture, self).cancel(*args, **kwargs)
+
+    def set_result(self, *args, **kwargs):
+        with self._condition:
+            # This method always overwrites the result, so we always overwrite
+            # the timing, even if another timing was already recorded.
+            self.__timing[1] = time()
+            return super(TimedFuture, self).set_result(*args, **kwargs)
+
+    def set_exception_info(self, *args, **kwargs):
+        # XXX: This makes the potentially unsafe assumption that
+        # ``set_exception`` will always continue to call this function.
+        with self._condition:
+            # This method always overwrites the result, so we always overwrite
+            # the timing, even if another timing was already recorded.
+            self.__timing[1] = time()
+            return super(TimedFuture, self).set_exception_info(*args, **kwargs)
+
+
 class ThreadedExecutor(object):
     """\
     This executor provides a method of executing callables in a threaded worker
@@ -59,7 +128,7 @@ class ThreadedExecutor(object):
 
     def submit(self, callable, priority=0, block=True, timeout=None):
         """\
-        Enqueue a task to be executed, returning a ``Future``.
+        Enqueue a task to be executed, returning a ``TimedFuture``.
 
         Tasks can be prioritized by providing a value for the ``priority``
         argument, which follows the same specification as the standard library
@@ -71,7 +140,7 @@ class ThreadedExecutor(object):
         if not self.__started:
             self.start()
 
-        future = Future()
+        future = TimedFuture()
         task = (priority, (callable, future))
         try:
             self.__queue.put(task, block=block, timeout=timeout)
diff --git a/tests/sentry/utils/test_concurrent.py b/tests/sentry/utils/test_concurrent.py
index aaecb315d4..485bda2a0f 100644
--- a/tests/sentry/utils/test_concurrent.py
+++ b/tests/sentry/utils/test_concurrent.py
@@ -3,10 +3,11 @@ from __future__ import absolute_import
 import mock
 import pytest
 from Queue import Full
-from concurrent.futures import Future
+from concurrent.futures import CancelledError, Future
+from contextlib import contextmanager
 from threading import Event
 
-from sentry.utils.concurrent import FutureSet, ThreadedExecutor
+from sentry.utils.concurrent import FutureSet, ThreadedExecutor, TimedFuture
 
 
 def test_future_set_callback_success():
@@ -73,8 +74,71 @@ def test_future_broken_callback():
     assert callback.call_args == mock.call(future_set)
 
 
+@contextmanager
+def timestamp(t):
+    with mock.patch('sentry.utils.concurrent.time') as mock_time:
+        mock_time.return_value = t
+        yield
+
+
+def test_timed_future_success():
+    future = TimedFuture()
+    assert future.get_timing() == (None, None)
+
+    with timestamp(1.0):
+        future.set_running_or_notify_cancel()
+        assert future.get_timing() == (1.0, None)
+
+    with timestamp(2.0):
+        future.set_result(None)
+        assert future.get_timing() == (1.0, 2.0)
+
+    with timestamp(3.0):
+        future.set_result(None)
+        assert future.get_timing() == (1.0, 3.0)
+
+
+def test_timed_future_error():
+    future = TimedFuture()
+    assert future.get_timing() == (None, None)
+
+    with timestamp(1.0):
+        future.set_running_or_notify_cancel()
+        assert future.get_timing() == (1.0, None)
+
+    with timestamp(2.0):
+        future.set_exception(None)
+        assert future.get_timing() == (1.0, 2.0)
+
+    with timestamp(3.0):
+        future.set_exception(None)
+        assert future.get_timing() == (1.0, 3.0)
+
+
+def test_timed_future_cancel():
+    future = TimedFuture()
+    assert future.get_timing() == (None, None)
+
+    with timestamp(1.0):
+        future.cancel()
+        assert future.get_timing() == (None, 1.0)
+
+    with timestamp(1.5):
+        future.cancel()
+        assert future.get_timing() == (None, 1.0)
+
+    with timestamp(2.0):
+        future.set_running_or_notify_cancel()
+        assert future.get_timing() == (2.0, 1.0)
+
+    with pytest.raises(RuntimeError):
+        future.set_running_or_notify_cancel()
+
+    assert future.get_timing() == (2.0, 1.0)
+
+
 def test_threaded_executor():
-    executor = ThreadedExecutor(worker_count=1, maxsize=2)
+    executor = ThreadedExecutor(worker_count=1, maxsize=3)
 
     def waiter(ready, waiting, result):
         ready.set()
@@ -103,6 +167,18 @@ def test_threaded_executor():
     )
     assert not low_priority_future.done(), 'future should not be done (indicative of a full queue)'
 
+    cancelled_future = executor.submit(
+        lambda: None,
+        block=True,
+        timeout=1,
+        priority=5,
+    )
+    assert not cancelled_future.done(), 'future should not be done (indicative of a full queue)'
+    assert cancelled_future.cancel(), 'future should be able to be cancelled'
+    assert cancelled_future.done(), 'future should be completed'
+    with pytest.raises(CancelledError):
+        cancelled_future.result()
+
     high_priority_ready = Event()
     high_priority_waiting = Event()
     high_priority_future = executor.submit(

commit 8bb4b94ec9be858cff8845ec20ed0e30ec15b9f3
Author: Evan Purkhiser <evanpurkhiser@gmail.com>
Date:   Thu Jul 11 14:13:03 2019 -0700

    feat(api): Add client-config API endpoint (#13922)
    
    This anonymous API endpoint is used to hydrate a standalone sentry
    frontend application.
    
    This is the same data that is exposed in the `__initialData` window
    variable when serving the app through django.

diff --git a/src/sentry/templatetags/sentry_react.py b/src/sentry/templatetags/sentry_react.py
index 152033b44c..612e8fec17 100644
--- a/src/sentry/templatetags/sentry_react.py
+++ b/src/sentry/templatetags/sentry_react.py
@@ -1,187 +1,15 @@
 from __future__ import absolute_import
 
-import sentry
-
 from django import template
-from django.core.cache import cache
-from django.conf import settings
-from django.contrib.auth.models import AnonymousUser
-from django.contrib.messages import get_messages
-from django.db.models import F
-from pkg_resources import parse_version
 
-from sentry import features, options
-from sentry.api.serializers.base import serialize
-from sentry.api.serializers.models.user import DetailedUserSerializer
-from sentry.auth.superuser import is_active_superuser
-from sentry.models import ProjectKey
-from sentry.utils import auth, json
-from sentry.utils.email import is_smtp_enabled
-from sentry.utils.assets import get_asset_url
-from sentry.utils.support import get_support_mail
+from sentry.utils import json
+from sentry.web.client_config import get_client_config
 
 register = template.Library()
 
 
-def _get_version_info():
-    current = sentry.VERSION
-
-    latest = options.get('sentry:latest_version') or current
-    upgrade_available = parse_version(latest) > parse_version(current)
-    build = sentry.__build__ or current
-
-    return {
-        'current': current,
-        'latest': latest,
-        'build': build,
-        'upgradeAvailable': upgrade_available,
-    }
-
-
-def _needs_upgrade():
-    version_configured = options.get('sentry:version-configured')
-    if not version_configured:
-        # If we were never previously upgraded (being a new install)
-        # we want to force an upgrade, even if the values are set.
-        return True
-
-    smtp_disabled = not is_smtp_enabled()
-
-    # Check all required options to see if they've been set
-    for key in options.filter(flag=options.FLAG_REQUIRED):
-        # ignore required flags which can be empty
-        if key.flags & options.FLAG_ALLOW_EMPTY:
-            continue
-        # Ignore mail.* keys if smtp is disabled
-        if smtp_disabled and key.name[:5] == 'mail.':
-            continue
-        if not options.isset(key.name):
-            return True
-
-    if version_configured != sentry.get_version():
-        # Everything looks good, but version changed, so let's bump it
-        options.set('sentry:version-configured', sentry.get_version())
-
-    return False
-
-
-def _get_statuspage():
-    id = settings.STATUS_PAGE_ID
-    if id is None:
-        return None
-    return {'id': id, 'api_host': settings.STATUS_PAGE_API_HOST}
-
-
-def _get_project_key(project_id):
-    try:
-        return ProjectKey.objects.filter(
-            project=project_id,
-            roles=F('roles').bitor(ProjectKey.roles.store),
-        )[0]
-    except IndexError:
-        return None
-
-
-def _get_public_dsn():
-    if settings.SENTRY_FRONTEND_DSN:
-        return settings.SENTRY_FRONTEND_DSN
-
-    project_id = settings.SENTRY_FRONTEND_PROJECT or settings.SENTRY_PROJECT
-    cache_key = 'dsn:%s' % (project_id, )
-
-    result = cache.get(cache_key)
-    if result is None:
-        key = _get_project_key(project_id)
-        if key:
-            result = key.dsn_public
-        else:
-            result = ''
-        cache.set(cache_key, result, 60)
-    return result
-
-
 @register.simple_tag(takes_context=True)
 def get_react_config(context):
-    if 'request' in context:
-        request = context['request']
-        user = getattr(request, 'user', None) or AnonymousUser()
-        messages = get_messages(request)
-        session = getattr(request, 'session', None)
-        is_superuser = is_active_superuser(request)
-        language_code = getattr(request, 'LANGUAGE_CODE', 'en')
-    else:
-        user = None
-        messages = []
-        is_superuser = False
-        language_code = 'en'
-
-    # User identity is used by the sentry SDK
-    if request and user:
-        user_identity = {'ip_address': request.META['REMOTE_ADDR']}
-        if user and user.is_authenticated():
-            user_identity.update({
-                'email': user.email,
-                'id': user.id,
-            })
-            if user.name:
-                user_identity['name'] = user.name
-    else:
-        user_identity = {}
-
-    enabled_features = []
-    if features.has('organizations:create', actor=user):
-        enabled_features.append('organizations:create')
-    if auth.has_user_registration():
-        enabled_features.append('auth:register')
-
-    version_info = _get_version_info()
-
-    needs_upgrade = False
-
-    if is_superuser:
-        needs_upgrade = _needs_upgrade()
+    context = get_client_config(context.get('request', None))
 
-    context = {
-        'singleOrganization': settings.SENTRY_SINGLE_ORGANIZATION,
-        'supportEmail': get_support_mail(),
-        'urlPrefix': options.get('system.url-prefix'),
-        'version': version_info,
-        'features': enabled_features,
-        'distPrefix': get_asset_url('sentry', 'dist/'),
-        'needsUpgrade': needs_upgrade,
-        'dsn': _get_public_dsn(),
-        'statuspage': _get_statuspage(),
-        'messages': [{
-            'message': msg.message,
-            'level': msg.tags,
-        } for msg in messages],
-        'isOnPremise': settings.SENTRY_ONPREMISE,
-        'invitesEnabled': settings.SENTRY_ENABLE_INVITES,
-        'gravatarBaseUrl': settings.SENTRY_GRAVATAR_BASE_URL,
-        'termsUrl': settings.TERMS_URL,
-        'privacyUrl': settings.PRIVACY_URL,
-        # Note `lastOrganization` should not be expected to update throughout frontend app lifecycle
-        # It should only be used on a fresh browser nav to a path where an
-        # organization is not in context
-        'lastOrganization': session['activeorg'] if session and 'activeorg' in session else None,
-        'languageCode': language_code,
-        'userIdentity': user_identity,
-        'csrfCookieName': settings.CSRF_COOKIE_NAME,
-        'sentryConfig': {
-            'dsn': _get_public_dsn(),
-            'release': version_info['build'],
-            'whitelistUrls': list(settings.ALLOWED_HOSTS),
-        },
-    }
-    if user and user.is_authenticated():
-        context.update({
-            'isAuthenticated': True,
-            'user': serialize(user, user, DetailedUserSerializer()),
-        })
-        context['user']['isSuperuser'] = is_superuser
-    else:
-        context.update({
-            'isAuthenticated': False,
-            'user': None,
-        })
     return json.dumps_htmlsafe(context)
diff --git a/src/sentry/web/api.py b/src/sentry/web/api.py
index 5418b8fccb..e41de83fdd 100644
--- a/src/sentry/web/api.py
+++ b/src/sentry/web/api.py
@@ -66,6 +66,7 @@ from sentry.utils.pubsub import QueuedPublisherService, KafkaPublisher
 from sentry.utils.safe import safe_execute
 from sentry.web.helpers import render_to_response
 from sentry.web.relay_config import get_full_relay_config
+from sentry.web.client_config import get_client_config
 
 logger = logging.getLogger('sentry')
 minidumps_logger = logging.getLogger('sentry.minidumps')
@@ -1002,6 +1003,12 @@ class StoreSchemaView(BaseView):
         return HttpResponse(json.dumps(schemas.EVENT_SCHEMA), content_type='application/json')
 
 
+class ClientConfigView(BaseView):
+    def get(self, request):
+        return HttpResponse(json.dumps(get_client_config(request)),
+                            content_type='application/json')
+
+
 class SecurityReportView(StoreView):
     auth_helper_cls = SecurityAuthHelper
     content_types = (
diff --git a/src/sentry/web/client_config.py b/src/sentry/web/client_config.py
new file mode 100644
index 0000000000..ec68577e09
--- /dev/null
+++ b/src/sentry/web/client_config.py
@@ -0,0 +1,184 @@
+from __future__ import absolute_import
+
+import sentry
+
+from django.core.cache import cache
+from django.conf import settings
+from django.contrib.auth.models import AnonymousUser
+from django.contrib.messages import get_messages
+from django.db.models import F
+from pkg_resources import parse_version
+
+from sentry import features, options
+from sentry.api.serializers.base import serialize
+from sentry.api.serializers.models.user import DetailedUserSerializer
+from sentry.auth.superuser import is_active_superuser
+from sentry.models import ProjectKey
+from sentry.utils import auth
+from sentry.utils.email import is_smtp_enabled
+from sentry.utils.assets import get_asset_url
+from sentry.utils.support import get_support_mail
+
+
+def _get_version_info():
+    current = sentry.VERSION
+
+    latest = options.get('sentry:latest_version') or current
+    upgrade_available = parse_version(latest) > parse_version(current)
+    build = sentry.__build__ or current
+
+    return {
+        'current': current,
+        'latest': latest,
+        'build': build,
+        'upgradeAvailable': upgrade_available,
+    }
+
+
+def _needs_upgrade():
+    version_configured = options.get('sentry:version-configured')
+    if not version_configured:
+        # If we were never previously upgraded (being a new install)
+        # we want to force an upgrade, even if the values are set.
+        return True
+
+    smtp_disabled = not is_smtp_enabled()
+
+    # Check all required options to see if they've been set
+    for key in options.filter(flag=options.FLAG_REQUIRED):
+        # ignore required flags which can be empty
+        if key.flags & options.FLAG_ALLOW_EMPTY:
+            continue
+        # Ignore mail.* keys if smtp is disabled
+        if smtp_disabled and key.name[:5] == 'mail.':
+            continue
+        if not options.isset(key.name):
+            return True
+
+    if version_configured != sentry.get_version():
+        # Everything looks good, but version changed, so let's bump it
+        options.set('sentry:version-configured', sentry.get_version())
+
+    return False
+
+
+def _get_statuspage():
+    id = settings.STATUS_PAGE_ID
+    if id is None:
+        return None
+    return {'id': id, 'api_host': settings.STATUS_PAGE_API_HOST}
+
+
+def _get_project_key(project_id):
+    try:
+        return ProjectKey.objects.filter(
+            project=project_id,
+            roles=F('roles').bitor(ProjectKey.roles.store),
+        )[0]
+    except IndexError:
+        return None
+
+
+def _get_public_dsn():
+    if settings.SENTRY_FRONTEND_DSN:
+        return settings.SENTRY_FRONTEND_DSN
+
+    project_id = settings.SENTRY_FRONTEND_PROJECT or settings.SENTRY_PROJECT
+    cache_key = 'dsn:%s' % (project_id, )
+
+    result = cache.get(cache_key)
+    if result is None:
+        key = _get_project_key(project_id)
+        if key:
+            result = key.dsn_public
+        else:
+            result = ''
+        cache.set(cache_key, result, 60)
+    return result
+
+
+def get_client_config(request=None):
+    """
+    Provides initial bootstrap data needed to boot the frontend application.
+    """
+    if request is not None:
+        user = getattr(request, 'user', None) or AnonymousUser()
+        messages = get_messages(request)
+        session = getattr(request, 'session', None)
+        is_superuser = is_active_superuser(request)
+        language_code = getattr(request, 'LANGUAGE_CODE', 'en')
+
+        # User identity is used by the sentry SDK
+        user_identity = {'ip_address': request.META['REMOTE_ADDR']}
+        if user and user.is_authenticated():
+            user_identity.update({
+                'email': user.email,
+                'id': user.id,
+            })
+            if user.name:
+                user_identity['name'] = user.name
+    else:
+        user = None
+        user_identity = {}
+        messages = []
+        is_superuser = False
+        language_code = 'en'
+
+    enabled_features = []
+    if features.has('organizations:create', actor=user):
+        enabled_features.append('organizations:create')
+    if auth.has_user_registration():
+        enabled_features.append('auth:register')
+
+    version_info = _get_version_info()
+
+    needs_upgrade = False
+
+    if is_superuser:
+        needs_upgrade = _needs_upgrade()
+
+    context = {
+        'singleOrganization': settings.SENTRY_SINGLE_ORGANIZATION,
+        'supportEmail': get_support_mail(),
+        'urlPrefix': options.get('system.url-prefix'),
+        'version': version_info,
+        'features': enabled_features,
+        'distPrefix': get_asset_url('sentry', 'dist/'),
+        'needsUpgrade': needs_upgrade,
+        'dsn': _get_public_dsn(),
+        'statuspage': _get_statuspage(),
+        'messages': [{
+            'message': msg.message,
+            'level': msg.tags,
+        } for msg in messages],
+        'isOnPremise': settings.SENTRY_ONPREMISE,
+        'invitesEnabled': settings.SENTRY_ENABLE_INVITES,
+        'gravatarBaseUrl': settings.SENTRY_GRAVATAR_BASE_URL,
+        'termsUrl': settings.TERMS_URL,
+        'privacyUrl': settings.PRIVACY_URL,
+        # Note `lastOrganization` should not be expected to update throughout frontend app lifecycle
+        # It should only be used on a fresh browser nav to a path where an
+        # organization is not in context
+        'lastOrganization': session['activeorg'] if session and 'activeorg' in session else None,
+        'languageCode': language_code,
+        'userIdentity': user_identity,
+        'csrfCookieName': settings.CSRF_COOKIE_NAME,
+        'sentryConfig': {
+            'dsn': _get_public_dsn(),
+            'release': version_info['build'],
+            'whitelistUrls': list(settings.ALLOWED_HOSTS),
+        },
+    }
+    if user and user.is_authenticated():
+        context.update({
+            'isAuthenticated': True,
+            'user': serialize(user, user, DetailedUserSerializer()),
+        })
+        context['user']['isSuperuser'] = is_superuser
+    else:
+        context.update({
+            'isAuthenticated': False,
+            'user': None,
+        })
+
+    return context
diff --git a/src/sentry/web/urls.py b/src/sentry/web/urls.py
index 7321b12ced..dcef60b66f 100644
--- a/src/sentry/web/urls.py
+++ b/src/sentry/web/urls.py
@@ -135,6 +135,13 @@ urlpatterns += patterns(
     ),
     url(r'^api/store/schema$', api.StoreSchemaView.as_view(), name='sentry-api-store-schema'),
 
+    # Frontend client config
+    url(
+        r'^api/client-config/?$',
+        api.ClientConfigView.as_view(),
+        name='sentry-api-client-config'
+    ),
+
     # The static version is either a 10 digit timestamp, a sha1, or md5 hash
     url(
         r'^_static/(?:(?P<version>\d{10}|[a-f0-9]{32,40})/)?(?P<module>[^/]+)/(?P<path>.*)$',
diff --git a/tests/sentry/web/api/tests.py b/tests/sentry/web/api/tests.py
index a97c58e60f..6e8ff53eb7 100644
--- a/tests/sentry/web/api/tests.py
+++ b/tests/sentry/web/api/tests.py
@@ -829,3 +829,45 @@ class APIViewTest(TestCase):
     def test_retry_after_int(self):
         resp = self._postWithHeader({})
         assert resp['Retry-After'] == '43'
+
+
+class ClientConfigViewTest(TestCase):
+    @fixture
+    def path(self):
+        return reverse('sentry-api-client-config')
+
+    def test_unauthenticated(self):
+        resp = self.client.get(self.path)
+        assert resp.status_code == 200
+        assert resp['Content-Type'] == 'application/json'
+
+        data = json.loads(resp.content)
+        assert not data['isAuthenticated']
+        assert data['user'] is None
+
+    def test_authenticated(self):
+        user = self.create_user('foo@example.com')
+        self.login_as(user)
+
+        resp = self.client.get(self.path)
+        assert resp.status_code == 200
+        assert resp['Content-Type'] == 'application/json'
+
+        data = json.loads(resp.content)
+        assert data['isAuthenticated']
+        assert data['user']
+        assert data['user']['email'] == user.email
+
+    def test_superuser(self):
+        user = self.create_user('foo@example.com', is_superuser=True)
+        self.login_as(user, superuser=True)
+
+        resp = self.client.get(self.path)
+        assert resp.status_code == 200
+        assert resp['Content-Type'] == 'application/json'
+
+        data = json.loads(resp.content)
+        assert data['isAuthenticated']
+        assert data['user']
+        assert data['user']['email'] == user.email
+        assert data['user']['isSuperuser']

commit 013d22561765bfac3fb800e3a15e5f5aa7d9c3bd
Author: Lyn Nagara <lyn.nagara@gmail.com>
Date:   Thu Aug 1 11:37:07 2019 -0700

    feat: Introduce Eventstore (#14173)
    
    Introduce Eventstore with a Snuba backend
    
    This is based on the API proposal outlined in
    https://www.notion.so/sentry/Eventstore-API-proposal-70ae5bb725114ab5806b24772df90c02.
    
    The current implementation allows a custom list of columns to be
    requested via the Eventstore.
    
    How to hydrate Event properties given that any custom list of
    columns can be requested is yet to be decided.

diff --git a/src/sentry/db/models/manager.py b/src/sentry/db/models/manager.py
index f2e6e5f070..7cff804cfe 100644
--- a/src/sentry/db/models/manager.py
+++ b/src/sentry/db/models/manager.py
@@ -337,7 +337,7 @@ class SnubaEventManager:
 
 
 class EventManager(BaseManager):
-
+    # TODO: Remove method in favour of eventstore.bind_nodes
     def bind_nodes(self, object_list, *node_names):
         """
         For a list of Event objects, and a property name where we might find an
diff --git a/src/sentry/eventstore/__init__.py b/src/sentry/eventstore/__init__.py
new file mode 100644
index 0000000000..a8c453ef3e
--- /dev/null
+++ b/src/sentry/eventstore/__init__.py
@@ -0,0 +1,11 @@
+from __future__ import absolute_import
+
+from sentry.utils.services import LazyServiceWrapper
+
+from .base import EventStorage  # NOQA
+
+backend = LazyServiceWrapper(
+    EventStorage, 'sentry.eventstore.snuba.SnubaEventStorage', {},
+    metrics_path='eventstore',
+)
+backend.expose(locals())
diff --git a/src/sentry/eventstore/base.py b/src/sentry/eventstore/base.py
new file mode 100644
index 0000000000..952264a42a
--- /dev/null
+++ b/src/sentry/eventstore/base.py
@@ -0,0 +1,144 @@
+from __future__ import absolute_import
+
+from enum import Enum
+
+from sentry import nodestore
+from sentry.utils.services import Service
+
+
+class Columns(Enum):
+    EVENT_ID = 'event_id'
+    GROUP_ID = 'group_id'
+    PROJECT_ID = 'project_id'
+    TIMESTAMP = 'timestamp'
+    CULPRIT = 'culprit'
+    LOCATION = 'location'
+    MESSAGE = 'message'
+    PLATFORM = 'platform'
+    TITLE = 'title'
+    TYPE = 'type'
+    TAGS_KEY = 'tags.key'
+    TAGS_VALUE = 'tags.value'
+    EMAIL = 'email'
+    IP_ADDRESS = 'ip_address'
+    USER_ID = 'user_id'
+    USERNAME = 'username'
+
+
+class EventStorage(Service):
+    __all__ = (
+        'minimal_columns',
+        'full_columns',
+        'get_event_by_id',
+        'get_events',
+        'get_prev_event_id',
+        'get_next_event_id',
+        'bind_nodes',
+    )
+
+    # The minimal list of columns we need to get from snuba to bootstrap an
+    # event. If the client is planning on loading the entire event body from
+    # nodestore anyway, we may as well only fetch the minimum from snuba to
+    # avoid duplicated work.
+    minimal_columns = [
+        Columns.EVENT_ID,
+        Columns.GROUP_ID,
+        Columns.PROJECT_ID,
+        Columns.TIMESTAMP,
+    ]
+
+    # A list of all useful columns we can get from snuba.
+    full_columns = minimal_columns + [
+        Columns.CULPRIT,
+        Columns.LOCATION,
+        Columns.MESSAGE,
+        Columns.PLATFORM,
+        Columns.TITLE,
+        Columns.TYPE,
+
+        # Required to provide snuba-only tags
+        Columns.TAGS_KEY,
+        Columns.TAGS_VALUE,
+
+        # Required to provide snuba-only 'user' interface
+        Columns.EMAIL,
+        Columns.IP_ADDRESS,
+        Columns.USER_ID,
+        Columns.USERNAME,
+    ]
+
+    def get_event_by_id(self, project_id, event_id, additional_columns):
+        """
+        Gets a single event given a project_id and event_id.
+
+        Keyword arguments:
+        project_id (int): Project ID
+        event_id (str): Event ID
+        additional_columns: (Sequence[Column]) - List of addition columns to fetch - default None
+        """
+        raise NotImplementedError
+
+    def get_events(self, start, end, additional_columns,
+                   conditions, filter_keys, orderby, limit, offset):
+        """
+        Fetches a list of events given a set of criteria.
+
+        Keyword arguments:
+        start (DateTime): Start datetime - default datetime.utcfromtimestamp(0)
+        end (DateTime): End datetime - default datetime.utcnow()
+        additional_columns (Sequence[Column]): List of additional columns to fetch - default None
+        conditions (Sequence[Sequence[str, str, Any]]): List of conditions to fetch - default None
+        filter_keys (Mapping[str, Any]): Filter keys - default None
+        orderby (Sequence[str]): List of fields to order by - default ['-time', '-event_id']
+        limit (int): Query limit - default 100
+        offset (int): Query offset - default 0
+        """
+        raise NotImplementedError
+
+    def get_next_event_id(self, event, conditions, filter_keys):
+        """
+        Gets the next event given a current event and some conditions/filters.
+        Returns a tuple of (project_id, event_id)
+
+        Arguments:
+        event (Event): Event object
+
+        Keyword arguments:
+        conditions (Sequence[Sequence[str, str, Any]]): List of conditions - default None
+        filter_keys (Mapping[str, Any]): Filter keys - default None
+        """
+        raise NotImplementedError
+
+    def get_prev_event_id(self, event, conditions, filter_keys):
+        """
+        Gets the previous event given a current event and some conditions/filters.
+        Returns a tuple of (project_id, event_id)
+
+        Arguments:
+        event (Event): Event object
+
+        Keyword arguments:
+        conditions (Sequence[Sequence[str, str, Any]]): List of conditions - default None
+        filter_keys (Mapping[str, Any]): Filter keys - default None
+        """
+        raise NotImplementedError
+
+    def bind_nodes(self, object_list, node_name='data'):
+        """
+        For a list of Event objects, and a property name where we might find an
+        (unfetched) NodeData on those objects, fetch all the data blobs for
+        those NodeDatas with a single multi-get command to nodestore, and bind
+        the returned blobs to the NodeDatas
+        """
+        object_node_list = [(i, getattr(i, node_name))
+                            for i in object_list if getattr(i, node_name).id]
+
+        node_ids = [n.id for _, n in object_node_list]
+        if not node_ids:
+            return
+
+        node_results = nodestore.get_multi(node_ids)
+
+        for item, node in object_node_list:
+            data = node_results.get(node.id) or {}
+            node.bind_data(data, ref=node.get_ref(item))
diff --git a/src/sentry/eventstore/snuba/__init__.py b/src/sentry/eventstore/snuba/__init__.py
new file mode 100644
index 0000000000..34c34dd0bb
--- /dev/null
+++ b/src/sentry/eventstore/snuba/__init__.py
@@ -0,0 +1,3 @@
+from __future__ import absolute_import
+
+from .backend import SnubaEventStorage  # NOQA
diff --git a/src/sentry/eventstore/snuba/backend.py b/src/sentry/eventstore/snuba/backend.py
new file mode 100644
index 0000000000..006f6aa9aa
--- /dev/null
+++ b/src/sentry/eventstore/snuba/backend.py
@@ -0,0 +1,10 @@
+from __future__ import absolute_import
+
+
+from sentry.eventstore.base import EventStorage
+
+
+class SnubaEventStorage(EventStorage):
+    """
+    Eventstore backend backed by Snuba
+    """
diff --git a/tests/sentry/eventstore/__init__.py b/tests/sentry/eventstore/__init__.py
new file mode 100644
index 0000000000..c3961685ab
--- /dev/null
+++ b/tests/sentry/eventstore/__init__.py
@@ -0,0 +1 @@
+from __future__ import absolute_import
diff --git a/tests/sentry/eventstore/test_base.py b/tests/sentry/eventstore/test_base.py
new file mode 100644
index 0000000000..97b1372f36
--- /dev/null
+++ b/tests/sentry/eventstore/test_base.py
@@ -0,0 +1,52 @@
+from __future__ import absolute_import
+
+from datetime import timedelta
+from django.utils import timezone
+
+from sentry.models import SnubaEvent
+from sentry.testutils import TestCase
+from sentry.eventstore.base import EventStorage
+
+
+class EventStorageTest(TestCase):
+    def setUp(self):
+        self.eventstorage = EventStorage()
+
+    def test_minimal_columns(self):
+        assert len(self.eventstorage.minimal_columns) == 4
+
+    def test_full_columns(self):
+        assert len(self.eventstorage.full_columns) == 16
+
+    def test_bind_nodes(self):
+        """
+        Test that bind_nodes populates _node_data
+        """
+        min_ago = (timezone.now() - timedelta(minutes=1)).isoformat()[:19]
+        self.store_event(
+            data={
+                'event_id': 'a' * 32,
+                'timestamp': min_ago,
+                'user': {
+                    'id': u'user1',
+                },
+            },
+            project_id=self.project.id,
+        )
+        self.store_event(
+            data={
+                'event_id': 'b' * 32,
+                'timestamp': min_ago,
+                'user': {
+                    'id': u'user2',
+                },
+            },
+            project_id=self.project.id,
+        )
+
+        event = SnubaEvent.objects.from_event_id('a' * 32, self.project.id)
+        event2 = SnubaEvent.objects.from_event_id('b' * 32, self.project.id)
+        assert event.data._node_data is None
+        self.eventstorage.bind_nodes([event, event2], 'data')
+        assert event.data._node_data is not None
+        assert event.data['user']['id'] == u'user1'

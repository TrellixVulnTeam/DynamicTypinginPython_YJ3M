commit 18ba1084091dbed00062da39bb4dc36153eae117
Author: Matt Robenolt <matt@ydekproductions.com>
Date:   Wed Dec 2 15:17:21 2015 -0800

    Split OptionsManager into an OptionsStore

diff --git a/src/sentry/options/__init__.py b/src/sentry/options/__init__.py
index 2ecd31a022..7569d84ebf 100644
--- a/src/sentry/options/__init__.py
+++ b/src/sentry/options/__init__.py
@@ -7,6 +7,7 @@ sentry.options
 """
 from __future__ import absolute_import, print_function
 
+from .store import OptionsStore
 from .manager import OptionsManager
 from .manager import DEFAULT_FLAGS, FLAG_IMMUTABLE, FLAG_NOSTORE, FLAG_STOREONLY  # NOQA
 
@@ -14,7 +15,8 @@ __all__ = (
     'get', 'set', 'delete', 'register',
 )
 
-default_manager = OptionsManager()
+default_store = OptionsStore()
+default_manager = OptionsManager(store=default_store)
 
 # expose public API
 get = default_manager.get
diff --git a/src/sentry/options/manager.py b/src/sentry/options/manager.py
index 014072df28..680ed7aaf6 100644
--- a/src/sentry/options/manager.py
+++ b/src/sentry/options/manager.py
@@ -7,23 +7,13 @@ sentry.options.manager
 """
 from __future__ import absolute_import, print_function
 
-from collections import namedtuple
+import logging
 from types import NoneType
-
 from django.conf import settings
-from django.utils import timezone
-
-from sentry.db.models.query import create_or_update
-from sentry.models import Option
-from sentry.utils.hashlib import md5
-
-
-CACHE_FETCH_ERR = 'Unable to fetch option cache for %s'
-CACHE_UPDATE_ERR = 'Unable to update option cache for %s'
 
-Key = namedtuple('Key', ('name', 'default', 'type', 'flags', 'cache_key'))
 # Prevent outselves from clobbering the builtin
 _type = type
+logger = logging.getLogger('sentry')
 
 
 class UnknownOption(KeyError):
@@ -58,21 +48,10 @@ class OptionsManager(object):
     constants in the global configuration.
     """
 
-    def __init__(self, cache=None, ttl=None, logger=None):
-        if cache is None:
-            from sentry.cache import default_cache
-            cache = default_cache
-        if logger is None:
-            import logging
-            logger = logging.getLogger('sentry')
-        self.cache = cache
-        self.logger = logger
-        self.ttl = ttl
+    def __init__(self, store):
+        self.store = store
         self.registry = {}
 
-    def _make_cache_key(self, key):
-        return 'o:{0}'.format(md5(key).hexdigest())
-
     def set(self, key, value):
         """
         Set the value for an option. If the cache is unavailable the action will
@@ -91,21 +70,7 @@ class OptionsManager(object):
         if not isinstance(value, opt.type):
             raise TypeError('got %r, expected %r' % (_type(value), opt.type))
 
-        create_or_update(
-            model=Option,
-            key=key,
-            values={
-                'value': value,
-                'last_updated': timezone.now(),
-            }
-        )
-
-        try:
-            self.update_cached_value(opt.cache_key, value)
-            return True
-        except Exception:
-            self.logger.warn(CACHE_UPDATE_ERR, key, exc_info=True)
-            return False
+        return self.store.set(opt, value)
 
     def lookup_key(self, key):
         try:
@@ -115,10 +80,10 @@ class OptionsManager(object):
             # Fortunately, they all share the same prefix, 'sentry:', so
             # we special case them here and construct a faux key until we migrate.
             if key.startswith(('sentry:', 'getsentry:')):
-                self.logger.debug('Using legacy key: %s', key, exc_info=True)
+                logger.debug('Using legacy key: %s', key, exc_info=True)
                 # History shows, there was an expectation of no types, and empty string
                 # as the default response value
-                return Key(key, '', object, DEFAULT_FLAGS, self._make_cache_key(key))
+                return self.store.make_key(key, '', object, DEFAULT_FLAGS)
             raise UnknownOption(key)
 
     def get(self, key):
@@ -136,7 +101,7 @@ class OptionsManager(object):
         opt = self.lookup_key(key)
 
         if not (opt.flags & FLAG_NOSTORE):
-            result = self.fetch_from_store(opt)
+            result = self.store.get(opt)
             if result is not None:
                 return result
 
@@ -151,31 +116,6 @@ class OptionsManager(object):
         except KeyError:
             return opt.default
 
-    def fetch_from_store(self, opt):
-        try:
-            result = self.cache.get(opt.cache_key)
-        except Exception:
-            self.logger.warn(CACHE_FETCH_ERR, opt.name, exc_info=True)
-            result = None
-
-        if result is None:
-            try:
-                result = Option.objects.get(key=opt.name).value
-            except Option.DoesNotExist:
-                result = None
-            except Exception as e:
-                self.logger.exception(unicode(e))
-                result = None
-            else:
-                # we only attempt to populate the cache if we were previously
-                # able to successfully talk to the backend
-                try:
-                    self.update_cached_value(opt.cache_key, result)
-                except Exception:
-                    self.logger.warn(CACHE_UPDATE_ERR, opt.name, exc_info=True)
-
-        return result
-
     def delete(self, key):
         """
         Permanently remove the value of an option.
@@ -193,17 +133,7 @@ class OptionsManager(object):
         # Enforce immutability on key
         assert not (opt.flags & FLAG_IMMUTABLE), '%r cannot be changed at runtime' % key
 
-        Option.objects.filter(key=key).delete()
-
-        try:
-            self.cache.delete(opt.cache_key)
-            return True
-        except Exception:
-            self.logger.warn(CACHE_UPDATE_ERR, key, exc_info=True)
-            return False
-
-    def update_cached_value(self, cache_key, value):
-        self.cache.set(cache_key, value, self.ttl)
+        return self.store.delete(opt)
 
     def register(self, key, default='', type=None, flags=DEFAULT_FLAGS):
         assert key not in self.registry, 'Option already registered: %r' % key
@@ -220,7 +150,7 @@ class OptionsManager(object):
             raise TypeError('Options must not be NoneType')
         if not isinstance(default, type):
             raise TypeError('got %r, expected %r' % (_type(default), type))
-        self.registry[key] = Key(key, default, type, flags, self._make_cache_key(key))
+        self.registry[key] = self.store.make_key(key, default, type, flags)
 
     def unregister(self, key):
         try:
diff --git a/src/sentry/options/store.py b/src/sentry/options/store.py
new file mode 100644
index 0000000000..fcb11e72dc
--- /dev/null
+++ b/src/sentry/options/store.py
@@ -0,0 +1,108 @@
+"""
+sentry.options.store
+~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2015 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+from __future__ import absolute_import, print_function
+
+import logging
+from collections import namedtuple
+
+from django.utils import timezone
+from sentry.db.models.query import create_or_update
+from sentry.models import Option
+from sentry.utils.hashlib import md5
+
+
+Key = namedtuple('Key', ('name', 'default', 'type', 'flags', 'cache_key'))
+
+CACHE_FETCH_ERR = 'Unable to fetch option cache for %s'
+CACHE_UPDATE_ERR = 'Unable to update option cache for %s'
+
+logger = logging.getLogger('sentry')
+
+
+class OptionsStore(object):
+    def __init__(self, cache=None, ttl=None):
+        if cache is None:
+            from sentry.cache import default_cache
+            cache = default_cache
+        self.cache = cache
+        self.ttl = ttl
+
+    def _make_cache_key(self, key):
+        return 'o:%s' % md5(key).hexdigest()
+
+    def make_key(self, name, default, type, flags):
+        return Key(name, default, type, flags, self._make_cache_key(name))
+
+    def get(self, key):
+        try:
+            result = self.get_cache(key)
+        except Exception:
+            logger.warn(CACHE_FETCH_ERR, key.name, exc_info=True)
+            result = None
+
+        if result is None:
+            try:
+                result = self.get_store(key)
+            except Option.DoesNotExist:
+                result = None
+            except Exception as e:
+                logger.exception(unicode(e))
+                result = None
+            else:
+                # we only attempt to populate the cache if we were previously
+                # able to successfully talk to the backend
+                # NOTE: There is definitely a race condition here between updating
+                # the store and the cache
+                try:
+                    self.set_cache(key, result)
+                except Exception:
+                    logger.warn(CACHE_UPDATE_ERR, key.name, exc_info=True)
+        return result
+
+    def get_cache(self, key):
+        return self.cache.get(key.cache_key)
+
+    def get_store(self, key):
+        return Option.objects.get(key=key.name).value
+
+    def set(self, key, value):
+        self.set_store(key, value)
+        try:
+            self.set_cache(key, value)
+            return True
+        except Exception:
+            logger.warn(CACHE_UPDATE_ERR, key, exc_info=True)
+            return False
+
+    def set_store(self, key, value):
+        create_or_update(
+            model=Option,
+            key=key.name,
+            values={
+                'value': value,
+                'last_updated': timezone.now(),
+            }
+        )
+
+    def set_cache(self, key, value):
+        self.cache.set(key.cache_key, value, self.ttl)
+
+    def delete(self, key):
+        self.delete_store(key)
+        try:
+            self.delete_cache(key)
+            return True
+        except Exception:
+            logger.warn(CACHE_UPDATE_ERR, key, exc_info=True)
+            return False
+
+    def delete_store(self, key):
+        Option.objects.filter(key=key.name).delete()
+
+    def delete_cache(self, key):
+        self.cache.delete(key.cache_key)
diff --git a/src/sentry/tasks/options.py b/src/sentry/tasks/options.py
index 5d056587c1..ee054302ca 100644
--- a/src/sentry/tasks/options.py
+++ b/src/sentry/tasks/options.py
@@ -34,6 +34,6 @@ def sync_options(cutoff=ONE_HOUR):
     for option in Option.objects.filter(last_updated__gte=cutoff_dt).iterator():
         try:
             opt = default_manager.lookup_key(option.key)
-            default_manager.update_cached_value(opt.cache_key, option.value)
+            default_manager.store.set_cache(opt, option.value)
         except UnknownOption as e:
             logger.exception(unicode(e))
diff --git a/tests/sentry/options/test_manager.py b/tests/sentry/options/test_manager.py
index b422458b06..af1edbc50f 100644
--- a/tests/sentry/options/test_manager.py
+++ b/tests/sentry/options/test_manager.py
@@ -5,7 +5,7 @@ from __future__ import absolute_import
 from exam import fixture, around
 from mock import patch
 
-from sentry.models import Option
+from sentry.options.store import OptionsStore
 from sentry.options.manager import (
     OptionsManager, UnknownOption,
     FLAG_IMMUTABLE, FLAG_NOSTORE, FLAG_STOREONLY)
@@ -13,9 +13,11 @@ from sentry.testutils import TestCase
 
 
 class OptionsManagerTest(TestCase):
+    store = fixture(OptionsStore)
+
     @fixture
     def manager(self):
-        return OptionsManager()
+        return OptionsManager(store=self.store)
 
     @around
     def register(self):
@@ -100,8 +102,8 @@ class OptionsManagerTest(TestCase):
             self.manager.set('nostore', 'thing')
 
         # Make sure that we don't touch either of the stores
-        with patch.object(self.manager.cache, 'get', side_effect=Exception()):
-            with patch.object(Option.objects, 'get_queryset', side_effect=Exception()):
+        with patch.object(self.store, 'get_cache', side_effect=Exception()):
+            with patch.object(self.store, 'get_store', side_effect=Exception()):
                 assert self.manager.get('nostore') == ''
 
                 with self.settings(SENTRY_OPTIONS={'nostore': 'foo'}):
@@ -132,40 +134,40 @@ class OptionsManagerTest(TestCase):
             assert self.manager.get('storeonly') == ''
 
     def test_db_unavailable(self):
-        with patch.object(Option.objects, 'get_queryset', side_effect=Exception()):
+        with patch.object(self.store, 'set_store', side_effect=Exception()):
             # we can't update options if the db is unavailable
             with self.assertRaises(Exception):
                 self.manager.set('foo', 'bar')
 
         self.manager.set('foo', 'bar')
 
-        with patch.object(Option.objects, 'get_queryset', side_effect=Exception()):
+        with patch.object(self.store, 'get_store', side_effect=Exception()):
             assert self.manager.get('foo') == 'bar'
 
-            with patch.object(self.manager.cache, 'get', side_effect=Exception()):
+            with patch.object(self.store, 'get_cache', side_effect=Exception()):
                 assert self.manager.get('foo') == ''
 
-                with patch.object(self.manager.cache, 'set', side_effect=Exception()):
+                with patch.object(self.store, 'set_cache', side_effect=Exception()):
                     assert self.manager.get('foo') == ''
 
     def test_db_and_cache_unavailable(self):
         self.manager.set('foo', 'bar')
 
         with self.settings(SENTRY_OPTIONS={'foo': 'baz'}):
-            with patch.object(Option.objects, 'get_queryset', side_effect=Exception()):
-                with patch.object(self.manager.cache, 'get', side_effect=Exception()):
+            with patch.object(self.store, 'get_store', side_effect=Exception()):
+                with patch.object(self.store, 'get_cache', side_effect=Exception()):
                     assert self.manager.get('foo') == 'baz'
 
-                    with patch.object(self.manager.cache, 'set', side_effect=Exception()):
+                    with patch.object(self.store, 'set_cache', side_effect=Exception()):
                         assert self.manager.get('foo') == 'baz'
 
     def test_cache_unavailable(self):
         self.manager.set('foo', 'bar')
 
-        with patch.object(self.manager.cache, 'get', side_effect=Exception()):
+        with patch.object(self.store, 'get_cache', side_effect=Exception()):
             assert self.manager.get('foo') == 'bar'
 
-            with patch.object(self.manager.cache, 'set', side_effect=Exception()):
+            with patch.object(self.store, 'set_cache', side_effect=Exception()):
                 assert self.manager.get('foo') == 'bar'
 
                 # we should still be able to write a new value
@@ -176,10 +178,10 @@ class OptionsManagerTest(TestCase):
         assert self.manager.get('foo') == 'bar'
 
         # when the cache poofs, the db will be return the most-true answer
-        with patch.object(self.manager.cache, 'get', side_effect=Exception()):
+        with patch.object(self.store, 'get_cache', side_effect=Exception()):
             assert self.manager.get('foo') == 'baz'
 
-            with patch.object(self.manager.cache, 'set', side_effect=Exception()):
+            with patch.object(self.store, 'set_cache', side_effect=Exception()):
                 assert self.manager.get('foo') == 'baz'
 
     def test_unregister(self):
diff --git a/tests/sentry/tasks/test_options.py b/tests/sentry/tasks/test_options.py
index b31533f983..8cc77627d5 100644
--- a/tests/sentry/tasks/test_options.py
+++ b/tests/sentry/tasks/test_options.py
@@ -5,7 +5,7 @@ from mock import patch
 from datetime import timedelta
 
 from sentry.models import Option
-from sentry.options import default_manager
+from sentry.options import default_store, default_manager
 from sentry.tasks.options import sync_options
 from sentry.testutils import TestCase
 
@@ -14,8 +14,8 @@ class SyncOptionsTest(TestCase):
     def test_task_persistent_name(self):
         assert sync_options.name == 'sentry.tasks.options.sync_options'
 
-    @patch.object(default_manager, 'update_cached_value')
-    def test_simple(self, mock_update_cached_value):
+    @patch.object(default_store, 'set_cache')
+    def test_simple(self, mock_set_cache):
         default_manager.register('foo')
         option = Option.objects.create(
             key='foo',
@@ -23,12 +23,11 @@ class SyncOptionsTest(TestCase):
         )
         sync_options(cutoff=60)
 
-        assert mock_update_cached_value.called
-
-        mock_update_cached_value.reset_mock()
+        assert mock_set_cache.called
+        mock_set_cache.reset_mock()
 
         option.update(last_updated=option.last_updated - timedelta(days=1))
 
         sync_options(cutoff=60)
 
-        assert not mock_update_cached_value.called
+        assert not mock_set_cache.called

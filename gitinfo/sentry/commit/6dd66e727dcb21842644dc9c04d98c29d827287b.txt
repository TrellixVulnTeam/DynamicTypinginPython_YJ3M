commit 6dd66e727dcb21842644dc9c04d98c29d827287b
Author: Filippo Pacifici <fpacifici@sentry.io>
Date:   Tue Jul 16 10:32:15 2019 -0700

    feat(issueless events) Skip group creation for transaction events (#13907)
    
    Skips the creation and storage of the group if the event type is transaction. It also skips all the phases of event_manager save that depends on a group.

diff --git a/src/sentry/event_manager.py b/src/sentry/event_manager.py
index 2917aca1a2..a063105f6a 100644
--- a/src/sentry/event_manager.py
+++ b/src/sentry/event_manager.py
@@ -566,6 +566,13 @@ class EventManager(object):
         if transaction_name:
             transaction_name = force_text(transaction_name)
 
+        # Right now the event type is the signal to skip the group. This
+        # is going to change a lot.
+        if event.get_event_type() == 'transaction':
+            issueless_event = True
+        else:
+            issueless_event = False
+
         # Some of the data that are toplevel attributes are duplicated
         # into tags (logger, level, environment, transaction).  These are
         # different from legacy attributes which are normalized into tags
@@ -659,53 +666,64 @@ class EventManager(object):
         event.message = self.get_search_message(event_metadata, culprit)
         received_timestamp = event.data.get('received') or float(event.datetime.strftime('%s'))
 
-        # The group gets the same metadata as the event when it's flushed but
-        # additionally the `last_received` key is set.  This key is used by
-        # _save_aggregate.
-        group_metadata = dict(materialized_metadata)
-        group_metadata['last_received'] = received_timestamp
-        kwargs = {
-            'platform': platform,
-            'message': event.message,
-            'culprit': culprit,
-            'logger': logger_name,
-            'level': LOG_LEVELS_MAP.get(level),
-            'last_seen': date,
-            'first_seen': date,
-            'active_at': date,
-            'data': group_metadata,
-        }
+        if not issueless_event:
+            # The group gets the same metadata as the event when it's flushed but
+            # additionally the `last_received` key is set.  This key is used by
+            # _save_aggregate.
+            group_metadata = dict(materialized_metadata)
+            group_metadata['last_received'] = received_timestamp
+            kwargs = {
+                'platform': platform,
+                'message': event.message,
+                'culprit': culprit,
+                'logger': logger_name,
+                'level': LOG_LEVELS_MAP.get(level),
+                'last_seen': date,
+                'first_seen': date,
+                'active_at': date,
+                'data': group_metadata,
+            }
 
-        if release:
-            kwargs['first_release'] = release
+            if release:
+                kwargs['first_release'] = release
 
-        try:
-            group, is_new, is_regression, is_sample = self._save_aggregate(
-                event=event, hashes=hashes, release=release, **kwargs
-            )
-        except HashDiscarded:
-            event_discarded.send_robust(
-                project=project,
-                sender=EventManager,
-            )
+            try:
+                group, is_new, is_regression, is_sample = self._save_aggregate(
+                    event=event, hashes=hashes, release=release, **kwargs
+                )
+            except HashDiscarded:
+                event_discarded.send_robust(
+                    project=project,
+                    sender=EventManager,
+                )
 
-            metrics.incr(
-                'events.discarded',
-                skip_internal=True,
-                tags={
-                    'organization_id': project.organization_id,
-                    'platform': platform,
-                },
-            )
-            raise
+                metrics.incr(
+                    'events.discarded',
+                    skip_internal=True,
+                    tags={
+                        'organization_id': project.organization_id,
+                        'platform': platform,
+                    },
+                )
+                raise
+            else:
+                event_saved.send_robust(
+                    project=project,
+                    event_size=event.size,
+                    sender=EventManager,
+                )
+            event.group = group
         else:
+            group = None
+            is_new = False
+            is_regression = False
+            is_sample = False
             event_saved.send_robust(
                 project=project,
                 event_size=event.size,
                 sender=EventManager,
             )
 
-        event.group = group
         # store a reference to the group id to guarantee validation of isolation
         event.data.bind_ref(event)
 
@@ -736,13 +754,16 @@ class EventManager(object):
             name=environment,
         )
 
-        group_environment, is_new_group_environment = GroupEnvironment.get_or_create(
-            group_id=group.id,
-            environment_id=environment.id,
-            defaults={
-                'first_release': release if release else None,
-            },
-        )
+        if group:
+            group_environment, is_new_group_environment = GroupEnvironment.get_or_create(
+                group_id=group.id,
+                environment_id=environment.id,
+                defaults={
+                    'first_release': release if release else None,
+                },
+            )
+        else:
+            is_new_group_environment = False
 
         if release:
             ReleaseEnvironment.get_or_create(
@@ -759,18 +780,21 @@ class EventManager(object):
                 datetime=date,
             )
 
-            grouprelease = GroupRelease.get_or_create(
-                group=group,
-                release=release,
-                environment=environment,
-                datetime=date,
-            )
+            if group:
+                grouprelease = GroupRelease.get_or_create(
+                    group=group,
+                    release=release,
+                    environment=environment,
+                    datetime=date,
+                )
 
         counters = [
-            (tsdb.models.group, group.id),
             (tsdb.models.project, project.id),
         ]
 
+        if group:
+            counters.append((tsdb.models.group, group.id))
+
         if release:
             counters.append((tsdb.models.release, release.id))
 
@@ -787,39 +811,44 @@ class EventManager(object):
             #         group.id: 1,
             #     },
             # })
-            (tsdb.models.frequent_environments_by_group, {
-                group.id: {
-                    environment.id: 1,
-                },
-            })
         ]
 
-        if release:
+        if group:
             frequencies.append(
-                (tsdb.models.frequent_releases_by_group, {
+                (tsdb.models.frequent_environments_by_group, {
                     group.id: {
-                        grouprelease.id: 1,
+                        environment.id: 1,
                     },
                 })
             )
 
-        tsdb.record_frequency_multi(frequencies, timestamp=event.datetime)
+            if release:
+                frequencies.append(
+                    (tsdb.models.frequent_releases_by_group, {
+                        group.id: {
+                            grouprelease.id: 1,
+                        },
+                    })
+                )
+        if frequencies:
+            tsdb.record_frequency_multi(frequencies, timestamp=event.datetime)
 
-        UserReport.objects.filter(
-            project=project,
-            event_id=event_id,
-        ).update(
-            group=group,
-            environment=environment,
-        )
+        if group:
+            UserReport.objects.filter(
+                project=project,
+                event_id=event_id,
+            ).update(
+                group=group,
+                environment=environment,
+            )
 
-        # Update any event attachment that arrived before the event group was defined.
-        EventAttachment.objects.filter(
-            project_id=project.id,
-            event_id=event_id,
-        ).update(
-            group_id=group.id,
-        )
+            # Update any event attachment that arrived before the event group was defined.
+            EventAttachment.objects.filter(
+                project_id=project.id,
+                event_id=event_id,
+            ).update(
+                group_id=group.id,
+            )
 
         # save the event unless its been sampled
         if not is_sample:
@@ -850,14 +879,20 @@ class EventManager(object):
             )
 
         if event_user:
+            counters = [
+                (tsdb.models.users_affected_by_project, project.id, (event_user.tag_value, )),
+            ]
+
+            if group:
+                counters.append((tsdb.models.users_affected_by_group,
+                                 group.id, (event_user.tag_value, )))
+
             tsdb.record_multi(
-                (
-                    (tsdb.models.users_affected_by_group, group.id, (event_user.tag_value, )),
-                    (tsdb.models.users_affected_by_project, project.id, (event_user.tag_value, )),
-                ),
+                counters,
                 timestamp=event.datetime,
                 environment_id=environment.id,
             )
+
         if release:
             if is_new:
                 buffer.incr(
@@ -875,12 +910,13 @@ class EventManager(object):
                     }
                 )
 
-        safe_execute(
-            Group.objects.add_tags,
-            group,
-            environment,
-            event.get_tags(),
-            _with_transaction=False)
+        if group:
+            safe_execute(
+                Group.objects.add_tags,
+                group,
+                environment,
+                event.get_tags(),
+                _with_transaction=False)
 
         if not raw:
             if not project.first_event:
diff --git a/src/sentry/testutils/factories.py b/src/sentry/testutils/factories.py
index 09ef8dcf73..d9d423a784 100644
--- a/src/sentry/testutils/factories.py
+++ b/src/sentry/testutils/factories.py
@@ -519,7 +519,8 @@ class Factories(object):
             assert not errors, errors
 
         event = manager.save(project_id)
-        event.group.save()
+        if event.group:
+            event.group.save()
         return event
 
     @staticmethod
diff --git a/tests/sentry/event_manager/test_event_manager.py b/tests/sentry/event_manager/test_event_manager.py
index 994cdb8eea..ad9f545eef 100644
--- a/tests/sentry/event_manager/test_event_manager.py
+++ b/tests/sentry/event_manager/test_event_manager.py
@@ -1104,6 +1104,28 @@ class EventManagerTest(TestCase):
             'message': "Blocked 'script' from 'example.com'",
         }
 
+    def test_transaction_event_type(self):
+        manager = EventManager(
+            make_event(
+                **{
+                    'transaction': 'wait',
+                    'contexts': {
+                        'trace': {
+                            'parent_span_id': 'bce14471e0e9654d',
+                            'trace_id': 'a0fa8803753e40fd8124b21eeb2986b5',
+                            'span_id': 'bf5be759039ede9a'
+                        }
+                    },
+                    'spans': [],
+                    'start_timestamp': '2019-06-14T14:01:40Z',
+                    'type': 'transaction',
+                }
+            )
+        )
+        manager.normalize()
+        data = manager.get_data()
+        assert data['type'] == 'transaction'
+
     def test_sdk(self):
         manager = EventManager(
             make_event(**{
@@ -1359,6 +1381,79 @@ class EventManagerTest(TestCase):
         tags = dict(event.tags)
         assert tags['server_name'] == 'foo.com'
 
+    def test_save_issueless_event(self):
+        manager = EventManager(
+            make_event(
+                transaction='wait',
+                contexts={
+                    'trace': {
+                        'parent_span_id': 'bce14471e0e9654d',
+                        'trace_id': 'a0fa8803753e40fd8124b21eeb2986b5',
+                        'span_id': 'bf5be759039ede9a'
+                    }
+                },
+                spans=[],
+                start_timestamp='2019-06-14T14:01:40Z',
+                type='transaction',
+                platform='python',
+            )
+        )
+
+        event = manager.save(self.project.id)
+
+        assert event.group is None
+        assert tsdb.get_sums(
+            tsdb.models.project,
+            [self.project.id],
+            event.datetime,
+            event.datetime,
+        )[self.project.id] == 1
+
+    def test_fingerprint_ignored(self):
+        manager1 = EventManager(
+            make_event(
+                event_id='a' * 32,
+                fingerprint='fingerprint1'
+            )
+        )
+        event1 = manager1.save(self.project.id)
+
+        manager2 = EventManager(
+            make_event(
+                event_id='b' * 32,
+                fingerprint='fingerprint1',
+                transaction='wait',
+                contexts={
+                    'trace': {
+                        'parent_span_id': 'bce14471e0e9654d',
+                        'trace_id': 'a0fa8803753e40fd8124b21eeb2986b5',
+                        'span_id': 'bf5be759039ede9a'
+                    }
+                },
+                spans=[],
+                start_timestamp='2019-06-14T14:01:40Z',
+                type='transaction',
+                platform='python',
+            )
+        )
+        event2 = manager2.save(self.project.id)
+
+        assert event1.group is not None
+        assert event2.group is None
+        assert tsdb.get_sums(
+            tsdb.models.project,
+            [self.project.id],
+            event1.datetime,
+            event1.datetime,
+        )[self.project.id] == 2
+
+        assert tsdb.get_sums(
+            tsdb.models.group,
+            [event1.group.id],
+            event1.datetime,
+            event1.datetime,
+        )[event1.group.id] == 1
+
 
 class ReleaseIssueTest(TestCase):
     def setUp(self):
diff --git a/tests/snuba/api/endpoints/test_event_details.py b/tests/snuba/api/endpoints/test_event_details.py
index 7ddc35a6ed..4b5cfea3b2 100644
--- a/tests/snuba/api/endpoints/test_event_details.py
+++ b/tests/snuba/api/endpoints/test_event_details.py
@@ -330,3 +330,41 @@ class EventDetailsTest(APITestCase, SnubaTestCase):
         assert response.status_code == 200, response.content
         assert response.data['id'] == six.text_type(event.id)
         assert response.data['previousEventID'] == six.text_type(before.event_id)
+
+    def test_issueless_event(self):
+        self.login_as(user=self.user)
+
+        data = {
+            'event_id': 'b' * 32,
+            'timestamp': self.two_min_ago,
+            'fingerprint': ['whatever-will-be-ignored'],
+            'transaction': 'wait',
+            'contexts': {
+                'trace': {
+                    'parent_span_id': 'bce14471e0e9654d',
+                    'trace_id': 'a0fa8803753e40fd8124b21eeb2986b5',
+                    'span_id': 'bf5be759039ede9a'
+                }
+            },
+            'spans': [],
+            'start_timestamp': '2019-06-14T14:01:40Z',
+            'type': 'transaction',
+        }
+
+        cur_event = self.store_event(
+            data,
+            project_id=self.project.id
+        )
+
+        url = reverse(
+            'sentry-api-0-event-details', kwargs={
+                'event_id': cur_event.id,
+            }
+        )
+        response = self.client.get(url, format='json')
+
+        assert response.status_code == 200, response.content
+        assert response.data['id'] == six.text_type(cur_event.id)
+        assert response.data['groupID'] is None
+        assert not response.data['userReport']
+        assert response.data['type'] == 'transaction'

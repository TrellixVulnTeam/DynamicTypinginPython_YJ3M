commit 634594d2414949193de2b7307d0fbef072be8872
Author: David Cramer <dcramer@gmail.com>
Date:   Tue May 20 21:08:14 2014 -0700

    New Search API
    
    - Filters are no longer extendable
    - Initial draft ElasticSearch backend
    
    Squashed commit of the following:
    
    commit 8aa1b955ec44f578bf0e88926d647f20c6062197
    Author: David Cramer <dcramer@gmail.com>
    Date:   Tue May 20 20:58:44 2014 -0700
    
        Restore partial filter API (primarily for rendering sidebar)
    
    commit 5f47a66881cdb2a3c720b72797c0358e2fa6a087
    Merge: 3b65d9a 2a602c1
    Author: David Cramer <dcramer@gmail.com>
    Date:   Tue May 20 20:42:21 2014 -0700
    
        Merge branch 'master' into search-refactor
    
        Conflicts:
            src/sentry/search/django/backend.py
    
    commit 3b65d9aac197a37617fa0e28db098f512dd8f76c
    Author: David Cramer <dcramer@gmail.com>
    Date:   Mon May 19 20:19:18 2014 -0700
    
        A form
    
    commit f7f3846d4cfba4691a121f0bb19aa3c01d7a223b
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun May 18 23:05:02 2014 -0700
    
        Kill sidebar on stream
    
    commit caadfa7af4065490b7661b65ba8a23f22beffd4c
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun May 18 12:44:15 2014 -0700
    
        Move search constants into .constants
    
    commit ca694a375c39add48c4b1e385beed6ce5a97846e
    Merge: 92848be 245b39e
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun May 18 12:38:58 2014 -0700
    
        Merge branch 'master' into es
    
        Conflicts:
            CHANGES
            src/sentry/conf/server.py
            src/sentry/filters/widgets.py
            src/sentry/search/django/backend.py
            src/sentry/testutils/fixtures.py
            src/sentry/web/frontend/groups.py
    
    commit 92848bea888f154483339b071f6b7953b49f13d6
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 20 22:32:42 2014 -0700
    
        Add missing params to base/elastic search
    
    commit 657c679e079b78bc71ad42cb6f949114bd9e8f87
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 20 13:29:00 2014 -0700
    
        Correct behavior of Django search backend
    
    commit 6c456c1b0aeac6b4df9e860e4cbc0c0d924167d7
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 20 13:23:39 2014 -0700
    
        Remove legacy search
    
    commit 70f08401f114cda98dd3ac77f1ae4b69e17bef0b
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 20 13:15:52 2014 -0700
    
        Bring sort values back
    
    commit 81a2b00788f135500e95c3bf7b074341c44d010b
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 20 12:57:43 2014 -0700
    
        First pass at removing filter related code
    
    commit ee278b9ce5e60ebad85114d6dca947fe4bf290b2
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 20 12:47:54 2014 -0700
    
        Abstract search results
    
    commit b3230e5ff27c31c5e0205b8ee20fdbff5b495908
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 20 12:31:09 2014 -0700
    
        search => query
    
    commit a6885ff1b2cda751cc67ba8f9417f73f7712ae29
    Merge: 04d6314 ab448ee
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 20 12:30:11 2014 -0700
    
        Merge branch 'master' into es
    
        Conflicts:
            src/sentry/web/frontend/groups.py
    
    commit 04d63140bcd9216077ecffb05fc6870ee7db973a
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 20 11:46:57 2014 -0700
    
        Initial work on abstracting stream fully into search
    
    commit e4feaa00066bc4239ad89ca8a962f0cc205f9d30
    Merge: 3ff6779 0584c8d
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sat Apr 19 14:09:35 2014 -0700
    
        Merge branch 'master' into es
    
    commit 3ff67797786bd9bc035ea88deb104ca305ab3e0f
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 13 22:14:03 2014 -0700
    
        Remove print
    
    commit f8c1aedfef370084b644020b37990c5d52963f7a
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 13 22:12:45 2014 -0700
    
        Tag and status queries
    
    commit db3623d37c61dbe8ada296ab74f40f52f9bf2236
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 13 21:39:16 2014 -0700
    
        Optional query param
    
    commit e1ca10d656fd33ea7adcb28a8adfd17803159579
    Merge: af8d390 453ea56
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 13 21:34:53 2014 -0700
    
        Merge branch 'master' into es
    
    commit af8d390e48dda2e71781ff3c1f2ea4e7b437e9f6
    Merge: 1a76e2c aadf4ee
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 13 21:34:34 2014 -0700
    
        Merge branch 'master' into es
    
    commit aadf4eed2d8d3960286aedfa252fdb8027aec9f9
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 13 21:34:27 2014 -0700
    
        Auto slug in fixtures
    
    commit 1a76e2cce5df9420ffa8abf5bbca492a3075728e
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 13 21:34:16 2014 -0700
    
        Fix test
    
    commit 2e42bb9eb3667fb985183c7c4cb7be8b101840d5
    Merge: e39eb66 0add3c9
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 13 21:31:53 2014 -0700
    
        Merge branch 'master' into es
    
    commit 0add3c97359a8ac3c0e691ad4be64df351a993a3
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 13 21:31:45 2014 -0700
    
        Add create_team/create_project to fixtures
    
    commit e39eb667c1d49b1f2225667bbff738001892b3ce
    Author: David Cramer <dcramer@gmail.com>
    Date:   Sun Apr 13 18:38:29 2014 -0400
    
        Initial draft code for new search backends

diff --git a/CHANGES b/CHANGES
index dadfc5e713..1ac0b662f5 100644
--- a/CHANGES
+++ b/CHANGES
@@ -8,6 +8,7 @@ Backwards Incompatible Changes
 - The UDP server has been removed. Threaded/async models are the preferred replacement.
 - The ``is_rate_limited`` plugin hook has been removed in favor of singular quota managers.
 - The trends feature has been removed until it can be reimplemented in a more scalable way.
+- Filters have been removed. Integrations should use the tagging infrastructure instead.
 - NodeStore.generate_id() now returns a base64-encoded UUID.
 - The API for interfaces has been rewritten.
 - GroupMeta.objects.get_value no longer errors when a value is missing.
diff --git a/setup.py b/setup.py
index b609fd2cec..c358ca20db 100755
--- a/setup.py
+++ b/setup.py
@@ -49,6 +49,7 @@ dev_requires = [
 tests_require = [
     'casscache',
     'cqlsh',
+    'elasticsearch',
     'exam>=0.5.1',
     'eventlet',
     'httpretty',
diff --git a/src/sentry/api/endpoints/project_group_index.py b/src/sentry/api/endpoints/project_group_index.py
index 8b2b773dff..aaedc5a6c8 100644
--- a/src/sentry/api/endpoints/project_group_index.py
+++ b/src/sentry/api/endpoints/project_group_index.py
@@ -1,21 +1,14 @@
 from datetime import timedelta
-from django.http import HttpResponse
 from django.utils import timezone
+from rest_framework.response import Response
 
+from sentry.app import search
 from sentry.api.base import Endpoint
 from sentry.api.permissions import assert_perm
 from sentry.api.serializers import serialize
-from sentry.constants import (
-    SORT_OPTIONS, SORT_CLAUSES, SCORE_CLAUSES,
-    MYSQL_SORT_CLAUSES, MYSQL_SCORE_CLAUSES,
-    SQLITE_SORT_CLAUSES, SQLITE_SCORE_CLAUSES,
-    ORACLE_SORT_CLAUSES, ORACLE_SCORE_CLAUSES,
-    MSSQL_SORT_CLAUSES, MSSQL_SCORE_CLAUSES,
-    DEFAULT_SORT_OPTION,
-)
-from sentry.models import TagKey, Group, Project
+from sentry.constants import DEFAULT_SORT_OPTION
+from sentry.models import TagKey, Project
 from sentry.utils.dates import parse_date
-from sentry.utils.db import get_db_engine
 
 
 class ProjectGroupIndexEndpoint(Endpoint):
@@ -29,29 +22,32 @@ class ProjectGroupIndexEndpoint(Endpoint):
 
         assert_perm(project, request.user, request.auth)
 
-        group_list = Group.objects.all()
+        query_kwargs = {
+            'project': project,
+        }
+
+        if request.GET.get('status'):
+            query_kwargs['status'] = int(request.GET['status'])
 
         if request.user.is_authenticated() and request.GET.get('bookmarks'):
-            group_list = group_list.filter(
-                bookmark_set__project=project,
-                bookmark_set__user=request.user,
-            )
-        else:
-            group_list = group_list.filter(project=project)
-
-        status = request.GET.get('status')
-        if status:
-            group_list = group_list.filter(status=int(status))
-
-        tag_keys = TagKey.objects.all_keys(project)
-        for tag in tag_keys:
-            value = request.GET.get(tag)
-            if value:
-                group_list = group_list.filter(
-                    grouptag__project=project,
-                    grouptag__key=tag,
-                    grouptag__value=value,
-                )
+            query_kwargs['bookmarked_by'] = request.user
+
+        sort_by = request.GET.get('sort') or request.session.get('streamsort')
+        if sort_by is None:
+            sort_by = DEFAULT_SORT_OPTION
+
+        # Save last sort in session
+        if sort_by != request.session.get('streamsort'):
+            request.session['streamsort'] = sort_by
+
+        query_kwargs['sort_by'] = sort_by
+
+        tags = {}
+        for tag_key in TagKey.objects.all_keys(project):
+            if request.GET.get(tag_key):
+                tags[tag_key] = request.GET[tag_key]
+        if tags:
+            query_kwargs['tags'] = tags
 
         # TODO: dates should include timestamps
         date_from = request.GET.get('since')
@@ -62,7 +58,6 @@ class ProjectGroupIndexEndpoint(Endpoint):
         time_to = request.GET.get('tt')
 
         today = timezone.now()
-
         # date format is Y-m-d
         if any(x is not None for x in [date_from, time_from, date_to, time_to]):
             date_from, date_to = parse_date(date_from, time_from), parse_date(date_to, time_to)
@@ -70,60 +65,16 @@ class ProjectGroupIndexEndpoint(Endpoint):
             date_from = today - timedelta(days=5)
             date_to = None
 
-        if date_filter == 'first_seen':
-            if date_from:
-                group_list = group_list.filter(first_seen__gte=date_from)
-            elif date_to:
-                group_list = group_list.filter(first_seen__lte=date_to)
-        else:
-            # TODO(dcramer): a date_to no longer makes a lot of sense, and will
-            # need corrected when search lands
-            if date_from:
-                group_list = group_list.filter(last_seen__gte=date_from)
-            if date_to:
-                group_list = group_list.filter(last_seen__lte=date_to)
-
-        sort = request.GET.get('sort') or request.session.get('streamsort')
-        if sort is None:
-            sort = DEFAULT_SORT_OPTION
-        elif sort not in SORT_OPTIONS or sort.startswith('accel_'):
-            return HttpResponse(status=400)
-
-        # Save last sort in session
-        if sort != request.session.get('streamsort'):
-            request.session['streamsort'] = sort
-
-        engine = get_db_engine('default')
-        if engine.startswith('sqlite'):
-            score_clause = SQLITE_SORT_CLAUSES.get(sort)
-            filter_clause = SQLITE_SCORE_CLAUSES.get(sort)
-        elif engine.startswith('mysql'):
-            score_clause = MYSQL_SORT_CLAUSES.get(sort)
-            filter_clause = MYSQL_SCORE_CLAUSES.get(sort)
-        elif engine.startswith('oracle'):
-            score_clause = ORACLE_SORT_CLAUSES.get(sort)
-            filter_clause = ORACLE_SCORE_CLAUSES.get(sort)
-        elif engine in ('django_pytds', 'sqlserver_ado', 'sql_server.pyodbc'):
-            score_clause = MSSQL_SORT_CLAUSES.get(sort)
-            filter_clause = MSSQL_SCORE_CLAUSES.get(sort)
-        else:
-            score_clause = SORT_CLAUSES.get(sort)
-            filter_clause = SCORE_CLAUSES.get(sort)
+        query_kwargs['date_from'] = date_from
+        query_kwargs['date_to'] = date_to
+        if date_filter:
+            query_kwargs['date_filter'] = date_filter
 
-        assert score_clause
+        # TODO: proper pagination support
+        cursor = request.GET.get('cursor')
+        if cursor:
+            query_kwargs['cursor'] = cursor
 
-        if sort == 'tottime':
-            group_list = group_list.filter(time_spent_count__gt=0)
-        elif sort == 'avgtime':
-            group_list = group_list.filter(time_spent_count__gt=0)
+        results = search.query(**query_kwargs)
 
-        group_list = group_list.extra(
-            select={'sort_value': score_clause},
-        )
-
-        return self.paginate(
-            request=request,
-            queryset=group_list,
-            order_by='-sort_value',
-            on_results=lambda x: serialize(x, request.user),
-        )
+        return Response(serialize(list(results), request.user))
diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index 0b62438f4b..a7d4b92a0d 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -473,7 +473,6 @@ SENTRY_IGNORE_EXCEPTIONS = (
     'OperationalError',
 )
 
-
 SENTRY_KEY = None
 
 # Absolute URL to the sentry root directory. Should not include a trailing slash.
diff --git a/src/sentry/constants.py b/src/sentry/constants.py
index 8914388f9e..7c58356200 100644
--- a/src/sentry/constants.py
+++ b/src/sentry/constants.py
@@ -36,44 +36,6 @@ SORT_OPTIONS = SortedDict((
     ('avgtime', _('Average Time Spent')),
 ))
 
-SORT_CLAUSES = {
-    'priority': 'sentry_groupedmessage.score',
-    'date': 'EXTRACT(EPOCH FROM sentry_groupedmessage.last_seen)',
-    'new': 'EXTRACT(EPOCH FROM sentry_groupedmessage.first_seen)',
-    'freq': 'sentry_groupedmessage.times_seen',
-    'tottime': 'sentry_groupedmessage.time_spent_total',
-    'avgtime': '(sentry_groupedmessage.time_spent_total / sentry_groupedmessage.time_spent_count)',
-}
-SCORE_CLAUSES = SORT_CLAUSES.copy()
-
-SQLITE_SORT_CLAUSES = SORT_CLAUSES.copy()
-SQLITE_SORT_CLAUSES.update({
-    'date': "(julianday(sentry_groupedmessage.last_seen) - 2440587.5) * 86400.0",
-    'new': "(julianday(sentry_groupedmessage.first_seen) - 2440587.5) * 86400.0",
-})
-SQLITE_SCORE_CLAUSES = SQLITE_SORT_CLAUSES.copy()
-
-MYSQL_SORT_CLAUSES = SORT_CLAUSES.copy()
-MYSQL_SORT_CLAUSES.update({
-    'date': 'UNIX_TIMESTAMP(sentry_groupedmessage.last_seen)',
-    'new': 'UNIX_TIMESTAMP(sentry_groupedmessage.first_seen)',
-})
-MYSQL_SCORE_CLAUSES = MYSQL_SORT_CLAUSES.copy()
-
-ORACLE_SORT_CLAUSES = SCORE_CLAUSES.copy()
-ORACLE_SORT_CLAUSES.update({
-    'date': "(cast(sentry_groupedmessage.last_seen as date)-TO_DATE('01/01/1970 00:00:00', 'MM-DD-YYYY HH24:MI:SS')) * 24 * 60 * 60",
-    'new': "(cast(sentry_groupedmessage.first_seen as date)-TO_DATE('01/01/1970 00:00:00', 'MM-DD-YYYY HH24:MI:SS')) * 24 * 60 * 60",
-})
-ORACLE_SCORE_CLAUSES = ORACLE_SORT_CLAUSES.copy()
-
-MSSQL_SORT_CLAUSES = SCORE_CLAUSES.copy()
-MSSQL_SORT_CLAUSES.update({
-    'date': "DATEDIFF(s, '1970-01-01T00:00:00', sentry_groupedmessage.last_seen)",
-    'new': "DATEDIFF(s, '1970-01-01T00:00:00', sentry_groupedmessage.first_seen)",
-})
-MSSQL_SCORE_CLAUSES = MSSQL_SORT_CLAUSES.copy()
-
 SEARCH_SORT_OPTIONS = SortedDict((
     ('score', _('Score')),
     ('date', _('Last Seen')),
@@ -202,9 +164,6 @@ EVENTS_PER_PAGE = 15
 # Default sort option for the group stream
 DEFAULT_SORT_OPTION = 'date'
 
-# Default sort option for the search results
-SEARCH_DEFAULT_SORT_OPTION = 'date'
-
 # Setup languages for only available locales
 LANGUAGE_MAP = dict(settings.LANGUAGES)
 LANGUAGES = [(k, LANGUAGE_MAP[k]) for k in get_all_languages() if k in LANGUAGE_MAP]
diff --git a/src/sentry/filters/__init__.py b/src/sentry/filters/__init__.py
index 9e8c818793..5694e6fcfc 100644
--- a/src/sentry/filters/__init__.py
+++ b/src/sentry/filters/__init__.py
@@ -8,7 +8,6 @@ sentry.filters
 
 from sentry.filters.base import *  # NOQA
 from sentry.filters.builtins import *  # NOQA
-from sentry.filters.helpers import *  # NOQA
 from sentry.filters.widgets import *  # NOQA
 
 # Backwards compatibility
diff --git a/src/sentry/filters/base.py b/src/sentry/filters/base.py
index 647b4136f9..98f187c5af 100644
--- a/src/sentry/filters/base.py
+++ b/src/sentry/filters/base.py
@@ -29,9 +29,13 @@ class Filter(object):
     show_label = True
     max_choices = 50
 
-    def __init__(self, request, project):
+    def __init__(self, request, project, label=None, column=None):
         self.request = request
         self.project = project
+        if label is not None:
+            self.label = label
+        if column is not None:
+            self.column = column
 
     def is_set(self):
         return bool(self.get_value())
@@ -71,10 +75,6 @@ class Filter(object):
             cache.set(key, result, 60)
         return SortedDict((l, l) for l in result)
 
-    def get_query_set(self, queryset):
-        kwargs = {self.column: self.get_value()}
-        return queryset.filter(**kwargs)
-
     def process(self, data):
         """``self.request`` is not available within this method"""
         return data
@@ -82,13 +82,3 @@ class Filter(object):
     def render(self):
         widget = self.get_widget()
         return widget.render(self.get_value())
-
-
-class TagFilter(Filter):
-    def get_query_set(self, queryset):
-        col, val = self.get_column(), self.get_value()
-        queryset = queryset.filter(**dict(
-            grouptag__key=col,
-            grouptag__value=val,
-        ))
-        return queryset.distinct()
diff --git a/src/sentry/filters/helpers.py b/src/sentry/filters/helpers.py
deleted file mode 100644
index 5c3dbec364..0000000000
--- a/src/sentry/filters/helpers.py
+++ /dev/null
@@ -1,66 +0,0 @@
-"""
-sentry.filters.helpers
-~~~~~~~~~~~~~~~~~~~~~~
-
-:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-
-# Widget api is pretty ugly
-from __future__ import absolute_import
-
-__all__ = ('get_filters',)
-
-import logging
-
-from django.conf import settings
-from sentry.constants import TAG_LABELS
-from sentry.filters.base import TagFilter
-from sentry.plugins import plugins
-from sentry.utils.safe import safe_execute
-
-
-FILTER_CACHE = {}
-TAG_FILTER_CACHE = {}
-
-
-def get_filters(model=None, project=None):
-    filter_list = []
-
-    # Add builtins (specified with the FILTERS setting)
-    for class_path in settings.SENTRY_FILTERS:
-        if class_path not in FILTER_CACHE:
-            module_name, class_name = class_path.rsplit('.', 1)
-            try:
-                module = __import__(module_name, {}, {}, class_name)
-                cls = getattr(module, class_name)
-            except Exception:
-                logger = logging.getLogger('sentry.errors.filters')
-                logger.exception('Unable to import %s', class_path)
-                continue
-            FILTER_CACHE[class_path] = cls
-        filter_list.append(FILTER_CACHE[class_path])
-
-    if project:
-        for tag in project.get_tags():
-            if tag not in TAG_FILTER_CACHE:
-                # Generate a new filter class because we are lazy and do
-                # not want to rewrite code
-                class new(TagFilter):
-                    label = TAG_LABELS.get(tag) or tag.replace('_', ' ').title()
-                    column = tag
-                new.__name__ = '__%sGeneratedFilter' % tag.encode('utf8')
-                TAG_FILTER_CACHE[tag] = new
-            filter_list.append(TAG_FILTER_CACHE[tag])
-
-    # Add plugin-provided filters
-    for plugin in plugins.for_project(project):
-        results = safe_execute(plugin.get_filters, project)
-        if results:
-            for filter_cls in results:
-                if filter_cls not in filter_list:
-                    filter_list.append(filter_cls)
-
-    # yield all filters which support ``model``
-    for filter_cls in filter_list:
-        yield filter_cls
diff --git a/src/sentry/manager.py b/src/sentry/manager.py
index 2a96fab429..54da6bb88e 100644
--- a/src/sentry/manager.py
+++ b/src/sentry/manager.py
@@ -310,8 +310,7 @@ class GroupManager(BaseManager):
                 is_regression=is_regression,
             )
 
-        if getattr(settings, 'SENTRY_INDEX_SEARCH', settings.SENTRY_USE_SEARCH):
-            index_event.delay(event)
+        index_event.delay(event)
 
         # TODO: move this to the queue
         if is_new and not raw:
diff --git a/src/sentry/plugins/base.py b/src/sentry/plugins/base.py
index a191f3ff2a..037cdae09b 100644
--- a/src/sentry/plugins/base.py
+++ b/src/sentry/plugins/base.py
@@ -499,17 +499,6 @@ class IPlugin(local):
         >>>     return [('tag-name', 'tag-value')]
         """
 
-    def get_filters(self, project=None, **kwargs):
-        """
-        Provides additional filters to the builtins.
-
-        Must return an iterable.
-
-        >>> def get_filters(self, project, **kwargs):
-        >>>     return [MyFilterClass]
-        """
-        return []
-
     def get_notification_forms(self, **kwargs):
         """
         Provides additional UserOption forms for the Notification Settings page.
diff --git a/src/sentry/search/base.py b/src/sentry/search/base.py
index 1701d96e61..b136af0d0e 100644
--- a/src/sentry/search/base.py
+++ b/src/sentry/search/base.py
@@ -8,16 +8,61 @@ sentry.search.base
 
 from __future__ import absolute_import
 
+from collections import Sequence
+
+
+class SearchResult(Sequence):
+    def __init__(self, id_list=None, instances=None):
+        assert not (id_list and instances), \
+            'pass either id_list or instances, not both'
+        self._id_list = id_list
+        self._result_cache = instances
+
+    def __len__(self):
+        if self._result_cache is None:
+            self._populate_result_cache()
+        return len(self._result_cache)
+
+    def __iter__(self):
+        if self._result_cache is None:
+            self._populate_result_cache()
+        return iter(self._result_cache)
+
+    def __getitem__(self, key):
+        if self._result_cache is None:
+            self._populate_result_cache()
+        return self._result_cache[key]
+
+    def __repr__(self):
+        return '<%s: ids=%s>' % (type(self).__name__, self._id_list)
+
+    def _populate_result_cache(self):
+        from sentry.models import Group
+
+        id_list = self._id_list
+        group_map = Group.objects.in_bulk(id_list)
+
+        results = []
+        for g_id in id_list:
+            try:
+                results.append(group_map[g_id])
+            except KeyError:
+                pass
+
+        self._result_cache = results
+
 
 class SearchBackend(object):
     def __init__(self, **options):
         pass
 
-    def index(self, group, event):
-        pass
-
-    def remove(self, group):
-        pass
+    def index(self, event):
+        raise NotImplementedError
 
-    def query(self, **kwargs):
+    def query(self, project, query=None, status=None, tags=None,
+              bookmarked_by=None, sort_by='date', date_filter='last_seen',
+              date_from=None, date_to=None, cursor=None):
         raise NotImplementedError
+
+    def upgrade(self):
+        pass
diff --git a/src/sentry/search/django/backend.py b/src/sentry/search/django/backend.py
index cf0b5de150..0511518f62 100644
--- a/src/sentry/search/django/backend.py
+++ b/src/sentry/search/django/backend.py
@@ -8,136 +8,99 @@ sentry.search.django.backend
 
 from __future__ import absolute_import
 
-import re
-import itertools
-
-from collections import defaultdict
-
-from django.utils.encoding import force_unicode
-
-from sentry.search.base import SearchBackend
-
-# Words which should not be indexed
-STOP_WORDS = set(['the', 'of', 'to', 'and', 'a', 'in', 'is', 'it', 'you', 'that'])
-
-# Do not index any words shorter than this
-MIN_WORD_LENGTH = 3
-
-# Consider these characters to be punctuation (they will be replaced with spaces prior to word extraction)
-PUNCTUATION_CHARS = re.compile('[%s]' % re.escape(".,;:!?@$%^&*()-<>[]{}\\|/`~'\""))
+from sentry.search.base import SearchBackend, SearchResult
+from sentry.search.django.constants import (
+    SORT_CLAUSES, SCORE_CLAUSES,
+    SQLITE_SORT_CLAUSES, SQLITE_SCORE_CLAUSES,
+    MYSQL_SORT_CLAUSES, MYSQL_SCORE_CLAUSES,
+    MSSQL_SORT_CLAUSES, MSSQL_SCORE_CLAUSES, MSSQL_ENGINES,
+    ORACLE_SORT_CLAUSES, ORACLE_SCORE_CLAUSES
+)
+from sentry.utils.db import get_db_engine
 
 
 class DjangoSearchBackend(SearchBackend):
-    def _tokenize(self, text):
-        """
-        Given a string, returns a list of tokens.
-        """
-        if not text:
-            return []
-
-        text = PUNCTUATION_CHARS.sub(' ', text)
-
-        words = [
-            t[:128].lower() for t in text.split()
-            if len(t) >= MIN_WORD_LENGTH and t.lower() not in STOP_WORDS
-        ]
-
-        return words
-
-    def index(self, group, event):
-        from sentry import app
-        from sentry.search.django.models import SearchDocument, SearchToken
-
-        document, created = SearchDocument.objects.get_or_create(
-            project=event.project,
-            group=group,
-            defaults={
-                'status': group.status,
-                'total_events': 1,
-                'date_added': group.first_seen,
-                'date_changed': group.last_seen,
-            }
-        )
-        if not created:
-            app.buffer.incr(SearchDocument, {
-                'total_events': 1,
-            }, {
-                'id': document.id,
-            }, {
-                'date_changed': group.last_seen,
-                'status': group.status,
-            })
-
-            document.total_events += 1
-            document.date_changed = group.last_seen
-            document.status = group.status
-
-        context = defaultdict(list)
-        context['text'].append(event.message)
-
-        token_counts = defaultdict(lambda: defaultdict(int))
-        for field, values in context.iteritems():
-            field = field.lower()
-            if field == 'text':
-                # we only tokenize the base text field
-                values = itertools.chain(*[self._tokenize(force_unicode(v)) for v in values])
-            else:
-                values = [v.lower() for v in values]
-            for value in values:
-                if not value:
-                    continue
-                token_counts[field][value] += 1
-
-        for field, tokens in token_counts.iteritems():
-            for token, count in tokens.iteritems():
-                app.buffer.incr(SearchToken, {
-                    'times_seen': count,
-                }, {
-                    'document': document,
-                    'token': token,
-                    'field': field,
-                })
-
-        return document
-
-    def query(self, project, query, sort_by='score', offset=0, limit=100):
-        from sentry.search.django.models import SearchDocument
-
-        tokens = self._tokenize(query)
-
-        if sort_by == 'score':
-            order_by = 'SUM(st.times_seen) / sd.total_events DESC'
-        elif sort_by == 'new':
-            order_by = 'sd.date_added DESC'
-        elif sort_by == 'date':
-            order_by = 'sd.date_changed DESC'
+    def index(self, event):
+        pass
+
+    def query(self, project, query=None, status=None, tags=None,
+              bookmarked_by=None, sort_by='date', date_filter='last_seen',
+              date_from=None, date_to=None, cursor=None):
+        from sentry.models import Group
+
+        queryset = Group.objects.filter(project=project)
+        if query:
+            queryset = queryset.filter(message__icontains=query)
+
+        if status is not None:
+            queryset = queryset.filter(status=status)
+
+        if bookmarked_by:
+            queryset = queryset.filter(
+                bookmark_set__project=project,
+                bookmark_set__user=bookmarked_by,
+            )
+
+        if tags:
+            for k, v in tags.iteritems():
+                queryset = queryset.filter(**dict(
+                    grouptag__key=k,
+                    grouptag__value=v,
+                ))
+
+        if date_filter == 'first_seen':
+            if date_from:
+                queryset = queryset.filter(first_seen__gte=date_from)
+            elif date_to:
+                queryset = queryset.filter(first_seen__lte=date_to)
+        elif date_filter == 'last_seen':
+            if date_from and date_to:
+                queryset = queryset.filter(
+                    groupcountbyminute__date__gte=date_from,
+                    groupcountbyminute__date__lte=date_to,
+                )
+            elif date_from:
+                queryset = queryset.filter(last_seen__gte=date_from)
+            elif date_to:
+                queryset = queryset.filter(last_seen__lte=date_to)
+
+        engine = get_db_engine('default')
+        if engine.startswith('sqlite'):
+            score_clause = SQLITE_SORT_CLAUSES.get(sort_by)
+            filter_clause = SQLITE_SCORE_CLAUSES.get(sort_by)
+        elif engine.startswith('mysql'):
+            score_clause = MYSQL_SORT_CLAUSES.get(sort_by)
+            filter_clause = MYSQL_SCORE_CLAUSES.get(sort_by)
+        elif engine.startswith('oracle'):
+            score_clause = ORACLE_SORT_CLAUSES.get(sort_by)
+            filter_clause = ORACLE_SCORE_CLAUSES.get(sort_by)
+        elif engine in MSSQL_ENGINES:
+            score_clause = MSSQL_SORT_CLAUSES.get(sort_by)
+            filter_clause = MSSQL_SCORE_CLAUSES.get(sort_by)
         else:
-            raise ValueError('sort_by: %r' % sort_by)
+            score_clause = SORT_CLAUSES.get(sort_by)
+            filter_clause = SCORE_CLAUSES.get(sort_by)
+
+        if sort_by == 'tottime':
+            queryset = queryset.filter(time_spent_count__gt=0)
+        elif sort_by == 'avgtime':
+            queryset = queryset.filter(time_spent_count__gt=0)
+
+        if score_clause:
+            queryset = queryset.extra(
+                select={'sort_value': score_clause},
+            )
+            # HACK: don't sort by the same column twice
+            if sort_by == 'date':
+                queryset = queryset.order_by('-last_seen')
+            else:
+                queryset = queryset.order_by('-sort_value', '-last_seen')
 
-        if tokens:
-            token_sql = ' st.token IN (%s) AND ' % \
-                ', '.join('%s' for i in range(len(tokens)))
-        else:
-            token_sql = ' '
-
-        sql = """
-            SELECT sd.*,
-                   SUM(st.times_seen) / sd.total_events as score
-            FROM sentry_searchdocument as sd
-            INNER JOIN sentry_searchtoken as st
-                ON st.document_id = sd.id
-            WHERE %s
-                sd.project_id = %s
-            GROUP BY sd.id, sd.group_id, sd.total_events, sd.date_changed, sd.date_added, sd.project_id, sd.status
-            ORDER BY %s
-            LIMIT %d OFFSET %d
-        """ % (
-            token_sql,
-            project.id,
-            order_by,
-            limit,
-            offset,
-        )
-        params = tokens
-
-        return list(SearchDocument.objects.raw(sql, params))
+            if cursor:
+                queryset = queryset.extra(
+                    where=['%s > %%s' % filter_clause],
+                    params=[float(cursor)],
+                )
+
+        # HACK:
+        return SearchResult(instances=list(queryset))
diff --git a/src/sentry/search/django/constants.py b/src/sentry/search/django/constants.py
new file mode 100644
index 0000000000..4e6cd80a32
--- /dev/null
+++ b/src/sentry/search/django/constants.py
@@ -0,0 +1,49 @@
+"""
+sentry.search.django.constants
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from __future__ import absolute_import
+
+
+SORT_CLAUSES = {
+    'priority': 'sentry_groupedmessage.score',
+    'date': 'EXTRACT(EPOCH FROM sentry_groupedmessage.last_seen)',
+    'new': 'EXTRACT(EPOCH FROM sentry_groupedmessage.first_seen)',
+    'freq': 'sentry_groupedmessage.times_seen',
+    'tottime': 'sentry_groupedmessage.time_spent_total',
+    'avgtime': '(sentry_groupedmessage.time_spent_total / sentry_groupedmessage.time_spent_count)',
+}
+SCORE_CLAUSES = SORT_CLAUSES.copy()
+
+SQLITE_SORT_CLAUSES = SORT_CLAUSES.copy()
+SQLITE_SORT_CLAUSES.update({
+    'date': "(julianday(sentry_groupedmessage.last_seen) - 2440587.5) * 86400.0",
+    'new': "(julianday(sentry_groupedmessage.first_seen) - 2440587.5) * 86400.0",
+})
+SQLITE_SCORE_CLAUSES = SQLITE_SORT_CLAUSES.copy()
+
+MYSQL_SORT_CLAUSES = SORT_CLAUSES.copy()
+MYSQL_SORT_CLAUSES.update({
+    'date': 'UNIX_TIMESTAMP(sentry_groupedmessage.last_seen)',
+    'new': 'UNIX_TIMESTAMP(sentry_groupedmessage.first_seen)',
+})
+MYSQL_SCORE_CLAUSES = MYSQL_SORT_CLAUSES.copy()
+
+ORACLE_SORT_CLAUSES = SCORE_CLAUSES.copy()
+ORACLE_SORT_CLAUSES.update({
+    'date': "(cast(sentry_groupedmessage.last_seen as date)-TO_DATE('01/01/1970 00:00:00', 'MM-DD-YYYY HH24:MI:SS')) * 24 * 60 * 60",
+    'new': "(cast(sentry_groupedmessage.first_seen as date)-TO_DATE('01/01/1970 00:00:00', 'MM-DD-YYYY HH24:MI:SS')) * 24 * 60 * 60",
+})
+ORACLE_SCORE_CLAUSES = ORACLE_SORT_CLAUSES.copy()
+
+MSSQL_SORT_CLAUSES = SCORE_CLAUSES.copy()
+MSSQL_SORT_CLAUSES.update({
+    'date': "DATEDIFF(s, '1970-01-01T00:00:00', sentry_groupedmessage.last_seen)",
+    'new': "DATEDIFF(s, '1970-01-01T00:00:00', sentry_groupedmessage.first_seen)",
+})
+MSSQL_SCORE_CLAUSES = MSSQL_SORT_CLAUSES.copy()
+MSSQL_ENGINES = set(['django_pytds', 'sqlserver_ado', 'sql_server.pyodbc'])
diff --git a/src/sentry/search/elastic_search/__init__.py b/src/sentry/search/elastic_search/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/src/sentry/search/elastic_search/backend.py b/src/sentry/search/elastic_search/backend.py
new file mode 100644
index 0000000000..ada8bc25f3
--- /dev/null
+++ b/src/sentry/search/elastic_search/backend.py
@@ -0,0 +1,156 @@
+'''
+sentry.search.elastic_search.backend
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+
+
+GET /_search
+{
+  'query': {
+    'bool': {
+      'must': [
+        { 'match': {
+            'title':  {
+              'query': 'War and Peace',
+              'boost': 2
+        }}},
+      ]
+    }
+  }
+}
+
+- has_child query
+- curator (rotate indexes/etc)
+- index templates
+- allocate 50% memory to ES (needs file cache)
+- aggregates/graph?
+- allocation/routing for cluster key
+- snapshots
+- kopf plugin
+- kibana/marvel
+
+'''
+
+from __future__ import absolute_import
+
+from elasticsearch import Elasticsearch
+
+from sentry.search.base import SearchBackend, SearchResult
+
+
+class ElasticSearchBackend(SearchBackend):
+    def __init__(self, hosts=None, index_prefix='', **options):
+        self.index_prefix = index_prefix
+        self.backend = Elasticsearch(hosts, **options)
+
+    def _get_index(self, group):
+        return self.index_prefix + 'sentry-1'
+
+    def index(self, group, event):
+        data = {
+            'message': group.message,
+            'project_id': group.project_id,
+            'first_seen': group.first_seen,
+            'last_seen': group.last_seen,
+            'status': group.status,
+        }
+
+        self.backend.index(
+            index=self._get_index(group),
+            doc_type='group',
+            id=group.id,
+            body=data,
+        )
+
+        data = dict(
+            ('tag:{0}'.format(k), v)
+            for k, v in event.get_tags()
+        )
+
+        self.backend.index(
+            index=self._get_index(group),
+            doc_type='event',
+            id=event.event_id,
+            body=data,
+            parent=group.id,
+        )
+
+    def query(self, project, query=None, status=None, tags=None,
+              bookmarked_by=None, sort_by='date', date_filter='last_seen',
+              date_from=None, date_to=None, cursor=None):
+        query_body = {
+            'filter': {
+                'and': [
+                    {'term': {'project_id': project.id}},
+                ],
+            },
+        }
+        if query:
+            query_body['query'] = {'match': {'message': query}}
+
+        if status is not None:
+            query_body['filter']['and'].append({'term': {'status': status}})
+
+        if tags:
+            # TODO(dcramer): filter might be too expensive here, need to confirm
+            query_body['filter']['and'].append({'has_child': {
+                'type': 'event',
+                'filter': {
+                    'and': [
+                        {'term': {'tag:{0}'.format(k): v}}
+                        for k, v in tags.iteritems()
+                    ]
+                },
+            }})
+
+        results = self.backend.search(
+            index=self.index_prefix + 'sentry-1',
+            doc_type='group',
+            body={
+                'query': {'filtered': query_body},
+                'sort': [
+                    {'last_seen': {'order': 'desc'}},
+                ],
+            },
+        )
+        if not results.get('hits'):
+            return SearchResult([])
+        return SearchResult([int(n['_id']) for n in results['hits']['hits']])
+
+    def upgrade(self):
+        self.backend.indices.put_template(
+            name='sentry',
+            body={
+                'template': self.index_prefix + 'sentry-*',
+                'mappings': {
+                    'group': {
+                        '_source': {'enabled': False},
+                        '_routing': {
+                            'required': True,
+                            'path': 'project_id',
+                        },
+                        'message': {
+                            'type': 'string',
+                        },
+                        'project_id': {
+                            'type': 'long',
+                            'index': 'not_analyzed',
+                        },
+                        'first_seen': {
+                            'type': 'date',
+                        },
+                        'last_seen': {
+                            'type': 'date',
+                        },
+                    },
+                    'event': {
+                        '_source': {'enabled': False},
+                        '_parent': {
+                            'type': 'group',
+                        },
+                    }
+                },
+            },
+        )
diff --git a/src/sentry/tasks/index.py b/src/sentry/tasks/index.py
index 0240939a5b..381c5225d4 100644
--- a/src/sentry/tasks/index.py
+++ b/src/sentry/tasks/index.py
@@ -15,4 +15,4 @@ from sentry.tasks.base import instrumented_task
 def index_event(event, **kwargs):
     from sentry import app
 
-    app.search.index(event.group, event)
+    app.search.index(event)
diff --git a/src/sentry/templates/sentry/bases/stream.html b/src/sentry/templates/sentry/bases/stream.html
index 13fe390791..f9b0cc4a83 100644
--- a/src/sentry/templates/sentry/bases/stream.html
+++ b/src/sentry/templates/sentry/bases/stream.html
@@ -6,8 +6,8 @@
 
 {% block page_header %}
     <div class="pull-right">
-        <form action="{% url 'sentry-search' project.team.slug project.slug %}" id="search">
-            <input type="text" name="q" value="{% if query %}{{ query }}{% endif %}" placeholder="{% if HAS_SEARCH %}{% trans "Search query or event ID" %}{% else %}{% trans "Event ID" %}{% endif %}" />
+        <form action="{% url 'sentry-stream' project.team.slug project.slug %}" id="search">
+            <input type="text" name="query" value="{% if query %}{{ query }}{% endif %}" placeholder="{% trans "Search query or event ID" %}" />
         </form>
     </div>
 
diff --git a/src/sentry/templates/sentry/groups/group_list.html b/src/sentry/templates/sentry/groups/group_list.html
index 38fc062844..8c423a414a 100644
--- a/src/sentry/templates/sentry/groups/group_list.html
+++ b/src/sentry/templates/sentry/groups/group_list.html
@@ -3,6 +3,7 @@
 {% load i18n %}
 {% load sentry_helpers %}
 {% load sentry_plugins %}
+{% load sentry_stream_filters %}
 
 {% block sidebar %}
     <div id="chart" class="chart" data-api-url="{% url 'sentry-api-0-project-stats' project.id %}" data-days="1">
@@ -24,7 +25,7 @@
             </div>
         {% endif %}
 
-        {% for filter in filters %}
+        {% for filter in project|get_filters:request %}
             {% if filter.show_label %}
                 <h6>{% trans filter.label %}</h6>
             {% endif %}
diff --git a/src/sentry/templates/sentry/invalid_message_id.html b/src/sentry/templates/sentry/invalid_message_id.html
deleted file mode 100644
index 7f2a6c6b37..0000000000
--- a/src/sentry/templates/sentry/invalid_message_id.html
+++ /dev/null
@@ -1,11 +0,0 @@
-{% extends "sentry/search.html" %}
-
-{% load i18n %}
-
-{% block title %}{% trans "Search" %} | {{ block.super }}{% endblock %}
-
-{% block main %}
-    <section class="body">
-        <p>{% trans "We were unable to find a message matching the ID you entered." %}</p>
-    </section>
-{% endblock %}
diff --git a/src/sentry/templates/sentry/search.html b/src/sentry/templates/sentry/search.html
deleted file mode 100644
index 6b33da921e..0000000000
--- a/src/sentry/templates/sentry/search.html
+++ /dev/null
@@ -1,42 +0,0 @@
-{% extends "sentry/bases/stream.html" %}
-
-{% load i18n %}
-{% load sentry_helpers %}
-{% load sentry_plugins %}
-
-{% block heading %}{% trans "Search" %}{% endblock %}
-
-{% block main %}
-    {% querystring from request without sort as sort_querystring %}
-
-    <div class="btn-toolbar">
-        <div class="btn-group">
-            <a href="#" class="btn dropdown-toggle" data-toggle="dropdown">{% blocktrans with sort_label as label %}Sort by: {{ label }}{% endblocktrans %} <span class="caret"></span></a>
-            <ul class="dropdown-menu">
-                <li{% ifequal sort 'date' %} class="active"{% endifequal %}><a href="?{{ sort_querystring }}&amp;sort=date">{% trans "Last Seen" %}</a></li>
-                <li{% ifequal sort 'score' %} class="active"{% endifequal %}><a href="?{{ sort_querystring }}&amp;sort=score">{% trans "Score" %}</a></li>
-                <li{% ifequal sort 'new' %} class="active"{% endifequal %}><a href="?{{ sort_querystring }}&amp;sort=new">{% trans "First Seen" %}</a></li>
-            </ul>
-        </div>
-    </div>
-
-    {% if event_list %}
-        {% handle_before_events request event_list %}
-        <ul class="events" id="event_list">
-            {% for group, metadata in event_list|with_metadata:request %}
-                {% include "sentry/partial/_group.html" %}
-            {% endfor %}
-        </ul>
-    {% else %}
-        <ul class="events" id="event_list">
-            <li class="empty-result" id="no_messages">{% trans "No events match your search query." %}</li>
-        </ul>
-    {% endif %}
-
-    <div class="btn-toolbar">
-        <div class="btn-group pull-right">
-            <a class="btn prev disabled"><span>{% trans "Previous" %}</span></a>
-            <a class="btn next disabled"><span>{% trans "Next" %}</span></a>
-        </div>
-    </div>
-{% endblock %}
diff --git a/src/sentry/templatetags/sentry_stream_filters.py b/src/sentry/templatetags/sentry_stream_filters.py
new file mode 100644
index 0000000000..5cab148232
--- /dev/null
+++ b/src/sentry/templatetags/sentry_stream_filters.py
@@ -0,0 +1,42 @@
+"""
+sentry.templatetags.sentry_stream_filters
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+from __future__ import absolute_import
+
+import logging
+
+from django import template
+from django.conf import settings
+from sentry.constants import TAG_LABELS
+from sentry.filters.base import Filter
+from sentry.utils.imports import import_string
+
+register = template.Library()
+
+
+@register.filter
+def get_filters(project, request):
+    filter_list = []
+
+    for class_path in settings.SENTRY_FILTERS:
+        try:
+            filter_cls = import_string(class_path)
+        except Exception:
+            logger = logging.getLogger('sentry.errors.filters')
+            logger.exception('Unable to import %s', class_path)
+            continue
+        filter_list.append(filter_cls(request, project))
+
+    for tag in project.get_tags():
+        filter_list.append(Filter(
+            column=tag,
+            label=TAG_LABELS.get(tag) or tag.replace('_', ' ').title(),
+            request=request,
+            project=project,
+        ))
+
+    return filter_list
diff --git a/src/sentry/testutils/fixtures.py b/src/sentry/testutils/fixtures.py
index 10cc4f24da..f636ba699d 100644
--- a/src/sentry/testutils/fixtures.py
+++ b/src/sentry/testutils/fixtures.py
@@ -105,6 +105,11 @@ class Fixtures(object):
         kwargs.setdefault('project', kwargs['group'].project)
         kwargs.setdefault('message', kwargs['group'].message)
         kwargs.setdefault('data', LEGACY_DATA)
+        if kwargs.get('tags'):
+            tags = kwargs.pop('tags')
+            if isinstance(tags, dict):
+                tags = tags.items()
+            kwargs['data']['tags'] = tags
 
         return Event.objects.create(
             event_id=event_id,
diff --git a/src/sentry/testutils/skips.py b/src/sentry/testutils/skips.py
index 4f7befc4f8..9d8513fd80 100644
--- a/src/sentry/testutils/skips.py
+++ b/src/sentry/testutils/skips.py
@@ -6,11 +6,11 @@ sentry.testutils.skips
 :license: BSD, see LICENSE for more details.
 """
 
+import socket
 import pytest
 
 
 def riak_is_available():
-    import socket
     try:
         socket.create_connection(('127.0.0.1', 8098), 1.0)
     except socket.error:
@@ -25,7 +25,6 @@ requires_riak = pytest.mark.skipif(
 
 
 def cassandra_is_available():
-    import socket
     try:
         socket.create_connection(('127.0.0.1', 9042), 1.0)
     except socket.error:
@@ -37,3 +36,17 @@ def cassandra_is_available():
 requires_cassandra = pytest.mark.skipif(
     lambda x: not cassandra_is_available(),
     reason="requires cassandra server running")
+
+
+def elastic_search_is_available():
+    try:
+        socket.create_connection(('127.0.0.1', 9200), 1.0)
+    except socket.error:
+        return False
+    else:
+        return True
+
+
+requires_elastic_search = pytest.mark.skipif(
+    lambda x: not elastic_search_is_available(),
+    reason="requires elastic search server running")
diff --git a/src/sentry/web/frontend/groups.py b/src/sentry/web/frontend/groups.py
index 7945cf622f..feb85e8485 100644
--- a/src/sentry/web/frontend/groups.py
+++ b/src/sentry/web/frontend/groups.py
@@ -12,10 +12,8 @@ TODO: Move all events.py views into here, and rename this file to events.
 from __future__ import division
 
 import datetime
-import logging
 import re
 
-from django.conf import settings
 from django.core.urlresolvers import reverse
 from django.http import HttpResponse, HttpResponseRedirect, Http404
 from django.shortcuts import get_object_or_404
@@ -23,15 +21,9 @@ from django.utils import timezone
 
 from sentry import app
 from sentry.constants import (
-    SORT_OPTIONS, SEARCH_SORT_OPTIONS, SORT_CLAUSES,
-    MYSQL_SORT_CLAUSES, SQLITE_SORT_CLAUSES, MEMBER_USER,
-    SCORE_CLAUSES, MYSQL_SCORE_CLAUSES, SQLITE_SCORE_CLAUSES,
-    ORACLE_SORT_CLAUSES, ORACLE_SCORE_CLAUSES,
-    MSSQL_SORT_CLAUSES, MSSQL_SCORE_CLAUSES, DEFAULT_SORT_OPTION,
-    SEARCH_DEFAULT_SORT_OPTION, MAX_JSON_RESULTS
+    SORT_OPTIONS, MEMBER_USER, MAX_JSON_RESULTS, DEFAULT_SORT_OPTION
 )
 from sentry.db.models import create_or_update
-from sentry.filters import get_filters
 from sentry.models import (
     Project, Group, Event, Activity, EventMapping, TagKey, GroupSeen
 )
@@ -39,7 +31,6 @@ from sentry.permissions import can_admin_group, can_create_projects
 from sentry.plugins import plugins
 from sentry.utils import json
 from sentry.utils.dates import parse_date
-from sentry.utils.db import get_db_engine
 from sentry.web.decorators import has_access, has_group_access, login_required
 from sentry.web.forms import NewNoteForm
 from sentry.web.helpers import render_to_response, group_is_public
@@ -49,40 +40,58 @@ event_re = re.compile(r'^(?P<event_id>[a-z0-9]{32})\$(?P<checksum>[a-z0-9]{32})$
 
 
 def _get_group_list(request, project):
-    filters = []
-    for cls in get_filters(Group, project):
+    query_kwargs = {
+        'project': project,
+    }
+
+    query = request.GET.get('query')
+    if query and uuid_re.match(query):
+        # Forward to event if it exists
         try:
-            filters.append(cls(request, project))
-        except Exception as e:
-            logger = logging.getLogger('sentry.filters')
-            logger.exception('Error initializing filter %r: %s', cls, e)
+            group_id = EventMapping.objects.filter(
+                project=project, event_id=query
+            ).values('group', flat=True)[0]
+        except EventMapping.DoesNotExist:
+            pass
+        else:
+            return HttpResponseRedirect(reverse('sentry-group', kwargs={
+                'project_id': project.slug,
+                'team_slug': project.team.slug,
+                'group_id': group_id,
+            }))
+    elif query:
+        query_kwargs['query'] = query
+
+    if request.GET.get('status'):
+        query_kwargs['status'] = int(request.GET['status'])
 
-    event_list = Group.objects
     if request.user.is_authenticated() and request.GET.get('bookmarks'):
-        event_list = event_list.filter(
-            bookmark_set__project=project,
-            bookmark_set__user=request.user,
-        )
-    else:
-        event_list = event_list.filter(project=project)
+        query_kwargs['bookmarked_by'] = request.user
 
-    for filter_ in filters:
-        try:
-            if not filter_.is_set():
-                continue
-            event_list = filter_.get_query_set(event_list)
-        except Exception as e:
-            logger = logging.getLogger('sentry.filters')
-            logger.exception('Error processing filter %r: %s', cls, e)
+    sort_by = request.GET.get('sort') or request.session.get('streamsort')
+    if sort_by is None:
+        sort_by = DEFAULT_SORT_OPTION
+
+    # Save last sort in session
+    if sort_by != request.session.get('streamsort'):
+        request.session['streamsort'] = sort_by
+
+    query_kwargs['sort_by'] = sort_by
+
+    tags = {}
+    for tag_key in TagKey.objects.all_keys(project):
+        if request.GET.get(tag_key):
+            tags[tag_key] = request.GET[tag_key]
+    if tags:
+        query_kwargs['tags'] = tags
 
     date_from = request.GET.get('df')
     time_from = request.GET.get('tf')
     date_to = request.GET.get('dt')
     time_to = request.GET.get('tt')
-    date_type = request.GET.get('date_type')
+    date_filter = request.GET.get('date_type')
 
     today = timezone.now()
-
     # date format is Y-m-d
     if any(x is not None for x in [date_from, time_from, date_to, time_to]):
         date_from, date_to = parse_date(date_from, time_from), parse_date(date_to, time_to)
@@ -90,78 +99,24 @@ def _get_group_list(request, project):
         date_from = today - datetime.timedelta(days=5)
         date_to = None
 
-    if date_type == 'first_seen':
-        if date_from:
-            event_list = event_list.filter(first_seen__gte=date_from)
-        elif date_to:
-            event_list = event_list.filter(first_seen__lte=date_to)
-    else:
-        if date_from and date_to:
-            event_list = event_list.filter(
-                first_seen__gte=date_from,
-                last_seen__lte=date_to,
-            )
-        elif date_from:
-            event_list = event_list.filter(last_seen__gte=date_from)
-        elif date_to:
-            event_list = event_list.filter(last_seen__lte=date_to)
-
-    sort = request.GET.get('sort') or request.session.get('streamsort')
-    if sort not in SORT_OPTIONS:
-        sort = DEFAULT_SORT_OPTION
+    query_kwargs['date_from'] = date_from
+    query_kwargs['date_to'] = date_to
+    if date_filter:
+        query_kwargs['date_filter'] = date_filter
 
-    # Save last sort in session
-    if sort != request.session.get('streamsort'):
-        request.session['streamsort'] = sort
-
-    engine = get_db_engine('default')
-    if engine.startswith('sqlite'):
-        score_clause = SQLITE_SORT_CLAUSES.get(sort)
-        filter_clause = SQLITE_SCORE_CLAUSES.get(sort)
-    elif engine.startswith('mysql'):
-        score_clause = MYSQL_SORT_CLAUSES.get(sort)
-        filter_clause = MYSQL_SCORE_CLAUSES.get(sort)
-    elif engine.startswith('oracle'):
-        score_clause = ORACLE_SORT_CLAUSES.get(sort)
-        filter_clause = ORACLE_SCORE_CLAUSES.get(sort)
-    elif engine in ('django_pytds', 'sqlserver_ado', 'sql_server.pyodbc'):
-        score_clause = MSSQL_SORT_CLAUSES.get(sort)
-        filter_clause = MSSQL_SCORE_CLAUSES.get(sort)
-    else:
-        score_clause = SORT_CLAUSES.get(sort)
-        filter_clause = SCORE_CLAUSES.get(sort)
+    cursor = request.GET.get('cursor', request.GET.get('c'))
+    if cursor:
+        query_kwargs['cursor'] = cursor
 
-    # IMPORTANT: All filters must already be applied once we reach this point
-
-    if sort == 'tottime':
-        event_list = event_list.filter(time_spent_count__gt=0)
-    elif sort == 'avgtime':
-        event_list = event_list.filter(time_spent_count__gt=0)
-
-    if score_clause:
-        event_list = event_list.extra(
-            select={'sort_value': score_clause},
-        )
-        # HACK: don't sort by the same column twice
-        if sort == 'date':
-            event_list = event_list.order_by('-last_seen')
-        else:
-            event_list = event_list.order_by('-sort_value', '-last_seen')
-        cursor = request.GET.get('cursor', request.GET.get('c'))
-        if cursor:
-            event_list = event_list.extra(
-                where=['%s > %%s' % filter_clause],
-                params=[float(cursor)],
-            )
+    results = app.search.query(**query_kwargs)
 
     return {
-        'filters': filters,
-        'event_list': event_list,
+        'event_list': results,
         'date_from': date_from,
         'date_to': date_to,
         'today': today,
-        'sort': sort,
-        'date_type': date_type
+        'sort': sort_by,
+        'date_type': date_filter,
     }
 
 
@@ -252,90 +207,6 @@ def wall_display(request, team):
     }, request)
 
 
-@login_required
-@has_access
-def search(request, team, project):
-    query = request.GET.get('q', '').strip()
-
-    if not query:
-        return HttpResponseRedirect(reverse('sentry-stream', args=[team.slug, project.slug]))
-
-    sort = request.GET.get('sort')
-    if sort not in SEARCH_SORT_OPTIONS:
-        sort = SEARCH_DEFAULT_SORT_OPTION
-    sort_label = SEARCH_SORT_OPTIONS[sort]
-
-    result = event_re.match(query)
-    if result:
-        # Forward to aggregate if it exists
-        # event_id = result.group(1)
-        checksum = result.group(2)
-        try:
-            group = Group.objects.filter(project=project, checksum=checksum)[0]
-        except IndexError:
-            return render_to_response('sentry/invalid_message_id.html', {
-                'team': team,
-                'project': project,
-            }, request)
-        else:
-            return HttpResponseRedirect(reverse('sentry-group', kwargs={
-                'project_id': group.project.slug,
-                'team_slug': group.team.slug,
-                'group_id': group.id,
-            }))
-    elif uuid_re.match(query):
-        # Forward to event if it exists
-        try:
-            group_id = EventMapping.objects.get(
-                project=project, event_id=query
-            ).group_id
-        except EventMapping.DoesNotExist:
-            try:
-                event = Event.objects.get(project=project, event_id=query)
-            except Event.DoesNotExist:
-                return render_to_response('sentry/invalid_message_id.html', {
-                    'team': team,
-                    'project': project,
-                }, request)
-            else:
-                return HttpResponseRedirect(reverse('sentry-group-event', kwargs={
-                    'project_id': project.slug,
-                    'team_slug': team.slug,
-                    'group_id': event.group.id,
-                    'event_id': event.id,
-                }))
-        else:
-            return HttpResponseRedirect(reverse('sentry-group', kwargs={
-                'project_id': project.slug,
-                'team_slug': team.slug,
-                'group_id': group_id,
-            }))
-    elif not settings.SENTRY_USE_SEARCH:
-        event_list = Group.objects.none()
-        # return render_to_response('sentry/invalid_message_id.html', {
-        #         'project': project,
-        #     }, request)
-    else:
-        documents = list(app.search.query(project, query, sort_by=sort))
-        groups = Group.objects.in_bulk([d.group_id for d in documents])
-
-        event_list = []
-        for doc in documents:
-            try:
-                event_list.append(groups[doc.group_id])
-            except KeyError:
-                continue
-
-    return render_to_response('sentry/search.html', {
-        'team': project.team,
-        'project': project,
-        'event_list': event_list,
-        'query': query,
-        'sort': sort,
-        'sort_label': sort_label,
-    }, request)
-
-
 @login_required
 @has_access
 def group_list(request, team, project):
@@ -365,7 +236,6 @@ def group_list(request, team, project):
         'today': response['today'],
         'sort': response['sort'],
         'sort_label': sort_label,
-        'filters': response['filters'],
         'SORT_OPTIONS': SORT_OPTIONS,
     }, request)
 
diff --git a/src/sentry/web/helpers.py b/src/sentry/web/helpers.py
index 45644d5fb1..443a90e268 100644
--- a/src/sentry/web/helpers.py
+++ b/src/sentry/web/helpers.py
@@ -99,7 +99,6 @@ def get_default_context(request, existing_context=None, team=None):
     from sentry.plugins import plugins
 
     context = {
-        'HAS_SEARCH': settings.SENTRY_USE_SEARCH,
         'EVENTS_PER_PAGE': EVENTS_PER_PAGE,
         'URL_PREFIX': settings.SENTRY_URL_PREFIX,
         'PLUGINS': plugins,
diff --git a/src/sentry/web/urls.py b/src/sentry/web/urls.py
index a9e71db0a6..dd29b051e2 100644
--- a/src/sentry/web/urls.py
+++ b/src/sentry/web/urls.py
@@ -328,8 +328,6 @@ urlpatterns += patterns('',
         name='sentry-group-tags'),
     url(r'^(?P<team_slug>[\w_-]+)/(?P<project_id>[\w_-]+)/group/(?P<group_id>\d+)/tags/(?P<tag_name>[^/]+)/$', groups.group_tag_details,
         name='sentry-group-tag-details'),
-    url(r'^(?P<team_slug>[\w_-]+)/(?P<project_id>[\w_-]+)/search/$', groups.search,
-        name='sentry-search'),
     url(r'^(?P<team_slug>[\w_-]+)/(?P<project_id>[\w_-]+)/alerts/$', alerts.alert_list,
         name='sentry-alerts'),
     url(r'^(?P<team_slug>[\w_-]+)/(?P<project_id>[\w_-]+)/alerts/(?P<alert_id>\d+)/$', alerts.alert_details,
diff --git a/tests/sentry/search/django/tests.py b/tests/sentry/search/django/tests.py
index 7f3eb61042..75be1e977f 100644
--- a/tests/sentry/search/django/tests.py
+++ b/tests/sentry/search/django/tests.py
@@ -5,36 +5,31 @@ from __future__ import absolute_import
 from exam import fixture
 
 from sentry.search.django.backend import DjangoSearchBackend
-from sentry.testutils import TestCase, assert_date_resembles
+from sentry.testutils import TestCase
 
 
-class SearchIndexTest(TestCase):
+class DjangoSearchTest(TestCase):
     @fixture
     def backend(self):
         return DjangoSearchBackend()
 
-    def test_index_behavior(self):
-        event = self.event
-
-        doc = self.backend.index(event.group, event)
-        assert doc.project == event.project
-        assert doc.group == event.group
-        assert doc.total_events == 1
-        assert_date_resembles(doc.date_added, event.group.first_seen)
-        assert_date_resembles(doc.date_changed, event.group.last_seen)
-
-        doc = self.backend.index(event.group, event)
-        assert doc.project == event.project
-        assert doc.group == event.group
-        assert doc.total_events == 2
-        assert_date_resembles(doc.date_added, event.group.first_seen)
-        assert_date_resembles(doc.date_changed, event.group.last_seen)
-
-    def test_search(self):
-        event = self.event
-        doc = self.backend.index(event.group, event)
+    def test_simple(self):
+        project = self.project
+        group1 = self.create_group(
+            project=project,
+            checksum='a' * 40,
+            message='foo',
+        )
+        group2 = self.create_group(
+            project=project,
+            checksum='b' * 40,
+            message='bar',
+        )
+
+        results = self.backend.query(project, query='foo')
+        assert len(results) == 1
+        assert results[0] == group1
 
-        results = self.backend.query(event.project, event.message.upper())
+        results = self.backend.query(project, query='bar')
         assert len(results) == 1
-        [res] = results
-        assert res.id == doc.id
+        assert results[0] == group2
diff --git a/tests/sentry/search/elastic_search/__init__.py b/tests/sentry/search/elastic_search/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/tests/sentry/search/elastic_search/test_backend.py b/tests/sentry/search/elastic_search/test_backend.py
new file mode 100644
index 0000000000..92bec5ecb4
--- /dev/null
+++ b/tests/sentry/search/elastic_search/test_backend.py
@@ -0,0 +1,85 @@
+# -*- coding: utf-8 -*-
+
+from __future__ import absolute_import
+
+from sentry.constants import STATUS_RESOLVED, STATUS_UNRESOLVED
+from sentry.search.elastic_search.backend import ElasticSearchBackend
+from sentry.testutils import TestCase
+
+
+class ElasticSearchTest(TestCase):
+    def setUp(self):
+        from elasticsearch import Elasticsearch
+
+        self.conn = Elasticsearch()
+        try:
+            self.conn.indices.delete(index='test-sentry-1')
+        except Exception:
+            pass
+
+        self.backend = ElasticSearchBackend(index_prefix='test-')
+        self.backend.upgrade()
+
+    def test_simple(self):
+        project1 = self.project
+        project2 = self.create_project(team=self.team, name='estest')
+        group1 = self.create_group(
+            project=project1,
+            checksum='a' * 40,
+            message='foo',
+            status=STATUS_RESOLVED,
+        )
+        event1 = self.create_event(
+            event_id='a' * 40,
+            group=group1,
+            tags={
+                'server': 'example.com',
+                'env': 'production',
+            }
+        )
+        group2 = self.create_group(
+            project=project1,
+            checksum='b' * 40,
+            message='bar',
+            status=STATUS_UNRESOLVED,
+        )
+        event2 = self.create_event(
+            event_id='b' * 40,
+            group=group2,
+            tags={
+                'server': 'example.com',
+                'env': 'staging',
+                'url': 'http://example.com',
+            }
+        )
+
+        self.backend.index(group1, event1)
+        self.backend.index(group2, event2)
+
+        self.conn.indices.refresh(index='test-sentry-1')
+
+        results = self.backend.query(project1, query='foo')
+        assert len(results) == 1
+        assert results[0] == group1
+
+        results = self.backend.query(project1, query='bar')
+        assert len(results) == 1
+        assert results[0] == group2
+
+        results = self.backend.query(project2, query='bar')
+        assert len(results) == 0
+
+        results = self.backend.query(project1, tags={'env': 'staging'})
+        assert len(results) == 1
+        assert results[0] == group2
+
+        results = self.backend.query(project1, query='foo', tags={'env': 'staging'})
+        assert len(results) == 0
+
+        results = self.backend.query(project1, status=STATUS_RESOLVED)
+        assert len(results) == 1
+        assert results[0] == group1
+
+        results = self.backend.query(project1, status=STATUS_UNRESOLVED)
+        assert len(results) == 1
+        assert results[0] == group2
diff --git a/tests/sentry/web/frontend/tests.py b/tests/sentry/web/frontend/tests.py
index a4cf1ecfbd..6308631963 100644
--- a/tests/sentry/web/frontend/tests.py
+++ b/tests/sentry/web/frontend/tests.py
@@ -3,10 +3,10 @@
 from __future__ import absolute_import
 
 from django.core.urlresolvers import reverse
-from exam import before, fixture
+from exam import fixture
 
 from sentry.constants import MEMBER_USER
-from sentry.models import Group, Project, TeamMember, Team, User
+from sentry.models import Project, TeamMember, Team, User
 from sentry.testutils import TestCase
 
 
@@ -347,31 +347,3 @@ class RemoveTeamMemberTest(PermissionBase):
 
     def test_member_cannot_load(self):
         self._assertPerm(self.path, self.template, self.member.username, False)
-
-
-class SentrySearchTest(TestCase):
-    @before
-    def login_user(self):
-        self.login_as(self.user)
-
-    @fixture
-    def path(self):
-        return reverse('sentry-search', kwargs={'team_slug': self.team.slug, 'project_id': self.project.id})
-
-    def test_checksum_query(self):
-        checksum = 'a' * 32
-        group = Group.objects.create(
-            project=self.project,
-            logger='root',
-            culprit='a',
-            checksum=checksum,
-            message='hi',
-        )
-
-        response = self.client.get(self.path, {'q': '%s$%s' % (checksum, checksum)})
-        self.assertEquals(response.status_code, 302)
-        self.assertEquals(response['Location'], 'http://testserver%s' % (reverse('sentry-group', kwargs={
-            'project_id': group.project.slug,
-            'team_slug': group.team.slug,
-            'group_id': group.id,
-        }),))

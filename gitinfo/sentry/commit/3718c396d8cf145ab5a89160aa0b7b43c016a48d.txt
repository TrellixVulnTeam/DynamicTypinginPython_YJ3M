commit 3718c396d8cf145ab5a89160aa0b7b43c016a48d
Author: Mark Story <mark@sentry.io>
Date:   Mon Aug 19 10:26:48 2019 -0400

    feat(discover2) Make pagination functional again (#14395)
    
    Restore the pagination button behavior and make the oldest/newest links
    work as intended. We now pass `field` to the API to allow pagination
    event ids to be constrained by the current event or 'reference' event.
    We use the group conditions and reference event values to ensure that
    the next/previous event are in the same 'group' as the modal looks at
    groupings of events now.
    
    Remove the `issue_title` alias. Using/having this alias makes grouping
    events into errors harder as the title doesn't serve as a grouping value
    for pagination. By using a simple title we can paginate more easily in the
    modal view, and we have less complexity overall.
    
    Refs SEN-887

diff --git a/src/sentry/api/bases/organization_events.py b/src/sentry/api/bases/organization_events.py
index a1f94d7ec4..c278a50654 100644
--- a/src/sentry/api/bases/organization_events.py
+++ b/src/sentry/api/bases/organization_events.py
@@ -8,6 +8,11 @@ from sentry.api.event_search import get_snuba_query_args, resolve_field_list, In
 from sentry.models.project import Project
 
 
+class Direction(object):
+    NEXT = 0
+    PREV = 1
+
+
 class OrganizationEventsEndpointBase(OrganizationEndpoint):
     def get_snuba_query_args(self, request, organization, params):
         query = request.GET.get("query")
@@ -109,3 +114,36 @@ class OrganizationEventsEndpointBase(OrganizationEndpoint):
 
         if prev_event:
             return prev_event[1]
+
+    def oldest_event_id(self, snuba_args, event):
+        """
+        Returns the oldest event ID if there is a subsequent event matching the
+        conditions provided
+        """
+        return self._get_terminal_event_id(Direction.PREV, snuba_args, event)
+
+    def latest_event_id(self, snuba_args, event):
+        """
+        Returns the latest event ID if there is a newer event matching the
+        conditions provided
+        """
+        return self._get_terminal_event_id(Direction.NEXT, snuba_args, event)
+
+    def _get_terminal_event_id(self, direction, snuba_args, event):
+        if direction == Direction.NEXT:
+            time_condition = [["timestamp", ">", event.timestamp]]
+            orderby = ["-timestamp", "-event_id"]
+        else:
+            time_condition = [["timestamp", "<", event.timestamp]]
+            orderby = ["timestamp", "event_id"]
+
+        conditions = snuba_args["conditions"][:]
+        conditions.extend(time_condition)
+
+        result = eventstore.get_events(
+            conditions=conditions, filter_keys=snuba_args["filter_keys"], orderby=orderby, limit=1
+        )
+        if not result:
+            return None
+
+        return result[0].event_id
diff --git a/src/sentry/api/endpoints/organization_event_details.py b/src/sentry/api/endpoints/organization_event_details.py
index 51c733710f..b24f20aed5 100644
--- a/src/sentry/api/endpoints/organization_event_details.py
+++ b/src/sentry/api/endpoints/organization_event_details.py
@@ -5,6 +5,7 @@ import six
 from enum import Enum
 
 from sentry.api.bases import OrganizationEventsEndpointBase, OrganizationEventsError, NoProjects
+from sentry.api.event_search import get_reference_event_conditions
 from sentry import eventstore, features
 from sentry.models import SnubaEvent
 from sentry.models.project import Project
@@ -37,11 +38,17 @@ class OrganizationEventDetailsEndpoint(OrganizationEventsEndpointBase):
 
         # We return the requested event if we find a match regardless of whether
         # it occurred within the range specified
-        event = eventstore.get_event_by_id(project.id, event_id)
+        event = eventstore.get_event_by_id(project.id, event_id, eventstore.full_columns)
 
         if event is None:
             return Response({"detail": "Event not found"}, status=404)
 
+        # Scope the pagination related event ids to the current event
+        # This ensure that if a field list/groupby conditions were provided
+        # that we constrain related events to the query + current event values
+        snuba_args["conditions"].extend(
+            get_reference_event_conditions(snuba_args, event.snuba_data)
+        )
         next_event = eventstore.get_next_event_id(
             event, conditions=snuba_args["conditions"], filter_keys=snuba_args["filter_keys"]
         )
@@ -52,7 +59,8 @@ class OrganizationEventDetailsEndpoint(OrganizationEventsEndpointBase):
         data = serialize(event)
         data["nextEventID"] = next_event[1] if next_event else None
         data["previousEventID"] = prev_event[1] if prev_event else None
-
+        data["oldestEventID"] = self.oldest_event_id(snuba_args, event)
+        data["latestEventID"] = self.latest_event_id(snuba_args, event)
         data["projectSlug"] = project_slug
 
         return Response(data)
diff --git a/src/sentry/api/event_search.py b/src/sentry/api/event_search.py
index 3c7ea1c79d..8237215217 100644
--- a/src/sentry/api/event_search.py
+++ b/src/sentry/api/event_search.py
@@ -12,6 +12,8 @@ from parsimonious.exceptions import IncompleteParseError, ParseError
 from parsimonious.nodes import Node
 from parsimonious.grammar import Grammar, NodeVisitor
 
+from sentry import eventstore
+from sentry.models import Project
 from sentry.search.utils import (
     parse_datetime_range,
     parse_datetime_string,
@@ -19,8 +21,7 @@ from sentry.search.utils import (
     InvalidQuery,
 )
 from sentry.utils.dates import to_timestamp
-from sentry.utils.snuba import SENTRY_SNUBA_MAP
-from sentry.models import Project
+from sentry.utils.snuba import SENTRY_SNUBA_MAP, get_snuba_column_name
 
 WILDCARD_CHARS = re.compile(r"[\*]")
 
@@ -650,7 +651,6 @@ def get_snuba_query_args(query=None, params=None):
 
 
 FIELD_ALIASES = {
-    "issue_title": {"aggregations": [["anyHeavy", "title", "issue_title"]]},
     "last_seen": {"aggregations": [["max", "timestamp", "last_seen"]]},
     "latest_event": {
         "aggregations": [
@@ -800,3 +800,44 @@ def resolve_field_list(fields, snuba_args):
         "groupby": groupby,
         "orderby": orderby,
     }
+
+
+def find_reference_event(snuba_args, reference_event_id):
+    try:
+        project_slug, event_id = reference_event_id.split(":")
+    except ValueError:
+        raise InvalidSearchQuery("Invalid reference event")
+    try:
+        project = Project.objects.get(
+            slug=project_slug, id__in=snuba_args["filter_keys"]["project_id"]
+        )
+    except Project.DoesNotExist:
+        raise InvalidSearchQuery("Invalid reference event")
+
+    reference_event = eventstore.get_event_by_id(project.id, event_id, eventstore.full_columns)
+    if not reference_event:
+        raise InvalidSearchQuery("Invalid reference event")
+
+    return reference_event
+
+
+def get_reference_event_conditions(snuba_args, reference_event):
+    """
+    Returns a list of additional conditions/filter_keys to
+    scope a query by the groupby fields using values from the reference event
+
+    This is a key part of pagination in the event details modal and
+    summary graph navigation.
+    """
+    conditions = []
+
+    # If we were given an project/event to use build additional
+    # conditions using that event and the non-aggregated columns
+    # we received in the querystring. This lets us find the oldest/newest.
+    # This only handles simple fields on the snuba_data dict.
+    for field in snuba_args.get("groupby", []):
+        prop = get_snuba_column_name(field)
+        value = reference_event.get(prop, None)
+        if value:
+            conditions.append([prop, "=", value])
+    return conditions
diff --git a/src/sentry/eventstore/base.py b/src/sentry/eventstore/base.py
index 2fc11bd253..4bfca3f00f 100644
--- a/src/sentry/eventstore/base.py
+++ b/src/sentry/eventstore/base.py
@@ -23,6 +23,7 @@ class Columns(Enum):
     IP_ADDRESS = "ip_address"
     USER_ID = "user_id"
     USERNAME = "username"
+    TRANSACTION = "transaction"
 
 
 class EventStorage(Service):
@@ -50,6 +51,7 @@ class EventStorage(Service):
         Columns.PLATFORM,
         Columns.TITLE,
         Columns.TYPE,
+        Columns.TRANSACTION,
         # Required to provide snuba-only tags
         Columns.TAGS_KEY,
         Columns.TAGS_VALUE,
diff --git a/src/sentry/static/sentry/app/views/organizationEventsV2/data.jsx b/src/sentry/static/sentry/app/views/organizationEventsV2/data.jsx
index 4f399fd306..037d0c45bb 100644
--- a/src/sentry/static/sentry/app/views/organizationEventsV2/data.jsx
+++ b/src/sentry/static/sentry/app/views/organizationEventsV2/data.jsx
@@ -17,7 +17,7 @@ import {QueryLink} from './styles';
 
 export const MODAL_QUERY_KEYS = ['eventSlug'];
 export const PIN_ICON = `image://${pinIcon}`;
-export const AGGREGATE_ALIASES = ['issue_title', 'last_seen', 'latest_event'];
+export const AGGREGATE_ALIASES = ['last_seen', 'latest_event'];
 
 export const ALL_VIEWS = deepFreeze([
   {
@@ -42,9 +42,9 @@ export const ALL_VIEWS = deepFreeze([
     id: 'errors',
     name: t('Errors'),
     data: {
-      fields: ['issue_title', 'count(id)', 'count_unique(user)', 'project', 'last_seen'],
+      fields: ['title', 'count(id)', 'count_unique(user)', 'project', 'last_seen'],
       columnNames: ['error', 'events', 'users', 'project', 'last seen'],
-      sort: ['-last_seen', '-issue_title'],
+      sort: ['-last_seen', '-title'],
       query: 'event.type:error',
     },
     tags: ['error.type', 'project.name'],
@@ -54,9 +54,9 @@ export const ALL_VIEWS = deepFreeze([
     id: 'csp',
     name: t('CSP'),
     data: {
-      fields: ['issue_title', 'count(id)', 'count_unique(user)', 'project', 'last_seen'],
+      fields: ['title', 'count(id)', 'count_unique(user)', 'project', 'last_seen'],
       columnNames: ['csp', 'events', 'users', 'project', 'last seen'],
-      sort: ['-last_seen', '-issue_title'],
+      sort: ['-last_seen', '-title'],
       query: 'event.type:csp',
     },
     tags: [
@@ -164,11 +164,12 @@ export const SPECIAL_FIELDS = {
   transaction: {
     sortField: 'transaction',
     renderFunc: (data, {location}) => {
+      const id = data.id || data.latest_event;
       const target = {
         pathname: location.pathname,
         query: {
           ...location.query,
-          eventSlug: `${data['project.name']}:${data.latest_event}`,
+          eventSlug: `${data['project.name']}:${id}`,
         },
       };
       return (
@@ -183,9 +184,10 @@ export const SPECIAL_FIELDS = {
   title: {
     sortField: 'title',
     renderFunc: (data, {location}) => {
+      const id = data.id || data.latest_event;
       const target = {
         pathname: location.pathname,
-        query: {...location.query, eventSlug: `${data['project.name']}:${data.id}`},
+        query: {...location.query, eventSlug: `${data['project.name']}:${id}`},
       };
       return (
         <Container>
@@ -255,25 +257,6 @@ export const SPECIAL_FIELDS = {
       return <QueryLink to={target}>{badge}</QueryLink>;
     },
   },
-  issue_title: {
-    sortField: 'issue_title',
-    renderFunc: (data, {location}) => {
-      const target = {
-        pathname: location.pathname,
-        query: {
-          ...location.query,
-          eventSlug: `${data['project.name']}:${data.latest_event}`,
-        },
-      };
-      return (
-        <Container>
-          <Link css={overflowEllipsis} to={target} aria-label={data.issue_title}>
-            {data.issue_title}
-          </Link>
-        </Container>
-      );
-    },
-  },
   last_seen: {
     sortField: 'last_seen',
     renderFunc: data => {
diff --git a/src/sentry/static/sentry/app/views/organizationEventsV2/eventModalContent.jsx b/src/sentry/static/sentry/app/views/organizationEventsV2/eventModalContent.jsx
index e9901feda9..c38b1fc8ea 100644
--- a/src/sentry/static/sentry/app/views/organizationEventsV2/eventModalContent.jsx
+++ b/src/sentry/static/sentry/app/views/organizationEventsV2/eventModalContent.jsx
@@ -17,8 +17,8 @@ import ModalPagination from './modalPagination';
 import ModalLineGraph from './modalLineGraph';
 import RelatedEvents from './relatedEvents';
 import TagsTable from './tagsTable';
-import {AGGREGATE_ALIASES} from './data';
 import TransanctionView from './transactionView';
+import {hasAggregateField} from './utils';
 
 /**
  * Render the columns and navigation elements inside the event modal view.
@@ -27,10 +27,8 @@ import TransanctionView from './transactionView';
 const EventModalContent = props => {
   const {event, projectId, organization, location, view} = props;
 
-  // Known aggregate aliases and functions indicated grouped views.
-  const isGroupedView = !!view.data.fields.find(
-    field => AGGREGATE_ALIASES.includes(field) || field.match(/[a-z_]+\([a-z_\.]+\)/)
-  );
+  // Having an aggregate field means we want to show pagination/graphs
+  const isGroupedView = hasAggregateField(view);
   const eventJsonUrl = `/api/0/projects/${organization.slug}/${projectId}/events/${
     event.eventID
   }/json/`;
@@ -39,9 +37,7 @@ const EventModalContent = props => {
     <ColumnGrid>
       <HeaderBox>
         <EventHeader event={event} />
-        {isGroupedView && (
-          <ModalPagination view={view} event={event} location={location} />
-        )}
+        {isGroupedView && <ModalPagination event={event} location={location} />}
         {isGroupedView &&
           getDynamicText({
             value: (
diff --git a/src/sentry/static/sentry/app/views/organizationEventsV2/modalPagination.jsx b/src/sentry/static/sentry/app/views/organizationEventsV2/modalPagination.jsx
index 3b17f9565b..d506c0f121 100644
--- a/src/sentry/static/sentry/app/views/organizationEventsV2/modalPagination.jsx
+++ b/src/sentry/static/sentry/app/views/organizationEventsV2/modalPagination.jsx
@@ -22,10 +22,8 @@ function buildTargets(event, location) {
   const urlMap = {
     previous: event.previousEventID,
     next: event.nextEventID,
-    // TODO(mark) Make latest, oldest work once we have new endpoints.
-    // `${event.eventID}:latest`,
-    latest: null,
-    oldest: null,
+    oldest: event.oldestEventID,
+    latest: event.latestEventID,
   };
 
   const links = {};
diff --git a/src/sentry/static/sentry/app/views/organizationEventsV2/utils.jsx b/src/sentry/static/sentry/app/views/organizationEventsV2/utils.jsx
index fcf8efa66b..bc050f8503 100644
--- a/src/sentry/static/sentry/app/views/organizationEventsV2/utils.jsx
+++ b/src/sentry/static/sentry/app/views/organizationEventsV2/utils.jsx
@@ -2,7 +2,7 @@ import {partial, pick, get} from 'lodash';
 
 import {DEFAULT_PER_PAGE} from 'app/constants';
 import {URL_PARAM} from 'app/constants/globalSelectionHeader';
-import {ALL_VIEWS, SPECIAL_FIELDS, FIELD_FORMATTERS} from './data';
+import {ALL_VIEWS, AGGREGATE_ALIASES, SPECIAL_FIELDS, FIELD_FORMATTERS} from './data';
 
 /**
  * Given a view id, return the corresponding view object
@@ -15,9 +15,25 @@ export function getCurrentView(requestedView) {
   return ALL_VIEWS.find(view => view.id === requestedView) || ALL_VIEWS[0];
 }
 
+/**
+ * Takes a view and determines if there are any aggregate fields in it.
+ *
+ * TODO(mark) This function should be part of an EventView abstraction
+ *
+ * @param {Object} view
+ * @returns {Boolean}
+ */
+export function hasAggregateField(view) {
+  return view.data.fields.some(
+    field => AGGREGATE_ALIASES.includes(field) || field.match(/[a-z_]+\([a-z_\.]+\)/)
+  );
+}
+
 /**
  * Takes a view and converts it into the format required for the events API
  *
+ * TODO(mark) This function should be part of an EventView abstraction
+ *
  * @param {Object} view
  * @returns {Object}
  */
@@ -51,6 +67,8 @@ export function getQuery(view, location) {
  * Generate a querystring based on the view defaults, current
  * location and any additional parameters
  *
+ * TODO(mark) This function should be part of an EventView abstraction
+ *
  * @param {Object} view defaults containing `.data.query`
  * @param {Location} browser location
  * @param {Object} additional parameters to merge into the query string.
diff --git a/src/sentry/utils/snuba.py b/src/sentry/utils/snuba.py
index db027d2fa4..340028b0f3 100644
--- a/src/sentry/utils/snuba.py
+++ b/src/sentry/utils/snuba.py
@@ -60,6 +60,7 @@ SENTRY_SNUBA_MAP = {
     "issue.id": "issue",
     "timestamp": "timestamp",
     "time": "time",
+    "transaction": "transaction",
     # We support type as both tag and a real column
     "event.type": "type",
     # user
diff --git a/tests/sentry/api/test_event_search.py b/tests/sentry/api/test_event_search.py
index fc1a97e55f..18df877ce3 100644
--- a/tests/sentry/api/test_event_search.py
+++ b/tests/sentry/api/test_event_search.py
@@ -1088,21 +1088,22 @@ class ResolveFieldListTest(unittest.TestCase):
         assert result["groupby"] == []
 
     def test_automatic_fields_with_aggregate_aliases(self):
-        fields = ["issue_title", "message"]
+        fields = ["title", "last_seen"]
         result = resolve_field_list(fields, {})
         # Automatic fields should be inserted
-        assert result["selected_columns"] == ["message"]
+        assert result["selected_columns"] == ["title"]
         assert result["aggregations"] == [
-            ["anyHeavy", "title", "issue_title"],
+            ["max", "timestamp", "last_seen"],
             ["argMax(event_id, timestamp)", "", "latest_event"],
             ["argMax(project_id, timestamp)", "", "projectid"],
         ]
-        assert result["groupby"] == ["message"]
+        assert result["groupby"] == ["title"]
 
     def test_field_alias_expansion(self):
-        fields = ["issue_title", "last_seen", "latest_event", "project", "user", "message"]
+        fields = ["title", "last_seen", "latest_event", "project", "user", "message"]
         result = resolve_field_list(fields, {})
         assert result["selected_columns"] == [
+            "title",
             "project.id",
             "user.id",
             "user.name",
@@ -1112,11 +1113,11 @@ class ResolveFieldListTest(unittest.TestCase):
             "message",
         ]
         assert result["aggregations"] == [
-            ["anyHeavy", "title", "issue_title"],
             ["max", "timestamp", "last_seen"],
             ["argMax(event_id, timestamp)", "", "latest_event"],
         ]
         assert result["groupby"] == [
+            "title",
             "project.id",
             "user.id",
             "user.name",
@@ -1198,12 +1199,12 @@ class ResolveFieldListTest(unittest.TestCase):
         assert result["groupby"] == []
 
     def test_orderby_field_alias(self):
-        fields = ["issue_title"]
-        snuba_args = {"orderby": "-issue_title"}
+        fields = ["last_seen"]
+        snuba_args = {"orderby": "-last_seen"}
         result = resolve_field_list(fields, snuba_args)
         assert result["selected_columns"] == []
         assert result["aggregations"] == [
-            ["anyHeavy", "title", "issue_title"],
+            ["max", "timestamp", "last_seen"],
             ["argMax(event_id, timestamp)", "", "latest_event"],
             ["argMax(project_id, timestamp)", "", "projectid"],
         ]
diff --git a/tests/sentry/eventstore/snuba/test_backend.py b/tests/sentry/eventstore/snuba/test_backend.py
index 03f7484618..4ffe768135 100644
--- a/tests/sentry/eventstore/snuba/test_backend.py
+++ b/tests/sentry/eventstore/snuba/test_backend.py
@@ -83,7 +83,7 @@ class SnubaEventStorageTest(TestCase, SnubaTestCase):
         assert event.id == "b" * 32
         assert event.event_id == "b" * 32
         assert event.project_id == self.project2.id
-        assert len(event.snuba_data.keys()) == 16
+        assert len(event.snuba_data.keys()) == 17
 
         # Get non existent event
         event = self.eventstore.get_event_by_id(self.project2.id, "d" * 32)
diff --git a/tests/sentry/eventstore/test_base.py b/tests/sentry/eventstore/test_base.py
index 23be60fd82..4b0713b7c4 100644
--- a/tests/sentry/eventstore/test_base.py
+++ b/tests/sentry/eventstore/test_base.py
@@ -16,7 +16,7 @@ class EventStorageTest(TestCase):
         assert len(self.eventstorage.minimal_columns) == 4
 
     def test_full_columns(self):
-        assert len(self.eventstorage.full_columns) == 16
+        assert len(self.eventstorage.full_columns) == 17
 
     def test_bind_nodes(self):
         """
diff --git a/tests/snuba/api/endpoints/test_organization_event_details.py b/tests/snuba/api/endpoints/test_organization_event_details.py
index 96d3507cbd..38a390f0c4 100644
--- a/tests/snuba/api/endpoints/test_organization_event_details.py
+++ b/tests/snuba/api/endpoints/test_organization_event_details.py
@@ -7,26 +7,45 @@ from sentry.testutils import APITestCase, SnubaTestCase
 from sentry.models import Group
 
 
+def create_timestamp(delta):
+    return (timezone.now() - delta).isoformat()[:19]
+
+
 class OrganizationEventDetailsTestBase(APITestCase, SnubaTestCase):
     def setUp(self):
         super(OrganizationEventDetailsTestBase, self).setUp()
-        min_ago = (timezone.now() - timedelta(minutes=1)).isoformat()[:19]
-        two_min_ago = (timezone.now() - timedelta(minutes=2)).isoformat()[:19]
-        three_min_ago = (timezone.now() - timedelta(minutes=3)).isoformat()[:19]
+        min_ago = create_timestamp(timedelta(minutes=1))
+        two_min_ago = create_timestamp(timedelta(minutes=2))
+        three_min_ago = create_timestamp(timedelta(minutes=3))
 
         self.login_as(user=self.user)
         self.project = self.create_project()
 
         self.store_event(
-            data={"event_id": "a" * 32, "timestamp": three_min_ago, "fingerprint": ["group-1"]},
+            data={
+                "event_id": "a" * 32,
+                "message": "oh no",
+                "timestamp": three_min_ago,
+                "fingerprint": ["group-1"],
+            },
             project_id=self.project.id,
         )
         self.store_event(
-            data={"event_id": "b" * 32, "timestamp": two_min_ago, "fingerprint": ["group-1"]},
+            data={
+                "event_id": "b" * 32,
+                "message": "very bad",
+                "timestamp": two_min_ago,
+                "fingerprint": ["group-1"],
+            },
             project_id=self.project.id,
         )
         self.store_event(
-            data={"event_id": "c" * 32, "timestamp": min_ago, "fingerprint": ["group-2"]},
+            data={
+                "event_id": "c" * 32,
+                "message": "very bad",
+                "timestamp": min_ago,
+                "fingerprint": ["group-2"],
+            },
             project_id=self.project.id,
         )
         self.groups = list(Group.objects.all().order_by("id"))
@@ -81,6 +100,50 @@ class OrganizationEventDetailsEndpointTest(OrganizationEventDetailsTestBase):
 
         assert response.status_code == 404, response.content
 
+    def test_event_links_with_field_parameter(self):
+        # Create older and newer events
+        ten_sec_ago = create_timestamp(timedelta(seconds=10))
+        self.store_event(
+            data={"event_id": "2" * 32, "message": "no match", "timestamp": ten_sec_ago},
+            project_id=self.project.id,
+        )
+        thirty_sec_ago = create_timestamp(timedelta(seconds=30))
+        self.store_event(
+            data={"event_id": "1" * 32, "message": "very bad", "timestamp": thirty_sec_ago},
+            project_id=self.project.id,
+        )
+        five_min_ago = create_timestamp(timedelta(minutes=5))
+        self.store_event(
+            data={"event_id": "d" * 32, "message": "very bad", "timestamp": five_min_ago},
+            project_id=self.project.id,
+        )
+        seven_min_ago = create_timestamp(timedelta(minutes=7))
+        self.store_event(
+            data={"event_id": "e" * 32, "message": "very bad", "timestamp": seven_min_ago},
+            project_id=self.project.id,
+        )
+        eight_min_ago = create_timestamp(timedelta(minutes=8))
+        self.store_event(
+            data={"event_id": "f" * 32, "message": "no match", "timestamp": eight_min_ago},
+            project_id=self.project.id,
+        )
+
+        url = reverse(
+            "sentry-api-0-organization-event-details",
+            kwargs={
+                "organization_slug": self.project.organization.slug,
+                "project_slug": self.project.slug,
+                "event_id": "b" * 32,
+            },
+        )
+        with self.feature("organizations:events-v2"):
+            response = self.client.get(url, format="json", data={"field": ["message", "count()"]})
+        assert response.data["eventID"] == "b" * 32
+        assert response.data["nextEventID"] == "c" * 32, "c is newer & matches message"
+        assert response.data["previousEventID"] == "d" * 32, "d is older & matches message"
+        assert response.data["oldestEventID"] == "e" * 32, "e is oldest matching message"
+        assert response.data["latestEventID"] == "1" * 32, "1 is newest matching message"
+
 
 class OrganizationEventDetailsLatestEndpointTest(OrganizationEventDetailsTestBase):
     def test_simple(self):

commit 8788371008ae9205f2aef5debb1e0c94820ec1f6
Author: Alex Hofsteede <alex@hofsteede.com>
Date:   Mon Nov 19 13:19:12 2018 -0800

    fix: Get key counts again in group_tag_keys_and_top_values (#10656)
    
    Omitting the key counts was ok for the tags sidebar, but broke the
    group tags page, and leads to poor comparison results. Even though
    adding the counts back requires another query, it's probably better
    than the complexity of having to deal with all the different cases
    where we may or may not need the counts.
    
    Although I can always make it so that we don't do the extra query for
    just the tags sidebar case if we want that component to keep loading
    as fast as possible.

diff --git a/src/sentry/tagstore/snuba/backend.py b/src/sentry/tagstore/snuba/backend.py
index 9e6922191a..e385440da6 100644
--- a/src/sentry/tagstore/snuba/backend.py
+++ b/src/sentry/tagstore/snuba/backend.py
@@ -292,10 +292,13 @@ class SnubaTagStorage(TagStorage):
         # Similar to __get_tag_key_and_top_values except we get the top values
         # for all the keys provided. value_limit in this case means the number
         # of top values for each key, so the total rows returned should be
-        # num_keys * limit.  We also can't use `totals` here to get the number
-        # of "other" values for each key as we only get a single total back,
-        # which will be the total count across all keys.
+        # num_keys * limit.
         start, end = self.get_time_range()
+
+        # First get totals and unique counts by key.
+        keys_with_counts = self.get_group_tag_keys(project_id, group_id, environment_id, keys=keys)
+
+        # Then get the top values with first_seen/last_seen/count for each
         filters = {
             'project_id': [project_id],
         }
@@ -312,42 +315,32 @@ class SnubaTagStorage(TagStorage):
             ['max', SEEN_COLUMN, 'last_seen'],
         ]
 
-        result = snuba.query(
+        values_by_key = snuba.query(
             start, end, ['tags_key', 'tags_value'], None, filters, aggregations,
             orderby='-count', limitby=[value_limit, 'tags_key'],
             referrer='tagstore.__get_tag_keys_and_top_values'
         )
 
+        # Then supplement the key objects with the top values for each.
         if group_id is None:
-            key_ctor = TagKey
             value_ctor = TagValue
         else:
-            key_ctor = functools.partial(GroupTagKey, group_id=group_id)
             value_ctor = functools.partial(GroupTagValue, group_id=group_id)
 
-        return set([
-            key_ctor(
-
-                # TODO we don't know these from the current query, but in the
-                # context of this method, the client usually knows these values
-                # from the result of a previous call to get_group_tag_keys, so
-                # we could fill them in here with another query, but also it
-                # could be a waste of time.
-                values_seen=0,
-                count=0,
+        for keyobj in keys_with_counts:
+            key = keyobj.key
+            values = values_by_key.get(key, [])
+            keyobj.top_values = [
+                value_ctor(
+                    key=keyobj.key,
+                    value=value,
+                    times_seen=data['count'],
+                    first_seen=parse_datetime(data['first_seen']),
+                    last_seen=parse_datetime(data['last_seen']),
+                ) for value, data in six.iteritems(values)
+            ]
 
-                key=key,
-                top_values=[
-                    value_ctor(
-                        key=key,
-                        value=value,
-                        times_seen=data['count'],
-                        first_seen=parse_datetime(data['first_seen']),
-                        last_seen=parse_datetime(data['last_seen']),
-                    ) for value, data in six.iteritems(values)
-                ]
-            ) for key, values in six.iteritems(result)
-        ])
+        return keys_with_counts
 
     def __get_release(self, project_id, group_id, first=True):
         start, end = self.get_time_range()
diff --git a/tests/snuba/tagstore/test_tagstore_backend.py b/tests/snuba/tagstore/test_tagstore_backend.py
index 8836bbe53a..83519e4c43 100644
--- a/tests/snuba/tagstore/test_tagstore_backend.py
+++ b/tests/snuba/tagstore/test_tagstore_backend.py
@@ -96,12 +96,12 @@ class TagStorageTest(SnubaTestCase):
         result.sort(key=lambda r: r.key)
         assert result[0].key == 'baz'
         assert result[0].top_values[0].value == 'quux'
-        # assert result[0].values_seen == 1
-        # assert result[0].count == 2
+        assert result[0].values_seen == 1
+        assert result[0].count == 2
 
         assert result[3].key == 'sentry:release'
-        # assert result[3].values_seen == 2
-        # assert result[3].count == 2
+        assert result[3].values_seen == 2
+        assert result[3].count == 2
         top_release_values = result[3].top_values
         assert len(top_release_values) == 2
         assert set(v.value for v in top_release_values) == set(['100', '200'])

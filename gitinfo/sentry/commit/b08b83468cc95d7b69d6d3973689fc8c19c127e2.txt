commit b08b83468cc95d7b69d6d3973689fc8c19c127e2
Author: Pierre du Plessis <pierre@pcservice.co.za>
Date:   Thu Feb 27 19:53:57 2020 +0200

    feat(bitbuckerserver): Add support for Bitbucket Server (#15221)

diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index 425d0d29ed..e51c367d92 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -1432,6 +1432,7 @@ SENTRY_USE_X_FORWARDED_FOR = True
 
 SENTRY_DEFAULT_INTEGRATIONS = (
     "sentry.integrations.bitbucket.BitbucketIntegrationProvider",
+    "sentry.integrations.bitbucket_server.BitbucketServerIntegrationProvider",
     "sentry.integrations.slack.SlackIntegrationProvider",
     "sentry.integrations.github.GitHubIntegrationProvider",
     "sentry.integrations.github_enterprise.GitHubEnterpriseIntegrationProvider",
diff --git a/src/sentry/integrations/bitbucket_server/__init__.py b/src/sentry/integrations/bitbucket_server/__init__.py
new file mode 100644
index 0000000000..ffdddd1622
--- /dev/null
+++ b/src/sentry/integrations/bitbucket_server/__init__.py
@@ -0,0 +1,4 @@
+from __future__ import absolute_import
+from sentry.utils.imports import import_submodules
+
+import_submodules(globals(), __name__, __path__)
diff --git a/src/sentry/integrations/bitbucket_server/client.py b/src/sentry/integrations/bitbucket_server/client.py
new file mode 100644
index 0000000000..bafc7c2ca9
--- /dev/null
+++ b/src/sentry/integrations/bitbucket_server/client.py
@@ -0,0 +1,155 @@
+from __future__ import absolute_import
+
+from oauthlib.oauth1 import SIGNATURE_RSA
+from requests_oauthlib import OAuth1
+from six.moves.urllib.parse import parse_qsl
+from sentry.integrations.client import ApiClient, ApiError
+
+
+class BitbucketServerAPIPath(object):
+    """
+    project is the short key of the project
+    repo is the fully qualified slug
+    """
+
+    repository = u"/rest/api/1.0/projects/{project}/repos/{repo}"
+    repositories = u"/rest/api/1.0/repos"
+    repository_hook = u"/rest/api/1.0/projects/{project}/repos/{repo}/webhooks/{id}"
+    repository_hooks = u"/rest/api/1.0/projects/{project}/repos/{repo}/webhooks"
+    repository_commits = u"/rest/api/1.0/projects/{project}/repos/{repo}/commits"
+
+
+class BitbucketServerSetupClient(ApiClient):
+    """
+    Client for making requests to Bitbucket Server to follow OAuth1 flow.
+    """
+
+    request_token_url = u"{}/plugins/servlet/oauth/request-token"
+    access_token_url = u"{}/plugins/servlet/oauth/access-token"
+    authorize_url = u"{}/plugins/servlet/oauth/authorize?oauth_token={}"
+    integration_name = "bitbucket_server_setup"
+
+    def __init__(self, base_url, consumer_key, private_key, verify_ssl=True):
+        self.base_url = base_url
+        self.consumer_key = consumer_key
+        self.private_key = private_key
+        self.verify_ssl = verify_ssl
+
+    def get_request_token(self):
+        """
+        Step 1 of the oauth flow.
+        Get a request token that we can have the user verify.
+        """
+        url = self.request_token_url.format(self.base_url)
+        resp = self.post(url, allow_text=True)
+        return dict(parse_qsl(resp.text))
+
+    def get_authorize_url(self, request_token):
+        """
+        Step 2 of the oauth flow.
+        Get a URL that the user can verify our request token at.
+        """
+        return self.authorize_url.format(self.base_url, request_token["oauth_token"])
+
+    def get_access_token(self, request_token, verifier):
+        """
+        Step 3 of the oauth flow.
+        Use the verifier and request token from step 1 to get an access token.
+        """
+        if not verifier:
+            raise ApiError("Missing OAuth token verifier")
+        auth = OAuth1(
+            client_key=self.consumer_key,
+            resource_owner_key=request_token["oauth_token"],
+            resource_owner_secret=request_token["oauth_token_secret"],
+            verifier=verifier,
+            rsa_key=self.private_key,
+            signature_method=SIGNATURE_RSA,
+            signature_type="auth_header",
+        )
+        url = self.access_token_url.format(self.base_url)
+        resp = self.post(url, auth=auth, allow_text=True)
+        return dict(parse_qsl(resp.text))
+
+    def request(self, *args, **kwargs):
+        """
+        Add OAuth1 RSA signatures.
+        """
+        if "auth" not in kwargs:
+            kwargs["auth"] = OAuth1(
+                client_key=self.consumer_key,
+                rsa_key=self.private_key,
+                signature_method=SIGNATURE_RSA,
+                signature_type="auth_header",
+            )
+        return self._request(*args, **kwargs)
+
+
+class BitbucketServer(ApiClient):
+    """
+    Contains the BitBucket Server specifics in order to communicate with bitbucket
+
+    You can find BitBucket REST API docs here:
+
+    https://developer.atlassian.com/server/bitbucket/reference/rest-api/
+    """
+
+    integration_name = "bitbucket_server"
+
+    def __init__(self, base_url, credentials, verify_ssl):
+        super(BitbucketServer, self).__init__(verify_ssl)
+
+        self.base_url = base_url
+        self.credentials = credentials
+
+    def get_repos(self):
+        return self.get(
+            BitbucketServerAPIPath.repositories,
+            auth=self.get_auth(),
+            params={"limit": 250, "permission": "REPO_ADMIN"},
+        )
+
+    def search_repositories(self, query_string):
+        return self.get(
+            BitbucketServerAPIPath.repositories,
+            auth=self.get_auth(),
+            params={"limit": 250, "permission": "REPO_ADMIN", "name": query_string},
+        )
+
+    def get_repo(self, project, repo):
+        return self.get(
+            BitbucketServerAPIPath.repository.format(project=project, repo=repo),
+            auth=self.get_auth(),
+        )
+
+    def create_hook(self, project, repo, data):
+        return self.post(
+            BitbucketServerAPIPath.repository_hooks.format(project=project, repo=repo),
+            auth=self.get_auth(),
+            data=data,
+        )
+
+    def delete_hook(self, project, repo, webhook_id):
+        return self.delete(
+            BitbucketServerAPIPath.repository_hook.format(
+                project=project, repo=repo, id=webhook_id
+            ),
+            auth=self.get_auth(),
+        )
+
+    def get_commits(self, project, repo, fromHash, toHash):
+        return self.get(
+            BitbucketServerAPIPath.repository_commits.format(project=project, repo=repo),
+            auth=self.get_auth(),
+            params={"since": fromHash, "until": toHash, "merges": "exclude"},
+        )
+
+    def get_auth(self):
+        return OAuth1(
+            client_key=self.credentials["consumer_key"],
+            rsa_key=self.credentials["private_key"],
+            resource_owner_key=self.credentials["access_token"],
+            resource_owner_secret=self.credentials["access_token_secret"],
+            signature_method=SIGNATURE_RSA,
+            signature_type="auth_header",
+        )
diff --git a/src/sentry/integrations/bitbucket_server/integration.py b/src/sentry/integrations/bitbucket_server/integration.py
new file mode 100644
index 0000000000..65a27773b9
--- /dev/null
+++ b/src/sentry/integrations/bitbucket_server/integration.py
@@ -0,0 +1,356 @@
+from __future__ import absolute_import
+
+import logging
+import six
+
+from cryptography.hazmat.primitives.serialization import load_pem_private_key
+from cryptography.hazmat.backends import default_backend
+from django import forms
+from django.core.validators import URLValidator
+from django.views.decorators.csrf import csrf_exempt
+from sentry.integrations import (
+    IntegrationFeatures,
+    IntegrationProvider,
+    IntegrationMetadata,
+    FeatureDescription,
+    IntegrationInstallation,
+)
+from six.moves.urllib.parse import urlparse
+from sentry.integrations.repositories import RepositoryMixin
+from sentry.pipeline import PipelineView
+from sentry.utils.compat import filter
+from django.utils.translation import ugettext_lazy as _
+from sentry.integrations.exceptions import ApiError
+from sentry.models.repository import Repository
+from sentry.tasks.integrations import migrate_repo
+from sentry.web.helpers import render_to_response
+from .repository import BitbucketServerRepositoryProvider
+from .client import BitbucketServer, BitbucketServerSetupClient
+
+logger = logging.getLogger("sentry.integrations.bitbucket_server")
+
+DESCRIPTION = """
+Connect your Sentry organization to Bitbucket Server, enabling the following features:
+"""
+
+FEATURES = [
+    FeatureDescription(
+        """
+        Track commits and releases (learn more
+        [here](https://docs.sentry.io/learn/releases/))
+        """,
+        IntegrationFeatures.COMMITS,
+    ),
+    FeatureDescription(
+        """
+        Resolve Sentry issues via Bitbucket Server commits by
+        including `Fixes PROJ-ID` in the message
+        """,
+        IntegrationFeatures.COMMITS,
+    ),
+]
+
+setup_alert = {
+    "type": "warning",
+    "icon": "icon-warning-sm",
+    "text": "Your Bitbucket Server instance must be able to communicate with Sentry."
+    " Sentry makes outbound requests from a [static set of IP"
+    " addresses](https://docs.sentry.io/ip-ranges/) that you may wish"
+    " to whitelist to support this integration.",
+}
+
+metadata = IntegrationMetadata(
+    description=DESCRIPTION.strip(),
+    features=FEATURES,
+    author="The Sentry Team",
+    noun=_("Installation"),
+    issue_url="https://github.com/getsentry/sentry/issues/new?title=Bitbucket%20Server%20Integration:%20&labels=Component%3A%20Integrations",
+    source_url="https://github.com/getsentry/sentry/tree/master/src/sentry/integrations/bitbucket_server",
+    aspects={},
+)
+
+
+class InstallationForm(forms.Form):
+    url = forms.CharField(
+        label=_("Bitbucket URL"),
+        help_text=_(
+            "The base URL for your Bitbucket Server instance, including the host and protocol."
+        ),
+        widget=forms.TextInput(attrs={"placeholder": "https://bitbucket.example.com"}),
+        validators=[URLValidator()],
+    )
+    verify_ssl = forms.BooleanField(
+        label=_("Verify SSL"),
+        help_text=_(
+            "By default, we verify SSL certificates "
+            "when making requests to your Bitbucket instance."
+        ),
+        widget=forms.CheckboxInput(),
+        required=False,
+        initial=True,
+    )
+    consumer_key = forms.CharField(
+        label=_("Bitbucket Consumer Key"),
+        widget=forms.TextInput(attrs={"placeholder": _("sentry-consumer-key")}),
+    )
+    private_key = forms.CharField(
+        label=_("Bitbucket Consumer Private Key"),
+        widget=forms.Textarea(
+            attrs={
+                "placeholder": _(
+                    "-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----"
+                )
+            }
+        ),
+    )
+
+    def clean_url(self):
+        """Strip off trailing / as they cause invalid URLs downstream"""
+        return self.cleaned_data["url"].rstrip("/")
+
+    def clean_private_key(self):
+        data = self.cleaned_data["private_key"]
+
+        try:
+            load_pem_private_key(data.encode("utf-8"), None, default_backend())
+        except Exception:
+            raise forms.ValidationError(
+                "Private key must be a valid SSH private key encoded in a PEM format."
+            )
+        return data
+
+    def clean_consumer_key(self):
+        data = self.cleaned_data["consumer_key"]
+        if len(data) > 200:
+            raise forms.ValidationError("Consumer key is limited to 200 characters.")
+        return data
+
+
+class InstallationConfigView(PipelineView):
+    """
+    Collect the OAuth client credentials from the user.
+    """
+
+    def dispatch(self, request, pipeline):
+        if request.method == "POST":
+            form = InstallationForm(request.POST)
+            if form.is_valid():
+                form_data = form.cleaned_data
+
+                pipeline.bind_state("installation_data", form_data)
+                return pipeline.next_step()
+        else:
+            form = InstallationForm()
+
+        return render_to_response(
+            template="sentry/integrations/bitbucket-server-config.html",
+            context={"form": form},
+            request=request,
+        )
+
+
+class OAuthLoginView(PipelineView):
+    """
+    Start the OAuth dance by creating a request token
+    and redirecting the user to approve it.
+    """
+
+    @csrf_exempt
+    def dispatch(self, request, pipeline):
+        if "oauth_token" in request.GET:
+            return pipeline.next_step()
+
+        config = pipeline.fetch_state("installation_data")
+        client = BitbucketServerSetupClient(
+            config.get("url"),
+            config.get("consumer_key"),
+            config.get("private_key"),
+            config.get("verify_ssl"),
+        )
+
+        try:
+            request_token = client.get_request_token()
+            pipeline.bind_state("request_token", request_token)
+            authorize_url = client.get_authorize_url(request_token)
+
+            return self.redirect(authorize_url)
+        except ApiError as error:
+            logger.info(
+                "identity.bitbucket-server.request-token",
+                extra={"url": config.get("url"), "error": error},
+            )
+            return pipeline.error("Could not fetch a request token from Bitbucket. %s" % error)
+
+
+class OAuthCallbackView(PipelineView):
+    """
+    Complete the OAuth dance by exchanging our request token
+    into an access token.
+    """
+
+    @csrf_exempt
+    def dispatch(self, request, pipeline):
+        config = pipeline.fetch_state("installation_data")
+        client = BitbucketServerSetupClient(
+            config.get("url"),
+            config.get("consumer_key"),
+            config.get("private_key"),
+            config.get("verify_ssl"),
+        )
+
+        try:
+            access_token = client.get_access_token(
+                pipeline.fetch_state("request_token"), request.GET["oauth_token"]
+            )
+
+            pipeline.bind_state("access_token", access_token)
+
+            return pipeline.next_step()
+        except ApiError as error:
+            logger.info("identity.bitbucket-server.access-token", extra={"error": error})
+            return pipeline.error(
+                "Could not fetch an access token from Bitbucket. %s" % six.binary_type(error)
+            )
+
+
+class BitbucketServerIntegration(IntegrationInstallation, RepositoryMixin):
+    """
+        IntegrationInstallation implementation for Bitbucket Server
+    """
+
+    repo_search = True
+
+    default_identity = None
+
+    def get_client(self):
+        if self.default_identity is None:
+            self.default_identity = self.get_default_identity()
+
+        return BitbucketServer(
+            self.model.metadata["base_url"],
+            self.default_identity.data,
+            self.model.metadata["verify_ssl"],
+        )
+
+    @property
+    def username(self):
+        return self.model.name
+
+    def error_message_from_json(self, data):
+        return data.get("error", {}).get("message", "unknown error")
+
+    def get_repositories(self, query=None):
+        if not query:
+            resp = self.get_client().get_repos()
+
+            return [
+                {
+                    "identifier": repo["project"]["key"] + "/" + repo["slug"],
+                    "project": repo["project"]["key"],
+                    "repo": repo["slug"],
+                    "name": repo["project"]["name"] + "/" + repo["name"],
+                }
+                for repo in resp.get("values", [])
+            ]
+
+        full_query = (query).encode("utf-8")
+        resp = self.get_client().search_repositories(full_query)
+
+        return [
+            {
+                "identifier": repo["project"]["key"] + "/" + repo["slug"],
+                "project": repo["project"]["key"],
+                "repo": repo["slug"],
+                "name": repo["project"]["name"] + "/" + repo["name"],
+            }
+            for repo in resp.get("values", [])
+        ]
+
+    def has_repo_access(self, repo):
+        """
+        We can assume user always has repo access, since the Bitbucket API is limiting the results based on the REPO_ADMIN permission
+        """
+
+        return True
+
+    def get_unmigratable_repositories(self):
+        repos = Repository.objects.filter(
+            organization_id=self.organization_id, provider="bitbucket_server"
+        )
+
+        accessible_repos = [r["identifier"] for r in self.get_repositories()]
+
+        return filter(lambda repo: repo.name not in accessible_repos, repos)
+
+    def reinstall(self):
+        self.reinstall_repositories()
+
+
+class BitbucketServerIntegrationProvider(IntegrationProvider):
+    key = "bitbucket_server"
+    name = "Bitbucket Server"
+    metadata = metadata
+    integration_cls = BitbucketServerIntegration
+    needs_default_identity = True
+    can_add = True
+    features = frozenset([IntegrationFeatures.COMMITS])
+    setup_dialog_config = {"width": 1030, "height": 1000}
+
+    def get_pipeline_views(self):
+        return [InstallationConfigView(), OAuthLoginView(), OAuthCallbackView()]
+
+    def post_install(self, integration, organization):
+        repo_ids = Repository.objects.filter(
+            organization_id=organization.id,
+            provider__in=["bitbucket_server", "integrations:bitbucket_server"],
+            integration_id__isnull=True,
+        ).values_list("id", flat=True)
+
+        for repo_id in repo_ids:
+            migrate_repo.apply_async(
+                kwargs={
+                    "repo_id": repo_id,
+                    "integration_id": integration.id,
+                    "organization_id": organization.id,
+                }
+            )
+
+    def build_integration(self, state):
+        install = state["installation_data"]
+        access_token = state["access_token"]
+
+        hostname = urlparse(install["url"]).netloc
+        external_id = u"{}:{}".format(hostname, install["consumer_key"])[:64]
+
+        credentials = {
+            "consumer_key": install["consumer_key"],
+            "private_key": install["private_key"],
+            "access_token": access_token["oauth_token"],
+            "access_token_secret": access_token["oauth_token_secret"],
+        }
+
+        return {
+            "name": install["consumer_key"],
+            "provider": self.key,
+            "external_id": external_id,
+            "metadata": {
+                "base_url": install["url"],
+                "domain_name": hostname,
+                "verify_ssl": install["verify_ssl"],
+            },
+            "user_identity": {
+                "type": self.key,
+                "external_id": external_id,
+                "data": credentials,
+                "scopes": [],
+            },
+        }
+
+    def setup(self):
+        from sentry.plugins.base import bindings
+
+        bindings.add(
+            "integration-repository.provider",
+            BitbucketServerRepositoryProvider,
+            id="integrations:%s" % self.key,
+        )
diff --git a/src/sentry/integrations/bitbucket_server/repository.py b/src/sentry/integrations/bitbucket_server/repository.py
new file mode 100644
index 0000000000..b54567fe6e
--- /dev/null
+++ b/src/sentry/integrations/bitbucket_server/repository.py
@@ -0,0 +1,129 @@
+from __future__ import absolute_import
+
+import six
+
+from datetime import datetime
+from django.utils import timezone
+from django.core.urlresolvers import reverse
+from sentry.models.integration import Integration
+from sentry.plugins.providers.integration_repository import IntegrationRepositoryProvider
+from sentry.utils.http import absolute_uri
+from sentry.integrations.exceptions import ApiError, IntegrationError
+
+
+class BitbucketServerRepositoryProvider(IntegrationRepositoryProvider):
+    name = "Bitbucket Server"
+
+    def get_installation(self, integration_id, organization_id):
+        if integration_id is None:
+            raise IntegrationError("Bitbucket Server requires an integration id.")
+        integration_model = Integration.objects.get(
+            id=integration_id, organizations=organization_id, provider="bitbucket_server"
+        )
+
+        return integration_model.get_installation(organization_id)
+
+    def get_repository_data(self, organization, config):
+        installation = self.get_installation(config.get("installation"), organization.id)
+        client = installation.get_client()
+        try:
+            project, repo = config["identifier"].split("/", 1)
+            repo = client.get_repo(project, repo)
+        except Exception as e:
+            installation.raise_error(e)
+        else:
+            config["external_id"] = six.text_type(repo["id"])
+            config["name"] = repo["project"]["key"] + "/" + repo["name"]
+            config["project"] = repo["project"]["key"]
+            config["repo"] = repo["name"]
+        return config
+
+    def build_repository_config(self, organization, data):
+        installation = self.get_installation(data.get("installation"), organization.id)
+        client = installation.get_client()
+
+        try:
+            resp = client.create_hook(
+                data["project"],
+                data["repo"],
+                {
+                    "name": "sentry-bitbucket-server-repo-hook",
+                    "url": absolute_uri(
+                        reverse(
+                            "sentry-extensions-bitbucketserver-webhook",
+                            kwargs={
+                                "organization_id": organization.id,
+                                "integration_id": data.get("installation"),
+                            },
+                        )
+                    ),
+                    "active": True,
+                    "events": ["repo:refs_changed", "pr:merged"],
+                },
+            )
+        except Exception as e:
+            installation.raise_error(e)
+        else:
+            return {
+                "name": data["identifier"],
+                "external_id": data["external_id"],
+                "url": installation.model.metadata["base_url"]
+                + u"/projects/{project}/repos/{repo}/browse".format(
+                    project=data["project"], repo=data["repo"]
+                ),
+                "config": {
+                    "name": data["identifier"],
+                    "project": data["project"],
+                    "repo": data["repo"],
+                    "webhook_id": resp["id"],
+                },
+                "integration_id": data["installation"],
+            }
+
+    def on_delete_repository(self, repo):
+        installation = self.get_installation(repo.integration_id, repo.organization_id)
+        client = installation.get_client()
+
+        try:
+            client.delete_hook(
+                repo.config["project"], repo.config["repo"], repo.config["webhook_id"]
+            )
+        except ApiError as exc:
+            if exc.code == 404:
+                return
+            raise
+
+    def _format_commits(self, repo, commit_list):
+        return [
+            {
+                "id": c["id"],
+                "repository": repo.name,
+                "author_email": c["author"]["emailAddress"],
+                "author_name": c["author"]["displayName"],
+                "message": c["message"],
+                "timestamp": datetime.fromtimestamp(c["authorTimestamp"] / 1000, timezone.utc),
+                "patch_set": None,
+            }
+            for c in commit_list["values"]
+        ]
+
+    def compare_commits(self, repo, start_sha, end_sha):
+        installation = self.get_installation(repo.integration_id, repo.organization_id)
+        client = installation.get_client()
+        # use config name because that is kept in sync via webhooks
+
+        # Bitbucket servers send an empty commit as a string of zeros
+        if "0" * 40 == start_sha:
+            start_sha = None
+
+        try:
+            res = client.get_commits(
+                repo.config["project"], repo.config["repo"], start_sha, end_sha
+            )
+        except Exception as e:
+            installation.raise_error(e)
+        else:
+            return self._format_commits(repo, res)
+
+    def repository_external_slug(self, repo):
+        return repo.name
diff --git a/src/sentry/integrations/bitbucket_server/urls.py b/src/sentry/integrations/bitbucket_server/urls.py
new file mode 100644
index 0000000000..fb5d85a290
--- /dev/null
+++ b/src/sentry/integrations/bitbucket_server/urls.py
@@ -0,0 +1,12 @@
+from __future__ import absolute_import
+
+from django.conf.urls import url
+from .webhook import BitbucketServerWebhookEndpoint
+
+urlpatterns = [
+    url(
+        r"^organizations/(?P<organization_id>[^\/]+)/webhook/(?P<integration_id>\d+)/$",
+        BitbucketServerWebhookEndpoint.as_view(),
+        name="sentry-extensions-bitbucketserver-webhook",
+    )
+]
diff --git a/src/sentry/integrations/bitbucket_server/webhook.py b/src/sentry/integrations/bitbucket_server/webhook.py
new file mode 100644
index 0000000000..534e7392bb
--- /dev/null
+++ b/src/sentry/integrations/bitbucket_server/webhook.py
@@ -0,0 +1,159 @@
+from __future__ import absolute_import
+
+import logging
+
+import six
+
+from datetime import datetime
+from django.db import IntegrityError, transaction
+from django.http import HttpResponse, Http404
+from django.utils import timezone
+from django.utils.decorators import method_decorator
+from django.views.decorators.csrf import csrf_exempt
+from django.views.generic.base import View
+from simplejson import JSONDecodeError
+from sentry.models import Commit, CommitAuthor, Organization, Repository
+from sentry.plugins.providers import IntegrationRepositoryProvider
+from sentry.utils import json
+
+logger = logging.getLogger("sentry.webhooks")
+
+PROVIDER_NAME = "integrations:bitbucket_server"
+
+
+class Webhook(object):
+    def __call__(self, organization, integration_id, event):
+        raise NotImplementedError
+
+    def update_repo_data(self, repo, event):
+        """
+        Given a webhook payload, update stored repo data if needed.
+        """
+
+        name_from_event = event["repository"]["project"]["key"] + "/" + event["repository"]["slug"]
+        # build the URL manually since it doesn't come back from the API in
+        # the form that we need
+        url_from_event = event["repository"]["links"]["self"][0]["href"]
+
+        if (
+            repo.name != name_from_event
+            or repo.config.get("name") != name_from_event
+            or repo.url != url_from_event
+        ):
+            repo.update(name=name_from_event, config=dict(repo.config, name=name_from_event))
+
+
+class PushEventWebhook(Webhook):
+    def __call__(self, organization, integration_id, event):
+        authors = {}
+
+        try:
+            repo = Repository.objects.get(
+                organization_id=organization.id,
+                provider=PROVIDER_NAME,
+                external_id=six.text_type(event["repository"]["id"]),
+            )
+        except Repository.DoesNotExist:
+            raise Http404()
+
+        client = repo.get_provider().get_installation(integration_id, organization.id).get_client()
+
+        # while we're here, make sure repo data is up to date
+        self.update_repo_data(repo, event)
+
+        [project_name, repo_name] = repo.name.split("/")
+
+        for change in event["changes"]:
+            from_hash = None if change.get("fromHash") == "0" * 40 else change.get("fromHash")
+            for commit in client.get_commits(
+                project_name, repo_name, from_hash, change.get("toHash")
+            )["values"]:
+
+                if IntegrationRepositoryProvider.should_ignore_commit(commit["message"]):
+                    continue
+
+                author_email = commit["author"]["emailAddress"]
+
+                # its optional, lets just throw it out for now
+                if author_email is None or len(author_email) > 75:
+                    author = None
+                elif author_email not in authors:
+                    authors[author_email] = author = CommitAuthor.objects.get_or_create(
+                        organization_id=organization.id,
+                        email=author_email,
+                        defaults={"name": commit["author"]["name"]},
+                    )[0]
+                else:
+                    author = authors[author_email]
+                try:
+                    with transaction.atomic():
+
+                        Commit.objects.create(
+                            repository_id=repo.id,
+                            organization_id=organization.id,
+                            key=commit["id"],
+                            message=commit["message"],
+                            author=author,
+                            date_added=datetime.fromtimestamp(
+                                commit["authorTimestamp"] / 1000, timezone.utc
+                            ),
+                        )
+
+                except IntegrityError:
+                    pass
+
+
+class BitbucketServerWebhookEndpoint(View):
+    _handlers = {"repo:refs_changed": PushEventWebhook}
+
+    def get_handler(self, event_type):
+        return self._handlers.get(event_type)
+
+    @method_decorator(csrf_exempt)
+    def dispatch(self, request, *args, **kwargs):
+        if request.method != "POST":
+            return HttpResponse(status=405)
+
+        return super(BitbucketServerWebhookEndpoint, self).dispatch(request, *args, **kwargs)
+
+    def post(self, request, organization_id, integration_id):
+        try:
+            organization = Organization.objects.get_from_cache(id=organization_id)
+        except Organization.DoesNotExist:
+            logger.error(
+                PROVIDER_NAME + ".webhook.invalid-organization",
+                extra={"organization_id": organization_id, "integration_id": integration_id},
+            )
+            return HttpResponse(status=400)
+
+        body = six.binary_type(request.body)
+        if not body:
+            logger.error(
+                PROVIDER_NAME + ".webhook.missing-body", extra={"organization_id": organization.id}
+            )
+            return HttpResponse(status=400)
+
+        try:
+            handler = self.get_handler(request.META["HTTP_X_EVENT_KEY"])
+        except KeyError:
+            logger.error(
+                PROVIDER_NAME + ".webhook.missing-event",
+                extra={"organization_id": organization.id, "integration_id": integration_id},
+            )
+            return HttpResponse(status=400)
+
+        if not handler:
+            return HttpResponse(status=204)
+
+        try:
+            event = json.loads(body.decode("utf-8"))
+        except JSONDecodeError:
+            logger.error(
+                PROVIDER_NAME + ".webhook.invalid-json",
+                extra={"organization_id": organization.id, "integration_id": integration_id},
+                exc_info=True,
+            )
+            return HttpResponse(status=400)
+
+        handler()(organization, integration_id, event)
+        return HttpResponse(status=204)
diff --git a/src/sentry/static/sentry/app/plugins/components/pluginIcon.tsx b/src/sentry/static/sentry/app/plugins/components/pluginIcon.tsx
index 5be73d2ee7..2a68743297 100644
--- a/src/sentry/static/sentry/app/plugins/components/pluginIcon.tsx
+++ b/src/sentry/static/sentry/app/plugins/components/pluginIcon.tsx
@@ -6,6 +6,7 @@ import sentry from 'app/../images/logos/logo-sentry.svg';
 import amixr from 'app/../images/logos/logo-amixr.svg';
 import asana from 'app/../images/logos/logo-asana.svg';
 import bitbucket from 'app/../images/logos/logo-bitbucket.svg';
+import bitbucketserver from 'app/../images/logos/logo-bitbucket-server.svg';
 import campfire from 'app/../images/logos/logo-campfire.svg';
 import clickup from 'app/../images/logos/logo-clickup.svg';
 import clubhouse from 'app/../images/logos/logo-clubhouse.svg';
@@ -48,6 +49,7 @@ export const ICON_PATHS = {
   amixr,
   asana,
   bitbucket,
+  bitbucket_server: bitbucketserver,
   campfire,
   clickup,
   clubhouse,
diff --git a/src/sentry/static/sentry/images/logos/logo-bitbucket-server.svg b/src/sentry/static/sentry/images/logos/logo-bitbucket-server.svg
new file mode 100644
index 0000000000..8ff698a6ef
--- /dev/null
+++ b/src/sentry/static/sentry/images/logos/logo-bitbucket-server.svg
@@ -0,0 +1 @@
+<svg id="Logos" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="10 10 60 60"><defs><style>.cls-1{fill:none;}.cls-2{fill:#7a869a;}.cls-3{fill:url(#New_Gradient_Swatch_4);}</style><linearGradient id="New_Gradient_Swatch_4" x1="71.61" y1="36.15" x2="41.78" y2="59.43" gradientUnits="userSpaceOnUse"><stop offset="0.18" stop-color="#344563"/><stop offset="1" stop-color="#7a869a"/></linearGradient></defs><title>bitbucket-icon-gradient-neutral</title><polygon class="cls-1" points="33.81 48.88 46.36 48.88 49.39 31.2 30.47 31.2 33.81 48.88"/><path class="cls-2" d="M12,13.06a1.92,1.92,0,0,0-1.9,2.23l8.14,49.56A2.62,2.62,0,0,0,20.78,67H60a1.93,1.93,0,0,0,1.9-1.62L70,15.3a1.92,1.92,0,0,0-1.9-2.23ZM46.36,48.88H33.81L30.47,31.2H49.39Z"/><path class="cls-3" d="M67.44,31.2h-18l-3,17.68H33.81L19.1,66.4a2.61,2.61,0,0,0,1.68.63H60a1.93,1.93,0,0,0,1.9-1.62Z"/></svg>
\ No newline at end of file
diff --git a/src/sentry/templates/sentry/integrations/bitbucket-server-config.html b/src/sentry/templates/sentry/integrations/bitbucket-server-config.html
new file mode 100644
index 0000000000..8dc18d80fa
--- /dev/null
+++ b/src/sentry/templates/sentry/integrations/bitbucket-server-config.html
@@ -0,0 +1,57 @@
+{% extends "sentry/bases/modal.html" %}
+{% load crispy_forms_tags %}
+{% load sentry_assets %}
+{% load i18n %}
+
+{% block css %}
+  <style>
+    ol li {
+      padding:10px 0px;
+    }
+    .code-list {
+      padding: 10px;
+      background-color: #f7f8f9;
+      margin-top: 10px;
+      border-radius: 3px;
+    }
+    .code-list li {
+      font-size: 90%;
+    }
+  </style>
+{% endblock %}
+
+{% block wrapperclass %} narrow auth {% endblock %}
+{% block modal_header_signout %} {% endblock %}
+
+{% block title %} {% trans "Bitbucket-Server Setup" %} | {{ block.super }} {% endblock %}
+
+{% block main %}
+<h3>{% trans "Connect Sentry with your App" %}</h3>
+  <p>{% trans "Add your Bitbucket Server App credentials to Sentry." %}</p>
+  <p class="alert alert-block flex">
+    <i class="icon icon-exclamation"></i>
+    <span>
+        {% blocktrans %}
+        You must complete the <a href="https://docs.sentry.io/workflow/integrations/global-integrations/bitbucket-server/">required steps</a>
+
+        in Bitbucket Server before attempting to connect with Sentry.
+        {% endblocktrans %}
+    </span>
+  </p>
+  <form action="" method="post" class="form-stacked">
+    {% csrf_token %}
+    <input type="hidden" name="provider" value="bitbucket_server" />
+
+    {{ form|as_crispy_errors }}
+
+    {% for field in form %}
+    {{ field|as_crispy_field }}
+    {% endfor %}
+
+    <fieldset class="form-actions clearfix">
+      <div class="pull-right">
+        <button type="submit" class="btn btn-primary" name="save_mappings" value="url">{% trans "Submit" %}</button>
+      </div>
+    </fieldset>
+  </form>
+{% endblock %}
diff --git a/src/sentry/utils/pytest/sentry.py b/src/sentry/utils/pytest/sentry.py
index 93612013f2..e8d82dcd93 100644
--- a/src/sentry/utils/pytest/sentry.py
+++ b/src/sentry/utils/pytest/sentry.py
@@ -182,6 +182,7 @@ def register_extensions():
 
     from sentry import integrations
     from sentry.integrations.bitbucket import BitbucketIntegrationProvider
+    from sentry.integrations.bitbucket_server import BitbucketServerIntegrationProvider
     from sentry.integrations.example import (
         ExampleIntegrationProvider,
         AliasedIntegrationProvider,
@@ -199,6 +200,7 @@ def register_extensions():
     from sentry.integrations.pagerduty.integration import PagerDutyIntegrationProvider
 
     integrations.register(BitbucketIntegrationProvider)
+    integrations.register(BitbucketServerIntegrationProvider)
     integrations.register(ExampleIntegrationProvider)
     integrations.register(AliasedIntegrationProvider)
     integrations.register(ServerExampleProvider)
diff --git a/src/sentry/web/urls.py b/src/sentry/web/urls.py
index b04a45a3d0..27d4e5ef8e 100644
--- a/src/sentry/web/urls.py
+++ b/src/sentry/web/urls.py
@@ -630,6 +630,7 @@ urlpatterns += [
                 url(r"^gitlab/", include("sentry.integrations.gitlab.urls")),
                 url(r"^vsts/", include("sentry.integrations.vsts.urls")),
                 url(r"^bitbucket/", include("sentry.integrations.bitbucket.urls")),
+                url(r"^bitbucket-server/", include("sentry.integrations.bitbucket_server.urls")),
             ]
         ),
     ),
diff --git a/tests/sentry/integrations/bitbucket_server/__init__.py b/tests/sentry/integrations/bitbucket_server/__init__.py
new file mode 100644
index 0000000000..c3961685ab
--- /dev/null
+++ b/tests/sentry/integrations/bitbucket_server/__init__.py
@@ -0,0 +1 @@
+from __future__ import absolute_import
diff --git a/tests/sentry/integrations/bitbucket_server/test_integration.py b/tests/sentry/integrations/bitbucket_server/test_integration.py
new file mode 100644
index 0000000000..0ee8e73ee8
--- /dev/null
+++ b/tests/sentry/integrations/bitbucket_server/test_integration.py
@@ -0,0 +1,329 @@
+from __future__ import absolute_import
+
+import responses
+
+from requests.exceptions import ReadTimeout
+from sentry.integrations.bitbucket_server import BitbucketServerIntegrationProvider
+from sentry.models import Identity, IdentityProvider, Integration, OrganizationIntegration
+from sentry.testutils import IntegrationTestCase
+from .testutils import EXAMPLE_PRIVATE_KEY
+
+
+class BitbucketServerIntegrationTest(IntegrationTestCase):
+    provider = BitbucketServerIntegrationProvider
+
+    def test_config_view(self):
+        resp = self.client.get(self.init_path)
+        assert resp.status_code == 200
+
+        resp = self.client.get(self.setup_path)
+        assert resp.status_code == 200
+        self.assertContains(resp, "Connect Sentry")
+        self.assertContains(resp, "Submit</button>")
+
+    @responses.activate
+    def test_validate_url(self):
+        # Start pipeline and go to setup page.
+        self.client.get(self.setup_path)
+
+        # Submit credentials
+        data = {
+            "url": "bitbucket.example.com/",
+            "verify_ssl": False,
+            "consumer_key": "sentry-bot",
+            "private_key": EXAMPLE_PRIVATE_KEY,
+        }
+        resp = self.client.post(self.setup_path, data=data)
+        assert resp.status_code == 200
+        self.assertContains(resp, "Enter a valid URL")
+
+    @responses.activate
+    def test_validate_private_key(self):
+        responses.add(
+            responses.POST,
+            "https://bitbucket.example.com/plugins/servlet/oauth/request-token",
+            status=503,
+        )
+
+        # Start pipeline and go to setup page.
+        self.client.get(self.setup_path)
+
+        # Submit credentials
+        data = {
+            "url": "https://bitbucket.example.com/",
+            "verify_ssl": False,
+            "consumer_key": "sentry-bot",
+            "private_key": "hot-garbage",
+        }
+        resp = self.client.post(self.setup_path, data=data)
+        assert resp.status_code == 200
+        self.assertContains(
+            resp, "Private key must be a valid SSH private key encoded in a PEM format."
+        )
+
+    @responses.activate
+    def test_validate_consumer_key_length(self):
+        # Start pipeline and go to setup page.
+        self.client.get(self.setup_path)
+
+        # Submit credentials
+        data = {
+            "url": "bitbucket.example.com/",
+            "verify_ssl": False,
+            "consumer_key": "x" * 201,
+            "private_key": EXAMPLE_PRIVATE_KEY,
+        }
+        resp = self.client.post(self.setup_path, data=data)
+        assert resp.status_code == 200
+        self.assertContains(resp, "Consumer key is limited to 200")
+
+    @responses.activate
+    def test_authentication_request_token_timeout(self):
+        timeout = ReadTimeout("Read timed out. (read timeout=30)")
+        responses.add(
+            responses.POST,
+            "https://bitbucket.example.com/plugins/servlet/oauth/request-token",
+            body=timeout,
+        )
+
+        # Start pipeline and go to setup page.
+        self.client.get(self.setup_path)
+
+        # Submit credentials
+        data = {
+            "url": "https://bitbucket.example.com/",
+            "verify_ssl": False,
+            "consumer_key": "sentry-bot",
+            "private_key": EXAMPLE_PRIVATE_KEY,
+        }
+        resp = self.client.post(self.setup_path, data=data)
+        assert resp.status_code == 200
+        self.assertContains(resp, "Setup Error")
+        self.assertContains(resp, "request token from Bitbucket")
+        self.assertContains(resp, "Timed out")
+
+    @responses.activate
+    def test_authentication_request_token_fails(self):
+        responses.add(
+            responses.POST,
+            "https://bitbucket.example.com/plugins/servlet/oauth/request-token",
+            status=503,
+        )
+
+        # Start pipeline and go to setup page.
+        self.client.get(self.setup_path)
+
+        # Submit credentials
+        data = {
+            "url": "https://bitbucket.example.com/",
+            "verify_ssl": False,
+            "consumer_key": "sentry-bot",
+            "private_key": EXAMPLE_PRIVATE_KEY,
+        }
+        resp = self.client.post(self.setup_path, data=data)
+        assert resp.status_code == 200
+        self.assertContains(resp, "Setup Error")
+        self.assertContains(resp, "request token from Bitbucket")
+
+    @responses.activate
+    def test_authentication_request_token_redirect(self):
+        responses.add(
+            responses.POST,
+            "https://bitbucket.example.com/plugins/servlet/oauth/request-token",
+            status=200,
+            content_type="text/plain",
+            body="oauth_token=abc123&oauth_token_secret=def456",
+        )
+
+        # Start pipeline
+        self.client.get(self.init_path)
+
+        # Submit credentials
+        data = {
+            "url": "https://bitbucket.example.com/",
+            "verify_ssl": False,
+            "consumer_key": "sentry-bot",
+            "private_key": EXAMPLE_PRIVATE_KEY,
+        }
+        resp = self.client.post(self.setup_path, data=data)
+        assert resp.status_code == 302
+        redirect = (
+            "https://bitbucket.example.com/plugins/servlet/oauth/authorize?oauth_token=abc123"
+        )
+        assert redirect == resp["Location"]
+
+    @responses.activate
+    def test_authentication_access_token_failure(self):
+        responses.add(
+            responses.POST,
+            "https://bitbucket.example.com/plugins/servlet/oauth/request-token",
+            status=200,
+            content_type="text/plain",
+            body="oauth_token=abc123&oauth_token_secret=def456",
+        )
+        responses.add(
+            responses.POST,
+            "https://bitbucket.example.com/plugins/servlet/oauth/access-token",
+            status=500,
+            content_type="text/plain",
+            body="<html>it broke</html>",
+        )
+
+        # Get config page
+        resp = self.client.get(self.init_path)
+        assert resp.status_code == 200
+
+        # Submit credentials
+        data = {
+            "url": "https://bitbucket.example.com/",
+            "verify_ssl": False,
+            "consumer_key": "sentry-bot",
+            "private_key": EXAMPLE_PRIVATE_KEY,
+        }
+        resp = self.client.post(self.setup_path, data=data)
+        assert resp.status_code == 302
+        assert resp["Location"]
+
+        resp = self.client.get(self.setup_path + "?oauth_token=xyz789")
+        assert resp.status_code == 200
+        self.assertContains(resp, "Setup Error")
+        self.assertContains(resp, "access token from Bitbucket")
+
+    def install_integration(self):
+        # Get config page
+        resp = self.client.get(self.setup_path)
+        assert resp.status_code == 200
+
+        # Submit credentials
+        data = {
+            "url": "https://bitbucket.example.com/",
+            "verify_ssl": False,
+            "consumer_key": "sentry-bot",
+            "private_key": EXAMPLE_PRIVATE_KEY,
+        }
+        resp = self.client.post(self.setup_path, data=data)
+        assert resp.status_code == 302
+        assert resp["Location"]
+
+        resp = self.client.get(self.setup_path + "?oauth_token=xyz789")
+        assert resp.status_code == 200
+
+        return resp
+
+    @responses.activate
+    def test_authentication_verifier_expired(self):
+        responses.add(
+            responses.POST,
+            "https://bitbucket.example.com/plugins/servlet/oauth/request-token",
+            status=200,
+            content_type="text/plain",
+            body="oauth_token=abc123&oauth_token_secret=def456",
+        )
+        responses.add(
+            responses.POST,
+            "https://bitbucket.example.com/plugins/servlet/oauth/access-token",
+            status=404,
+            content_type="text/plain",
+            body="oauth_error=token+expired",
+        )
+
+        # Try getting the token but it has expired for some reason,
+        # perhaps a stale reload/history navigate.
+        resp = self.install_integration()
+
+        self.assertContains(resp, "Setup Error")
+        self.assertContains(resp, "access token from Bitbucket")
+
+    @responses.activate
+    def test_authentication_success(self):
+        responses.add(
+            responses.POST,
+            "https://bitbucket.example.com/plugins/servlet/oauth/request-token",
+            status=200,
+            content_type="text/plain",
+            body="oauth_token=abc123&oauth_token_secret=def456",
+        )
+        responses.add(
+            responses.POST,
+            "https://bitbucket.example.com/plugins/servlet/oauth/access-token",
+            status=200,
+            content_type="text/plain",
+            body="oauth_token=valid-token&oauth_token_secret=valid-secret",
+        )
+        responses.add(
+            responses.POST,
+            "https://bitbucket.example.com/rest/webhooks/1.0/webhook",
+            status=204,
+            body="",
+        )
+
+        self.install_integration()
+
+        integration = Integration.objects.get()
+        assert integration.name == "sentry-bot"
+        assert integration.metadata["domain_name"] == "bitbucket.example.com"
+        assert integration.metadata["base_url"] == "https://bitbucket.example.com"
+        assert integration.metadata["verify_ssl"] is False
+
+        org_integration = OrganizationIntegration.objects.get(
+            integration=integration, organization=self.organization
+        )
+        assert org_integration.config == {}
+
+        idp = IdentityProvider.objects.get(type="bitbucket_server")
+        identity = Identity.objects.get(
+            idp=idp, user=self.user, external_id="bitbucket.example.com:sentry-bot"
+        )
+        assert identity.data["consumer_key"] == "sentry-bot"
+        assert identity.data["access_token"] == "valid-token"
+        assert identity.data["access_token_secret"] == "valid-secret"
+        assert identity.data["private_key"] == EXAMPLE_PRIVATE_KEY
+
+    @responses.activate
+    def test_setup_external_id_length(self):
+        responses.add(
+            responses.POST,
+            "https://bitbucket.example.com/plugins/servlet/oauth/request-token",
+            status=200,
+            content_type="text/plain",
+            body="oauth_token=abc123&oauth_token_secret=def456",
+        )
+        responses.add(
+            responses.POST,
+            "https://bitbucket.example.com/plugins/servlet/oauth/access-token",
+            status=200,
+            content_type="text/plain",
+            body="oauth_token=valid-token&oauth_token_secret=valid-secret",
+        )
+        responses.add(
+            responses.POST,
+            "https://bitbucket.example.com/rest/webhooks/1.0/webhook",
+            status=204,
+            body="",
+        )
+
+        # Start pipeline and go to setup page.
+        self.client.get(self.setup_path)
+
+        # Submit credentials
+        data = {
+            "url": "https://bitbucket.example.com/",
+            "verify_ssl": False,
+            "consumer_key": "a-very-long-consumer-key-that-when-combined-with-host-would-overflow",
+            "private_key": EXAMPLE_PRIVATE_KEY,
+        }
+        resp = self.client.post(self.setup_path, data=data)
+        assert resp.status_code == 302
+        redirect = (
+            "https://bitbucket.example.com/plugins/servlet/oauth/authorize?oauth_token=abc123"
+        )
+        assert redirect == resp["Location"]
+
+        resp = self.client.get(self.setup_path + "?oauth_token=xyz789")
+        assert resp.status_code == 200
+
+        integration = Integration.objects.get(provider="bitbucket_server")
+        assert (
+            integration.external_id
+            == "bitbucket.example.com:a-very-long-consumer-key-that-when-combine"
+        )
diff --git a/tests/sentry/integrations/bitbucket_server/test_repository.py b/tests/sentry/integrations/bitbucket_server/test_repository.py
new file mode 100644
index 0000000000..fcb313ba90
--- /dev/null
+++ b/tests/sentry/integrations/bitbucket_server/test_repository.py
@@ -0,0 +1,153 @@
+from __future__ import absolute_import
+
+import datetime
+import responses
+import pytest
+import six
+
+from django.utils import timezone
+from exam import fixture
+from sentry.models import Integration, Repository, IdentityProvider, Identity, IdentityStatus
+from sentry.testutils import APITestCase
+from sentry.integrations.bitbucket_server.repository import BitbucketServerRepositoryProvider
+from sentry.integrations.exceptions import IntegrationError
+from .testutils import EXAMPLE_PRIVATE_KEY, COMPARE_COMMITS_EXAMPLE, REPO
+
+
+class BitbucketServerRepositoryProviderTest(APITestCase):
+    @fixture
+    def integration(self):
+        integration = Integration.objects.create(
+            provider="bitbucket_server",
+            name="Example Bitbucket",
+            metadata={"verify_ssl": False, "base_url": "https://bitbucket.example.com"},
+        )
+        identity_provider = IdentityProvider.objects.create(
+            external_id="bitbucket.example.com:sentry-test", type="bitbucket_server"
+        )
+        identity = Identity.objects.create(
+            idp=identity_provider,
+            user=self.user,
+            scopes=(),
+            status=IdentityStatus.VALID,
+            data={
+                "consumer_key": "sentry-test",
+                "private_key": EXAMPLE_PRIVATE_KEY,
+                "access_token": "access-token",
+                "access_token_secret": "access-token-secret",
+            },
+        )
+        integration.add_organization(self.organization, self.user, default_auth_id=identity.id)
+        return integration
+
+    @fixture
+    def provider(self):
+        return BitbucketServerRepositoryProvider("bitbucket_server")
+
+    def test_get_client(self):
+        installation = self.integration.get_installation(self.organization.id)
+        client = installation.get_client()
+        assert client.base_url == self.integration.metadata["base_url"]
+        assert client.verify_ssl == self.integration.metadata["verify_ssl"]
+
+    @responses.activate
+    def test_compare_commits(self):
+        repo = Repository.objects.create(
+            provider="bitbucket_server",
+            name="sentryuser/newsdiffs",
+            organization_id=self.organization.id,
+            config={"name": "sentryuser/newsdiffs", "project": "sentryuser", "repo": "newsdiffs"},
+            integration_id=self.integration.id,
+        )
+
+        responses.add(
+            responses.GET,
+            "https://bitbucket.example.com/rest/api/1.0/projects/sentryuser/repos/newsdiffs/commits",
+            json=COMPARE_COMMITS_EXAMPLE,
+        )
+
+        res = self.provider.compare_commits(repo, None, "e18e4e72de0d824edfbe0d73efe34cbd0d01d301")
+
+        assert res == [
+            {
+                "author_email": "sentryuser@getsentry.com",
+                "author_name": "Sentry User",
+                "message": "README.md edited online with Bitbucket",
+                "id": "e18e4e72de0d824edfbe0d73efe34cbd0d01d301",
+                "repository": "sentryuser/newsdiffs",
+                "patch_set": None,
+                "timestamp": datetime.datetime(2019, 12, 19, 13, 56, 56, tzinfo=timezone.utc),
+            }
+        ]
+
+    @responses.activate
+    def test_build_repository_config(self):
+        project = u"laurynsentry"
+        repo = u"helloworld"
+        full_repo_name = u"%s/%s" % (project, repo)
+
+        webhook_id = 79
+        responses.add(
+            responses.GET,
+            "https://bitbucket.example.com/rest/api/1.0/projects/%s/repos/%s" % (project, repo),
+            json=REPO,
+        )
+        responses.add(
+            responses.POST,
+            "https://bitbucket.example.com/rest/api/1.0/projects/%s/repos/%s/webhooks"
+            % (project, repo),
+            json={"id": webhook_id},
+            status=201,
+        )
+
+        organization = self.organization
+        integration = self.integration
+
+        data = {
+            "provider": "integrations:bitbucket_server",
+            "identifier": project + "/" + repo,
+            "installation": integration.id,
+        }
+        data = self.provider.get_repository_data(organization, data)
+        assert data == {
+            "provider": "integrations:bitbucket_server",
+            "repo": repo,
+            "project": project,
+            "identifier": project + "/" + repo,
+            "name": full_repo_name,
+            "installation": integration.id,
+            "external_id": six.text_type(REPO["id"]),
+        }
+
+        data["identifier"] = full_repo_name
+        data = self.provider.build_repository_config(organization, data)
+
+        assert data == {
+            "name": full_repo_name,
+            "external_id": six.text_type(REPO["id"]),
+            "url": "https://bitbucket.example.com/projects/laurynsentry/repos/helloworld/browse",
+            "integration_id": integration.id,
+            "config": {
+                "name": full_repo_name,
+                "project": project,
+                "repo": repo,
+                "webhook_id": webhook_id,
+            },
+        }
+
+    def test_repository_external_slug(self):
+        repo = Repository.objects.create(
+            provider="bitbucket_server",
+            name="sentryuser/newsdiffs",
+            organization_id=self.organization.id,
+            config={"name": "sentryuser/newsdiffs"},
+            integration_id=self.integration.id,
+        )
+
+        result = self.provider.repository_external_slug(repo)
+        assert result == repo.name
+
+    def test_get_repository_data_no_installation_id(self):
+        with pytest.raises(IntegrationError) as e:
+            self.provider.get_repository_data(self.organization, {})
+            assert "requires an integration id" in six.text_type(e)
diff --git a/tests/sentry/integrations/bitbucket_server/testutils.py b/tests/sentry/integrations/bitbucket_server/testutils.py
new file mode 100644
index 0000000000..aab6d6f8e6
--- /dev/null
+++ b/tests/sentry/integrations/bitbucket_server/testutils.py
@@ -0,0 +1,109 @@
+from __future__ import absolute_import
+from collections import OrderedDict
+
+EXAMPLE_PRIVATE_KEY = """-----BEGIN RSA PRIVATE KEY-----
+MIICWwIBAAKBgQC1cd9t8sA03awggLiX2gjZxyvOVUPJksLly1E662tttTeR3Wm9
+eo6onNeI8HRD+O4wubUp4h4Chc7DtLDmFEPhUZ8Qkwztiifm99Xo3s0nUq4Pygp5
+AU09KXTEPbzHLh1dnXLcxVLmGDE4drh0NWmYsd/Zp7XNIZq2TRQQ3NTdVQIDAQAB
+AoGAFwMyS0eWiR30TssEnn3Q0Y4pSCoYRuCOR4bZ7pcdMPTi72UdnCKHJWt/Cqc0
+l8piq1tiVsWO+NLvvnKUXRoE4cAyrGrpf1F0uP5zYW71SQALc9wwsjDzuj7BZEuK
+fg35JSceLHWE1WtzPDX5Xg20YPnMrA/xe/RwuPjuBH0wSqECQQDizzmKdKCq0ejy
+3OxEto5knqpSEgRcOk0HDsdgjwkwiZJOj5ECV2FKpNHuu2thGy/aDJyLlmUso8j0
+OpvLAzOvAkEAzMwAgGexTxKm8hy3ilvVn9EvhSKjaIakqY4ONK9LZ4zMiDHI0H6C
+FXlwWX7CJM0YVFMubj8SB8rnIuvFDEBMOwJABHtRyMGbNyTktH/XD1iIIcbc2LhQ
+a74fLYeGOws4hEQDpxfBJsmxO3dcSppbedS+slFTepKjNymZW/IYh/9tMwJAEL5E
+9DqGBn7x4y1x2//yESTbC7lvPqZzY+FXS/tg4NBkEGZxkoolPHg3NTnlyXhzGsHK
+M/04DicKipJYA85l7QJAJ3u67qZXecM/oWTtJToBDuyKGHfdY1564+RbyDEjJJRb
+vz4O/8FQQ1sGjdEBMMrRBCHEG8o3/XDTrB97t45TeA==
+-----END RSA PRIVATE KEY-----"""
+
+COMPARE_COMMITS_EXAMPLE = {
+    "values": [
+        {
+            "id": "e18e4e72de0d824edfbe0d73efe34cbd0d01d301",
+            "displayId": "e18e4e72de0",
+            "author": {
+                "name": "SentryU",
+                "displayName": "Sentry User",
+                "emailAddress": "sentryuser@getsentry.com",
+                "type": "NORMAL",
+            },
+            "message": "README.md edited online with Bitbucket",
+            "authorTimestamp": 1576763816000,
+        }
+    ]
+}
+
+REPO = {
+    u"slug": u"helloworld",
+    u"id": 72,
+    u"name": u"helloworld",
+    u"scmId": u"git",
+    u"state": u"AVAILABLE",
+    u"statusMessage": u"Available",
+    u"forkable": True,
+    u"project": OrderedDict(
+        [
+            (u"key", u"laurynsentry"),
+            (u"id", 75),
+            (u"name", u"laurynsentry"),
+            (u"description", u""),
+            (u"public", False),
+            (u"type", u"Normal"),
+            (
+                u"links",
+                OrderedDict(
+                    [
+                        (
+                            u"self",
+                            OrderedDict(
+                                [(u"href", u"https://bitbucket.example.org/projects/laurynsentry")]
+                            ),
+                        )
+                    ]
+                ),
+            ),
+        ]
+    ),
+    u"public": False,
+    u"links": OrderedDict(
+        [
+            (
+                u"clone",
+                OrderedDict(
+                    [
+                        OrderedDict(
+                            [
+                                (
+                                    u"href",
+                                    u"https://bitbucket.example.org/scm/laurynsentry/helloworld.git",
+                                ),
+                                (u"name", u"http"),
+                            ]
+                        ),
+                        OrderedDict(
+                            [
+                                (
+                                    u"href",
+                                    u"ssh://git@bitbucket.example.org:7999/laurynsentry/helloworld.git",
+                                ),
+                                (u"name", u"ssh"),
+                            ]
+                        ),
+                    ]
+                ),
+            ),
+            (
+                u"self",
+                OrderedDict(
+                    [
+                        (
+                            u"href",
+                            u"https://bitbucket.example.org/projects/laurynsentry/repos/helloworld/browse",
+                        )
+                    ]
+                ),
+            ),
+        ]
+    ),
+}

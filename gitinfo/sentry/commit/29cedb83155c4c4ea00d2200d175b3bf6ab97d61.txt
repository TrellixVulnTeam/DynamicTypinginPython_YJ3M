commit 29cedb83155c4c4ea00d2200d175b3bf6ab97d61
Author: Armin Ronacher <armin.ronacher@active-4.com>
Date:   Mon Apr 27 14:06:08 2020 +0200

    feat(releases): Prevent deletion if a release has health data (#18474)

diff --git a/src/sentry/api/endpoints/organization_release_details.py b/src/sentry/api/endpoints/organization_release_details.py
index 240d64f909..58c699e1d0 100644
--- a/src/sentry/api/endpoints/organization_release_details.py
+++ b/src/sentry/api/endpoints/organization_release_details.py
@@ -14,13 +14,12 @@ from sentry.api.serializers.rest_framework import (
     ReleaseHeadCommitSerializer,
     ReleaseHeadCommitSerializerDeprecated,
 )
-from sentry.models import Activity, Group, Release, ReleaseFile, Project
+from sentry.models import Activity, Release, Project
+from sentry.models.release import UnsafeReleaseDeletion
 from sentry.utils.apidocs import scenario, attach_scenarios
 from sentry.snuba.sessions import STATS_PERIODS
 from sentry.api.endpoints.organization_releases import get_stats_period_detail
 
-ERR_RELEASE_REFERENCED = "This release is referenced by active issues and cannot be removed."
-
 
 @scenario("RetrieveOrganizationRelease")
 def retrieve_organization_release_scenario(runner):
@@ -219,18 +218,9 @@ class OrganizationReleaseDetailsEndpoint(OrganizationReleasesBaseEndpoint):
         if not self.has_release_permission(request, organization, release):
             raise ResourceDoesNotExist
 
-        # we don't want to remove the first_release metadata on the Group, and
-        # while people might want to kill a release (maybe to remove files),
-        # removing the release is prevented
-        if Group.objects.filter(first_release=release).exists():
-            return Response({"detail": ERR_RELEASE_REFERENCED}, status=400)
-
-        # TODO(dcramer): this needs to happen in the queue as it could be a long
-        # and expensive operation
-        file_list = ReleaseFile.objects.filter(release=release).select_related("file")
-        for releasefile in file_list:
-            releasefile.file.delete()
-            releasefile.delete()
-        release.delete()
+        try:
+            release.safe_delete()
+        except UnsafeReleaseDeletion as e:
+            return Response({"detail": six.text_type(e)}, status=400)
 
         return Response(status=204)
diff --git a/src/sentry/api/endpoints/project_release_details.py b/src/sentry/api/endpoints/project_release_details.py
index bb131554c4..ac7bbb1160 100644
--- a/src/sentry/api/endpoints/project_release_details.py
+++ b/src/sentry/api/endpoints/project_release_details.py
@@ -1,5 +1,7 @@
 from __future__ import absolute_import
 
+import six
+
 from rest_framework.response import Response
 from rest_framework.exceptions import ParseError
 
@@ -8,16 +10,14 @@ from sentry.api.exceptions import ResourceDoesNotExist
 from sentry.api.serializers import serialize
 from sentry.api.serializers.rest_framework import ReleaseSerializer
 
-from sentry.models import Activity, Group, Release, ReleaseFile
+from sentry.models import Activity, Release
+from sentry.models.release import UnsafeReleaseDeletion
 from sentry.plugins.interfaces.releasehook import ReleaseHook
 
 from sentry.snuba.sessions import STATS_PERIODS
 from sentry.api.endpoints.organization_releases import get_stats_period_detail
 
 
-ERR_RELEASE_REFERENCED = "This release is referenced by active issues and cannot be removed."
-
-
 class ProjectReleaseDetailsEndpoint(ProjectEndpoint):
     permission_classes = (ProjectReleasePermission,)
 
@@ -152,18 +152,9 @@ class ProjectReleaseDetailsEndpoint(ProjectEndpoint):
         except Release.DoesNotExist:
             raise ResourceDoesNotExist
 
-        # we don't want to remove the first_release metadata on the Group, and
-        # while people might want to kill a release (maybe to remove files),
-        # removing the release is prevented
-        if Group.objects.filter(first_release=release).exists():
-            return Response({"detail": ERR_RELEASE_REFERENCED}, status=400)
-
-        # TODO(dcramer): this needs to happen in the queue as it could be a long
-        # and expensive operation
-        file_list = ReleaseFile.objects.filter(release=release).select_related("file")
-        for releasefile in file_list:
-            releasefile.file.delete()
-            releasefile.delete()
-        release.delete()
+        try:
+            release.safe_delete()
+        except UnsafeReleaseDeletion as e:
+            return Response({"detail": six.text_type(e)}, status=400)
 
         return Response(status=204)
diff --git a/src/sentry/models/release.py b/src/sentry/models/release.py
index d9489f0f85..d9194b8eac 100644
--- a/src/sentry/models/release.py
+++ b/src/sentry/models/release.py
@@ -38,6 +38,14 @@ _dotted_path_prefix_re = re.compile(r"^([a-zA-Z][a-zA-Z0-9-]+)(\.[a-zA-Z][a-zA-Z
 DB_VERSION_LENGTH = 250
 
 
+ERR_RELEASE_REFERENCED = "This release is referenced by active issues and cannot be removed."
+ERR_RELEASE_HEALTH_DATA = "This release has health data and cannot be removed."
+
+
+class UnsafeReleaseDeletion(Exception):
+    pass
+
+
 class ReleaseProject(Model):
     __core__ = False
 
@@ -627,3 +635,32 @@ class Release(Model):
             kick_off_status_syncs.apply_async(
                 kwargs={"project_id": group_project_lookup[group_id], "group_id": group_id}
             )
+
+    def safe_delete(self):
+        """Deletes a release if possible or raises a `UnsafeReleaseDeletion`
+        exception.
+        """
+        from sentry.models import Group, ReleaseFile
+        from sentry.snuba.sessions import check_has_health_data
+
+        # we don't want to remove the first_release metadata on the Group, and
+        # while people might want to kill a release (maybe to remove files),
+        # removing the release is prevented
+        if Group.objects.filter(first_release=self).exists():
+            raise UnsafeReleaseDeletion(ERR_RELEASE_REFERENCED)
+
+        # We do not allow releases with health data to be deleted because
+        # the upserting from snuba data would create the release again.
+        # We would need to be able to delete this data from snuba which we
+        # can't do yet.
+        project_ids = list(self.projects.values_list("id").all())
+        if check_has_health_data([(p[0], self.version) for p in project_ids]):
+            raise UnsafeReleaseDeletion(ERR_RELEASE_HEALTH_DATA)
+
+        # TODO(dcramer): this needs to happen in the queue as it could be a long
+        # and expensive operation
+        file_list = ReleaseFile.objects.filter(release=self).select_related("file")
+        for releasefile in file_list:
+            releasefile.file.delete()
+            releasefile.delete()
+        self.delete()

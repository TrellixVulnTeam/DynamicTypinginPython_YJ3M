commit df1773d93e3465c627674f68246bf6b2302f6ec0
Author: Mark Story <mark@sentry.io>
Date:   Thu Feb 20 13:07:29 2020 -0500

    feat(discover) Add new row component for column modal (#17129)
    
    We're updating discover to have a new column editor that allows users to
    choose and order all their columns at once. This change adds the new
    column editor UX which lets users pick a column and function name.
    
    I've used a storybook as a way of prototyping the component outside of
    the application, as I don't want to disrupt customers or have to incur
    complexity around feature flags.
    
    The next step will be to add a collection of fields that can be drag
    resorted.

diff --git a/docs-ui/components/columnEditor.stories.js b/docs-ui/components/columnEditor.stories.js
new file mode 100644
index 0000000000..f5e798dd9e
--- /dev/null
+++ b/docs-ui/components/columnEditor.stories.js
@@ -0,0 +1,61 @@
+import React from 'react';
+import {storiesOf} from '@storybook/react';
+import {withInfo} from '@storybook/addon-info';
+import {action} from '@storybook/addon-actions';
+
+import ColumnEditRow from 'app/views/eventsV2/table/columnEditRow';
+
+storiesOf('Discover|ColumnEditor', module).add(
+  'all',
+  withInfo({
+    text: 'Playground for building out column editor v2 for discover',
+  })(() => {
+    const organization = {
+      slug: 'test-org',
+      features: ['transaction-events'],
+    };
+    const tags = ['browser.name', 'custom-field'];
+
+    const simple = {
+      field: 'event.type',
+    };
+    const simpleTag = {
+      field: 'browser.name',
+    };
+    const aggregateField = {
+      field: 'id',
+      aggregation: 'count',
+    };
+
+    return (
+      <div>
+        <h3>Basic field</h3>
+        <ColumnEditRow
+          organization={organization}
+          column={simple}
+          tagKeys={tags}
+          onChange={action('onchange')}
+          parentIndex={0}
+        />
+
+        <h3>Tag field</h3>
+        <ColumnEditRow
+          organization={organization}
+          column={simpleTag}
+          tagKeys={tags}
+          onChange={action('onchange')}
+          parentIndex={0}
+        />
+
+        <h3>Aggregate field</h3>
+        <ColumnEditRow
+          organization={organization}
+          column={aggregateField}
+          tagKeys={tags}
+          onChange={action('onchange')}
+          parentIndex={0}
+        />
+      </div>
+    );
+  })
+);
diff --git a/src/sentry/static/sentry/app/views/eventsV2/data.tsx b/src/sentry/static/sentry/app/views/eventsV2/data.tsx
index 672b619ed5..3fb8859d71 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/data.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/data.tsx
@@ -30,7 +30,7 @@ export const AGGREGATE_ALIASES = [
   'p99',
   'last_seen',
   'latest_event',
-] as const;
+];
 
 // default list of yAxis options
 export const CHART_AXIS_OPTIONS = [
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditRow.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditRow.tsx
new file mode 100644
index 0000000000..bf49433cc3
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditRow.tsx
@@ -0,0 +1,151 @@
+import React from 'react';
+import styled from '@emotion/styled';
+
+import SelectControl from 'app/components/forms/selectControl';
+import {OrganizationSummary, SelectValue} from 'app/types';
+import space from 'app/styles/space';
+
+import {
+  AGGREGATIONS,
+  FIELDS,
+  TRACING_FIELDS,
+  Field,
+  Aggregation,
+} from '../eventQueryParams';
+import {Column} from '../eventView';
+import {AGGREGATE_ALIASES} from '../data';
+
+type Props = {
+  organization: OrganizationSummary;
+  parentIndex: number;
+  column: Column;
+  tagKeys: string[];
+  onChange: (index: number, column: Column) => void;
+};
+
+type State = {
+  field: string;
+  fields: SelectValue<string>[];
+  aggregation: Aggregation;
+  aggregations: string[];
+};
+
+class ColumnEditRow extends React.Component<Props, State> {
+  state = {
+    field: this.props.column.field,
+    fields: generateOptions(Object.keys(FIELDS).concat(this.props.tagKeys)),
+    aggregation: this.props.column.aggregation as Aggregation,
+    aggregations: filterAggregations(this.props.organization, this.props.column.field),
+  };
+
+  componentDidUpdate(prevProps: Props) {
+    if (prevProps.tagKeys !== this.props.tagKeys) {
+      this.syncFields();
+    }
+  }
+
+  handleFieldChange = ({value}) => {
+    this.setState((state: State, props: Props) => {
+      const newAggregates = filterAggregations(props.organization, value);
+      const newState = {...state, field: value, aggregations: newAggregates};
+
+      // If the new field makes the aggregation invalid, we should clear that state.
+      if (state.aggregation && !newAggregates.includes(state.aggregation)) {
+        // TODO(mark) Figure out why react-select isn't wiping the text value when this happens.
+        newState.aggregation = '';
+      }
+      return newState;
+    }, this.triggerChange);
+  };
+
+  handleFunctionChange = ({value}) => {
+    // TODO(mark) When we add improved tracing function support also clear
+    // the function parameter as necessary.
+    this.setState({aggregation: value}, this.triggerChange);
+  };
+
+  triggerChange() {
+    const {parentIndex} = this.props;
+    const {field, aggregation} = this.state;
+    this.props.onChange(parentIndex, {
+      field,
+      aggregation,
+    });
+  }
+
+  syncFields() {
+    this.setState({
+      fields: generateOptions(Object.keys(FIELDS).concat(this.props.tagKeys)),
+    });
+  }
+
+  render() {
+    const {field, fields, aggregation, aggregations} = this.state;
+
+    return (
+      <RowContainer>
+        <SelectControl options={fields} value={field} onChange={this.handleFieldChange} />
+        <SelectControl
+          options={aggregations.map(item => ({label: item, value: item}))}
+          value={aggregation}
+          onChange={this.handleFunctionChange}
+        />
+      </RowContainer>
+    );
+  }
+}
+
+function generateOptions(values: string[]): SelectValue<string>[] {
+  return values.map(item => ({label: item, value: item}));
+}
+
+function filterAggregations(organization: OrganizationSummary, f?: Field): Aggregation[] {
+  let functionList = Object.keys(AGGREGATIONS);
+  if (!organization.features.includes('transaction-events')) {
+    functionList = functionList.filter(item => !TRACING_FIELDS.includes(item));
+  }
+
+  // sort list in ascending order
+  functionList.sort();
+
+  if (!f) {
+    return functionList as Aggregation[];
+  }
+  // Unknown fields are likely tag keys and thus strings.
+  const fieldType = FIELDS[f] || 'string';
+
+  if (fieldType === 'never') {
+    return [];
+  }
+
+  // Aggregate aliases cannot be aggregated again.
+  if (AGGREGATE_ALIASES.includes(f)) {
+    return [];
+  }
+
+  functionList = functionList.reduce((accumulator, a) => {
+    if (
+      AGGREGATIONS[a].type.includes(fieldType) ||
+      AGGREGATIONS[a].type === '*' ||
+      fieldType === '*'
+    ) {
+      accumulator.push(a as Aggregation);
+    }
+
+    return accumulator;
+  }, [] as Aggregation[]);
+
+  // sort list in ascending order
+  functionList.sort();
+
+  return functionList as Aggregation[];
+}
+
+const RowContainer = styled('div')`
+  display: grid;
+  grid-template-columns: repeat(2, 50%);
+  grid-column-gap: ${space(2)};
+  align-items: center;
+`;
+
+export default ColumnEditRow;
diff --git a/tests/js/spec/components/forms/selectField.spec.jsx b/tests/js/spec/components/forms/selectField.spec.jsx
index 1763397a0b..5ed558c70d 100644
--- a/tests/js/spec/components/forms/selectField.spec.jsx
+++ b/tests/js/spec/components/forms/selectField.spec.jsx
@@ -90,6 +90,34 @@ describe('SelectField', function() {
       );
     });
 
+    it('can set the value to empty string via props with no options', function() {
+      const mock = jest.fn();
+      const wrapper = mountWithTheme(
+        <SelectField
+          deprecatedSelectControl
+          options={[
+            {label: 'a', value: 'a'},
+            {label: 'b', value: 'b'},
+          ]}
+          name="fieldName"
+          onChange={mock}
+        />
+      );
+      // Select a value so there is an option selected.
+      selectByValue(wrapper, 'a', {name: 'fieldName'});
+      expect(mock).toHaveBeenCalledTimes(1);
+      expect(mock).toHaveBeenLastCalledWith('a');
+
+      // Update props to remove value and options.
+      wrapper.setProps({value: '', options: []});
+      wrapper.update();
+      expect(wrapper.find('SelectPicker').props().value).toEqual('');
+
+      // second update.
+      expect(mock).toHaveBeenCalledTimes(2);
+      expect(mock).toHaveBeenLastCalledWith('');
+    });
+
     describe('Multiple', function() {
       it('selects multiple values and submits', function() {
         const mock = jest.fn();

commit f0ac4faf29714f0ecfd1d90fa8db5869f8c24560
Author: Matt Robenolt <matt@ydekproductions.com>
Date:   Wed Oct 19 12:06:31 2016 -0700

    sourcemaps: remove python processing (#4391)

diff --git a/src/sentry/lang/javascript/processor.py b/src/sentry/lang/javascript/processor.py
index d2df6b5f8d..3365425b53 100644
--- a/src/sentry/lang/javascript/processor.py
+++ b/src/sentry/lang/javascript/processor.py
@@ -16,6 +16,7 @@ from collections import namedtuple
 from os.path import splitext
 from requests.exceptions import RequestException, Timeout
 from six.moves.urllib.parse import urlparse, urljoin, urlsplit
+from libsourcemap import from_json as view_from_json
 
 # In case SSL is unavailable (light builds) we can't import this here.
 try:
@@ -37,7 +38,6 @@ from sentry.utils.strings import truncatechars
 from sentry.utils import metrics
 
 from .cache import SourceCache, SourceMapCache
-from .sourcemaps import from_json as view_from_json
 
 
 # number of surrounding lines (on each side) to fetch
@@ -501,12 +501,6 @@ def fetch_sourcemap(url, project=None, release=None, allow_scraping=True):
         body = result.body
 
     try:
-        # According to various specs[1][2] a SourceMap may be prefixed to force
-        # a Javascript load error.
-        # [1] https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.h7yy76c5il9v
-        # [2] http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-xssi
-        if body.startswith((u")]}'\n", u")]}\n")):
-            body = body.split(u'\n', 1)[1]
         return view_from_json(body)
     except Exception as exc:
         # This is in debug because the product shows an error already.
diff --git a/src/sentry/lang/javascript/sourcemaps/__init__.py b/src/sentry/lang/javascript/sourcemaps/__init__.py
deleted file mode 100644
index f40a3740d5..0000000000
--- a/src/sentry/lang/javascript/sourcemaps/__init__.py
+++ /dev/null
@@ -1,6 +0,0 @@
-from __future__ import absolute_import
-
-try:
-    from libsourcemap import from_json
-except ImportError:
-    from .native import from_json  # NOQA
diff --git a/src/sentry/lang/javascript/sourcemaps/native.py b/src/sentry/lang/javascript/sourcemaps/native.py
deleted file mode 100644
index 2141aaab92..0000000000
--- a/src/sentry/lang/javascript/sourcemaps/native.py
+++ /dev/null
@@ -1,247 +0,0 @@
-"""
-sentry.utils.sourcemaps
-~~~~~~~~~~~~~~~~~~~~~~~
-
-Originally based on https://github.com/martine/python-sourcemap
-
-Sentry implements the Source Map Revision 3 protocol. Specification:
-https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit
-
-Sentry supports both "standard" source maps, and has partial support for "indexed" source
-maps. Specifically, it supports indexed source maps with the "map" section property as
-output by the React Native bundler. It does NOT support indexed source maps with the "url"
-section property.
-
-:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
-:license: BSD, see LICENSE for more details.
-"""
-from __future__ import absolute_import
-
-from bisect import bisect_right
-
-from collections import namedtuple
-from six import text_type
-from six.moves.urllib.parse import urljoin
-
-from sentry.utils import json
-
-
-Token = namedtuple('Token', ['dst_line', 'dst_col', 'src', 'src_line', 'src_col', 'src_id', 'name'])
-SourceMapIndex = namedtuple('SourceMapIndex', ['tokens', 'keys', 'sources', 'content'])
-IndexedSourceMapIndex = namedtuple('IndexedSourceMapIndex', ['offsets', 'maps'])
-
-# Mapping of base64 letter -> integer value.
-B64 = dict(
-    (c, i) for i, c in
-    enumerate('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/')
-)
-
-
-def parse_vlq(segment):
-    """
-    Parse a string of VLQ-encoded data.
-
-    Returns:
-      a list of integers.
-    """
-
-    values = []
-
-    cur, shift = 0, 0
-    for c in segment:
-        val = B64[c]
-        # Each character is 6 bits:
-        # 5 of value and the high bit is the continuation.
-        val, cont = val & 0b11111, val >> 5
-        cur += val << shift
-        shift += 5
-
-        if not cont:
-            # The low bit of the unpacked value is the sign.
-            cur, sign = cur >> 1, cur & 1
-            if sign:
-                cur = -cur
-            values.append(cur)
-            cur, shift = 0, 0
-
-    if cur or shift:
-        raise Exception('leftover cur/shift in vlq decode')
-
-    return values
-
-
-def parse_sourcemap(smap):
-    """
-    Given a sourcemap json object, yield SourceMap objects as they are read from it.
-    """
-    sources = smap['sources']
-    names = smap.get('names', [])
-    mappings = smap['mappings']
-    lines = mappings.split(';')
-    sourceRoot = smap.get('sourceRoot')
-
-    # turn /foo/bar into /foo/bar/ so urljoin doesnt strip the last path
-    if sourceRoot:
-        if not sourceRoot[-1:] == '/':
-            sourceRoot = sourceRoot + '/'
-
-        sources = [
-            urljoin(sourceRoot, src)
-            for src in sources
-        ]
-
-    dst_col, src_id, src_line, src_col, name_id = 0, 0, 0, 0, 0
-    for dst_line, line in enumerate(lines):
-        segments = line.split(',')
-        dst_col = 0
-        for segment in segments:
-            if not segment:
-                continue
-            parse = parse_vlq(segment)
-
-            # Must be either 4 or 5 long
-            assert len(parse) in (4, 5)
-
-            dst_col += parse[0]
-
-            src_id += parse[1]
-            src = sources[src_id]
-            src_line += parse[2]
-            src_col += parse[3]
-
-            if len(parse) == 5:
-                name_id += parse[4]
-                name = names[name_id]
-            else:
-                name = None
-
-            assert dst_line >= 0
-            assert dst_col >= 0
-            assert src_line >= 0
-            assert src_col >= 0
-
-            yield Token(dst_line, dst_col, src, src_line, src_col, src_id, name)
-
-
-def _sourcemap_to_index(smap):
-    token_list = []
-    key_list = []
-    content = {}
-    sourceRoot = smap.get('sourceRoot')
-
-    # turn /foo/bar into /foo/bar/ so urljoin doesnt strip the last path
-    if sourceRoot:
-        if not sourceRoot[-1:] == '/':
-            sourceRoot = sourceRoot + '/'
-
-        smap['sources'] = [
-            urljoin(sourceRoot, src)
-            for src in smap['sources']
-        ]
-
-        # Pop off the sourceRoot key to prevent applying this again
-        # inside parse_sourcemap
-        smap.pop('sourceRoot')
-
-    if smap.get('sourcesContent'):
-        for src_id, source in enumerate(smap['sources']):
-            # Ensure we handle null files that may be specified outside of
-            # sourcesContent
-            try:
-                value = smap['sourcesContent'][src_id]
-            except IndexError:
-                continue
-
-            if value is None:
-                continue
-
-            content[src_id] = value
-
-    for token in parse_sourcemap(smap):
-        token_list.append(token)
-        key_list.append((token.dst_line, token.dst_col))
-
-    return SourceMapIndex(token_list, key_list, smap['sources'], content)
-
-
-class View(object):
-    def __init__(self, index):
-        self.index = index
-
-    @staticmethod
-    def from_json(sourcemap):
-        """
-        Converts a raw sourcemap string to either a SourceMapIndex (basic source map)
-        or IndexedSourceMapIndex (indexed source map w/ "sections")
-        """
-        if isinstance(sourcemap, text_type):
-            sourcemap = sourcemap.encode('utf-8')
-        smap = json.loads(sourcemap)
-
-        if smap.get('sections'):
-            # indexed source map
-            offsets = []
-            maps = []
-            for section in smap.get('sections'):
-                offset = section.get('offset')
-
-                offsets.append((offset.get('line'), offset.get('column')))
-                maps.append(_sourcemap_to_index(section.get('map')))
-        else:
-            # standard source map
-            offsets = [(0, 0)]
-            maps = [_sourcemap_to_index(smap)]
-
-        return View(IndexedSourceMapIndex(offsets, maps))
-
-    def iter_sources(self):
-        for map_id, smap in enumerate(self.index.maps):
-            for src_id, source in enumerate(smap.sources):
-                yield (map_id, src_id), source
-
-    def get_source_contents(self, (map_id, src_id)):
-        try:
-            return self.index.maps[map_id].content[src_id]
-        except LookupError:
-            return None
-
-    def lookup_token(self, lineno, colno):
-        """
-        Given a SourceMapIndex and a transformed lineno/colno position,
-        return the SourceMap object (which contains original file, line,
-        column, and token name)
-        """
-        if lineno < 0 or colno < 0:
-            return None
-
-        smap_index = self.index
-
-        # Optimize for the case where we only have 1 map which is
-        # most common.
-        if len(smap_index.maps) == 1:
-            smap = smap_index.maps[0]
-            line_offset = 0
-            col_offset = 0
-        else:
-            map_index = bisect_right(smap_index.offsets, (lineno, colno)) - 1
-            offset = smap_index.offsets[map_index]
-            smap = smap_index.maps[map_index]
-            line_offset = offset[0]
-            col_offset = 0 if lineno != offset[0] else offset[1]
-            lineno -= line_offset
-            colno -= col_offset
-
-        token = smap.tokens[bisect_right(smap.keys, (lineno, colno)) - 1]
-        return Token(
-            token.dst_line + line_offset,
-            token.dst_col + col_offset,
-            token.src,
-            token.src_line,
-            token.src_col,
-            token.src_id,
-            token.name,
-        )
-
-
-# For API Compatibility with libsourcemap
-from_json = View.from_json
diff --git a/src/sentry/testutils/skips.py b/src/sentry/testutils/skips.py
index 194469519e..d05c7a8a88 100644
--- a/src/sentry/testutils/skips.py
+++ b/src/sentry/testutils/skips.py
@@ -37,15 +37,3 @@ def cassandra_is_available():
 requires_cassandra = pytest.mark.skipif(
     not cassandra_is_available(),
     reason="requires cassandra server running")
-
-
-def libsourcemap_is_available():
-    try:
-        import libsourcemap  # NOQA
-        return True
-    except ImportError:
-        return False
-
-requires_no_libsourcemap = pytest.mark.skipif(
-    libsourcemap_is_available(),
-    reason="doesn't work with libsourcemap")
diff --git a/tests/sentry/lang/javascript/test_processor.py b/tests/sentry/lang/javascript/test_processor.py
index 9ef6e8990e..44ebac9f67 100644
--- a/tests/sentry/lang/javascript/test_processor.py
+++ b/tests/sentry/lang/javascript/test_processor.py
@@ -5,6 +5,7 @@ from __future__ import absolute_import
 import pytest
 import responses
 import six
+from libsourcemap import Token
 
 from mock import patch
 from requests.exceptions import RequestException
@@ -14,12 +15,11 @@ from sentry.lang.javascript.processor import (
     BadSource, discover_sourcemap, fetch_sourcemap, fetch_file, generate_module,
     SourceProcessor, trim_line, UrlResult, fetch_release_file
 )
-from sentry.lang.javascript.sourcemaps.native import Token, SourceMapIndex, IndexedSourceMapIndex
 from sentry.lang.javascript.errormapping import (
     rewrite_exception, REACT_MAPPING_URL
 )
 from sentry.models import File, Release, ReleaseFile
-from sentry.testutils import TestCase, requires_no_libsourcemap
+from sentry.testutils import TestCase
 
 base64_sourcemap = 'data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvdGVzdC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zb2xlLmxvZyhcImhlbGxvLCBXb3JsZCFcIikiXX0='
 
@@ -245,16 +245,14 @@ class GenerateModuleTest(TestCase):
         assert generate_module('~/app/components/projectHeader/projectSelector.jsx') == 'app/components/projectHeader/projectSelector'
 
 
-@requires_no_libsourcemap
 class FetchBase64SourcemapTest(TestCase):
     def test_simple(self):
         smap_view = fetch_sourcemap(base64_sourcemap)
         tokens = [Token(1, 0, '/test.js', 0, 0, 0, None)]
-        sources = ['/test.js']
-        keys = [(1, 0)]
-        content = {0: 'console.log("hello, World!")'}
 
-        assert smap_view.index == IndexedSourceMapIndex([(0, 0)], [SourceMapIndex(tokens, keys, sources, content)])
+        assert list(smap_view) == tokens
+        assert smap_view.get_source_contents(0) == 'console.log("hello, World!")'
+        assert smap_view.get_source_name(0) == u'/test.js'
 
 
 class TrimLineTest(TestCase):
diff --git a/tests/sentry/lang/javascript/test_sourcemaps.py b/tests/sentry/lang/javascript/test_sourcemaps.py
index 68595cad37..36e7756bbe 100644
--- a/tests/sentry/lang/javascript/test_sourcemaps.py
+++ b/tests/sentry/lang/javascript/test_sourcemaps.py
@@ -2,9 +2,7 @@
 
 from __future__ import absolute_import
 
-from sentry.lang.javascript.sourcemaps.native import (
-    parse_vlq, parse_sourcemap, View as NativeView, Token,
-)
+from libsourcemap import from_json as view_from_json, Token
 from sentry.testutils import TestCase
 
 from sentry.utils import json
@@ -74,18 +72,9 @@ indexed_sourcemap_example = json.dumps({
 })
 
 
-class ParseVlqTest(TestCase):
-    def test_simple(self):
-        assert parse_vlq('gqjG') == [100000]
-        assert parse_vlq('hqjG') == [-100000]
-        assert parse_vlq('DFLx+BhqjG') == [-1, -2, -5, -1000, -100000]
-        assert parse_vlq('CEKw+BgqjG') == [1, 2, 5, 1000, 100000]
-        assert parse_vlq('/+Z') == [-13295]
-
-
 class FindSourceTest(TestCase):
     def test_simple(self):
-        smap_view = NativeView.from_json(sourcemap)
+        smap_view = view_from_json(sourcemap)
 
         result = smap_view.lookup_token(0, 56)
         assert result == Token(dst_line=0, dst_col=50, src='foo/file2.js', src_line=0, src_col=9, src_id=1, name='multiply')
@@ -109,29 +98,29 @@ class FindSourceTest(TestCase):
 
 class IterSourcesTest(TestCase):
     def test_basic(self):
-        smap_view = NativeView.from_json(sourcemap)
+        smap_view = view_from_json(sourcemap)
         assert list(smap_view.iter_sources()) == [
-            ((0, 0), 'foo/file1.js'),
-            ((0, 1), 'foo/file2.js'),
+            (0, 'foo/file1.js'),
+            (1, 'foo/file2.js'),
         ]
 
 
 class GetSourceContentsTest(TestCase):
     def test_no_inline(self):
         # basic sourcemap fixture has no inlined sources, so expect None
-        smap_view = NativeView.from_json(sourcemap)
+        smap_view = view_from_json(sourcemap)
 
-        source = smap_view.get_source_contents((0, 0))
+        source = smap_view.get_source_contents(0)
         assert source is None
 
     def test_indexed_inline(self):
-        smap_view = NativeView.from_json(indexed_sourcemap_example)
+        smap_view = view_from_json(indexed_sourcemap_example)
 
-        assert smap_view.get_source_contents((0, 0)) == (
+        assert smap_view.get_source_contents(0) == (
             ' ONE.foo = function (bar) {\n' +
             '   return baz(bar);\n' +
             ' };')
-        assert smap_view.get_source_contents((1, 0)) == (
+        assert smap_view.get_source_contents(1) == (
             ' TWO.inc = function (n) {\n' +
             '   return n + 1;\n' +
             ' };')
@@ -139,10 +128,9 @@ class GetSourceContentsTest(TestCase):
 
 class ParseSourcemapTest(TestCase):
     def test_basic(self):
-        smap = json.loads(sourcemap)
-        states = list(parse_sourcemap(smap))
+        index = view_from_json(sourcemap)
 
-        assert states == [
+        assert list(index) == [
             Token(dst_line=0, dst_col=0, src='foo/file1.js', src_line=0, src_col=0, src_id=0, name=None),
             Token(dst_line=0, dst_col=8, src='foo/file1.js', src_line=0, src_col=9, src_id=0, name='add'),
             Token(dst_line=0, dst_col=13, src='foo/file1.js', src_line=0, src_col=13, src_id=0, name='a'),
@@ -185,7 +173,7 @@ class ParseIndexedSourcemapTest(TestCase):
     # Tests lookups that fall exactly on source map token boundaries
     # https://github.com/mozilla/source-map/blob/master/test/test-source-map-consumer.js#138
     def test_exact_mappings(self):
-        smap_view = NativeView.from_json(indexed_sourcemap_example)
+        smap_view = view_from_json(indexed_sourcemap_example)
 
         # one.js
         assert smap_view.lookup_token(0, 1) == \
@@ -197,16 +185,16 @@ class ParseIndexedSourcemapTest(TestCase):
 
         # two.js
         assert smap_view.lookup_token(1, 18) == \
-            Token(dst_line=1, dst_col=18, src='/the/root/two.js', src_line=0, src_col=21, src_id=0, name='n')
+            Token(dst_line=1, dst_col=18, src='/the/root/two.js', src_line=0, src_col=21, src_id=1, name='n')
         assert smap_view.lookup_token(1, 21) == \
-            Token(dst_line=1, dst_col=21, src='/the/root/two.js', src_line=1, src_col=3, src_id=0, name=None)
+            Token(dst_line=1, dst_col=21, src='/the/root/two.js', src_line=1, src_col=3, src_id=1, name=None)
         assert smap_view.lookup_token(1, 21) == \
-            Token(dst_line=1, dst_col=21, src='/the/root/two.js', src_line=1, src_col=3, src_id=0, name=None)
+            Token(dst_line=1, dst_col=21, src='/the/root/two.js', src_line=1, src_col=3, src_id=1, name=None)
 
     # Tests lookups that fall inside source map token boundaries
     # https://github.com/mozilla/source-map/blob/master/test/test-source-map-consumer.js#181
     def test_fuzzy_mapping(self):
-        smap_view = NativeView.from_json(indexed_sourcemap_example)
+        smap_view = view_from_json(indexed_sourcemap_example)
 
         # one.js
         assert smap_view.lookup_token(0, 20) == \
@@ -214,4 +202,4 @@ class ParseIndexedSourcemapTest(TestCase):
         assert smap_view.lookup_token(0, 30) == \
             Token(dst_line=0, dst_col=28, src='/the/root/one.js', src_line=1, src_col=10, src_id=0, name='baz')
         assert smap_view.lookup_token(1, 12) == \
-            Token(dst_line=1, dst_col=9, src='/the/root/two.js', src_line=0, src_col=11, src_id=0, name=None)
+            Token(dst_line=1, dst_col=9, src='/the/root/two.js', src_line=0, src_col=11, src_id=1, name=None)

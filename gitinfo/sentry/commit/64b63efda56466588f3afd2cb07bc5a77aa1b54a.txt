commit 64b63efda56466588f3afd2cb07bc5a77aa1b54a
Author: Lauryn Brown <lauryndbrown@gmail.com>
Date:   Tue Apr 17 11:19:57 2018 -0700

    feat(digest): Owners digests (#7924)
    
    * saving place.
    
    * wrote out the process.
    
    * Added tests to smaller methods in digest/utilities
    
    * Added tests to the intermediary steps in my code. added a hash and repr to actor.
    
    * Added additional methods for testing the larger changes.:
    
    * Added create_events method.
    
    * Added tests and corrected code to pass the tests. Added the case where everyone is passed from projectownership.
    
    * Added a couple edgecases to team to user ids. Removed old team_to_userids method. Added more descriptive TODO Comments.
    
    * Renamed tests to be clearer.
    
    * Added user with no specific owner declaration to test cases
    
    * Moved sort_record to tests
    
    * renamed variable.
    
    * Corrected typo in Actors, Moved everyone check to build_events_by_actor.
    
    * changed iterkeys to iteritems in get_personalized_digests
    
    * Added small changes to docstrings.
    
    * Moved sort records to module level. Changed get_events_digest method name. Added part in tests to test group with multiple events.
    
    * Removed a comment.

diff --git a/src/sentry/api/fields/actor.py b/src/sentry/api/fields/actor.py
index 247fd50eaf..721e07896c 100644
--- a/src/sentry/api/fields/actor.py
+++ b/src/sentry/api/fields/actor.py
@@ -84,6 +84,15 @@ class Actor(object):
             return False
         return (self.id, self.type) == (other.id, other.type)
 
+    def __ne__(self, other):
+        return not self.__eq__(other)
+
+    def __hash__(self):
+        return hash((self.id, self.type))
+
+    def __repr__(self):
+        return '<Actor id=%s, type=%s>' % (six.text_type(self.id), six.text_type(self.type))
+
 
 class ActorField(serializers.WritableField):
     def to_native(self, obj):
diff --git a/src/sentry/digests/utilities.py b/src/sentry/digests/utilities.py
index 595136e0cb..18d5000043 100644
--- a/src/sentry/digests/utilities.py
+++ b/src/sentry/digests/utilities.py
@@ -2,7 +2,9 @@ from __future__ import absolute_import
 
 import six
 
-from collections import Counter
+from collections import Counter, defaultdict, OrderedDict
+from sentry.models import OrganizationMemberTeam, ProjectOwnership, Team, User
+from sentry.api.fields.actor import Actor
 
 
 # TODO(tkaemming): This should probably just be part of `build_digest`.
@@ -23,3 +25,116 @@ def get_digest_metadata(digest):
                     end = record.datetime
 
     return start, end, counts
+
+
+def get_personalized_digests(project_id, digest, user_ids):
+    """
+    get_personalized_digests(project_id: Int, digest: Digest, user_ids: Set[Int]) -> Iterator[user_id: Int, digest: Digest]
+    """
+    # TODO(LB): I Know this is inefficent.
+    # In the case that ProjectOwnership does exist, I do the same query twice.
+    # Once with this statement and again with the call to ProjectOwnership.get_actors()
+    # Will follow up with another PR to reduce the number of queries.
+    if ProjectOwnership.objects.filter(project_id=project_id).exists():
+        events = get_event_from_groups_in_digest(digest)
+        events_by_actor = build_events_by_actor(project_id, events, user_ids)
+        events_by_user = convert_actors_to_users(events_by_actor, user_ids)
+        for user_id, user_events in six.iteritems(events_by_user):
+            yield user_id, build_custom_digest(digest, user_events)
+    else:
+        for user_id in user_ids:
+            yield user_id, digest
+
+
+def get_event_from_groups_in_digest(digest):
+    """
+    get_event_from_groups_in_digest(digest: Digest)
+
+    Gets the first event from each group in the digest
+    """
+    events = []
+    for rule_groups in six.itervalues(digest):
+        for group_records in six.itervalues(rule_groups):
+            events.append(group_records[0].value.event)
+    return set(events)
+
+
+def build_custom_digest(original_digest, events):
+    """
+    build_custom_digest(original_digest: Digest, events: Set[Events]) -> Digest
+    """
+    user_digest = OrderedDict()
+    for rule, rule_groups in six.iteritems(original_digest):
+        user_rule_groups = OrderedDict()
+        for group, group_records in six.iteritems(rule_groups):
+            user_group_records = [
+                record for record in group_records
+                if record.value.event in events
+            ]
+            if user_group_records:
+                user_rule_groups[group] = user_group_records
+        if user_rule_groups:
+            user_digest[rule] = user_rule_groups
+    return user_digest
+
+
+def build_events_by_actor(project_id, events, user_ids):
+    """
+    build_events_by_actor(project_id: Int, events: Set(Events), user_ids: Set[Int]) -> Map[Actor, Set(Events)]
+    """
+    events_by_actor = defaultdict(set)
+    for event in events:
+        # TODO(LB): I Know this is inefficent.
+        # ProjectOwnership.get_owners is O(n) queries and I'm doing that O(len(events)) times
+        # I will create a follow-up PR to address this method's efficency problem
+        # Just wanted to make as few changes as possible for now.
+        actors, __ = ProjectOwnership.get_owners(project_id, event.data)
+        if actors == ProjectOwnership.Everyone:
+            actors = [Actor(user_id, User) for user_id in user_ids]
+        for actor in actors:
+            events_by_actor[actor].add(event)
+    return events_by_actor
+
+
+def convert_actors_to_users(events_by_actor, user_ids):
+    """
+    convert_actors_to_user_set(events_by_actor: Map[Actor, Set(Events)], user_ids: List(Int)) -> Map[user_id: Int, Set(Events)]
+    """
+    events_by_user = defaultdict(set)
+    team_actors = [actor for actor in six.iterkeys(events_by_actor) if actor.type == Team]
+    teams_to_user_ids = team_actors_to_user_ids(team_actors, user_ids)
+    for actor, events in six.iteritems(events_by_actor):
+        if actor.type == Team:
+            try:
+                team_user_ids = teams_to_user_ids[actor.id]
+            except KeyError:
+                pass
+            else:
+                for user_id in team_user_ids:
+                    events_by_user[user_id].update(events)
+        elif actor.type == User:
+            events_by_user[actor.id].update(events)
+        else:
+            raise ValueError('Unknown Actor type: %s' % actor.type)
+    return events_by_user
+
+
+def team_actors_to_user_ids(team_actors, user_ids):
+    """
+    team_actors_to_user_ids(team_actors: List(Actors), user_ids: List(Int)) -> Map[team_id:Int, user_ids:Set(Int)]
+
+    Will not include a team in the result if there are no active members in a team.
+    """
+    team_ids = [actor.id for actor in team_actors]
+    members = OrganizationMemberTeam.objects.filter(
+        team_id__in=team_ids,
+        is_active=True,
+        organizationmember__user_id__in=user_ids,
+    ).select_related('organizationmember')
+
+    team_members = defaultdict(set)
+    for member in members:
+        user_id = member.organizationmember.user_id
+        team_members[member.team_id].add(user_id)
+
+    return team_members
diff --git a/src/sentry/plugins/sentry_mail/models.py b/src/sentry/plugins/sentry_mail/models.py
index b1c5da489a..1fd96e7314 100644
--- a/src/sentry/plugins/sentry_mail/models.py
+++ b/src/sentry/plugins/sentry_mail/models.py
@@ -21,7 +21,7 @@ from django.utils.safestring import mark_safe
 from sentry import features, options
 from sentry.models import ProjectOwnership, User
 
-from sentry.digests.utilities import get_digest_metadata
+from sentry.digests.utilities import get_digest_metadata, get_personalized_digests
 from sentry.plugins import register
 from sentry.plugins.base.structs import Notification
 from sentry.plugins.bases.notify import NotificationPlugin
@@ -289,39 +289,40 @@ class MailPlugin(NotificationPlugin):
         )
 
     def notify_digest(self, project, digest):
-        start, end, counts = get_digest_metadata(digest)
-
-        # If there is only one group in this digest (regardless of how many
-        # rules it appears in), we should just render this using the single
-        # notification template. If there is more than one record for a group,
-        # just choose the most recent one.
-        if len(counts) == 1:
-            group = six.next(iter(counts))
-            record = max(
-                itertools.chain.from_iterable(
-                    groups.get(group, []) for groups in six.itervalues(digest)
-                ),
-                key=lambda record: record.timestamp,
-            )
-            notification = Notification(record.value.event, rules=record.value.rules)
-            return self.notify(notification)
-
-        context = {
-            'start': start,
-            'end': end,
-            'project': project,
-            'digest': digest,
-            'counts': counts,
-        }
+        user_ids = self.get_send_to(project)
+        for user_id, digest in get_personalized_digests(project.id, digest, user_ids):
+            start, end, counts = get_digest_metadata(digest)
+
+            # If there is only one group in this digest (regardless of how many
+            # rules it appears in), we should just render this using the single
+            # notification template. If there is more than one record for a group,
+            # just choose the most recent one.
+            if len(counts) == 1:
+                group = six.next(iter(counts))
+                record = max(
+                    itertools.chain.from_iterable(
+                        groups.get(group, []) for groups in six.itervalues(digest)
+                    ),
+                    key=lambda record: record.timestamp,
+                )
+                notification = Notification(record.value.event, rules=record.value.rules)
+                return self.notify(notification)
+
+            context = {
+                'start': start,
+                'end': end,
+                'project': project,
+                'digest': digest,
+                'counts': counts,
+            }
 
-        headers = {
-            'X-Sentry-Project': project.slug,
-        }
+            headers = {
+                'X-Sentry-Project': project.slug,
+            }
 
-        group = six.next(iter(counts))
-        subject = self.get_digest_subject(group, counts, start)
+            group = six.next(iter(counts))
+            subject = self.get_digest_subject(group, counts, start)
 
-        for user_id in self.get_send_to(project):
             self.add_unsubscribe_link(context, user_id, project)
             self._send_mail(
                 subject=subject,
diff --git a/tests/sentry/digests/test_utilities.py b/tests/sentry/digests/test_utilities.py
new file mode 100644
index 0000000000..4767c8622e
--- /dev/null
+++ b/tests/sentry/digests/test_utilities.py
@@ -0,0 +1,324 @@
+from __future__ import absolute_import
+
+from datetime import timedelta
+from django.utils import timezone
+
+from sentry.api.fields.actor import Actor
+from sentry.digests.notifications import build_digest, event_to_record
+from sentry.digests.utilities import (
+    build_events_by_actor,
+    convert_actors_to_users,
+    get_event_from_groups_in_digest,
+    get_personalized_digests,
+    team_actors_to_user_ids,
+)
+from sentry.models import OrganizationMemberTeam, ProjectOwnership, Team, User
+from sentry.ownership.grammar import Rule, Owner, Matcher, dump_schema
+from sentry.testutils import TestCase
+
+
+def sort_records(records):
+    """
+    Sorts records for fetch_state method
+    fetch_state is expecting these records to be ordered from newest to oldest
+    """
+    return sorted(records, key=lambda r: r.value.event.datetime, reverse=True)
+
+
+class UtilitiesHelpersTestCase(TestCase):
+    def test_get_event_from_groups_in_digest(self):
+        project = self.create_project()
+        rule = project.rule_set.all()[0]
+        same_group = self.create_group(project=project)
+
+        events = [
+            self.create_event(group=same_group),
+            self.create_event(group=same_group),
+            self.create_event(group=self.create_group(project=project)),
+            self.create_event(group=self.create_group(project=project)),
+            self.create_event(group=self.create_group(project=project)),
+            self.create_event(group=self.create_group(project=project)),
+        ]
+        digest = build_digest(
+            project,
+            sort_records([event_to_record(event, (rule, )) for event in events]),
+        )
+
+        events.pop(0)  # remove event with same group
+        assert get_event_from_groups_in_digest(digest) == set(events)
+
+    def test_team_actors_to_user_ids(self):
+        team1 = self.create_team()
+        team2 = self.create_team()
+        team3 = self.create_team()  # team with no active members
+        users = [self.create_user() for i in range(0, 8)]
+
+        self.create_member(user=users[0], organization=self.organization, teams=[team1])
+        self.create_member(user=users[1], organization=self.organization, teams=[team1])
+        self.create_member(user=users[2], organization=self.organization, teams=[team1])
+        self.create_member(user=users[3], organization=self.organization, teams=[team1, team2])
+        self.create_member(user=users[4], organization=self.organization, teams=[team2, self.team])
+        self.create_member(user=users[5], organization=self.organization, teams=[team2])
+
+        # Inactive member
+        member6 = self.create_member(
+            user=users[6],
+            organization=self.organization,
+            teams=[
+                team2,
+                team3])
+        team_member6 = OrganizationMemberTeam.objects.filter(organizationmember_id=member6.id)
+        for team_member in team_member6:
+            team_member.update(is_active=False)
+        # Member without teams
+        self.create_member(user=users[7], organization=self.organization, teams=[])
+
+        team_actors = [Actor(team1.id, Team), Actor(team2.id, Team), Actor(team3.id, Team)]
+        user_ids = [user.id for user in users]
+
+        assert team_actors_to_user_ids(team_actors, user_ids) == {
+            team1.id: set([users[0].id, users[1].id, users[2].id, users[3].id]),
+            team2.id: set([users[3].id, users[4].id, users[5].id]),
+        }
+
+    def test_convert_actors_to_user_set(self):
+        user1 = self.create_user()
+        user2 = self.create_user()
+        user3 = self.create_user()
+        user4 = self.create_user()
+
+        team1 = self.create_team()
+        team2 = self.create_team()
+
+        self.create_member(user=user1, organization=self.organization, teams=[team1])
+        self.create_member(user=user2, organization=self.organization, teams=[team2])
+        self.create_member(user=user3, organization=self.organization, teams=[team1, team2])
+        self.create_member(user=user4, organization=self.organization, teams=[])
+
+        team1_events = set([
+            self.create_event(),
+            self.create_event(),
+            self.create_event(),
+            self.create_event(),
+        ])
+        team2_events = set([
+            self.create_event(),
+            self.create_event(),
+            self.create_event(),
+            self.create_event(),
+        ])
+        user4_events = set([self.create_event(), self.create_event()])
+        events_by_actor = {
+            Actor(team1.id, Team): team1_events,
+            Actor(team2.id, Team): team2_events,
+            Actor(user3.id, User): team1_events.union(team2_events),
+            Actor(user4.id, User): user4_events,
+        }
+        user_by_events = {
+            user1.id: team1_events,
+            user2.id: team2_events,
+            user3.id: team1_events.union(team2_events),
+            user4.id: user4_events,
+        }
+        assert convert_actors_to_users(events_by_actor, user_by_events.keys()) == user_by_events
+
+
+class GetPersonalizedDigestsTestCase(TestCase):
+    def setUp(self):
+        self.user1 = self.create_user()
+        self.user2 = self.create_user()
+        self.user3 = self.create_user()
+        self.user4 = self.create_user()
+        self.user5 = self.create_user()  # this user has no events
+        self.user_ids = [self.user1.id, self.user2.id, self.user3.id, self.user4.id, self.user5.id]
+
+        self.team1 = self.create_team()
+        self.team2 = self.create_team()
+        self.team3 = self.create_team()
+
+        self.project = self.create_project(teams=[self.team1, self.team2, self.team3])
+
+        self.create_member(user=self.user1, organization=self.organization, teams=[self.team1])
+        self.create_member(user=self.user2, organization=self.organization, teams=[self.team2])
+        self.create_member(
+            user=self.user3,
+            organization=self.organization,
+            teams=[
+                self.team1,
+                self.team2])
+        self.create_member(user=self.user4, organization=self.organization, teams=[self.team3])
+        self.create_member(user=self.user5, organization=self.organization, teams=[self.team3])
+
+        start_time = timezone.now()
+
+        self.team1_events = self.create_events(
+            start_time, self.project, [
+                'hello.py', 'goodbye.py', 'hola.py', 'adios.py'])
+        self.team2_events = self.create_events(
+            start_time, self.project, [
+                'old.cbl', 'retro.cbl', 'cool.cbl', 'gem.cbl'])
+
+        self.user4_events = [
+            self.create_event(
+                group=self.create_group(
+                    project=self.project), data=self.create_event_data(
+                    'foo.bar', 'helloworld.org')),
+            self.create_event(
+                group=self.create_group(
+                    project=self.project), data=self.create_event_data(
+                    'bar.foo', 'helloworld.org')),
+        ]
+        self.team1_matcher = Matcher('path', '*.py')
+        self.team2_matcher = Matcher('path', '*.cbl')
+        self.user4_matcher = Matcher('url', '*.org')
+
+        ProjectOwnership.objects.create(
+            project_id=self.project.id,
+            schema=dump_schema([
+                Rule(self.team1_matcher, [
+                    Owner('team', self.team1.slug),
+                    Owner('user', self.user3.email),
+                ]),
+                Rule(self.team2_matcher, [
+                    Owner('team', self.team2.slug),
+                ]),
+                Rule(self.user4_matcher, [
+                    Owner('user', self.user4.email),
+                ]),
+            ]),
+            fallthrough=True,
+        )
+
+    def create_event_data(self, filename, url='http://example.com'):
+        data = {
+            'tags': [('level', 'error')],
+            'sentry.interfaces.Stacktrace': {
+                'frames': [
+                    {
+                        'lineno': 1,
+                        'filename': filename,
+                    },
+                ],
+            },
+            'sentry.interfaces.Http': {
+                'url': url
+            },
+        }
+        return data
+
+    def create_events(self, start_time, project, filenames=None, urls=None):
+        events = []
+        for index, label in enumerate(filenames or urls):
+            group = self.create_group(
+                project=project,
+                first_seen=start_time - timedelta(days=index + 1),
+                last_seen=start_time - timedelta(hours=index + 1),
+                message='group%d' % index
+            )
+            if filenames is not None:
+                event = self.create_event(
+                    group=group,
+                    message=group.message,
+                    datetime=group.last_seen,
+                    project=project,
+                    data=self.create_event_data(filename=label)
+                )
+            else:
+                event = self.create_event(
+                    group=group,
+                    message=group.message,
+                    datetime=group.last_seen,
+                    project=project,
+                    data=self.create_event_data('foo.bar', url=label)
+                )
+            events.append(event)
+        return events
+
+    def assert_get_personalized_digests(self, project, digest, user_ids, expected_result):
+        result_user_ids = []
+        for user_id, user_digest in get_personalized_digests(project.id, digest, user_ids):
+            assert user_id in expected_result
+            assert expected_result[user_id] == get_event_from_groups_in_digest(user_digest)
+            result_user_ids.append(user_id)
+
+        assert sorted(expected_result.keys()) == sorted(result_user_ids)
+
+    def test_build_events_by_actor(self):
+        events = self.team1_events + self.team2_events + self.user4_events
+
+        events_by_actor = {
+            Actor(self.team1.id, Team): set(self.team1_events),
+            Actor(self.team2.id, Team): set(self.team2_events),
+            Actor(self.user3.id, User): set(self.team1_events),
+            Actor(self.user4.id, User): set(self.user4_events),
+        }
+        assert build_events_by_actor(self.project.id, events, self.user_ids) == events_by_actor
+
+    def test_simple(self):
+        rule = self.project.rule_set.all()[0]
+        records = [event_to_record(event, (rule, ))
+                   for event in self.team1_events + self.team2_events + self.user4_events]
+        digest = build_digest(self.project, sort_records(records))
+
+        expected_result = {
+            self.user1.id: set(self.team1_events),
+            self.user2.id: set(self.team2_events),
+            self.user3.id: set(self.team1_events + self.team2_events),
+            self.user4.id: set(self.user4_events),
+        }
+        self.assert_get_personalized_digests(self.project, digest, self.user_ids, expected_result)
+
+    def test_team_without_members(self):
+        team = self.create_team()
+        project = self.create_project(teams=[team])
+        ProjectOwnership.objects.create(
+            project_id=project.id,
+            schema=dump_schema([
+                Rule(Matcher('path', '*.cpp'), [
+                    Owner('team', team.slug),
+                ]),
+            ]),
+            fallthrough=True,
+        )
+        rule = project.rule_set.all()[0]
+        records = [
+            event_to_record(event, (rule, )) for event in self.create_events(timezone.now(), project, [
+                'hello.py', 'goodbye.py', 'hola.py', 'adios.py'])
+        ]
+        digest = build_digest(project, sort_records(records))
+        user_ids = [member.user_id for member in team.member_set]
+        assert not user_ids
+        for user_id, user_digest in get_personalized_digests(project.id, digest, user_ids):
+            assert False  # no users in this team no digests should be processed
+
+    def test_only_everyone(self):
+        rule = self.project.rule_set.all()[0]
+        events = self.create_events(
+            timezone.now(), self.project, [
+                'hello.moz', 'goodbye.moz', 'hola.moz', 'adios.moz'])
+        records = [event_to_record(event, (rule, )) for event in events]
+        digest = build_digest(self.project, sort_records(records))
+        expected_result = {
+            self.user1.id: set(events),
+            self.user2.id: set(events),
+            self.user3.id: set(events),
+            self.user4.id: set(events),
+            self.user5.id: set(events),
+        }
+        self.assert_get_personalized_digests(self.project, digest, self.user_ids, expected_result)
+
+    def test_everyone_with_owners(self):
+        rule = self.project.rule_set.all()[0]
+        events = self.create_events(
+            timezone.now(), self.project, [
+                'hello.moz', 'goodbye.moz', 'hola.moz', 'adios.moz'])
+        records = [event_to_record(event, (rule, )) for event in events + self.team1_events]
+        digest = build_digest(self.project, sort_records(records))
+        expected_result = {
+            self.user1.id: set(events + self.team1_events),
+            self.user2.id: set(events),
+            self.user3.id: set(events + self.team1_events),
+            self.user4.id: set(events),
+            self.user5.id: set(events),
+        }
+        self.assert_get_personalized_digests(self.project, digest, self.user_ids, expected_result)

commit 2fecc1a9e8faddc36c72e28ffda60042daa523c9
Author: David Cramer <dcramer@gmail.com>
Date:   Thu Jan 1 23:52:12 2015 -0800

    Add support for LiveReload

diff --git a/gulpfile.js b/gulpfile.js
index de3c285029..9e807c4f1a 100644
--- a/gulpfile.js
+++ b/gulpfile.js
@@ -6,6 +6,7 @@ var browserSync = require("browser-sync"),
     gp_clean = require("gulp-clean"),
     gp_concat = require("gulp-concat"),
     gp_less = require("gulp-less"),
+    gp_livereload = require("gulp-livereload"),
     gp_rename = require("gulp-rename"),
     gp_uglify = require("gulp-uglify"),
     gp_util = require("gulp-util"),
@@ -104,17 +105,27 @@ gulp.task("watch:css:wall", function(){
 
 gulp.task("watch:css", ["watch:css:sentry", "watch:css:wall"]);
 
+gulp.task("watch:templates", function(){
+  return gp_watch(path.join(__dirname, 'src/sentry/templates/**'), function(){
+    gp_livereload.changed('.');
+  });
+});
+
 // TODO(dcramer): this is causing issues, use webpack --watch for now
 gulp.task("watch:webpack", function(callback){
   var config = require('./webpack.config.js');
   webpack(config).watch(200, function(err, stats) {
     if(err) throw new gutil.PluginError("webpack", err);
     gp_util.log("[webpack]", stats.toString(webpackStatsOptions));
+    gp_livereload.changed('.');
   });
   callback();
 });
 
-gulp.task("watch", ["watch:css", "watch:webpack", "livereload"]);
+gulp.task("watch", function(){
+  gp_livereload.listen();
+  return gulp.start(["livereload", "watch:css", "watch:webpack", "watch:templates"]);
+});
 
 gulp.task("livereload", function() {
   browserSync({
diff --git a/package.json b/package.json
index 189f65079a..6a20894568 100644
--- a/package.json
+++ b/package.json
@@ -15,6 +15,7 @@
     "gulp-clean": "^0.3.1",
     "gulp-concat": "^2.4.2",
     "gulp-less": "^1.3.6",
+    "gulp-livereload": "^3.0.2",
     "gulp-react": "^2.0.0",
     "gulp-rename": "^1.2.0",
     "gulp-uglify": "^1.0.2",
diff --git a/src/sentry/management/commands/runserver.py b/src/sentry/management/commands/runserver.py
index 67b21149b3..fa91fe4238 100644
--- a/src/sentry/management/commands/runserver.py
+++ b/src/sentry/management/commands/runserver.py
@@ -5,20 +5,32 @@ import os.path
 import sys
 
 from django.conf import settings
+from django.core.management.color import color_style
 from django.core.management.commands.runserver import Command as RunserverCommand
 from optparse import make_option
 from subprocess import Popen
+from urllib2 import urlopen
 
 
 class Command(RunserverCommand):
     """
-    ALmost identical to the built-in runserver except that we don't hijack
-    static files.
+    A version of Django's runserver which bundles Sentry's development
+    tooling (such as static assets and live reload).
+
+    Live reload inspired by django-livereload.
     """
     help = "Starts a lightweight Web server for development"
 
     option_list = RunserverCommand.option_list + (
-        make_option('--nowatcher', action='store_false', dest='use_watcher', default=settings.DEBUG,
+        make_option(
+            '--nolivereload', action='store_false', dest='use_livereload',
+            default=settings.DEBUG, help='Tells Sentry to NOT use LiveReload.'),
+        make_option(
+            '--livereload-port', action='store', dest='livereload_port',
+            default='35729', help='Port where LiveReload listen.'),
+        make_option(
+            '--nowatcher', action='store_false', dest='use_watcher',
+            default=settings.DEBUG,
             help='Tells Sentry to NOT automatically recompile static distributions.'),
     )
 
@@ -26,24 +38,52 @@ class Command(RunserverCommand):
 
     gulp_bin = os.path.join(cwd, 'node_modules', '.bin', 'gulp')
 
-    def run_watcher(self):
-        devnull = open('/dev/null', 'w')
+    def livereload_request(self, verbosity, **options):
+        """
+        Performs the LiveReload request.
+        """
+        host = 'localhost:%s' % options['livereload_port']
+        try:
+            urlopen('http://%s/changed?files=.' % host)
+            if self.verbosity:
+                sys.stdout.write(self.style.HTTP_INFO('>> Sending LiveReload request\n'))
+        except IOError as e:
+            sys.stdout.write(self.style.ERROR('>> LiveReload failed: %s\n' % (e,)))
+            pass
+
+    def run_watcher(self, verbosity, **options):
+        if self.verbosity:
+            self.stdout.write(self.style.HTTP_INFO('>> Running [gulp watch]'))
+            stdout = None
+        else:
+            stdout = open('/dev/null', 'w')
+        return Popen([self.gulp_bin, 'watch'], cwd=self.cwd, stdout=stdout)
 
-        self.stdout.write('>> Running [gulp watch]')
-        return Popen([self.gulp_bin, 'watch'], cwd=self.cwd)
+    def run_server(self, verbosity, **options):
+        if self.verbosity:
+            self.stdout.write(self.style.HTTP_INFO('>> Launching webserver..'))
+        return Popen(sys.argv + ['--nowatcher'], env=os.environ, cwd=self.cwd)
 
-    def run_server(self):
-        args = sys.argv
-        self.stdout.write('>> Launching webserver..')
-        return Popen(args + ['--nowatcher'], env=os.environ, cwd=self.cwd)
+    def get_handler(self, *args, **options):
+        handler = super(Command, self).get_handler(*args, **options)
+        if options['use_livereload']:
+            self.livereload_request(**options)
+        return handler
 
     def run(self, *args, **options):
+        self.style = color_style()
+        self.verbosity = int(options['verbosity'])
+
         if options['use_watcher']:
-            self.stdout.write('>> Running [gulp dist]')
-            Popen([self.gulp_bin, 'dist'], cwd=self.cwd).wait()
+            if self.verbosity:
+                self.stdout.write(self.style.HTTP_INFO('>> Running [gulp dist]'))
+                stdout = None
+            else:
+                stdout = open('/dev/null', 'w')
+            Popen([self.gulp_bin, 'dist'], cwd=self.cwd, stdout=stdout).wait()
 
-            watcher = self.run_watcher()
-            server = self.run_server()
+            watcher = self.run_watcher(**options)
+            server = self.run_server(**options)
             try:
                 server.wait()
             finally:

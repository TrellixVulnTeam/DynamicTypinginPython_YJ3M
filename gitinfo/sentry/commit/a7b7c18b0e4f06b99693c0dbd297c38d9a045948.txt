commit a7b7c18b0e4f06b99693c0dbd297c38d9a045948
Author: Ben Vinegar <ben@benv.ca>
Date:   Fri Aug 28 15:31:06 2015 -0700

    Render urlencoded body/querystring as definition list (refs #1853)

diff --git a/package.json b/package.json
index ba0fad57da..e939862957 100644
--- a/package.json
+++ b/package.json
@@ -24,6 +24,7 @@
     "moment": "^2.10.5",
     "moment-timezone": "^0.4.0",
     "node-libs-browser": "^0.5.2",
+    "query-string": "^2.4.0",
     "raven-js": "^1.1.19",
     "react": "^0.13.3",
     "react-bootstrap": "^0.13.0",
diff --git a/src/sentry/static/sentry/app/components/interfaces/richHttpContent.jsx b/src/sentry/static/sentry/app/components/interfaces/richHttpContent.jsx
index 493ee3e685..f81b99c2b7 100644
--- a/src/sentry/static/sentry/app/components/interfaces/richHttpContent.jsx
+++ b/src/sentry/static/sentry/app/components/interfaces/richHttpContent.jsx
@@ -3,19 +3,43 @@ import React from "react";
 import ClippedBox from "../../components/clippedBox";
 import DefinitionList from "./definitionList";
 import ContextData from "../contextData";
+
 import {objectIsEmpty} from "../../utils";
+import queryString from "query-string";
 
 var RichHttpContent = React.createClass({
 
+  /**
+   * Converts an object of body/querystring key/value pairs
+   * into a tuple of [key, value] pairs.
+   *
+   * Note that the query-string parser returns dupes like this:
+   *   { foo: ['bar', 'baz'] } // ?foo=bar&bar=baz
+   *
+   * This method accounts for this.
+   */
   objectToTupleArray(obj) {
-    return Object.keys(obj).map((k) => [k, obj[k]]);
+    return Object.keys(obj).reduce((out, k) => {
+      let val = obj[k];
+      return out.concat(
+        {}.toString.call(val) === '[object Array]' ?
+          val.map(v => [k, v]) : // key has multiple values (array)
+          [[k, val]]             // key has single value
+      );
+    }, []);
   },
 
   getBodySection(data) {
     let contentType = data.headers.find(h => h[0] === 'Content-Type');
-    return contentType && contentType[1] === 'application/json'
-      ? <ContextData data={JSON.parse(data.data)} />
-      : <pre>{data.data}</pre>;
+
+    switch (contentType && contentType[1]) {
+      case 'application/json':
+        return <ContextData data={JSON.parse(data.data)} />;
+      case 'application/x-www-form-urlencoded':
+        return <DefinitionList data={this.objectToTupleArray(queryString.parse(data.data))}/>
+      default:
+        return <pre>{data.data}</pre>;
+    }
   },
 
   render(){
@@ -25,7 +49,7 @@ var RichHttpContent = React.createClass({
       <div>
         {data.query &&
           <ClippedBox title="Query String">
-            <pre>{data.query}</pre>
+            <DefinitionList data={this.objectToTupleArray(queryString.parse(data.query))}/>
           </ClippedBox>
         }
         {data.fragment &&
diff --git a/tests/js/spec/components/interfaces/richHttpContent.spec.jsx b/tests/js/spec/components/interfaces/richHttpContent.spec.jsx
index 22bf122652..15809618d2 100644
--- a/tests/js/spec/components/interfaces/richHttpContent.spec.jsx
+++ b/tests/js/spec/components/interfaces/richHttpContent.spec.jsx
@@ -16,6 +16,7 @@ describe("RichHttpContent", function () {
       cookies: [],
       env: {}
     };
+    this.elem = TestUtils.renderIntoDocument(<RichHttpContent data={this.data} />);
     this.sandbox = sinon.sandbox.create();
     stubReactComponents(this.sandbox, [ClippedBox, DefinitionList, ContextData]);
   });
@@ -26,42 +27,69 @@ describe("RichHttpContent", function () {
 
   describe("objectToTupleArray", function () {
     it("should convert a key/value object to an array of key/value tuples", function () {
-      var elem = TestUtils.renderIntoDocument(<RichHttpContent data={this.data} />);
+      let elem = this.elem;
       expect(elem.objectToTupleArray({
         foo: 'bar',
         bar: 'baz'
       })).to.eql([
         ['foo', 'bar'], ['bar', 'baz']
       ]);
+
+      expect(elem.objectToTupleArray({
+        foo: ['bar', 'baz']
+      })).to.eql([
+        ['foo', 'bar'], ['foo', 'baz']
+      ]);
+
+      expect(elem.objectToTupleArray({
+        foo: ''
+      })).to.eql([
+        ['foo', '']
+      ]);
     });
   });
 
   describe("getBodySection", function () {
     it("should return plain-text when unrecognized Content-Type", function () {
-      var elem = TestUtils.renderIntoDocument(<RichHttpContent data={this.data} />);
-
-      var data = {
+      let out = this.elem.getBodySection({
         headers: [], // no content-type header,
         data: 'helloworld'
-      };
-      var out = elem.getBodySection(data);
+      });
+
       expect(out.type).to.eql('pre');
     });
 
-    it("should return a ContextData element when Content-Type is application/json", function () {
-      var elem = TestUtils.renderIntoDocument(<RichHttpContent data={this.data} />);
+    it("should return a DefinitionList element when Content-Type is application/x-www-form-urlencoded", function () {
+      var out = this.elem.getBodySection({
+        headers: [
+          ['lol' , 'no'],
+          ['Content-Type', 'application/x-www-form-urlencoded']
+        ], // no content-type header,
+        data: "foo=bar&bar=baz"
+      });
 
-      var data = {
+      // NOTE: ContextData is stubbed in tests; instead returns <div className="ContextData"/>
+      expect(out.props.className).to.eql('DefinitionList');
+      expect(out.props.data).to.eql([
+        ['foo', 'bar'],
+        ['bar', 'baz']
+      ]);
+    });
+
+    it("should return a ContextData element when Content-Type is application/json", function () {
+      var out = this.elem.getBodySection({
         headers: [
           ['lol' , 'no'],
           ['Content-Type', 'application/json']
         ], // no content-type header,
-        data: JSON.stringify({'foo': 'bar'})
-      };
+        data: JSON.stringify({foo: 'bar'})
+      });
 
       // NOTE: ContextData is stubbed in tests; instead returns <div className="ContextData"/>
-      var out = elem.getBodySection(data);
       expect(out.props.className).to.eql('ContextData');
+      expect(out.props.data).to.eql({
+        foo: 'bar'
+      });
     });
   });
 });

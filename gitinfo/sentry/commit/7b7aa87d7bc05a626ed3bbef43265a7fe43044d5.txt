commit 7b7aa87d7bc05a626ed3bbef43265a7fe43044d5
Author: David Cramer <dcramer@gmail.com>
Date:   Tue May 24 15:51:06 2016 -0700

    Handle identities changing on existing SSO accounts
    
    For example, when the sentry-auth-google plugin updated the 'id' parameter
    for identities to be the email instead of Google's public ID, this caused
    users to have an already attached identity that didn't match the same ident.
    
    In this case it makes sense detach that identity wherever it exists, and
    attach it to the authenticating user.
    
    @getsentry/infrastructure

diff --git a/src/sentry/auth/helper.py b/src/sentry/auth/helper.py
index 454a0e9b8c..83bb93f3d8 100644
--- a/src/sentry/auth/helper.py
+++ b/src/sentry/auth/helper.py
@@ -192,10 +192,19 @@ class AuthHelper(object):
         organization = self.organization
 
         try:
-            auth_identity = AuthIdentity.objects.get(
-                auth_provider=auth_provider,
-                ident=identity['id'],
-            )
+            try:
+                # prioritize identifying by the SSO provider's user ID
+                auth_identity = AuthIdentity.objects.get(
+                    auth_provider=auth_provider,
+                    ident=identity['id'],
+                )
+            except AuthIdentity.DoesNotExist:
+                # otherwise look for an already attached identity
+                # this can happen if the SSO provider's internal ID changes
+                auth_identity = AuthIdentity.objects.get(
+                    auth_provider=auth_provider,
+                    user=user,
+                )
         except AuthIdentity.DoesNotExist:
             auth_identity = AuthIdentity.objects.create(
                 auth_provider=auth_provider,
@@ -208,6 +217,7 @@ class AuthHelper(object):
             now = timezone.now()
             auth_identity.update(
                 user=user,
+                ident=identity['id'],
                 data=self.provider.update_identity(
                     new_data=identity.get('data', {}),
                     current_data=auth_identity.data,
diff --git a/tests/sentry/web/frontend/test_auth_organization_login.py b/tests/sentry/web/frontend/test_auth_organization_login.py
index 363fcf6927..55e0f16085 100644
--- a/tests/sentry/web/frontend/test_auth_organization_login.py
+++ b/tests/sentry/web/frontend/test_auth_organization_login.py
@@ -286,3 +286,64 @@ class OrganizationAuthLoginTest(AuthProviderTestCase):
 
         assert getattr(member.flags, 'sso:linked')
         assert not getattr(member.flags, 'sso:invalid')
+
+    def test_flow_as_unauthenticated_existing_matched_user_with_merge_and_existing_identity(self):
+        organization = self.create_organization(name='foo', owner=self.user)
+        auth_provider = AuthProvider.objects.create(
+            organization=organization,
+            provider='dummy',
+        )
+        user = self.create_user('bar@example.com')
+
+        auth_identity = AuthIdentity.objects.create(
+            auth_provider=auth_provider,
+            user=user,
+            ident='adfadsf@example.com'
+        )
+
+        path = reverse('sentry-auth-organization', args=[organization.slug])
+
+        resp = self.client.post(path)
+
+        assert resp.status_code == 200
+        assert self.provider.TEMPLATE in resp.content
+
+        path = reverse('sentry-auth-sso')
+
+        resp = self.client.post(path, {'email': user.email})
+
+        self.assertTemplateUsed(resp, 'sentry/auth-confirm-identity.html')
+        assert resp.status_code == 200
+        assert resp.context['existing_user'] == user
+        assert resp.context['login_form']
+
+        resp = self.client.post(path, {
+            'op': 'login',
+            'username': user.username,
+            'password': 'admin',
+        })
+
+        self.assertTemplateUsed(resp, 'sentry/auth-confirm-link.html')
+        assert resp.status_code == 200
+
+        resp = self.client.post(path, {'op': 'confirm'})
+
+        assert resp.status_code == 302
+        assert resp['Location'] == 'http://testserver/'
+
+        auth_identity = AuthIdentity.objects.get(
+            id=auth_identity.id,
+        )
+
+        assert auth_identity.ident == user.email
+
+        new_user = auth_identity.user
+        assert new_user == user
+
+        member = OrganizationMember.objects.get(
+            organization=organization,
+            user=user,
+        )
+
+        assert getattr(member.flags, 'sso:linked')
+        assert not getattr(member.flags, 'sso:invalid')

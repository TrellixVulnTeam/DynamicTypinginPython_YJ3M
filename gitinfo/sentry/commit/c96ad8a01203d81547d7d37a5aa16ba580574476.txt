commit c96ad8a01203d81547d7d37a5aa16ba580574476
Author: David Wang <davidw1339@gmail.com>
Date:   Fri Jan 24 13:55:19 2020 -0500

    feat(ui): Lightweight Organization Issues Page (#15977)
    
    - First event checking is done via API instead of organization.projects
    - Only enforce a single project at most once on subsequent renders of the GlobalSelectionHeader component
    - Fix over enforcing single project for orgs with multiple project feature
    - Add tests
    
    
    Co-authored-by: Billy Vong <billyvg@users.noreply.github.com>
    Co-authored-by: Alberto Leal <mail4alberto@gmail.com>
    Co-authored-by: jeffkwoh <23180853+jeffkwoh@users.noreply.github.com>

diff --git a/src/sentry/static/sentry/app/actionCreators/organization.jsx b/src/sentry/static/sentry/app/actionCreators/organization.jsx
index 5aba88d096..2c1626f3a5 100644
--- a/src/sentry/static/sentry/app/actionCreators/organization.jsx
+++ b/src/sentry/static/sentry/app/actionCreators/organization.jsx
@@ -14,12 +14,13 @@ import TeamStore from 'app/stores/teamStore';
  * @param {String} slug The organization slug
  * @param {boolean} detailed Whether or not the detailed org details should be
  *                           retrieved
- * @param {boolean} silent Should we silenty update the organization (do not
+ * @param {boolean} silent Should we silently update the organization (do not
  *                         clear the current organization in the store)
  */
 export async function fetchOrganizationDetails(api, slug, detailed, silent) {
   if (!silent) {
     OrganizationActions.fetchOrg();
+    ProjectActions.reset();
   }
 
   try {
diff --git a/src/sentry/static/sentry/app/actions/projectActions.jsx b/src/sentry/static/sentry/app/actions/projectActions.jsx
index 4cb356b331..5d125ebf76 100644
--- a/src/sentry/static/sentry/app/actions/projectActions.jsx
+++ b/src/sentry/static/sentry/app/actions/projectActions.jsx
@@ -17,6 +17,7 @@ export default Reflux.createActions([
   'removeTeam',
   'removeTeamError',
   'removeTeamSuccess',
+  'reset',
   'setActive',
   'update',
   'updateError',
diff --git a/src/sentry/static/sentry/app/components/organizations/globalSelectionHeader/index.jsx b/src/sentry/static/sentry/app/components/organizations/globalSelectionHeader/index.jsx
index 96f3ab4bb9..feb49a6a00 100644
--- a/src/sentry/static/sentry/app/components/organizations/globalSelectionHeader/index.jsx
+++ b/src/sentry/static/sentry/app/components/organizations/globalSelectionHeader/index.jsx
@@ -206,8 +206,11 @@ class GlobalSelectionHeader extends React.Component {
       return true;
     }
 
-    // Update if `forceProject` changes
-    if (this.props.forceProject !== nextProps.forceProject) {
+    // Update if `forceProject` changes or loading state changes
+    if (
+      this.props.forceProject !== nextProps.forceProject ||
+      this.props.loadingProjects !== nextProps.loadingProjects
+    ) {
       return true;
     }
 
@@ -259,14 +262,30 @@ class GlobalSelectionHeader extends React.Component {
       return;
     }
 
+    const hasMultipleProjectFeature = this.hasMultipleProjectSelection();
+    let singleProjectIsEnforced = false;
     // This means that previously forceProject was falsey (e.g. loading) and now
     // we have the project to force.
     //
     // If user does not have multiple project selection, we need to save the forced
     // project into the store (if project is not in URL params), otherwise
     // there will be weird behavior in this component since it just picks a project
-    if (!this.hasMultipleProjectSelection() && forceProject && !prevProps.forceProject) {
+    if (!hasMultipleProjectFeature && forceProject && !prevProps.forceProject) {
       // Make sure a project isn't specified in query param already, since it should take precendence
+      const {project} = getStateFromQuery(location.query);
+      if (!project) {
+        singleProjectIsEnforced = true;
+        this.enforceSingleProject({forceProject});
+      }
+    }
+
+    // Projects have finished loading so now we can enforce a single project
+    if (
+      !singleProjectIsEnforced &&
+      prevProps.loadingProjects &&
+      !this.props.loadingProjects &&
+      (!hasMultipleProjectFeature || forceProject)
+    ) {
       const {project} = getStateFromQuery(location.query);
       if (!project) {
         this.enforceSingleProject({forceProject});
diff --git a/src/sentry/static/sentry/app/routes.jsx b/src/sentry/static/sentry/app/routes.jsx
index cbadb4bde1..c24011eb37 100644
--- a/src/sentry/static/sentry/app/routes.jsx
+++ b/src/sentry/static/sentry/app/routes.jsx
@@ -1211,6 +1211,14 @@ function routes() {
           }
           component={errorHandler(LazyLoad)}
         />
+        <Route
+          path="/organizations/:orgId/issues/"
+          component={errorHandler(IssueListContainer)}
+        >
+          <Redirect from="/organizations/:orgId/" to="/organizations/:orgId/issues/" />
+          <IndexRoute component={errorHandler(IssueListOverview)} />
+          <Route path="searches/:searchId/" component={errorHandler(IssueListOverview)} />
+        </Route>
         {/* Once org issues is complete, these routes can be nested under
           /organizations/:orgId/issues */}
         <Route
@@ -1526,17 +1534,6 @@ function routes() {
             path="/organizations/:orgId/projects/:projectId/events/:eventId/"
             component={errorHandler(ProjectEventRedirect)}
           />
-          <Route
-            path="/organizations/:orgId/issues/"
-            component={errorHandler(IssueListContainer)}
-          >
-            <Redirect from="/organizations/:orgId/" to="/organizations/:orgId/issues/" />
-            <IndexRoute component={errorHandler(IssueListOverview)} />
-            <Route
-              path="searches/:searchId/"
-              component={errorHandler(IssueListOverview)}
-            />
-          </Route>
           <Route
             path="/organizations/:orgId/releases/"
             componentPromise={() =>
diff --git a/src/sentry/static/sentry/app/stores/globalSelectionStore.jsx b/src/sentry/static/sentry/app/stores/globalSelectionStore.jsx
index df8de4b5b7..e6089dd6eb 100644
--- a/src/sentry/static/sentry/app/stores/globalSelectionStore.jsx
+++ b/src/sentry/static/sentry/app/stores/globalSelectionStore.jsx
@@ -29,18 +29,43 @@ const getDefaultSelection = () => {
   };
 };
 
-const isValidSelection = (selection, organization) => {
-  const allowedProjects = new Set(
-    organization.projects.filter(project => project.isMember).map(p => parseInt(p.id, 10))
-  );
-  if (
-    Array.isArray(selection.projects) &&
-    selection.projects.some(project => !allowedProjects.has(project))
-  ) {
-    return false;
-  }
+const getProjectsByIds = async (organization, projectIds, api) => {
+  const query = {};
+  query.query = projectIds.map(id => `id:${id}`).join(' ');
+  return await api.requestPromise(`/organizations/${organization.slug}/projects/`, {
+    query,
+  });
+};
 
-  return true;
+const isValidSelection = async (selection, organization, api) => {
+  if (organization.projects) {
+    const allowedProjects = new Set(
+      organization.projects
+        .filter(project => project.hasAccess)
+        .map(p => parseInt(p.id, 10))
+    );
+    if (
+      Array.isArray(selection.projects) &&
+      selection.projects.some(project => !allowedProjects.has(project))
+    ) {
+      return false;
+    }
+    return true;
+  } else {
+    // if the selection is [-1] (all projects) or [] (my projects) return true
+    if (selection.projects.length === 0 || selection.projects[0] === -1) {
+      return true;
+    }
+    // if we do not have organization.projects then make an API call to fetch projects based on id
+    const projects = await getProjectsByIds(organization, selection.projects, api);
+    if (
+      selection.projects.length !== projects.length ||
+      projects.some(project => !project.hasAccess)
+    ) {
+      return false;
+    }
+    return true;
+  }
 };
 
 const GlobalSelectionStore = Reflux.createStore({
@@ -61,7 +86,11 @@ const GlobalSelectionStore = Reflux.createStore({
    * Initializes the global selection store
    * If there are query params apply these, otherwise check local storage
    */
-  loadInitialData(organization, queryParams, {forceUrlSync, onlyIfNeverLoaded} = {}) {
+  loadInitialData(
+    organization,
+    queryParams,
+    {api, forceUrlSync, onlyIfNeverLoaded} = {}
+  ) {
     // If this option is true, only load if it has never been loaded before
     if (onlyIfNeverLoaded && this._hasLoaded) {
       return;
@@ -102,8 +131,11 @@ const GlobalSelectionStore = Reflux.createStore({
         // use default if invalid
       }
     }
+    this.loadSelectionIfValid(globalSelection, organization, forceUrlSync, api);
+  },
 
-    if (isValidSelection(globalSelection, organization)) {
+  async loadSelectionIfValid(globalSelection, organization, forceUrlSync, api) {
+    if (await isValidSelection(globalSelection, organization, api)) {
       this.selection = {
         ...globalSelection,
         ...(forceUrlSync ? {forceUrlSync: true} : {}),
diff --git a/src/sentry/static/sentry/app/stores/projectsStore.jsx b/src/sentry/static/sentry/app/stores/projectsStore.jsx
index e67c879f0a..f5dd47016f 100644
--- a/src/sentry/static/sentry/app/stores/projectsStore.jsx
+++ b/src/sentry/static/sentry/app/stores/projectsStore.jsx
@@ -14,6 +14,7 @@ const ProjectsStore = Reflux.createStore({
     this.listenTo(ProjectActions.loadProjects, this.loadInitialData);
     this.listenTo(ProjectActions.loadStatsSuccess, this.onStatsLoadSuccess);
     this.listenTo(ProjectActions.removeTeamSuccess, this.onRemoveTeam);
+    this.listenTo(ProjectActions.reset, this.reset);
     this.listenTo(ProjectActions.updateSuccess, this.onUpdateSuccess);
 
     this.listenTo(TeamActions.removeTeamSuccess, this.onDeleteTeam);
diff --git a/src/sentry/static/sentry/app/views/issueList/container.jsx b/src/sentry/static/sentry/app/views/issueList/container.jsx
index b5812b647f..e120bbd27f 100644
--- a/src/sentry/static/sentry/app/views/issueList/container.jsx
+++ b/src/sentry/static/sentry/app/views/issueList/container.jsx
@@ -3,7 +3,7 @@ import DocumentTitle from 'react-document-title';
 
 import {PageContent} from 'app/styles/organization';
 import GlobalSelectionHeader from 'app/components/organizations/globalSelectionHeader';
-import NoProjectMessage from 'app/components/noProjectMessage';
+import LightWeightNoProjectMessage from 'app/components/lightWeightNoProjectMessage';
 import SentryTypes from 'app/sentryTypes';
 import withOrganization from 'app/utils/withOrganization';
 
@@ -25,7 +25,9 @@ class IssueListContainer extends React.Component {
           <GlobalSelectionHeader organization={organization} />
 
           <PageContent>
-            <NoProjectMessage organization={organization}>{children}</NoProjectMessage>
+            <LightWeightNoProjectMessage organization={organization}>
+              {children}
+            </LightWeightNoProjectMessage>
           </PageContent>
         </React.Fragment>
       </DocumentTitle>
diff --git a/src/sentry/static/sentry/app/views/issueList/overview.jsx b/src/sentry/static/sentry/app/views/issueList/overview.jsx
index 1ab38636bb..60ef3964cd 100644
--- a/src/sentry/static/sentry/app/views/issueList/overview.jsx
+++ b/src/sentry/static/sentry/app/views/issueList/overview.jsx
@@ -252,21 +252,12 @@ const IssueListOverview = createReactClass({
     return new Set(this.props.organization.features);
   },
 
-  /**
-   * Get the projects that are selected in the global filters
-   */
-  getGlobalSearchProjects() {
-    let {projects} = this.props.selection;
-
-    // Not sure how this worked before for "omits null values" test
-    projects = (projects && projects.map(p => p.toString())) || [];
-
-    return this.props.organization.projects.filter(p => projects.indexOf(p.id) > -1);
+  getGlobalSearchProjectIds() {
+    return this.props.selection.projects;
   },
 
   fetchMemberList() {
-    const projects = this.getGlobalSearchProjects();
-    const projectIds = projects.map(p => p.id);
+    const projectIds = this.getGlobalSearchProjectIds();
 
     fetchOrgMembers(this.api, this.props.organization.slug, projectIds).then(members => {
       this.setState({memberList: indexMembersByProject(members)});
@@ -545,7 +536,6 @@ const IssueListOverview = createReactClass({
 
   renderStreamBody() {
     let body;
-
     if (this.state.issuesLoading) {
       body = this.renderLoading();
     } else if (this.state.error) {
@@ -596,7 +586,7 @@ const IssueListOverview = createReactClass({
 
   tagValueLoader(key, search) {
     const {orgId} = this.props.params;
-    const projectIds = this.getGlobalSearchProjects().map(p => p.id);
+    const projectIds = this.getGlobalSearchProjectIds();
     const endpointParams = this.getEndpointParams();
 
     return fetchTagValues(this.api, orgId, key, search, projectIds, endpointParams);
diff --git a/src/sentry/static/sentry/app/views/organizationContext.jsx b/src/sentry/static/sentry/app/views/organizationContext.jsx
index 0e3385a4a4..8146b45bac 100644
--- a/src/sentry/static/sentry/app/views/organizationContext.jsx
+++ b/src/sentry/static/sentry/app/views/organizationContext.jsx
@@ -133,6 +133,11 @@ const OrganizationContext = createReactClass({
     );
   },
 
+  isOrgChanging() {
+    const {organization} = OrganizationStore.get();
+    return organization && organization.slug !== this.getOrganizationSlug();
+  },
+
   isOrgStorePopulatedCorrectly() {
     const {detailed} = this.props;
     const {organization, dirty} = OrganizationStore.get();
@@ -140,7 +145,7 @@ const OrganizationContext = createReactClass({
     return (
       !dirty &&
       organization &&
-      organization.slug === this.getOrganizationSlug() &&
+      !this.isOrgChanging() &&
       (!detailed || (detailed && organization.projects && organization.teams))
     );
   },
@@ -163,7 +168,7 @@ const OrganizationContext = createReactClass({
     );
   },
 
-  async fetchData() {
+  fetchData() {
     if (!this.getOrganizationSlug()) {
       return;
     }
@@ -171,12 +176,13 @@ const OrganizationContext = createReactClass({
     if (this.isOrgStorePopulatedCorrectly()) {
       return;
     }
+
     metric.mark('organization-details-fetch-start');
     fetchOrganizationDetails(
       this.props.api,
       this.getOrganizationSlug(),
       this.props.detailed,
-      true // silent, to not reset a lightweight org that was fetched
+      !this.isOrgChanging() // if true, will preserve a lightweight org that was fetched
     );
   },
 
@@ -197,13 +203,13 @@ const OrganizationContext = createReactClass({
       // We do not want to load the user's last used env/project in this case, otherwise will
       // lead to very confusing behavior.
       if (
-        this.props.detailed &&
-        organization.projects &&
         !this.props.routes.find(
           ({path}) => path && path.includes('/organizations/:orgId/issues/:groupId/')
         )
       ) {
-        GlobalSelectionStore.loadInitialData(organization, this.props.location.query);
+        GlobalSelectionStore.loadInitialData(organization, this.props.location.query, {
+          api: this.props.api,
+        });
       }
     } else if (error) {
       // If user is superuser, open sudo window
diff --git a/src/sentry/static/sentry/app/views/organizationGroupDetails/groupEventDetails/groupEventDetails.tsx b/src/sentry/static/sentry/app/views/organizationGroupDetails/groupEventDetails/groupEventDetails.tsx
index dd46d9d2cb..1703402fe9 100644
--- a/src/sentry/static/sentry/app/views/organizationGroupDetails/groupEventDetails/groupEventDetails.tsx
+++ b/src/sentry/static/sentry/app/views/organizationGroupDetails/groupEventDetails/groupEventDetails.tsx
@@ -107,6 +107,7 @@ class GroupEventDetails extends React.Component<Props, State> {
     // TBD: if this behavior is actually desired
     if (organization.projects) {
       GlobalSelectionStore.loadInitialData(organization, this.props.location.query, {
+        api: this.props.api,
         onlyIfNeverLoaded: true,
         forceUrlSync: true,
       });
diff --git a/tests/js/spec/components/organizations/globalSelectionHeader.spec.jsx b/tests/js/spec/components/organizations/globalSelectionHeader.spec.jsx
index 9b36b389ac..abf5072551 100644
--- a/tests/js/spec/components/organizations/globalSelectionHeader.spec.jsx
+++ b/tests/js/spec/components/organizations/globalSelectionHeader.spec.jsx
@@ -57,7 +57,7 @@ describe('GlobalSelectionHeader', function() {
     MockApiClient.clearMockResponses();
     jest.spyOn(ProjectsStore, 'getState').mockImplementation(() => ({
       projects: organization.projects,
-      loadingProjects: false,
+      loading: false,
     }));
     GlobalSelectionStore.reset();
     [
@@ -274,7 +274,7 @@ describe('GlobalSelectionHeader', function() {
     });
     jest.spyOn(ProjectsStore, 'getState').mockImplementation(() => ({
       projects: initialData.projects,
-      loadingProjects: false,
+      loading: false,
     }));
 
     const wrapper = mountWithTheme(
@@ -498,7 +498,7 @@ describe('GlobalSelectionHeader', function() {
       const org = TestStubs.Organization({projects: [project]});
       jest
         .spyOn(ProjectsStore, 'getState')
-        .mockImplementation(() => ({projects: org.projects, loadingProjects: false}));
+        .mockImplementation(() => ({projects: org.projects, loading: false}));
 
       const initializationObj = initializeOrg({
         organization: org,
@@ -520,6 +520,10 @@ describe('GlobalSelectionHeader', function() {
   describe('forceProject selection mode', function() {
     let wrapper;
     beforeAll(function() {
+      MockApiClient.addMockResponse({
+        url: '/organizations/org-slug/projects/',
+        body: [],
+      });
       const initialData = initializeOrg({
         organization: {features: ['global-views']},
         projects: [
@@ -590,7 +594,7 @@ describe('GlobalSelectionHeader', function() {
       beforeEach(function() {
         jest.spyOn(ProjectsStore, 'getState').mockImplementation(() => ({
           projects: initialData.organization.projects,
-          loadingProjects: false,
+          loading: false,
         }));
         initialData.router.push.mockClear();
         initialData.router.replace.mockClear();
@@ -609,9 +613,22 @@ describe('GlobalSelectionHeader', function() {
       });
 
       it('appends projectId to URL when `forceProject` becomes available (async)', async function() {
+        const mockProjectsStoreState = {
+          projects: [],
+          loading: true,
+        };
+
+        jest
+          .spyOn(ProjectsStore, 'getState')
+          .mockImplementation(() => mockProjectsStoreState);
+
         // forceProject generally starts undefined
         createWrapper({shouldForceProject: true});
 
+        // load the projects
+        mockProjectsStoreState.projects = initialData.organization.projects;
+        mockProjectsStoreState.loading = false;
+
         wrapper.setProps({
           forceProject: initialData.organization.projects[1],
         });
@@ -622,6 +639,8 @@ describe('GlobalSelectionHeader', function() {
           pathname: undefined,
           query: {project: [1]},
         });
+
+        expect(initialData.router.replace).toHaveBeenCalledTimes(1);
       });
 
       it('does not append projectId to URL when `forceProject` becomes available but project id already exists in URL', async function() {
@@ -715,6 +734,130 @@ describe('GlobalSelectionHeader', function() {
     });
   });
 
+  describe('with global-views (multi-project feature)', function() {
+    describe('without existing URL params', function() {
+      let wrapper;
+      const initialData = initializeOrg({
+        organization: {features: ['global-views']},
+        projects: [
+          {id: 0, slug: 'random project', isMember: true},
+          {id: 1, slug: 'staging-project', environments: ['staging']},
+          {id: 2, slug: 'prod-project', environments: ['prod']},
+        ],
+        router: {
+          location: {query: {}},
+          params: {orgId: 'org-slug'},
+        },
+      });
+
+      const createWrapper = props => {
+        wrapper = mountWithTheme(
+          <GlobalSelectionHeader
+            params={{orgId: initialData.organization.slug}}
+            organization={initialData.organization}
+            {...props}
+          />,
+          initialData.routerContext
+        );
+        return wrapper;
+      };
+
+      beforeEach(function() {
+        jest.spyOn(ProjectsStore, 'getState').mockImplementation(() => ({
+          projects: initialData.organization.projects,
+          loading: false,
+        }));
+        initialData.router.push.mockClear();
+        initialData.router.replace.mockClear();
+      });
+
+      it('does not use first project in org projects when mounting', async function() {
+        createWrapper();
+
+        await tick();
+        wrapper.update();
+
+        expect(initialData.router.replace).not.toHaveBeenCalled();
+      });
+
+      it('does not append projectId to URL when `loadingProjects` changes and finishes loading', async function() {
+        const mockProjectsStoreState = {
+          projects: [],
+          loading: true,
+        };
+
+        jest
+          .spyOn(ProjectsStore, 'getState')
+          .mockImplementation(() => mockProjectsStoreState);
+
+        createWrapper();
+
+        // load the projects
+        mockProjectsStoreState.projects = initialData.organization.projects;
+        mockProjectsStoreState.loading = false;
+
+        wrapper.update();
+
+        expect(initialData.router.replace).not.toHaveBeenCalled();
+      });
+
+      it('appends projectId to URL when `forceProject` becomes available (async)', async function() {
+        const mockProjectsStoreState = {
+          projects: [],
+          loading: true,
+        };
+
+        jest
+          .spyOn(ProjectsStore, 'getState')
+          .mockImplementation(() => mockProjectsStoreState);
+
+        // forceProject generally starts undefined
+        createWrapper({shouldForceProject: true});
+
+        // load the projects
+        mockProjectsStoreState.projects = initialData.organization.projects;
+        mockProjectsStoreState.loading = false;
+
+        wrapper.setProps({
+          forceProject: initialData.organization.projects[1],
+        });
+
+        wrapper.update();
+
+        expect(initialData.router.replace).toHaveBeenLastCalledWith({
+          pathname: undefined,
+          query: {project: [1]},
+        });
+
+        expect(initialData.router.replace).toHaveBeenCalledTimes(1);
+      });
+
+      it('does not append projectId to URL when `forceProject` becomes available but project id already exists in URL', async function() {
+        // forceProject generally starts undefined
+        createWrapper({shouldForceProject: true});
+
+        wrapper.setContext({
+          router: {
+            ...initialData.router,
+            location: {
+              ...initialData.router.location,
+              query: {
+                project: 321,
+              },
+            },
+          },
+        });
+        wrapper.setProps({
+          forceProject: initialData.organization.projects[1],
+        });
+
+        wrapper.update();
+
+        expect(initialData.router.replace).not.toHaveBeenCalled();
+      });
+    });
+  });
+
   describe('projects list', function() {
     let wrapper, memberProject, nonMemberProject, initialData;
     beforeEach(function() {
@@ -723,7 +866,7 @@ describe('GlobalSelectionHeader', function() {
       const org = TestStubs.Organization({projects: [memberProject, nonMemberProject]});
       jest
         .spyOn(ProjectsStore, 'getState')
-        .mockImplementation(() => ({projects: org.projects, loadingProjects: false}));
+        .mockImplementation(() => ({projects: org.projects, loading: false}));
 
       initialData = initializeOrg({
         organization: org,
diff --git a/tests/js/spec/views/organizationContext.spec.jsx b/tests/js/spec/views/organizationContext.spec.jsx
index ac9bb97577..ab25f53e06 100644
--- a/tests/js/spec/views/organizationContext.spec.jsx
+++ b/tests/js/spec/views/organizationContext.spec.jsx
@@ -89,7 +89,7 @@ describe('OrganizationContext', function() {
       true,
       true
     );
-    expect(GlobalSelectionStore.loadInitialData).toHaveBeenCalledWith(org, {});
+    expect(GlobalSelectionStore.loadInitialData).toHaveBeenCalledWith(org, {}, {api});
   });
 
   it('fetches new org when router params change', async function() {

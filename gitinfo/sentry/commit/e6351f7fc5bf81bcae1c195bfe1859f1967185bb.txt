commit e6351f7fc5bf81bcae1c195bfe1859f1967185bb
Author: Lyn Nagara <lyn.nagara@gmail.com>
Date:   Wed Oct 9 10:30:05 2019 -0700

    ref(eventstore): Simplify eventstore interface take 2 (#14952)
    
    This is a second attempt at simplifying the eventstore interface to
    accept a single filter argument instead of the snuba_args dict. A filter
    consists of start and end timestamp, a list of conditions and any project,
    group and event IDs for filtering.
    
    Ideally I think we would not distinguish the project, group and event
    filtering from regular conditions and do away with the concept of
    filter_keys however since we perform a number of additional steps on
    these keys we need to keep these separate.
    
    V1 - https://github.com/getsentry/sentry/pull/14339

diff --git a/src/sentry/api/bases/organization_events.py b/src/sentry/api/bases/organization_events.py
index 04a8fefd2c..4cdebfbd89 100644
--- a/src/sentry/api/bases/organization_events.py
+++ b/src/sentry/api/bases/organization_events.py
@@ -1,12 +1,11 @@
 from __future__ import absolute_import
 
 from rest_framework.exceptions import PermissionDenied
-from copy import copy
 
-from sentry import eventstore, features
+from sentry import eventstore
 from sentry.api.bases import OrganizationEndpoint, OrganizationEventsError
 from sentry.api.event_search import (
-    get_snuba_query_args,
+    get_filter,
     resolve_field_list,
     InvalidSearchQuery,
     get_reference_event_conditions,
@@ -24,10 +23,17 @@ class OrganizationEventsEndpointBase(OrganizationEndpoint):
     def get_snuba_query_args(self, request, organization, params):
         query = request.GET.get("query")
         try:
-            snuba_args = get_snuba_query_args(query=query, params=params)
+            filter = get_filter(query, params)
         except InvalidSearchQuery as exc:
             raise OrganizationEventsError(exc.message)
 
+        snuba_args = {
+            "start": filter.start,
+            "end": filter.end,
+            "conditions": filter.conditions,
+            "filter_keys": filter.filter_keys,
+        }
+
         sort = request.GET.getlist("sort")
         if sort:
             snuba_args["orderby"] = sort
@@ -57,14 +63,6 @@ class OrganizationEventsEndpointBase(OrganizationEndpoint):
                 snuba_args, reference_event_id
             )
 
-        # TODO(lb): remove once boolean search is fully functional
-        has_boolean_op_flag = features.has(
-            "organizations:boolean-search", organization, actor=request.user
-        )
-        if snuba_args.pop("has_boolean_terms", False) and not has_boolean_op_flag:
-            raise OrganizationEventsError(
-                "Boolean search operator OR and AND not allowed in this search."
-            )
         return snuba_args
 
     def get_snuba_query_args_legacy(self, request, organization):
@@ -90,18 +88,16 @@ class OrganizationEventsEndpointBase(OrganizationEndpoint):
 
         query = request.GET.get("query")
         try:
-            snuba_args = get_snuba_query_args(query=query, params=params)
+            _filter = get_filter(query, params)
         except InvalidSearchQuery as exc:
             raise OrganizationEventsError(exc.message)
 
-        # TODO(lb): remove once boolean search is fully functional
-        has_boolean_op_flag = features.has(
-            "organizations:boolean-search", organization, actor=request.user
-        )
-        if snuba_args.pop("has_boolean_terms", False) and not has_boolean_op_flag:
-            raise OrganizationEventsError(
-                "Boolean search operator OR and AND not allowed in this search."
-            )
+        snuba_args = {
+            "start": _filter.start,
+            "end": _filter.end,
+            "conditions": _filter.conditions,
+            "filter_keys": _filter.filter_keys,
+        }
 
         # 'legacy' endpoints cannot access transactions dataset.
         # as they often have assumptions about which columns are returned.
@@ -110,6 +106,7 @@ class OrganizationEventsEndpointBase(OrganizationEndpoint):
             raise OrganizationEventsError(
                 "Invalid query. You cannot reference non-events data in this endpoint."
             )
+
         return snuba_args
 
     def next_event_id(self, snuba_args, event):
@@ -117,10 +114,7 @@ class OrganizationEventsEndpointBase(OrganizationEndpoint):
         Returns the next event ID if there is a subsequent event matching the
         conditions provided. Ignores the project_id.
         """
-        conditions = self._apply_start_and_end(snuba_args)
-        next_event = eventstore.get_next_event_id(
-            event, conditions=conditions, filter_keys=snuba_args["filter_keys"]
-        )
+        next_event = eventstore.get_next_event_id(event, filter=self._get_filter(snuba_args))
 
         if next_event:
             return next_event[1]
@@ -130,21 +124,19 @@ class OrganizationEventsEndpointBase(OrganizationEndpoint):
         Returns the previous event ID if there is a previous event matching the
         conditions provided. Ignores the project_id.
         """
-        conditions = self._apply_start_and_end(snuba_args)
-        prev_event = eventstore.get_prev_event_id(
-            event, conditions=conditions, filter_keys=snuba_args["filter_keys"]
-        )
+        prev_event = eventstore.get_prev_event_id(event, filter=self._get_filter(snuba_args))
 
         if prev_event:
             return prev_event[1]
 
-    def _apply_start_and_end(self, snuba_args):
-        conditions = copy(snuba_args["conditions"])
-        if "start" in snuba_args:
-            conditions.append(["timestamp", ">=", snuba_args["start"]])
-        if "end" in snuba_args:
-            conditions.append(["timestamp", "<=", snuba_args["end"]])
-        return conditions
+    def _get_filter(self, snuba_args):
+        return eventstore.Filter(
+            conditions=snuba_args["conditions"],
+            start=snuba_args.get("start", None),
+            end=snuba_args.get("end", None),
+            project_ids=snuba_args["filter_keys"].get("project_id", None),
+            group_ids=snuba_args["filter_keys"].get("issue", None),
+        )
 
     def oldest_event_id(self, snuba_args, event):
         """
diff --git a/src/sentry/api/endpoints/group_events.py b/src/sentry/api/endpoints/group_events.py
index 0d58528c5c..97d77755cd 100644
--- a/src/sentry/api/endpoints/group_events.py
+++ b/src/sentry/api/endpoints/group_events.py
@@ -8,10 +8,10 @@ from rest_framework.response import Response
 from functools import partial
 
 
-from sentry import eventstore, features
+from sentry import eventstore
 from sentry.api.base import DocSection, EnvironmentMixin
 from sentry.api.bases import GroupEndpoint
-from sentry.api.event_search import get_snuba_query_args
+from sentry.api.event_search import get_filter
 from sentry.api.exceptions import ResourceDoesNotExist
 from sentry.api.helpers.environments import get_environments
 from sentry.api.helpers.events import get_direct_hit_response
@@ -86,17 +86,7 @@ class GroupEventsEndpoint(GroupEndpoint, EnvironmentMixin):
             params["environment"] = [env.name for env in environments]
 
         full = request.GET.get("full", False)
-        snuba_args = get_snuba_query_args(request.GET.get("query", None), params)
-
-        # TODO(lb): remove once boolean search is fully functional
-        if snuba_args:
-            has_boolean_op_flag = features.has(
-                "organizations:boolean-search", group.project.organization, actor=request.user
-            )
-            if snuba_args.pop("has_boolean_terms", False) and not has_boolean_op_flag:
-                raise GroupEventsError(
-                    "Boolean search operator OR and AND not allowed in this search."
-                )
+        snuba_filter = get_filter(request.GET.get("query", None), params)
 
         snuba_cols = None if full else eventstore.full_columns
 
@@ -104,7 +94,7 @@ class GroupEventsEndpoint(GroupEndpoint, EnvironmentMixin):
             eventstore.get_events,
             additional_columns=snuba_cols,
             referrer="api.group-events",
-            **snuba_args
+            filter=snuba_filter,
         )
 
         serializer = EventSerializer() if full else SimpleEventSerializer()
diff --git a/src/sentry/api/endpoints/organization_eventid.py b/src/sentry/api/endpoints/organization_eventid.py
index eeb4d66339..08bcb248d0 100644
--- a/src/sentry/api/endpoints/organization_eventid.py
+++ b/src/sentry/api/endpoints/organization_eventid.py
@@ -47,7 +47,9 @@ class EventIdLookupEndpoint(OrganizationEndpoint):
 
         try:
             event = eventstore.get_events(
-                filter_keys={"project_id": project_slugs_by_id.keys(), "event_id": event_id},
+                filter=eventstore.Filter(
+                    project_ids=project_slugs_by_id.keys(), event_ids=[event_id]
+                ),
                 limit=1,
             )[0]
         except IndexError:
diff --git a/src/sentry/api/endpoints/organization_events.py b/src/sentry/api/endpoints/organization_events.py
index 2c2f72e2be..98f955acab 100644
--- a/src/sentry/api/endpoints/organization_events.py
+++ b/src/sentry/api/endpoints/organization_events.py
@@ -50,7 +50,13 @@ class OrganizationEventsEndpoint(OrganizationEventsEndpointBase):
                 eventstore.get_events,
                 additional_columns=cols,
                 referrer="api.organization-events",
-                **snuba_args
+                filter=eventstore.Filter(
+                    start=snuba_args["start"],
+                    end=snuba_args["end"],
+                    conditions=snuba_args["conditions"],
+                    project_ids=snuba_args["filter_keys"].get("project_id", None),
+                    group_ids=snuba_args["filter_keys"].get("issue", None),
+                ),
             )
 
         serializer = EventSerializer() if full else SimpleEventSerializer()
diff --git a/src/sentry/api/endpoints/project_event_details.py b/src/sentry/api/endpoints/project_event_details.py
index 382cbf2d76..e03d1854ec 100644
--- a/src/sentry/api/endpoints/project_event_details.py
+++ b/src/sentry/api/endpoints/project_event_details.py
@@ -60,15 +60,13 @@ class ProjectEventDetailsEndpoint(ProjectEndpoint):
             if requested_environments:
                 conditions.append(["environment", "IN", requested_environments])
 
-            filter_keys = {"project_id": [event.project_id], "issue": [event.group_id]}
-
-            next_event = eventstore.get_next_event_id(
-                event, conditions=conditions, filter_keys=filter_keys
+            filter = eventstore.Filter(
+                conditions=conditions, project_ids=[event.project_id], group_ids=[event.group_id]
             )
 
-            prev_event = eventstore.get_prev_event_id(
-                event, conditions=conditions, filter_keys=filter_keys
-            )
+            next_event = eventstore.get_next_event_id(event, filter=filter)
+
+            prev_event = eventstore.get_prev_event_id(event, filter=filter)
 
             next_event_id = next_event[1] if next_event else None
             prev_event_id = prev_event[1] if prev_event else None
diff --git a/src/sentry/api/endpoints/project_events.py b/src/sentry/api/endpoints/project_events.py
index 2575a93712..e7019b1f70 100644
--- a/src/sentry/api/endpoints/project_events.py
+++ b/src/sentry/api/endpoints/project_events.py
@@ -51,8 +51,7 @@ class ProjectEventsEndpoint(ProjectEndpoint):
 
         data_fn = partial(
             eventstore.get_events,
-            conditions=conditions,
-            filter_keys={"project_id": [project.id]},
+            filter=eventstore.Filter(conditions=conditions, project_ids=[project.id]),
             additional_columns=cols,
             referrer="api.project-events",
         )
diff --git a/src/sentry/api/event_search.py b/src/sentry/api/event_search.py
index 47c35b547d..395e3a539f 100644
--- a/src/sentry/api/event_search.py
+++ b/src/sentry/api/event_search.py
@@ -1,7 +1,7 @@
 from __future__ import absolute_import
 
 import re
-from collections import namedtuple, defaultdict
+from collections import namedtuple
 from copy import deepcopy
 from datetime import datetime
 
@@ -624,7 +624,11 @@ def convert_search_filter_to_snuba_query(search_filter):
             return condition
 
 
-def get_snuba_query_args(query=None, params=None):
+def get_filter(query=None, params=None):
+    """
+    Returns an eventstore filter given the search text provided by the user and
+    URL params
+    """
     # NOTE: this function assumes project permissions check already happened
     parsed_terms = []
     if query is not None:
@@ -637,7 +641,7 @@ def get_snuba_query_args(query=None, params=None):
     if params is not None:
         parsed_terms.extend(convert_endpoint_params(params))
 
-    kwargs = {"conditions": [], "filter_keys": defaultdict(list)}
+    kwargs = {"start": None, "end": None, "conditions": [], "project_ids": [], "group_ids": []}
 
     projects = {}
     has_project_term = any(
@@ -658,18 +662,19 @@ def get_snuba_query_args(query=None, params=None):
             elif snuba_name in ("start", "end"):
                 kwargs[snuba_name] = term.value.value
             elif snuba_name in ("project_id", "issue"):
+                if snuba_name == "issue":
+                    snuba_name = "group_ids"
+                if snuba_name == "project_id":
+                    snuba_name = "project_ids"
                 value = term.value.value
                 if isinstance(value, int):
                     value = [value]
-                kwargs["filter_keys"][snuba_name].extend(value)
+                kwargs[snuba_name].extend(value)
             else:
                 converted_filter = convert_search_filter_to_snuba_query(term)
                 kwargs["conditions"].append(converted_filter)
-        else:  # SearchBoolean
-            # TODO(lb): remove when boolean terms fully functional
-            kwargs["has_boolean_terms"] = True
-            kwargs["conditions"].append(convert_search_boolean_to_snuba_query(term))
-    return kwargs
+
+    return eventstore.Filter(**kwargs)
 
 
 FIELD_ALIASES = {
diff --git a/src/sentry/api/helpers/events.py b/src/sentry/api/helpers/events.py
index 3c3e479acd..b5e3dd9792 100644
--- a/src/sentry/api/helpers/events.py
+++ b/src/sentry/api/helpers/events.py
@@ -3,7 +3,7 @@ from __future__ import absolute_import
 from rest_framework.response import Response
 
 from sentry import eventstore
-from sentry.api.event_search import get_snuba_query_args
+from sentry.api.event_search import get_filter
 from sentry.utils.validators import normalize_event_id
 from sentry.api.serializers import serialize
 
@@ -15,9 +15,9 @@ def get_direct_hit_response(request, query, snuba_params, referrer):
     """
     event_id = normalize_event_id(query)
     if event_id:
-        snuba_args = get_snuba_query_args(query=u"id:{}".format(event_id), params=snuba_params)
+        snuba_filter = get_filter(query=u"id:{}".format(event_id), params=snuba_params)
 
-        results = eventstore.get_events(referrer=referrer, **snuba_args)
+        results = eventstore.get_events(referrer=referrer, filter=snuba_filter)
 
         if len(results) == 1:
             response = Response(serialize(results, request.user))
diff --git a/src/sentry/eventstore/__init__.py b/src/sentry/eventstore/__init__.py
index bd4cc57975..b22d565b76 100644
--- a/src/sentry/eventstore/__init__.py
+++ b/src/sentry/eventstore/__init__.py
@@ -2,7 +2,7 @@ from __future__ import absolute_import
 
 from sentry.utils.services import LazyServiceWrapper
 
-from .base import EventStorage, Columns  # NOQA
+from .base import EventStorage, Columns, Filter  # NOQA
 
 backend = LazyServiceWrapper(
     EventStorage, "sentry.eventstore.snuba.SnubaEventStorage", {}, metrics_path="eventstore"
diff --git a/src/sentry/eventstore/base.py b/src/sentry/eventstore/base.py
index 152d1dbf4b..6a71b13455 100644
--- a/src/sentry/eventstore/base.py
+++ b/src/sentry/eventstore/base.py
@@ -66,6 +66,54 @@ class Columns(Enum):
     CONTEXTS_VALUE = "contexts.value"
 
 
+class Filter(object):
+    """
+    A set of conditions, start/end times and project, group and event ID sets
+    used to restrict the results of a Snuba query.
+
+    start (DateTime): Start datetime - default None
+    end (DateTime): Start datetime - default None
+    conditions (Sequence[Sequence[str, str, Any]]): List of conditions to fetch - default None
+    project_ids (Sequence[int]): List of project IDs to fetch - default None
+    group_ids (Sequence[int]): List of group IDs to fetch - defualt None
+    event_ids (Sequence[int]): List of event IDs to fetch - default None
+    """
+
+    def __init__(
+        self,
+        start=None,
+        end=None,
+        conditions=None,
+        project_ids=None,
+        group_ids=None,
+        event_ids=None,
+    ):
+        self.start = start
+        self.end = end
+        self.conditions = conditions
+        self.project_ids = project_ids
+        self.group_ids = group_ids
+        self.event_ids = event_ids
+
+    @property
+    def filter_keys(self):
+        """
+        Get filter_keys value required for raw snuba query
+        """
+        filter_keys = {}
+
+        if self.project_ids:
+            filter_keys["project_id"] = self.project_ids
+
+        if self.group_ids:
+            filter_keys["issue"] = self.group_ids
+
+        if self.event_ids:
+            filter_keys["event_id"] = self.event_ids
+
+        return filter_keys
+
+
 class EventStorage(Service):
     __all__ = (
         "minimal_columns",
@@ -102,60 +150,50 @@ class EventStorage(Service):
         Columns.USERNAME,
     ]
 
-    def get_event_by_id(self, project_id, event_id, additional_columns):
-        """
-        Gets a single event given a project_id and event_id.
-
-        Keyword arguments:
-        project_id (int): Project ID
-        event_id (str): Event ID
-        additional_columns: (Sequence[Column]) - List of addition columns to fetch - default None
-        """
-        raise NotImplementedError
-
-    def get_events(
-        self, start, end, additional_columns, conditions, filter_keys, orderby, limit, offset
-    ):
+    def get_events(self, filter, additional_columns, orderby, limit, offset, referrer):
         """
         Fetches a list of events given a set of criteria.
 
-        Keyword arguments:
-        start (DateTime): Start datetime - default datetime.utcfromtimestamp(0)
-        end (DateTime): End datetime - default datetime.utcnow()
+        Arguments:
+        filter (Filter): Filter
         additional_columns (Sequence[Column]): List of additional columns to fetch - default None
-        conditions (Sequence[Sequence[str, str, Any]]): List of conditions to fetch - default None
-        filter_keys (Mapping[str, Any]): Filter keys - default None
         orderby (Sequence[str]): List of fields to order by - default ['-time', '-event_id']
         limit (int): Query limit - default 100
         offset (int): Query offset - default 0
+        referrer (string): Referrer - default "eventstore.get_events"
         """
         raise NotImplementedError
 
-    def get_next_event_id(self, event, conditions, filter_keys):
+    def get_event_by_id(self, project_id, event_id, additional_columns):
+        """
+        Gets a single event given a project_id and event_id.
+
+        Arguments:
+        project_id (int): Project ID
+        event_id (str): Event ID
+        additional_columns: (Sequence[Column]) - List of addition columns to fetch - default None
+        """
+        raise NotImplementedError
+
+    def get_next_event_id(self, event, filter):
         """
         Gets the next event given a current event and some conditions/filters.
         Returns a tuple of (project_id, event_id)
 
         Arguments:
         event (Event): Event object
-
-        Keyword arguments:
-        conditions (Sequence[Sequence[str, str, Any]]): List of conditions - default None
-        filter_keys (Mapping[str, Any]): Filter keys - default None
+        filter (Filter): Filter
         """
         raise NotImplementedError
 
-    def get_prev_event_id(self, event, conditions, filter_keys):
+    def get_prev_event_id(self, event, filter):
         """
         Gets the previous event given a current event and some conditions/filters.
         Returns a tuple of (project_id, event_id)
 
         Arguments:
         event (Event): Event object
-
-        Keyword arguments:
-        conditions (Sequence[Sequence[str, str, Any]]): List of conditions - default None
-        filter_keys (Mapping[str, Any]): Filter keys - default None
+        filter (Filter): Filter
         """
         raise NotImplementedError
 
diff --git a/src/sentry/eventstore/snuba/backend.py b/src/sentry/eventstore/snuba/backend.py
index 0ec97af9ab..67e221cebe 100644
--- a/src/sentry/eventstore/snuba/backend.py
+++ b/src/sentry/eventstore/snuba/backend.py
@@ -2,7 +2,7 @@ from __future__ import absolute_import
 
 from datetime import datetime
 import six
-from copy import copy
+from copy import deepcopy
 
 from sentry.models import SnubaEvent
 from sentry.utils import snuba
@@ -21,11 +21,8 @@ class SnubaEventStorage(EventStorage):
 
     def get_events(
         self,
-        start=None,
-        end=None,
+        filter,
         additional_columns=None,
-        conditions=None,
-        filter_keys=None,
         orderby=DEFAULT_ORDERBY,
         limit=DEFAULT_LIMIT,
         offset=DEFAULT_OFFSET,
@@ -34,14 +31,16 @@ class SnubaEventStorage(EventStorage):
         """
         Get events from Snuba.
         """
+        assert filter, "You must provide a filter"
+
         cols = self.__get_columns(additional_columns)
 
         result = snuba.raw_query(
-            start=start,
-            end=end,
             selected_columns=cols,
-            conditions=conditions,
-            filter_keys=filter_keys,
+            start=filter.start,
+            end=filter.end,
+            conditions=filter.conditions,
+            filter_keys=filter.filter_keys,
             orderby=orderby,
             limit=limit,
             offset=offset,
@@ -75,57 +74,51 @@ class SnubaEventStorage(EventStorage):
             return SnubaEvent(result["data"][0])
         return None
 
-    def get_next_event_id(self, event, conditions=None, filter_keys=None):
+    def get_next_event_id(self, event, filter):
         """
         Returns (project_id, event_id) of a next event given a current event
         and any filters/conditions. Returns None if no next event is found.
         """
+        assert filter, "You must provide a filter"
 
         if not event:
             return None
 
-        conditions = copy(conditions)
+        filter = deepcopy(filter)
 
         time_condition = [
             ["timestamp", ">=", event.timestamp],
             [["timestamp", ">", event.timestamp], ["event_id", ">", event.event_id]],
         ]
+        filter.conditions = filter.conditions or []
+        filter.conditions.extend(time_condition)
+        filter.start = event.datetime
+        filter.end = datetime.utcnow()
 
-        conditions = conditions or []
-        conditions.extend(time_condition)
-
-        return self.__get_next_or_prev_event_id(
-            start=event.datetime,
-            end=datetime.utcnow(),
-            conditions=conditions,
-            filter_keys=filter_keys,
-            orderby=["timestamp", "event_id"],
-        )
+        return self.__get_next_or_prev_event_id(filter=filter, orderby=["timestamp", "event_id"])
 
-    def get_prev_event_id(self, event, conditions=None, filter_keys=None):
+    def get_prev_event_id(self, event, filter):
         """
         Returns (project_id, event_id) of a previous event given a current event
-        and any filters/conditions. Returns None if no previous event is found.
+        and a filter. Returns None if no previous event is found.
         """
+        assert filter, "You must provide a filter"
+
         if not event:
             return None
 
-        conditions = copy(conditions)
+        filter = deepcopy(filter)
 
         time_condition = [
             ["timestamp", "<=", event.timestamp],
             [["timestamp", "<", event.timestamp], ["event_id", "<", event.event_id]],
         ]
-        conditions = conditions or []
-        conditions.extend(time_condition)
-
-        return self.__get_next_or_prev_event_id(
-            end=event.datetime,
-            start=datetime.utcfromtimestamp(0),
-            conditions=conditions,
-            filter_keys=filter_keys,
-            orderby=["-timestamp", "-event_id"],
-        )
+        filter.conditions = filter.conditions or []
+        filter.conditions.extend(time_condition)
+        filter.end = event.datetime
+        filter.start = datetime.utcfromtimestamp(0)
+
+        return self.__get_next_or_prev_event_id(filter=filter, orderby=["-timestamp", "-event_id"])
 
     def __get_columns(self, additional_columns):
         columns = EventStorage.minimal_columns
@@ -135,13 +128,21 @@ class SnubaEventStorage(EventStorage):
 
         return [col.value for col in columns]
 
-    def __get_next_or_prev_event_id(self, **kwargs):
+    def __get_next_or_prev_event_id(self, filter=None, orderby=None):
+        columns = ["event_id", "project_id"]
         result = snuba.dataset_query(
-            selected_columns=["event_id", "project_id"],
+            selected_columns=columns,
+            conditions=filter.conditions,
+            filter_keys=filter.filter_keys,
+            start=filter.start,
+            end=filter.end,
             limit=1,
             referrer="eventstore.get_next_or_prev_event_id",
-            dataset=snuba.detect_dataset(kwargs, aliased_conditions=True),
-            **kwargs
+            orderby=orderby,
+            dataset=snuba.detect_dataset(
+                {"selected_columns": columns, "conditions": filter.conditions},
+                aliased_conditions=True,
+            ),
         )
 
         if "error" in result or len(result["data"]) == 0:
diff --git a/src/sentry/incidents/logic.py b/src/sentry/incidents/logic.py
index feace19092..b2602e8fed 100644
--- a/src/sentry/incidents/logic.py
+++ b/src/sentry/incidents/logic.py
@@ -11,7 +11,7 @@ from django.db import transaction
 from django.utils import timezone
 
 from sentry import analytics
-from sentry.api.event_search import get_snuba_query_args
+from sentry.api.event_search import get_filter
 from sentry.incidents.models import (
     AlertRule,
     AlertRuleExcludedProjects,
@@ -142,7 +142,7 @@ def calculate_incident_start(query, projects, groups):
     if projects:
         params["project_id"] = [p.id for p in projects]
 
-    query_args = get_snuba_query_args(query, params)
+    filter = get_filter(query, params)
     rollup = int(INCIDENT_START_ROLLUP.total_seconds())
 
     result = raw_query(
@@ -152,7 +152,10 @@ def calculate_incident_start(query, projects, groups):
         rollup=rollup,
         referrer="incidents.calculate_incident_start",
         limit=10000,
-        **query_args
+        start=filter.start,
+        end=filter.end,
+        conditions=filter.conditions,
+        filter_keys=filter.filter_keys,
     )["data"]
     # TODO: Start could be the period before the first period we find
     result = zerofill(result, params["start"], params["end"], rollup, "time")
@@ -423,7 +426,17 @@ def bulk_build_incident_query_params(incidents, start=None, end=None):
         project_ids = incident_projects[incident.id]
         if project_ids:
             params["project_id"] = project_ids
-        query_args_list.append(get_snuba_query_args(incident.query, params))
+
+        filter = get_filter(incident.query, params)
+
+        query_args_list.append(
+            {
+                "start": filter.start,
+                "end": filter.end,
+                "conditions": filter.conditions,
+                "filter_keys": filter.filter_keys,
+            }
+        )
 
     return query_args_list
 
@@ -837,7 +850,7 @@ def validate_alert_rule_query(query):
     # TODO: We should add more validation here to reject queries that include
     # fields that are invalid in alert rules. For now this will just make sure
     # the query parses correctly.
-    get_snuba_query_args(query)
+    get_filter(query)
 
 
 def get_excluded_projects_for_alert_rule(alert_rule):
diff --git a/src/sentry/models/group.py b/src/sentry/models/group.py
index 03d6e621ff..a9adea3cb4 100644
--- a/src/sentry/models/group.py
+++ b/src/sentry/models/group.py
@@ -137,25 +137,22 @@ class EventOrdering(Enum):
 def get_oldest_or_latest_event_for_environments(
     ordering, environments=(), issue_id=None, project_id=None
 ):
-    from sentry.utils import snuba
-    from sentry.models import SnubaEvent
-
     conditions = []
 
     if len(environments) > 0:
         conditions.append(["environment", "IN", environments])
 
-    result = snuba.raw_query(
-        selected_columns=SnubaEvent.selected_columns,
-        conditions=conditions,
-        filter_keys={"issue": [issue_id], "project_id": [project_id]},
-        orderby=ordering.value,
+    events = eventstore.get_events(
+        filter=eventstore.Filter(
+            conditions=conditions, project_ids=[project_id], group_ids=[issue_id]
+        ),
         limit=1,
+        orderby=ordering.value,
         referrer="Group.get_latest",
     )
 
-    if "error" not in result and len(result["data"]) == 1:
-        return SnubaEvent(result["data"][0])
+    if events:
+        return events[0]
 
     return None
 
@@ -212,9 +209,12 @@ class GroupManager(BaseManager):
         return Group.objects.get(id=group_id)
 
     def filter_by_event_id(self, project_ids, event_id):
+        event_ids = [event_id]
+        conditions = [["group_id", "IS NOT NULL", None]]
         data = eventstore.get_events(
-            conditions=[["group_id", "IS NOT NULL", None]],
-            filter_keys={"event_id": [event_id], "project_id": project_ids},
+            filter=eventstore.Filter(
+                event_ids=event_ids, project_ids=project_ids, conditions=conditions
+            ),
             limit=len(project_ids),
             referrer="Group.filter_by_event_id",
         )
diff --git a/src/sentry/snuba/subscriptions.py b/src/sentry/snuba/subscriptions.py
index b21bd6b9c8..09ca480a08 100644
--- a/src/sentry/snuba/subscriptions.py
+++ b/src/sentry/snuba/subscriptions.py
@@ -4,7 +4,7 @@ import json
 
 from django.db import transaction
 
-from sentry.api.event_search import get_snuba_query_args
+from sentry.api.event_search import get_filter
 from sentry.snuba.models import QueryAggregations, QueryDatasets, QuerySubscription
 from sentry.utils.snuba import _snuba_pool, SnubaError
 
@@ -168,7 +168,7 @@ def _create_in_snuba(project, dataset, query, aggregation, time_window, resoluti
                 # We only care about conditions here. Filter keys only matter for
                 # filtering to project and groups. Projects are handled with an
                 # explicit param, and groups can't be queried here.
-                "conditions": get_snuba_query_args(query)["conditions"],
+                "conditions": get_filter(query).conditions,
                 "aggregates": [query_aggregation_to_snuba[aggregation]],
                 "time_window": time_window,
                 "resolution": resolution,
diff --git a/src/sentry/tasks/unmerge.py b/src/sentry/tasks/unmerge.py
index e206f8b7a7..73370e82c2 100644
--- a/src/sentry/tasks/unmerge.py
+++ b/src/sentry/tasks/unmerge.py
@@ -539,11 +539,12 @@ def unmerge(
         )
 
     events = eventstore.get_events(
-        filter_keys={"project_id": [project_id], "issue": [source.id]},
+        filter=eventstore.Filter(
+            project_ids=[project_id], group_ids=[source.id], conditions=conditions
+        ),
         # We need the text-only "search message" from Snuba, not the raw message
         # dict field from nodestore.
         additional_columns=[eventstore.Columns.MESSAGE],
-        conditions=conditions,
         limit=batch_size,
         referrer="unmerge",
         orderby=["-timestamp", "-event_id"],
diff --git a/tests/integration/tests.py b/tests/integration/tests.py
index cbb9254073..22119129d0 100644
--- a/tests/integration/tests.py
+++ b/tests/integration/tests.py
@@ -608,7 +608,9 @@ class CspReportTest(TestCase, SnubaTestCase):
         # doesn't work here because the event isn't created directly by this test.
         sleep(0.1)
         events = eventstore.get_events(
-            filter_keys={"project_id": [self.project.id]}, conditions=[["type", "=", "csp"]]
+            filter=eventstore.Filter(
+                project_ids=[self.project.id], conditions=[["type", "=", "csp"]]
+            )
         )
         assert len(events) == 1
         e = events[0]
diff --git a/tests/sentry/api/test_event_search.py b/tests/sentry/api/test_event_search.py
index 26a824e2db..83edf587c3 100644
--- a/tests/sentry/api/test_event_search.py
+++ b/tests/sentry/api/test_event_search.py
@@ -12,7 +12,7 @@ from freezegun import freeze_time
 from sentry.api.event_search import (
     convert_endpoint_params,
     event_search_grammar,
-    get_snuba_query_args,
+    get_filter,
     resolve_field_list,
     get_reference_event_conditions,
     parse_search_query,
@@ -849,233 +849,143 @@ class ParseBooleanSearchQueryTest(unittest.TestCase):
 
 class GetSnubaQueryArgsTest(TestCase):
     def test_simple(self):
-        assert get_snuba_query_args(
+        filter = get_filter(
             "user.email:foo@example.com release:1.2.1 fruit:apple hello",
             {
                 "project_id": [1, 2, 3],
                 "start": datetime.datetime(2015, 5, 18, 10, 15, 1, tzinfo=timezone.utc),
                 "end": datetime.datetime(2015, 5, 19, 10, 15, 1, tzinfo=timezone.utc),
             },
-        ) == {
-            "conditions": [
-                ["email", "=", "foo@example.com"],
-                ["tags[sentry:release]", "=", "1.2.1"],
-                [["ifNull", ["tags[fruit]", "''"]], "=", "apple"],
-                [["positionCaseInsensitive", ["message", "'hello'"]], "!=", 0],
-            ],
-            "filter_keys": {"project_id": [1, 2, 3]},
-            "start": datetime.datetime(2015, 5, 18, 10, 15, 1, tzinfo=timezone.utc),
-            "end": datetime.datetime(2015, 5, 19, 10, 15, 1, tzinfo=timezone.utc),
-        }
+        )
+
+        assert filter.conditions == [
+            ["email", "=", "foo@example.com"],
+            ["tags[sentry:release]", "=", "1.2.1"],
+            [["ifNull", ["tags[fruit]", "''"]], "=", "apple"],
+            [["positionCaseInsensitive", ["message", "'hello'"]], "!=", 0],
+        ]
+        assert filter.start == datetime.datetime(2015, 5, 18, 10, 15, 1, tzinfo=timezone.utc)
+        assert filter.end == datetime.datetime(2015, 5, 19, 10, 15, 1, tzinfo=timezone.utc)
+        assert filter.filter_keys == {"project_id": [1, 2, 3]}
+        assert filter.project_ids == [1, 2, 3]
+        assert not filter.group_ids
+        assert not filter.event_ids
 
     def test_negation(self):
-        assert get_snuba_query_args("!user.email:foo@example.com") == {
-            "conditions": [[[["isNull", ["email"]], "=", 1], ["email", "!=", "foo@example.com"]]],
-            "filter_keys": {},
-        }
+        filter = get_filter("!user.email:foo@example.com")
+        assert filter.conditions == [
+            [[["isNull", ["email"]], "=", 1], ["email", "!=", "foo@example.com"]]
+        ]
+        assert filter.filter_keys == {}
 
     def test_implicit_and_explicit_tags(self):
-        assert get_snuba_query_args("tags[fruit]:apple") == {
-            "conditions": [[["ifNull", ["tags[fruit]", "''"]], "=", "apple"]],
-            "filter_keys": {},
-        }
+        assert get_filter("tags[fruit]:apple").conditions == [
+            [["ifNull", ["tags[fruit]", "''"]], "=", "apple"]
+        ]
 
-        assert get_snuba_query_args("fruit:apple") == {
-            "conditions": [[["ifNull", ["tags[fruit]", "''"]], "=", "apple"]],
-            "filter_keys": {},
-        }
+        assert get_filter("fruit:apple").conditions == [
+            [["ifNull", ["tags[fruit]", "''"]], "=", "apple"]
+        ]
 
-        assert get_snuba_query_args("tags[project_id]:123") == {
-            "conditions": [[["ifNull", ["tags[project_id]", "''"]], "=", "123"]],
-            "filter_keys": {},
-        }
+        assert get_filter("tags[project_id]:123").conditions == [
+            [["ifNull", ["tags[project_id]", "''"]], "=", "123"]
+        ]
 
     def test_no_search(self):
-        assert get_snuba_query_args(
+        filter = get_filter(
             params={
                 "project_id": [1, 2, 3],
                 "start": datetime.datetime(2015, 5, 18, 10, 15, 1, tzinfo=timezone.utc),
                 "end": datetime.datetime(2015, 5, 19, 10, 15, 1, tzinfo=timezone.utc),
             }
-        ) == {
-            "conditions": [],
-            "filter_keys": {"project_id": [1, 2, 3]},
-            "start": datetime.datetime(2015, 5, 18, 10, 15, 1, tzinfo=timezone.utc),
-            "end": datetime.datetime(2015, 5, 19, 10, 15, 1, tzinfo=timezone.utc),
-        }
+        )
+        assert not filter.conditions
+        assert filter.filter_keys == {"project_id": [1, 2, 3]}
+        assert filter.start == datetime.datetime(2015, 5, 18, 10, 15, 1, tzinfo=timezone.utc)
+        assert filter.end == datetime.datetime(2015, 5, 19, 10, 15, 1, tzinfo=timezone.utc)
 
     def test_wildcard(self):
-        assert get_snuba_query_args("release:3.1.* user.email:*@example.com") == {
-            "conditions": [
-                [["match", ["tags[sentry:release]", "'(?i)^3\\.1\\..*$'"]], "=", 1],
-                [["match", ["email", "'(?i)^.*\\@example\\.com$'"]], "=", 1],
-            ],
-            "filter_keys": {},
-        }
+        filter = get_filter("release:3.1.* user.email:*@example.com")
+        assert filter.conditions == [
+            [["match", ["tags[sentry:release]", "'(?i)^3\\.1\\..*$'"]], "=", 1],
+            [["match", ["email", "'(?i)^.*\\@example\\.com$'"]], "=", 1],
+        ]
+        assert filter.filter_keys == {}
 
     def test_negated_wildcard(self):
-        assert get_snuba_query_args("!release:3.1.* user.email:*@example.com") == {
-            "conditions": [
-                [
-                    [["isNull", ["tags[sentry:release]"]], "=", 1],
-                    [["match", ["tags[sentry:release]", "'(?i)^3\\.1\\..*$'"]], "!=", 1],
-                ],
-                [["match", ["email", "'(?i)^.*\\@example\\.com$'"]], "=", 1],
+        filter = get_filter("!release:3.1.* user.email:*@example.com")
+        assert filter.conditions == [
+            [
+                [["isNull", ["tags[sentry:release]"]], "=", 1],
+                [["match", ["tags[sentry:release]", "'(?i)^3\\.1\\..*$'"]], "!=", 1],
             ],
-            "filter_keys": {},
-        }
+            [["match", ["email", "'(?i)^.*\\@example\\.com$'"]], "=", 1],
+        ]
+        assert filter.filter_keys == {}
 
     def test_escaped_wildcard(self):
-        assert get_snuba_query_args("release:3.1.\\* user.email:\\*@example.com") == {
-            "conditions": [
-                [["match", ["tags[sentry:release]", "'(?i)^3\\.1\\.\\*$'"]], "=", 1],
-                [["match", ["email", "'(?i)^\*\\@example\\.com$'"]], "=", 1],
-            ],
-            "filter_keys": {},
-        }
-        assert get_snuba_query_args("release:\\\\\\*") == {
-            "conditions": [[["match", ["tags[sentry:release]", "'(?i)^\\\\\\*$'"]], "=", 1]],
-            "filter_keys": {},
-        }
-        assert get_snuba_query_args("release:\\\\*") == {
-            "conditions": [[["match", ["tags[sentry:release]", "'(?i)^\\\\.*$'"]], "=", 1]],
-            "filter_keys": {},
-        }
+        assert get_filter("release:3.1.\\* user.email:\\*@example.com").conditions == [
+            [["match", ["tags[sentry:release]", "'(?i)^3\\.1\\.\\*$'"]], "=", 1],
+            [["match", ["email", "'(?i)^\*\\@example\\.com$'"]], "=", 1],
+        ]
+        assert get_filter("release:\\\\\\*").conditions == [
+            [["match", ["tags[sentry:release]", "'(?i)^\\\\\\*$'"]], "=", 1]
+        ]
+        assert get_filter("release:\\\\*").conditions == [
+            [["match", ["tags[sentry:release]", "'(?i)^\\\\.*$'"]], "=", 1]
+        ]
 
     def test_has(self):
-        assert get_snuba_query_args("has:release") == {
-            "filter_keys": {},
-            "conditions": [[["isNull", ["tags[sentry:release]"]], "!=", 1]],
-        }
+        assert get_filter("has:release").conditions == [
+            [["isNull", ["tags[sentry:release]"]], "!=", 1]
+        ]
 
     def test_not_has(self):
-        assert get_snuba_query_args("!has:release") == {
-            "filter_keys": {},
-            "conditions": [[["isNull", ["tags[sentry:release]"]], "=", 1]],
-        }
+        assert get_filter("!has:release").conditions == [
+            [["isNull", ["tags[sentry:release]"]], "=", 1]
+        ]
 
     def test_message_negative(self):
-        assert get_snuba_query_args('!message:"post_process.process_error HTTPError 403"') == {
-            "filter_keys": {},
-            "conditions": [
+        assert get_filter('!message:"post_process.process_error HTTPError 403"').conditions == [
+            [
                 [
-                    [
-                        "positionCaseInsensitive",
-                        ["message", "'post_process.process_error HTTPError 403'"],
-                    ],
-                    "=",
-                    0,
-                ]
-            ],
-        }
+                    "positionCaseInsensitive",
+                    ["message", "'post_process.process_error HTTPError 403'"],
+                ],
+                "=",
+                0,
+            ]
+        ]
 
     def test_malformed_groups(self):
         with pytest.raises(InvalidSearchQuery):
-            get_snuba_query_args("(user.email:foo@example.com OR user.email:bar@example.com")
-
-    def test_boolean_term_simple(self):
-        assert get_snuba_query_args(
-            "user.email:foo@example.com AND user.email:bar@example.com"
-        ) == {
-            "conditions": [
-                ["and", [["email", "=", "foo@example.com"], ["email", "=", "bar@example.com"]]]
-            ],
-            "filter_keys": {},
-            "has_boolean_terms": True,
-        }
-        assert get_snuba_query_args("user.email:foo@example.com OR user.email:bar@example.com") == {
-            "conditions": [
-                ["or", [["email", "=", "foo@example.com"], ["email", "=", "bar@example.com"]]]
-            ],
-            "filter_keys": {},
-            "has_boolean_terms": True,
-        }
-        assert get_snuba_query_args(
-            "user.email:foo@example.com AND user.email:bar@example.com OR user.email:foobar@example.com AND user.email:hello@example.com AND user.email:hi@example.com OR user.email:foo@example.com AND user.email:bar@example.com OR user.email:foobar@example.com AND user.email:hello@example.com AND user.email:hi@example.com"
-        ) == {
-            "conditions": [
-                [
-                    "or",
-                    [
-                        [
-                            "and",
-                            [["email", "=", "foo@example.com"], ["email", "=", "bar@example.com"]],
-                        ],
-                        [
-                            "or",
-                            [
-                                [
-                                    "and",
-                                    [
-                                        ["email", "=", "foobar@example.com"],
-                                        [
-                                            "and",
-                                            [
-                                                ["email", "=", "hello@example.com"],
-                                                ["email", "=", "hi@example.com"],
-                                            ],
-                                        ],
-                                    ],
-                                ],
-                                [
-                                    "or",
-                                    [
-                                        [
-                                            "and",
-                                            [
-                                                ["email", "=", "foo@example.com"],
-                                                ["email", "=", "bar@example.com"],
-                                            ],
-                                        ],
-                                        [
-                                            "and",
-                                            [
-                                                ["email", "=", "foobar@example.com"],
-                                                [
-                                                    "and",
-                                                    [
-                                                        ["email", "=", "hello@example.com"],
-                                                        ["email", "=", "hi@example.com"],
-                                                    ],
-                                                ],
-                                            ],
-                                        ],
-                                    ],
-                                ],
-                            ],
-                        ],
-                    ],
-                ]
-            ],
-            "filter_keys": {},
-            "has_boolean_terms": True,
-        }
+            get_filter("(user.email:foo@example.com OR user.email:bar@example.com")
 
     def test_issue_filter(self):
-        assert get_snuba_query_args("issue.id:1") == {
-            "conditions": [],
-            "filter_keys": {"issue": [1]},
-        }
+        filter = get_filter("issue.id:1")
+        assert not filter.conditions
+        assert filter.filter_keys == {"issue": [1]}
+        assert filter.group_ids == [1]
 
-        assert get_snuba_query_args("issue.id:1 issue.id:2 issue.id:3") == {
-            "conditions": [],
-            "filter_keys": {"issue": [1, 2, 3]},
-        }
+        filter = get_filter("issue.id:1 issue.id:2 issue.id:3")
+        assert not filter.conditions
+        assert filter.filter_keys == {"issue": [1, 2, 3]}
+        assert filter.group_ids == [1, 2, 3]
 
-        assert get_snuba_query_args("issue.id:1 user.email:foo@example.com") == {
-            "conditions": [["email", "=", "foo@example.com"]],
-            "filter_keys": {"issue": [1]},
-        }
+        filter = get_filter("issue.id:1 user.email:foo@example.com")
+        assert filter.conditions == [["email", "=", "foo@example.com"]]
+        assert filter.filter_keys == {"issue": [1]}
+        assert filter.group_ids == [1]
 
     def test_project_name(self):
         p1 = self.create_project(organization=self.organization)
         p2 = self.create_project(organization=self.organization)
 
         params = {"project_id": [p1.id, p2.id]}
-        assert get_snuba_query_args("project.name:{}".format(p1.slug), params) == {
-            "conditions": [["project_id", "=", p1.id]],
-            "filter_keys": {"project_id": [p1.id, p2.id]},
-        }
+        filter = get_filter("project.name:{}".format(p1.slug), params)
+        filter.conditions == [["project_id", "=", p1.id]]
+        filter.filter_keys == {"project_id": [p1.id, p2.id]}
+        filter.project_ids == [p1.id, p2.id]
 
 
 class ConvertEndpointParamsTests(unittest.TestCase):
diff --git a/tests/sentry/eventstore/snuba/test_backend.py b/tests/sentry/eventstore/snuba/test_backend.py
index a7b79d3af2..42eb21e57c 100644
--- a/tests/sentry/eventstore/snuba/test_backend.py
+++ b/tests/sentry/eventstore/snuba/test_backend.py
@@ -5,6 +5,7 @@ import six
 from sentry.testutils import TestCase, SnubaTestCase
 from sentry.testutils.helpers.datetime import iso_format, before_now
 from sentry.eventstore.snuba.backend import SnubaEventStorage
+from sentry.eventstore.base import Filter
 
 
 class SnubaEventStorageTest(TestCase, SnubaTestCase):
@@ -53,7 +54,7 @@ class SnubaEventStorageTest(TestCase, SnubaTestCase):
 
     def test_get_events(self):
         events = self.eventstore.get_events(
-            filter_keys={"project_id": [self.project1.id, self.project2.id]}
+            filter=Filter(project_ids=[self.project1.id, self.project2.id])
         )
         assert len(events) == 3
         # Default sort is timestamp desc, event_id desc
@@ -63,7 +64,7 @@ class SnubaEventStorageTest(TestCase, SnubaTestCase):
 
         # No events found
         project = self.create_project()
-        events = self.eventstore.get_events(filter_keys={"project_id": [project.id]})
+        events = self.eventstore.get_events(filter=Filter(project_ids=[project.id]))
         assert events == []
 
     def test_get_event_by_id(self):
@@ -91,11 +92,11 @@ class SnubaEventStorageTest(TestCase, SnubaTestCase):
     def test_get_next_prev_event_id(self):
         event = self.eventstore.get_event_by_id(self.project2.id, "b" * 32)
 
-        filter_keys = {"project_id": [self.project1.id, self.project2.id]}
+        filter = Filter(project_ids=[self.project1.id, self.project2.id])
 
-        prev_event = self.eventstore.get_prev_event_id(event, filter_keys=filter_keys)
+        prev_event = self.eventstore.get_prev_event_id(event, filter=filter)
 
-        next_event = self.eventstore.get_next_event_id(event, filter_keys=filter_keys)
+        next_event = self.eventstore.get_next_event_id(event, filter=filter)
 
         assert prev_event == (six.text_type(self.project1.id), "a" * 32)
 
@@ -103,5 +104,5 @@ class SnubaEventStorageTest(TestCase, SnubaTestCase):
         assert next_event == (six.text_type(self.project2.id), "c" * 32)
 
         # Returns None if no event
-        assert self.eventstore.get_prev_event_id(None, filter_keys=filter_keys) is None
-        assert self.eventstore.get_next_event_id(None, filter_keys=filter_keys) is None
+        assert self.eventstore.get_prev_event_id(None, filter=filter) is None
+        assert self.eventstore.get_next_event_id(None, filter=filter) is None
diff --git a/tests/snuba/api/endpoints/test_group_events.py b/tests/snuba/api/endpoints/test_group_events.py
index 354f2ede55..5a2453c39e 100644
--- a/tests/snuba/api/endpoints/test_group_events.py
+++ b/tests/snuba/api/endpoints/test_group_events.py
@@ -291,15 +291,3 @@ class GroupEventsTest(APITestCase, SnubaTestCase):
             assert sorted(map(lambda x: x["eventID"], response.data)) == sorted(
                 [six.text_type(event.event_id)]
             )
-
-    def test_boolean_feature_flag_failure(self):
-        self.login_as(user=self.user)
-        group = self.create_group()
-
-        for query in ["title:hi OR title:hello", "title:hi AND title:hello"]:
-            url = u"/api/0/issues/{}/events/?query={}".format(group.id, query)
-            response = self.client.get(url, format="json")
-            assert response.status_code == 400
-            assert response.data == {
-                "detail": "Boolean search operator OR and AND not allowed in this search."
-            }
diff --git a/tests/snuba/api/endpoints/test_organization_events.py b/tests/snuba/api/endpoints/test_organization_events.py
index 394f193ba7..8a47f59764 100644
--- a/tests/snuba/api/endpoints/test_organization_events.py
+++ b/tests/snuba/api/endpoints/test_organization_events.py
@@ -534,21 +534,6 @@ class OrganizationEventsEndpointTest(APITestCase, SnubaTestCase):
         assert response.status_code == 200, response.content
         assert len(response.data) == 0
 
-    def test_boolean_feature_flag_failure(self):
-        self.login_as(user=self.user)
-        project = self.create_project()
-        url = reverse(
-            "sentry-api-0-organization-events",
-            kwargs={"organization_slug": project.organization.slug},
-        )
-
-        for query in ["title:hi OR title:hello", "title:hi AND title:hello"]:
-            response = self.client.get(url, {"query": query}, format="json")
-            assert response.status_code == 400
-            assert response.data == {
-                "detail": "Boolean search operator OR and AND not allowed in this search."
-            }
-
     def test_group_filtering(self):
         user = self.create_user()
         org = self.create_organization(owner=user)

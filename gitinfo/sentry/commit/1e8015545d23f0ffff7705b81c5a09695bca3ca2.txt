commit 1e8015545d23f0ffff7705b81c5a09695bca3ca2
Author: Matt Robenolt <matt@ydekproductions.com>
Date:   Mon Jan 9 12:02:35 2017 -0800

    javascript: handle unexpected file codecs
    
    Limit the valid codecs that we will attempt to decode on files. Try to
    leverage `CodecInfo._is_text_encoding` when available, which was
    introduced in python 2.7.12. This avoids using codecs such as `base64`.
    
    Fixes SENTRY-2KK

diff --git a/src/sentry/lang/javascript/cache.py b/src/sentry/lang/javascript/cache.py
index e5805b631d..689d2d4434 100644
--- a/src/sentry/lang/javascript/cache.py
+++ b/src/sentry/lang/javascript/cache.py
@@ -1,5 +1,7 @@
 from __future__ import absolute_import, print_function
 
+from sentry.utils.strings import codec_lookup
+
 __all__ = ['SourceCache', 'SourceMapCache']
 
 
@@ -38,12 +40,7 @@ class SourceCache(object):
         if callable(body):
             body = body()
 
-        try:
-            body = body.decode(encoding or 'utf8', 'replace').split(u'\n')
-        except LookupError:
-            # We got an encoding that python doesn't support,
-            # so let's just coerce it to utf8
-            body = body.decode('utf8', 'replace').split(u'\n')
+        body = body.decode(codec_lookup(encoding, 'utf-8').name, 'replace').split(u'\n')
 
         # Set back a marker to indicate we've parsed this url
         self._cache[url] = (True, body)
diff --git a/src/sentry/utils/strings.py b/src/sentry/utils/strings.py
index 974b11da15..0c23de5258 100644
--- a/src/sentry/utils/strings.py
+++ b/src/sentry/utils/strings.py
@@ -8,6 +8,7 @@ sentry.utils.strings
 from __future__ import absolute_import
 
 import base64
+import codecs
 import re
 import six
 import string
@@ -198,3 +199,36 @@ def is_valid_dot_atom(value):
 def count_sprintf_parameters(string):
     """Counts the number of sprintf parameters in a string."""
     return len(_sprintf_placeholder_re.findall(string))
+
+
+def codec_lookup(encoding, default='utf-8'):
+    """Safely lookup a codec and ignore non-text codecs,
+    falling back to a default on errors.
+    Note: the default value is not sanity checked and would
+    bypass these checks."""
+
+    if not encoding:
+        return codecs.lookup(default)
+
+    try:
+        info = codecs.lookup(encoding)
+    except (LookupError, TypeError):
+        return codecs.lookup(default)
+
+    try:
+        # Check for `CodecInfo._is_text_encoding`.
+        # If this attribute exists, we can assume we can operate
+        # with this encoding value safely. This attribute was
+        # introduced into 2.7.12, so versions prior to this will
+        # raise, but this is the best we can do.
+        if not info._is_text_encoding:
+            return codecs.lookup(default)
+    except AttributeError:
+        pass
+
+    # `undefined` is special a special encoding in python that 100% of
+    # the time will raise, so ignore it.
+    if info.name == 'undefined':
+        return codecs.lookup(default)
+
+    return info

commit 1d323f9a81055a0521d4bba8aed3d47fa0846953
Author: Chris Fuller <cfuller@sentry.io>
Date:   Mon Apr 6 23:30:41 2020 -0400

    feat(workflow): Plotting accurate start/end points (#18019)
    
    * Plotting accurate alert start/end points

diff --git a/src/sentry/incidents/logic.py b/src/sentry/incidents/logic.py
index edf4616919..3b7f8dc068 100644
--- a/src/sentry/incidents/logic.py
+++ b/src/sentry/incidents/logic.py
@@ -425,7 +425,7 @@ def bulk_get_incident_stats(incidents, windowed_stats=False):
     affect the snapshots. Only the live fetched stats.
     """
     incident_stats = {}
-    if windowed_stats is True:
+    if windowed_stats:
         # At the moment, snapshots are only ever created with windowed_stats as True
         # so if they send False, we need to do a live calculation below.
         closed = [i for i in incidents if i.status == IncidentStatus.CLOSED.value]
diff --git a/src/sentry/static/sentry/app/views/alerts/details/chart.tsx b/src/sentry/static/sentry/app/views/alerts/details/chart.tsx
index 594ae02beb..8d1b0ce01a 100644
--- a/src/sentry/static/sentry/app/views/alerts/details/chart.tsx
+++ b/src/sentry/static/sentry/app/views/alerts/details/chart.tsx
@@ -10,7 +10,7 @@ import MarkPoint from 'app/components/charts/components/markPoint';
 import closedSymbol from './closedSymbol';
 import detectedSymbol from './detectedSymbol';
 
-type Data = [number, {count: number}[]][];
+type Data = [number, {count: number}[]];
 
 /**
  * So we'll have to see how this looks with real data, but echarts requires
@@ -25,7 +25,7 @@ type Data = [number, {count: number}[]][];
  * @param data Data array
  * @param needle the target timestamp
  */
-function getNearbyIndex(data: Data, needle: number) {
+function getNearbyIndex(data: Data[], needle: number) {
   // `data` is sorted, return the first index whose value (timestamp) is > `needle`
   const index = data.findIndex(([ts]) => ts > needle);
 
@@ -37,8 +37,35 @@ function getNearbyIndex(data: Data, needle: number) {
   return index !== -1 ? index - 1 : data.length - 1;
 }
 
+/**
+ * We can't just pass an x value to the charts, so we calculate a y value
+ * between points using the average of the two points it's between.
+ *
+ * @param data Data array
+ * @param index The (lower) index of the two points used to calculate the average
+ */
+function getAverageBetweenPoints(data: Data[], index: number) {
+  if (index >= data.length - 1) {
+    return getDataValue(data[data.length - 1]);
+  } else if (index < 0) {
+    return getDataValue(data[0]);
+  } else {
+    const pt1 = getDataValue(data[index]);
+    const pt2 = getDataValue(data[index + 1]);
+    return (pt1 + pt2) / 2;
+  }
+}
+
+function getDataValue(data: Data) {
+  if (data === undefined || data[1] === undefined) {
+    return 0;
+  } else {
+    return data[1].reduce((acc, {count} = {count: 0}) => acc + count, 0);
+  }
+}
+
 type Props = {
-  data: Data;
+  data: Data[];
   aggregation: AlertRuleAggregations;
   detected: string;
   closed?: string;
@@ -47,24 +74,37 @@ type Props = {
 export default class Chart extends React.PureComponent<Props> {
   render() {
     const {aggregation, data, detected, closed} = this.props;
-
+    const detectedTs = detected && moment.utc(detected).unix();
+    const closedTs = closed && moment.utc(closed).unix();
     const chartData = data.map(([ts, val]) => [
       ts * 1000,
       val.length ? val.reduce((acc, {count} = {count: 0}) => acc + count, 0) : 0,
     ]);
 
-    const detectedTs = detected && moment.utc(detected).unix();
-    const closedTs = closed && moment.utc(closed).unix();
+    let detectedCoordinate: number[] | undefined;
+    if (detectedTs) {
+      const nearbyDetectedTimestampIndex = getNearbyIndex(data, detectedTs);
+      const detectedYValue =
+        nearbyDetectedTimestampIndex &&
+        getAverageBetweenPoints(data, nearbyDetectedTimestampIndex);
+      detectedCoordinate = [detectedTs * 1000, detectedYValue];
+      chartData.splice(nearbyDetectedTimestampIndex + 1, 0, detectedCoordinate);
+    }
 
-    const nearbyDetectedTimestampIndex = detectedTs && getNearbyIndex(data, detectedTs);
-    const nearbyClosedTimestampIndex = closedTs && getNearbyIndex(data, closedTs);
+    const showClosedMarker =
+      data && closedTs && data[data.length - 1] && data[data.length - 1][0] >= closedTs
+        ? true
+        : false;
+    let closedCoordinate: number[] | undefined;
+    if (closedTs && showClosedMarker) {
+      const nearbyClosedTimestampIndex = getNearbyIndex(data, closedTs);
+      const closedYValue =
+        nearbyClosedTimestampIndex &&
+        getAverageBetweenPoints(data, nearbyClosedTimestampIndex);
+      closedCoordinate = [closedTs * 1000, closedYValue];
+      chartData.splice(nearbyClosedTimestampIndex + 1, 0, closedCoordinate);
+    }
 
-    const detectedCoordinate = chartData && chartData[nearbyDetectedTimestampIndex];
-    const closedCoordinate =
-      chartData &&
-      closedTs &&
-      typeof nearbyClosedTimestampIndex !== 'undefined' &&
-      chartData[nearbyClosedTimestampIndex];
     const seriesName = getDisplayForAlertRuleAggregation(aggregation);
 
     return (
@@ -75,7 +115,7 @@ export default class Chart extends React.PureComponent<Props> {
           {
             // e.g. Events or Users
             seriesName,
-            dataArray: chartData?.slice(0, -1),
+            dataArray: chartData,
             markPoint: MarkPoint({
               data: [
                 {

commit 11681feaa4aea14273157b99a7d1ba97f4a67f4a
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Fri Jun 22 10:40:29 2018 -0700

    feat(ui): Change stream sidebar to use SelectControl (APP-341) (#8706)
    
    Also fixes "timesSeen" to be input instead of select dropdown
    
    ![image](https://user-images.githubusercontent.com/79684/41247714-b4390e3a-6d63-11e8-80a8-9b49da2f8acb.png)

diff --git a/src/sentry/static/sentry/app/stores/tagStore.jsx b/src/sentry/static/sentry/app/stores/tagStore.jsx
index 8e1bdfa08e..d767e4ae93 100644
--- a/src/sentry/static/sentry/app/stores/tagStore.jsx
+++ b/src/sentry/static/sentry/app/stores/tagStore.jsx
@@ -84,6 +84,8 @@ const TagStore = Reflux.createStore({
       timesSeen: {
         key: 'timesSeen',
         name: 'Times Seen',
+        isInput: true,
+        // Below values are required or else SearchBar will attempt to get values // This is required or else SearchBar will attempt to get values
         values: [],
         predefined: true,
       },
diff --git a/src/sentry/static/sentry/app/views/stream/sidebar.jsx b/src/sentry/static/sentry/app/views/stream/sidebar.jsx
index 277b2f077f..76f96fd750 100644
--- a/src/sentry/static/sentry/app/views/stream/sidebar.jsx
+++ b/src/sentry/static/sentry/app/views/stream/sidebar.jsx
@@ -109,9 +109,10 @@ const StreamSidebar = createReactClass({
   },
 
   render() {
+    let {loading, orgId, projectId, tags} = this.props;
     return (
       <div className="stream-sidebar">
-        {this.props.loading ? (
+        {loading ? (
           <LoadingIndicator />
         ) : (
           <div>
@@ -133,15 +134,15 @@ const StreamSidebar = createReactClass({
               <hr />
             </div>
 
-            {_.map(this.props.tags, tag => {
+            {_.map(tags, tag => {
               return (
                 <StreamTagFilter
                   value={this.state.queryObj[tag.key]}
                   key={tag.key}
                   tag={tag}
                   onSelect={this.onSelectTag}
-                  orgId={this.props.orgId}
-                  projectId={this.props.projectId}
+                  orgId={orgId}
+                  projectId={projectId}
                 />
               );
             })}
diff --git a/src/sentry/static/sentry/app/views/stream/tagFilter.jsx b/src/sentry/static/sentry/app/views/stream/tagFilter.jsx
index 421e7c8de7..7b4c5b84f0 100644
--- a/src/sentry/static/sentry/app/views/stream/tagFilter.jsx
+++ b/src/sentry/static/sentry/app/views/stream/tagFilter.jsx
@@ -1,8 +1,12 @@
 import PropTypes from 'prop-types';
 import React from 'react';
-import ReactDOM from 'react-dom';
-import _ from 'lodash';
+import {debounce} from 'lodash';
 
+import {t} from 'app/locale';
+import {Client} from 'app/api';
+import SelectControl from 'app/components/forms/selectControl';
+
+// TODO(billy): Update to use SelectAutocomplete when it is ported to use react-select
 class StreamTagFilter extends React.Component {
   static propTypes = {
     tag: PropTypes.object.isRequired,
@@ -12,10 +16,10 @@ class StreamTagFilter extends React.Component {
     onSelect: PropTypes.func,
   };
 
-  static tagValueToSelect2Format = key => {
+  static tagValueToSelectFormat = ({value}) => {
     return {
-      id: key,
-      text: key,
+      value,
+      label: value,
     };
   };
 
@@ -28,103 +32,142 @@ class StreamTagFilter extends React.Component {
     super(...args);
     this.state = {
       query: '',
-      loading: false,
+      isLoading: false,
       value: this.props.value,
+      textValue: this.props.value,
     };
-  }
-
-  componentDidMount() {
-    let select = this.refs.select;
-
-    let selectOpts = {
-      placeholder: '--',
-      allowClear: true,
-    };
-
-    if (!this.props.tag.predefined) {
-      Object.assign(selectOpts, {
-        initSelection: (element, callback) => {
-          callback(StreamTagFilter.tagValueToSelect2Format(this.props.value));
-        },
-        ajax: {
-          url: this.getTagValuesAPIEndpoint(),
-          dataType: 'json',
-          delay: 250,
-          data: (term, page) => {
-            return {
-              query: term,
-            };
-          },
-          results: (data, page) => {
-            // parse the results into the format expected by Select2
-            return {
-              results: _.map(data, val =>
-                StreamTagFilter.tagValueToSelect2Format(val.value)
-              ),
-            };
-          },
-          cache: true,
-        },
-      });
-    }
-
-    $(select)
-      .select2(selectOpts)
-      .select2('val', this.state.value)
-      .on('change', this.onSelectValue);
+    this.api = new Client();
   }
 
   componentWillReceiveProps(nextProps) {
     if (nextProps.value !== this.state.value) {
-      this.setState(
-        {
-          value: nextProps.value,
-        },
-        () => {
-          let select = this.refs.select;
-          $(select).select2('val', this.state.value);
-        }
-      );
+      this.setState({
+        value: nextProps.value,
+        textValue: nextProps.value,
+      });
     }
   }
 
   componentWillUnmount() {
-    let select = ReactDOM.findDOMNode(this.refs.select);
-    $(select).select2('destroy');
+    if (!this.api) return;
+    this.api.clear();
   }
 
   getTagValuesAPIEndpoint = () => {
-    return `/api/0/projects/${this.props.orgId}/${this.props.projectId}/tags/${this.props
-      .tag.key}/values/`;
+    let {orgId, projectId, tag} = this.props;
+
+    return `/api/0/projects/${orgId}/${projectId}/tags/${tag.key}/values/`;
   };
 
-  onSelectValue = evt => {
-    let val = evt.target.value;
+  handleLoadOptions = () => {
+    let {tag} = this.props;
+    if (tag.isInput || tag.predefined) return;
+    if (!this.api) return;
+
     this.setState({
-      value: val,
+      isLoading: true,
     });
 
-    this.props.onSelect && this.props.onSelect(this.props.tag, val);
+    this.api
+      .requestPromise(this.getTagValuesAPIEndpoint(), {
+        query: {
+          query: this.state.textValue,
+        },
+      })
+      .then(resp => {
+        this.setState({
+          isLoading: false,
+          options: Object.values(resp).map(StreamTagFilter.tagValueToSelectFormat),
+        });
+      });
+  };
+
+  handleChangeInput = e => {
+    let value = e.target.value;
+    this.setState({
+      textValue: value,
+    });
+    this.debouncedTextChange(value);
+  };
+
+  debouncedTextChange = debounce(function(text) {
+    this.handleChange(text);
+  }, 150);
+
+  handleOpenMenu = () => {
+    if (this.props.tag.predefined) return;
+
+    this.setState(
+      {
+        isLoading: true,
+      },
+      this.handleLoadOptions
+    );
+  };
+
+  handleChangeSelect = valueObj => {
+    let value = valueObj ? valueObj.value : null;
+    this.handleChange(value);
+  };
+
+  handleChangeSelectInput = value => {
+    this.setState(
+      {
+        textValue: value,
+      },
+      this.handleLoadOptions
+    );
+  };
+
+  handleChange = value => {
+    let {onSelect, tag} = this.props;
+
+    this.setState(
+      {
+        value,
+      },
+      () => {
+        onSelect && onSelect(tag, value);
+      }
+    );
   };
 
   render() {
-    // NOTE: need to specify empty onChange handler on <select> - even though this
-    //       will get overridden by select2 - because React will complain with
-    //       a warning
-    let tag = this.props.tag;
+    let {tag} = this.props;
     return (
       <div className="stream-tag-filter">
         <h6 className="nav-header">{tag.key}</h6>
 
-        {this.props.tag.predefined ? (
-          <select ref="select" onChange={function() {}}>
-            <option key="empty" />
-            {this.props.tag.values.map(val => {
-              return <option key={val}>{val}</option>;
-            })}
-          </select>
-        ) : (
-          <input type="hidden" ref="select" value={this.props.value} />
+        {!!tag.isInput && (
+          <input
+            className="form-control"
+            type="text"
+            value={this.state.textValue}
+            onChange={this.handleChangeInput}
+          />
+        )}
+
+        {!tag.isInput && (
+          <SelectControl
+            filterOptions={(options, filter, currentValues) => options}
+            placeholder="--"
+            value={this.state.value}
+            onChange={this.handleChangeSelect}
+            isLoading={this.state.isLoading}
+            onInputChange={this.handleChangeSelectInput}
+            onOpen={this.handleOpenMenu}
+            autoload={false}
+            noResultsText={this.state.isLoading ? t('Loading...') : t('No results found')}
+            options={
+              tag.predefined
+                ? tag.values &&
+                  tag.values.map(value => ({
+                    value,
+                    label: value,
+                  }))
+                : this.state.options
+            }
+          />
         )}
       </div>
     );
diff --git a/tests/js/spec/views/stream/__snapshots__/stream.spec.jsx.snap b/tests/js/spec/views/stream/__snapshots__/stream.spec.jsx.snap
index b55e6f776d..4b2dfd570d 100644
--- a/tests/js/spec/views/stream/__snapshots__/stream.spec.jsx.snap
+++ b/tests/js/spec/views/stream/__snapshots__/stream.spec.jsx.snap
@@ -161,6 +161,7 @@ exports[`Stream render() displays the group list 1`] = `
           ],
         },
         "timesSeen": Object {
+          "isInput": true,
           "key": "timesSeen",
           "name": "Times Seen",
           "predefined": true,
@@ -333,6 +334,7 @@ exports[`Stream toggles environment select all environments 1`] = `
           ],
         },
         "timesSeen": Object {
+          "isInput": true,
           "key": "timesSeen",
           "name": "Times Seen",
           "predefined": true,
diff --git a/tests/js/spec/views/stream/searchBar.spec.jsx b/tests/js/spec/views/stream/searchBar.spec.jsx
index 4f6eef316a..3930fc745c 100644
--- a/tests/js/spec/views/stream/searchBar.spec.jsx
+++ b/tests/js/spec/views/stream/searchBar.spec.jsx
@@ -282,5 +282,22 @@ describe('SearchBar', function() {
       clock.tick(301);
       expect(environmentTagValuesMock).not.toHaveBeenCalled();
     });
+
+    it('does not request values when tag is `timesSeen`', function() {
+      // This should never get called
+      let mock = MockApiClient.addMockResponse({
+        url: '/projects/123/456/tags/timesSeen/values/',
+        body: [],
+      });
+      let props = {
+        orgId: '123',
+        projectId: '456',
+        query: 'timesSeen:',
+      };
+      let searchBar = mount(<SearchBar {...props} />, options).instance();
+      searchBar.updateAutoCompleteItems();
+      clock.tick(301);
+      expect(mock).not.toHaveBeenCalled();
+    });
   });
 });
diff --git a/tests/js/spec/views/stream/tagFilter.spec.jsx b/tests/js/spec/views/stream/tagFilter.spec.jsx
new file mode 100644
index 0000000000..d2f809daf2
--- /dev/null
+++ b/tests/js/spec/views/stream/tagFilter.spec.jsx
@@ -0,0 +1,56 @@
+import React from 'react';
+
+import {mount} from 'enzyme';
+import StreamTagFilter from 'app/views/stream/tagFilter';
+
+describe('Stream TagFilter', function() {
+  let apiMock;
+
+  let organization;
+  let project;
+
+  beforeEach(function() {
+    MockApiClient.clearMockResponses();
+    organization = TestStubs.Organization();
+    project = TestStubs.ProjectDetails();
+    apiMock = MockApiClient.addMockResponse({
+      url: `/api/0/projects/${organization.slug}/${project.slug}/tags/browser/values/`,
+      body: [
+        {
+          count: 0,
+          firstSeen: '2018-05-30T11:33:46.535Z',
+          key: 'browser',
+          lastSeen: '2018-05-30T11:33:46.535Z',
+          name: 'foo',
+          value: 'foo',
+        },
+      ],
+    });
+  });
+
+  it('calls API and renders options when opened', async function() {
+    let selectMock = jest.fn();
+    let tag = {key: 'browser', name: 'Browser'};
+    let wrapper = mount(
+      <StreamTagFilter
+        tag={tag}
+        orgId={organization.slug}
+        projectId={project.slug}
+        value=""
+        onSelect={selectMock}
+      />
+    );
+
+    wrapper.find('input').simulate('focus');
+    wrapper.find('.Select-control').simulate('mouseDown', {button: 0});
+
+    await tick();
+    wrapper.update();
+
+    expect(apiMock).toHaveBeenCalled();
+    expect(wrapper.find('div.Select-option').prop('children')).toBe('foo');
+
+    wrapper.find('Option').simulate('mouseDown');
+    expect(selectMock).toHaveBeenCalledWith(tag, 'foo');
+  });
+});

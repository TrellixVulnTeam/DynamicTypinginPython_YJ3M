commit a51ffed9bba7498592d21b186ef5d379b6d075b0
Author: Brett Hoerner <brett@bretthoerner.com>
Date:   Tue Dec 18 10:17:26 2018 -0600

    ref(store): Use a single ClientApiHelper class (#11043)
    
    * ref(store): Use a single ClientApiHelper class
    
    This breaks out the stateless auth-related methods into new *AuthHelper
    classes, so that every store endpoint can use the same ClientApiHelper
    class, removing the need for us to pass around an `event_type`.
    
    * Switch to abc for AuthHelpers.

diff --git a/src/sentry/coreapi.py b/src/sentry/coreapi.py
index 5f032994aa..88f142b50e 100644
--- a/src/sentry/coreapi.py
+++ b/src/sentry/coreapi.py
@@ -10,6 +10,7 @@ sentry.coreapi
 #       metadata (rather than generic log messages which aren't useful).
 from __future__ import absolute_import, print_function
 
+import abc
 import base64
 import logging
 import re
@@ -116,39 +117,6 @@ class ClientApiHelper(object):
             ip_address=ip_address,
         )
 
-    def auth_from_request(self, request):
-        result = {k: request.GET[k] for k in six.iterkeys(
-            request.GET) if k[:7] == 'sentry_'}
-
-        if request.META.get('HTTP_X_SENTRY_AUTH', '')[:7].lower() == 'sentry ':
-            if result:
-                raise SuspiciousOperation(
-                    'Multiple authentication payloads were detected.')
-            result = parse_auth_header(request.META['HTTP_X_SENTRY_AUTH'])
-        elif request.META.get('HTTP_AUTHORIZATION', '')[:7].lower() == 'sentry ':
-            if result:
-                raise SuspiciousOperation(
-                    'Multiple authentication payloads were detected.')
-            result = parse_auth_header(request.META['HTTP_AUTHORIZATION'])
-
-        if not result:
-            raise APIUnauthorized('Unable to find authentication information')
-
-        origin = self.origin_from_request(request)
-        auth = Auth(result, is_public=bool(origin))
-        # default client to user agent
-        if not auth.client:
-            auth.client = request.META.get('HTTP_USER_AGENT')
-        return auth
-
-    def origin_from_request(self, request):
-        """
-        Returns either the Origin or Referer value from the request headers.
-        """
-        if request.META.get('HTTP_ORIGIN') == 'null':
-            return 'null'
-        return origin_from_request(request)
-
     def project_key_from_auth(self, auth):
         if not auth.public_key:
             raise APIUnauthorized('Invalid api key')
@@ -215,12 +183,62 @@ class ClientApiHelper(object):
                    event_id=data['event_id'])
 
 
-class MinidumpApiHelper(ClientApiHelper):
-    def origin_from_request(self, request):
+@six.add_metaclass(abc.ABCMeta)
+class AbstractAuthHelper(object):
+    @abc.abstractmethod
+    def auth_from_request(cls, request):
+        pass
+
+    @abc.abstractmethod
+    def origin_from_request(cls, request):
+        pass
+
+
+class ClientAuthHelper(AbstractAuthHelper):
+    @classmethod
+    def auth_from_request(cls, request):
+        result = {k: request.GET[k] for k in six.iterkeys(
+            request.GET) if k[:7] == 'sentry_'}
+
+        if request.META.get('HTTP_X_SENTRY_AUTH', '')[:7].lower() == 'sentry ':
+            if result:
+                raise SuspiciousOperation(
+                    'Multiple authentication payloads were detected.')
+            result = parse_auth_header(request.META['HTTP_X_SENTRY_AUTH'])
+        elif request.META.get('HTTP_AUTHORIZATION', '')[:7].lower() == 'sentry ':
+            if result:
+                raise SuspiciousOperation(
+                    'Multiple authentication payloads were detected.')
+            result = parse_auth_header(request.META['HTTP_AUTHORIZATION'])
+
+        if not result:
+            raise APIUnauthorized('Unable to find authentication information')
+
+        origin = cls.origin_from_request(request)
+        auth = Auth(result, is_public=bool(origin))
+        # default client to user agent
+        if not auth.client:
+            auth.client = request.META.get('HTTP_USER_AGENT')
+        return auth
+
+    @classmethod
+    def origin_from_request(cls, request):
+        """
+        Returns either the Origin or Referer value from the request headers.
+        """
+        if request.META.get('HTTP_ORIGIN') == 'null':
+            return 'null'
+        return origin_from_request(request)
+
+
+class MinidumpAuthHelper(AbstractAuthHelper):
+    @classmethod
+    def origin_from_request(cls, request):
         # We don't use an origin here
         return None
 
-    def auth_from_request(self, request):
+    @classmethod
+    def auth_from_request(cls, request):
         key = request.GET.get('sentry_key')
         if not key:
             raise APIUnauthorized('Unable to find authentication information')
@@ -233,17 +251,16 @@ class MinidumpApiHelper(ClientApiHelper):
         return auth
 
 
-class SecurityApiHelper(ClientApiHelper):
-
-    report_interfaces = ('csp', 'hpkp', 'expectct', 'expectstaple')
-
-    def origin_from_request(self, request):
+class SecurityAuthHelper(AbstractAuthHelper):
+    @classmethod
+    def origin_from_request(cls, request):
         # In the case of security reports, the origin is not available at the
         # dispatch() stage, as we need to parse it out of the request body, so
         # we do our own CORS check once we have parsed it.
         return None
 
-    def auth_from_request(self, request):
+    @classmethod
+    def auth_from_request(cls, request):
         key = request.GET.get('sentry_key')
         if not key:
             raise APIUnauthorized('Unable to find authentication information')
diff --git a/src/sentry/event_consumer.py b/src/sentry/event_consumer.py
index 2a03ef2f57..67075cbe4d 100644
--- a/src/sentry/event_consumer.py
+++ b/src/sentry/event_consumer.py
@@ -1,24 +1,21 @@
 from __future__ import absolute_import, print_function
 
-from sentry.coreapi import Auth
+from sentry.coreapi import Auth, ClientApiHelper
 from sentry.event_manager import EventManager
-from sentry.web.api import process_event, type_name_to_view
+from sentry.models import Project
+from sentry.web.api import process_event
 
 
 def process_event_from_kafka(message):
-    from sentry.models import Project
-
     project = Project.objects.get_from_cache(pk=message['project_id'])
 
-    event_type = message['type']
-    view = type_name_to_view[event_type]
-    helper_cls = view.helper_cls
     remote_addr = message['remote_addr']
-    helper = helper_cls(
+    helper = ClientApiHelper(
         agent=message['agent'],
         project_id=project.id,
         ip_address=remote_addr,
     )
+    helper.context.bind_project(project)
 
     auth = Auth(message['auth'], message['auth'].pop('is_public'))
     helper.context.bind_auth(auth)
@@ -39,5 +36,5 @@ def process_event_from_kafka(message):
     event_manager._normalized = True
     del data
 
-    return process_event(event_type, event_manager, project, key,
+    return process_event(event_manager, project, key,
                          remote_addr, helper, attachments=None)
diff --git a/src/sentry/web/api.py b/src/sentry/web/api.py
index 0647355db4..b99ba89f23 100644
--- a/src/sentry/web/api.py
+++ b/src/sentry/web/api.py
@@ -31,7 +31,8 @@ from symbolic import ProcessMinidumpError, Unreal4Error
 from sentry import features, quotas, tsdb, options
 from sentry.attachments import CachedAttachment
 from sentry.coreapi import (
-    Auth, APIError, APIForbidden, APIRateLimited, ClientApiHelper, SecurityApiHelper, MinidumpApiHelper, safely_load_json_string, logger as api_logger
+    Auth, APIError, APIForbidden, APIRateLimited, ClientApiHelper, ClientAuthHelper,
+    SecurityAuthHelper, MinidumpAuthHelper, safely_load_json_string, logger as api_logger
 )
 from sentry.event_manager import EventManager
 from sentry.interfaces import schemas
@@ -91,10 +92,8 @@ def api(func):
     return wrapped
 
 
-def process_event(event_type, event_manager, project, key, remote_addr, helper, attachments):
-    sender = type_name_to_view[event_type]
-
-    event_received.send_robust(ip=remote_addr, project=project, sender=sender)
+def process_event(event_manager, project, key, remote_addr, helper, attachments):
+    event_received.send_robust(ip=remote_addr, project=project, sender=process_event)
 
     start_time = time()
     tsdb_start_time = to_datetime(start_time)
@@ -128,7 +127,7 @@ def process_event(event_type, event_manager, project, key, remote_addr, helper,
         event_filtered.send_robust(
             ip=remote_addr,
             project=project,
-            sender=sender,
+            sender=process_event,
         )
         raise APIForbidden('Event dropped due to filter: %s' % (filter_reason,))
 
@@ -167,7 +166,7 @@ def process_event(event_type, event_manager, project, key, remote_addr, helper,
             ip=remote_addr,
             project=project,
             reason_code=rate_limit.reason_code if rate_limit else None,
-            sender=sender,
+            sender=process_event,
         )
         if rate_limit is not None:
             raise APIRateLimited(rate_limit.retry_after)
@@ -241,14 +240,14 @@ def process_event(event_type, event_manager, project, key, remote_addr, helper,
         ip=remote_addr,
         data=data,
         project=project,
-        sender=sender,
+        sender=process_event,
     )
 
     return event_id
 
 
 class APIView(BaseView):
-    helper_cls = ClientApiHelper
+    auth_helper_cls = ClientAuthHelper
 
     def _get_project_from_id(self, project_id):
         if not project_id:
@@ -261,7 +260,7 @@ class APIView(BaseView):
             raise APIError('Invalid project_id: %r' % project_id)
 
     def _parse_header(self, request, helper, project):
-        auth = helper.auth_from_request(request)
+        auth = self.auth_helper_cls.auth_from_request(request)
 
         if auth.version not in PROTOCOL_VERSIONS:
             raise APIError(
@@ -310,7 +309,7 @@ class APIView(BaseView):
     @csrf_exempt
     @never_cache
     def dispatch(self, request, project_id=None, *args, **kwargs):
-        helper = self.helper_cls(
+        helper = ClientApiHelper(
             agent=request.META.get('HTTP_USER_AGENT'),
             project_id=project_id,
             ip_address=request.META['REMOTE_ADDR'],
@@ -321,7 +320,7 @@ class APIView(BaseView):
             self._publish_to_kafka(request)
 
         try:
-            origin = helper.origin_from_request(request)
+            origin = self.auth_helper_cls.origin_from_request(request)
 
             response = self._dispatch(
                 request, helper, project_id=project_id, origin=origin, *args, **kwargs
@@ -550,7 +549,7 @@ class StoreView(APIView):
         self.pre_normalize(event_manager, helper)
         event_manager.normalize()
 
-        event_type = type(self).type_name
+        agent = request.META.get('HTTP_USER_AGENT')
 
         # TODO: Some form of coordination between the Kafka consumer
         # and this method (the 'relay') to decide whether a 429 should
@@ -579,8 +578,7 @@ class StoreView(APIView):
                             'is_public': auth.is_public,
                         },
                         'remote_addr': remote_addr,
-                        'agent': request.META.get('HTTP_USER_AGENT'),
-                        'type': event_type,
+                        'agent': agent,
                         # Whether or not the Kafka consumer is in charge
                         # of actually processing this event.
                         'should_process': process_in_kafka,
@@ -595,13 +593,12 @@ class StoreView(APIView):
                     return event_manager.get_data()['event_id']
 
         # Everything after this will eventually be done in a Kafka consumer.
-        return process_event(event_type, event_manager, project,
+        return process_event(event_manager, project,
                              key, remote_addr, helper, attachments)
 
 
 class MinidumpView(StoreView):
-    type_name = 'minidump'
-    helper_cls = MinidumpApiHelper
+    auth_helper_cls = MinidumpAuthHelper
     content_types = ('multipart/form-data', )
 
     def _dispatch(self, request, helper, project_id=None, origin=None, *args, **kwargs):
@@ -629,7 +626,7 @@ class MinidumpView(StoreView):
         # This is yanking the auth from the querystring since it's not
         # in the POST body. This means we expect a `sentry_key` and
         # `sentry_version` to be set in querystring
-        auth = helper.auth_from_request(request)
+        auth = self.auth_helper_cls.auth_from_request(request)
 
         key = helper.project_key_from_auth(auth)
         if key.project_id != project.id:
@@ -768,7 +765,6 @@ class MinidumpView(StoreView):
 
 # Endpoint used by the Unreal Engine 4 (UE4) Crash Reporter.
 class UnrealView(StoreView):
-    type_name = 'unreal'
     content_types = ('application/octet-stream', )
 
     def _dispatch(self, request, helper, sentry_key, project_id=None, origin=None, *args, **kwargs):
@@ -867,8 +863,7 @@ class StoreSchemaView(BaseView):
 
 
 class SecurityReportView(StoreView):
-    type_name = 'security'
-    helper_cls = SecurityApiHelper
+    auth_helper_cls = SecurityAuthHelper
     content_types = (
         'application/csp-report',
         'application/json',
@@ -898,7 +893,7 @@ class SecurityReportView(StoreView):
         # This is yanking the auth from the querystring since it's not
         # in the POST body. This means we expect a `sentry_key` and
         # `sentry_version` to be set in querystring
-        auth = helper.auth_from_request(request)
+        auth = self.auth_helper_cls.auth_from_request(request)
 
         key = helper.project_key_from_auth(auth)
         if key.project_id != project.id:
@@ -981,10 +976,3 @@ def crossdomain_xml(request, project_id):
     response['Content-Type'] = 'application/xml'
 
     return response
-
-
-type_name_to_view = {
-    v.type_name: v for v in [
-        StoreView, SecurityReportView, UnrealView, MinidumpView
-    ]
-}
diff --git a/tests/sentry/coreapi/test_auth_from_request.py b/tests/sentry/coreapi/test_auth_from_request.py
index 5ccbaaf37e..01ac7d8f08 100644
--- a/tests/sentry/coreapi/test_auth_from_request.py
+++ b/tests/sentry/coreapi/test_auth_from_request.py
@@ -5,11 +5,11 @@ import pytest
 
 from django.core.exceptions import SuspiciousOperation
 
-from sentry.coreapi import ClientApiHelper, APIUnauthorized
+from sentry.coreapi import ClientAuthHelper, APIUnauthorized
 
 
 def test_valid():
-    helper = ClientApiHelper()
+    helper = ClientAuthHelper()
     request = mock.Mock()
     request.META = {'HTTP_X_SENTRY_AUTH': 'Sentry sentry_key=value, biz=baz'}
     request.GET = {}
@@ -18,7 +18,7 @@ def test_valid():
 
 
 def test_valid_missing_space():
-    helper = ClientApiHelper()
+    helper = ClientAuthHelper()
     request = mock.Mock()
     request.META = {'HTTP_X_SENTRY_AUTH': 'Sentry sentry_key=value,biz=baz'}
     request.GET = {}
@@ -27,7 +27,7 @@ def test_valid_missing_space():
 
 
 def test_valid_ignore_case():
-    helper = ClientApiHelper()
+    helper = ClientAuthHelper()
     request = mock.Mock()
     request.META = {'HTTP_X_SENTRY_AUTH': 'SeNtRy sentry_key=value, biz=baz'}
     request.GET = {}
@@ -36,7 +36,7 @@ def test_valid_ignore_case():
 
 
 def test_invalid_header_defers_to_GET():
-    helper = ClientApiHelper()
+    helper = ClientAuthHelper()
     request = mock.Mock()
     request.META = {'HTTP_X_SENTRY_AUTH': 'foobar'}
     request.GET = {'sentry_version': '1', 'foo': 'bar'}
@@ -45,7 +45,7 @@ def test_invalid_header_defers_to_GET():
 
 
 def test_invalid_legacy_header_defers_to_GET():
-    helper = ClientApiHelper()
+    helper = ClientAuthHelper()
     request = mock.Mock()
     request.META = {'HTTP_AUTHORIZATION': 'foobar'}
     request.GET = {'sentry_version': '1', 'foo': 'bar'}
@@ -54,7 +54,7 @@ def test_invalid_legacy_header_defers_to_GET():
 
 
 def test_invalid_header_bad_token():
-    helper = ClientApiHelper()
+    helper = ClientAuthHelper()
     request = mock.Mock()
     request.META = {'HTTP_X_SENTRY_AUTH': 'Sentryfoo'}
     request.GET = {}
@@ -63,7 +63,7 @@ def test_invalid_header_bad_token():
 
 
 def test_invalid_header_missing_pair():
-    helper = ClientApiHelper()
+    helper = ClientAuthHelper()
     request = mock.Mock()
     request.META = {'HTTP_X_SENTRY_AUTH': 'Sentry foo'}
     request.GET = {}
@@ -72,7 +72,7 @@ def test_invalid_header_missing_pair():
 
 
 def test_invalid_malformed_value():
-    helper = ClientApiHelper()
+    helper = ClientAuthHelper()
     request = mock.Mock()
     request.META = {'HTTP_X_SENTRY_AUTH': 'Sentry sentry_key=value,,biz=baz'}
     request.GET = {}
@@ -81,7 +81,7 @@ def test_invalid_malformed_value():
 
 
 def test_multiple_auth_suspicious():
-    helper = ClientApiHelper()
+    helper = ClientAuthHelper()
     request = mock.Mock()
     request.GET = {'sentry_version': '1', 'foo': 'bar'}
     request.META = {'HTTP_X_SENTRY_AUTH': 'Sentry sentry_key=value, biz=baz'}
diff --git a/tests/sentry/coreapi/test_coreapi.py b/tests/sentry/coreapi/test_coreapi.py
index 67a66c908e..6195bf2228 100644
--- a/tests/sentry/coreapi/test_coreapi.py
+++ b/tests/sentry/coreapi/test_coreapi.py
@@ -10,6 +10,7 @@ from sentry.coreapi import (
     APIUnauthorized,
     Auth,
     ClientApiHelper,
+    ClientAuthHelper,
     decode_data,
     safely_load_json_string
 )
@@ -18,14 +19,14 @@ from sentry.testutils import TestCase
 
 
 class BaseAPITest(TestCase):
-    helper_cls = ClientApiHelper
+    auth_helper_cls = ClientAuthHelper
 
     def setUp(self):
         self.user = self.create_user('coreapi@example.com')
         self.team = self.create_team(name='Foo')
         self.project = self.create_project(teams=[self.team])
         self.pk = self.project.key_set.get_or_create()[0]
-        self.helper = self.helper_cls(agent='Awesome Browser', ip_address='198.51.100.0')
+        self.helper = ClientApiHelper(agent='Awesome Browser', ip_address='198.51.100.0')
 
 
 class ProjectIdFromAuthTest(BaseAPITest):

commit c91a752d7d17b08fe9c131aca9bc47bd07970749
Author: Evan Purkhiser <evanpurkhiser@gmail.com>
Date:   Wed Sep 13 14:24:16 2017 -0700

    Implement RetryingStrictRedisCluster
    
    Re-initializes the cluster upon failure

diff --git a/src/sentry/utils/redis.py b/src/sentry/utils/redis.py
index 3479e3df57..a9bf4d37d5 100644
--- a/src/sentry/utils/redis.py
+++ b/src/sentry/utils/redis.py
@@ -8,10 +8,12 @@ import six
 from threading import Lock
 
 import rb
-import rediscluster
 from pkg_resources import resource_string
 from redis.client import Script
 from redis.connection import ConnectionPool
+from redis.exceptions import ConnectionError, BusyLoadingError
+from rediscluster.exceptions import RedisClusterException
+from rediscluster import StrictRedisCluster
 
 from sentry import options
 from sentry.exceptions import InvalidConfiguration
@@ -74,6 +76,23 @@ class _RBCluster(object):
         return 'Redis Blaster Cluster'
 
 
+class RetryingStrictRedisCluster(StrictRedisCluster):
+    """
+    Execute a command with cluster reinitialization retry logic.
+
+    Should a cluster respond with a ConnectionError or BusyLoadingError the
+    cluster nodes list will be reinitialized and the command will be executed
+    again with the most up to date view of the world.
+    """
+
+    def execute_command(self, *args, **kwargs):
+        try:
+            return super(self.__class__, self).execute_command(*args, **kwargs)
+        except (ConnectionError, BusyLoadingError):
+            self.connection_pool.nodes.reset()
+            return super(self.__class__, self).execute_command(*args, **kwargs)
+
+
 class _RedisCluster(object):
     def supports(self, config):
         return config.get('is_redis_cluster', False)
@@ -87,8 +106,8 @@ class _RedisCluster(object):
         # Redis cluster does not wait to attempt to connect, we don't want the
         # application to fail to boot because of this, raise a KeyError
         try:
-            return rediscluster.StrictRedisCluster(startup_nodes=hosts, decode_responses=True)
-        except rediscluster.exceptions.RedisClusterException:
+            return RetryingStrictRedisCluster(startup_nodes=hosts, decode_responses=True)
+        except RedisClusterException:
             logger.warning('Failed to connect to Redis Cluster', exc_info=True)
             raise KeyError('Redis Cluster could not be initalized')
 
diff --git a/tests/sentry/utils/test_redis.py b/tests/sentry/utils/test_redis.py
index e96f967843..75b821d3f9 100644
--- a/tests/sentry/utils/test_redis.py
+++ b/tests/sentry/utils/test_redis.py
@@ -47,7 +47,7 @@ make_manager = functools.partial(
     },
 )
 
-redis_cluster_exception = RedisClusterException('Failed to connect')
+rc_exception = RedisClusterException('Failed to connect')
 
 
 class ClusterManagerTestCase(TestCase):
@@ -59,14 +59,14 @@ class ClusterManagerTestCase(TestCase):
         with pytest.raises(KeyError):
             manager.get('invalid')
 
-    @mock.patch('rediscluster.StrictRedisCluster')
+    @mock.patch('sentry.utils.redis.RetryingStrictRedisCluster')
     def test_specific_cluster(self, cluster):
         manager = make_manager(cluster_type=_RedisCluster)
         assert manager.get('baz') is cluster.return_value
         with pytest.raises(KeyError):
             manager.get('foo')
 
-    @mock.patch('rediscluster.StrictRedisCluster', side_effect=redis_cluster_exception)
+    @mock.patch('sentry.utils.redis.RetryingStrictRedisCluster', side_effect=rc_exception)
     def test_failed_redis_cluster(self, cluster):
         manager = make_manager(cluster_type=_RedisCluster)
         with pytest.raises(KeyError):

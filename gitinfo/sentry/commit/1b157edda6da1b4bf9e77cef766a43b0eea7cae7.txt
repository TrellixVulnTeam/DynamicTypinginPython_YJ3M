commit 1b157edda6da1b4bf9e77cef766a43b0eea7cae7
Author: Mark Story <mark@sentry.io>
Date:   Mon Dec 9 17:03:44 2019 -0800

    feat(discover) Add get_pagination_ids API to discover module (#15993)
    
    Currently this new interface is just wrapping evenstore. However, once
    it is used in the required endpoints I'd like to deprecate the
    eventstore methods as if eventstore is going to be focused on getting
    event objects the pagination id methods aren't a great fit.

diff --git a/src/sentry/snuba/discover.py b/src/sentry/snuba/discover.py
index 0ce8068ad4..a000139ddf 100644
--- a/src/sentry/snuba/discover.py
+++ b/src/sentry/snuba/discover.py
@@ -6,6 +6,7 @@ from collections import namedtuple
 from copy import deepcopy
 
 from sentry.api.event_search import TAG_KEY_RE, get_filter, resolve_field_list, InvalidSearchQuery
+from sentry import eventstore
 from sentry.models import Project, ProjectStatus
 from sentry.snuba.events import get_columns_from_aliases
 from sentry.utils.snuba import (
@@ -19,7 +20,19 @@ from sentry.utils.snuba import (
     zerofill,
 )
 
+__all__ = (
+    "ReferenceEvent",
+    "PaginationResult",
+    "InvalidSearchQuery",
+    "create_reference_event_conditions",
+    "query",
+    "timeseries_query",
+    "get_pagination_ids",
+)
+
+
 ReferenceEvent = namedtuple("ReferenceEvent", ["organization", "slug", "fields"])
+PaginationResult = namedtuple("PaginationResult", ["next", "previous", "oldest", "latest"])
 
 
 def find_reference_event(reference_event):
@@ -322,11 +335,35 @@ def timeseries_query(selected_columns, query, params, rollup, reference_event=No
     return SnubaTSResult(result, snuba_filter.start, snuba_filter.end, rollup)
 
 
-def get_pagination_ids(event, query, params):
+def get_id(result):
+    if result:
+        return result[1]
+
+
+def get_pagination_ids(event, query, params, reference_event=None, referrer=None):
     """
     High-level API for getting pagination data for an event + filter
 
     The provided event is used as a reference event to find events
     that are older and newer than the current one.
+
+    event (Event) The event to find related events for.
+    query (str) Filter query string to create conditions from.
+    params (Dict[str, str]) Filtering parameters with start, end, project_id, environment,
+    reference_event (ReferenceEvent) A reference event object. Used to generate additional
+                                    conditions based on the provided reference.
+    referrer (str|None) A referrer string to help locate the origin of this query.
     """
-    raise NotImplementedError
+    snuba_filter = get_filter(query, params)
+
+    if reference_event:
+        ref_conditions = create_reference_event_conditions(reference_event)
+        if ref_conditions:
+            snuba_filter.conditions.extend(ref_conditions)
+
+    return PaginationResult(
+        next=get_id(eventstore.get_next_event_id(event, filter=snuba_filter)),
+        previous=get_id(eventstore.get_prev_event_id(event, filter=snuba_filter)),
+        latest=get_id(eventstore.get_latest_event_id(event, filter=snuba_filter)),
+        oldest=get_id(eventstore.get_earliest_event_id(event, filter=snuba_filter)),
+    )
diff --git a/tests/sentry/snuba/test_discover.py b/tests/sentry/snuba/test_discover.py
index 175ff00307..1a3509f88f 100644
--- a/tests/sentry/snuba/test_discover.py
+++ b/tests/sentry/snuba/test_discover.py
@@ -1,5 +1,6 @@
 from __future__ import absolute_import
 
+from sentry import eventstore
 from sentry.api.event_search import InvalidSearchQuery
 from sentry.snuba import discover
 from sentry.testutils import TestCase, SnubaTestCase
@@ -753,5 +754,125 @@ class CreateReferenceEventConditionsTest(SnubaTestCase, TestCase):
         assert result == [["issue.id", "=", event.group_id]]
 
 
-class GetPaginationIdsTest(TestCase):
-    pass
+class GetPaginationIdsTest(SnubaTestCase, TestCase):
+    def setUp(self):
+        super(GetPaginationIdsTest, self).setUp()
+
+        self.project = self.create_project()
+        self.min_ago = before_now(minutes=1)
+        self.day_ago = before_now(days=1)
+
+        self.store_event(
+            data={
+                "event_id": "a" * 32,
+                "message": "very bad",
+                "type": "default",
+                "platform": "python",
+                "timestamp": iso_format(before_now(minutes=4)),
+                "tags": {"foo": "1"},
+            },
+            project_id=self.project.id,
+        )
+        self.store_event(
+            data={
+                "event_id": "b" * 32,
+                "message": "very bad",
+                "type": "default",
+                "platform": "python",
+                "timestamp": iso_format(before_now(minutes=3)),
+                "tags": {"foo": "1"},
+            },
+            project_id=self.project.id,
+        )
+        self.store_event(
+            data={
+                "event_id": "c" * 32,
+                "message": "very bad",
+                "type": "default",
+                "platform": "python",
+                "timestamp": iso_format(before_now(minutes=2)),
+                "tags": {"foo": "1"},
+            },
+            project_id=self.project.id,
+        )
+        self.event = eventstore.get_event_by_id(self.project.id, "b" * 32)
+
+    def test_no_related_events(self):
+        result = discover.get_pagination_ids(
+            self.event,
+            "foo:bar",
+            {"project_id": [self.project.id], "start": self.min_ago, "end": self.day_ago},
+        )
+        assert result.previous is None
+        assert result.next is None
+        assert result.oldest is None
+        assert result.latest is None
+
+    def test_invalid_conditions(self):
+        with pytest.raises(InvalidSearchQuery):
+            discover.get_pagination_ids(
+                self.event,
+                "foo:(11",
+                {"project_id": [self.project.id], "end": self.min_ago, "start": self.day_ago},
+            )
+
+    def test_matching_conditions(self):
+        result = discover.get_pagination_ids(
+            self.event,
+            "foo:1",
+            {"project_id": [self.project.id], "end": self.min_ago, "start": self.day_ago},
+        )
+        assert result.previous == "a" * 32
+        assert result.next == "c" * 32
+        assert result.oldest == "a" * 32
+        assert result.latest == "c" * 32
+
+    def test_reference_event_matching(self):
+        # Create an event that won't match the reference
+        self.store_event(
+            data={
+                "event_id": "d" * 32,
+                "message": "completely bad",
+                "type": "default",
+                "platform": "python",
+                "timestamp": iso_format(before_now(minutes=2)),
+                "tags": {"foo": "1"},
+            },
+            project_id=self.project.id,
+        )
+        reference = discover.ReferenceEvent(
+            self.organization, "{}:{}".format(self.project.slug, self.event.id), ["message"]
+        )
+        result = discover.get_pagination_ids(
+            self.event,
+            "foo:1",
+            {"project_id": [self.project.id], "end": self.min_ago, "start": self.day_ago},
+            reference_event=reference,
+        )
+        assert result.previous == "a" * 32
+        assert result.next == "c" * 32
+        assert result.oldest == "a" * 32
+        assert result.latest == "c" * 32
+
+    def test_date_params_included(self):
+        # Create an event that is outside the date range
+        self.store_event(
+            data={
+                "event_id": "d" * 32,
+                "message": "very bad",
+                "type": "default",
+                "platform": "python",
+                "timestamp": iso_format(before_now(days=2)),
+                "tags": {"foo": "1"},
+            },
+            project_id=self.project.id,
+        )
+        result = discover.get_pagination_ids(
+            self.event,
+            "foo:1",
+            {"project_id": [self.project.id], "end": self.min_ago, "start": self.day_ago},
+        )
+        assert result.previous == "a" * 32
+        assert result.next == "c" * 32
+        assert result.oldest == "a" * 32
+        assert result.latest == "c" * 32

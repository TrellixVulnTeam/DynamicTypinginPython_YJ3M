commit 1b87b927d420008aea48a8dd331dd86ecfb59f1c
Author: Chris Fuller <cfuller@sentry.io>
Date:   Mon Apr 13 17:48:40 2020 -0400

    feat(workflow): Snapshot AlertRule on update if attached alert exists (#18154)

diff --git a/src/sentry/incidents/logic.py b/src/sentry/incidents/logic.py
index ffceedf500..00adce3997 100644
--- a/src/sentry/incidents/logic.py
+++ b/src/sentry/incidents/logic.py
@@ -1,6 +1,7 @@
 from __future__ import absolute_import
 
 from collections import defaultdict
+from copy import deepcopy
 from datetime import timedelta
 
 import six
@@ -563,6 +564,30 @@ def create_alert_rule(
     return alert_rule
 
 
+def snapshot_alert_rule(alert_rule):
+    # Creates an archived alert_rule using the same properties as the passed rule
+    # It will also resolve any incidents attached to this rule.
+    with transaction.atomic():
+        triggers = AlertRuleTrigger.objects.filter(alert_rule=alert_rule)
+        incidents = Incident.objects.filter(alert_rule=alert_rule)
+        alert_rule_snapshot = deepcopy(alert_rule)
+        alert_rule_snapshot.id = None
+        alert_rule_snapshot.status = AlertRuleStatus.SNAPSHOT.value
+        alert_rule_snapshot.save()
+
+        incidents.update(alert_rule=alert_rule_snapshot, status=IncidentStatus.CLOSED.value)
+
+        for trigger in triggers:
+            actions = AlertRuleTriggerAction.objects.filter(alert_rule_trigger=trigger)
+            trigger.id = None
+            trigger.alert_rule = alert_rule_snapshot
+            trigger.save()
+            for action in actions:
+                action.id = None
+                action.alert_rule_trigger = trigger
+                action.save()
+
+
 def update_alert_rule(
     alert_rule,
     projects=None,
@@ -618,7 +643,12 @@ def update_alert_rule(
         updated_fields["include_all_projects"] = include_all_projects
 
     with transaction.atomic():
+        incidents = Incident.objects.filter(alert_rule=alert_rule).exists()
+        if incidents:
+            snapshot_alert_rule(alert_rule)
+
         alert_rule.update(**updated_fields)
+
         existing_subs = []
         if (
             query is not None
diff --git a/src/sentry/incidents/models.py b/src/sentry/incidents/models.py
index c20a562002..f2af9cb6c2 100644
--- a/src/sentry/incidents/models.py
+++ b/src/sentry/incidents/models.py
@@ -401,6 +401,8 @@ class AlertRule(Model):
     class Meta:
         app_label = "sentry"
         db_table = "sentry_alertrule"
+        base_manager_name = "objects_with_snapshots"
+        default_manager_name = "objects_with_snapshots"
         # This constraint does not match what is in migration 0061, since there is no
         # way to declare an index on an expression. Therefore, tests would break depending
         # on whether we run migrations - to work around this, we skip some tests if
diff --git a/tests/sentry/incidents/test_logic.py b/tests/sentry/incidents/test_logic.py
index 572b7eda25..7b9141fbdc 100644
--- a/tests/sentry/incidents/test_logic.py
+++ b/tests/sentry/incidents/test_logic.py
@@ -1,5 +1,4 @@
 from __future__ import absolute_import
-
 import json
 import pytest
 from uuid import uuid4
@@ -767,7 +766,7 @@ class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
 
         updated_projects = [self.project, self.create_project(fire_project_created=True)]
 
-        update_alert_rule(
+        updated_rule = update_alert_rule(
             self.alert_rule,
             projects=updated_projects,
             name=name,
@@ -776,6 +775,7 @@ class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
             time_window=time_window,
             threshold_period=threshold_period,
         )
+        assert self.alert_rule.id == updated_rule.id
         assert self.alert_rule.name == name
         updated_subscriptions = self.alert_rule.query_subscriptions.all()
         assert set([sub.project for sub in updated_subscriptions]) == set(updated_projects)
@@ -910,6 +910,82 @@ class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
             sub.project for sub in QuerySubscription.objects.filter(alert_rules=alert_rule)
         ] == [new_project]
 
+    def test_with_attached_incident(self):
+        # A snapshot of the pre-updated rule should be created, and the incidents should also be resolved.
+        incident = self.create_incident()
+        incident.update(alert_rule=self.alert_rule)
+        incident_2 = self.create_incident()
+        incident_2.update(alert_rule=self.alert_rule)
+
+        # Give the rule some actions and triggers so we can verify they've been snapshotted correctly.
+        trigger = create_alert_rule_trigger(
+            self.alert_rule, "hello", AlertRuleThresholdType.ABOVE, 1000, 400
+        )
+        action = create_alert_rule_trigger_action(
+            trigger,
+            AlertRuleTriggerAction.Type.EMAIL,
+            AlertRuleTriggerAction.TargetType.USER,
+            target_identifier=six.text_type(self.user.id),
+        )
+        trigger_count = AlertRuleTrigger.objects.all().count()
+        action_count = AlertRuleTriggerAction.objects.all().count()
+
+        updated_projects = [self.project, self.create_project(fire_project_created=True)]
+
+        updated_rule = update_alert_rule(
+            self.alert_rule,
+            projects=updated_projects,
+            query="level:warning",
+            aggregation=QueryAggregations.UNIQUE_USERS,
+            time_window=50,
+            threshold_period=2,
+        )
+
+        incident.refresh_from_db()
+        incident_2.refresh_from_db()
+        rule_snapshot = AlertRule.objects_with_snapshots.filter(name=self.alert_rule.name).exclude(
+            id=updated_rule.id
+        )
+        assert rule_snapshot.count() == 1
+        rule_snapshot = rule_snapshot.first()
+        assert rule_snapshot.status == AlertRuleStatus.SNAPSHOT.value
+
+        # Rule snapshot should have properties of the rule before it was updated.
+        assert rule_snapshot.id != updated_rule.id
+        assert rule_snapshot.name == updated_rule.name
+        assert rule_snapshot.query == "level:error"
+        assert rule_snapshot.time_window == 10
+        assert rule_snapshot.aggregation == QueryAggregations.TOTAL.value
+        assert rule_snapshot.threshold_period == 1
+
+        for incident in (incident, incident_2):
+            # Incidents should now be pointing to the rule snapshot.
+            assert incident.alert_rule.id == rule_snapshot.id
+            assert incident.alert_rule.name == updated_rule.name
+            # Incidents should be resolved
+            assert incident.status == IncidentStatus.CLOSED.value
+
+        # Action and trigger counts should double (from 1 to 2)
+        assert AlertRuleTrigger.objects.all().count() == trigger_count * 2
+        assert AlertRuleTriggerAction.objects.all().count() == action_count * 2
+
+        # Verify actions and triggers have the same properties...and are not the same actions & triggers as the original rule.
+        assert AlertRuleTrigger.objects.filter(alert_rule=rule_snapshot).exists()
+        trigger_snapshot = AlertRuleTrigger.objects.get(alert_rule=rule_snapshot)
+        assert trigger_snapshot.id != trigger.id
+        assert trigger_snapshot.label == trigger.label
+        assert trigger_snapshot.threshold_type == trigger.threshold_type
+        assert trigger_snapshot.alert_threshold == trigger.alert_threshold
+        assert trigger_snapshot.resolve_threshold == trigger.resolve_threshold
+
+        assert AlertRuleTriggerAction.objects.filter(alert_rule_trigger=trigger_snapshot).exists()
+        action_snapshot = AlertRuleTriggerAction.objects.get(alert_rule_trigger=trigger_snapshot)
+        assert action_snapshot.id != action.id
+        assert action_snapshot.type == action.type
+        assert action_snapshot.target_type == action.target_type
+        assert action_snapshot.target_identifier == action.target_identifier
+        assert action_snapshot.target_display == action.target_display
+
 
 class DeleteAlertRuleTest(TestCase, BaseIncidentsTest):
     @fixture

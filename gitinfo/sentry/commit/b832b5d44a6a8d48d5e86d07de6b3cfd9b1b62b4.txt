commit b832b5d44a6a8d48d5e86d07de6b3cfd9b1b62b4
Author: Alex Hofsteede <alex@hofsteede.com>
Date:   Tue Nov 14 14:43:18 2017 -0800

    feat(schemas): Model most of input validation as schema (#6481)
    
    * feat(schemas): Model most of input validation as schema
    
    This takes most of the imperative validation code in validate_data
    and uses declarative JSON schema to validate it instead. There is an
    associated helper method that uses the schema validation errors to do
    the same things as the old code, namely deleting invalid keys, or
    defaulting them if there is an applicable default.
    
    There is a pre-validation casting step that forces some of the values to be
    certain types before we apply the schema validation. This is to avoid
    having to create a bunch of special cases in the schema for eg. values
    that are either integers OR numeric strings. In theory this casting code
    could be removed completely if all clients were well behaved and only
    sent data for a given key in a single correct format.
    
    There are also additional validators for the individual interfaces that
    are created. These are checked when the interface is created with
    to_python.
    
    I had to make minor changes to some tests as the choice to raise an
    APIError on some types of invalid keys (eg. non-string event_id value)
    but not on others (culprit too long, too short, etc) seemed kinda
    arbitrary anyway and it would have made for some messy special case code
    to fix.

diff --git a/requirements-base.txt b/requirements-base.txt
index 979a2bc340..8c075b9a75 100644
--- a/requirements-base.txt
+++ b/requirements-base.txt
@@ -20,6 +20,7 @@ honcho>=0.7.0,<0.8.0
 kombu==3.0.35
 ipaddress>=1.0.16,<1.1.0
 loremipsum>=1.0.5,<1.1.0
+jsonschema==2.6.0
 lxml>=3.4.1
 mock>=0.8.0,<1.1
 mmh3>=2.3.1,<2.4
diff --git a/src/sentry/coreapi.py b/src/sentry/coreapi.py
index 29f9e7e917..f2681aa992 100644
--- a/src/sentry/coreapi.py
+++ b/src/sentry/coreapi.py
@@ -13,7 +13,6 @@ from __future__ import absolute_import, print_function
 import base64
 import logging
 import six
-import uuid
 import zlib
 import re
 
@@ -25,19 +24,18 @@ from gzip import GzipFile
 from six import BytesIO
 from time import time
 
-from sentry import filters, tagstore
+from sentry import filters
 from sentry.cache import default_cache
 from sentry.constants import (
     CLIENT_RESERVED_ATTRS,
     DEFAULT_LOG_LEVEL,
     LOG_LEVELS_MAP,
-    MAX_TAG_VALUE_LENGTH,
-    MAX_TAG_KEY_LENGTH,
     VALID_PLATFORMS,
 )
-from sentry.db.models import BoundedIntegerField
 from sentry.interfaces.base import get_interface, InterfaceValidationError
 from sentry.interfaces.csp import Csp
+from sentry.interfaces.schemas import \
+    EVENT_SCHEMA, TAGS_TUPLES_SCHEMA, validate_and_default_from_schema
 from sentry.event_manager import EventManager
 from sentry.models import EventError, ProjectKey, upload_minidump, merge_minidump_event
 from sentry.tasks.store import preprocess_event, \
@@ -49,7 +47,7 @@ from sentry.utils.http import origin_from_request
 from sentry.utils.data_filters import is_valid_ip, \
     is_valid_release, is_valid_error_message, FilterStatKeys
 from sentry.utils.strings import decompress
-from sentry.utils.validators import is_float, is_event_id
+from sentry.utils.validators import is_float
 
 try:
     # Attempt to load ujson if it's installed.
@@ -101,10 +99,6 @@ class InvalidTimestamp(Exception):
     pass
 
 
-class InvalidFingerprint(Exception):
-    pass
-
-
 class Auth(object):
     def __init__(self, auth_vars, is_public=False):
         self.client = auth_vars.get('sentry_client')
@@ -321,12 +315,16 @@ class ClientApiHelper(object):
         if not value:
             del data['timestamp']
             return data
-        elif is_float(value):
+        data['timestamp'] = self._process_timestamp(data['timestamp'], current_datetime)
+        return data
+
+    def _process_timestamp(self, value, current_datetime=None):
+        if is_float(value):
             try:
                 value = datetime.fromtimestamp(float(value))
             except Exception:
                 raise InvalidTimestamp(
-                    'Invalid value for timestamp: %r' % data['timestamp'])
+                    'Invalid value for timestamp: %r' % value)
         elif not isinstance(value, datetime):
             # all timestamps are in UTC, but the marker is optional
             if value.endswith('Z'):
@@ -343,7 +341,7 @@ class ClientApiHelper(object):
                 value = datetime.strptime(value, fmt)
             except Exception:
                 raise InvalidTimestamp(
-                    'Invalid value for timestamp: %r' % data['timestamp'])
+                    'Invalid value for timestamp: %r' % value)
 
         if current_datetime is None:
             current_datetime = datetime.now()
@@ -356,20 +354,7 @@ class ClientApiHelper(object):
             raise InvalidTimestamp(
                 'Invalid value for timestamp (too old): %r' % value)
 
-        data['timestamp'] = float(value.strftime('%s'))
-
-        return data
-
-    def _process_fingerprint(self, data):
-        if not isinstance(data['fingerprint'], (list, tuple)):
-            raise InvalidFingerprint
-
-        result = []
-        for bit in data['fingerprint']:
-            if not isinstance(bit, six.string_types + six.integer_types + (float, )):
-                raise InvalidFingerprint
-            result.append(six.text_type(bit))
-        return result
+        return float(value.strftime('%s'))
 
     def parse_client_as_sdk(self, value):
         if not value:
@@ -417,215 +402,64 @@ class ClientApiHelper(object):
         # TODO(dcramer): move project out of the data packet
         data['project'] = project.id
 
-        data['errors'] = []
-
-        if data.get('culprit'):
-            if not isinstance(data['culprit'], six.string_types):
-                raise APIForbidden('Invalid value for culprit')
-
-        if not data.get('event_id'):
-            data['event_id'] = uuid.uuid4().hex
-        elif not isinstance(data['event_id'], six.string_types):
-            raise APIForbidden('Invalid value for event_id')
+        errors = []
+
+        # Before validating with a schema, attempt to cast values to their desired types
+        # so that the schema doesn't have to take every type variation into account.
+        text = six.text_type
+        fingerprint_types = six.string_types + six.integer_types + (float, )
+
+        def to_values(v):
+            return {'values': v} if v and isinstance(v, (tuple, list)) else v
+
+        casts = {
+            'environment': lambda v: text(v) if v is not None else v,
+            'fingerprint': lambda v: map(text, v) if isinstance(v, list) and all(isinstance(f, fingerprint_types) for f in v) else v,
+            'release': lambda v: text(v) if v is not None else v,
+            'dist': lambda v: text(v).strip() if v is not None else v,
+            'time_spent': lambda v: int(v) if v is not None else v,
+            'tags': lambda v: [(text(v_k.replace(' ', '-')), text(v_v)) for (v_k, v_v) in dict(v).items()],
+            'timestamp': lambda v: self._process_timestamp(v),
+            'platform': lambda v: v if v in VALID_PLATFORMS else 'other',
+
+            # These can be sent as lists and need to be converted to {'values': list}
+            'exception': to_values,
+            'sentry.interfaces.Exception': to_values,
+            'breadcrumbs': to_values,
+            'sentry.interfaces.Breadcrumbs': to_values,
+            'threads': to_values,
+            'sentry.interfaces.Threads': to_values,
+        }
 
-        if len(data['event_id']) > 32:
-            self.log.debug(
-                'Discarded value for event_id due to length (%d chars)', len(
-                    data['event_id'])
-            )
-            data['errors'].append(
-                {
-                    'type': EventError.VALUE_TOO_LONG,
-                    'name': 'event_id',
-                    'value': data['event_id'],
-                }
-            )
-            data['event_id'] = uuid.uuid4().hex
-        elif not is_event_id(data['event_id']):
-            self.log.debug(
-                'Discarded invalid value for event_id: %r', data['event_id'], exc_info=True
-            )
-            data['errors'].append(
-                {
-                    'type': EventError.INVALID_DATA,
-                    'name': 'event_id',
-                    'value': data['event_id'],
-                }
-            )
-            data['event_id'] = uuid.uuid4().hex
-
-        if 'timestamp' in data:
-            try:
-                self._process_data_timestamp(data)
-            except InvalidTimestamp as e:
-                self.log.debug(
-                    'Discarded invalid value for timestamp: %r', data['timestamp'], exc_info=True
-                )
-                data['errors'].append(
-                    {
+        for c in casts:
+            if c in data:
+                try:
+                    data[c] = casts[c](data[c])
+                except Exception:
+                    errors.append({
                         'type': EventError.INVALID_DATA,
-                        'name': 'timestamp',
-                        'value': data['timestamp'],
-                    }
-                )
-                del data['timestamp']
+                        'name': c,
+                        'value': data[c],
+                    })
+                    del data[c]
+
+        # raw 'message' is coerced to the Message interface, as its used for pure index of
+        # searchable strings. If both a raw 'message' and a Message interface exist, try and
+        # add the former as the 'formatted' attribute of the latter.
+        # See GH-3248
+        msg_str = data.pop('message', None)
+        if msg_str:
+            msg_if = data.setdefault('sentry.interfaces.Message', {'message': msg_str})
+            if msg_if.get('message') != msg_str:
+                msg_if.setdefault('formatted', msg_str)
 
-        if 'fingerprint' in data:
-            try:
-                data['fingerprint'] = self._process_fingerprint(data)
-            except InvalidFingerprint as e:
-                self.log.debug(
-                    'Discarded invalid value for fingerprint: %r',
-                    data['fingerprint'],
-                    exc_info=True
-                )
-                data['errors'].append(
-                    {
-                        'type': EventError.INVALID_DATA,
-                        'name': 'fingerprint',
-                        'value': data['fingerprint'],
-                    }
-                )
-                del data['fingerprint']
-
-        if 'platform' not in data or data['platform'] not in VALID_PLATFORMS:
-            data['platform'] = 'other'
-
-        if data.get('modules') and type(data['modules']) != dict:
-            self.log.debug(
-                'Discarded invalid type for modules: %s', type(data['modules']))
-            data['errors'].append(
-                {
-                    'type': EventError.INVALID_DATA,
-                    'name': 'modules',
-                    'value': data['modules'],
-                }
-            )
-            del data['modules']
-
-        if data.get('extra') is not None and type(data['extra']) != dict:
-            self.log.debug('Discarded invalid type for extra: %s',
-                           type(data['extra']))
-            data['errors'].append(
-                {
-                    'type': EventError.INVALID_DATA,
-                    'name': 'extra',
-                    'value': data['extra'],
-                }
-            )
-            del data['extra']
-
-        if data.get('tags') is not None:
-            if type(data['tags']) == dict:
-                data['tags'] = list(data['tags'].items())
-            elif not isinstance(data['tags'], (list, tuple)):
-                self.log.debug(
-                    'Discarded invalid type for tags: %s', type(data['tags']))
-                data['errors'].append(
-                    {
-                        'type': EventError.INVALID_DATA,
-                        'name': 'tags',
-                        'value': data['tags'],
-                    }
-                )
-                del data['tags']
+        main_errors = validate_and_default_from_schema(data, EVENT_SCHEMA)
+        errors.extend(main_errors)
 
-        if data.get('tags'):
-            # remove any values which are over 32 characters
-            tags = []
-            for pair in data['tags']:
-                try:
-                    k, v = pair
-                except ValueError:
-                    self.log.debug('Discarded invalid tag value: %r', pair)
-                    data['errors'].append(
-                        {
-                            'type': EventError.INVALID_DATA,
-                            'name': 'tags',
-                            'value': pair,
-                        }
-                    )
-                    continue
-
-                if not isinstance(k, six.string_types):
-                    try:
-                        k = six.text_type(k)
-                    except Exception:
-                        self.log.debug(
-                            'Discarded invalid tag key: %r', type(k))
-                        data['errors'].append(
-                            {
-                                'type': EventError.INVALID_DATA,
-                                'name': 'tags',
-                                'value': pair,
-                            }
-                        )
-                        continue
-
-                if not isinstance(v, six.string_types):
-                    try:
-                        v = six.text_type(v)
-                    except Exception:
-                        self.log.debug(
-                            'Discarded invalid tag value: %s=%r', k, type(v))
-                        data['errors'].append(
-                            {
-                                'type': EventError.INVALID_DATA,
-                                'name': 'tags',
-                                'value': pair,
-                            }
-                        )
-                        continue
-
-                if len(k) > MAX_TAG_KEY_LENGTH or len(v) > MAX_TAG_VALUE_LENGTH:
-                    self.log.debug('Discarded invalid tag: %s=%s', k, v)
-                    data['errors'].append(
-                        {
-                            'type': EventError.INVALID_DATA,
-                            'name': 'tags',
-                            'value': pair,
-                        }
-                    )
-                    continue
-
-                # support tags with spaces by converting them
-                k = k.replace(' ', '-')
-
-                if tagstore.is_reserved_key(k):
-                    self.log.debug('Discarding reserved tag key: %s', k)
-                    data['errors'].append(
-                        {
-                            'type': EventError.INVALID_DATA,
-                            'name': 'tags',
-                            'value': pair,
-                        }
-                    )
-                    continue
-
-                if not tagstore.is_valid_key(k):
-                    self.log.debug('Discarded invalid tag key: %s', k)
-                    data['errors'].append(
-                        {
-                            'type': EventError.INVALID_DATA,
-                            'name': 'tags',
-                            'value': pair,
-                        }
-                    )
-                    continue
-
-                if not tagstore.is_valid_value(v):
-                    self.log.debug('Discard invalid tag value: %s', v)
-                    data['errors'].append(
-                        {
-                            'type': EventError.INVALID_DATA,
-                            'name': 'tags',
-                            'value': pair,
-                        }
-                    )
-                    continue
-
-                tags.append((k, v))
-            data['tags'] = tags
+        if 'tags' in data:
+            tag_errors = validate_and_default_from_schema(
+                data['tags'], TAGS_TUPLES_SCHEMA, name='tags')
+            errors.extend(tag_errors)
 
         for k in list(iter(data)):
             if k in CLIENT_RESERVED_ATTRS:
@@ -641,30 +475,12 @@ class ClientApiHelper(object):
                 interface = get_interface(k)
             except ValueError:
                 self.log.debug('Ignored unknown attribute: %s', k)
-                data['errors'].append({
+                errors.append({
                     'type': EventError.INVALID_ATTRIBUTE,
                     'name': k,
                 })
                 continue
 
-            if type(value) != dict:
-                # HACK(dcramer): the exception/breadcrumbs interface supports a
-                # list as the value. We should change this in a new protocol
-                # version.
-                if type(value) in (list, tuple):
-                    value = {'values': value}
-                else:
-                    self.log.debug(
-                        'Invalid parameter for value: %s (%r)', k, type(value))
-                    data['errors'].append(
-                        {
-                            'type': EventError.INVALID_DATA,
-                            'name': k,
-                            'value': value,
-                        }
-                    )
-                    continue
-
             try:
                 inst = interface.to_python(value)
                 data[inst.get_path()] = inst.to_json()
@@ -675,7 +491,7 @@ class ClientApiHelper(object):
                     log = self.log.error
                 log('Discarded invalid value for interface: %s (%r)',
                     k, value, exc_info=True)
-                data['errors'].append(
+                errors.append(
                     {
                         'type': EventError.INVALID_DATA,
                         'name': k,
@@ -683,132 +499,14 @@ class ClientApiHelper(object):
                     }
                 )
 
-        # TODO(dcramer): ideally this logic would happen in normalize, but today
-        # we don't do "validation" there (create errors)
-
-        # message is coerced to an interface, as its used for pure
-        # index of searchable strings
-        # See GH-3248
-        message = data.pop('message', None)
-        if message:
-            if 'sentry.interfaces.Message' not in data:
-                value = {
-                    'message': message,
-                }
-            elif not data['sentry.interfaces.Message'].get('formatted'):
-                value = data['sentry.interfaces.Message']
-                value['formatted'] = message
-            else:
-                value = None
-
-            if value is not None:
-                k = 'sentry.interfaces.Message'
-                interface = get_interface(k)
-                try:
-                    inst = interface.to_python(value)
-                    data[inst.get_path()] = inst.to_json()
-                except Exception as e:
-                    if isinstance(e, InterfaceValidationError):
-                        log = self.log.debug
-                    else:
-                        log = self.log.error
-                    log('Discarded invalid value for interface: %s (%r)',
-                        k, value, exc_info=True)
-                    data['errors'].append(
-                        {
-                            'type': EventError.INVALID_DATA,
-                            'name': k,
-                            'value': value,
-                        }
-                    )
-
         level = data.get('level') or DEFAULT_LOG_LEVEL
         if isinstance(level, six.string_types) and not level.isdigit():
-            # assume it's something like 'warning'
-            try:
-                data['level'] = LOG_LEVELS_MAP[level]
-            except KeyError as e:
-                self.log.debug('Discarded invalid logger value: %s', level)
-                data['errors'].append(
-                    {
-                        'type': EventError.INVALID_DATA,
-                        'name': 'level',
-                        'value': level,
-                    }
-                )
-                data['level'] = LOG_LEVELS_MAP.get(
-                    DEFAULT_LOG_LEVEL, DEFAULT_LOG_LEVEL)
+            data['level'] = LOG_LEVELS_MAP.get(level, LOG_LEVELS_MAP[DEFAULT_LOG_LEVEL])
 
-        if data.get('release'):
-            data['release'] = six.text_type(data['release'])
-            if len(data['release']) > 64:
-                data['errors'].append(
-                    {
-                        'type': EventError.VALUE_TOO_LONG,
-                        'name': 'release',
-                        'value': data['release'],
-                    }
-                )
-                del data['release']
-
-        if data.get('dist'):
-            data['dist'] = six.text_type(data['dist']).strip()
-            if not data.get('release'):
-                data['dist'] = None
-            elif len(data['dist']) > 64:
-                data['errors'].append(
-                    {
-                        'type': EventError.VALUE_TOO_LONG,
-                        'name': 'dist',
-                        'value': data['dist'],
-                    }
-                )
-                del data['dist']
-            elif _dist_re.match(data['dist']) is None:
-                data['errors'].append(
-                    {
-                        'type': EventError.INVALID_DATA,
-                        'name': 'dist',
-                        'value': data['dist'],
-                    }
-                )
-                del data['dist']
-
-        if data.get('environment'):
-            data['environment'] = six.text_type(data['environment'])
-            if len(data['environment']) > 64:
-                data['errors'].append(
-                    {
-                        'type': EventError.VALUE_TOO_LONG,
-                        'name': 'environment',
-                        'value': data['environment'],
-                    }
-                )
-                del data['environment']
-
-        if data.get('time_spent'):
-            try:
-                data['time_spent'] = int(data['time_spent'])
-            except (ValueError, TypeError):
-                data['errors'].append(
-                    {
-                        'type': EventError.INVALID_DATA,
-                        'name': 'time_spent',
-                        'value': data['time_spent'],
-                    }
-                )
-                del data['time_spent']
-            else:
-                if data['time_spent'] > BoundedIntegerField.MAX_VALUE:
-                    data['errors'].append(
-                        {
-                            'type': EventError.VALUE_TOO_LONG,
-                            'name': 'time_spent',
-                            'value': data['time_spent'],
-                        }
-                    )
-                    del data['time_spent']
+        if data.get('dist') and not data.get('release'):
+            data['dist'] = None
 
+        data['errors'] = errors
         return data
 
     def ensure_does_not_have_ip(self, data):
@@ -977,6 +675,7 @@ class CspApiHelper(ClientApiHelper):
             'message': inst.get_message(),
             'culprit': inst.get_culprit(),
             'release': meta.get('release'),
+            'tags': inst.get_tags(),
             inst.get_path(): inst.to_json(),
             # This is a bit weird, since we don't have nearly enough
             # information to create an Http interface, but
@@ -989,51 +688,21 @@ class CspApiHelper(ClientApiHelper):
             'sentry.interfaces.User': {
                 'ip_address': self.context.ip_address,
             },
-            'errors': [],
         }
 
-        # Copy/pasted from above in ClientApiHelper.validate_data
-        if data.get('release'):
-            data['release'] = six.text_type(data['release'])
-            if len(data['release']) > 64:
-                data['errors'].append(
-                    {
-                        'type': EventError.VALUE_TOO_LONG,
-                        'name': 'release',
-                        'value': data['release'],
-                    }
-                )
-                del data['release']
+        errors = []
 
-        tags = []
-        for k, v in inst.get_tags():
-            if not v:
-                continue
-            if len(v) > MAX_TAG_VALUE_LENGTH:
-                self.log.debug('Discarded invalid tag: %s=%s', k, v)
-                data['errors'].append(
-                    {
-                        'type': EventError.INVALID_DATA,
-                        'name': 'tags',
-                        'value': (k, v),
-                    }
-                )
-                continue
-            if not tagstore.is_valid_value(v):
-                self.log.debug('Discard invalid tag value: %s', v)
-                data['errors'].append(
-                    {
-                        'type': EventError.INVALID_DATA,
-                        'name': 'tags',
-                        'value': (k, v),
-                    }
-                )
-                continue
-            tags.append((k, v))
+        main_errors = validate_and_default_from_schema(data, EVENT_SCHEMA)
+        errors.extend(main_errors)
 
-        if tags:
-            data['tags'] = tags
+        if 'tags' in data:
+            tag_errors = validate_and_default_from_schema(
+                data['tags'], TAGS_TUPLES_SCHEMA, name='tags')
+            errors.extend(tag_errors)
+            if not data['tags']:
+                del data['tags']  # TODO could solve empty tags by validating tags first
 
+        data['errors'] = errors
         return data
 
 
diff --git a/src/sentry/interfaces/csp.py b/src/sentry/interfaces/csp.py
index fe42e26cb0..fb109aa1bc 100644
--- a/src/sentry/interfaces/csp.py
+++ b/src/sentry/interfaces/csp.py
@@ -137,10 +137,10 @@ class Csp(Interface):
         return self._normalize_directive(self.violated_directive)
 
     def get_tags(self):
-        return (
+        return [
             ('effective-directive', self.effective_directive),
             ('blocked-uri', self.sanitized_blocked_uri()),
-        )
+        ]
 
     def sanitized_blocked_uri(self):
         # HACK: This is 100% to work around Stripe urls
diff --git a/src/sentry/interfaces/exception.py b/src/sentry/interfaces/exception.py
index f9ea76b0ae..7912faed25 100644
--- a/src/sentry/interfaces/exception.py
+++ b/src/sentry/interfaces/exception.py
@@ -15,6 +15,8 @@ import six
 from django.conf import settings
 
 from sentry.interfaces.base import Interface, InterfaceValidationError
+from sentry.interfaces.schemas import \
+    INTERFACE_SCHEMAS, is_valid_interface, validate_and_default_from_schema
 from sentry.interfaces.stacktrace import Stacktrace, slim_frame_data
 from sentry.utils import json
 from sentry.utils.safe import trim
@@ -40,9 +42,14 @@ class SingleException(Interface):
     >>> }
     """
     score = 2000
+    path = 'sentry.interfaces.Exception'
 
     @classmethod
     def to_python(cls, data, slim_frames=True):
+        validate_and_default_from_schema(data, INTERFACE_SCHEMAS[cls.path])
+        if not is_valid_interface(data, cls.path):
+            raise InterfaceValidationError("Invalid exception")
+
         if not (data.get('type') or data.get('value')):
             raise InterfaceValidationError("No 'type' or 'value' present")
 
@@ -75,8 +82,6 @@ class SingleException(Interface):
 
         mechanism = data.get('mechanism')
         if mechanism is not None:
-            if not isinstance(mechanism, dict):
-                raise InterfaceValidationError('Bad value for mechanism')
             mechanism = trim(data.get('mechanism'), 4096)
             mechanism.setdefault('type', 'generic')
 
@@ -138,7 +143,7 @@ class SingleException(Interface):
         return 'exception'
 
     def get_path(self):
-        return 'sentry.interfaces.Exception'
+        return self.path
 
     def get_hash(self, platform=None):
         output = None
diff --git a/src/sentry/interfaces/http.py b/src/sentry/interfaces/http.py
index d90866c143..f86840e479 100644
--- a/src/sentry/interfaces/http.py
+++ b/src/sentry/interfaces/http.py
@@ -18,6 +18,8 @@ from django.utils.translation import ugettext as _
 from six.moves.urllib.parse import parse_qsl, urlencode, urlsplit, urlunsplit
 
 from sentry.interfaces.base import Interface, InterfaceValidationError
+from sentry.interfaces.schemas import \
+    INTERFACE_SCHEMAS, is_valid_interface, validate_and_default_from_schema
 from sentry.utils.safe import trim, trim_dict, trim_pairs
 from sentry.utils.http import heuristic_decode
 from sentry.web.helpers import render_to_string
@@ -116,13 +118,15 @@ class Http(Interface):
     """
     display_score = 1000
     score = 800
+    path = 'sentry.interfaces.Http'
 
     FORM_TYPE = 'application/x-www-form-urlencoded'
 
     @classmethod
     def to_python(cls, data):
-        if not data.get('url'):
-            raise InterfaceValidationError("No value for 'url'")
+        validate_and_default_from_schema(data, INTERFACE_SCHEMAS[cls.path])
+        if not is_valid_interface(data, cls.path):
+            raise InterfaceValidationError("Invalid interface data")
 
         kwargs = {}
 
@@ -146,7 +150,6 @@ class Http(Interface):
                     [(to_bytes(k), to_bytes(v)) for k, v in query_string.items()]
                 )
             else:
-                query_string = query_string
                 if query_string[0] == '?':
                     # remove '?' prefix
                     query_string = query_string[1:]
@@ -200,7 +203,7 @@ class Http(Interface):
         return cls(**kwargs)
 
     def get_path(self):
-        return 'sentry.interfaces.Http'
+        return self.path
 
     @property
     def full_url(self):
diff --git a/src/sentry/interfaces/schemas.py b/src/sentry/interfaces/schemas.py
new file mode 100644
index 0000000000..0d4c065e51
--- /dev/null
+++ b/src/sentry/interfaces/schemas.py
@@ -0,0 +1,487 @@
+"""
+sentry.interfaces.schemas
+~~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2017 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+
+from __future__ import absolute_import
+
+from itertools import groupby
+import jsonschema
+import six
+import uuid
+
+from sentry.db.models import BoundedIntegerField
+from sentry.constants import (
+    LOG_LEVELS_MAP,
+    MAX_TAG_KEY_LENGTH,
+    MAX_TAG_VALUE_LENGTH,
+    VALID_PLATFORMS,
+)
+from sentry.interfaces.base import InterfaceValidationError
+from sentry.models import EventError
+from sentry.tagstore.base import INTERNAL_TAG_KEYS
+
+
+def iverror(message="Invalid data"):
+    raise InterfaceValidationError(message)
+
+
+def apierror(message="Invalid data"):
+    from sentry.coreapi import APIForbidden
+    raise APIForbidden(message)
+
+PAIRS = {
+    'type': 'array',
+    'items': {
+        'type': 'array',
+        'minItems': 2,
+        'maxItems': 2,
+        'items': {'type': 'string'}
+    }
+}
+
+HTTP_INTERFACE_SCHEMA = {
+    'type': 'object',
+    'properties': {
+        'url': {
+            'type': 'string',
+            'minLength': 1,
+        },
+        'method': {'type': 'string'},
+        'query_string': {'type': ['string', 'object']},
+        'inferred_content_type': {'type': 'string'},
+        'cookies': {
+            'anyOf': [
+                {'type': ['string', 'object']},  # either a string of object
+                PAIRS,  # or a list of 2-tuples
+            ]
+        },
+        'env': {'type': 'object'},
+        'headers': {
+            'anyOf': [
+                {'type': 'object'},  # either an object
+                PAIRS,  # or a list of 2-tuples
+            ]
+        },
+        'data': {'type': ['string', 'object', 'array']},
+        'fragment': {'type': 'string'},
+    },
+    'required': ['url'],
+    'additionalProperties': True,
+}
+
+FRAME_INTERFACE_SCHEMA = {
+    'type': 'object',
+    'properties': {
+        'abs_path': {
+            'type': 'string',
+            'default': iverror,
+        },
+        'colno': {'type': ['number', 'string']},
+        'context_line': {'type': 'string'},
+        'data': {
+            'anyOf': [
+                {'type': 'object'},
+                PAIRS,
+            ]
+        },
+        'errors': {},
+        'filename': {
+            'type': 'string',
+            'default': iverror,
+        },
+        'function': {'type': 'string'},
+        'image_addr': {},
+        'in_app': {'type': 'boolean', 'default': False},
+        'instruction_addr': {},
+        'lineno': {'type': ['number', 'string']},
+        'module': {
+            'type': 'string',
+            'default': iverror,
+        },
+        'package': {'type': 'string'},
+        'platform': {
+            'type': 'string',
+            'enum': list(VALID_PLATFORMS),
+        },
+        'post_context': {},
+        'pre_context': {},
+        'symbol': {'type': 'string'},
+        'symbol_addr': {},
+        'vars': {
+            'anyOf': [
+                {'type': 'object'},
+                PAIRS,
+            ]
+        },
+    },
+    'anyOf': [
+        # TODO abs_path vs. filename validation depends on whether this is a raw frame or not.
+        {'required': ['abs_path']},
+        {'required': ['filename']},
+        {
+            # can only accept function on its own if it's not None or '?'
+            'required': ['function'],
+            'properties': {
+                'function': {
+                    'type': 'string',  # TODO probably shouldn't allow empty string either
+                    'not': {'pattern': '^\?$'},
+                },
+            },
+        },
+        {'required': ['module']},
+        {'required': ['package']},
+    ],
+    'additionalProperties': False,
+}
+
+STACKTRACE_INTERFACE_SCHEMA = {
+    'type': 'object',
+    'properties': {
+        'frames': {
+            'type': 'array',
+            # To validate individual frames use FRAME_INTERFACE_SCHEMA
+            'items': {'type': 'object'},
+            'minItems': 1,
+        },
+        'frames_omitted': {
+            'type': 'array',
+            'maxItems': 2,
+            'minItems': 2,
+            'items': {'type': 'number'},
+        },
+        'registers': {'type': 'object'},
+    },
+    'required': ['frames'],
+    'additionalProperties': False,
+}
+
+EXCEPTION_INTERFACE_SCHEMA = {
+    'type': 'object',
+    'properties': {
+        'type': {
+            'type': 'string',
+            # 'minLength': 1,
+        },
+        'value': {
+            # 'minProperties': 1,
+            # 'minItems': 1,
+            # 'minLength': 1,
+        },
+        'module': {'type': 'string'},
+        'mechanism': {'type': 'object'},
+        'stacktrace': {
+            # To validate stacktraces use STACKTRACE_INTERFACE_SCHEMA
+            'type': 'object',
+            'properties': {
+                # The code allows for the possibility of an empty
+                # {"frames":[]} object, this sucks and should go.
+                # STACKTRACE_INTERFACE_SCHEMA enforces at least 1
+                'frames': {'type': 'array'},
+            },
+        },
+        'thread_id': {},
+        'raw_stacktrace': {
+            'type': 'object',
+            'properties': {
+                'frames': {'type': 'array'},
+            },
+        },
+    },
+    'anyOf': [  # Require at least one of these keys.
+        {'required': ['type']},
+        {'required': ['value']},
+    ],
+    # TODO should be false but allowing extra garbage for now
+    # for compatibility
+    'additionalProperties': True,
+}
+
+TEMPLATE_INTERFACE_SCHEMA = {'type': 'object'}  # TODO fill this out
+MESSAGE_INTERFACE_SCHEMA = {'type': 'object'}
+
+TAGS_DICT_SCHEMA = {
+    'allOf': [
+        {
+            'type': 'object',
+            # TODO with draft 6 support, we can just use propertyNames/maxLength
+            'patternProperties': {
+                '^[a-zA-Z0-9_\.:-]{1,%d}$' % MAX_TAG_KEY_LENGTH: {
+                    'type': 'string',
+                    'maxLength': MAX_TAG_VALUE_LENGTH,
+                    'pattern': '^[^\n]+\Z',  # \Z because $ matches before trailing newline
+                }
+            },
+            'additionalProperties': False,
+        },
+        {
+            # This is a negative match for all the reserved tags
+            'type': 'object',
+            'patternProperties': {
+                '^(%s)$' % '|'.join(INTERNAL_TAG_KEYS): {'not': {}}
+            },
+            'additionalProperties': True,
+        },
+    ],
+}
+
+TAGS_TUPLES_SCHEMA = {
+    'type': 'array',
+    'items': {
+        'type': 'array',
+        'minItems': 2,
+        'maxItems': 2,
+        'items': [
+            # Key
+            {
+                'type': 'string',
+                'pattern': '^[a-zA-Z0-9_\.:-]+$',
+                'maxLength': MAX_TAG_KEY_LENGTH,
+                'not': {
+                    'pattern': '^(%s)$' % '|'.join(INTERNAL_TAG_KEYS),
+                },
+            },
+            # Value
+            {
+                'type': 'string',
+                'pattern': '^[^\n]*\Z',  # \Z because $ matches before a trailing newline
+                # 'minLength': 1,
+                'maxLength': MAX_TAG_VALUE_LENGTH,
+            },
+        ]
+    }
+}
+
+TAGS_SCHEMA = {
+    'anyOf': [TAGS_DICT_SCHEMA, TAGS_TUPLES_SCHEMA]
+}
+
+EVENT_SCHEMA = {
+    'type': 'object',
+    'properties': {
+        'event_id': {
+            'type': 'string',
+            'pattern': '^[a-fA-F0-9]+$',
+            'maxLength': 32,
+            'minLength': 32,
+            'default': lambda: uuid.uuid4().hex,
+        },
+        'timestamp': {
+            'anyOf': [
+                {'type': 'string', 'format': 'date-time'},
+                {'type': 'number'}
+            ],
+        },
+        'logger': {'type': 'string'},
+        'platform': {
+            'type': 'string',
+            'enum': list(VALID_PLATFORMS),
+            'default': 'other',
+        },
+        'sdk': {
+            'type': 'object',
+            'properties': {
+                'name': {'type': 'string'},
+                'version': {},
+                'integrations': {},
+            },
+            'additionalProperties': True,
+        },
+        'level': {
+            'anyOf': [
+                {'type': 'number'},
+                {
+                    'type': 'string',
+                    'pattern': '^[0-9]+$',
+                },
+                {
+                    'type': 'string',
+                    'enum': LOG_LEVELS_MAP.keys(),
+                },
+            ],
+        },
+        'culprit': {
+            'type': 'string',
+            # 'minLength': 1,
+            # 'maxLength': MAX_CULPRIT_LENGTH,
+            'default': lambda: apierror('Invalid value for culprit'),
+        },
+        'server_name': {'type': 'string'},
+        'release': {
+            'type': 'string',
+            'maxLength': 64,
+        },
+        'dist': {
+            'type': 'string',
+            'pattern': '^[a-zA-Z0-9_.-]+$',
+            'maxLength': 64,
+        },
+        'tags': {
+            # This is a loose tags schema, individual tags
+            # are also validated more in depth with TAGS_SCHEMA
+            'anyOf': [
+                {'type': 'object'},
+                PAIRS,
+            ]
+        },
+        'environment': {
+            'type': 'string',
+            'maxLength': 64,
+        },
+        'modules': {'type': 'object'},
+        'extra': {'type': 'object'},
+        'fingerprint': {
+            'type': 'array',
+            'items': {'type': 'string'},
+        },
+        'time_spent': {
+            'type': 'number',
+            'maximum': BoundedIntegerField.MAX_VALUE,
+            'minimum': 0,
+        },
+
+        # Exceptions:
+        'exception': {},  # EXCEPTION_INTERFACE_SCHEMA,
+        'sentry.interfaces.Exception': {},  # EXCEPTION_INTERFACE_SCHEMA,
+
+        # Messages:
+        # 'message' is not an alias for the sentry.interfaces.Message interface
+        # but instead is a raw string that will be wrapped in a Message interface
+        'message': {'type': 'string'},
+        'logentry': {},  # MESSAGE_INTERFACE_SCHEMA,
+        'sentry.interfaces.Message': {},  # MESSAGE_INTERFACE_SCHEMA,
+
+        # Templates:
+        'template': {},  # TEMPLATE_INTERFACE_SCHEMA,
+        'sentry.interfaces.Template': {},  # TEMPLATE_INTERFACE_SCHEMA,
+
+        # Other interfaces
+        'sentry.interfaces.User': {},
+        'sentry.interfaces.Http': {},
+
+        # Other reserved keys. (some are added in processing)
+        'project': {'type': 'number'},
+        'errors': {'type': 'array'},
+        'checksum': {},
+        'site': {},
+        'received': {},
+    },
+    'required': ['platform', 'event_id'],
+    'additionalProperties': True,
+}
+"""
+Schemas for raw request data.
+
+This is to validate input data at the very first stage of ingestion. It can
+then be transformed into the requisite interface.
+"""
+INPUT_SCHEMAS = {
+    'event': EVENT_SCHEMA,  # Not an interface per se, but the main store API input.
+}
+
+"""
+Schemas for interfaces.
+
+Data returned by interface.to_json() or passed into interface.to_python()
+should conform to these schemas. Currently this is not enforced everywhere yet.
+"""
+INTERFACE_SCHEMAS = {
+    # These should match SENTRY_INTERFACES keys
+    'sentry.interfaces.Http': HTTP_INTERFACE_SCHEMA,
+    'request': HTTP_INTERFACE_SCHEMA,
+    'exception': EXCEPTION_INTERFACE_SCHEMA,
+    'sentry.interfaces.Exception': EXCEPTION_INTERFACE_SCHEMA,
+    'stacktrace': STACKTRACE_INTERFACE_SCHEMA,
+    'sentry.interfaces.Stacktrace': STACKTRACE_INTERFACE_SCHEMA,
+    'frame': FRAME_INTERFACE_SCHEMA,  # Not listed in SENTRY_INTERFACES
+    'logentry': MESSAGE_INTERFACE_SCHEMA,
+    'sentry.interfaces.Message': MESSAGE_INTERFACE_SCHEMA,
+    'template': TEMPLATE_INTERFACE_SCHEMA,
+    'sentry.interfaces.Template': TEMPLATE_INTERFACE_SCHEMA,
+}
+
+
+def is_valid_input(data, interface):
+    if interface not in INPUT_SCHEMAS:
+        return True
+    return jsonschema.Draft4Validator(
+        INPUT_SCHEMAS[interface],
+        types={'array': (list, tuple)},
+        format_checker=jsonschema.FormatChecker(),
+    ).is_valid(data)
+
+
+def is_valid_interface(data, interface):
+    if interface not in INTERFACE_SCHEMAS:
+        return True
+    return jsonschema.Draft4Validator(
+        INTERFACE_SCHEMAS[interface],
+        types={'array': (list, tuple)},  # treat python tuples as arrays
+        format_checker=jsonschema.FormatChecker(),
+    ).is_valid(data)
+
+
+def validate_and_default_from_schema(data, schema, name=None, strip_nones=True):
+    """
+    Modify data to conform to schema.
+
+    Takes the object in `data` and checks it against `schema`,
+    removing or defaulting any keys that do not pass validation
+    and adding defaults for any keys that are required by (and
+    have a default value in) the schema.
+
+    This functon does not guarantee that the resulting data will
+    validate against the schema. For example, if there were
+    required keys missing that had no default in the schema.
+
+    Returns a list of the validation errors encountered.
+    """
+
+    errors = []
+
+    if strip_nones and isinstance(data, dict):
+        for k in data.keys():
+            if data[k] is None:
+                del data[k]
+
+    validator = jsonschema.Draft4Validator(
+        schema,
+        types={'array': (list, tuple)},
+        format_checker=jsonschema.FormatChecker(),
+    )
+    val_errors = validator.iter_errors(data)
+    keyed_errors = reversed([e for e in val_errors if len(e.path)])
+    # TODO raise any non-keyed errors? (eg disallowed keys)
+
+    # Values that need to be defaulted or deleted because they are not valid.
+    for key, group in groupby(keyed_errors, lambda e: e.path[0]):
+        ve = six.next(group)
+        errors.append({
+            'type': EventError.VALUE_TOO_LONG if ve.validator.startswith('max') else EventError.INVALID_DATA,
+            'name': name or key,
+            'value': data[key],
+        })
+
+        if 'default' in ve.schema:
+            default = ve.schema['default']
+            data[key] = default() if callable(default) else default
+        else:
+            del data[key]
+
+    # Values that are missing entirely, but are required and should be defaulted
+    if 'properties' in schema and 'required' in schema:
+        for p in schema['required']:
+            if p not in data:
+                if p in schema['properties'] and 'default' in schema['properties'][p]:
+                    default = schema['properties'][p]['default']
+                    data[p] = default() if callable(default) else default
+                else:
+                    errors.append({
+                        'type': EventError.MISSING_ATTRIBUTE,
+                        'name': p,
+                    })
+
+    return errors
diff --git a/src/sentry/interfaces/stacktrace.py b/src/sentry/interfaces/stacktrace.py
index feabc4855d..f2f946c726 100644
--- a/src/sentry/interfaces/stacktrace.py
+++ b/src/sentry/interfaces/stacktrace.py
@@ -20,10 +20,11 @@ from six.moves.urllib.parse import urlparse
 
 from sentry.app import env
 from sentry.interfaces.base import Interface, InterfaceValidationError
+from sentry.interfaces.schemas import \
+    INTERFACE_SCHEMAS, is_valid_interface, validate_and_default_from_schema
 from sentry.models import UserOption
 from sentry.utils.safe import trim, trim_dict
 from sentry.web.helpers import render_to_string
-from sentry.constants import VALID_PLATFORMS
 
 _ruby_anon_func = re.compile(r'_\d{2,}')
 _filename_version_re = re.compile(
@@ -253,8 +254,15 @@ def handle_nan(value):
 
 
 class Frame(Interface):
+
+    path = 'frame'
+
     @classmethod
     def to_python(cls, data, raw=False):
+        validate_and_default_from_schema(data, INTERFACE_SCHEMAS[cls.path])
+        if not is_valid_interface(data, cls.path):
+            raise InterfaceValidationError("Invalid stack frame data.")
+
         abs_path = data.get('abs_path')
         filename = data.get('filename')
         symbol = data.get('symbol')
@@ -270,11 +278,6 @@ class Frame(Interface):
         if symbol == '?':
             symbol = None
 
-        for name in ('abs_path', 'filename', 'symbol', 'function', 'module', 'package'):
-            v = data.get(name)
-            if v is not None and not isinstance(v, six.string_types):
-                raise InterfaceValidationError("Invalid value for '%s'" % name)
-
         # Some of this processing should only be done for non raw frames
         if not raw:
             # absolute path takes priority over filename
@@ -293,15 +296,7 @@ class Frame(Interface):
                 else:
                     filename = abs_path
 
-            if not (filename or function or module or package):
-                raise InterfaceValidationError(
-                    "No 'filename' or 'function' or "
-                    "'module' or 'package'"
-                )
-
         platform = data.get('platform')
-        if platform not in VALID_PLATFORMS:
-            platform = None
 
         context_locals = data.get('vars') or {}
         if isinstance(context_locals, (list, tuple)):
@@ -329,10 +324,7 @@ class Frame(Interface):
         else:
             pre_context, post_context = None, None
 
-        try:
-            in_app = validate_bool(data.get('in_app'), False)
-        except AssertionError:
-            raise InterfaceValidationError("Invalid value for 'in_app'")
+        in_app = validate_bool(data.get('in_app'), False)
 
         kwargs = {
             'abs_path': trim(abs_path, 2048),
@@ -648,17 +640,16 @@ class Stacktrace(Interface):
               to the full interface path.
     """
     score = 2000
+    path = 'sentry.interfaces.Stacktrace'
 
     def __iter__(self):
         return iter(self.frames)
 
     @classmethod
     def to_python(cls, data, slim_frames=True, raw=False):
-        if not data.get('frames'):
-            raise InterfaceValidationError("No 'frames' present")
-
-        if not isinstance(data['frames'], list):
-            raise InterfaceValidationError("Invalid value for 'frames'")
+        validate_and_default_from_schema(data, INTERFACE_SCHEMAS[cls.path])
+        if not is_valid_interface(data, cls.path):
+            raise InterfaceValidationError("Invalid stacktrace data.")
 
         frame_list = [
             # XXX(dcramer): handle PHP sending an empty array for a frame
@@ -674,8 +665,6 @@ class Stacktrace(Interface):
             kwargs['registers'] = data.get('registers')
 
         if data.get('frames_omitted'):
-            if len(data['frames_omitted']) != 2:
-                raise InterfaceValidationError("Invalid value for 'frames_omitted'")
             kwargs['frames_omitted'] = data['frames_omitted']
         else:
             kwargs['frames_omitted'] = None
@@ -721,7 +710,7 @@ class Stacktrace(Interface):
         }
 
     def get_path(self):
-        return 'sentry.interfaces.Stacktrace'
+        return self.path
 
     def compute_hashes(self, platform):
         system_hash = self.get_hash(platform, system_frames=True)
diff --git a/src/sentry/models/eventerror.py b/src/sentry/models/eventerror.py
index 6d44348c5f..b7325aff84 100644
--- a/src/sentry/models/eventerror.py
+++ b/src/sentry/models/eventerror.py
@@ -21,6 +21,7 @@ class dontexplodedict(object):
 class EventError(object):
     INVALID_DATA = 'invalid_data'
     INVALID_ATTRIBUTE = 'invalid_attribute'
+    MISSING_ATTRIBUTE = 'missing_attribute'
     VALUE_TOO_LONG = 'value_too_long'
     UNKNOWN_ERROR = 'unknown_error'
     SECURITY_VIOLATION = 'security_violation'
@@ -57,6 +58,7 @@ class EventError(object):
     _messages = {
         INVALID_DATA: u'Discarded invalid value for parameter \'{name}\'',
         INVALID_ATTRIBUTE: u'Discarded invalid parameter \'{name}\'',
+        MISSING_ATTRIBUTE: u'Missing value for required parameter \'{name}\'',
         VALUE_TOO_LONG: u'Discarded value for \'{name}\' due to exceeding maximum length',
         UNKNOWN_ERROR: u'Unknown error',
         SECURITY_VIOLATION: u'Cannot fetch resource due to security violation on {url}',
diff --git a/src/sentry/utils/json.py b/src/sentry/utils/json.py
index 8be41ce96c..ab54a3c747 100644
--- a/src/sentry/utils/json.py
+++ b/src/sentry/utils/json.py
@@ -37,6 +37,8 @@ def better_default_encoder(o):
         return list(o)
     elif isinstance(o, decimal.Decimal):
         return six.text_type(o)
+    elif callable(o):
+        return '<function>'
     raise TypeError(repr(o) + ' is not JSON serializable')
 
 
diff --git a/src/sentry/web/api.py b/src/sentry/web/api.py
index 2b3f48c5e5..36d1a41323 100644
--- a/src/sentry/web/api.py
+++ b/src/sentry/web/api.py
@@ -24,6 +24,7 @@ from sentry.coreapi import (
     APIError, APIForbidden, APIRateLimited, ClientApiHelper, CspApiHelper, LazyData,
     MinidumpApiHelper,
 )
+from sentry.interfaces import schemas
 from sentry.models import Project, OrganizationOption, Organization
 from sentry.signals import (
     event_accepted, event_dropped, event_filtered, event_received)
@@ -577,6 +578,11 @@ class MinidumpView(StoreView):
         )
 
 
+class StoreSchemaView(BaseView):
+    def get(self, request, **kwargs):
+        return HttpResponse(json.dumps(schemas.EVENT_SCHEMA), content_type='application/json')
+
+
 class CspReportView(StoreView):
     helper_cls = CspApiHelper
     content_types = ('application/csp-report', 'application/json')
diff --git a/src/sentry/web/urls.py b/src/sentry/web/urls.py
index 5555d67066..e380427841 100644
--- a/src/sentry/web/urls.py
+++ b/src/sentry/web/urls.py
@@ -121,6 +121,7 @@ urlpatterns += patterns(
         api.crossdomain_xml,
         name='sentry-api-crossdomain-xml'
     ),
+    url(r'^api/store/schema$', api.StoreSchemaView.as_view(), name='sentry-api-store-schema'),
 
     # The static version is either a 10 digit timestamp, a sha1, or md5 hash
     url(
diff --git a/tests/sentry/coreapi/tests.py b/tests/sentry/coreapi/tests.py
index 5143354f04..b4853fda26 100644
--- a/tests/sentry/coreapi/tests.py
+++ b/tests/sentry/coreapi/tests.py
@@ -219,9 +219,6 @@ class ValidateDataTest(BaseAPITest):
         assert data['errors'][0]['name'] == 'event_id'
         assert data['errors'][0]['value'] == 'xyz'
 
-    def test_invalid_event_id_raises(self):
-        self.assertRaises(APIError, self.helper.validate_data, self.project, {'event_id': 1})
-
     def test_unknown_attribute(self):
         data = self.helper.validate_data(self.project, {
             'message': 'foo',
@@ -325,11 +322,10 @@ class ValidateDataTest(BaseAPITest):
                 'tags': [('foo', 'bar'), ('biz', 'baz', 'boz')],
             }
         )
-        assert data['tags'] == [('foo', 'bar')]
         assert len(data['errors']) == 1
         assert data['errors'][0]['type'] == 'invalid_data'
         assert data['errors'][0]['name'] == 'tags'
-        assert data['errors'][0]['value'] == ('biz', 'baz', 'boz')
+        assert data['errors'][0]['value'] == [('foo', 'bar'), ('biz', 'baz', 'boz')]
 
     def test_reserved_tags(self):
         data = self.helper.validate_data(
@@ -364,9 +360,6 @@ class ValidateDataTest(BaseAPITest):
         })
         assert 'extra' not in data
 
-    def test_invalid_culprit_raises(self):
-        self.assertRaises(APIError, self.helper.validate_data, self.project, {'culprit': 1})
-
     def test_release_too_long(self):
         data = self.helper.validate_data(self.project, {
             'release': 'a' * 65,
@@ -542,6 +535,7 @@ class ValidateDataTest(BaseAPITest):
             'formatted': 'something else formatted'
         }
 
+    @pytest.mark.skip(reason="Message behavior that didn't make a lot of sense.")
     def test_messages_old_behavior(self):
         # both 'message' and complete valid interface but interface has the same
         # value for both keys so the 'formatted' value is discarded and ends up
diff --git a/tests/sentry/interfaces/test_csp.py b/tests/sentry/interfaces/test_csp.py
index 55f4dbd304..c5c0873535 100644
--- a/tests/sentry/interfaces/test_csp.py
+++ b/tests/sentry/interfaces/test_csp.py
@@ -144,9 +144,9 @@ class CspTest(TestCase):
         assert result.get_hash() == ['img-src', 'ftp://example.com']
 
     def test_get_tags(self):
-        assert self.interface.get_tags() == (
+        assert self.interface.get_tags() == [
             ('effective-directive', 'style-src'), ('blocked-uri', 'http://example.com/lol.css'),
-        )
+        ]
 
     def test_get_tags_stripe(self):
         result = Csp.to_python(
@@ -155,10 +155,10 @@ class CspTest(TestCase):
                 effective_directive='script-src',
             )
         )
-        assert result.get_tags() == (
+        assert result.get_tags() == [
             ('effective-directive', 'script-src'),
             ('blocked-uri', 'https://api.stripe.com/v1/tokens'),
-        )
+        ]
 
     def test_get_message(self):
         result = Csp.to_python(

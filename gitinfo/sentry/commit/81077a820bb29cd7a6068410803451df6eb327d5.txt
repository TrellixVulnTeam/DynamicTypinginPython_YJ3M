commit 81077a820bb29cd7a6068410803451df6eb327d5
Author: David Cramer <dcramer@David-Cramers-MacBook.local>
Date:   Tue Nov 10 11:21:08 2009 -0600

    Several fixes for nullable fields. Added logging handler which will automatically enable via DBLOG_WITH_LOGGING.  no longer has a type argument.

diff --git a/README.rst b/README.rst
index 3882903683..b10ac8d172 100644
--- a/README.rst
+++ b/README.rst
@@ -8,7 +8,7 @@ Logs Django exceptions to your database handler.
 Upgrading
 =========
 
-If you are upgrading from a version older than 1.3.0 you will need to update your database::
+The first thing you will want to do is confirm your database matches. Do this by verifying your version, or simply taking a look at the changes::
 
 	python manage.py sql djangodblog > dblog.sql
 	mysqldump -d --skip-opt -uroot -p yourdatabase djangodblog_error djangodblog_errorbatch > dblog.cur.sql
@@ -18,6 +18,13 @@ Note: the above example is using MySQL, and isn't going to give anywhere near a
 
 Review the diff, then make any changes which appear nescesary.
 
+###############
+Notable Changes
+###############
+
+* 1.4.0 Added `logger` column to both Error and ErrorBatch. `traceback` and `class_name` are now nullable.
+* 1.3.0 Added `level` column to both Error and ErrorBatch.
+
 =======
 Install
 =======
@@ -57,7 +64,9 @@ Several options exist to configure django-db-log via your ``settings.py``:
 DBLOG_CATCH_404_ERRORS
 ######################
 
-Enable catching of 404 errors in the logs. Default value is ``False``.
+Enable catching of 404 errors in the logs. Default value is ``False``::
+
+	DBLOG_CATCH_404_ERRORS = True
 
 ##############
 DBLOG_DATABASE
@@ -82,6 +91,32 @@ Some things to note:
 * You will need to create the tables by hand if you use this option. Use ``python manage.py sql djangodblog`` and dump that SQL into the correct server.
 * This functionality does not yet support Django 1.2.
 
+##################
+DBLOG_WITH_LOGGING
+##################
+
+django-db-log supports the ability to directly tie into your ``logging`` module entries. To use it simply define ``DBLOG_WITH_LOGGING=True`` in your ``settings.py``.
+
+Note: The `class_name` (also labeled `type`) will use the record's logger name value.
+
+You will also most likely want to configure the logging module, as you would in any logging situation, using something similar to::
+
+	DBLOG_WITH_LOGGING = True
+	
+	import logging
+	
+	logging.basicConfig(
+	    level=DEBUG and logging.DEBUG or logging.INFO,
+	    format='%(asctime)s %(levelname)-8s %(message)s',
+	    datefmt='%a, %d %b %Y %H:%M:%S',
+	)
+
+If you only want to use django-db-log's logging mechanism, you can remove the default handlers using something similar to::
+
+	logger = logging.getLogger()
+	for h in logger.handlers:
+	    logger.removeHandler(h)
+
 =====
 Usage
 =====
@@ -109,20 +144,20 @@ You can also record errors outside of middleware if you want::
 	except Exception, exc:
 		Error.objects.create_from_exception(exc, [url=None])
 
-If you wish to log normal messages (useful for ``logging`` integration):
+If you wish to log normal messages (useful for non-``logging`` integration):
 
 	from djangodblog.models import Error
 	import logging
 	
-	Error.objects.create_from_text('Error Type', 'Error Message'[, level=logging.WARNING, url=None])
+	Error.objects.create_from_text('Error Message'[, level=logging.WARNING, url=None])
 
 Both the ``url`` and ``level`` parameters are optional. ``level`` should be one of the following:
 
-* logging.DEBUG
-* logging.INFO
-* logging.WARNING
-* logging.ERROR
-* logging.FATAL
+* ``logging.DEBUG``
+* ``logging.INFO``
+* ``logging.WARNING``
+* ``logging.ERROR``
+* ``logging.FATAL``
 
 =====
 Notes
diff --git a/djangodblog/__init__.py b/djangodblog/__init__.py
index a0e4b2fc1d..f74441f391 100644
--- a/djangodblog/__init__.py
+++ b/djangodblog/__init__.py
@@ -1 +1 @@
-__version__ = (1, 3, 1)
\ No newline at end of file
+__version__ = (1, 4, 0)
\ No newline at end of file
diff --git a/djangodblog/admin.py b/djangodblog/admin.py
index aa3bcd59ba..efb4baa884 100644
--- a/djangodblog/admin.py
+++ b/djangodblog/admin.py
@@ -3,13 +3,13 @@ from django.contrib import admin
 from models import ErrorBatch, Error
 
 class ErrorBatchAdmin(admin.ModelAdmin):
-    list_display    = ('class_name', 'status', 'message', 'last_seen', 'times_seen', 'url', 'server_name')
-    list_filter     = ('class_name', 'server_name', 'status')
+    list_display    = ('logger', 'class_name', 'status', 'message', 'last_seen', 'times_seen', 'url', 'server_name')
+    list_filter     = ('logger', 'class_name', 'server_name', 'status')
     ordering        = ('status', '-last_seen')
 
 class ErrorAdmin(admin.ModelAdmin):
-    list_display    = ('class_name', 'message', 'datetime', 'url', 'server_name')
-    list_filter     = ('class_name', 'datetime', 'server_name')
+    list_display    = ('logger', 'class_name', 'message', 'datetime', 'url', 'server_name')
+    list_filter     = ('logger', 'class_name', 'datetime', 'server_name')
     ordering        = ('-datetime',)
 
 admin.site.register(ErrorBatch, ErrorBatchAdmin)
diff --git a/djangodblog/handlers.py b/djangodblog/handlers.py
new file mode 100644
index 0000000000..172ea5e99a
--- /dev/null
+++ b/djangodblog/handlers.py
@@ -0,0 +1,12 @@
+from models import Error
+
+from django.conf import settings
+
+import logging
+
+class DBLogHandler(logging.Handler):
+    def emit(self, record):
+        Error.objects.create_from_record(record)
+    
+if getattr(settings, 'DBLOG_WITH_LOGGING', False):
+    logging.getLogger().addHandler(DBLogHandler())
\ No newline at end of file
diff --git a/djangodblog/manager.py b/djangodblog/manager.py
index 6f30d8fdd5..db2e557889 100644
--- a/djangodblog/manager.py
+++ b/djangodblog/manager.py
@@ -111,27 +111,25 @@ class DBLogManager(models.Manager):
             del savepoint_state[thread_ident]
         return ret
 
-    def create_from_text(self, type, message, level=logging.FATAL, url=None):
+    def _create(self, **defaults):
         from models import Error, ErrorBatch
-
+        
         server_name = socket.gethostname()
-        checksum    = md5_constructor(str(level))
-        checksum.update(type)
-        checksum.update(message)
+        class_name  = defaults.pop('class_name', None)
+        checksum    = md5_constructor(str(defaults.get('level', logging.FATAL)))
+        checksum.update(class_name or '')
+        checksum.update(defaults.get('traceback') or defaults['message'])
         checksum    = checksum.hexdigest()
-        
-        defaults = dict(
-            class_name  = type,
-            message     = smart_unicode(message),
-            url         = url,
-            server_name = server_name,
-        )
 
         try:
-            instance = Error.objects.create(**defaults)
+            instance = Error.objects.create(
+                class_name=class_name,
+                server_name=server_name,
+                **defaults
+            )
             batch, created = ErrorBatch.objects.get_or_create(
-                class_name = defaults['class_name'],
-                server_name = defaults['server_name'],
+                class_name = class_name,
+                server_name = server_name,
                 checksum = checksum,
                 defaults = defaults
             )
@@ -144,40 +142,35 @@ class DBLogManager(models.Manager):
             warnings.warn(smart_unicode(exc))
         else:
             return instance
-        
-    def create_from_exception(self, exception, url=None):
-        from models import Error, ErrorBatch
-        
-        server_name = socket.gethostname()
-        tb_text     = traceback.format_exc()
-        class_name  = exception.__class__.__name__
-        checksum    = md5_constructor(str(logging.FATAL))
-        checksum.update(class_name)
-        checksum.update(tb_text)
-        checksum    = checksum.hexdigest()
-
-        defaults = dict(
-            class_name  = class_name,
-            message     = smart_unicode(exception),
-            url         = url,
-            server_name = server_name,
-            traceback   = tb_text,
+    
+    def create_from_record(self, record, **kwargs):
+        """
+        Creates an error log for a `logging` module `record` instance.
+        """
+        return self._create(
+            logger=record.name,
+            level=record.levelno,
+            traceback=record.exc_text,
+            message=record.getMessage(),
+            **kwargs
         )
 
-        try:
-            instance = Error.objects.create(**defaults)
-            batch, created = ErrorBatch.objects.get_or_create(
-                class_name = defaults['class_name'],
-                server_name = defaults['server_name'],
-                checksum = checksum,
-                defaults = defaults
-            )
-            if not created:
-                batch.times_seen += 1
-                batch.status = 0
-                batch.last_seen = datetime.datetime.now()
-                batch.save()
-        except Exception, exc:
-            warnings.warn(smart_unicode(exc))
-        else:
-            return instance
\ No newline at end of file
+    def create_from_text(self, message, **kwargs):
+        """
+        Creates an error log for from `type` and `message`.
+        """
+        return self._create(
+            message=message,
+            **kwargs
+        )
+    
+    def create_from_exception(self, exception, **kwargs):
+        """
+        Creates an error log from an `exception` instance.
+        """
+        return self._create(
+            class_name=exception.__class__.__name__,
+            traceback=traceback.format_exc(),
+            message=smart_unicode(exception),
+            **kwargs
+        )
\ No newline at end of file
diff --git a/djangodblog/models.py b/djangodblog/models.py
index 95da167167..e09a782bfc 100644
--- a/djangodblog/models.py
+++ b/djangodblog/models.py
@@ -29,8 +29,9 @@ STATUS_LEVELS = (
 )
 
 class ErrorBatch(Model):
-    class_name      = models.CharField(_('type'), max_length=128)
-    level           = models.PositiveIntegerField(choices=LOG_LEVELS, default=logging.ERROR, blank=True)
+    logger          = models.CharField(max_length=64, blank=True, default='root', db_index=True)
+    class_name      = models.CharField(_('type'), max_length=128, blank=True, null=True)
+    level           = models.PositiveIntegerField(choices=LOG_LEVELS, default=logging.ERROR, blank=True, db_index=True)
     message         = models.TextField()
     traceback       = models.TextField(blank=True, null=True)
     # XXX: We're using the legacy column for `is_resolved` for status
@@ -45,15 +46,16 @@ class ErrorBatch(Model):
     objects         = DBLogManager()
 
     class Meta:
-        unique_together = (('class_name', 'server_name', 'checksum'),)
+        unique_together = (('logger', 'class_name', 'server_name', 'checksum'),)
         verbose_name_plural = 'Error batches'
     
     def __unicode__(self):
         return "(%s) %s: %s" % (self.times_seen, self.class_name, self.message)
 
 class Error(Model):
-    class_name      = models.CharField(_('type'), max_length=128)
-    level           = models.PositiveIntegerField(choices=LOG_LEVELS, default=logging.FATAL, blank=True)
+    logger          = models.CharField(max_length=64, blank=True, default='root', db_index=True)
+    class_name      = models.CharField(_('type'), max_length=128, blank=True, null=True)
+    level           = models.PositiveIntegerField(choices=LOG_LEVELS, default=logging.FATAL, blank=True, db_index=True)
     message         = models.TextField()
     traceback       = models.TextField(blank=True, null=True)
     datetime        = models.DateTimeField(default=datetime.datetime.now)
diff --git a/djangodblog/tests.py b/djangodblog/tests.py
index c31d406408..4f991abbc2 100644
--- a/djangodblog/tests.py
+++ b/djangodblog/tests.py
@@ -2,10 +2,13 @@ from django.test.client import Client
 from django.test import TestCase
 from django.core.handlers.wsgi import WSGIRequest
 from django.conf import settings
+from django.utils.encoding import smart_unicode
 
 from models import Error, ErrorBatch
 from middleware import DBLogMiddleware
 
+import logging
+
 class RequestFactory(Client):
     # Used to generate request objects.
     def request(self, **request):
@@ -28,12 +31,55 @@ RF = RequestFactory()
 class DBLogTestCase(TestCase):
     def setUp(self):
         settings.DBLOG_DATABASE = None
+        settings.DBLOG_WITH_LOGGER = False
+
+    def testLogger(self):
+        from handlers import DBLogHandler
+        
+        Error.objects.all().delete()
+        ErrorBatch.objects.all().delete()
+
+        logging.getLogger().addHandler(DBLogHandler())
+
+        logging.error('This is a test error')
+        cur = (Error.objects.count(), ErrorBatch.objects.count())
+        self.assertEquals(cur, (1, 1), 'Assumed logs failed to save. %s' % (cur,))
+        last = Error.objects.all().order_by('-id')[0:1].get()
+        self.assertEquals(last.logger, 'root')
+        self.assertEquals(last.level, logging.ERROR)
+        self.assertEquals(last.message, 'This is a test error')
+
+        logging.warning('This is a test warning')
+        cur = (Error.objects.count(), ErrorBatch.objects.count())
+        self.assertEquals(cur, (2, 2), 'Assumed logs failed to save. %s' % (cur,))
+        last = Error.objects.all().order_by('-id')[0:1].get()
+        self.assertEquals(last.logger, 'root')
+        self.assertEquals(last.level, logging.WARNING)
+        self.assertEquals(last.message, 'This is a test warning')
+        
+        logging.error('This is a test error')
+        cur = (Error.objects.count(), ErrorBatch.objects.count())
+        self.assertEquals(cur, (3, 2), 'Assumed logs failed to save. %s' % (cur,))
+        last = Error.objects.all().order_by('-id')[0:1].get()
+        self.assertEquals(last.logger, 'root')
+        self.assertEquals(last.level, logging.ERROR)
+        self.assertEquals(last.message, 'This is a test error')
+    
+        logger = logging.getLogger('test')
+        logger.info('This is a test info')
+        cur = (Error.objects.count(), ErrorBatch.objects.count())
+        self.assertEquals(cur, (4, 3), 'Assumed logs failed to save. %s' % (cur,))
+        last = Error.objects.all().order_by('-id')[0:1].get()
+        self.assertEquals(last.logger, 'test')
+        self.assertEquals(last.level, logging.INFO)
+        self.assertEquals(last.message, 'This is a test info')
     
     def testMiddleware(self):
+        Error.objects.all().delete()
+        ErrorBatch.objects.all().delete()
+        
         request = RF.get("/", REMOTE_ADDR="127.0.0.1:8000")
 
-        ttl = (Error.objects.count(), ErrorBatch.objects.count())
-
         try:
             Error.objects.get(id=999999999)
         except Error.DoesNotExist, exc:
@@ -41,21 +87,42 @@ class DBLogTestCase(TestCase):
         else:
             self.fail('Unable to create `Error` entry.')
         
-        cur = (Error.objects.count()-1, ErrorBatch.objects.count()-1)
-        self.assertEquals(cur, ttl, 'Counts do not match. Assumed logs failed to save. %s != %s' % (cur, ttl))
+        cur = (Error.objects.count(), ErrorBatch.objects.count())
+        self.assertEquals(cur, (1, 1), 'Assumed logs failed to save. %s' % (cur,))
+        last = Error.objects.all().order_by('-id')[0:1].get()
+        self.assertEquals(last.logger, 'root')
+        self.assertEquals(last.class_name, 'DoesNotExist')
+        self.assertEquals(last.level, logging.FATAL)
+        self.assertEquals(last.message, smart_unicode(exc))
         
     def testAPI(self):
-        ttl = (Error.objects.count(), ErrorBatch.objects.count())
+        Error.objects.all().delete()
+        ErrorBatch.objects.all().delete()
 
         try:
-            Error.objects.get(id=999999999)
+            Error.objects.get(id=999999989)
         except Error.DoesNotExist, exc:
             Error.objects.create_from_exception(exc)
         else:
             self.fail('Unable to create `Error` entry.')
         
-        cur = (Error.objects.count()-1, ErrorBatch.objects.count()-1)
-        self.assertEquals(cur, ttl, 'Counts do not match. Assumed logs failed to save. %s != %s' % (cur, ttl))
+        cur = (Error.objects.count(), ErrorBatch.objects.count())
+        self.assertEquals(cur, (1, 1), 'Assumed logs failed to save. %s' % (cur,))
+        last = Error.objects.all().order_by('-id')[0:1].get()
+        self.assertEquals(last.logger, 'root')
+        self.assertEquals(last.class_name, 'DoesNotExist')
+        self.assertEquals(last.level, logging.FATAL)
+        self.assertEquals(last.message, smart_unicode(exc))
+        
+        Error.objects.create_from_text('This is an error', level=logging.DEBUG)
+        
+        cur = (Error.objects.count(), ErrorBatch.objects.count())
+        self.assertEquals(cur, (2, 2), 'Assumed logs failed to save. %s' % (cur,))
+        last = Error.objects.all().order_by('-id')[0:1].get()
+        self.assertEquals(last.logger, 'root')
+        self.assertEquals(last.level, logging.DEBUG)
+        self.assertEquals(last.message, 'This is an error')
+        
         
     def testAlternateDatabase(self):
         settings.DBLOG_DATABASE = dict(
@@ -67,16 +134,22 @@ class DBLogTestCase(TestCase):
             DATABASE_OPTIONS=settings.DATABASE_OPTIONS,
         )
         
-        ttl = (Error.objects.count(), ErrorBatch.objects.count())
+        Error.objects.all().delete()
+        ErrorBatch.objects.all().delete()
 
         try:
-            Error.objects.get(id=999999999)
+            Error.objects.get(id=999999979)
         except Error.DoesNotExist, exc:
             Error.objects.create_from_exception(exc)
         else:
             self.fail('Unable to create `Error` entry.')
             
-        cur = (Error.objects.count()-1, ErrorBatch.objects.count()-1)
-        self.assertEquals(cur, ttl, 'Counts do not match. Assumed logs failed to save. %s != %s' % (cur, ttl))
+        cur = (Error.objects.count(), ErrorBatch.objects.count())
+        self.assertEquals(cur, (1, 1), 'Assumed logs failed to save. %s' % (cur,))
+        last = Error.objects.all().order_by('-id')[0:1].get()
+        self.assertEquals(last.logger, 'root')
+        self.assertEquals(last.class_name, 'DoesNotExist')
+        self.assertEquals(last.level, logging.FATAL)
+        self.assertEquals(last.message, smart_unicode(exc))
 
         settings.DBLOG_DATABASE = None
\ No newline at end of file

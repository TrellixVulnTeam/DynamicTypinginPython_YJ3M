commit bbe83f8f2f068588833e90acbf2fbc2163b26d1a
Author: Armin Ronacher <armin.ronacher@active-4.com>
Date:   Sun Jan 15 17:28:10 2017 +0100

    First pass on switch to new processing interface

diff --git a/src/sentry/event_manager.py b/src/sentry/event_manager.py
index ec30446626..df78da4ee4 100644
--- a/src/sentry/event_manager.py
+++ b/src/sentry/event_manager.py
@@ -593,7 +593,7 @@ class EventManager(object):
             },
         })
 
-        processing_issues = data.pop('processing_issues', [])
+        processing_issues = data.pop('processing_issues', None)
 
         if release:
             release = Release.get_or_create(
diff --git a/src/sentry/lang/native/plugin.py b/src/sentry/lang/native/plugin.py
index 64a0ffd587..278a958657 100644
--- a/src/sentry/lang/native/plugin.py
+++ b/src/sentry/lang/native/plugin.py
@@ -2,7 +2,6 @@ from __future__ import absolute_import
 
 import os
 import re
-import sys
 import six
 import time
 import logging
@@ -13,12 +12,12 @@ from symsynd.demangle import demangle_symbol
 from sentry.models import Project, EventError
 from sentry.plugins import Plugin2
 from sentry.lang.native.symbolizer import Symbolizer, SymbolicationFailed
-from sentry.lang.native.utils import find_all_stacktraces, update_stacktrace, \
+from sentry.lang.native.utils import \
     find_apple_crash_report_referenced_images, get_sdk_from_event, \
     find_stacktrace_referenced_images, get_sdk_from_apple_system_info, \
     APPLE_SDK_MAPPING
 from sentry.utils.native import parse_addr
-from sentry.reprocessing import record_processing_issue
+from sentry.stacktraces import StacktraceProcessor
 
 
 logger = logging.getLogger(__name__)
@@ -344,126 +343,101 @@ def preprocess_apple_crash_event(data):
     return data
 
 
-def resolve_frame_symbols(data):
-    debug_meta = data['debug_meta']
-    debug_images = debug_meta['images']
-    is_debug_build = debug_meta.get('is_debug_build')
-    sdk_info = get_sdk_from_event(data)
-
-    stacktraces = find_all_stacktraces(data)
-    if not stacktraces:
-        return
-
-    project = Project.objects.get_from_cache(
-        id=data['project'],
-    )
-
-    errors = []
-    referenced_images = find_stacktrace_referenced_images(
-        debug_images, [x[0] for x in stacktraces])
-    sym = Symbolizer(project, debug_images,
-                     referenced_images=referenced_images,
-                     is_debug_build=is_debug_build)
-
-    frame = None
-    idx = -1
-
-    def report_error(exc_type, exc_value, tb):
-        e = exc_value
-        if e.is_user_fixable or e.is_sdk_failure:
-            errors.append({
-                'type': EventError.NATIVE_INTERNAL_FAILURE,
-                'frame': frame,
-                'error': u'frame #%d: %s' % (idx, e)
-            })
-            record_processing_issue(data, 'native', 'dsym:%s' % e.image_uuid, data={
-                'image_uuid': e.image_uuid,
-                'image_path': e.image_path,
-                'image_arch': e.image_arch,
-                'type': e.type,
-                'message': e.message,
-            })
-        if not exc_value.is_user_fixable:
-            logger.debug('Failed to symbolicate',
-                         exc_info=(exc_type, exc_value, tb))
-
-    with sym:
-        for stacktrace, container in stacktraces:
-            store_raw = False
-
-            new_frames = list(stacktrace['frames'])
-            for idx, frame in enumerate(stacktrace['frames']):
-                if 'image_addr' not in frame or \
-                   'instruction_addr' not in frame or \
-                   'symbol_addr' not in frame:
-                    continue
-                try:
-                    # Construct a raw frame that is used by the symbolizer
-                    # backend.
-                    raw_frame = {
-                        'object_name': frame.get('package'),
-                        'object_addr': frame['image_addr'],
-                        'instruction_addr': frame['instruction_addr'],
-                        'symbol_name': frame.get('function'),
-                        'symbol_addr': frame['symbol_addr'],
-                    }
-                    new_frame = dict(frame)
-
-                    try:
-                        sfrm = sym.symbolize_frame(raw_frame, sdk_info)
-                    except SymbolicationFailed:
-                        report_error(*sys.exc_info())
-                    else:
-                        symbol = sfrm.get('symbol_name') or \
-                            new_frame.get('function') or '<unknown>'
-                        function = demangle_symbol(symbol, simplified=True)
-
-                        new_frame['function'] = function
-
-                        # If we demangled something, store the original in the
-                        # symbol portion of the frame
-                        if function != symbol:
-                            new_frame['symbol'] = symbol
-
-                        new_frame['abs_path'] = sfrm.get('filename') or None
-                        if new_frame['abs_path']:
-                            new_frame['filename'] = posixpath.basename(
-                                new_frame['abs_path'])
-                        if sfrm.get('line') is not None:
-                            new_frame['lineno'] = sfrm['line']
-                        else:
-                            new_frame['instruction_offset'] = \
-                                parse_addr(sfrm['instruction_addr']) - \
-                                parse_addr(sfrm['symbol_addr'])
-                        if sfrm.get('column') is not None:
-                            new_frame['colno'] = sfrm['column']
-                        new_frame['package'] = sfrm['object_name'] \
-                            or new_frame.get('package')
-                        new_frame['symbol_addr'] = '0x%x' % \
-                            parse_addr(sfrm['symbol_addr'])
-                        new_frame['instruction_addr'] = '0x%x' % parse_addr(
-                            sfrm['instruction_addr'])
-
-                    conceptionally_different = new_frame != frame
-                    new_frame['in_app'] = sym.is_in_app(raw_frame)
-                    if new_frame != frame:
-                        new_frames[idx] = new_frame
-                        if conceptionally_different:
-                            store_raw = True
-                except Exception:
-                    logger.exception('Failed to symbolicate')
-                    errors.append({
-                        'type': EventError.NATIVE_INTERNAL_FAILURE,
-                        'error': 'The symbolicator encountered an internal failure',
-                    })
-
-            update_stacktrace(stacktrace, new_frames, container=container,
-                              store_raw=store_raw)
-
-    if errors:
-        data.setdefault('errors', []).extend(errors)
+class NativeStacktraceProcessor(StacktraceProcessor):
+
+    def __init__(self, data, stacktrace_infos):
+        StacktraceProcessor.__init__(self, data, stacktrace_infos)
+        debug_meta = data.get('debug_meta')
+        if debug_meta:
+            self.sdk_info = get_sdk_from_event(data)
+            is_debug_build = debug_meta.get('is_debug_build')
+            referenced_images = find_stacktrace_referenced_images(
+                debug_meta['images'], [x.stacktrace for x in stacktrace_infos])
+            self.sym = Symbolizer(self.project, debug_meta['images'],
+                                  referenced_images=referenced_images,
+                                  is_debug_build=is_debug_build)
+            self.available = True
+        else:
+            self.available = False
+
+    def close(self):
+        StacktraceProcessor.close(self)
+        self.sym.close()
+
+    def process_frame(self, frame):
+        # XXX: warn on missing availability?
+
+        # Only process frames here that are of supported platforms and
+        # have the mandatory requirements for
+        if not self.available or \
+           self.get_effective_platform(frame) != 'cocoa' or \
+           'image_addr' not in frame or \
+           'instruction_addr' not in frame or \
+           'symbol_addr' not in frame:
+            return None
+
+        errors = []
+
+        # Construct a raw frame that is used by the symbolizer
+        # backend.
+        sym_frame = {
+            'object_name': frame.get('package'),
+            'object_addr': frame['image_addr'],
+            'instruction_addr': frame['instruction_addr'],
+            'symbol_name': frame.get('function'),
+            'symbol_addr': frame['symbol_addr'],
+        }
+        new_frame = dict(frame)
+        raw_frame = dict(frame)
 
-    return data
+        try:
+            sfrm = self.sym.symbolize_frame(sym_frame, self.sdk_info)
+        except SymbolicationFailed as e:
+            if e.is_user_fixable or e.is_sdk_failure:
+                errors.append({
+                    'type': EventError.NATIVE_INTERNAL_FAILURE,
+                    'image_uuid': e.image_uuid,
+                    'image_path': e.image_path,
+                    'image_arch': e.image_arch,
+                    'message': e.message,
+                })
+            else:
+                logger.debug('Failed to symbolicate with native backend',
+                             exc_info=True)
+        else:
+            symbol = sfrm.get('symbol_name') or \
+                new_frame.get('function') or '<unknown>'
+            function = demangle_symbol(symbol, simplified=True)
+
+            new_frame['function'] = function
+
+            # If we demangled something, store the original in the
+            # symbol portion of the frame
+            if function != symbol:
+                new_frame['symbol'] = symbol
+
+            new_frame['abs_path'] = sfrm.get('filename') or None
+            if new_frame['abs_path']:
+                new_frame['filename'] = posixpath.basename(
+                    new_frame['abs_path'])
+            if sfrm.get('line') is not None:
+                new_frame['lineno'] = sfrm['line']
+            else:
+                new_frame['instruction_offset'] = \
+                    parse_addr(sfrm['instruction_addr']) - \
+                    parse_addr(sfrm['symbol_addr'])
+            if sfrm.get('column') is not None:
+                new_frame['colno'] = sfrm['column']
+            new_frame['package'] = sfrm['object_name'] \
+                or new_frame.get('package')
+            new_frame['symbol_addr'] = '0x%x' % \
+                parse_addr(sfrm['symbol_addr'])
+            new_frame['instruction_addr'] = '0x%x' % parse_addr(
+                sfrm['instruction_addr'])
+
+        in_app = self.sym.is_in_app(sym_frame)
+        new_frame['in_app'] = raw_frame['in_app'] = in_app
+        return [new_frame], [raw_frame], errors
 
 
 class NativePlugin(Plugin2):
@@ -473,6 +447,9 @@ class NativePlugin(Plugin2):
         rv = []
         if data.get('sentry.interfaces.AppleCrashReport'):
             rv.append(preprocess_apple_crash_event)
-        if data.get('debug_meta'):
-            rv.append(resolve_frame_symbols)
         return rv
+
+    def get_stacktrace_processors(self, data, stacktrace_infos,
+                                  platforms, **kwargs):
+        if 'cocoa' in platforms:
+            return NativeStacktraceProcessor(data, stacktrace_infos)
diff --git a/src/sentry/lang/native/symbolizer.py b/src/sentry/lang/native/symbolizer.py
index b9fa928d9d..c82763980e 100644
--- a/src/sentry/lang/native/symbolizer.py
+++ b/src/sentry/lang/native/symbolizer.py
@@ -14,6 +14,11 @@ from sentry.models import DSymSymbol, EventError
 from sentry.constants import MAX_SYM
 
 
+USER_FIXABLE_ERRORS = (
+    EventError.NATIVE_MISSING_DSYM,
+    EventError.NATIVE_BAD_DSYM,
+    EventError.NATIVE_MISSING_SYMBOL,
+)
 APP_BUNDLE_PATHS = (
     '/var/containers/Bundle/Application/',
     '/private/var/containers/Bundle/Application/',
@@ -58,8 +63,7 @@ class SymbolicationFailed(Exception):
     @property
     def is_user_fixable(self):
         """These are errors that a user can fix themselves."""
-        return self.type in ('missing-dsym', 'bad-dsym',
-                             'missing-symbol')
+        return self.type in USER_FIXABLE_ERRORS
 
     @property
     def is_sdk_failure(self):
@@ -132,11 +136,8 @@ class Symbolizer(object):
         self.images = dict((img['image_addr'], img) for img in binary_images)
         self.is_debug_build = is_debug_build
 
-    def __enter__(self):
-        return self.symsynd_symbolizer.driver.__enter__()
-
-    def __exit__(self, *args):
-        return self.symsynd_symbolizer.driver.__exit__(*args)
+    def close(self):
+        self.symsynd_symbolizer.close()
 
     def _process_frame(self, frame, img):
         rv = trim_frame(frame)
@@ -188,9 +189,9 @@ class Symbolizer(object):
     def symbolize_app_frame(self, frame, img):
         if frame['object_addr'] not in self.symsynd_symbolizer.images:
             if self._is_optional_app_bundled_framework(frame, img):
-                type = 'missing-optionally-bundled-dsym'
+                type = EventError.NATIVE_MISSING_OPTIONALLY_BUNDLED_DSYM
             else:
-                type = 'missing-dsym'
+                type = EventError.NATIVE_MISSING_DSYM
             raise SymbolicationFailed(
                 type=type,
                 image=img
@@ -201,14 +202,14 @@ class Symbolizer(object):
                 frame, silent=False, demangle=False)
         except SymbolicationError as e:
             raise SymbolicationFailed(
-                type='bad-dsym',
+                type=EventError.NATIVE_BAD_DSYM,
                 message=six.text_type(e),
                 image=img
             )
 
         if new_frame is None:
             raise SymbolicationFailed(
-                type='missing-symbol',
+                type=EventError.NATIVE_MISSING_SYMBOL,
                 image=img
             )
 
@@ -220,9 +221,9 @@ class Symbolizer(object):
         if symbol is None:
             # Simulator frames cannot be symbolicated
             if self._is_simulator_frame(frame, img):
-                type = 'simulator-frame'
+                type = EventError.NATIVE_SIMULATOR_FRAME
             else:
-                type = 'missing-system-dsym'
+                type = EventError.NATIVE_MISSING_SYSTEM_DSYM
             raise SymbolicationFailed(
                 type=type,
                 image=img
@@ -237,7 +238,7 @@ class Symbolizer(object):
         img = self.images.get(frame['object_addr'])
         if img is None:
             raise SymbolicationFailed(
-                type='unknown-image'
+                type=EventError.NATIVE_UNKNOWN_IMAGE
             )
 
         # If we are dealing with a frame that is not bundled with the app
diff --git a/src/sentry/models/eventerror.py b/src/sentry/models/eventerror.py
index a516fa85fa..a729245b78 100644
--- a/src/sentry/models/eventerror.py
+++ b/src/sentry/models/eventerror.py
@@ -39,6 +39,13 @@ class EventError(object):
     NATIVE_NO_CRASHED_THREAD = 'native_no_crashed_thread'
     NATIVE_INTERNAL_FAILURE = 'native_internal_failure'
     NATIVE_NO_SYMSYND = 'native_no_symsynd'
+    NATIVE_BAD_DSYM = 'native_bad_dsym'
+    NATIVE_MISSING_OPTIONALLY_BUNDLED_DSYM = 'native_optionally_bundled_dsym'
+    NATIVE_MISSING_DSYM = 'native_missing_dsym'
+    NATIVE_MISSING_SYSTEM_DSYM = 'native_missing_system_dsym'
+    NATIVE_MISSING_SYMBOL = 'native_missing_symbol'
+    NATIVE_SIMULATOR_FRAME = 'native_simulator_frame'
+    NATIVE_UNKNOWN_IMAGE = 'native_unknown_image'
 
     _messages = {
         INVALID_DATA: u'Discarded invalid value for parameter \'{name}\'',
diff --git a/src/sentry/plugins/base/v2.py b/src/sentry/plugins/base/v2.py
index 219bd34b15..4ae10c717a 100644
--- a/src/sentry/plugins/base/v2.py
+++ b/src/sentry/plugins/base/v2.py
@@ -365,6 +365,23 @@ class IPlugin2(local, PluginConfigMixin):
         """
         return []
 
+    def get_stacktrace_processors(self, data, stacktrace, platforms, **kwargs):
+        """
+        This works similarly to `get_event_preprocessors` but returns a
+        function that is invoked for all encountered stacktraces in an
+        event.
+
+        Preprocessors should not be returned if there is nothing to
+        do with the event data.
+
+        :::
+
+            def get_stacktrace_processors(self, data, stacktrace_infos,
+                                          platforms, **kwargs):
+                if 'cocoa' in platforms:
+                    return [CocoaProcessor(data, stacktrace_infos)]
+        """
+
     def get_feature_hooks(self, **kwargs):
         """
         Return a list of callables to check for feature status.
diff --git a/src/sentry/reprocessing.py b/src/sentry/reprocessing.py
index 4ad0abf336..4c65763379 100644
--- a/src/sentry/reprocessing.py
+++ b/src/sentry/reprocessing.py
@@ -13,13 +13,16 @@ def record_processing_issue(event_data, type, key, release_bound=True,
     """
     if hold_group:
         event_data['unprocessed'] = True
-    event_data.setdefault('processing_issues', []).append({
+    issue = {
         'type': type,
         'key': key,
         'release_bound': release_bound,
         'issue_data': data or {},
         'group_data': group_data or {},
-    })
+    }
+    issues = event_data.setdefault('processing_issues', [])
+    if issue not in issues:
+        issues.append(issue)
 
 
 def resolve_processing_issue(project, type, key=None):
diff --git a/src/sentry/stacktraces.py b/src/sentry/stacktraces.py
new file mode 100644
index 0000000000..7504430be9
--- /dev/null
+++ b/src/sentry/stacktraces.py
@@ -0,0 +1,176 @@
+from __future__ import absolute_import
+
+import logging
+
+from sentry.models import Project
+from sentry.utils.safe import safe_execute
+
+
+logger = logging.getLogger(__name__)
+
+
+class StacktraceInfo(object):
+    """A wrapper around a stacktrace that was extracted from event
+    data.
+    """
+
+    def __init__(self, stacktrace, container=None, platforms=None):
+        self.stacktrace = stacktrace
+        self.container = container
+        self.platforms = platforms
+
+
+class StacktraceProcessor(object):
+
+    def __init__(self, data, stacktrace_infos):
+        self.data = data
+        self.stacktrace_infos = stacktrace_infos
+        self.project = Project.objects.get_from_cache(
+            id=data['project']
+        )
+
+    def close(self):
+        pass
+
+    def get_effective_platform(self, frame):
+        return frame.get('platform') or self.data['platform']
+
+    def process_frame(self, frame):
+        pass
+
+
+class FrameError(object):
+
+    def __init__(self, type=None, key=None, data=None,
+                 record_processing_issue=False, release_bound=True):
+        self.type = type
+        self.key = key
+        self.data = data
+        self.record_processing_issue = record_processing_issue
+        self.release_bound = release_bound
+
+
+def find_stacktraces_in_data(data):
+    """Finds all stracktraces in a given data blob and returns it
+    together with some meta information.
+    """
+    rv = []
+
+    def _report_stack(stacktrace, container):
+        platforms = set()
+        for frame in stacktrace.get('frames') or ():
+            platforms.add(frame.get('platform') or data['platform'])
+        rv.append(StacktraceInfo(
+            stacktrace=stacktrace,
+            container=container,
+            platforms=platforms
+        ))
+
+    exc_container = data.get('sentry.interfaces.Exception')
+    if exc_container:
+        for exc in exc_container['values']:
+            stacktrace = exc.get('stacktrace')
+            if stacktrace:
+                _report_stack(stacktrace, exc)
+
+    stacktrace = data.get('sentry.interfaces.Stacktrace')
+    if stacktrace:
+        _report_stack(stacktrace, None)
+
+    threads = data.get('threads')
+    if threads:
+        for thread in threads['values']:
+            stacktrace = thread.get('stacktrace')
+            if stacktrace:
+                _report_stack(stacktrace, thread)
+
+    return rv
+
+
+def get_processors_for_stacktraces(data, infos):
+    from sentry.plugins import plugins
+
+    platforms = set()
+    for info in infos:
+        platforms.update(info.platforms or ())
+
+    processors = []
+    for plugin in plugins.all(version=2):
+        processors.extend(safe_execute(plugin.get_stacktrace_processors,
+                                       data=data, stacktrace_infos=infos,
+                                       platforms=platforms,
+                                       _with_transaction=False) or ())
+
+    return processors
+
+
+def process_single_stacktrace(stacktrace_info, processors):
+    # TODO: associate errors with the frames and processing issues
+    changed_raw = False
+    changed_processed = False
+    raw_frames = []
+    processed_frames = []
+    all_errors = []
+
+    for frame in stacktrace_info.stacktrace['frames']:
+        need_processed_frame = True
+        need_raw_frame = True
+        errors = None
+        for processor in processors:
+            try:
+                rv = processor.process_frame(frame) or None, None, None
+            except Exception:
+                logger.exception('Failed to process frame')
+                continue
+
+            expand_processed, expand_raw, errors = rv
+            if expand_processed is not None:
+                processed_frames.extend(expand_processed)
+                changed_processed = True
+                need_processed_frame = False
+
+            if expand_raw is not None:
+                raw_frames.extend(expand_raw)
+                changed_raw = True
+                need_raw_frame = False
+
+            break
+
+        if need_processed_frame:
+            processed_frames.append(frame)
+        if need_raw_frame:
+            raw_frames.append(frame)
+        all_errors.extend(errors or ())
+
+    return (
+        dict(stacktrace_info.stacktrace,
+             frames=processed_frames) if changed_processed else None,
+        dict(stacktrace_info.stacktrace,
+             frames=raw_frames) if changed_raw else None,
+        all_errors,
+    )
+
+
+def process_stacktraces(data):
+    infos = find_stacktraces_in_data(data)
+    processors = get_processors_for_stacktraces(data, infos)
+    changed = False
+
+    for stacktrace_info in infos:
+        new_stacktrace, raw_stacktrace, errors = process_single_stacktrace(
+            stacktrace_info, processors)
+        if new_stacktrace is not None:
+            stacktrace_info.stacktrace.clear()
+            stacktrace_info.stacktrace.update(new_stacktrace)
+            changed = True
+        if raw_stacktrace is not None and \
+           stacktrace_info.container is not None:
+            stacktrace_info.container['raw_stacktrace'] = raw_stacktrace
+            changed = True
+        data.setdefault('errors', []).extend(errors or ())
+
+    for processor in processors:
+        processor.close()
+
+    if changed:
+        return data
diff --git a/src/sentry/tasks/store.py b/src/sentry/tasks/store.py
index 6b98f10218..14e08dac5a 100644
--- a/src/sentry/tasks/store.py
+++ b/src/sentry/tasks/store.py
@@ -22,6 +22,28 @@ from sentry.utils.safe import safe_execute
 error_logger = logging.getLogger('sentry.errors.events')
 
 
+def should_process(data):
+    """Quick check if processing is needed at all."""
+    from sentry.plugins import plugins
+    from sentry.models import Stacktrace
+
+    for plugin in plugins.all(version=2):
+        processors = safe_execute(plugin.get_event_preprocessors, data=data,
+                                  _with_transaction=False)
+        if processors:
+            return True
+
+        for info in Stacktrace.find_stacktraces_in_data(data):
+            processors = safe_execute(plugin.get_stacktrace_processors,
+                                      data=data, stacktrace=info['stacktrace'],
+                                      platforms=info['platforms'],
+                                      _with_transaction=False)
+            if processors:
+                return True
+
+    return False
+
+
 @instrumented_task(
     name='sentry.tasks.store.preprocess_event',
     queue='events.preprocess_event',
@@ -30,8 +52,6 @@ error_logger = logging.getLogger('sentry.errors.events')
 )
 def preprocess_event(cache_key=None, data=None, start_time=None,
                      reprocesses_event_id=None, **kwargs):
-    from sentry.plugins import plugins
-
     if cache_key:
         data = default_cache.get(cache_key)
 
@@ -45,17 +65,10 @@ def preprocess_event(cache_key=None, data=None, start_time=None,
         'project': project,
     })
 
-    # Iterate over all plugins looking for processors based on the input data
-    # plugins should yield a processor function only if it actually can operate
-    # on the input data, otherwise it should yield nothing
-    for plugin in plugins.all(version=2):
-        processors = safe_execute(plugin.get_event_preprocessors, data=data, _with_transaction=False)
-        for processor in (processors or ()):
-            # On the first processor found, we just defer to the process_event
-            # queue to handle the actual work.
-            process_event.delay(cache_key=cache_key, start_time=start_time,
-                                reprocesses_event_id=reprocesses_event_id)
-            return
+    if should_process(data):
+        process_event.delay(cache_key=cache_key, start_time=start_time,
+                            reprocesses_event_id=reprocesses_event_id)
+        return
 
     # If we get here, that means the event had no preprocessing needed to be done
     # so we can jump directly to save_event
@@ -74,6 +87,7 @@ def preprocess_event(cache_key=None, data=None, start_time=None,
 def process_event(cache_key, start_time=None, reprocesses_event_id=None,
                   **kwargs):
     from sentry.plugins import plugins
+    from sentry.models import Stacktrace
 
     data = default_cache.get(cache_key)
 
@@ -86,9 +100,24 @@ def process_event(cache_key, start_time=None, reprocesses_event_id=None,
     Raven.tags_context({
         'project': project,
     })
+    has_changed = False
+
+    # Stacktrace based event processors.  These run before anything else.
+    for plugin in plugins.all(version=2):
+        for info in Stacktrace.find_stacktraces_in_data(data):
+            processors = safe_execute(plugin.get_stacktrace_processors,
+                                      data=data, stacktrace=info['stacktrace'],
+                                      platforms=info['platforms'],
+                                      _with_transaction=False)
+            for processor in processors or ():
+                result = safe_execute(processor, data=data,
+                                      stacktrace=info['stacktrace'],
+                                      platforms=info['platforms'])
+                if result is None:
+                    continue
 
     # TODO(dcramer): ideally we would know if data changed by default
-    has_changed = False
+    # Default event processors.
     for plugin in plugins.all(version=2):
         processors = safe_execute(plugin.get_event_preprocessors, data=data, _with_transaction=False)
         for processor in (processors or ()):

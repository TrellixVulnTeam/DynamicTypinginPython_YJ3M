commit 22bf8d26f85deeb8d0e2f0e40506409fc484c4d1
Author: David Cramer <dcramer@gmail.com>
Date:   Fri Oct 10 13:00:42 2014 -0700

    Migrate search to cursors

diff --git a/src/sentry/api/base.py b/src/sentry/api/base.py
index 710e5ba6df..9517b21605 100644
--- a/src/sentry/api/base.py
+++ b/src/sentry/api/base.py
@@ -42,19 +42,18 @@ class Endpoint(APIView):
         assert per_page <= 100
 
         paginator = Paginator(**kwargs)
-        cursor = paginator.get_cursor(
+        cursor_result = paginator.get_result(
             limit=per_page,
             cursor=input_cursor,
         )
 
         # map results based on callback
-        results = on_results(cursor.results)
+        results = on_results(cursor_result.results)
 
-        links = []
-        if cursor.has_prev:
-            links.append(('previous', cursor.prev))
-        if cursor.has_next:
-            links.append(('next', cursor.next))
+        links = [
+            ('previous', str(cursor_result.prev)),
+            ('next', str(cursor_result.next)),
+        ]
 
         querystring = u'&'.join(
             u'{0}={1}'.format(quote(k), quote(v))
diff --git a/src/sentry/api/endpoints/group_events.py b/src/sentry/api/endpoints/group_events.py
index fc215b0dd5..019df39762 100644
--- a/src/sentry/api/endpoints/group_events.py
+++ b/src/sentry/api/endpoints/group_events.py
@@ -21,6 +21,7 @@ class GroupEventsEndpoint(Endpoint):
         return self.paginate(
             request=request,
             queryset=events,
-            order_by='-datetime',
+            # TODO(dcramer): we want to sort by datetime
+            order_by='-id',
             on_results=lambda x: serialize(x, request.user),
         )
diff --git a/src/sentry/api/endpoints/group_notes.py b/src/sentry/api/endpoints/group_notes.py
index f3802bb603..4c90259180 100644
--- a/src/sentry/api/endpoints/group_notes.py
+++ b/src/sentry/api/endpoints/group_notes.py
@@ -33,7 +33,8 @@ class GroupNotesEndpoint(Endpoint):
         return self.paginate(
             request=request,
             queryset=notes,
-            order_by='-datetime',
+            # TODO(dcramer): we want to sort by datetime
+            order_by='-id',
             on_results=lambda x: serialize(x, request.user),
         )
 
diff --git a/src/sentry/api/endpoints/project_group_index.py b/src/sentry/api/endpoints/project_group_index.py
index ac4a349b1e..c447535c6a 100644
--- a/src/sentry/api/endpoints/project_group_index.py
+++ b/src/sentry/api/endpoints/project_group_index.py
@@ -16,6 +16,7 @@ from sentry.models import (
     Activity, Group, GroupBookmark, GroupMeta, GroupStatus, Project, TagKey
 )
 from sentry.search.utils import parse_query
+from sentry.utils.cursors import Cursor
 from sentry.utils.dates import parse_date
 
 
@@ -95,7 +96,7 @@ class ProjectGroupIndexEndpoint(Endpoint):
         # TODO: proper pagination support
         cursor = request.GET.get('cursor')
         if cursor:
-            query_kwargs['cursor'] = cursor
+            query_kwargs['cursor'] = Cursor.from_string(cursor)
 
         query = request.GET.get('query', 'is:unresolved')
         if query is not None:
diff --git a/src/sentry/api/endpoints/project_releases.py b/src/sentry/api/endpoints/project_releases.py
index f05a7f0500..581366dbb6 100644
--- a/src/sentry/api/endpoints/project_releases.py
+++ b/src/sentry/api/endpoints/project_releases.py
@@ -21,6 +21,7 @@ class ProjectReleasesEndpoint(Endpoint):
         return self.paginate(
             request=request,
             queryset=queryset,
-            order_by='-date_added',
+            # TODO(dcramer): we want to sort by date_added
+            order_by='-id',
             on_results=lambda x: serialize(x, request.user),
         )
diff --git a/src/sentry/api/paginator.py b/src/sentry/api/paginator.py
index 1aac83d950..fa8774beb6 100644
--- a/src/sentry/api/paginator.py
+++ b/src/sentry/api/paginator.py
@@ -1,18 +1,17 @@
-from __future__ import absolute_import
+"""
+sentry.api.paginator
+~~~~~~~~~~~~~~~~~~~~
 
-import datetime
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+from __future__ import absolute_import
 
+from django.db import connections
 
-class CursorResult(object):
-    def __init__(self, results, next, prev=None, has_prev=None, has_next=None):
-        self.next = next
-        self.prev = prev
-        self.has_next = has_next
-        self.has_prev = has_prev
-        self.results = results
+from sentry.utils.cursors import build_cursor, Cursor
 
-    def get_response(self):
-        return self.results
+quote_name = connections['default'].ops.quote_name
 
 
 class Paginator(object):
@@ -23,7 +22,7 @@ class Paginator(object):
             self.key, self.desc = order_by, False
         self.queryset = queryset
 
-    def _get_results_from_qs(self, cursor_offset, is_prev):
+    def _get_results_from_qs(self, value, is_prev):
         results = self.queryset
 
         # "asc" controls whether or not we need to change the ORDER BY to
@@ -51,124 +50,50 @@ class Paginator(object):
             else:
                 results = results.order_by('-%s' % self.key)
 
-        if cursor_offset:
+        if value:
+            if self.key in results.query.extra:
+                col_query, col_params = results.query.extra[self.key]
+                col_params = col_params[:]
+            else:
+                col_query, col_params = quote_name(self.key), []
+            col_params.append(value)
+
             if asc:
-                results = results.filter(**{'%s__gte' % self.key: cursor_offset})
+                results = results.extra(
+                    where=['%s >= %%s' % (col_query,)],
+                    params=col_params,
+                )
             else:
-                results = results.filter(**{'%s__lte' % self.key: cursor_offset})
+                results = results.extra(
+                    where=['%s <= %%s' % (col_query,)],
+                    params=col_params,
+                )
 
         return results
 
-    def get_cursor(self, limit=100, cursor=None):
+    def get_result(self, limit=100, cursor=None):
         # cursors are:
-        #   (identifier(integer), row offset, is_previous)
-
-        cursor = cursor or (0, 0, 0)
-
-        if cursor:
-            cursor_offset, offset, is_prev = map(int, cursor)
-        else:
-            cursor_offset, offset, is_prev = 0, 0, 0
-
-        results = self._get_results_from_qs(cursor_offset, is_prev)
-
-        if is_prev:
-            # this effectively gets us the before post, and the current (after) post
-            stop = offset + limit + 2
-        else:
-            stop = offset + limit + 1
-
-        results = list(results[offset:stop])
+        #   (identifier(integer), row offset, is_prev)
+        if cursor is None:
+            cursor = Cursor(0, 0, 0)
 
-        num_results = len(results)
+        queryset = self._get_results_from_qs(cursor.value, cursor.is_prev)
 
-        if is_prev:
-            has_prev = num_results > (limit + 1)
-            results = [r for r in reversed(results[:limit + 1])]
-            num_results = len(results)
-        elif cursor_offset or offset:
-            # It's likely that there's a previous page if they passed us either offset values
-            has_prev = True
+        # this effectively gets us the before post, and the current (after) post
+        # every time
+        if cursor.is_prev:
+            stop = cursor.offset + limit + 2
         else:
-            # we don't know
-            has_prev = False
+            stop = cursor.offset + limit + 1
 
-        # Default cursor if not present
-        if is_prev:
-            next_cursor_offset = cursor_offset
-            next_offset = offset
+        results = list(queryset[cursor.offset:stop])
 
-            # Are there more results than whats on the current page?
-            has_next = num_results > limit
-        elif num_results:
-            if not cursor_offset:
-                cursor_offset = getattr(results[0], self.key)
-
-            # Are there more results than whats on the current page?
-            has_next = num_results > limit
-
-            # Determine what our next cursor is by ensuring we have a unique offset
-            next_cursor_offset = getattr(results[-1], self.key)
-
-            if next_cursor_offset == cursor_offset:
-                next_offset = offset + limit
-            else:
-                next_offset = 0
-
-                for result in results[1 if is_prev else 0:limit][::-1]:
-                    if getattr(result, self.key) == next_cursor_offset:
-                        next_offset += 1
-                    else:
-                        break
-        else:
-            next_cursor_offset = cursor_offset
-            next_offset = offset
-            has_next = False
-
-        # Determine what our pervious cursor is by ensuring we have a unique offset
-        if is_prev and num_results:
-            prev_cursor_offset = getattr(results[0], self.key)
-
-            if num_results > 2:
-                i = 1
-                while i < num_results and prev_cursor_offset == getattr(results[i], self.key):
-                    i += 1
-                i -= 1
-            else:
-                i = 0
-
-            # if we iterated every result and the offset didn't change, we need
-            # to simply add the current offset to our total results (visible)
-            if prev_cursor_offset == cursor_offset:
-                prev_offset = offset + i
-            else:
-                prev_offset = i
-        else:
-            # previous cursor is easy if we're paginating forward
-            prev_cursor_offset = cursor_offset
-            prev_offset = offset
-
-        # Truncate the list to our original result size now that we've determined the next page
-        results = results[:limit]
-
-        # XXX: We convert datetimes to unix_time and bump 7 decimal places so we don't
-        # have to worry about float point restrictions. This conversion is also handled
-        # in the CursorTimestamp validator
-        if isinstance(next_cursor_offset, datetime.datetime):
-            next_cursor_offset = int(float(next_cursor_offset.strftime('%s.%f')) * 1000000)
-        if isinstance(prev_cursor_offset, datetime.datetime):
-            prev_cursor_offset = int(float(prev_cursor_offset.strftime('%s.%f')) * 1000000)
-
-        next_cursor = ':'.join(map(lambda x: str(int(x)), [next_cursor_offset or 0, next_offset, 0]))
-        if has_prev:
-            prev_cursor = ':'.join(map(lambda x: str(int(x)), [prev_cursor_offset or 0, prev_offset, 1]))
-        else:
-            prev_cursor = None
+        if cursor.is_prev:
+            results = results[1:][::-1]
 
-        return CursorResult(
+        return build_cursor(
             results=results,
-            next=next_cursor,
-            prev=prev_cursor,
-            has_next=has_next,
-            has_prev=has_prev,
+            limit=limit,
+            cursor=cursor,
+            key=self.key,
         )
diff --git a/src/sentry/search/base.py b/src/sentry/search/base.py
index acafe275b7..3ea51bc3da 100644
--- a/src/sentry/search/base.py
+++ b/src/sentry/search/base.py
@@ -8,49 +8,6 @@ sentry.search.base
 
 from __future__ import absolute_import
 
-from collections import Sequence
-
-
-class SearchResult(Sequence):
-    def __init__(self, id_list=None, instances=None):
-        assert not (id_list and instances), \
-            'pass either id_list or instances, not both'
-        self._id_list = id_list
-        self._result_cache = instances
-
-    def __len__(self):
-        if self._result_cache is None:
-            self._populate_result_cache()
-        return len(self._result_cache)
-
-    def __iter__(self):
-        if self._result_cache is None:
-            self._populate_result_cache()
-        return iter(self._result_cache)
-
-    def __getitem__(self, key):
-        if self._result_cache is None:
-            self._populate_result_cache()
-        return self._result_cache[key]
-
-    def __repr__(self):
-        return '<%s: ids=%s>' % (type(self).__name__, self._id_list)
-
-    def _populate_result_cache(self):
-        from sentry.models import Group
-
-        id_list = self._id_list
-        group_map = Group.objects.in_bulk(id_list)
-
-        results = []
-        for g_id in id_list:
-            try:
-                results.append(group_map[g_id])
-            except KeyError:
-                pass
-
-        self._result_cache = results
-
 
 class SearchBackend(object):
     def __init__(self, **options):
@@ -61,8 +18,15 @@ class SearchBackend(object):
 
     def query(self, project, query=None, status=None, tags=None,
               bookmarked_by=None, assigned_to=None, sort_by='date',
-              date_filter='last_seen', date_from=None, date_to=None, offset=0,
-              limit=100):
+              date_filter='last_seen', date_from=None, date_to=None,
+              cursor=None, limit=100):
+        """
+        The return value should be a CursorResult.
+
+        The limit here is a soft input limit, which gets trimmed by the Cursor.
+        This means the backend should query limit + 2 and return that within the
+        CursorResult.
+        """
         raise NotImplementedError
 
     def upgrade(self):
diff --git a/src/sentry/search/django/backend.py b/src/sentry/search/django/backend.py
index ac76b96288..306534c017 100644
--- a/src/sentry/search/django/backend.py
+++ b/src/sentry/search/django/backend.py
@@ -10,7 +10,8 @@ from __future__ import absolute_import
 
 from django.db.models import Q
 
-from sentry.search.base import SearchBackend, SearchResult
+from sentry.api.paginator import Paginator
+from sentry.search.base import SearchBackend
 from sentry.search.django.constants import (
     SORT_CLAUSES, SQLITE_SORT_CLAUSES, MYSQL_SORT_CLAUSES, MSSQL_SORT_CLAUSES,
     MSSQL_ENGINES, ORACLE_SORT_CLAUSES
@@ -24,8 +25,8 @@ class DjangoSearchBackend(SearchBackend):
 
     def query(self, project, query=None, status=None, tags=None,
               bookmarked_by=None, assigned_to=None, sort_by='date',
-              date_filter='last_seen', date_from=None, date_to=None, offset=0,
-              limit=100):
+              date_filter='last_seen', date_from=None, date_to=None,
+              cursor=None, limit=100):
         from sentry.models import Group
 
         queryset = Group.objects.filter(project=project)
@@ -99,10 +100,15 @@ class DjangoSearchBackend(SearchBackend):
         elif sort_by == 'avgtime':
             queryset = queryset.filter(time_spent_count__gt=0)
 
+        queryset = queryset.extra(
+            select={'sort_value': score_clause},
+        )
+
         # HACK: don't sort by the same column twice
         if sort_by == 'date':
-            queryset = queryset.order_by('-last_seen')
+            queryset = queryset.order_by('-sort_value')
         else:
             queryset = queryset.order_by('-sort_value', '-last_seen')
 
-        return SearchResult(instances=list(queryset[offset:offset + limit]))
+        paginator = Paginator(queryset, '-sort_value')
+        return paginator.get_result(limit, cursor)
diff --git a/src/sentry/search/django/constants.py b/src/sentry/search/django/constants.py
index 4e6cd80a32..35ceafe37f 100644
--- a/src/sentry/search/django/constants.py
+++ b/src/sentry/search/django/constants.py
@@ -17,33 +17,28 @@ SORT_CLAUSES = {
     'tottime': 'sentry_groupedmessage.time_spent_total',
     'avgtime': '(sentry_groupedmessage.time_spent_total / sentry_groupedmessage.time_spent_count)',
 }
-SCORE_CLAUSES = SORT_CLAUSES.copy()
 
 SQLITE_SORT_CLAUSES = SORT_CLAUSES.copy()
 SQLITE_SORT_CLAUSES.update({
-    'date': "(julianday(sentry_groupedmessage.last_seen) - 2440587.5) * 86400.0",
-    'new': "(julianday(sentry_groupedmessage.first_seen) - 2440587.5) * 86400.0",
+    'date': "cast((julianday(sentry_groupedmessage.last_seen) - 2440587.5) * 86400.0 as INTEGER)",
+    'new': "cast((julianday(sentry_groupedmessage.first_seen) - 2440587.5) * 86400.0 as INTEGER)",
 })
-SQLITE_SCORE_CLAUSES = SQLITE_SORT_CLAUSES.copy()
 
 MYSQL_SORT_CLAUSES = SORT_CLAUSES.copy()
 MYSQL_SORT_CLAUSES.update({
     'date': 'UNIX_TIMESTAMP(sentry_groupedmessage.last_seen)',
     'new': 'UNIX_TIMESTAMP(sentry_groupedmessage.first_seen)',
 })
-MYSQL_SCORE_CLAUSES = MYSQL_SORT_CLAUSES.copy()
 
-ORACLE_SORT_CLAUSES = SCORE_CLAUSES.copy()
+ORACLE_SORT_CLAUSES = SORT_CLAUSES.copy()
 ORACLE_SORT_CLAUSES.update({
     'date': "(cast(sentry_groupedmessage.last_seen as date)-TO_DATE('01/01/1970 00:00:00', 'MM-DD-YYYY HH24:MI:SS')) * 24 * 60 * 60",
     'new': "(cast(sentry_groupedmessage.first_seen as date)-TO_DATE('01/01/1970 00:00:00', 'MM-DD-YYYY HH24:MI:SS')) * 24 * 60 * 60",
 })
-ORACLE_SCORE_CLAUSES = ORACLE_SORT_CLAUSES.copy()
 
-MSSQL_SORT_CLAUSES = SCORE_CLAUSES.copy()
+MSSQL_SORT_CLAUSES = SORT_CLAUSES.copy()
 MSSQL_SORT_CLAUSES.update({
     'date': "DATEDIFF(s, '1970-01-01T00:00:00', sentry_groupedmessage.last_seen)",
     'new': "DATEDIFF(s, '1970-01-01T00:00:00', sentry_groupedmessage.first_seen)",
 })
-MSSQL_SCORE_CLAUSES = MSSQL_SORT_CLAUSES.copy()
 MSSQL_ENGINES = set(['django_pytds', 'sqlserver_ado', 'sql_server.pyodbc'])
diff --git a/src/sentry/search/elastic_search/backend.py b/src/sentry/search/elastic_search/backend.py
index 713ed89dd6..c2bac69804 100644
--- a/src/sentry/search/elastic_search/backend.py
+++ b/src/sentry/search/elastic_search/backend.py
@@ -37,7 +37,8 @@ from __future__ import absolute_import, print_function
 
 from elasticsearch import Elasticsearch
 
-from sentry.search.base import SearchBackend, SearchResult
+from sentry.search.base import SearchBackend
+from sentry.utils.cursors import CursorResult
 
 
 class ElasticSearchBackend(SearchBackend):
@@ -83,8 +84,8 @@ class ElasticSearchBackend(SearchBackend):
 
     def query(self, project, query=None, status=None, tags=None,
               bookmarked_by=None, assigned_to=None, sort_by='date',
-              date_filter='last_seen', date_from=None, date_to=None, offset=0,
-              limit=100):
+              date_filter='last_seen', date_from=None, date_to=None,
+              cursor=None, limit=100):
 
         query_body = {
             'filter': {
@@ -164,15 +165,24 @@ class ElasticSearchBackend(SearchBackend):
                 'query': {'filtered': query_body},
                 'sort': sort_clause,
                 'size': limit,
-                'from': offset,
+                # 'from': offset,
             },
         )
         if not results.get('hits'):
-            return SearchResult([])
+            return CursorResult(
+                results=[],
+                cursor=cursor,
+                limit=limit,
+            )
 
         instance_ids = [int(n['_id']) for n in results['hits']['hits']]
 
-        return SearchResult(instance_ids)
+        return CursorResult.from_ids(
+            id_list=instance_ids,
+            cursor=cursor,
+            limit=limit,
+            key='TODO',
+        )
 
     def upgrade(self):
         self.backend.indices.put_template(
diff --git a/src/sentry/templates/sentry/groups/group_list.html b/src/sentry/templates/sentry/groups/group_list.html
index 82bf68b469..92db8dae55 100644
--- a/src/sentry/templates/sentry/groups/group_list.html
+++ b/src/sentry/templates/sentry/groups/group_list.html
@@ -79,13 +79,13 @@
              <i aria-hidden="true" class="icon-arrow-down"></i></a>
         </div>
         <div class="btn-group pull-right">
-            {% if previous_page %}
-                <a class="btn prev" href="?{{ pageless_query_string|escape }}&amp;p={{ previous_page }}"><span>{% trans "Previous" %}</span></a>
+            {% if prev_cursor %}
+                <a class="btn prev" href="?{{ cursorless_query_string|escape }}&amp;cursor={{ prev_cursor }}"><span>{% trans "Previous" %}</span></a>
             {% else %}
                 <a class="btn prev disabled"><span>{% trans "Previous" %}</span></a>
             {% endif %}
-            {% if next_page %}
-                <a class="btn next" href="?{{ pageless_query_string|escape }}&amp;p={{ next_page }}"><span>{% trans "Next" %}</span></a>
+            {% if next_cursor %}
+                <a class="btn next" href="?{{ cursorless_query_string|escape }}&amp;cursor={{ next_cursor }}"><span>{% trans "Next" %}</span></a>
             {% else %}
                 <a class="btn next disabled"><span>{% trans "Next" %}</span></a>
             {% endif %}
@@ -143,13 +143,13 @@
 
     <div class="btn-toolbar" style="border-bottom: none">
         <div class="btn-group pull-right">
-            {% if previous_page %}
-                <a class="btn prev" href="?{{ pageless_query_string|escape }}&amp;p={{ previous_page }}"><span>{% trans "Previous" %}</span></a>
+            {% if prev_cursor %}
+                <a class="btn prev" href="?{{ cursorless_query_string|escape }}&amp;cursor={{ prev_cursor }}"><span>{% trans "Previous" %}</span></a>
             {% else %}
                 <a class="btn prev disabled"><span>{% trans "Previous" %}</span></a>
             {% endif %}
-            {% if next_page %}
-                <a class="btn next" href="?{{ pageless_query_string|escape }}&amp;p={{ next_page }}"><span>{% trans "Next" %}</span></a>
+            {% if next_cursor %}
+                <a class="btn next" href="?{{ cursorless_query_string|escape }}&amp;cursor={{ next_cursor }}"><span>{% trans "Next" %}</span></a>
             {% else %}
                 <a class="btn next disabled"><span>{% trans "Next" %}</span></a>
             {% endif %}
diff --git a/src/sentry/utils/cursors.py b/src/sentry/utils/cursors.py
new file mode 100644
index 0000000000..5b805c7d9b
--- /dev/null
+++ b/src/sentry/utils/cursors.py
@@ -0,0 +1,168 @@
+"""
+sentry.utils.cursors
+~~~~~~~~~~~~~~~~~~~~
+
+:copyright: (c) 2010-2014 by the Sentry Team, see AUTHORS for more details.
+:license: BSD, see LICENSE for more details.
+"""
+from __future__ import absolute_import
+
+from collections import Sequence
+
+
+class Cursor(object):
+    def __init__(self, value, offset=0, is_prev=False, has_results=None):
+        # XXX: ceil is not entirely correct here, but it's a simple hack
+        # that solves most problems
+        self.value = long(value)
+        self.offset = int(offset)
+        self.is_prev = bool(is_prev)
+        self.has_results = has_results
+
+    def __str__(self):
+        return '%s:%s:%s' % (self.value, self.offset, int(self.is_prev))
+
+    def __repr__(self):
+        return '<%s: value=%s offset=%s is_prev=%s>' % (
+            type(self), self.value, self.offset, int(self.is_prev))
+
+    def __nonzero__(self):
+        return self.has_results
+
+    @classmethod
+    def from_string(cls, value):
+        bits = value.split(':')
+        if len(bits) != 3:
+            raise ValueError
+        try:
+            bits = map(int, bits)
+        except (TypeError, ValueError):
+            raise ValueError
+        return cls(*bits)
+
+
+class CursorResult(Sequence):
+    def __init__(self, results, next, prev):
+        self.results = results
+        self.next = next
+        self.prev = prev
+
+    def __len__(self):
+        return len(self.results)
+
+    def __iter__(self):
+        return iter(self.results)
+
+    def __getitem__(self, key):
+        return self.results[key]
+
+    def __repr__(self):
+        return '<%s: results=%s>' % (type(self).__name__, len(self.results))
+
+    @classmethod
+    def from_ids(self, id_list, key=None, limit=100, cursor=None):
+        from sentry.models import Group
+
+        group_map = Group.objects.in_bulk(id_list)
+
+        results = []
+        for g_id in id_list:
+            try:
+                results.append(group_map[g_id])
+            except KeyError:
+                pass
+
+        return build_cursor(
+            results=results,
+            key=key,
+            cursor=cursor,
+            limit=limit,
+        )
+
+
+def build_cursor(results, key, limit=100, cursor=None):
+    if cursor is None:
+        cursor = Cursor(0, 0, 0)
+
+    value = cursor.value
+    offset = cursor.offset
+    is_prev = cursor.is_prev
+
+    num_results = len(results)
+
+    if is_prev:
+        has_prev = num_results > limit
+        num_results = len(results)
+    elif value or offset:
+        # It's likely that there's a previous page if they passed us either offset values
+        has_prev = True
+    else:
+        # we don't know
+        has_prev = False
+
+    # Default cursor if not present
+    if is_prev:
+        next_value = value
+        next_offset = offset
+        has_next = True
+    elif num_results:
+        if not value:
+            value = getattr(results[0], key)
+
+        # Are there more results than whats on the current page?
+        has_next = num_results > limit
+
+        # Determine what our next cursor is by ensuring we have a unique offset
+        next_value = getattr(results[-1], key)
+
+        if next_value == value:
+            next_offset = offset + limit
+        else:
+            next_offset = 0
+            result_iter = reversed(results)
+            # skip the last result
+            result_iter.next()
+            for result in result_iter:
+                if getattr(result, key) == next_value:
+                    next_offset += 1
+                else:
+                    break
+    else:
+        next_value = value
+        next_offset = offset
+        has_next = False
+
+    # Determine what our pervious cursor is by ensuring we have a unique offset
+    if is_prev and num_results:
+        prev_value = getattr(results[0], key)
+
+        if num_results > 2:
+            i = 1
+            while i < num_results and prev_value == getattr(results[i], key):
+                i += 1
+            i -= 1
+        else:
+            i = 0
+
+        # if we iterated every result and the offset didn't change, we need
+        # to simply add the current offset to our total results (visible)
+        if prev_value == value:
+            prev_offset = offset + i
+        else:
+            prev_offset = i
+    else:
+        # previous cursor is easy if we're paginating forward
+        prev_value = value
+        prev_offset = offset
+
+    # Truncate the list to our original result size now that we've determined the next page
+    results = results[:limit]
+
+    next_cursor = Cursor(next_value or 0, next_offset, False, has_next)
+    prev_cursor = Cursor(prev_value or 0, prev_offset, True, has_prev)
+
+    return CursorResult(
+        results=results,
+        next=next_cursor,
+        prev=prev_cursor,
+    )
diff --git a/src/sentry/web/frontend/groups.py b/src/sentry/web/frontend/groups.py
index a44d530c42..fd64626f18 100644
--- a/src/sentry/web/frontend/groups.py
+++ b/src/sentry/web/frontend/groups.py
@@ -33,6 +33,7 @@ from sentry.permissions import (
 from sentry.plugins import plugins
 from sentry.search.utils import parse_query
 from sentry.utils import json
+from sentry.utils.cursors import Cursor
 from sentry.utils.dates import parse_date
 from sentry.web.decorators import has_access, has_group_access, login_required
 from sentry.web.forms import NewNoteForm
@@ -93,15 +94,10 @@ def _get_group_list(request, project):
     if date_filter:
         query_kwargs['date_filter'] = date_filter
 
-    # HACK(dcramer): this should be removed once the pagination component
-    # is abstracted from the paginator tag
-    try:
-        page = int(request.GET.get('p', 1))
-    except (ValueError, TypeError):
-        page = 1
-
-    query_kwargs['offset'] = (page - 1) * EVENTS_PER_PAGE
-    query_kwargs['limit'] = EVENTS_PER_PAGE + 1
+    cursor = request.GET.get('cursor')
+    if cursor:
+        query_kwargs['cursor'] = Cursor.from_string(cursor)
+    query_kwargs['limit'] = EVENTS_PER_PAGE
 
     query = request.GET.get('query', 'is:unresolved')
     if query is not None:
@@ -109,16 +105,6 @@ def _get_group_list(request, project):
 
     results = app.search.query(**query_kwargs)
 
-    if len(results) == query_kwargs['limit']:
-        next_page = page + 1
-    else:
-        next_page = None
-
-    if page > 1:
-        prev_page = page - 1
-    else:
-        prev_page = None
-
     return {
         'event_list': results[:EVENTS_PER_PAGE],
         'date_from': date_from,
@@ -126,8 +112,8 @@ def _get_group_list(request, project):
         'today': today,
         'sort': sort_by,
         'date_type': date_filter,
-        'previous_page': prev_page,
-        'next_page': next_page,
+        'next_cursor': results.next,
+        'prev_cursor': results.prev,
     }
 
 
@@ -226,11 +212,6 @@ def wall_display(request, organization, team):
 @login_required
 @has_access
 def group_list(request, organization, project):
-    try:
-        page = int(request.GET.get('p', 1))
-    except (TypeError, ValueError):
-        page = 1
-
     query = request.GET.get('query', 'is:unresolved')
     if query and uuid_re.match(query):
         # Forward to event if it exists
@@ -257,12 +238,12 @@ def group_list(request, organization, project):
     # XXX: this is duplicate in _get_group_list
     sort_label = SORT_OPTIONS[response['sort']]
 
-    has_realtime = page == 1
+    has_realtime = not request.GET.get('cursor')
 
     query_dict = request.GET.copy()
-    if 'p' in query_dict:
-        del query_dict['p']
-    pageless_query_string = query_dict.urlencode()
+    if 'cursor' in query_dict:
+        del query_dict['cursor']
+    cursorless_query_string = query_dict.urlencode()
 
     GroupMeta.objects.populate_cache(response['event_list'])
 
@@ -275,12 +256,12 @@ def group_list(request, organization, project):
         'date_type': response['date_type'],
         'has_realtime': has_realtime,
         'event_list': response['event_list'],
-        'previous_page': response['previous_page'],
-        'next_page': response['next_page'],
+        'prev_cursor': response['prev_cursor'],
+        'next_cursor': response['next_cursor'],
         'today': response['today'],
         'sort': response['sort'],
         'query': query,
-        'pageless_query_string': pageless_query_string,
+        'cursorless_query_string': cursorless_query_string,
         'sort_label': sort_label,
         'SORT_OPTIONS': SORT_OPTIONS,
     }, request)
diff --git a/tests/sentry/api/endpoints/test_group_events.py b/tests/sentry/api/endpoints/test_group_events.py
index aa1fe81254..10d5c71bdc 100644
--- a/tests/sentry/api/endpoints/test_group_events.py
+++ b/tests/sentry/api/endpoints/test_group_events.py
@@ -2,7 +2,7 @@ from django.core.urlresolvers import reverse
 from sentry.testutils import APITestCase
 
 
-class GroupResolveTest(APITestCase):
+class GroupEventsTest(APITestCase):
     def test_simple(self):
         self.login_as(user=self.user)
 
diff --git a/tests/sentry/search/django/tests.py b/tests/sentry/search/django/tests.py
index 1a5739996f..42cd72070b 100644
--- a/tests/sentry/search/django/tests.py
+++ b/tests/sentry/search/django/tests.py
@@ -134,14 +134,16 @@ class DjangoSearchBackendTest(TestCase):
         results = self.backend.query(self.project2)
         assert len(results) == 0
 
-    def test_limit_and_offset(self):
-        results = self.backend.query(self.project1, limit=1)
+    def test_pagination(self):
+        results = self.backend.query(self.project1, limit=1, sort_by='date')
         assert len(results) == 1
+        assert results[0] == self.group1
 
-        results = self.backend.query(self.project1, offset=1, limit=1)
+        results = self.backend.query(self.project1, cursor=results.next, limit=1, sort_by='date')
         assert len(results) == 1
+        assert results[0] == self.group2
 
-        results = self.backend.query(self.project1, offset=2, limit=1)
+        results = self.backend.query(self.project1, cursor=results.next, limit=1, sort_by='date')
         assert len(results) == 0
 
     def test_first_seen_date_filter(self):

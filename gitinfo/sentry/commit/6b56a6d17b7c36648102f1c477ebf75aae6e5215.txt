commit 6b56a6d17b7c36648102f1c477ebf75aae6e5215
Author: Danny Lee <leedongwei@gmail.com>
Date:   Wed Sep 18 22:54:08 2019 -0700

    feat(discover-v2): Add add/update/remove columns for QueryBuilder

diff --git a/src/sentry/static/sentry/app/views/eventsV2/table.tsx b/src/sentry/static/sentry/app/views/eventsV2/table.tsx
index 85a0061e15..bf1c17307c 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table.tsx
@@ -1,69 +1,60 @@
 import React from 'react';
 import {Location} from 'history';
-import {omit} from 'lodash';
 import {browserHistory} from 'react-router';
 import styled from 'react-emotion';
 
-import space from 'app/styles/space';
-import withApi from 'app/utils/withApi';
-import Alert from 'app/components/alert';
 import {Client} from 'app/api';
 import {Organization} from 'app/types';
+import withApi from 'app/utils/withApi';
+
 import Pagination from 'app/components/pagination';
-import Panel from 'app/components/panels/panel';
-import LoadingContainer from 'app/components/loading/loadingContainer';
-import EmptyStateWarning from 'app/components/emptyStateWarning';
-import Placeholder from 'app/components/placeholder';
-import {t} from 'app/locale';
 
 import {DEFAULT_EVENT_VIEW_V1} from './data';
-import {MetaType, getFieldRenderer} from './utils';
 import EventView from './eventView';
-import SortLink from './sortLink';
-
-type DataRow = {
-  [key: string]: string;
-};
-
-// TODO: move this
-type DataPayload = {
-  data: Array<DataRow>;
-  meta: MetaType;
-};
+import TableView from './tableView';
+import {TableData} from './tableTypes';
 
-type Props = {
+type TableProps = {
   api: Client;
   location: Location;
   organization: Organization;
 };
+type TableState = {
+  isLoading: boolean;
+  error: null | string;
 
-type State = {
   eventView: EventView;
-  loading: boolean;
-  error: null | string;
   pageLinks: null | string;
-  dataPayload: DataPayload | null | undefined;
+
+  tableData: TableData | null | undefined;
 };
 
 /**
- * Container element that fetches events and handles pagination
+ * `Table` is a container element that handles 2 things
+ * 1. Fetch data from source
+ * 2. Handle pagination of data
+ *
+ * It will pass the data it fetched to `TableView`, where the state of the
+ * Table is maintained and controlled
  */
-class Table extends React.PureComponent<Props, State> {
-  state: State = {
-    eventView: EventView.fromLocation(this.props.location),
-    loading: true,
-    error: null,
-    pageLinks: null,
-    dataPayload: null,
-  };
-
-  static getDerivedStateFromProps(props: Props, state: State): State {
+class Table extends React.PureComponent<TableProps, TableState> {
+  static getDerivedStateFromProps(props: TableProps, state: TableState): TableState {
     return {
       ...state,
       eventView: EventView.fromLocation(props.location),
     };
   }
 
+  state: TableState = {
+    isLoading: true,
+    error: null,
+
+    eventView: EventView.fromLocation(this.props.location),
+    pageLinks: null,
+
+    tableData: null,
+  };
+
   componentDidMount() {
     const {location} = this.props;
 
@@ -84,6 +75,7 @@ class Table extends React.PureComponent<Props, State> {
   }
 
   componentDidUpdate(prevProps) {
+    // todo(leedongwei): Ensure that checking by address is not a problem
     if (this.props.location !== prevProps.location) {
       this.fetchData();
     }
@@ -91,26 +83,25 @@ class Table extends React.PureComponent<Props, State> {
 
   fetchData = () => {
     const {organization, location} = this.props;
-
     const url = `/organizations/${organization.slug}/eventsv2/`;
 
-    this.setState({loading: true});
+    this.setState({isLoading: true});
 
     this.props.api.request(url, {
       query: this.state.eventView.getEventsAPIPayload(location),
-      success: (dataPayload, __textStatus, jqxhr) => {
+      success: (data, __textStatus, jqxhr) => {
         this.setState(prevState => {
           return {
-            loading: false,
+            isLoading: false,
             error: null,
             pageLinks: jqxhr ? jqxhr.getResponseHeader('Link') : prevState.pageLinks,
-            dataPayload,
+            tableData: data,
           };
         });
       },
       error: err => {
         this.setState({
-          loading: false,
+          isLoading: false,
           error: err.responseJSON.detail,
         });
       },
@@ -118,18 +109,16 @@ class Table extends React.PureComponent<Props, State> {
   };
 
   render() {
-    const {organization, location} = this.props;
-    const {pageLinks, eventView, loading, dataPayload, error} = this.state;
+    const {pageLinks, eventView, tableData, isLoading, error} = this.state;
 
     return (
       <Container>
         <TableView
-          eventView={eventView}
-          organization={organization}
-          dataPayload={dataPayload}
-          isLoading={loading}
-          location={location}
+          {...this.props}
+          isLoading={isLoading}
           error={error}
+          eventView={eventView}
+          tableData={tableData}
         />
         <Pagination pageLinks={pageLinks} />
       </Container>
@@ -137,237 +126,9 @@ class Table extends React.PureComponent<Props, State> {
   }
 }
 
-type TableViewProps = {
-  organization: Organization;
-  eventView: EventView;
-  isLoading: boolean;
-  dataPayload: DataPayload | null | undefined;
-  error: string | null;
-  location: Location;
-};
-
-/**
- * Renders the table headers and rows for the result set.
- */
-class TableView extends React.Component<TableViewProps> {
-  renderHeader = () => {
-    const {eventView, location, dataPayload} = this.props;
-
-    if (eventView.fields.length <= 0) {
-      return null;
-    }
-
-    const defaultSort = eventView.getDefaultSort() || eventView.fields[0].field;
-
-    return eventView.fields.map((field, index) => {
-      if (!dataPayload) {
-        return <PanelHeaderCell key={index}>{field.title}</PanelHeaderCell>;
-      }
-
-      const {meta} = dataPayload;
-      const sortKey = eventView.getSortKey(field.field, meta);
-
-      if (sortKey === null) {
-        return <PanelHeaderCell key={index}>{field.title}</PanelHeaderCell>;
-      }
-
-      return (
-        <PanelHeaderCell key={index}>
-          <SortLink
-            defaultSort={defaultSort}
-            sortKey={sortKey}
-            title={field.title}
-            location={location}
-          />
-        </PanelHeaderCell>
-      );
-    });
-  };
-
-  renderContent = (): React.ReactNode => {
-    const {isLoading, dataPayload, eventView, organization, location} = this.props;
-
-    if (isLoading && !dataPayload) {
-      return (
-        <PanelGridInfo numOfCols={eventView.numOfColumns()}>
-          <Placeholder height="240px" width="100%" />
-        </PanelGridInfo>
-      );
-    }
-    if (!(dataPayload && dataPayload.data && dataPayload.data.length > 0)) {
-      return (
-        <PanelGridInfo numOfCols={eventView.numOfColumns()}>
-          <EmptyStateWarning>
-            <p>{t('No results found')}</p>
-          </EmptyStateWarning>
-        </PanelGridInfo>
-      );
-    }
-
-    const {meta} = dataPayload;
-    const fields = eventView.getFieldNames();
-    const lastRowIndex = dataPayload.data.length - 1;
-    const hasLinkField = eventView.hasAutolinkField();
-    const firstCellIndex = 0;
-    const lastCellIndex = fields.length - 1;
-
-    return dataPayload.data.map((row, rowIndex) => {
-      return (
-        <React.Fragment key={rowIndex}>
-          {fields.map((field, columnIndex) => {
-            const key = `${field}.${columnIndex}`;
-            const forceLinkField = !hasLinkField && columnIndex === 0;
-
-            const fieldRenderer = getFieldRenderer(field, meta, forceLinkField);
-            return (
-              <PanelItemCell
-                hideBottomBorder={rowIndex === lastRowIndex}
-                style={{
-                  paddingLeft: columnIndex === firstCellIndex ? space(1) : void 0,
-                  paddingRight: columnIndex === lastCellIndex ? space(1) : void 0,
-                }}
-                key={key}
-              >
-                {fieldRenderer(row, {organization, location})}
-              </PanelItemCell>
-            );
-          })}
-        </React.Fragment>
-      );
-    });
-  };
-
-  renderTable() {
-    const {isLoading, dataPayload} = this.props;
-    return (
-      <React.Fragment>
-        {this.renderHeader()}
-        {isLoading && (
-          <FloatingLoadingContainer
-            isLoading={true}
-            isReloading={isLoading && !!dataPayload}
-          />
-        )}
-        {this.renderContent()}
-      </React.Fragment>
-    );
-  }
-
-  renderError() {
-    const {error, eventView} = this.props;
-    return (
-      <React.Fragment>
-        <Alert type="error" icon="icon-circle-exclamation">
-          {error}
-        </Alert>
-        <PanelGrid numOfCols={eventView.numOfColumns()}>{this.renderHeader()}</PanelGrid>
-      </React.Fragment>
-    );
-  }
-
-  render() {
-    const {error, eventView} = this.props;
-
-    if (error) {
-      return this.renderError();
-    }
-    return (
-      <PanelGrid numOfCols={eventView.numOfColumns()}>{this.renderTable()}</PanelGrid>
-    );
-  }
-}
-
-type PanelGridProps = {
-  numOfCols: number;
-};
-
-const PanelGrid = styled((props: PanelGridProps) => {
-  const otherProps = omit(props, 'numOfCols');
-  return <Panel {...otherProps} />;
-})<PanelGridProps>`
-  display: grid;
-
-  overflow-x: auto;
-
-  ${(props: PanelGridProps) => {
-    const firstColumn = '3fr';
-
-    function generateRestColumns(): string {
-      if (props.numOfCols <= 1) {
-        return '';
-      }
-
-      return `repeat(${props.numOfCols - 1}, auto)`;
-    }
-
-    return `
-      grid-template-columns:  ${firstColumn} ${generateRestColumns()};
-    `;
-  }};
-`;
-
-const PanelHeaderCell = styled('div')`
-  color: ${p => p.theme.gray3};
-  font-size: 13px;
-  font-weight: 600;
-  text-transform: uppercase;
-  border-bottom: 1px solid ${p => p.theme.borderDark};
-  border-radius: ${p => p.theme.borderRadius} ${p => p.theme.borderRadius} 0 0;
-  background: ${p => p.theme.offWhite};
-  line-height: 1;
-
-  text-overflow: ellipsis;
-  overflow: hidden;
-  white-space: nowrap;
-
-  padding: ${space(2)};
-
-  /*
-    By default, a grid item cannot be smaller than the size of its content.
-    We override this by setting it to be 0.
-  */
-  min-width: 0;
-`;
-
-type PanelGridInfoProps = {
-  numOfCols: number;
-};
-
-const PanelGridInfo = styled('div')<PanelGridInfoProps>`
-  ${(props: PanelGridInfoProps) => {
-    return `
-  grid-column: 1 / span ${props.numOfCols};
-  `;
-  }};
-`;
-
-const PanelItemCell = styled('div')<{hideBottomBorder: boolean}>`
-  border-bottom: ${p =>
-    p.hideBottomBorder ? 'none' : `1px solid ${p.theme.borderLight}`};
-
-  font-size: ${p => p.theme.fontSizeMedium};
-
-  padding-top: ${space(1)};
-  padding-bottom: ${space(1)};
-
-  /*
-    By default, a grid item cannot be smaller than the size of its content.
-    We override this by setting it to be 0.
-  */
-  min-width: 0;
-`;
+export default withApi<TableProps>(Table);
 
 const Container = styled('div')`
   min-width: 0;
   overflow: hidden;
 `;
-
-const FloatingLoadingContainer = styled(LoadingContainer)<LoadingContainer['props']>`
-  position: absolute;
-  top: 0;
-  left: 0;
-  right: 0;
-  bottom: 0;
-`;
-
-export default withApi<Props>(Table);
diff --git a/src/sentry/static/sentry/app/views/eventsV2/tableModalEditColumn.tsx b/src/sentry/static/sentry/app/views/eventsV2/tableModalEditColumn.tsx
new file mode 100644
index 0000000000..26a5ea5ee6
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/eventsV2/tableModalEditColumn.tsx
@@ -0,0 +1,230 @@
+import React from 'react';
+import styled from 'react-emotion';
+
+import {t} from 'app/locale';
+import {Form, SelectField, TextField} from 'app/components/forms';
+import InlineSvg from 'app/components/inlineSvg';
+import space from 'app/styles/space';
+
+import {AGGREGATIONS, FIELDS, Aggregation, Field} from './eventQueryParams';
+import {TableColumn} from './tableTypes';
+
+type ModalEditColumnFormProps = {
+  column: {
+    aggregation: Aggregation;
+    field: Field;
+    name: string;
+  };
+
+  actions: {
+    createColumn: {(): void};
+    updateColumn: {(column, indexOfColumnOrder: number): void};
+  };
+};
+type ModalEditColumnFormState = {
+  currAggregation: Aggregation;
+  currField: Field;
+  currName: string;
+  aggregations: Aggregation[];
+  fields: Field[];
+};
+
+class ModalEditColumnForm extends React.Component<
+  ModalEditColumnFormProps,
+  ModalEditColumnFormState
+> {
+  static defaultProps = {
+    column: {
+      aggregation: '',
+      field: '',
+      name: '',
+    },
+  };
+
+  state = {
+    currAggregation: this.props.column.aggregation,
+    currField: this.props.column.field,
+    currName: this.props.column.name,
+    aggregations: filterAggregationByField(this.props.column.field),
+    fields: filterFieldByAggregation(this.props.column.aggregation),
+  };
+
+  onChangeAggregation = (value: Aggregation) => {
+    if (value === this.state.currAggregation) {
+      return;
+    }
+
+    this.setState({
+      currAggregation: value,
+      fields: filterFieldByAggregation(value),
+    });
+  };
+
+  onChangeField = (value: Field) => {
+    if (value === this.state.currField) {
+      return;
+    }
+
+    this.setState({
+      currField: value,
+      aggregations: filterAggregationByField(value),
+    });
+  };
+
+  onChangeName = (value: string) => {
+    if (value === this.state.currName) {
+      return;
+    }
+
+    this.setState({
+      currName: value,
+    });
+  };
+
+  render() {
+    return (
+      <React.Fragment>
+        <Form onSubmit={values => console.log('onSubmit', values)}>
+          <FormRow>
+            <FormRowItem style={{width: '35%'}}>
+              <SelectField
+                name="aggregation"
+                label={t('Select')}
+                placeholder="Aggregate"
+                choices={this.state.aggregations}
+                onChange={this.onChangeAggregation}
+                value={this.state.currAggregation}
+              />
+            </FormRowItem>
+            <FormRowItem style={{width: '65%'}}>
+              <SelectField
+                name="field"
+                label="&nbsp;" // This sets the correct padding-top
+                placeholder="Column"
+                choices={this.state.fields}
+                onChange={this.onChangeField}
+                value={this.state.currField}
+              />
+            </FormRowItem>
+          </FormRow>
+          <TextField
+            name="name"
+            label={t('Display Name')}
+            placeholder="Column Name"
+            onChange={this.onChangeName}
+            value={this.state.currName}
+          />
+        </Form>
+
+        {/* {data && data.column ? (
+          <React.Fragment>
+            <Button priority="primary">Update</Button>
+            <Button>Delete</Button>
+          </React.Fragment>
+        ) : (
+          <Button priority="primary">Create</Button>
+        )} */}
+      </React.Fragment>
+    );
+  }
+}
+
+function renderModalBody(column?: TableColumn<React.ReactText>): React.ReactNode {
+  return (
+    <ModalEditColumnForm
+      column={column}
+      actions={
+        {
+          createColumn: () => {},
+          updateColumn: () => {},
+        } as any
+      }
+    />
+  );
+}
+
+function renderModalFooter(): React.ReactNode {
+  // todo(leedongwei): Check with Mimi to get the link for DiscoverV2 docs
+  return (
+    <FooterContent href="https://docs.sentry.io/">
+      <div>
+        <InlineSvg src="icon-docs" /> Discover Documentation
+      </div>
+      <div>
+        <InlineSvg src="icon-chevron-right" />
+      </div>
+    </FooterContent>
+  );
+}
+
+export default {
+  renderModalBody,
+  renderModalFooter,
+};
+
+function filterAggregationByField(f?: Field): Aggregation[] {
+  if (!f || !FIELDS[f]) {
+    return Object.keys(AGGREGATIONS) as Aggregation[];
+  }
+
+  return Object.keys(AGGREGATIONS).reduce(
+    (accumulator, a) => {
+      if (AGGREGATIONS[a] && FIELDS[f] && AGGREGATIONS[a].type === FIELDS[f]) {
+        accumulator.push(a as Aggregation);
+      }
+
+      return accumulator;
+    },
+    [] as Aggregation[]
+  );
+}
+
+function filterFieldByAggregation(a?: Aggregation): Field[] {
+  if (!a || !AGGREGATIONS[a]) {
+    return Object.keys(FIELDS) as Field[];
+  }
+
+  return Object.keys(FIELDS).reduce(
+    (accumulator, f) => {
+      if (FIELDS[f] && FIELDS[f] === AGGREGATIONS[a].type) {
+        accumulator.push(f as Field);
+      }
+
+      return accumulator;
+    },
+    [] as Field[]
+  );
+}
+
+const FormRow = styled.div`
+  box-sizing: border-box;
+`;
+const FormRowItem = styled.div`
+  display: inline-block;
+  padding-right: ${space(1)};
+
+  &:last-child {
+    padding-right: 0;
+  }
+`;
+
+const FooterContent = styled.a`
+  display: flex;
+  width: 100%;
+
+  > div {
+    display: flex;
+    align-items: center;
+  }
+
+  > div:first-child {
+    flex-grow: 1;
+
+    svg {
+      margin-right: 10px;
+    }
+  }
+  > div:last-child {
+    flex-grow: 0;
+  }
+`;
diff --git a/src/sentry/static/sentry/app/views/eventsV2/tableView.tsx b/src/sentry/static/sentry/app/views/eventsV2/tableView.tsx
new file mode 100644
index 0000000000..27fe7c9ee0
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/eventsV2/tableView.tsx
@@ -0,0 +1,471 @@
+import React from 'react';
+import {Location} from 'history';
+import {omit} from 'lodash';
+import styled from 'react-emotion';
+import {browserHistory} from 'react-router';
+
+import {t} from 'app/locale';
+import {Organization} from 'app/types';
+import space from 'app/styles/space';
+
+import Alert from 'app/components/alert';
+import EmptyStateWarning from 'app/components/emptyStateWarning';
+import GridEditable from 'app/components/gridEditable';
+import LoadingContainer from 'app/components/loading/loadingContainer';
+import Panel from 'app/components/panels/panel';
+import Placeholder from 'app/components/placeholder';
+
+import {
+  decodeColumnOrderAndColumnSortBy,
+  encodeColumnOrderAndColumnSortBy,
+  getFieldRenderer,
+} from './utils';
+import EventView from './eventView';
+import SortLink from './sortLink';
+import tableModalEditColumn from './tableModalEditColumn';
+import {
+  TableColumn,
+  TableColumnSort,
+  TableState,
+  TableData,
+  TableDataRow,
+} from './tableTypes';
+
+export type TableViewProps = {
+  location: Location;
+  organization: Organization;
+
+  isLoading: boolean;
+  error: string | null;
+
+  eventView: EventView;
+  tableData: TableData | null | undefined;
+};
+export type TableViewState = TableState & {
+  hasQueryBuilder: boolean;
+};
+
+/**
+ * `TableView` is currently in turmoil as it is containing 2 implementations
+ * of the Discover V2 QueryBuilder.
+ *
+ * The old `TableView` is split away from `table.tsx` file as it was too long
+ * and its methods have not been changed. It reads its state from `EventView`,
+ * which is shared across several component.
+ *
+ * The new `TableView` is marked with leading _ in its method names. It
+ * is coupled to the `Location` object and derives its state entirely from it.
+ * It implements methods to mutate the column state in `Location.query`.
+ */
+class TableView extends React.Component<TableViewProps, TableViewState> {
+  constructor(props) {
+    super(props);
+
+    this.setState = () => {
+      throw new Error(
+        'TableView: Please do not directly mutate the state of TableView. You can read the comments on TableView.addColumn for more information.'
+      );
+    };
+  }
+
+  state = {
+    columnOrder: [],
+    columnSortBy: [],
+    hasQueryBuilder: false,
+  } as TableViewState;
+
+  static getDerivedStateFromProps(props: TableViewProps): TableViewState {
+    const hasQueryBuilder =
+      props.organization.features.indexOf('discover-v2-query-builder') > -1;
+
+    return {
+      hasQueryBuilder,
+      ...decodeColumnOrderAndColumnSortBy(props.location),
+    };
+  }
+
+  /**
+   * The state of the columns is derived from `Location.query`. There are other
+   * components mutating the state of the column (sidebar, etc) too.
+   *
+   * To make add/edit/remove tableColumns, we will update `Location.query` and
+   * the changes will be propagated downwards to all the other components.
+   *
+   *
+   * todo(leedongwei): 18 Sept 2019
+   * It may be a good idea to move this method somewhere else so that other
+   * components mutating the column state can use it too.
+   */
+  _setColumnState = (
+    nextColumnOrder: TableColumn<keyof TableDataRow>[],
+    nextColumnSortBy: TableColumnSort<keyof TableDataRow>[]
+  ) => {
+    const {location} = this.props;
+
+    browserHistory.push({
+      ...location,
+      query: {
+        ...location.query,
+        ...encodeColumnOrderAndColumnSortBy({
+          columnOrder: nextColumnOrder,
+          columnSortBy: nextColumnSortBy,
+        }),
+      },
+    });
+  };
+
+  /**
+   * Because the "truth" on the state of the columns is found in `Location`,
+   * `addColumn`, `updateColumn`, `deleteColumn` and `moveColumn` copies some
+   * ideas from Redux / Functional Programming.
+   *
+   * It creates an entire new state and passes it to `_setColumnState`.
+   * It does not mutate the local state at all to prevent side-effects and
+   * ensure that there will always be a single source of truth.
+   */
+  _addColumn = (nextColumn: TableColumn<keyof TableDataRow>, i: number) => {
+    const {columnOrder, columnSortBy} = this.state;
+    const nextColumnOrder = [...columnOrder];
+    const nextColumnSortBy = [...columnSortBy];
+
+    nextColumnOrder.splice(i, 0, nextColumn);
+    this._setColumnState(nextColumnOrder, nextColumnSortBy);
+  };
+
+  /**
+   * Please read the comment on `addColumn`
+   */
+  _updateColumn = (nextColumn: TableColumn<keyof TableDataRow>, i: number) => {
+    const {columnOrder, columnSortBy} = this.state;
+    const nextColumnOrder = [...columnOrder];
+    const nextColumnSortBy = [...columnSortBy];
+
+    if (nextColumnOrder[i].key !== nextColumn.key) {
+      throw new Error(
+        'TableView.updateColumn: nextColumn does not have the same key as prevColumn'
+      );
+    }
+
+    nextColumnOrder[i] = nextColumn;
+    this._setColumnState(nextColumnOrder, nextColumnSortBy);
+  };
+
+  /**
+   * Please read the comment on `addColumn`
+   */
+  _deleteColumn = (i: number) => {
+    const {columnOrder, columnSortBy} = this.state;
+    const nextColumnOrder = [...columnOrder];
+    const nextColumnSortBy = [...columnSortBy];
+
+    // Disallow delete of last column and check for out-of-bounds
+    if (columnOrder.length === 1 || nextColumnOrder.length <= i) {
+      return;
+    }
+
+    // Remove column from columnOrder
+    const deletedColumn = nextColumnOrder.splice(i, 1)[0];
+
+    // Remove column from columnSortBy (if it is there)
+    // EventView will throw an error if sorting by a column that isn't displayed
+    const j = columnSortBy.findIndex(c => c.key === deletedColumn.key);
+    if (j >= 0) {
+      nextColumnSortBy.splice(i, 1);
+    }
+
+    this._setColumnState(nextColumnOrder, nextColumnSortBy);
+  };
+
+  /**
+   * Please read the comment on `addColumn`
+   */
+  _moveColumn = (fromIndex: number, toIndex: number) => {
+    const {columnOrder, columnSortBy} = this.state;
+    const nextColumnOrder = [...columnOrder];
+    const nextColumnSortBy = [...columnSortBy];
+
+    nextColumnOrder.splice(toIndex, 0, nextColumnOrder.splice(fromIndex, 1)[0]);
+    this._setColumnState(nextColumnOrder, nextColumnSortBy);
+  };
+
+  _renderGridHeaderCell = (column: TableColumn<keyof TableDataRow>): React.ReactNode => {
+    const {eventView, location, tableData} = this.props;
+    if (!tableData) {
+      return column.name;
+    }
+
+    // tood(leedongwei): Deprecate eventView and use state.columnSortBy
+    const defaultSort = eventView.getDefaultSort() || eventView.fields[0].field;
+
+    return (
+      <SortLink
+        defaultSort={defaultSort}
+        sortKey={`${column.key}`}
+        title={column.name}
+        location={location}
+      />
+    );
+  };
+
+  _renderGridBodyCell = (
+    column: TableColumn<keyof TableDataRow>,
+    dataRow: TableDataRow
+  ): React.ReactNode => {
+    const {location, organization, tableData} = this.props;
+
+    if (!tableData) {
+      return dataRow[column.key];
+    }
+
+    const fieldRenderer = getFieldRenderer(String(column.key), tableData.meta, true);
+    return fieldRenderer(dataRow, {organization, location});
+  };
+
+  renderHeader = () => {
+    const {eventView, location, tableData} = this.props;
+
+    if (eventView.fields.length <= 0) {
+      return null;
+    }
+
+    const defaultSort = eventView.getDefaultSort() || eventView.fields[0].field;
+
+    return eventView.fields.map((field, index) => {
+      if (!tableData) {
+        return <PanelHeaderCell key={index}>{field.title}</PanelHeaderCell>;
+      }
+
+      const {meta} = tableData;
+      const sortKey = eventView.getSortKey(field.field, meta);
+
+      if (sortKey === null) {
+        return <PanelHeaderCell key={index}>{field.title}</PanelHeaderCell>;
+      }
+
+      return (
+        <PanelHeaderCell key={index}>
+          <SortLink
+            defaultSort={defaultSort}
+            sortKey={sortKey}
+            title={field.title}
+            location={location}
+          />
+        </PanelHeaderCell>
+      );
+    });
+  };
+
+  renderContent = (): React.ReactNode => {
+    const {
+      isLoading,
+      tableData: dataPayload,
+      eventView,
+      organization,
+      location,
+    } = this.props;
+
+    if (isLoading && !dataPayload) {
+      return (
+        <PanelGridInfo numOfCols={eventView.numOfColumns()}>
+          <Placeholder height="240px" width="100%" />
+        </PanelGridInfo>
+      );
+    }
+    if (!(dataPayload && dataPayload.data && dataPayload.data.length > 0)) {
+      return (
+        <PanelGridInfo numOfCols={eventView.numOfColumns()}>
+          <EmptyStateWarning>
+            <p>{t('No results found')}</p>
+          </EmptyStateWarning>
+        </PanelGridInfo>
+      );
+    }
+
+    const {meta} = dataPayload;
+    const fields = eventView.getFieldNames();
+    const lastRowIndex = dataPayload.data.length - 1;
+    const hasLinkField = eventView.hasAutolinkField();
+    const firstCellIndex = 0;
+    const lastCellIndex = fields.length - 1;
+
+    return dataPayload.data.map((row, rowIndex) => {
+      return (
+        <React.Fragment key={rowIndex}>
+          {fields.map((field, columnIndex) => {
+            const key = `${field}.${columnIndex}`;
+            const forceLinkField = !hasLinkField && columnIndex === 0;
+
+            const fieldRenderer = getFieldRenderer(field, meta, forceLinkField);
+            return (
+              <PanelItemCell
+                hideBottomBorder={rowIndex === lastRowIndex}
+                style={{
+                  paddingLeft: columnIndex === firstCellIndex ? space(1) : void 0,
+                  paddingRight: columnIndex === lastCellIndex ? space(1) : void 0,
+                }}
+                key={key}
+              >
+                {fieldRenderer(row, {organization, location})}
+              </PanelItemCell>
+            );
+          })}
+        </React.Fragment>
+      );
+    });
+  };
+
+  renderTable() {
+    const {isLoading, tableData: dataPayload} = this.props;
+    return (
+      <React.Fragment>
+        {this.renderHeader()}
+        {isLoading && (
+          <FloatingLoadingContainer
+            isLoading={true}
+            isReloading={isLoading && !!dataPayload}
+          />
+        )}
+        {this.renderContent()}
+      </React.Fragment>
+    );
+  }
+
+  renderError() {
+    const {error, eventView} = this.props;
+    return (
+      <React.Fragment>
+        <Alert type="error" icon="icon-circle-exclamation">
+          {error}
+        </Alert>
+        {this.renderHeader()}
+        <PanelGrid numOfCols={eventView.numOfColumns()}>{this.renderHeader()}</PanelGrid>
+      </React.Fragment>
+    );
+  }
+
+  render() {
+    const {eventView, isLoading, error, tableData} = this.props;
+    const {hasQueryBuilder, columnOrder, columnSortBy} = this.state;
+    const {renderModalBody, renderModalFooter} = tableModalEditColumn;
+
+    if (hasQueryBuilder) {
+      return (
+        <GridEditable
+          isEditable={hasQueryBuilder}
+          isLoading={isLoading}
+          error={error}
+          data={tableData ? tableData.data : []}
+          columnOrder={columnOrder}
+          columnSortBy={columnSortBy}
+          grid={{
+            renderHeaderCell: this._renderGridHeaderCell as any,
+            renderBodyCell: this._renderGridBodyCell as any,
+          }}
+          modalEditColumn={{
+            renderBodyWithForm: renderModalBody as any,
+            renderFooter: renderModalFooter,
+          }}
+          actions={{
+            deleteColumn: this._deleteColumn,
+            moveColumn: this._moveColumn,
+          }}
+        />
+      );
+    }
+
+    // GridResizable has its own error-handling, but PanelGrid does not.
+    if (error) {
+      return this.renderError();
+    }
+
+    return (
+      <PanelGrid numOfCols={eventView.numOfColumns()}>{this.renderTable()}</PanelGrid>
+    );
+  }
+}
+
+export default TableView;
+
+type PanelGridProps = {
+  numOfCols: number;
+};
+const PanelGrid = styled((props: PanelGridProps) => {
+  const otherProps = omit(props, 'numOfCols');
+  return <Panel {...otherProps} />;
+})<PanelGridProps>`
+  display: grid;
+
+  overflow-x: auto;
+
+  ${(props: PanelGridProps) => {
+    const firstColumn = '3fr';
+
+    function generateRestColumns(): string {
+      if (props.numOfCols <= 1) {
+        return '';
+      }
+
+      return `repeat(${props.numOfCols - 1}, auto)`;
+    }
+
+    return `
+      grid-template-columns:  ${firstColumn} ${generateRestColumns()};
+    `;
+  }};
+`;
+
+const PanelHeaderCell = styled('div')`
+  color: ${p => p.theme.gray3};
+  font-size: 13px;
+  font-weight: 600;
+  text-transform: uppercase;
+  border-bottom: 1px solid ${p => p.theme.borderDark};
+  background: ${p => p.theme.offWhite};
+  line-height: 1;
+
+  text-overflow: ellipsis;
+  overflow: hidden;
+  white-space: nowrap;
+
+  padding: ${space(2)};
+
+  /**
+   * By default, a grid item cannot be smaller than the size of its content.
+   * We override this by setting it to be 0.
+   */
+  min-width: 0;
+`;
+
+type PanelGridInfoProps = {
+  numOfCols: number;
+};
+
+const PanelGridInfo = styled('div')<PanelGridInfoProps>`
+  ${(props: PanelGridInfoProps) => {
+    return `grid-column: 1 / span ${props.numOfCols};`;
+  }};
+`;
+
+const PanelItemCell = styled('div')<{hideBottomBorder: boolean}>`
+  border-bottom: ${p =>
+    p.hideBottomBorder ? 'none' : `1px solid ${p.theme.borderLight}`};
+
+  font-size: ${p => p.theme.fontSizeMedium};
+
+  padding-top: ${space(1)};
+  padding-bottom: ${space(1)};
+
+  /**
+   * By default, a grid item cannot be smaller than the size of its content.
+   * We override this by setting it to be 0.
+   */
+  min-width: 0;
+`;
+
+const FloatingLoadingContainer = styled(LoadingContainer)<LoadingContainer['props']>`
+  position: absolute;
+  top: 0;
+  left: 0;
+  right: 0;
+  bottom: 0;
+`;
diff --git a/src/sentry/static/sentry/app/views/eventsV2/utils.tsx b/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
index 907db9b649..105f9c166a 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
@@ -1,9 +1,10 @@
 import {partial, pick} from 'lodash';
-import {Location} from 'history';
+import {Location, Query} from 'history';
 
 import {Client} from 'app/api';
 import {URL_PARAM} from 'app/constants/globalSelectionHeader';
 import {appendTagCondition} from 'app/utils/queryString';
+
 import {
   AGGREGATE_ALIASES,
   SPECIAL_FIELDS,
@@ -13,6 +14,14 @@ import {
   FieldFormatterRenderFunctionPartial,
 } from './data';
 import EventView from './eventView';
+import {
+  Aggregation,
+  Field,
+  AGGREGATIONS,
+  FIELDS,
+  ColumnValueType,
+} from './eventQueryParams';
+import {TableColumn, TableColumnSort, TableState} from './tableTypes';
 
 export type EventQuery = {
   field: Array<string>;
@@ -23,6 +32,7 @@ export type EventQuery = {
 };
 
 const AGGREGATE_PATTERN = /^([^\(]+)\(([a-z\._+]*)\)$/;
+const ROUND_BRACKETS_PATTERN = /[\(\)]/;
 
 /**
  * Takes a view and determines if there are any aggregate fields in it.
@@ -204,3 +214,135 @@ export function getFirstQueryString(
 
   return defaultValue;
 }
+
+type QueryWithColumnState =
+  | Query
+  | {
+      alias: string | string[] | null | undefined;
+      field: string | string[] | null | undefined;
+      sort: string | string[] | null | undefined;
+    };
+
+export function decodeColumnOrderAndColumnSortBy(location: Location): TableState {
+  const {query} = location;
+
+  const state = {
+    columnOrder: query ? decodeColumnOrder(query) : [],
+    columnSortBy: query ? decodeColumnSortBy(query) : [],
+  };
+
+  // Check that values in SortBy is inside Order (and remove those that aren't),
+  // to avoid causing an error on the sorting function
+  state.columnSortBy = state.columnSortBy.reduce(
+    (acc, col) => {
+      if (state.columnOrder.findIndex(c => c.key === col.key) >= 0) {
+        acc.push(col);
+      }
+
+      return acc;
+    },
+    [] as TableState['columnSortBy']
+  );
+
+  return state;
+}
+
+const TEMPLATE_TABLE_COLUMN: TableColumn<React.ReactText> = {
+  key: '',
+  name: '',
+  aggregation: '',
+  field: '',
+
+  type: 'unknown',
+  isSortable: false,
+  isPrimary: false,
+};
+
+function decodeColumnOrder(query: QueryWithColumnState): TableColumn<React.ReactText>[] {
+  const {alias, field} = query;
+  const columnsRaw: {
+    aggregationField: string;
+    name: string;
+  }[] = [];
+
+  if (typeof alias === 'string' && typeof field === 'string') {
+    columnsRaw.push({aggregationField: field, name: alias});
+  } else if (
+    Array.isArray(alias) &&
+    Array.isArray(field) &&
+    alias.length === field.length
+  ) {
+    field.forEach((f, i) => {
+      columnsRaw.push({aggregationField: f, name: alias[i]});
+    });
+  }
+
+  return columnsRaw.map(col => {
+    const column: TableColumn<React.ReactText> = {...TEMPLATE_TABLE_COLUMN};
+    const aggregationField = col.aggregationField
+      .split(ROUND_BRACKETS_PATTERN)
+      .filter(Boolean);
+
+    if (aggregationField.length === 2) {
+      column.aggregation = aggregationField[0] as Aggregation;
+      column.field = aggregationField[1] as Field;
+    } else if (aggregationField.length === 1) {
+      column.field = aggregationField[0] as Field;
+    }
+
+    column.key = col.aggregationField;
+    column.name = col.name;
+    column.type = (FIELDS[column.field] || '') as ColumnValueType;
+    column.isSortable = AGGREGATIONS[column.aggregation]
+      ? AGGREGATIONS[column.aggregation].isSortable
+      : false;
+    column.isPrimary = column.field === 'title';
+
+    return column;
+  });
+}
+
+function decodeColumnSortBy(
+  query: QueryWithColumnState
+): TableColumnSort<React.ReactText>[] {
+  const {sort} = query;
+
+  // Linter forced the ternary into a single line ¯\_(ツ)_/¯
+  const keys: string[] =
+    typeof sort === 'string' ? [sort] : Array.isArray(sort) ? sort : [];
+
+  return keys.map(key => {
+    const hasLeadingDash = key[0] === '-';
+
+    return {
+      key: hasLeadingDash ? key.substring(1) : key,
+      order: hasLeadingDash ? -1 : 1,
+    } as TableColumnSort<string>;
+  });
+}
+
+export function encodeColumnOrderAndColumnSortBy(
+  tableState: TableState
+): QueryWithColumnState {
+  return {
+    alias: encodeColumnAlias(tableState),
+    field: encodeColumnField(tableState),
+    sort: encodeColumnSort(tableState),
+  };
+}
+
+function encodeColumnAlias(tableState: TableState): string[] {
+  return tableState.columnOrder.map(col => col.name);
+}
+
+function encodeColumnField(tableState: TableState): string[] {
+  return tableState.columnOrder.map(col =>
+    col.aggregation ? `${col.aggregation}(${col.field})` : col.field
+  );
+}
+
+function encodeColumnSort(tableState: TableState): string[] {
+  return tableState.columnSortBy.map(col =>
+    col.order === -1 ? `-${col.key}` : `${col.key}`
+  );
+}

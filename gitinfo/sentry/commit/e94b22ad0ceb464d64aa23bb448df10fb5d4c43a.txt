commit e94b22ad0ceb464d64aa23bb448df10fb5d4c43a
Author: Lyn Nagara <lyn.nagara@gmail.com>
Date:   Wed Nov 20 10:24:47 2019 -0800

    feat(eventstore): Run the Discover dataset and log differences (#15592)
    
    This PR introduces the SnubaDiscover eventstore backend.
    
    This alternative eventstore backend skips dataset detection in Sentry
    and simply routes the query to the Discover dataset in Snuba for the
    following methods:
    
    - get_next_event_by_id
    - get_prev_event_by_id
    - get_latest_event_by_id
    - get_earliest_event_by_id
    
    Currently results are not being returned from this dataset, we are just
    using this backend to log any differences in results with the primary
    Snuba backend.

diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index e9afaaa80c..28666833ef 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -1037,6 +1037,24 @@ SENTRY_SEARCH_OPTIONS = {}
 SENTRY_TSDB = "sentry.tsdb.dummy.DummyTSDB"
 SENTRY_TSDB_OPTIONS = {}
 
+# Event storage backend
+SENTRY_EVENTSTORE = "sentry.utils.services.ServiceDelegator"
+SENTRY_EVENTSTORE_OPTIONS = {
+    "backend_base": "sentry.eventstore.base.EventStorage",
+    "backends": {
+        "snuba": {
+            "path": "sentry.eventstore.snuba.SnubaEventStorage",
+            "executor": {"path": "sentry.utils.concurrent.SynchronousExecutor"},
+        },
+        "snuba_discover": {
+            "path": "sentry.eventstore.snuba_discover.SnubaDiscoverEventStorage",
+            "executor": {"path": "sentry.utils.services.ThreadedExecutor"},
+        },
+    },
+    "selector_func": "sentry.eventstore.utils.selector_func",
+    "callback_func": "sentry.eventstore.utils.callback_func",
+}
+
 SENTRY_NEWSLETTER = "sentry.newsletter.base.Newsletter"
 SENTRY_NEWSLETTER_OPTIONS = {}
 
diff --git a/src/sentry/eventstore/__init__.py b/src/sentry/eventstore/__init__.py
index 15d6395ee2..0c4a46fbc6 100644
--- a/src/sentry/eventstore/__init__.py
+++ b/src/sentry/eventstore/__init__.py
@@ -1,10 +1,15 @@
 from __future__ import absolute_import
 
+from django.conf import settings
+
 from sentry.utils.services import LazyServiceWrapper
 
 from .base import EventStorage, Filter  # NOQA
 
 backend = LazyServiceWrapper(
-    EventStorage, "sentry.eventstore.snuba.SnubaEventStorage", {}, metrics_path="eventstore"
+    EventStorage,
+    settings.SENTRY_EVENTSTORE,
+    settings.SENTRY_EVENTSTORE_OPTIONS,
+    metrics_path="eventstore",
 )
 backend.expose(locals())
diff --git a/src/sentry/eventstore/base.py b/src/sentry/eventstore/base.py
index 989b74cdfb..698b594147 100644
--- a/src/sentry/eventstore/base.py
+++ b/src/sentry/eventstore/base.py
@@ -92,7 +92,15 @@ class EventStorage(Service):
         Columns.USER_USERNAME,
     ]
 
-    def get_events(self, filter, additional_columns, orderby, limit, offset, referrer):
+    def get_events(
+        self,
+        filter,
+        additional_columns=None,
+        orderby=None,
+        limit=100,
+        offset=0,
+        referrer="eventstore.get_events",
+    ):
         """
         Fetches a list of events given a set of criteria.
 
@@ -106,7 +114,7 @@ class EventStorage(Service):
         """
         raise NotImplementedError
 
-    def get_event_by_id(self, project_id, event_id, additional_columns):
+    def get_event_by_id(self, project_id, event_id, additional_columns=None):
         """
         Gets a single event given a project_id and event_id.
 
diff --git a/src/sentry/eventstore/snuba/backend.py b/src/sentry/eventstore/snuba/backend.py
index 38d5bce572..ca71b4699f 100644
--- a/src/sentry/eventstore/snuba/backend.py
+++ b/src/sentry/eventstore/snuba/backend.py
@@ -8,7 +8,8 @@ from sentry.utils import snuba
 from sentry.eventstore.base import EventStorage
 from sentry.utils.validators import normalize_event_id
 
-DEFAULT_ORDERBY = ["-timestamp", "-event_id"]
+DESC_ORDERING = ["-timestamp", "-event_id"]
+ASC_ORDERING = ["timestamp", "event_id"]
 DEFAULT_LIMIT = 100
 DEFAULT_OFFSET = 0
 
@@ -36,7 +37,7 @@ class SnubaEventStorage(EventStorage):
         self,
         filter,
         additional_columns=None,
-        orderby=DEFAULT_ORDERBY,
+        orderby=None,
         limit=DEFAULT_LIMIT,
         offset=DEFAULT_OFFSET,
         referrer="eventstore.get_events",
@@ -46,6 +47,7 @@ class SnubaEventStorage(EventStorage):
         """
         assert filter, "You must provide a filter"
         cols = self.__get_columns(additional_columns)
+        orderby = orderby or DESC_ORDERING
 
         result = snuba.dataset_query(
             selected_columns=cols,
@@ -87,24 +89,20 @@ class SnubaEventStorage(EventStorage):
         return None
 
     def get_earliest_event_id(self, event, filter):
-        orderby = ["timestamp", "event_id"]
-
         filter = deepcopy(filter)
         filter.conditions = filter.conditions or []
         filter.conditions.extend(get_before_event_condition(event))
         filter.end = event.datetime
 
-        return self.__get_event_id_from_filter(filter=filter, orderby=orderby)
+        return self.__get_event_id_from_filter(filter=filter, orderby=ASC_ORDERING)
 
     def get_latest_event_id(self, event, filter):
-        orderby = ["-timestamp", "-event_id"]
-
         filter = deepcopy(filter)
         filter.conditions = filter.conditions or []
         filter.conditions.extend(get_after_event_condition(event))
         filter.start = event.datetime
 
-        return self.__get_event_id_from_filter(filter=filter, orderby=orderby)
+        return self.__get_event_id_from_filter(filter=filter, orderby=DESC_ORDERING)
 
     def get_next_event_id(self, event, filter):
         """
@@ -121,7 +119,7 @@ class SnubaEventStorage(EventStorage):
         filter.conditions.extend(get_after_event_condition(event))
         filter.start = event.datetime
 
-        return self.__get_event_id_from_filter(filter=filter, orderby=["timestamp", "event_id"])
+        return self.__get_event_id_from_filter(filter=filter, orderby=ASC_ORDERING)
 
     def get_prev_event_id(self, event, filter):
         """
@@ -138,7 +136,7 @@ class SnubaEventStorage(EventStorage):
         filter.conditions.extend(get_before_event_condition(event))
         filter.end = event.datetime
 
-        return self.__get_event_id_from_filter(filter=filter, orderby=["-timestamp", "-event_id"])
+        return self.__get_event_id_from_filter(filter=filter, orderby=DESC_ORDERING)
 
     def __get_columns(self, additional_columns):
         columns = EventStorage.minimal_columns
diff --git a/src/sentry/eventstore/snuba_discover/__init__.py b/src/sentry/eventstore/snuba_discover/__init__.py
new file mode 100644
index 0000000000..e30c939eb5
--- /dev/null
+++ b/src/sentry/eventstore/snuba_discover/__init__.py
@@ -0,0 +1,3 @@
+from __future__ import absolute_import
+
+from .backend import SnubaDiscoverEventStorage  # NOQA
diff --git a/src/sentry/eventstore/snuba_discover/backend.py b/src/sentry/eventstore/snuba_discover/backend.py
new file mode 100644
index 0000000000..0231a67eee
--- /dev/null
+++ b/src/sentry/eventstore/snuba_discover/backend.py
@@ -0,0 +1,98 @@
+from __future__ import absolute_import
+
+import six
+from copy import deepcopy
+
+from sentry.utils import snuba
+from sentry.eventstore.base import EventStorage
+from sentry.eventstore.snuba.backend import (
+    ASC_ORDERING,
+    DESC_ORDERING,
+    get_after_event_condition,
+    get_before_event_condition,
+    SnubaEventStorage,
+)
+
+
+class SnubaDiscoverEventStorage(EventStorage):
+    """
+    Experimental backend that uses the Snuba Discover dataset instead of Events
+    or Transactions directly.
+    """
+
+    def get_events(self, *args, **kwargs):
+        return SnubaEventStorage().get_events(*args, **kwargs)
+
+    def get_event_by_id(self, *args, **kwargs):
+        return SnubaEventStorage().get_event_by_id(*args, **kwargs)
+
+    def get_earliest_event_id(self, event, filter):
+        filter = deepcopy(filter)
+        filter.conditions = filter.conditions or []
+        filter.conditions.extend(get_before_event_condition(event))
+        filter.end = event.datetime
+
+        return self.__get_event_id_from_filter(filter=filter, orderby=ASC_ORDERING)
+
+    def get_latest_event_id(self, event, filter):
+        filter = deepcopy(filter)
+        filter.conditions = filter.conditions or []
+        filter.conditions.extend(get_after_event_condition(event))
+        filter.start = event.datetime
+
+        return self.__get_event_id_from_filter(filter=filter, orderby=DESC_ORDERING)
+
+    def get_next_event_id(self, event, filter):
+        """
+        Returns (project_id, event_id) of a next event given a current event
+        and any filters/conditions. Returns None if no next event is found.
+        """
+        assert filter, "You must provide a filter"
+
+        if not event:
+            return None
+
+        filter = deepcopy(filter)
+        filter.conditions = filter.conditions or []
+        filter.conditions.extend(get_after_event_condition(event))
+        filter.start = event.datetime
+
+        return self.__get_event_id_from_filter(filter=filter, orderby=ASC_ORDERING)
+
+    def get_prev_event_id(self, event, filter):
+        """
+        Returns (project_id, event_id) of a previous event given a current event
+        and a filter. Returns None if no previous event is found.
+        """
+        assert filter, "You must provide a filter"
+
+        if not event:
+            return None
+
+        filter = deepcopy(filter)
+        filter.conditions = filter.conditions or []
+        filter.conditions.extend(get_before_event_condition(event))
+        filter.end = event.datetime
+
+        return self.__get_event_id_from_filter(filter=filter, orderby=DESC_ORDERING)
+
+    def __get_event_id_from_filter(self, filter=None, orderby=None):
+        columns = ["event_id", "project_id", "timestamp"]
+        result = snuba.raw_query(
+            selected_columns=columns,
+            conditions=filter.conditions,
+            filter_keys=filter.filter_keys,
+            start=filter.start,
+            end=filter.end,
+            limit=1,
+            referrer="eventstore.discover_dataset.get_next_or_prev_event_id",
+            orderby=orderby,
+            dataset=snuba.Dataset.Discover,
+        )
+
+        if "error" in result or len(result["data"]) == 0:
+            return None
+
+        row = result["data"][0]
+
+        return (six.text_type(row["project_id"]), six.text_type(row["event_id"]))
diff --git a/src/sentry/eventstore/utils.py b/src/sentry/eventstore/utils.py
new file mode 100644
index 0000000000..a9c7ac3a0b
--- /dev/null
+++ b/src/sentry/eventstore/utils.py
@@ -0,0 +1,44 @@
+from __future__ import absolute_import
+
+import logging
+
+get_by_id_methods = [
+    "get_next_event_id",
+    "get_prev_event_id",
+    "get_earliest_event_id",
+    "get_latest_event_id",
+]
+
+methods_to_test = get_by_id_methods
+
+logger = logging.getLogger("sentry.eventstore")
+
+
+def selector_func(context, method, callargs):
+    if method in methods_to_test:
+        return ["snuba", "snuba_discover"]
+
+    return ["snuba"]
+
+
+def callback_func(context, method, callargs, backends, results):
+    """
+    Log if results are different
+    """
+    if backends == ["snuba", "snuba_discover"]:
+        if method in get_by_id_methods:
+            snuba_result = results[0].result()
+            snuba_discover_reuslt = results[1].result()
+
+            if snuba_result != snuba_discover_reuslt:
+                logger.info(
+                    "discover.result-mismatch",
+                    extra={
+                        "method": method,
+                        "event_id": callargs["event"].event_id,
+                        "filter_keys": callargs["filter"].filter_keys,
+                        "conditions": callargs["filter"].conditions,
+                        "snuba_result": results[0].result(),
+                        "snuba_discover_result": results[1].result(),
+                    },
+                )
diff --git a/src/sentry/utils/pytest/sentry.py b/src/sentry/utils/pytest/sentry.py
index f1f10c8648..0e3af85f76 100644
--- a/src/sentry/utils/pytest/sentry.py
+++ b/src/sentry/utils/pytest/sentry.py
@@ -1,5 +1,6 @@
 from __future__ import absolute_import
 
+from copy import deepcopy
 import mock
 import os
 
@@ -101,6 +102,13 @@ def pytest_configure(config):
         settings.SENTRY_TSDB = "sentry.tsdb.redissnuba.RedisSnubaTSDB"
         settings.SENTRY_EVENTSTREAM = "sentry.eventstream.snuba.SnubaEventStream"
 
+    # Use the synchronous executor to make multiple backends easier to test
+    eventstore_options = deepcopy(settings.SENTRY_EVENTSTORE_OPTIONS)
+    eventstore_options["backends"]["snuba_discover"]["executor"][
+        "path"
+    ] = "sentry.utils.concurrent.SynchronousExecutor"
+    settings.SENTRY_EVENTSTORE_OPTIONS = eventstore_options
+
     if not hasattr(settings, "SENTRY_OPTIONS"):
         settings.SENTRY_OPTIONS = {}
 
diff --git a/src/sentry/utils/snuba.py b/src/sentry/utils/snuba.py
index 7bef52114e..b6c4c273ce 100644
--- a/src/sentry/utils/snuba.py
+++ b/src/sentry/utils/snuba.py
@@ -63,6 +63,7 @@ TRANSACTIONS_SENTRY_SNUBA_MAP = {
 class Dataset(Enum):
     Events = "events"
     Transactions = "transactions"
+    Discover = "discover"
     Outcomes = "outcomes"
     OutcomesRaw = "outcomes_raw"
 
@@ -609,7 +610,7 @@ def _prepare_query_params(query_params):
             query_params.filter_keys, is_grouprelease=query_params.is_grouprelease
         )
 
-    if query_params.dataset in [Dataset.Events, Dataset.Transactions]:
+    if query_params.dataset in [Dataset.Events, Dataset.Transactions, Dataset.Discover]:
         (organization_id, params_to_update) = get_query_params_to_update_for_projects(query_params)
     elif query_params.dataset in [Dataset.Outcomes, Dataset.OutcomesRaw]:
         (organization_id, params_to_update) = get_query_params_to_update_for_organizations(
diff --git a/tests/sentry/eventstore/snuba/__init__.py b/tests/sentry/eventstore/snuba/__init__.py
new file mode 100644
index 0000000000..c3961685ab
--- /dev/null
+++ b/tests/sentry/eventstore/snuba/__init__.py
@@ -0,0 +1 @@
+from __future__ import absolute_import
diff --git a/tests/sentry/eventstore/snuba_discover/__init__.py b/tests/sentry/eventstore/snuba_discover/__init__.py
new file mode 100644
index 0000000000..c3961685ab
--- /dev/null
+++ b/tests/sentry/eventstore/snuba_discover/__init__.py
@@ -0,0 +1 @@
+from __future__ import absolute_import
diff --git a/tests/sentry/eventstore/snuba_discover/test_backend.py b/tests/sentry/eventstore/snuba_discover/test_backend.py
new file mode 100644
index 0000000000..fa0e884647
--- /dev/null
+++ b/tests/sentry/eventstore/snuba_discover/test_backend.py
@@ -0,0 +1,175 @@
+from __future__ import absolute_import
+
+import six
+import pytest
+
+from sentry.testutils import TestCase, SnubaTestCase
+from sentry.testutils.helpers.datetime import iso_format, before_now
+from sentry.eventstore.snuba_discover.backend import SnubaDiscoverEventStorage
+from sentry.eventstore.base import Filter
+
+from sentry.utils.samples import load_data
+
+
+class SnubaDiscoverEventStorageTest(TestCase, SnubaTestCase):
+    """
+    This is just a temporary copy/paste of eventstore.snuba.test_backend
+    """
+
+    def setUp(self):
+        super(SnubaDiscoverEventStorageTest, self).setUp()
+        self.min_ago = iso_format(before_now(minutes=1))
+        self.two_min_ago = iso_format(before_now(minutes=2))
+        self.project1 = self.create_project()
+        self.project2 = self.create_project()
+
+        self.event1 = self.store_event(
+            data={
+                "event_id": "a" * 32,
+                "type": "default",
+                "platform": "python",
+                "fingerprint": ["group1"],
+                "timestamp": self.two_min_ago,
+                "tags": {"foo": "1"},
+            },
+            project_id=self.project1.id,
+        )
+        self.event2 = self.store_event(
+            data={
+                "event_id": "b" * 32,
+                "type": "default",
+                "platform": "python",
+                "fingerprint": ["group1"],
+                "timestamp": self.min_ago,
+                "tags": {"foo": "1"},
+            },
+            project_id=self.project2.id,
+        )
+        self.event3 = self.store_event(
+            data={
+                "event_id": "c" * 32,
+                "type": "default",
+                "platform": "python",
+                "fingerprint": ["group2"],
+                "timestamp": self.min_ago,
+                "tags": {"foo": "1"},
+            },
+            project_id=self.project2.id,
+        )
+
+        event_data = load_data("transaction")
+        event_data["timestamp"] = iso_format(before_now(minutes=1))
+        event_data["start_timestamp"] = iso_format(before_now(minutes=1, seconds=1))
+        event_data["event_id"] = "d" * 32
+
+        self.transaction_event = self.store_event(data=event_data, project_id=self.project2.id)
+
+        event_data_2 = load_data("transaction")
+        event_data_2["timestamp"] = iso_format(before_now(seconds=30))
+        event_data_2["start_timestamp"] = iso_format(before_now(seconds=31))
+
+        event_data_2["event_id"] = "e" * 32
+
+        self.transaction_event_2 = self.store_event(data=event_data_2, project_id=self.project2.id)
+
+        self.eventstore = SnubaDiscoverEventStorage()
+
+    def test_get_events(self):
+        events = self.eventstore.get_events(
+            filter=Filter(project_ids=[self.project1.id, self.project2.id])
+        )
+        assert len(events) == 5
+        # Default sort is timestamp desc, event_id desc
+        assert events[0].id == "e" * 32
+        assert events[1].id == "d" * 32
+        assert events[2].id == "c" * 32
+        assert events[3].id == "b" * 32
+        assert events[4].id == "a" * 32
+
+        # No events found
+        project = self.create_project()
+        events = self.eventstore.get_events(filter=Filter(project_ids=[project.id]))
+        assert events == []
+
+    def test_get_event_by_id(self):
+        # Get event with default columns
+        event = self.eventstore.get_event_by_id(self.project1.id, "a" * 32)
+
+        assert event.id == "a" * 32
+        assert event.event_id == "a" * 32
+        assert event.project_id == self.project1.id
+        assert len(event.snuba_data.keys()) == 4
+
+        # Get all columns
+        event = self.eventstore.get_event_by_id(
+            self.project2.id, "b" * 32, self.eventstore.full_columns
+        )
+        assert event.id == "b" * 32
+        assert event.event_id == "b" * 32
+        assert event.project_id == self.project2.id
+        assert len(event.snuba_data.keys()) == 17
+
+        # Get non existent event
+        event = self.eventstore.get_event_by_id(self.project2.id, "f" * 32)
+        assert event is None
+
+    def test_get_next_prev_event_id(self):
+        event = self.eventstore.get_event_by_id(self.project2.id, "b" * 32)
+
+        filter = Filter(project_ids=[self.project1.id, self.project2.id])
+
+        prev_event = self.eventstore.get_prev_event_id(event, filter=filter)
+
+        next_event = self.eventstore.get_next_event_id(event, filter=filter)
+
+        assert prev_event == (six.text_type(self.project1.id), "a" * 32)
+
+        # Events with the same timestamp are sorted by event_id
+        assert next_event == (six.text_type(self.project2.id), "c" * 32)
+
+        # Returns None if no event
+        assert self.eventstore.get_prev_event_id(None, filter=filter) is None
+        assert self.eventstore.get_next_event_id(None, filter=filter) is None
+
+    def test_get_latest_or_oldest_event_id(self):
+        # Returns a latest/oldest event
+        event = self.eventstore.get_event_by_id(self.project2.id, "b" * 32)
+        filter = Filter(project_ids=[self.project1.id, self.project2.id])
+        oldest_event = self.eventstore.get_earliest_event_id(event, filter=filter)
+        latest_event = self.eventstore.get_latest_event_id(event, filter=filter)
+        assert oldest_event == (six.text_type(self.project1.id), "a" * 32)
+        assert latest_event == (six.text_type(self.project2.id), "e" * 32)
+
+        # Returns none when no latest/oldest event that meets conditions
+        event = self.eventstore.get_event_by_id(self.project2.id, "b" * 32)
+        filter = Filter(project_ids=[self.project1.id], group_ids=[self.event2.group_id])
+        oldest_event = self.eventstore.get_earliest_event_id(event, filter=filter)
+        latest_event = self.eventstore.get_latest_event_id(event, filter=filter)
+        assert oldest_event is None
+        assert latest_event is None
+
+    def test_transaction_get_event_by_id(self):
+        event = self.eventstore.get_event_by_id(self.project2.id, self.transaction_event.event_id)
+
+        assert event.id == "d" * 32
+        assert event.get_event_type() == "transaction"
+        assert event.project_id == self.project2.id
+
+    @pytest.mark.skip(reason="Not yet implemented")
+    def test_transaction_get_next_prev_event_id(self):
+        filter = Filter(
+            project_ids=[self.project1.id, self.project2.id],
+            conditions=[["type", "=", "transaction"]],
+        )
+
+        event = self.eventstore.get_event_by_id(self.project2.id, "e" * 32)
+        prev_event = self.eventstore.get_prev_event_id(event, filter=filter)
+        next_event = self.eventstore.get_next_event_id(event, filter=filter)
+        assert prev_event == (six.text_type(self.project2.id), "d" * 32)
+        assert next_event is None
+
+        event = self.eventstore.get_event_by_id(self.project2.id, "d" * 32)
+        prev_event = self.eventstore.get_prev_event_id(event, filter=filter)
+        next_event = self.eventstore.get_next_event_id(event, filter=filter)
+        assert prev_event is None
+        assert next_event == (six.text_type(self.project2.id), "e" * 32)
diff --git a/tests/sentry/eventstore/test_base.py b/tests/sentry/eventstore/test_base.py
index a330cffc3e..fe472580b9 100644
--- a/tests/sentry/eventstore/test_base.py
+++ b/tests/sentry/eventstore/test_base.py
@@ -1,10 +1,16 @@
 from __future__ import absolute_import
 
+import logging
+import mock
+import six
+
 from sentry import eventstore
-from sentry.testutils import TestCase
+from sentry.testutils import SnubaTestCase, TestCase
 from sentry.testutils.helpers.datetime import iso_format, before_now
 from sentry.eventstore.base import EventStorage
 
+from sentry.utils.samples import load_data
+
 
 class EventStorageTest(TestCase):
     def setUp(self):
@@ -36,3 +42,60 @@ class EventStorageTest(TestCase):
         self.eventstorage.bind_nodes([event, event2], "data")
         assert event.data._node_data is not None
         assert event.data["user"]["id"] == u"user1"
+
+
+class ServiceDelegationTest(TestCase, SnubaTestCase):
+    def setUp(self):
+        super(ServiceDelegationTest, self).setUp()
+        self.min_ago = iso_format(before_now(minutes=1))
+        self.two_min_ago = iso_format(before_now(minutes=2))
+        self.project = self.create_project()
+
+        self.event = self.store_event(
+            data={
+                "event_id": "a" * 32,
+                "type": "default",
+                "platform": "python",
+                "fingerprint": ["group1"],
+                "timestamp": self.two_min_ago,
+                "tags": {"foo": "1"},
+            },
+            project_id=self.project.id,
+        )
+
+        event_data = load_data("transaction")
+        event_data["timestamp"] = iso_format(before_now(minutes=1))
+        event_data["start_timestamp"] = iso_format(before_now(minutes=1, seconds=1))
+        event_data["event_id"] = "b" * 32
+
+        self.transaction_event = self.store_event(data=event_data, project_id=self.project.id)
+
+    def test_logs_differences(self):
+
+        logger = logging.getLogger("sentry.eventstore")
+
+        with mock.patch.object(logger, "info") as mock_logger:
+            # No differences to log
+            filter = eventstore.Filter(project_ids=[self.project.id])
+            eventstore.get_events(filter=filter)
+            eventstore.get_event_by_id(self.project.id, "a" * 32)
+            assert mock_logger.call_count == 0
+
+            # Here we expect a difference since the original implementation handles type as a tag
+            event = eventstore.get_event_by_id(self.project.id, "a" * 32)
+            filter = eventstore.Filter(
+                project_ids=[self.project.id], conditions=[["type", "=", "transaction"]]
+            )
+            eventstore.get_next_event_id(event, filter)
+            assert mock_logger.call_count == 1
+            mock_logger.assert_called_with(
+                "discover.result-mismatch",
+                extra={
+                    "snuba_result": None,
+                    "snuba_discover_result": (six.text_type(self.project.id), "b" * 32),
+                    "method": "get_next_event_id",
+                    "event_id": event.event_id,
+                    "filter_keys": filter.filter_keys,
+                    "conditions": filter.conditions,
+                },
+            )

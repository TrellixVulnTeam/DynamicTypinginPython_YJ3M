commit 7c10ce474c2015f0ca30e9559cf4845175085b03
Author: Dan Fuller <dfuller@sentry.io>
Date:   Thu May 14 15:20:05 2020 -0700

    refs(alert_rules): Stop using query related fields on AlertRule and QuerySubscription. Remove unused columns from models, and unused Models (#18805)
    
    This removes all query related fields from both `AlertRule` and `QuerySubscription`, since we can
    now rely solely on `SnubaQuery`. This also removes the *Environment many to many tables, since these
    are also unused. This migration only removes them from the state - we'll add another migration later to really remove the columns and unused tables.
    
    As part of this pr we remove any final outstanding uses of these columns and tables as well.

diff --git a/migrations_lockfile.txt b/migrations_lockfile.txt
index 41f15e5a8c..80ba8432ba 100644
--- a/migrations_lockfile.txt
+++ b/migrations_lockfile.txt
@@ -10,7 +10,7 @@ auth: 0008_alter_user_username_max_length
 contenttypes: 0002_remove_content_type_name
 jira_ac: 0001_initial
 nodestore: 0001_initial
-sentry: 0076_alert_rules_disable_constraints
+sentry: 0077_alert_query_col_drop_state
 sessions: 0001_initial
 sites: 0002_alter_domain_unique
 social_auth: 0001_initial
diff --git a/src/sentry/api/endpoints/organization_incident_index.py b/src/sentry/api/endpoints/organization_incident_index.py
index 33e7b45646..0e23267580 100644
--- a/src/sentry/api/endpoints/organization_incident_index.py
+++ b/src/sentry/api/endpoints/organization_incident_index.py
@@ -68,7 +68,7 @@ class OrganizationIncidentIndexEndpoint(OrganizationEndpoint):
 
         envs = self.get_environments(request, organization)
         if envs:
-            incidents = incidents.filter(alert_rule__environment__in=envs)
+            incidents = incidents.filter(alert_rule__snuba_query__environment__in=envs)
 
         query_status = request.GET.get("status")
         if query_status is not None:
diff --git a/src/sentry/incidents/endpoints/serializers.py b/src/sentry/incidents/endpoints/serializers.py
index 4658d57735..979de17513 100644
--- a/src/sentry/incidents/endpoints/serializers.py
+++ b/src/sentry/incidents/endpoints/serializers.py
@@ -274,6 +274,12 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
     projects = serializers.ListField(child=ProjectField(), required=False)
     excluded_projects = serializers.ListField(child=ProjectField(), required=False)
     triggers = serializers.ListField(required=True)
+    query = serializers.CharField(required=True, allow_blank=True)
+    time_window = serializers.IntegerField(
+        required=True, min_value=1, max_value=int(timedelta(days=1).total_seconds() / 60)
+    )
+    threshold_period = serializers.IntegerField(default=1, min_value=1, max_value=20)
+    aggregation = serializers.IntegerField(required=False)
 
     class Meta:
         model = AlertRule
@@ -290,14 +296,6 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
             "triggers",
         ]
         extra_kwargs = {
-            "query": {"allow_blank": True, "required": True},
-            "threshold_period": {"default": 1, "min_value": 1, "max_value": 20},
-            "time_window": {
-                "min_value": 1,
-                "max_value": int(timedelta(days=1).total_seconds() / 60),
-                "required": True,
-            },
-            "aggregation": {"required": False},
             "name": {"min_length": 1, "max_length": 64},
             "include_all_projects": {"default": False},
         }
diff --git a/src/sentry/incidents/logic.py b/src/sentry/incidents/logic.py
index 628d66d615..5ac03fb1c8 100644
--- a/src/sentry/incidents/logic.py
+++ b/src/sentry/incidents/logic.py
@@ -14,7 +14,6 @@ from sentry.api.event_search import get_filter
 from sentry.incidents import tasks
 from sentry.incidents.models import (
     AlertRule,
-    AlertRuleEnvironment,
     AlertRuleExcludedProjects,
     AlertRuleStatus,
     AlertRuleTrigger,
@@ -35,7 +34,7 @@ from sentry.incidents.models import (
 )
 from sentry.models import Integration, Project
 from sentry.snuba.discover import resolve_discover_aliases
-from sentry.snuba.models import query_aggregation_to_snuba, QueryAggregations, QueryDatasets
+from sentry.snuba.models import query_aggregation_to_snuba, QueryDatasets
 from sentry.snuba.subscriptions import (
     aggregate_to_query_aggregation,
     bulk_create_snuba_subscriptions,
@@ -593,11 +592,6 @@ def create_alert_rule(
             organization=organization,
             snuba_query=snuba_query,
             name=name,
-            dataset=dataset.value,
-            query=query,
-            aggregation=aggregation.value,
-            time_window=time_window,
-            resolution=resolution,
             threshold_period=threshold_period,
             include_all_projects=include_all_projects,
         )
@@ -613,9 +607,6 @@ def create_alert_rule(
             ]
             AlertRuleExcludedProjects.objects.bulk_create(exclusions)
 
-        if environment:
-            AlertRuleEnvironment.objects.create(alert_rule=alert_rule, environment=environment)
-
         subscribe_projects_to_alert_rule(alert_rule, projects)
 
     return alert_rule
@@ -699,12 +690,10 @@ def update_alert_rule(
         updated_fields["name"] = name
     if query is not None:
         validate_alert_rule_query(query)
-        updated_query_fields["query"] = updated_fields["query"] = query
+        updated_query_fields["query"] = query
     if aggregation is not None:
-        updated_fields["aggregation"] = aggregation.value
         updated_query_fields["aggregation"] = aggregation
     if time_window:
-        updated_fields["time_window"] = time_window
         updated_query_fields["time_window"] = timedelta(minutes=time_window)
     if threshold_period:
         updated_fields["threshold_period"] = threshold_period
@@ -723,7 +712,7 @@ def update_alert_rule(
             # XXX: We use the alert rule aggregation here since currently we're
             # expecting the enum value to be passed.
             updated_query_fields.setdefault(
-                "aggregation", QueryAggregations(alert_rule.aggregation)
+                "aggregation", aggregate_to_query_aggregation[snuba_query.aggregate]
             )
             updated_query_fields.setdefault(
                 "time_window", timedelta(seconds=snuba_query.time_window)
@@ -798,17 +787,6 @@ def update_alert_rule(
         if deleted_subs:
             bulk_delete_snuba_subscriptions(deleted_subs)
 
-        if environment:
-            # Delete rows we don't have present in the updated data.
-            AlertRuleEnvironment.objects.filter(alert_rule=alert_rule).exclude(
-                environment=environment
-            ).delete()
-            AlertRuleEnvironment.objects.get_or_create(
-                alert_rule=alert_rule, environment=environment
-            )
-        else:
-            AlertRuleEnvironment.objects.filter(alert_rule=alert_rule).delete()
-
     return alert_rule
 
 
diff --git a/src/sentry/incidents/models.py b/src/sentry/incidents/models.py
index 23cb3ed8e4..d1dc7f5bad 100644
--- a/src/sentry/incidents/models.py
+++ b/src/sentry/incidents/models.py
@@ -352,31 +352,6 @@ class AlertRuleManager(BaseManager):
             )
 
 
-class AlertRuleEnvironment(Model):
-    __core__ = True
-
-    environment = FlexibleForeignKey("sentry.Environment", db_constraint=False)
-    alert_rule = FlexibleForeignKey("sentry.AlertRule", db_constraint=False)
-
-    class Meta:
-        app_label = "sentry"
-        db_table = "sentry_alertruleenvironment"
-        unique_together = (("alert_rule", "environment"),)
-
-
-class AlertRuleQuerySubscription(Model):
-    __core__ = True
-
-    query_subscription = FlexibleForeignKey(
-        "sentry.QuerySubscription", db_constraint=False, unique=True
-    )
-    alert_rule = FlexibleForeignKey("sentry.AlertRule", db_constraint=False)
-
-    class Meta:
-        app_label = "sentry"
-        db_table = "sentry_alertrulequerysubscription"
-
-
 class AlertRuleExcludedProjects(Model):
     __core__ = True
 
@@ -398,26 +373,14 @@ class AlertRule(Model):
 
     organization = FlexibleForeignKey("sentry.Organization", null=True)
     snuba_query = FlexibleForeignKey("sentry.SnubaQuery", null=True, unique=True)
-    query_subscriptions = models.ManyToManyField(
-        "sentry.QuerySubscription", related_name="alert_rules", through=AlertRuleQuerySubscription
-    )
     excluded_projects = models.ManyToManyField(
         "sentry.Project", related_name="alert_rule_exclusions", through=AlertRuleExcludedProjects
     )
     name = models.TextField()
     status = models.SmallIntegerField(default=AlertRuleStatus.PENDING.value)
-    dataset = models.TextField(null=True)
-    query = models.TextField(null=True)
-    environment = models.ManyToManyField(
-        "sentry.Environment", related_name="alert_rule_environment", through=AlertRuleEnvironment
-    )
     # Determines whether we include all current and future projects from this
     # organization in this rule.
     include_all_projects = models.BooleanField(default=False)
-    # TODO: Remove this default after we migrate
-    aggregation = models.IntegerField(default=QueryAggregations.TOTAL.value, null=True)
-    time_window = models.IntegerField(null=True)
-    resolution = models.IntegerField(null=True)
     threshold_period = models.IntegerField()
     date_modified = models.DateTimeField(default=timezone.now)
     date_added = models.DateTimeField(default=timezone.now)
diff --git a/src/sentry/integrations/slack/utils.py b/src/sentry/integrations/slack/utils.py
index be20394bfb..dfb655cb7c 100644
--- a/src/sentry/integrations/slack/utils.py
+++ b/src/sentry/integrations/slack/utils.py
@@ -13,6 +13,7 @@ from sentry.api.fields.actor import Actor
 from sentry.incidents.logic import get_incident_aggregates
 from sentry.incidents.models import IncidentStatus, IncidentTrigger
 from sentry.snuba.models import QueryAggregations
+from sentry.snuba.subscriptions import aggregate_to_query_aggregation
 from sentry.utils import json
 from sentry.utils.assets import get_asset_url
 from sentry.utils.dates import to_timestamp
@@ -314,11 +315,12 @@ def build_incident_attachment(incident):
         status = "Critical"
         color = LEVEL_TO_COLOR["fatal"]
 
-    agg_text = QUERY_AGGREGATION_DISPLAY[alert_rule.aggregation]
+    query_aggregation = aggregate_to_query_aggregation[alert_rule.snuba_query.aggregate]
+    agg_text = QUERY_AGGREGATION_DISPLAY[query_aggregation.value]
 
     agg_value = (
         aggregates["count"]
-        if alert_rule.aggregation == QueryAggregations.TOTAL.value
+        if query_aggregation == QueryAggregations.TOTAL
         else aggregates["unique_users"]
     )
     time_window = alert_rule.snuba_query.time_window / 60
@@ -326,7 +328,7 @@ def build_incident_attachment(incident):
     text = "{} {} in the last {} minutes".format(agg_value, agg_text, time_window)
 
     if alert_rule.snuba_query.query != "":
-        text = text + "\nFilter: {}".format(alert_rule.query)
+        text = text + "\nFilter: {}".format(alert_rule.snuba_query.query)
 
     ts = incident.date_started
 
diff --git a/src/sentry/migrations/0077_alert_query_col_drop_state.py b/src/sentry/migrations/0077_alert_query_col_drop_state.py
new file mode 100644
index 0000000000..9c6d209d19
--- /dev/null
+++ b/src/sentry/migrations/0077_alert_query_col_drop_state.py
@@ -0,0 +1,67 @@
+# -*- coding: utf-8 -*-
+# Generated by Django 1.11.29 on 2020-05-13 22:23
+from __future__ import unicode_literals
+
+from django.db import migrations
+
+
+class Migration(migrations.Migration):
+    # This flag is used to mark that a migration shouldn't be automatically run in
+    # production. We set this to True for operations that we think are risky and want
+    # someone from ops to run manually and monitor.
+    # General advice is that if in doubt, mark your migration as `is_dangerous`.
+    # Some things you should always mark as dangerous:
+    # - Large data migrations. Typically we want these to be run manually by ops so that
+    #   they can be monitored. Since data migrations will now hold a transaction open
+    #   this is even more important.
+    # - Adding columns to highly active tables, even ones that are NULL.
+    is_dangerous = False
+
+    # This flag is used to decide whether to run this migration in a transaction or not.
+    # By default we prefer to run in a transaction, but for migrations where you want
+    # to `CREATE INDEX CONCURRENTLY` this needs to be set to False. Typically you'll
+    # want to create an index concurrently when adding one to an existing table.
+    atomic = True
+
+    dependencies = [("sentry", "0076_alert_rules_disable_constraints")]
+
+    operations = [
+        migrations.SeparateDatabaseAndState(
+            state_operations=[
+                migrations.AlterUniqueTogether(
+                    name="alertruleenvironment", unique_together=set([])
+                ),
+                migrations.RemoveField(model_name="alertruleenvironment", name="alert_rule"),
+                migrations.RemoveField(model_name="alertruleenvironment", name="environment"),
+                migrations.RemoveField(model_name="alertrulequerysubscription", name="alert_rule"),
+                migrations.RemoveField(
+                    model_name="alertrulequerysubscription", name="query_subscription"
+                ),
+                migrations.AlterUniqueTogether(
+                    name="querysubscriptionenvironment", unique_together=set([])
+                ),
+                migrations.RemoveField(
+                    model_name="querysubscriptionenvironment", name="environment"
+                ),
+                migrations.RemoveField(
+                    model_name="querysubscriptionenvironment", name="query_subscription"
+                ),
+                migrations.RemoveField(model_name="alertrule", name="aggregation"),
+                migrations.RemoveField(model_name="alertrule", name="dataset"),
+                migrations.RemoveField(model_name="alertrule", name="environment"),
+                migrations.RemoveField(model_name="alertrule", name="query"),
+                migrations.RemoveField(model_name="alertrule", name="query_subscriptions"),
+                migrations.RemoveField(model_name="alertrule", name="resolution"),
+                migrations.RemoveField(model_name="alertrule", name="time_window"),
+                migrations.RemoveField(model_name="querysubscription", name="aggregation"),
+                migrations.RemoveField(model_name="querysubscription", name="dataset"),
+                migrations.RemoveField(model_name="querysubscription", name="environments"),
+                migrations.RemoveField(model_name="querysubscription", name="query"),
+                migrations.RemoveField(model_name="querysubscription", name="resolution"),
+                migrations.RemoveField(model_name="querysubscription", name="time_window"),
+                migrations.DeleteModel(name="AlertRuleEnvironment"),
+                migrations.DeleteModel(name="AlertRuleQuerySubscription"),
+                migrations.DeleteModel(name="QuerySubscriptionEnvironment"),
+            ]
+        )
+    ]
diff --git a/src/sentry/snuba/models.py b/src/sentry/snuba/models.py
index 90f777fa0b..a27e8f6fdf 100644
--- a/src/sentry/snuba/models.py
+++ b/src/sentry/snuba/models.py
@@ -25,19 +25,6 @@ class QueryDatasets(Enum):
     EVENTS = "events"
 
 
-class QuerySubscriptionEnvironment(Model):
-    __core__ = True
-
-    query_subscription = FlexibleForeignKey("sentry.QuerySubscription", db_constraint=False)
-    environment = FlexibleForeignKey("sentry.Environment", db_constraint=False)
-    date_added = models.DateTimeField(default=timezone.now)
-
-    class Meta:
-        app_label = "sentry"
-        db_table = "sentry_querysubscriptionenvironment"
-        unique_together = (("query_subscription", "environment"),)
-
-
 class SnubaQuery(Model):
     __core__ = True
 
@@ -64,18 +51,10 @@ class QuerySubscription(Model):
         DELETING = 3
 
     project = FlexibleForeignKey("sentry.Project", db_constraint=False)
-    environments = models.ManyToManyField(
-        "sentry.Environment", through=QuerySubscriptionEnvironment
-    )
     snuba_query = FlexibleForeignKey("sentry.SnubaQuery", null=True, related_name="subscriptions")
     type = models.TextField()
     status = models.SmallIntegerField(default=Status.ACTIVE.value)
     subscription_id = models.TextField(unique=True, null=True)
-    dataset = models.TextField(null=True)
-    query = models.TextField(null=True)
-    aggregation = models.IntegerField(default=0, null=True)
-    time_window = models.IntegerField(null=True)
-    resolution = models.IntegerField(null=True)
     date_added = models.DateTimeField(default=timezone.now)
 
     objects = BaseManager(
diff --git a/src/sentry/snuba/subscriptions.py b/src/sentry/snuba/subscriptions.py
index dee5dfba09..af578c4fa9 100644
--- a/src/sentry/snuba/subscriptions.py
+++ b/src/sentry/snuba/subscriptions.py
@@ -4,12 +4,7 @@ import logging
 
 from django.db import transaction
 
-from sentry.snuba.models import (
-    QueryAggregations,
-    QuerySubscription,
-    QuerySubscriptionEnvironment,
-    SnubaQuery,
-)
+from sentry.snuba.models import QueryAggregations, QuerySubscription, SnubaQuery
 from sentry.snuba.tasks import (
     create_subscription_in_snuba,
     delete_subscription_from_snuba,
@@ -118,17 +113,7 @@ def create_snuba_subscription(project, subscription_type, snuba_query):
         project=project,
         snuba_query=snuba_query,
         type=subscription_type,
-        dataset=snuba_query.dataset,
-        query=snuba_query.query,
-        aggregation=aggregate_to_query_aggregation[snuba_query.aggregate].value,
-        time_window=snuba_query.time_window,
-        resolution=snuba_query.resolution,
     )
-    if snuba_query.environment:
-        QuerySubscriptionEnvironment.objects.create(
-            query_subscription=subscription, environment=snuba_query.environment
-        )
-
     create_subscription_in_snuba.apply_async(
         kwargs={"query_subscription_id": subscription.id}, countdown=5
     )
@@ -163,20 +148,7 @@ def update_snuba_subscription(subscription, snuba_query):
     :return: The QuerySubscription representing the subscription
     """
     with transaction.atomic():
-        subscription.update(
-            status=QuerySubscription.Status.UPDATING.value,
-            query=snuba_query.query,
-            aggregation=aggregate_to_query_aggregation[snuba_query.aggregate].value,
-            time_window=snuba_query.time_window,
-            resolution=snuba_query.resolution,
-        )
-        QuerySubscriptionEnvironment.objects.filter(query_subscription=subscription).exclude(
-            environment=snuba_query.environment
-        ).delete()
-        if snuba_query.environment:
-            QuerySubscriptionEnvironment.objects.get_or_create(
-                query_subscription=subscription, environment=snuba_query.environment
-            )
+        subscription.update(status=QuerySubscription.Status.UPDATING.value)
 
         update_subscription_in_snuba.apply_async(
             kwargs={"query_subscription_id": subscription.id}, countdown=5
diff --git a/src/sentry/snuba/tasks.py b/src/sentry/snuba/tasks.py
index bdca348c3b..136822adad 100644
--- a/src/sentry/snuba/tasks.py
+++ b/src/sentry/snuba/tasks.py
@@ -106,7 +106,9 @@ def delete_subscription_from_snuba(query_subscription_id):
         return
 
     if subscription.subscription_id is not None:
-        _delete_from_snuba(QueryDatasets(subscription.dataset), subscription.subscription_id)
+        _delete_from_snuba(
+            QueryDatasets(subscription.snuba_query.dataset), subscription.subscription_id
+        )
 
     subscription.delete()
 
@@ -125,7 +127,7 @@ def _create_in_snuba(subscription):
     )
     response = _snuba_pool.urlopen(
         "POST",
-        "/%s/subscriptions" % (subscription.dataset,),
+        "/%s/subscriptions" % (snuba_query.dataset,),
         body=json.dumps(
             {
                 "project_id": subscription.project_id,
diff --git a/tests/sentry/api/serializers/test_alert_rule.py b/tests/sentry/api/serializers/test_alert_rule.py
index 07bc21ed58..0fe6712436 100644
--- a/tests/sentry/api/serializers/test_alert_rule.py
+++ b/tests/sentry/api/serializers/test_alert_rule.py
@@ -13,6 +13,7 @@ from sentry.models import Rule
 from sentry.incidents.logic import create_alert_rule, create_alert_rule_trigger
 from sentry.incidents.models import AlertRuleThresholdType
 from sentry.snuba.models import QueryAggregations
+from sentry.snuba.subscriptions import aggregate_to_query_aggregation
 from sentry.testutils import TestCase, APITestCase
 
 
@@ -24,7 +25,10 @@ class BaseAlertRuleSerializerTest(object):
         assert result["dataset"] == alert_rule.snuba_query.dataset
         assert result["query"] == alert_rule.snuba_query.query
         assert result["aggregate"] == alert_rule.snuba_query.aggregate
-        assert result["aggregation"] == alert_rule.aggregation
+        assert (
+            result["aggregation"]
+            == aggregate_to_query_aggregation[alert_rule.snuba_query.aggregate].value
+        )
         assert result["timeWindow"] == alert_rule.snuba_query.time_window / 60
         assert result["resolution"] == alert_rule.snuba_query.resolution / 60
         assert result["thresholdPeriod"] == alert_rule.threshold_period
diff --git a/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py b/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
index a50d798a6c..8ef183ccff 100644
--- a/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
+++ b/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
@@ -6,6 +6,7 @@ from sentry.api.serializers import serialize
 from sentry.incidents.logic import create_alert_rule
 from sentry.incidents.models import AlertRule, AlertRuleStatus, Incident, IncidentStatus
 from sentry.snuba.models import QueryAggregations
+from sentry.snuba.subscriptions import aggregate_to_query_aggregation
 from sentry.testutils import APITestCase
 
 
@@ -147,7 +148,13 @@ class AlertRuleDetailsPutEndpointTest(AlertRuleDetailsBase, APITestCase):
 
     def test_not_updated_fields(self):
         test_params = self.valid_params.copy()
-        test_params.update({"aggregation": self.alert_rule.aggregation})
+        test_params.update(
+            {
+                "aggregation": aggregate_to_query_aggregation[
+                    self.alert_rule.snuba_query.aggregate
+                ].value
+            }
+        )
 
         self.create_member(
             user=self.user, organization=self.organization, role="owner", teams=[self.team]
diff --git a/tests/sentry/incidents/endpoints/test_serializers.py b/tests/sentry/incidents/endpoints/test_serializers.py
index ebe0c16c77..deccbb903b 100644
--- a/tests/sentry/incidents/endpoints/test_serializers.py
+++ b/tests/sentry/incidents/endpoints/test_serializers.py
@@ -14,12 +14,7 @@ from sentry.incidents.endpoints.serializers import (
     string_to_action_target_type,
 )
 from sentry.incidents.logic import create_alert_rule_trigger
-from sentry.incidents.models import (
-    AlertRule,
-    AlertRuleThresholdType,
-    AlertRuleTriggerAction,
-    AlertRuleEnvironment,
-)
+from sentry.incidents.models import AlertRule, AlertRuleThresholdType, AlertRuleTriggerAction
 from sentry.models import Integration, Environment
 from sentry.snuba.models import QueryAggregations
 from sentry.testutils import TestCase
@@ -102,12 +97,7 @@ class TestAlertRuleSerializer(TestCase):
         serializer = AlertRuleSerializer(context=self.context, data=base_params)
         assert serializer.is_valid(), serializer.errors
         alert_rule = serializer.save()
-
-        # Make sure AlertRuleEnvironment entry was made:
-        alert_rule_env = AlertRuleEnvironment.objects.get(
-            environment=env_1.id, alert_rule=alert_rule
-        )
-        assert alert_rule_env
+        assert alert_rule.snuba_query.environment == env_1
 
     def test_time_window(self):
         self.run_fail_validation_test(
diff --git a/tests/sentry/incidents/test_action_handlers.py b/tests/sentry/incidents/test_action_handlers.py
index b50d412674..b82bcb5e2d 100644
--- a/tests/sentry/incidents/test_action_handlers.py
+++ b/tests/sentry/incidents/test_action_handlers.py
@@ -17,12 +17,12 @@ from sentry.incidents.models import (
     AlertRuleTriggerAction,
     IncidentStatus,
     IncidentStatusMethod,
-    QueryAggregations,
     TriggerStatus,
     INCIDENT_STATUS,
 )
 from sentry.integrations.slack.utils import build_incident_attachment
 from sentry.models import Integration, UserOption
+from sentry.snuba.subscriptions import aggregate_to_query_aggregation
 from sentry.testutils import TestCase
 from sentry.utils.http import absolute_uri
 
@@ -109,7 +109,9 @@ class EmailActionHandlerGenerateEmailContextTest(TestCase):
             ),
             "incident_name": incident.title,
             "aggregate": handler.query_aggregations_display[
-                QueryAggregations(action.alert_rule_trigger.alert_rule.aggregation)
+                aggregate_to_query_aggregation[
+                    action.alert_rule_trigger.alert_rule.snuba_query.aggregate
+                ]
             ],
             "query": action.alert_rule_trigger.alert_rule.snuba_query.query,
             "threshold": action.alert_rule_trigger.alert_threshold,
diff --git a/tests/sentry/incidents/test_logic.py b/tests/sentry/incidents/test_logic.py
index 305706d9cc..c95e9f673e 100644
--- a/tests/sentry/incidents/test_logic.py
+++ b/tests/sentry/incidents/test_logic.py
@@ -723,15 +723,10 @@ class CreateAlertRuleTest(TestCase, BaseIncidentsTest):
         assert alert_rule.status == AlertRuleStatus.PENDING.value
         assert alert_rule.snuba_query.subscriptions.all().count() == 1
         assert alert_rule.snuba_query.dataset == QueryDatasets.EVENTS.value
-        assert alert_rule.dataset == QueryDatasets.EVENTS.value
         assert alert_rule.snuba_query.query == query
-        assert alert_rule.query == query
         assert alert_rule.snuba_query.aggregate == aggregation_function_translations[aggregation]
-        assert alert_rule.aggregation == aggregation.value
         assert alert_rule.snuba_query.time_window == time_window * 60
-        assert alert_rule.time_window == time_window
         assert alert_rule.snuba_query.resolution == DEFAULT_ALERT_RULE_RESOLUTION * 60
-        assert alert_rule.resolution == DEFAULT_ALERT_RULE_RESOLUTION
         assert alert_rule.threshold_period == threshold_period
 
     def test_include_all_projects(self):
@@ -843,23 +838,17 @@ class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
         assert set([sub.project for sub in updated_subscriptions]) == set(updated_projects)
         for subscription in updated_subscriptions:
             assert subscription.snuba_query.query == query
-            assert subscription.query == query
             assert (
                 subscription.snuba_query.aggregate == aggregation_function_translations[aggregation]
             )
-            assert subscription.aggregation == aggregation.value
             assert subscription.snuba_query.time_window == int(
                 timedelta(minutes=time_window).total_seconds()
             )
-            assert subscription.time_window == int(timedelta(minutes=time_window).total_seconds())
         assert self.alert_rule.snuba_query.query == query
-        assert self.alert_rule.query == query
         assert (
             self.alert_rule.snuba_query.aggregate == aggregation_function_translations[aggregation]
         )
-        assert self.alert_rule.aggregation == aggregation.value
         assert self.alert_rule.snuba_query.time_window == time_window * 60
-        assert self.alert_rule.time_window == time_window
         assert self.alert_rule.threshold_period == threshold_period
 
     def test_update_subscription(self):
@@ -872,7 +861,7 @@ class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
 
     def test_empty_query(self):
         alert_rule = update_alert_rule(self.alert_rule, query="")
-        assert alert_rule.query == ""
+        assert alert_rule.snuba_query.query == ""
 
     def test_name_used(self):
         used_name = "uh oh"
@@ -923,7 +912,7 @@ class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
         updated_subscriptions = alert_rule.snuba_query.subscriptions.all()
         assert set([sub.project for sub in updated_subscriptions]) == set(updated_projects)
         for sub in updated_subscriptions:
-            assert sub.query == query_update
+            assert sub.snuba_query.query == query_update
 
     def test_update_to_include_all(self):
         orig_project = self.project
@@ -1015,14 +1004,11 @@ class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
             assert rule_snapshot.snuba_query_id != updated_rule.snuba_query_id
             assert rule_snapshot.name == updated_rule.name
             assert rule_snapshot.snuba_query.query == "level:error"
-            assert rule_snapshot.query == "level:error"
             assert rule_snapshot.snuba_query.time_window == 600
-            assert rule_snapshot.time_window == 10
             assert (
                 rule_snapshot.snuba_query.aggregate
                 == aggregation_function_translations[QueryAggregations.TOTAL]
             )
-            assert rule_snapshot.aggregation == QueryAggregations.TOTAL.value
             assert rule_snapshot.threshold_period == 1
 
             for incident in (incident, incident_2):
diff --git a/tests/sentry/incidents/test_subscription_processor.py b/tests/sentry/incidents/test_subscription_processor.py
index 5c2ad2bd22..e4c38f2dc2 100644
--- a/tests/sentry/incidents/test_subscription_processor.py
+++ b/tests/sentry/incidents/test_subscription_processor.py
@@ -38,7 +38,7 @@ from sentry.incidents.subscription_processor import (
     SubscriptionProcessor,
     update_alert_rule_stats,
 )
-from sentry.snuba.models import query_aggregation_to_snuba, QueryAggregations, QuerySubscription
+from sentry.snuba.models import QueryAggregations, QuerySubscription
 from sentry.testutils import TestCase
 from sentry.utils.dates import to_timestamp
 from sentry.utils.compat import map
@@ -117,11 +117,7 @@ class ProcessUpdateTest(TestCase):
         data = {}
 
         if subscription:
-            aggregation_type = query_aggregation_to_snuba[
-                QueryAggregations(subscription.aggregation)
-            ]
-            value = randint(0, 100) if value is None else value
-            data = {aggregation_type[2]: value}
+            data = {"some_col_name": randint(0, 100) if value is None else value}
         values = {"data": [data]}
         return {
             "subscription_id": subscription.subscription_id if subscription else uuid4().hex,
diff --git a/tests/sentry/snuba/test_query_subscription_consumer.py b/tests/sentry/snuba/test_query_subscription_consumer.py
index aa14c8d19a..2c58160650 100644
--- a/tests/sentry/snuba/test_query_subscription_consumer.py
+++ b/tests/sentry/snuba/test_query_subscription_consumer.py
@@ -82,14 +82,7 @@ class HandleMessageTest(BaseQuerySubscriptionTest, TestCase):
 
     def test_subscription_not_registered(self):
         sub = QuerySubscription.objects.create(
-            project=self.project,
-            type="unregistered",
-            subscription_id="an_id",
-            dataset="something",
-            query="hello",
-            aggregation=0,
-            time_window=1,
-            resolution=1,
+            project=self.project, type="unregistered", subscription_id="an_id"
         )
         data = self.valid_wrapper
         data["payload"]["subscription_id"] = sub.subscription_id
diff --git a/tests/sentry/snuba/test_subscriptions.py b/tests/sentry/snuba/test_subscriptions.py
index 12904c8d65..1be0a75e53 100644
--- a/tests/sentry/snuba/test_subscriptions.py
+++ b/tests/sentry/snuba/test_subscriptions.py
@@ -65,11 +65,6 @@ class CreateSnubaSubscriptionTest(TestCase):
         assert subscription.project == self.project
         assert subscription.type == type
         assert subscription.subscription_id is None
-        assert subscription.dataset == dataset.value
-        assert subscription.query == query
-        assert subscription.aggregation == aggregation.value
-        assert subscription.time_window == int(time_window.total_seconds())
-        assert subscription.resolution == int(resolution.total_seconds())
 
     def test_with_task(self):
         with self.tasks():
@@ -88,11 +83,6 @@ class CreateSnubaSubscriptionTest(TestCase):
             assert subscription.project == self.project
             assert subscription.type == type
             assert subscription.subscription_id is not None
-            assert subscription.dataset == dataset.value
-            assert subscription.query == query
-            assert subscription.aggregation == aggregation.value
-            assert subscription.time_window == int(time_window.total_seconds())
-            assert subscription.resolution == int(resolution.total_seconds())
 
     def test_translated_query(self):
         type = "something"
@@ -111,11 +101,6 @@ class CreateSnubaSubscriptionTest(TestCase):
         assert subscription.project == self.project
         assert subscription.type == type
         assert subscription.subscription_id is not None
-        assert subscription.dataset == dataset.value
-        assert subscription.query == query
-        assert subscription.aggregation == aggregation.value
-        assert subscription.time_window == int(time_window.total_seconds())
-        assert subscription.resolution == int(resolution.total_seconds())
 
 
 class UpdateSnubaQueryTest(TestCase):
@@ -185,9 +170,7 @@ class UpdateSnubaQueryTest(TestCase):
         update_snuba_query(snuba_query, query, aggregation, time_window, resolution, new_env)
         sub.refresh_from_db()
         assert sub.snuba_query == snuba_query
-        assert sub.query == query
-        assert sub.time_window == int(time_window.total_seconds())
-        assert sub.resolution == int(resolution.total_seconds())
+        assert sub.status == QuerySubscription.Status.UPDATING.value
 
 
 class UpdateSnubaSubscriptionTest(TestCase):
@@ -221,13 +204,9 @@ class UpdateSnubaSubscriptionTest(TestCase):
         assert subscription.status == QuerySubscription.Status.UPDATING.value
         assert subscription.subscription_id == subscription_id
         assert subscription.snuba_query.query == query
-        assert subscription.query == query
         assert subscription.snuba_query.aggregate == aggregation_function_translations[aggregation]
-        assert subscription.aggregation == aggregation.value
         assert subscription.snuba_query.time_window == int(time_window.total_seconds())
-        assert subscription.time_window == int(time_window.total_seconds())
         assert subscription.snuba_query.resolution == int(resolution.total_seconds())
-        assert subscription.resolution == int(resolution.total_seconds())
 
     def test_with_task(self):
         with self.tasks():
@@ -260,10 +239,6 @@ class UpdateSnubaSubscriptionTest(TestCase):
             assert subscription.status == QuerySubscription.Status.ACTIVE.value
             assert subscription.subscription_id is not None
             assert subscription.subscription_id != subscription_id
-            assert subscription.query == query
-            assert subscription.aggregation == aggregation.value
-            assert subscription.time_window == int(time_window.total_seconds())
-            assert subscription.resolution == int(resolution.total_seconds())
 
 
 class BulkDeleteSnubaSubscriptionTest(TestCase):
diff --git a/tests/sentry/snuba/test_tasks.py b/tests/sentry/snuba/test_tasks.py
index b356c6f0a3..a619882cca 100644
--- a/tests/sentry/snuba/test_tasks.py
+++ b/tests/sentry/snuba/test_tasks.py
@@ -59,11 +59,6 @@ class BaseSnubaTaskTest(object):
             subscription_id=subscription_id,
             project=self.project,
             type="something",
-            dataset=dataset,
-            query=query,
-            aggregation=aggregate.value,
-            time_window=time_window,
-            resolution=resolution,
         )
 
     def test_no_subscription(self):
diff --git a/tests/snuba/incidents/test_tasks.py b/tests/snuba/incidents/test_tasks.py
index 3a878481c6..a6051c78e5 100644
--- a/tests/snuba/incidents/test_tasks.py
+++ b/tests/snuba/incidents/test_tasks.py
@@ -27,7 +27,7 @@ from sentry.incidents.models import (
     TriggerStatus,
 )
 from sentry.incidents.tasks import INCIDENTS_SNUBA_SUBSCRIPTION_TYPE
-from sentry.snuba.models import query_aggregation_to_snuba, QueryAggregations
+from sentry.snuba.models import QueryAggregations
 from sentry.snuba.query_subscription_consumer import QuerySubscriptionConsumer, subscriber_registry
 
 from sentry.testutils import TestCase
@@ -111,14 +111,12 @@ class HandleSnubaQueryUpdateTest(TestCase):
             callback(*args, **kwargs)
             raise KeyboardInterrupt()
 
-        value_name = query_aggregation_to_snuba[QueryAggregations(self.subscription.aggregation)][2]
-
         subscriber_registry[INCIDENTS_SNUBA_SUBSCRIPTION_TYPE] = exception_callback
         message = {
             "version": 1,
             "payload": {
                 "subscription_id": self.subscription.subscription_id,
-                "values": {"data": [{value_name: self.trigger.alert_threshold + 1}]},
+                "values": {"data": [{"some_col": self.trigger.alert_threshold + 1}]},
                 "timestamp": "2020-01-01T01:23:45.1234",
             },
         }

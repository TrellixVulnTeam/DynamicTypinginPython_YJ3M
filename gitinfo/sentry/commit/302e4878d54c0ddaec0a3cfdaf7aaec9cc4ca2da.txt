commit 302e4878d54c0ddaec0a3cfdaf7aaec9cc4ca2da
Author: William Mak <william@wmak.io>
Date:   Wed Dec 11 14:37:57 2019 -0500

    Switch caching from being on object to threadlocal (#15990)
    
    * fix(organization-option): Switch to threading cache
    
    - Adding an OptionManager that uses a threadlocal cache since these option
      models all use caching in a similar way.
    - This means that all the option models will now share the same object
      for caching
    - But means that
      - we don't need to worry about set/get state at all
      - cache keys must be unique between the three models
    - Also renamed `_cache` to `_option_cache` to be clearer

diff --git a/src/sentry/db/models/manager.py b/src/sentry/db/models/manager.py
index 59689a6fa0..7446c30fe2 100644
--- a/src/sentry/db/models/manager.py
+++ b/src/sentry/db/models/manager.py
@@ -12,14 +12,16 @@ from django.db import router
 from django.db.models import Model
 from django.db.models.manager import Manager, QuerySet
 from django.db.models.signals import post_save, post_delete, post_init, class_prepared
+from django.core.signals import request_finished
 from django.utils.encoding import smart_text
+from celery.signals import task_postrun
 
 from sentry.utils.cache import cache
 from sentry.utils.hashlib import md5_text
 
 from .query import create_or_update
 
-__all__ = ("BaseManager",)
+__all__ = ("BaseManager", "OptionManager")
 
 logger = logging.getLogger("sentry")
 
@@ -451,3 +453,23 @@ class BaseManager(Manager):
         if hasattr(self, "_hints"):
             return self._queryset_class(self.model, using=self._db, hints=self._hints)
         return self._queryset_class(self.model, using=self._db)
+
+
+class OptionManager(BaseManager):
+    @property
+    def _option_cache(self):
+        if not hasattr(_local_cache, "option_cache"):
+            _local_cache.option_cache = {}
+        return _local_cache.option_cache
+
+    def clear_local_cache(self, **kwargs):
+        self._option_cache.clear()
+
+    def contribute_to_class(self, model, name):
+        super(OptionManager, self).contribute_to_class(model, name)
+        task_postrun.connect(self.clear_local_cache)
+        request_finished.connect(self.clear_local_cache)
+
+    def _make_key(self, instance_id):
+        assert instance_id
+        return u"%s:%s" % (self.model._meta.db_table, instance_id)
diff --git a/src/sentry/models/organizationoption.py b/src/sentry/models/organizationoption.py
index cec0f4a9cb..a331d1923e 100644
--- a/src/sentry/models/organizationoption.py
+++ b/src/sentry/models/organizationoption.py
@@ -1,34 +1,14 @@
 from __future__ import absolute_import, print_function
 
-from celery.signals import task_postrun
-from django.core.signals import request_finished
 from django.db import models
 
 from sentry.db.models import Model, FlexibleForeignKey, sane_repr
 from sentry.db.models.fields import EncryptedPickledObjectField
-from sentry.db.models.manager import BaseManager
+from sentry.db.models.manager import OptionManager
 from sentry.utils.cache import cache
 
 
-class OrganizationOptionManager(BaseManager):
-    def __init__(self, *args, **kwargs):
-        super(OrganizationOptionManager, self).__init__(*args, **kwargs)
-        self.__cache = {}
-
-    def __getstate__(self):
-        d = self.__dict__.copy()
-        # we cant serialize weakrefs
-        d.pop("_OrganizationOptionManager__cache", None)
-        return d
-
-    def __setstate__(self, state):
-        self.__dict__.update(state)
-        self.__cache = {}
-
-    def _make_key(self, instance_id):
-        assert instance_id
-        return "%s:%s" % (self.model._meta.db_table, instance_id)
-
+class OrganizationOptionManager(OptionManager):
     def get_value_bulk(self, instances, key):
         instance_map = dict((i.id, i) for i in instances)
         queryset = self.filter(organization__in=instances, key=key)
@@ -58,24 +38,21 @@ class OrganizationOptionManager(BaseManager):
             organization_id = organization.id
         else:
             organization_id = organization
+        cache_key = self._make_key(organization_id)
 
-        if organization_id not in self.__cache:
-            cache_key = self._make_key(organization_id)
+        if cache_key not in self._option_cache:
             result = cache.get(cache_key)
             if result is None:
                 result = self.reload_cache(organization_id)
             else:
-                self.__cache[organization_id] = result
-        return self.__cache.get(organization_id, {})
-
-    def clear_local_cache(self, **kwargs):
-        self.__cache = {}
+                self._option_cache[cache_key] = result
+        return self._option_cache.get(cache_key, {})
 
     def reload_cache(self, organization_id):
         cache_key = self._make_key(organization_id)
         result = dict((i.key, i.value) for i in self.filter(organization=organization_id))
         cache.set(cache_key, result)
-        self.__cache[organization_id] = result
+        self._option_cache[cache_key] = result
         return result
 
     def post_save(self, instance, **kwargs):
@@ -84,11 +61,6 @@ class OrganizationOptionManager(BaseManager):
     def post_delete(self, instance, **kwargs):
         self.reload_cache(instance.organization_id)
 
-    def contribute_to_class(self, model, name):
-        super(OrganizationOptionManager, self).contribute_to_class(model, name)
-        task_postrun.connect(self.clear_local_cache)
-        request_finished.connect(self.clear_local_cache)
-
 
 class OrganizationOption(Model):
     """
diff --git a/src/sentry/models/projectoption.py b/src/sentry/models/projectoption.py
index 3b287cc8a6..4af1fd2126 100644
--- a/src/sentry/models/projectoption.py
+++ b/src/sentry/models/projectoption.py
@@ -1,35 +1,15 @@
 from __future__ import absolute_import, print_function
 
-from celery.signals import task_postrun
-from django.core.signals import request_finished
 from django.db import models
 
 from sentry import projectoptions
 from sentry.db.models import Model, FlexibleForeignKey, sane_repr
 from sentry.db.models.fields import EncryptedPickledObjectField
-from sentry.db.models.manager import BaseManager
+from sentry.db.models.manager import OptionManager
 from sentry.utils.cache import cache
 
 
-class ProjectOptionManager(BaseManager):
-    def __init__(self, *args, **kwargs):
-        super(ProjectOptionManager, self).__init__(*args, **kwargs)
-        self.__cache = {}
-
-    def __getstate__(self):
-        d = self.__dict__.copy()
-        # we cant serialize weakrefs
-        d.pop("_ProjectOptionManager__cache", None)
-        return d
-
-    def __setstate__(self, state):
-        self.__dict__.update(state)
-        self.__cache = {}
-
-    def _make_key(self, instance_id):
-        assert instance_id
-        return "%s:%s" % (self.model._meta.db_table, instance_id)
-
+class ProjectOptionManager(OptionManager):
     def get_value_bulk(self, instances, key):
         instance_map = dict((i.id, i) for i in instances)
         queryset = self.filter(project__in=instances, key=key)
@@ -63,24 +43,21 @@ class ProjectOptionManager(BaseManager):
             project_id = project.id
         else:
             project_id = project
+        cache_key = self._make_key(project_id)
 
-        if project_id not in self.__cache:
-            cache_key = self._make_key(project_id)
+        if cache_key not in self._option_cache:
             result = cache.get(cache_key)
             if result is None:
                 result = self.reload_cache(project_id)
             else:
-                self.__cache[project_id] = result
-        return self.__cache.get(project_id, {})
-
-    def clear_local_cache(self, **kwargs):
-        self.__cache = {}
+                self._option_cache[cache_key] = result
+        return self._option_cache.get(cache_key, {})
 
     def reload_cache(self, project_id):
         cache_key = self._make_key(project_id)
         result = dict((i.key, i.value) for i in self.filter(project=project_id))
         cache.set(cache_key, result)
-        self.__cache[project_id] = result
+        self._option_cache[cache_key] = result
         return result
 
     def post_save(self, instance, **kwargs):
@@ -89,11 +66,6 @@ class ProjectOptionManager(BaseManager):
     def post_delete(self, instance, **kwargs):
         self.reload_cache(instance.project_id)
 
-    def contribute_to_class(self, model, name):
-        super(ProjectOptionManager, self).contribute_to_class(model, name)
-        task_postrun.connect(self.clear_local_cache)
-        request_finished.connect(self.clear_local_cache)
-
 
 class ProjectOption(Model):
     """
diff --git a/src/sentry/models/useroption.py b/src/sentry/models/useroption.py
index 57b40091f2..f6657da8da 100644
--- a/src/sentry/models/useroption.py
+++ b/src/sentry/models/useroption.py
@@ -1,13 +1,11 @@
 from __future__ import absolute_import, print_function
 
-from celery.signals import task_postrun
 from django.conf import settings
-from django.core.signals import request_finished
 from django.db import models
 
 from sentry.db.models import FlexibleForeignKey, Model, sane_repr
 from sentry.db.models.fields import EncryptedPickledObjectField
-from sentry.db.models.manager import BaseManager
+from sentry.db.models.manager import OptionManager
 
 
 class UserOptionValue(object):
@@ -24,32 +22,16 @@ class UserOptionValue(object):
 option_scope_error = "this is not a supported use case, scope to project OR organization"
 
 
-def user_metakey(user):
-    return user.pk
-
-
-def project_metakey(user, project):
-    return (user.pk, project.pk, "project")
-
-
-def organization_metakey(user, organization):
-    return (user.pk, organization.pk, "organization")
-
-
-class UserOptionManager(BaseManager):
-    def __init__(self, *args, **kwargs):
-        super(UserOptionManager, self).__init__(*args, **kwargs)
-        self.__metadata = {}
-
-    def __getstate__(self):
-        d = self.__dict__.copy()
-        # we cant serialize weakrefs
-        d.pop("_UserOptionManager__metadata", None)
-        return d
+class UserOptionManager(OptionManager):
+    def _make_key(self, user, project=None, organization=None):
+        if project:
+            metakey = u"%s:%s:project" % (user.pk, project.id)
+        elif organization:
+            metakey = u"%s:%s:organization" % (user.pk, organization.id)
+        else:
+            metakey = u"%s:user" % (user.pk)
 
-    def __setstate__(self, state):
-        self.__dict__.update(state)
-        self.__metadata = {}
+        return super(UserOptionManager, self)._make_key(metakey)
 
     def get_value(self, user, key, default=None, **kwargs):
         project = kwargs.get("project")
@@ -69,13 +51,12 @@ class UserOptionManager(BaseManager):
         self.filter(user=user, project=project, key=key).delete()
         if not hasattr(self, "_metadata"):
             return
-        if project:
-            metakey = project_metakey(user, project)
-        else:
-            metakey = user_metakey(user)
-        if metakey not in self.__metadata:
+
+        metakey = self._make_key(user, project=project)
+
+        if metakey not in self._option_cache:
             return
-        self.__metadata[metakey].pop(key, None)
+        self._option_cache[metakey].pop(key, None)
 
     def set_value(self, user, key, value, **kwargs):
         project = kwargs.get("project")
@@ -94,41 +75,35 @@ class UserOptionManager(BaseManager):
         if not created and inst.value != value:
             inst.update(value=value)
 
-        if project:
-            metakey = project_metakey(user, project)
-        elif organization:
-            metakey = organization_metakey(user, organization)
-        else:
-            metakey = user_metakey(user)
-        if metakey not in self.__metadata:
+        metakey = self._make_key(user, project=project, organization=organization)
+
+        if metakey not in self._option_cache:
             return
-        self.__metadata[metakey][key] = value
+        self._option_cache[metakey][key] = value
 
-    def get_all_values(self, user, project=None, organization=None):
+    def get_all_values(self, user, project=None, organization=None, force_reload=False):
         if organization and project:
             raise NotImplementedError(option_scope_error)
 
-        if project:
-            metakey = project_metakey(user, project)
-        elif organization:
-            metakey = organization_metakey(user, organization)
-        else:
-            metakey = user_metakey(user)
-        if metakey not in self.__metadata:
+        metakey = self._make_key(user, project=project, organization=organization)
+
+        if metakey not in self._option_cache or force_reload:
             result = dict(
                 (i.key, i.value)
                 for i in self.filter(user=user, project=project, organization=organization)
             )
-            self.__metadata[metakey] = result
-        return self.__metadata.get(metakey, {})
+            self._option_cache[metakey] = result
+        return self._option_cache.get(metakey, {})
 
-    def clear_local_cache(self, **kwargs):
-        self.__metadata = {}
+    def post_save(self, instance, **kwargs):
+        self.get_all_values(
+            instance.user, instance.project, instance.organization, force_reload=True
+        )
 
-    def contribute_to_class(self, model, name):
-        super(UserOptionManager, self).contribute_to_class(model, name)
-        task_postrun.connect(self.clear_local_cache)
-        request_finished.connect(self.clear_local_cache)
+    def post_delete(self, instance, **kwargs):
+        self.get_all_values(
+            instance.user, instance.project, instance.organization, force_reload=True
+        )
 
 
 # TODO(dcramer): the NULL UNIQUE constraint here isnt valid, and instead has to
diff --git a/tests/sentry/api/endpoints/test_user_details.py b/tests/sentry/api/endpoints/test_user_details.py
index 1ca931280e..ed05572177 100644
--- a/tests/sentry/api/endpoints/test_user_details.py
+++ b/tests/sentry/api/endpoints/test_user_details.py
@@ -89,6 +89,17 @@ class UserUpdateTest(APITestCase):
         assert UserOption.objects.get_value(user=self.user, key="clock_24_hours")
         assert not UserOption.objects.get_value(user=self.user, key="extra")
 
+    def test_saving_changes_value(self):
+        """ Even when saving on an option directly, we should still be able to use get_value to retrieve updated options
+        """
+        UserOption.objects.set_value(user=self.user, key="language", value="fr")
+
+        uo = UserOption.objects.get(user=self.user, key="language")
+        uo.value = "en"
+        uo.save()
+
+        assert UserOption.objects.get_value(user=self.user, key="language") == "en"
+
     def test_superuser(self):
         # superuser should be able to change self.user's name
         superuser = self.create_user(email="b@example.com", is_superuser=True)

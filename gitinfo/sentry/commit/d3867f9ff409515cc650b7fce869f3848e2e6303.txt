commit d3867f9ff409515cc650b7fce869f3848e2e6303
Author: Dan Fuller <dfuller@sentry.io>
Date:   Thu Sep 5 17:35:51 2019 -0700

    feat(api): Change Incident Alert Rules and related to use `aggregate` instead of `aggregates`
    
    Continuing work from https://github.com/getsentry/sentry/pull/14530 to move aggregations to be a
    single field.

diff --git a/src/sentry/api/serializers/models/alert_rule.py b/src/sentry/api/serializers/models/alert_rule.py
index afa762c5dc..3ff7139cf1 100644
--- a/src/sentry/api/serializers/models/alert_rule.py
+++ b/src/sentry/api/serializers/models/alert_rule.py
@@ -17,7 +17,8 @@ class AlertRuleSerializer(Serializer):
             "thresholdType": obj.threshold_type,
             "dataset": obj.dataset,
             "query": obj.query,
-            "aggregations": [agg for agg in obj.aggregations],
+            "aggregation": obj.aggregation,
+            "aggregations": [obj.aggregation],
             "timeWindow": obj.time_window,
             "resolution": obj.resolution,
             "alertThreshold": obj.alert_threshold,
diff --git a/src/sentry/incidents/endpoints/serializers.py b/src/sentry/incidents/endpoints/serializers.py
index 11f42f9909..019e6ec635 100644
--- a/src/sentry/incidents/endpoints/serializers.py
+++ b/src/sentry/incidents/endpoints/serializers.py
@@ -17,7 +17,7 @@ from sentry.incidents.logic import (
 
 class AlertRuleSerializer(CamelSnakeModelSerializer):
     # XXX: ArrayFields aren't supported automatically until DRF 3.1
-    aggregations = serializers.ListField(child=serializers.IntegerField())
+    aggregations = serializers.ListField(child=serializers.IntegerField(), required=False)
 
     class Meta:
         model = AlertRule
@@ -29,6 +29,7 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
             "alert_threshold",
             "resolve_threshold",
             "threshold_period",
+            "aggregation",
             "aggregations",
         ]
         extra_kwargs = {
@@ -41,7 +42,7 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
                 "max_value": int(timedelta(days=1).total_seconds() / 60),
                 "required": True,
             },
-            "aggregations": {"min_length": 1, "max_length": 10, "required": True},
+            "aggregation": {"required": False},
             "name": {"min_length": 1, "max_length": 64},
         }
 
@@ -54,7 +55,17 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
                 % [item.value for item in AlertRuleThresholdType]
             )
 
+    def validate_aggregation(self, aggregation):
+        try:
+            return AlertRuleAggregations(aggregation)
+        except ValueError:
+            raise serializers.ValidationError(
+                "Invalid aggregation, valid values are %s"
+                % [item.value for item in AlertRuleAggregations]
+            )
+
     def validate_aggregations(self, aggregations):
+        # TODO: Remove this once FE transitions
         try:
             return [AlertRuleAggregations(agg) for agg in aggregations]
         except ValueError:
@@ -63,8 +74,15 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
                 % [item.value for item in AlertRuleAggregations]
             )
 
+    def validate(self, attrs):
+        return self._handle_aggregations_transition(attrs)
+
     def create(self, validated_data):
         try:
+            # TODO: Remove this, just temporary while we're supporting both fields.
+            if "aggregation" not in validated_data:
+                raise serializers.ValidationError("aggregation is required")
+
             return create_alert_rule(project=self.context["project"], **validated_data)
         except AlertRuleNameAlreadyUsedError:
             raise serializers.ValidationError("This name is already in use for this project")
@@ -80,6 +98,15 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
                 validated_data.pop(field_name)
         return validated_data
 
+    def _handle_aggregations_transition(self, validated_data):
+        # Temporary methods for transitioning from multiple aggregations to a single
+        # aggregate
+        if "aggregations" in validated_data and "aggregation" not in validated_data:
+            validated_data["aggregation"] = validated_data["aggregations"][0]
+
+        validated_data.pop("aggregations", None)
+        return validated_data
+
     def update(self, instance, validated_data):
         validated_data = self._remove_unchanged_fields(instance, validated_data)
         return update_alert_rule(instance, **validated_data)
diff --git a/src/sentry/incidents/logic.py b/src/sentry/incidents/logic.py
index d3f5e7fba5..026e5ed26f 100644
--- a/src/sentry/incidents/logic.py
+++ b/src/sentry/incidents/logic.py
@@ -575,7 +575,7 @@ def create_alert_rule(
     name,
     threshold_type,
     query,
-    aggregations,
+    aggregation,
     time_window,
     alert_threshold,
     resolve_threshold,
@@ -608,7 +608,7 @@ def create_alert_rule(
         raise AlertRuleNameAlreadyUsedError()
     try:
         subscription_id = create_snuba_subscription(
-            project, dataset, query, aggregations, time_window, resolution
+            project, dataset, query, aggregation, time_window, resolution
         )
         alert_rule = AlertRule.objects.create(
             project=project,
@@ -617,7 +617,7 @@ def create_alert_rule(
             threshold_type=threshold_type.value,
             dataset=SnubaDatasets.EVENTS.value,
             query=query,
-            aggregations=[agg.value for agg in aggregations],
+            aggregation=aggregation.value,
             time_window=time_window,
             resolution=resolution,
             alert_threshold=alert_threshold,
@@ -638,7 +638,7 @@ def update_alert_rule(
     name=None,
     threshold_type=None,
     query=None,
-    aggregations=None,
+    aggregation=None,
     time_window=None,
     alert_threshold=None,
     resolve_threshold=None,
@@ -652,8 +652,7 @@ def update_alert_rule(
     incident name, and must be unique per project.
     :param threshold_type: An AlertRuleThresholdType
     :param query: An event search query to subscribe to and monitor for alerts
-    :param aggregations: A list of AlertRuleAggregations that we want to fetch
-    for this alert rule
+    :param aggregation: An AlertRuleAggregation that we want to fetch for this alert rule
     :param time_window: Time period to aggregate over, in minutes.
     :param alert_threshold: Value that the subscription needs to reach to
     trigger the alert
@@ -680,8 +679,8 @@ def update_alert_rule(
     if query is not None:
         validate_alert_rule_query(query)
         updated_fields["query"] = query
-    if aggregations:
-        updated_fields["aggregations"] = [a.value for a in aggregations]
+    if aggregation is not None:
+        updated_fields["aggregation"] = aggregation.value
     if time_window:
         updated_fields["time_window"] = time_window
     if alert_threshold:
@@ -691,16 +690,14 @@ def update_alert_rule(
     if threshold_period:
         updated_fields["threshold_period"] = threshold_period
 
-    if query or aggregations or time_window:
+    if query is not None or aggregation is not None or time_window is not None:
         old_subscription_id = alert_rule.subscription_id
         # If updating any details of the query, create a new subscription
         subscription_id = create_snuba_subscription(
             alert_rule.project,
             SnubaDatasets(alert_rule.dataset),
             query if query is not None else alert_rule.query,
-            aggregations
-            if aggregations
-            else [AlertRuleAggregations(agg) for agg in alert_rule.aggregations],
+            aggregation if aggregation else AlertRuleAggregations(alert_rule.aggregation),
             time_window if time_window else alert_rule.time_window,
             DEFAULT_ALERT_RULE_RESOLUTION,
         )
@@ -750,7 +747,7 @@ def validate_alert_rule_query(query):
     get_snuba_query_args(query)
 
 
-def create_snuba_subscription(project, dataset, query, aggregations, time_window, resolution):
+def create_snuba_subscription(project, dataset, query, aggregation, time_window, resolution):
     """
     Creates a subscription to a snuba query.
 
@@ -777,7 +774,7 @@ def create_snuba_subscription(project, dataset, query, aggregations, time_window
                 # filtering to project and groups. Projects are handled with an
                 # explicit param, and groups can't be queried here.
                 "conditions": get_snuba_query_args(query)["conditions"],
-                "aggregates": [alert_aggregation_to_snuba[agg] for agg in aggregations],
+                "aggregates": alert_aggregation_to_snuba[aggregation],
                 "time_window": time_window,
                 "resolution": resolution,
             }
diff --git a/src/sentry/incidents/subscription_processor.py b/src/sentry/incidents/subscription_processor.py
index 2b3cd31d4d..45e0d814b9 100644
--- a/src/sentry/incidents/subscription_processor.py
+++ b/src/sentry/incidents/subscription_processor.py
@@ -96,7 +96,7 @@ class SubscriptionProcessor(object):
 
         # TODO: At the moment we only have individual aggregations. Handle multiple
         # later
-        aggregation = AlertRuleAggregations(self.alert_rule.aggregations[0])
+        aggregation = AlertRuleAggregations(self.alert_rule.aggregation)
         aggregation_name = alert_aggregation_to_snuba[aggregation][2]
         aggregation_value = subscription_update["values"][aggregation_name]
 
diff --git a/tests/sentry/api/serializers/test_alert_rule.py b/tests/sentry/api/serializers/test_alert_rule.py
index f1f9f95b4c..2291193996 100644
--- a/tests/sentry/api/serializers/test_alert_rule.py
+++ b/tests/sentry/api/serializers/test_alert_rule.py
@@ -17,7 +17,7 @@ class IncidentSerializerTest(TestCase):
             "hello",
             AlertRuleThresholdType.ABOVE,
             "level:error",
-            [AlertRuleAggregations.TOTAL],
+            AlertRuleAggregations.TOTAL,
             10,
             1000,
             400,
@@ -31,7 +31,7 @@ class IncidentSerializerTest(TestCase):
         assert result["thresholdType"] == alert_rule.threshold_type
         assert result["dataset"] == alert_rule.dataset
         assert result["query"] == alert_rule.query
-        assert result["aggregations"] == alert_rule.aggregations
+        assert result["aggregation"] == alert_rule.aggregation
         assert result["timeWindow"] == alert_rule.time_window
         assert result["resolution"] == alert_rule.resolution
         assert result["alertThreshold"] == alert_rule.alert_threshold
diff --git a/tests/sentry/api/serializers/test_incident.py b/tests/sentry/api/serializers/test_incident.py
index 9b4daa1c95..601bdf5f39 100644
--- a/tests/sentry/api/serializers/test_incident.py
+++ b/tests/sentry/api/serializers/test_incident.py
@@ -71,7 +71,7 @@ class DetailedIncidentSerializerTest(TestCase):
             "hi",
             AlertRuleThresholdType.ABOVE,
             "test query",
-            [AlertRuleAggregations.TOTAL],
+            AlertRuleAggregations.TOTAL,
             10,
             1000,
             400,
diff --git a/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py b/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
index cce9a313b6..618ea006ca 100644
--- a/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
+++ b/tests/sentry/incidents/endpoints/test_project_alert_rule_details.py
@@ -30,7 +30,7 @@ class AlertRuleDetailsBase(object):
             "hello",
             AlertRuleThresholdType.ABOVE,
             "level:error",
-            [AlertRuleAggregations.TOTAL],
+            AlertRuleAggregations.TOTAL,
             10,
             1000,
             400,
@@ -105,7 +105,7 @@ class AlertRuleDetailsPutEndpointTest(AlertRuleDetailsBase, APITestCase):
                 self.organization.slug,
                 self.project.slug,
                 self.alert_rule.id,
-                aggregations=self.alert_rule.aggregations,
+                aggregation=self.alert_rule.aggregation,
             )
 
         # Alert rule should be exactly the same
diff --git a/tests/sentry/incidents/endpoints/test_project_alert_rule_index.py b/tests/sentry/incidents/endpoints/test_project_alert_rule_index.py
index 31f584c97a..e41e5ff2a3 100644
--- a/tests/sentry/incidents/endpoints/test_project_alert_rule_index.py
+++ b/tests/sentry/incidents/endpoints/test_project_alert_rule_index.py
@@ -34,7 +34,7 @@ class AlertRuleListEndpointTest(APITestCase):
             "hello",
             AlertRuleThresholdType.ABOVE,
             "level:error",
-            [AlertRuleAggregations.TOTAL],
+            AlertRuleAggregations.TOTAL,
             10,
             1000,
             400,
@@ -79,7 +79,7 @@ class AlertRuleCreateEndpointTest(APITestCase):
         name = "an alert"
         threshold_type = 1
         query = "hi"
-        aggregations = [0]
+        aggregation = 0
         time_window = 10
         alert_threshold = 1000
         resolve_threshold = 300
@@ -90,7 +90,7 @@ class AlertRuleCreateEndpointTest(APITestCase):
                 name=name,
                 thresholdType=threshold_type,
                 query=query,
-                aggregations=aggregations,
+                aggregation=aggregation,
                 timeWindow=time_window,
                 alertThreshold=alert_threshold,
                 resolveThreshold=resolve_threshold,
diff --git a/tests/sentry/incidents/endpoints/test_serializers.py b/tests/sentry/incidents/endpoints/test_serializers.py
index b6fc896ad8..b96cb9af6f 100644
--- a/tests/sentry/incidents/endpoints/test_serializers.py
+++ b/tests/sentry/incidents/endpoints/test_serializers.py
@@ -17,7 +17,7 @@ class TestAlertRuleSerializer(TestCase):
             "threshold_type": 0,
             "resolve_threshold": 1,
             "alert_threshold": 0,
-            "aggregations": [0],
+            "aggregation": 0,
             "threshold_period": 1,
         }
 
@@ -39,7 +39,6 @@ class TestAlertRuleSerializer(TestCase):
             "thresholdType": field_is_required,
             "resolveThreshold": field_is_required,
             "alertThreshold": field_is_required,
-            "aggregations": field_is_required,
         }
 
     def test_time_window(self):
@@ -64,15 +63,15 @@ class TestAlertRuleSerializer(TestCase):
         )
         self.run_fail_validation_test({"thresholdType": 50}, {"thresholdType": invalid_values})
 
-    def test_aggregations(self):
+    def test_aggregation(self):
         invalid_values = [
             "Invalid aggregation, valid values are %s"
             % [item.value for item in AlertRuleAggregations]
         ]
         self.run_fail_validation_test(
-            {"aggregations": ["a"]}, {"aggregations": ["A valid integer is required."]}
+            {"aggregation": "a"}, {"aggregation": ["A valid integer is required."]}
         )
-        self.run_fail_validation_test({"aggregations": [50]}, {"aggregations": invalid_values})
+        self.run_fail_validation_test({"aggregation": 50}, {"aggregation": invalid_values})
 
     def _run_changed_fields_test(self, alert_rule, params, expected):
         serializer = AlertRuleSerializer(
@@ -87,11 +86,9 @@ class TestAlertRuleSerializer(TestCase):
         alert_rule = AlertRule(**self.valid_params)
         self._run_changed_fields_test(alert_rule, self.valid_params, {})
         self._run_changed_fields_test(alert_rule, {"name": "a name"}, {"name": "a name"})
-        self._run_changed_fields_test(alert_rule, {"aggregations": [0]}, {})
+        self._run_changed_fields_test(alert_rule, {"aggregation": 0}, {})
         self._run_changed_fields_test(
-            alert_rule,
-            {"aggregations": [1]},
-            {"aggregations": [AlertRuleAggregations.UNIQUE_USERS]},
+            alert_rule, {"aggregation": 1}, {"aggregation": AlertRuleAggregations.UNIQUE_USERS}
         )
         self._run_changed_fields_test(alert_rule, {"threshold_type": 0}, {})
         self._run_changed_fields_test(
diff --git a/tests/sentry/incidents/test_logic.py b/tests/sentry/incidents/test_logic.py
index f4566da825..2b6267efeb 100644
--- a/tests/sentry/incidents/test_logic.py
+++ b/tests/sentry/incidents/test_logic.py
@@ -82,7 +82,7 @@ class CreateIncidentTest(TestCase):
             "hello",
             AlertRuleThresholdType.ABOVE,
             "level:error",
-            [AlertRuleAggregations.TOTAL],
+            AlertRuleAggregations.TOTAL,
             10,
             1000,
             400,
@@ -755,7 +755,7 @@ class CreateAlertRuleTest(TestCase, BaseIncidentsTest):
         name = "hello"
         threshold_type = AlertRuleThresholdType.ABOVE
         query = "level:error"
-        aggregations = [AlertRuleAggregations.TOTAL]
+        aggregation = AlertRuleAggregations.TOTAL
         time_window = 10
         alert_threshold = 1000
         resolve_threshold = 400
@@ -765,7 +765,7 @@ class CreateAlertRuleTest(TestCase, BaseIncidentsTest):
             name,
             threshold_type,
             query,
-            aggregations,
+            aggregation,
             time_window,
             alert_threshold,
             resolve_threshold,
@@ -778,7 +778,7 @@ class CreateAlertRuleTest(TestCase, BaseIncidentsTest):
         assert alert_rule.threshold_type == threshold_type.value
         assert alert_rule.dataset == SnubaDatasets.EVENTS.value
         assert alert_rule.query == query
-        assert alert_rule.aggregations == [agg.value for agg in aggregations]
+        assert alert_rule.aggregation == aggregation.value
         assert alert_rule.time_window == time_window
         assert alert_rule.resolution == DEFAULT_ALERT_RULE_RESOLUTION
         assert alert_rule.alert_threshold == alert_threshold
@@ -788,17 +788,41 @@ class CreateAlertRuleTest(TestCase, BaseIncidentsTest):
     def test_invalid_query(self):
         with self.assertRaises(InvalidSearchQuery):
             create_alert_rule(
-                self.project, "hi", AlertRuleThresholdType.ABOVE, "has:", [], 1, 1, 1, 1
+                self.project,
+                "hi",
+                AlertRuleThresholdType.ABOVE,
+                "has:",
+                AlertRuleAggregations.TOTAL,
+                1,
+                1,
+                1,
+                1,
             )
 
     def test_existing_name(self):
         name = "uh oh"
         create_alert_rule(
-            self.project, name, AlertRuleThresholdType.ABOVE, "level:error", [], 1, 1, 1, 1
+            self.project,
+            name,
+            AlertRuleThresholdType.ABOVE,
+            "level:error",
+            AlertRuleAggregations.TOTAL,
+            1,
+            1,
+            1,
+            1,
         )
         with self.assertRaises(AlertRuleNameAlreadyUsedError):
             create_alert_rule(
-                self.project, name, AlertRuleThresholdType.ABOVE, "level:error", [], 1, 1, 1, 1
+                self.project,
+                name,
+                AlertRuleThresholdType.ABOVE,
+                "level:error",
+                AlertRuleAggregations.TOTAL,
+                1,
+                1,
+                1,
+                1,
             )
 
 
@@ -810,7 +834,7 @@ class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
             "hello",
             AlertRuleThresholdType.ABOVE,
             "level:error",
-            [AlertRuleAggregations.TOTAL],
+            AlertRuleAggregations.TOTAL,
             10,
             1000,
             400,
@@ -821,7 +845,7 @@ class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
         name = "uh oh"
         threshold_type = AlertRuleThresholdType.BELOW
         query = "level:warning"
-        aggregations = [AlertRuleAggregations.UNIQUE_USERS]
+        aggregation = AlertRuleAggregations.UNIQUE_USERS
         time_window = 50
         alert_threshold = 2000
         resolve_threshold = 800
@@ -832,7 +856,7 @@ class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
             name=name,
             threshold_type=threshold_type,
             query=query,
-            aggregations=aggregations,
+            aggregation=aggregation,
             time_window=time_window,
             alert_threshold=alert_threshold,
             resolve_threshold=resolve_threshold,
@@ -841,7 +865,7 @@ class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
         assert self.alert_rule.name == name
         assert self.alert_rule.threshold_type == threshold_type.value
         assert self.alert_rule.query == query
-        assert self.alert_rule.aggregations == [a.value for a in aggregations]
+        assert self.alert_rule.aggregation == aggregation.value
         assert self.alert_rule.time_window == time_window
         assert self.alert_rule.alert_threshold == alert_threshold
         assert self.alert_rule.resolve_threshold == resolve_threshold
@@ -863,7 +887,7 @@ class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
             used_name,
             AlertRuleThresholdType.ABOVE,
             "level:error",
-            [AlertRuleAggregations.TOTAL],
+            AlertRuleAggregations.TOTAL,
             10,
             1000,
             400,
@@ -885,7 +909,7 @@ class DeleteAlertRuleTest(TestCase, BaseIncidentsTest):
             "hello",
             AlertRuleThresholdType.ABOVE,
             "level:error",
-            [AlertRuleAggregations.TOTAL],
+            AlertRuleAggregations.TOTAL,
             10,
             1000,
             400,
diff --git a/tests/sentry/incidents/test_subscription_processor.py b/tests/sentry/incidents/test_subscription_processor.py
index 9f21f6c41d..24db9c32f2 100644
--- a/tests/sentry/incidents/test_subscription_processor.py
+++ b/tests/sentry/incidents/test_subscription_processor.py
@@ -50,7 +50,7 @@ class ProcessUpdateTest(TestCase):
             "some rule",
             AlertRuleThresholdType.ABOVE,
             query="",
-            aggregations=[AlertRuleAggregations.TOTAL],
+            aggregation=AlertRuleAggregations.TOTAL,
             time_window=1,
             alert_threshold=100,
             resolve_threshold=10,
diff --git a/tests/sentry/snuba/test_query_subscription_consumer.py b/tests/sentry/snuba/test_query_subscription_consumer.py
index 5a9edcbdf5..9be4f0808f 100644
--- a/tests/sentry/snuba/test_query_subscription_consumer.py
+++ b/tests/sentry/snuba/test_query_subscription_consumer.py
@@ -60,7 +60,7 @@ class HandleMessageTest(BaseQuerySubscriptionTest, TestCase):
             subscription_id="an_id",
             dataset="something",
             query="hello",
-            aggregations=[],
+            aggregation=0,
             time_window=1,
             resolution=1,
         )
@@ -81,7 +81,7 @@ class HandleMessageTest(BaseQuerySubscriptionTest, TestCase):
             subscription_id="an_id",
             dataset="something",
             query="hello",
-            aggregations=[],
+            aggregation=0,
             time_window=1,
             resolution=1,
         )
diff --git a/tests/snuba/incidents/test_tasks.py b/tests/snuba/incidents/test_tasks.py
index 13c8ce3d2a..39b58caa56 100644
--- a/tests/snuba/incidents/test_tasks.py
+++ b/tests/snuba/incidents/test_tasks.py
@@ -48,7 +48,7 @@ class HandleSubaQueryUpdateTest(TestCase):
             subscription_id="some_id",
             dataset=SnubaDatasets.EVENTS.value,
             query="",
-            aggregations=[AlertRuleAggregations.TOTAL.value],
+            aggregation=AlertRuleAggregations.TOTAL.value,
             time_window=1,
             resolution=1,
         )
@@ -61,7 +61,7 @@ class HandleSubaQueryUpdateTest(TestCase):
             "some rule",
             AlertRuleThresholdType.ABOVE,
             query="",
-            aggregations=[AlertRuleAggregations.TOTAL],
+            aggregation=AlertRuleAggregations.TOTAL,
             time_window=1,
             alert_threshold=100,
             resolve_threshold=10,
@@ -98,7 +98,7 @@ class HandleSubaQueryUpdateTest(TestCase):
             raise KeyboardInterrupt()
 
         value_name = alert_aggregation_to_snuba[
-            AlertRuleAggregations(self.subscription.aggregations[0])
+            AlertRuleAggregations(self.subscription.aggregation)
         ][2]
 
         subscriber_registry[INCIDENTS_SNUBA_SUBSCRIPTION_TYPE] = exception_callback
diff --git a/tests/snuba/snuba/test_query_subscription_consumer.py b/tests/snuba/snuba/test_query_subscription_consumer.py
index 9f30c7db57..ac07824503 100644
--- a/tests/snuba/snuba/test_query_subscription_consumer.py
+++ b/tests/snuba/snuba/test_query_subscription_consumer.py
@@ -90,7 +90,7 @@ class QuerySubscriptionConsumerTest(TestCase, SnubaTestCase):
             subscription_id=self.subscription_id,
             dataset="something",
             query="hello",
-            aggregations=[],
+            aggregations=0,
             time_window=1,
             resolution=1,
         )
@@ -122,7 +122,7 @@ class QuerySubscriptionConsumerTest(TestCase, SnubaTestCase):
             subscription_id=self.subscription_id,
             dataset="something",
             query="hello",
-            aggregations=[],
+            aggregations=0,
             time_window=1,
             resolution=1,
         )

commit ec843a686be0d7947401953e725f0bae9dc41c5a
Author: David Cramer <dcramer@gmail.com>
Date:   Wed Jun 21 16:43:43 2017 -0700

    workflow: improve resolution by commit metadata

diff --git a/src/sentry/models/release.py b/src/sentry/models/release.py
index 1fd16acb05..248a1e2ac3 100644
--- a/src/sentry/models/release.py
+++ b/src/sentry/models/release.py
@@ -343,6 +343,7 @@ class Release(Model):
 
             authors = {}
             repos = {}
+            commit_author_by_commit = {}
             latest_commit = None
             for idx, data in enumerate(commit_list):
                 repo_name = data.get('repository') or 'organization-{}'.format(self.organization_id)
@@ -385,6 +386,10 @@ class Release(Model):
                     key=data['id'],
                     defaults=defaults,
                 )
+                if author is None:
+                    author = commit.author
+
+                commit_author_by_commit[commit.id] = author
 
                 patch_set = data.get('patch_set', [])
 
@@ -423,21 +428,33 @@ class Release(Model):
                 last_commit_id=latest_commit.id if latest_commit else None,
             )
 
-        group_ids = list(GroupCommitResolution.objects.filter(
+        commit_resolutions = list(GroupCommitResolution.objects.filter(
             commit_id__in=ReleaseCommit.objects.filter(
                 release=self
             ).values_list('commit_id', flat=True),
-        ).values_list('group_id', flat=True))
-        for group_id in group_ids:
-            GroupResolution.objects.create_or_update(
-                group_id=group_id,
-                release=self,
-                values={
-                    'status': GroupResolution.Status.resolved,
-                },
-            )
+        ).values_list('group_id', 'commit_id'))
+        user_by_author = {None: None}
+        for group_id, commit_id in commit_resolutions:
+            author = commit_author_by_commit.get(commit_id)
+            if author not in user_by_author:
+                try:
+                    user_by_author[author] = author.find_users()[0]
+                except IndexError:
+                    user_by_author[author] = None
+            actor = user_by_author[author]
 
-        if group_ids:
-            Group.objects.filter(
-                id__in=group_ids,
-            ).update(status=GroupStatus.RESOLVED)
+            with transaction.atomic():
+                GroupResolution.objects.create_or_update(
+                    group_id=group_id,
+                    values={
+                        'release': self,
+                        'type': GroupResolution.Type.in_release,
+                        'status': GroupResolution.Status.resolved,
+                        'actor_id': actor.id if actor else None,
+                    },
+                )
+                Group.objects.filter(
+                    id=group_id,
+                ).update(
+                    status=GroupStatus.RESOLVED
+                )
diff --git a/src/sentry/testutils/fixtures.py b/src/sentry/testutils/fixtures.py
index b7da819165..8fc0dc5b8c 100644
--- a/src/sentry/testutils/fixtures.py
+++ b/src/sentry/testutils/fixtures.py
@@ -23,7 +23,7 @@ from django.utils import timezone
 
 from sentry.models import (
     Activity, Event, EventError, EventMapping, Group, Organization,
-    OrganizationMember, OrganizationMemberTeam, Project, Team, User,
+    OrganizationMember, OrganizationMemberTeam, Project, Team, User, UserEmail,
     Release, Commit, ReleaseCommit, CommitAuthor, Repository, CommitFileChange
 )
 
@@ -349,6 +349,12 @@ class Fixtures(object):
         user.set_password('admin')
         user.save()
 
+        # UserEmail is created by a signal
+        UserEmail.objects.filter(
+            user=user,
+            email=email,
+        ).update(is_verified=True)
+
         return user
 
     def create_event(self, event_id=None, **kwargs):
diff --git a/tests/sentry/api/endpoints/test_user_details.py b/tests/sentry/api/endpoints/test_user_details.py
index de17fe7003..adb8a1de73 100644
--- a/tests/sentry/api/endpoints/test_user_details.py
+++ b/tests/sentry/api/endpoints/test_user_details.py
@@ -4,7 +4,7 @@ import six
 
 from django.core.urlresolvers import reverse
 
-from sentry.models import Authenticator, AuthIdentity, AuthProvider, User, UserOption
+from sentry.models import User, UserOption
 from sentry.testutils import APITestCase
 
 
@@ -28,21 +28,6 @@ class UserDetailsTest(APITestCase):
     def test_lookup_self(self):
         user = self.create_user(email='a@example.com')
 
-        org = self.create_organization(owner=user)
-        auth_provider = AuthProvider.objects.create(
-            organization=org,
-            provider='dummy',
-        )
-        auth_identity = AuthIdentity.objects.create(
-            auth_provider=auth_provider,
-            ident=user.email,
-            user=user,
-        )
-        auth = Authenticator.objects.create(
-            type=3,  # u2f
-            user=user,
-        )
-
         self.login_as(user=user)
 
         url = reverse('sentry-api-0-user-details', kwargs={
@@ -52,16 +37,6 @@ class UserDetailsTest(APITestCase):
 
         assert resp.status_code == 200, resp.content
         assert resp.data['id'] == six.text_type(user.id)
-        assert 'identities' in resp.data
-        assert len(resp.data['identities']) == 1
-        assert resp.data['identities'][0]['id'] == six.text_type(auth_identity.id)
-        assert resp.data['identities'][0]['name'] == auth_identity.ident
-        assert 'authenticators' in resp.data
-        assert len(resp.data['authenticators']) == 1
-        assert resp.data['authenticators'][0]['id'] == six.text_type(auth.id)
-        assert len(resp.data['emails']) == 1
-        assert resp.data['emails'][0]['email'] == user.email
-        assert resp.data['emails'][0]['is_verified'] is False
 
     def test_superuser(self):
         user = self.create_user(email='a@example.com')
diff --git a/tests/sentry/api/serializers/test_user.py b/tests/sentry/api/serializers/test_user.py
index 654d2c6d9b..0271ddb2b3 100644
--- a/tests/sentry/api/serializers/test_user.py
+++ b/tests/sentry/api/serializers/test_user.py
@@ -5,8 +5,9 @@ from __future__ import absolute_import
 import six
 
 from sentry.api.serializers import serialize
+from sentry.api.serializers.models.user import DetailedUserSerializer
 from sentry.testutils import TestCase
-from sentry.models import Authenticator, UserEmail
+from sentry.models import AuthIdentity, AuthProvider, Authenticator, UserEmail
 from sentry.models.authenticator import available_authenticators
 
 
@@ -19,8 +20,8 @@ class UserSerializerTest(TestCase):
         assert result['has2fa'] is False
 
         Authenticator.objects.create(
-            user=user,
             type=available_authenticators(ignore_backup=True)[0].type,
+            user=user,
         )
 
         result = serialize(user)
@@ -28,7 +29,7 @@ class UserSerializerTest(TestCase):
         assert result['has2fa'] is True
         assert len(result['emails']) == 1
         assert result['emails'][0]['email'] == user.email
-        assert result['emails'][0]['is_verified'] is False
+        assert result['emails'][0]['is_verified']
 
     def test_no_useremail(self):
         user = self.create_user()
@@ -38,3 +39,38 @@ class UserSerializerTest(TestCase):
 
         result = serialize(user)
         assert len(result['emails']) == 0
+
+
+class DetailedUserSerializerTest(TestCase):
+    def test_simple(self):
+        user = self.create_user()
+
+        org = self.create_organization(owner=user)
+
+        auth_provider = AuthProvider.objects.create(
+            organization=org,
+            provider='dummy',
+        )
+        auth_identity = AuthIdentity.objects.create(
+            auth_provider=auth_provider,
+            ident=user.email,
+            user=user,
+        )
+        auth = Authenticator.objects.create(
+            type=available_authenticators(ignore_backup=True)[0].type,
+            user=user,
+        )
+
+        result = serialize(user, user, DetailedUserSerializer())
+        assert result['id'] == six.text_type(user.id)
+        assert result['has2fa'] is True
+        assert len(result['emails']) == 1
+        assert result['emails'][0]['email'] == user.email
+        assert result['emails'][0]['is_verified']
+        assert 'identities' in result
+        assert len(result['identities']) == 1
+        assert result['identities'][0]['id'] == six.text_type(auth_identity.id)
+        assert result['identities'][0]['name'] == auth_identity.ident
+        assert 'authenticators' in result
+        assert len(result['authenticators']) == 1
+        assert result['authenticators'][0]['id'] == six.text_type(auth.id)
diff --git a/tests/sentry/models/test_release.py b/tests/sentry/models/test_release.py
index 999c90adb0..2a28911d89 100644
--- a/tests/sentry/models/test_release.py
+++ b/tests/sentry/models/test_release.py
@@ -191,11 +191,7 @@ class SetCommitsTestCase(TestCase):
 
         assert ReleaseCommit.objects.filter(commit=commit, release=release).exists()
         assert ReleaseCommit.objects.filter(commit=commit2, release=release).exists()
-        assert GroupResolution.objects.filter(group=group, release=release).exists()
-        assert GroupResolution.objects.get(
-            group=group,
-            release=release,
-        ).status == GroupResolution.Status.resolved
+
         assert Group.objects.get(id=group.id).status == GroupStatus.RESOLVED
         # test that backfilling works
         assert Commit.objects.filter(key='a' * 40, repository_id=repo.id).exists()
@@ -364,3 +360,92 @@ class SetCommitsTestCase(TestCase):
         assert release.commit_count == 3
         assert release.authors == [six.text_type(author.id)]
         assert release.last_commit_id == latest_commit.id
+
+    def test_resolution_support_full_featured(self):
+        org = self.create_organization()
+        project = self.create_project(organization=org, name='foo')
+        group = self.create_group(project=project)
+
+        repo = Repository.objects.create(
+            organization_id=org.id,
+            name='test/repo',
+        )
+        author = CommitAuthor.objects.create(
+            organization_id=org.id,
+            name='Foo Bar',
+            email=self.user.email,
+        )
+        commit = Commit.objects.create(
+            organization_id=org.id,
+            repository_id=repo.id,
+            message='fixes %s' % (group.qualified_short_id),
+            key='alksdflskdfjsldkfajsflkslk',
+            author=author,
+        )
+
+        old_release = self.create_release(project=project, version='pre-1.0')
+
+        resolution = GroupResolution.objects.create(
+            group=group,
+            release=old_release,
+            type=GroupResolution.Type.in_next_release,
+            status=GroupResolution.Status.pending,
+        )
+
+        release = self.create_release(project=project, version='abcdabc')
+        release.set_commits([{
+            'id': commit.key,
+            'repository': repo.name,
+        }])
+
+        assert GroupCommitResolution.objects.filter(
+            group_id=group.id,
+            commit_id=commit.id
+        ).exists()
+
+        resolution = GroupResolution.objects.get(
+            group=group,
+        )
+        assert resolution.status == GroupResolution.Status.resolved
+        assert resolution.release == release
+        assert resolution.type == GroupResolution.Type.in_release
+        assert resolution.actor_id == self.user.id
+
+        assert Group.objects.get(id=group.id).status == GroupStatus.RESOLVED
+
+    def test_resolution_support_without_author(self):
+        org = self.create_organization()
+        project = self.create_project(organization=org, name='foo')
+        group = self.create_group(project=project)
+
+        repo = Repository.objects.create(
+            organization_id=org.id,
+            name='test/repo',
+        )
+        commit = Commit.objects.create(
+            organization_id=org.id,
+            repository_id=repo.id,
+            message='fixes %s' % (group.qualified_short_id),
+            key='alksdflskdfjsldkfajsflkslk',
+        )
+
+        release = self.create_release(project=project, version='abcdabc')
+        release.set_commits([{
+            'id': commit.key,
+            'repository': repo.name,
+        }])
+
+        assert GroupCommitResolution.objects.filter(
+            group_id=group.id,
+            commit_id=commit.id
+        ).exists()
+
+        resolution = GroupResolution.objects.get(
+            group=group,
+        )
+        assert resolution.status == GroupResolution.Status.resolved
+        assert resolution.release == release
+        assert resolution.type == GroupResolution.Type.in_release
+        assert resolution.actor_id is None
+
+        assert Group.objects.get(id=group.id).status == GroupStatus.RESOLVED
diff --git a/tests/sentry/web/frontend/accounts/tests.py b/tests/sentry/web/frontend/accounts/tests.py
index ca137e28ee..34b3e8a6c4 100644
--- a/tests/sentry/web/frontend/accounts/tests.py
+++ b/tests/sentry/web/frontend/accounts/tests.py
@@ -278,6 +278,7 @@ class ConfirmEmailSendTest(TestCase):
     @mock.patch('sentry.models.User.send_confirm_emails')
     def test_valid(self, send_confirm_email):
         self.login_as(self.user)
+        UserEmail.objects.filter(user=self.user).update(is_verified=False)
         resp = self.client.post(reverse('sentry-account-confirm-email-send'))
         self.assertRedirects(resp, reverse('sentry-account-settings-emails'), status_code=302)
         send_confirm_email.assert_called_once_with()
@@ -303,6 +304,7 @@ class ConfirmEmailTest(TestCase):
 
     def test_invalid(self):
         self.user.save()
+        UserEmail.objects.get(email=self.user.email).update(is_verified=False)
         resp = self.client.get(reverse('sentry-account-confirm-email',
                                        args=[self.user.id, '5b1f2f266efa03b721cc9ea0d4742c5e']))
         assert resp.status_code == 302
@@ -311,6 +313,7 @@ class ConfirmEmailTest(TestCase):
 
     def test_valid(self):
         self.user.save()
+        UserEmail.objects.get(email=self.user.email).update(is_verified=False)
         self.login_as(self.user)
         self.client.post(reverse('sentry-account-confirm-email-send'))
         email = self.user.emails.first()

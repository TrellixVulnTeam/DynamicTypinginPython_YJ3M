commit 818a39c52efa328b068366f297b9cd360e1e4c14
Author: Jess MacQueen <jess@getsentry.com>
Date:   Wed Apr 20 16:02:21 2016 -0700

    split BarChar and StackedBarChart classes

diff --git a/src/sentry/static/sentry/app/components/barChart.jsx b/src/sentry/static/sentry/app/components/barChart.jsx
index f3d4f93114..0b12d24581 100644
--- a/src/sentry/static/sentry/app/components/barChart.jsx
+++ b/src/sentry/static/sentry/app/components/barChart.jsx
@@ -1,13 +1,11 @@
-import moment from 'moment';
 import React from 'react';
-import {valueIsEqual} from '../utils';
-import TooltipMixin from '../mixins/tooltip';
+import StackedBarChart from '../components/stackedBarChart';
 
 const BarChart = React.createClass({
   propTypes: {
     points: React.PropTypes.arrayOf(React.PropTypes.shape({
       x: React.PropTypes.number.isRequired,
-      y: React.PropTypes.array.isRequired,
+      y: React.PropTypes.number.isRequired,
       label: React.PropTypes.string
     })),
     interval: React.PropTypes.string,
@@ -18,250 +16,24 @@ const BarChart = React.createClass({
     markers: React.PropTypes.arrayOf(React.PropTypes.shape({
       x: React.PropTypes.number.isRequired,
       label: React.PropTypes.string
-    })),
-    barClasses: React.PropTypes.array
-  },
-
-  mixins: [
-    TooltipMixin(function () {
-      let barChartInstance = this;
-      return {
-        html: true,
-        placement: this.props.placement,
-        selector: '.tip',
-        viewport: this.props.viewport,
-
-        // This callback is fired when the user hovers over the
-        // barchart / triggers tooltip rendering. This is better
-        // than using data-title, which renders up-front for each
-        // BarChart (slow).
-        title: function (instance) {
-          // `this` is the targeted element
-          let pointIdx = this.getAttribute('data-point-index');
-
-          if (pointIdx)
-            return barChartInstance.renderTooltip(pointIdx);
-          else
-            return this.getAttribute('data-title');
-        }
-      };
-    })
-  ],
-
-  statics: {
-    getInterval(points) {
-      return points.length > 1 ? points[1].x - points[0].x : null;
-    }
+    }))
   },
 
   getDefaultProps() {
     return {
-      className: '',
-      height: null,
-      label: 'events',
-      placement: 'bottom',
       points: [],
-      markers: [],
-      width: null,
-      barClasses: ['chart-bar']
     };
   },
 
-  getInitialState() {
-    return {
-      interval: BarChart.getInterval(this.props.points)
-    };
-  },
-
-  componentWillReceiveProps(nextProps) {
-    if (nextProps.points) {
-      this.setState({
-        interval: BarChart.getInterval(nextProps.points)
-      });
-    }
-  },
-
-  shouldComponentUpdate(nextProps, nextState) {
-    return !valueIsEqual(this.props, nextProps, true);
-  },
-
-  floatFormat(number, places) {
-    let multi = Math.pow(10, places);
-    return parseInt(number * multi, 10) / multi;
-  },
-
-  timeLabelAsHour(point) {
-    let timeMoment = moment(point.x * 1000);
-    let nextMoment = timeMoment.clone().add(59, 'minute');
-
-    return (
-      '<span>' +
-        timeMoment.format('LL') + '<br />' +
-        timeMoment.format('LT') + '  &#8594; ' + nextMoment.format('LT') +
-      '</span>'
-    );
-  },
-
-  timeLabelAsDay(point) {
-    let timeMoment = moment(point.x * 1000);
-
-    return (
-      '<span>' +
-        timeMoment.format('LL') +
-      '</span>'
-    );
-  },
-
-  timeLabelAsRange(interval, point) {
-    let timeMoment = moment(point.x * 1000);
-    let nextMoment = timeMoment.clone().add(interval - 1, 'second');
-
-    return (
-      '<span>' +
-        // e.g. Aug 23rd, 12:50 pm
-        timeMoment.format('MMM Do, h:mm a') +
-        ' &#8594 ' + nextMoment.format('MMM Do, h:mm a') +
-      '</span>'
-    );
-  },
-
-  timeLabelAsFull(point) {
-    let timeMoment = moment(point.x * 1000);
-    return timeMoment.format('lll');
-  },
-
-  getTimeLabel(point) {
-    switch (this.state.interval) {
-      case 3600:
-        return this.timeLabelAsHour(point);
-      case 86400:
-        return this.timeLabelAsDay(point);
-      case null:
-        return this.timeLabelAsFull(point);
-      default:
-        return this.timeLabelAsRange(this.state.interval, point);
-    }
-  },
-
-  maxPointValue() {
-    let maxval = 10;
-    this.props.points.forEach((point) => {
-      let totalY = 0;
-      point.y.forEach((y) => {
-        totalY += y;
-      });
-      if (totalY > maxval) {
-        maxval = totalY;
-      }
-    });
-    return maxval;
-  },
-
-  renderMarker(marker) {
-    let timeLabel = moment(marker.x * 1000).format('lll');
-    let title = (
-      '<div style="width:130px">' +
-        marker.label + '<br/>' +
-        timeLabel +
-      '</div>'
-    );
-    let className = 'chart-marker tip ' + (marker.className || '');
-
-    // example key: m-last-seen-22811123, m-first-seen-228191
-    let key = ['m', marker.className, marker.x].join('-');
-
-    return (
-      <a key={key} className={className} data-title={title}>
-        <span>{marker.label}</span>
-      </a>
-    );
-  },
-
-  renderTooltip(pointIdx) {
-    let point = this.props.points[pointIdx];
-    let timeLabel = this.getTimeLabel(point);
-    let totalY = 0;
-    for (let i = 0; i < point.y.length; i++) {
-      totalY += point.y[i];
-    }
-    let title = (
-      '<div style="width:130px">' +
-        totalY + ' ' + this.props.label + '<br/>' +
-        timeLabel +
-      '</div>'
-    );
-    if (point.label) {
-      title += '<div>(' + point.label + ')</div>';
-    }
-    return title;
-  },
-
-  renderChartColumn(pointIdx, maxval, pointWidth) {
-    let point = this.props.points[pointIdx];
-    let totalY = 0;
-    for (let i = 0; i < point.y.length; i++) {
-      totalY += point.y[i];
-    }
-    let totalPct = totalY / maxval;
-    let prevPct = 0;
-    let pts = point.y.map((y, i) => {
-        let pct = totalY && this.floatFormat((y / totalY) * totalPct * 99, 2);
-        let pt = (
-          <span key={i} className={this.props.barClasses[i]}
-                style={{height: pct + '%', bottom: prevPct + '%'}}>{y}</span>
-        );
-        prevPct += pct;
-        return pt;
-     });
-    return (
-      <a key={point.x}
-         className="chart-column tip"
-         data-point-index={pointIdx}
-         style={{width: pointWidth}}
-       >
-       {pts}
-      </a>
-    );
-  },
-
-  renderChart() {
-    let points = this.props.points;
-    let pointWidth = this.floatFormat(100.0 / points.length, 2) + '%';
-
-    let maxval = this.maxPointValue();
-
-    let markers = this.props.markers.slice();
-
-    let children = [];
-    points.forEach((point, pointIdx) => {
-      while(markers.length && markers[0].x <= point.x) {
-        children.push(this.renderMarker(markers.shift()));
-      }
-
-      children.push(this.renderChartColumn(pointIdx, maxval, pointWidth));
-    });
-
-    // in bizarre case where markers never got rendered, render them last
-    // NOTE: should this ever happen?
-    markers.forEach((marker) => {
-      children.push(this.renderMarker(marker));
-    });
-
-    return children;
-  },
 
   render() {
-    let figureClass = [this.props.className, 'barchart'].join(' ');
-    let maxval = this.maxPointValue();
-
-    return (
-      <figure className={figureClass} height={this.props.height} width={this.props.width}>
-        <span className="max-y">{maxval}</span>
-        <span className="min-y">0</span>
-        <span>{this.renderChart()}</span>
-      </figure>
-    );
+    let points = this.props.points.map((point) => {
+      return {x: point.x, y: [point.y]};
+    });
+    let props = Object.assign({}, this.props, {points: points});
+    return <StackedBarChart {...props} />;
   }
+
 });
 
 export default BarChart;
diff --git a/src/sentry/static/sentry/app/components/events/eventsPerHour.jsx b/src/sentry/static/sentry/app/components/events/eventsPerHour.jsx
index 963976f705..9c4c9d794e 100644
--- a/src/sentry/static/sentry/app/components/events/eventsPerHour.jsx
+++ b/src/sentry/static/sentry/app/components/events/eventsPerHour.jsx
@@ -3,7 +3,7 @@ import React from 'react';
 import {Link} from 'react-router';
 
 import ApiMixin from '../../mixins/apiMixin';
-import BarChart from '../../components/barChart';
+import StackedBarChart from '../../components/stackedBarChart';
 import LoadingError from '../../components/loadingError';
 import OrganizationState from '../../mixins/organizationState';
 
@@ -123,7 +123,7 @@ const EventsPerHour = React.createClass({
       <div>
         <Link className="btn-sidebar-header" to={`/organizations/${org.slug}/stats/`}>{t('View Stats')}</Link>
         <h6 className="nav-header">{t('Events Per Hour')}</h6>
-          <BarChart points={this.state.formattedData} className="sparkline dashboard-sparkline" barClasses={this.STAT_OPTS} />
+          <StackedBarChart points={this.state.formattedData} className="sparkline dashboard-sparkline" barClasses={this.STAT_OPTS} />
       </div>
     );
   },
diff --git a/src/sentry/static/sentry/app/components/group/chart.jsx b/src/sentry/static/sentry/app/components/group/chart.jsx
index 61aec883d4..bd9eaa3002 100644
--- a/src/sentry/static/sentry/app/components/group/chart.jsx
+++ b/src/sentry/static/sentry/app/components/group/chart.jsx
@@ -21,7 +21,7 @@ const GroupChart = React.createClass({
     let stats = group.stats[this.props.statsPeriod];
     if (!stats || !stats.length) return null;
     let points = stats.map((point) => {
-      return {x: point[0], y: [point[1]]};
+      return {x: point[0], y: point[1]};
     });
     let className = 'bar-chart group-chart ' + (this.props.className || '');
 
diff --git a/src/sentry/static/sentry/app/components/stackedBarChart.jsx b/src/sentry/static/sentry/app/components/stackedBarChart.jsx
new file mode 100644
index 0000000000..01a780de7e
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/stackedBarChart.jsx
@@ -0,0 +1,267 @@
+import moment from 'moment';
+import React from 'react';
+import {valueIsEqual} from '../utils';
+import TooltipMixin from '../mixins/tooltip';
+
+const StackedBarChart = React.createClass({
+  propTypes: {
+    points: React.PropTypes.arrayOf(React.PropTypes.shape({
+      x: React.PropTypes.number.isRequired,
+      y: React.PropTypes.array.isRequired,
+      label: React.PropTypes.string
+    })),
+    interval: React.PropTypes.string,
+    height: React.PropTypes.number,
+    width: React.PropTypes.number,
+    placement: React.PropTypes.string,
+    label: React.PropTypes.string,
+    markers: React.PropTypes.arrayOf(React.PropTypes.shape({
+      x: React.PropTypes.number.isRequired,
+      label: React.PropTypes.string
+    })),
+    barClasses: React.PropTypes.array
+  },
+
+  mixins: [
+    TooltipMixin(function () {
+      let barChartInstance = this;
+      return {
+        html: true,
+        placement: this.props.placement,
+        selector: '.tip',
+        viewport: this.props.viewport,
+
+        // This callback is fired when the user hovers over the
+        // barchart / triggers tooltip rendering. This is better
+        // than using data-title, which renders up-front for each
+        // StackedBarChart (slow).
+        title: function (instance) {
+          // `this` is the targeted element
+          let pointIdx = this.getAttribute('data-point-index');
+
+          if (pointIdx)
+            return barChartInstance.renderTooltip(pointIdx);
+          else
+            return this.getAttribute('data-title');
+        }
+      };
+    })
+  ],
+
+  statics: {
+    getInterval(points) {
+      return points.length > 1 ? points[1].x - points[0].x : null;
+    }
+  },
+
+  getDefaultProps() {
+    return {
+      className: '',
+      height: null,
+      label: 'events',
+      placement: 'bottom',
+      points: [],
+      markers: [],
+      width: null,
+      barClasses: ['chart-bar']
+    };
+  },
+
+  getInitialState() {
+    return {
+      interval: StackedBarChart.getInterval(this.props.points)
+    };
+  },
+
+  componentWillReceiveProps(nextProps) {
+    if (nextProps.points) {
+      this.setState({
+        interval: StackedBarChart.getInterval(nextProps.points)
+      });
+    }
+  },
+
+  shouldComponentUpdate(nextProps, nextState) {
+    return !valueIsEqual(this.props, nextProps, true);
+  },
+
+  floatFormat(number, places) {
+    let multi = Math.pow(10, places);
+    return parseInt(number * multi, 10) / multi;
+  },
+
+  timeLabelAsHour(point) {
+    let timeMoment = moment(point.x * 1000);
+    let nextMoment = timeMoment.clone().add(59, 'minute');
+
+    return (
+      '<span>' +
+        timeMoment.format('LL') + '<br />' +
+        timeMoment.format('LT') + '  &#8594; ' + nextMoment.format('LT') +
+      '</span>'
+    );
+  },
+
+  timeLabelAsDay(point) {
+    let timeMoment = moment(point.x * 1000);
+
+    return (
+      '<span>' +
+        timeMoment.format('LL') +
+      '</span>'
+    );
+  },
+
+  timeLabelAsRange(interval, point) {
+    let timeMoment = moment(point.x * 1000);
+    let nextMoment = timeMoment.clone().add(interval - 1, 'second');
+
+    return (
+      '<span>' +
+        // e.g. Aug 23rd, 12:50 pm
+        timeMoment.format('MMM Do, h:mm a') +
+        ' &#8594 ' + nextMoment.format('MMM Do, h:mm a') +
+      '</span>'
+    );
+  },
+
+  timeLabelAsFull(point) {
+    let timeMoment = moment(point.x * 1000);
+    return timeMoment.format('lll');
+  },
+
+  getTimeLabel(point) {
+    switch (this.state.interval) {
+      case 3600:
+        return this.timeLabelAsHour(point);
+      case 86400:
+        return this.timeLabelAsDay(point);
+      case null:
+        return this.timeLabelAsFull(point);
+      default:
+        return this.timeLabelAsRange(this.state.interval, point);
+    }
+  },
+
+  maxPointValue() {
+    let maxval = 10;
+    this.props.points.forEach((point) => {
+      let totalY = 0;
+      point.y.forEach((y) => {
+        totalY += y;
+      });
+      if (totalY > maxval) {
+        maxval = totalY;
+      }
+    });
+    return maxval;
+  },
+
+  renderMarker(marker) {
+    let timeLabel = moment(marker.x * 1000).format('lll');
+    let title = (
+      '<div style="width:130px">' +
+        marker.label + '<br/>' +
+        timeLabel +
+      '</div>'
+    );
+    let className = 'chart-marker tip ' + (marker.className || '');
+
+    // example key: m-last-seen-22811123, m-first-seen-228191
+    let key = ['m', marker.className, marker.x].join('-');
+
+    return (
+      <a key={key} className={className} data-title={title}>
+        <span>{marker.label}</span>
+      </a>
+    );
+  },
+
+  renderTooltip(pointIdx) {
+    let point = this.props.points[pointIdx];
+    let timeLabel = this.getTimeLabel(point);
+    let totalY = 0;
+    for (let i = 0; i < point.y.length; i++) {
+      totalY += point.y[i];
+    }
+    let title = (
+      '<div style="width:130px">' +
+        totalY + ' ' + this.props.label + '<br/>' +
+        timeLabel +
+      '</div>'
+    );
+    if (point.label) {
+      title += '<div>(' + point.label + ')</div>';
+    }
+    return title;
+  },
+
+  renderChartColumn(pointIdx, maxval, pointWidth) {
+    let point = this.props.points[pointIdx];
+    let totalY = 0;
+    for (let i = 0; i < point.y.length; i++) {
+      totalY += point.y[i];
+    }
+    let totalPct = totalY / maxval;
+    let prevPct = 0;
+    let pts = point.y.map((y, i) => {
+        let pct = totalY && this.floatFormat((y / totalY) * totalPct * 99, 2);
+        let pt = (
+          <span key={i} className={this.props.barClasses[i]}
+                style={{height: pct + '%', bottom: prevPct + '%'}}>{y}</span>
+        );
+        prevPct += pct;
+        return pt;
+     });
+    return (
+      <a key={point.x}
+         className="chart-column tip"
+         data-point-index={pointIdx}
+         style={{width: pointWidth}}
+       >
+       {pts}
+      </a>
+    );
+  },
+
+  renderChart() {
+    let points = this.props.points;
+    let pointWidth = this.floatFormat(100.0 / points.length, 2) + '%';
+
+    let maxval = this.maxPointValue();
+
+    let markers = this.props.markers.slice();
+
+    let children = [];
+    points.forEach((point, pointIdx) => {
+      while(markers.length && markers[0].x <= point.x) {
+        children.push(this.renderMarker(markers.shift()));
+      }
+
+      children.push(this.renderChartColumn(pointIdx, maxval, pointWidth));
+    });
+
+    // in bizarre case where markers never got rendered, render them last
+    // NOTE: should this ever happen?
+    markers.forEach((marker) => {
+      children.push(this.renderMarker(marker));
+    });
+
+    return children;
+  },
+
+  render() {
+    let figureClass = [this.props.className, 'barchart'].join(' ');
+    let maxval = this.maxPointValue();
+
+    return (
+      <figure className={figureClass} height={this.props.height} width={this.props.width}>
+        <span className="max-y">{maxval}</span>
+        <span className="min-y">0</span>
+        <span>{this.renderChart()}</span>
+      </figure>
+    );
+  }
+});
+
+export default StackedBarChart;
diff --git a/src/sentry/static/sentry/app/components/stream/groupChart.jsx b/src/sentry/static/sentry/app/components/stream/groupChart.jsx
index 217dbe7dab..427dfc3c19 100644
--- a/src/sentry/static/sentry/app/components/stream/groupChart.jsx
+++ b/src/sentry/static/sentry/app/components/stream/groupChart.jsx
@@ -60,7 +60,7 @@ const GroupChart = React.createClass({
       return null;
 
     let chartData = this.state.stats.map((point) => {
-      return {x: point[0], y: [point[1]]};
+      return {x: point[0], y: point[1]};
     });
 
     return (
diff --git a/src/sentry/static/sentry/app/views/organizationTeams/expandedTeamList.jsx b/src/sentry/static/sentry/app/views/organizationTeams/expandedTeamList.jsx
index 37937e4de6..a004260b30 100644
--- a/src/sentry/static/sentry/app/views/organizationTeams/expandedTeamList.jsx
+++ b/src/sentry/static/sentry/app/views/organizationTeams/expandedTeamList.jsx
@@ -118,7 +118,7 @@ const ExpandedTeamList = React.createClass({
   renderProject(project) {
     let org = this.props.organization;
     let chartData = project.stats && project.stats.map(point => {
-      return {x: point[0], y: [point[1]]};
+      return {x: point[0], y: point[1]};
     });
 
     return (
diff --git a/src/sentry/static/sentry/app/views/projectDashboard/chart.jsx b/src/sentry/static/sentry/app/views/projectDashboard/chart.jsx
index 99cef25de9..9515505e87 100644
--- a/src/sentry/static/sentry/app/views/projectDashboard/chart.jsx
+++ b/src/sentry/static/sentry/app/views/projectDashboard/chart.jsx
@@ -82,7 +82,7 @@ const ProjectChart = React.createClass({
 
   renderChart() {
     let points = this.state.stats.map((point) => {
-      return {x: point[0], y: [point[1]]};
+      return {x: point[0], y: point[1]};
     });
     let startX = (new Date().getTime() / 1000) - 3600 * 24 * 7;
     let markers = this.state.releaseList.filter((release) => {
diff --git a/tests/js/spec/components/barChart.spec.jsx b/tests/js/spec/components/barChart.spec.jsx
index 9941f2b90a..aff628b342 100644
--- a/tests/js/spec/components/barChart.spec.jsx
+++ b/tests/js/spec/components/barChart.spec.jsx
@@ -15,9 +15,9 @@ describe('BarChart', function() {
 
     it('renders with points data', function () {
       let points = [
-        {x: 1439766000, y: [10]},
-        {x: 1439769600, y: [20]},
-        {x: 1439773200, y: [30]},
+        {x: 1439766000, y: 10},
+        {x: 1439769600, y: 20},
+        {x: 1439773200, y: 30},
       ];
 
       let comp = TestUtils.renderIntoDocument(<BarChart points={points}/>);
@@ -31,9 +31,9 @@ describe('BarChart', function() {
 
     it('renders with points and markers', function () {
       let points = [
-        {x: 1439769600, y: [10]},
-        {x: 1439773200, y: [20]},
-        {x: 1439776800, y: [30]}
+        {x: 1439769600, y: 10},
+        {x: 1439773200, y: 20},
+        {x: 1439776800, y: 30}
       ];
       let markers = [
         {x: 1439769600, className: 'first-seen', label: 'first seen'}, // matches first point
@@ -55,7 +55,7 @@ describe('BarChart', function() {
 
     it('renders with points and markers, when first and last seen are same data point', function () {
       let points = [
-        {x: 1439776800, y: [30]}
+        {x: 1439776800, y: 30}
       ];
       let markers = [
         {x: 1439776800, className: 'first-seen', label: 'first seen'},

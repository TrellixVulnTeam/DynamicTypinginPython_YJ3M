commit 181ac76a0754556545ef614532c1cfa4d1ed6252
Author: Matt Robenolt <matt@ydekproductions.com>
Date:   Wed Dec 2 18:21:43 2015 -0800

    Add on a local cache to OptionsStore
    
    This local cache is meant to just hold Option values in-process since
    it's likely that Options may get queried very frequently.
    
    This implements a TTL + grace scenario for Option keys.
    
    TTL is the time for a key to be alive while everything is healthy.
    Meaning, if the TTL hasn't passed, we can make an attempt to fetch from
    network storage.
    
    Grace allows us to pave over network failures a bit. If we get a request
    within the grace period, but network errors, we can safely default to
    just returning the stale value instead of erroring loudly.

diff --git a/src/sentry/middleware/env.py b/src/sentry/middleware/env.py
index adf06ef805..d089e54da0 100644
--- a/src/sentry/middleware/env.py
+++ b/src/sentry/middleware/env.py
@@ -4,6 +4,8 @@ from django.conf import settings
 from django.core.urlresolvers import reverse
 
 from sentry.app import env
+from random import random
+from sentry.options import default_store
 
 
 class SentryEnvMiddleware(object):
@@ -14,3 +16,12 @@ class SentryEnvMiddleware(object):
 
         # bind request to env
         env.request = request
+
+        # Periodically for an expire the local OptionsStore cache.
+        # This cleanup is purely to keep memory low and garbage collect
+        # old values. It's not required to run to keep things consistent.
+        # Internally, if an option is fetched and it's expired, it gets
+        # evicted immediately. This is purely for options that haven't
+        # been fetched since they've expired.
+        if random() < 0.25:
+            default_store.expire_local_cache()
diff --git a/src/sentry/options/manager.py b/src/sentry/options/manager.py
index 680ed7aaf6..c9fc01aac8 100644
--- a/src/sentry/options/manager.py
+++ b/src/sentry/options/manager.py
@@ -29,6 +29,11 @@ FLAG_NOSTORE = 0b010
 # config files.
 FLAG_STOREONLY = 0b100
 
+# How long will a cache key exist in local memory before being evicted
+DEFAULT_KEY_TTL = 10
+# How long will a cache key exist in local memory while the backing store is erroring
+DEFAULT_KEY_GRACE = 60
+
 
 class OptionsManager(object):
     """
@@ -83,13 +88,12 @@ class OptionsManager(object):
                 logger.debug('Using legacy key: %s', key, exc_info=True)
                 # History shows, there was an expectation of no types, and empty string
                 # as the default response value
-                return self.store.make_key(key, '', object, DEFAULT_FLAGS)
+                return self.store.make_key(key, '', object, DEFAULT_FLAGS, 0, 0)
             raise UnknownOption(key)
 
     def get(self, key):
         """
-        Get the value of an option prioritizing the cache, then the database,
-        and finally the local configuration.
+        Get the value of an option, falling back to the local configuration.
 
         If no value is present for the key, the default Option value is returned.
 
@@ -120,7 +124,7 @@ class OptionsManager(object):
         """
         Permanently remove the value of an option.
 
-        This will also clear the value within the cache, which means a following
+        This will also clear the value within the store, which means a following
         get() will result in a miss.
 
         >>> from sentry import options
@@ -135,7 +139,8 @@ class OptionsManager(object):
 
         return self.store.delete(opt)
 
-    def register(self, key, default='', type=None, flags=DEFAULT_FLAGS):
+    def register(self, key, default='', type=None, flags=DEFAULT_FLAGS,
+                 ttl=DEFAULT_KEY_TTL, grace=DEFAULT_KEY_GRACE):
         assert key not in self.registry, 'Option already registered: %r' % key
         # Guess type based on the default value
         if type is None:
@@ -150,7 +155,7 @@ class OptionsManager(object):
             raise TypeError('Options must not be NoneType')
         if not isinstance(default, type):
             raise TypeError('got %r, expected %r' % (_type(default), type))
-        self.registry[key] = self.store.make_key(key, default, type, flags)
+        self.registry[key] = self.store.make_key(key, default, type, flags, ttl, grace)
 
     def unregister(self, key):
         try:
diff --git a/src/sentry/options/store.py b/src/sentry/options/store.py
index fcb11e72dc..bf8335c10c 100644
--- a/src/sentry/options/store.py
+++ b/src/sentry/options/store.py
@@ -9,6 +9,7 @@ from __future__ import absolute_import, print_function
 
 import logging
 from collections import namedtuple
+from time import time
 
 from django.utils import timezone
 from sentry.db.models.query import create_or_update
@@ -16,7 +17,7 @@ from sentry.models import Option
 from sentry.utils.hashlib import md5
 
 
-Key = namedtuple('Key', ('name', 'default', 'type', 'flags', 'cache_key'))
+Key = namedtuple('Key', ('name', 'default', 'type', 'flags', 'ttl', 'grace', 'cache_key'))
 
 CACHE_FETCH_ERR = 'Unable to fetch option cache for %s'
 CACHE_UPDATE_ERR = 'Unable to update option cache for %s'
@@ -24,60 +25,143 @@ CACHE_UPDATE_ERR = 'Unable to update option cache for %s'
 logger = logging.getLogger('sentry')
 
 
+def _make_cache_key(key):
+    return 'o:%s' % md5(key).hexdigest()
+
+
+def _make_cache_value(key, value):
+    now = int(time())
+    return (
+        value,
+        now + key.ttl,
+        now + key.ttl + key.grace,
+    )
+
+
 class OptionsStore(object):
+    """
+    Abstraction for the Option storage logic that should be driven
+    by the OptionsManager.
+
+    OptionsStore is gooey and raw. It provides no protection over
+    what goes into the store. It only knows that it's reading/writing
+    to the right place. If using the OptionsStore directly, it's your
+    job to do validation of the data. You should probably go through
+    OptionsManager instead, unless you need raw access to something.
+    """
+
     def __init__(self, cache=None, ttl=None):
         if cache is None:
             from sentry.cache import default_cache
             cache = default_cache
         self.cache = cache
         self.ttl = ttl
+        self.flush_local_cache()
 
-    def _make_cache_key(self, key):
-        return 'o:%s' % md5(key).hexdigest()
-
-    def make_key(self, name, default, type, flags):
-        return Key(name, default, type, flags, self._make_cache_key(name))
+    def make_key(self, name, default, type, flags, ttl, grace):
+        return Key(name, default, type, flags, int(ttl), int(grace), _make_cache_key(name))
 
     def get(self, key):
+        """
+        Fetches a value from the options store.
+        """
+        result = self.get_cache(key)
+        if result is not None:
+            return result
+
+        result = self.get_store(key)
+        if result is not None:
+            return result
+
+        # As a last ditch effort, let's hope we have a key
+        # in local cache that's possibly stale
+        return self.get_local_cache(key, grace=True)
+
+    def get_cache(self, key):
+        """
+        First check agaist our local in-process cache, falling
+        back to the network cache.
+        """
+        value = self.get_local_cache(key)
+        if value is not None:
+            return value
+
+        cache_key = key.cache_key
         try:
-            result = self.get_cache(key)
+            value = self.cache.get(cache_key)
         except Exception:
             logger.warn(CACHE_FETCH_ERR, key.name, exc_info=True)
-            result = None
+            value = None
+        else:
+            if key.ttl > 0:
+                self._local_cache[cache_key] = _make_cache_value(key, value)
+        return value
+
+    def get_local_cache(self, key, grace=False):
+        """
+        Attempt to fetch a key out of the local cache.
+
+        If the key exists, but is beyond expiration, we only
+        return it if grace=True. This forces the key to be returned
+        in a disaster scenario as long as we're still holding onto it.
+        This allows the OptionStore to pave over potential network hiccups
+        by returning a stale value.
+        """
+        try:
+            value, expires, grace = self._local_cache[key.cache_key]
+        except KeyError:
+            return None
 
-        if result is None:
-            try:
-                result = self.get_store(key)
-            except Option.DoesNotExist:
-                result = None
-            except Exception as e:
-                logger.exception(unicode(e))
-                result = None
-            else:
-                # we only attempt to populate the cache if we were previously
-                # able to successfully talk to the backend
-                # NOTE: There is definitely a race condition here between updating
-                # the store and the cache
-                try:
-                    self.set_cache(key, result)
-                except Exception:
-                    logger.warn(CACHE_UPDATE_ERR, key.name, exc_info=True)
-        return result
+        now = int(time())
 
-    def get_cache(self, key):
-        return self.cache.get(key.cache_key)
+        # Key is within normal expiry window, so just return it
+        if now < expires:
+            return value
+
+        # If we're able to accept within grace window, return it
+        if grace and now < grace:
+            return value
+
+        # Let's clean up values if we're beyond grace.
+        if now > grace:
+            del self._local_cache[key.cache_key]
+
+        # If we're outside the grace window, even if we ask for it
+        # in grace, too bad. The value is considered bad.
+        return None
 
     def get_store(self, key):
-        return Option.objects.get(key=key.name).value
+        """
+        Attempt to fetch value from the database. If successful,
+        also set it back in the cache.
+        """
+        try:
+            value = Option.objects.get(key=key.name).value
+        except Option.DoesNotExist:
+            value = None
+        except Exception as e:
+            logger.exception(unicode(e))
+            value = None
+        else:
+            # we only attempt to populate the cache if we were previously
+            # able to successfully talk to the backend
+            # NOTE: There is definitely a race condition here between updating
+            # the store and the cache
+            try:
+                self.set_cache(key, value)
+            except Exception:
+                logger.warn(CACHE_UPDATE_ERR, key.name, exc_info=True)
+        return value
 
     def set(self, key, value):
+        """
+        Store a value in the option store. Value must get persisted to database first,
+        then attempt caches. If it fails datastore, the entire operation blows up.
+        If cache fails, we ignore silently since it'll get repaired later by sync_options.
+        A boolean is returned to indicate if the network set succeeds.
+        """
         self.set_store(key, value)
-        try:
-            self.set_cache(key, value)
-            return True
-        except Exception:
-            logger.warn(CACHE_UPDATE_ERR, key, exc_info=True)
-            return False
+        return self.set_cache(key, value)
 
     def set_store(self, key, value):
         create_or_update(
@@ -90,19 +174,61 @@ class OptionsStore(object):
         )
 
     def set_cache(self, key, value):
-        self.cache.set(key.cache_key, value, self.ttl)
-
-    def delete(self, key):
-        self.delete_store(key)
+        cache_key = key.cache_key
+        if key.ttl > 0:
+            self._local_cache[cache_key] = _make_cache_value(key, value)
         try:
-            self.delete_cache(key)
+            self.cache.set(cache_key, value, self.ttl)
             return True
         except Exception:
-            logger.warn(CACHE_UPDATE_ERR, key, exc_info=True)
+            logger.warn(CACHE_UPDATE_ERR, key.name, exc_info=True)
             return False
 
+    def delete(self, key):
+        """
+        Remove key out of option stores. This operation must succeed on the
+        database first. If database fails, an exception is raised.
+        If database succeeds, caches are then allowed to fail silently.
+        A boolean is returned to indicate if the network deletion succeeds.
+        """
+        self.delete_store(key)
+        return self.delete_cache(key)
+
     def delete_store(self, key):
         Option.objects.filter(key=key.name).delete()
 
     def delete_cache(self, key):
-        self.cache.delete(key.cache_key)
+        cache_key = key.cache_key
+        try:
+            del self._local_cache[cache_key]
+        except KeyError:
+            pass
+        try:
+            self.cache.delete(cache_key)
+            return True
+        except Exception:
+            logger.warn(CACHE_UPDATE_ERR, key, exc_info=True)
+            return False
+
+    def expire_local_cache(self):
+        """
+        Iterate over our local cache items, and
+        remove the keys that are beyond their grace time.
+        """
+        if not self._local_cache:
+            return
+
+        to_expire = []
+        now = int(time())
+        for k, (_, _, grace) in self._local_cache.iteritems():
+            if now > grace:
+                to_expire.append(k)
+
+        for k in to_expire:
+            del self._local_cache[k]
+
+    def flush_local_cache(self):
+        """
+        Empty store's local in-process cache.
+        """
+        self._local_cache = {}
diff --git a/tests/sentry/options/test_manager.py b/tests/sentry/options/test_manager.py
index af1edbc50f..ff27196af9 100644
--- a/tests/sentry/options/test_manager.py
+++ b/tests/sentry/options/test_manager.py
@@ -5,6 +5,7 @@ from __future__ import absolute_import
 from exam import fixture, around
 from mock import patch
 
+from sentry.models import Option
 from sentry.options.store import OptionsStore
 from sentry.options.manager import (
     OptionsManager, UnknownOption,
@@ -102,12 +103,14 @@ class OptionsManagerTest(TestCase):
             self.manager.set('nostore', 'thing')
 
         # Make sure that we don't touch either of the stores
-        with patch.object(self.store, 'get_cache', side_effect=Exception()):
-            with patch.object(self.store, 'get_store', side_effect=Exception()):
+        with patch.object(self.store.cache, 'get', side_effect=Exception()):
+            with patch.object(Option.objects, 'get_queryset', side_effect=Exception()):
                 assert self.manager.get('nostore') == ''
+                self.store.flush_local_cache()
 
                 with self.settings(SENTRY_OPTIONS={'nostore': 'foo'}):
                     assert self.manager.get('nostore') == 'foo'
+                    self.store.flush_local_cache()
 
         with self.assertRaises(AssertionError):
             self.manager.delete('nostore')
@@ -134,55 +137,69 @@ class OptionsManagerTest(TestCase):
             assert self.manager.get('storeonly') == ''
 
     def test_db_unavailable(self):
-        with patch.object(self.store, 'set_store', side_effect=Exception()):
+        with patch.object(Option.objects, 'get_queryset', side_effect=Exception()):
             # we can't update options if the db is unavailable
             with self.assertRaises(Exception):
                 self.manager.set('foo', 'bar')
 
         self.manager.set('foo', 'bar')
+        self.store.flush_local_cache()
 
-        with patch.object(self.store, 'get_store', side_effect=Exception()):
+        with patch.object(Option.objects, 'get_queryset', side_effect=Exception()):
             assert self.manager.get('foo') == 'bar'
+            self.store.flush_local_cache()
 
-            with patch.object(self.store, 'get_cache', side_effect=Exception()):
+            with patch.object(self.store.cache, 'get', side_effect=Exception()):
                 assert self.manager.get('foo') == ''
+                self.store.flush_local_cache()
 
-                with patch.object(self.store, 'set_cache', side_effect=Exception()):
+                with patch.object(self.store.cache, 'set', side_effect=Exception()):
                     assert self.manager.get('foo') == ''
+                    self.store.flush_local_cache()
 
     def test_db_and_cache_unavailable(self):
         self.manager.set('foo', 'bar')
+        self.store.flush_local_cache()
 
         with self.settings(SENTRY_OPTIONS={'foo': 'baz'}):
-            with patch.object(self.store, 'get_store', side_effect=Exception()):
-                with patch.object(self.store, 'get_cache', side_effect=Exception()):
+            with patch.object(Option.objects, 'get_queryset', side_effect=Exception()):
+                with patch.object(self.store.cache, 'get', side_effect=Exception()):
                     assert self.manager.get('foo') == 'baz'
+                    self.store.flush_local_cache()
 
-                    with patch.object(self.store, 'set_cache', side_effect=Exception()):
+                    with patch.object(self.store.cache, 'set', side_effect=Exception()):
                         assert self.manager.get('foo') == 'baz'
+                        self.store.flush_local_cache()
 
     def test_cache_unavailable(self):
         self.manager.set('foo', 'bar')
+        self.store.flush_local_cache()
 
-        with patch.object(self.store, 'get_cache', side_effect=Exception()):
+        with patch.object(self.store.cache, 'get', side_effect=Exception()):
             assert self.manager.get('foo') == 'bar'
+            self.store.flush_local_cache()
 
-            with patch.object(self.store, 'set_cache', side_effect=Exception()):
+            with patch.object(self.store.cache, 'set', side_effect=Exception()):
                 assert self.manager.get('foo') == 'bar'
+                self.store.flush_local_cache()
 
                 # we should still be able to write a new value
                 self.manager.set('foo', 'baz')
+                self.store.flush_local_cache()
 
         # the cache should be incorrect now, but sync_options will eventually
         # correct the state
         assert self.manager.get('foo') == 'bar'
+        self.store.flush_local_cache()
 
         # when the cache poofs, the db will be return the most-true answer
-        with patch.object(self.store, 'get_cache', side_effect=Exception()):
+        with patch.object(self.store.cache, 'get', side_effect=Exception()):
             assert self.manager.get('foo') == 'baz'
+            self.store.flush_local_cache()
 
-            with patch.object(self.store, 'set_cache', side_effect=Exception()):
+            with patch.object(self.store.cache, 'set', side_effect=Exception()):
                 assert self.manager.get('foo') == 'baz'
+                self.store.flush_local_cache()
 
     def test_unregister(self):
         with self.assertRaises(UnknownOption):

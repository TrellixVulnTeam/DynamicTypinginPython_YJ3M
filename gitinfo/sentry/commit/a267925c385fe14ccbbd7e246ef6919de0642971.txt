commit a267925c385fe14ccbbd7e246ef6919de0642971
Author: MeredithAnya <meredith.a.heller@gmail.com>
Date:   Tue May 5 11:47:03 2020 -0700

    ref(slack): Add user_scope parameter (#18604)
    
    * update slack provider to support user_scope

diff --git a/src/sentry/identity/slack/provider.py b/src/sentry/identity/slack/provider.py
index 60ecffea94..8b66c13792 100644
--- a/src/sentry/identity/slack/provider.py
+++ b/src/sentry/identity/slack/provider.py
@@ -3,7 +3,7 @@ from __future__ import absolute_import
 from django.conf import settings
 
 from sentry import options
-from sentry.identity.oauth2 import OAuth2Provider
+from sentry.identity.oauth2 import OAuth2Provider, OAuth2LoginView, OAuth2CallbackView
 
 
 class SlackIdentityProvider(OAuth2Provider):
@@ -15,6 +15,10 @@ class SlackIdentityProvider(OAuth2Provider):
 
     oauth_scopes = ("identity.basic", "identity.email")
 
+    # Only used during installation for Bot apps in order to request "links:read"
+    # user_scope, needed for unfurling.
+    user_scopes = ()
+
     def get_oauth_authorize_url(self):
         if self.use_wst_app:
             return "https://slack.com/oauth/authorize"
@@ -50,6 +54,24 @@ class SlackIdentityProvider(OAuth2Provider):
             return options.get("slack-v2.client-secret")
         return options.get("slack.client-secret")
 
+    def get_user_scopes(self):
+        return self.config.get("user_scopes", self.user_scopes)
+
+    def get_pipeline_views(self):
+        return [
+            SlackOAuth2LoginView(
+                authorize_url=self.get_oauth_authorize_url(),
+                client_id=self.get_oauth_client_id(),
+                scope=" ".join(self.get_oauth_scopes()),
+                user_scope=" ".join(self.get_user_scopes()),
+            ),
+            OAuth2CallbackView(
+                access_token_url=self.get_oauth_access_token_url(),
+                client_id=self.get_oauth_client_id(),
+                client_secret=self.get_oauth_client_secret(),
+            ),
+        ]
+
     def get_oauth_data(self, payload):
         # TODO(epurkhiser): This flow isn't actually used right now in sentry.
         # In slack-bot world we would need to make an API call to the 'me'
@@ -67,3 +89,42 @@ class SlackIdentityProvider(OAuth2Provider):
             "scopes": sorted(data["scope"].split(",")),
             "data": self.get_oauth_data(data),
         }
+
+
+class SlackOAuth2LoginView(OAuth2LoginView):
+    """
+    We need to customize the OAuth2LoginView in order to support passing through
+    the `user_scope` param in the request.
+
+    The `user_scope` param would not be used when requesting identity scopes.
+    """
+
+    user_scope = ""
+
+    def __init__(
+        self, authorize_url=None, client_id=None, scope=None, user_scope=None, *args, **kwargs
+    ):
+        super(SlackOAuth2LoginView, self).__init__(
+            authorize_url=authorize_url, client_id=client_id, scope=scope, *args, **kwargs
+        )
+        if user_scope is not None:
+            self.user_scope = user_scope
+
+    def get_authorize_params(self, state, redirect_uri):
+        data = super(SlackOAuth2LoginView, self).get_authorize_params(state, redirect_uri)
+
+        # XXX(meredith): Bot apps must be added manually to channels, and link unfurling
+        # only works for channels the bot is a part of, so in order to expand the usage
+        # of unfurling to work in channels the bot is not a part of we must request the
+        # `links:read` scope for the user. This way channels that the authorizing user
+        # are in will support link unfurling
+        #
+        # The way we can request scopes for users is by using the `user_scope` param. This
+        # will give us the user token...which I don't think we use, but requesting the scope
+        # seems to be enough to get the unfurling to work.
+        #
+        # Resources: https://api.slack.com/authentication/oauth-v2#asking
+        if self.user_scope:
+            data["user_scope"] = self.user_scope
+
+        return data
diff --git a/src/sentry/integrations/slack/integration.py b/src/sentry/integrations/slack/integration.py
index 2ed8b494a2..fc523d8c3a 100644
--- a/src/sentry/integrations/slack/integration.py
+++ b/src/sentry/integrations/slack/integration.py
@@ -123,6 +123,7 @@ class SlackIntegrationProvider(IntegrationProvider):
     def get_pipeline_views(self):
         identity_pipeline_config = {
             "oauth_scopes": self.identity_oauth_scopes,
+            "user_scopes": frozenset(["links:read"]) if not self.use_wst_app else (),
             "redirect_url": absolute_uri("/extensions/slack/setup/"),
         }
 
diff --git a/tests/sentry/integrations/slack/test_integration.py b/tests/sentry/integrations/slack/test_integration.py
index b969972ca5..9c8254457a 100644
--- a/tests/sentry/integrations/slack/test_integration.py
+++ b/tests/sentry/integrations/slack/test_integration.py
@@ -45,6 +45,8 @@ class SlackIntegrationTest(IntegrationTestCase):
         assert params["redirect_uri"] == ["http://testserver/extensions/slack/setup/"]
         assert params["response_type"] == ["code"]
         assert params["client_id"] == [expected_client_id]
+
+        assert params.get("user_scope") is None if is_wst_app else ["links:read"]
         # once we've asserted on it, switch to a singular values to make life
         # easier
         authorize_params = {k: v[0] for k, v in six.iteritems(params)}

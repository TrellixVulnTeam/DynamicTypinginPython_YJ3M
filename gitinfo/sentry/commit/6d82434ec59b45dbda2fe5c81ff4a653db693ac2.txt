commit 6d82434ec59b45dbda2fe5c81ff4a653db693ac2
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Thu Nov 29 08:24:21 2018 -0800

    ref(ui): Refactor stream search bar into two components (#10691)
    
    This refactors the stream search bar into two components so that the base component
    can be re-used. The stream search bar will provide supported tags, default tags, and the API call to get tag values.

diff --git a/src/sentry/static/sentry/app/components/smartSearchBar.jsx b/src/sentry/static/sentry/app/components/smartSearchBar.jsx
new file mode 100644
index 0000000000..c81055004a
--- /dev/null
+++ b/src/sentry/static/sentry/app/components/smartSearchBar.jsx
@@ -0,0 +1,497 @@
+import PropTypes from 'prop-types';
+import React from 'react';
+import Reflux from 'reflux';
+import _ from 'lodash';
+import classNames from 'classnames';
+import createReactClass from 'create-react-class';
+import styled from 'react-emotion';
+
+import {t} from 'app/locale';
+import MemberListStore from 'app/stores/memberListStore';
+import SearchDropdown from 'app/views/stream/searchDropdown';
+import withOrganization from 'app/utils/withOrganization';
+
+export function addSpace(query = '') {
+  if (query.length !== 0 && query[query.length - 1] !== ' ') {
+    return query + ' ';
+  } else {
+    return query;
+  }
+}
+
+export function removeSpace(query = '') {
+  if (query[query.length - 1] === ' ') {
+    return query.slice(0, query.length - 1);
+  } else {
+    return query;
+  }
+}
+class SmartSearchBar extends React.Component {
+  static propTypes = {
+    defaultQuery: PropTypes.string,
+    query: PropTypes.string,
+    defaultSearchItems: PropTypes.array.isRequired,
+    disabled: PropTypes.bool,
+    placeholder: PropTypes.string,
+
+    // Map of tags
+    supportedTags: PropTypes.object,
+
+    onGetTagValues: PropTypes.func,
+
+    onSearch: PropTypes.func,
+    // If true, excludes the environment tag from the autocompletion list
+    // This is because we don't want to treat environment as a tag in some places
+    // such as the stream view where it is a top level concept
+    excludeEnvironment: PropTypes.bool,
+  };
+
+  /**
+   * Given a query, and the current cursor position, return the string-delimiting
+   * index of the search term designated by the cursor.
+   */
+  static getLastTermIndex = (query, cursor) => {
+    // TODO: work with quoted-terms
+    let cursorOffset = query.slice(cursor).search(/\s|$/);
+    return cursor + (cursorOffset === -1 ? 0 : cursorOffset);
+  };
+
+  /**
+   * Returns an array of query terms, including incomplete terms
+   *
+   * e.g. ["is:unassigned", "browser:\"Chrome 33.0\"", "assigned"]
+   */
+  static getQueryTerms = (query, cursor) => {
+    return query.slice(0, cursor).match(/\S+:"[^"]*"?|\S+/g);
+  };
+
+  static defaultProps = {
+    defaultQuery: '',
+    query: null,
+    onSearch: function() {},
+    excludeEnvironment: false,
+    placeholder: t('Search for events, users, tags, and everything else.'),
+    supportedTags: {},
+    defaultSearchItems: [],
+  };
+
+  constructor(props) {
+    super(props);
+
+    this.state = {
+      query: props.query !== null ? addSpace(props.query) : props.defaultQuery,
+
+      searchTerm: '',
+      searchItems: [],
+      activeSearchItem: 0,
+
+      tags: {},
+
+      dropdownVisible: false,
+      loading: false,
+    };
+
+    this.searchInput = React.createRef();
+  }
+
+  componentWillReceiveProps(nextProps) {
+    // query was updated by another source (e.g. sidebar filters)
+    if (nextProps.query !== this.props.query) {
+      this.setState({
+        query: addSpace(nextProps.query),
+      });
+    }
+  }
+
+  DROPDOWN_BLUR_DURATION = 200;
+
+  blur = () => {
+    if (!this.searchInput.current) {
+      return;
+    }
+    this.searchInput.current.blur();
+  };
+
+  onSubmit = evt => {
+    evt.preventDefault();
+    this.blur();
+    this.props.onSearch(removeSpace(this.state.query));
+  };
+
+  clearSearch = () => {
+    this.setState({query: ''}, () => this.props.onSearch(this.state.query));
+  };
+
+  onQueryFocus = () => {
+    this.setState({
+      dropdownVisible: true,
+    });
+  };
+
+  onQueryBlur = () => {
+    // wait 200ms before closing dropdown in case blur was a result of
+    // clicking a menu option
+    this.blurTimeout = setTimeout(() => {
+      this.blurTimeout = null;
+      this.setState({dropdownVisible: false});
+    }, this.DROPDOWN_BLUR_DURATION);
+  };
+
+  onQueryChange = evt => {
+    this.setState({query: evt.target.value}, () => this.updateAutoCompleteItems());
+  };
+
+  onKeyUp = evt => {
+    if (evt.key === 'Escape' || evt.keyCode === 27) {
+      // blur handler should additionally hide dropdown
+      this.blur();
+    }
+  };
+
+  getCursorPosition = () => {
+    if (!this.searchInput.current) {
+      return -1;
+    }
+    return this.searchInput.current.selectionStart;
+  };
+
+  /**
+   * Returns array of possible key values that substring match `query`
+   *
+   * e.g. ['is:', 'assigned:', 'url:', 'release:']
+   */
+  getTagKeys = function(query) {
+    const {supportedTags} = this.props;
+    const tagKeys = Object.keys(supportedTags)
+      .map(key => `${key}:`)
+      .filter(key => key.indexOf(query) > -1);
+
+    // If the environment feature is active and excludeEnvironment = true
+    // then remove the environment key
+    if (this.props.excludeEnvironment) {
+      return tagKeys.filter(key => key !== 'environment:');
+    } else {
+      return tagKeys;
+    }
+  };
+
+  /**
+   * Returns array of tag values that substring match `query`; invokes `callback`
+   * with data when ready
+   */
+  getTagValues = _.debounce((tag, query, callback) => {
+    // Strip double quotes if there are any
+    query = query.replace(/"/g, '').trim();
+
+    this.setState({
+      loading: true,
+    });
+
+    this.props.onGetTagValues(tag, query).then(
+      values => {
+        this.setState({loading: false});
+        callback(
+          values.map(value => {
+            // Wrap in quotes if there is a space
+            return value.indexOf(' ') > -1 ? `"${value}"` : value;
+          }),
+          tag.key,
+          query
+        );
+      },
+      () => {
+        this.setState({loading: false});
+      }
+    );
+  }, 300);
+
+  /**
+   * Returns array of tag values that substring match `query`; invokes `callback`
+   * with results
+   */
+  getPredefinedTagValues = function(tag, query, callback) {
+    let values = tag.values.filter(value => value.indexOf(query) > -1);
+
+    callback(values, tag.key);
+  };
+
+  onInputClick = () => {
+    this.updateAutoCompleteItems();
+  };
+
+  updateAutoCompleteItems = () => {
+    if (this.blurTimeout) {
+      clearTimeout(this.blurTimeout);
+      this.blurTimeout = null;
+    }
+
+    let cursor = this.getCursorPosition();
+    let query = this.state.query;
+
+    let lastTermIndex = SmartSearchBar.getLastTermIndex(query, cursor);
+    let terms = SmartSearchBar.getQueryTerms(query.slice(0, lastTermIndex));
+
+    if (
+      !terms || // no terms
+      terms.length === 0 || // no terms
+      (terms.length === 1 && terms[0] === this.props.defaultQuery) || // default term
+      /^\s+$/.test(query.slice(cursor - 1, cursor + 1))
+    ) {
+      // cursor on whitespace
+      // show default "help" search terms
+      return void this.setState({
+        searchTerm: '',
+        searchItems: this.props.defaultSearchItems,
+        activeSearchItem: 0,
+      });
+    }
+
+    let last = terms.pop();
+    let autoCompleteItems;
+    let matchValue;
+    let tagName;
+    let index = last.indexOf(':');
+
+    if (index === -1) {
+      // No colon present; must still be deciding key
+      matchValue = last;
+      autoCompleteItems = this.getTagKeys(matchValue);
+
+      this.setState({searchTerm: matchValue});
+      this.updateAutoCompleteState(autoCompleteItems, matchValue);
+    } else {
+      let {supportedTags} = this.props;
+      tagName = last.slice(0, index);
+      query = last.slice(index + 1);
+
+      // filter existing items immediately, until API can return
+      // with actual tag value results
+      let filteredSearchItems = this.state.searchItems.filter(
+        item => query && item.value.indexOf(query) !== -1
+      );
+
+      this.setState({
+        searchTerm: query,
+        searchItems: filteredSearchItems,
+      });
+
+      let tag = supportedTags[tagName];
+
+      if (!tag) return undefined;
+
+      // Ignore the environment tag if the feature is active and excludeEnvironment = true
+      if (this.props.excludeEnvironment && tagName === 'environment') {
+        return undefined;
+      }
+
+      return void (tag.predefined ? this.getPredefinedTagValues : this.getTagValues)(
+        tag,
+        query,
+        this.updateAutoCompleteState
+      );
+    }
+    return undefined;
+  };
+
+  isDefaultDropdown = () => {
+    return this.state.searchItems === this.props.defaultSearchItems;
+  };
+
+  updateAutoCompleteState = (autoCompleteItems, tagName) => {
+    autoCompleteItems = autoCompleteItems.map(item => {
+      let out = {
+        desc: item,
+        value: item,
+      };
+
+      // Specify icons according to tag value
+      switch (tagName || item.replace(':', '')) {
+        case 'is':
+          out.className = 'icon-toggle';
+          break;
+        case 'assigned':
+        case 'bookmarks':
+          out.className = 'icon-user';
+          break;
+        case 'firstSeen':
+        case 'lastSeen':
+        case 'event.timestamp':
+          out.className = 'icon-clock';
+          break;
+        default:
+          out.className = 'icon-tag';
+      }
+      return out;
+    });
+
+    if (autoCompleteItems.length > 0 && !this.isDefaultDropdown()) {
+      autoCompleteItems[0].active = true;
+    }
+
+    this.setState({
+      searchItems: autoCompleteItems.slice(0, 5), // only show 5
+      activeSearchItem: 0,
+    });
+  };
+
+  onKeyDown = evt => {
+    let state = this.state;
+    let searchItems = state.searchItems;
+
+    if (!searchItems.length) return;
+
+    if (evt.key === 'ArrowDown' || evt.key === 'ArrowUp') {
+      evt.preventDefault();
+
+      // Move active selection up/down
+      delete searchItems[state.activeSearchItem].active;
+
+      state.activeSearchItem =
+        evt.key === 'ArrowDown'
+          ? Math.min(state.activeSearchItem + 1, searchItems.length - 1)
+          : Math.max(state.activeSearchItem - 1, 0);
+
+      searchItems[state.activeSearchItem].active = true;
+      this.setState({searchItems: searchItems.slice(0)});
+    } else if (evt.key === 'Tab' && !this.isDefaultDropdown()) {
+      evt.preventDefault();
+
+      this.onAutoComplete(searchItems[state.activeSearchItem].value);
+    }
+  };
+
+  onAutoComplete = replaceText => {
+    let cursor = this.getCursorPosition();
+    let query = this.state.query;
+
+    let lastTermIndex = SmartSearchBar.getLastTermIndex(query, cursor);
+    let terms = SmartSearchBar.getQueryTerms(query.slice(0, lastTermIndex));
+    let newQuery;
+
+    // If not postfixed with : (tag value), add trailing space
+    let lastChar = replaceText.charAt(replaceText.length - 1);
+    replaceText += lastChar === ':' || lastChar === '.' ? '' : ' ';
+
+    if (!terms) {
+      newQuery = replaceText;
+    } else {
+      let last = terms.pop();
+
+      newQuery = query.slice(0, lastTermIndex); // get text preceding last term
+
+      newQuery =
+        last.indexOf(':') > -1
+          ? // tag key present: replace everything after colon with replaceText
+            newQuery.replace(/\:"[^"]*"?$|\:\S*$/, ':' + replaceText)
+          : // no tag key present: replace last token with replaceText
+            newQuery.replace(/\S+$/, replaceText);
+
+      newQuery = newQuery.concat(query.slice(lastTermIndex));
+    }
+
+    this.setState(
+      {
+        query: newQuery,
+      },
+      () => {
+        // setting a new input value will lose focus; restore it
+        if (this.searchInput.current) {
+          this.searchInput.current.focus();
+        }
+
+        // then update the autocomplete box with new contextTypes
+        this.updateAutoCompleteItems();
+      }
+    );
+  };
+
+  render() {
+    let {className, disabled} = this.props;
+
+    return (
+      <div
+        className={classNames(
+          'search',
+          {
+            disabled,
+          },
+          className
+        )}
+      >
+        <form className="form-horizontal" onSubmit={this.onSubmit}>
+          <div>
+            <input
+              type="text"
+              className="search-input form-control"
+              placeholder={this.props.placeholder}
+              name="query"
+              ref={this.searchInput}
+              autoComplete="off"
+              value={this.state.query}
+              onFocus={this.onQueryFocus}
+              onBlur={this.onQueryBlur}
+              onKeyUp={this.onKeyUp}
+              onKeyDown={this.onKeyDown}
+              onChange={this.onQueryChange}
+              onClick={this.onInputClick}
+              disabled={this.props.disabled}
+            />
+            <span className="icon-search" />
+            {this.state.query !== '' && (
+              <div>
+                <a className="search-clear-form" onClick={this.clearSearch}>
+                  <span className="icon-circle-cross" />
+                </a>
+              </div>
+            )}
+          </div>
+
+          {(this.state.loading || this.state.searchItems.length > 0) && (
+            <DropdownWrapper visible={this.state.dropdownVisible}>
+              <SearchDropdown
+                items={this.state.searchItems}
+                onClick={this.onAutoComplete}
+                loading={this.state.loading}
+                searchSubstring={this.state.searchTerm}
+              />
+            </DropdownWrapper>
+          )}
+        </form>
+      </div>
+    );
+  }
+}
+
+const SmartSearchBarContainer = withOrganization(
+  createReactClass({
+    displayName: 'SmartSearchBarContainer',
+
+    mixins: [Reflux.listenTo(MemberListStore, 'onMemberListStoreChange')],
+
+    getInitialState() {
+      return {
+        members: MemberListStore.getAll(),
+      };
+    },
+
+    onMemberListStoreChange(members) {
+      this.setState(
+        {
+          members,
+        },
+        this.updateAutoCompleteItems
+      );
+    },
+
+    render() {
+      return <SmartSearchBar {...this.props} members={this.state.members} />;
+    },
+  })
+);
+
+const DropdownWrapper = styled('div')`
+  display: ${p => (p.visible ? 'block' : 'none')};
+`;
+
+export default SmartSearchBarContainer;
+export {SmartSearchBar};
diff --git a/src/sentry/static/sentry/app/views/stream/filters.jsx b/src/sentry/static/sentry/app/views/stream/filters.jsx
index 72fa3066e1..11eeace405 100644
--- a/src/sentry/static/sentry/app/views/stream/filters.jsx
+++ b/src/sentry/static/sentry/app/views/stream/filters.jsx
@@ -4,7 +4,7 @@ import React from 'react';
 import SavedSearchSelector from 'app/views/stream/savedSearchSelector';
 import SearchBar from 'app/views/stream/searchBar';
 import SortOptions from 'app/views/stream/sortOptions';
-import {t} from 'app/locale';
+import TagStore from 'app/stores/tagStore';
 
 class StreamFilters extends React.Component {
   static propTypes = {
@@ -83,11 +83,11 @@ class StreamFilters extends React.Component {
               <SearchBar
                 orgId={orgId}
                 projectId={projectId}
-                placeholder={t('Search for events, users, tags, and everything else.')}
                 query={query || ''}
                 onSearch={onSearch}
                 disabled={isSearchDisabled}
                 excludeEnvironment={true}
+                supportedTags={TagStore.getAllTags()}
               />
               <a
                 className="btn btn-default toggle-stream-sidebar"
diff --git a/src/sentry/static/sentry/app/views/stream/searchBar.jsx b/src/sentry/static/sentry/app/views/stream/searchBar.jsx
index fda4e5cdb8..341c5ac765 100644
--- a/src/sentry/static/sentry/app/views/stream/searchBar.jsx
+++ b/src/sentry/static/sentry/app/views/stream/searchBar.jsx
@@ -1,513 +1,93 @@
 import PropTypes from 'prop-types';
 import React from 'react';
-import createReactClass from 'create-react-class';
-import ReactDOM from 'react-dom';
-import Reflux from 'reflux';
-import _ from 'lodash';
-import classNames from 'classnames';
 
-import TagStore from 'app/stores/tagStore';
-import MemberListStore from 'app/stores/memberListStore';
-
-import ApiMixin from 'app/mixins/apiMixin';
 import {t} from 'app/locale';
-
-import SearchDropdown from 'app/views/stream/searchDropdown';
-import OrganizationState from 'app/mixins/organizationState';
-
-export function addSpace(query = '') {
-  if (query.length !== 0 && query[query.length - 1] !== ' ') {
-    return query + ' ';
-  } else {
-    return query;
-  }
-}
-
-export function removeSpace(query = '') {
-  if (query[query.length - 1] === ' ') {
-    return query.slice(0, query.length - 1);
-  } else {
-    return query;
-  }
-}
-
-const SearchBar = createReactClass({
-  displayName: 'SearchBar',
-
-  propTypes: {
-    defaultQuery: PropTypes.string,
-    query: PropTypes.string,
-    defaultSearchItems: PropTypes.array.isRequired,
-    disabled: PropTypes.bool,
-    placeholder: PropTypes.string,
-    onSearch: PropTypes.func,
-    // If true, excludes the environment tag from the autocompletion list
-    // This is because we don't want to treat environment as a tag in some places
-    // such as the stream view where it is a top level concept
-    excludeEnvironment: PropTypes.bool,
-  },
-
-  mixins: [
-    ApiMixin,
-    OrganizationState,
-    Reflux.listenTo(MemberListStore, 'onMemberListStoreChange'),
-  ],
-
-  statics: {
-    /**
-     * Given a query, and the current cursor position, return the string-delimiting
-     * index of the search term designated by the cursor.
-     */
-    getLastTermIndex(query, cursor) {
-      // TODO: work with quoted-terms
-      let cursorOffset = query.slice(cursor).search(/\s|$/);
-      return cursor + (cursorOffset === -1 ? 0 : cursorOffset);
-    },
-
-    /**
-     * Returns an array of query terms, including incomplete terms
-     *
-     * e.g. ["is:unassigned", "browser:\"Chrome 33.0\"", "assigned"]
-     */
-    getQueryTerms(query, cursor) {
-      return query.slice(0, cursor).match(/\S+:"[^"]*"?|\S+/g);
-    },
-  },
-
-  getDefaultProps() {
-    return {
-      defaultQuery: '',
-      query: null,
-      onSearch: function() {},
-      excludeEnvironment: false,
-      defaultSearchItems: [
-        {
-          title: t('Tag'),
-          desc: t('key/value pair associated to an issue'),
-          example: 'browser:"Chrome 34", has:browser',
-          className: 'icon-tag',
-          value: 'browser:',
-        },
-        {
-          title: t('Status'),
-          desc: t('State of an issue'),
-          example: 'is:resolved, unresolved, ignored, assigned, unassigned',
-          className: 'icon-toggle',
-          value: 'is:',
-        },
-        {
-          title: t('Time or Count'),
-          desc: t('Time or Count related search'),
-          example: 'firstSeen, lastSeen, event.timestamp, timesSeen',
-          className: 'icon-clock',
-          value: '',
-        },
-        {
-          title: t('Assigned'),
-          desc: t('team member assigned to an issue'),
-          example: 'assigned:[me|user@example.com]',
-          className: 'icon-user',
-          value: 'assigned:',
-        },
-        {
-          title: t('Bookmarked By'),
-          desc: t('team member who bookmarked an issue'),
-          example: 'bookmarks:[me|user@example.com]',
-          className: 'icon-user',
-          value: 'bookmarks:',
-        },
-        {
-          desc: t('or paste an event id to jump straight to it'),
-          className: 'icon-hash',
-          value: '',
-        },
-      ],
-    };
-  },
-
-  getInitialState() {
-    return {
-      query:
-        this.props.query !== null ? addSpace(this.props.query) : this.props.defaultQuery,
-
-      searchTerm: '',
-      searchItems: [],
-      activeSearchItem: 0,
-
-      tags: {},
-      members: MemberListStore.getAll(),
-
-      dropdownVisible: false,
-      loading: false,
-    };
-  },
-
-  componentWillReceiveProps(nextProps) {
-    // query was updated by another source (e.g. sidebar filters)
-    if (nextProps.query !== this.props.query) {
-      this.setState({
-        query: addSpace(nextProps.query),
-      });
-    }
-  },
-
-  DROPDOWN_BLUR_DURATION: 200,
-
-  blur() {
-    ReactDOM.findDOMNode(this.refs.searchInput).blur();
-  },
-
-  onSubmit(evt) {
-    evt.preventDefault();
-    this.blur();
-    this.props.onSearch(removeSpace(this.state.query));
-  },
-
-  clearSearch() {
-    this.setState({query: ''}, () => this.props.onSearch(this.state.query));
-  },
-
-  onQueryFocus() {
-    this.setState({
-      dropdownVisible: true,
-    });
-  },
-
-  onQueryBlur() {
-    // wait 200ms before closing dropdown in case blur was a result of
-    // clicking a menu option
-    this.blurTimeout = setTimeout(() => {
-      this.blurTimeout = null;
-      this.setState({dropdownVisible: false});
-    }, this.DROPDOWN_BLUR_DURATION);
-  },
-
-  onQueryChange(evt) {
-    this.setState({query: evt.target.value}, () => this.updateAutoCompleteItems());
-  },
-
-  onKeyUp(evt) {
-    if (evt.key === 'Escape' || evt.keyCode === 27) {
-      // blur handler should additionally hide dropdown
-      this.blur();
-    }
-  },
-
-  getCursorPosition() {
-    return ReactDOM.findDOMNode(this.refs.searchInput).selectionStart;
-  },
-
-  /**
-   * Returns array of possible key values that substring match `query`
-   *
-   * e.g. ['is:', 'assigned:', 'url:', 'release:']
-   */
-  getTagKeys: function(query) {
-    const allKeys = TagStore.getTagKeys()
-      .map(key => key + ':')
-      .filter(key => key.indexOf(query) > -1);
-
-    // If the environment feature is active and excludeEnvironment = true
-    // then remove the environment key
-    if (this.props.excludeEnvironment) {
-      return allKeys.filter(key => key !== 'environment:');
-    } else {
-      return allKeys;
-    }
-  },
+import SmartSearchBar from 'app/components/smartSearchBar';
+import TagStore from 'app/stores/tagStore';
+import withApi from 'app/utils/withApi';
+
+const SEARCH_ITEMS = [
+  {
+    title: t('Tag'),
+    desc: t('key/value pair associated to an issue'),
+    example: 'browser:"Chrome 34", has:browser',
+    className: 'icon-tag',
+    value: 'browser:',
+  },
+  {
+    title: t('Status'),
+    desc: t('State of an issue'),
+    example: 'is:resolved, unresolved, ignored, assigned, unassigned',
+    className: 'icon-toggle',
+    value: 'is:',
+  },
+  {
+    title: t('Time or Count'),
+    desc: t('Time or Count related search'),
+    example: 'firstSeen, lastSeen, event.timestamp, timesSeen',
+    className: 'icon-clock',
+    value: '',
+  },
+  {
+    title: t('Assigned'),
+    desc: t('team member assigned to an issue'),
+    example: 'assigned:[me|user@example.com]',
+    className: 'icon-user',
+    value: 'assigned:',
+  },
+  {
+    title: t('Bookmarked By'),
+    desc: t('team member who bookmarked an issue'),
+    example: 'bookmarks:[me|user@example.com]',
+    className: 'icon-user',
+    value: 'bookmarks:',
+  },
+  {
+    desc: t('or paste an event id to jump straight to it'),
+    className: 'icon-hash',
+    value: '',
+  },
+];
+
+class SearchBar extends React.Component {
+  static propTypes = {
+    api: PropTypes.object,
+    orgId: PropTypes.string.isRequired,
+    projectId: PropTypes.string.isRequired,
+  };
 
   /**
    * Returns array of tag values that substring match `query`; invokes `callback`
    * with data when ready
    */
-  getTagValues: _.debounce(function(tag, query, callback) {
-    // Strip double quotes if there are any
-    query = query.replace('"', '').trim();
-
-    this.setState({
-      loading: true,
-    });
+  getTagValues = (tag, query) => {
+    let {api, orgId, projectId} = this.props;
 
-    let {orgId, projectId} = this.props;
-
-    this.api.request(`/projects/${orgId}/${projectId}/tags/${tag.key}/values/`, {
-      data: {
-        query,
-      },
-      method: 'GET',
-      success: values => {
-        this.setState({loading: false});
-        callback(
-          values.map(v => {
-            // Wrap in quotes if there is a space
-            return v.value.indexOf(' ') > -1 ? `"${v.value}"` : v.value;
-          }),
-          tag.key,
-          query
-        );
-      },
-    });
-  }, 300),
-
-  /**
-   * Returns array of tag values that substring match `query`; invokes `callback`
-   * with results
-   */
-  getPredefinedTagValues: function(tag, query, callback) {
-    let values = tag.values.filter(value => value.indexOf(query) > -1);
-
-    callback(values, tag.key);
-  },
-
-  onInputClick() {
-    this.updateAutoCompleteItems();
-  },
-
-  updateAutoCompleteItems() {
-    if (this.blurTimeout) {
-      clearTimeout(this.blurTimeout);
-      this.blurTimeout = null;
-    }
-
-    let cursor = this.getCursorPosition();
-    let query = this.state.query;
-
-    let lastTermIndex = SearchBar.getLastTermIndex(query, cursor);
-    let terms = SearchBar.getQueryTerms(query.slice(0, lastTermIndex));
-
-    if (
-      !terms || // no terms
-      terms.length === 0 || // no terms
-      (terms.length === 1 && terms[0] === this.props.defaultQuery) || // default term
-      /^\s+$/.test(query.slice(cursor - 1, cursor + 1))
-    ) {
-      // cursor on whitespace
-      // show default "help" search terms
-      return void this.setState({
-        searchTerm: '',
-        searchItems: this.props.defaultSearchItems,
-        activeSearchItem: 0,
-      });
-    }
-
-    let last = terms.pop();
-    let autoCompleteItems;
-    let matchValue;
-    let tagName;
-    let index = last.indexOf(':');
-
-    if (index === -1) {
-      // No colon present; must still be deciding key
-      matchValue = last;
-      autoCompleteItems = this.getTagKeys(matchValue);
-
-      this.setState({searchTerm: matchValue});
-      this.updateAutoCompleteState(autoCompleteItems, matchValue);
-    } else {
-      tagName = last.slice(0, index);
-      query = last.slice(index + 1);
-
-      // filter existing items immediately, until API can return
-      // with actual tag value results
-      let filteredSearchItems = this.state.searchItems.filter(
-        item => query && item.value.indexOf(query) !== -1
-      );
-
-      this.setState({
-        searchTerm: query,
-        searchItems: filteredSearchItems,
-      });
-
-      let tag = TagStore.getTag(tagName);
-
-      if (!tag) return undefined;
-
-      // Ignore the environment tag if the feature is active and excludeEnvironment = true
-      if (this.props.excludeEnvironment && tagName === 'environment') {
-        return undefined;
-      }
-
-      return void (tag.predefined ? this.getPredefinedTagValues : this.getTagValues)(
-        tag,
-        query,
-        this.updateAutoCompleteState
+    return api
+      .requestPromise(`/projects/${orgId}/${projectId}/tags/${tag.key}/values/`, {
+        data: {
+          query,
+        },
+        method: 'GET',
+      })
+      .then(
+        values => values.map(({value}) => value),
+        () => {
+          throw new Error('Unable to fetch project tags');
+        }
       );
-    }
-    return undefined;
-  },
-
-  isDefaultDropdown() {
-    return this.state.searchItems === this.props.defaultSearchItems;
-  },
-
-  updateAutoCompleteState(autoCompleteItems, tagName) {
-    autoCompleteItems = autoCompleteItems.map(item => {
-      let out = {
-        desc: item,
-        value: item,
-      };
-
-      // Specify icons according to tag value
-      switch (tagName || item.replace(':', '')) {
-        case 'is':
-          out.className = 'icon-toggle';
-          break;
-        case 'assigned':
-        case 'bookmarks':
-          out.className = 'icon-user';
-          break;
-        case 'firstSeen':
-        case 'lastSeen':
-        case 'event.timestamp':
-          out.className = 'icon-clock';
-          break;
-        default:
-          out.className = 'icon-tag';
-      }
-      return out;
-    });
-
-    if (autoCompleteItems.length > 0 && !this.isDefaultDropdown()) {
-      autoCompleteItems[0].active = true;
-    }
-
-    this.setState({
-      searchItems: autoCompleteItems.slice(0, 5), // only show 5
-      activeSearchItem: 0,
-    });
-  },
-
-  onKeyDown(evt) {
-    let state = this.state;
-    let searchItems = state.searchItems;
-
-    if (!searchItems.length) return;
-
-    if (evt.key === 'ArrowDown' || evt.key === 'ArrowUp') {
-      evt.preventDefault();
-
-      // Move active selection up/down
-      delete searchItems[state.activeSearchItem].active;
-
-      state.activeSearchItem =
-        evt.key === 'ArrowDown'
-          ? Math.min(state.activeSearchItem + 1, searchItems.length - 1)
-          : Math.max(state.activeSearchItem - 1, 0);
-
-      searchItems[state.activeSearchItem].active = true;
-      this.setState({searchItems: searchItems.slice(0)});
-    } else if (evt.key === 'Tab' && !this.isDefaultDropdown()) {
-      evt.preventDefault();
-
-      this.onAutoComplete(searchItems[state.activeSearchItem].value);
-    }
-  },
-
-  onAutoComplete(replaceText) {
-    let cursor = this.getCursorPosition();
-    let query = this.state.query;
-
-    let lastTermIndex = SearchBar.getLastTermIndex(query, cursor);
-    let terms = SearchBar.getQueryTerms(query.slice(0, lastTermIndex));
-    let newQuery;
-
-    // If not postfixed with : (tag value), add trailing space
-    replaceText += replaceText.charAt(replaceText.length - 1) === ':' ? '' : ' ';
-
-    if (!terms) {
-      newQuery = replaceText;
-    } else {
-      let last = terms.pop();
-
-      newQuery = query.slice(0, lastTermIndex); // get text preceding last term
-
-      newQuery =
-        last.indexOf(':') > -1
-          ? // tag key present: replace everything after colon with replaceText
-            newQuery.replace(/\:"[^"]*"?$|\:\S*$/, ':' + replaceText)
-          : // no tag key present: replace last token with replaceText
-            newQuery.replace(/\S+$/, replaceText);
-
-      newQuery = newQuery.concat(query.slice(lastTermIndex));
-    }
-
-    this.setState(
-      {
-        query: newQuery,
-      },
-      () => {
-        // setting a new input value will lose focus; restore it
-        let node = ReactDOM.findDOMNode(this.refs.searchInput);
-        node.focus();
-
-        // then update the autocomplete box with new contextTypes
-        this.updateAutoCompleteItems();
-      }
-    );
-  },
-
-  onMemberListStoreChange(members) {
-    this.setState(
-      {
-        members,
-      },
-      this.updateAutoCompleteItems
-    );
-  },
+  };
 
   render() {
-    let dropdownStyle = {
-      display: this.state.dropdownVisible ? 'block' : 'none',
-    };
-
-    let rootClassNames = ['search'];
-    if (this.props.disabled) rootClassNames.push('disabled');
-
     return (
-      <div className={classNames(rootClassNames)}>
-        <form className="form-horizontal" ref="searchForm" onSubmit={this.onSubmit}>
-          <div>
-            <input
-              type="text"
-              className="search-input form-control"
-              placeholder={this.props.placeholder}
-              name="query"
-              ref="searchInput"
-              autoComplete="off"
-              value={this.state.query}
-              onFocus={this.onQueryFocus}
-              onBlur={this.onQueryBlur}
-              onKeyUp={this.onKeyUp}
-              onKeyDown={this.onKeyDown}
-              onChange={this.onQueryChange}
-              onClick={this.onInputClick}
-              disabled={this.props.disabled}
-            />
-            <span className="icon-search" />
-            {this.state.query !== '' && (
-              <div>
-                <a className="search-clear-form" onClick={this.clearSearch}>
-                  <span className="icon-circle-cross" />
-                </a>
-              </div>
-            )}
-          </div>
-
-          {(this.state.loading || this.state.searchItems.length > 0) && (
-            <div style={dropdownStyle}>
-              <SearchDropdown
-                style={dropdownStyle}
-                items={this.state.searchItems}
-                onClick={this.onAutoComplete}
-                loading={this.state.loading}
-                searchSubstring={this.state.searchTerm}
-              />
-            </div>
-          )}
-        </form>
-      </div>
+      <SmartSearchBar
+        {...this.props}
+        onGetTagValues={this.getTagValues}
+        supportedTags={TagStore.getAllTags()}
+        defaultSearchItems={SEARCH_ITEMS}
+      />
     );
-  },
-});
+  }
+}
 
-export default SearchBar;
+export default withApi(SearchBar);
diff --git a/tests/js/spec/components/smartSearchBar.spec.jsx b/tests/js/spec/components/smartSearchBar.spec.jsx
new file mode 100644
index 0000000000..2ac6a5755c
--- /dev/null
+++ b/tests/js/spec/components/smartSearchBar.spec.jsx
@@ -0,0 +1,365 @@
+import React from 'react';
+import {shallow, mount} from 'enzyme';
+
+import {SmartSearchBar, addSpace, removeSpace} from 'app/components/smartSearchBar';
+import TagStore from 'app/stores/tagStore';
+
+describe('addSpace()', function() {
+  it('should add a space when there is no trailing space', function() {
+    expect(addSpace('one')).toEqual('one ');
+  });
+
+  it('should not add another space when there is already one', function() {
+    expect(addSpace('one ')).toEqual('one ');
+  });
+
+  it('should leave the empty string alone', function() {
+    expect(addSpace('')).toEqual('');
+  });
+});
+
+describe('removeSpace()', function() {
+  it('should remove a trailing space', function() {
+    expect(removeSpace('one ')).toEqual('one');
+  });
+
+  it('should not remove the last character if it is not a space', function() {
+    expect(removeSpace('one')).toEqual('one');
+  });
+
+  it('should leave the empty string alone', function() {
+    expect(removeSpace('')).toEqual('');
+  });
+});
+
+describe('SmartSearchBar', function() {
+  let sandbox;
+  let options;
+  let environmentTagValuesMock;
+  let supportedTags;
+  let tagValuesMock = jest.fn(() => Promise.resolve([]));
+
+  beforeEach(function() {
+    TagStore.reset();
+    TagStore.onLoadTagsSuccess(TestStubs.Tags());
+    tagValuesMock.mockClear();
+    supportedTags = {};
+
+    sandbox = sinon.sandbox.create();
+
+    options = {
+      context: {organization: {id: '123'}},
+    };
+
+    environmentTagValuesMock = MockApiClient.addMockResponse({
+      url: '/projects/123/456/tags/environment/values/',
+      body: [],
+    });
+  });
+
+  afterEach(function() {
+    MockApiClient.clearMockResponses();
+    sandbox.restore();
+  });
+
+  describe('componentWillReceiveProps()', function() {
+    it('should add a space when setting state.query', function() {
+      let searchBar = shallow(
+        <SmartSearchBar supportedTags={supportedTags} query="one" />,
+        options
+      );
+
+      expect(searchBar.state().query).toEqual('one ');
+    });
+
+    it('should update state.query if props.query is updated from outside', function() {
+      let searchBar = shallow(
+        <SmartSearchBar supportedTags={supportedTags} query="one" />,
+        options
+      );
+
+      searchBar.setProps({query: 'two'});
+
+      expect(searchBar.state().query).toEqual('two ');
+    });
+
+    it('should not reset user input if a noop props change happens', function() {
+      let searchBar = shallow(
+        <SmartSearchBar supportedTags={supportedTags} query="one" />,
+        options
+      );
+      searchBar.setState({query: 'two'});
+
+      searchBar.setProps({query: 'one'});
+
+      expect(searchBar.state().query).toEqual('two');
+    });
+
+    it('should reset user input if a meaningful props change happens', function() {
+      let searchBar = shallow(
+        <SmartSearchBar supportedTags={supportedTags} query="one" />,
+        options
+      );
+      searchBar.setState({query: 'two'});
+
+      searchBar.setProps({query: 'three'});
+
+      expect(searchBar.state().query).toEqual('three ');
+    });
+  });
+
+  describe('getQueryTerms()', function() {
+    it('should extract query terms from a query string', function() {
+      let query = 'tagname: ';
+      expect(SmartSearchBar.getQueryTerms(query, query.length)).toEqual(['tagname:']);
+
+      query = 'tagname:derp browser:';
+      expect(SmartSearchBar.getQueryTerms(query, query.length)).toEqual([
+        'tagname:derp',
+        'browser:',
+      ]);
+
+      query = '   browser:"Chrome 33.0"    ';
+      expect(SmartSearchBar.getQueryTerms(query, query.length)).toEqual([
+        'browser:"Chrome 33.0"',
+      ]);
+    });
+  });
+
+  describe('getLastTermIndex()', function() {
+    it('should provide the index of the last query term, given cursor index', function() {
+      let query = 'tagname:';
+      expect(SmartSearchBar.getLastTermIndex(query, 0)).toEqual(8);
+
+      query = 'tagname:foo'; // 'f' (index 9)
+      expect(SmartSearchBar.getLastTermIndex(query, 9)).toEqual(11);
+
+      query = 'tagname:foo anothertag:bar'; // 'f' (index 9)
+      expect(SmartSearchBar.getLastTermIndex(query, 9)).toEqual(11);
+    });
+  });
+
+  describe('clearSearch()', function() {
+    it('clears the query', function() {
+      let props = {
+        orgId: '123',
+        projectId: '456',
+        query: 'is:unresolved ruby',
+        defaultQuery: 'is:unresolved',
+        supportedTags,
+      };
+      let searchBar = shallow(<SmartSearchBar {...props} />, options).instance();
+
+      searchBar.clearSearch();
+
+      expect(searchBar.state.query).toEqual('');
+    });
+
+    it('calls onSearch()', async function() {
+      let props = {
+        orgId: '123',
+        projectId: '456',
+        query: 'is:unresolved ruby',
+        defaultQuery: 'is:unresolved',
+        supportedTags,
+        onSearch: sandbox.spy(),
+      };
+      let searchBar = shallow(<SmartSearchBar {...props} />, options).instance();
+
+      await searchBar.clearSearch();
+      expect(props.onSearch.calledWith('')).toBe(true);
+    });
+  });
+
+  describe('onQueryFocus()', function() {
+    it('displays the drop down', function() {
+      let searchBar = shallow(
+        <SmartSearchBar
+          orgId="123"
+          projectId="456"
+          supportedTags={supportedTags}
+          onGetTagValues={tagValuesMock}
+        />,
+        options
+      ).instance();
+      expect(searchBar.state.dropdownVisible).toBe(false);
+
+      searchBar.onQueryFocus();
+
+      expect(searchBar.state.dropdownVisible).toBe(true);
+    });
+  });
+
+  describe('onQueryBlur()', function() {
+    it('hides the drop down', function() {
+      let searchBar = shallow(
+        <SmartSearchBar orgId="123" projectId="456" supportedTags={supportedTags} />,
+        options
+      ).instance();
+      searchBar.state.dropdownVisible = true;
+
+      let clock = sandbox.useFakeTimers();
+      searchBar.onQueryBlur();
+      clock.tick(201); // doesn't close until 200ms
+
+      expect(searchBar.state.dropdownVisible).toBe(false);
+    });
+  });
+
+  describe('onKeyUp()', function() {
+    describe('escape', function() {
+      it('blurs the input', function() {
+        let wrapper = shallow(
+          <SmartSearchBar orgId="123" projectId="456" supportedTags={supportedTags} />,
+          options
+        );
+        wrapper.setState({dropdownVisible: true});
+
+        let instance = wrapper.instance();
+        sandbox.stub(instance, 'blur');
+
+        wrapper.find('input').simulate('keyup', {key: 'Escape', keyCode: '27'});
+
+        expect(instance.blur.calledOnce).toBeTruthy();
+      });
+    });
+  });
+
+  describe('render()', function() {
+    it('invokes onSearch() when submitting the form', function() {
+      let stubbedOnSearch = sandbox.spy();
+      let wrapper = mount(
+        <SmartSearchBar
+          onSearch={stubbedOnSearch}
+          orgId="123"
+          projectId="456"
+          query="is:unresolved"
+          supportedTags={supportedTags}
+        />,
+        options
+      );
+
+      wrapper.find('form').simulate('submit', {
+        preventDefault() {},
+      });
+
+      expect(stubbedOnSearch.calledWith('is:unresolved')).toBe(true);
+    });
+
+    it('invokes onSearch() when search is cleared', function(done) {
+      let props = {
+        orgId: '123',
+        projectId: '456',
+        query: 'is:unresolved',
+        supportedTags,
+        onSearch: sandbox.spy(),
+      };
+      let wrapper = mount(<SmartSearchBar {...props} />, options);
+
+      wrapper.find('.search-clear-form').simulate('click');
+
+      setTimeout(function() {
+        expect(props.onSearch.calledWith('')).toBe(true);
+        done();
+      });
+    });
+  });
+
+  it('handles an empty query', function() {
+    let props = {
+      orgId: '123',
+      projectId: '456',
+      query: '',
+      defaultQuery: 'is:unresolved',
+      supportedTags,
+    };
+    let wrapper = mount(<SmartSearchBar {...props} />, options);
+    expect(wrapper.state('query')).toEqual('');
+  });
+
+  describe('updateAutoCompleteItems()', function() {
+    let clock;
+
+    beforeEach(function() {
+      clock = sandbox.useFakeTimers();
+    });
+    afterEach(function() {
+      clock.restore();
+    });
+    it('sets state when empty', function() {
+      let props = {
+        orgId: '123',
+        projectId: '456',
+        query: '',
+        supportedTags,
+      };
+      let searchBar = mount(<SmartSearchBar {...props} />, options).instance();
+      searchBar.updateAutoCompleteItems();
+      expect(searchBar.state.searchTerm).toEqual('');
+      expect(searchBar.state.searchItems).toEqual(searchBar.props.defaultSearchItems);
+      expect(searchBar.state.activeSearchItem).toEqual(0);
+    });
+
+    it('sets state when incomplete tag', function() {
+      let props = {
+        orgId: '123',
+        projectId: '456',
+        query: 'fu',
+        supportedTags,
+      };
+      let searchBar = mount(<SmartSearchBar {...props} />, options).instance();
+      searchBar.updateAutoCompleteItems();
+      expect(searchBar.state.searchTerm).toEqual('fu');
+      expect(searchBar.state.searchItems).toEqual([]);
+      expect(searchBar.state.activeSearchItem).toEqual(0);
+    });
+
+    it('sets state when incomplete tag as second input', function() {
+      let props = {
+        orgId: '123',
+        projectId: '456',
+        query: 'is:unresolved fu',
+        supportedTags,
+      };
+      let searchBar = mount(<SmartSearchBar {...props} />, options).instance();
+      searchBar.getCursorPosition = jest.fn();
+      searchBar.getCursorPosition.mockReturnValue(15); // end of line
+      searchBar.updateAutoCompleteItems();
+      expect(searchBar.state.searchTerm).toEqual('fu');
+      expect(searchBar.state.searchItems).toHaveLength(0);
+      expect(searchBar.state.activeSearchItem).toEqual(0);
+    });
+
+    it('does not request values when tag is environments', function() {
+      let props = {
+        orgId: '123',
+        projectId: '456',
+        query: 'environment:production',
+        excludeEnvironment: true,
+        supportedTags,
+      };
+      let searchBar = mount(<SmartSearchBar {...props} />, options).instance();
+      searchBar.updateAutoCompleteItems();
+      clock.tick(301);
+      expect(environmentTagValuesMock).not.toHaveBeenCalled();
+    });
+
+    it('does not request values when tag is `timesSeen`', function() {
+      // This should never get called
+      let mock = MockApiClient.addMockResponse({
+        url: '/projects/123/456/tags/timesSeen/values/',
+        body: [],
+      });
+      let props = {
+        orgId: '123',
+        projectId: '456',
+        query: 'timesSeen:',
+        supportedTags,
+      };
+      let searchBar = mount(<SmartSearchBar {...props} />, options).instance();
+      searchBar.updateAutoCompleteItems();
+      clock.tick(301);
+      expect(mock).not.toHaveBeenCalled();
+    });
+  });
+});
diff --git a/tests/js/spec/views/stream/searchBar.spec.jsx b/tests/js/spec/views/stream/searchBar.spec.jsx
index 5ab05b140c..ce7385e26c 100644
--- a/tests/js/spec/views/stream/searchBar.spec.jsx
+++ b/tests/js/spec/views/stream/searchBar.spec.jsx
@@ -1,46 +1,20 @@
 import React from 'react';
-import {shallow, mount} from 'enzyme';
+import {mount} from 'enzyme';
 
-import SearchBar, {addSpace, removeSpace} from 'app/views/stream/searchBar';
+import SearchBar from 'app/views/stream/searchBar';
 import TagStore from 'app/stores/tagStore';
 
-describe('addSpace()', function() {
-  it('should add a space when there is no trailing space', function() {
-    expect(addSpace('one')).toEqual('one ');
-  });
-
-  it('should not add another space when there is already one', function() {
-    expect(addSpace('one ')).toEqual('one ');
-  });
-
-  it('should leave the empty string alone', function() {
-    expect(addSpace('')).toEqual('');
-  });
-});
-
-describe('removeSpace()', function() {
-  it('should remove a trailing space', function() {
-    expect(removeSpace('one ')).toEqual('one');
-  });
-
-  it('should not remove the last character if it is not a space', function() {
-    expect(removeSpace('one')).toEqual('one');
-  });
-
-  it('should leave the empty string alone', function() {
-    expect(removeSpace('')).toEqual('');
-  });
-});
-
 describe('SearchBar', function() {
   let sandbox;
   let options;
   let urlTagValuesMock;
-  let environmentTagValuesMock;
+  let supportedTags;
+  const clickInput = searchBar => searchBar.find('input[name="query"]').simulate('click');
 
   beforeEach(function() {
     TagStore.reset();
     TagStore.onLoadTagsSuccess(TestStubs.Tags());
+    supportedTags = TagStore.getAllTags();
 
     sandbox = sinon.sandbox.create();
 
@@ -52,10 +26,6 @@ describe('SearchBar', function() {
       url: '/projects/123/456/tags/url/values/',
       body: [],
     });
-    environmentTagValuesMock = MockApiClient.addMockResponse({
-      url: '/projects/123/456/tags/environment/values/',
-      body: [],
-    });
   });
 
   afterEach(function() {
@@ -63,200 +33,6 @@ describe('SearchBar', function() {
     sandbox.restore();
   });
 
-  describe('componentWillReceiveProps()', function() {
-    it('should add a space when setting state.query', function() {
-      let searchBar = shallow(<SearchBar query="one" />, options);
-
-      expect(searchBar.state().query).toEqual('one ');
-    });
-
-    it('should update state.query if props.query is updated from outside', function() {
-      let searchBar = shallow(<SearchBar query="one" />, options);
-
-      searchBar.setProps({query: 'two'});
-
-      expect(searchBar.state().query).toEqual('two ');
-    });
-
-    it('should not reset user input if a noop props change happens', function() {
-      let searchBar = shallow(<SearchBar query="one" />, options);
-      searchBar.setState({query: 'two'});
-
-      searchBar.setProps({query: 'one'});
-
-      expect(searchBar.state().query).toEqual('two');
-    });
-
-    it('should reset user input if a meaningful props change happens', function() {
-      let searchBar = shallow(<SearchBar query="one" />, options);
-      searchBar.setState({query: 'two'});
-
-      searchBar.setProps({query: 'three'});
-
-      expect(searchBar.state().query).toEqual('three ');
-    });
-  });
-
-  describe('getQueryTerms()', function() {
-    it('should extract query terms from a query string', function() {
-      let query = 'tagname: ';
-      expect(SearchBar.getQueryTerms(query, query.length)).toEqual(['tagname:']);
-
-      query = 'tagname:derp browser:';
-      expect(SearchBar.getQueryTerms(query, query.length)).toEqual([
-        'tagname:derp',
-        'browser:',
-      ]);
-
-      query = '   browser:"Chrome 33.0"    ';
-      expect(SearchBar.getQueryTerms(query, query.length)).toEqual([
-        'browser:"Chrome 33.0"',
-      ]);
-    });
-  });
-
-  describe('getLastTermIndex()', function() {
-    it('should provide the index of the last query term, given cursor index', function() {
-      let query = 'tagname:';
-      expect(SearchBar.getLastTermIndex(query, 0)).toEqual(8);
-
-      query = 'tagname:foo'; // 'f' (index 9)
-      expect(SearchBar.getLastTermIndex(query, 9)).toEqual(11);
-
-      query = 'tagname:foo anothertag:bar'; // 'f' (index 9)
-      expect(SearchBar.getLastTermIndex(query, 9)).toEqual(11);
-    });
-  });
-
-  describe('clearSearch()', function() {
-    it('clears the query', function() {
-      let props = {
-        orgId: '123',
-        projectId: '456',
-        query: 'is:unresolved ruby',
-        defaultQuery: 'is:unresolved',
-      };
-      let searchBar = shallow(<SearchBar {...props} />, options).instance();
-
-      searchBar.clearSearch();
-
-      expect(searchBar.state.query).toEqual('');
-    });
-
-    it('calls onSearch()', function(done) {
-      let props = {
-        orgId: '123',
-        projectId: '456',
-        query: 'is:unresolved ruby',
-        defaultQuery: 'is:unresolved',
-        onSearch: sandbox.spy(),
-      };
-      let searchBar = shallow(<SearchBar {...props} />, options).instance();
-
-      searchBar.clearSearch();
-
-      setTimeout(() => {
-        expect(props.onSearch.calledWith('')).toBe(true);
-        done();
-      });
-    });
-  });
-
-  describe('onQueryFocus()', function() {
-    it('displays the drop down', function() {
-      let searchBar = shallow(
-        <SearchBar orgId="123" projectId="456" />,
-        options
-      ).instance();
-      expect(searchBar.state.dropdownVisible).toBe(false);
-
-      searchBar.onQueryFocus();
-
-      expect(searchBar.state.dropdownVisible).toBe(true);
-    });
-  });
-
-  describe('onQueryBlur()', function() {
-    it('hides the drop down', function() {
-      let searchBar = shallow(
-        <SearchBar orgId="123" projectId="456" />,
-        options
-      ).instance();
-      searchBar.state.dropdownVisible = true;
-
-      let clock = sandbox.useFakeTimers();
-      searchBar.onQueryBlur();
-      clock.tick(201); // doesn't close until 200ms
-
-      expect(searchBar.state.dropdownVisible).toBe(false);
-    });
-  });
-
-  describe('onKeyUp()', function() {
-    describe('escape', function() {
-      it('blurs the input', function() {
-        let wrapper = shallow(<SearchBar orgId="123" projectId="456" />, options);
-        wrapper.setState({dropdownVisible: true});
-
-        let instance = wrapper.instance();
-        sandbox.stub(instance, 'blur');
-
-        wrapper.find('input').simulate('keyup', {key: 'Escape', keyCode: '27'});
-
-        expect(instance.blur.calledOnce).toBeTruthy();
-      });
-    });
-  });
-
-  describe('render()', function() {
-    it('invokes onSearch() when submitting the form', function() {
-      let stubbedOnSearch = sandbox.spy();
-      let wrapper = mount(
-        <SearchBar
-          onSearch={stubbedOnSearch}
-          orgId="123"
-          projectId="456"
-          query="is:unresolved"
-        />,
-        options
-      );
-
-      wrapper.find('form').simulate('submit', {
-        preventDefault() {},
-      });
-
-      expect(stubbedOnSearch.calledWith('is:unresolved')).toBe(true);
-    });
-
-    it('invokes onSearch() when search is cleared', function(done) {
-      let props = {
-        orgId: '123',
-        projectId: '456',
-        query: 'is:unresolved',
-        onSearch: sandbox.spy(),
-      };
-      let wrapper = mount(<SearchBar {...props} />, options);
-
-      wrapper.find('.search-clear-form').simulate('click');
-
-      setTimeout(function() {
-        expect(props.onSearch.calledWith('')).toBe(true);
-        done();
-      });
-    });
-  });
-
-  it('handles an empty query', function() {
-    let props = {
-      orgId: '123',
-      projectId: '456',
-      query: '',
-      defaultQuery: 'is:unresolved',
-    };
-    let wrapper = mount(<SearchBar {...props} />, options);
-    expect(wrapper.state('query')).toEqual('');
-  });
-
   describe('updateAutoCompleteItems()', function() {
     let clock;
 
@@ -266,59 +42,23 @@ describe('SearchBar', function() {
     afterEach(function() {
       clock.restore();
     });
-    it('sets state when empty', function() {
-      let props = {
-        orgId: '123',
-        projectId: '456',
-        query: '',
-      };
-      let searchBar = mount(<SearchBar {...props} />, options).instance();
-      searchBar.updateAutoCompleteItems();
-      expect(searchBar.state.searchTerm).toEqual('');
-      expect(searchBar.state.searchItems).toEqual(searchBar.props.defaultSearchItems);
-      expect(searchBar.state.activeSearchItem).toEqual(0);
-    });
-
-    it('sets state when incomplete tag', function() {
-      let props = {
-        orgId: '123',
-        projectId: '456',
-        query: 'fu',
-      };
-      let searchBar = mount(<SearchBar {...props} />, options).instance();
-      searchBar.updateAutoCompleteItems();
-      expect(searchBar.state.searchTerm).toEqual('fu');
-      expect(searchBar.state.searchItems).toEqual([]);
-      expect(searchBar.state.activeSearchItem).toEqual(0);
-    });
 
     it('sets state with complete tag', function() {
       let props = {
         orgId: '123',
         projectId: '456',
         query: 'url:"fu"',
+        supportedTags,
       };
-      let searchBar = mount(<SearchBar {...props} />, options).instance();
-      searchBar.updateAutoCompleteItems();
+      let searchBar = mount(<SearchBar {...props} />, options);
+      clickInput(searchBar);
       clock.tick(301);
-      expect(searchBar.state.searchTerm).toEqual('"fu"');
-      expect(searchBar.state.searchItems).toEqual([]);
-      expect(searchBar.state.activeSearchItem).toEqual(0);
-    });
-
-    it('sets state when incomplete tag as second input', function() {
-      let props = {
-        orgId: '123',
-        projectId: '456',
-        query: 'is:unresolved fu',
-      };
-      let searchBar = mount(<SearchBar {...props} />, options).instance();
-      searchBar.getCursorPosition = jest.fn();
-      searchBar.getCursorPosition.mockReturnValue(15); // end of line
-      searchBar.updateAutoCompleteItems();
-      expect(searchBar.state.searchTerm).toEqual('fu');
-      expect(searchBar.state.searchItems).toHaveLength(0);
-      expect(searchBar.state.activeSearchItem).toEqual(0);
+      expect(searchBar.find('SearchDropdown').prop('searchSubstring')).toEqual('"fu"');
+      expect(searchBar.find('SearchDropdown').prop('items')).toEqual([]);
+      expect(urlTagValuesMock).toHaveBeenCalledWith(
+        '/projects/123/456/tags/url/values/',
+        expect.objectContaining({data: {query: 'fu'}})
+      );
     });
 
     it('sets state when value has colon', function() {
@@ -326,28 +66,22 @@ describe('SearchBar', function() {
         orgId: '123',
         projectId: '456',
         query: 'url:"http://example.com"',
+        supportedTags,
       };
 
-      let searchBar = mount(<SearchBar {...props} />, options).instance();
-      searchBar.updateAutoCompleteItems();
-      expect(searchBar.state.searchTerm).toEqual('"http://example.com"');
-      expect(searchBar.state.searchItems).toEqual([]);
-      expect(searchBar.state.activeSearchItem).toEqual(0);
+      let searchBar = mount(<SearchBar {...props} />, options);
+      clickInput(searchBar);
+      expect(searchBar.state.searchTerm).toEqual();
+      expect(searchBar.find('SearchDropdown').prop('searchSubstring')).toEqual(
+        '"http://example.com"'
+      );
+      expect(searchBar.find('SearchDropdown').prop('items')).toEqual([]);
       clock.tick(301);
-      expect(urlTagValuesMock).toHaveBeenCalled();
-    });
 
-    it('does not request values when tag is environments', function() {
-      let props = {
-        orgId: '123',
-        projectId: '456',
-        query: 'environment:production',
-        excludeEnvironment: true,
-      };
-      let searchBar = mount(<SearchBar {...props} />, options).instance();
-      searchBar.updateAutoCompleteItems();
-      clock.tick(301);
-      expect(environmentTagValuesMock).not.toHaveBeenCalled();
+      expect(urlTagValuesMock).toHaveBeenCalledWith(
+        '/projects/123/456/tags/url/values/',
+        expect.objectContaining({data: {query: 'http://example.com'}})
+      );
     });
 
     it('does not request values when tag is `timesSeen`', function() {
@@ -360,9 +94,10 @@ describe('SearchBar', function() {
         orgId: '123',
         projectId: '456',
         query: 'timesSeen:',
+        supportedTags,
       };
-      let searchBar = mount(<SearchBar {...props} />, options).instance();
-      searchBar.updateAutoCompleteItems();
+      let searchBar = mount(<SearchBar {...props} />, options);
+      clickInput(searchBar);
       clock.tick(301);
       expect(mock).not.toHaveBeenCalled();
     });

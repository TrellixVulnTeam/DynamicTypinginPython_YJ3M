commit cc3a93b7675bca623475f2bb0ba8b56b6e4f6228
Author: Evan Purkhiser <evanpurkhiser@gmail.com>
Date:   Thu May 21 14:49:58 2020 -0700

    feat(alerts): Add new metricField (#18927)

diff --git a/src/sentry/static/sentry/app/utils/discover/eventView.tsx b/src/sentry/static/sentry/app/utils/discover/eventView.tsx
index 517742b093..a999184ad1 100644
--- a/src/sentry/static/sentry/app/utils/discover/eventView.tsx
+++ b/src/sentry/static/sentry/app/utils/discover/eventView.tsx
@@ -23,6 +23,7 @@ import {
   ColumnType,
   isAggregateField,
   getAggregateAlias,
+  generateFieldAsString,
 } from './fields';
 import {getSortField} from './fieldRenderers';
 import {CHART_AXIS_OPTIONS, DisplayModes, DISPLAY_MODE_OPTIONS} from './types';
@@ -84,16 +85,6 @@ export function isFieldSortable(field: Field, tableMeta?: MetaType): boolean {
   return !!getSortKeyFromField(field, tableMeta);
 }
 
-const generateFieldAsString = (col: Column): string => {
-  if (col.kind === 'field') {
-    return col.field;
-  }
-
-  const aggregation = col.function[0];
-  const parameters = col.function.slice(1).filter(i => i);
-  return `${aggregation}(${parameters.join(',')})`;
-};
-
 const decodeFields = (location: Location): Array<Field> => {
   const {query} = location;
   if (!query || !query.field) {
diff --git a/src/sentry/static/sentry/app/utils/discover/fields.tsx b/src/sentry/static/sentry/app/utils/discover/fields.tsx
index cb07043137..c36e5266a7 100644
--- a/src/sentry/static/sentry/app/utils/discover/fields.tsx
+++ b/src/sentry/static/sentry/app/utils/discover/fields.tsx
@@ -50,7 +50,7 @@ export type QueryFieldValue =
     }
   | {
       kind: 'function';
-      function: [Aggregation, string, AggregationRefinement];
+      function: [AggregationKey, string, AggregationRefinement];
     };
 
 // Column is just an alias of a Query value
@@ -222,20 +222,16 @@ export const AGGREGATIONS = {
   },
 } as const;
 
-assert(
-  AGGREGATIONS as Readonly<
-    {
-      [key in keyof typeof AGGREGATIONS]: {
-        parameters: Readonly<AggregateParameter[]>;
-        // null means to inherit from the column.
-        outputType: null | ColumnType;
-        isSortable: boolean;
-      };
-    }
-  >
-);
+assert(AGGREGATIONS as Readonly<{[key in keyof typeof AGGREGATIONS]: Aggregation}>);
+
+export type AggregationKey = keyof typeof AGGREGATIONS | '';
 
-export type Aggregation = keyof typeof AGGREGATIONS | '';
+export type Aggregation = {
+  parameters: Readonly<AggregateParameter[]>;
+  // null means to inherit from the column.
+  outputType: null | ColumnType;
+  isSortable: boolean;
+};
 
 /**
  * Refer to src/sentry/snuba/events.py, search for Columns
@@ -313,7 +309,7 @@ export const FIELDS = {
 } as const;
 assert(FIELDS as Readonly<{[key in keyof typeof FIELDS]: ColumnType}>);
 
-export type Fields = keyof typeof FIELDS | string | '';
+export type FieldKey = keyof typeof FIELDS | string | '';
 
 // This list should be removed with the tranaction-events feature flag.
 export const TRACING_FIELDS = [
@@ -345,7 +341,7 @@ export function explodeFieldString(field: string): Column {
     return {
       kind: 'function',
       function: [
-        results[1] as Aggregation,
+        results[1] as AggregationKey,
         results[2],
         results[3] as AggregationRefinement,
       ],
@@ -355,6 +351,16 @@ export function explodeFieldString(field: string): Column {
   return {kind: 'field', field};
 }
 
+export function generateFieldAsString(value: QueryFieldValue): string {
+  if (value.kind === 'field') {
+    return value.field;
+  }
+
+  const aggregation = value.function[0];
+  const parameters = value.function.slice(1).filter(i => i);
+  return `${aggregation}(${parameters.join(',')})`;
+}
+
 export function explodeField(field: Field): Column {
   const results = explodeFieldString(field.field);
 
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditCollection.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditCollection.tsx
index 7e30d627a2..abbc64442b 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditCollection.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditCollection.tsx
@@ -13,10 +13,11 @@ import {t} from 'app/locale';
 import {SelectValue, OrganizationSummary} from 'app/types';
 import space from 'app/styles/space';
 import theme from 'app/utils/theme';
-import {Column, AGGREGATIONS, FIELDS, TRACING_FIELDS} from 'app/utils/discover/fields';
+import {Column} from 'app/utils/discover/fields';
 
-import {FieldValue, FieldValueKind} from './types';
+import {FieldValue} from './types';
 import {QueryField} from './queryField';
+import {generateFieldOptions} from '../utils';
 
 type Props = {
   // Input columns
@@ -52,7 +53,7 @@ class ColumnEditCollection extends React.Component<Props, State> {
     draggingTargetIndex: void 0,
     left: void 0,
     top: void 0,
-    fieldOptions: this.generateFieldOptions(),
+    fieldOptions: this.fieldOptions,
   };
 
   componentDidMount() {
@@ -87,71 +88,15 @@ class ColumnEditCollection extends React.Component<Props, State> {
   portal: HTMLElement | null = null;
   dragGhostRef = React.createRef<HTMLDivElement>();
 
-  generateFieldOptions() {
-    const {organization, tagKeys} = this.props;
-
-    let fields = Object.keys(FIELDS);
-    let functions = Object.keys(AGGREGATIONS);
-
-    // Strip tracing features if the org doesn't have access.
-    if (!organization.features.includes('transaction-events')) {
-      fields = fields.filter(item => !TRACING_FIELDS.includes(item));
-      functions = functions.filter(item => !TRACING_FIELDS.includes(item));
-    }
-    const fieldOptions: Record<string, SelectValue<FieldValue>> = {};
-
-    // Index items by prefixed keys as custom tags
-    // can overlap both fields and function names.
-    // Having a mapping makes finding the value objects easier
-    // later as well.
-    functions.forEach(func => {
-      const ellipsis = AGGREGATIONS[func].parameters.length ? '\u2026' : '';
-      fieldOptions[`function:${func}`] = {
-        label: `${func}(${ellipsis})`,
-        value: {
-          kind: FieldValueKind.FUNCTION,
-          meta: {
-            name: func,
-            parameters: AGGREGATIONS[func].parameters,
-          },
-        },
-      };
-    });
-
-    fields.forEach(field => {
-      fieldOptions[`field:${field}`] = {
-        label: field,
-        value: {
-          kind: FieldValueKind.FIELD,
-          meta: {
-            name: field,
-            dataType: FIELDS[field],
-          },
-        },
-      };
+  get fieldOptions() {
+    return generateFieldOptions({
+      organization: this.props.organization,
+      tagKeys: this.props.tagKeys,
     });
-
-    if (tagKeys !== null) {
-      tagKeys.forEach(tag => {
-        const tagValue =
-          FIELDS.hasOwnProperty(tag) || AGGREGATIONS.hasOwnProperty(tag)
-            ? `tags[${tag}]`
-            : tag;
-        fieldOptions[`tag:${tag}`] = {
-          label: tag,
-          value: {
-            kind: FieldValueKind.TAG,
-            meta: {name: tagValue, dataType: 'string'},
-          },
-        };
-      });
-    }
-
-    return fieldOptions;
   }
 
   syncFields() {
-    this.setState({fieldOptions: this.generateFieldOptions()});
+    this.setState({fieldOptions: this.fieldOptions});
   }
 
   keyForColumn(column: Column, isGhost: boolean): string {
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/queryField.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/queryField.tsx
index 0c030d80f7..d0dd9bf87a 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/queryField.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/queryField.tsx
@@ -40,9 +40,17 @@ type Props = {
   fieldOptions: FieldOptions;
   /**
    * The number of columns to render. Columns that do not have a parameter will
-   * render an empty parameter placeholder.
+   * render an empty parameter placeholder. Leave blank to avoid adding spacers.
    */
-  gridColumns: number;
+  gridColumns?: number;
+  /**
+   * Filter the options in the primary selector. Useful if you only want to
+   * show a subset of selectable items.
+   *
+   * NOTE: This is different from passing an already filtered fieldOptions
+   * list, as tag items in the list may be used as parameters to functions.
+   */
+  filterPrimaryOptions?: (option: SelectValue<FieldValue>) => boolean;
   onChange: (fieldValue: QueryFieldValue) => void;
 };
 
@@ -200,7 +208,7 @@ class QueryField extends React.Component<Props> {
       field &&
       field.kind === FieldValueKind.FUNCTION &&
       field.meta.parameters.length > 0 &&
-      fieldValue.kind === 'function'
+      fieldValue.kind === FieldValueKind.FUNCTION
     ) {
       parameterDescriptions = field.meta.parameters.map(
         (param, index: number): ParameterDescription => {
@@ -253,7 +261,6 @@ class QueryField extends React.Component<Props> {
   }
 
   renderParameterInputs(parameters: ParameterDescription[]): React.ReactNode[] {
-    const {gridColumns} = this.props;
     const inputs = parameters.map((descriptor: ParameterDescription, index: number) => {
       if (descriptor.kind === 'column' && descriptor.options.length > 0) {
         return (
@@ -316,8 +323,9 @@ class QueryField extends React.Component<Props> {
 
     // Add enough disabled inputs to fill the grid up.
     // We always have 1 input.
-    const requiredInputs = gridColumns - inputs.length - 1;
-    if (requiredInputs > 0) {
+    const {gridColumns} = this.props;
+    const requiredInputs = (gridColumns ?? inputs.length + 1) - inputs.length - 1;
+    if (gridColumns !== undefined && requiredInputs > 0) {
       for (let i = 0; i < requiredInputs; i++) {
         inputs.push(<BlankSpace key={i} />);
       }
@@ -327,12 +335,16 @@ class QueryField extends React.Component<Props> {
   }
 
   render() {
-    const {className, takeFocus, gridColumns} = this.props;
+    const {className, takeFocus, filterPrimaryOptions} = this.props;
     const {field, fieldOptions, parameterDescriptions} = this.getFieldData();
 
+    const allFieldOptions = filterPrimaryOptions
+      ? Object.values(fieldOptions).filter(filterPrimaryOptions)
+      : Object.values(fieldOptions);
+
     const selectProps: React.ComponentProps<SelectControl> = {
       name: 'field',
-      options: Object.values(fieldOptions),
+      options: Object.values(allFieldOptions),
       placeholder: t('(Required)'),
       value: field,
       onChange: this.handleFieldChange,
@@ -362,8 +374,10 @@ class QueryField extends React.Component<Props> {
       },
     };
 
+    const parameters = this.renderParameterInputs(parameterDescriptions);
+
     return (
-      <Container className={className} gridColumns={gridColumns}>
+      <Container className={className} gridColumns={parameters.length + 1}>
         <SelectControl
           {...selectProps}
           styles={styles}
@@ -382,7 +396,7 @@ class QueryField extends React.Component<Props> {
             ),
           }}
         />
-        {this.renderParameterInputs(parameterDescriptions)}
+        {parameters}
       </Container>
     );
   }
diff --git a/src/sentry/static/sentry/app/views/eventsV2/utils.tsx b/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
index 7a6891feda..8c76d8f025 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
@@ -4,7 +4,7 @@ import {browserHistory} from 'react-router';
 
 import {tokenizeSearch, stringifyQueryObject} from 'app/utils/tokenizeSearch';
 import {t} from 'app/locale';
-import {Event, Organization, OrganizationSummary} from 'app/types';
+import {Event, Organization, OrganizationSummary, SelectValue} from 'app/types';
 import {getTitle} from 'app/utils/events';
 import {getUtcDateString} from 'app/utils/dates';
 import {URL_PARAM} from 'app/constants/globalSelectionHeader';
@@ -14,14 +14,17 @@ import EventView from 'app/utils/discover/eventView';
 import {
   Field,
   Column,
+  ColumnType,
   AGGREGATIONS,
   FIELDS,
   explodeFieldString,
   getAggregateAlias,
+  TRACING_FIELDS,
+  Aggregation,
 } from 'app/utils/discover/fields';
 
 import {ALL_VIEWS, TRANSACTION_VIEWS} from './data';
-import {TableColumn, TableDataRow} from './table/types';
+import {TableColumn, TableDataRow, FieldValue, FieldValueKind} from './table/types';
 
 export type QueryWithColumnState =
   | Query
@@ -159,7 +162,7 @@ export function downloadAsCsv(tableData, columnOrder, filename) {
 }
 
 // A map between aggregate function names and its un-aggregated form
-const TRANSFORM_AGGREGATES: {[field: string]: string} = {
+const TRANSFORM_AGGREGATES = {
   p99: 'transaction.duration',
   p95: 'transaction.duration',
   p75: 'transaction.duration',
@@ -169,7 +172,7 @@ const TRANSFORM_AGGREGATES: {[field: string]: string} = {
   impact: '',
   user_misery: '',
   error_rate: '',
-};
+} as const;
 
 /**
  * Convert an aggregated query into one that does not have aggregates.
@@ -376,3 +379,75 @@ export function getDiscoverLandingUrl(organization: OrganizationSummary): string
   }
   return `/organizations/${organization.slug}/discover/results/`;
 }
+
+type FieldGeneratorOpts = {
+  organization: OrganizationSummary;
+  tagKeys?: string[] | null;
+  aggregations?: Record<string, Aggregation>;
+  fields?: Record<string, ColumnType>;
+};
+
+export function generateFieldOptions({
+  organization,
+  tagKeys,
+  aggregations = AGGREGATIONS,
+  fields = FIELDS,
+}: FieldGeneratorOpts) {
+  let fieldKeys = Object.keys(fields);
+  let functions = Object.keys(aggregations);
+
+  // Strip tracing features if the org doesn't have access.
+  if (!organization.features.includes('transaction-events')) {
+    fieldKeys = fieldKeys.filter(item => !TRACING_FIELDS.includes(item));
+    functions = functions.filter(item => !TRACING_FIELDS.includes(item));
+  }
+  const fieldOptions: Record<string, SelectValue<FieldValue>> = {};
+
+  // Index items by prefixed keys as custom tags can overlap both fields and
+  // function names. Having a mapping makes finding the value objects easier
+  // later as well.
+  functions.forEach(func => {
+    const ellipsis = aggregations[func].parameters.length ? '\u2026' : '';
+    fieldOptions[`function:${func}`] = {
+      label: `${func}(${ellipsis})`,
+      value: {
+        kind: FieldValueKind.FUNCTION,
+        meta: {
+          name: func,
+          parameters: [...aggregations[func].parameters],
+        },
+      },
+    };
+  });
+
+  fieldKeys.forEach(field => {
+    fieldOptions[`field:${field}`] = {
+      label: field,
+      value: {
+        kind: FieldValueKind.FIELD,
+        meta: {
+          name: field,
+          dataType: fields[field],
+        },
+      },
+    };
+  });
+
+  if (tagKeys !== undefined && tagKeys !== null) {
+    tagKeys.forEach(tag => {
+      const tagValue =
+        fields.hasOwnProperty(tag) || AGGREGATIONS.hasOwnProperty(tag)
+          ? `tags[${tag}]`
+          : tag;
+      fieldOptions[`tag:${tag}`] = {
+        label: tag,
+        value: {
+          kind: FieldValueKind.TAG,
+          meta: {name: tagValue, dataType: 'string'},
+        },
+      };
+    });
+  }
+
+  return fieldOptions;
+}
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/metricField.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/metricField.tsx
new file mode 100644
index 0000000000..1d51ca66ee
--- /dev/null
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/metricField.tsx
@@ -0,0 +1,199 @@
+import React from 'react';
+import styled from '@emotion/styled';
+import {css} from '@emotion/core';
+
+import FormField from 'app/views/settings/components/forms/formField';
+import {t, tct} from 'app/locale';
+import {QueryField} from 'app/views/eventsV2/table/queryField';
+import {generateFieldOptions} from 'app/views/eventsV2/utils';
+import {FieldValueKind} from 'app/views/eventsV2/table/types';
+import {Organization} from 'app/types';
+import space from 'app/styles/space';
+import FormModel from 'app/views/settings/components/forms/model';
+import Button from 'app/components/button';
+import Tooltip from 'app/components/tooltip';
+import {
+  explodeFieldString,
+  generateFieldAsString,
+  AggregationKey,
+  FieldKey,
+  AGGREGATIONS,
+  FIELDS,
+} from 'app/utils/discover/fields';
+
+import {Dataset} from './types';
+
+type Props = Omit<FormField['props'], 'children' | 'help'> & {
+  organization: Organization;
+};
+
+const cannedAggregates = [
+  {
+    match: /^count\(\)/,
+    name: 'Number of errors',
+    validDataset: [Dataset.ERRORS],
+    default: 'count()',
+  },
+  {
+    match: /^count_unique\(user(\.id)?\)/,
+    name: 'Users affected',
+    validDataset: [Dataset.ERRORS],
+    default: 'count_unique(user)',
+  },
+  {
+    match: /^(p[0-9]{2,3}|percentile\(transaction\.duration,[^)]+\))/,
+    name: 'Latency',
+    validDataset: [Dataset.TRANSACTIONS],
+    default: 'percentile(transaction.duration, 0.95)',
+  },
+  {
+    match: /^apdex\([0-9.]+\)/,
+    name: 'Apdex',
+    validDataset: [Dataset.TRANSACTIONS],
+    default: 'apdex(300)',
+  },
+  {
+    match: /^count\(\)/,
+    name: 'Throughput',
+    validDataset: [Dataset.TRANSACTIONS],
+    default: 'count()',
+  },
+  {
+    match: /^error_rate\(\)/,
+    name: 'Error rate',
+    validDataset: [Dataset.TRANSACTIONS],
+    default: 'error_rate()',
+  },
+];
+
+type OptionConfig = {
+  aggregations: AggregationKey[];
+  fields: FieldKey[];
+};
+
+const errorFieldConfig: OptionConfig = {
+  aggregations: ['count', 'count_unique'],
+  fields: ['user'],
+};
+
+const transactionFieldConfig: OptionConfig = {
+  aggregations: [
+    'avg',
+    'percentile',
+    'error_rate',
+    'apdex',
+    'count',
+    'p50',
+    'p75',
+    'p95',
+    'p99',
+    'p100',
+  ],
+  fields: ['transaction.duration'],
+};
+
+const getFieldOptionConfig = (dataset: Dataset) => {
+  const config = dataset === Dataset.ERRORS ? errorFieldConfig : transactionFieldConfig;
+
+  const aggregations = Object.fromEntries(
+    config.aggregations.map(key => [key, AGGREGATIONS[key]])
+  );
+  const fields = Object.fromEntries(config.fields.map(key => [key, FIELDS[key]]));
+
+  return {aggregations, fields};
+};
+
+const help = ({name, model}: {name: string; model: FormModel}) => {
+  const aggregate = model.getValue(name) as string;
+
+  const presets = cannedAggregates
+    .filter(preset => preset.validDataset.includes(model.getValue('dataset') as Dataset))
+    .map(preset => ({...preset, selected: preset.match.test(aggregate)}))
+    .map((preset, i, list) => (
+      <React.Fragment key={preset.name}>
+        <Tooltip title={t('This preset is selected')} disabled={!preset.selected}>
+          <PresetLink
+            onClick={() => model.setValue(name, preset.default)}
+            isSelected={preset.selected}
+          >
+            {preset.name}
+          </PresetLink>
+        </Tooltip>
+        {i + 1 < list.length && ', '}
+      </React.Fragment>
+    ));
+
+  return tct(
+    'Choose an aggregate function. Not sure what to select, try a preset: [presets]',
+    {presets}
+  );
+};
+
+const MetricField = ({organization, ...props}: Props) => (
+  <FormField help={help} {...props}>
+    {({onChange, value, model}) => {
+      const dataset = model.getValue('dataset');
+
+      const fieldOptionsConfig = getFieldOptionConfig(dataset);
+      const fieldOptions = generateFieldOptions({organization, ...fieldOptionsConfig});
+      const fieldValue = explodeFieldString(value ?? '');
+
+      const fieldKey =
+        fieldValue?.kind === FieldValueKind.FUNCTION
+          ? `function:${fieldValue.function[0]}`
+          : '';
+
+      const selectedField = fieldOptions[fieldKey]?.value;
+      const numParameters =
+        selectedField &&
+        selectedField.kind === FieldValueKind.FUNCTION &&
+        selectedField.meta.parameters.length;
+
+      return (
+        <React.Fragment>
+          <AggregateHeader>
+            <div>{t('Function')}</div>
+            {numParameters > 0 && <div>{t('Parameter')}</div>}
+          </AggregateHeader>
+          <QueryField
+            filterPrimaryOptions={option => option.value.kind === FieldValueKind.FUNCTION}
+            fieldOptions={fieldOptions}
+            fieldValue={fieldValue}
+            onChange={v => onChange(generateFieldAsString(v), {})}
+          />
+        </React.Fragment>
+      );
+    }}
+  </FormField>
+);
+
+const AggregateHeader = styled('div')`
+  display: grid;
+  grid-auto-flow: column;
+  grid-auto-columns: 1fr;
+  grid-gap: ${space(1)};
+  text-transform: uppercase;
+  font-size: ${p => p.theme.fontSizeSmall};
+  color: ${p => p.theme.gray2};
+  font-weight: bold;
+  margin-bottom: ${space(1)};
+`;
+
+const PresetLink = styled(Button)<{isSelected: boolean}>`
+  ${p =>
+    p.isSelected &&
+    css`
+      color: ${p.theme.gray4};
+      &:hover,
+      &:focus {
+        color: ${p.theme.gray5};
+      }
+    `}
+`;
+
+PresetLink.defaultProps = {
+  priority: 'link',
+  borderless: true,
+};
+
+export default MetricField;
diff --git a/src/sentry/static/sentry/app/views/settings/incidentRules/types.tsx b/src/sentry/static/sentry/app/views/settings/incidentRules/types.tsx
index 6d8af7ec45..896b694f44 100644
--- a/src/sentry/static/sentry/app/views/settings/incidentRules/types.tsx
+++ b/src/sentry/static/sentry/app/views/settings/incidentRules/types.tsx
@@ -13,6 +13,11 @@ export enum AlertRuleAggregations {
   UNIQUE_USERS,
 }
 
+export enum Dataset {
+  ERRORS,
+  TRANSACTIONS,
+}
+
 export type UnsavedTrigger = {
   // UnsavedTrigger can be apart of an Unsaved Alert Rule that does not have an
   // id yet
diff --git a/tests/js/spec/views/settings/incidentRules/metricField.spec.jsx b/tests/js/spec/views/settings/incidentRules/metricField.spec.jsx
new file mode 100644
index 0000000000..a4955bb61c
--- /dev/null
+++ b/tests/js/spec/views/settings/incidentRules/metricField.spec.jsx
@@ -0,0 +1,99 @@
+import React from 'react';
+
+import {openMenu, selectByLabel} from 'sentry-test/select-new';
+import {mountWithTheme} from 'sentry-test/enzyme';
+import {initializeOrg} from 'sentry-test/initializeOrg';
+
+import Form from 'app/views/settings/components/forms/form';
+import MetricField from 'app/views/settings/incidentRules/metricField';
+import {Dataset} from 'app/views/settings/incidentRules/types';
+
+describe('MetricField', function() {
+  const {organization} = initializeOrg({
+    organization: {features: ['transaction-events']},
+  });
+
+  it('renders', function() {
+    mountWithTheme(
+      <Form initialData={{dataset: Dataset.ERRORS}}>
+        <MetricField name="metric" organization={organization} />
+      </Form>
+    );
+  });
+
+  it('has a select subset of error fields', function() {
+    const wrapper = mountWithTheme(
+      <Form initialData={{dataset: Dataset.ERRORS}}>
+        <MetricField name="metric" organization={organization} />
+      </Form>
+    );
+    openMenu(wrapper, {selector: 'QueryField'});
+
+    // two error aggregation configs
+    expect(wrapper.find('Option Option')).toHaveLength(2);
+
+    // Select count_unique and verify the tags
+    selectByLabel(wrapper, 'count_unique(…)', {selector: 'QueryField'});
+    openMenu(wrapper, {selector: 'QueryField', at: 1});
+
+    expect(
+      wrapper
+        .find('SelectControl')
+        .at(1)
+        .find('Option')
+    ).toHaveLength(1);
+  });
+
+  it('has a select subset of transaction fields', function() {
+    const wrapper = mountWithTheme(
+      <Form initialData={{dataset: Dataset.TRANSACTIONS}}>
+        <MetricField name="metric" organization={organization} />
+      </Form>
+    );
+    openMenu(wrapper, {selector: 'QueryField'});
+
+    // 10 error aggregate configs
+    expect(wrapper.find('Option Option')).toHaveLength(10);
+
+    selectByLabel(wrapper, 'avg(…)', {selector: 'QueryField'});
+    openMenu(wrapper, {selector: 'QueryField', at: 1});
+
+    expect(
+      wrapper
+        .find('SelectControl')
+        .at(1)
+        .find('Option')
+    ).toHaveLength(1);
+  });
+
+  it('maps field value to selected presets', function() {
+    const wrapper = mountWithTheme(
+      <Form initialData={{dataset: Dataset.TRANSACTIONS}}>
+        <MetricField name="metric" organization={organization} />
+      </Form>
+    );
+    selectByLabel(wrapper, 'error_rate()', {selector: 'QueryField'});
+
+    expect(wrapper.find('FieldHelp Button[isSelected=true]').text()).toEqual(
+      'Error rate'
+    );
+
+    selectByLabel(wrapper, 'p95()', {selector: 'QueryField'});
+
+    expect(wrapper.find('FieldHelp Button[isSelected=true]').text()).toEqual('Latency');
+  });
+
+  it('changes field values when selecting presets', function() {
+    const wrapper = mountWithTheme(
+      <Form initialData={{dataset: Dataset.TRANSACTIONS}}>
+        <MetricField name="metric" organization={organization} />
+      </Form>
+    );
+
+    wrapper.find('FieldHelp button[aria-label="Error rate"]').simulate('click');
+
+    expect(wrapper.find('QueryField SingleValue SingleValue').text()).toEqual(
+      'error_rate()'
+    );
+  });
+});

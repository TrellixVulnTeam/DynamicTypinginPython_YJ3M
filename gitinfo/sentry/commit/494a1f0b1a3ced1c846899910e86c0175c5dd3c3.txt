commit 494a1f0b1a3ced1c846899910e86c0175c5dd3c3
Author: Jan Michael Auer <account@jauer.org>
Date:   Fri Nov 23 11:32:32 2018 +0100

    feat(native): Handle null values more gracefully in Native plugin (#10736)

diff --git a/src/sentry/lang/native/cfi.py b/src/sentry/lang/native/cfi.py
index bf526fca20..c6a84c7439 100644
--- a/src/sentry/lang/native/cfi.py
+++ b/src/sentry/lang/native/cfi.py
@@ -13,6 +13,7 @@ from sentry.lang.native.utils import parse_addr, rebase_addr
 from sentry.models import Project, ProjectDebugFile
 from sentry.utils.cache import cache
 from sentry.utils.hashlib import hash_values
+from sentry.utils.safe import get_path
 
 
 logger = logging.getLogger(__name__)
@@ -169,8 +170,8 @@ class ThreadProcessingHandle(object):
         self.changed = False
 
     def _get_modules(self):
-        modules = (self.data.get('debug_meta') or {}).get('images') or []
-        return ObjectLookup(modules)
+        modules = get_path(self.data, 'debug_meta', 'images', filter=True)
+        return ObjectLookup(modules or [])
 
     def iter_modules(self):
         """Returns an iterator over all code modules (images) loaded by the
@@ -182,16 +183,15 @@ class ThreadProcessingHandle(object):
         """Returns an iterator over all threads of the process at the time of
         the crash, including the crashing thread. The values are of type
         ``ThreadRef``."""
-        for thread in (self.data.get('threads') or {}).get('values') or []:
+        for thread in get_path(self.data, 'threads', 'values', filter=True, default=()):
             if thread.get('crashed'):
                 # XXX: Assumes that the full list of threads is present in the
                 # original crash report. This is guaranteed by KSCrash and our
                 # minidump utility.
-                exceptions = (self.data.get('exception') or {}).get('values') or []
-                exception = exceptions[0] if exceptions else {}
-                frames = (exception.get('stacktrace') or {}).get('frames')
+                exceptions = get_path(self.data, 'exception', 'values', filter=True)
+                frames = get_path(exceptions, 0, 'stacktrace', 'frames')
             else:
-                frames = (thread.get('stacktrace') or {}).get('frames')
+                frames = get_path(thread, 'stacktrace', 'frames')
 
             tid = thread.get('id')
             if tid and frames:
diff --git a/src/sentry/lang/native/minidump.py b/src/sentry/lang/native/minidump.py
index d36ec4c106..ecfe65a485 100644
--- a/src/sentry/lang/native/minidump.py
+++ b/src/sentry/lang/native/minidump.py
@@ -1,9 +1,10 @@
 from __future__ import absolute_import
 
 from django.core.files.uploadedfile import InMemoryUploadedFile, TemporaryUploadedFile
-
 from symbolic import arch_from_breakpad, ProcessState, id_from_breakpad
 
+from sentry.utils.safe import get_path
+
 # Attachment type used for minidump files
 MINIDUMP_ATTACHMENT_TYPE = 'event.minidump'
 
@@ -15,11 +16,8 @@ MINIDUMP_OS_TYPES = {
 
 
 def is_minidump_event(data):
-    exceptions = (data.get('exception') or {}).get('values') or []
-    if not exceptions:
-        return False
-
-    return (exceptions[0].get('mechanism') or {}).get('type') == 'minidump'
+    exceptions = get_path(data, 'exception', 'values', filter=True)
+    return get_path(exceptions, 0, 'mechanism', 'type') == 'minidump'
 
 
 def process_minidump(minidump, cfi=None):
diff --git a/src/sentry/lang/native/plugin.py b/src/sentry/lang/native/plugin.py
index e61ef8a361..a9140aa89a 100644
--- a/src/sentry/lang/native/plugin.py
+++ b/src/sentry/lang/native/plugin.py
@@ -16,6 +16,7 @@ from sentry.lang.native.utils import get_sdk_from_event, cpu_name_from_data, \
     rebase_addr
 from sentry.lang.native.systemsymbols import lookup_system_symbols
 from sentry.utils import metrics
+from sentry.utils.safe import get_path
 from sentry.stacktraces import StacktraceProcessor
 from sentry.reprocessing import report_processing_issue
 
@@ -30,17 +31,18 @@ class NativeStacktraceProcessor(StacktraceProcessor):
 
     def __init__(self, *args, **kwargs):
         StacktraceProcessor.__init__(self, *args, **kwargs)
-        debug_meta = self.data.get('debug_meta')
+
         self.arch = cpu_name_from_data(self.data)
         self.sym = None
         self.difs_referenced = set()
-        if debug_meta:
+
+        images = get_path(self.data, 'debug_meta', 'images', default=(),
+                          filter=(lambda img: img and img.get('type') in self.supported_images))
+
+        if images:
             self.available = True
-            self.debug_meta = debug_meta
             self.sdk_info = get_sdk_from_event(self.data)
-            self.object_lookup = ObjectLookup(
-                [img for img in self.debug_meta['images'] if img['type'] in self.supported_images]
-            )
+            self.object_lookup = ObjectLookup(images)
         else:
             self.available = False
 
@@ -72,16 +74,12 @@ class NativeStacktraceProcessor(StacktraceProcessor):
             # The signal is useful information for symbolic in some situations
             # to disambiugate the first frame.  If we can get this information
             # from the mechanism we want to pass it onwards.
-            signal = None
-            exc = self.data.get('exception')
-            if exc is not None:
-                mechanism = exc['values'][0].get('mechanism')
-                if mechanism and 'meta' in mechanism and \
-                    'signal' in mechanism['meta'] and \
-                        'number' in mechanism['meta']['signal']:
-                    signal = int(mechanism['meta']['signal']['number'])
-            registers = processable_frame.stacktrace_info.stacktrace.get(
-                'registers')
+            exceptions = get_path(self.data, 'exception', 'values', filter=True)
+            signal = get_path(exceptions, 0, 'mechanism', 'meta', 'signal', 'number')
+            if signal is not None:
+                signal = int(signal)
+
+            registers = processable_frame.stacktrace_info.stacktrace.get('registers')
             if registers:
                 ip_reg_name = arch_get_ip_reg_name(self.arch)
                 if ip_reg_name:
diff --git a/src/sentry/lang/native/utils.py b/src/sentry/lang/native/utils.py
index a0ba30c827..277d6c3a8f 100644
--- a/src/sentry/lang/native/utils.py
+++ b/src/sentry/lang/native/utils.py
@@ -8,6 +8,7 @@ from collections import namedtuple
 from symbolic import parse_addr, arch_from_macho, arch_is_known
 
 from sentry.interfaces.contexts import DeviceContextType
+from sentry.utils.safe import get_path
 
 logger = logging.getLogger(__name__)
 
@@ -25,52 +26,20 @@ def image_name(pkg):
     return pkg.rsplit(split, 1)[-1]
 
 
-def find_all_stacktraces(data):
-    """Given a data dictionary from an event this returns all
-    relevant stacktraces in a list.  If a frame contains a raw_stacktrace
-    property it's preferred over the processed one.
-    """
-    rv = []
-
-    def _probe_for_stacktrace(container):
-        raw = container.get('raw_stacktrace')
-        if raw is not None:
-            rv.append((raw, container))
-        else:
-            processed = container.get('stacktrace')
-            if processed is not None:
-                rv.append((processed, container))
-
-    exc_container = data.get('exception')
-    if exc_container:
-        for exc in exc_container['values']:
-            _probe_for_stacktrace(exc)
-
-    # The legacy stacktrace interface does not support raw stacktraces
-    stacktrace = data.get('stacktrace')
-    if stacktrace:
-        rv.append((stacktrace, None))
-
-    threads = data.get('threads')
-    if threads:
-        for thread in threads['values']:
-            _probe_for_stacktrace(thread)
-
-    return rv
-
-
 def get_sdk_from_event(event):
-    sdk_info = (event.get('debug_meta') or {}).get('sdk_info')
+    sdk_info = get_path(event, 'debug_meta', 'sdk_info')
     if sdk_info:
         return sdk_info
-    os = (event.get('contexts') or {}).get('os')
+
+    os = get_path(event, 'contexts', 'os')
     if os and os.get('type') == 'os':
         return get_sdk_from_os(os)
 
 
 def get_sdk_from_os(data):
-    if 'name' not in data or 'version' not in data:
+    if data.get('name') is None or data.get('version') is None:
         return
+
     try:
         version = six.text_type(data['version']).split('-', 1)[0] + '.0' * 3
         system_version = tuple(int(x) for x in version.split('.')[:3])
@@ -89,15 +58,12 @@ def get_sdk_from_os(data):
 def cpu_name_from_data(data):
     """Returns the CPU name from the given data if it exists."""
     device = DeviceContextType.primary_value_for_data(data)
-    if device:
-        arch = device.get('arch')
-        if isinstance(arch, six.string_types):
-            return arch
+    if device and device.get('arch'):
+        return device['arch']
 
     # TODO: kill this here.  we want to not support that going forward
     unique_cpu_name = None
-    images = (data.get('debug_meta') or {}).get('images') or []
-    for img in images:
+    for img in get_path(data, 'debug_meta', 'images', filter=True, default=()):
         if img.get('arch') and arch_is_known(img['arch']):
             cpu_name = img['arch']
         elif img.get('cpu_type') is not None \
diff --git a/tests/sentry/lang/native/test_minidump.py b/tests/sentry/lang/native/test_minidump.py
index 68947f8b99..f51da3cf03 100644
--- a/tests/sentry/lang/native/test_minidump.py
+++ b/tests/sentry/lang/native/test_minidump.py
@@ -43,12 +43,24 @@ def test_is_minidump():
         }
     })
 
+    assert not is_minidump_event({
+        'exception': {
+            'values': [None]
+        }
+    })
+
     assert not is_minidump_event({
         'exception': {
             'values': []
         }
     })
 
+    assert not is_minidump_event({
+        'exception': {
+            'values': None
+        }
+    })
+
     assert not is_minidump_event({
         'exception': None
     })

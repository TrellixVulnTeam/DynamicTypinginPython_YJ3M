commit d2524313562b5304473b475ed3fa774463b6a0a6
Author: David Cramer <dcramer@gmail.com>
Date:   Tue Apr 29 03:17:14 2014 -0400

    large refactor of option managers and localizing code

diff --git a/CHANGES b/CHANGES
index b18bb845fe..b9161598f0 100644
--- a/CHANGES
+++ b/CHANGES
@@ -9,6 +9,7 @@ Backwards Incompatible Changes
 - The ``is_rate_limited`` plugin hook has been removed in favor of singular quota managers.
 - The trends feature has been removed until it can be reimplemented in a more scalable way.
 - NodeStore.generate_id() now returns a base64-encoded UUID.
+- GroupMeta.objects.get_value no longer errors when a value is missing.
 
 Version 6.4.0
 -------------
diff --git a/src/sentry/db/models/manager.py b/src/sentry/db/models/manager.py
index 011d8b9555..71e24b544b 100644
--- a/src/sentry/db/models/manager.py
+++ b/src/sentry/db/models/manager.py
@@ -101,8 +101,12 @@ class BaseManager(Manager):
         """
         Given the cache is configured, connects the required signals for invalidation.
         """
+        post_save.connect(self.post_save, sender=sender, weak=False)
+        post_delete.connect(self.post_delete, sender=sender, weak=False)
+
         if not self.cache_fields:
             return
+
         post_init.connect(self.__post_init, sender=sender, weak=False)
         post_save.connect(self.__post_save, sender=sender, weak=False)
         post_delete.connect(self.__post_delete, sender=sender, weak=False)
@@ -246,3 +250,13 @@ class BaseManager(Manager):
 
         for node in object_node_list:
             node.bind_data(node_results.get(node.id) or {})
+
+    def post_save(self, instance, **kwargs):
+        """
+        Triggered when a model bound to this manager is saved.
+        """
+
+    def post_delete(self, instance, **kwargs):
+        """
+        Triggered when a model bound to this manager is deleted.
+        """
diff --git a/src/sentry/manager.py b/src/sentry/manager.py
index 5d6c1dc18d..6917c56930 100644
--- a/src/sentry/manager.py
+++ b/src/sentry/manager.py
@@ -15,11 +15,9 @@ import time
 import warnings
 import uuid
 
-from celery.signals import task_postrun
 from django.conf import settings
 from django.contrib.auth.models import UserManager
-from django.core.signals import request_finished
-from django.db import models, transaction, IntegrityError
+from django.db import transaction, IntegrityError
 from django.db.models import Sum
 from django.utils import timezone
 from django.utils.datastructures import SortedDict
@@ -35,7 +33,7 @@ from sentry.processors.base import send_group_processors
 from sentry.signals import regression_signal
 from sentry.tasks.index import index_event
 from sentry.tsdb.base import TSDBModel
-from sentry.utils.cache import cache, memoize
+from sentry.utils.cache import memoize
 from sentry.utils.dates import get_sql_date_trunc, normalize_datetime
 from sentry.utils.db import get_db_engine, has_charts, attach_foreignkey
 from sentry.utils.safe import safe_execute, trim, trim_dict, trim_frames
@@ -720,236 +718,6 @@ class ProjectManager(BaseManager, ChartMixin):
         return self._get_chart_data(queryset, max_days, db, key=key)
 
 
-class MetaManager(BaseManager):
-    NOTSET = object()
-
-    def __init__(self, *args, **kwargs):
-        super(MetaManager, self).__init__(*args, **kwargs)
-        task_postrun.connect(self.clear_cache)
-        request_finished.connect(self.clear_cache)
-        self.__metadata = {}
-
-    def __getstate__(self):
-        d = self.__dict__.copy()
-        # we cant serialize weakrefs
-        d.pop('_MetaManager__metadata', None)
-        return d
-
-    def __setstate__(self, state):
-        self.__dict__.update(state)
-        self.__metadata = {}
-
-    def get_value(self, key, default=NOTSET):
-        result = self.get_all_values()
-        if default is self.NOTSET:
-            return result[key]
-        return result.get(key, default)
-
-    def unset_value(self, key):
-        self.filter(key=key).delete()
-        self.__metadata.pop(key, None)
-
-    def set_value(self, key, value):
-        inst, _ = self.get_or_create(
-            key=key,
-            defaults={
-                'value': value,
-            }
-        )
-        if inst.value != value:
-            inst.update(value=value)
-
-        self.__metadata[key] = value
-
-    def get_all_values(self):
-        if not hasattr(self, '_MetaManager__metadata'):
-            self.__metadata = dict(self.values_list('key', 'value'))
-        return self.__metadata
-
-    def clear_cache(self, **kwargs):
-        self.__metadata = {}
-
-
-class InstanceMetaManager(BaseManager):
-    NOTSET = object()
-
-    def __init__(self, field_name, *args, **kwargs):
-        super(InstanceMetaManager, self).__init__(*args, **kwargs)
-        self.field_name = field_name
-        task_postrun.connect(self.clear_cache)
-        request_finished.connect(self.clear_cache)
-        self.__metadata = {}
-
-    def __getstate__(self):
-        d = self.__dict__.copy()
-        # we cant serialize weakrefs
-        d.pop('_InstanceMetaManager__metadata', None)
-        return d
-
-    def __setstate__(self, state):
-        self.__dict__.update(state)
-        self.__metadata = {}
-
-    def _make_key(self, instance):
-        if isinstance(instance, models.Model):
-            instance_id = instance.pk
-        else:
-            instance_id = instance
-
-        return '%s:%s' % (self.model._meta.db_table, instance_id)
-
-    def get_value_bulk(self, instances, key):
-        return dict(self.filter(**{
-            '%s__in' % self.field_name: instances,
-            'key': key,
-        }).values_list(self.field_name, 'value'))
-
-    def get_value(self, instance, key, default=NOTSET):
-        result = self.get_all_values(instance)
-        if default is self.NOTSET:
-            return result[key]
-        return result.get(key, default)
-
-    def unset_value(self, instance, key):
-        self.filter(**{self.field_name: instance, 'key': key}).delete()
-        if instance.pk not in self.__metadata:
-            cache.delete(self._make_key(instance))
-            return
-        self.__metadata[instance.pk].pop(key, None)
-        cache.set(self._make_key(instance), self.__metadata[instance.pk])
-
-    def set_value(self, instance, key, value):
-        inst, created = self.get_or_create(**{
-            self.field_name: instance,
-            'key': key,
-            'defaults': {
-                'value': value,
-            }
-        })
-        if not created and inst.value != value:
-            inst.update(value=value)
-
-        if instance.pk not in self.__metadata:
-            cache.delete(self._make_key(instance))
-            return
-        self.__metadata[instance.pk][key] = value
-        cache.set(self._make_key(instance), self.__metadata[instance.pk])
-
-    def get_all_values(self, instance):
-        if isinstance(instance, models.Model):
-            instance_id = instance.pk
-        else:
-            instance_id = instance
-
-        if instance_id not in self.__metadata:
-            cache_key = self._make_key(instance)
-            result = cache.get(cache_key)
-            if result is None:
-                result = dict(
-                    (i.key, i.value) for i in
-                    self.filter(**{
-                        self.field_name: instance_id,
-                    })
-                )
-                cache.set(cache_key, result)
-            self.__metadata[instance_id] = result
-        return self.__metadata.get(instance_id, {})
-
-    def clear_cache(self, **kwargs):
-        self.__metadata = {}
-
-
-class UserOptionManager(BaseManager):
-    NOTSET = object()
-
-    def __init__(self, *args, **kwargs):
-        super(UserOptionManager, self).__init__(*args, **kwargs)
-        task_postrun.connect(self.clear_cache)
-        request_finished.connect(self.clear_cache)
-        self.__metadata = {}
-
-    def __getstate__(self):
-        d = self.__dict__.copy()
-        # we cant serialize weakrefs
-        d.pop('_UserOptionManager__metadata', None)
-        return d
-
-    def __setstate__(self, state):
-        self.__dict__.update(state)
-        self.__metadata = {}
-
-    def get_value(self, user, project, key, default=NOTSET):
-        result = self.get_all_values(user, project)
-        if default is self.NOTSET:
-            return result[key]
-        return result.get(key, default)
-
-    def unset_value(self, user, project, key):
-        self.filter(user=user, project=project, key=key).delete()
-        if not hasattr(self, '_metadata'):
-            return
-        if project:
-            metakey = (user.pk, project.pk)
-        else:
-            metakey = (user.pk, None)
-        if metakey not in self.__metadata:
-            return
-        self.__metadata[metakey].pop(key, None)
-
-    def set_value(self, user, project, key, value):
-        inst, created = self.get_or_create(
-            user=user,
-            project=project,
-            key=key,
-            defaults={
-                'value': value,
-            },
-        )
-        if not created and inst.value != value:
-            inst.update(value=value)
-
-        if project:
-            metakey = (user.pk, project.pk)
-        else:
-            metakey = (user.pk, None)
-        if metakey not in self.__metadata:
-            return
-        self.__metadata[metakey][key] = value
-
-    def get_all_values(self, user, project):
-        if project:
-            metakey = (user.pk, project.pk)
-        else:
-            metakey = (user.pk, None)
-        if metakey not in self.__metadata:
-            result = dict(
-                (i.key, i.value) for i in
-                self.filter(
-                    user=user,
-                    project=project,
-                )
-            )
-            self.__metadata[metakey] = result
-        return self.__metadata.get(metakey, {})
-
-    def clear_cache(self, **kwargs):
-        self.__metadata = {}
-
-
-class TagKeyManager(BaseManager):
-    def _get_cache_key(self, project_id):
-        return 'filterkey:all:%s' % project_id
-
-    def all_keys(self, project):
-        # TODO: cache invalidation via post_save/post_delete signals much like BaseManager
-        key = self._get_cache_key(project.id)
-        result = cache.get(key)
-        if result is None:
-            result = list(self.filter(project=project).values_list('key', flat=True))
-            cache.set(key, result, 60)
-        return result
-
-
 class TeamManager(BaseManager):
     def get_for_user(self, user, access=None, access_groups=True, with_projects=False):
         """
diff --git a/src/sentry/models/groupmeta.py b/src/sentry/models/groupmeta.py
index 61dbec2faa..6c97b36b07 100644
--- a/src/sentry/models/groupmeta.py
+++ b/src/sentry/models/groupmeta.py
@@ -9,7 +9,38 @@ sentry.models.groupmeta
 from django.db import models
 
 from sentry.db.models import Model, sane_repr
-from sentry.manager import InstanceMetaManager
+from sentry.db.models.manager import BaseManager
+
+
+class GroupMetaManager(BaseManager):
+    def get_value_bulk(self, instances, key):
+        return dict(self.filter(
+            group__in=instances,
+            key=key,
+        ).values_list('group', 'value'))
+
+    def get_value(self, instance, key, default=None):
+        try:
+            return self.get(
+                group=instance,
+                key=key,
+            )
+        except self.model.DoesNotExist:
+            return default
+
+    def unset_value(self, instance, key):
+        self.filter(group=instance, key=key).delete()
+
+    def set_value(self, instance, key, value):
+        inst, created = self.get_or_create(
+            group=instance,
+            key=key,
+            defaults={
+                'value': value,
+            },
+        )
+        if not created and inst.value != value:
+            inst.update(value=value)
 
 
 class GroupMeta(Model):
@@ -23,7 +54,7 @@ class GroupMeta(Model):
     key = models.CharField(max_length=64)
     value = models.TextField()
 
-    objects = InstanceMetaManager('group')
+    objects = GroupMetaManager()
 
     class Meta:
         app_label = 'sentry'
diff --git a/src/sentry/models/option.py b/src/sentry/models/option.py
index 3a7e13197f..b1d17bd3ff 100644
--- a/src/sentry/models/option.py
+++ b/src/sentry/models/option.py
@@ -6,11 +6,61 @@ sentry.models.option
 :license: BSD, see LICENSE for more details.
 """
 
+from celery.signals import task_postrun
+from django.core.signals import request_finished
 from django.db import models
 
 from sentry.db.models import Model, sane_repr
 from sentry.db.models.fields import UnicodePickledObjectField
-from sentry.manager import MetaManager
+from sentry.db.models.manager import BaseManager
+
+
+class OptionManager(BaseManager):
+    NOTSET = object()
+
+    def __init__(self, *args, **kwargs):
+        super(OptionManager, self).__init__(*args, **kwargs)
+        task_postrun.connect(self.clear_local_cache)
+        request_finished.connect(self.clear_local_cache)
+        self.__cache = {}
+
+    def __getstate__(self):
+        d = self.__dict__.copy()
+        # we cant serialize weakrefs
+        d.pop('_OptionManager__cache', None)
+        return d
+
+    def __setstate__(self, state):
+        self.__dict__.update(state)
+        self.__cache = {}
+
+    def get_value(self, key, default=None):
+        result = self.get_all_values()
+        return result.get(key, default)
+
+    def unset_value(self, key):
+        self.filter(key=key).delete()
+        self.__cache.pop(key, None)
+
+    def set_value(self, key, value):
+        inst, _ = self.get_or_create(
+            key=key,
+            defaults={
+                'value': value,
+            }
+        )
+        if inst.value != value:
+            inst.update(value=value)
+
+        self.__cache[key] = value
+
+    def get_all_values(self):
+        if not hasattr(self, '_OptionManager__cache'):
+            self.__cache = dict(self.values_list('key', 'value'))
+        return self.__cache
+
+    def clear_local_cache(self, **kwargs):
+        self.__cache = {}
 
 
 class Option(Model):
@@ -24,7 +74,7 @@ class Option(Model):
     key = models.CharField(max_length=64, unique=True)
     value = UnicodePickledObjectField()
 
-    objects = MetaManager(cache_fields=[
+    objects = OptionManager(cache_fields=[
         'key',
     ])
 
diff --git a/src/sentry/models/projectoption.py b/src/sentry/models/projectoption.py
index 8fa09a7394..a01db67a08 100644
--- a/src/sentry/models/projectoption.py
+++ b/src/sentry/models/projectoption.py
@@ -6,11 +6,94 @@ sentry.models.projectoption
 :license: BSD, see LICENSE for more details.
 """
 
+from celery.signals import task_postrun
+from django.core.signals import request_finished
 from django.db import models
 
 from sentry.db.models import Model, sane_repr
 from sentry.db.models.fields import UnicodePickledObjectField
-from sentry.manager import InstanceMetaManager
+from sentry.db.models.manager import BaseManager
+from sentry.utils.cache import cache
+
+
+class ProjectOptionManager(BaseManager):
+    def __init__(self, *args, **kwargs):
+        super(ProjectOptionManager, self).__init__(*args, **kwargs)
+        task_postrun.connect(self.clear_local_cache)
+        request_finished.connect(self.clear_local_cache)
+        self.__cache = {}
+
+    def __getstate__(self):
+        d = self.__dict__.copy()
+        # we cant serialize weakrefs
+        d.pop('_ProjectOptionManager__cache', None)
+        return d
+
+    def __setstate__(self, state):
+        self.__dict__.update(state)
+        self.__cache = {}
+
+    def _make_key(self, instance_id):
+        return '%s:%s' % (self.model._meta.db_table, instance_id)
+
+    def get_value_bulk(self, instances, key):
+        return dict(self.filter(
+            project__in=instances,
+            key=key,
+        ).values_list('project', 'value'))
+
+    def get_value(self, project, key, default=None):
+        result = self.get_all_values(project)
+        return result.get(key, default)
+
+    def unset_value(self, project, key):
+        self.filter(project=project, key=key).delete()
+        self.reload_cache(project)
+
+    def set_value(self, project, key, value):
+        self.create_or_update(
+            project=project,
+            key=key,
+            defaults={
+                'value': value,
+            },
+        )
+        self.reload_cache(project.id)
+
+    def get_all_values(self, project):
+        if isinstance(project, models.Model):
+            project_id = project.id
+        else:
+            project_id = project
+
+        if project_id not in self.__cache:
+            cache_key = self._make_key(project_id)
+            result = cache.get(cache_key)
+            if result is None:
+                result = self.reload_cache(project_id)
+            else:
+                self.__cache[project_id] = result
+        return self.__cache.get(project_id, {})
+
+    def clear_local_cache(self, **kwargs):
+        self.__cache = {}
+
+    def reload_cache(self, project_id):
+        cache_key = self._make_key(project_id)
+        result = dict(
+            (i.key, i.value)
+            for i in self.filter(project=project_id)
+        )
+        cache.set(cache_key, result)
+        if project_id in self.__cache:
+            self.__cache[project_id] = result
+        return result
+
+    def post_save(self, instance, **kwargs):
+        self.reload_cache(instance.project_id)
+
+    def post_delete(self, instance, **kwargs):
+        self.reload_cache(instance.project_id)
 
 
 class ProjectOption(Model):
@@ -24,7 +107,7 @@ class ProjectOption(Model):
     key = models.CharField(max_length=64)
     value = UnicodePickledObjectField()
 
-    objects = InstanceMetaManager('project')
+    objects = ProjectOptionManager()
 
     class Meta:
         app_label = 'sentry'
diff --git a/src/sentry/models/tagkey.py b/src/sentry/models/tagkey.py
index 3ad141cd24..e7384e4c26 100644
--- a/src/sentry/models/tagkey.py
+++ b/src/sentry/models/tagkey.py
@@ -11,10 +11,25 @@ from django.db import models
 
 from sentry.constants import MAX_TAG_KEY_LENGTH, TAG_LABELS
 from sentry.db.models import Model, BoundedPositiveIntegerField, sane_repr
-from sentry.manager import TagKeyManager
+from sentry.db.models.manager import BaseManager
+from sentry.utils.cache import cache
 from sentry.utils.http import absolute_uri
 
 
+class TagKeyManager(BaseManager):
+    def _get_cache_key(self, project_id):
+        return 'filterkey:all:%s' % project_id
+
+    def all_keys(self, project):
+        # TODO: cache invalidation via post_save/post_delete signals much like BaseManager
+        key = self._get_cache_key(project.id)
+        result = cache.get(key)
+        if result is None:
+            result = list(self.filter(project=project).values_list('key', flat=True))
+            cache.set(key, result, 60)
+        return result
+
+
 class TagKey(Model):
     """
     Stores references to available filters keys.
diff --git a/src/sentry/models/useroption.py b/src/sentry/models/useroption.py
index b605e3197b..62de8f7ffe 100644
--- a/src/sentry/models/useroption.py
+++ b/src/sentry/models/useroption.py
@@ -6,13 +6,87 @@ sentry.models.useroption
 :license: BSD, see LICENSE for more details.
 """
 
-
+from celery.signals import task_postrun
+from django.core.signals import request_finished
 from django.conf import settings
 from django.db import models
 
 from sentry.db.models import Model, sane_repr
 from sentry.db.models.fields import UnicodePickledObjectField
-from sentry.manager import UserOptionManager
+from sentry.db.models.manager import BaseManager
+
+
+class UserOptionManager(BaseManager):
+    def __init__(self, *args, **kwargs):
+        super(UserOptionManager, self).__init__(*args, **kwargs)
+        task_postrun.connect(self.clear_cache)
+        request_finished.connect(self.clear_cache)
+        self.__metadata = {}
+
+    def __getstate__(self):
+        d = self.__dict__.copy()
+        # we cant serialize weakrefs
+        d.pop('_UserOptionManager__metadata', None)
+        return d
+
+    def __setstate__(self, state):
+        self.__dict__.update(state)
+        self.__metadata = {}
+
+    def get_value(self, user, project, key, default=None):
+        result = self.get_all_values(user, project)
+        return result.get(key, default)
+
+    def unset_value(self, user, project, key):
+        self.filter(user=user, project=project, key=key).delete()
+        if not hasattr(self, '_metadata'):
+            return
+        if project:
+            metakey = (user.pk, project.pk)
+        else:
+            metakey = (user.pk, None)
+        if metakey not in self.__metadata:
+            return
+        self.__metadata[metakey].pop(key, None)
+
+    def set_value(self, user, project, key, value):
+        inst, created = self.get_or_create(
+            user=user,
+            project=project,
+            key=key,
+            defaults={
+                'value': value,
+            },
+        )
+        if not created and inst.value != value:
+            inst.update(value=value)
+
+        if project:
+            metakey = (user.pk, project.pk)
+        else:
+            metakey = (user.pk, None)
+        if metakey not in self.__metadata:
+            return
+        self.__metadata[metakey][key] = value
+
+    def get_all_values(self, user, project):
+        if project:
+            metakey = (user.pk, project.pk)
+        else:
+            metakey = (user.pk, None)
+        if metakey not in self.__metadata:
+            result = dict(
+                (i.key, i.value) for i in
+                self.filter(
+                    user=user,
+                    project=project,
+                )
+            )
+            self.__metadata[metakey] = result
+        return self.__metadata.get(metakey, {})
+
+    def clear_cache(self, **kwargs):
+        self.__metadata = {}
 
 
 class UserOption(Model):
diff --git a/src/sentry/testutils/cases.py b/src/sentry/testutils/cases.py
index 750842821b..12706d49ba 100644
--- a/src/sentry/testutils/cases.py
+++ b/src/sentry/testutils/cases.py
@@ -91,8 +91,8 @@ class BaseTestCase(Fixtures, Exam):
 
     def _pre_setup(self):
         cache.clear()
-        ProjectOption.objects.clear_cache()
-        Option.objects.clear_cache()
+        ProjectOption.objects.clear_local_cache()
+        Option.objects.clear_local_cache()
         super(BaseTestCase, self)._pre_setup()
 
     def _makeMessage(self, data):

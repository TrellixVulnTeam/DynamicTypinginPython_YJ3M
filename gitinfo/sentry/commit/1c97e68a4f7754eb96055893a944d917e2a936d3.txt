commit 1c97e68a4f7754eb96055893a944d917e2a936d3
Author: Leander Rodrigues <leandergrodrigues@gmail.com>
Date:   Thu Feb 27 15:09:39 2020 -0800

    chore(async-csv): Handle async errors in CSV export (#17267)
    
    Add error handling emails for common errors in the async task

diff --git a/src/sentry/api/endpoints/data_export.py b/src/sentry/api/endpoints/data_export.py
index b18b545257..ec1b293d8a 100644
--- a/src/sentry/api/endpoints/data_export.py
+++ b/src/sentry/api/endpoints/data_export.py
@@ -42,16 +42,20 @@ class DataExportEndpoint(OrganizationEndpoint):
         data = serializer.validated_data
 
         try:
-            # TODO(Leander): Prevent repeated requests for identical queries per organization, if one is in progress
-            data_export = ExportedData.objects.create(
+            # If this user has sent a sent a request with the same payload and organization,
+            # we return them the latest one that is NOT complete (i.e. don't start another)
+            data_export, created = ExportedData.objects.get_or_create(
                 organization=organization,
                 user=request.user,
                 query_type=data["query_type"],
                 query_info=data["query_info"],
+                date_finished=None,
             )
+            status = 200
+            if created:
+                assemble_download.delay(data_export=data_export)
+                status = 201
         except ValidationError as e:
             # This will handle invalid JSON requests
             return Response({"detail": six.text_type(e)}, status=400)
-
-        assemble_download.delay(data_export=data_export)
-        return Response(serialize(data_export, request.user), status=201)
+        return Response(serialize(data_export, request.user), status=status)
diff --git a/src/sentry/api/endpoints/data_export_details.py b/src/sentry/api/endpoints/data_export_details.py
index b70841871c..9425ac57d4 100644
--- a/src/sentry/api/endpoints/data_export_details.py
+++ b/src/sentry/api/endpoints/data_export_details.py
@@ -23,7 +23,8 @@ class DataExportDetailsEndpoint(OrganizationEndpoint):
 
         try:
             data_export = ExportedData.objects.get(id=kwargs["data_export_id"])
-            if request.GET.get("download") is not None:
+            # Ignore the download parameter unless we have a file to stream
+            if request.GET.get("download") is not None and data_export.file is not None:
                 return self.download(data_export)
             return Response(serialize(data_export, request.user))
         except ExportedData.DoesNotExist:
diff --git a/src/sentry/models/exporteddata.py b/src/sentry/models/exporteddata.py
index 16be3bcd83..b5edcfaae4 100644
--- a/src/sentry/models/exporteddata.py
+++ b/src/sentry/models/exporteddata.py
@@ -1,5 +1,6 @@
 from __future__ import absolute_import
 
+import json
 import six
 from enum import Enum
 from datetime import timedelta
@@ -62,6 +63,12 @@ class ExportedData(Model):
             return None
         return self.date_expired.strftime("%-I:%M %p on %B %d, %Y (%Z)")
 
+    @property
+    def payload(self):
+        payload = self.query_info.copy()
+        payload["export_type"] = ExportQueryType.as_str(self.query_type)
+        return payload
+
     def delete_file(self):
         if self.file:
             self.file.delete()
@@ -97,6 +104,22 @@ class ExportedData(Model):
         )
         msg.send_async([self.user.email])
 
+    def email_failure(self, message):
+        from sentry.utils.email import MessageBuilder
+
+        msg = MessageBuilder(
+            subject="Unable to Export Data",
+            context={
+                "error_message": message,
+                "payload": json.dumps(self.payload, indent=2, sort_keys=True),
+            },
+            type="organization.export-data",
+            template="sentry/emails/data-export-failure.txt",
+            html_template="sentry/emails/data-export-failure.html",
+        )
+        msg.send_async([self.user.email])
+        self.delete()
+
     class Meta:
         app_label = "sentry"
         db_table = "sentry_exporteddata"
diff --git a/src/sentry/tasks/data_export.py b/src/sentry/tasks/data_export.py
index a868a27245..e5646daeef 100644
--- a/src/sentry/tasks/data_export.py
+++ b/src/sentry/tasks/data_export.py
@@ -3,7 +3,7 @@ from __future__ import absolute_import
 import csv
 import tempfile
 
-from django.db import transaction
+from django.db import transaction, IntegrityError
 
 from sentry import tagstore
 from sentry.constants import ExportQueryType
@@ -13,27 +13,41 @@ from sentry.tasks.base import instrumented_task
 SNUBA_MAX_RESULTS = 1000
 
 
+class DataExportError(Exception):
+    pass
+
+
 @instrumented_task(name="sentry.tasks.data_export.assemble_download", queue="data_export")
 def assemble_download(data_export):
     # Create a temporary file
-    with tempfile.TemporaryFile() as tf:
-        # Process the query based on its type
-        if data_export.query_type == ExportQueryType.DISCOVER_V2:
-            process_discover_v2(data_export, tf)
-            return
-        elif data_export.query_type == ExportQueryType.BILLING_REPORT:
-            process_billing_report(data_export, tf)
-            return
-        elif data_export.query_type == ExportQueryType.ISSUE_BY_TAG:
-            file_name = process_issue_by_tag(data_export, tf)
-        # Create a new File object and attach it to the ExportedData
-        tf.seek(0)
-        with transaction.atomic():
-            file = File.objects.create(
-                name=file_name, type="export.csv", headers={"Content-Type": "text/csv"}
-            )
-            file.putfile(tf)
-            data_export.finalize_upload(file=file)
+    try:
+        with tempfile.TemporaryFile() as tf:
+            # Process the query based on its type
+            if data_export.query_type == ExportQueryType.DISCOVER_V2:
+                process_discover_v2(data_export, tf)
+                return
+            elif data_export.query_type == ExportQueryType.BILLING_REPORT:
+                process_billing_report(data_export, tf)
+                return
+            elif data_export.query_type == ExportQueryType.ISSUE_BY_TAG:
+                file_name = process_issue_by_tag(data_export, tf)
+            # Create a new File object and attach it to the ExportedData
+            tf.seek(0)
+            try:
+                with transaction.atomic():
+                    file = File.objects.create(
+                        name=file_name, type="export.csv", headers={"Content-Type": "text/csv"}
+                    )
+                    file.putfile(tf)
+                    data_export.finalize_upload(file=file)
+            except IntegrityError:
+                raise DataExportError("Failed to save the assembled file")
+    except DataExportError as err:
+        # TODO(Leander): Implement logging
+        return data_export.email_failure(message=err)
+    except BaseException:
+        # TODO(Leander): Implement logging
+        return data_export.email_failure(message="Internal processing failure")
 
 
 def process_discover_v2(data_export, file):
@@ -53,17 +67,23 @@ def process_issue_by_tag(data_export, file):
     (Adapted from 'src/sentry/web/frontend/group_tag_export.py')
     """
     # Get the pertaining project
-    payload = data_export.query_info
-    project = Project.objects.get(id=payload["project_id"])
+    try:
+        payload = data_export.query_info
+        project = Project.objects.get(id=payload["project_id"])
+    except Project.DoesNotExist:
+        raise DataExportError("Requested project does not exist")
 
     # Get the pertaining issue
-    group, _ = get_group_with_redirect(
-        payload["group_id"], queryset=Group.objects.filter(project=project)
-    )
+    try:
+        group, _ = get_group_with_redirect(
+            payload["group_id"], queryset=Group.objects.filter(project=project)
+        )
+    except Group.DoesNotExist:
+        raise DataExportError("Requested issue does not exist")
 
     # Get the pertaining key
     key = payload["key"]
-    lookup_key = u"sentry:{0}".format(key) if tagstore.is_reserved_key(key) else key
+    lookup_key = u"sentry:{}".format(key) if tagstore.is_reserved_key(key) else key
 
     # If the key is the 'user' tag, attach the event user
     def attach_eventuser(items):
diff --git a/src/sentry/templates/sentry/emails/data-export-failure.html b/src/sentry/templates/sentry/emails/data-export-failure.html
new file mode 100644
index 0000000000..f749eec1c8
--- /dev/null
+++ b/src/sentry/templates/sentry/emails/data-export-failure.html
@@ -0,0 +1,19 @@
+
+{% extends "sentry/emails/base.html" %}
+
+{% load i18n %}
+
+{% block main %}
+    <h3>Unable to Export Data</h3>
+    <p>We were unable to generate your data export due to an error:</p>
+    <code><pre>{{error_message}}</pre></code>
+    <p>We received the following payload:</p>
+    <code>
+        <pre>{{payload}}</pre>
+    </code>
+    <p><strong>Troubleshooting &amp; References</strong></p>
+    <ul>
+        <li><a href="https://docs.sentry.io/">Documentation</a></li>
+        <li><a href="https://help.sentry.io/">FAQs</a></li>
+    </ul>
+{% endblock %}
diff --git a/src/sentry/templates/sentry/emails/data-export-failure.txt b/src/sentry/templates/sentry/emails/data-export-failure.txt
new file mode 100644
index 0000000000..e83d355e0c
--- /dev/null
+++ b/src/sentry/templates/sentry/emails/data-export-failure.txt
@@ -0,0 +1,14 @@
+Unable to Export Data
+---------------------
+
+We were unable to generate your data export due to an error:
+
+    {{error_message}}
+
+We received the following payload:
+
+    {{payload}}
+
+Troubleshooting & References:
+ - https://docs.sentry.io/ (Documentation)
+ - https://help.sentry.io/ (FAQs)
diff --git a/tests/sentry/api/endpoints/test_data_export.py b/tests/sentry/api/endpoints/test_data_export.py
index 129c7df1e4..66da1947f9 100644
--- a/tests/sentry/api/endpoints/test_data_export.py
+++ b/tests/sentry/api/endpoints/test_data_export.py
@@ -2,9 +2,6 @@ from __future__ import absolute_import
 
 import six
 
-from django.core.urlresolvers import reverse
-from django.utils import timezone
-
 from sentry.models import ExportedData
 from sentry.models.exporteddata import ExportStatus
 from sentry.testutils import APITestCase
@@ -12,31 +9,58 @@ from sentry.testutils import APITestCase
 
 class DataExportTest(APITestCase):
     endpoint = "sentry-api-0-organization-data-export"
+    method = "post"
+    payload = {"query_type": 0, "query_info": {"env": "test"}}
 
-    TEST_DATE_ADDED = timezone.now()
+    def setUp(self):
+        self.user = self.create_user("user1@example.com")
+        self.organization = self.create_organization(owner=self.user)
+        self.login_as(user=self.user)
 
-    def test_simple(self):
+    def test_new_export(self):
+        """
+        Ensures that a request to this endpoint returns a 201 status code
+        and an appropriate response object
+        """
         with self.feature("organizations:data-export"):
-            self.user = self.create_user("foo@example.com")
-            self.org = self.create_organization(owner=self.user, name="Toucan Sam")
-            self.login_as(user=self.user)
-
-            data = {"query_type": 2, "query_info": {"environment": "test"}}
-            url = reverse(self.endpoint, kwargs={"organization_slug": self.org.slug})
+            response = self.get_valid_response(
+                self.organization.slug, status_code=201, **self.payload
+            )
+        data_export = ExportedData.objects.get(id=response.data["id"])
+        assert response.data == {
+            "id": data_export.id,
+            "user": {
+                "id": six.binary_type(self.user.id),
+                "email": self.user.email,
+                "username": self.user.username,
+            },
+            "dateCreated": data_export.date_added,
+            "dateFinished": None,
+            "dateExpired": None,
+            "query": {"type": self.payload["query_type"], "info": self.payload["query_info"]},
+            "status": ExportStatus.Early,
+        }
 
-            response = self.client.post(url, data=data)
-            data_export = ExportedData.objects.get(id=response.data["id"])
-            assert response.status_code == 201
-            assert response.data == {
-                "id": data_export.id,
-                "user": {
-                    "id": six.binary_type(self.user.id),
-                    "email": self.user.email,
-                    "username": self.user.username,
-                },
-                "dateCreated": data_export.date_added,
-                "dateFinished": None,
-                "dateExpired": None,
-                "query": {"type": data["query_type"], "info": data["query_info"]},
-                "status": ExportStatus.Early,
-            }
+    def test_progress_export(self):
+        """
+        Checks to make sure that identical requests (same payload, organization, user)
+        are routed to the same ExportedData object, with a 200 status code
+        """
+        with self.feature("organizations:data-export"):
+            response1 = self.get_response(self.organization.slug, **self.payload)
+        data_export = ExportedData.objects.get(id=response1.data["id"])
+        with self.feature("organizations:data-export"):
+            response2 = self.get_valid_response(self.organization.slug, **self.payload)
+        assert response2.data == {
+            "id": data_export.id,
+            "user": {
+                "id": six.binary_type(self.user.id),
+                "email": self.user.email,
+                "username": self.user.username,
+            },
+            "dateCreated": data_export.date_added,
+            "dateFinished": data_export.date_finished,
+            "dateExpired": data_export.date_expired,
+            "query": {"type": data_export.query_type, "info": data_export.query_info},
+            "status": data_export.status,
+        }
diff --git a/tests/sentry/api/endpoints/test_data_export_details.py b/tests/sentry/api/endpoints/test_data_export_details.py
index 3953fb3d9f..7736cba546 100644
--- a/tests/sentry/api/endpoints/test_data_export_details.py
+++ b/tests/sentry/api/endpoints/test_data_export_details.py
@@ -1,8 +1,7 @@
 from __future__ import absolute_import
 
 import six
-
-from django.core.urlresolvers import reverse
+from datetime import timedelta
 from django.utils import timezone
 
 from sentry.models import ExportedData
@@ -13,38 +12,58 @@ from sentry.testutils import APITestCase
 class DataExportDetailsTest(APITestCase):
     endpoint = "sentry-api-0-organization-data-export-details"
 
-    TEST_DATE_ADDED = timezone.now()
+    def setUp(self):
+        self.user = self.create_user()
+        self.organization = self.create_organization(owner=self.user)
+        self.login_as(user=self.user)
+        self.data_export = ExportedData.objects.create(
+            user=self.user, organization=self.organization, query_type=0, query_info={"env": "test"}
+        )
+
+    def test_content(self):
+        with self.feature("organizations:data-export"):
+            response = self.get_valid_response(self.organization.slug, self.data_export.id)
+        assert response.data["id"] == self.data_export.id
+        assert response.data["user"] == {
+            "id": six.binary_type(self.user.id),
+            "email": self.user.email,
+            "username": self.user.username,
+        }
+        assert response.data["dateCreated"] == self.data_export.date_added
+        assert response.data["query"] == {
+            "type": self.data_export.query_type,
+            "info": self.data_export.query_info,
+        }
+
+    def test_early(self):
+        with self.feature("organizations:data-export"):
+            response = self.get_valid_response(self.organization.slug, self.data_export.id)
+        assert response.data["dateFinished"] is None
+        assert response.data["dateExpired"] is None
+        assert response.data["status"] == ExportStatus.Early
+
+    def test_valid(self):
+        self.data_export.update(
+            date_finished=timezone.now() - timedelta(weeks=2),
+            date_expired=timezone.now() + timedelta(weeks=1),
+        )
+        with self.feature("organizations:data-export"):
+            response = self.get_valid_response(self.organization.slug, self.data_export.id)
+        assert response.data["dateFinished"] is not None
+        assert response.data["dateFinished"] == self.data_export.date_finished
+        assert response.data["dateExpired"] is not None
+        assert response.data["dateExpired"] == self.data_export.date_expired
+        assert response.data["status"] == ExportStatus.Valid
 
-    def test_simple(self):
+    def test_expired(self):
+        self.data_export.update(
+            date_finished=timezone.now() - timedelta(weeks=2),
+            date_expired=timezone.now() - timedelta(weeks=1),
+        )
         with self.feature("organizations:data-export"):
-            self.user = self.create_user("foo@example.com")
-            self.org = self.create_organization(owner=self.user, name="Toucan Sam")
-            self.login_as(user=self.user)
-
-            data_export = ExportedData.objects.create(
-                organization=self.org,
-                user=self.user,
-                date_added=self.TEST_DATE_ADDED,
-                query_type=1,
-                query_info={"environment": "test"},
-            )
-            url = reverse(
-                self.endpoint,
-                kwargs={"data_export_id": data_export.id, "organization_slug": self.org.slug},
-            )
-
-            response = self.client.get(url, format="json")
-            assert response.status_code == 200
-            assert response.data == {
-                "id": data_export.id,
-                "user": {
-                    "id": six.binary_type(self.user.id),
-                    "email": self.user.email,
-                    "username": self.user.username,
-                },
-                "dateCreated": self.TEST_DATE_ADDED,
-                "dateFinished": None,
-                "dateExpired": None,
-                "query": {"type": data_export.query_type, "info": data_export.query_info},
-                "status": ExportStatus.Early,
-            }
+            response = self.get_valid_response(self.organization.slug, self.data_export.id)
+        assert response.data["dateFinished"] is not None
+        assert response.data["dateFinished"] == self.data_export.date_finished
+        assert response.data["dateExpired"] is not None
+        assert response.data["dateExpired"] == self.data_export.date_expired
+        assert response.data["status"] == ExportStatus.Expired
diff --git a/tests/sentry/models/test_exporteddata.py b/tests/sentry/models/test_exporteddata.py
index ba1b470302..de3cd5319a 100644
--- a/tests/sentry/models/test_exporteddata.py
+++ b/tests/sentry/models/test_exporteddata.py
@@ -1,5 +1,7 @@
 from __future__ import absolute_import
 
+import six
+import json
 import tempfile
 from datetime import timedelta
 from django.core import mail
@@ -14,6 +16,8 @@ from sentry.utils.compat.mock import patch
 
 
 class ExportedDataTest(TestCase):
+    TEST_STRING = "A bunch of test data..."
+
     def setUp(self):
         super(ExportedDataTest, self).setUp()
         self.user = self.create_user()
@@ -42,9 +46,12 @@ class ExportedDataTest(TestCase):
         assert self.data_export.date_expired_string is None
         current_time = timezone.now()
         self.data_export.update(date_expired=current_time)
-        assert self.data_export.date_expired_string == current_time.strftime(
-            "%-I:%M %p on %B %d, %Y (%Z)"
-        )
+        assert isinstance(self.data_export.date_expired_string, six.binary_type)
+
+    def test_payload_property(self):
+        assert isinstance(self.data_export.payload, dict)
+        keys = self.data_export.query_info.keys() + ["export_type"]
+        assert sorted(self.data_export.payload.keys()) == sorted(keys)
 
     def test_delete_file(self):
         # Empty call should have no effect
@@ -70,24 +77,23 @@ class ExportedDataTest(TestCase):
         assert not File.objects.filter(id=self.file1.id).exists()
 
     def test_finalize_upload(self):
-        TEST_STRING = "A bunch of test data..."
         # With default expiration
         with tempfile.TemporaryFile() as tf:
-            tf.write(TEST_STRING)
+            tf.write(self.TEST_STRING)
             tf.seek(0)
             self.file1.putfile(tf)
         self.data_export.finalize_upload(file=self.file1)
-        assert self.data_export.file.getfile().read() == TEST_STRING
+        assert self.data_export.file.getfile().read() == self.TEST_STRING
         assert self.data_export.date_finished is not None
         assert self.data_export.date_expired is not None
         assert self.data_export.date_expired == self.data_export.date_finished + DEFAULT_EXPIRATION
         # With custom expiration
         with tempfile.TemporaryFile() as tf:
-            tf.write(TEST_STRING + TEST_STRING)
+            tf.write(self.TEST_STRING + self.TEST_STRING)
             tf.seek(0)
             self.file2.putfile(tf)
         self.data_export.finalize_upload(file=self.file2, expiration=timedelta(weeks=2))
-        assert self.data_export.file.getfile().read() == TEST_STRING + TEST_STRING
+        assert self.data_export.file.getfile().read() == self.TEST_STRING + self.TEST_STRING
         # Ensure the first file is deleted
         assert not File.objects.filter(id=self.file1.id).exists()
         assert self.data_export.date_expired == self.data_export.date_finished + timedelta(weeks=2)
@@ -119,4 +125,26 @@ class ExportedDataTest(TestCase):
             "template": "sentry/emails/data-export-success.txt",
             "html_template": "sentry/emails/data-export-success.html",
         }
-        assert builder.call_args[1] == expected_email_args
+        builder.assert_called_with(**expected_email_args)
+
+    def test_email_failure(self):
+        with self.tasks():
+            self.data_export.email_failure(self.TEST_STRING)
+        assert len(mail.outbox) == 1
+        assert not ExportedData.objects.filter(id=self.data_export.id).exists()
+
+    @patch("sentry.utils.email.MessageBuilder")
+    def test_email_failure_content(self, builder):
+        with self.tasks():
+            self.data_export.email_failure(self.TEST_STRING)
+        expected_email_args = {
+            "subject": "Unable to Export Data",
+            "type": "organization.export-data",
+            "context": {
+                "error_message": self.TEST_STRING,
+                "payload": json.dumps(self.data_export.payload, indent=2, sort_keys=True),
+            },
+            "template": "sentry/emails/data-export-failure.txt",
+            "html_template": "sentry/emails/data-export-failure.html",
+        }
+        builder.assert_called_with(**expected_email_args)
diff --git a/tests/sentry/tasks/test_data_export.py b/tests/sentry/tasks/test_data_export.py
index e8073b7dab..a7656d5506 100644
--- a/tests/sentry/tasks/test_data_export.py
+++ b/tests/sentry/tasks/test_data_export.py
@@ -1,8 +1,11 @@
 from __future__ import absolute_import
 
+import six
+
 from sentry.models import ExportedData, File
-from sentry.tasks.data_export import assemble_download, get_file_name
+from sentry.tasks.data_export import assemble_download, get_file_name, DataExportError
 from sentry.testutils import TestCase, SnubaTestCase
+from sentry.utils.compat.mock import patch
 
 
 class AssembleDownloadTest(TestCase, SnubaTestCase):
@@ -30,7 +33,7 @@ class AssembleDownloadTest(TestCase, SnubaTestCase):
         file_name = get_file_name("TESTING", "proj1_user1_test")
         assert file_name == "TESTING-proj1_user1_test.csv"
 
-    def test_assemble_download_issue_by_tag(self):
+    def test_issue_by_tag(self):
         de1 = ExportedData.objects.create(
             user=self.user,
             organization=self.org,
@@ -69,3 +72,28 @@ class AssembleDownloadTest(TestCase, SnubaTestCase):
         raw1, raw2 = sorted([raw1, raw2])
         assert raw1.startswith("bar,1,")
         assert raw2.startswith("bar2,2,")
+
+    @patch("sentry.models.ExportedData.email_failure")
+    def test_issue_by_tag_errors(self, emailer):
+        de1 = ExportedData.objects.create(
+            user=self.user,
+            organization=self.org,
+            query_type=2,
+            query_info={"project_id": -1, "group_id": self.event.group_id, "key": "user"},
+        )
+        with self.tasks():
+            assemble_download(de1)
+        error = emailer.call_args[1]["message"]
+        assert isinstance(error, DataExportError)
+        assert six.binary_type(error) == "Requested project does not exist"
+        de2 = ExportedData.objects.create(
+            user=self.user,
+            organization=self.org,
+            query_type=2,
+            query_info={"project_id": self.project.id, "group_id": -1, "key": "user"},
+        )
+        with self.tasks():
+            assemble_download(de2)
+        error = emailer.call_args[1]["message"]
+        assert isinstance(error, DataExportError)
+        assert six.binary_type(error) == "Requested issue does not exist"

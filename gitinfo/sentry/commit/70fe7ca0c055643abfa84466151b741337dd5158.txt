commit 70fe7ca0c055643abfa84466151b741337dd5158
Author: Mark Story <mark@sentry.io>
Date:   Fri May 1 10:18:46 2020 -0400

    fix(search) Separate the issue and events tag HOCs (#18549)
    
    Remove the options that let consumers choose which tag lists they want
    in favor of having two different HOCs that do what is needed. This
    allows discover2 to have transaction attributes show up in the key
    autocomplete, and issue search to have issue-only properties show up.
    This also streamlines the TagStore to only actively store tags alone.
    
    Co-authored-by: Billy Vong <billyvg@users.noreply.github.com>

diff --git a/src/sentry/static/sentry/app/stores/tagStore.jsx b/src/sentry/static/sentry/app/stores/tagStore.jsx
index 8a1c89d188..331791126e 100644
--- a/src/sentry/static/sentry/app/stores/tagStore.jsx
+++ b/src/sentry/static/sentry/app/stores/tagStore.jsx
@@ -2,26 +2,9 @@ import Reflux from 'reflux';
 import reduce from 'lodash/reduce';
 
 import TagActions from 'app/actions/tagActions';
-import MemberListStore from 'app/stores/memberListStore';
 
-const uuidPattern = /[0-9a-f]{32}$/;
-
-const getUsername = ({isManaged, username, email}) => {
-  // Users created via SAML receive unique UUID usernames. Use
-  // their email in these cases, instead.
-  if (username && uuidPattern.test(username)) {
-    return email;
-  } else {
-    return !isManaged && username ? username : email;
-  }
-};
-
-const getMemberListStoreUsernames = () => MemberListStore.getAll().map(getUsername);
-
-// This list is not the same as the list of
-// fields in app/utils/discover/fields.tsx@FIELDS
-// The differences are because discover1 and issue
-// search expose a subset of all event attributes.
+// This list is only used on issues. Events/discover
+// have their own field list that exists elsewhere.
 const BUILTIN_TAGS = [
   'event.type',
   'platform',
@@ -61,20 +44,20 @@ const BUILTIN_TAGS = [
   'stack.module',
   'stack.function',
   'stack.stack_level',
-].map(tag => ({
-  key: tag,
-}));
+].reduce((acc, tag) => {
+  acc[tag] = {key: tag, name: tag};
+  return acc;
+}, {});
 
 const TagStore = Reflux.createStore({
   listenables: TagActions,
 
   init() {
-    this.listenTo(MemberListStore, this.onMemberListStoreChange);
     this.reset();
   },
 
   getBuiltInTags() {
-    return [...BUILTIN_TAGS];
+    return {...BUILTIN_TAGS};
   },
 
   getIssueAttributes() {
@@ -97,19 +80,19 @@ const TagStore = Reflux.createStore({
       has: {
         key: 'has',
         name: 'Has Tag',
-        values: [],
+        values: Object.keys(this.tags),
         predefined: true,
       },
       assigned: {
         key: 'assigned',
         name: 'Assigned To',
-        values: getMemberListStoreUsernames(),
+        values: [],
         predefined: true,
       },
       bookmarks: {
         key: 'bookmarks',
         name: 'Bookmarked By',
-        values: getMemberListStoreUsernames(),
+        values: [],
         predefined: true,
       },
       lastSeen: {
@@ -148,8 +131,7 @@ const TagStore = Reflux.createStore({
   },
 
   reset() {
-    this.tags = this.getIssueAttributes();
-
+    this.tags = {};
     this.trigger(this.tags);
   },
 
@@ -169,28 +151,13 @@ const TagStore = Reflux.createStore({
             },
             tag
           );
-
-          const old = this.tags[tag.key];
-
-          // Don't override predefined filters (e.g. "is")
-          if (!old || !old.predefined) {
-            obj[tag.key] = tag;
-          }
+          obj[tag.key] = tag;
 
           return obj;
         },
         {}
       )
     );
-    this.tags.has.values = data.map(tag => tag.key);
-    this.trigger(this.tags);
-  },
-
-  onMemberListStoreChange() {
-    const assignedTag = this.tags.assigned;
-    assignedTag.values = getMemberListStoreUsernames();
-    assignedTag.values.unshift('me');
-    this.tags.bookmarks.values = assignedTag.values;
     this.trigger(this.tags);
   },
 });
diff --git a/src/sentry/static/sentry/app/utils/withIssueTags.tsx b/src/sentry/static/sentry/app/utils/withIssueTags.tsx
new file mode 100644
index 0000000000..be5f1a947a
--- /dev/null
+++ b/src/sentry/static/sentry/app/utils/withIssueTags.tsx
@@ -0,0 +1,103 @@
+import React from 'react';
+import Reflux from 'reflux';
+import createReactClass from 'create-react-class';
+import assign from 'lodash/assign';
+
+import getDisplayName from 'app/utils/getDisplayName';
+import MemberListStore from 'app/stores/memberListStore';
+import TagStore from 'app/stores/tagStore';
+import {User, Tag} from 'app/types';
+
+type TagCollection = {[key: string]: Tag};
+
+type InjectedTagsProps = {
+  tags: TagCollection;
+};
+
+type State = {
+  tags: TagCollection;
+  users: User[];
+};
+
+const uuidPattern = /[0-9a-f]{32}$/;
+const getUsername = ({isManaged, username, email}: User) => {
+  // Users created via SAML receive unique UUID usernames. Use
+  // their email in these cases, instead.
+  if (username && uuidPattern.test(username)) {
+    return email;
+  } else {
+    return !isManaged && username ? username : email;
+  }
+};
+
+/**
+ * HOC for getting tags and many useful issue attributes as 'tags' for use
+ * in autocomplete selectors or condition builders.
+ */
+const withIssueTags = <P extends InjectedTagsProps>(
+  WrappedComponent: React.ComponentType<P>
+) =>
+  createReactClass<Omit<P, keyof InjectedTagsProps>, State>({
+    displayName: `withIssueTags(${getDisplayName(WrappedComponent)})`,
+
+    mixins: [
+      Reflux.listenTo(MemberListStore, 'onMemberListStoreChange') as any,
+      Reflux.listenTo(TagStore, 'onTagsUpdate') as any,
+    ],
+
+    getInitialState() {
+      const tags = assign(
+        {},
+        TagStore.getAllTags(),
+        TagStore.getIssueAttributes(),
+        TagStore.getBuiltInTags()
+      );
+      const users = MemberListStore.getAll();
+
+      return {tags, users};
+    },
+
+    onMemberListStoreChange(users: User[]) {
+      this.setState({users});
+      this.setAssigned();
+    },
+
+    onTagsUpdate(storeTags: TagCollection) {
+      const tags = assign(
+        {},
+        storeTags,
+        TagStore.getIssueAttributes(),
+        TagStore.getBuiltInTags()
+      );
+      this.setState({tags});
+      this.setAssigned();
+    },
+
+    setAssigned() {
+      if (this.state.users && this.state.tags.assigned) {
+        const {tags, users} = this.state;
+        const usernames: string[] = users.map(getUsername);
+        usernames.unshift('me');
+
+        this.setState({
+          tags: {
+            ...tags,
+            assigned: {
+              ...tags.assigned,
+              values: usernames,
+            },
+            bookmarks: {
+              ...tags.bookmarks,
+              values: usernames,
+            },
+          },
+        });
+      }
+    },
+
+    render() {
+      return <WrappedComponent tags={this.state.tags} {...(this.props as P)} />;
+    },
+  });
+
+export default withIssueTags;
diff --git a/src/sentry/static/sentry/app/utils/withTags.tsx b/src/sentry/static/sentry/app/utils/withTags.tsx
index e908846fcb..eb91a5b590 100644
--- a/src/sentry/static/sentry/app/utils/withTags.tsx
+++ b/src/sentry/static/sentry/app/utils/withTags.tsx
@@ -1,7 +1,6 @@
 import React from 'react';
 import Reflux from 'reflux';
 import createReactClass from 'create-react-class';
-import omit from 'lodash/omit';
 
 import getDisplayName from 'app/utils/getDisplayName';
 import TagStore from 'app/stores/tagStore';
@@ -18,45 +17,10 @@ type State = {
 };
 
 /**
- * TODO(mark) Remove these options and have TagStore only contain tags.
- * Add new HOCs that layer in the event + issue attributes as needed.
+ * HOC for getting *only* tags from the TagStore.
  */
-type Options = {
-  /**
-   * Set to true if you want to include issue attributes in the tag list
-   * that is forwarded to the wrapped component.
-   */
-  includeIssueAttributes?: boolean;
-  /**
-   * Set to true if you want to include event properties
-   */
-  includeEventAttributes?: boolean;
-};
-
-const ISSUE_TAGS: TagCollection = TagStore.getIssueAttributes();
-
-function filterTags(tags: TagCollection, options: Options): TagCollection {
-  const out: TagCollection = {...tags};
-  if (options.includeEventAttributes) {
-    TagStore.getBuiltInTags().forEach((tag: Tag) => (out[tag.key] = tag));
-  }
-
-  if (options.includeIssueAttributes) {
-    // timestamp is replaced by event.timestamp
-    // environment is in the globalSelectionHeader.
-    return omit(out, ['environment', 'timestamp']);
-  }
-
-  // Remove issue attributes as they are include by default by TagStore
-  // for now.
-  Object.keys(ISSUE_TAGS).forEach(key => delete out[key]);
-
-  return out;
-}
-
 const withTags = <P extends InjectedTagsProps>(
-  WrappedComponent: React.ComponentType<P>,
-  {includeIssueAttributes = false, includeEventAttributes = true}: Options = {}
+  WrappedComponent: React.ComponentType<P>
 ) =>
   createReactClass<Omit<P, keyof InjectedTagsProps>, State>({
     displayName: `withTags(${getDisplayName(WrappedComponent)})`,
@@ -64,16 +28,13 @@ const withTags = <P extends InjectedTagsProps>(
 
     getInitialState() {
       return {
-        tags: filterTags(TagStore.getAllTags(), {
-          includeIssueAttributes,
-          includeEventAttributes,
-        }),
+        tags: TagStore.getAllTags(),
       };
     },
 
     onTagsUpdate(tags: TagCollection) {
       this.setState({
-        tags: filterTags(tags, {includeIssueAttributes, includeEventAttributes}),
+        tags,
       });
     },
 
diff --git a/src/sentry/static/sentry/app/views/events/searchBar.jsx b/src/sentry/static/sentry/app/views/events/searchBar.jsx
index 856b840626..f6b3d07b1e 100644
--- a/src/sentry/static/sentry/app/views/events/searchBar.jsx
+++ b/src/sentry/static/sentry/app/views/events/searchBar.jsx
@@ -1,31 +1,30 @@
 import {ClassNames} from '@emotion/core';
+import assign from 'lodash/assign';
 import flatten from 'lodash/flatten';
+import isEqual from 'lodash/isEqual';
 import memoize from 'lodash/memoize';
+import omit from 'lodash/omit';
 import PropTypes from 'prop-types';
 import React from 'react';
-import isEqual from 'lodash/isEqual';
 
 import {NEGATION_OPERATOR, SEARCH_TYPES, SEARCH_WILDCARD} from 'app/constants';
 import {defined} from 'app/utils';
 import {fetchTagValues} from 'app/actionCreators/tags';
 import SentryTypes from 'app/sentryTypes';
 import SmartSearchBar from 'app/components/smartSearchBar';
+import {FIELDS, TRACING_FIELDS} from 'app/utils/discover/fields';
 import withApi from 'app/utils/withApi';
 import withTags from 'app/utils/withTags';
 
-const tagToObjectReducer = (acc, name) => {
-  acc[name] = {
-    key: name,
-    name,
-  };
-  return acc;
-};
-
 const SEARCH_SPECIAL_CHARS_REGEXP = new RegExp(
   `^${NEGATION_OPERATOR}|\\${SEARCH_WILDCARD}`,
   'g'
 );
 
+const FIELD_TAGS = Object.fromEntries(
+  Object.keys(FIELDS).map(item => [item, {key: item, name: item}])
+);
+
 class SearchBar extends React.PureComponent {
   static propTypes = {
     api: PropTypes.object,
@@ -72,14 +71,29 @@ class SearchBar extends React.PureComponent {
     ({key}, query) => `${key}-${query}`
   );
 
-  getAllTags = (orgTags = []) => orgTags.sort().reduce(tagToObjectReducer, {});
-
   /**
    * Prepare query string (e.g. strip special characters like negation operator)
    */
   prepareQuery = query => query.replace(SEARCH_SPECIAL_CHARS_REGEXP, '');
 
+  getTagList() {
+    const {organization, tags} = this.props;
+    const fields = organization.features.includes('transaction-events')
+      ? FIELD_TAGS
+      : omit(FIELD_TAGS, TRACING_FIELDS);
+    const combined = assign({}, tags, fields);
+    combined.has = {
+      key: 'has',
+      name: 'Has property',
+      values: Object.keys(combined),
+      predefined: true,
+    };
+
+    return combined;
+  }
+
   render() {
+    const tags = this.getTagList();
     return (
       <ClassNames>
         {({css}) => (
@@ -88,7 +102,7 @@ class SearchBar extends React.PureComponent {
             hasRecentSearches
             savedSearchType={SEARCH_TYPES.EVENT}
             onGetTagValues={this.getEventFieldValues}
-            supportedTags={this.props.tags}
+            supportedTags={tags}
             prepareQuery={this.prepareQuery}
             excludeEnvironment
             dropdownClassName={css`
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/index.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/index.tsx
index 8fc89210fd..d60370adb2 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/index.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/index.tsx
@@ -155,9 +155,7 @@ class Table extends React.PureComponent<TableProps, TableState> {
   }
 }
 
-export default withApi(
-  withTags(Table, {includeEventAttributes: false, includeIssueAttributes: false})
-);
+export default withApi(withTags(Table));
 
 const Container = styled('div')`
   min-width: 0;
diff --git a/src/sentry/static/sentry/app/views/issueList/overview.jsx b/src/sentry/static/sentry/app/views/issueList/overview.jsx
index 0fe597e45c..07a65d62c4 100644
--- a/src/sentry/static/sentry/app/views/issueList/overview.jsx
+++ b/src/sentry/static/sentry/app/views/issueList/overview.jsx
@@ -38,7 +38,7 @@ import withProfiler from 'app/utils/withProfiler';
 import withGlobalSelection from 'app/utils/withGlobalSelection';
 import withOrganization from 'app/utils/withOrganization';
 import withSavedSearches from 'app/utils/withSavedSearches';
-import withTags from 'app/utils/withTags';
+import withIssueTags from 'app/utils/withIssueTags';
 
 import IssueListActions from './actions';
 import IssueListFilters from './filters';
@@ -656,13 +656,6 @@ const IssueListOverview = createReactClass({
 });
 
 export default withGlobalSelection(
-  withSavedSearches(
-    withOrganization(
-      withTags(withProfiler(IssueListOverview), {
-        includeIssueAttributes: true,
-        includeEventAttributes: true,
-      })
-    )
-  )
+  withSavedSearches(withOrganization(withIssueTags(withProfiler(IssueListOverview))))
 );
 export {IssueListOverview};
diff --git a/tests/js/spec/components/smartSearchBar.spec.jsx b/tests/js/spec/components/smartSearchBar.spec.jsx
index 302c1fd5ba..76b9b2b5cb 100644
--- a/tests/js/spec/components/smartSearchBar.spec.jsx
+++ b/tests/js/spec/components/smartSearchBar.spec.jsx
@@ -43,6 +43,10 @@ describe('SmartSearchBar', function() {
     TagStore.onLoadTagsSuccess(TestStubs.Tags());
     tagValuesMock.mockClear();
     supportedTags = TagStore.getAllTags();
+    supportedTags.firstRelease = {
+      key: 'firstRelease',
+      name: 'firstRelease',
+    };
     organization = TestStubs.Organization({id: '123'});
 
     const location = {
diff --git a/tests/js/spec/stores/tagStore.spec.jsx b/tests/js/spec/stores/tagStore.spec.jsx
index 1c4d3a8375..9d4cd29ea6 100644
--- a/tests/js/spec/stores/tagStore.spec.jsx
+++ b/tests/js/spec/stores/tagStore.spec.jsx
@@ -1,5 +1,4 @@
 import TagStore from 'app/stores/tagStore';
-import MemberListStore from 'app/stores/memberListStore';
 
 describe('TagStore', function() {
   beforeEach(() => {
@@ -8,40 +7,6 @@ describe('TagStore', function() {
 
   afterEach(() => {});
 
-  describe('onMemberListStoreChange()', () => {
-    it('should map each user\'s username to the "assigned" value array', () => {
-      jest.spyOn(MemberListStore, 'getAll').mockImplementation(() => [
-        {
-          username: 'janesmith',
-          email: 'janesmith@example.org',
-        },
-      ]);
-      TagStore.onMemberListStoreChange();
-      expect(TagStore.tags.assigned.values).toEqual(['me', 'janesmith']);
-    });
-
-    it("should fall back to email when username isn't available", () => {
-      jest.spyOn(MemberListStore, 'getAll').mockImplementation(() => [
-        {
-          email: 'janesmith@example.org',
-        },
-      ]);
-      TagStore.onMemberListStoreChange();
-      expect(TagStore.tags.assigned.values).toEqual(['me', 'janesmith@example.org']);
-    });
-
-    it('should fall back to email when the username is a UUID', () => {
-      jest.spyOn(MemberListStore, 'getAll').mockImplementation(() => [
-        {
-          username: '8f5c6478172d4389930c12841f45dc18',
-          email: 'janesmith@example.org',
-        },
-      ]);
-      TagStore.onMemberListStoreChange();
-      expect(TagStore.tags.assigned.values).toEqual(['me', 'janesmith@example.org']);
-    });
-  });
-
   describe('onLoadTagsSuccess()', () => {
     it('should add a new tag with empty values and trigger the new addition', () => {
       jest.spyOn(TagStore, 'trigger');
@@ -51,19 +16,47 @@ describe('TagStore', function() {
           key: 'mytag',
           name: 'My Custom Tag',
         },
+        {key: 'other', name: 'Other'},
       ]);
 
-      expect(TagStore.tags.mytag).toEqual({
+      const tags = TagStore.getAllTags();
+      expect(tags.mytag).toEqual({
         key: 'mytag',
         name: 'My Custom Tag',
         values: [],
       });
+      expect(tags.other).toEqual({
+        key: 'other',
+        name: 'Other',
+        values: [],
+      });
 
       expect(TagStore.trigger).toHaveBeenCalledTimes(1);
     });
+  });
+
+  describe('getIssueAttributes()', function() {
+    it('should populate the has tag with values', () => {
+      TagStore.onLoadTagsSuccess([
+        {
+          key: 'mytag',
+          name: 'My Custom Tag',
+        },
+        {
+          key: 'otherkey',
+          name: 'My other tag',
+        },
+      ]);
+
+      expect(TagStore.getIssueAttributes().has).toEqual({
+        key: 'has',
+        name: 'Has Tag',
+        values: ['mytag', 'otherkey'],
+        predefined: true,
+      });
+    });
 
     it('should not overwrite predefined filters', () => {
-      const isTag = TagStore.tags.is;
       TagStore.onLoadTagsSuccess([
         {
           key: 'is',
@@ -71,7 +64,21 @@ describe('TagStore', function() {
         },
       ]);
 
-      expect(TagStore.tags.is).toEqual(isTag);
+      const tags = TagStore.getIssueAttributes();
+      expect(tags.is).toBeTruthy();
+      expect(tags.is.key).toBe('is');
+      expect(tags.assigned).toBeTruthy();
+    });
+  });
+
+  describe('getBuiltInTags()', function() {
+    it('should be a map of built in properties', () => {
+      const tags = TagStore.getBuiltInTags();
+      expect(tags.location).toEqual({
+        key: 'location',
+        name: 'location',
+      });
+      expect(tags.id).toBeUndefined();
     });
   });
 });
diff --git a/tests/js/spec/utils/withIssueTags.spec.jsx b/tests/js/spec/utils/withIssueTags.spec.jsx
new file mode 100644
index 0000000000..1a28cf4a6b
--- /dev/null
+++ b/tests/js/spec/utils/withIssueTags.spec.jsx
@@ -0,0 +1,70 @@
+import React from 'react';
+
+import {mount} from 'sentry-test/enzyme';
+import TagStore from 'app/stores/tagStore';
+import MemberListStore from 'app/stores/memberListStore';
+import withIssueTags from 'app/utils/withIssueTags';
+
+describe('withIssueTags HoC', function() {
+  beforeEach(() => {
+    TagStore.reset();
+    MemberListStore.loadInitialData([]);
+  });
+
+  it('fowards loaded tags to the wrapped component', async function() {
+    const MyComponent = () => null;
+    const Container = withIssueTags(MyComponent);
+    const wrapper = mount(<Container other="value" />);
+
+    // Should forward props.
+    expect(wrapper.find('MyComponent').prop('other')).toEqual('value');
+
+    TagStore.onLoadTagsSuccess([{name: 'Mechanism', key: 'mechanism', count: 1}]);
+    await wrapper.update();
+
+    // Should forward prop
+    expect(wrapper.find('MyComponent').prop('other')).toEqual('value');
+
+    const tagsProp = wrapper.find('MyComponent').prop('tags');
+    // includes custom tags
+    expect(tagsProp.mechanism).toBeTruthy();
+
+    // should include special issue and attributes.
+    expect(tagsProp.is).toBeTruthy();
+    expect(tagsProp.bookmarks).toBeTruthy();
+    expect(tagsProp.assigned).toBeTruthy();
+    expect(tagsProp['stack.filename']).toBeTruthy();
+  });
+
+  it('updates the assigned and bookmark tags with users', async function() {
+    const MyComponent = () => null;
+    const Container = withIssueTags(MyComponent);
+    const wrapper = mount(<Container other="value" />);
+
+    // Should forward props.
+    expect(wrapper.find('MyComponent').prop('other')).toEqual('value');
+
+    TagStore.onLoadTagsSuccess([{name: 'Mechanism', key: 'mechanism', count: 1}]);
+    await wrapper.update();
+
+    let tagsProp = wrapper.find('MyComponent').prop('tags');
+    expect(tagsProp.assigned).toBeTruthy();
+    expect(tagsProp.assigned.values).toEqual(['me']);
+
+    const users = [TestStubs.User(), TestStubs.User({username: 'joe@example.com'})];
+    MemberListStore.loadInitialData(users);
+    await wrapper.update();
+
+    tagsProp = wrapper.find('MyComponent').prop('tags');
+    expect(tagsProp.assigned.values).toEqual([
+      'me',
+      'foo@example.com',
+      'joe@example.com',
+    ]);
+    expect(tagsProp.bookmarks.values).toEqual([
+      'me',
+      'foo@example.com',
+      'joe@example.com',
+    ]);
+  });
+});
diff --git a/tests/js/spec/utils/withTags.spec.jsx b/tests/js/spec/utils/withTags.spec.jsx
index 638f5a87ab..09e5d00792 100644
--- a/tests/js/spec/utils/withTags.spec.jsx
+++ b/tests/js/spec/utils/withTags.spec.jsx
@@ -29,22 +29,4 @@ describe('withTags HoC', function() {
     // excludes issue tags by default
     expect(tagsProp.is).toBeUndefined();
   });
-
-  it('can include issue attributes', async function() {
-    const MyComponent = () => null;
-    const Container = withTags(MyComponent, {includeIssueAttributes: true});
-    const wrapper = mount(<Container other="value" />);
-
-    TagStore.onLoadTagsSuccess([{name: 'Mechanism', key: 'mechanism', count: 1}]);
-    await wrapper.update();
-
-    // Should forward props.
-    expect(wrapper.find('MyComponent').prop('other')).toEqual('value');
-
-    const tagsProp = wrapper.find('MyComponent').prop('tags');
-    // includes custom tags
-    expect(tagsProp.mechanism).toBeTruthy();
-    // includes issue tags
-    expect(tagsProp.is).toBeTruthy();
-  });
 });
diff --git a/tests/js/spec/views/issueList/searchBar.spec.jsx b/tests/js/spec/views/issueList/searchBar.spec.jsx
index f73132703d..a3346a034d 100644
--- a/tests/js/spec/views/issueList/searchBar.spec.jsx
+++ b/tests/js/spec/views/issueList/searchBar.spec.jsx
@@ -20,6 +20,13 @@ describe('IssueListSearchBar', function() {
     TagStore.reset();
     TagStore.onLoadTagsSuccess(TestStubs.Tags());
     supportedTags = TagStore.getAllTags();
+    // Add a tag that is preseeded with values.
+    supportedTags.is = {
+      key: 'is',
+      name: 'is',
+      values: ['assigned', 'unresolved', 'ignored'],
+      predefined: true,
+    };
 
     tagValuePromise = Promise.resolve([]);
 

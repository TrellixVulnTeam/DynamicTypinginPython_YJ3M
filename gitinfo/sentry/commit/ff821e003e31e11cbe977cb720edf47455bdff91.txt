commit ff821e003e31e11cbe977cb720edf47455bdff91
Author: Lauryn Brown <lauryndbrown@gmail.com>
Date:   Tue Jun 18 10:40:58 2019 -0700

    ref(event-search): Changed total values in heatmaps to reflect the current query (#13659)
    
    * Changed total values so that heatmaps will update with total value from the given query.
    
    * Added changes lyn suggested. added ordering to values and categories themselves.
    
    * Redid the pr to better match expectations.
    
    * Added project.name to selected projects example.
    
    * Added test to ensure conditions work as well.
    
    * Added error handling and logging.
    
    * Reveted snuba changes. added deepcopy where needed.
    
    * Added invalid tag check
    
    * moved snuba stuff to tagstore/snuba/logic.py
    
    * Rearranged the functionality into a logic file. Added limit to the non_tag query.
    
    * Changed keys to key.
    
    * changed logic to utils.py
    
    * Raise an error when key is missing.
    
    * Update parameter name to match backend key
    
    * Fix 500 when error.type has multiple values.
    
    This can happen when an SDK reports chained exceptions.
    
    * Remove commented code

diff --git a/src/sentry/api/endpoints/organization_events.py b/src/sentry/api/endpoints/organization_events.py
index c12839e7c0..0d1a2e5776 100644
--- a/src/sentry/api/endpoints/organization_events.py
+++ b/src/sentry/api/endpoints/organization_events.py
@@ -1,29 +1,32 @@
 from __future__ import absolute_import
 
+import logging
+import six
+
 from datetime import timedelta
 from functools import partial
-
 from rest_framework.response import Response
 
 from sentry import tagstore
-from sentry.tagstore.types import TagKey, TagValue
 from sentry.api.bases import OrganizationEventsEndpointBase, OrganizationEventsError, NoProjects
-from sentry.api.exceptions import ResourceDoesNotExist
 from sentry.api.helpers.events import get_direct_hit_response
 from sentry.api.paginator import GenericOffsetPaginator
 from sentry.api.serializers import EventSerializer, serialize, SimpleEventSerializer
 from sentry.api.serializers.snuba import SnubaTSResultSerializer
 from sentry.models import SnubaEvent
+from sentry.tagstore.snuba.utils import lookup_tags
 from sentry.utils.dates import parse_stats_period
 from sentry.utils.snuba import (
     raw_query,
     transform_aliases_and_query,
     SnubaTSResult,
+    SnubaError,
 )
 from sentry import features
 from sentry.models.project import Project
 
 ALLOWED_GROUPINGS = frozenset(('issue.id', 'project.id'))
+logger = logging.getLogger('sentry.api.organization-events')
 
 
 class OrganizationEventsEndpoint(OrganizationEventsEndpointBase):
@@ -89,7 +92,7 @@ class OrganizationEventsEndpoint(OrganizationEventsEndpointBase):
 
             if any(field for field in groupby if field not in ALLOWED_GROUPINGS):
                 message = ('Invalid groupby value requested. Allowed values are ' +
-                    ', '.join(ALLOWED_GROUPINGS))
+                           ', '.join(ALLOWED_GROUPINGS))
                 return Response({'detail': message}, status=400)
 
         except OrganizationEventsError as exc:
@@ -185,7 +188,6 @@ class OrganizationEventsStatsEndpoint(OrganizationEventsEndpointBase):
 
 
 class OrganizationEventsHeatmapEndpoint(OrganizationEventsEndpointBase):
-    NON_TAG_KEYS = frozenset(['project.name'])
 
     def get(self, request, organization):
         try:
@@ -195,17 +197,44 @@ class OrganizationEventsHeatmapEndpoint(OrganizationEventsEndpointBase):
         except NoProjects:
             return Response({'detail': 'A valid project must be included.'}, status=400)
 
-        lookup_keys = []
-        non_tag_lookup_keys = []
-        for key in request.GET.getlist('keys'):
-            if key in self.NON_TAG_KEYS:
-                non_tag_lookup_keys.append(key)
-            lookup_keys.append(tagstore.prefix_reserved_key(key))
+        try:
+            keys = self._validate_keys(request)
+            self._validate_project_ids(request, organization, snuba_args)
+        except OrganizationEventsError as error:
+            return Response({'detail': six.text_type(error)}, status=400)
+
+        try:
+            tags = lookup_tags(keys, **snuba_args)
+        except (KeyError, SnubaError) as error:
+            logger.info(
+                'api.organization-events-heatmap',
+                extra={
+                    'organization_id': organization.id,
+                    'user_id': request.user.id,
+                    'keys': keys,
+                    'snuba_args': snuba_args,
+                    'error': six.text_type(error)
+                }
+            )
+            return Response({
+                'detail': 'Invalid query.'
+            }, status=400)
+
+        return Response(serialize(tags, request.user))
+
+    def _validate_keys(self, request):
+        keys = request.GET.getlist('key')
+        if not keys:
+            raise OrganizationEventsError('Tag keys must be specified.')
+
+        for key in keys:
+            if not tagstore.is_valid_key(key):
+                raise OrganizationEventsError('Tag key %s is not valid.' % key)
+
+        return keys
 
-        if not lookup_keys:
-            return Response({'detail': 'Tag keys must be specified.'}, status=400)
+    def _validate_project_ids(self, request, organization, snuba_args):
         project_ids = snuba_args['filter_keys']['project_id']
-        environment_ids = snuba_args['filter_keys'].get('environment_id')
 
         has_global_views = features.has(
             'organizations:global-views',
@@ -213,69 +242,9 @@ class OrganizationEventsHeatmapEndpoint(OrganizationEventsEndpointBase):
             actor=request.user)
 
         if not has_global_views and len(project_ids) > 1:
-            return Response({
-                'detail': 'You cannot view events from multiple projects.'
-            }, status=400)
-
-        try:
-            tag_keys = tagstore.get_group_tag_keys_and_top_values(
-                project_ids, None, environment_ids, keys=lookup_keys, get_excluded_tags=True, **snuba_args)
-        except tagstore.TagKeyNotFound:
-            raise ResourceDoesNotExist
+            raise OrganizationEventsError('You cannot view events from multiple projects.')
 
-        if non_tag_lookup_keys:
-            tag_keys.update(self.handle_non_tag_keys(non_tag_lookup_keys, snuba_args))
-
-        return Response(serialize(tag_keys, request.user))
-
-    def handle_non_tag_keys(self, keys, snuba_args):
-        result = set([])
-        for key in keys:
-            if key == 'project.name':
-                data = self._query_non_tag_data('project_id', snuba_args)
-                projects = Project.objects.filter(id__in=snuba_args['filter_keys']['project_id'])
-                for project_data in data:
-                    project = projects.filter(id=project_data['project_id'])[0]
-                    project_data['key'] = 'project.name'
-                    project_data['value'] = project.slug
-            result.add(self._create_tag_key_tag_value_objects('project', data))
-        return result
-
-    def _query_non_tag_data(self, key, snuba_args):
-        data = raw_query(
-            groupby=[key],
-            aggregations=snuba_args.get('aggregations', []) + [
-                ['count()', '', 'count'],
-                ['min', 'timestamp', 'first_seen'],
-                ['max', 'timestamp', 'last_seen'],
-                ['uniq', key, 'values_seen'],
-            ],
-            orderby='-count',
-            referrer='api.organization-events-heatmap',
-            **snuba_args
-        )['data']
-        return data
-
-    def _create_tag_key_tag_value_objects(self, key, data):
-        tag_values = []
-        values_seen = 0
-        for datum in data:
-            tag_values.append(TagValue(
-                key=key,
-                value=datum['value'],
-                times_seen=datum['count'],
-                last_seen=datum['last_seen'],
-                first_seen=datum['first_seen'],
-            ))
-            values_seen += datum['count']
-
-        tag_key = TagKey(
-            key=key,
-            values_seen=len(tag_values),
-            count=values_seen,
-            top_values=tag_values,
-        )
-        return tag_key
+        return project_ids
 
 
 class OrganizationEventsMetaEndpoint(OrganizationEventsEndpointBase):
diff --git a/src/sentry/static/sentry/app/views/organizationEventsV2/utils.jsx b/src/sentry/static/sentry/app/views/organizationEventsV2/utils.jsx
index 904d75b7ad..d3d3e16e29 100644
--- a/src/sentry/static/sentry/app/views/organizationEventsV2/utils.jsx
+++ b/src/sentry/static/sentry/app/views/organizationEventsV2/utils.jsx
@@ -105,7 +105,7 @@ export function fetchTags(api, orgSlug, tagList, query) {
 
   return api
     .requestPromise(`/organizations/${orgSlug}/events-heatmap/`, {
-      query: {...urlParams, keys: tagList, query: query.query},
+      query: {...urlParams, key: tagList, query: query.query},
     })
     .then(resp => {
       const tags = {};
diff --git a/src/sentry/tagstore/snuba/utils.py b/src/sentry/tagstore/snuba/utils.py
new file mode 100644
index 0000000000..4c7e2c3c30
--- /dev/null
+++ b/src/sentry/tagstore/snuba/utils.py
@@ -0,0 +1,164 @@
+from __future__ import absolute_import
+
+from collections import OrderedDict
+from copy import deepcopy
+
+from sentry import tagstore
+from sentry.models import Project
+from sentry.tagstore.types import TagKey, TagValue
+from sentry.tagstore.base import TOP_VALUES_DEFAULT_LIMIT
+from sentry.utils.snuba import (
+    raw_query,
+    SENTRY_SNUBA_MAP,
+)
+
+NON_TAG_KEYS = SENTRY_SNUBA_MAP.copy()
+NON_TAG_KEYS.update({'project.name': 'project_id'})
+
+
+def lookup_tags(keys, **snuba_args):
+    tag_keys = []
+    non_tag_keys = []
+
+    for key in keys:
+        if key in NON_TAG_KEYS:
+            non_tag_keys.append(key)
+        else:
+            tag_keys.append(tagstore.prefix_reserved_key(key))
+
+    if tag_keys:
+        top_values = get_top_values(keys=tag_keys, **snuba_args)
+    else:
+        top_values = []
+
+    if non_tag_keys:
+        handle_non_tag_keys(non_tag_keys, top_values, **snuba_args)
+
+    total_count = get_total_value_count(**snuba_args)
+    tag_keys = create_tag_objects(keys, total_count, top_values)
+
+    # sort heatmap categories in the same order requested.
+    tag_keys = sorted(tag_keys, key=lambda x: keys.index(x.key))
+    return tag_keys
+
+
+def handle_non_tag_keys(keys, top_values, **kwargs):
+    for key in keys:
+        data = query_non_tag_data(NON_TAG_KEYS[key], **kwargs)
+
+        if key == 'project.name':
+            projects = Project.objects.filter(id__in=kwargs['filter_keys']['project_id'])
+            for value in data:
+                project_slug = projects.filter(id=value['project_id'])[0].slug
+                value['tags_value'] = project_slug
+                value['tags_key'] = key
+        else:
+            for value in data:
+                tag_value = value[NON_TAG_KEYS[key]]
+                # If we have multiple values take the last one.
+                # This happens most commonly with error.type and chained
+                # exceptions.
+                if isinstance(tag_value, list):
+                    tag_value = tag_value[-1]
+                value['tags_key'] = key
+                value['tags_value'] = tag_value
+
+        top_values += data
+
+    # order combined values by count
+    top_values = sorted(top_values, key=lambda x: x['count'])
+    return top_values
+
+
+def query_non_tag_data(key, value_limit=TOP_VALUES_DEFAULT_LIMIT, **kwargs):
+    kwargs = deepcopy(kwargs)
+    data = raw_query(
+        groupby=[key],
+        conditions=kwargs.pop('conditions', []) + [
+            [['isNotNull', [key]], '=', 1]
+        ],
+        aggregations=kwargs.pop('aggregations', []) + [
+            ['count()', '', 'count'],
+            ['min', 'timestamp', 'first_seen'],
+            ['max', 'timestamp', 'last_seen'],
+        ],
+        orderby='-count',
+        referrer='api.organization-events-heatmap',
+        limit=value_limit,
+        **kwargs
+    )
+
+    return data['data']
+
+
+def create_tag_objects(keys, total_count, top_values):
+    tag_keys_dict = OrderedDict()
+
+    for top_value in top_values:
+        key = top_value['tags_key']
+
+        if key not in tag_keys_dict:
+            tag_keys_dict[key] = TagKey(
+                key=key,
+                top_values=[],
+                count=total_count,
+            )
+        tag_keys_dict[key].top_values.append(
+            TagValue(
+                key=key,
+                value=top_value['tags_value'],
+                times_seen=top_value['count'],
+                first_seen=top_value['first_seen'],
+                last_seen=top_value['last_seen'],
+            )
+        )
+
+    # Add categories with no values
+    for key in keys:
+        if key not in tag_keys_dict:
+            tag_keys_dict[key] = TagKey(
+                key=key,
+                top_values=[],
+                count=total_count,
+            )
+    return tag_keys_dict.values()
+
+
+def get_total_value_count(**kwargs):
+    kwargs = deepcopy(kwargs)
+    aggregations = kwargs.pop('aggregations', [])
+    aggregations += [
+        ['count()', '', 'count'],
+    ]
+
+    total_count = raw_query(
+        aggregations=aggregations,
+        referrer='api.organization-events-heatmap',
+        **kwargs
+    )['data'][0]['count']
+    return total_count
+
+
+def get_top_values(keys, value_limit=TOP_VALUES_DEFAULT_LIMIT, **kwargs):
+
+    kwargs = deepcopy(kwargs)
+    filters = kwargs.pop('filter_keys', {})
+    filters['tags_key'] = keys
+
+    aggregations = kwargs.pop('aggregations', [])
+    aggregations += [
+        ['count()', '', 'count'],
+        ['min', 'timestamp', 'first_seen'],
+        ['max', 'timestamp', 'last_seen'],
+    ]
+
+    values = raw_query(
+        groupby=['tags_key', 'tags_value'],
+        filter_keys=filters,
+        aggregations=aggregations,
+        orderby='-count',
+        limitby=[value_limit, 'tags_key'],
+        referrer='api.organization-events-heatmap',
+        **kwargs
+    )
+    return values['data']
diff --git a/src/sentry/utils/snuba.py b/src/sentry/utils/snuba.py
index a1b9bac25d..67b095536d 100644
--- a/src/sentry/utils/snuba.py
+++ b/src/sentry/utils/snuba.py
@@ -4,6 +4,7 @@ from collections import (
     namedtuple,
     OrderedDict,
 )
+from copy import deepcopy
 from contextlib import contextmanager
 from datetime import datetime, timedelta
 from dateutil.parser import parse as parse_datetime
@@ -548,7 +549,7 @@ def raw_query(start, end, groupby=None, conditions=None, filter_keys=None,
     else:
         project_ids = []
 
-    for col, keys in six.iteritems(forward(filter_keys.copy())):
+    for col, keys in six.iteritems(forward(deepcopy(filter_keys))):
         if keys:
             if len(keys) == 1 and None in keys:
                 conditions.append((col, 'IS NULL', None))
diff --git a/tests/snuba/api/endpoints/test_organization_events.py b/tests/snuba/api/endpoints/test_organization_events.py
index deb81528dc..80b289077a 100644
--- a/tests/snuba/api/endpoints/test_organization_events.py
+++ b/tests/snuba/api/endpoints/test_organization_events.py
@@ -7,6 +7,7 @@ from django.utils import timezone
 from django.core.urlresolvers import reverse
 from uuid import uuid4
 
+from sentry.tagstore.base import TOP_VALUES_DEFAULT_LIMIT
 from sentry.testutils import APITestCase, SnubaTestCase
 
 
@@ -822,13 +823,14 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
             }
         )
         self.min_ago = self.min_ago.replace(microsecond=0)
+        self.min_ago_iso = self.min_ago.isoformat()
         self.day_ago = self.day_ago.replace(microsecond=0)
 
     def test_simple(self):
         self.store_event(
             data={
                 'event_id': uuid4().hex,
-                'timestamp': self.min_ago.isoformat(),
+                'timestamp': self.min_ago_iso,
                 'tags': {'color': 'green'},
             },
             project_id=self.project.id
@@ -836,7 +838,7 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
         self.store_event(
             data={
                 'event_id': uuid4().hex,
-                'timestamp': self.min_ago.isoformat(),
+                'timestamp': self.min_ago_iso,
                 'tags': {'number': 'one'},
             },
             project_id=self.project2.id
@@ -844,7 +846,7 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
         self.store_event(
             data={
                 'event_id': uuid4().hex,
-                'timestamp': self.min_ago.isoformat(),
+                'timestamp': self.min_ago_iso,
                 'tags': {'color': 'green'},
             },
             project_id=self.project.id
@@ -852,52 +854,52 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
         self.store_event(
             data={
                 'event_id': uuid4().hex,
-                'timestamp': self.min_ago.isoformat(),
+                'timestamp': self.min_ago_iso,
                 'tags': {'color': 'red'},
             },
             project_id=self.project.id
         )
 
         with self.feature('organizations:global-views'):
-            response = self.client.get(self.url, {'keys': ['color', 'number']}, format='json')
+            response = self.client.get(self.url, {'key': ['number', 'color']}, format='json')
 
         assert response.status_code == 200, response.content
         assert len(response.data) == 2
-        response.data[0] == {
+        assert response.data[0] == {
             'topValues': [
                 {
                     'count': 1,
                     'name': 'one',
                     'value': 'one',
-                    'lastSeen': self.min_ago,
+                    'lastSeen': self.min_ago_iso,
                     'key': 'number',
-                    'firstSeen': self.min_ago
+                    'firstSeen': self.min_ago_iso
                 }
             ],
-            'totalValues': 1,
+            'totalValues': 4,
             'name': 'Number',
             'key': 'number'
         }
-        response.data[1] == {
+        assert response.data[1] == {
             'topValues': [
                 {
                     'count': 2,
                     'name': 'green',
                     'value': 'green',
-                    'lastSeen': self.min_ago,
+                    'lastSeen': self.min_ago_iso,
                     'key': 'color',
-                    'firstSeen': self.min_ago
+                    'firstSeen': self.min_ago_iso
                 },
                 {
                     'count': 1,
                     'name': 'red',
                     'value': 'red',
-                    'lastSeen': self.min_ago,
+                    'lastSeen': self.min_ago_iso,
                     'key': 'color',
-                    'firstSeen': self.min_ago
+                    'firstSeen': self.min_ago_iso
                 }
             ],
-            'totalValues': 3,
+            'totalValues': 4,
             'name': 'Color',
             'key': 'color'
         }
@@ -906,7 +908,7 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
         self.store_event(
             data={
                 'event_id': uuid4().hex,
-                'timestamp': self.min_ago.isoformat(),
+                'timestamp': self.min_ago_iso,
                 'tags': {'world': 'hello'},
             },
             project_id=self.project.id
@@ -914,7 +916,7 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
         self.store_event(
             data={
                 'event_id': uuid4().hex,
-                'timestamp': self.min_ago.isoformat(),
+                'timestamp': self.min_ago_iso,
                 'tags': {'color': 'yellow'},
             },
             project_id=self.project.id
@@ -922,7 +924,7 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
         self.store_event(
             data={
                 'event_id': uuid4().hex,
-                'timestamp': self.min_ago.isoformat(),
+                'timestamp': self.min_ago_iso,
                 'tags': {'color': 'red'},
             },
             project_id=self.project2.id
@@ -930,14 +932,14 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
         self.store_event(
             data={
                 'event_id': uuid4().hex,
-                'timestamp': self.min_ago.isoformat(),
+                'timestamp': self.min_ago_iso,
                 'tags': {'color': 'yellow'},
             },
             project_id=self.project.id
         )
 
         with self.feature('organizations:global-views'):
-            response = self.client.get(self.url, {'keys': ['color']}, format='json')
+            response = self.client.get(self.url, {'key': ['color']}, format='json')
         assert response.status_code == 200, response.content
         assert len(response.data) == 1
         assert response.data[0] == {
@@ -946,29 +948,29 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
                     'count': 2,
                     'name': 'yellow',
                     'value': 'yellow',
-                    'lastSeen': self.min_ago,
+                    'lastSeen': self.min_ago_iso,
                     'key': 'color',
-                    'firstSeen': self.min_ago
+                    'firstSeen': self.min_ago_iso
                 },
                 {
                     'count': 1,
                     'name': 'red',
                     'value': 'red',
-                    'lastSeen': self.min_ago,
+                    'lastSeen': self.min_ago_iso,
                     'key': 'color',
-                    'firstSeen': self.min_ago
+                    'firstSeen': self.min_ago_iso
                 }
             ],
-            'totalValues': 3,
+            'totalValues': 4,
             'name': 'Color',
             'key': 'color'
         }
 
-    def test_with_query(self):
+    def test_with_message_query(self):
         self.store_event(
             data={
                 'event_id': uuid4().hex,
-                'timestamp': self.min_ago.isoformat(),
+                'timestamp': self.min_ago_iso,
                 'message': 'how to make fast',
                 'tags': {'color': 'green'},
             },
@@ -977,7 +979,7 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
         self.store_event(
             data={
                 'event_id': uuid4().hex,
-                'timestamp': self.min_ago.isoformat(),
+                'timestamp': self.min_ago_iso,
                 'message': 'Delet the Data',
                 'tags': {'color': 'red'},
             },
@@ -986,7 +988,7 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
         self.store_event(
             data={
                 'event_id': uuid4().hex,
-                'timestamp': self.min_ago.isoformat(),
+                'timestamp': self.min_ago_iso,
                 'message': 'Data the Delet ',
                 'tags': {'color': 'yellow'},
             },
@@ -996,34 +998,104 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
         with self.feature('organizations:global-views'):
             response = self.client.get(
                 self.url, {
-                    'query': 'delet', 'keys': ['color']}, format='json')
+                    'query': 'delet', 'key': ['color']}, format='json')
 
         assert response.status_code == 200, response.content
         assert len(response.data) == 1
+
         assert response.data[0] == {
             'topValues': [
                 {
                     'count': 1,
                     'name': 'yellow',
                     'value': 'yellow',
-                    'lastSeen': self.min_ago,
+                    'lastSeen': self.min_ago_iso,
                     'key': 'color',
-                    'firstSeen': self.min_ago
+                    'firstSeen': self.min_ago_iso
                 },
                 {
                     'count': 1,
                     'name': 'red',
                     'value': 'red',
-                    'lastSeen': self.min_ago,
+                    'lastSeen': self.min_ago_iso,
                     'key': 'color',
-                    'firstSeen': self.min_ago
+                    'firstSeen': self.min_ago_iso
                 }
             ],
-            'totalValues': 3,
+            'totalValues': 2,
             'name': 'Color',
             'key': 'color'
         }
 
+    def test_with_condition(self):
+        self.store_event(
+            data={
+                'event_id': uuid4().hex,
+                'timestamp': self.min_ago_iso,
+                'message': 'how to make fast',
+                'tags': {'color': 'green'},
+            },
+            project_id=self.project.id
+        )
+        self.store_event(
+            data={
+                'event_id': uuid4().hex,
+                'timestamp': self.min_ago_iso,
+                'message': 'Delet the Data',
+                'tags': {'color': 'red'},
+            },
+            project_id=self.project.id
+        )
+        self.store_event(
+            data={
+                'event_id': uuid4().hex,
+                'timestamp': self.min_ago_iso,
+                'message': 'Data the Delet ',
+                'tags': {'color': 'yellow'},
+            },
+            project_id=self.project2.id
+        )
+
+        with self.feature('organizations:global-views'):
+            response = self.client.get(
+                self.url, {
+                    'query': 'color:yellow', 'key': ['color', 'project.name']}, format='json')
+
+        assert response.status_code == 200, response.content
+        assert len(response.data) == 2
+
+        assert response.data[0] == {
+            'topValues': [
+                {
+                    'count': 1,
+                    'name': 'yellow',
+                    'value': 'yellow',
+                    'lastSeen': self.min_ago_iso,
+                    'key': 'color',
+                    'firstSeen': self.min_ago_iso
+                },
+            ],
+            'totalValues': 1,
+            'name': 'Color',
+            'key': 'color'
+        }
+
+        assert response.data[1] == {
+            'topValues': [
+                {
+                    'count': 1,
+                    'name': self.project2.slug,
+                    'value': self.project2.slug,
+                    'lastSeen': self.min_ago_iso,
+                    'key': 'project.name',
+                    'firstSeen': self.min_ago_iso
+                }
+            ],
+            'totalValues': 1,
+            'name': 'Project.Name',
+            'key': 'project.name'
+        }
+
     def test_start_end(self):
         two_days_ago = self.day_ago - timedelta(days=1)
         hour_ago = self.min_ago - timedelta(hours=1)
@@ -1068,7 +1140,7 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
                 {
                     'start': self.day_ago.isoformat()[:19],
                     'end': self.min_ago.isoformat()[:19],
-                    'keys': ['color'],
+                    'key': ['color'],
                 },
                 format='json'
             )
@@ -1081,9 +1153,9 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
                     'count': 2,
                     'name': 'red',
                     'value': 'red',
-                    'lastSeen': hour_ago,
+                    'lastSeen': hour_ago.isoformat(),
                     'key': 'color',
-                    'firstSeen': two_hours_ago
+                    'firstSeen': two_hours_ago.isoformat()
                 }
             ],
             'totalValues': 2,
@@ -1122,7 +1194,7 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
         response = self.client.get(
             self.url,
             {
-                'keys': ['user'],
+                'key': ['user'],
                 'project': [self.project.id]
             },
             format='json'
@@ -1136,17 +1208,17 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
                     'count': 2,
                     'name': self.user2.email,
                     'value': self.user2.email,
-                    'lastSeen': self.day_ago,
+                    'lastSeen': self.day_ago.isoformat(),
                     'key': 'user',
-                    'firstSeen': self.day_ago
+                    'firstSeen': self.day_ago.isoformat()
                 },
                 {
                     'count': 1,
                     'name': self.user.email,
                     'value': self.user.email,
-                    'lastSeen': self.day_ago,
+                    'lastSeen': self.day_ago.isoformat(),
                     'key': 'user',
-                    'firstSeen': self.day_ago
+                    'firstSeen': self.day_ago.isoformat()
                 }
             ],
             'totalValues': 3,
@@ -1162,10 +1234,15 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
                 'organization_slug': org.slug,
             }
         )
-        response = self.client.get(url, {'keys': ['color']}, format='json')
+        response = self.client.get(url, {'key': ['color']}, format='json')
         assert response.status_code == 400, response.content
         assert response.data == {'detail': 'A valid project must be included.'}
 
+    def test_no_key_param(self):
+        response = self.client.get(self.url, {'project': [self.project.id]}, format='json')
+        assert response.status_code == 400, response.content
+        assert response.data == {'detail': 'Tag keys must be specified.'}
+
     def test_multiple_projects_without_global_view(self):
         self.store_event(
             data={
@@ -1180,15 +1257,80 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
             project_id=self.project2.id
         )
 
-        response = self.client.get(self.url, {'keys': ['color']}, format='json')
+        response = self.client.get(self.url, {'key': ['color']}, format='json')
         assert response.status_code == 400, response.content
         assert response.data == {'detail': 'You cannot view events from multiple projects.'}
 
+    def test_project_selected(self):
+        self.store_event(
+            data={
+                'event_id': uuid4().hex,
+                'timestamp': self.min_ago_iso,
+                'tags': {'color': 'green'},
+            },
+            project_id=self.project.id
+        )
+        self.store_event(
+            data={
+                'event_id': uuid4().hex,
+                'timestamp': self.min_ago_iso,
+                'tags': {'number': 'one'},
+            },
+            project_id=self.project2.id
+        )
+
+        with self.feature('organizations:global-views'):
+            response = self.client.get(
+                self.url, {
+                    'key': [
+                        'number', 'color', 'project.name'], 'project': [
+                        self.project.id]}, format='json')
+
+        assert response.status_code == 200, response.content
+        assert len(response.data) == 3
+        assert response.data[0] == {
+            'topValues': [],
+            'totalValues': 1,
+            'name': 'Number',
+            'key': 'number'
+        }
+        assert response.data[1] == {
+            'topValues': [
+                {
+                    'count': 1,
+                    'name': 'green',
+                    'value': 'green',
+                    'lastSeen': self.min_ago_iso,
+                    'key': 'color',
+                    'firstSeen': self.min_ago_iso
+                },
+            ],
+            'totalValues': 1,
+            'name': 'Color',
+            'key': 'color'
+        }
+
+        assert response.data[2] == {
+            'topValues': [
+                {
+                    'count': 1,
+                    'name': self.project.slug,
+                    'value': self.project.slug,
+                    'lastSeen': self.min_ago_iso,
+                    'key': 'project.name',
+                    'firstSeen': self.min_ago_iso
+                },
+            ],
+            'totalValues': 1,
+            'name': 'Project.Name',
+            'key': 'project.name'
+        }
+
     def test_project_key(self):
         self.store_event(
             data={
                 'event_id': uuid4().hex,
-                'timestamp': self.min_ago.isoformat(),
+                'timestamp': self.min_ago_iso,
                 'tags': {'color': 'green'},
             },
             project_id=self.project.id
@@ -1196,7 +1338,7 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
         self.store_event(
             data={
                 'event_id': uuid4().hex,
-                'timestamp': self.min_ago.isoformat(),
+                'timestamp': self.min_ago_iso,
                 'tags': {'number': 'one'},
             },
             project_id=self.project2.id
@@ -1204,7 +1346,7 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
         self.store_event(
             data={
                 'event_id': uuid4().hex,
-                'timestamp': self.min_ago.isoformat(),
+                'timestamp': self.min_ago_iso,
                 'tags': {'color': 'green'},
             },
             project_id=self.project.id
@@ -1212,7 +1354,7 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
         self.store_event(
             data={
                 'event_id': uuid4().hex,
-                'timestamp': self.min_ago.isoformat(),
+                'timestamp': self.min_ago_iso,
                 'tags': {'color': 'red'},
             },
             project_id=self.project.id
@@ -1221,74 +1363,298 @@ class OrganizationEventsHeatmapEndpointTest(OrganizationEventsTestBase):
         with self.feature('organizations:global-views'):
             response = self.client.get(
                 self.url, {
-                    'keys': [
-                        'color', 'number', 'project.name']}, format='json')
+                    'key': [
+                        'project.name', 'number', 'color']}, format='json')
 
         assert response.status_code == 200, response.content
         assert len(response.data) == 3
-        response.data[0] == {
+        assert response.data[0] == {
             'topValues': [
                 {
                     'count': 3,
                     'name': self.project.slug,
                     'value': self.project.slug,
-                    'lastSeen': self.min_ago,
-                    'key': 'project',
-                    'firstSeen': self.min_ago
+                    'lastSeen': self.min_ago_iso,
+                    'key': 'project.name',
+                    'firstSeen': self.min_ago_iso
                 },
                 {
                     'count': 1,
                     'name': self.project2.slug,
                     'value': self.project2.slug,
-                    'lastSeen': self.min_ago,
-                    'key': 'project',
-                    'firstSeen': self.min_ago
+                    'lastSeen': self.min_ago_iso,
+                    'key': 'project.name',
+                    'firstSeen': self.min_ago_iso
                 }
             ],
             'totalValues': 4,
-            'uniqueValues': 2,
-            'name': 'Project',
-            'key': 'project'
+            'name': 'Project.Name',
+            'key': 'project.name'
         }
-        response.data[1] == {
+        assert response.data[1] == {
             'topValues': [
                 {
                     'count': 1,
                     'name': 'one',
                     'value': 'one',
-                    'lastSeen': self.min_ago,
+                    'lastSeen': self.min_ago_iso,
                     'key': 'number',
-                    'firstSeen': self.min_ago
+                    'firstSeen': self.min_ago_iso
                 }
             ],
-            'totalValues': 1,
+            'totalValues': 4,
             'name': 'Number',
             'key': 'number'
         }
-        response.data[2] == {
+        assert response.data[2] == {
             'topValues': [
                 {
                     'count': 2,
                     'name': 'green',
                     'value': 'green',
-                    'lastSeen': self.min_ago,
+                    'lastSeen': self.min_ago_iso,
                     'key': 'color',
-                    'firstSeen': self.min_ago
+                    'firstSeen': self.min_ago_iso
                 },
                 {
                     'count': 1,
                     'name': 'red',
                     'value': 'red',
-                    'lastSeen': self.min_ago,
+                    'lastSeen': self.min_ago_iso,
                     'key': 'color',
-                    'firstSeen': self.min_ago
+                    'firstSeen': self.min_ago_iso
                 }
             ],
-            'totalValues': 3,
+            'totalValues': 4,
             'name': 'Color',
             'key': 'color'
         }
 
+    def test_non_tag_key(self):
+        user1 = {
+            'id': '1',
+            'ip_address': '127.0.0.1',
+            'email': 'foo@example.com',
+            'username': 'foo',
+        }
+        user2 = {
+            'id': '2',
+            'ip_address': '127.0.0.2',
+            'email': 'bar@example.com',
+            'username': 'bar',
+        }
+        self.store_event(
+            data={
+                'event_id': uuid4().hex,
+                'timestamp': self.min_ago_iso,
+                'user': user1,
+            },
+            project_id=self.project.id
+        )
+        self.store_event(
+            data={
+                'event_id': uuid4().hex,
+                'timestamp': self.min_ago_iso,
+                'tags': {'color': 'green'},
+                'user': user2,
+            },
+            project_id=self.project2.id
+        )
+        self.store_event(
+            data={
+                'event_id': uuid4().hex,
+                'timestamp': self.min_ago_iso,
+                'tags': {'color': 'green'},
+            },
+            project_id=self.project.id
+        )
+        self.store_event(
+            data={
+                'event_id': uuid4().hex,
+                'timestamp': self.min_ago_iso,
+                'tags': {'color': 'red'},
+                'user': user1,
+            },
+            project_id=self.project.id
+        )
+
+        with self.feature('organizations:global-views'):
+            response = self.client.get(
+                self.url, {
+                    'key': [
+                        'user.email', 'user.ip']}, format='json')
+
+        assert response.status_code == 200, response.content
+        assert len(response.data) == 2
+
+        assert response.data[0] == {
+            'topValues': [
+                {
+                    'count': 2,
+                    'name': user1['email'],
+                    'value': user1['email'],
+                    'lastSeen': self.min_ago_iso,
+                    'key': 'user.email',
+                    'firstSeen': self.min_ago_iso
+                },
+                {
+                    'count': 1,
+                    'name': user2['email'],
+                    'value': user2['email'],
+                    'lastSeen': self.min_ago_iso,
+                    'key': 'user.email',
+                    'firstSeen': self.min_ago_iso
+                }
+            ],
+            'totalValues': 4,
+            'name': 'User.Email',
+            'key': 'user.email'
+        }
+        assert response.data[1] == {
+            'topValues': [
+                {
+                    'count': 2,
+                    'name': user1['ip_address'],
+                    'value': user1['ip_address'],
+                    'lastSeen': self.min_ago_iso,
+                    'key': 'user.ip',
+                    'firstSeen': self.min_ago_iso
+                },
+                {
+                    'count': 1,
+                    'name': user2['ip_address'],
+                    'value': user2['ip_address'],
+                    'lastSeen': self.min_ago_iso,
+                    'key': 'user.ip',
+                    'firstSeen': self.min_ago_iso
+                },
+            ],
+            'totalValues': 4,
+            'name': 'User.Ip',
+            'key': 'user.ip'
+        }
+
+    def test_non_tag_key__multiple_values(self):
+        frame = {
+            'filename': 'server.php',
+            'lineno': 21,
+            'in_app': True,
+        }
+
+        # Check that error.type works with chained exceptions
+        # as they create multiple results for exception_stacks.type
+        self.store_event(
+            data={
+                'event_id': uuid4().hex,
+                'timestamp': self.min_ago_iso,
+                'exception': {
+                    'values': [
+                        {'type': 'PDOException', 'stacktrace': {
+                            'frames': [frame]}, 'value': 'Database error'},
+                        {'type': 'QueryException', 'stacktrace': {
+                            'frames': [frame]}, 'value': 'Query failed'},
+                    ]
+                }
+            },
+            project_id=self.project.id
+        )
+
+        response = self.client.get(
+            self.url,
+            {'key': ['error.type'], 'project': [self.project.id]},
+            format='json')
+
+        assert response.status_code == 200, response.content
+        assert len(response.data) == 1
+
+        assert response.data[0] == {
+            'topValues': [
+                {
+                    'count': 1,
+                    'name': 'QueryException',
+                    'value': 'QueryException',
+                    'lastSeen': self.min_ago_iso,
+                    'key': 'error.type',
+                    'firstSeen': self.min_ago_iso
+                },
+            ],
+            'totalValues': 1,
+            'name': 'Error.Type',
+            'key': 'error.type'
+        }
+
+    def test_value_limit(self):
+        for i in range(0, 12):
+            self.store_event(
+                data={
+                    'event_id': uuid4().hex,
+                    'timestamp': self.min_ago_iso,
+                    'tags': {'color': 'color%d' % i}
+                },
+                project_id=self.create_project().id
+            )
+        self.store_event(
+            data={
+                'event_id': uuid4().hex,
+                'timestamp': self.min_ago_iso,
+                'tags': {'color': 'yellow'}
+            },
+            project_id=self.project2.id
+        )
+        self.store_event(
+            data={
+                'event_id': uuid4().hex,
+                'timestamp': self.min_ago_iso,
+                'tags': {'color': 'yellow'}
+            },
+            project_id=self.project2.id
+        )
+        with self.feature('organizations:global-views'):
+            response = self.client.get(
+                self.url, {
+                    'key': ['project.name', 'color']}, format='json')
+
+        assert response.status_code == 200, response.content
+        assert len(response.data) == 2
+        assert len(response.data[0]['topValues']) == TOP_VALUES_DEFAULT_LIMIT
+        assert response.data[0]['topValues'][0] == {
+            'count': 2, 'name': self.project2.slug, 'value': self.project2.slug,
+            'lastSeen': self.min_ago_iso, 'key': 'project.name', 'firstSeen': self.min_ago_iso
+        }
+        assert len(response.data[1]['topValues']) == TOP_VALUES_DEFAULT_LIMIT
+        assert response.data[1]['topValues'][0] == {
+            'count': 2, 'name': 'yellow', 'value': 'yellow',
+            'lastSeen': self.min_ago_iso, 'key': 'color', 'firstSeen': self.min_ago_iso
+        }
+
+    def test_malformed_query(self):
+        self.store_event(
+            data={
+                'event_id': uuid4().hex,
+            },
+            project_id=self.project.id
+        )
+        self.store_event(
+            data={
+                'event_id': uuid4().hex,
+            },
+            project_id=self.project2.id
+        )
+
+        response = self.client.get(
+            self.url, {
+                'key': ['color'], 'query': '\n\n\n\n'}, format='json')
+        assert response.status_code == 400, response.content
+        assert response.data == {
+            'detail': "Parse error: 'search' (column 1). This is commonly caused by unmatched-parentheses. Enclose any text in double quotes."}
+
+    def test_invalid_tag(self):
+        response = self.client.get(
+            self.url, {
+                'key': ['color;;;']}, format='json')
+        assert response.status_code == 400, response.content
+        assert response.data == {'detail': "Tag key color;;; is not valid."}
+
 
 class OrganizationEventsMetaEndpoint(OrganizationEventsTestBase):
     def test_simple(self):

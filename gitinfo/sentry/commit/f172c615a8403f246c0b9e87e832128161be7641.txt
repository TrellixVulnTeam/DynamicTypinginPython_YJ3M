commit f172c615a8403f246c0b9e87e832128161be7641
Author: Dan Fuller <dfuller@sentry.io>
Date:   Wed May 6 10:15:12 2020 -0700

    refs(alerts): Change internal metric alerts code to handle only a single environment. (#18563)
    
    This restricts us to selecting only a single environment for an alert rule.
    
    Depends on https://github.com/getsentry/sentry/pull/18555

diff --git a/src/sentry/incidents/endpoints/serializers.py b/src/sentry/incidents/endpoints/serializers.py
index 80204cebc6..de55b07764 100644
--- a/src/sentry/incidents/endpoints/serializers.py
+++ b/src/sentry/incidents/endpoints/serializers.py
@@ -9,6 +9,7 @@ from rest_framework import serializers
 from django.db import transaction
 
 from sentry.api.serializers.rest_framework.base import CamelSnakeModelSerializer
+from sentry.api.serializers.rest_framework.environment import EnvironmentField
 from sentry.api.serializers.rest_framework.project import ProjectField
 from sentry.incidents.logic import (
     AlertRuleNameAlreadyUsedError,
@@ -29,7 +30,6 @@ from sentry.incidents.models import (
     AlertRuleTrigger,
     AlertRuleTriggerAction,
 )
-from sentry.models.environment import Environment
 from sentry.models.organizationmember import OrganizationMember
 from sentry.models.team import Team
 from sentry.models.user import User
@@ -268,7 +268,7 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
      - `access`: An access object (from `request.access`)
     """
 
-    environment = ObjectField(required=False)
+    environment = EnvironmentField(required=False)
     # TODO: These might be slow for many projects, since it will query for each
     # individually. If we find this to be a problem then we can look into batching.
     projects = serializers.ListField(child=ProjectField(), required=False)
@@ -311,21 +311,6 @@ class AlertRuleSerializer(CamelSnakeModelSerializer):
                 % [item.value for item in QueryAggregations]
             )
 
-    def validate_environment(self, environment):
-        def convert_to_environment(env_name):
-            try:
-                return Environment.objects.get(
-                    organization_id=self.context["organization"].id, name=env_name
-                )
-            except Environment.DoesNotExist:
-                raise serializers.ValidationError("Environment is not part of this organization")
-
-        if isinstance(environment, list):
-            environments = map(convert_to_environment, environment)
-        else:
-            environments = [convert_to_environment(environment)]
-        return environments
-
     def validate(self, data):
         """Performs validation on an alert rule's data
         This includes ensuring there is either 1 or 2 triggers, which each have actions, and have proper thresholds set.
diff --git a/src/sentry/incidents/logic.py b/src/sentry/incidents/logic.py
index 2665be5f84..d7d0b1c4ac 100644
--- a/src/sentry/incidents/logic.py
+++ b/src/sentry/incidents/logic.py
@@ -34,7 +34,7 @@ from sentry.incidents.models import (
     IncidentSubscription,
     TimeSeriesSnapshot,
 )
-from sentry.models import Integration, Project
+from sentry.models import Environment, Integration, Project
 from sentry.snuba.discover import resolve_discover_aliases
 from sentry.snuba.models import query_aggregation_to_snuba, QueryAggregations, QueryDatasets
 from sentry.snuba.subscriptions import (
@@ -280,7 +280,7 @@ def create_pending_incident_snapshot(incident):
         timedelta(minutes=time_window * 10), timedelta(days=10)
     )
     return PendingIncidentSnapshot.objects.create(
-        incident=incident, target_run_date=target_run_date,
+        incident=incident, target_run_date=target_run_date
     )
 
 
@@ -559,7 +559,7 @@ def create_alert_rule(
     :param query: An event search query to subscribe to and monitor for alerts
     :param aggregation: A QueryAggregation to fetch for this alert rule
     :param time_window: Time period to aggregate over, in minutes
-    :param environment: List of environments that this rule applies to
+    :param environment: An optional environment that this rule applies to
     :param threshold_period: How many update periods the value of the
     subscription needs to exceed the threshold before triggering
     :param include_all_projects: Whether to include all current and future projects
@@ -599,8 +599,7 @@ def create_alert_rule(
             AlertRuleExcludedProjects.objects.bulk_create(exclusions)
 
         if environment:
-            for e in environment:
-                AlertRuleEnvironment.objects.create(alert_rule=alert_rule, environment=e)
+            AlertRuleEnvironment.objects.create(alert_rule=alert_rule, environment=environment)
 
         subscribe_projects_to_alert_rule(alert_rule, projects)
 
@@ -659,7 +658,7 @@ def update_alert_rule(
     :param query: An event search query to subscribe to and monitor for alerts
     :param aggregation: An AlertRuleAggregation that we want to fetch for this alert rule
     :param time_window: Time period to aggregate over, in minutes.
-    :param environment: List of environments that this rule applies to
+    :param environment: An optional environment that this rule applies to
     :param threshold_period: How many update periods the value of the
     subscription needs to exceed the threshold before triggering
     :param include_all_projects: Whether to include all current and future projects
@@ -767,16 +766,22 @@ def update_alert_rule(
         if environment:
             # Delete rows we don't have present in the updated data.
             AlertRuleEnvironment.objects.filter(alert_rule=alert_rule).exclude(
-                environment__in=environment
+                environment=environment
             ).delete()
-            for e in environment:
-                AlertRuleEnvironment.objects.get_or_create(alert_rule=alert_rule, environment=e)
+            AlertRuleEnvironment.objects.get_or_create(
+                alert_rule=alert_rule, environment=environment
+            )
         else:
             AlertRuleEnvironment.objects.filter(alert_rule=alert_rule).delete()
 
         if existing_subs and (
             query is not None or aggregation is not None or time_window is not None
         ):
+            try:
+                environment = alert_rule.environment.all()[:1].get()
+            except Environment.DoesNotExist:
+                environment = None
+
             # If updating any subscription details, update related Snuba subscriptions
             # too
             bulk_update_snuba_subscriptions(
@@ -785,7 +790,7 @@ def update_alert_rule(
                 QueryAggregations(alert_rule.aggregation),
                 timedelta(minutes=alert_rule.time_window),
                 timedelta(minutes=DEFAULT_ALERT_RULE_RESOLUTION),
-                list(alert_rule.environment.all()),
+                environment,
             )
 
     return alert_rule
@@ -796,6 +801,11 @@ def subscribe_projects_to_alert_rule(alert_rule, projects):
     Subscribes a list of projects to an alert rule
     :return: The list of created subscriptions
     """
+    try:
+        environment = alert_rule.environment.all()[:1].get()
+    except Environment.DoesNotExist:
+        environment = None
+
     subscriptions = bulk_create_snuba_subscriptions(
         projects,
         tasks.INCIDENTS_SNUBA_SUBSCRIPTION_TYPE,
@@ -804,7 +814,7 @@ def subscribe_projects_to_alert_rule(alert_rule, projects):
         QueryAggregations(alert_rule.aggregation),
         timedelta(minutes=alert_rule.time_window),
         timedelta(minutes=alert_rule.resolution),
-        list(alert_rule.environment.all()),
+        environment,
     )
     subscription_links = [
         AlertRuleQuerySubscription(query_subscription=subscription, alert_rule=alert_rule)
diff --git a/src/sentry/snuba/subscriptions.py b/src/sentry/snuba/subscriptions.py
index a27352f958..19f87602d2 100644
--- a/src/sentry/snuba/subscriptions.py
+++ b/src/sentry/snuba/subscriptions.py
@@ -13,7 +13,7 @@ logger = logging.getLogger(__name__)
 
 
 def bulk_create_snuba_subscriptions(
-    projects, subscription_type, dataset, query, aggregation, time_window, resolution, environments
+    projects, subscription_type, dataset, query, aggregation, time_window, resolution, environment
 ):
     """
     Creates a subscription to a snuba query for each project.
@@ -27,7 +27,7 @@ def bulk_create_snuba_subscriptions(
     :param aggregation: An aggregation to calculate over the time window
     :param time_window: The time window to aggregate over
     :param resolution: How often to receive updates/bucket size
-    :param environments: List of environments to filter by
+    :param environment: An optional environment to filter by
     :return: A list of QuerySubscriptions
     """
     subscriptions = []
@@ -42,14 +42,14 @@ def bulk_create_snuba_subscriptions(
                 aggregation,
                 time_window,
                 resolution,
-                environments,
+                environment,
             )
         )
     return subscriptions
 
 
 def create_snuba_subscription(
-    project, subscription_type, dataset, query, aggregation, time_window, resolution, environments
+    project, subscription_type, dataset, query, aggregation, time_window, resolution, environment
 ):
     """
     Creates a subscription to a snuba query.
@@ -63,7 +63,7 @@ def create_snuba_subscription(
     :param aggregation: An aggregation to calculate over the time window
     :param time_window: The time window to aggregate over
     :param resolution: How often to receive updates/bucket size
-    :param environments: List of environments to filter by
+    :param environment: An optional environment to filter by
     :return: The QuerySubscription representing the subscription
     """
     subscription = QuerySubscription.objects.create(
@@ -76,11 +76,10 @@ def create_snuba_subscription(
         time_window=int(time_window.total_seconds()),
         resolution=int(resolution.total_seconds()),
     )
-    sub_envs = [
-        QuerySubscriptionEnvironment(query_subscription=subscription, environment=env)
-        for env in environments
-    ]
-    QuerySubscriptionEnvironment.objects.bulk_create(sub_envs)
+    if environment:
+        QuerySubscriptionEnvironment.objects.create(
+            query_subscription=subscription, environment=environment
+        )
 
     create_subscription_in_snuba.apply_async(
         kwargs={"query_subscription_id": subscription.id}, countdown=5
@@ -90,7 +89,7 @@ def create_snuba_subscription(
 
 
 def bulk_update_snuba_subscriptions(
-    subscriptions, query, aggregation, time_window, resolution, environments
+    subscriptions, query, aggregation, time_window, resolution, environment
 ):
     """
     Updates a list of query subscriptions.
@@ -101,7 +100,7 @@ def bulk_update_snuba_subscriptions(
     :param aggregation: An aggregation to calculate over the time window
     :param time_window: The time window to aggregate over
     :param resolution: How often to receive updates/bucket size
-    :param environments: List of environments to filter by
+    :param environment: An optional environment to filter by
     :return: A list of QuerySubscriptions
     """
     updated_subscriptions = []
@@ -109,14 +108,14 @@ def bulk_update_snuba_subscriptions(
     for subscription in subscriptions:
         updated_subscriptions.append(
             update_snuba_subscription(
-                subscription, query, aggregation, time_window, resolution, environments
+                subscription, query, aggregation, time_window, resolution, environment
             )
         )
     return subscriptions
 
 
 def update_snuba_subscription(
-    subscription, query, aggregation, time_window, resolution, environments
+    subscription, query, aggregation, time_window, resolution, environment
 ):
     """
     Updates a subscription to a snuba query.
@@ -126,7 +125,7 @@ def update_snuba_subscription(
     :param aggregation: An aggregation to calculate over the time window
     :param time_window: The time window to aggregate over
     :param resolution: How often to receive updates/bucket size
-    :param environments: List of environments to filter by
+    :param environment: An optional environment to filter by
     :return: The QuerySubscription representing the subscription
     """
     subscription.update(
@@ -137,11 +136,11 @@ def update_snuba_subscription(
         resolution=int(resolution.total_seconds()),
     )
     QuerySubscriptionEnvironment.objects.filter(query_subscription=subscription).exclude(
-        environment__in=environments
+        environment=environment
     ).delete()
-    for e in environments:
+    if environment:
         QuerySubscriptionEnvironment.objects.get_or_create(
-            query_subscription=subscription, environment=e
+            query_subscription=subscription, environment=environment
         )
 
     update_subscription_in_snuba.apply_async(
diff --git a/src/sentry/snuba/tasks.py b/src/sentry/snuba/tasks.py
index 82fd1e68ef..2ad4c104b5 100644
--- a/src/sentry/snuba/tasks.py
+++ b/src/sentry/snuba/tasks.py
@@ -3,6 +3,7 @@ from __future__ import absolute_import
 import json
 
 from sentry.api.event_search import get_filter
+from sentry.models import Environment
 from sentry.snuba.discover import resolve_discover_aliases
 from sentry.snuba.models import (
     QueryAggregations,
@@ -116,9 +117,13 @@ def delete_subscription_from_snuba(query_subscription_id):
 
 def _create_in_snuba(subscription):
     conditions = resolve_discover_aliases(get_filter(subscription.query))[0].conditions
-    environments = list(subscription.environments.all())
-    if environments:
-        conditions.append(["environment", "IN", [env.name for env in environments]])
+    try:
+        environment = subscription.environments.all()[:1].get()
+    except Environment.DoesNotExist:
+        environment = None
+
+    if environment:
+        conditions.append(["environment", "=", environment.name])
     conditions = apply_dataset_conditions(QueryDatasets(subscription.dataset), conditions)
     response = _snuba_pool.urlopen(
         "POST",
diff --git a/tests/sentry/api/endpoints/test_organization_incident_index.py b/tests/sentry/api/endpoints/test_organization_incident_index.py
index 65456314b5..8e6a805dc5 100644
--- a/tests/sentry/api/endpoints/test_organization_incident_index.py
+++ b/tests/sentry/api/endpoints/test_organization_incident_index.py
@@ -51,7 +51,7 @@ class IncidentListEndpointTest(APITestCase):
     def test_filter_env(self):
         self.create_team(organization=self.organization, members=[self.user])
         env = self.create_environment(self.project)
-        rule = self.create_alert_rule(projects=[self.project], environment=[env])
+        rule = self.create_alert_rule(projects=[self.project], environment=env)
 
         incident = self.create_incident(alert_rule=rule)
         self.create_incident()
@@ -59,9 +59,7 @@ class IncidentListEndpointTest(APITestCase):
         self.login_as(self.user)
 
         with self.feature("organizations:incidents"):
-            resp_filter_env = self.get_valid_response(
-                self.organization.slug, environment=[env.name]
-            )
+            resp_filter_env = self.get_valid_response(self.organization.slug, environment=env.name)
             resp_no_env_filter = self.get_valid_response(self.organization.slug)
 
         # The alert without an environment assigned should not be selected
diff --git a/tests/sentry/incidents/endpoints/test_organization_alert_rule_details.py b/tests/sentry/incidents/endpoints/test_organization_alert_rule_details.py
index 5c7c2072b7..382685c9fc 100644
--- a/tests/sentry/incidents/endpoints/test_organization_alert_rule_details.py
+++ b/tests/sentry/incidents/endpoints/test_organization_alert_rule_details.py
@@ -88,6 +88,10 @@ class AlertRuleDetailsBase(object):
             resp = self.get_valid_response(self.organization.slug)
             assert len(resp.data) >= 1
             serialized_alert_rule = resp.data[0]
+            if serialized_alert_rule["environment"]:
+                serialized_alert_rule["environment"] = serialized_alert_rule["environment"][0]
+            else:
+                serialized_alert_rule.pop("environment", None)
         self.endpoint = original_endpoint
         self.method = original_method
         return serialized_alert_rule
diff --git a/tests/sentry/incidents/endpoints/test_serializers.py b/tests/sentry/incidents/endpoints/test_serializers.py
index 200655152b..ebe0c16c77 100644
--- a/tests/sentry/incidents/endpoints/test_serializers.py
+++ b/tests/sentry/incidents/endpoints/test_serializers.py
@@ -94,67 +94,9 @@ class TestAlertRuleSerializer(TestCase):
             "triggers": field_is_required,
         }
 
-    def test_environment(self):
-        base_params = self.valid_params.copy()
-        env_1 = Environment.objects.create(organization_id=self.organization.id, name="test_env_1")
-        env_2 = Environment.objects.create(organization_id=self.organization.id, name="test_env_2")
-
-        base_params.update({"environment": [env_1.name]})
-        serializer = AlertRuleSerializer(context=self.context, data=base_params)
-        assert serializer.is_valid(), serializer.errors
-        alert_rule = serializer.save()
-
-        # Make sure AlertRuleEnvironment entry was made:
-        alert_rule_env = AlertRuleEnvironment.objects.get(
-            environment=env_1.id, alert_rule=alert_rule
-        )
-        assert alert_rule_env
-
-        base_params.update({"id": alert_rule.id})
-        base_params.update({"environment": [env_1.name, env_2.name]})
-        serializer = AlertRuleSerializer(
-            context=self.context, instance=alert_rule, data=base_params
-        )
-        assert serializer.is_valid()
-        alert_rule = serializer.save()
-
-        assert len(AlertRuleEnvironment.objects.filter(alert_rule=alert_rule)) == 2
-        assert len(list(alert_rule.environment.all())) == 2
-
-        base_params.update({"environment": [env_2.name]})
-        serializer = AlertRuleSerializer(
-            context=self.context, instance=alert_rule, data=base_params
-        )
-        assert serializer.is_valid()
-        serializer.save()
-
-        # Make sure env_1 AlertRuleEnvironment was deleted:
-        try:
-            alert_rule_env = AlertRuleEnvironment.objects.get(
-                environment=env_1.id, alert_rule=alert_rule
-            )
-            assert False
-        except AlertRuleEnvironment.DoesNotExist:
-            assert True
-        # And that env_2 is still present:
-        assert len(AlertRuleEnvironment.objects.filter(alert_rule=alert_rule)) == 1
-        assert (
-            len(AlertRuleEnvironment.objects.filter(environment=env_2.id, alert_rule=alert_rule))
-            == 1
-        )
-
-        base_params.update({"environment": []})
-        serializer = AlertRuleSerializer(
-            context=self.context, instance=alert_rule, data=base_params
-        )
-        assert serializer.is_valid()
-        serializer.save()
-        assert len(AlertRuleEnvironment.objects.filter(alert_rule=alert_rule)) == 0
-
     def test_environment_non_list(self):
         base_params = self.valid_params.copy()
         env_1 = Environment.objects.create(organization_id=self.organization.id, name="test_env_1")
-        Environment.objects.create(organization_id=self.organization.id, name="test_env_2")
 
         base_params.update({"environment": env_1.name})
         serializer = AlertRuleSerializer(context=self.context, data=base_params)
diff --git a/tests/sentry/incidents/test_action_handlers.py b/tests/sentry/incidents/test_action_handlers.py
index a07ff22da0..0c43b6f63a 100644
--- a/tests/sentry/incidents/test_action_handlers.py
+++ b/tests/sentry/incidents/test_action_handlers.py
@@ -130,12 +130,12 @@ class EmailActionHandlerGenerateEmailContextTest(TestCase):
             self.create_environment(project=self.project, name="prod"),
             self.create_environment(project=self.project, name="dev"),
         ]
-        alert_rule = self.create_alert_rule(environment=environments)
+        alert_rule = self.create_alert_rule(environment=environments[0])
         alert_rule_trigger = self.create_alert_rule_trigger(alert_rule=alert_rule)
         action = self.create_alert_rule_trigger_action(alert_rule_trigger=alert_rule_trigger)
         incident = self.create_incident()
         handler = EmailActionHandler(action, incident, self.project)
-        assert "dev, prod" == handler.generate_email_context(status).get("environment")
+        assert "prod" == handler.generate_email_context(status).get("environment")
 
 
 @freeze_time()
diff --git a/tests/sentry/snuba/test_subscriptions.py b/tests/sentry/snuba/test_subscriptions.py
index 371420fa7d..b859a216e5 100644
--- a/tests/sentry/snuba/test_subscriptions.py
+++ b/tests/sentry/snuba/test_subscriptions.py
@@ -21,7 +21,7 @@ class CreateSnubaSubscriptionTest(TestCase):
         time_window = timedelta(minutes=10)
         resolution = timedelta(minutes=1)
         subscription = create_snuba_subscription(
-            self.project, type, dataset, query, aggregation, time_window, resolution, []
+            self.project, type, dataset, query, aggregation, time_window, resolution, None
         )
         assert subscription.status == QuerySubscription.Status.CREATING.value
         assert subscription.project == self.project
@@ -42,7 +42,7 @@ class CreateSnubaSubscriptionTest(TestCase):
             time_window = timedelta(minutes=10)
             resolution = timedelta(minutes=1)
             subscription = create_snuba_subscription(
-                self.project, type, dataset, query, aggregation, time_window, resolution, []
+                self.project, type, dataset, query, aggregation, time_window, resolution, None
             )
             subscription = QuerySubscription.objects.get(id=subscription.id)
             assert subscription.status == QuerySubscription.Status.ACTIVE.value
@@ -63,7 +63,7 @@ class CreateSnubaSubscriptionTest(TestCase):
         time_window = timedelta(minutes=10)
         resolution = timedelta(minutes=1)
         subscription = create_snuba_subscription(
-            self.project, type, dataset, query, aggregation, time_window, resolution, []
+            self.project, type, dataset, query, aggregation, time_window, resolution, None
         )
         assert subscription.status == QuerySubscription.Status.CREATING.value
         assert subscription.project == self.project
@@ -87,7 +87,7 @@ class UpdateSnubaSubscriptionTest(TestCase):
                 QueryAggregations.TOTAL,
                 timedelta(minutes=10),
                 timedelta(minutes=1),
-                [],
+                None,
             )
 
         query = "level:warning"
@@ -97,7 +97,7 @@ class UpdateSnubaSubscriptionTest(TestCase):
         subscription = QuerySubscription.objects.get(id=subscription.id)
         subscription_id = subscription.subscription_id
         assert subscription_id is not None
-        update_snuba_subscription(subscription, query, aggregation, time_window, resolution, [])
+        update_snuba_subscription(subscription, query, aggregation, time_window, resolution, None)
         assert subscription.status == QuerySubscription.Status.UPDATING.value
         assert subscription.subscription_id == subscription_id
         assert subscription.query == query
@@ -115,7 +115,7 @@ class UpdateSnubaSubscriptionTest(TestCase):
                 QueryAggregations.TOTAL,
                 timedelta(minutes=10),
                 timedelta(minutes=1),
-                [],
+                None,
             )
 
             query = "level:warning"
@@ -125,7 +125,9 @@ class UpdateSnubaSubscriptionTest(TestCase):
             subscription = QuerySubscription.objects.get(id=subscription.id)
             subscription_id = subscription.subscription_id
             assert subscription_id is not None
-            update_snuba_subscription(subscription, query, aggregation, time_window, resolution, [])
+            update_snuba_subscription(
+                subscription, query, aggregation, time_window, resolution, None
+            )
             subscription = QuerySubscription.objects.get(id=subscription.id)
             assert subscription.status == QuerySubscription.Status.ACTIVE.value
             assert subscription.subscription_id is not None
@@ -147,7 +149,7 @@ class BulkDeleteSnubaSubscriptionTest(TestCase):
                 QueryAggregations.TOTAL,
                 timedelta(minutes=10),
                 timedelta(minutes=1),
-                [],
+                None,
             )
             other_subscription = create_snuba_subscription(
                 self.create_project(organization=self.organization),
@@ -157,7 +159,7 @@ class BulkDeleteSnubaSubscriptionTest(TestCase):
                 QueryAggregations.TOTAL,
                 timedelta(minutes=10),
                 timedelta(minutes=1),
-                [],
+                None,
             )
         subscription_ids = [subscription.id, other_subscription.id]
         bulk_delete_snuba_subscriptions([subscription, other_subscription])
@@ -182,7 +184,7 @@ class DeleteSnubaSubscriptionTest(TestCase):
                 QueryAggregations.TOTAL,
                 timedelta(minutes=10),
                 timedelta(minutes=1),
-                [],
+                None,
             )
         # Refetch since snuba creation happens in a task
         subscription = QuerySubscription.objects.get(id=subscription.id)
@@ -202,7 +204,7 @@ class DeleteSnubaSubscriptionTest(TestCase):
                 QueryAggregations.TOTAL,
                 timedelta(minutes=10),
                 timedelta(minutes=1),
-                [],
+                None,
             )
             subscription_id = subscription.id
             delete_snuba_subscription(subscription)

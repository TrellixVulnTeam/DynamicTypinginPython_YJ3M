commit 7ff0f571ee049019b06bdd208f7b50f7e9bc1d1c
Author: David Wang <davidw1339@gmail.com>
Date:   Thu Oct 17 11:43:34 2019 -0700

    feat(ui): Connect organization context to organization store (#14973)
    
    Integrate organization context with organization store. Now before fetching for the organization, org context checks to see if there is an organization in the store which is fully populated with teams and projects and matches the current slug. If there is a heavyweight matching organization then no data will be fetched, otherwise the organization will be fetched and the store will be set accordingly. In the case of settings changes, the store will be marked as dirty and the next mount of organization context will trigger a refetch
    
    Refs: SEN-1145

diff --git a/src/sentry/static/sentry/app/actionCreators/organization.jsx b/src/sentry/static/sentry/app/actionCreators/organization.jsx
new file mode 100644
index 0000000000..99c48e707a
--- /dev/null
+++ b/src/sentry/static/sentry/app/actionCreators/organization.jsx
@@ -0,0 +1,34 @@
+import {setActiveOrganization} from 'app/actionCreators/organizations';
+
+import OrganizationActions from 'app/actions/organizationActions';
+import TeamStore from 'app/stores/teamStore';
+import ProjectsStore from 'app/stores/projectsStore';
+
+/**
+ * Fetches an organization's details with an option for the detailed representation
+ * with teams and projects
+ *
+ * @param {Object} api A reference to the api client
+ * @param {String} slug The organization slug
+ * @param {boolean} detailed whether or not the detailed org details should be retrieved
+ */
+export async function fetchOrganizationDetails(api, slug, detailed) {
+  OrganizationActions.fetchOrg();
+  try {
+    const org = await api.requestPromise(`/organizations/${slug}/`, {
+      query: {detailed: detailed ? 1 : 0},
+    });
+    if (!org) {
+      OrganizationActions.fetchOrgError(new Error('retrieved organization is falsey'));
+      return;
+    }
+    OrganizationActions.update(org);
+    setActiveOrganization(org);
+    if (detailed) {
+      TeamStore.loadInitialData(org.teams);
+      ProjectsStore.loadInitialData(org.projects);
+    }
+  } catch (err) {
+    OrganizationActions.fetchOrgError(err);
+  }
+}
diff --git a/src/sentry/static/sentry/app/actions/organizationActions.jsx b/src/sentry/static/sentry/app/actions/organizationActions.jsx
index fab246357b..bdd5fdf6b0 100644
--- a/src/sentry/static/sentry/app/actions/organizationActions.jsx
+++ b/src/sentry/static/sentry/app/actions/organizationActions.jsx
@@ -1,3 +1,3 @@
 import Reflux from 'reflux';
 
-export default Reflux.createActions(['update']);
+export default Reflux.createActions(['fetchOrg', 'fetchOrgError', 'update']);
diff --git a/src/sentry/static/sentry/app/constants/index.tsx b/src/sentry/static/sentry/app/constants/index.tsx
index d81230675e..c5082eed73 100644
--- a/src/sentry/static/sentry/app/constants/index.tsx
+++ b/src/sentry/static/sentry/app/constants/index.tsx
@@ -210,3 +210,8 @@ export const EXPERIMENTAL_SPA = process.env.EXPERIMENTAL_SPA;
 // TODO(kmclb): once relay is doing the scrubbing, the masking value will be dynamic,
 // so this will have to change
 export const FILTER_MASK = '[Filtered]';
+
+// Errors that may occur during the fetching of organization details
+export const ORGANIZATION_FETCH_ERROR_TYPES = {
+  ORG_NOT_FOUND: 'ORG_NOT_FOUND',
+};
diff --git a/src/sentry/static/sentry/app/stores/organizationStore.jsx b/src/sentry/static/sentry/app/stores/organizationStore.jsx
index ce299a95e2..ed5f730fb9 100644
--- a/src/sentry/static/sentry/app/stores/organizationStore.jsx
+++ b/src/sentry/static/sentry/app/stores/organizationStore.jsx
@@ -1,24 +1,76 @@
 import Reflux from 'reflux';
 
 import OrganizationActions from 'app/actions/organizationActions';
+import ProjectActions from 'app/actions/projectActions';
+import TeamActions from 'app/actions/teamActions';
+import {ORGANIZATION_FETCH_ERROR_TYPES} from 'app/constants';
 
 const OrganizationStore = Reflux.createStore({
   init() {
     this.reset();
     this.listenTo(OrganizationActions.update, this.onUpdate);
+    this.listenTo(OrganizationActions.fetchOrg, this.reset);
+    this.listenTo(OrganizationActions.fetchOrgError, this.onFetchOrgError);
+
+    // mark the store as dirty if projects or teams change
+    this.listenTo(ProjectActions.createSuccess, this.onProjectOrTeamChange);
+    this.listenTo(ProjectActions.updateSuccess, this.onProjectOrTeamChange);
+    this.listenTo(ProjectActions.changeSlug, this.onProjectOrTeamChange);
+    this.listenTo(ProjectActions.addTeamSuccess, this.onProjectOrTeamChange);
+    this.listenTo(ProjectActions.removeTeamSuccess, this.onProjectOrTeamChange);
+
+    this.listenTo(TeamActions.updateSuccess, this.onProjectOrTeamChange);
+    this.listenTo(TeamActions.removeTeamSuccess, this.onProjectOrTeamChange);
+    this.listenTo(TeamActions.createTeamSuccess, this.onProjectOrTeamChange);
   },
 
   reset() {
-    this.org = null;
+    this.loading = true;
+    this.error = null;
+    this.errorType = null;
+    this.organization = null;
+    this.dirty = false;
+    this.trigger(this.get());
   },
 
   onUpdate(updatedOrg) {
-    this.org = {...this.org, ...updatedOrg};
-    this.trigger(this.org);
+    this.loading = false;
+    this.error = null;
+    this.errorType = null;
+    this.organization = {...this.organization, ...updatedOrg};
+    this.dirty = false;
+    this.trigger(this.get());
+  },
+
+  onFetchOrgError(err) {
+    this.organization = null;
+    this.errorType = null;
+
+    switch (err.statusText) {
+      case 'NOT FOUND':
+        this.errorType = ORGANIZATION_FETCH_ERROR_TYPES.ORG_NOT_FOUND;
+        break;
+      default:
+    }
+    this.loading = false;
+    this.error = err;
+    this.dirty = false;
+    this.trigger(this.get());
+  },
+
+  onProjectOrTeamChange() {
+    // mark the store as dirty so the next fetch will trigger an org details refetch
+    this.dirty = true;
   },
 
-  getOrganization() {
-    return this.org;
+  get() {
+    return {
+      organization: this.organization,
+      error: this.error,
+      loading: this.loading,
+      errorType: this.errorType,
+      dirty: this.dirty,
+    };
   },
 });
 
diff --git a/src/sentry/static/sentry/app/views/organizationContext.jsx b/src/sentry/static/sentry/app/views/organizationContext.jsx
index 07a72b22a6..81f5494669 100644
--- a/src/sentry/static/sentry/app/views/organizationContext.jsx
+++ b/src/sentry/static/sentry/app/views/organizationContext.jsx
@@ -6,9 +6,10 @@ import * as Sentry from '@sentry/browser';
 import createReactClass from 'create-react-class';
 import styled from 'react-emotion';
 
+import {ORGANIZATION_FETCH_ERROR_TYPES} from 'app/constants';
+import {fetchOrganizationDetails} from 'app/actionCreators/organization';
 import {metric} from 'app/utils/analytics';
 import {openSudo} from 'app/actionCreators/modal';
-import {setActiveOrganization} from 'app/actionCreators/organizations';
 import {t} from 'app/locale';
 import Alert from 'app/components/alert';
 import ConfigStore from 'app/stores/configStore';
@@ -16,21 +17,16 @@ import GlobalSelectionStore from 'app/stores/globalSelectionStore';
 import HookStore from 'app/stores/hookStore';
 import LoadingError from 'app/components/loadingError';
 import LoadingIndicator from 'app/components/loadingIndicator';
+import OrganizationStore from 'app/stores/organizationStore';
 import ProjectActions from 'app/actions/projectActions';
-import ProjectsStore from 'app/stores/projectsStore';
 import SentryTypes from 'app/sentryTypes';
 import Sidebar from 'app/components/sidebar';
-import TeamStore from 'app/stores/teamStore';
 import getRouteStringFromRoutes from 'app/utils/getRouteStringFromRoutes';
 import profiler from 'app/utils/profiler';
 import space from 'app/styles/space';
 import withApi from 'app/utils/withApi';
 import withOrganizations from 'app/utils/withOrganizations';
 
-const ERROR_TYPES = {
-  ORG_NOT_FOUND: 'ORG_NOT_FOUND',
-};
-
 const OrganizationContext = createReactClass({
   displayName: 'OrganizationContext',
 
@@ -48,15 +44,14 @@ const OrganizationContext = createReactClass({
     organization: SentryTypes.Organization,
   },
 
-  mixins: [Reflux.listenTo(ProjectActions.createSuccess, 'onProjectCreation')],
+  mixins: [
+    Reflux.listenTo(ProjectActions.createSuccess, 'onProjectCreation'),
+    Reflux.listenTo(OrganizationStore, 'loadOrganization'),
+  ],
 
   getInitialState() {
-    return {
-      loading: true,
-      error: false,
-      errorType: null,
-      organization: null,
-    };
+    // retrieve initial state from store
+    return OrganizationStore.get();
   },
 
   getChildContext() {
@@ -95,10 +90,6 @@ const OrganizationContext = createReactClass({
     }
   },
 
-  componentWillUnmount() {
-    TeamStore.reset();
-  },
-
   remountComponent() {
     this.setState(this.getInitialState(), this.fetchData);
   },
@@ -107,7 +98,7 @@ const OrganizationContext = createReactClass({
     // If a new project was created, we need to re-fetch the
     // org details endpoint, which will propagate re-rendering
     // for the entire component tree
-    this.fetchData();
+    fetchOrganizationDetails(this.props.api, this.getOrganizationSlug(), true);
   },
 
   getOrganizationSlug() {
@@ -126,88 +117,71 @@ const OrganizationContext = createReactClass({
       this.setState({loading: this.props.organizationsLoading});
       return;
     }
-
+    // fetch from the store, then fetch from the API if necessary
+    const {organization, dirty} = OrganizationStore.get();
+    if (
+      !dirty &&
+      organization &&
+      organization.slug === this.getOrganizationSlug() &&
+      organization.projects &&
+      organization.teams
+    ) {
+      return;
+    }
     metric.mark('organization-details-fetch-start');
+    fetchOrganizationDetails(this.props.api, this.getOrganizationSlug(), true);
+  },
 
-    this.props.api
-      .requestPromise(this.getOrganizationDetailsEndpoint())
-      .then(data => {
-        // Allow injection via getsentry et all
-        const hooks = [];
-        HookStore.get('organization:header').forEach(cb => {
-          hooks.push(cb(data));
-        });
-
-        setActiveOrganization(data);
-
-        // Configure scope to have organization tag
-        Sentry.configureScope(scope => {
-          scope.setTag('organization', data.id);
-        });
-
-        TeamStore.loadInitialData(data.teams);
-        ProjectsStore.loadInitialData(data.projects);
-
-        // Make an exception for issue details in the case where it is accessed directly (e.g. from email)
-        // We do not want to load the user's last used env/project in this case, otherwise will
-        // lead to very confusing behavior.
-        if (
-          !this.props.routes.find(
-            ({path}) => path && path.includes('/organizations/:orgId/issues/:groupId/')
-          )
-        ) {
-          GlobalSelectionStore.loadInitialData(data, this.props.location.query);
-        }
-        this.setState(
-          {
-            organization: data,
-            loading: false,
-            error: false,
-            errorType: null,
-            hooks,
-          },
-          () => {
-            // Take a measurement for when organization details are done loading and the new state is applied
-            metric.measure({
-              name: 'app.component.perf',
-              start: 'organization-details-fetch-start',
-              data: {
-                name: 'org-details',
-                route: getRouteStringFromRoutes(this.props.routes),
-                organization_id: parseInt(data.id, 10),
-              },
-            });
-          }
-        );
-      })
-      .catch(err => {
-        let errorType = null;
-
-        switch (err.statusText) {
-          case 'NOT FOUND':
-            errorType = ERROR_TYPES.ORG_NOT_FOUND;
-            break;
-          default:
-        }
-        this.setState({
-          loading: false,
-          error: true,
-          errorType,
-        });
+  loadOrganization(orgData) {
+    const {organization, error} = orgData;
+    if (organization && !error) {
+      const hooks = [];
+      HookStore.get('organization:header').forEach(cb => {
+        hooks.push(cb(organization));
+      });
 
-        // If user is superuser, open sudo window
-        const user = ConfigStore.get('user');
-        if (!user || !user.isSuperuser || err.status !== 403) {
-          // This `catch` can swallow up errors in development (and tests)
-          // So let's log them. This may create some noise, especially the test case where
-          // we specifically test this branch
-          console.error(err); // eslint-disable-line no-console
-          return;
-        }
+      // Configure scope to have organization tag
+      Sentry.configureScope(scope => {
+        scope.setTag('organization', organization.id);
+      });
+      // Make an exception for issue details in the case where it is accessed directly (e.g. from email)
+      // We do not want to load the user's last used env/project in this case, otherwise will
+      // lead to very confusing behavior.
+      if (
+        !this.props.routes.find(
+          ({path}) => path && path.includes('/organizations/:orgId/issues/:groupId/')
+        )
+      ) {
+        GlobalSelectionStore.loadInitialData(organization, this.props.location.query);
+      }
+    } else if (error) {
+      // If user is superuser, open sudo window
+      const user = ConfigStore.get('user');
+      if (!user || !user.isSuperuser || error.status !== 403) {
+        // This `catch` can swallow up errors in development (and tests)
+        // So let's log them. This may create some noise, especially the test case where
+        // we specifically test this branch
+        console.error(error); // eslint-disable-line no-console
+      } else {
         openSudo({
           retryRequest: () => Promise.resolve(this.fetchData()),
         });
-      });
+      }
+    }
+    this.setState(orgData, () => {
+      // Take a measurement for when organization details are done loading and the new state is applied
+      if (organization) {
+        metric.measure({
+          name: 'app.component.perf',
+          start: 'organization-details-fetch-start',
+          data: {
+            name: 'org-details',
+            route: getRouteStringFromRoutes(this.props.routes),
+            organization_id: parseInt(organization.id, 10),
+          },
+        });
+      }
+    });
   },
 
   getOrganizationDetailsEndpoint() {
@@ -233,7 +207,7 @@ const OrganizationContext = createReactClass({
     let errorComponent;
 
     switch (this.state.errorType) {
-      case ERROR_TYPES.ORG_NOT_FOUND:
+      case ORGANIZATION_FETCH_ERROR_TYPES.ORG_NOT_FOUND:
         errorComponent = (
           <Alert type="error">
             {t('The organization you were looking for was not found.')}
diff --git a/tests/js/spec/actionCreators/organization.spec.jsx b/tests/js/spec/actionCreators/organization.spec.jsx
new file mode 100644
index 0000000000..72fde6987f
--- /dev/null
+++ b/tests/js/spec/actionCreators/organization.spec.jsx
@@ -0,0 +1,91 @@
+import * as OrganizationsActionCreator from 'app/actionCreators/organizations';
+import {fetchOrganizationDetails} from 'app/actionCreators/organization';
+import TeamStore from 'app/stores/teamStore';
+import ProjectsStore from 'app/stores/projectsStore';
+import OrganizationActions from 'app/actions/organizationActions';
+
+describe('OrganizationActionCreator', function() {
+  const detailedOrg = TestStubs.Organization({
+    teams: [TestStubs.Team()],
+    projects: [TestStubs.Project()],
+  });
+
+  const lightOrg = TestStubs.Organization();
+  delete lightOrg.teams;
+  delete lightOrg.projects;
+
+  const api = new MockApiClient();
+
+  beforeEach(function() {
+    MockApiClient.clearMockResponses();
+    jest.spyOn(TeamStore, 'loadInitialData');
+    jest.spyOn(ProjectsStore, 'loadInitialData');
+    jest.spyOn(OrganizationActions, 'fetchOrg');
+    jest.spyOn(OrganizationActions, 'update');
+    jest.spyOn(OrganizationActions, 'fetchOrgError');
+    jest.spyOn(OrganizationsActionCreator, 'setActiveOrganization');
+  });
+
+  afterEach(function() {
+    jest.restoreAllMocks();
+    MockApiClient.clearMockResponses();
+  });
+
+  it('fetches heavyweight organization details', async function() {
+    const getOrgMock = MockApiClient.addMockResponse({
+      url: `/organizations/${detailedOrg.slug}/`,
+      body: detailedOrg,
+    });
+
+    fetchOrganizationDetails(api, detailedOrg.slug, true);
+    await tick();
+    expect(OrganizationActions.fetchOrg).toHaveBeenCalled();
+
+    expect(getOrgMock).toHaveBeenCalledWith(
+      `/organizations/${detailedOrg.slug}/`,
+      expect.anything()
+    );
+    expect(OrganizationActions.update).toHaveBeenCalledWith(detailedOrg);
+    expect(OrganizationsActionCreator.setActiveOrganization).toHaveBeenCalled();
+
+    expect(TeamStore.loadInitialData).toHaveBeenCalledWith(detailedOrg.teams);
+    expect(ProjectsStore.loadInitialData).toHaveBeenCalledWith(detailedOrg.projects);
+  });
+
+  it('fetches lightweight organization details', async function() {
+    const getOrgMock = MockApiClient.addMockResponse({
+      url: `/organizations/${lightOrg.slug}/`,
+      body: lightOrg,
+    });
+
+    fetchOrganizationDetails(api, lightOrg.slug, false);
+    await tick();
+    expect(OrganizationActions.fetchOrg).toHaveBeenCalled();
+
+    expect(getOrgMock).toHaveBeenCalledWith(
+      `/organizations/${lightOrg.slug}/`,
+      expect.anything()
+    );
+    expect(OrganizationActions.update).toHaveBeenCalledWith(lightOrg);
+    expect(OrganizationsActionCreator.setActiveOrganization).toHaveBeenCalled();
+
+    expect(TeamStore.loadInitialData).not.toHaveBeenCalled();
+    expect(ProjectsStore.loadInitialData).not.toHaveBeenCalled();
+  });
+
+  it('errors out correctly', async function() {
+    const getOrgMock = MockApiClient.addMockResponse({
+      url: `/organizations/${detailedOrg.slug}/`,
+      statusCode: 400,
+    });
+
+    fetchOrganizationDetails(api, detailedOrg.slug, true);
+    await tick();
+    expect(OrganizationActions.fetchOrg).toHaveBeenCalled();
+    expect(getOrgMock).toHaveBeenCalledWith(
+      `/organizations/${detailedOrg.slug}/`,
+      expect.anything()
+    );
+    expect(OrganizationActions.fetchOrgError).toHaveBeenCalled();
+  });
+});
diff --git a/tests/js/spec/stores/organizationStore.spec.jsx b/tests/js/spec/stores/organizationStore.spec.jsx
index c50437f298..62b69cd610 100644
--- a/tests/js/spec/stores/organizationStore.spec.jsx
+++ b/tests/js/spec/stores/organizationStore.spec.jsx
@@ -7,17 +7,65 @@ describe('OrganizationStore', function() {
     OrganizationStore.reset();
   });
 
+  it('starts with loading state', function() {
+    expect(OrganizationStore.get()).toMatchObject({
+      loading: true,
+      error: null,
+      errorType: null,
+      organization: null,
+      dirty: false,
+    });
+  });
+
   it('updates correctly', async function() {
-    const org = TestStubs.Organization();
-    OrganizationActions.update(org);
+    const organization = TestStubs.Organization();
+    OrganizationActions.update(organization);
+    await tick();
+    expect(OrganizationStore.get()).toMatchObject({
+      loading: false,
+      error: null,
+      errorType: null,
+      organization,
+      dirty: false,
+    });
+
+    // updates
+    organization.slug = 'a new slug';
+    OrganizationActions.update(organization);
     await tick();
-    expect(OrganizationStore.getOrganization()).toMatchObject(org);
+    expect(OrganizationStore.get()).toMatchObject({
+      loading: false,
+      error: null,
+      errorType: null,
+      organization,
+      dirty: false,
+    });
   });
 
   it('updates correctly from setting changes', async function() {
-    const org = TestStubs.Organization();
-    updateOrganization(org);
+    const organization = TestStubs.Organization();
+    updateOrganization(organization);
+    await tick();
+    expect(OrganizationStore.get()).toMatchObject({
+      loading: false,
+      error: null,
+      errorType: null,
+      organization,
+      dirty: false,
+    });
+  });
+
+  it('errors correctly', async function() {
+    const error = new Error('uh-oh');
+    error.statusText = 'NOT FOUND';
+    OrganizationActions.fetchOrgError(error);
     await tick();
-    expect(OrganizationStore.getOrganization()).toMatchObject(org);
+    expect(OrganizationStore.get()).toMatchObject({
+      loading: false,
+      error,
+      errorType: 'ORG_NOT_FOUND',
+      organization: null,
+      dirty: false,
+    });
   });
 });
diff --git a/tests/js/spec/views/organizationContext.spec.jsx b/tests/js/spec/views/organizationContext.spec.jsx
index 2d9b153eb2..a66fcd7de3 100644
--- a/tests/js/spec/views/organizationContext.spec.jsx
+++ b/tests/js/spec/views/organizationContext.spec.jsx
@@ -2,11 +2,13 @@ import React from 'react';
 
 import {mount} from 'sentry-test/enzyme';
 import {openSudo} from 'app/actionCreators/modal';
+import * as OrganizationActionCreator from 'app/actionCreators/organization';
 import ConfigStore from 'app/stores/configStore';
 import {OrganizationContext} from 'app/views/organizationContext';
 import ProjectsStore from 'app/stores/projectsStore';
 import TeamStore from 'app/stores/teamStore';
 import GlobalSelectionStore from 'app/stores/globalSelectionStore';
+import OrganizationStore from 'app/stores/organizationStore';
 
 jest.mock('app/stores/configStore', () => ({
   get: jest.fn(),
@@ -21,12 +23,13 @@ describe('OrganizationContext', function() {
     teams: [TestStubs.Team()],
     projects: [TestStubs.Project()],
   });
+  const api = new MockApiClient();
   let getOrgMock;
 
-  const createWrapper = props =>
-    mount(
+  const createWrapper = props => {
+    wrapper = mount(
       <OrganizationContext
-        api={new MockApiClient()}
+        api={api}
         params={{orgId: 'org-slug'}}
         location={{query: {}}}
         routes={[]}
@@ -35,6 +38,8 @@ describe('OrganizationContext', function() {
         <div />
       </OrganizationContext>
     );
+    return wrapper;
+  };
 
   beforeEach(function() {
     MockApiClient.clearMockResponses();
@@ -45,17 +50,27 @@ describe('OrganizationContext', function() {
     jest.spyOn(TeamStore, 'loadInitialData');
     jest.spyOn(ProjectsStore, 'loadInitialData');
     jest.spyOn(GlobalSelectionStore, 'loadInitialData');
+    jest.spyOn(OrganizationActionCreator, 'fetchOrganizationDetails');
   });
 
-  afterEach(function() {
+  afterEach(async function() {
+    wrapper.unmount();
+    OrganizationStore.reset();
+    // await for store change to finish propagating
+    await tick();
+
     TeamStore.loadInitialData.mockRestore();
     ProjectsStore.loadInitialData.mockRestore();
     ConfigStore.get.mockRestore();
     GlobalSelectionStore.loadInitialData.mockRestore();
+    OrganizationActionCreator.fetchOrganizationDetails.mockRestore();
   });
 
   it('renders and fetches org', async function() {
     wrapper = createWrapper();
+    // await dispatching the action to org store
+    await tick();
+    // await resolving the api promise from action creator and updating component
     await tick();
     expect(getOrgMock).toHaveBeenCalledWith(
       '/organizations/org-slug/',
@@ -63,53 +78,35 @@ describe('OrganizationContext', function() {
     );
 
     expect(wrapper.state('loading')).toBe(false);
-    expect(wrapper.state('error')).toBe(false);
+    expect(wrapper.state('error')).toBe(null);
     expect(wrapper.state('organization')).toEqual(org);
 
     expect(TeamStore.loadInitialData).toHaveBeenCalledWith(org.teams);
     expect(ProjectsStore.loadInitialData).toHaveBeenCalledWith(org.projects);
+    expect(OrganizationActionCreator.fetchOrganizationDetails).toHaveBeenCalledWith(
+      api,
+      'org-slug',
+      true
+    );
     expect(GlobalSelectionStore.loadInitialData).toHaveBeenCalledWith(org, {});
   });
 
-  it('resets TeamStore when unmounting', async function() {
+  it('fetches new org when router params change', async function() {
     wrapper = createWrapper();
-    // This `tick` is so that we are not in the middle of a fetch data call when unmounting
-    // Otherwise will throw "setState on unmounted component" react warnings
     await tick();
-    jest.spyOn(TeamStore, 'reset');
-    wrapper.unmount();
-    expect(TeamStore.reset).toHaveBeenCalled();
-    TeamStore.reset.mockRestore();
-  });
-
-  it('fetches new org when router params change', function() {
-    wrapper = createWrapper();
-    MockApiClient.addMockResponse({
-      url: '/organizations/new-slug/environments/',
-      body: TestStubs.Environments(),
-    });
+    await tick();
     const mock = MockApiClient.addMockResponse({
       url: '/organizations/new-slug/',
       body: org,
     });
     wrapper.setProps({params: {orgId: 'new-slug'}});
+    // await fetching new org
+    await tick();
     wrapper.update();
 
     expect(mock).toHaveBeenLastCalledWith('/organizations/new-slug/', expect.anything());
   });
 
-  it('fetches new org when router location state is `refresh`', function() {
-    wrapper = createWrapper();
-    getOrgMock.mockReset();
-    wrapper.setProps({location: {state: 'refresh'}});
-    wrapper.update();
-
-    expect(getOrgMock).toHaveBeenLastCalledWith(
-      '/organizations/org-slug/',
-      expect.anything()
-    );
-  });
-
   it('shows loading error for non-superusers on 403s', async function() {
     getOrgMock = MockApiClient.addMockResponse({
       url: '/organizations/org-slug/',
@@ -118,9 +115,11 @@ describe('OrganizationContext', function() {
     console.error = jest.fn(); // eslint-disable-line no-console
     wrapper = createWrapper();
 
+    // await dispatching action
+    await tick();
+    // await resolving api, and updating component
     await tick();
     wrapper.update();
-
     expect(wrapper.find('LoadingError')).toHaveLength(1);
     console.error.mockRestore(); // eslint-disable-line no-console
   });
@@ -134,18 +133,16 @@ describe('OrganizationContext', function() {
       statusCode: 403,
     });
     wrapper = createWrapper();
-
+    // await dispatching action
+    await tick();
+    // await resolving api, and updating component
     await tick();
     wrapper.update();
 
     expect(openSudo).toHaveBeenCalled();
   });
 
-  it('uses last organization from ConfigStore', function() {
-    MockApiClient.addMockResponse({
-      url: '/organizations/lastOrganization/environments/',
-      body: TestStubs.Environments(),
-    });
+  it('uses last organization from ConfigStore', async function() {
     getOrgMock = MockApiClient.addMockResponse({
       url: '/organizations/lastOrganization/',
       body: org,
@@ -153,6 +150,10 @@ describe('OrganizationContext', function() {
     // mocking `.get('lastOrganization')`
     ConfigStore.get.mockImplementation(() => 'lastOrganization');
     wrapper = createWrapper({useLastOrganization: true, params: {}});
+    // await dispatching action
+    await tick();
+    // await dispatching the action to org store
+    await tick();
     expect(getOrgMock).toHaveBeenLastCalledWith(
       '/organizations/lastOrganization/',
       expect.anything()
@@ -201,6 +202,9 @@ describe('OrganizationContext', function() {
       organizationsLoading: true,
       organizations: [],
     });
+    // await dispatching action
+    await tick();
+    // await resolving api, and updating component
     await tick();
     wrapper.update();
     expect(wrapper.find('LoadingIndicator')).toHaveLength(0);
@@ -220,14 +224,18 @@ describe('OrganizationContext', function() {
   });
 
   it('does not call `GlobalSelectionStore.loadInitialData` on group details route', async function() {
+    expect(GlobalSelectionStore.loadInitialData).not.toHaveBeenCalled();
     wrapper = createWrapper({
       routes: [{path: '/organizations/:orgId/issues/:groupId/'}],
     });
+    // await dispatching action
+    await tick();
+    // await resolving api, and updating component
     await tick();
     wrapper.update();
 
     expect(wrapper.state('loading')).toBe(false);
-    expect(wrapper.state('error')).toBe(false);
+    expect(wrapper.state('error')).toBe(null);
 
     expect(GlobalSelectionStore.loadInitialData).not.toHaveBeenCalled();
   });
diff --git a/tests/js/spec/views/organizationDetails/organizationsDetails.spec.jsx b/tests/js/spec/views/organizationDetails/organizationsDetails.spec.jsx
index 74853fee0d..5e40bf910a 100644
--- a/tests/js/spec/views/organizationDetails/organizationsDetails.spec.jsx
+++ b/tests/js/spec/views/organizationDetails/organizationsDetails.spec.jsx
@@ -2,9 +2,11 @@ import React from 'react';
 import {mountWithTheme} from 'sentry-test/enzyme';
 
 import OrganizationDetails from 'app/views/organizationDetails';
+import OrganizationStore from 'app/stores/organizationStore';
 
 describe('OrganizationDetails', function() {
   beforeEach(function() {
+    OrganizationStore.reset();
     MockApiClient.clearMockResponses();
     MockApiClient.addMockResponse({
       url: '/broadcasts/',
@@ -42,7 +44,6 @@ describe('OrganizationDetails', function() {
         );
         expect(tree.find('button[aria-label="Restore Organization"]')).toHaveLength(1);
       });
-
       it('should render a restoration prompt without action for members', async function() {
         MockApiClient.addMockResponse({
           url: '/organizations/org-slug/',

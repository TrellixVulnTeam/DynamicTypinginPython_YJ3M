commit 00875b86696e4e0a961083fb45026ad7e5748718
Author: David Cramer <dcramer@gmail.com>
Date:   Mon Feb 11 21:32:52 2013 -0800

    Moar tests

diff --git a/src/sentry/counter/base.py b/src/sentry/counter/base.py
index 2673d7f81c..540020a7ac 100644
--- a/src/sentry/counter/base.py
+++ b/src/sentry/counter/base.py
@@ -28,9 +28,9 @@ class Counter(object):
     def __init__(self, **options):
         pass
 
-    def incr(self, amount, created=False, **kwargs):
+    def incr(self, amount, is_new=False, **kwargs):
         """
-        >>> incr(1, team_id=1, project_id=1, group_id=1, created=False)
+        >>> incr(1, team_id=1, project_id=1, group_id=1, is_new=False)
         """
         pass
 
diff --git a/src/sentry/counter/redis.py b/src/sentry/counter/redis.py
index e4f02d8946..b9191d55a7 100644
--- a/src/sentry/counter/redis.py
+++ b/src/sentry/counter/redis.py
@@ -34,27 +34,27 @@ class RedisCounter(Counter):
             'hosts': options['hosts'],
         })
 
-    def _make_key(self, key, value, when=None, unique=False):
+    def _make_key(self, key, value, when=None, is_new=False):
         """
         Returns a Redis-compatible key for the given key/value combination.
         """
         if when is None:
             when = time.time()
         when = int(when / 60)  # chop it down to the minute
-        return 'sentry.counter:%s:%s:%s=%s' % (when, int(unique), key, value)
+        return 'sentry.counter:%s:%s:%s=%s' % (when, int(is_new), key, value)
 
-    def incr(self, amount, created=False, **kwargs):
+    def incr(self, amount, is_new=False, **kwargs):
         now = time.time()
         with self.conn.map() as conn:
             keys = [self._make_key('global', '1', now)]
             keys.extend(self._make_key(k, v, now, False) for k, v in kwargs.iteritems())
-            if created:
+            if is_new:
                 keys.extend(self._make_key(k, v, now, True) for k, v in kwargs.iteritems())
             for key in keys:
                 conn.incr(key, amount)
                 conn.expire(key, self.key_expire)
 
-    def _get_count(self, key=None, value=None, minutes=None, unique=False):
+    def _get_count(self, key=None, value=None, minutes=None, is_new=False):
         if minutes is None:
             minutes = self.num_minutes
 
@@ -66,13 +66,13 @@ class RedisCounter(Counter):
         results = []
         with self.conn.map() as conn:
             for minute in xrange(minutes):
-                redis_key = self._make_key(key, value, now - (minute * 60), unique)
+                redis_key = self._make_key(key, value, now - (minute * 60), is_new)
                 results.append(conn.get(redis_key))
 
         return sum(int(r or 0) for r in results)
 
     def total(self, key, value, minutes=None):
-        return self._get_count(key, value, minutes=minutes, unique=False)
+        return self._get_count(key, value, minutes=minutes, is_new=False)
 
-    def unique(self, key, value, minutes=None):
-        return self._get_count(key, value, minutes=minutes, unique=True)
+    def new(self, key, value, minutes=None):
+        return self._get_count(key, value, minutes=minutes, is_new=True)
diff --git a/src/sentry/manager.py b/src/sentry/manager.py
index 20eca92835..60ea5710f4 100644
--- a/src/sentry/manager.py
+++ b/src/sentry/manager.py
@@ -606,8 +606,24 @@ class GroupManager(BaseManager, ChartMixin):
         except Exception, e:
             logger.exception('Unable to record tags: %s' % (e,))
 
+        # It's important that we increment short-counters without using the queue otherwise they could
+        # quickly become inaccurate
+        try:
+            self.incr_counters(group, is_new)
+        except Exception, e:
+            logger.exception('Unable to increment counters: %s' % (e,))
+
         return group, is_new, is_sample
 
+    def incr_counters(self, group, is_new):
+        app.counter.incr(
+            amount=1,
+            group_id=group.id,
+            team_id=group.team.id,
+            project_id=group.project.id,
+            is_new=is_new,
+        )
+
     def record_affected_user(self, group, user_ident, data=None):
         from sentry.models import TrackedUser, AffectedUserByGroup
 
diff --git a/tests/sentry/counter/redis/tests.py b/tests/sentry/counter/redis/tests.py
index 2516068c9f..1eb64d9340 100644
--- a/tests/sentry/counter/redis/tests.py
+++ b/tests/sentry/counter/redis/tests.py
@@ -27,26 +27,26 @@ class RedisCounterTest(TestCase):
         time = time.time
 
         time.return_value = 1360644295.816033
-        assert self.counter._make_key('team_id', 1) == 'sentry.counter:22677404:0:team_id=1'
+        assert self.counter._make_key('team_id', 1, is_new=False) == 'sentry.counter:22677404:0:team_id=1'
         time.assert_called_once_with()
 
         now = 1360654295.816033
-        assert self.counter._make_key('team_id', 1, now, unique=True) == 'sentry.counter:22677571:1:team_id=1'
+        assert self.counter._make_key('team_id', 1, now, is_new=True) == 'sentry.counter:22677571:1:team_id=1'
 
-        assert self.counter._make_key('project_id', 'foo', now, unique=True) == 'sentry.counter:22677571:1:project_id=foo'
+        assert self.counter._make_key('project_id', 'foo', now, is_new=True) == 'sentry.counter:22677571:1:project_id=foo'
 
     def test_all_the_things(self):
-        self.counter.incr(1, team_id=1, project_id=1, group_id=1, created=False)
-        self.counter.incr(1, team_id=1, project_id=1, group_id=1, created=True)
-        self.counter.incr(1, team_id=1, project_id=2, group_id=1, created=False)
-        self.counter.incr(2, team_id=1, project_id=2, group_id=2, created=True)
+        self.counter.incr(1, team_id=1, project_id=1, group_id=1, is_new=False)
+        self.counter.incr(1, team_id=1, project_id=1, group_id=1, is_new=True)
+        self.counter.incr(1, team_id=1, project_id=2, group_id=1, is_new=False)
+        self.counter.incr(2, team_id=1, project_id=2, group_id=2, is_new=True)
         assert self.counter.total('team_id', 1) == 5
         assert self.counter.total('project_id', 1) == 2
         assert self.counter.total('project_id', 2) == 3
         assert self.counter.total('group_id', 1) == 3
         assert self.counter.total('group_id', 2) == 2
-        assert self.counter.unique('team_id', 1) == 3
-        assert self.counter.unique('project_id', 1) == 1
-        assert self.counter.unique('project_id', 2) == 2
-        assert self.counter.unique('group_id', 1) == 1
-        assert self.counter.unique('group_id', 2) == 2
+        assert self.counter.new('team_id', 1) == 3
+        assert self.counter.new('project_id', 1) == 1
+        assert self.counter.new('project_id', 2) == 2
+        assert self.counter.new('group_id', 1) == 1
+        assert self.counter.new('group_id', 2) == 2
diff --git a/tests/sentry/manager/tests.py b/tests/sentry/manager/tests.py
index 049878a9f1..5a688817fa 100644
--- a/tests/sentry/manager/tests.py
+++ b/tests/sentry/manager/tests.py
@@ -246,6 +246,33 @@ class SentryManagerTest(TestCase):
         self.assertEquals(res.value, 'boz')
         self.assertEquals(res.times_seen, 1)
 
+    @mock.patch('sentry.manager.send_group_processors', mock.Mock())
+    @mock.patch('sentry.manager.GroupManager.incr_counters')
+    def test_calls_incr_counters(self, incr_counters):
+        event = Group.objects.from_kwargs(1, message='foo', tags=[('foo', 'bar')])
+        group = event.group
+        incr_counters.assert_called_once_with(group, True)
+
+    @mock.patch('sentry.manager.send_group_processors', mock.Mock())
+    @mock.patch('sentry.manager.GroupManager.incr_counters')
+    def test_handles_incr_counters_failure(self, incr_counters):
+        incr_counters.side_effect = Exception()
+        event = Group.objects.from_kwargs(1, message='foo')
+        group = event.group
+        incr_counters.assert_called_once_with(group, True)
+
+    @mock.patch('sentry.manager.app.counter.incr')
+    def test_incr_counters_calls_buffer(self, incr):
+        is_new = mock.Mock()
+        Group.objects.incr_counters(self.group, is_new=is_new)
+        incr.assert_called_once_with(
+            amount=1,
+            team_id=self.group.team.id,
+            project_id=self.group.project.id,
+            group_id=self.group.id,
+            is_new=is_new,
+        )
+
 
 class SearchManagerTest(TestCase):
     def test_search(self):

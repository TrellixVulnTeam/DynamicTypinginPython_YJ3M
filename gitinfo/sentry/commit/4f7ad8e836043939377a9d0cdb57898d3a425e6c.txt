commit 4f7ad8e836043939377a9d0cdb57898d3a425e6c
Author: Dan Fuller <dfuller@sentry.io>
Date:   Thu Sep 12 15:32:39 2019 -0700

    feat(api): Change alert rule updating to be at the org level (SEN-989)
    
    This make updating an alert rule happen at the org level. This operation is a little more
    complicated due to changes in which projects can be involved in an alert rule. We calculate the diff
    of projects passed compared to existing subscriptions and add/update/remove depending on the diff.

diff --git a/src/sentry/incidents/logic.py b/src/sentry/incidents/logic.py
index 463085a435..a412f88521 100644
--- a/src/sentry/incidents/logic.py
+++ b/src/sentry/incidents/logic.py
@@ -34,7 +34,7 @@ from sentry.incidents import tasks
 from sentry.snuba.subscriptions import (
     bulk_create_snuba_subscriptions,
     bulk_delete_snuba_subscriptions,
-    update_snuba_subscription,
+    bulk_update_snuba_subscriptions,
 )
 from sentry.utils.committers import get_event_file_committers
 from sentry.utils.snuba import bulk_raw_query, raw_query, SnubaQueryParams, SnubaTSResult, zerofill
@@ -630,6 +630,7 @@ def create_alert_rule(
 
 def update_alert_rule(
     alert_rule,
+    projects=None,
     name=None,
     threshold_type=None,
     query=None,
@@ -684,24 +685,66 @@ def update_alert_rule(
         updated_fields["threshold_period"] = threshold_period
 
     with transaction.atomic():
-        if query is not None or aggregation is not None or time_window is not None:
-            # TODO: We're assuming only one subscription for the moment
-            subscription = (
-                AlertRuleQuerySubscription.objects.select_related("query_subscription")
-                .get(alert_rule=alert_rule)
-                .query_subscription
-            )
-            # If updating any details of the query, update the Snuba subscription
-            update_snuba_subscription(
-                subscription,
-                query if query is not None else alert_rule.query,
-                aggregation
-                if aggregation is not None
-                else QueryAggregations(alert_rule.aggregation),
-                time_window if time_window else alert_rule.time_window,
+        alert_rule.update(**updated_fields)
+        existing_subs = []
+        if (
+            query is not None
+            or aggregation is not None
+            or time_window is not None
+            or projects is not None
+        ):
+            existing_subs = alert_rule.query_subscriptions.all().select_related("project")
+
+        if projects is not None:
+            existing_project_slugs = {sub.project.slug for sub in existing_subs}
+            # Determine whether we've added any new projects as part of this update
+            new_projects = [
+                project for project in projects if project.slug not in existing_project_slugs
+            ]
+            updated_project_slugs = {project.slug for project in projects}
+            # Find any subscriptions that were removed as part of this update
+            deleted_subs = [
+                sub for sub in existing_subs if sub.project.slug not in updated_project_slugs
+            ]
+            if new_projects:
+                new_subscriptions = bulk_create_snuba_subscriptions(
+                    new_projects,
+                    tasks.INCIDENTS_SNUBA_SUBSCRIPTION_TYPE,
+                    QueryDatasets(alert_rule.dataset),
+                    alert_rule.query,
+                    QueryAggregations(alert_rule.aggregation),
+                    alert_rule.time_window,
+                    DEFAULT_ALERT_RULE_RESOLUTION,
+                )
+                subscription_links = [
+                    AlertRuleQuerySubscription(
+                        query_subscription=subscription, alert_rule=alert_rule
+                    )
+                    for subscription in new_subscriptions
+                ]
+                AlertRuleQuerySubscription.objects.bulk_create(subscription_links)
+
+            if deleted_subs:
+                bulk_delete_snuba_subscriptions(deleted_subs)
+
+            # Remove any deleted subscriptions from `existing_subscriptions`, so that
+            # if we need to update any subscriptions we don't end up doing it twice. We
+            # don't add new subscriptions here since they'll already have the updated
+            # values
+            existing_subs = [sub for sub in existing_subs if sub.id]
+
+        if existing_subs and (
+            query is not None or aggregation is not None or time_window is not None
+        ):
+            # If updating any subscription details, update related Snuba subscriptions
+            # too
+            bulk_update_snuba_subscriptions(
+                existing_subs,
+                alert_rule.query,
+                QueryAggregations(alert_rule.aggregation),
+                alert_rule.time_window,
                 DEFAULT_ALERT_RULE_RESOLUTION,
             )
-        alert_rule.update(**updated_fields)
 
     return alert_rule
 
diff --git a/src/sentry/snuba/subscriptions.py b/src/sentry/snuba/subscriptions.py
index fc54ef2326..b21bd6b9c8 100644
--- a/src/sentry/snuba/subscriptions.py
+++ b/src/sentry/snuba/subscriptions.py
@@ -18,7 +18,7 @@ def bulk_create_snuba_subscriptions(
     projects, subscription_type, dataset, query, aggregation, time_window, resolution
 ):
     """
-    Creates a subscription to a snuba query.
+    Creates a subscription to a snuba query for each project.
 
     :param projects: The projects we're applying the query to
     :param subscription_type: Text identifier for the subscription type this is. Used
@@ -78,6 +78,27 @@ def create_snuba_subscription(
     )
 
 
+def bulk_update_snuba_subscriptions(subscriptions, query, aggregation, time_window, resolution):
+    """
+    Updates a list of query subscriptions.
+
+    :param subscriptions: The subscriptions we're updating
+    :param query: An event search query that we can parse and convert into a
+    set of Snuba conditions
+    :param aggregation: An aggregation to calculate over the time window
+    :param time_window: The time window to aggregate over
+    :param resolution: How often to receive updates/bucket size
+    :return: A list of QuerySubscriptions
+    """
+    updated_subscriptions = []
+    # TODO: Batch this up properly once we move to tasks.
+    for subscription in subscriptions:
+        updated_subscriptions.append(
+            update_snuba_subscription(subscription, query, aggregation, time_window, resolution)
+        )
+    return subscriptions
+
+
 def update_snuba_subscription(subscription, query, aggregation, time_window, resolution):
     """
     Updates a subscription to a snuba query.
diff --git a/tests/sentry/incidents/test_logic.py b/tests/sentry/incidents/test_logic.py
index b2b7c970e0..3a408eac80 100644
--- a/tests/sentry/incidents/test_logic.py
+++ b/tests/sentry/incidents/test_logic.py
@@ -856,8 +856,11 @@ class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
         resolve_threshold = 800
         threshold_period = 2
 
+        updated_projects = [self.project, self.create_project()]
+
         update_alert_rule(
             self.alert_rule,
+            projects=updated_projects,
             name=name,
             threshold_type=threshold_type,
             query=query,
@@ -868,6 +871,12 @@ class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
             threshold_period=threshold_period,
         )
         assert self.alert_rule.name == name
+        updated_subscriptions = self.alert_rule.query_subscriptions.all()
+        assert set([sub.project for sub in updated_subscriptions]) == set(updated_projects)
+        for subscription in updated_subscriptions:
+            assert subscription.query == query
+            assert subscription.aggregation == aggregation.value
+            assert subscription.time_window == time_window
         assert self.alert_rule.threshold_type == threshold_type.value
         assert self.alert_rule.query == query
         assert self.alert_rule.aggregation == aggregation.value
@@ -906,6 +915,44 @@ class UpdateAlertRuleTest(TestCase, BaseIncidentsTest):
         with self.assertRaises(InvalidSearchQuery):
             update_alert_rule(self.alert_rule, query="has:")
 
+    def test_delete_projects(self):
+        alert_rule = create_alert_rule(
+            self.organization,
+            [self.project, self.create_project()],
+            "something",
+            AlertRuleThresholdType.ABOVE,
+            "level:error",
+            QueryAggregations.TOTAL,
+            10,
+            1000,
+            400,
+            1,
+        )
+        update_alert_rule(alert_rule, [self.project])
+        assert self.alert_rule.query_subscriptions.get().project == self.project
+
+    def test_new_updated_deleted_projects(self):
+        alert_rule = create_alert_rule(
+            self.organization,
+            [self.project, self.create_project()],
+            "something",
+            AlertRuleThresholdType.ABOVE,
+            "level:error",
+            QueryAggregations.TOTAL,
+            10,
+            1000,
+            400,
+            1,
+        )
+        query_update = "level:warning"
+        new_project = self.create_project()
+        updated_projects = [self.project, new_project]
+        update_alert_rule(alert_rule, updated_projects, query=query_update)
+        updated_subscriptions = alert_rule.query_subscriptions.all()
+        assert set([sub.project for sub in updated_subscriptions]) == set(updated_projects)
+        for sub in updated_subscriptions:
+            assert sub.query == query_update
+
 
 class DeleteAlertRuleTest(TestCase, BaseIncidentsTest):
     @fixture

commit 0eb6dfebdb25c364f76cdce022cd18f270423cec
Author: Brett Hoerner <brett@bretthoerner.com>
Date:   Mon Nov 19 14:14:01 2018 -0600

    feat(snuba): Add Snuba search optimization path (#10612)
    
    * feat(snuba): Add Snuba search optimization path
    
    * Get project_group_count with Snuba.

diff --git a/src/sentry/options/defaults.py b/src/sentry/options/defaults.py
index 063747cfdd..c555c5049a 100644
--- a/src/sentry/options/defaults.py
+++ b/src/sentry/options/defaults.py
@@ -136,7 +136,11 @@ register('vsts.client-secret', flags=FLAG_PRIORITIZE_DISK)
 
 # Snuba
 register('snuba.use_group_id_column', default=True)
-register('snuba.search.max-pre-snuba-candidates', default=500)
+register('snuba.search.pre-snuba-candidates-optimizer', type=Bool, default=False)
+register('snuba.search.pre-snuba-candidates-percentage', default=0.2)
+register('snuba.search.project-group-count-cache-time', default=24 * 60 * 60)
+register('snuba.search.min-pre-snuba-candidates', default=500)
+register('snuba.search.max-pre-snuba-candidates', default=5000)
 register('snuba.search.chunk-growth-rate', default=1.5)
 register('snuba.search.max-chunk-size', default=2000)
 register('snuba.search.max-total-chunk-time-seconds', default=30.0)
diff --git a/src/sentry/search/snuba/backend.py b/src/sentry/search/snuba/backend.py
index dac5756076..9d7a8d4b91 100644
--- a/src/sentry/search/snuba/backend.py
+++ b/src/sentry/search/snuba/backend.py
@@ -16,6 +16,7 @@ from sentry.event_manager import ALLOWED_FUTURE_DELTA
 from sentry.models import Release, Group, GroupEnvironment
 from sentry.search.django import backend as ds
 from sentry.utils import snuba, metrics
+from sentry.utils.cache import cache
 from sentry.utils.dates import to_timestamp
 
 
@@ -240,17 +241,53 @@ class SnubaSearchBackend(ds.DjangoSearchBackend):
 
         assert start < end
 
-        # maximum number of Group IDs to send down to Snuba,
-        # if more Group ID candidates are found, a "bare" Snuba
-        # search is performed and the result groups are then
-        # post-filtered via queries to the Sentry DB
-        max_pre_snuba_candidates = options.get('snuba.search.max-pre-snuba-candidates')
+        # num_candidates is the number of Group IDs to send down to Snuba, if
+        # more Group ID candidates are found, a "bare" Snuba search is performed
+        # and the result groups are then post-filtered via queries to the Sentry DB
+        optimizer_enabled = options.get('snuba.search.pre-snuba-candidates-optimizer')
+        if optimizer_enabled:
+            key = 'snuba.search:project.group.count:%s' % project.id
+            project_group_count = cache.get(key)
+            if not project_group_count:
+                project_group_count = snuba.query(
+                    start=max(
+                        filter(None, [
+                            retention_window_start,
+                            now - timedelta(days=90)
+                        ])
+                    ),
+                    end=now,
+                    groupby=[],
+                    filter_keys={
+                        'project_id': [project.id],
+                    },
+                    aggregations=[['uniq', 'group_id', 'group_count']],
+                    referrer='search',
+                )
+
+                cache.set(key, project_group_count, options.get(
+                    'snuba.search.project-group-count-cache-time')
+                )
+
+            min_candidates = options.get('snuba.search.min-pre-snuba-candidates')
+            max_candidates = options.get('snuba.search.max-pre-snuba-candidates')
+            candidates_percentage = options.get('snuba.search.pre-snuba-candidates-percentage')
+
+            num_candidates = max(
+                min_candidates,
+                min(
+                    max_candidates,
+                    project_group_count * candidates_percentage
+                )
+            )
+        else:
+            num_candidates = options.get('snuba.search.min-pre-snuba-candidates')
 
         # pre-filter query
         candidate_ids = None
-        if max_pre_snuba_candidates and limit <= max_pre_snuba_candidates:
+        if num_candidates and limit <= num_candidates:
             candidate_ids = list(
-                group_queryset.values_list('id', flat=True)[:max_pre_snuba_candidates + 1]
+                group_queryset.values_list('id', flat=True)[:num_candidates + 1]
             )
             metrics.timing('snuba.search.num_candidates', len(candidate_ids))
 
@@ -258,12 +295,12 @@ class SnubaSearchBackend(ds.DjangoSearchBackend):
                 # no matches could possibly be found from this point on
                 metrics.incr('snuba.search.no_candidates')
                 return Paginator(Group.objects.none()).get_result()
-            elif len(candidate_ids) > max_pre_snuba_candidates:
+            elif len(candidate_ids) > num_candidates:
                 # If the pre-filter query didn't include anything to significantly
                 # filter down the number of results (from 'first_release', 'query',
                 # 'status', 'bookmarked_by', 'assigned_to', 'unassigned',
                 # 'subscribed_by', 'active_at_from', or 'active_at_to') then it
-                # might have surpassed the `max_pre_snuba_candidates`. In this case,
+                # might have surpassed the `num_candidates`. In this case,
                 # we *don't* want to pass candidates down to Snuba, and instead we
                 # want Snuba to do all the filtering/sorting it can and *then* apply
                 # this queryset to the results from Snuba, which we call

commit b61505ddda22401002f87a7674924c63ead8bca2
Author: Alberto Leal <mail4alberto@gmail.com>
Date:   Fri Nov 22 16:37:06 2019 -0500

    fix(discover2): Be able to delete columns on invalid queries (#15774)

diff --git a/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx b/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
index 4a4f3f8c1d..f7402ae979 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
@@ -58,14 +58,14 @@ export type Field = {
 const isSortEqualToField = (
   sort: Sort,
   field: Field,
-  tableDataMeta: MetaType
+  tableMeta: MetaType | undefined
 ): boolean => {
-  const sortKey = getSortKeyFromField(field, tableDataMeta);
+  const sortKey = getSortKeyFromField(field, tableMeta);
   return sort.field === sortKey;
 };
 
-const fieldToSort = (field: Field, tableDataMeta: MetaType): Sort | undefined => {
-  const sortKey = getSortKeyFromField(field, tableDataMeta);
+const fieldToSort = (field: Field, tableMeta: MetaType | undefined): Sort | undefined => {
+  const sortKey = getSortKeyFromField(field, tableMeta);
 
   if (!sortKey) {
     return void 0;
@@ -77,24 +77,21 @@ const fieldToSort = (field: Field, tableDataMeta: MetaType): Sort | undefined =>
   };
 };
 
-function getSortKeyFromFieldWithoutMeta(field: Field): string | null {
+function getSortKeyFromField(
+  field: Field,
+  tableMeta: MetaType | undefined
+): string | null {
   const column = getAggregateAlias(field.field);
   if (SPECIAL_FIELDS.hasOwnProperty(column)) {
     return SPECIAL_FIELDS[column as keyof typeof SPECIAL_FIELDS].sortField;
   }
 
-  return column;
-}
-
-function getSortKeyFromField(field: Field, tableDataMeta: MetaType): string | null {
-  const column = getAggregateAlias(field.field);
-  if (SPECIAL_FIELDS.hasOwnProperty(column)) {
-    return SPECIAL_FIELDS[column as keyof typeof SPECIAL_FIELDS].sortField;
+  if (!tableMeta) {
+    return column;
   }
 
-  if (FIELD_FORMATTERS.hasOwnProperty(tableDataMeta[column])) {
-    return FIELD_FORMATTERS[tableDataMeta[column] as keyof typeof FIELD_FORMATTERS]
-      .sortField
+  if (FIELD_FORMATTERS.hasOwnProperty(tableMeta[column])) {
+    return FIELD_FORMATTERS[tableMeta[column] as keyof typeof FIELD_FORMATTERS].sortField
       ? column
       : null;
   }
@@ -102,8 +99,8 @@ function getSortKeyFromField(field: Field, tableDataMeta: MetaType): string | nu
   return null;
 }
 
-export function isFieldSortable(field: Field, tableDataMeta: MetaType): boolean {
-  return !!getSortKeyFromField(field, tableDataMeta);
+export function isFieldSortable(field: Field, tableMeta: MetaType | undefined): boolean {
+  return !!getSortKeyFromField(field, tableMeta);
 }
 
 const generateFieldAsString = (props: {aggregation: string; field: string}): string => {
@@ -289,6 +286,10 @@ const queryStringFromSavedQuery = (saved: NewQuery | LegacySavedQuery): string =
   return '';
 };
 
+function validateTableMeta(tableMeta: MetaType | undefined): MetaType | undefined {
+  return tableMeta && Object.keys(tableMeta).length > 0 ? tableMeta : undefined;
+}
+
 class EventView {
   id: string | undefined;
   name: string | undefined;
@@ -327,7 +328,7 @@ class EventView {
 
     const sortKeys = fields
       .map(field => {
-        return getSortKeyFromFieldWithoutMeta(field);
+        return getSortKeyFromField(field, undefined);
       })
       .filter(
         (sortKey): sortKey is string => {
@@ -675,7 +676,7 @@ class EventView {
       field: string;
       fieldname: string;
     },
-    tableDataMeta: MetaType
+    tableMeta: MetaType | undefined
   ): EventView {
     const {field, aggregation, fieldname} = updatedColumn;
 
@@ -690,6 +691,9 @@ class EventView {
       return this;
     }
 
+    // ensure tableMeta is non-empty
+    tableMeta = validateTableMeta(tableMeta);
+
     const newEventView = this.clone();
 
     const updatedField: Field = {
@@ -706,14 +710,14 @@ class EventView {
     // it from the list of sorts
 
     const needleSortIndex = this.sorts.findIndex(sort => {
-      return isSortEqualToField(sort, columnToBeUpdated, tableDataMeta);
+      return isSortEqualToField(sort, columnToBeUpdated, tableMeta);
     });
 
     if (needleSortIndex >= 0) {
       const needleSort = this.sorts[needleSortIndex];
 
       const numOfColumns = this.fields.reduce((sum, currentField) => {
-        if (isSortEqualToField(needleSort, currentField, tableDataMeta)) {
+        if (isSortEqualToField(needleSort, currentField, tableMeta)) {
           return sum + 1;
         }
 
@@ -732,9 +736,9 @@ class EventView {
       if (newEventView.sorts.length <= 0 && newEventView.fields.length > 0) {
         // establish a default sort by finding the first sortable field
 
-        if (isFieldSortable(updatedField, tableDataMeta)) {
+        if (isFieldSortable(updatedField, tableMeta)) {
           // use the current updated field as the sort key
-          const sort = fieldToSort(updatedField, tableDataMeta)!;
+          const sort = fieldToSort(updatedField, tableMeta)!;
 
           // preserve the sort kind
           sort.kind = needleSort.kind;
@@ -742,11 +746,11 @@ class EventView {
           newEventView.sorts = [sort];
         } else {
           const sortableFieldIndex = newEventView.fields.findIndex(currentField => {
-            return isFieldSortable(currentField, tableDataMeta);
+            return isFieldSortable(currentField, tableMeta);
           });
           if (sortableFieldIndex >= 0) {
             const fieldToBeSorted = newEventView.fields[sortableFieldIndex];
-            const sort = fieldToSort(fieldToBeSorted, tableDataMeta)!;
+            const sort = fieldToSort(fieldToBeSorted, tableMeta)!;
             newEventView.sorts = [sort];
           }
         }
@@ -756,12 +760,15 @@ class EventView {
     return newEventView;
   }
 
-  withDeletedColumn(columnIndex: number, tableDataMeta: MetaType): EventView {
+  withDeletedColumn(columnIndex: number, tableMeta: MetaType | undefined): EventView {
     // Disallow removal of the orphan column, and check for out-of-bounds
     if (this.fields.length <= 1 || this.fields.length <= columnIndex || columnIndex < 0) {
       return this;
     }
 
+    // ensure tableMeta is non-empty
+    tableMeta = validateTableMeta(tableMeta);
+
     // delete the column
 
     const newEventView = this.clone();
@@ -776,14 +783,14 @@ class EventView {
     const columnToBeDeleted = this.fields[columnIndex];
 
     const needleSortIndex = this.sorts.findIndex(sort => {
-      return isSortEqualToField(sort, columnToBeDeleted, tableDataMeta);
+      return isSortEqualToField(sort, columnToBeDeleted, tableMeta);
     });
 
     if (needleSortIndex >= 0) {
       const needleSort = this.sorts[needleSortIndex];
 
       const numOfColumns = this.fields.reduce((sum, field) => {
-        if (isSortEqualToField(needleSort, field, tableDataMeta)) {
+        if (isSortEqualToField(needleSort, field, tableMeta)) {
           return sum + 1;
         }
 
@@ -802,12 +809,12 @@ class EventView {
           // establish a default sort by finding the first sortable field
 
           const sortableFieldIndex = newEventView.fields.findIndex(field => {
-            return isFieldSortable(field, tableDataMeta);
+            return isFieldSortable(field, tableMeta);
           });
 
           if (sortableFieldIndex >= 0) {
             const fieldToBeSorted = newEventView.fields[sortableFieldIndex];
-            const sort = fieldToSort(fieldToBeSorted, tableDataMeta)!;
+            const sort = fieldToSort(fieldToBeSorted, tableMeta)!;
             newEventView.sorts = [sort];
           }
         }
@@ -930,22 +937,22 @@ class EventView {
     return eventQuery;
   }
 
-  isFieldSorted(field: Field, tableDataMeta: MetaType): Sort | undefined {
+  isFieldSorted(field: Field, tableMeta: MetaType): Sort | undefined {
     const needle = this.sorts.find(sort => {
-      return isSortEqualToField(sort, field, tableDataMeta);
+      return isSortEqualToField(sort, field, tableMeta);
     });
 
     return needle;
   }
 
-  sortOnField(field: Field, tableDataMeta: MetaType): EventView {
+  sortOnField(field: Field, tableMeta: MetaType): EventView {
     // check if field can be sorted
-    if (!isFieldSortable(field, tableDataMeta)) {
+    if (!isFieldSortable(field, tableMeta)) {
       return this;
     }
 
     const needleIndex = this.sorts.findIndex(sort => {
-      return isSortEqualToField(sort, field, tableDataMeta);
+      return isSortEqualToField(sort, field, tableMeta);
     });
 
     if (needleIndex >= 0) {
@@ -966,7 +973,7 @@ class EventView {
     const newEventView = this.clone();
 
     // invariant: this is not falsey, since sortKey exists
-    const sort = fieldToSort(field, tableDataMeta)!;
+    const sort = fieldToSort(field, tableMeta)!;
 
     newEventView.sorts = [sort];
 
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
index 343890de3a..7fdd4012c7 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
@@ -108,21 +108,14 @@ class TableView extends React.Component<TableViewProps> {
   _updateColumn = (columnIndex: number, nextColumn: TableColumn<keyof TableDataRow>) => {
     const {location, eventView, tableData, organization} = this.props;
 
-    if (!tableData || !tableData.meta) {
-      return;
-    }
-
     const payload = {
       aggregation: String(nextColumn.aggregation),
       field: String(nextColumn.field),
       fieldname: nextColumn.name,
     };
 
-    const nextEventView = eventView.withUpdatedColumn(
-      columnIndex,
-      payload,
-      tableData.meta
-    );
+    const tableMeta = (tableData && tableData.meta) || undefined;
+    const nextEventView = eventView.withUpdatedColumn(columnIndex, payload, tableMeta);
 
     if (nextEventView !== eventView) {
       const changed: string[] = [];
@@ -170,13 +163,10 @@ class TableView extends React.Component<TableViewProps> {
   _deleteColumn = (columnIndex: number) => {
     const {location, eventView, tableData, organization} = this.props;
 
-    if (!tableData || !tableData.meta) {
-      return;
-    }
-
     const prevField = explodeField(eventView.fields[columnIndex]);
 
-    const nextEventView = eventView.withDeletedColumn(columnIndex, tableData.meta);
+    const tableMeta = (tableData && tableData.meta) || undefined;
+    const nextEventView = eventView.withDeletedColumn(columnIndex, tableMeta);
 
     // metrics
     trackAnalyticsEvent({
diff --git a/tests/js/spec/views/eventsV2/eventView.spec.jsx b/tests/js/spec/views/eventsV2/eventView.spec.jsx
index 2ce35e20a3..af89b4718a 100644
--- a/tests/js/spec/views/eventsV2/eventView.spec.jsx
+++ b/tests/js/spec/views/eventsV2/eventView.spec.jsx
@@ -1255,6 +1255,34 @@ describe('EventView.withUpdatedColumn()', function() {
 
       expect(eventView2).toMatchObject(nextState);
     });
+
+    it('using no provided table meta', function() {
+      // table meta may not be provided in the invalid query state;
+      // we will still want to be able to update columns
+
+      const eventView = new EventView(state);
+
+      const expected = {
+        ...state,
+        sorts: [{field: 'title', kind: 'desc'}],
+        fields: [{field: 'title', title: 'event title'}, state.fields[1]],
+      };
+
+      const newColumn = {
+        aggregation: '',
+        field: 'title',
+        fieldname: 'event title',
+      };
+
+      const eventView2 = eventView.withUpdatedColumn(0, newColumn, {});
+      expect(eventView2).toMatchObject(expected);
+
+      const eventView3 = eventView.withUpdatedColumn(0, newColumn);
+      expect(eventView3).toMatchObject(expected);
+
+      const eventView4 = eventView.withUpdatedColumn(0, newColumn, null);
+      expect(eventView4).toMatchObject(expected);
+    });
   });
 
   describe('update a column to a non-sortable column', function() {
@@ -1363,6 +1391,41 @@ describe('EventView.withDeletedColumn()', function() {
   });
 
   describe('deletes column, and use any remaining sortable column', function() {
+    it('using no provided table meta', function() {
+      // table meta may not be provided in the invalid query state;
+      // we will still want to be able to delete columns
+
+      const state2 = {
+        ...state,
+        fields: [
+          {field: 'title', title: 'title'},
+          {field: 'timestamp', title: 'timestamp'},
+          {field: 'count(id)', title: 'count(id)'},
+        ],
+        sorts: generateSorts(['timestamp']),
+      };
+
+      const eventView = new EventView(state2);
+
+      const expected = {
+        ...state,
+        sorts: generateSorts(['title']),
+        fields: [
+          {field: 'title', title: 'title'},
+          {field: 'count(id)', title: 'count(id)'},
+        ],
+      };
+
+      const eventView2 = eventView.withDeletedColumn(1, {});
+      expect(eventView2).toMatchObject(expected);
+
+      const eventView3 = eventView.withDeletedColumn(1);
+      expect(eventView3).toMatchObject(expected);
+
+      const eventView4 = eventView.withDeletedColumn(1, null);
+      expect(eventView4).toMatchObject(expected);
+    });
+
     it('has no remaining sortable column', function() {
       const eventView = new EventView(state);
 

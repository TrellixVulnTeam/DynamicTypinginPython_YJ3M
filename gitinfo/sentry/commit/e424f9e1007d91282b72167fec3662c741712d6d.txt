commit e424f9e1007d91282b72167fec3662c741712d6d
Author: Billy Vong <billyvg@users.noreply.github.com>
Date:   Thu Aug 15 12:43:47 2019 -0700

    feat(ui): Add resolution line and threshold shading to Incidenâ€¦ (#14347)

diff --git a/src/sentry/static/sentry/app/views/settings/components/forms/controls/rangeSlider.jsx b/src/sentry/static/sentry/app/views/settings/components/forms/controls/rangeSlider.jsx
index 39a2b81836..7d14220d46 100644
--- a/src/sentry/static/sentry/app/views/settings/components/forms/controls/rangeSlider.jsx
+++ b/src/sentry/static/sentry/app/views/settings/components/forms/controls/rangeSlider.jsx
@@ -46,6 +46,9 @@ class RangeSlider extends React.Component {
      */
     showCustomInput: PropTypes.bool,
 
+    // Placeholder for custom input
+    placeholder: PropTypes.string,
+
     /**
      * This is called when *any* MouseUp or KeyUp event happens.
      * Used for "smart" Fields to trigger a "blur" event. `onChange` can
@@ -137,7 +140,14 @@ class RangeSlider extends React.Component {
 
   render() {
     let {min, max, step} = this.props;
-    const {name, disabled, allowedValues, formatLabel, showCustomInput} = this.props;
+    const {
+      name,
+      disabled,
+      allowedValues,
+      formatLabel,
+      placeholder,
+      showCustomInput,
+    } = this.props;
     const {sliderValue} = this.state;
     let actualValue = sliderValue;
     let displayValue = actualValue;
@@ -174,6 +184,7 @@ class RangeSlider extends React.Component {
           />
           {showCustomInput && (
             <Input
+              placeholder={placeholder}
               value={sliderValue}
               onChange={this.handleCustomInputChange}
               onBlur={this.handleCustomInputBlur}
diff --git a/src/sentry/static/sentry/app/views/settings/projectIncidentRules/chart.tsx b/src/sentry/static/sentry/app/views/settings/projectIncidentRules/chart.tsx
index 1f43a828d5..734a3e5c15 100644
--- a/src/sentry/static/sentry/app/views/settings/projectIncidentRules/chart.tsx
+++ b/src/sentry/static/sentry/app/views/settings/projectIncidentRules/chart.tsx
@@ -8,17 +8,30 @@ import {Panel} from 'app/components/panels';
 import Graphic from 'app/components/charts/components/graphic';
 import LineChart from 'app/components/charts/lineChart';
 import space from 'app/styles/space';
+import theme from 'app/utils/theme';
 
 type Props = {
   data: Series[];
-  onChangeUpperBound: (upperBound: number) => void;
-  upperBound: number;
+  alertThreshold: number | null;
+  resolveThreshold: number | null;
+  isInverted: boolean;
+  onChangeIncidentThreshold: (alertThreshold: number) => void;
+  onChangeResolutionThreshold: (resolveThreshold: number) => void;
 };
+
 type State = {
   width: number;
+  height: number;
   yAxisMax: number | null;
 };
 
+const CHART_GRID = {
+  left: space(1),
+  right: space(1),
+  top: space(2),
+  bottom: space(1),
+};
+
 export default class IncidentRulesChart extends React.Component<Props, State> {
   static defaultProps = {
     data: [],
@@ -26,12 +39,13 @@ export default class IncidentRulesChart extends React.Component<Props, State> {
 
   state = {
     width: -1,
+    height: -1,
     yAxisMax: null,
   };
 
   componentDidUpdate(prevProps: Props) {
     if (
-      this.props.upperBound !== prevProps.upperBound ||
+      this.props.alertThreshold !== prevProps.alertThreshold ||
       this.props.data !== prevProps.data
     ) {
       this.handleUpdateChartAxis();
@@ -41,32 +55,49 @@ export default class IncidentRulesChart extends React.Component<Props, State> {
   chartRef: null | ECharts = null;
 
   // If we have ref to chart and data, try to update chart axis so that
-  // upperBound is visible in chart
+  // alertThreshold or resolveThreshold is visible in chart
   handleUpdateChartAxis = () => {
-    const {data, upperBound} = this.props;
-    if (this.chartRef && data.length && data[0].data) {
-      this.updateChartAxis(upperBound, data[0].data);
+    const {data, alertThreshold, resolveThreshold} = this.props;
+    if (
+      this.chartRef &&
+      data.length &&
+      data[0].data &&
+      (alertThreshold !== null || resolveThreshold !== null)
+    ) {
+      this.updateChartAxis(
+        Math.max(alertThreshold || 0, resolveThreshold || 0),
+        data[0].data
+      );
     }
   };
 
-  updateChartAxis = debounce((upperBound, dataArray: SeriesDataUnit[]) => {
+  updateChartAxis = debounce((threshold: number, dataArray: SeriesDataUnit[]) => {
     const max = maxBy(dataArray, ({value}) => value);
-    if (typeof max !== 'undefined' && upperBound > max) {
+    if (typeof max !== 'undefined' && threshold > max.value) {
       // We need to force update after we set a new yAxis max because `convertToPixel` will
       // can return a negitive position (probably because yAxisMax is not synced with chart yet)
-      this.setState({yAxisMax: Math.round(upperBound * 1.1)}, this.forceUpdate);
+      this.setState({yAxisMax: Math.round(threshold * 1.1)}, this.forceUpdate);
     } else {
       this.setState({yAxisMax: null});
     }
   }, 150);
 
-  setUpperBound = (pos: [number, number]) => {
+  setIncidentThreshold = (pos: [number, number]) => {
     if (!this.chartRef) {
       return;
     }
 
-    const upperBound = this.chartRef.convertFromPixel({gridIndex: 0}, pos)[1];
-    this.props.onChangeUpperBound(upperBound);
+    const alertThreshold = this.chartRef.convertFromPixel({gridIndex: 0}, pos)[1];
+    this.props.onChangeIncidentThreshold(alertThreshold);
+  };
+
+  setResolutionThreshold = (pos: [number, number]) => {
+    if (!this.chartRef) {
+      return;
+    }
+
+    const boundary = this.chartRef.convertFromPixel({gridIndex: 0}, pos)[1];
+    this.props.onChangeResolutionThreshold(boundary);
   };
 
   handleRef = (ref: ReactEchartsRef): void => {
@@ -75,10 +106,12 @@ export default class IncidentRulesChart extends React.Component<Props, State> {
     if (ref && typeof ref.getEchartsInstance === 'function' && !this.chartRef) {
       this.chartRef = ref.getEchartsInstance();
       const width = this.chartRef.getWidth();
+      const height = this.chartRef.getHeight();
       this.handleUpdateChartAxis();
-      if (width !== this.state.width) {
+      if (width !== this.state.width || height !== this.state.height) {
         this.setState({
           width,
+          height,
         });
       }
     }
@@ -88,45 +121,138 @@ export default class IncidentRulesChart extends React.Component<Props, State> {
     }
   };
 
-  handleUpperBoundDrag = _e => {};
+  getShadedThresholdPosition = (
+    isResolution: boolean,
+    position: number
+    // yAxisPosition: number
+  ) => {
+    const {isInverted} = this.props;
 
-  handleLowerBoundDrag = () => {};
+    // i.e. isInverted xor isResolution
+    // We shade the bottom area if:
+    // * we are shading the resolution and it is *NOT* inverted
+    // * we are shading the incident and it *IS* inverted
+    if (isInverted !== isResolution) {
+      return [0, position + 1];
+    }
 
-  render() {
-    const {width} = this.state;
+    // Otherwise shade the top area (`0,0` coordinates represents top left of chart)
+    return [0, 0];
+  };
 
-    const upperBoundPosition =
+  /**
+   * Draws the boundary lines and shaded areas for the chart.
+   */
+  getThresholdLine = (
+    position: string | any[] | null | number,
+    isResolution: boolean,
+    setFn: Function
+  ) => {
+    const {alertThreshold, resolveThreshold, isInverted} = this.props;
+
+    if (
+      typeof position !== 'number' ||
+      (isResolution && resolveThreshold === null) ||
+      (!isResolution && alertThreshold === null) ||
+      !this.state.height ||
+      !this.chartRef
+    ) {
+      return [];
+    }
+
+    const yAxisPixelPosition = this.chartRef.convertToPixel({yAxisIndex: 0}, '0');
+    const yAxisPosition = typeof yAxisPixelPosition === 'number' ? yAxisPixelPosition : 0;
+
+    const LINE_STYLE = {
+      stroke: theme.purpleLight,
+      lineDash: [2],
+    };
+
+    return [
+      // Draggable line
+      {
+        type: 'line',
+        // Resolution is considered "off" if it is -1
+        invisible: position === null,
+        draggable: true,
+        position: [0, position],
+        // We are doubling the width so that it looks like you are only able to drag along Y axis
+        // There doesn't seem to be a way in echarts to lock dragging to a single axis
+        shape: {y1: 1, y2: 1, x1: -this.state.width, x2: this.state.width * 2},
+        style: LINE_STYLE,
+        ondragend: e => {
+          setFn(e.target.position);
+        },
+        z: 101,
+      },
+      // This is the stationary line (e.g. when you drag, this stays in place while the other
+      // line moves to show user where they are moving the line)
+      {
+        type: 'line',
+        // Resolution is considered "off" if it is -1
+        invisible: position === null,
+        draggable: false,
+        position: [0, position],
+        shape: {y1: 1, y2: 1, x1: 0, x2: this.state.width},
+        style: LINE_STYLE,
+      },
+
+      // Shaded area for incident/resolutions to show user when they can expect to be alerted
+      // for incidents (or when they will be considered as resolved)
+      //
+      // Resolution is considered "off" if it is -1
+      ...(position !== null && [
+        {
+          type: 'rect',
+          draggable: false,
+
+          //
+          position: isResolution !== isInverted ? [0, position + 1] : [0, 0],
+          shape: {
+            width: this.state.width,
+            height: isResolution !== isInverted ? yAxisPosition - position : position,
+          },
+
+          style: {
+            fill: isResolution ? 'rgba(87, 190, 140, 0.1)' : 'rgba(220, 107, 107, 0.18)',
+          },
+
+          // This needs to be below the draggable line
+          z: 100,
+        },
+      ]),
+    ];
+  };
+
+  render() {
+    const alertThresholdPosition =
+      this.chartRef &&
+      this.chartRef.convertToPixel({yAxisIndex: 0}, `${this.props.alertThreshold}`);
+    const resolveThresholdPosition =
       this.chartRef &&
-      this.chartRef.convertToPixel({yAxisIndex: 0}, `${this.props.upperBound}`);
+      this.chartRef.convertToPixel({yAxisIndex: 0}, `${this.props.resolveThreshold}`);
 
     return (
       <ChartPanel>
         <LineChart
           isGroupedByDate
           forwardedRef={this.handleRef}
+          grid={CHART_GRID}
           yAxis={{
             max: this.state.yAxisMax,
           }}
           graphic={Graphic({
             elements: [
-              {
-                type: 'line',
-                invisible: false,
-                draggable: true,
-                position: [0, upperBoundPosition],
-                shape: {y1: 1, y2: 1, x1: -width, x2: width * 2},
-                ondragend: e => {
-                  this.setUpperBound(e.target.position);
-                },
-                z: 100,
-              },
-              {
-                type: 'line',
-                draggable: false,
-                position: [0, upperBoundPosition],
-                shape: {y1: 1, y2: 1, x1: 0, x2: width},
-                ondrag: () => {},
-              },
+              ...this.getThresholdLine(
+                alertThresholdPosition,
+                false,
+                this.setIncidentThreshold
+              ),
+              ...this.getThresholdLine(
+                resolveThresholdPosition,
+                true,
+                this.setResolutionThreshold
+              ),
             ],
           })}
           series={this.props.data}
@@ -139,5 +265,4 @@ export default class IncidentRulesChart extends React.Component<Props, State> {
 const ChartPanel = styled(Panel)`
   background-color: white;
   margin-bottom: ${space(1)};
-  padding: 0 ${space(1)};
 `;
diff --git a/src/sentry/static/sentry/app/views/settings/projectIncidentRules/constants.ts b/src/sentry/static/sentry/app/views/settings/projectIncidentRules/constants.ts
index 0cddb96afc..a0601c2d45 100644
--- a/src/sentry/static/sentry/app/views/settings/projectIncidentRules/constants.ts
+++ b/src/sentry/static/sentry/app/views/settings/projectIncidentRules/constants.ts
@@ -1,3 +1,8 @@
+export enum AlertRuleThreshold {
+  INCIDENT,
+  RESOLUTION,
+}
+
 export enum AlertRuleThresholdType {
   ABOVE,
   BELOW,
diff --git a/src/sentry/static/sentry/app/views/settings/projectIncidentRules/ruleForm.tsx b/src/sentry/static/sentry/app/views/settings/projectIncidentRules/ruleForm.tsx
index 921bfed504..cabcf12d07 100644
--- a/src/sentry/static/sentry/app/views/settings/projectIncidentRules/ruleForm.tsx
+++ b/src/sentry/static/sentry/app/views/settings/projectIncidentRules/ruleForm.tsx
@@ -4,30 +4,48 @@ import React from 'react';
 
 import {EventsStatsData, Organization, Project} from 'app/types';
 import {PanelAlert} from 'app/components/panels';
+import {addErrorMessage} from 'app/actionCreators/indicator';
 import {t} from 'app/locale';
 import EventsRequest from 'app/views/events/utils/eventsRequest';
 import Form from 'app/views/settings/components/forms/form';
 import JsonForm from 'app/views/settings/components/forms/jsonForm';
+import Placeholder from 'app/components/placeholder';
 import withApi from 'app/utils/withApi';
 import withOrganization from 'app/utils/withOrganization';
 import withProject from 'app/utils/withProject';
 
+import {
+  AlertRuleAggregations,
+  AlertRuleThreshold,
+  AlertRuleThresholdType,
+} from './constants';
+import {IncidentRule} from './types';
 import IncidentRulesChart from './chart';
-import {AlertRuleAggregations, AlertRuleThresholdType} from './constants';
 
 type Props = {
   api: any;
   data: EventsStatsData;
   organization: Organization;
   project: Project;
+  initialData?: IncidentRule;
 };
 
 type State = {
   width?: number;
-  upperBound: number;
+  aggregations: AlertRuleAggregations[];
+  isInverted: boolean;
+  timeWindow: number;
+  alertThreshold: number | null;
+  resolveThreshold: number | null;
 };
 
-const START_POSITION = 20;
+type AlertRuleThresholdKey = {
+  [AlertRuleThreshold.INCIDENT]: 'alertThreshold';
+  [AlertRuleThreshold.RESOLUTION]: 'resolveThreshold';
+};
+
+const DEFAULT_TIME_WINDOW = 60;
+const DEFAULT_METRIC = [AlertRuleAggregations.TOTAL];
 
 class RuleForm extends React.Component<Props, State> {
   static contextTypes = {
@@ -39,19 +57,138 @@ class RuleForm extends React.Component<Props, State> {
   };
 
   state = {
-    upperBound: START_POSITION,
+    aggregations: this.props.initialData
+      ? this.props.initialData.aggregations
+      : DEFAULT_METRIC,
+    isInverted: this.props.initialData
+      ? this.props.initialData.thresholdType === AlertRuleThresholdType.BELOW
+      : false,
+    timeWindow: this.props.initialData
+      ? this.props.initialData.timeWindow
+      : DEFAULT_TIME_WINDOW,
+    alertThreshold: this.props.initialData ? this.props.initialData.alertThreshold : null,
+    resolveThreshold: this.props.initialData
+      ? this.props.initialData.resolveThreshold
+      : null,
+  };
+
+  getThresholdKey = (
+    type: AlertRuleThreshold
+  ): AlertRuleThresholdKey[AlertRuleThreshold] =>
+    type === AlertRuleThreshold.RESOLUTION ? 'resolveThreshold' : 'alertThreshold';
+
+  /**
+   * Checks to see if threshold is valid given target value, and state of
+   * inverted threshold as well as the *other* threshold
+   *
+   * @param type The threshold type to be updated
+   * @param value The new threshold value
+   */
+  canUpdateThreshold = (type: AlertRuleThreshold, value: number): boolean => {
+    const isResolution = type === AlertRuleThreshold.RESOLUTION;
+    const otherKey = isResolution ? 'alertThreshold' : 'resolveThreshold';
+    const otherValue = this.state[otherKey];
+
+    // If other value is `null`, then there are no checks to perform against
+    if (otherValue === null) {
+      return true;
+    }
+
+    // If this is alert threshold and not inverted, it can't be below resolve
+    // If this is alert threshold and inverted, it can't be above resolve
+    // If this is resolve threshold and not inverted, it can't be above resolve
+    // If this is resolve threshold and inverted, it can't be below resolve
+    return !!this.state.isInverted !== isResolution
+      ? value <= otherValue
+      : value >= otherValue;
+  };
+
+  revertThresholdUpdate = () => {
+    addErrorMessage(t('Invalid threshold value'));
+    // Need to a re-render so that our chart re-renders and moves the draggable line back
+    // to its original position (since the drag update is not valid)
+    this.forceUpdate();
+  };
+
+  updateThresholdInput = (type: AlertRuleThreshold, value: number) => {
+    if (this.canUpdateThreshold(type, value)) {
+      this.setState(state => ({
+        ...state,
+        [this.getThresholdKey(type)]: value,
+      }));
+    } else {
+      this.revertThresholdUpdate();
+    }
   };
 
-  handleChangeUpperBoundInput = debounce(upperBound => {
-    this.setState({upperBound});
+  updateThreshold = (type: AlertRuleThreshold, value: number) => {
+    if (this.canUpdateThreshold(type, value)) {
+      const thresholdKey = this.getThresholdKey(type);
+      const newValue = Math.round(value);
+      this.setState(state => ({
+        ...state,
+        [thresholdKey]: newValue,
+      }));
+      this.context.form.setValue(thresholdKey, Math.round(newValue));
+    } else {
+      this.revertThresholdUpdate();
+    }
+  };
+
+  handleChangeIncidentThresholdInput = debounce((value: number) => {
+    this.updateThresholdInput(AlertRuleThreshold.INCIDENT, value);
+  }, 50);
+
+  handleChangeIncidentThreshold = (value: number) => {
+    this.updateThreshold(AlertRuleThreshold.INCIDENT, value);
+  };
+
+  handleChangeResolutionThresholdInput = debounce((value: number) => {
+    this.updateThresholdInput(AlertRuleThreshold.RESOLUTION, value);
   }, 50);
 
-  handleChangeUpperBound = upperBound => {
-    this.setState({upperBound});
-    this.context.form.setValue('alertThreshold', Math.round(upperBound));
+  handleChangeResolutionThreshold = (value: number) => {
+    this.updateThreshold(AlertRuleThreshold.RESOLUTION, value);
   };
+
+  handleTimeWindowChange = (timeWindow: number) => {
+    this.setState({timeWindow});
+  };
+
+  handleChangeMetric = (aggregations: AlertRuleAggregations) => {
+    this.setState({aggregations: [aggregations]});
+  };
+
+  /**
+   * Changes the threshold type (i.e. if thresholds are inverted or not)
+   */
+  handleChangeThresholdType = (value: boolean) => {
+    // Swap values and toggle `state.isInverted`, so they if invert it twice, they get their original values
+    this.setState(state => {
+      const oldValues = {
+        resolve: state.resolveThreshold,
+        alert: state.alertThreshold,
+      };
+
+      this.context.form.setValue('resolveThreshold', oldValues.alert);
+      this.context.form.setValue('alertThreshold', oldValues.resolve);
+      return {
+        isInverted: value,
+        resolveThreshold: oldValues.alert,
+        alertThreshold: oldValues.resolve,
+      };
+    });
+  };
+
   render() {
     const {api, organization, project} = this.props;
+    const {
+      aggregations,
+      alertThreshold,
+      resolveThreshold,
+      isInverted,
+      timeWindow,
+    } = this.state;
 
     return (
       <React.Fragment>
@@ -59,16 +196,26 @@ class RuleForm extends React.Component<Props, State> {
           api={api}
           organization={organization}
           project={[parseInt(project.id, 10)]}
-          interval="10m"
+          interval={`${timeWindow}s`}
+          yAxis={
+            aggregations[0] === AlertRuleAggregations.TOTAL ? 'event_count' : 'user_count'
+          }
           includePrevious={false}
         >
-          {({timeseriesData}) => (
-            <IncidentRulesChart
-              onChangeUpperBound={this.handleChangeUpperBound}
-              upperBound={this.state.upperBound}
-              data={timeseriesData}
-            />
-          )}
+          {({loading, timeseriesData}) =>
+            loading ? (
+              <Placeholder height="200px" bottomGutter={1} />
+            ) : (
+              <IncidentRulesChart
+                onChangeIncidentThreshold={this.handleChangeIncidentThreshold}
+                alertThreshold={alertThreshold}
+                onChangeResolutionThreshold={this.handleChangeResolutionThreshold}
+                resolveThreshold={resolveThreshold}
+                isInverted={isInverted}
+                data={timeseriesData}
+              />
+            )
+          }
         </EventsRequest>
         <JsonForm
           renderHeader={() => {
@@ -85,9 +232,9 @@ class RuleForm extends React.Component<Props, State> {
               title: t('Metric'),
               fields: [
                 {
-                  label: t('Metric'),
                   name: 'aggregations',
                   type: 'select',
+                  label: t('Metric'),
                   help: t('Choose which metric to display on the Y-axis'),
                   choices: [
                     [AlertRuleAggregations.UNIQUE_USERS, 'Users Affected'],
@@ -96,59 +243,75 @@ class RuleForm extends React.Component<Props, State> {
                   required: true,
                   setValue: value => (value && value.length ? value[0] : value),
                   getValue: value => [value],
+                  onChange: this.handleChangeMetric,
                 },
                 {
-                  label: t('Time Window'),
                   name: 'timeWindow',
-                  type: 'number',
-                  min: 1,
-                  max: 86400,
-                  placeholder: '60',
-                  help: t(
-                    'The time window to use when evaluating the Metric (in number of seconds)'
-                  ),
+                  type: 'select',
+                  label: t('Time Window'),
+                  help: t('The time window to use when evaluating the Metric'),
+                  onChange: this.handleTimeWindowChange,
+                  choices: [
+                    [60, t('1 minute')],
+                    [300, t('5 minutes')],
+                    [600, t('10 minutes')],
+                    [900, t('15 minutes')],
+                    [1800, t('30 minutes')],
+                    [3600, t('1 hour')],
+                    [7200, t('2 hours')],
+                    [14400, t('4 hours')],
+                    [86400, t('24 hours')],
+                  ],
                   required: true,
                 },
                 {
-                  label: t('Filter'),
                   name: 'query',
-                  defaultValue: '',
                   type: 'text',
+                  label: t('Filter'),
+                  defaultValue: '',
                   placeholder: 'error.type:TypeError',
                   help: t(
                     'You can apply standard Sentry filter syntax to filter by status, user, etc.'
                   ),
                 },
                 {
-                  label: t('Incident Boundary'),
                   name: 'alertThreshold',
                   type: 'range',
-                  help: t('Anything trending above this limit will trigger an Incident'),
-                  onChange: this.handleChangeUpperBoundInput,
+                  label: t('Incident Boundary'),
+                  help: !isInverted
+                    ? t('Anything trending above this limit will trigger an Incident')
+                    : t('Anything trending below this limit will trigger an Incident'),
+                  onChange: this.handleChangeIncidentThresholdInput,
                   showCustomInput: true,
                   required: true,
                 },
                 {
-                  label: t('Resolution Boundary'),
                   name: 'resolveThreshold',
                   type: 'range',
-                  help: t('Anything trending below this limit will resolve an Incident'),
+                  label: t('Resolution Threshold'),
+                  help: !isInverted
+                    ? t('Anything trending below this limit will resolve an Incident')
+                    : t('Anything trending above this limit will resolve an Incident'),
+                  onChange: this.handleChangeResolutionThresholdInput,
                   showCustomInput: true,
-                  required: true,
+                  placeholder: resolveThreshold === null ? t('Off') : '',
+                  ...(!isInverted && alertThreshold !== null && {max: alertThreshold}),
+                  ...(isInverted && alertThreshold !== null && {min: alertThreshold}),
                 },
                 {
-                  label: t('Use an inverted incident threshold'),
                   name: 'thresholdType',
                   type: 'boolean',
+                  label: t('Reverse the Boundaries'),
                   defaultValue: AlertRuleThresholdType.ABOVE,
                   help: t(
-                    'Alert me when the limit is trending below the incident boundary'
+                    'This is a metric that needs to stay above a certain threshold'
                   ),
+                  onChange: this.handleChangeThresholdType,
                 },
                 {
-                  label: t('Name'),
                   name: 'name',
                   type: 'text',
+                  label: t('Name'),
                   help: t('Give your Incident Rule a name so it is easy to manage later'),
                   placeholder: t('My Incident Rule Name'),
                   required: true,
@@ -169,7 +332,7 @@ type RuleFormContainerProps = {
   orgId: string;
   projectId: string;
   incidentRuleId?: string;
-  initialData?: {[key: string]: string | number | boolean | number[]};
+  initialData?: IncidentRule;
   onSubmitSuccess?: Function;
 };
 function RuleFormContainer({
@@ -191,13 +354,21 @@ function RuleFormContainer({
       }`}
       initialData={{
         query: '',
+        aggregations: DEFAULT_METRIC,
         thresholdType: AlertRuleThresholdType.ABOVE,
+        timeWindow: DEFAULT_TIME_WINDOW,
         ...initialData,
       }}
       saveOnBlur={false}
       onSubmitSuccess={onSubmitSuccess}
     >
-      <RuleForm api={api} project={project} organization={organization} {...props} />
+      <RuleForm
+        api={api}
+        project={project}
+        organization={organization}
+        initialData={initialData}
+        {...props}
+      />
     </Form>
   );
 }

commit 938a654a898d27f8bb2ecd67b98c7dd67380ce0a
Author: Lauryn Brown <lauryndbrown@gmail.com>
Date:   Mon Feb 11 13:06:24 2019 -0800

    feat(dashboards): Dashboard Details Endpoint (put method). (#11571)
    
    * Added put stuff.
    
    * updated put
    
    * Altered Dashboard details to only reorder existing widgets.
    
    * removed unused functions on the model.
    
    * Added tests and made changes.
    
    * Minor edits
    
    * moved dashboard serializer back to organization dashboards.
    
    * Fixed docstrings.
    
    * Update src/sentry/api/endpoints/organization_dashboard_details.py
    
    Co-Authored-By: lauryndbrown <lauryndbrown@gmail.com>
    
    * Renamed widget_titles to widget_ids
    
    * Corrected test error message.
    
    * updated get next order.
    
    * Added transaction atomic and hard delete to widgets reordered.
    
    * consolidated get_dashboard_order method to rest framework widgets file.
    
    * Added count to the filter query.
    
    * Added 409 instead.

diff --git a/src/sentry/api/bases/dashboard.py b/src/sentry/api/bases/dashboard.py
index 23a5df2d33..fb1877c765 100644
--- a/src/sentry/api/bases/dashboard.py
+++ b/src/sentry/api/bases/dashboard.py
@@ -1,7 +1,5 @@
 from __future__ import absolute_import
 
-from django.db.models import Max
-
 from sentry.api.bases.organization import (
     OrganizationEndpoint
 )
@@ -9,14 +7,6 @@ from sentry.api.exceptions import ResourceDoesNotExist
 from sentry.models import Dashboard, Widget
 
 
-def get_next_dashboard_order(dashboard_id):
-    max_order = Widget.objects.filter(
-        dashboard_id=dashboard_id,
-    ).aggregate(Max('order'))['order__max']
-
-    return max_order + 1 if max_order else 1
-
-
 class OrganizationDashboardEndpoint(OrganizationEndpoint):
     def convert_args(self, request, organization_slug, dashboard_id, *args, **kwargs):
         args, kwargs = super(OrganizationDashboardEndpoint,
diff --git a/src/sentry/api/endpoints/organization_dashboard_details.py b/src/sentry/api/endpoints/organization_dashboard_details.py
index e5b148a10b..2754271c92 100644
--- a/src/sentry/api/endpoints/organization_dashboard_details.py
+++ b/src/sentry/api/endpoints/organization_dashboard_details.py
@@ -1,11 +1,89 @@
 from __future__ import absolute_import
 
+from django.db import IntegrityError, transaction
+from rest_framework import serializers
+from rest_framework.response import Response
+
 from sentry.api.base import DocSection
 from sentry.api.bases.dashboard import (
     OrganizationDashboardEndpoint
 )
 from sentry.api.serializers import serialize
-from sentry.models import ObjectStatus
+from sentry.api.serializers.rest_framework import get_next_dashboard_order, ListField, ValidationError
+from sentry.models import ObjectStatus, Widget
+
+
+def remove_widgets(dashboard_widgets, widget_data):
+    """
+    Removes current widgets belonging to dashboard not in widget_data.
+    Returns remaining widgets.
+    """
+    widget_ids = [wd['id'] for wd in widget_data]
+    dashboard_widgets.exclude(
+        id__in=widget_ids
+    ).delete()
+    return dashboard_widgets.filter(
+        id__in=widget_ids
+    )
+
+
+def reorder_widgets(dashboard_id, widget_data):
+    """
+    Reorders Widgets given the relative order desired,
+    reorders widgets in the next possible set of numbers
+    i.e if order of widgets is 1, 2, 3
+        the reordered widgets will have order 4, 5, 6
+    """
+    dashboard_widgets = Widget.objects.filter(
+        dashboard_id=dashboard_id,
+    )
+    dashboard_widgets = list(remove_widgets(dashboard_widgets, widget_data))
+
+    # dashboard_widgets and widget_data should now have the same widgets
+    widget_data.sort(key=lambda x: x['order'])
+
+    next_order = get_next_dashboard_order(dashboard_id)
+    for index, data in enumerate(widget_data):
+        for widget in dashboard_widgets:
+            if widget.id == data['id']:
+                widget.order = next_order + index
+                widget.save()
+                break
+
+
+class WidgetSerializer(serializers.Serializer):
+    order = serializers.IntegerField(min_value=0, required=True)
+    id = serializers.IntegerField(min_value=0, required=True)
+
+
+class DashboardWithWidgetsSerializer(serializers.Serializer):
+    title = serializers.CharField(required=False)
+    widgets = ListField(
+        child=WidgetSerializer(),
+        required=False,
+        allow_null=True,
+    )
+
+    def validate_widgets(self, attrs, source):
+        try:
+            widgets = attrs[source]
+        except KeyError:
+            return attrs
+
+        if len(widgets) != len(set([w['order'] for w in widgets])):
+            raise ValidationError('Widgets must not have duplicate order values.')
+
+        widgets_count = Widget.objects.filter(
+            id__in=[w['id'] for w in widgets],
+            dashboard_id=self.context['dashboard_id'],
+            status=ObjectStatus.VISIBLE,
+        ).count()
+
+        if len(widgets) != widgets_count:
+            raise ValidationError(
+                'All widgets must exist within this dashboard prior to reordering.')
+
+        return attrs
 
 
 class OrganizationDashboardDetailsEndpoint(OrganizationDashboardEndpoint):
@@ -44,3 +122,40 @@ class OrganizationDashboardDetailsEndpoint(OrganizationDashboardEndpoint):
         dashboard.save()
 
         return self.respond(status=204)
+
+    def put(self, request, organization, dashboard):
+        """
+        Edit an Organization's Dashboard
+        ```````````````````````````````````
+
+        Edit an individual organization's dashboard as well as
+        bulk edits on widgets (i.e. rearranging widget order).
+
+        :pparam string organization_slug: the slug of the organization the
+                                          dashboard belongs to.
+        :pparam int dashboard_id: the id of the dashboard.
+        :param array widgets: the array of widgets (consisting of a widget id and the order)
+                            to be updated.
+        :auth: required
+        """
+        serializer = DashboardWithWidgetsSerializer(
+            data=request.DATA,
+            context={'dashboard_id': dashboard.id}
+        )
+
+        if not serializer.is_valid():
+            return Response(serializer.errors, status=400)
+        data = serializer.object
+        try:
+            with transaction.atomic():
+                title = data.get('title')
+                if title:
+                    dashboard.update(title=data['title'])
+
+                widgets = data.get('widgets')
+                if widgets:
+                    reorder_widgets(dashboard.id, widgets)
+        except IntegrityError:
+            return self.respond({'Dashboard with that title already exists'}, status=409)
+
+        return self.respond(serialize(dashboard, request.user), status=200)
diff --git a/src/sentry/api/endpoints/organization_dashboard_widgets.py b/src/sentry/api/endpoints/organization_dashboard_widgets.py
index 8904d96567..d0a83483e9 100644
--- a/src/sentry/api/endpoints/organization_dashboard_widgets.py
+++ b/src/sentry/api/endpoints/organization_dashboard_widgets.py
@@ -5,10 +5,10 @@ from rest_framework.response import Response
 
 from sentry.api.base import DocSection
 from sentry.api.bases.dashboard import (
-    OrganizationDashboardEndpoint, get_next_dashboard_order
+    OrganizationDashboardEndpoint
 )
 from sentry.api.serializers import serialize
-from sentry.api.serializers.rest_framework import WidgetSerializer
+from sentry.api.serializers.rest_framework import get_next_dashboard_order, WidgetSerializer
 from sentry.models import Widget, WidgetDataSource
 
 
diff --git a/src/sentry/api/serializers/rest_framework/widget.py b/src/sentry/api/serializers/rest_framework/widget.py
index 8e79f7178a..accbc4786e 100644
--- a/src/sentry/api/serializers/rest_framework/widget.py
+++ b/src/sentry/api/serializers/rest_framework/widget.py
@@ -1,10 +1,19 @@
 from __future__ import absolute_import
 
+from django.db.models import Max
 from rest_framework import serializers
 
 from sentry.api.bases.discoversavedquery import DiscoverSavedQuerySerializer
 from sentry.api.serializers.rest_framework import JSONField, ListField, ValidationError
-from sentry.models import WidgetDisplayTypes, WidgetDataSourceTypes
+from sentry.models import Widget, WidgetDisplayTypes, WidgetDataSourceTypes
+
+
+def get_next_dashboard_order(dashboard_id):
+    max_order = Widget.objects.filter(
+        dashboard_id=dashboard_id,
+    ).aggregate(Max('order'))['order__max']
+
+    return max_order + 1 if max_order else 1
 
 
 class WidgetDataSourceSerializer(serializers.Serializer):
diff --git a/tests/sentry/api/endpoints/test_organization_dashboard_details.py b/tests/sentry/api/endpoints/test_organization_dashboard_details.py
index 287e81a23c..2b86dfbf32 100644
--- a/tests/sentry/api/endpoints/test_organization_dashboard_details.py
+++ b/tests/sentry/api/endpoints/test_organization_dashboard_details.py
@@ -152,3 +152,174 @@ class OrganizationDashboardDetailsDeleteTest(OrganizationDashboardDetailsTestCas
         response = self.client.delete(self.url(1234567890))
         assert response.status_code == 404
         assert response.data == {u'detail': 'The requested resource does not exist'}
+
+
+class OrganizationDashboardDetailsPutTest(OrganizationDashboardDetailsTestCase):
+
+    def setUp(self):
+        super(OrganizationDashboardDetailsPutTest, self).setUp()
+        self.widget_3 = Widget.objects.create(
+            dashboard=self.dashboard,
+            order=3,
+            title='Widget 3',
+            display_type=WidgetDisplayTypes.LINE_CHART,
+        )
+        self.widget_4 = Widget.objects.create(
+            dashboard=self.dashboard,
+            order=4,
+            title='Widget 4',
+            display_type=WidgetDisplayTypes.LINE_CHART,
+        )
+        self.widget_ids = [self.widget_1.id, self.widget_2.id, self.widget_3.id, self.widget_4.id]
+
+    def assert_no_changes(self):
+        self.assert_dashboard_and_widgets(self.widget_ids, [1, 2, 3, 4])
+
+    def assert_dashboard_and_widgets(self, widget_ids, order):
+        assert Dashboard.objects.filter(
+            organization=self.organization,
+            id=self.dashboard.id
+        ).exists()
+
+        widgets = self.sort_by_order(Widget.objects.filter(
+            dashboard_id=self.dashboard.id,
+            status=ObjectStatus.VISIBLE,
+        ))
+        assert len(widgets) == len(list(widget_ids))
+
+        for widget, id, order in zip(widgets, widget_ids, order):
+            assert widget.id == id
+            assert widget.order == order
+
+    def test_put(self):
+        response = self.client.put(
+            self.url(self.dashboard.id),
+            data={
+                'title': 'Changed the title',
+                'widgets':
+                [
+                    {'order': 4, 'id': self.widget_1.id},
+                    {'order': 3, 'id': self.widget_2.id},
+                    {'order': 2, 'id': self.widget_3.id},
+                    {'order': 1, 'id': self.widget_4.id},
+                ]
+            }
+        )
+        assert response.status_code == 200
+        self.assert_dashboard_and_widgets(reversed(self.widget_ids), [5, 6, 7, 8])
+
+    def test_change_dashboard_title(self):
+        response = self.client.put(
+            self.url(self.dashboard.id),
+            data={'title': 'Dashboard Hello'}
+        )
+        assert response.status_code == 200
+        assert Dashboard.objects.filter(
+            title='Dashboard Hello',
+            organization=self.organization,
+            id=self.dashboard.id,
+        ).exists()
+
+    def test_reorder_widgets(self):
+        response = self.client.put(
+            self.url(self.dashboard.id),
+            data={
+                'widgets':
+                [
+                    {'order': 4, 'id': self.widget_1.id},
+                    {'order': 3, 'id': self.widget_2.id},
+                    {'order': 2, 'id': self.widget_3.id},
+                    {'order': 1, 'id': self.widget_4.id},
+                ]
+            }
+        )
+        assert response.status_code == 200
+        self.assert_dashboard_and_widgets(reversed(self.widget_ids), [5, 6, 7, 8])
+
+    def test_dashboard_does_not_exist(self):
+        response = self.client.put(self.url(1234567890))
+        assert response.status_code == 404
+        assert response.data == {u'detail': u'The requested resource does not exist'}
+
+    def test_duplicate_order(self):
+        response = self.client.put(
+            self.url(self.dashboard.id),
+            data={
+                'widgets':
+                [
+                    {'order': 4, 'id': self.widget_1.id},
+                    {'order': 4, 'id': self.widget_2.id},
+                    {'order': 2, 'id': self.widget_3.id},
+                    {'order': 1, 'id': self.widget_4.id},
+                ]
+            }
+        )
+        assert response.status_code == 400
+        assert response.data == {'widgets': [u'Widgets must not have duplicate order values.']}
+        self.assert_no_changes()
+
+    def test_partial_reordering_deletes_widgets(self):
+        response = self.client.put(
+            self.url(self.dashboard.id),
+            data={
+                'title': 'Changed the title',
+                'widgets':
+                [
+                    {'order': 2, 'id': self.widget_3.id},
+                    {'order': 1, 'id': self.widget_4.id},
+                ]
+            }
+        )
+        assert response.status_code == 200
+        self.assert_dashboard_and_widgets([self.widget_4.id, self.widget_3.id], [5, 6])
+        deleted_widget_ids = [self.widget_1.id, self.widget_2.id]
+        assert not Widget.objects.filter(id__in=deleted_widget_ids).exists()
+        assert not WidgetDataSource.objects.filter(widget_id__in=deleted_widget_ids).exists()
+
+    def test_widget_does_not_belong_to_dashboard(self):
+        widget = Widget.objects.create(
+            order=5,
+            dashboard=Dashboard.objects.create(
+                organization=self.organization,
+                title='Dashboard 2',
+                created_by=self.user,
+            ),
+            title='Widget 200',
+            display_type=WidgetDisplayTypes.LINE_CHART,
+        )
+        response = self.client.put(
+            self.url(self.dashboard.id),
+            data={
+                'widgets':
+                [
+                    {'order': 5, 'id': self.widget_1.id},
+                    {'order': 4, 'id': self.widget_2.id},
+                    {'order': 3, 'id': self.widget_3.id},
+                    {'order': 2, 'id': self.widget_4.id},
+                    {'order': 1, 'id': widget.id},
+                ]
+            }
+        )
+        assert response.status_code == 400
+        assert response.data == {
+            'widgets': [u'All widgets must exist within this dashboard prior to reordering.']}
+        self.assert_no_changes()
+
+    def test_widget_does_not_exist(self):
+        response = self.client.put(
+            self.url(self.dashboard.id),
+            data={
+                'widgets':
+                [
+                    {'order': 5, 'id': self.widget_1.id},
+                    {'order': 4, 'id': self.widget_2.id},
+                    {'order': 3, 'id': self.widget_3.id},
+                    {'order': 2, 'id': self.widget_4.id},
+                    {'order': 1, 'id': 1234567890},
+                ]
+            }
+        )
+        assert response.status_code == 400
+        assert response.data == {
+            'widgets': [u'All widgets must exist within this dashboard prior to reordering.']}
+        self.assert_no_changes()

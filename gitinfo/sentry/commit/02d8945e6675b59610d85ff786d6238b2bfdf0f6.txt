commit 02d8945e6675b59610d85ff786d6238b2bfdf0f6
Author: Ted Kaemming <ted@kaemming.com>
Date:   Tue Sep 22 18:14:25 2015 -0700

    Add a test for record addition.

diff --git a/src/sentry/digests/redis.py b/src/sentry/digests/redis.py
index e39174df78..2ddc3a9631 100644
--- a/src/sentry/digests/redis.py
+++ b/src/sentry/digests/redis.py
@@ -6,9 +6,7 @@ import logging
 import random
 import time
 from contextlib import contextmanager
-from datetime import datetime
 
-import pytz
 from django.conf import settings
 from rb import Cluster
 from redis.client import Script
@@ -102,10 +100,6 @@ add_to_schedule = Script(None, ADD_TO_SCHEDULE_SCRIPT)
 truncate_timeline = Script(None, TRUNCATE_TIMELINE_SCRIPT)
 
 
-def to_timestamp(value):
-    return (value - datetime(1970, 1, 1, tzinfo=pytz.utc)).total_seconds()
-
-
 class RedisBackend(Backend):
     def __init__(self, **options):
         super(RedisBackend, self).__init__(**options)
diff --git a/tests/sentry/digests/__init__.py b/tests/sentry/digests/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/tests/sentry/digests/test_redis.py b/tests/sentry/digests/test_redis.py
new file mode 100644
index 0000000000..3217d25217
--- /dev/null
+++ b/tests/sentry/digests/test_redis.py
@@ -0,0 +1,56 @@
+import functools
+from datetime import datetime
+
+import pytz
+
+from sentry.digests.base import (
+    Record,
+)
+from sentry.digests.redis import (
+    SCHEDULE_STATE_WAITING,
+    RedisBackend,
+    make_iteration_key,
+    make_timeline_key,
+    make_schedule_key,
+    make_record_key,
+)
+from sentry.testutils import TestCase
+
+
+def to_timestamp(value):
+    return (value - datetime(1970, 1, 1, tzinfo=pytz.utc)).total_seconds()
+
+
+class RedisBackendTestCase(TestCase):
+    def setUp(self):
+        self.backend = RedisBackend(
+            cluster={
+                'hosts': {
+                    0: {'db': 9},
+                },
+            },
+        )
+
+    def test_add_record(self):
+        record = Record('00000000000010008080808080808080', 'value', 0)
+        timeline = 'timeline'
+
+        timeline_key = make_timeline_key(self.backend.namespace, timeline)
+        connection = self.backend.cluster.get_local_client_for_key(timeline_key)
+
+        waiting_set_key = make_schedule_key(self.backend.namespace, SCHEDULE_STATE_WAITING)
+        record_key = make_record_key(timeline_key, record.key)
+
+        get_timeline_score_in_waiting_set = functools.partial(connection.zscore, waiting_set_key, timeline)
+        get_timeline_iteration_counter = functools.partial(connection.get, make_iteration_key(timeline_key))
+        get_record_score_in_timeline_set = functools.partial(connection.zscore, timeline_key, record.key)
+
+        def get_record_value():
+            value = connection.get(record_key)
+            return self.backend.codec.decode(value) if value is not None else None
+
+        with self.assertChanges(get_timeline_score_in_waiting_set, before=None, after=record.timestamp), \
+                self.assertChanges(get_timeline_iteration_counter, before=None, after='0'), \
+                self.assertChanges(get_record_score_in_timeline_set, before=None, after=record.timestamp), \
+                self.assertChanges(get_record_value, before=None, after=record.value):
+            self.backend.add(timeline, record)

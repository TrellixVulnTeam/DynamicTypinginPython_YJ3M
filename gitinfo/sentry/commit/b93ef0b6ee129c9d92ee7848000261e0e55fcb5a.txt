commit b93ef0b6ee129c9d92ee7848000261e0e55fcb5a
Author: Mark Story <mark@sentry.io>
Date:   Thu Mar 5 13:32:27 2020 -0500

    feat(discover) Use new column editor in discover2 (#17439)
    
    *Remove the previous column editor and start using the simpler to operate
    column editor. I've made several changes in how ColumnEditRow handles
    fields and field parameters to increase compatibility with unknown
    fields and older field aliases. This reduces the chances of creating
    broken states when dealing with existing saved queries.

diff --git a/docs-ui/components/columnEditor.stories.js b/docs-ui/components/columnEditor.stories.js
index 1225539ac8..cbfc8bfcbd 100644
--- a/docs-ui/components/columnEditor.stories.js
+++ b/docs-ui/components/columnEditor.stories.js
@@ -37,6 +37,14 @@ storiesOf('Discover|ColumnEditor', module).add(
         field: '',
         aggregation: 'p95',
       },
+      {
+        field: 'issue.id',
+        aggregation: '',
+      },
+      {
+        field: 'issue.id',
+        aggregation: 'count_unique',
+      },
     ];
 
     const showModal = () => {
diff --git a/src/sentry/static/sentry/app/components/gridEditable/gridHeadCell.tsx b/src/sentry/static/sentry/app/components/gridEditable/gridHeadCell.tsx
deleted file mode 100644
index f860dccff3..0000000000
--- a/src/sentry/static/sentry/app/components/gridEditable/gridHeadCell.tsx
+++ /dev/null
@@ -1,149 +0,0 @@
-import React from 'react';
-
-import InlineSvg from 'app/components/inlineSvg';
-import {IconEdit} from 'app/icons/iconEdit';
-
-import {
-  GridHeadCell as GridHeadCellWrapper,
-  GridHeadCellButton,
-  GridHeadCellButtonHover,
-  GridHeadCellButtonHoverButton,
-  GridHeadCellButtonHoverDraggable,
-} from './styles';
-import {GridColumnHeader} from './types';
-
-type DefaultProps = {
-  isFirst: boolean;
-  isEditing: boolean;
-  isDeletable: boolean;
-};
-
-export type GridHeadCellProps<Column> = DefaultProps & {
-  isColumnDragging: boolean;
-  gridHeadCellButtonProps: {[prop: string]: any};
-
-  indexColumnOrder: number;
-  column: Column;
-  children: React.ReactNode | React.ReactChild;
-
-  openModalAddColumnAt: (insertIndex: number) => void;
-
-  actions: {
-    moveColumnCommit: (indexFrom: number, indexTo: number) => void;
-    onDragStart: (
-      event: React.MouseEvent<SVGSVGElement, MouseEvent>,
-      indexFrom: number
-    ) => void;
-    deleteColumn: (index: number) => void;
-    toggleModalEditColumn: (index?: number, column?: Column) => void;
-  };
-};
-
-export type GridHeadCellState = {
-  isHovering: boolean;
-};
-
-/**
- * The GridHeadCell has several user interactions that result in different
- * states that are only specific to the header. This component aims to abstract
- * the complexity of GridHeadCell away.
- */
-class GridHeadCell<Column extends GridColumnHeader> extends React.Component<
-  GridHeadCellProps<Column>,
-  GridHeadCellState
-> {
-  static defaultProps: DefaultProps = {
-    isEditing: false,
-    isDeletable: true,
-    isFirst: false,
-  };
-
-  state = {
-    isHovering: false,
-  };
-
-  setHovering = (isHovering: boolean) => {
-    this.setState({isHovering});
-  };
-
-  deleteColumn = () => {
-    const {actions, indexColumnOrder} = this.props;
-    actions.deleteColumn(indexColumnOrder);
-  };
-
-  toggleModal = () => {
-    const {actions, indexColumnOrder, column} = this.props;
-    actions.toggleModalEditColumn(indexColumnOrder, column);
-  };
-
-  onDragStart = (event: React.MouseEvent<SVGSVGElement, MouseEvent>) => {
-    // hide hovers when dragging
-    this.setHovering(false);
-
-    const fromColumn = this.props.indexColumnOrder;
-    this.props.actions.onDragStart(event, fromColumn);
-  };
-
-  renderButtonHoverDraggable() {
-    const {isHovering} = this.state;
-    const {isEditing, isDeletable, isColumnDragging} = this.props;
-
-    if (!isEditing || !isHovering || isColumnDragging) {
-      return null;
-    }
-
-    const deleteButton = isDeletable ? (
-      <GridHeadCellButtonHoverButton onClick={this.deleteColumn}>
-        <InlineSvg src="icon-trash" />
-      </GridHeadCellButtonHoverButton>
-    ) : null;
-
-    return (
-      <React.Fragment>
-        {/* Ensure that background is always at the top. The background must be
-            independent because it has <100% opacity, but the elements on top
-            of it must be 100% opacity */}
-        <GridHeadCellButtonHover>
-          <GridHeadCellButtonHoverDraggable
-            src="icon-grabbable"
-            onMouseDown={this.onDragStart}
-          />
-
-          <div>
-            <GridHeadCellButtonHoverButton onClick={this.toggleModal}>
-              <IconEdit size="xs" />
-            </GridHeadCellButtonHoverButton>
-            {deleteButton}
-          </div>
-
-          <GridHeadCellButtonHoverDraggable
-            src="icon-grabbable"
-            onMouseDown={this.onDragStart}
-          />
-        </GridHeadCellButtonHover>
-      </React.Fragment>
-    );
-  }
-
-  render() {
-    const {isEditing, isFirst, children, column, gridHeadCellButtonProps} = this.props;
-
-    return (
-      <GridHeadCellWrapper isFirst={isFirst}>
-        <GridHeadCellButton
-          isDragging={column.isDragging}
-          {...gridHeadCellButtonProps}
-          isEditing={isEditing}
-          onMouseEnter={() => this.setHovering(true)}
-          onMouseMove={() => this.setHovering(true)}
-          onMouseLeave={() => this.setHovering(false)}
-        >
-          {children}
-          {this.renderButtonHoverDraggable()}
-        </GridHeadCellButton>
-      </GridHeadCellWrapper>
-    );
-  }
-}
-
-export default GridHeadCell;
diff --git a/src/sentry/static/sentry/app/components/gridEditable/gridModalEditColumn.tsx b/src/sentry/static/sentry/app/components/gridEditable/gridModalEditColumn.tsx
deleted file mode 100644
index 2eb1a3db48..0000000000
--- a/src/sentry/static/sentry/app/components/gridEditable/gridModalEditColumn.tsx
+++ /dev/null
@@ -1,62 +0,0 @@
-import React from 'react';
-
-import {t} from 'app/locale';
-
-export type GridModalEditColumnProps<Column> = {
-  indexColumnOrder?: number;
-  column?: Column;
-
-  renderBodyWithForm: (
-    indexColumnOrder?: number,
-    column?: Column,
-    onSubmit?: (column: Column) => void,
-    onSuccess?: () => void,
-    onError?: () => void
-  ) => React.ReactNode;
-  renderFooter: () => React.ReactNode;
-
-  /**
-   * These are props passed in by the openModal function
-   * See 'app/actionCreators/modal' for more info
-   */
-  Header: React.ComponentType;
-  Body: React.ComponentType;
-  Footer: React.ComponentType;
-  closeModal: () => void;
-};
-
-class GridModalEditColumn<Column> extends React.Component<
-  GridModalEditColumnProps<Column>
-> {
-  static defaultProps = {
-    data: {},
-  };
-
-  renderHeader() {
-    const {column} = this.props;
-    return <h4>{column ? t('Edit Column') : t('New Column')}</h4>;
-  }
-
-  render() {
-    const {
-      Header,
-      Body,
-      Footer,
-      closeModal,
-      indexColumnOrder,
-      column,
-      renderBodyWithForm,
-      renderFooter,
-    } = this.props;
-
-    return (
-      <React.Fragment>
-        <Header>{this.renderHeader()}</Header>
-        <Body>{renderBodyWithForm(indexColumnOrder, column, undefined, closeModal)}</Body>
-        <Footer>{renderFooter()}</Footer>
-      </React.Fragment>
-    );
-  }
-}
-
-export default GridModalEditColumn;
diff --git a/src/sentry/static/sentry/app/components/gridEditable/index.tsx b/src/sentry/static/sentry/app/components/gridEditable/index.tsx
index 488d3f8e86..7435ff3b89 100644
--- a/src/sentry/static/sentry/app/components/gridEditable/index.tsx
+++ b/src/sentry/static/sentry/app/components/gridEditable/index.tsx
@@ -1,14 +1,13 @@
 import React from 'react';
 
 import {t} from 'app/locale';
-import {openModal} from 'app/actionCreators/modal';
 import EmptyStateWarning from 'app/components/emptyStateWarning';
 import Feature from 'app/components/acl/feature';
 import FeatureDisabled from 'app/components/acl/featureDisabled';
 import Hovercard from 'app/components/hovercard';
 import InlineSvg from 'app/components/inlineSvg';
 import LoadingIndicator from 'app/components/loadingIndicator';
-import {IconAdd, IconEdit, IconWarning} from 'app/icons';
+import {IconEdit, IconWarning} from 'app/icons';
 import theme from 'app/utils/theme';
 
 import {
@@ -27,20 +26,16 @@ import {
   Grid,
   GridRow,
   GridHead,
+  GridHeadCell,
   GridHeadCellStatic,
   GridBody,
   GridBodyCell,
   GridBodyCellStatus,
   GridResizer,
 } from './styles';
-import GridHeadCell from './gridHeadCell';
-import GridModalEditColumn from './gridModalEditColumn';
 import {COL_WIDTH_MINIMUM, COL_WIDTH_UNDEFINED, ColResizeMetadata} from './utils';
 
 type GridEditableProps<DataRow, ColumnKey> = {
-  onToggleEdit?: (nextValue: boolean) => void;
-
-  gridHeadCellButtonProps?: {[prop: string]: any};
   /**
    * This is currently required as we only have one usage of
    * this component in the future. If we have more this could be
@@ -50,7 +45,6 @@ type GridEditableProps<DataRow, ColumnKey> = {
   noEditMessage?: string;
 
   isLoading?: boolean;
-  isColumnDragging: boolean;
   error?: React.ReactNode | null;
 
   /**
@@ -92,40 +86,18 @@ type GridEditableProps<DataRow, ColumnKey> = {
     prependColumnWidths?: string[];
   };
 
-  /**
-   * As GridEditable is unopinionated about the structure of GridColumn,
-   * ModalEditColumn relies on the parent component to provide the form layout
-   * and logic to create/update the columns
-   */
-  modalEditColumn: {
-    renderBodyWithForm: (
-      indexColumnOrder?: number,
-      column?: GridColumn<ColumnKey>,
-      onSubmit?: (column: GridColumn<ColumnKey>) => void,
-      onSuccess?: () => void,
-      onError?: () => void
-    ) => React.ReactNode;
-    renderFooter: () => React.ReactNode;
-  };
-
   /**
    * As there is no internal state being maintained, the parent component will
    * have to provide functions to update the state of the columns, especially
    * after moving/resizing
    */
   actions: {
-    moveColumnCommit: (indexFrom: number, indexTo: number) => void;
-    onDragStart: (
-      event: React.MouseEvent<SVGSVGElement, MouseEvent>,
-      indexFrom: number
-    ) => void;
-    deleteColumn: (index: number) => void;
+    editColumns: () => void;
     downloadAsCsv: () => void;
   };
 };
 
 type GridEditableState = {
-  isEditing: boolean;
   numColumn: number;
 };
 
@@ -147,7 +119,6 @@ class GridEditable<
 
   state = {
     numColumn: 0,
-    isEditing: false,
   };
 
   componentDidMount() {
@@ -208,8 +179,8 @@ class GridEditable<
       return;
     }
 
-    // <GridResizer> is nested 2 levels down from <GridHeadCell>
-    const cell = e.currentTarget!.parentElement!.parentElement;
+    // <GridResizer> is nested 1 level down from <GridHeadCell>
+    const cell = e.currentTarget!.parentElement;
     if (!cell) {
       return;
     }
@@ -257,41 +228,7 @@ class GridEditable<
   };
 
   handleToggleEdit = () => {
-    const nextValue = !this.state.isEditing;
-
-    if (this.props.onToggleEdit) {
-      this.props.onToggleEdit(nextValue);
-    }
-
-    this.setState({isEditing: nextValue});
-  };
-
-  /**
-   * Leave `insertIndex` as undefined to add new column to the end.
-   */
-  openModalAddColumnAt = (insertIndex: number = -1) => {
-    if (insertIndex < 0) {
-      insertIndex = this.props.columnOrder.length;
-    }
-
-    return this.toggleModalEditColumn(insertIndex);
-  };
-
-  toggleModalEditColumn = (
-    indexColumnOrder?: number,
-    column?: GridColumn<ColumnKey>
-  ): void => {
-    const {modalEditColumn} = this.props;
-
-    openModal(openModalProps => (
-      <GridModalEditColumn
-        {...openModalProps}
-        indexColumnOrder={indexColumnOrder}
-        column={column}
-        renderBodyWithForm={modalEditColumn.renderBodyWithForm}
-        renderFooter={modalEditColumn.renderFooter}
-      />
-    ));
+    this.props.actions.editColumns();
   };
 
   resizeGridColumn(e: MouseEvent, metadata: ColResizeMetadata) {
@@ -374,24 +311,13 @@ class GridEditable<
         {({hasFeature}) => (
           <React.Fragment>
             {this.renderDownloadCsvButton(hasFeature)}
-            {this.renderAddColumnButton(hasFeature)}
-            {this.renderEditButtons(hasFeature)}
+            {this.renderEditButton(hasFeature)}
           </React.Fragment>
         )}
       </Feature>
     );
   }
 
-  renderAddColumnButton(canEdit: boolean) {
-    const onClick = canEdit ? () => this.openModalAddColumnAt() : undefined;
-    return (
-      <HeaderButton disabled={!canEdit} onClick={onClick} data-test-id="grid-add-column">
-        <IconAdd size="xs" circle />
-        {t('Add Column')}
-      </HeaderButton>
-    );
-  }
-
   renderDownloadCsvButton(canEdit: boolean) {
     const disabled = this.props.isLoading || canEdit === false;
     const onClick = disabled ? undefined : this.props.actions.downloadAsCsv;
@@ -408,32 +334,18 @@ class GridEditable<
     );
   }
 
-  renderEditButtons(canEdit: boolean) {
+  renderEditButton(canEdit: boolean) {
     const onClick = canEdit ? this.handleToggleEdit : undefined;
-    if (!this.state.isEditing) {
-      return (
-        <HeaderButton
-          disabled={!canEdit}
-          onClick={onClick}
-          data-test-id="grid-edit-enable"
-        >
-          <IconEdit size="xs" />
-          {t('Edit Columns')}
-        </HeaderButton>
-      );
-    }
-
     return (
-      <HeaderButton onClick={onClick} data-test-id="grid-edit-disable">
-        <InlineSvg src="icon-circle-check" />
-        {t('Save & Close')}
+      <HeaderButton disabled={!canEdit} onClick={onClick} data-test-id="grid-edit-enable">
+        <IconEdit size="xs" />
+        {t('Edit Columns')}
       </HeaderButton>
     );
   }
 
   renderGridHead() {
-    const {error, isLoading, columnOrder, actions, grid, data} = this.props;
-    const {isEditing} = this.state;
+    const {error, isLoading, columnOrder, grid, data} = this.props;
 
     // Ensure that the last column cannot be removed
     const numColumn = columnOrder.length;
@@ -448,25 +360,9 @@ class GridEditable<
             <GridHeadCellStatic key={`prepend-${i}`}>{item}</GridHeadCellStatic>
           ))}
         {/* Note that this.onResizeMouseDown assumes GridResizer is nested
-            2 levels under GridHeadCell */
+            1 levels under GridHeadCell */
         columnOrder.map((column, i) => (
-          <GridHeadCell
-            openModalAddColumnAt={this.openModalAddColumnAt}
-            isFirst={i === 0}
-            key={`${i}.${column.key}`}
-            isColumnDragging={this.props.isColumnDragging}
-            isEditing={isEditing}
-            isDeletable={numColumn > 1}
-            indexColumnOrder={i}
-            column={column}
-            gridHeadCellButtonProps={this.props.gridHeadCellButtonProps || {}}
-            actions={{
-              moveColumnCommit: actions.moveColumnCommit,
-              onDragStart: actions.onDragStart,
-              deleteColumn: actions.deleteColumn,
-              toggleModalEditColumn: this.toggleModalEditColumn,
-            }}
-          >
+          <GridHeadCell key={`${i}.${column.key}`} isFirst={i === 0}>
             {grid.renderHeadCell ? grid.renderHeadCell(column, i) : column.name}
             {i !== numColumn - 1 && (
               <GridResizer
@@ -579,5 +475,4 @@ export {
   GridColumnHeader,
   GridColumnOrder,
   GridColumnSortBy,
-  GridModalEditColumn,
 };
diff --git a/src/sentry/static/sentry/app/components/gridEditable/styles.tsx b/src/sentry/static/sentry/app/components/gridEditable/styles.tsx
index f84740a8fa..fc09f24ad7 100644
--- a/src/sentry/static/sentry/app/components/gridEditable/styles.tsx
+++ b/src/sentry/static/sentry/app/components/gridEditable/styles.tsx
@@ -1,7 +1,6 @@
 import React from 'react';
 import styled from '@emotion/styled';
 
-import InlineSvg from 'app/components/inlineSvg';
 import {Panel, PanelBody} from 'app/components/panels';
 import space from 'app/styles/space';
 
@@ -21,12 +20,6 @@ const Z_INDEX_GRID = 5;
 // Parent context is GridHeadCell
 const Z_INDEX_GRID_RESIZER = 1;
 
-type GridEditableProps = {
-  isEditable?: boolean;
-  isEditing?: boolean;
-  isDragging?: boolean;
-};
-
 export const Header = styled('div')`
   display: flex;
   justify-content: space-between;
@@ -131,11 +124,30 @@ export const GridHeadCell = styled('th')<{isFirst: boolean}>`
   /* By default, a grid item cannot be smaller than the size of its content.
      We override this by setting min-width to be 0. */
   position: relative; /* Used by GridResizer */
-  min-width: 0;
   height: ${GRID_HEAD_ROW_HEIGHT}px;
+  display: flex;
+  align-items: center;
+  min-width: 24px;
+  padding: 0 ${space(2)};
+
   border-right: 1px solid transparent;
   border-left: 1px solid transparent;
   background-color: ${p => p.theme.offWhite};
+  color: ${p => p.theme.gray3};
+
+  font-size: ${p => p.theme.fontSizeSmall};
+  font-weight: 600;
+  text-transform: uppercase;
+  user-select: none;
+
+  a,
+  div {
+    line-height: 1.1;
+    color: inherit;
+    white-space: nowrap;
+    text-overflow: ellipsis;
+    overflow: hidden;
+  }
 
   &:first-child {
     border-top-left-radius: ${p => p.theme.borderRadius};
@@ -152,51 +164,6 @@ export const GridHeadCell = styled('th')<{isFirst: boolean}>`
   }
 `;
 
-export const GridHeadCellButton = styled('div')<GridEditableProps>`
-  display: block;
-  min-width: 24px;
-  margin: ${space(0.5)};
-  padding: ${space(1.5)};
-  border-radius: 2px;
-  font-size: 12px;
-  font-weight: 600;
-  line-height: 1;
-  text-transform: uppercase;
-  user-select: none;
-
-  background: ${p => {
-    if (p.isDragging) {
-      return p.theme.purple;
-    }
-
-    if (p.isEditing) {
-      return p.theme.offWhite2;
-    }
-
-    return 'none';
-  }};
-
-  color: ${p => {
-    if (p.isDragging) {
-      return p.theme.offWhite2;
-    }
-
-    if (p.isEditing) {
-      return p.theme.gray2;
-    }
-
-    return p.theme.gray3;
-  }};
-
-  a,
-  div {
-    color: inherit;
-    white-space: nowrap;
-    text-overflow: ellipsis;
-    overflow: hidden;
-  }
-`;
-
 /**
  * Create spacing/padding similar to GridHeadCellWrapper but
  * without interactive aspects.
@@ -205,9 +172,9 @@ export const GridHeadCellStatic = styled('th')`
   height: ${GRID_HEAD_ROW_HEIGHT}px;
   display: flex;
   align-items: center;
-  padding: ${space(2)};
+  padding: 0 ${space(2)};
   background-color: ${p => p.theme.offWhite};
-  font-size: 13px;
+  font-size: ${p => p.theme.fontSizeSmall};
   font-weight: 600;
   line-height: 1;
   text-transform: uppercase;
@@ -221,40 +188,6 @@ export const GridHeadCellStatic = styled('th')`
   }
 `;
 
-/**
- * GridHeadCellButtonHover is the collection of interactive elements to add or
- * move the columns. They are expected to be draggable.
- */
-export const GridHeadCellButtonHover = styled('div')<GridEditableProps>`
-  display: flex;
-  justify-content: space-between;
-  align-items: center;
-  position: absolute;
-  left: ${space(0.5)};
-  right: ${space(0.5)};
-  top: ${space(0.5)};
-  bottom: ${space(0.5)};
-`;
-
-export const GridHeadCellButtonHoverButton = styled('div')`
-  display: inline-flex;
-  justify-content: center;
-  align-items: center;
-  width: 24px;
-  height: 24px;
-  margin: 0 ${space(0.25)};
-  color: ${p => p.theme.gray4};
-  border: 2px solid ${p => p.theme.gray4};
-  background-color: ${p => p.theme.offWhite2};
-  border-radius: ${p => p.theme.borderRadius};
-  cursor: pointer;
-`;
-
-export const GridHeadCellButtonHoverDraggable = styled(InlineSvg)`
-  cursor: grab;
-  user-select: none;
-`;
-
 /**
  * GridBody are the collection of elements that contains and display the data
  * of the Grid. They are rather simple.
diff --git a/src/sentry/static/sentry/app/components/gridEditable/types.tsx b/src/sentry/static/sentry/app/components/gridEditable/types.tsx
index f79af613ba..d376b85fb0 100644
--- a/src/sentry/static/sentry/app/components/gridEditable/types.tsx
+++ b/src/sentry/static/sentry/app/components/gridEditable/types.tsx
@@ -14,7 +14,6 @@ export type GridColumn<K = ObjectKey> = {
 
 export type GridColumnHeader<K = ObjectKey> = GridColumn<K> & {
   name: string;
-  isDragging: boolean;
 };
 
 export type GridColumnOrder<K = ObjectKey> = GridColumnHeader<K>;
diff --git a/src/sentry/static/sentry/app/views/eventsV2/eventQueryParams.tsx b/src/sentry/static/sentry/app/views/eventsV2/eventQueryParams.tsx
index 81c013cf00..6af12f9804 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/eventQueryParams.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/eventQueryParams.tsx
@@ -22,7 +22,6 @@ export const AGGREGATIONS = {
   count: {
     parameters: [],
     outputType: 'number',
-    type: ['*'],
     isSortable: true,
   },
   count_unique: {
@@ -34,7 +33,6 @@ export const AGGREGATIONS = {
       },
     ],
     outputType: 'number',
-    type: ['*'],
     isSortable: true,
   },
   min: {
@@ -46,7 +44,6 @@ export const AGGREGATIONS = {
       },
     ],
     outputType: null,
-    type: ['timestamp', 'duration'],
     isSortable: true,
   },
   max: {
@@ -58,7 +55,6 @@ export const AGGREGATIONS = {
       },
     ],
     outputType: null,
-    type: ['timestamp', 'duration'],
     isSortable: true,
   },
   avg: {
@@ -70,7 +66,6 @@ export const AGGREGATIONS = {
       },
     ],
     outputType: null,
-    type: ['duration'],
     isSortable: true,
   },
   sum: {
@@ -82,20 +77,16 @@ export const AGGREGATIONS = {
       },
     ],
     outputType: null,
-    type: ['duration'],
     isSortable: true,
   },
-  /* TODO(mark) swap these in with the new column builder
   last_seen: {
     parameters: [],
     outputType: 'timestamp',
-    type: [],
     isSortable: true,
   },
   p75: {
     parameters: [],
     outputType: 'duration',
-    type: [],
     isSortable: true,
   },
   p95: {
@@ -107,10 +98,8 @@ export const AGGREGATIONS = {
   p99: {
     parameters: [],
     outputType: 'duration',
-    type: [],
     isSortable: true,
   },
-  */
 } as const;
 
 assert(
@@ -120,7 +109,6 @@ assert(
         parameters: Readonly<AggregateParameter[]>;
         // null means to inherit from the column.
         outputType: null | ColumnType;
-        type: Readonly<ColumnType[]>;
         isSortable: boolean;
       };
     }
@@ -202,14 +190,8 @@ export const FIELDS = {
   // Field alises defined in src/sentry/api/event_search.py
   project: 'string',
   issue: 'string',
-
-  // TODO(mark) Remove these with the new column builder.
-  last_seen: 'timestamp',
-  p75: 'duration',
-  p95: 'duration',
-  p99: 'duration',
 } as const;
-assert(FIELDS as Readonly<{[key in keyof typeof FIELDS]: ColumnValueType}>);
+assert(FIELDS as Readonly<{[key in keyof typeof FIELDS]: ColumnType}>);
 
 export type Field = keyof typeof FIELDS | string | '';
 
@@ -227,3 +209,17 @@ export const TRACING_FIELDS = [
   'p75',
   'error_rate',
 ];
+
+// In the early days of discover2 these functions were exposed
+// as simple fields. Until we clean up all the saved queries we
+// need this for backwards compatibility.
+export const FIELD_ALIASES = [
+  'apdex',
+  'impact',
+  'p99',
+  'p95',
+  'p75',
+  'error_rate',
+  'last_seen',
+  'latest_event',
+];
diff --git a/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx b/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
index 1506173fc9..e925fd6f60 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/eventView.tsx
@@ -108,12 +108,9 @@ export function isFieldSortable(field: Field, tableMeta: MetaType | undefined):
 
 const generateFieldAsString = (props: {aggregation: string; field: string}): string => {
   const {aggregation, field} = props;
-
   const hasAggregation = aggregation.length > 0;
 
-  const fieldAsString = hasAggregation ? `${aggregation}(${field})` : field;
-
-  return fieldAsString;
+  return hasAggregation ? `${aggregation}(${field})` : field;
 };
 
 const decodeFields = (location: Location): Array<Field> => {
@@ -572,28 +569,58 @@ class EventView {
     });
   }
 
+  withColumns(columns: Column[]): EventView {
+    const newEventView = this.clone();
+    const fields: Field[] = columns
+      .map(col => generateFieldAsString(col))
+      .map((field, i) => {
+        // newly added field
+        if (!newEventView.fields[i]) {
+          return {field, width: COL_WIDTH_UNDEFINED};
+        }
+        // Existing columns that were not re ordered should retain
+        // their old widths.
+        const existing = newEventView.fields[i];
+        const width =
+          existing.field === field && existing.width !== undefined
+            ? existing.width
+            : COL_WIDTH_UNDEFINED;
+        return {field, width};
+      });
+    newEventView.fields = fields;
+
+    // Update sorts as sorted fields may have been removed.
+    if (newEventView.sorts) {
+      // Filter the sort fields down to those that are still selected.
+      const sortKeys = fields.map(field => fieldToSort(field, undefined)?.field);
+      const newSort = newEventView.sorts.filter(
+        sort => sort && sortKeys.includes(sort.field)
+      );
+      // If the sort field was removed, try and find a new sortable column.
+      if (newSort.length === 0) {
+        const sortField = fields.find(field => isFieldSortable(field, undefined));
+        if (sortField) {
+          newSort.push({field: sortField.field, kind: 'desc'});
+        }
+      }
+      newEventView.sorts = newSort;
+    }
+
+    return newEventView;
+  }
+
   withNewColumn(newColumn: Column): EventView {
-    const field = newColumn.field.trim();
-    const aggregation = newColumn.aggregation.trim();
-    const fieldAsString = generateFieldAsString({field, aggregation});
+    const fieldAsString = generateFieldAsString(newColumn);
     const newField: Field = {
       field: fieldAsString,
       width: newColumn.width || COL_WIDTH_UNDEFINED,
     };
-
     const newEventView = this.clone();
     newEventView.fields = [...newEventView.fields, newField];
 
     return newEventView;
   }
 
-  withNewColumnAt(newColumn: Column, insertIndex: number): EventView {
-    const newEventView = this.withNewColumn(newColumn);
-    const fromIndex = newEventView.fields.length - 1;
-
-    return newEventView.withMovedColumn({fromIndex, toIndex: insertIndex});
-  }
-
   withUpdatedColumn(
     columnIndex: number,
     updatedColumn: Column,
diff --git a/src/sentry/static/sentry/app/views/eventsV2/sortLink.tsx b/src/sentry/static/sentry/app/views/eventsV2/sortLink.tsx
index 57c130e2ea..fddfd0703e 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/sortLink.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/sortLink.tsx
@@ -67,9 +67,8 @@ const StyledLink = styled((props: StyledLinkProps) => {
   return <Link {...forwardProps} />;
 })`
   display: block;
+  width: 100%;
   white-space: nowrap;
-  text-overflow: ellipsis;
-  overflow: hidden;
   color: inherit;
 
   &:hover,
@@ -83,6 +82,8 @@ const StyledLink = styled((props: StyledLinkProps) => {
 `;
 
 const StyledNonLink = styled('div')<{align: Alignments}>`
+  display: block;
+  width: 100%;
   white-space: nowrap;
   ${(p: {align: Alignments}) => (p.align ? `text-align: ${p.align};` : '')}
 `;
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditCollection.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditCollection.tsx
index 1732b47bf1..bec398595a 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditCollection.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditCollection.tsx
@@ -15,13 +15,14 @@ import theme from 'app/utils/theme';
 
 import {AGGREGATIONS, FIELDS, TRACING_FIELDS} from '../eventQueryParams';
 import {Column} from '../eventView';
-import {ColumnEditRow, FieldValue, FieldValueKind} from './columnEditRow';
+import {FieldValue, FieldValueKind} from './types';
+import {ColumnEditRow} from './columnEditRow';
 
 type Props = {
   // Input columns
   columns: Column[];
   organization: OrganizationSummary;
-  tagKeys: string[];
+  tagKeys: null | string[];
   // Fired when columns are added/removed/modified
   onChange: (columns: Column[]) => void;
 };
@@ -39,6 +40,11 @@ type State = {
 const DRAG_CLASS = 'draggable-item';
 const GRAB_HANDLE_FUDGE = 25;
 
+enum PlaceholderPosition {
+  TOP,
+  BOTTOM,
+}
+
 class ColumnEditCollection extends React.Component<Props, State> {
   state = {
     isDragging: false,
@@ -125,15 +131,17 @@ class ColumnEditCollection extends React.Component<Props, State> {
       };
     });
 
-    tagKeys.forEach(tag => {
-      fieldOptions[`tag:${tag}`] = {
-        label: tag,
-        value: {
-          kind: FieldValueKind.TAG,
-          meta: {name: tag, dataType: 'string'},
-        },
-      };
-    });
+    if (tagKeys !== null) {
+      tagKeys.forEach(tag => {
+        fieldOptions[`tag:${tag}`] = {
+          label: tag,
+          value: {
+            kind: FieldValueKind.TAG,
+            meta: {name: tag, dataType: 'string'},
+          },
+        };
+      });
+    }
 
     this.setState({fieldOptions});
   }
@@ -206,7 +214,7 @@ class ColumnEditCollection extends React.Component<Props, State> {
     // Find the item that the ghost is currently over.
     const targetIndex = Array.from(dragItems).findIndex(dragItem => {
       const rects = dragItem.getBoundingClientRect();
-      const top = event.pageY;
+      const top = event.clientY;
 
       const thresholdStart = rects.top;
       const thresholdEnd = rects.top + rects.height;
@@ -269,51 +277,78 @@ class ColumnEditCollection extends React.Component<Props, State> {
     };
     const ghost = (
       <Ghost ref={this.dragGhostRef} style={style}>
-        {this.renderItem(col, index, true, true)}
+        {this.renderItem(col, index, {isGhost: true})}
       </Ghost>
     );
 
     return ReactDOM.createPortal(ghost, this.portal);
   }
 
-  renderItem(col: Column, i: number, canDelete: boolean, isGhost: boolean = false) {
-    const {isDragging, draggingTargetIndex, fieldOptions} = this.state;
+  renderItem(
+    col: Column,
+    i: number,
+    {canDelete = true, isGhost = false}: {canDelete?: boolean; isGhost?: boolean}
+  ) {
+    const {isDragging, draggingTargetIndex, draggingIndex, fieldOptions} = this.state;
 
-    // Replace the dragged row with a placeholder.
+    let placeholder: React.ReactNode = null;
+    // Add a placeholder above the target row.
     if (isDragging && isGhost === false && draggingTargetIndex === i) {
-      return <DragPlaceholder key={`placeholder-${i}`} className={DRAG_CLASS} />;
+      placeholder = (
+        <DragPlaceholder
+          key={`placeholder:${col.aggregation}:${col.field}`}
+          className={DRAG_CLASS}
+        />
+      );
+    }
+
+    // If the current row is the row in the drag ghost return the placeholder
+    // or a hole if the placeholder is elsewhere.
+    if (isDragging && isGhost === false && draggingIndex === i) {
+      return placeholder;
     }
 
+    const position =
+      Number(draggingTargetIndex) <= Number(draggingIndex)
+        ? PlaceholderPosition.TOP
+        : PlaceholderPosition.BOTTOM;
+
     return (
-      <RowContainer key={`container-${i}`}>
-        {canDelete ? (
-          <IconButton
-            aria-label={t('Drag to reorder columns')}
-            onMouseDown={event => this.startDrag(event, i)}
-          >
-            <IconGrabbable size="sm" />
-          </IconButton>
-        ) : (
-          <span />
-        )}
-        <ColumnEditRow
-          className={DRAG_CLASS}
-          fieldOptions={fieldOptions}
-          column={col}
-          parentIndex={i}
-          onChange={this.handleUpdateColumn}
-        />
-        {canDelete ? (
-          <IconButton
-            aria-label={t('Remove column')}
-            onClick={() => this.removeColumn(i)}
-          >
-            <IconClose size="sm" />
-          </IconButton>
-        ) : (
-          <span />
-        )}
-      </RowContainer>
+      <React.Fragment>
+        {position === PlaceholderPosition.TOP && placeholder}
+        <RowContainer
+          className={isGhost ? '' : DRAG_CLASS}
+          key={`container:${col.aggregation}:${col.field}:${isGhost}`}
+        >
+          {canDelete ? (
+            <IconButton
+              aria-label={t('Drag to reorder columns')}
+              onMouseDown={event => this.startDrag(event, i)}
+            >
+              <IconGrabbable size="sm" />
+            </IconButton>
+          ) : (
+            <span />
+          )}
+          <ColumnEditRow
+            fieldOptions={fieldOptions}
+            column={col}
+            parentIndex={i}
+            onChange={this.handleUpdateColumn}
+          />
+          {canDelete ? (
+            <IconButton
+              aria-label={t('Remove column')}
+              onClick={() => this.removeColumn(i)}
+            >
+              <IconClose size="sm" />
+            </IconButton>
+          ) : (
+            <span />
+          )}
+        </RowContainer>
+        {position === PlaceholderPosition.BOTTOM && placeholder}
+      </React.Fragment>
     );
   }
 
@@ -329,7 +364,7 @@ class ColumnEditCollection extends React.Component<Props, State> {
             <strong>{t('Field Parameter')}</strong>
           </Heading>
         </RowContainer>
-        {columns.map((col: Column, i: number) => this.renderItem(col, i, canDelete))}
+        {columns.map((col: Column, i: number) => this.renderItem(col, i, {canDelete}))}
         <RowContainer>
           <Actions>
             <Button size="xsmall" onClick={this.handleAddColumn}>
@@ -349,7 +384,7 @@ const RowContainer = styled('div')`
   align-items: center;
   width: 100%;
 
-  margin-bottom: ${space(1)};
+  padding-bottom: ${space(1)};
 `;
 
 const Ghost = styled('div')`
@@ -364,7 +399,7 @@ const Ghost = styled('div')`
   cursor: grabbing;
 
   & > ${RowContainer} {
-    margin-bottom: 0;
+    padding-bottom: 0;
   }
 
   & svg {
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditModal.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditModal.tsx
index f7bdffa3ea..478c4c3e74 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditModal.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditModal.tsx
@@ -13,7 +13,7 @@ import ColumnEditCollection from './columnEditCollection';
 type Props = {
   columns: Column[];
   organization: OrganizationSummary;
-  tagKeys: string[];
+  tagKeys: null | string[];
   // Fired when column selections have been applied.
   onApply: (columns: Column[]) => void;
 } & ModalRenderProps;
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditRow.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditRow.tsx
index 81405515bd..aecd4266c0 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/columnEditRow.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/columnEditRow.tsx
@@ -8,45 +8,16 @@ import {SelectValue} from 'app/types';
 import {t} from 'app/locale';
 import space from 'app/styles/space';
 
-import {ColumnType, AggregateParameter} from '../eventQueryParams';
+import {FieldValueKind, FieldValue} from './types';
+import {FIELD_ALIASES, AggregateParameter} from '../eventQueryParams';
 import {Column} from '../eventView';
 
-export enum FieldValueKind {
-  TAG = 'tag',
-  FIELD = 'field',
-  FUNCTION = 'function',
-}
-
-// Payload of select options used to update column
-// data as the first picker has tags, fields and functions all combined.
-export type FieldValue =
-  | {
-      kind: FieldValueKind.TAG;
-      meta: {
-        name: string;
-        dataType: ColumnType;
-      };
-    }
-  | {
-      kind: FieldValueKind.FIELD;
-      meta: {
-        name: string;
-        dataType: ColumnType;
-      };
-    }
-  | {
-      kind: FieldValueKind.FUNCTION;
-      meta: {
-        name: string;
-        parameters: AggregateParameter[];
-      };
-    };
-
+type FieldOptions = {[key: string]: SelectValue<FieldValue>};
 type Props = {
   className?: string;
   parentIndex: number;
   column: Column;
-  fieldOptions: {[key: string]: SelectValue<FieldValue>};
+  fieldOptions: FieldOptions;
   onChange: (index: number, column: Column) => void;
 };
 
@@ -66,9 +37,13 @@ class ColumnEditRow extends React.Component<Props> {
         break;
       case FieldValueKind.FUNCTION:
         aggregation = value.meta.name;
+        // Backwards compatibility for field alias versions of functions.
+        if (FIELD_ALIASES.includes(field)) {
+          field = '';
+        }
         break;
       default:
-        throw new Error('Invald field type found in column picker');
+        throw new Error('Invalid field type found in column picker');
     }
 
     const currentField = this.getFieldOrTagValue(field);
@@ -108,25 +83,56 @@ class ColumnEditRow extends React.Component<Props> {
 
   getFieldOrTagValue(name: string): FieldValue | null {
     const {fieldOptions} = this.props;
-    return (fieldOptions[`field:${name}`] || fieldOptions[`tag:${name}`] || {value: null})
-      .value;
+    const fieldName = `field:${name}`;
+    const tagName = `tag:${name}`;
+    if (fieldOptions[fieldName]) {
+      return fieldOptions[fieldName].value;
+    }
+    if (fieldOptions[tagName]) {
+      return fieldOptions[tagName].value;
+    }
+
+    // Likely a tag that was deleted but left behind in a saved query
+    // Cook up a tag option so select control works.
+    if (name.length > 0) {
+      return {
+        kind: FieldValueKind.TAG,
+        meta: {
+          name,
+          dataType: 'string',
+          unknown: true,
+        },
+      };
+    }
+    return null;
   }
 
-  getFieldParameterData() {
+  getFieldData() {
     let field: FieldValue | null = null,
       fieldParameter: FieldValue | null = null,
       fieldParameterOptions: SelectValue<FieldValue>[] = [];
 
-    const {column, fieldOptions} = this.props;
+    const {column} = this.props;
+    let {fieldOptions} = this.props;
     const funcName = `function:${column.aggregation}`;
 
-    if (column.aggregation && fieldOptions[funcName] !== undefined) {
+    if (fieldOptions[funcName] !== undefined) {
       field = fieldOptions[funcName].value;
       fieldParameter = this.getFieldOrTagValue(column.field);
+    } else if (!column.aggregation && FIELD_ALIASES.includes(column.field)) {
+      // Handle backwards compatible field aliases.
+      const aliasName = `function:${column.field}`;
+      if (fieldOptions[aliasName] !== undefined) {
+        field = fieldOptions[aliasName].value;
+      }
     } else {
       field = this.getFieldOrTagValue(column.field);
     }
 
+    // If our current field, or columnParameter is a virtual tag, add it to the option list.
+    fieldOptions = this.appendFieldIfUnknown(fieldOptions, field);
+    fieldOptions = this.appendFieldIfUnknown(fieldOptions, fieldParameter);
+
     if (
       field &&
       field.kind === FieldValueKind.FUNCTION &&
@@ -134,19 +140,40 @@ class ColumnEditRow extends React.Component<Props> {
     ) {
       const parameters = field.meta.parameters;
       fieldParameterOptions = Object.values(fieldOptions).filter(
-        item =>
-          item.value.kind === FieldValueKind.FIELD &&
-          parameters[0].columnTypes.includes(item.value.meta.dataType)
+        ({value}) =>
+          (value.kind === FieldValueKind.FIELD || value.kind === FieldValueKind.TAG) &&
+          parameters[0].columnTypes.includes(value.meta.dataType)
       );
     }
 
-    return {field, fieldParameter, fieldParameterOptions};
+    return {field, fieldOptions, fieldParameter, fieldParameterOptions};
+  }
+
+  appendFieldIfUnknown(
+    fieldOptions: FieldOptions,
+    field: FieldValue | null
+  ): FieldOptions {
+    if (!field) {
+      return fieldOptions;
+    }
+
+    if (field && field.kind === FieldValueKind.TAG && field.meta.unknown) {
+      // Clone the options so we don't mutate other rows.
+      fieldOptions = Object.assign({}, fieldOptions);
+      fieldOptions[field.meta.name] = {label: field.meta.name, value: field};
+    }
+
+    return fieldOptions;
   }
 
   render() {
-    // TODO add additional parameter for tracing functions
-    const {className, fieldOptions} = this.props;
-    const {field, fieldParameter, fieldParameterOptions} = this.getFieldParameterData();
+    const {className} = this.props;
+    const {
+      field,
+      fieldOptions,
+      fieldParameter,
+      fieldParameterOptions,
+    } = this.getFieldData();
 
     return (
       <Container className={className}>
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/draggableColumns.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/draggableColumns.tsx
deleted file mode 100644
index 0ebae5eef6..0000000000
--- a/src/sentry/static/sentry/app/views/eventsV2/table/draggableColumns.tsx
+++ /dev/null
@@ -1,262 +0,0 @@
-import React from 'react';
-import ReactDOM from 'react-dom';
-import styled from '@emotion/styled';
-import debounce from 'lodash/debounce';
-
-import space from 'app/styles/space';
-import {
-  UserSelectValues,
-  setBodyUserSelect,
-} from 'app/components/events/interfaces/spans/utils';
-
-import {TableColumn} from './types';
-
-export const DRAGGABLE_COLUMN_CLASSNAME_IDENTIFIER = 'grid-head-cell-button';
-
-export type DraggableColumnsChildrenProps = {
-  isColumnDragging: boolean;
-  startColumnDrag: (
-    event: React.MouseEvent<SVGSVGElement, MouseEvent>,
-    initialColumnIndex: number
-  ) => void;
-  draggingColumnIndex: undefined | number;
-  destinationColumnIndex: undefined | number;
-};
-
-type Props = {
-  children: (props: DraggableColumnsChildrenProps) => JSX.Element;
-  columnOrder: TableColumn<React.ReactText>[];
-  onDragDone: (props: {
-    draggingColumnIndex: undefined | number;
-    destinationColumnIndex: undefined | number;
-  }) => void;
-};
-
-type State = {
-  isDragging: boolean;
-  left: undefined | number;
-  top: undefined | number;
-
-  draggingColumnIndex: undefined | number;
-  destinationColumnIndex: undefined | number;
-};
-
-class DraggableColumns extends React.Component<Props, State> {
-  state: State = {
-    isDragging: false,
-
-    // initial coordinates for when the drag began
-    left: void 0,
-    top: void 0,
-
-    draggingColumnIndex: void 0,
-    destinationColumnIndex: void 0,
-  };
-
-  previousUserSelect: UserSelectValues | null = null;
-  portal: HTMLElement | null = null;
-  dragGhostRef = React.createRef<HTMLDivElement>();
-
-  startColumnDrag = (
-    event: React.MouseEvent<SVGSVGElement, MouseEvent>,
-    initialColumnIndex: number
-  ) => {
-    const isDragging = this.state.isDragging;
-
-    if (isDragging || event.type !== 'mousedown') {
-      return;
-    }
-
-    // prevent the user from selecting things when dragging a column.
-    this.previousUserSelect = setBodyUserSelect({
-      userSelect: 'none',
-      MozUserSelect: 'none',
-      msUserSelect: 'none',
-    });
-
-    // attach event listeners so that the mouse cursor can drag anywhere
-    window.addEventListener('mousemove', this.onDragMove);
-    window.addEventListener('mouseup', this.onDragEnd);
-
-    this.setState({
-      isDragging: true,
-      draggingColumnIndex: initialColumnIndex,
-      destinationColumnIndex: initialColumnIndex,
-      left: event.pageX,
-      top: event.pageY,
-    });
-  };
-
-  onDragMove = (event: MouseEvent) => {
-    if (!this.state.isDragging || event.type !== 'mousemove') {
-      return;
-    }
-
-    if (this.dragGhostRef.current) {
-      // move the ghosted column title
-      const ghostDOM = this.dragGhostRef.current;
-      ghostDOM.style.left = `${event.pageX}px`;
-      ghostDOM.style.top = `${event.pageY}px`;
-    }
-
-    const gridHeadCellButtons = document.querySelectorAll(
-      `.${DRAGGABLE_COLUMN_CLASSNAME_IDENTIFIER}`
-    );
-
-    const destinationColumnIndex = Array.from(gridHeadCellButtons).findIndex(
-      headerElement => {
-        const rects = headerElement.getBoundingClientRect();
-
-        const left = event.pageX;
-
-        const thresholdStart = rects.left;
-        const thresholdEnd = rects.left + rects.width;
-
-        return left >= thresholdStart && left <= thresholdEnd;
-      }
-    );
-
-    if (destinationColumnIndex >= 0) {
-      if (this.state.destinationColumnIndex !== destinationColumnIndex) {
-        this.setDestinationColumnIndex(destinationColumnIndex);
-      }
-    }
-  };
-
-  setDestinationColumnIndex = debounce((destinationColumnIndex: number) => {
-    this.setState({
-      destinationColumnIndex,
-    });
-  }, 100);
-
-  onDragEnd = (event: MouseEvent) => {
-    if (!this.state.isDragging || event.type !== 'mouseup') {
-      return;
-    }
-
-    // remove listeners that were attached in startColumnDrag
-
-    this.cleanUpListeners();
-
-    // restore body styles
-
-    if (this.previousUserSelect) {
-      setBodyUserSelect(this.previousUserSelect);
-      this.previousUserSelect = null;
-    }
-
-    // indicate drag has ended
-
-    const destinationColumnIndex = this.state.destinationColumnIndex;
-    const draggingColumnIndex = this.state.draggingColumnIndex;
-
-    this.setState({
-      isDragging: false,
-      left: undefined,
-      top: undefined,
-      draggingColumnIndex: undefined,
-      destinationColumnIndex: undefined,
-    });
-
-    this.props.onDragDone({draggingColumnIndex, destinationColumnIndex});
-  };
-
-  cleanUpListeners = () => {
-    if (this.state.isDragging) {
-      window.removeEventListener('mousemove', this.onDragMove);
-      window.removeEventListener('mouseup', this.onDragEnd);
-    }
-  };
-
-  componentDidMount() {
-    if (!this.portal) {
-      const portal = document.createElement('div');
-
-      portal.style.position = 'absolute';
-      portal.style.top = '0';
-      portal.style.left = '0';
-      portal.style.zIndex = '9999';
-
-      this.portal = portal;
-
-      document.body.appendChild(this.portal);
-    }
-  }
-
-  componentWillUnmount() {
-    if (this.portal) {
-      document.body.removeChild(this.portal);
-    }
-    this.cleanUpListeners();
-  }
-
-  renderChildren = () => {
-    const childrenProps = {
-      isColumnDragging: this.state.isDragging,
-      startColumnDrag: this.startColumnDrag,
-      draggingColumnIndex: this.state.draggingColumnIndex,
-      destinationColumnIndex: this.state.destinationColumnIndex,
-    };
-
-    return this.props.children(childrenProps);
-  };
-
-  activeDragPlaceholder = () => {
-    if (
-      this.portal &&
-      this.state.isDragging &&
-      typeof this.state.draggingColumnIndex === 'number'
-    ) {
-      const columnBeingDragged = this.props.columnOrder[this.state.draggingColumnIndex];
-
-      const top = `${this.state.top}px`;
-      const left = `${this.state.left}px`;
-
-      const ghost = (
-        <GhostPlacement ref={this.dragGhostRef} style={{display: 'block', top, left}}>
-          <GhostContentBox>{columnBeingDragged.name}</GhostContentBox>
-        </GhostPlacement>
-      );
-
-      return ReactDOM.createPortal(ghost, this.portal);
-    }
-
-    return null;
-  };
-
-  render() {
-    return (
-      <React.Fragment>
-        {this.activeDragPlaceholder()}
-        {this.renderChildren()}
-      </React.Fragment>
-    );
-  }
-}
-
-const GhostPlacement = styled('div')`
-  position: absolute;
-  top: 0;
-  bottom: 0;
-  display: none;
-
-  user-select: none;
-`;
-
-const GhostContentBox = styled('div')`
-  padding: ${space(1)} ${space(1.5)};
-  border-radius: ${p => p.theme.borderRadius};
-
-  color: ${p => p.theme.gray2};
-  font-size: 13px;
-  font-weight: 600;
-  line-height: 1;
-  text-transform: uppercase;
-  white-space: nowrap;
-  text-overflow: ellipsis;
-  overflow: hidden;
-
-  background: ${p => p.theme.offWhite2};
-`;
-
-export default DraggableColumns;
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/tableModalEditColumn.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/tableModalEditColumn.tsx
deleted file mode 100644
index 06394855bb..0000000000
--- a/src/sentry/static/sentry/app/views/eventsV2/table/tableModalEditColumn.tsx
+++ /dev/null
@@ -1,302 +0,0 @@
-import React, {ReactText} from 'react';
-import styled from '@emotion/styled';
-import uniq from 'lodash/uniq';
-
-import {trackAnalyticsEvent} from 'app/utils/analytics';
-import {t} from 'app/locale';
-import {DISCOVER2_DOCS_URL} from 'app/constants';
-import {Form, SelectField} from 'app/components/forms';
-import Link from 'app/components/links/link';
-import {IconChevron, IconDocs} from 'app/icons';
-import {Organization} from 'app/types';
-import space from 'app/styles/space';
-
-import {
-  AGGREGATIONS,
-  FIELDS,
-  TRACING_FIELDS,
-  Aggregation,
-  Field,
-  ColumnType,
-} from '../eventQueryParams';
-import {TableColumn} from './types';
-
-type ModalActions = {
-  createColumn: (column: TableColumn<ReactText>, insertAt?: number) => void;
-  updateColumn: (indexColumnOrder: number, column: TableColumn<ReactText>) => void;
-};
-
-export function renderTableModalEditColumnFactory(
-  organization: Organization,
-  tagKeys: null | string[],
-  actions: ModalActions
-) {
-  return {
-    renderModalBodyWithForm: (
-      indexColumnOrder?: number,
-      column?: TableColumn<ReactText>,
-      onSuccessFromChild?: () => void,
-      onErrorFromChild?: (error?: Error) => void
-    ) => (
-      <TableModalEditColumnBodyForm
-        organization={organization}
-        indexColumnOrder={indexColumnOrder}
-        column={column}
-        tagKeys={tagKeys}
-        actions={{
-          createColumn: actions.createColumn,
-          updateColumn: actions.updateColumn,
-          onSuccess: onSuccessFromChild,
-          onError: onErrorFromChild,
-        }}
-      />
-    ),
-    renderModalFooter: () => <TableModalEditColumnFooter />,
-  };
-}
-
-export default renderTableModalEditColumnFactory;
-
-type TableModalEditColumnFormProps = {
-  organization: Organization;
-  indexColumnOrder?: number;
-  column?: TableColumn<ReactText>;
-  tagKeys: null | string[];
-
-  actions: ModalActions & {
-    onSuccess?: () => void;
-    onError?: (error?: Error) => void;
-  };
-};
-type TableModalEditColumnFormState = {
-  aggregations: Aggregation[];
-  fields: Field[];
-};
-
-class TableModalEditColumnBodyForm extends React.Component<
-  TableModalEditColumnFormProps,
-  TableModalEditColumnFormState
-> {
-  state = {
-    aggregations: filterAggregationByField(
-      this.props.organization,
-      this.props.column ? this.props.column.field : ''
-    ),
-    fields: filterFieldByAggregation(
-      this.props.organization,
-      this.props.tagKeys,
-      this.props.column ? this.props.column.aggregation : ''
-    ),
-  };
-
-  componentDidMount() {
-    const {column, indexColumnOrder, organization} = this.props;
-
-    const isEditing = !!column;
-    const focusedColumnIndex =
-      typeof indexColumnOrder === 'number' && indexColumnOrder >= 0
-        ? indexColumnOrder
-        : -1;
-
-    if (isEditing) {
-      if (typeof indexColumnOrder === 'number') {
-        // metrics
-        trackAnalyticsEvent({
-          eventKey: 'discover_v2.edit_column.open_modal',
-          eventName: 'Discoverv2: Opened modal to edit a column',
-          index: focusedColumnIndex,
-          organization_id: parseInt(organization.id, 10),
-        });
-      }
-    } else {
-      // metrics
-      trackAnalyticsEvent({
-        eventKey: 'discover_v2.add_column.open_modal',
-        eventName: 'Discoverv2: Opened modal to add a column',
-        index: focusedColumnIndex,
-        organization_id: parseInt(organization.id, 10),
-      });
-    }
-  }
-
-  onChangeAggregation = (value: Aggregation) => {
-    const {organization, tagKeys} = this.props;
-    this.setState({
-      fields: filterFieldByAggregation(organization, tagKeys, value),
-    });
-  };
-
-  onChangeField = (value: Field) => {
-    this.setState({
-      aggregations: filterAggregationByField(this.props.organization, value),
-    });
-  };
-
-  onSubmitForm = (values: any) => {
-    const {indexColumnOrder, column} = this.props;
-    const {createColumn, updateColumn, onSuccess, onError} = this.props.actions;
-    const nextColumn: TableColumn<ReactText> = {...column, ...values};
-
-    try {
-      if (typeof indexColumnOrder === 'number' && this.props.column) {
-        updateColumn(indexColumnOrder, nextColumn);
-      } else {
-        createColumn(nextColumn, indexColumnOrder);
-      }
-
-      if (onSuccess) {
-        onSuccess();
-      }
-    } catch (e) {
-      if (onError) {
-        onError(e);
-      }
-    }
-  };
-
-  render() {
-    const {column} = this.props;
-
-    return (
-      <React.Fragment>
-        <Form
-          onSubmit={v => this.onSubmitForm(v)}
-          submitLabel={column ? t('Update column') : t('Create column')}
-          initialData={{
-            aggregation: column ? column.aggregation : '',
-            field: column ? column.field : '',
-          }}
-        >
-          <FormRow>
-            <SelectField
-              deprecatedSelectControl
-              name="aggregation"
-              label={t('Aggregate')}
-              placeholder="Select Aggregate"
-              choices={this.state.aggregations}
-              onChange={this.onChangeAggregation}
-            />
-            <SelectField
-              deprecatedSelectControl
-              required
-              name="field"
-              label={t('Column Type')}
-              placeholder="Select Column Type"
-              choices={this.state.fields}
-              onChange={this.onChangeField}
-            />
-          </FormRow>
-        </Form>
-      </React.Fragment>
-    );
-  }
-}
-
-const TableModalEditColumnFooter = () => (
-  <FooterContent href={`${DISCOVER2_DOCS_URL}query-builder/`} target="_blank">
-    <StyledIconDocs /> {t('Read the docs')}
-    <StyledIconChevron direction="right" size="xs" />
-  </FooterContent>
-);
-
-function filterAggregationByField(organization: Organization, f?: Field): Aggregation[] {
-  let functionList = Object.keys(AGGREGATIONS);
-  if (!organization.features.includes('transaction-events')) {
-    functionList = functionList.filter(item => !TRACING_FIELDS.includes(item));
-  }
-
-  // sort list in ascending order
-  functionList.sort();
-
-  if (!f) {
-    return functionList as Aggregation[];
-  }
-  // Unknown fields are likely tag keys and thus strings.
-  const fieldType = FIELDS[f] || 'string';
-
-  if (fieldType === 'never') {
-    return [];
-  }
-
-  functionList = functionList.reduce((accumulator, a) => {
-    if (
-      AGGREGATIONS[a].type.includes(fieldType) ||
-      AGGREGATIONS[a].type === '*' ||
-      fieldType === '*'
-    ) {
-      accumulator.push(a as Aggregation);
-    }
-
-    return accumulator;
-  }, [] as Aggregation[]);
-
-  // sort list in ascending order
-  functionList.sort();
-
-  return functionList as Aggregation[];
-}
-
-function filterFieldByAggregation(
-  organization: Organization,
-  tagKeys: null | string[],
-  a?: Aggregation
-): Field[] {
-  let fieldList = Object.keys(FIELDS);
-  if (tagKeys && tagKeys.length) {
-    fieldList = uniq(fieldList.concat(tagKeys));
-  }
-  if (!organization.features.includes('transaction-events')) {
-    fieldList = fieldList.filter(item => !TRACING_FIELDS.includes(item));
-  }
-
-  // sort list in ascending order
-  fieldList.sort();
-
-  if (!a || !AGGREGATIONS[a]) {
-    return fieldList as Field[];
-  }
-
-  fieldList = fieldList.reduce((accumulator, f) => {
-    // tag keys are all strings, and values not in FIELDS is a tag.
-    const fieldType = FIELDS[f] || 'string';
-    if (fieldType === 'never' || typeof AGGREGATIONS[a] === 'undefined') {
-      return accumulator;
-    }
-
-    const aggregate = AGGREGATIONS[a];
-    // Acts as a cast to get around the `as const` type narrowing.
-    const aggregateType: ColumnType[] = [...aggregate.type];
-    if (aggregateType.includes('*') || aggregateType.includes(fieldType as ColumnType)) {
-      accumulator.push(f as Field);
-    }
-
-    return accumulator;
-  }, [] as Field[]);
-
-  // sort list in ascending order
-  fieldList.sort();
-
-  return fieldList;
-}
-
-const FormRow = styled('div')`
-  box-sizing: border-box;
-  display: grid;
-  grid-template-columns: 35% auto;
-  grid-column-gap: ${space(2)};
-`;
-
-const FooterContent = styled(Link)`
-  display: flex;
-  align-items: center;
-  flex-grow: 1;
-  color: inherit;
-`;
-
-const StyledIconDocs = styled(IconDocs)`
-  margin-right: ${space(1)};
-`;
-
-const StyledIconChevron = styled(IconChevron)`
-  margin-left: auto;
-`;
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
index e8082d3dc2..8cf9e1ef29 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/tableView.tsx
@@ -1,5 +1,6 @@
 import React from 'react';
 import styled from '@emotion/styled';
+import {browserHistory} from 'react-router';
 import {Location, LocationDescriptorObject} from 'history';
 
 import {Organization} from 'app/types';
@@ -8,6 +9,7 @@ import GridEditable, {COL_WIDTH_UNDEFINED} from 'app/components/gridEditable';
 import {IconEvent, IconStack} from 'app/icons';
 import {t} from 'app/locale';
 import {assert} from 'app/types/utils';
+import {openModal} from 'app/actionCreators/modal';
 import Link from 'app/components/links/link';
 import Tooltip from 'app/components/tooltip';
 
@@ -19,15 +21,12 @@ import {
   explodeField,
   MetaType,
 } from '../utils';
-import EventView, {pickRelevantLocationQueryStrings} from '../eventView';
+import EventView, {Column, pickRelevantLocationQueryStrings} from '../eventView';
 import SortLink from '../sortLink';
-import renderTableModalEditColumnFactory from './tableModalEditColumn';
+import {generateEventSlug, eventDetailsRouteWithEventView} from '../eventDetails/utils';
+import ColumnEditModal from './columnEditModal';
 import {TableColumn, TableData, TableDataRow} from './types';
 import HeaderCell from './headerCell';
-import DraggableColumns, {
-  DRAGGABLE_COLUMN_CLASSNAME_IDENTIFIER,
-} from './draggableColumns';
-import {generateEventSlug, eventDetailsRouteWithEventView} from '../eventDetails/utils';
 
 export type TableViewProps = {
   location: Location;
@@ -59,55 +58,6 @@ class TableView extends React.Component<TableViewProps> {
    * In most cases, the new EventView object differs from the previous EventView
    * object. The new EventView object is pushed to the location object.
    */
-  _createColumn = (
-    nextColumn: TableColumn<keyof TableDataRow>,
-    insertAt: number | undefined
-  ) => {
-    const {location, eventView, organization} = this.props;
-
-    let nextEventView: EventView;
-    const payload = {
-      aggregation: String(nextColumn.aggregation),
-      field: String(nextColumn.field),
-      fieldname: nextColumn.name,
-      width: COL_WIDTH_UNDEFINED,
-    };
-
-    if (typeof insertAt === 'number') {
-      // create and insert a column at a specific index
-      nextEventView = eventView.withNewColumnAt(payload, insertAt);
-
-      // metrics
-      trackAnalyticsEvent({
-        eventKey: 'discover_v2.add_column',
-        eventName: 'Discoverv2: Add a new column at an index',
-        insert_at_index: insertAt,
-        organization_id: parseInt(organization.id, 10),
-        ...payload,
-      });
-    } else {
-      // create and insert a column at the right end of the table
-      nextEventView = eventView.withNewColumn(payload);
-
-      // metrics
-      trackAnalyticsEvent({
-        eventKey: 'discover_v2.add_column.right_end',
-        eventName: 'Discoverv2: Add a new column at the right end of the table',
-        organization_id: parseInt(organization.id, 10),
-        ...payload,
-      });
-    }
-
-    pushEventViewToLocation({
-      location,
-      nextEventView,
-      extraQuery: pickRelevantLocationQueryStrings(location),
-    });
-  };
-
-  /**
-   * Please read the comment on `_createColumn`
-   */
   _updateColumn = (columnIndex: number, nextColumn: TableColumn<keyof TableDataRow>) => {
     const {location, eventView, tableData, organization} = this.props;
 
@@ -159,61 +109,6 @@ class TableView extends React.Component<TableViewProps> {
     });
   };
 
-  /**
-   * Please read the comment on `_createColumn`
-   */
-  _deleteColumn = (columnIndex: number) => {
-    const {location, eventView, tableData, organization} = this.props;
-
-    const prevField = explodeField(eventView.fields[columnIndex]);
-
-    const tableMeta = (tableData && tableData.meta) || undefined;
-    const nextEventView = eventView.withDeletedColumn(columnIndex, tableMeta);
-
-    // metrics
-    trackAnalyticsEvent({
-      eventKey: 'discover_v2.delete_column',
-      eventName: 'Discoverv2: A column was deleted',
-      deleted_at_index: columnIndex,
-      organization_id: parseInt(organization.id, 10),
-      aggregation: prevField.aggregation,
-      field: prevField.field,
-    });
-
-    pushEventViewToLocation({
-      location,
-      nextEventView,
-      extraQuery: pickRelevantLocationQueryStrings(location),
-    });
-  };
-
-  /**
-   * Please read the comment on `_createColumn`
-   */
-  _moveColumnCommit = (fromIndex: number, toIndex: number) => {
-    const {location, eventView, organization} = this.props;
-
-    const prevField = explodeField(eventView.fields[fromIndex]);
-    const nextEventView = eventView.withMovedColumn({fromIndex, toIndex});
-
-    // metrics
-    trackAnalyticsEvent({
-      eventKey: 'discover_v2.move_column',
-      eventName: 'Discoverv2: A column was moved',
-      from_index: fromIndex,
-      to_index: toIndex,
-      organization_id: parseInt(organization.id, 10),
-      aggregation: prevField.aggregation,
-      field: prevField.field,
-    });
-
-    pushEventViewToLocation({
-      location,
-      nextEventView,
-      extraQuery: pickRelevantLocationQueryStrings(location),
-    });
-  };
-
   _renderPrependColumns = (
     isHeader: boolean,
     dataRow?: any,
@@ -320,54 +215,30 @@ class TableView extends React.Component<TableViewProps> {
     );
   };
 
-  generateColumnOrder = ({
-    initialColumnIndex,
-    destinationColumnIndex,
-  }: {
-    initialColumnIndex: undefined | number;
-    destinationColumnIndex: undefined | number;
-  }) => {
-    const {eventView} = this.props;
-    const columnOrder = eventView.getColumns();
-
-    if (
-      typeof destinationColumnIndex !== 'number' ||
-      typeof initialColumnIndex !== 'number'
-    ) {
-      return columnOrder;
-    }
-
-    if (destinationColumnIndex === initialColumnIndex) {
-      const currentDraggingColumn: TableColumn<keyof TableDataRow> = {
-        ...columnOrder[destinationColumnIndex],
-        isDragging: true,
-      };
-
-      columnOrder[destinationColumnIndex] = currentDraggingColumn;
-
-      return columnOrder;
-    }
-
-    const nextColumnOrder = [...columnOrder];
-
-    nextColumnOrder.splice(
-      destinationColumnIndex,
-      0,
-      nextColumnOrder.splice(initialColumnIndex, 1)[0]
-    );
+  handleEditColumns = () => {
+    const {organization, eventView, tagKeys} = this.props;
+    this.trackEditAnalytics(organization, true);
+
+    openModal(modalProps => (
+      <ColumnEditModal
+        {...modalProps}
+        organization={organization}
+        tagKeys={tagKeys}
+        columns={eventView.getColumns()}
+        onApply={this.handleUpdateColumns}
+      />
+    ));
+  };
 
-    const currentDraggingColumn: TableColumn<keyof TableDataRow> = {
-      ...nextColumnOrder[destinationColumnIndex],
-      isDragging: true,
-    };
-    nextColumnOrder[destinationColumnIndex] = currentDraggingColumn;
+  handleUpdateColumns = (columns: Column[]): void => {
+    const {organization, eventView} = this.props;
+    this.trackEditAnalytics(organization, false);
 
-    return nextColumnOrder;
+    const nextView = eventView.withColumns(columns);
+    browserHistory.push(nextView.getResultsViewUrlTarget(organization.slug));
   };
 
-  onToggleEdit = (isEditing: boolean) => {
-    const {organization} = this.props;
-
+  trackEditAnalytics(organization: Organization, isEditing: boolean) {
     if (isEditing) {
       // metrics
       trackAnalyticsEvent({
@@ -383,83 +254,35 @@ class TableView extends React.Component<TableViewProps> {
         organization_id: parseInt(organization.id, 10),
       });
     }
-  };
+  }
 
   render() {
-    const {
-      organization,
-      isLoading,
-      error,
-      tableData,
-      tagKeys,
-      eventView,
-      title,
-    } = this.props;
+    const {isLoading, error, tableData, eventView, title} = this.props;
 
     const columnOrder = eventView.getColumns();
     const columnSortBy = eventView.getSorts();
 
-    const {
-      renderModalBodyWithForm,
-      renderModalFooter,
-    } = renderTableModalEditColumnFactory(organization, tagKeys, {
-      createColumn: this._createColumn,
-      updateColumn: this._updateColumn,
-    });
-
     return (
-      <DraggableColumns
+      <GridEditable
+        editFeatures={['organizations:discover-query']}
+        noEditMessage={t('Requires discover query feature.')}
+        isLoading={isLoading}
+        error={error}
+        data={tableData ? tableData.data : []}
         columnOrder={columnOrder}
-        onDragDone={({draggingColumnIndex, destinationColumnIndex}) => {
-          if (
-            typeof draggingColumnIndex === 'number' &&
-            typeof destinationColumnIndex === 'number' &&
-            draggingColumnIndex !== destinationColumnIndex
-          ) {
-            this._moveColumnCommit(draggingColumnIndex, destinationColumnIndex);
-          }
+        columnSortBy={columnSortBy}
+        grid={{
+          renderHeadCell: this._renderGridHeaderCell as any,
+          renderBodyCell: this._renderGridBodyCell as any,
+          onResizeColumn: this._updateColumn as any,
+          renderPrependColumns: this._renderPrependColumns as any,
+          prependColumnWidths: ['40px'],
         }}
-      >
-        {({
-          isColumnDragging,
-          startColumnDrag,
-          draggingColumnIndex,
-          destinationColumnIndex,
-        }) => (
-          <GridEditable
-            editFeatures={['organizations:discover-query']}
-            noEditMessage={t('Requires discover query feature.')}
-            onToggleEdit={this.onToggleEdit}
-            isColumnDragging={isColumnDragging}
-            gridHeadCellButtonProps={{className: DRAGGABLE_COLUMN_CLASSNAME_IDENTIFIER}}
-            isLoading={isLoading}
-            error={error}
-            data={tableData ? tableData.data : []}
-            columnOrder={this.generateColumnOrder({
-              initialColumnIndex: draggingColumnIndex,
-              destinationColumnIndex,
-            })}
-            columnSortBy={columnSortBy}
-            grid={{
-              renderHeadCell: this._renderGridHeaderCell as any,
-              renderBodyCell: this._renderGridBodyCell as any,
-              onResizeColumn: this._updateColumn as any,
-              renderPrependColumns: this._renderPrependColumns as any,
-              prependColumnWidths: ['40px'],
-            }}
-            modalEditColumn={{
-              renderBodyWithForm: renderModalBodyWithForm as any,
-              renderFooter: renderModalFooter,
-            }}
-            actions={{
-              deleteColumn: this._deleteColumn,
-              moveColumnCommit: this._moveColumnCommit,
-              onDragStart: startColumnDrag,
-              downloadAsCsv: () => downloadAsCsv(tableData, columnOrder, title),
-            }}
-          />
-        )}
-      </DraggableColumns>
+        actions={{
+          editColumns: this.handleEditColumns,
+          downloadAsCsv: () => downloadAsCsv(tableData, columnOrder, title),
+        }}
+      />
     );
   }
 }
diff --git a/src/sentry/static/sentry/app/views/eventsV2/table/types.tsx b/src/sentry/static/sentry/app/views/eventsV2/table/types.tsx
index 073e9b7fb8..8b2f400978 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/table/types.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/table/types.tsx
@@ -1,6 +1,12 @@
 import {GridColumnOrder, GridColumnSortBy} from 'app/components/gridEditable';
 
-import {ColumnValueType, Aggregation, Field} from '../eventQueryParams';
+import {
+  ColumnType,
+  ColumnValueType,
+  AggregateParameter,
+  Aggregation,
+  Field,
+} from '../eventQueryParams';
 import {Field as FieldType} from '../eventView';
 import {MetaType} from '../utils';
 
@@ -34,3 +40,37 @@ export type TableData = {
   meta?: MetaType;
   data: Array<TableDataRow>;
 };
+
+export enum FieldValueKind {
+  TAG = 'tag',
+  FIELD = 'field',
+  FUNCTION = 'function',
+}
+
+// Payload of select options in the column editor.
+// The first column contains a union of tags, fields and functions,
+// and we need ways to disambiguate them.
+export type FieldValue =
+  | {
+      kind: FieldValueKind.TAG;
+      meta: {
+        name: string;
+        dataType: ColumnType;
+        // Set to true for tag values we invent at runtime.
+        unknown?: boolean;
+      };
+    }
+  | {
+      kind: FieldValueKind.FIELD;
+      meta: {
+        name: string;
+        dataType: ColumnType;
+      };
+    }
+  | {
+      kind: FieldValueKind.FUNCTION;
+      meta: {
+        name: string;
+        parameters: AggregateParameter[];
+      };
+    };
diff --git a/src/sentry/static/sentry/app/views/eventsV2/utils.tsx b/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
index 3e08a765d9..0bf41fecc1 100644
--- a/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
+++ b/src/sentry/static/sentry/app/views/eventsV2/utils.tsx
@@ -194,7 +194,6 @@ const TEMPLATE_TABLE_COLUMN: TableColumn<React.ReactText> = {
   width: COL_WIDTH_UNDEFINED,
 
   type: 'never',
-  isDragging: false,
   isSortable: false,
 
   eventViewField: Object.freeze({field: '', width: COL_WIDTH_UNDEFINED}),
@@ -226,8 +225,6 @@ export function decodeColumnOrder(
     const aggregate = AGGREGATIONS[column.aggregation];
     if (aggregate && aggregate.outputType) {
       column.type = aggregate.outputType;
-    } else if (FIELDS[column.aggregation]) {
-      column.type = FIELDS[column.aggregation];
     } else {
       column.type = FIELDS[column.field];
     }
diff --git a/tests/acceptance/test_organization_events_v2.py b/tests/acceptance/test_organization_events_v2.py
index 4a18464fb5..1fa185b9ac 100644
--- a/tests/acceptance/test_organization_events_v2.py
+++ b/tests/acceptance/test_organization_events_v2.py
@@ -213,11 +213,6 @@ class OrganizationEventsV2Test(AcceptanceTestCase, SnubaTestCase):
                 "events-v2 - errors query - empty state - querybuilder - column edit state"
             )
 
-            self.browser.click_when_visible('[data-test-id="grid-add-column"]')
-            self.browser.snapshot(
-                "events-v2 - errors query - empty state - querybuilder - add column"
-            )
-
     @patch("django.utils.timezone.now")
     def test_errors_query(self, mock_now):
         mock_now.return_value = before_now().replace(tzinfo=pytz.utc)
diff --git a/tests/js/spec/views/eventsV2/eventView.spec.jsx b/tests/js/spec/views/eventsV2/eventView.spec.jsx
index 174b66fffb..7bc8d108c0 100644
--- a/tests/js/spec/views/eventsV2/eventView.spec.jsx
+++ b/tests/js/spec/views/eventsV2/eventView.spec.jsx
@@ -1060,11 +1060,91 @@ describe('EventView.clone()', function() {
   });
 });
 
+describe('EventView.withColumns()', function() {
+  const state = {
+    id: '1234',
+    name: 'best query',
+    fields: [
+      {field: 'count()', width: 30},
+      {field: 'project.id', width: 99},
+    ],
+    sorts: generateSorts(['count']),
+    query: 'event.type:error',
+    project: [42],
+    start: '2019-10-01T00:00:00',
+    end: '2019-10-02T00:00:00',
+    statsPeriod: '14d',
+    environment: ['staging'],
+  };
+  const eventView = new EventView(state);
+
+  it('adds new columns, and replaces existing ones', function() {
+    const newView = eventView.withColumns([
+      {field: 'title', aggregation: ''},
+      {field: '', aggregation: 'count'},
+      {field: 'project.id', aggregation: ''},
+      {field: 'culprit', aggregation: ''},
+    ]);
+    // Views should be different.
+    expect(newView.isEqualTo(eventView)).toBe(false);
+    expect(newView.fields).toEqual([
+      {field: 'title', width: COL_WIDTH_UNDEFINED},
+      {field: 'count()', width: COL_WIDTH_UNDEFINED},
+      {field: 'project.id', width: COL_WIDTH_UNDEFINED},
+      {field: 'culprit', width: COL_WIDTH_UNDEFINED},
+    ]);
+  });
+
+  it('inherits widths from existing columns when names match', function() {
+    const newView = eventView.withColumns([
+      {field: '', aggregation: 'count'},
+      {field: 'project.id', aggregation: ''},
+      {field: 'title', aggregation: ''},
+      {field: 'time', aggregation: ''},
+    ]);
+
+    expect(newView.fields).toEqual([
+      {field: 'count()', width: 30},
+      {field: 'project.id', width: 99},
+      {field: 'title', width: COL_WIDTH_UNDEFINED},
+      {field: 'time', width: COL_WIDTH_UNDEFINED},
+    ]);
+  });
+
+  it('retains sorts when sorted field is included', function() {
+    const newView = eventView.withColumns([
+      {field: 'title', aggregation: ''},
+      {field: '', aggregation: 'count'},
+    ]);
+    expect(newView.fields).toEqual([
+      {field: 'title', width: COL_WIDTH_UNDEFINED},
+      {field: 'count()', width: COL_WIDTH_UNDEFINED},
+    ]);
+    expect(newView.sorts).toEqual([{field: 'count', kind: 'desc'}]);
+  });
+
+  it('updates sorts when sorted field is removed', function() {
+    const newView = eventView.withColumns([{field: 'title', aggregation: ''}]);
+    expect(newView.fields).toEqual([{field: 'title', width: COL_WIDTH_UNDEFINED}]);
+    // Should pick a sortable field.
+    expect(newView.sorts).toEqual([{field: 'title', kind: 'desc'}]);
+  });
+
+  it('has no sort if no sortable fields remain', function() {
+    const newView = eventView.withColumns([{field: 'issue', aggregation: ''}]);
+    expect(newView.fields).toEqual([{field: 'issue', width: COL_WIDTH_UNDEFINED}]);
+    expect(newView.sorts).toEqual([]);
+  });
+});
+
 describe('EventView.withNewColumn()', function() {
   const state = {
     id: '1234',
     name: 'best query',
-    fields: [{field: 'count()'}, {field: 'project.id'}],
+    fields: [
+      {field: 'count()', width: 30},
+      {field: 'project.id', width: 99},
+    ],
     sorts: generateSorts(['count']),
     query: 'event.type:error',
     project: [42],
@@ -1074,69 +1154,55 @@ describe('EventView.withNewColumn()', function() {
     environment: ['staging'],
   };
 
-  it('add a field', function() {
+  it('adds a field', function() {
     const eventView = new EventView(state);
-
     const newColumn = {
       aggregation: '',
       field: 'title',
     };
-
     const eventView2 = eventView.withNewColumn(newColumn);
-
     expect(eventView2 !== eventView).toBeTruthy();
-
     expect(eventView).toMatchObject(state);
 
     const nextState = {
       ...state,
       fields: [...state.fields, {field: 'title'}],
     };
-
     expect(eventView2).toMatchObject(nextState);
   });
 
-  it('add an aggregate function with no arguments', function() {
+  it('adds an aggregate function with no arguments', function() {
     const eventView = new EventView(state);
-
     const newColumn = {
       aggregation: 'count',
       field: '',
     };
 
     const eventView2 = eventView.withNewColumn(newColumn);
-
     expect(eventView2 !== eventView).toBeTruthy();
-
     expect(eventView).toMatchObject(state);
 
     const nextState = {
       ...state,
       fields: [...state.fields, {field: 'count()'}],
     };
-
     expect(eventView2).toMatchObject(nextState);
   });
 
   it('add an aggregate function with arguments', function() {
     const eventView = new EventView(state);
-
     const newColumn = {
       aggregation: 'avg',
       field: 'transaction.duration',
     };
-
     const eventView2 = eventView.withNewColumn(newColumn);
-
     expect(eventView2 !== eventView).toBeTruthy();
-
     expect(eventView).toMatchObject(state);
 
     const nextState = {
       ...state,
       fields: [...state.fields, {field: 'avg(transaction.duration)'}],
     };
-
     expect(eventView2).toMatchObject(nextState);
   });
 });
@@ -2089,12 +2155,8 @@ describe('isAPIPayloadSimilar', function() {
       const location = {};
       const thisAPIPayload = thisEventView.getEventsAPIPayload(location);
 
-      const newColumn = {
-        aggregation: '',
-        field: 'title',
-      };
-
-      const otherEventView = thisEventView.withNewColumn(newColumn);
+      const otherEventView = thisEventView.clone();
+      otherEventView.fields.push({field: 'title', width: COL_WIDTH_UNDEFINED});
       const otherLocation = {};
       const otherAPIPayload = otherEventView.getEventsAPIPayload(otherLocation);
 
@@ -2246,12 +2308,8 @@ describe('isAPIPayloadSimilar', function() {
       const location = {};
       const thisAPIPayload = thisEventView.getFacetsAPIPayload(location);
 
-      const newColumn = {
-        aggregation: '',
-        field: 'title',
-      };
-
-      const otherEventView = thisEventView.withNewColumn(newColumn);
+      const otherEventView = thisEventView.clone();
+      otherEventView.fields.push({field: 'title', width: COL_WIDTH_UNDEFINED});
       const otherLocation = {};
       const otherAPIPayload = otherEventView.getFacetsAPIPayload(otherLocation);
 
diff --git a/tests/js/spec/views/eventsV2/utils.spec.jsx b/tests/js/spec/views/eventsV2/utils.spec.jsx
index 65895a51b3..4f774dae27 100644
--- a/tests/js/spec/views/eventsV2/utils.spec.jsx
+++ b/tests/js/spec/views/eventsV2/utils.spec.jsx
@@ -148,7 +148,6 @@ describe('decodeColumnOrder', function() {
         field: 'title',
         width: 123,
       },
-      isDragging: false,
       isSortable: false,
       type: 'string',
     });
@@ -168,7 +167,6 @@ describe('decodeColumnOrder', function() {
         field: 'count()',
         width: 123,
       },
-      isDragging: false,
       isSortable: true,
       type: 'number',
     });
@@ -192,7 +190,6 @@ describe('decodeColumnOrder', function() {
       field: 'transaction.duration',
       width: COL_WIDTH_NUMBER,
       eventViewField: {field: 'avg(transaction.duration)'},
-      isDragging: false,
       isSortable: true,
       type: 'duration',
     });

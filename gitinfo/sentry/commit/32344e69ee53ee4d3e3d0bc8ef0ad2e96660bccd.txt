commit 32344e69ee53ee4d3e3d0bc8ef0ad2e96660bccd
Author: Dan Fuller <dfuller@sentry.io>
Date:   Wed May 6 16:23:53 2020 -0700

    refs(subscriptions): Update subscriptions to support v2 format. Log request data. (#18648)
    
    As part of investigating some data inconsistencies we want to log the details of the query we made.
    We've updated the payload format to support this.
    
    We should stop using the raw dict at some point and convert it into an object, but until we get time
    there's a hack in place for compatibility.

diff --git a/src/sentry/snuba/json_schemas.py b/src/sentry/snuba/json_schemas.py
index 54d1f5b26e..586c77930b 100644
--- a/src/sentry/snuba/json_schemas.py
+++ b/src/sentry/snuba/json_schemas.py
@@ -33,5 +33,30 @@ SUBSCRIPTION_PAYLOAD_VERSIONS = {
         },
         "required": ["subscription_id", "values", "timestamp"],
         "additionalProperties": False,
-    }
+    },
+    2: {
+        "type": "object",
+        "properties": {
+            "subscription_id": {"type": "string", "minLength": 1},
+            "request": {"type": "object"},
+            "result": {
+                "type": "object",
+                "properties": {
+                    "data": {
+                        "type": "array",
+                        "minItems": 1,
+                        "items": {
+                            "type": "object",
+                            "minProperties": 1,
+                            "additionalProperties": {"type": "number"},
+                        },
+                    }
+                },
+                "required": ["data"],
+            },
+            "timestamp": {"type": "string", "format": "date-time"},
+        },
+        "required": ["subscription_id", "request", "result", "timestamp"],
+        "additionalProperties": False,
+    },
 }
diff --git a/src/sentry/snuba/query_subscription_consumer.py b/src/sentry/snuba/query_subscription_consumer.py
index 79a00e371c..01c56a43e5 100644
--- a/src/sentry/snuba/query_subscription_consumer.py
+++ b/src/sentry/snuba/query_subscription_consumer.py
@@ -200,6 +200,7 @@ class QuerySubscriptionConsumer(object):
                     "timestamp": contents["timestamp"],
                     "query_subscription_id": contents["subscription_id"],
                     "project_id": subscription.project_id,
+                    "request": contents.get("request"),
                     "subscription_dataset": subscription.dataset,
                     "subscription_query": subscription.query,
                     "subscription_aggregation": subscription.aggregation,
@@ -248,6 +249,11 @@ class QuerySubscriptionConsumer(object):
             except jsonschema.ValidationError:
                 metrics.incr("snuba_query_subscriber.message_payload_invalid")
                 raise InvalidSchemaError("Message payload does not match schema")
+        # XXX: Since we just return the raw dict here, when the payload changes it'll
+        # break things. This should convert the payload into a class rather than passing
+        # the dict around, but until we get time to refactor we can keep things working
+        # here.
+        payload.setdefault("values", payload.get("result"))
 
         payload["timestamp"] = parse_date(payload["timestamp"]).replace(tzinfo=pytz.utc)
         return payload
diff --git a/tests/sentry/snuba/test_query_subscription_consumer.py b/tests/sentry/snuba/test_query_subscription_consumer.py
index 1de34f2470..87d819b0e8 100644
--- a/tests/sentry/snuba/test_query_subscription_consumer.py
+++ b/tests/sentry/snuba/test_query_subscription_consumer.py
@@ -30,16 +30,25 @@ class BaseQuerySubscriptionTest(object):
 
     @fixture
     def valid_wrapper(self):
-        return {"version": 1, "payload": self.valid_payload}
+        return {"version": 2, "payload": self.valid_payload}
 
     @fixture
-    def valid_payload(self):
+    def old_payload(self):
         return {
             "subscription_id": "1234",
             "values": {"data": [{"hello": 50}]},
             "timestamp": "2020-01-01T01:23:45.1234",
         }
 
+    @fixture
+    def valid_payload(self):
+        return {
+            "subscription_id": "1234",
+            "result": {"data": [{"hello": 50}]},
+            "request": {"some": "data"},
+            "timestamp": "2020-01-01T01:23:45.1234",
+        }
+
     def build_mock_message(self, data, topic=None):
         message = Mock()
         message.value.return_value = json.dumps(data)
@@ -104,6 +113,8 @@ class HandleMessageTest(BaseQuerySubscriptionTest, TestCase):
         data = self.valid_wrapper
         data["payload"]["subscription_id"] = sub.subscription_id
         self.consumer.handle_message(self.build_mock_message(data))
+        data = deepcopy(data)
+        data["payload"]["values"] = data["payload"]["result"]
         data["payload"]["timestamp"] = parse_date(data["payload"]["timestamp"]).replace(
             tzinfo=pytz.utc
         )
@@ -125,15 +136,15 @@ class ParseMessageValueTest(BaseQuerySubscriptionTest, unittest.TestCase):
                 payload.pop(field)
         if update_fields:
             payload.update(update_fields)
-        self.run_invalid_schema_test({"version": 1, "payload": payload})
+        self.run_invalid_schema_test({"version": 2, "payload": payload})
 
     def test_invalid_payload(self):
         self.run_invalid_payload_test(remove_fields=["subscription_id"])
-        self.run_invalid_payload_test(remove_fields=["values"])
+        self.run_invalid_payload_test(remove_fields=["result"])
         self.run_invalid_payload_test(remove_fields=["timestamp"])
         self.run_invalid_payload_test(update_fields={"subscription_id": ""})
-        self.run_invalid_payload_test(update_fields={"values": {}})
-        self.run_invalid_payload_test(update_fields={"values": {"hello": "hi"}})
+        self.run_invalid_payload_test(update_fields={"result": {}})
+        self.run_invalid_payload_test(update_fields={"result": {"hello": "hi"}})
         self.run_invalid_payload_test(update_fields={"timestamp": -1})
 
     def test_invalid_version(self):
@@ -142,7 +153,10 @@ class ParseMessageValueTest(BaseQuerySubscriptionTest, unittest.TestCase):
         assert six.text_type(cm.exception) == "Version specified in wrapper has no schema"
 
     def test_valid(self):
-        self.run_test({"version": 1, "payload": self.valid_payload})
+        self.run_test({"version": 2, "payload": self.valid_payload})
+
+    def test_old_version(self):
+        self.run_test({"version": 1, "payload": self.old_payload})
 
     def test_invalid_wrapper(self):
         self.run_invalid_schema_test({})
diff --git a/tests/snuba/snuba/test_query_subscription_consumer.py b/tests/snuba/snuba/test_query_subscription_consumer.py
index bca65da67c..ac7cc25e63 100644
--- a/tests/snuba/snuba/test_query_subscription_consumer.py
+++ b/tests/snuba/snuba/test_query_subscription_consumer.py
@@ -26,15 +26,28 @@ class QuerySubscriptionConsumerTest(TestCase, SnubaTestCase):
     def subscription_id(self):
         return "1234"
 
+    @fixture
+    def old_valid_wrapper(self):
+        return {"version": 1, "payload": self.old_payload}
+
+    @fixture
+    def old_payload(self):
+        return {
+            "subscription_id": self.subscription_id,
+            "values": {"data": [{"hello": 50}]},
+            "timestamp": "2020-01-01T01:23:45.1234",
+        }
+
     @fixture
     def valid_wrapper(self):
-        return {"version": 1, "payload": self.valid_payload}
+        return {"version": 2, "payload": self.valid_payload}
 
     @fixture
     def valid_payload(self):
         return {
             "subscription_id": self.subscription_id,
-            "values": {"data": [{"hello": 50}]},
+            "result": {"data": [{"hello": 50}]},
+            "request": {"some": "data"},
             "timestamp": "2020-01-01T01:23:45.1234",
         }
 
@@ -69,6 +82,37 @@ class QuerySubscriptionConsumerTest(TestCase, SnubaTestCase):
     def registration_key(self):
         return "registered_keyboard_interrupt"
 
+    def test_old(self):
+        cluster_name = settings.KAFKA_TOPICS[self.topic]["cluster"]
+
+        conf = {
+            "bootstrap.servers": settings.KAFKA_CLUSTERS[cluster_name]["bootstrap.servers"],
+            "session.timeout.ms": 6000,
+        }
+
+        producer = Producer(conf)
+        producer.produce(self.topic, json.dumps(self.old_valid_wrapper))
+        producer.flush()
+        mock_callback = Mock()
+        mock_callback.side_effect = KeyboardInterrupt()
+        register_subscriber(self.registration_key)(mock_callback)
+        sub = QuerySubscription.objects.create(
+            project=self.project,
+            type=self.registration_key,
+            subscription_id=self.subscription_id,
+            dataset="something",
+            query="hello",
+            aggregation=0,
+            time_window=1,
+            resolution=1,
+        )
+        consumer = QuerySubscriptionConsumer("hi", topic=self.topic, commit_batch_size=1)
+        consumer.run()
+
+        payload = self.old_payload
+        payload["timestamp"] = parse_date(payload["timestamp"]).replace(tzinfo=pytz.utc)
+        mock_callback.assert_called_once_with(payload, sub)
+
     def test_normal(self):
         cluster_name = settings.KAFKA_TOPICS[self.topic]["cluster"]
 
@@ -97,15 +141,16 @@ class QuerySubscriptionConsumerTest(TestCase, SnubaTestCase):
         consumer.run()
 
         payload = self.valid_payload
+        payload["values"] = payload["result"]
         payload["timestamp"] = parse_date(payload["timestamp"]).replace(tzinfo=pytz.utc)
         mock_callback.assert_called_once_with(payload, sub)
 
     def test_shutdown(self):
         self.producer.produce(self.topic, json.dumps(self.valid_wrapper))
         valid_wrapper_2 = deepcopy(self.valid_wrapper)
-        valid_wrapper_2["payload"]["values"]["hello"] = 25
+        valid_wrapper_2["payload"]["result"]["hello"] = 25
         valid_wrapper_3 = deepcopy(valid_wrapper_2)
-        valid_wrapper_3["payload"]["values"]["hello"] = 5000
+        valid_wrapper_3["payload"]["result"]["hello"] = 5000
         self.producer.produce(self.topic, json.dumps(valid_wrapper_2))
         self.producer.flush()
 
@@ -133,7 +178,9 @@ class QuerySubscriptionConsumerTest(TestCase, SnubaTestCase):
         consumer = QuerySubscriptionConsumer("hi", topic=self.topic, commit_batch_size=100)
         consumer.run()
         valid_payload = self.valid_payload
+        valid_payload["values"] = valid_payload["result"]
         valid_payload["timestamp"] = parse_date(valid_payload["timestamp"]).replace(tzinfo=pytz.utc)
+        valid_wrapper_2["payload"]["values"] = valid_wrapper_2["payload"]["result"]
         valid_wrapper_2["payload"]["timestamp"] = parse_date(
             valid_wrapper_2["payload"]["timestamp"]
         ).replace(tzinfo=pytz.utc)
@@ -145,6 +192,7 @@ class QuerySubscriptionConsumerTest(TestCase, SnubaTestCase):
         mock.reset_mock()
         counts[0] = 0
         consumer.run()
+        valid_wrapper_3["payload"]["values"] = valid_wrapper_3["payload"]["result"]
         valid_wrapper_3["payload"]["timestamp"] = parse_date(
             valid_wrapper_3["payload"]["timestamp"]
         ).replace(tzinfo=pytz.utc)

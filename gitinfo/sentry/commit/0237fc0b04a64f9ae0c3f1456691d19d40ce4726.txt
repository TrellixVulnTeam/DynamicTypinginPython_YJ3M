commit 0237fc0b04a64f9ae0c3f1456691d19d40ce4726
Author: David Cramer <dcramer@David-Cramers-MacBook.local>
Date:   Tue Jan 5 15:19:23 2010 -0600

    Compatibility with multi-db in 1.2. Requires DBLOG_DATABASE_USING setting to be present.

diff --git a/README.rst b/README.rst
index 0279809f09..abfd30ed06 100644
--- a/README.rst
+++ b/README.rst
@@ -72,24 +72,14 @@ Enable catching of 404 errors in the logs. Default value is ``False``::
 DBLOG_DATABASE
 ##############
 
-Warning: This feature is currently in the testing phase.
-
 Use a secondary database to store error logs. This is useful if you have several websites and want to aggregate error logs onto one database server::
 
-	DBLOG_DATABASE = dict(
-	    DATABASE_ENGINE='mysql', # defaults to settings.DATABASE_ENGINE
-	    DATABASE_NAME='my_db_name',
-	    DATABASE_USER='db_user',
-	    DATABASE_PASSWORD='db_pass',
-	    DATABASE_HOST='localhost', # defaults to localhost
-	    DATABASE_PORT='', # defaults to [default port]
-	    DATABASE_OPTIONS={}
-	)
+	# This should correspond to a key in your DATABASES setting
+	DBLOG_DATABASE_USING = 'default'
 
 Some things to note:
 
-* You will need to create the tables by hand if you use this option. Use ``python manage.py sql djangodblog`` and dump that SQL into the correct server.
-* This functionality does not yet support Django 1.2.
+* This functionality REQUIRES Django 1.2.
 
 ##################
 DBLOG_WITH_LOGGING
diff --git a/djangodblog/manager.py b/djangodblog/manager.py
index 7041d94dd4..9b562179ec 100644
--- a/djangodblog/manager.py
+++ b/djangodblog/manager.py
@@ -2,20 +2,13 @@
 # TODO: is there a way to use the traceback module based on an exception variable?
 
 from django.conf import settings
-from django.core import signals
 from django.db import models
 from django.conf import settings
 from django.db.models import sql
-from django.db.transaction import savepoint_state
 from django.utils.hashcompat import md5_constructor
 from django.utils.encoding import smart_unicode
-from django.db.models.sql import BaseQuery
 from django.db.models.query import QuerySet
 
-try:
-    import thread
-except ImportError:
-    import dummy_thread as thread
 import traceback
 import logging
 import socket
@@ -23,34 +16,9 @@ import warnings
 import datetime
 import django
 
-django_is_10 = django.VERSION < (1, 1)
+DBLOG_DATABASE_USING = getattr(settings, 'DBLOG_DATABASE_USING', None)
 
-"""
-``DBLOG_DATABASE`` allows you to use a secondary database for error logging::
-
-    DBLOG_DATABASE = dict(
-        DATABASE_ENGINE='mysql', # defaults to settings.DATABASE_ENGINE
-        DATABASE_NAME='my_db_name',
-        DATABASE_USER='db_user',
-        DATABASE_PASSWORD='db_pass',
-        DATABASE_HOST='localhost', # defaults to localhost
-        DATABASE_PORT='', # defaults to [default port]
-        DATABASE_OPTIONS={}
-    )
-    
-Note: You will need to create the tables by hand if you use this option.
-"""
-
-assert not getattr(settings, 'DBLOG_DATABASE', None) or django.VERSION < (1, 2), 'The `DBLOG_DATABASE` setting requires Django < 1.2'
-
-_connection = None
-def close_connection(**kwargs):
-    global _connection
-    if _connection is None:
-        return
-    _connection.close()
-    _connection = None
-signals.request_finished.connect(close_connection)
+assert not DBLOG_DATABASE_USING or django.VERSION >= (1, 2), 'The `DBLOG_DATABASE_USING` setting requires Django >= 1.2'
 
 class DBLogManager(models.Manager):
     use_for_related_fields = True
@@ -65,51 +33,10 @@ class DBLogManager(models.Manager):
         return options
 
     def get_query_set(self):
-        db_options = self._get_settings()
-        if not db_options:
-            return super(DBLogManager, self).get_query_set()
-        connection = self.get_db_wrapper(db_options)
-        
-        if connection.features.uses_custom_query_class:
-            Query = connection.ops.query_class(BaseQuery)
-        else:
-            Query = BaseQuery
-        return QuerySet(self.model, Query(self.model, connection))
-
-    def get_db_wrapper(self, options):
-        global _connection
-        if _connection is None:
-            backend = __import__('django.db.backends.' + options.get('DATABASE_ENGINE', settings.DATABASE_ENGINE)
-                + ".base", {}, {}, ['base'])
-            if django_is_10:
-                backup = {}
-                for key, value in options.iteritems():
-                    backup[key] = getattr(settings, key)
-                    setattr(settings, key, value)
-            _connection = backend.DatabaseWrapper(options)
-            # if django_is_10:
-            #     connection._cursor(settings)
-            # else:
-            #     connection._cursor()
-            if django_is_10:
-                for key, value in backup.iteritems():
-                    setattr(settings, key, value)
-        return _connection
-
-    def _insert(self, values, return_id=False, raw_values=False):
-        db_options = self._get_settings()
-        if not db_options:
-            return super(DBLogManager, self)._insert(values, return_id=return_id, raw_values=raw_values)
-
-        query = sql.InsertQuery(self.model, self.get_db_wrapper(db_options))
-        query.insert_values(values, raw_values)
-        ret = query.execute_sql(return_id)
-        # XXX: Why is the following needed?
-        query.connection._commit()
-        thread_ident = thread.get_ident()
-        if thread_ident in savepoint_state:
-            del savepoint_state[thread_ident]
-        return ret
+        qs = super(DBLogManager, self).get_query_set()
+        if DBLOG_DATABASE_USING:
+            qs = qs.using(DBLOG_DATABASE_USING)
+        return qs
 
     def _create(self, **defaults):
         from models import Error, ErrorBatch

commit 2b8147e044f905feb325ebc3bdb9a2b8f58f7ca4
Author: Mark Story <mark@sentry.io>
Date:   Fri Sep 20 10:23:21 2019 -0400

    fix(discover2) Modal pagination should respect the selected date range (#14779)
    
    Add conditions to constrain pagination results to the currently selected
    date range. This prevents scenarios where an aggregated row will say
    5 events, but more than 5 events can be reached with pagination.
    
    Refs SEN-997

diff --git a/src/sentry/api/bases/organization_events.py b/src/sentry/api/bases/organization_events.py
index 45ea067afa..0e25cc1af4 100644
--- a/src/sentry/api/bases/organization_events.py
+++ b/src/sentry/api/bases/organization_events.py
@@ -1,6 +1,7 @@
 from __future__ import absolute_import
 
 from rest_framework.exceptions import PermissionDenied
+from copy import copy
 
 from sentry import eventstore, features
 from sentry.api.bases import OrganizationEndpoint, OrganizationEventsError
@@ -102,25 +103,36 @@ class OrganizationEventsEndpointBase(OrganizationEndpoint):
             )
         return snuba_args
 
-    def next_event_id(self, request, organization, snuba_args, event):
+    def next_event_id(self, snuba_args, event):
         """
         Returns the next event ID if there is a subsequent event matching the
         conditions provided. Ignores the project_id.
         """
+        conditions = copy(snuba_args["conditions"])
+        if "start" in snuba_args:
+            conditions.append(["timestamp", ">=", snuba_args["start"]])
+        if "end" in snuba_args:
+            conditions.append(["timestamp", "<=", snuba_args["end"]])
         next_event = eventstore.get_next_event_id(
-            event, conditions=snuba_args["conditions"], filter_keys=snuba_args["filter_keys"]
+            event, conditions=conditions, filter_keys=snuba_args["filter_keys"]
         )
 
         if next_event:
             return next_event[1]
 
-    def prev_event_id(self, request, organization, snuba_args, event):
+    def prev_event_id(self, snuba_args, event):
         """
         Returns the previous event ID if there is a previous event matching the
         conditions provided. Ignores the project_id.
         """
+        conditions = copy(snuba_args["conditions"])
+        if "start" in snuba_args:
+            conditions.append(["timestamp", ">=", snuba_args["start"]])
+        if "end" in snuba_args:
+            conditions.append(["timestamp", "<=", snuba_args["end"]])
+
         prev_event = eventstore.get_prev_event_id(
-            event, conditions=snuba_args["conditions"], filter_keys=snuba_args["filter_keys"]
+            event, conditions=conditions, filter_keys=snuba_args["filter_keys"]
         )
 
         if prev_event:
@@ -152,7 +164,12 @@ class OrganizationEventsEndpointBase(OrganizationEndpoint):
         conditions.extend(time_condition)
 
         result = eventstore.get_events(
-            conditions=conditions, filter_keys=snuba_args["filter_keys"], orderby=orderby, limit=1
+            start=snuba_args.get("start", None),
+            end=snuba_args.get("end", None),
+            conditions=conditions,
+            filter_keys=snuba_args["filter_keys"],
+            orderby=orderby,
+            limit=1,
         )
         if not result:
             return None
diff --git a/src/sentry/api/endpoints/organization_event_details.py b/src/sentry/api/endpoints/organization_event_details.py
index 7574a5b555..ab2eac28be 100644
--- a/src/sentry/api/endpoints/organization_event_details.py
+++ b/src/sentry/api/endpoints/organization_event_details.py
@@ -48,16 +48,10 @@ class OrganizationEventDetailsEndpoint(OrganizationEventsEndpointBase):
         # that we constrain related events to the query + current event values
         event_slug = u"{}:{}".format(project.slug, event_id)
         snuba_args["conditions"].extend(get_reference_event_conditions(snuba_args, event_slug))
-        next_event = eventstore.get_next_event_id(
-            event, conditions=snuba_args["conditions"], filter_keys=snuba_args["filter_keys"]
-        )
-        prev_event = eventstore.get_prev_event_id(
-            event, conditions=snuba_args["conditions"], filter_keys=snuba_args["filter_keys"]
-        )
 
         data = serialize(event)
-        data["nextEventID"] = next_event[1] if next_event else None
-        data["previousEventID"] = prev_event[1] if prev_event else None
+        data["nextEventID"] = self.next_event_id(snuba_args, event)
+        data["previousEventID"] = self.prev_event_id(snuba_args, event)
         data["oldestEventID"] = self.oldest_event_id(snuba_args, event)
         data["latestEventID"] = self.latest_event_id(snuba_args, event)
         data["projectSlug"] = project_slug
diff --git a/tests/snuba/api/endpoints/test_organization_event_details.py b/tests/snuba/api/endpoints/test_organization_event_details.py
index b0255ce167..b2b7cae05b 100644
--- a/tests/snuba/api/endpoints/test_organization_event_details.py
+++ b/tests/snuba/api/endpoints/test_organization_event_details.py
@@ -139,6 +139,37 @@ class OrganizationEventDetailsEndpointTest(OrganizationEventDetailsTestBase):
         assert response.data["oldestEventID"] == "e" * 32, "e is oldest matching message"
         assert response.data["latestEventID"] == "1" * 32, "1 is newest matching message"
 
+    def test_event_links_with_date_range(self):
+        # Create older in and out of range events
+        ten_day_ago = iso_format(before_now(days=14))
+        self.store_event(
+            data={"event_id": "3" * 32, "message": "very bad", "timestamp": ten_day_ago},
+            project_id=self.project.id,
+        )
+        seven_min_ago = iso_format(before_now(minutes=7))
+        self.store_event(
+            data={"event_id": "2" * 32, "message": "very bad", "timestamp": seven_min_ago},
+            project_id=self.project.id,
+        )
+
+        url = reverse(
+            "sentry-api-0-organization-event-details",
+            kwargs={
+                "organization_slug": self.project.organization.slug,
+                "project_slug": self.project.slug,
+                "event_id": "b" * 32,
+            },
+        )
+        with self.feature("organizations:events-v2"):
+            response = self.client.get(
+                url, format="json", data={"field": ["message", "count()"], "statsPeriod": "7d"}
+            )
+        assert response.data["eventID"] == "b" * 32
+        assert response.data["nextEventID"] == "c" * 32, "c is newer & matches message + range"
+        assert response.data["previousEventID"] == "2" * 32, "d is older & matches message + range"
+        assert response.data["oldestEventID"] == "2" * 32, "3 is outside range, no match"
+        assert response.data["latestEventID"] == "c" * 32, "c is newest matching message"
+
     def test_event_links_with_tag_fields(self):
         # Create events that overlap with other event messages but
         # with different tags

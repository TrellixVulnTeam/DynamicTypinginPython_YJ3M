commit 1d3313bea9464d0770934a426f39cb404e8a64f4
Author: Stephen Cefali <scefali@sentry.io>
Date:   Mon Apr 20 10:27:38 2020 -0700

    fix(alerts): centralize logic for checking logic for alert rules (#18331)

diff --git a/src/sentry/integrations/pagerduty/notify_action.py b/src/sentry/integrations/pagerduty/notify_action.py
index 5b345557f7..42298da848 100644
--- a/src/sentry/integrations/pagerduty/notify_action.py
+++ b/src/sentry/integrations/pagerduty/notify_action.py
@@ -81,9 +81,6 @@ class PagerDutyNotifyServiceAction(EventAction):
         return self.get_integrations().exists()
 
     def after(self, event, state):
-        if not event.group.is_unresolved():
-            return
-
         integration_id = self.get_option("account")
         service_id = self.get_option("service")
 
diff --git a/src/sentry/integrations/slack/notify_action.py b/src/sentry/integrations/slack/notify_action.py
index 95861cdf5b..feb0f67216 100644
--- a/src/sentry/integrations/slack/notify_action.py
+++ b/src/sentry/integrations/slack/notify_action.py
@@ -89,9 +89,6 @@ class SlackNotifyServiceAction(EventAction):
         return self.get_integrations().exists()
 
     def after(self, event, state):
-        if not event.group.is_unresolved():
-            return
-
         integration_id = self.get_option("workspace")
         channel = self.get_option("channel_id")
         tags = set(self.get_tags_list())
diff --git a/src/sentry/mail/adapter.py b/src/sentry/mail/adapter.py
index b9e3a69a25..010f5e5d40 100644
--- a/src/sentry/mail/adapter.py
+++ b/src/sentry/mail/adapter.py
@@ -156,11 +156,8 @@ class MailAdapter(object):
 
     def should_notify(self, group):
         metrics.incr("mail_adapter.should_notify")
-        send_to = self.get_sendable_users(group.project)
-        if not send_to:
-            return False
-
-        return group.is_unresolved()
+        # only notify if we have users to notify
+        return self.get_sendable_users(group.project)
 
     def get_send_to(self, project, target_type, target_identifier=None, event=None):
         """
diff --git a/src/sentry/plugins/base/notifier.py b/src/sentry/plugins/base/notifier.py
index 6178e42252..c5d2ec02c0 100644
--- a/src/sentry/plugins/base/notifier.py
+++ b/src/sentry/plugins/base/notifier.py
@@ -17,9 +17,6 @@ class Notifier(object):
         """
 
     def should_notify(self, group, event):
-        if not group.is_unresolved():
-            return False
-
         project = group.project
 
         rate_limited = ratelimits.is_limited(project=project, key=self.get_conf_key(), limit=10)
diff --git a/src/sentry/plugins/bases/notify.py b/src/sentry/plugins/bases/notify.py
index 41dba94ef0..2381a88556 100644
--- a/src/sentry/plugins/bases/notify.py
+++ b/src/sentry/plugins/bases/notify.py
@@ -123,9 +123,6 @@ class NotificationPlugin(Plugin):
         if not self.is_configured(project=project):
             return False
 
-        if not group.is_unresolved():
-            return False
-
         # If the plugin doesn't support digests or they are not enabled,
         # perform rate limit checks to support backwards compatibility with
         # older plugins.
diff --git a/src/sentry/rules/actions/base.py b/src/sentry/rules/actions/base.py
index e3d91c785c..ba96086d09 100644
--- a/src/sentry/rules/actions/base.py
+++ b/src/sentry/rules/actions/base.py
@@ -15,6 +15,9 @@ class EventAction(RuleBase):
 
         See the notification implementation for example usage.
 
+        Does not need to handle group state (e.g. is resolved or not)
+        Caller will handle state
+
         >>> def after(self, event, state):
         >>>     yield self.future(self.print_results)
         >>>
diff --git a/src/sentry/rules/processor.py b/src/sentry/rules/processor.py
index 6f3516b21c..57c915edc9 100644
--- a/src/sentry/rules/processor.py
+++ b/src/sentry/rules/processor.py
@@ -144,6 +144,10 @@ class RuleProcessor(object):
                     self.grouped_futures[key][1].append(rule_future)
 
     def apply(self):
+        # we should only apply rules on unresolved issues
+        if not self.event.group.is_unresolved():
+            return six.itervalues({})
+
         self.grouped_futures.clear()
         for rule in self.get_rules():
             self.apply_rule(rule)
diff --git a/tests/sentry/integrations/pagerduty/test_notify_action.py b/tests/sentry/integrations/pagerduty/test_notify_action.py
index 7ede230805..f32acc58ee 100644
--- a/tests/sentry/integrations/pagerduty/test_notify_action.py
+++ b/tests/sentry/integrations/pagerduty/test_notify_action.py
@@ -3,7 +3,7 @@ from __future__ import absolute_import
 import responses
 
 from sentry.utils import json
-from sentry.models import Integration, PagerDutyService, GroupStatus, OrganizationIntegration
+from sentry.models import Integration, PagerDutyService, OrganizationIntegration
 from sentry.testutils.cases import RuleTestCase
 from sentry.integrations.pagerduty.notify_action import PagerDutyNotifyServiceAction
 
@@ -178,24 +178,3 @@ class PagerDutyNotifyActionTest(RuleTestCase):
         form = rule.get_form_instance()
         assert not form.is_valid()
         assert len(form.errors) == 1
-
-    def test_dont_notify_ignored(self):
-        event = self.get_event()
-        event.group.status = GroupStatus.IGNORED
-        event.group.save()
-
-        rule = self.get_rule(data={"account": self.integration.id, "service": self.service.id})
-
-        results = list(rule.after(event=event, state=self.get_state()))
-        assert len(results) == 0
-
-    # this happens if an issue is marked as resolved in the next release
-    def test_dont_notify_resolved(self):
-        event = self.get_event()
-        event.group.status = GroupStatus.RESOLVED
-        event.group.save()
-
-        rule = self.get_rule(data={"account": self.integration.id, "service": self.service.id})
-
-        results = list(rule.after(event=event, state=self.get_state()))
-        assert len(results) == 0
diff --git a/tests/sentry/integrations/slack/test_notify_action.py b/tests/sentry/integrations/slack/test_notify_action.py
index 425e763910..def862722b 100644
--- a/tests/sentry/integrations/slack/test_notify_action.py
+++ b/tests/sentry/integrations/slack/test_notify_action.py
@@ -5,7 +5,7 @@ import responses
 from six.moves.urllib.parse import parse_qs
 
 from sentry.utils import json
-from sentry.models import Integration, GroupStatus
+from sentry.models import Integration
 from sentry.testutils.cases import RuleTestCase
 from sentry.integrations.slack import SlackNotifyServiceAction
 
@@ -231,24 +231,3 @@ class SlackNotifyActionTest(RuleTestCase):
 
         assert not form.is_valid()
         assert len(form.errors) == 1
-
-    def test_dont_notify_ignored(self):
-        event = self.get_event()
-        event.group.status = GroupStatus.IGNORED
-        event.group.save()
-
-        rule = self.get_rule(data={"workspace": self.integration.id, "channel": "#my-channel"})
-
-        results = list(rule.after(event=event, state=self.get_state()))
-        assert len(results) == 0
-
-    # this happens if an issue is marked as resolved in the next release
-    def test_dont_notify_resolved(self):
-        event = self.get_event()
-        event.group.status = GroupStatus.RESOLVED
-        event.group.save()
-
-        rule = self.get_rule(data={"workspace": self.integration.id, "channel": "#my-channel"})
-
-        results = list(rule.after(event=event, state=self.get_state()))
-        assert len(results) == 0
diff --git a/tests/sentry/mail/test_actions.py b/tests/sentry/mail/test_actions.py
index 5559578b6a..1b6f3959ed 100644
--- a/tests/sentry/mail/test_actions.py
+++ b/tests/sentry/mail/test_actions.py
@@ -4,7 +4,7 @@ import six
 from django.core import mail
 
 from sentry.mail.actions import ActionTargetType, NotifyEmailAction, NotifyEmailForm
-from sentry.models import GroupStatus, OrganizationMember, OrganizationMemberTeam, Rule
+from sentry.models import OrganizationMember, OrganizationMemberTeam, Rule
 from sentry.testutils import TestCase
 from sentry.testutils.cases import RuleTestCase
 from sentry.tasks.post_process import post_process_group
@@ -96,16 +96,6 @@ class NotifyEmailTest(RuleTestCase):
         results = list(rule.after(event=event, state=self.get_state()))
         assert len(results) == 1
 
-    def test_should_not_notify(self):
-        event = self.get_event()
-        group = event.group
-        group.update(status=GroupStatus.RESOLVED)
-
-        rule = self.get_rule()
-
-        results = list(rule.after(event=event, state=self.get_state()))
-        assert len(results) == 0
-
     def test_full_integration(self):
         one_min_ago = iso_format(before_now(minutes=1))
         event = self.store_event(
diff --git a/tests/sentry/mail/test_adapter.py b/tests/sentry/mail/test_adapter.py
index 750335ce05..55af336175 100644
--- a/tests/sentry/mail/test_adapter.py
+++ b/tests/sentry/mail/test_adapter.py
@@ -19,7 +19,6 @@ from sentry.event_manager import EventManager, get_event_type
 from sentry.mail.adapter import MailAdapter, ActionTargetType
 from sentry.models import (
     Activity,
-    GroupStatus,
     Organization,
     OrganizationMember,
     OrganizationMemberTeam,
@@ -562,10 +561,6 @@ class MailAdapterShouldNotifyTest(BaseMailAdapterTest, TestCase):
     def test_should_notify(self):
         assert self.adapter.should_notify(self.group)
 
-    def test_should_not_notify_resolved(self):
-        self.group.update(status=GroupStatus.RESOLVED)
-        assert not self.adapter.should_notify(self.group)
-
     def test_should_not_notify_no_users(self):
         UserOption.objects.set_value(
             user=self.user, key="mail:alert", value=0, project=self.project
diff --git a/tests/sentry/plugins/bases/notify/tests.py b/tests/sentry/plugins/bases/notify/tests.py
index 9424febc94..3c0a5d66b4 100644
--- a/tests/sentry/plugins/bases/notify/tests.py
+++ b/tests/sentry/plugins/bases/notify/tests.py
@@ -7,7 +7,6 @@ from sentry.plugins.bases.notify import NotificationPlugin
 from sentry.plugins.base.structs import Notification
 from sentry.testutils import TestCase
 from requests.exceptions import HTTPError, SSLError
-from sentry.models import GroupStatus
 
 
 class DummyNotificationPlugin(CorePluginMixin, NotificationPlugin):
@@ -85,13 +84,3 @@ class DummyNotificationPluginTest(TestCase):
 
     def test_should_notify(self):
         assert self.plugin.should_notify(self.group, self.event)
-
-    def test_dont_notify_ignored(self):
-        self.group.status = GroupStatus.IGNORED
-        self.group.save()
-        assert not self.plugin.should_notify(self.group, self.event)
-
-    def test_dont_notify_resolved(self):
-        self.group.status = GroupStatus.RESOLVED
-        self.group.save()
-        assert not self.plugin.should_notify(self.group, self.event)
diff --git a/tests/sentry/rules/test_processor.py b/tests/sentry/rules/test_processor.py
index 306da20246..ea6827a1af 100644
--- a/tests/sentry/rules/test_processor.py
+++ b/tests/sentry/rules/test_processor.py
@@ -5,16 +5,16 @@ from __future__ import absolute_import
 from datetime import timedelta
 from django.utils import timezone
 
+from sentry.models import GroupRuleStatus, Rule, GroupStatus
 from sentry.mail.actions import ActionTargetType
-from sentry.models import GroupRuleStatus, Rule
 from sentry.testutils import TestCase
 from sentry.rules.processor import RuleProcessor
 
 
 class RuleProcessorTest(TestCase):
-    # this test relies on a few other tests passing
-    def test_integrated(self):
-        event = self.store_event(data={}, project_id=self.project.id)
+    def setUp(self):
+        self.event = self.store_event(data={}, project_id=self.project.id)
+
         action_data = {
             "id": "sentry.mail.actions.NotifyEmailAction",
             "targetType": ActionTargetType.ISSUE_OWNERS.value,
@@ -22,13 +22,16 @@ class RuleProcessorTest(TestCase):
         }
         condition_data = {"id": "sentry.rules.conditions.every_event.EveryEventCondition"}
 
-        Rule.objects.filter(project=event.project).delete()
-        rule = Rule.objects.create(
-            project=event.project, data={"conditions": [condition_data], "actions": [action_data]}
+        Rule.objects.filter(project=self.event.project).delete()
+        self.rule = Rule.objects.create(
+            project=self.event.project,
+            data={"conditions": [condition_data], "actions": [action_data]},
         )
 
+    # this test relies on a few other tests passing
+    def test_integrated(self):
         rp = RuleProcessor(
-            event,
+            self.event,
             is_new=True,
             is_regression=True,
             is_new_group_environment=True,
@@ -38,7 +41,7 @@ class RuleProcessorTest(TestCase):
         assert len(results) == 1
         callback, futures = results[0]
         assert len(futures) == 1
-        assert futures[0].rule == rule
+        assert futures[0].rule == self.rule
         assert futures[0].kwargs == {}
 
         # should not apply twice due to default frequency
@@ -47,9 +50,35 @@ class RuleProcessorTest(TestCase):
 
         # now ensure that moving the last update backwards
         # in time causes the rule to trigger again
-        GroupRuleStatus.objects.filter(rule=rule).update(
+        GroupRuleStatus.objects.filter(rule=self.rule).update(
             last_active=timezone.now() - timedelta(minutes=Rule.DEFAULT_FREQUENCY + 1)
         )
 
         results = list(rp.apply())
         assert len(results) == 1
+
+    def test_ignored_issue(self):
+        self.event.group.status = GroupStatus.IGNORED
+        self.event.group.save()
+        rp = RuleProcessor(
+            self.event,
+            is_new=True,
+            is_regression=True,
+            is_new_group_environment=True,
+            has_reappeared=True,
+        )
+        results = list(rp.apply())
+        assert len(results) == 0
+
+    def test_resolved_issue(self):
+        self.event.group.status = GroupStatus.RESOLVED
+        self.event.group.save()
+        rp = RuleProcessor(
+            self.event,
+            is_new=True,
+            is_regression=True,
+            is_new_group_environment=True,
+            has_reappeared=True,
+        )
+        results = list(rp.apply())
+        assert len(results) == 0

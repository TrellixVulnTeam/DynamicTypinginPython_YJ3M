commit 66c8f9389b55a269a5b5d813141a325b736d3a54
Author: David Cramer <dcramer@gmail.com>
Date:   Sat Jun 7 09:57:04 2014 -0400

    Improve failure handling in HTTP

diff --git a/src/sentry/http.py b/src/sentry/http.py
index 08cabc1490..e32e75410f 100644
--- a/src/sentry/http.py
+++ b/src/sentry/http.py
@@ -6,15 +6,26 @@ sentry.utils.http
 :license: BSD, see LICENSE for more details.
 """
 
+import re
 import sentry
 import socket
 import urllib2
+import zlib
 
 from django.conf import settings
 from django.core.exceptions import SuspiciousOperation
 from ipaddr import IPNetwork
 from urlparse import urlparse
 
+CHARSET_RE = re.compile(r'charset=(\S+)')
+
+DEFAULT_ENCODING = 'utf-8'
+
+DEFAULT_HEADERS = (
+    ('Accept-Encoding', 'gzip'),
+)
+
+DEFAULT_USER_AGENT = 'sentry/%s' % sentry.VERSION
 
 DISALLOWED_IPS = set((IPNetwork(i) for i in settings.SENTRY_DISALLOWED_IPS))
 
@@ -38,8 +49,9 @@ def is_valid_url(url):
     return True
 
 
-def safe_urlopen(url, data=None, headers=(), user_agent='sentry/%s' % sentry.VERSION,
-                 allow_redirects=False, timeout=30):
+def safe_urlopen(url, data=None, headers=DEFAULT_HEADERS,
+                 user_agent=DEFAULT_USER_AGENT, allow_redirects=False,
+                 timeout=30):
     """
     A slightly safer version of ``urlib2.urlopen`` which prevents redirection
     and ensures the URL isn't attempting to hit a blacklisted IP range.
@@ -59,3 +71,28 @@ def safe_urlopen(url, data=None, headers=(), user_agent='sentry/%s' % sentry.VER
     opener = urllib2.build_opener(*handlers)
 
     return opener.open(req, timeout=timeout)
+
+
+def safe_urlread(request):
+    headers = dict(request.headers)
+
+    body = request.read()
+
+    if headers.get('content-encoding') == 'gzip':
+        # Content doesn't *have* to respect the Accept-Encoding header
+        # and may send gzipped data regardless.
+        # See: http://stackoverflow.com/questions/2423866/python-decompressing-gzip-chunk-by-chunk/2424549#2424549
+        body = zlib.decompress(body, 16 + zlib.MAX_WBITS)
+
+    try:
+        content_type = headers['content-type']
+    except KeyError:
+        # If there is no content_type header at all, quickly assume default utf-8 encoding
+        encoding = DEFAULT_ENCODING
+    else:
+        try:
+            encoding = CHARSET_RE.search(content_type).group(1)
+        except AttributeError:
+            encoding = DEFAULT_ENCODING
+
+    return body.decode(encoding).rstrip('\n')
diff --git a/src/sentry/tasks/check_update.py b/src/sentry/tasks/check_update.py
index 31e1f000a7..270974daca 100644
--- a/src/sentry/tasks/check_update.py
+++ b/src/sentry/tasks/check_update.py
@@ -13,8 +13,8 @@ import logging
 
 from simplejson import JSONDecodeError
 
+from sentry.http import safe_urlopen, safe_urlread
 from sentry.tasks.base import instrumented_task
-from sentry.tasks.fetch_source import fetch_url_content, BAD_SOURCE
 
 PYPI_URL = 'https://pypi.python.org/pypi/sentry/json'
 
@@ -28,17 +28,17 @@ def check_update():
     """
     from sentry.receivers import set_sentry_version
 
-    result = fetch_url_content(PYPI_URL)
-
-    if result == BAD_SOURCE:
+    try:
+        request = safe_urlopen(PYPI_URL)
+        result = safe_urlread(request)
+    except Exception:
+        logger.warning('Failed update info of latest version Sentry', exc_info=True)
         return
 
     try:
-        (_, _, body) = result
-
-        version = json.loads(body)['info']['version']
+        version = json.loads(result)['info']['version']
         set_sentry_version(version)
     except JSONDecodeError:
         logger.warning('Failed parsing data json from PYPI')
     except Exception:
-        logger.warning('Failed update info of latest version Sentry')
+        logger.warning('Failed update info of latest version Sentry', exc_info=True)
diff --git a/src/sentry/tasks/fetch_source.py b/src/sentry/tasks/fetch_source.py
index 95e9f5d972..bed90e6097 100644
--- a/src/sentry/tasks/fetch_source.py
+++ b/src/sentry/tasks/fetch_source.py
@@ -10,7 +10,6 @@ import itertools
 import logging
 import hashlib
 import re
-import zlib
 import base64
 
 from django.conf import settings
@@ -20,7 +19,7 @@ from simplejson import JSONDecodeError
 from urlparse import urlparse, urljoin, urlsplit
 
 from sentry.constants import MAX_CULPRIT_LENGTH
-from sentry.http import safe_urlopen
+from sentry.http import safe_urlopen, safe_urlread
 from sentry.utils.cache import cache
 from sentry.utils.sourcemaps import sourcemap_to_index, find_source
 from sentry.utils.strings import truncatechars
@@ -29,8 +28,6 @@ from sentry.utils.strings import truncatechars
 BAD_SOURCE = -1
 # number of surrounding lines (on each side) to fetch
 LINES_OF_CONTEXT = 5
-CHARSET_RE = re.compile(r'charset=(\S+)')
-DEFAULT_ENCODING = 'utf-8'
 BASE64_SOURCEMAP_PREAMBLE = 'data:application/json;base64,'
 BASE64_PREAMBLE_LENGTH = len(BASE64_SOURCEMAP_PREAMBLE)
 UNKNOWN_MODULE = '<unknown module>'
@@ -117,41 +114,6 @@ def discover_sourcemap(result):
     return sourcemap
 
 
-def fetch_url_content(url):
-    """
-    Pull down a URL, returning a tuple (url, headers, body).
-    """
-    try:
-        req = safe_urlopen(url, headers=[
-            ('Accept-Encoding', 'gzip'),
-        ], allow_redirects=True, timeout=settings.SENTRY_SOURCE_FETCH_TIMEOUT)
-        headers = dict(req.headers)
-        body = req.read()
-        if headers.get('content-encoding') == 'gzip':
-            # Content doesn't *have* to respect the Accept-Encoding header
-            # and may send gzipped data regardless.
-            # See: http://stackoverflow.com/questions/2423866/python-decompressing-gzip-chunk-by-chunk/2424549#2424549
-            body = zlib.decompress(body, 16 + zlib.MAX_WBITS)
-
-        try:
-            content_type = headers['content-type']
-        except KeyError:
-            # If there is no content_type header at all, quickly assume default utf-8 encoding
-            encoding = DEFAULT_ENCODING
-        else:
-            try:
-                encoding = CHARSET_RE.search(content_type).group(1)
-            except AttributeError:
-                encoding = DEFAULT_ENCODING
-
-        body = body.decode(encoding).rstrip('\n')
-    except Exception:
-        logging.info('Failed fetching %r', url, exc_info=True)
-        return BAD_SOURCE
-
-    return (url, headers, body)
-
-
 def fetch_url(url):
     """
     Pull down a URL, returning a UrlResult object.
@@ -170,17 +132,28 @@ def fetch_url(url):
         if domain_result:
             return BAD_SOURCE
 
-        result = fetch_url_content(url)
+        try:
+            req = safe_urlopen(url, allow_redirects=True,
+                               timeout=settings.SENTRY_SOURCE_FETCH_TIMEOUT)
+        except Exception:
+            # it's likely we've failed due to a timeout, dns, etc so let's
+            # ensure we can't cascade the failure by pinning this for 5 minutes
+            cache.set(domain_key, 1, 300)
+            logger.warning('Disabling sources to %s for %ss', domain, 300,
+                           exc_info=True)
+            return BAD_SOURCE
+
+        try:
+            result = safe_urlread(req)
+        except Exception:
+            result = BAD_SOURCE
+
         if result == BAD_SOURCE:
             timeout = 300
         else:
             timeout = 60
         cache.set(cache_key, result, timeout)
 
-        if result == BAD_SOURCE:
-            cache.set(domain_key, 1, timeout)
-            logger.warning('Disabling sources to %s for %ss', domain, timeout)
-
     if result == BAD_SOURCE:
         return result
 
diff --git a/tests/sentry/tasks/check_update/tests.py b/tests/sentry/tasks/check_update/tests.py
index 39891bfecb..954c26730f 100644
--- a/tests/sentry/tasks/check_update/tests.py
+++ b/tests/sentry/tasks/check_update/tests.py
@@ -1,6 +1,6 @@
 import json
 
-import mock
+from mock import patch
 
 from sentry.plugins.helpers import get_option, set_option
 from sentry.testutils import TestCase
@@ -17,21 +17,28 @@ class CheckUpdateTest(TestCase):
 
     KEY = 'sentry:latest_version'
 
-    def test_run_check_update_task(self):
-        with mock.patch('sentry.tasks.check_update.fetch_url_content') as fetch:
-            fetch.return_value = (
-                None, None, json.dumps({'info': {'version': self.NEW}})
-            )
-            check_update()  # latest_version > current_version
-            fetch.assert_called_once_with(PYPI_URL)
+    @patch('sentry.tasks.check_update.safe_urlopen')
+    @patch('sentry.tasks.check_update.safe_urlread')
+    def test_run_check_update_task(self, safe_urlread, safe_urlopen):
+        safe_urlread.return_value = json.dumps({'info': {'version': self.NEW}})
+
+        check_update()  # latest_version > current_version
+
+        safe_urlopen.assert_called_once_with(PYPI_URL)
+        safe_urlread.assert_called_once_with(safe_urlopen.return_value)
 
         self.assertEqual(get_option(key=self.KEY), self.NEW)
 
-    def test_run_check_update_task_with_bad_response(self):
-        with mock.patch('sentry.tasks.check_update.fetch_url_content') as fetch:
-            fetch.return_value = (None, None, '')
-            check_update()  # latest_version == current_version
-            fetch.assert_called_once_with(PYPI_URL)
+    @patch('sentry.tasks.check_update.safe_urlopen')
+    @patch('sentry.tasks.check_update.safe_urlread')
+    def test_run_check_update_task_with_bad_response(self, safe_urlread,
+                                                     safe_urlopen):
+        safe_urlread.return_value = ''
+
+        check_update()  # latest_version == current_version
+
+        safe_urlopen.assert_called_once_with(PYPI_URL)
+        safe_urlread.assert_called_once_with(safe_urlopen.return_value)
 
         self.assertEqual(get_option(key=self.KEY), None)
 
@@ -39,22 +46,22 @@ class CheckUpdateTest(TestCase):
         set_sentry_version(latest=self.NEW)
         self.assertEqual(get_option(key=self.KEY), self.NEW)
 
-    def test_set_sentry_version_new(self):
+    @patch('sentry.get_version')
+    def test_set_sentry_version_new(self, get_version):
         set_option(self.KEY, self.OLD)
 
-        with mock.patch('sentry.get_version') as get_version:
-            get_version.return_value = self.CURRENT
+        get_version.return_value = self.CURRENT
 
-            set_sentry_version(latest=self.NEW)
+        set_sentry_version(latest=self.NEW)
 
         self.assertEqual(Option.objects.get_value(key=self.KEY), self.NEW)
 
-    def test_set_sentry_version_old(self):
+    @patch('sentry.get_version')
+    def test_set_sentry_version_old(self, get_version):
         set_option(self.KEY, self.NEW)
 
-        with mock.patch('sentry.get_version') as get_version:
-            get_version.return_value = self.CURRENT
+        get_version.return_value = self.CURRENT
 
-            set_sentry_version(latest=self.OLD)
+        set_sentry_version(latest=self.OLD)
 
         self.assertEqual(Option.objects.get_value(key=self.KEY), self.NEW)

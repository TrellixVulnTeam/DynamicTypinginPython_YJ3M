commit ea1b6476fb261f879b962b178a95f7739dc61ffb
Author: Jess MacQueen <jessmacqueen@gmail.com>
Date:   Mon Jun 11 16:25:10 2018 -0700

    feat(jira): Add autocomplete search for user fields
    
    add another method for handling success to async component
    
    don't bind to instance

diff --git a/src/sentry/integrations/jira/client.py b/src/sentry/integrations/jira/client.py
index 1fc2590e77..31ee96bf6a 100644
--- a/src/sentry/integrations/jira/client.py
+++ b/src/sentry/integrations/jira/client.py
@@ -4,7 +4,7 @@ import datetime
 import jwt
 import re
 from hashlib import md5 as _md5
-from six.moves.urllib.parse import urlparse
+from six.moves.urllib.parse import parse_qs, urlparse, urlsplit
 
 from sentry.utils.cache import cache
 from django.utils.encoding import force_bytes
@@ -41,16 +41,21 @@ class JiraApiClient(ApiClient):
         super(JiraApiClient, self).__init__(verify_ssl=False)
 
     def request(self, method, path, data=None, params=None, **kwargs):
+        # handle params that are already part of the path
+        url_params = dict(parse_qs(urlsplit(path).query))
+        url_params.update(params or {})
+        path = path.split('?')[0]
+
         jwt_payload = {
             'iss': JIRA_KEY,
             'iat': datetime.datetime.utcnow(),
             'exp': datetime.datetime.utcnow() + datetime.timedelta(seconds=5 * 60),
-            'qsh': get_query_hash(path, method.upper(), params),
+            'qsh': get_query_hash(path, method.upper(), url_params),
         }
         encoded_jwt = jwt.encode(jwt_payload, self.shared_secret)
         params = dict(
             jwt=encoded_jwt,
-            **(params or {})
+            **(url_params or {})
         )
         return self._request(method, path, data=data, params=params, **kwargs)
 
diff --git a/src/sentry/integrations/jira/integration.py b/src/sentry/integrations/jira/integration.py
index 8576632d9b..c72ae2f452 100644
--- a/src/sentry/integrations/jira/integration.py
+++ b/src/sentry/integrations/jira/integration.py
@@ -1,5 +1,7 @@
 from __future__ import absolute_import
 
+from six.moves.urllib.parse import quote_plus
+
 from django.core.urlresolvers import reverse
 from django.utils.translation import ugettext_lazy as _
 
@@ -178,15 +180,13 @@ class JiraIntegration(Integration, IssueSyncMixin):
             fkwargs['choices'] = self.make_choices(field_meta.get('allowedValues'))
         elif field_meta.get('autoCompleteUrl') and \
                 (schema.get('items') == 'user' or schema['type'] == 'user'):
-            pass
-            # TODO(jess): implement autocomplete for users
-            # fieldtype = 'select'
-            # sentry_url = '/api/0/issues/%s/plugins/%s/autocomplete' % (group.id, self.slug)
-            # fkwargs['url'] = '%s?jira_url=%s' % (
-            #     sentry_url, quote_plus(field_meta['autoCompleteUrl']),
-            # )
-            # fkwargs['has_autocomplete'] = True
-            # fkwargs['placeholder'] = 'Start typing to search for a user'
+            fieldtype = 'select'
+            sentry_url = reverse(
+                'sentry-extensions-jira-search', args=[group.organization.slug, self.model.id],
+            )
+            fkwargs['url'] = '%s?jira_url=%s' % (
+                sentry_url, quote_plus(field_meta['autoCompleteUrl']),
+            )
         elif schema['type'] in ['timetracking']:
             # TODO: Implement timetracking (currently unsupported alltogether)
             return None
diff --git a/src/sentry/integrations/jira/search.py b/src/sentry/integrations/jira/search.py
index d41cb5e0cd..3eacf8ad4e 100644
--- a/src/sentry/integrations/jira/search.py
+++ b/src/sentry/integrations/jira/search.py
@@ -1,14 +1,28 @@
 from __future__ import absolute_import
 
+from six.moves.urllib.parse import parse_qs, unquote_plus, urlencode, urlsplit, urlunsplit
+
 from rest_framework.response import Response
 
 from sentry.api.bases.organization import OrganizationEndpoint, OrganizationPermission
+from sentry.integrations.exceptions import ApiError, ApiUnauthorized
 from sentry.models import Integration
 
 
 class JiraSearchEndpoint(OrganizationEndpoint):
     permission_classes = (OrganizationPermission, )
 
+    def _get_formatted_user(self, user):
+        display = '%s %s(%s)' % (
+            user.get('displayName', user['name']),
+            '- %s ' % user.get('emailAddress') if user.get('emailAddress') else '',
+            user['name'],
+        )
+        return {
+            'value': user['name'],
+            'label': display,
+        }
+
     def get(self, request, organization, integration_id):
         try:
             integration = Integration.objects.get(
@@ -37,5 +51,85 @@ class JiraSearchEndpoint(OrganizationEndpoint):
                 'value': i['key']
             } for i in resp.get('issues', [])])
 
+        jira_url = request.GET.get('jira_url')
+        if jira_url:
+            jira_url = unquote_plus(jira_url)
+            parsed = list(urlsplit(jira_url))
+            jira_query = parse_qs(parsed[3])
+
+            jira_client = installation.get_client()
+
+            is_user_api = '/rest/api/latest/user/' in jira_url
+
+            is_user_picker = '/rest/api/1.0/users/picker' in jira_url
+
+            if is_user_api:  # its the JSON version of the autocompleter
+                is_xml = False
+                jira_query['username'] = query.encode('utf8')
+                jira_query.pop(
+                    'issueKey', False
+                )  # some reason JIRA complains if this key is in the URL.
+                jira_query['project'] = request.GET.get('project', '').encode('utf8')
+            elif is_user_picker:
+                is_xml = False
+                # for whatever reason, the create meta api returns an
+                # invalid path, so let's just use the correct, documented one here:
+                # https://docs.atlassian.com/jira/REST/cloud/#api/2/user
+                # also, only pass path so saved instance url will be used
+                parsed[0] = ''
+                parsed[1] = ''
+                parsed[2] = '/rest/api/2/user/picker'
+                jira_query['query'] = query.encode('utf8')
+            else:  # its the stupid XML version of the API.
+                is_xml = True
+                jira_query['query'] = query.encode('utf8')
+                if jira_query.get('fieldName'):
+                    # for some reason its a list.
+                    jira_query['fieldName'] = jira_query['fieldName'][0]
+
+            parsed[3] = urlencode(jira_query)
+            final_url = urlunsplit(parsed)
+
+            try:
+                autocomplete_response = jira_client.get_cached(final_url)
+            except (ApiUnauthorized, ApiError):
+                autocomplete_response = None
+
+            users = []
+
+            if autocomplete_response is not None:
+                if is_user_picker:
+                    autocomplete_response = autocomplete_response['users']
+
+                if is_xml:
+                    for userxml in autocomplete_response.xml.findAll("users"):
+                        users.append(
+                            {
+                                'id': userxml.find('name').text,
+                                'text': userxml.find('html').text
+                            }
+                        )
+                else:
+                    for user in autocomplete_response:
+                        if user.get('name'):
+                            users.append(self._get_formatted_user(user))
+
+            # if JIRA user doesn't have proper permission for user api,
+            # try the assignee api instead
+            if not users and is_user_api:
+                try:
+                    autocomplete_response = jira_client.search_users_for_project(
+                        request.GET.get('project', ''),
+                        jira_query.get('username'),
+                    )
+                except (ApiUnauthorized, ApiError):
+                    return Response({'detail': 'Unable to fetch users from JIRA'}, status=400)
+
+                for user in autocomplete_response:
+                    if user.get('name'):
+                        users.append(self._get_formatted_user(user))
+
+            return Response(users)
+
         # TODO(jess): handle other autocomplete urls
         return Response(status=400)
diff --git a/src/sentry/static/sentry/app/components/asyncComponent.jsx b/src/sentry/static/sentry/app/components/asyncComponent.jsx
index 121ceeedc1..b173290e52 100644
--- a/src/sentry/static/sentry/app/components/asyncComponent.jsx
+++ b/src/sentry/static/sentry/app/components/asyncComponent.jsx
@@ -124,6 +124,10 @@ class AsyncComponent extends React.Component {
     });
   };
 
+  onRequestSuccess({stateKey, data, jqXHR}) {
+    // Allow children to implement this
+  }
+
   handleRequestSuccess = ({stateKey, data, jqXHR}, initialRequest) => {
     this.setState(prevState => {
       let state = {
@@ -139,6 +143,7 @@ class AsyncComponent extends React.Component {
 
       return state;
     });
+    this.onRequestSuccess({stateKey, data, jqXHR});
   };
 
   handleError(error, [stateKey]) {
diff --git a/src/sentry/static/sentry/app/components/group/externalIssues.jsx b/src/sentry/static/sentry/app/components/group/externalIssues.jsx
index a6ae6d83a0..bba9f84b31 100644
--- a/src/sentry/static/sentry/app/components/group/externalIssues.jsx
+++ b/src/sentry/static/sentry/app/components/group/externalIssues.jsx
@@ -43,14 +43,34 @@ class ExternalIssueForm extends AsyncComponent {
     if (!input) {
       return Promise.resolve([]);
     }
+    let {dynamicFieldValues} = this.state;
+    let additionalParams = Object.entries(dynamicFieldValues)
+      .map(([key, val]) => {
+        return `${key}=${encodeURIComponent(val)}`;
+      })
+      .join('&');
+    if (additionalParams) {
+      additionalParams = `&${additionalParams}`;
+    }
+
+    let url = field.url;
+    let separator = url.includes('?') ? '&' : '?';
     return $.ajax({
-      url: `${field.url}?field=${field.name}&query=${input}`,
+      url: `${url}${separator}field=${field.name}&query=${input}${additionalParams}`,
       method: 'GET',
     }).then(data => {
       return {options: data};
     });
   };
 
+  onRequestSuccess({stateKey, data, jqXHR}) {
+    if (stateKey === 'integrationDetails' && !this.state.dynamicFieldValues) {
+      this.setState({
+        dynamicFieldValues: this.getDynamicFields(data),
+      });
+    }
+  }
+
   refetchConfig = () => {
     let {dynamicFieldValues} = this.state;
     let {action, group, integration} = this.props;
@@ -73,14 +93,20 @@ class ExternalIssueForm extends AsyncComponent {
     });
   };
 
-  onFieldChange = (label, value) => {
-    let {integrationDetails} = this.state;
+  getDynamicFields(integrationDetails) {
+    integrationDetails = integrationDetails || this.state.integrationDetails;
     let {action} = this.props;
     let config = integrationDetails[`${action}IssueConfig`];
-    let dynamicFields = new Set(
-      config.filter(field => field.updatesForm).map(field => field.name)
-    );
-    if (dynamicFields.has(label)) {
+    let dynamicFields = {};
+    config.filter(field => field.updatesForm).forEach(field => {
+      dynamicFields[field.name] = field.default;
+    });
+    return dynamicFields;
+  }
+
+  onFieldChange = (label, value) => {
+    let dynamicFields = this.getDynamicFields();
+    if (label in dynamicFields) {
       let dynamicFieldValues = this.state.dynamicFieldValues || {};
       dynamicFieldValues[label] = value;
 

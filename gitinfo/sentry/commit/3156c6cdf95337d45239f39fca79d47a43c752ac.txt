commit 3156c6cdf95337d45239f39fca79d47a43c752ac
Author: ted kaemming <ted@kaemming.com>
Date:   Thu Nov 10 13:36:15 2016 -0800

    Correct subscription checks in issue API response. (#4501)

diff --git a/CHANGES b/CHANGES
index 025d80e897..1237bd3f69 100644
--- a/CHANGES
+++ b/CHANGES
@@ -5,6 +5,7 @@ Version 8.11 (Unreleased)
 - Added the ability to search for issues that you are subscribed to from the stream view.
 - Added the ability to search issues by their last seen timestamp.
 - Improved UI for password and API key fields used in integrations
+- Fixed bug where API responses would include incorrect `isSubscribed` values for issues.
 
 Version 8.10
 ------------
diff --git a/src/sentry/api/serializers/models/group.py b/src/sentry/api/serializers/models/group.py
index 97ed38ee3b..504dcb94f1 100644
--- a/src/sentry/api/serializers/models/group.py
+++ b/src/sentry/api/serializers/models/group.py
@@ -2,9 +2,10 @@ from __future__ import absolute_import, print_function
 
 import six
 
-from collections import namedtuple
+from collections import defaultdict, namedtuple
 from datetime import timedelta
 from django.core.urlresolvers import reverse
+from django.db.models import Q
 from django.utils import timezone
 
 from sentry.api.serializers import Serializer, register, serialize
@@ -23,26 +24,62 @@ from sentry.utils.safe import safe_execute
 @register(Group)
 class GroupSerializer(Serializer):
     def _get_subscriptions(self, item_list, user):
-        default_subscribed = UserOption.objects.get_value(
+        results = {group.id: None for group in item_list}
+
+        # First, the easy part -- if there is a subscription record associated
+        # with the group, we can just use that to know if a user is subscribed
+        # or not.
+        subscriptions = GroupSubscription.objects.filter(
+            group__in=results.keys(),
             user=user,
-            project=None,
-            key='workflow:notifications',
         )
-        if default_subscribed == UserOptionValue.participating_only:
-            subscriptions = set(GroupSubscription.objects.filter(
-                group__in=item_list,
-                user=user,
-                is_active=True,
-            ).values_list('group_id', flat=True))
-        else:
-            subscriptions = set([i.id for i in item_list]).difference(
-                GroupSubscription.objects.filter(
-                    group__in=item_list,
+
+        for subscription in subscriptions:
+            results[subscription.group_id] = subscription.is_active
+
+        # For any group that doesn't have a subscription associated with it,
+        # we'll need to fall back to the project's option value, so here we
+        # collect all of the projects to look up, and keep a set of groups that
+        # are part of that project. (Note that the common -- but not only --
+        # case here is that all groups are part of the same project.)
+        projects = defaultdict(set)
+        for group in item_list:
+            if results[group.id] is None:
+                projects[group.project].add(group.id)
+
+        if projects:
+            # NOTE: This doesn't use `values_list` because that bypasses field
+            # value decoding, so the `value` field would not be unpickled.
+            options = {
+                option.project_id: option.value
+                for option in
+                UserOption.objects.filter(
+                    Q(project__in=projects.keys()) | Q(project__isnull=True),
                     user=user,
-                    is_active=False,
-                ).values_list('group_id', flat=True),
-            )
-        return subscriptions
+                    key='workflow:notifications',
+                )
+            }
+
+            # This is the user's default value for any projects that don't have
+            # the option value specifically recorded. (The default "all
+            # conversations" value is convention.)
+            default = options.get(None, UserOptionValue.all_conversations)
+
+            # If you're subscribed to all notifications for the project, that
+            # means you're subscribed to all of the groups. Otherwise you're
+            # not subscribed to any of these leftover groups.
+            for project, group_ids in projects.items():
+                is_subscribed = options.get(
+                    project.id,
+                    default,
+                ) == UserOptionValue.all_conversations
+
+                for group_id in group_ids:
+                    results[group_id] = is_subscribed
+
+        # These are the IDs of all of the groups that the user is subscribed to
+        # that were part of the original candidate list.
+        return {group_id for group_id, is_subscribed in results.items() if is_subscribed}
 
     def get_attrs(self, item_list, user):
         from sentry.plugins import plugins
diff --git a/tests/sentry/api/serializers/test_group.py b/tests/sentry/api/serializers/test_group.py
index b2e4e2f106..c1ad32be64 100644
--- a/tests/sentry/api/serializers/test_group.py
+++ b/tests/sentry/api/serializers/test_group.py
@@ -9,7 +9,7 @@ from mock import patch
 from sentry.api.serializers import serialize
 from sentry.models import (
     GroupResolution, GroupResolutionStatus, GroupSnooze, GroupSubscription,
-    GroupStatus, Release
+    GroupStatus, Release, UserOption, UserOptionValue
 )
 from sentry.testutils import TestCase
 
@@ -129,8 +129,37 @@ class GroupSerializerTest(TestCase):
         user = self.create_user()
         group = self.create_group()
 
-        result = serialize(group, user)
-        assert result['isSubscribed']
+        combinations = (
+            ((None, None), True),
+            ((UserOptionValue.all_conversations, None), True),
+            ((UserOptionValue.all_conversations, UserOptionValue.all_conversations), True),
+            ((UserOptionValue.all_conversations, UserOptionValue.participating_only), False),
+            ((UserOptionValue.participating_only, None), False),
+            ((UserOptionValue.participating_only, UserOptionValue.all_conversations), True),
+            ((UserOptionValue.participating_only, UserOptionValue.participating_only), False),
+        )
+
+        def maybe_set_value(project, value):
+            if value is not None:
+                UserOption.objects.set_value(
+                    user=user,
+                    project=project,
+                    key='workflow:notifications',
+                    value=value,
+                )
+            else:
+                UserOption.objects.unset_value(
+                    user=user,
+                    project=project,
+                    key='workflow:notifications',
+                )
+
+        for options, expected_result in combinations:
+            UserOption.objects.clear_cache()
+            default_value, project_value = options
+            maybe_set_value(None, default_value)
+            maybe_set_value(group.project, project_value)
+            assert serialize(group, user)['isSubscribed'] is expected_result, 'expected {!r} for {!r}'.format(expected_result, options)
 
     def test_no_user_unsubscribed(self):
         group = self.create_group()

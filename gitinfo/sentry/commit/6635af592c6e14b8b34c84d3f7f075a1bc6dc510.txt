commit 6635af592c6e14b8b34c84d3f7f075a1bc6dc510
Author: Lyn Nagara <lyn.nagara@gmail.com>
Date:   Thu Jan 16 14:03:34 2020 -0800

    perf(eventstore): get_events fetches event data from nodestore (#16230)
    
    These queries yield 10+ columns from Snuba (including all
    of the tag data) and are frequently taking a long time.
    Instead we now fetch the minimal column set from Snuba, then use
    those IDs to populate the event bodies from nodestore. Users of
    eventstore.get_events() should no longer manually bind nodes since this
    has already been done. eventsttore.get_unfetched_events() can be used to
    skip the nodestore fetch.

diff --git a/src/sentry/api/endpoints/group_events.py b/src/sentry/api/endpoints/group_events.py
index 7139199c0a..023a7a679c 100644
--- a/src/sentry/api/endpoints/group_events.py
+++ b/src/sentry/api/endpoints/group_events.py
@@ -94,14 +94,7 @@ class GroupEventsEndpoint(GroupEndpoint, EnvironmentMixin):
         snuba_filter = get_filter(request.GET.get("query", None), params)
         snuba_filter.conditions.append(["event.type", "!=", "transaction"])
 
-        snuba_cols = None if full else eventstore.full_columns
-
-        data_fn = partial(
-            eventstore.get_events,
-            additional_columns=snuba_cols,
-            referrer="api.group-events",
-            filter=snuba_filter,
-        )
+        data_fn = partial(eventstore.get_events, referrer="api.group-events", filter=snuba_filter)
 
         serializer = EventSerializer() if full else SimpleEventSerializer()
         return self.paginate(
diff --git a/src/sentry/api/endpoints/organization_events.py b/src/sentry/api/endpoints/organization_events.py
index 8bdde13c37..b36af34bf8 100644
--- a/src/sentry/api/endpoints/organization_events.py
+++ b/src/sentry/api/endpoints/organization_events.py
@@ -49,11 +49,8 @@ class OrganizationEventsEndpoint(OrganizationEventsEndpointBase):
             # or user doesn't have access to projects in org
             data_fn = lambda *args, **kwargs: []
         else:
-            cols = None if full else eventstore.full_columns
-
             data_fn = partial(
                 eventstore.get_events,
-                additional_columns=cols,
                 referrer="api.organization-events",
                 filter=eventstore.Filter(
                     start=snuba_args["start"],
diff --git a/src/sentry/api/endpoints/project_events.py b/src/sentry/api/endpoints/project_events.py
index 6d388c465b..d0e4147007 100644
--- a/src/sentry/api/endpoints/project_events.py
+++ b/src/sentry/api/endpoints/project_events.py
@@ -49,12 +49,10 @@ class ProjectEventsEndpoint(ProjectEndpoint):
             )
 
         full = request.GET.get("full", False)
-        cols = None if full else eventstore.full_columns
 
         data_fn = partial(
             eventstore.get_events,
             filter=eventstore.Filter(conditions=conditions, project_ids=[project.id]),
-            additional_columns=cols,
             referrer="api.project-events",
         )
 
diff --git a/src/sentry/api/serializers/models/event.py b/src/sentry/api/serializers/models/event.py
index b026330d3a..a6e6fb9927 100644
--- a/src/sentry/api/serializers/models/event.py
+++ b/src/sentry/api/serializers/models/event.py
@@ -6,7 +6,6 @@ from datetime import datetime
 from django.utils import timezone
 from semaphore import meta_with_chunks
 
-from sentry import eventstore
 from sentry.api.serializers import Serializer, register, serialize
 from sentry.models import Event as DjangoEvent, EventAttachment, EventError, Release, UserReport
 from sentry.search.utils import convert_user_tag_to_query
@@ -168,8 +167,6 @@ class EventSerializer(Serializer):
         return serialize(user_report, user)
 
     def get_attrs(self, item_list, user, is_public=False):
-        eventstore.bind_nodes(item_list, "data")
-
         crash_files = get_crash_files(item_list)
         results = {}
         for item in item_list:
diff --git a/src/sentry/deletions/defaults/group.py b/src/sentry/deletions/defaults/group.py
index 0edcd7f1c1..2ad2d223df 100644
--- a/src/sentry/deletions/defaults/group.py
+++ b/src/sentry/deletions/defaults/group.py
@@ -33,7 +33,7 @@ class EventDataDeletionTask(BaseDeletionTask):
                 ]
             )
 
-        events = eventstore.get_events(
+        events = eventstore.get_unfetched_events(
             filter=eventstore.Filter(
                 conditions=conditions, project_ids=[self.project_id], group_ids=[self.group_id]
             ),
diff --git a/src/sentry/event_manager.py b/src/sentry/event_manager.py
index 5ab9fec039..3cf3b61fa3 100644
--- a/src/sentry/event_manager.py
+++ b/src/sentry/event_manager.py
@@ -8,7 +8,6 @@ import jsonschema
 import six
 
 from datetime import datetime, timedelta
-from django.conf import settings
 from django.core.cache import cache
 from django.db import connection, IntegrityError, router, transaction
 from django.db.models import Func
@@ -438,34 +437,6 @@ class EventManager(object):
             "location": event_type.get_location(event_metadata),
         }
 
-    def get_search_message(self, event_metadata=None, culprit=None):
-        """This generates the internal event.message attribute which is used
-        for search purposes.  It adds a bunch of data from the metadata and
-        the culprit.
-        """
-        if event_metadata is None:
-            event_metadata = self.get_event_type().get_metadata(self._data)
-        if culprit is None:
-            culprit = self.get_culprit()
-
-        data = self._data
-        message = ""
-
-        if data.get("logentry"):
-            message += data["logentry"].get("formatted") or data["logentry"].get("message") or ""
-
-        if event_metadata:
-            for value in six.itervalues(event_metadata):
-                value_u = force_text(value, errors="replace")
-                if value_u not in message:
-                    message = u"{} {}".format(message, value_u)
-
-        if culprit and culprit not in message:
-            culprit_u = force_text(culprit, errors="replace")
-            message = u"{} {}".format(message, culprit_u)
-
-        return trim(message.strip(), settings.SENTRY_MAX_MESSAGE_LENGTH)
-
     def save(self, project_id, raw=False, assume_normalized=False):
         """
         We re-insert events with duplicate IDs into Snuba, which is responsible
@@ -615,13 +586,17 @@ class EventManager(object):
         # however the data is dynamically overridden by Event.title and
         # Event.location (See Event.as_dict)
         materialized_metadata = self.materialize_metadata()
-        event_metadata = materialized_metadata["metadata"]
         data.update(materialized_metadata)
         data["culprit"] = culprit
 
         # index components into ``Event.message``
         # See GH-3248
-        event.message = self.get_search_message(event_metadata, culprit)
+        # TODO: We temporarily save the search message into the message field to
+        # maintain backward compatibility with the Django event model. Once
+        # "store.use-django-event" is turned off for good, we can just reference
+        # event.search_message everywhere.
+        event.message = event.search_message
+
         received_timestamp = event.data.get("received") or float(event.datetime.strftime("%s"))
 
         if not issueless_event:
diff --git a/src/sentry/eventstore/base.py b/src/sentry/eventstore/base.py
index 59c8262e65..b11cf0d3fe 100644
--- a/src/sentry/eventstore/base.py
+++ b/src/sentry/eventstore/base.py
@@ -62,10 +62,10 @@ class Filter(object):
 class EventStorage(Service):
     __all__ = (
         "minimal_columns",
-        "full_columns",
         "create_event",
         "get_event_by_id",
         "get_events",
+        "get_unfetched_events",
         "get_prev_event_id",
         "get_next_event_id",
         "get_earliest_event_id",
@@ -79,40 +79,14 @@ class EventStorage(Service):
     # avoid duplicated work.
     minimal_columns = [Columns.EVENT_ID, Columns.GROUP_ID, Columns.PROJECT_ID, Columns.TIMESTAMP]
 
-    # A list of all useful columns we can get from snuba.
-    full_columns = minimal_columns + [
-        Columns.CULPRIT,
-        Columns.LOCATION,
-        Columns.MESSAGE,
-        Columns.PLATFORM,
-        Columns.TITLE,
-        Columns.TYPE,
-        Columns.TRANSACTION,
-        # Required to provide snuba-only tags
-        Columns.TAGS_KEY,
-        Columns.TAGS_VALUE,
-        # Required to provide snuba-only 'user' interface
-        Columns.USER_EMAIL,
-        Columns.USER_IP_ADDRESS,
-        Columns.USER_ID,
-        Columns.USER_USERNAME,
-    ]
-
     def get_events(
-        self,
-        filter,
-        additional_columns=None,
-        orderby=None,
-        limit=100,
-        offset=0,
-        referrer="eventstore.get_events",
+        self, filter, orderby=None, limit=100, offset=0, referrer="eventstore.get_events"
     ):
         """
         Fetches a list of events given a set of criteria.
 
         Arguments:
         filter (Filter): Filter
-        additional_columns (Sequence[Column]): List of additional columns to fetch - default None
         orderby (Sequence[str]): List of fields to order by - default ['-time', '-event_id']
         limit (int): Query limit - default 100
         offset (int): Query offset - default 0
@@ -120,6 +94,27 @@ class EventStorage(Service):
         """
         raise NotImplementedError
 
+    def get_unfetched_events(
+        self, filter, orderby=None, limit=100, offset=0, referrer="eventstore.get_unfetched_events"
+    ):
+        """
+        Same as get_events but returns events without their node datas loaded.
+        Only the event ID, projectID, groupID and timestamp field will be present without
+        an additional fetch to nodestore.
+
+        Used for fetching large volumes of events that do not need data loaded
+        from nodestore. Currently this is just used for event data deletions where
+        we just need the event IDs in order to process the deletions.
+
+        Arguments:
+        filter (Filter): Filter
+        orderby (Sequence[str]): List of fields to order by - default ['-time', '-event_id']
+        limit (int): Query limit - default 100
+        offset (int): Query offset - default 0
+        referrer (string): Referrer - default "eventstore.get_unfetched_events"
+        """
+        raise NotImplementedError
+
     def get_event_by_id(self, project_id, event_id):
         """
         Gets a single event given a project_id and event_id.
@@ -174,12 +169,12 @@ class EventStorage(Service):
         """
         raise NotImplementedError
 
-    def create_event(self, project_id=None, event_id=None, group_id=None, message=None, data=None):
+    def create_event(self, project_id=None, event_id=None, group_id=None, data=None):
         """
         Returns an Event from processed data
         """
         return Event(
-            project_id=project_id, event_id=event_id, group_id=group_id, message=message, data=data
+            project_id=project_id, event_id=event_id, group_id=group_id, data=data
         )
 
     def bind_nodes(self, object_list, node_name="data"):
diff --git a/src/sentry/eventstore/models.py b/src/sentry/eventstore/models.py
index 25e76abfab..80c27e2e82 100644
--- a/src/sentry/eventstore/models.py
+++ b/src/sentry/eventstore/models.py
@@ -7,7 +7,6 @@ from dateutil.parser import parse as parse_date
 
 from sentry.models import EventCommon, EventDict
 from sentry.db.models import NodeData
-
 from sentry.snuba.events import Columns
 
 
@@ -16,13 +15,14 @@ def ref_func(x):
 
 
 class Event(EventCommon):
-    def __init__(
-        self, project_id, event_id, group_id=None, message=None, data=None, snuba_data=None
-    ):
+    """
+    Event backed by nodestore and Snuba.
+    """
+
+    def __init__(self, project_id, event_id, group_id=None, data=None, snuba_data=None):
         self.project_id = project_id
         self.event_id = event_id
         self.group_id = group_id
-        self.message = message
         self.data = data
         self._snuba_data = snuba_data or {}
         super(Event, self).__init__()
@@ -73,9 +73,8 @@ class Event(EventCommon):
 
     @property
     def message(self):
-        if self._message:
+        if hasattr(self, "_message"):
             return self._message
-
         column = self.__get_column_name(Columns.MESSAGE)
         if column in self._snuba_data:
             return self._snuba_data[column]
@@ -84,6 +83,10 @@ class Event(EventCommon):
 
     @message.setter
     def message(self, value):
+        """
+        This can be removed once Django Event is removed and we no longer need to manually
+        update this field in event_manager.save().
+        """
         self._message = value
 
     @property
diff --git a/src/sentry/eventstore/snuba/backend.py b/src/sentry/eventstore/snuba/backend.py
index f7d362d996..66e63b16bf 100644
--- a/src/sentry/eventstore/snuba/backend.py
+++ b/src/sentry/eventstore/snuba/backend.py
@@ -47,17 +47,54 @@ class SnubaEventStorage(EventStorage):
     def get_events(
         self,
         filter,
-        additional_columns=None,
         orderby=None,
         limit=DEFAULT_LIMIT,
         offset=DEFAULT_OFFSET,
         referrer="eventstore.get_events",
     ):
         """
-        Get events from Snuba.
+        Get events from Snuba, with node data loaded.
         """
+        return self.__get_events(
+            filter,
+            orderby=orderby,
+            limit=limit,
+            offset=offset,
+            referrer=referrer,
+            should_bind_nodes=True,
+        )
+
+    def get_unfetched_events(
+        self,
+        filter,
+        orderby=None,
+        limit=DEFAULT_LIMIT,
+        offset=DEFAULT_OFFSET,
+        referrer="eventstore.get_unfetched_events",
+    ):
+        """
+        Get events from Snuba, without node data loaded.
+        """
+        return self.__get_events(
+            filter,
+            orderby=orderby,
+            limit=limit,
+            offset=offset,
+            referrer=referrer,
+            should_bind_nodes=False,
+        )
+
+    def __get_events(
+        self,
+        filter,
+        orderby=None,
+        limit=DEFAULT_LIMIT,
+        offset=DEFAULT_OFFSET,
+        referrer=None,
+        should_bind_nodes=False,
+    ):
         assert filter, "You must provide a filter"
-        cols = self.__get_columns(additional_columns)
+        cols = self.__get_columns()
         orderby = orderby or DESC_ORDERING
 
         result = snuba.dataset_query(
@@ -74,7 +111,10 @@ class SnubaEventStorage(EventStorage):
         )
 
         if "error" not in result:
-            return [self.__make_event(evt) for evt in result["data"]]
+            events = [self.__make_event(evt) for evt in result["data"]]
+            if should_bind_nodes:
+                self.bind_nodes(events)
+            return events
 
         return []
 
@@ -169,7 +209,7 @@ class SnubaEventStorage(EventStorage):
 
         return self.__get_event_id_from_filter(filter=filter, orderby=DESC_ORDERING)
 
-    def __get_columns(self, additional_columns):
+    def __get_columns(self, additional_columns=None):
         columns = EventStorage.minimal_columns
 
         if additional_columns:
diff --git a/src/sentry/models/event.py b/src/sentry/models/event.py
index 56964b5286..48df644244 100644
--- a/src/sentry/models/event.py
+++ b/src/sentry/models/event.py
@@ -4,8 +4,10 @@ import six
 import string
 
 from collections import OrderedDict
+from django.conf import settings
 from django.db import models
 from django.utils import timezone
+from django.utils.encoding import force_text
 from django.utils.translation import ugettext_lazy as _
 from hashlib import md5
 
@@ -27,6 +29,7 @@ from sentry.utils.cache import memoize
 from sentry.utils.canonical import CanonicalKeyDict, CanonicalKeyView
 from sentry.utils.safe import get_path
 from sentry.utils.strings import truncatechars
+from sentry.utils.safe import trim
 
 
 class EventDict(CanonicalKeyDict):
@@ -342,6 +345,37 @@ class EventCommon(object):
 
         return data
 
+    @property
+    def search_message(self):
+        """
+        The internal search_message attribute is only used for search purposes.
+        It adds a bunch of data from the metadata and the culprit.
+        """
+        data = self.data
+        culprit = self.culprit
+
+        event_metadata = self.get_event_metadata()
+
+        if event_metadata is None:
+            event_metadata = eventtypes.get(self.get_event_type())().get_metadata(self.data)
+
+        message = ""
+
+        if data.get("logentry"):
+            message += data["logentry"].get("formatted") or data["logentry"].get("message") or ""
+
+        if event_metadata:
+            for value in six.itervalues(event_metadata):
+                value_u = force_text(value, errors="replace")
+                if value_u not in message:
+                    message = u"{} {}".format(message, value_u)
+
+        if culprit and culprit not in message:
+            culprit_u = force_text(culprit, errors="replace")
+            message = u"{} {}".format(message, culprit_u)
+
+        return trim(message.strip(), settings.SENTRY_MAX_MESSAGE_LENGTH)
+
 
 def ref_func(x):
     return x.project_id or x.project.id
diff --git a/src/sentry/tasks/unmerge.py b/src/sentry/tasks/unmerge.py
index 0d6797f0f4..62f8343719 100644
--- a/src/sentry/tasks/unmerge.py
+++ b/src/sentry/tasks/unmerge.py
@@ -23,7 +23,6 @@ from sentry.models import (
     EventAttachment,
 )
 from sentry.similarity import features
-from sentry.snuba.events import Columns
 from sentry.tasks.base import instrumented_task
 from six.moves import reduce
 
@@ -99,7 +98,7 @@ initial_fields = {
     },
     "last_seen": lambda event: event.datetime,
     "level": lambda event: LOG_LEVELS_MAP.get(event.get_tag("level"), logging.ERROR),
-    "message": lambda event: event.message,
+    "message": lambda event: event.search_message,
     "times_seen": lambda event: 0,
 }
 
@@ -505,9 +504,6 @@ def unmerge(
         filter=eventstore.Filter(
             project_ids=[project_id], group_ids=[source.id], conditions=conditions
         ),
-        # We need the text-only "search message" from Snuba, not the raw message
-        # dict field from nodestore.
-        additional_columns=[Columns.MESSAGE],
         limit=batch_size,
         referrer="unmerge",
         orderby=["-timestamp", "-event_id"],
@@ -522,8 +518,6 @@ def unmerge(
 
         return destination_id
 
-    eventstore.bind_nodes(events, "data")
-
     source_events = []
     destination_events = []
 
diff --git a/src/sentry/web/frontend/debug/mail.py b/src/sentry/web/frontend/debug/mail.py
index 3af9382be0..45cd5868c5 100644
--- a/src/sentry/web/frontend/debug/mail.py
+++ b/src/sentry/web/frontend/debug/mail.py
@@ -194,13 +194,13 @@ class ActivityMailDebugView(View):
         data = event_manager.get_data()
         event_type = event_manager.get_event_type()
 
-        group.message = event_manager.get_search_message()
-        group.data = {"type": event_type.key, "metadata": event_type.get_metadata(data)}
-
         event = eventstore.create_event(
             event_id="a" * 32, group_id=group.id, project_id=project.id, data=data.data
         )
 
+        group.message = event.search_message
+        group.data = {"type": event_type.key, "metadata": event_type.get_metadata(data)}
+
         activity = Activity(group=group, project=event.project, **self.get_activity(request, event))
 
         return render_to_response(
@@ -244,7 +244,7 @@ def alert(request):
         event.data["timestamp"] = 1504656000.0  # datetime(2017, 9, 6, 0, 0)
     event_type = event_manager.get_event_type()
 
-    group.message = event_manager.get_search_message()
+    group.message = event.search_message
     group.data = {"type": event_type.key, "metadata": event_type.get_metadata(data)}
 
     rule = Rule(label="An example rule")
diff --git a/tests/sentry/eventstore/snuba/test_backend.py b/tests/sentry/eventstore/snuba/test_backend.py
index 3850aa4fd1..7f1d989e00 100644
--- a/tests/sentry/eventstore/snuba/test_backend.py
+++ b/tests/sentry/eventstore/snuba/test_backend.py
@@ -6,7 +6,6 @@ from sentry.testutils import TestCase, SnubaTestCase
 from sentry.testutils.helpers.datetime import iso_format, before_now
 from sentry.eventstore.snuba.backend import SnubaEventStorage
 from sentry.eventstore.base import Filter
-
 from sentry.utils.samples import load_data
 
 
diff --git a/tests/sentry/eventstore/test_base.py b/tests/sentry/eventstore/test_base.py
index 1aa85f4698..6444f49a53 100644
--- a/tests/sentry/eventstore/test_base.py
+++ b/tests/sentry/eventstore/test_base.py
@@ -21,9 +21,6 @@ class EventStorageTest(TestCase):
     def test_minimal_columns(self):
         assert len(self.eventstorage.minimal_columns) == 4
 
-    def test_full_columns(self):
-        assert len(self.eventstorage.full_columns) == 17
-
     def test_bind_nodes(self):
         """
         Test that bind_nodes populates _node_data
diff --git a/tests/sentry/eventstore/test_models.py b/tests/sentry/eventstore/test_models.py
index d10042b380..72def2170b 100644
--- a/tests/sentry/eventstore/test_models.py
+++ b/tests/sentry/eventstore/test_models.py
@@ -3,7 +3,6 @@ from __future__ import absolute_import
 import pickle
 import pytest
 
-from sentry import eventstore
 from sentry.db.models.fields.node import NodeData
 from sentry.eventstore.models import Event
 from sentry.models import Environment
@@ -200,7 +199,24 @@ class EventTest(TestCase):
             project_id=self.project.id,
             event_id="a" * 32,
             snuba_data=snuba.raw_query(
-                selected_columns=[col.value.event_name for col in eventstore.full_columns],
+                selected_columns=[
+                    "event_id",
+                    "project_id",
+                    "group_id",
+                    "timestamp",
+                    "culprit",
+                    "location",
+                    "message",
+                    "title",
+                    "type",
+                    "transaction",
+                    "tags.key",
+                    "tags.value",
+                    "email",
+                    "ip_address",
+                    "user_id",
+                    "username",
+                ],
                 filter_keys={"project_id": [self.project.id], "event_id": ["a" * 32]},
             )["data"][0],
         )

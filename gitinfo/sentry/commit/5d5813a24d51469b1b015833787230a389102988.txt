commit 5d5813a24d51469b1b015833787230a389102988
Author: MeredithAnya <meredith.a.heller@gmail.com>
Date:   Mon Jul 2 15:27:20 2018 -0700

    feat(integrations): GHE webhook support (#8781)

diff --git a/src/sentry/integrations/github/client.py b/src/sentry/integrations/github/client.py
index 618903961d..369310bc85 100644
--- a/src/sentry/integrations/github/client.py
+++ b/src/sentry/integrations/github/client.py
@@ -52,6 +52,9 @@ class GitHubClientMixin(ApiClient):
         )
         return repositories['repositories']
 
+    def get_user(self, gh_username):
+        return self.get('/users/{}'.format(gh_username))
+
     def request(self, method, path, headers=None, data=None, params=None):
         if headers is None:
             headers = {
diff --git a/src/sentry/integrations/github/payload.py b/src/sentry/integrations/github/payload.py
deleted file mode 100644
index 75517862d1..0000000000
--- a/src/sentry/integrations/github/payload.py
+++ /dev/null
@@ -1,76 +0,0 @@
-from __future__ import absolute_import
-
-import hashlib
-import hmac
-import logging
-import six
-
-from django.http import HttpResponse
-from django.utils.crypto import constant_time_compare
-from django.utils.decorators import method_decorator
-from django.views.decorators.csrf import csrf_exempt
-from simplejson import JSONDecodeError
-from sentry import options
-
-from sentry.utils import json
-from sentry.api.base import Endpoint
-
-logger = logging.getLogger('sentry.integrations.github')
-
-
-class GitHubAppsEndpoint(Endpoint):
-    authentication_classes = ()
-    permission_classes = ()
-
-    @method_decorator(csrf_exempt)
-    def dispatch(self, request, *args, **kwargs):
-        return super(GitHubAppsEndpoint, self).dispatch(request, *args, **kwargs)
-
-    def get_secret(self):
-        return options.get('github-app.webhook-secret')
-
-    def is_valid_signature(self, method, body, secret, signature):
-        if method != 'sha1':
-            raise NotImplementedError('signature method %s is not supported' % (method, ))
-
-        mod = hashlib.sha1
-        expected = hmac.new(
-            key=secret.encode('utf-8'),
-            msg=body,
-            digestmod=mod,
-        ).hexdigest()
-        return constant_time_compare(expected, signature)
-
-    def post(self, request, *kwargs):
-
-        secret = self.get_secret()
-
-        if secret is None:
-            logger.error('github.webhook.missing-secret',)
-            return HttpResponse(status=401)
-
-        body = six.binary_type(request.body)
-        if not body:
-            logger.error('github.webhook.missing-body',)
-            return HttpResponse(status=400)
-
-        try:
-            method, signature = request.META['HTTP_X_HUB_SIGNATURE'].split('=', 1)
-        except (KeyError, IndexError):
-            logger.error('github.webhook.missing-signature',)
-            return HttpResponse(status=400)
-
-        if not self.is_valid_signature(method, body, self.get_secret(), signature):
-            logger.error('github.webhook.invalid-signature',)
-            return HttpResponse(status=401)
-
-        try:
-            json.loads(body.decode('utf-8'))
-        except JSONDecodeError:
-            logger.error(
-                'github.webhook.invalid-json',
-                exc_info=True,
-            )
-            return HttpResponse(status=400)
-
-        return HttpResponse(status=200)
diff --git a/src/sentry/integrations/github/urls.py b/src/sentry/integrations/github/urls.py
index 5adb88abc0..b51cbae85e 100644
--- a/src/sentry/integrations/github/urls.py
+++ b/src/sentry/integrations/github/urls.py
@@ -2,13 +2,9 @@ from __future__ import absolute_import, print_function
 
 from django.conf.urls import patterns, url
 
-from .webhook import GithubIntegrationsWebhookEndpoint
-
-from .payload import GitHubAppsEndpoint
+from .webhook import GitHubIntegrationsWebhookEndpoint
 
 urlpatterns = patterns(
     '',
-    url(r'^webhook/$', GithubIntegrationsWebhookEndpoint.as_view()),
-
-    url(r'^payload/$', GitHubAppsEndpoint.as_view()),
+    url(r'^webhook/$', GitHubIntegrationsWebhookEndpoint.as_view()),
 )
diff --git a/src/sentry/integrations/github/webhook.py b/src/sentry/integrations/github/webhook.py
index 79bc4a437f..af3375020a 100644
--- a/src/sentry/integrations/github/webhook.py
+++ b/src/sentry/integrations/github/webhook.py
@@ -18,8 +18,8 @@ from simplejson import JSONDecodeError
 from sentry import options
 from sentry.constants import ObjectStatus
 from sentry.models import (
-    Commit, CommitAuthor, CommitFileChange, Integration, PullRequest,
-    Repository, User
+    Commit, CommitAuthor, CommitFileChange, Identity, Integration, PullRequest,
+    Repository
 )
 from sentry.utils import json
 
@@ -30,22 +30,17 @@ from .client import GitHubAppsClient
 logger = logging.getLogger('sentry.webhooks')
 
 
-def is_anonymous_email(email):
-    return email[-25:] == '@users.noreply.github.com'
-
-
-def get_external_id(username):
-    return 'github:%s' % username
-
-
 class Webhook(object):
+    provider = 'github'
+    repo_provider = 'github'
+
     def _handle(self, event, organization, repo):
         raise NotImplementedError
 
     def __call__(self, event):
         integration = Integration.objects.get(
             external_id=event['installation']['id'],
-            provider='github',
+            provider=self.provider,
         )
 
         if 'repository' in event:
@@ -57,7 +52,7 @@ class Webhook(object):
 
             repos = Repository.objects.filter(
                 organization_id__in=orgs.keys(),
-                provider='integrations:github',
+                provider='integrations:%s' % self.repo_provider,
                 external_id=six.text_type(event['repository']['id']),
             )
             for repo in repos:
@@ -77,7 +72,7 @@ class InstallationEventWebhook(Webhook):
         if installation and event['action'] == 'deleted':
             integration = Integration.objects.get(
                 external_id=installation['id'],
-                provider='github',
+                provider=self.provider,
             )
             self._handle_delete(event, integration)
 
@@ -88,7 +83,7 @@ class InstallationEventWebhook(Webhook):
 
         Repository.objects.filter(
             organization_id__in=organizations.values_list('id', flat=True),
-            provider='integrations:github',
+            provider='integrations:%s' % self.repo_provider,
             integration_id=integration.id,
         ).update(status=ObjectStatus.DISABLED)
 
@@ -101,17 +96,30 @@ class InstallationRepositoryEventWebhook(Webhook):
 
 class PushEventWebhook(Webhook):
     # https://developer.github.com/v3/activity/events/types/#pushevent
+    def is_anonymous_email(self, email):
+        return email[-25:] == '@users.noreply.github.com'
+
+    def get_external_id(self, username):
+        return 'github:%s' % username
+
+    def get_client(self, event):
+        return GitHubAppsClient(event['installation']['id'])
+
+    def should_ignore_commit(self, commit):
+        return GitHubRepositoryProvider.should_ignore_commit(commit['message'])
 
     def _handle(self, event, organization, repo):
         authors = {}
-        client = GitHubAppsClient(event['installation']['id'])
+        client = self.get_client(event)
+        if client is None:
+            return HttpResponse(status=400)
         gh_username_cache = {}
 
         for commit in event['commits']:
             if not commit['distinct']:
                 continue
 
-            if GitHubRepositoryProvider.should_ignore_commit(commit['message']):
+            if self.should_ignore_commit(commit):
                 continue
 
             author_email = commit['author']['email']
@@ -120,11 +128,11 @@ class PushEventWebhook(Webhook):
                     author_email[:65],
                 )
             # try to figure out who anonymous emails are
-            elif is_anonymous_email(author_email):
+            elif self.is_anonymous_email(author_email):
                 gh_username = commit['author'].get('username')
                 # bot users don't have usernames
                 if gh_username:
-                    external_id = get_external_id(gh_username)
+                    external_id = self.get_external_id(gh_username)
                     if gh_username in gh_username_cache:
                         author_email = gh_username_cache[gh_username] or author_email
                     else:
@@ -136,14 +144,14 @@ class PushEventWebhook(Webhook):
                         except CommitAuthor.DoesNotExist:
                             commit_author = None
 
-                        if commit_author is not None and not is_anonymous_email(
+                        if commit_author is not None and not self.is_anonymous_email(
                             commit_author.email
                         ):
                             author_email = commit_author.email
                             gh_username_cache[gh_username] = author_email
                         else:
                             try:
-                                gh_user = client.get('/users/%s' % gh_username)
+                                gh_user = client.get_user(gh_username)
                             except ApiError as exc:
                                 logger.exception(six.text_type(exc))
                             else:
@@ -151,15 +159,12 @@ class PushEventWebhook(Webhook):
                                 # don't re-query
                                 gh_username_cache[gh_username] = None
                                 try:
-                                    user = User.objects.filter(
-                                        social_auth__provider='github',
-                                        social_auth__uid=gh_user['id'],
-                                        org_memberships=organization,
-                                    )[0]
-                                except IndexError:
+                                    identity = Identity.objects.get(
+                                        external_id=gh_user['id'], idp__type=self.provider)
+                                except Identity.DoesNotExist:
                                     pass
                                 else:
-                                    author_email = user.email
+                                    author_email = identity.user.email
                                     gh_username_cache[gh_username] = author_email
                                     if commit_author is not None:
                                         try:
@@ -194,8 +199,9 @@ class PushEventWebhook(Webhook):
 
                 gh_username = commit['author'].get('username')
                 if gh_username:
-                    external_id = get_external_id(gh_username)
-                    if author.external_id != external_id and not is_anonymous_email(author.email):
+                    external_id = self.get_external_id(gh_username)
+                    if author.external_id != external_id and not self.is_anonymous_email(
+                            author.email):
                         update_kwargs['external_id'] = external_id
 
                 if update_kwargs:
@@ -246,6 +252,11 @@ class PushEventWebhook(Webhook):
 
 class PullRequestEventWebhook(Webhook):
     # https://developer.github.com/v3/activity/events/types/#pullrequestevent
+    def is_anonymous_email(self, email):
+        return email[-25:] == '@users.noreply.github.com'
+
+    def get_external_id(self, username):
+        return 'github:%s' % username
 
     def _handle(self, event, organization, repo):
         pull_request = event['pull_request']
@@ -264,26 +275,22 @@ class PullRequestEventWebhook(Webhook):
         author_email = u'{}@localhost'.format(user['login'][:65])
         try:
             commit_author = CommitAuthor.objects.get(
-                external_id=get_external_id(user['login']),
+                external_id=self.get_external_id(user['login']),
                 organization_id=organization.id,
             )
             author_email = commit_author.email
         except CommitAuthor.DoesNotExist:
             try:
-                user_model = User.objects.filter(
-                    social_auth__provider='github',
-                    social_auth__uid=user['id'],
-                    org_memberships=organization,
-                )[0]
-            except IndexError:
+                identity = Identity.objects.get(external_id=user['id'], idp__type=self.provider)
+            except Identity.DoesNotExist:
                 pass
             else:
-                author_email = user_model.email
+                author_email = identity.user.email
 
         try:
             author = CommitAuthor.objects.get(
                 organization_id=organization.id,
-                external_id=get_external_id(user['login']),
+                external_id=self.get_external_id(user['login']),
             )
         except CommitAuthor.DoesNotExist:
             try:
@@ -295,7 +302,7 @@ class PullRequestEventWebhook(Webhook):
                 author = CommitAuthor.objects.create(
                     organization_id=organization.id,
                     email=author_email,
-                    external_id=get_external_id(user['login']),
+                    external_id=self.get_external_id(user['login']),
                     name=user['login'][:128]
                 )
 
@@ -315,7 +322,7 @@ class PullRequestEventWebhook(Webhook):
             pass
 
 
-class GithubWebhookBase(View):
+class GitHubWebhookBase(View):
     # https://developer.github.com/webhooks/
     def get_handler(self, event_type):
         return self._handlers.get(event_type)
@@ -337,7 +344,7 @@ class GithubWebhookBase(View):
         if request.method != 'POST':
             return HttpResponse(status=405)
 
-        return super(GithubWebhookBase, self).dispatch(request, *args, **kwargs)
+        return super(GitHubWebhookBase, self).dispatch(request, *args, **kwargs)
 
     def get_logging_data(self):
         pass
@@ -405,7 +412,7 @@ class GithubWebhookBase(View):
         return HttpResponse(status=204)
 
 
-class GithubIntegrationsWebhookEndpoint(GithubWebhookBase):
+class GitHubIntegrationsWebhookEndpoint(GitHubWebhookBase):
     _handlers = {
         'push': PushEventWebhook,
         'pull_request': PullRequestEventWebhook,
@@ -418,7 +425,7 @@ class GithubIntegrationsWebhookEndpoint(GithubWebhookBase):
         if request.method != 'POST':
             return HttpResponse(status=405)
 
-        return super(GithubIntegrationsWebhookEndpoint, self).dispatch(request, *args, **kwargs)
+        return super(GitHubIntegrationsWebhookEndpoint, self).dispatch(request, *args, **kwargs)
 
     def get_secret(self):
         return options.get('github-app.webhook-secret')
diff --git a/src/sentry/integrations/github_enterprise/payload.py b/src/sentry/integrations/github_enterprise/payload.py
deleted file mode 100644
index 4067f635b5..0000000000
--- a/src/sentry/integrations/github_enterprise/payload.py
+++ /dev/null
@@ -1,76 +0,0 @@
-from __future__ import absolute_import
-
-import hashlib
-import hmac
-import logging
-import six
-
-from django.http import HttpResponse
-from django.utils.crypto import constant_time_compare
-from django.utils.decorators import method_decorator
-from django.views.decorators.csrf import csrf_exempt
-from simplejson import JSONDecodeError
-from sentry import options
-
-from sentry.utils import json
-from sentry.api.base import Endpoint
-
-logger = logging.getLogger('sentry.integrations.github-enterprise')
-
-
-class GitHubEnterpriseAppsEndpoint(Endpoint):
-    authentication_classes = ()
-    permission_classes = ()
-
-    @method_decorator(csrf_exempt)
-    def dispatch(self, request, *args, **kwargs):
-        return super(GitHubEnterpriseAppsEndpoint, self).dispatch(request, *args, **kwargs)
-
-    def get_secret(self):
-        # todo(maxbittker)
-        return options.get('github-enterprise-app.webhook-secret')
-
-    def is_valid_signature(self, method, body, secret, signature):
-        if method != 'sha1':
-            raise NotImplementedError('signature method %s is not supported' % (method, ))
-
-        mod = hashlib.sha1
-        expected = hmac.new(
-            key=secret.encode('utf-8'),
-            msg=body,
-            digestmod=mod,
-        ).hexdigest()
-        return constant_time_compare(expected, signature)
-
-    def post(self, request, *kwargs):
-
-        secret = self.get_secret()
-        if secret is None:
-            logger.error('github-enterpise.webhook.missing-secret',)
-            return HttpResponse(status=401)
-
-        body = six.binary_type(request.body)
-        if not body:
-            logger.error('github-enterpise.webhook.missing-body',)
-            return HttpResponse(status=400)
-
-        try:
-            method, signature = request.META['HTTP_X_HUB_SIGNATURE'].split('=', 1)
-        except (KeyError, IndexError):
-            logger.error('github-enterpise.webhook.missing-signature',)
-            return HttpResponse(status=400)
-
-        if not self.is_valid_signature(method, body, self.get_secret(), signature):
-            logger.error('github-enterpise.webhook.invalid-signature',)
-            return HttpResponse(status=401)
-
-        try:
-            json.loads(body.decode('utf-8'))
-        except JSONDecodeError:
-            logger.error(
-                'github-enterpise.webhook.invalid-json',
-                exc_info=True,
-            )
-            return HttpResponse(status=400)
-
-        return HttpResponse(status=200)
diff --git a/src/sentry/integrations/github_enterprise/urls.py b/src/sentry/integrations/github_enterprise/urls.py
index d34f24cd51..5738d042c3 100644
--- a/src/sentry/integrations/github_enterprise/urls.py
+++ b/src/sentry/integrations/github_enterprise/urls.py
@@ -2,10 +2,10 @@ from __future__ import absolute_import, print_function
 
 from django.conf.urls import patterns, url
 
-from .payload import GitHubEnterpriseAppsEndpoint
+from .webhook import GitHubEnterpriseWebhookEndpoint
 
 
 urlpatterns = patterns(
     '',
-    url(r'^payload/$', GitHubEnterpriseAppsEndpoint.as_view()),
+    url(r'^webhook/$', GitHubEnterpriseWebhookEndpoint.as_view()),
 )
diff --git a/src/sentry/integrations/github_enterprise/webhook.py b/src/sentry/integrations/github_enterprise/webhook.py
new file mode 100644
index 0000000000..110df3a641
--- /dev/null
+++ b/src/sentry/integrations/github_enterprise/webhook.py
@@ -0,0 +1,196 @@
+# -*- coding: utf-8 -*-
+from __future__ import absolute_import
+
+import hashlib
+import hmac
+import logging
+import six
+
+from django.http import HttpResponse
+from django.utils.crypto import constant_time_compare
+from django.utils.decorators import method_decorator
+from django.views.decorators.csrf import csrf_exempt
+from django.views.generic import View
+from simplejson import JSONDecodeError
+from sentry.models import Integration
+from sentry.utils import json
+from sentry.integrations.github.webhook import InstallationEventWebhook, InstallationRepositoryEventWebhook, PushEventWebhook, PullRequestEventWebhook
+from .repository import GitHubEnterpriseRepositoryProvider
+from .client import GitHubEnterpriseAppsClient
+
+logger = logging.getLogger('sentry.webhooks')
+
+
+def get_installation_metadata(event):
+    try:
+        integration = Integration.objects.get(
+            external_id=event['installation']['id'],
+            provider='github-enterprise')
+    except Integration.DoesNotExist:
+        return
+    return integration.metadata['installation']
+
+
+class GitHubEnterpriseInstallationEventWebhook(InstallationEventWebhook):
+    provider = 'github-enterprise'
+    repo_provider = 'github_enterprise'
+
+
+class GitHubEnterpriseInstallationRepositoryEventWebhook(InstallationRepositoryEventWebhook):
+    provider = 'github-enterprise'
+    repo_provider = 'github_enterprise'
+
+    # https://developer.github.com/v3/activity/events/types/#installationrepositoriesevent
+    def _handle(self, event, organization, repo):
+        pass
+
+
+class GitHubEnterprisePushEventWebhook(PushEventWebhook):
+    provider = 'github-enterprise'
+    repo_provider = 'github_enterprise'
+
+    # https://developer.github.com/v3/activity/events/types/#pushevent
+    def is_anonymous_email(self, email):
+        return email[-25:] == '@users.noreply.github.com'
+
+    def get_external_id(self, username):
+        return 'github_enterprise:%s' % username
+
+    def get_client(self, event):
+        metadata = get_installation_metadata(event)
+        if metadata is None:
+            return None
+
+        return GitHubEnterpriseAppsClient(
+            metadata['url'],
+            metadata['id'],
+            event['installation']['id'],
+            metadata['private_key'])
+
+    def should_ignore_commit(self, commit):
+        return GitHubEnterpriseRepositoryProvider.should_ignore_commit(commit['message'])
+
+
+class GitHubEnterprisePullRequestEventWebhook(PullRequestEventWebhook):
+    provider = 'github-enterprise'
+    repo_provider = 'github_enterprise'
+
+    # https://developer.github.com/v3/activity/events/types/#pullrequestevent
+    def is_anonymous_email(self, email):
+        return email[-25:] == '@users.noreply.github.com'
+
+    def get_external_id(self, username):
+        return 'github_enterprise:%s' % username
+
+
+class GitHubEnterpriseWebhookBase(View):
+    # https://developer.github.com/webhooks/
+    def get_handler(self, event_type):
+        return self._handlers.get(event_type)
+
+    def is_valid_signature(self, method, body, secret, signature):
+        if method == 'sha1':
+            mod = hashlib.sha1
+        else:
+            raise NotImplementedError('signature method %s is not supported' % (method, ))
+        expected = hmac.new(
+            key=secret.encode('utf-8'),
+            msg=body,
+            digestmod=mod,
+        ).hexdigest()
+        return constant_time_compare(expected, signature)
+
+    @method_decorator(csrf_exempt)
+    def dispatch(self, request, *args, **kwargs):
+        if request.method != 'POST':
+            return HttpResponse(status=405)
+
+        return super(GitHubEnterpriseWebhookBase, self).dispatch(request, *args, **kwargs)
+
+    def get_logging_data(self):
+        pass
+
+    def get_secret(self, event):
+        metadata = get_installation_metadata(event)
+        if metadata:
+            return metadata.get('webhook_secret')
+        else:
+            return None
+
+    def handle(self, request):
+        body = six.binary_type(request.body)
+        if not body:
+            logger.error(
+                'github_enterprise.webhook.missing-body',
+                extra=self.get_logging_data(),
+            )
+            return HttpResponse(status=400)
+
+        try:
+            handler = self.get_handler(request.META['HTTP_X_GITHUB_EVENT'])
+        except KeyError:
+            logger.error(
+                'github_enterprise.webhook.missing-event',
+                extra=self.get_logging_data(),
+            )
+            return HttpResponse(status=400)
+
+        if not handler:
+            return HttpResponse(status=204)
+
+        try:
+            method, signature = request.META['HTTP_X_HUB_SIGNATURE'].split('=', 1)
+        except (KeyError, IndexError):
+            logger.error(
+                'github_enterprise.webhook.missing-signature',
+                extra=self.get_logging_data(),
+            )
+            return HttpResponse(status=400)
+
+        try:
+            event = json.loads(body.decode('utf-8'))
+        except JSONDecodeError:
+            logger.error(
+                'github_enterprise.webhook.invalid-json',
+                extra=self.get_logging_data(),
+                exc_info=True,
+            )
+            return HttpResponse(status=400)
+
+        secret = self.get_secret(event)
+        if secret is None:
+            logger.error(
+                'github_enterprise.webhook.missing-secret',
+                extra=self.get_logging_data(),
+            )
+            return HttpResponse(status=401)
+
+        if not self.is_valid_signature(method, body, self.get_secret(event), signature):
+            logger.error(
+                'github_enterprise.webhook.invalid-signature',
+                extra=self.get_logging_data(),
+            )
+            return HttpResponse(status=401)
+
+        handler()(event)
+        return HttpResponse(status=204)
+
+
+class GitHubEnterpriseWebhookEndpoint(GitHubEnterpriseWebhookBase):
+    _handlers = {
+        'push': GitHubEnterprisePushEventWebhook,
+        'pull_request': GitHubEnterprisePullRequestEventWebhook,
+        'installation': GitHubEnterpriseInstallationEventWebhook,
+        'installation_repositories': GitHubEnterpriseInstallationRepositoryEventWebhook,
+    }
+
+    @method_decorator(csrf_exempt)
+    def dispatch(self, request, *args, **kwargs):
+        if request.method != 'POST':
+            return HttpResponse(status=405)
+
+        return super(GitHubEnterpriseWebhookEndpoint, self).dispatch(request, *args, **kwargs)
+
+    @method_decorator(csrf_exempt)
+    def post(self, request):
+        return self.handle(request)
diff --git a/src/sentry/web/urls.py b/src/sentry/web/urls.py
index bcc85fc5b5..e7f5a33e7e 100644
--- a/src/sentry/web/urls.py
+++ b/src/sentry/web/urls.py
@@ -366,7 +366,9 @@ urlpatterns += patterns(
     url(r'^accept-transfer/$', react_page_view, name='sentry-accept-project-transfer'),
     # User settings use generic_react_page_view, while any view
     # acting on behalf of an organization should use react_page_view
-    url(r'^settings/account/security/$', generic_react_page_view, name='sentry-account-settings-security'),
+    url(r'^settings/account/security/$',
+        generic_react_page_view,
+        name='sentry-account-settings-security'),
     url(r'^settings/account/', generic_react_page_view),
     url(r'^settings/', react_page_view),
     url(
@@ -528,6 +530,7 @@ urlpatterns += patterns(
     url(r'^extensions/jira/', include('sentry.integrations.jira.urls')),
     url(r'^extensions/slack/', include('sentry.integrations.slack.urls')),
     url(r'^extensions/github/', include('sentry.integrations.github.urls')),
+    url(r'^extensions/github-enterprise/', include('sentry.integrations.github_enterprise.urls')),
     url(r'^extensions/vsts/', include('sentry.integrations.vsts.urls')),
     url(r'^extensions/bitbucket/', include('sentry.integrations.bitbucket.urls')),
 
diff --git a/tests/sentry/integrations/github_enterprise/test_webhooks.py b/tests/sentry/integrations/github_enterprise/test_webhooks.py
new file mode 100644
index 0000000000..73a8d8e604
--- /dev/null
+++ b/tests/sentry/integrations/github_enterprise/test_webhooks.py
@@ -0,0 +1,428 @@
+# -*- coding: utf-8 -*-
+from __future__ import absolute_import
+
+import six
+
+from datetime import datetime
+from django.utils import timezone
+from sentry.models import (
+    Commit,
+    CommitAuthor,
+    Integration,
+    PullRequest,
+    Repository)
+from sentry.testutils import APITestCase
+from uuid import uuid4
+
+from sentry.integrations.github.testutils import (
+    PUSH_EVENT_EXAMPLE_INSTALLATION, PULL_REQUEST_OPENED_EVENT_EXAMPLE,
+    PULL_REQUEST_EDITED_EVENT_EXAMPLE, PULL_REQUEST_CLOSED_EVENT_EXAMPLE
+)
+
+from mock import patch
+
+
+class WebhookTest(APITestCase):
+    def test_get(self):
+
+        url = '/extensions/github-enterprise/webhook/'
+
+        response = self.client.get(url)
+
+        assert response.status_code == 405
+
+    def test_unregistered_event(self):
+        project = self.project  # force creation
+        url = '/extensions/github-enterprise/webhook/'.format(
+            project.organization.id,
+        )
+
+        response = self.client.post(
+            path=url,
+            data=PUSH_EVENT_EXAMPLE_INSTALLATION,
+            content_type='application/json',
+            HTTP_X_GITHUB_EVENT='UnregisteredEvent',
+            HTTP_X_HUB_SIGNATURE='sha1=56a3df597e02adbc17fb617502c70e19d96a6136',
+            HTTP_X_GITHUB_DELIVERY=six.text_type(uuid4())
+        )
+
+        assert response.status_code == 204
+
+    def test_invalid_signature_event(self):
+
+        url = '/extensions/github-enterprise/webhook/'
+
+        response = self.client.post(
+            path=url,
+            data=PUSH_EVENT_EXAMPLE_INSTALLATION,
+            content_type='application/json',
+            HTTP_X_GITHUB_EVENT='push',
+            HTTP_X_HUB_SIGNATURE='sha1=33521abeaaf9a57c2abf486e0ccd54d23cf36fec',
+            HTTP_X_GITHUB_DELIVERY=six.text_type(uuid4())
+        )
+
+        assert response.status_code == 401
+
+
+class PushEventWebhookTest(APITestCase):
+    @patch('sentry.integrations.github_enterprise.client.get_jwt')
+    @patch('sentry.integrations.github_enterprise.webhook.get_installation_metadata')
+    def test_simple(self, mock_get_installation_metadata, mock_get_jwt):
+        mock_get_jwt.return_value = ""
+
+        project = self.project  # force creation
+
+        url = '/extensions/github-enterprise/webhook/'
+        mock_get_installation_metadata.return_value = {
+            'url': '35.232.149.196',
+            'id': '2',
+            'name': 'test-app',
+            'webhook_secret': 'b3002c3e321d4b7880360d397db2ccfd',
+            'private_key': 'private_key',
+        }
+
+        Repository.objects.create(
+            organization_id=project.organization.id,
+            external_id='35129377',
+            provider='integrations:github_enterprise',
+            name='baxterthehacker/public-repo',
+        )
+        integration = Integration.objects.create(
+            external_id="12345",
+            provider='github-enterprise',
+        )
+        integration.add_organization(project.organization.id)
+
+        response = self.client.post(
+            path=url,
+            data=PUSH_EVENT_EXAMPLE_INSTALLATION,
+            content_type='application/json',
+            HTTP_X_GITHUB_EVENT='push',
+            HTTP_X_HUB_SIGNATURE='sha1=2a0586cc46490b17441834e1e143ec3d8c1fe032',
+            HTTP_X_GITHUB_DELIVERY=six.text_type(uuid4())
+        )
+
+        assert response.status_code == 204
+
+        commit_list = list(
+            Commit.objects.filter(
+                # organization_id=project.organization_id,
+            ).select_related('author').order_by('-date_added')
+        )
+
+        assert len(commit_list) == 2
+
+        commit = commit_list[0]
+
+        assert commit.key == '133d60480286590a610a0eb7352ff6e02b9674c4'
+        assert commit.message == u'Update README.md (àgain)'
+        assert commit.author.name == u'bàxterthehacker'
+        assert commit.author.email == 'baxterthehacker@users.noreply.github.com'
+        assert commit.author.external_id is None
+        assert commit.date_added == datetime(2015, 5, 5, 23, 45, 15, tzinfo=timezone.utc)
+
+        commit = commit_list[1]
+
+        assert commit.key == '0d1a26e67d8f5eaf1f6ba5c57fc3c7d91ac0fd1c'
+        assert commit.message == 'Update README.md'
+        assert commit.author.name == u'bàxterthehacker'
+        assert commit.author.email == 'baxterthehacker@users.noreply.github.com'
+        assert commit.author.external_id is None
+        assert commit.date_added == datetime(2015, 5, 5, 23, 40, 15, tzinfo=timezone.utc)
+
+    @patch('sentry.integrations.github_enterprise.webhook.get_installation_metadata')
+    def test_anonymous_lookup(self, mock_get_installation_metadata):
+        project = self.project  # force creation
+
+        url = '/extensions/github-enterprise/webhook/'
+        mock_get_installation_metadata.return_value = {
+            'url': '35.232.149.196',
+            'id': '2',
+            'name': 'test-app',
+            'webhook_secret': 'b3002c3e321d4b7880360d397db2ccfd',
+            'private_key': 'private_key',
+        }
+
+        integration = Integration.objects.create(
+            provider='github-enterprise',
+            external_id='12345',
+            name='octocat',
+        )
+        integration.add_organization(project.organization.id)
+
+        Repository.objects.create(
+            organization_id=project.organization.id,
+            external_id='35129377',
+            provider='integrations:github_enterprise',
+            name='baxterthehacker/public-repo',
+        )
+
+        CommitAuthor.objects.create(
+            external_id='github_enterprise:baxterthehacker',
+            organization_id=project.organization_id,
+            email='baxterthehacker@example.com',
+            name=u'bàxterthehacker',
+        )
+
+        response = self.client.post(
+            path=url,
+            data=PUSH_EVENT_EXAMPLE_INSTALLATION,
+            content_type='application/json',
+            HTTP_X_GITHUB_EVENT='push',
+            HTTP_X_HUB_SIGNATURE='sha1=2a0586cc46490b17441834e1e143ec3d8c1fe032',
+            HTTP_X_GITHUB_DELIVERY=six.text_type(uuid4())
+        )
+
+        assert response.status_code == 204
+
+        commit_list = list(
+            Commit.objects.filter(
+                organization_id=project.organization_id,
+            ).select_related('author').order_by('-date_added')
+        )
+
+        # should be skipping the #skipsentry commit
+        assert len(commit_list) == 2
+
+        commit = commit_list[0]
+
+        assert commit.key == '133d60480286590a610a0eb7352ff6e02b9674c4'
+        assert commit.message == u'Update README.md (àgain)'
+        assert commit.author.name == u'bàxterthehacker'
+        assert commit.author.email == 'baxterthehacker@example.com'
+        assert commit.date_added == datetime(2015, 5, 5, 23, 45, 15, tzinfo=timezone.utc)
+
+        commit = commit_list[1]
+
+        assert commit.key == '0d1a26e67d8f5eaf1f6ba5c57fc3c7d91ac0fd1c'
+        assert commit.message == 'Update README.md'
+        assert commit.author.name == u'bàxterthehacker'
+        assert commit.author.email == 'baxterthehacker@example.com'
+        assert commit.date_added == datetime(2015, 5, 5, 23, 40, 15, tzinfo=timezone.utc)
+
+    @patch('sentry.integrations.github_enterprise.client.get_jwt')
+    @patch('sentry.integrations.github_enterprise.webhook.get_installation_metadata')
+    def test_multiple_orgs(self, mock_get_installation_metadata, mock_get_jwt):
+        mock_get_jwt.return_value = ""
+
+        project = self.project  # force creation
+
+        url = '/extensions/github-enterprise/webhook/'
+        mock_get_installation_metadata.return_value = {
+            'url': '35.232.149.196',
+            'id': '2',
+            'name': 'test-app',
+            'webhook_secret': 'b3002c3e321d4b7880360d397db2ccfd',
+            'private_key': 'private_key',
+        }
+
+        Repository.objects.create(
+            organization_id=project.organization.id,
+            external_id='35129377',
+            provider='integrations:github_enterprise',
+            name='baxterthehacker/public-repo',
+        )
+        integration = Integration.objects.create(
+            external_id="12345",
+            provider='github-enterprise',
+        )
+        integration.add_organization(project.organization.id)
+
+        org2 = self.create_organization()
+        project2 = self.create_project(organization=org2, name='bar')
+
+        Repository.objects.create(
+            organization_id=project2.organization.id,
+            external_id='77',
+            provider='integrations:github_enterprise',
+            name='another/repo',
+        )
+        integration = Integration.objects.create(
+            external_id="99",
+            provider='github-enterprise',
+        )
+        integration.add_organization(org2.id)
+
+        response = self.client.post(
+            path=url,
+            data=PUSH_EVENT_EXAMPLE_INSTALLATION,
+            content_type='application/json',
+            HTTP_X_GITHUB_EVENT='push',
+            HTTP_X_HUB_SIGNATURE='sha1=2a0586cc46490b17441834e1e143ec3d8c1fe032',
+            HTTP_X_GITHUB_DELIVERY=six.text_type(uuid4())
+        )
+
+        assert response.status_code == 204
+
+        commit_list = list(
+            Commit.objects.filter(
+                organization_id=project.organization_id,
+            ).select_related('author').order_by('-date_added')
+        )
+
+        assert len(commit_list) == 2
+
+        commit_list = list(
+            Commit.objects.filter(
+                organization_id=org2.id,
+            ).select_related('author').order_by('-date_added')
+        )
+        assert len(commit_list) == 0
+
+
+class PullRequestEventWebhook(APITestCase):
+    @patch('sentry.integrations.github_enterprise.webhook.get_installation_metadata')
+    def test_opened(self, mock_get_installation_metadata):
+        project = self.project  # force creation
+
+        url = '/extensions/github-enterprise/webhook/'
+        mock_get_installation_metadata.return_value = {
+            'url': '35.232.149.196',
+            'id': '2',
+            'name': 'test-app',
+            'webhook_secret': 'b3002c3e321d4b7880360d397db2ccfd',
+            'private_key': 'private_key',
+        }
+
+        integration = Integration.objects.create(
+            provider='github-enterprise',
+            external_id='234',
+            name='octocat',
+        )
+        integration.add_organization(project.organization.id)
+
+        repo = Repository.objects.create(
+            organization_id=project.organization.id,
+            external_id='35129377',
+            provider='integrations:github_enterprise',
+            name='baxterthehacker/public-repo',
+        )
+
+        response = self.client.post(
+            path=url,
+            data=PULL_REQUEST_OPENED_EVENT_EXAMPLE,
+            content_type='application/json',
+            HTTP_X_GITHUB_EVENT='pull_request',
+            HTTP_X_HUB_SIGNATURE='sha1=aa5b11bc52b9fac082cb59f9ee8667cb222c3aff',
+            HTTP_X_GITHUB_DELIVERY=six.text_type(uuid4())
+        )
+
+        assert response.status_code == 204
+
+        prs = PullRequest.objects.filter(
+            repository_id=repo.id,
+            organization_id=project.organization.id,
+        )
+
+        assert len(prs) == 1
+
+        pr = prs[0]
+
+        assert pr.key == '1'
+        assert pr.message == u'This is a pretty simple change that we need to pull into master.'
+        assert pr.title == u'Update the README with new information'
+        assert pr.author.name == u'baxterthehacker'
+
+    @patch('sentry.integrations.github_enterprise.webhook.get_installation_metadata')
+    def test_edited(self, mock_get_installation_metadata):
+        project = self.project  # force creation
+
+        url = '/extensions/github-enterprise/webhook/'
+        mock_get_installation_metadata.return_value = {
+            'url': '35.232.149.196',
+            'id': '2',
+            'name': 'test-app',
+            'webhook_secret': 'b3002c3e321d4b7880360d397db2ccfd',
+            'private_key': 'private_key',
+        }
+
+        integration = Integration.objects.create(
+            provider='github-enterprise',
+            external_id='234',
+            name='octocat',
+        )
+        integration.add_organization(project.organization.id)
+
+        repo = Repository.objects.create(
+            organization_id=project.organization.id,
+            external_id='35129377',
+            provider='integrations:github_enterprise',
+            name='baxterthehacker/public-repo',
+        )
+
+        pr = PullRequest.objects.create(
+            key='1',
+            repository_id=repo.id,
+            organization_id=project.organization.id,
+        )
+
+        response = self.client.post(
+            path=url,
+            data=PULL_REQUEST_EDITED_EVENT_EXAMPLE,
+            content_type='application/json',
+            HTTP_X_GITHUB_EVENT='pull_request',
+            HTTP_X_HUB_SIGNATURE='sha1=b50a13afd33b514e8e62e603827ea62530f0690e',
+            HTTP_X_GITHUB_DELIVERY=six.text_type(uuid4())
+        )
+
+        assert response.status_code == 204
+
+        pr = PullRequest.objects.get(id=pr.id)
+
+        assert pr.key == '1'
+        assert pr.message == u'new edited body'
+        assert pr.title == u'new edited title'
+        assert pr.author.name == u'baxterthehacker'
+
+    @patch('sentry.integrations.github_enterprise.webhook.get_installation_metadata')
+    def test_closed(self, mock_get_installation_metadata):
+        project = self.project  # force creation
+
+        url = '/extensions/github-enterprise/webhook/'
+        mock_get_installation_metadata.return_value = {
+            'url': '35.232.149.196',
+            'id': '2',
+            'name': 'test-app',
+            'webhook_secret': 'b3002c3e321d4b7880360d397db2ccfd',
+            'private_key': 'private_key',
+        }
+
+        integration = Integration.objects.create(
+            provider='github-enterprise',
+            external_id='234',
+            name='octocat',
+        )
+        integration.add_organization(project.organization.id)
+
+        repo = Repository.objects.create(
+            organization_id=project.organization.id,
+            external_id='35129377',
+            provider='integrations:github_enterprise',
+            name='baxterthehacker/public-repo',
+        )
+
+        response = self.client.post(
+            path=url,
+            data=PULL_REQUEST_CLOSED_EVENT_EXAMPLE,
+            content_type='application/json',
+            HTTP_X_GITHUB_EVENT='pull_request',
+            HTTP_X_HUB_SIGNATURE='sha1=dff1c803cf1e48c1b9aefe4a17952ea132758806',
+            HTTP_X_GITHUB_DELIVERY=six.text_type(uuid4())
+        )
+
+        assert response.status_code == 204
+
+        prs = PullRequest.objects.filter(
+            repository_id=repo.id,
+            organization_id=project.organization.id,
+        )
+
+        assert len(prs) == 1
+
+        pr = prs[0]
+
+        assert pr.key == '1'
+        assert pr.message == u'new closed body'
+        assert pr.title == u'new closed title'
+        assert pr.author.name == u'baxterthehacker'
+        assert pr.merge_commit_sha == '0d1a26e67d8f5eaf1f6ba5c57fc3c7d91ac0fd1c'

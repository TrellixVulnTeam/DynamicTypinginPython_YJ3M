commit 3b756c43db354194d47419e9d8849708cc070f08
Author: Dan Fuller <dfuller@sentry.io>
Date:   Tue Nov 5 17:54:37 2019 -0800

    feat(api): Create an alert rule action for sending alerts to slack (SEN-961)
    
    This updates our api to allow us to create slack actions. I refactored the slack integration so we
    could re-use the code for fetching channels from slack. Code for sending messages to slack, and for
    getting a list of installed integrations that can be used coming in a separate pr.

diff --git a/src/sentry/incidents/endpoints/organization_alert_rule_trigger_action_details.py b/src/sentry/incidents/endpoints/organization_alert_rule_trigger_action_details.py
index a3c13fb998..8fef9c8409 100644
--- a/src/sentry/incidents/endpoints/organization_alert_rule_trigger_action_details.py
+++ b/src/sentry/incidents/endpoints/organization_alert_rule_trigger_action_details.py
@@ -6,7 +6,7 @@ from rest_framework.response import Response
 from sentry.api.serializers import serialize
 from sentry.incidents.endpoints.bases import OrganizationAlertRuleTriggerActionEndpoint
 from sentry.incidents.endpoints.serializers import AlertRuleTriggerActionSerializer
-from sentry.incidents.logic import delete_alert_rule_trigger_action
+from sentry.incidents.logic import delete_alert_rule_trigger_action, InvalidTriggerActionError
 
 
 class OrganizationAlertRuleTriggerActionDetailsEndpoint(OrganizationAlertRuleTriggerActionEndpoint):
@@ -33,8 +33,13 @@ class OrganizationAlertRuleTriggerActionDetailsEndpoint(OrganizationAlertRuleTri
         )
 
         if serializer.is_valid():
-            trigger = serializer.save()
-            return Response(serialize(trigger, request.user), status=status.HTTP_200_OK)
+            try:
+                alert_rule_trigger_action = serializer.save()
+            except InvalidTriggerActionError as e:
+                return Response(e.message, status=status.HTTP_400_BAD_REQUEST)
+            return Response(
+                serialize(alert_rule_trigger_action, request.user), status=status.HTTP_200_OK
+            )
 
         return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
 
diff --git a/src/sentry/incidents/endpoints/organization_alert_rule_trigger_action_index.py b/src/sentry/incidents/endpoints/organization_alert_rule_trigger_action_index.py
index fdfa04ab2e..478e0359f2 100644
--- a/src/sentry/incidents/endpoints/organization_alert_rule_trigger_action_index.py
+++ b/src/sentry/incidents/endpoints/organization_alert_rule_trigger_action_index.py
@@ -9,7 +9,7 @@ from sentry.api.paginator import OffsetPaginator
 from sentry.api.serializers import serialize
 from sentry.incidents.endpoints.bases import OrganizationAlertRuleTriggerEndpoint
 from sentry.incidents.endpoints.serializers import AlertRuleTriggerActionSerializer
-from sentry.incidents.logic import get_actions_for_trigger
+from sentry.incidents.logic import get_actions_for_trigger, InvalidTriggerActionError
 
 
 class OrganizationAlertRuleTriggerActionIndexEndpoint(OrganizationAlertRuleTriggerEndpoint):
@@ -47,7 +47,10 @@ class OrganizationAlertRuleTriggerActionIndexEndpoint(OrganizationAlertRuleTrigg
         )
 
         if serializer.is_valid():
-            action = serializer.save()
+            try:
+                action = serializer.save()
+            except InvalidTriggerActionError as e:
+                return Response(e.message, status=status.HTTP_400_BAD_REQUEST)
             return Response(serialize(action, request.user), status=status.HTTP_201_CREATED)
 
         return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
diff --git a/src/sentry/incidents/endpoints/serializers.py b/src/sentry/incidents/endpoints/serializers.py
index b02b27bfda..109cc8af6b 100644
--- a/src/sentry/incidents/endpoints/serializers.py
+++ b/src/sentry/incidents/endpoints/serializers.py
@@ -226,8 +226,12 @@ class AlertRuleTriggerActionSerializer(CamelSnakeModelSerializer):
 
     class Meta:
         model = AlertRuleTriggerAction
-        fields = ["type", "target_type", "target_identifier"]
-        extra_kwargs = {"target_identifier": {"required": True}}
+        fields = ["type", "target_type", "target_identifier", "target_display", "integration"]
+        extra_kwargs = {
+            "target_identifier": {"required": True},
+            "target_display": {"required": False},
+            "integration": {"required": False, "allow_null": False},
+        }
 
     def validate_type(self, type):
         try:
@@ -255,27 +259,36 @@ class AlertRuleTriggerActionSerializer(CamelSnakeModelSerializer):
         target_type = attrs.get("target_type")
         access = self.context["access"]
         identifier = attrs.get("target_identifier")
-        if target_type == AlertRuleTriggerAction.TargetType.TEAM:
-            try:
-                team = Team.objects.get(id=identifier)
-            except Team.DoesNotExist:
-                raise serializers.ValidationError("Team does not exist")
-            if not access.has_team(team):
-                raise serializers.ValidationError("Team does not exist")
-        elif target_type == AlertRuleTriggerAction.TargetType.USER:
-            try:
-                user = User.objects.get(id=identifier)
-            except User.DoesNotExist:
-                raise serializers.ValidationError("User does not exist")
-
-            if not OrganizationMember.objects.filter(
-                organization=self.context["organization"], user=user
-            ).exists():
-                raise serializers.ValidationError("User does not belong to this organization")
-        elif target_type == AlertRuleTriggerAction.TargetType.SPECIFIC:
-            # Compare with `type` and perform a specific validation as needed
-            # TODO: Implement these as needed
-            pass
+        if attrs.get("type") == AlertRuleTriggerAction.Type.EMAIL:
+            if target_type == AlertRuleTriggerAction.TargetType.TEAM:
+                try:
+                    team = Team.objects.get(id=identifier)
+                except Team.DoesNotExist:
+                    raise serializers.ValidationError("Team does not exist")
+                if not access.has_team(team):
+                    raise serializers.ValidationError("Team does not exist")
+            elif target_type == AlertRuleTriggerAction.TargetType.USER:
+                try:
+                    user = User.objects.get(id=identifier)
+                except User.DoesNotExist:
+                    raise serializers.ValidationError("User does not exist")
+
+                if not OrganizationMember.objects.filter(
+                    organization=self.context["organization"], user=user
+                ).exists():
+                    raise serializers.ValidationError("User does not belong to this organization")
+            elif target_type == AlertRuleTriggerAction.TargetType.SPECIFIC:
+                # Compare with `type` and perform a specific validation as needed
+                pass
+        elif attrs.get("type") == AlertRuleTriggerAction.Type.SLACK:
+            if target_type != AlertRuleTriggerAction.TargetType.SPECIFIC:
+                raise serializers.ValidationError(
+                    {"target_type": "Must provide a specific channel for slack"}
+                )
+            if "integration" not in attrs:
+                raise serializers.ValidationError(
+                    {"integration": "Integration must be provided for slack"}
+                )
 
         return attrs
 
@@ -283,6 +296,12 @@ class AlertRuleTriggerActionSerializer(CamelSnakeModelSerializer):
         return create_alert_rule_trigger_action(trigger=self.context["trigger"], **validated_data)
 
     def _remove_unchanged_fields(self, instance, validated_data):
+        if validated_data.get("type", instance.type) == AlertRuleTriggerAction.Type.SLACK.value:
+            if (
+                "target_identifier" in validated_data
+                and validated_data["target_identifier"] == instance.target_display
+            ):
+                validated_data.pop("target_identifier")
         for field_name, value in list(six.iteritems(validated_data)):
             # Remove any fields that haven't actually changed
             if isinstance(value, Enum):
diff --git a/src/sentry/incidents/logic.py b/src/sentry/incidents/logic.py
index 29dd5b2b58..abd7bc9073 100644
--- a/src/sentry/incidents/logic.py
+++ b/src/sentry/incidents/logic.py
@@ -12,6 +12,8 @@ from django.utils import timezone
 
 from sentry import analytics
 from sentry.api.event_search import get_filter
+from sentry.models import Commit, Project, Release
+from sentry.incidents import tasks
 from sentry.incidents.models import (
     AlertRule,
     AlertRuleExcludedProjects,
@@ -33,8 +35,6 @@ from sentry.incidents.models import (
     TimeSeriesSnapshot,
 )
 from sentry.snuba.models import QueryAggregations, QueryDatasets
-from sentry.models import Commit, Project, Release
-from sentry.incidents import tasks
 from sentry.snuba.subscriptions import (
     bulk_create_snuba_subscriptions,
     bulk_delete_snuba_subscriptions,
@@ -55,6 +55,10 @@ class AlreadyDeletedError(Exception):
     pass
 
 
+class InvalidTriggerActionError(Exception):
+    pass
+
+
 def create_incident(
     organization,
     type,
@@ -997,7 +1001,7 @@ def get_subscriptions_from_alert_rule(alert_rule, projects):
 
 
 def create_alert_rule_trigger_action(
-    trigger, type, target_type, target_identifier=None, target_display=None, integration=None
+    trigger, type, target_type, target_identifier=None, integration=None
 ):
     """
     Creates an AlertRuleTriggerAction
@@ -1009,6 +1013,28 @@ def create_alert_rule_trigger_action(
     :param integration: (Optional) The Integration related to this action.
     :return: The created action
     """
+    target_display = None
+    if type == AlertRuleTriggerAction.Type.SLACK:
+        from sentry.integrations.slack.utils import get_channel_id
+
+        if target_type != AlertRuleTriggerAction.TargetType.SPECIFIC:
+            raise InvalidTriggerActionError("Slack action must specify channel")
+
+        channel_result = get_channel_id(
+            trigger.alert_rule.organization, integration.id, target_identifier
+        )
+        if channel_result is not None:
+            channel_id = channel_result[1]
+        else:
+            raise InvalidTriggerActionError(
+                "Could not find channel %s. Channel may not exist, or Sentry may not "
+                "have been granted permission to access it" % target_identifier
+            )
+
+        # Use the channel name for display
+        target_display = target_identifier
+        target_identifier = channel_id
+
     return AlertRuleTriggerAction.objects.create(
         alert_rule_trigger=trigger,
         type=type.value,
@@ -1020,12 +1046,7 @@ def create_alert_rule_trigger_action(
 
 
 def update_alert_rule_trigger_action(
-    trigger_action,
-    type=None,
-    target_type=None,
-    target_identifier=None,
-    target_display=None,
-    integration=None,
+    trigger_action, type=None, target_type=None, target_identifier=None, integration=None
 ):
     """
     Updates values on an AlertRuleTriggerAction
@@ -1042,12 +1063,25 @@ def update_alert_rule_trigger_action(
         updated_fields["type"] = type.value
     if target_type is not None:
         updated_fields["target_type"] = target_type.value
-    if target_identifier is not None:
-        updated_fields["target_identifier"] = target_identifier
-    if target_display is not None:
-        updated_fields["target_display"] = target_display
     if integration is not None:
         updated_fields["integration"] = integration
+    if target_identifier is not None:
+        type = updated_fields.get("type", trigger_action.type)
+
+        if type == AlertRuleTriggerAction.Type.SLACK.value:
+            from sentry.integrations.slack.utils import get_channel_id
+
+            integration = updated_fields.get("integration", trigger_action.integration)
+            channel_id = get_channel_id(
+                trigger_action.alert_rule_trigger.alert_rule.organization,
+                integration.id,
+                target_identifier,
+            )[1]
+            # Use the channel name for display
+            updated_fields["target_display"] = target_identifier
+            updated_fields["target_identifier"] = channel_id
+        else:
+            updated_fields["target_identifier"] = target_identifier
 
     trigger_action.update(**updated_fields)
     return trigger_action
diff --git a/src/sentry/integrations/slack/notify_action.py b/src/sentry/integrations/slack/notify_action.py
index aba433466a..d9f8407424 100644
--- a/src/sentry/integrations/slack/notify_action.py
+++ b/src/sentry/integrations/slack/notify_action.py
@@ -8,11 +8,7 @@ from sentry.rules.actions.base import EventAction
 from sentry.utils import metrics, json
 from sentry.models import Integration
 
-from .utils import build_group_attachment
-
-MEMBER_PREFIX = "@"
-CHANNEL_PREFIX = "#"
-strip_channel_chars = "".join([MEMBER_PREFIX, CHANNEL_PREFIX])
+from .utils import build_group_attachment, get_channel_id
 
 
 class SlackNotifyServiceForm(forms.Form):
@@ -38,7 +34,7 @@ class SlackNotifyServiceForm(forms.Form):
         cleaned_data = super(SlackNotifyServiceForm, self).clean()
 
         workspace = cleaned_data.get("workspace")
-        channel = cleaned_data.get("channel", "").lstrip(strip_channel_chars)
+        channel = cleaned_data.get("channel", "")
 
         channel_id = self.channel_transformer(workspace, channel)
 
@@ -149,83 +145,4 @@ class SlackNotifyServiceAction(EventAction):
         )
 
     def get_channel_id(self, integration_id, name):
-        try:
-            integration = Integration.objects.get(
-                provider="slack", organizations=self.project.organization, id=integration_id
-            )
-        except Integration.DoesNotExist:
-            return None
-
-        session = http.build_session()
-
-        token_payload = {"token": integration.metadata["access_token"]}
-
-        # Look for channel ID
-        channels_payload = dict(
-            token_payload, **{"exclude_archived": False, "exclude_members": True}
-        )
-
-        # Slack limits the response of `channels.list` to 1000 channels, paginate if needed
-        cursor = None
-        channels_list_initial = True
-        while cursor or channels_list_initial:
-            channels_list_initial = False
-            channels = session.get(
-                "https://slack.com/api/channels.list",
-                params=dict(channels_payload, **{"cursor": cursor}),
-            )
-            channels = channels.json()
-            if not channels.get("ok"):
-                self.logger.info(
-                    "rule.slack.channel_list_failed", extra={"error": channels.get("error")}
-                )
-                return None
-
-            cursor = channels.get("response_metadata", {}).get("next_cursor", None)
-            channel_id = {c["name"]: c["id"] for c in channels["channels"]}.get(name)
-            if channel_id:
-                return (CHANNEL_PREFIX, channel_id)
-
-        # Channel may be private
-        # Slack limits the response of `groups.list` to 1000 groups, paginate if needed
-        cursor = None
-        groups_list_initial = True
-        while cursor or groups_list_initial:
-            groups_list_initial = False
-            groups = session.get(
-                "https://slack.com/api/groups.list",
-                params=dict(channels_payload, **{"cursor": cursor}),
-            )
-            groups = groups.json()
-            if not groups.get("ok"):
-                self.logger.info(
-                    "rule.slack.group_list_failed", extra={"error": groups.get("error")}
-                )
-                return None
-
-            cursor = groups.get("response_metadata", {}).get("next_cursor", None)
-            group_id = {c["name"]: c["id"] for c in groups["groups"]}.get(name)
-            if group_id:
-                return (CHANNEL_PREFIX, group_id)
-
-        # Channel may actually be a user
-        # Slack limits the response of `users.list` to 1000 users, paginate if needed
-        cursor = None
-        users_list_initial = True
-        while cursor or users_list_initial:
-            users_list_initial = False
-            users = session.get(
-                "https://slack.com/api/users.list",
-                params=dict(channels_payload, **{"cursor": cursor}),
-            )
-            users = users.json()
-            if not users.get("ok"):
-                self.logger.info("rule.slack.user_list_failed", extra={"error": users.get("error")})
-                return None
-
-            cursor = users.get("response_metadata", {}).get("next_cursor", None)
-            member_id = {c["name"]: c["id"] for c in users["members"]}.get(name)
-            if member_id:
-                return (CHANNEL_PREFIX, member_id)
-
-        return None
+        return get_channel_id(self.project.organization, integration_id, name)
diff --git a/src/sentry/integrations/slack/utils.py b/src/sentry/integrations/slack/utils.py
index e1f3fc784c..b938dc1a9e 100644
--- a/src/sentry/integrations/slack/utils.py
+++ b/src/sentry/integrations/slack/utils.py
@@ -5,6 +5,7 @@ import logging
 from django.core.cache import cache
 from django.core.urlresolvers import reverse
 
+from sentry import http
 from sentry import tagstore
 from sentry.api.fields.actor import Actor
 from sentry.incidents.logic import get_incident_aggregates
@@ -20,6 +21,7 @@ from sentry.models import (
     Project,
     User,
     Identity,
+    Integration,
     Team,
     ReleaseProject,
 )
@@ -35,6 +37,9 @@ LEVEL_TO_COLOR = {
     "error": "#E03E2F",
     "fatal": "#d20f2a",
 }
+MEMBER_PREFIX = "@"
+CHANNEL_PREFIX = "#"
+strip_channel_chars = "".join([MEMBER_PREFIX, CHANNEL_PREFIX])
 
 
 def format_actor_option(actor):
@@ -308,3 +313,56 @@ def build_incident_attachment(incident):
         "color": LEVEL_TO_COLOR["error"],
         "actions": [],
     }
+
+
+# Different list types in slack that we'll use to resolve a channel name. Format is
+# (<list_name>, <result_name>, <prefix>).
+LIST_TYPES = [
+    ("channels", "channels", CHANNEL_PREFIX),
+    ("groups", "groups", CHANNEL_PREFIX),
+    ("users", "members", MEMBER_PREFIX),
+]
+
+
+def get_channel_id(organization, integration_id, name):
+    """
+    Fetches the internal slack id of a channel.
+    :param organization: The organization that is using this integration
+    :param integration_id: The integration id of this slack integration
+    :param name: The name of the channel
+    :return:
+    """
+    name = name.lstrip(strip_channel_chars)
+    try:
+        integration = Integration.objects.get(
+            provider="slack", organizations=organization, id=integration_id
+        )
+    except Integration.DoesNotExist:
+        return None
+
+    token_payload = {"token": integration.metadata["access_token"]}
+
+    # Look for channel ID
+    payload = dict(token_payload, **{"exclude_archived": False, "exclude_members": True})
+
+    session = http.build_session()
+    for list_type, result_name, prefix in LIST_TYPES:
+        # Slack limits the response of `<list_type>.list` to 1000 channels, paginate if
+        # needed
+        cursor = ""
+        while cursor is not None:
+            items = session.get(
+                "https://slack.com/api/%s.list" % list_type,
+                params=dict(payload, **{"cursor": cursor}),
+            )
+            items = items.json()
+            if not items.get("ok"):
+                logger.info(
+                    "rule.slack.%s_list_failed" % list_type, extra={"error": items.get("error")}
+                )
+                return None
+
+            cursor = items.get("response_metadata", {}).get("next_cursor", None)
+            item_id = {c["name"]: c["id"] for c in items[result_name]}.get(name)
+            if item_id:
+                return prefix, item_id
diff --git a/src/sentry/testutils/factories.py b/src/sentry/testutils/factories.py
index 29ffd0ee30..0cb91c85f9 100644
--- a/src/sentry/testutils/factories.py
+++ b/src/sentry/testutils/factories.py
@@ -959,9 +959,8 @@ class Factories(object):
         type=AlertRuleTriggerAction.Type.EMAIL,
         target_type=AlertRuleTriggerAction.TargetType.USER,
         target_identifier=None,
-        target_display=None,
         integration=None,
     ):
         return create_alert_rule_trigger_action(
-            trigger, type, target_type, target_identifier, target_display, integration
+            trigger, type, target_type, target_identifier, integration
         )
diff --git a/tests/sentry/incidents/endpoints/test_serializers.py b/tests/sentry/incidents/endpoints/test_serializers.py
index e5a43eda52..cc5e0e2557 100644
--- a/tests/sentry/incidents/endpoints/test_serializers.py
+++ b/tests/sentry/incidents/endpoints/test_serializers.py
@@ -13,8 +13,10 @@ from sentry.incidents.logic import (
     create_alert_rule,
     create_alert_rule_trigger,
     create_alert_rule_trigger_action,
+    InvalidTriggerActionError,
 )
 from sentry.incidents.models import AlertRuleThresholdType, AlertRuleTriggerAction
+from sentry.models import Integration
 from sentry.snuba.models import QueryAggregations
 from sentry.testutils import TestCase
 
@@ -367,10 +369,17 @@ class TestAlertRuleTriggerActionSerializer(TestCase):
         )
 
         self._run_changed_fields_test(action, {"type": type.value}, {})
+        integration = Integration.objects.create(external_id="1", provider="slack", metadata={})
+
         self._run_changed_fields_test(
             action,
-            {"type": AlertRuleTriggerAction.Type.SLACK.value},
-            {"type": AlertRuleTriggerAction.Type.SLACK},
+            {
+                "type": AlertRuleTriggerAction.Type.SLACK.value,
+                "targetIdentifier": "hello",
+                "targetType": AlertRuleTriggerAction.TargetType.SPECIFIC.value,
+                "integration": integration.id,
+            },
+            {"type": AlertRuleTriggerAction.Type.SLACK, "integration": integration},
         )
         self._run_changed_fields_test(
             action, {"target_type": target_type.value, "target_identifier": identifier}, {}
@@ -403,3 +412,41 @@ class TestAlertRuleTriggerActionSerializer(TestCase):
             },
             {"nonFieldErrors": ["User does not belong to this organization"]},
         )
+
+    def test_slack(self):
+        self.run_fail_validation_test(
+            {
+                "type": AlertRuleTriggerAction.Type.SLACK.value,
+                "target_type": AlertRuleTriggerAction.TargetType.USER.value,
+                "target_identifier": "123",
+            },
+            {"targetType": ["Must provide a specific channel for slack"]},
+        )
+        self.run_fail_validation_test(
+            {
+                "type": AlertRuleTriggerAction.Type.SLACK.value,
+                "targetType": AlertRuleTriggerAction.TargetType.SPECIFIC.value,
+                "targetIdentifier": "123",
+            },
+            {"integration": ["Integration must be provided for slack"]},
+        )
+        integration = Integration.objects.create(
+            external_id="1",
+            provider="slack",
+            metadata={"access_token": "xoxp-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx"},
+        )
+        integration.add_organization(self.organization, self.user)
+
+        base_params = self.valid_params.copy()
+        base_params.update(
+            {
+                "type": AlertRuleTriggerAction.Type.SLACK.value,
+                "targetType": AlertRuleTriggerAction.TargetType.SPECIFIC.value,
+                "targetIdentifier": "123",
+                "integration": six.text_type(integration.id),
+            }
+        )
+        serializer = AlertRuleTriggerActionSerializer(context=self.context, data=base_params)
+        assert serializer.is_valid()
+        with self.assertRaises(InvalidTriggerActionError):
+            serializer.save()
diff --git a/tests/sentry/incidents/test_logic.py b/tests/sentry/incidents/test_logic.py
index d436d84987..19addf6274 100644
--- a/tests/sentry/incidents/test_logic.py
+++ b/tests/sentry/incidents/test_logic.py
@@ -1,11 +1,13 @@
 from __future__ import absolute_import
 
+import json
+from uuid import uuid4
+
+import responses
 from datetime import timedelta
 from exam import fixture, patcher
 from freezegun import freeze_time
 
-from uuid import uuid4
-
 import six
 from django.utils import timezone
 from django.utils.functional import cached_property
@@ -73,6 +75,7 @@ from sentry.incidents.models import (
 )
 from sentry.snuba.models import QueryAggregations, QueryDatasets, QuerySubscription
 from sentry.models.commit import Commit
+from sentry.models.integration import Integration
 from sentry.models.repository import Repository
 from sentry.testutils import TestCase, SnubaTestCase
 from sentry.testutils.helpers.datetime import iso_format, before_now
@@ -1280,19 +1283,45 @@ class CreateAlertRuleTriggerAction(BaseAlertRuleTriggerActionTest, TestCase):
         type = AlertRuleTriggerAction.Type.EMAIL
         target_type = AlertRuleTriggerAction.TargetType.USER
         target_identifier = six.text_type(self.user.id)
-        target_display = "hello"
         action = create_alert_rule_trigger_action(
-            self.trigger,
-            type,
-            target_type,
-            target_identifier=target_identifier,
-            target_display=target_display,
+            self.trigger, type, target_type, target_identifier=target_identifier
         )
         assert action.alert_rule_trigger == self.trigger
         assert action.type == type.value
         assert action.target_type == target_type.value
         assert action.target_identifier == target_identifier
-        assert action.target_display == target_display
+
+    @responses.activate
+    def test_slack(self):
+        integration = Integration.objects.create(
+            external_id="1",
+            provider="slack",
+            metadata={"access_token": "xoxp-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx"},
+        )
+        integration.add_organization(self.organization, self.user)
+        type = AlertRuleTriggerAction.Type.SLACK
+        target_type = AlertRuleTriggerAction.TargetType.SPECIFIC
+        channel_name = "#some_channel"
+        channel_id = "s_c"
+        responses.add(
+            method=responses.GET,
+            url="https://slack.com/api/channels.list",
+            status=200,
+            content_type="application/json",
+            body=json.dumps(
+                {"ok": "true", "channels": [{"name": channel_name[1:], "id": channel_id}]}
+            ),
+        )
+
+        action = create_alert_rule_trigger_action(
+            self.trigger, type, target_type, target_identifier=channel_name, integration=integration
+        )
+        assert action.alert_rule_trigger == self.trigger
+        assert action.type == type.value
+        assert action.target_type == target_type.value
+        assert action.target_identifier == channel_id
+        assert action.target_display == channel_name
+        assert action.integration == integration
 
 
 class UpdateAlertRuleTriggerAction(BaseAlertRuleTriggerActionTest, TestCase):
@@ -1303,25 +1332,50 @@ class UpdateAlertRuleTriggerAction(BaseAlertRuleTriggerActionTest, TestCase):
             AlertRuleTriggerAction.Type.EMAIL,
             AlertRuleTriggerAction.TargetType.USER,
             target_identifier=six.text_type(self.user.id),
-            target_display="hello",
         )
 
     def test(self):
-        type = AlertRuleTriggerAction.Type.SLACK
-        target_type = AlertRuleTriggerAction.TargetType.SPECIFIC
-        target_identifier = "#ruhroh"
-        target_display = "Alert Channel"
+        type = AlertRuleTriggerAction.Type.EMAIL
+        target_type = AlertRuleTriggerAction.TargetType.TEAM
+        target_identifier = six.text_type(self.team.id)
         update_alert_rule_trigger_action(
-            self.action,
-            type=type,
-            target_type=target_type,
-            target_identifier=target_identifier,
-            target_display=target_display,
+            self.action, type=type, target_type=target_type, target_identifier=target_identifier
         )
         assert self.action.type == type.value
         assert self.action.target_type == target_type.value
         assert self.action.target_identifier == target_identifier
-        assert self.action.target_display == target_display
+
+    @responses.activate
+    def test_slack(self):
+        integration = Integration.objects.create(
+            external_id="1",
+            provider="slack",
+            metadata={"access_token": "xoxp-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx"},
+        )
+        integration.add_organization(self.organization, self.user)
+        type = AlertRuleTriggerAction.Type.SLACK
+        target_type = AlertRuleTriggerAction.TargetType.SPECIFIC
+        channel_name = "#some_channel"
+        channel_id = "s_c"
+        responses.add(
+            method=responses.GET,
+            url="https://slack.com/api/channels.list",
+            status=200,
+            content_type="application/json",
+            body=json.dumps(
+                {"ok": "true", "channels": [{"name": channel_name[1:], "id": channel_id}]}
+            ),
+        )
+
+        action = update_alert_rule_trigger_action(
+            self.action, type, target_type, target_identifier=channel_name, integration=integration
+        )
+        assert action.alert_rule_trigger == self.trigger
+        assert action.type == type.value
+        assert action.target_type == target_type.value
+        assert action.target_identifier == channel_id
+        assert action.target_display == channel_name
+        assert action.integration == integration
 
 
 class DeleteAlertRuleTriggerAction(BaseAlertRuleTriggerActionTest, TestCase):
@@ -1332,7 +1386,6 @@ class DeleteAlertRuleTriggerAction(BaseAlertRuleTriggerActionTest, TestCase):
             AlertRuleTriggerAction.Type.EMAIL,
             AlertRuleTriggerAction.TargetType.USER,
             target_identifier=six.text_type(self.user.id),
-            target_display="hello",
         )
 
     def test(self):
@@ -1350,6 +1403,5 @@ class GetActionsForTriggerTest(BaseAlertRuleTriggerActionTest, TestCase):
             AlertRuleTriggerAction.Type.EMAIL,
             AlertRuleTriggerAction.TargetType.USER,
             target_identifier=six.text_type(self.user.id),
-            target_display="hello",
         )
         assert list(get_actions_for_trigger(self.trigger)) == [action]
diff --git a/tests/sentry/integrations/slack/test_utils.py b/tests/sentry/integrations/slack/test_utils.py
index 71c778cf19..6964f59016 100644
--- a/tests/sentry/integrations/slack/test_utils.py
+++ b/tests/sentry/integrations/slack/test_utils.py
@@ -1,19 +1,82 @@
 from __future__ import absolute_import
 import six
 
+import responses
 from django.core.urlresolvers import reverse
 
 from sentry.integrations.slack.utils import (
-    build_incident_attachment,
     build_group_attachment,
+    build_incident_attachment,
+    CHANNEL_PREFIX,
+    get_channel_id,
     LEVEL_TO_COLOR,
+    MEMBER_PREFIX,
 )
+from sentry.models import Integration
 from sentry.testutils import TestCase
+from sentry.utils import json
 from sentry.utils.assets import get_asset_url
 from sentry.utils.dates import to_timestamp
 from sentry.utils.http import absolute_uri
 
 
+class GetChannelIdTest(TestCase):
+    def setUp(self):
+        self.resp = responses.mock
+        self.resp.__enter__()
+
+        self.integration = Integration.objects.create(
+            provider="slack",
+            name="Awesome Team",
+            external_id="TXXXXXXX1",
+            metadata={"access_token": "xoxp-xxxxxxxxx-xxxxxxxxxx-xxxxxxxxxxxx"},
+        )
+        self.integration.add_organization(self.event.project.organization, self.user)
+        self.add_list_response(
+            "channels",
+            [{"name": "my-channel", "id": "m-c"}, {"name": "other-chann", "id": "o-c"}],
+            result_name="channels",
+        )
+        self.add_list_response(
+            "groups", [{"name": "my-private-channel", "id": "m-p-c"}], result_name="groups"
+        )
+        self.add_list_response(
+            "users",
+            [{"name": "morty", "id": "m"}, {"name": "other-user", "id": "o-u"}],
+            result_name="members",
+        )
+
+    def tearDown(self):
+        self.resp.__exit__(None, None, None)
+
+    def add_list_response(self, list_type, channels, result_name="channels"):
+        self.resp.add(
+            method=responses.GET,
+            url="https://slack.com/api/%s.list" % list_type,
+            status=200,
+            content_type="application/json",
+            body=json.dumps({"ok": "true", result_name: channels}),
+        )
+
+    def run_valid_test(self, channel, expected_prefix, expected_id):
+        assert (expected_prefix, expected_id) == get_channel_id(
+            self.organization, self.integration.id, channel
+        )
+
+    def test_valid_channel_selected(self):
+        self.run_valid_test("#my-channel", CHANNEL_PREFIX, "m-c")
+
+    def test_valid_private_channel_selected(self):
+        self.run_valid_test("#my-private-channel", CHANNEL_PREFIX, "m-p-c")
+
+    def test_valid_member_selected(self):
+        self.run_valid_test("@morty", MEMBER_PREFIX, "m")
+
+    def test_invalid_channel_selected(self):
+        assert get_channel_id(self.organization, self.integration.id, "#fake-channel") is None
+        assert get_channel_id(self.organization, self.integration.id, "@fake-user") is None
+
+
 class BuildIncidentAttachmentTest(TestCase):
     def test_simple(self):
         logo_url = absolute_uri(get_asset_url("sentry", "images/sentry-email-avatar.png"))

commit 055cfe74bb88bbb2083f37f5df21b91d0ef4f9a7
Author: Mark Story <mark@sentry.io>
Date:   Fri Jan 3 09:56:01 2020 -0500

    feat(discover) Use new discover API in discover2 endpoints (#16070)
    
    Migrate the discover2 endpoints to use the discover dataset.
    
    The project_id condition should be treated as a tag as that field is not
    in the public schema. This reverses an earlier decision I made which
    aimed at fixing how project_id moved from conditions to filter_key.
    
    Notes from squashed commits:
    
    * Added missing offset/limit parameters to discover.query. I forgot
      these earlier and they are needed to make the results view
      work.
    * Because we need to preserve none values for environments, we should do
      so consistently. This changes behavior when an account is using the none
      environment in that it shows up all the time now instead of only when
      you explicitly ask for it. Because of this null user values will also show up
      in facet maps which better represents the actual data.
    * Fix up the project_id condition as I broke old events.
    * Fix project.name condition not working. Because get_filter() converts it into a project_id
      condition very early we have to let project_id slide through the column jail in
      resolve_column_alias.
    * Relax proptypes as name + value are optional.

diff --git a/src/sentry/api/bases/organization_events.py b/src/sentry/api/bases/organization_events.py
index e994f1547d..86f8294ead 100644
--- a/src/sentry/api/bases/organization_events.py
+++ b/src/sentry/api/bases/organization_events.py
@@ -3,56 +3,38 @@ from __future__ import absolute_import
 from rest_framework.exceptions import PermissionDenied
 
 from sentry.api.bases import OrganizationEndpoint, OrganizationEventsError
-from sentry.api.event_search import get_filter, resolve_field_list, InvalidSearchQuery
-from sentry.snuba.discover import ReferenceEvent, create_reference_event_conditions
+from sentry.api.event_search import get_filter, InvalidSearchQuery
 from sentry.models.project import Project
 from sentry.snuba.dataset import Dataset
+from sentry.snuba.discover import ReferenceEvent
 from sentry.utils import snuba
 
 
 class OrganizationEventsEndpointBase(OrganizationEndpoint):
-    def get_snuba_query_args(self, request, organization, params):
+    def get_snuba_filter(self, request, organization, params=None):
+        if params is None:
+            params = self.get_filter_params(request, organization)
         query = request.GET.get("query")
         try:
-            filter = get_filter(query, params)
+            return get_filter(query, params)
         except InvalidSearchQuery as exc:
             raise OrganizationEventsError(exc.message)
 
-        snuba_args = {
-            "start": filter.start,
-            "end": filter.end,
-            "conditions": filter.conditions,
-            "filter_keys": filter.filter_keys,
-        }
-
+    def get_orderby(self, request):
         sort = request.GET.getlist("sort")
         if sort:
-            snuba_args["orderby"] = sort
-
+            return sort
         # Deprecated. `sort` should be used as it is supported by
         # more endpoints.
         orderby = request.GET.getlist("orderby")
-        if orderby and "orderby" not in snuba_args:
-            snuba_args["orderby"] = orderby
-
-        if request.GET.get("rollup"):
-            try:
-                snuba_args["rollup"] = int(request.GET.get("rollup"))
-            except ValueError:
-                raise OrganizationEventsError("rollup must be an integer.")
+        if orderby:
+            return orderby
 
+    def reference_event(self, request, organization):
         fields = request.GET.getlist("field")[:]
-        if fields:
-            try:
-                snuba_args.update(resolve_field_list(fields, snuba_args))
-            except InvalidSearchQuery as exc:
-                raise OrganizationEventsError(exc.message)
-
         reference_event_id = request.GET.get("referenceEvent")
         if reference_event_id:
-            reference = ReferenceEvent(organization, reference_event_id, fields)
-            snuba_args["conditions"].extend(create_reference_event_conditions(reference))
-        return snuba_args
+            return ReferenceEvent(organization, reference_event_id, fields)
 
     def get_snuba_query_args_legacy(self, request, organization):
         params = self.get_filter_params(request, organization)
diff --git a/src/sentry/api/endpoints/organization_event_details.py b/src/sentry/api/endpoints/organization_event_details.py
index f2d089fbe1..893d222bf0 100644
--- a/src/sentry/api/endpoints/organization_event_details.py
+++ b/src/sentry/api/endpoints/organization_event_details.py
@@ -1,11 +1,14 @@
 from __future__ import absolute_import
 
+import six
+
 from rest_framework.response import Response
+from rest_framework.exceptions import ParseError
 
 from sentry.api.bases import OrganizationEventsEndpointBase, OrganizationEventsError, NoProjects
 from sentry import eventstore, features
+from sentry.snuba import discover
 from sentry.models.project import Project, ProjectStatus
-from sentry.snuba.discover import create_reference_event_conditions, ReferenceEvent
 from sentry.api.serializers import serialize
 
 
@@ -16,7 +19,6 @@ class OrganizationEventDetailsEndpoint(OrganizationEventsEndpointBase):
 
         try:
             params = self.get_filter_params(request, organization)
-            snuba_args = self.get_snuba_query_args(request, organization, params)
         except OrganizationEventsError as exc:
             return Response({"detail": exc.message}, status=400)
         except NoProjects:
@@ -40,69 +42,27 @@ class OrganizationEventDetailsEndpoint(OrganizationEventsEndpointBase):
         if event is None:
             return Response({"detail": "Event not found"}, status=404)
 
-        # Scope the pagination related event ids to the current event
-        # This ensure that if a field list/groupby conditions were provided
-        # that we constrain related events to the query + current event values
-        event_slug = u"{}:{}".format(project.slug, event_id)
+        reference = None
         fields = request.query_params.getlist("field")
         if fields:
-            reference = ReferenceEvent(organization, event_slug, fields)
-            snuba_args["conditions"].extend(create_reference_event_conditions(reference))
+            event_slug = u"{}:{}".format(project.slug, event_id)
+            reference = discover.ReferenceEvent(organization, event_slug, fields)
+        try:
+            pagination = discover.get_pagination_ids(
+                event=event,
+                query=request.query_params.get("query"),
+                params=params,
+                reference_event=reference,
+                referrer="api.organization-event-details",
+            )
+        except discover.InvalidSearchQuery as err:
+            raise ParseError(detail=six.text_type(err))
 
         data = serialize(event)
-        data["nextEventID"] = self.next_event_id(snuba_args, event)
-        data["previousEventID"] = self.prev_event_id(snuba_args, event)
-        data["oldestEventID"] = self.oldest_event_id(snuba_args, event)
-        data["latestEventID"] = self.latest_event_id(snuba_args, event)
+        data["nextEventID"] = pagination.next
+        data["previousEventID"] = pagination.previous
+        data["oldestEventID"] = pagination.oldest
+        data["latestEventID"] = pagination.latest
         data["projectSlug"] = project_slug
 
         return Response(data)
-
-    def next_event_id(self, snuba_args, event):
-        """
-        Returns the next event ID if there is a subsequent event matching the
-        conditions provided. Ignores the project_id.
-        """
-        next_event = eventstore.get_next_event_id(event, filter=self._get_filter(snuba_args))
-
-        if next_event:
-            return next_event[1]
-
-    def prev_event_id(self, snuba_args, event):
-        """
-        Returns the previous event ID if there is a previous event matching the
-        conditions provided. Ignores the project_id.
-        """
-        prev_event = eventstore.get_prev_event_id(event, filter=self._get_filter(snuba_args))
-
-        if prev_event:
-            return prev_event[1]
-
-    def latest_event_id(self, snuba_args, event):
-        """
-        Returns the latest event ID if there is a newer event matching the
-        conditions provided
-        """
-        latest_event = eventstore.get_latest_event_id(event, filter=self._get_filter(snuba_args))
-
-        if latest_event:
-            return latest_event[1]
-
-    def oldest_event_id(self, snuba_args, event):
-        """
-        Returns the oldest event ID if there is a subsequent event matching the
-        conditions provided
-        """
-        oldest_event = eventstore.get_earliest_event_id(event, filter=self._get_filter(snuba_args))
-
-        if oldest_event:
-            return oldest_event[1]
-
-    def _get_filter(self, snuba_args):
-        return eventstore.Filter(
-            conditions=snuba_args["conditions"],
-            start=snuba_args.get("start", None),
-            end=snuba_args.get("end", None),
-            project_ids=snuba_args["filter_keys"].get("project_id", None),
-            group_ids=snuba_args["filter_keys"].get("issue", None),
-        )
diff --git a/src/sentry/api/endpoints/organization_events.py b/src/sentry/api/endpoints/organization_events.py
index 5f95245911..3a36d88735 100644
--- a/src/sentry/api/endpoints/organization_events.py
+++ b/src/sentry/api/endpoints/organization_events.py
@@ -4,6 +4,7 @@ import logging
 import six
 from functools import partial
 from rest_framework.response import Response
+from rest_framework.exceptions import ParseError
 
 from semaphore.consts import SPAN_STATUS_CODE_TO_NAME
 from sentry.api.bases import OrganizationEventsEndpointBase, OrganizationEventsError, NoProjects
@@ -12,6 +13,7 @@ from sentry.api.helpers.events import get_direct_hit_response
 from sentry.api.paginator import GenericOffsetPaginator
 from sentry.api.serializers import EventSerializer, serialize, SimpleEventSerializer
 from sentry import eventstore, features
+from sentry.snuba import discover
 from sentry.utils import snuba
 from sentry.models.project import Project
 
@@ -94,30 +96,30 @@ class OrganizationEventsV2Endpoint(OrganizationEventsEndpointBase):
 
         try:
             params = self.get_filter_params(request, organization)
-            snuba_args = self.get_snuba_query_args(request, organization, params)
-            if not snuba_args.get("selected_columns") and not snuba_args.get("aggregations"):
-                return Response({"detail": "No fields provided"}, status=400)
-
         except OrganizationEventsError as exc:
-            return Response({"detail": exc.message}, status=400)
+            raise ParseError(detail=six.text_type(exc))
         except NoProjects:
             return Response([])
 
-        filters = snuba_args.get("filter_keys", {})
         has_global_views = features.has(
             "organizations:global-views", organization, actor=request.user
         )
-        if not has_global_views and len(filters.get("project_id", [])) > 1:
-            return Response(
-                {"detail": "You cannot view events from multiple projects."}, status=400
+        if not has_global_views and len(params.get("project_id", [])) > 1:
+            raise ParseError(detail="You cannot view events from multiple projects.")
+
+        def data_fn(offset, limit):
+            return discover.query(
+                selected_columns=request.GET.getlist("field")[:],
+                query=request.GET.get("query"),
+                params=params,
+                reference_event=self.reference_event(request, organization),
+                orderby=self.get_orderby(request),
+                offset=offset,
+                limit=limit,
+                referrer="api.organization-events-v2",
+                auto_fields=True,
             )
 
-        data_fn = partial(
-            lambda **kwargs: snuba.transform_aliases_and_query(**kwargs),
-            referrer="api.organization-events-v2",
-            **snuba_args
-        )
-
         try:
             return self.paginate(
                 request=request,
@@ -126,6 +128,8 @@ class OrganizationEventsV2Endpoint(OrganizationEventsEndpointBase):
                     request, organization, params["project_id"], results
                 ),
             )
+        except discover.InvalidSearchQuery as error:
+            raise ParseError(detail=six.text_type(error))
         except snuba.SnubaError as error:
             logger.info(
                 "organization.events.snuba-error",
@@ -135,7 +139,7 @@ class OrganizationEventsV2Endpoint(OrganizationEventsEndpointBase):
                     "error": six.text_type(error),
                 },
             )
-            return Response({"detail": "Invalid query."}, status=400)
+            raise ParseError(detail="Invalid query.")
 
     def handle_results_with_meta(self, request, organization, project_ids, results):
         data = self.handle_data(request, organization, project_ids, results.get("data"))
diff --git a/src/sentry/api/endpoints/organization_events_distribution.py b/src/sentry/api/endpoints/organization_events_distribution.py
index 7575949ac2..eb5ce9fcd9 100644
--- a/src/sentry/api/endpoints/organization_events_distribution.py
+++ b/src/sentry/api/endpoints/organization_events_distribution.py
@@ -3,9 +3,11 @@ from __future__ import absolute_import
 import six
 
 from rest_framework.response import Response
+from rest_framework.exceptions import ParseError
+
 from sentry.api.bases import OrganizationEventsEndpointBase, OrganizationEventsError, NoProjects
-from sentry.utils.snuba import transform_aliases_and_query
 from sentry import features, tagstore
+from sentry.snuba import discover
 from sentry.tagstore.base import TOP_VALUES_DEFAULT_LIMIT
 
 
@@ -20,54 +22,46 @@ class OrganizationEventsDistributionEndpoint(OrganizationEventsEndpointBase):
             return Response(status=404)
         try:
             params = self.get_filter_params(request, organization)
-            snuba_args = self.get_snuba_query_args(request, organization, params)
-        except OrganizationEventsError as exc:
-            return Response({"detail": exc.message}, status=400)
+        except OrganizationEventsError as error:
+            raise ParseError(detail=six.text_type(error))
         except NoProjects:
             return Response({"detail": "A valid project must be included."}, status=400)
 
         try:
             key = self._validate_key(request)
-            self._validate_project_ids(request, organization, snuba_args)
+            self._validate_project_ids(request, organization, params)
         except OrganizationEventsError as error:
-            return Response({"detail": six.text_type(error)}, status=400)
+            raise ParseError(detail=six.text_type(error))
 
         if key == PROJECT_KEY:
-            colname = "project_id"
-            conditions = snuba_args["conditions"]
+            colname = "project.id"
+        elif key == "user":
+            colname = "sentry:user"
         else:
             colname = key
-            additional_conditions = []
-            # the "no environment" environment is null in snuba
-            if not ("environment" in params and "" in params["environment"]):
-                additional_conditions = [[colname, "IS NOT NULL", None]]
-
-            conditions = snuba_args["conditions"] + additional_conditions
-
-        top_values = transform_aliases_and_query(
-            start=snuba_args["start"],
-            end=snuba_args["end"],
-            conditions=conditions,
-            filter_keys=snuba_args["filter_keys"],
-            groupby=[colname],
-            aggregations=[("count()", None, "count")],
-            orderby="-count",
-            limit=TOP_VALUES_DEFAULT_LIMIT,
-            referrer="api.organization-events-distribution",
-        )["data"]
+        try:
+            result = discover.query(
+                selected_columns=[colname, "count()"],
+                params=params,
+                query=request.GET.get("query"),
+                orderby="-count",
+                limit=TOP_VALUES_DEFAULT_LIMIT,
+                referrer="api.organization-events-distribution",
+            )
+        except discover.InvalidSearchQuery as error:
+            raise ParseError(detail=six.text_type(error))
 
         if key == PROJECT_KEY:
             projects = {p.id: p.slug for p in self.get_projects(request, organization)}
-
             resp = {
                 "key": PROJECT_KEY,
                 "topValues": [
                     {
-                        "value": projects[v["project_id"]],
-                        "name": projects[v["project_id"]],
+                        "value": projects[v["project.id"]],
+                        "name": projects[v["project.id"]],
                         "count": v["count"],
                     }
-                    for v in top_values
+                    for v in result["data"]
                 ],
             }
         else:
@@ -79,7 +73,7 @@ class OrganizationEventsDistributionEndpoint(OrganizationEventsEndpointBase):
                         "name": tagstore.get_tag_value_label(colname, v[colname]),
                         "count": v["count"],
                     }
-                    for v in top_values
+                    for v in result["data"]
                 ],
             }
 
@@ -96,8 +90,8 @@ class OrganizationEventsDistributionEndpoint(OrganizationEventsEndpointBase):
 
         return key
 
-    def _validate_project_ids(self, request, organization, snuba_args):
-        project_ids = snuba_args["filter_keys"]["project_id"]
+    def _validate_project_ids(self, request, organization, params):
+        project_ids = params["project_id"]
 
         has_global_views = features.has(
             "organizations:global-views", organization, actor=request.user
diff --git a/src/sentry/api/endpoints/organization_events_stats.py b/src/sentry/api/endpoints/organization_events_stats.py
index df7809fd75..c33dbcdae8 100644
--- a/src/sentry/api/endpoints/organization_events_stats.py
+++ b/src/sentry/api/endpoints/organization_events_stats.py
@@ -10,28 +10,46 @@ from sentry import features
 from sentry.api.bases import OrganizationEventsEndpointBase, OrganizationEventsError, NoProjects
 from sentry.api.event_search import resolve_field_list, InvalidSearchQuery
 from sentry.api.serializers.snuba import SnubaTSResultSerializer
-from sentry.utils.dates import parse_stats_period
+from sentry.snuba import discover
 from sentry.utils import snuba
+from sentry.utils.dates import parse_stats_period
 
 
 class OrganizationEventsStatsEndpoint(OrganizationEventsEndpointBase):
     def get(self, request, organization):
+        if not features.has("organizations:events-v2", organization, actor=request.user):
+            return self.get_v1_results(request, organization)
+
         try:
-            if features.has("organizations:events-v2", organization, actor=request.user):
-                params = self.get_filter_params(request, organization)
-                snuba_args = self.get_snuba_query_args(request, organization, params)
-            else:
-                snuba_args = self.get_snuba_query_args_legacy(request, organization)
-        except (OrganizationEventsError, InvalidSearchQuery) as exc:
-            raise ParseError(detail=six.text_type(exc))
-        except NoProjects:
-            return Response({"data": []})
+            params = self.get_filter_params(request, organization)
+            result = discover.timeseries_query(
+                selected_columns=[request.GET.get("yAxis", "count()")],
+                query=request.GET.get("query"),
+                params=params,
+                rollup=self.get_rollup(request),
+                reference_event=self.reference_event(request, organization),
+                referrer="api.organization-event-stats",
+            )
+        except InvalidSearchQuery as err:
+            raise ParseError(detail=six.text_type(err))
+        serializer = SnubaTSResultSerializer(organization, None, request.user)
+        return Response(serializer.serialize(result), status=200)
 
+    def get_rollup(self, request):
         interval = parse_stats_period(request.GET.get("interval", "1h"))
         if interval is None:
             interval = timedelta(hours=1)
-        rollup = int(interval.total_seconds())
+        return int(interval.total_seconds())
+
+    def get_v1_results(self, request, organization):
+        try:
+            snuba_args = self.get_snuba_query_args_legacy(request, organization)
+        except (OrganizationEventsError, InvalidSearchQuery) as exc:
+            raise ParseError(detail=six.text_type(exc))
+        except NoProjects:
+            return Response({"data": []})
 
+        rollup = self.get_rollup(request)
         snuba_args = self.get_field(request, snuba_args)
 
         result = snuba.transform_aliases_and_query(
diff --git a/src/sentry/api/event_search.py b/src/sentry/api/event_search.py
index 74a70efa88..8bb62fea25 100644
--- a/src/sentry/api/event_search.py
+++ b/src/sentry/api/event_search.py
@@ -590,7 +590,6 @@ def convert_search_filter_to_snuba_query(search_filter):
             if isinstance(value, datetime) and name != "timestamp"
             else value
         )
-
         # Tags are never null, but promoted tags are columns and so can be null.
         # To handle both cases, use `ifNull` to convert to an empty string and
         # compare so we need to check for empty values.
diff --git a/src/sentry/snuba/discover.py b/src/sentry/snuba/discover.py
index 20c8486501..53f17a2573 100644
--- a/src/sentry/snuba/discover.py
+++ b/src/sentry/snuba/discover.py
@@ -125,6 +125,10 @@ def resolve_column(col):
     """
     if col is None:
         return col
+    # Whilst project_id is not part of the public schema we convert
+    # the project.name field into project_id way before we get here.
+    if col == "project_id":
+        return col
     if col.startswith("tags[") or QUOTED_LITERAL_RE.match(col):
         return col
     return DISCOVER_COLUMN_MAP.get(col, u"tags[{}]".format(col))
@@ -356,6 +360,11 @@ def timeseries_query(selected_columns, query, params, rollup, reference_event=No
     if not snuba_args["aggregations"]:
         raise InvalidSearchQuery("Cannot get timeseries result with no aggregation.")
 
+    # Change the alias of the first aggregation to count. This ensures compatibility
+    # with other parts of the timeseries endpoint expectations
+    if len(snuba_args["aggregations"]) == 1:
+        snuba_args["aggregations"][0][2] = "count"
+
     result = raw_query(
         aggregations=snuba_args.get("aggregations"),
         conditions=snuba_args.get("conditions"),
diff --git a/src/sentry/static/sentry/app/components/tagDistributionMeter/index.jsx b/src/sentry/static/sentry/app/components/tagDistributionMeter/index.jsx
index 1ec7438fb6..24066819d0 100644
--- a/src/sentry/static/sentry/app/components/tagDistributionMeter/index.jsx
+++ b/src/sentry/static/sentry/app/components/tagDistributionMeter/index.jsx
@@ -18,10 +18,8 @@ export default class TagDistributionMeter extends React.Component {
     segments: PropTypes.arrayOf(
       PropTypes.shape({
         count: PropTypes.number.isRequired,
-        name: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.array])
-          .isRequired,
-        value: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.array])
-          .isRequired,
+        name: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.array]),
+        value: PropTypes.oneOfType([PropTypes.string, PropTypes.number, PropTypes.array]),
         url: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired,
       })
     ).isRequired,
@@ -58,7 +56,7 @@ export default class TagDistributionMeter extends React.Component {
       <Title>
         <TitleType>{title}</TitleType>
         <TitleDescription>
-          <Label>{largestSegment.name}</Label>
+          <Label>{largestSegment.name || t('n/a')}</Label>
           {isLoading || hasError ? null : <Percent>{pctLabel}%</Percent>}
         </TitleDescription>
       </Title>
@@ -98,7 +96,7 @@ export default class TagDistributionMeter extends React.Component {
 
           const tooltipHtml = (
             <React.Fragment>
-              <div className="truncate">{value.name}</div>
+              <div className="truncate">{value.name || t('n/a')}</div>
               {pctLabel}%
             </React.Fragment>
           );
diff --git a/tests/sentry/snuba/test_discover.py b/tests/sentry/snuba/test_discover.py
index 76dec0f50b..47d6ff4454 100644
--- a/tests/sentry/snuba/test_discover.py
+++ b/tests/sentry/snuba/test_discover.py
@@ -481,6 +481,64 @@ class QueryTransformTest(TestCase):
             referrer=None,
         )
 
+    @patch("sentry.snuba.discover.raw_query")
+    def test_condition_projectid_transform(self, mock_query):
+        mock_query.return_value = {
+            "meta": [{"name": "transaction"}, {"name": "duration"}],
+            "data": [{"transaction": "api.do_things", "duration": 200}],
+        }
+        # The project_id column is not a public column, but we
+        # have to let it through in conditions to ensure project.name works.
+        discover.query(
+            selected_columns=["transaction", "transaction.duration"],
+            query="project_id:1",
+            params={"project_id": [self.project.id]},
+        )
+        mock_query.assert_called_with(
+            selected_columns=["transaction", "duration"],
+            conditions=[["project_id", "=", 1]],
+            filter_keys={"project_id": [self.project.id]},
+            groupby=[],
+            dataset=Dataset.Discover,
+            aggregations=[],
+            orderby=None,
+            end=None,
+            start=None,
+            limit=50,
+            offset=None,
+            referrer=None,
+        )
+
+    @patch("sentry.snuba.discover.raw_query")
+    def test_condition_projectname_transform(self, mock_query):
+        mock_query.return_value = {
+            "meta": [{"name": "transaction"}, {"name": "duration"}],
+            "data": [{"transaction": "api.do_things", "duration": 200}],
+        }
+        project2 = self.create_project(organization=self.organization)
+
+        # project.name is in the public schema and should be converted to a
+        # project_id condition.
+        discover.query(
+            selected_columns=["transaction", "transaction.duration"],
+            query="project.name:{}".format(project2.slug),
+            params={"project_id": [self.project.id, project2.id]},
+        )
+        mock_query.assert_called_with(
+            selected_columns=["transaction", "duration"],
+            conditions=[["project_id", "=", project2.id]],
+            filter_keys={"project_id": [self.project.id, project2.id]},
+            groupby=[],
+            dataset=Dataset.Discover,
+            aggregations=[],
+            orderby=None,
+            end=None,
+            start=None,
+            limit=50,
+            offset=None,
+            referrer=None,
+        )
+
     @patch("sentry.snuba.discover.raw_query")
     def test_params_forward(self, mock_query):
         mock_query.return_value = {
@@ -523,6 +581,7 @@ class TimeseriesQueryTest(SnubaTestCase, TestCase):
                 "timestamp": iso_format(self.day_ago + timedelta(hours=1)),
                 "fingerprint": ["group1"],
                 "tags": {"important": "yes"},
+                "user": {"id": 1},
             },
             project_id=self.project.id,
         )
@@ -607,6 +666,23 @@ class TimeseriesQueryTest(SnubaTestCase, TestCase):
         assert len(result.data["data"]) == 3
         assert [2] == [val["count"] for val in result.data["data"] if "count" in val]
 
+        result = discover.timeseries_query(
+            selected_columns=["count_unique(user)"],
+            query="",
+            params={
+                "start": self.day_ago,
+                "end": self.day_ago + timedelta(hours=2),
+                "project_id": [self.project.id],
+            },
+            rollup=3600,
+        )
+        assert len(result.data["data"]) == 3
+        keys = []
+        for row in result.data["data"]:
+            keys.extend(list(row.keys()))
+        assert "count" in keys
+        assert "time" in keys
+
     def test_zerofilling(self):
         result = discover.timeseries_query(
             selected_columns=["count()"],
diff --git a/tests/snuba/api/endpoints/test_organization_events_distribution.py b/tests/snuba/api/endpoints/test_organization_events_distribution.py
index 70a7a31891..873ab2ec3a 100644
--- a/tests/snuba/api/endpoints/test_organization_events_distribution.py
+++ b/tests/snuba/api/endpoints/test_organization_events_distribution.py
@@ -393,10 +393,10 @@ class OrganizationEventsDistributionEndpointTest(SnubaTestCase, APITestCase):
             response = self.client.get(self.url, {"key": "user.email"}, format="json")
 
         assert response.status_code == 200, response.content
-
         assert response.data == {
             "topValues": [
                 {"count": 2, "name": user1["email"], "value": user1["email"]},
+                {"count": 1, "name": None, "value": None},
                 {"count": 1, "name": user2["email"], "value": user2["email"]},
             ],
             "key": "user.email",
@@ -490,6 +490,7 @@ class OrganizationEventsDistributionEndpointTest(SnubaTestCase, APITestCase):
 
             assert response.data == {
                 "topValues": [
+                    {"count": 1, "name": None, "value": None},
                     {"count": 1, "name": "staging", "value": "staging"},
                     {"count": 1, "name": "production", "value": "production"},
                 ],

commit dcb5ac2b4f1c0db65bbf349ef9aef90ed5734879
Author: David Cramer <dcramer@gmail.com>
Date:   Tue Sep 27 15:38:27 2016 -0700

    [alerts] Add frequency to rules
    
    This augments GroupRuleStatus to be utilized for a global frequency. All rules can now determine the execution frequency, which is defaulted to once every 30 minutes.
    
    Fixes GH-1400
    Fixes GH-4065

diff --git a/src/sentry/api/endpoints/project_rule_details.py b/src/sentry/api/endpoints/project_rule_details.py
index 1e96b93414..a1938ff1a1 100644
--- a/src/sentry/api/endpoints/project_rule_details.py
+++ b/src/sentry/api/endpoints/project_rule_details.py
@@ -48,7 +48,8 @@ class ProjectRuleDetailsEndpoint(ProjectEndpoint):
             id=rule_id,
         )
         serializer = RuleSerializer({
-            'actionMatch': rule.data.get('action_match', 'all'),
+            'actionMatch': rule.data.get('action_match') or Rule.DEFAULT_ACTION_MATCH,
+            'frequency': rule.data.get('frequency') or Rule.DEFAULT_FREQUENCY,
         }, context={'project': project}, data=request.DATA, partial=True)
 
         if serializer.is_valid():
diff --git a/src/sentry/api/serializers/models/rule.py b/src/sentry/api/serializers/models/rule.py
index b0607a9fbe..9e32bf5bbe 100644
--- a/src/sentry/api/serializers/models/rule.py
+++ b/src/sentry/api/serializers/models/rule.py
@@ -34,7 +34,8 @@ class RuleSerializer(Serializer):
                     'name': _generate_rule_label(obj.project, obj, o),
                 }, **o) for o in obj.data.get('actions', [])
             ],
-            'actionMatch': obj.data.get('action_match', 'all'),
+            'actionMatch': obj.data.get('action_match') or Rule.DEFAULT_ACTION_MATCH,
+            'frequency': obj.data.get('frequency') or Rule.DEFAULT_FREQUENCY,
             'name': obj.label,
             'dateCreated': obj.date_added,
         }
diff --git a/src/sentry/api/serializers/rest_framework/rule.py b/src/sentry/api/serializers/rest_framework/rule.py
index 059df8f4ac..2d3e1a3cc2 100644
--- a/src/sentry/api/serializers/rest_framework/rule.py
+++ b/src/sentry/api/serializers/rest_framework/rule.py
@@ -49,6 +49,7 @@ class RuleSerializer(serializers.Serializer):
     conditions = ListField(
         child=RuleNodeField(type='condition/event'),
     )
+    frequency = serializers.IntegerField(min_value=5, max_value=1440)
 
     def save(self, rule):
         rule.project = self.context['project']
@@ -60,5 +61,7 @@ class RuleSerializer(serializers.Serializer):
             rule.data['actions'] = self.data['actions']
         if self.data.get('conditions') is not None:
             rule.data['conditions'] = self.data['conditions']
+        if self.data.get('frequency'):
+            rule.data['frequency'] = self.data['frequency']
         rule.save()
         return rule
diff --git a/src/sentry/models/rule.py b/src/sentry/models/rule.py
index cd2c851139..349b6a5a2f 100644
--- a/src/sentry/models/rule.py
+++ b/src/sentry/models/rule.py
@@ -29,6 +29,9 @@ class RuleStatus(object):
 class Rule(Model):
     __core__ = True
 
+    DEFAULT_ACTION_MATCH = 'all'  # any, all
+    DEFAULT_FREQUENCY = 30  # minutes
+
     project = FlexibleForeignKey('sentry.Project')
     label = models.CharField(max_length=64)
     data = GzippedDictField()
diff --git a/src/sentry/rules/base.py b/src/sentry/rules/base.py
index 6053711100..479c175459 100644
--- a/src/sentry/rules/base.py
+++ b/src/sentry/rules/base.py
@@ -111,10 +111,7 @@ class RuleBase(object):
 
 
 class EventState(object):
-    def __init__(self, is_new, is_regression, is_sample, rule_is_active,
-                 rule_last_active):
+    def __init__(self, is_new, is_regression, is_sample):
         self.is_new = is_new
         self.is_regression = is_regression
         self.is_sample = is_sample,
-        self.rule_is_active = rule_is_active
-        self.rule_last_active = rule_last_active
diff --git a/src/sentry/rules/conditions/event_frequency.py b/src/sentry/rules/conditions/event_frequency.py
index 8ef77100a6..30ebefceb2 100644
--- a/src/sentry/rules/conditions/event_frequency.py
+++ b/src/sentry/rules/conditions/event_frequency.py
@@ -45,12 +45,6 @@ class BaseEventFrequencyCondition(EventCondition):
         super(BaseEventFrequencyCondition, self).__init__(*args, **kwargs)
 
     def passes(self, event, state):
-        # when a rule is not active (i.e. it hasnt gone from inactive -> active)
-        # it means that we already notified the user about this condition and
-        # shouldn't spam them again
-        if state.rule_is_active:
-            return False
-
         interval = self.get_option('interval')
         try:
             value = int(self.get_option('value'))
@@ -60,12 +54,6 @@ class BaseEventFrequencyCondition(EventCondition):
         if not interval:
             return False
 
-        now = timezone.now()
-
-        # XXX(dcramer): hardcode 30 minute frequency until rules support choices
-        if state.rule_last_active and state.rule_last_active > (now - timedelta(minutes=30)):
-            return False
-
         current_value = self.get_rate(event, interval)
 
         return current_value > value
diff --git a/src/sentry/rules/processor.py b/src/sentry/rules/processor.py
index e9ba7dfc16..152ab07335 100644
--- a/src/sentry/rules/processor.py
+++ b/src/sentry/rules/processor.py
@@ -3,6 +3,7 @@ from __future__ import absolute_import
 import logging
 
 from collections import defaultdict, namedtuple
+from datetime import timedelta
 from django.utils import timezone
 
 from sentry.models import GroupRuleStatus, Rule
@@ -51,13 +52,11 @@ class RuleProcessor(object):
         return Rule.get_for_project(self.project.id)
 
     def get_rule_status(self, rule):
-        # TODO(dcramer): this isnt the most efficient query pattern for this
         rule_status, _ = GroupRuleStatus.objects.get_or_create(
             rule=rule,
             group=self.group,
             defaults={
                 'project': self.project,
-                'status': GroupRuleStatus.INACTIVE,
             },
         )
 
@@ -73,26 +72,32 @@ class RuleProcessor(object):
         return safe_execute(condition_inst.passes, self.event, state,
                             _with_transaction=False)
 
-    def get_state(self, rule_status):
+    def get_state(self):
         return EventState(
             is_new=self.is_new,
             is_regression=self.is_regression,
             is_sample=self.is_sample,
-            rule_is_active=rule_status.status == GroupRuleStatus.ACTIVE,
-            rule_last_active=rule_status.last_active,
         )
 
     def apply_rule(self, rule):
-        match = rule.data.get('action_match', 'all')
+        match = rule.data.get('action_match') or Rule.DEFAULT_ACTION_MATCH
         condition_list = rule.data.get('conditions', ())
+        frequency = rule.data.get('frequency') or Rule.DEFAULT_FREQUENCY
 
         # XXX(dcramer): if theres no condition should we really skip it,
         # or should we just apply it blindly?
         if not condition_list:
             return
 
-        rule_status = self.get_rule_status(rule)
-        state = self.get_state(rule_status)
+        status = self.get_rule_status(rule)
+
+        now = timezone.now()
+        freq_offset = now - timedelta(minutes=frequency)
+
+        if status.last_active and status.last_active > freq_offset:
+            return
+
+        state = self.get_state()
 
         condition_iter = (
             self.condition_matches(c, state, rule)
@@ -110,31 +115,12 @@ class RuleProcessor(object):
                               match, rule.id)
             return
 
-        now = timezone.now()
-        if passed and rule_status.status == GroupRuleStatus.INACTIVE:
-            # we only fire if we're able to say that the state has changed
-            GroupRuleStatus.objects.filter(
-                id=rule_status.id,
-                status=GroupRuleStatus.INACTIVE,
-            ).update(
-                status=GroupRuleStatus.ACTIVE,
-                last_active=now,
-            )
-            rule_status.last_active = now
-            rule_status.status = GroupRuleStatus.ACTIVE
-        elif not passed and rule_status.status == GroupRuleStatus.ACTIVE:
-            # update the state to suggest this rule can fire again
-            GroupRuleStatus.objects.filter(
-                id=rule_status.id,
-                status=GroupRuleStatus.ACTIVE,
-            ).update(status=GroupRuleStatus.INACTIVE)
-            rule_status.status = GroupRuleStatus.INACTIVE
-        elif passed:
-            GroupRuleStatus.objects.filter(
-                id=rule_status.id,
-                status=GroupRuleStatus.ACTIVE,
+        if passed:
+            passed = GroupRuleStatus.objects.filter(
+                id=status.id,
+            ).exclude(
+                last_active__gt=freq_offset,
             ).update(last_active=now)
-            rule_status.last_active = now
 
         if not passed:
             return
diff --git a/src/sentry/static/sentry/app/views/projectAlertRules.jsx b/src/sentry/static/sentry/app/views/projectAlertRules.jsx
index 8fd2ea9672..978524f1ad 100644
--- a/src/sentry/static/sentry/app/views/projectAlertRules.jsx
+++ b/src/sentry/static/sentry/app/views/projectAlertRules.jsx
@@ -1,6 +1,7 @@
 import React from 'react';
 
 import ApiMixin from '../mixins/apiMixin';
+import Duration from '../components/duration';
 import IndicatorStore from '../stores/indicatorStore';
 import ListLink from '../components/listLink';
 import LoadingError from '../components/loadingError';
@@ -88,7 +89,7 @@ const RuleRow = React.createClass({
             <div className="col-md-6">
               {data.actions.length !== 0 &&
                 <div>
-                  <h6>Take these actions:</h6>
+                  <h6>Take these actions <strong>once every <Duration seconds={data.frequency * 60} /></strong>:</h6>
                   <table className="actions-list table">
                   {data.actions.map((action) => {
                     return (
diff --git a/src/sentry/static/sentry/app/views/ruleEditor/index.jsx b/src/sentry/static/sentry/app/views/ruleEditor/index.jsx
index f8aa5863a6..14bf46ea39 100644
--- a/src/sentry/static/sentry/app/views/ruleEditor/index.jsx
+++ b/src/sentry/static/sentry/app/views/ruleEditor/index.jsx
@@ -4,7 +4,7 @@ import $ from 'jquery';
 import ApiMixin from '../../mixins/apiMixin';
 import IndicatorStore from '../../stores/indicatorStore';
 import SelectInput from '../../components/selectInput';
-import {t} from '../../locale';
+import {t, tct} from '../../locale';
 
 import RuleNodeList from './ruleNodeList';
 
@@ -56,11 +56,13 @@ const RuleEditor = React.createClass({
       actions.push(this.serializeNode(el));
     });
     let actionMatch = $(ReactDOM.findDOMNode(this.refs.actionMatch)).val();
+    let frequency = $(ReactDOM.findDOMNode(this.refs.frequency)).val();
     let name = $(ReactDOM.findDOMNode(this.refs.name)).val();
     let data = {
       actionMatch: actionMatch,
       actions: actions,
       conditions: conditions,
+      frequency: frequency,
       name: name
     };
     let rule = this.props.rule;
@@ -99,7 +101,7 @@ const RuleEditor = React.createClass({
   render() {
     let rule = this.props.rule;
     let {loading, error} = this.state;
-    let {actionMatch, actions, conditions, name} = rule;
+    let {actionMatch, actions, conditions, frequency, name} = rule;
 
     return (
       <form onSubmit={this.onSubmit} ref="form">
@@ -124,6 +126,8 @@ const RuleEditor = React.createClass({
                      placeholder={t('My Rule Name')} />
             </div>
 
+            <hr />
+
             <div className="node-match-selector">
               <h6>
                 {t('Every time %s of these conditions are met:',
@@ -149,10 +153,12 @@ const RuleEditor = React.createClass({
               className="rule-condition-list"
               onChange={this.onConditionsChange} />
 
+            <hr />
+
             <h6>{t('Take these actions:')}</h6>
 
             {this.hasError('actions') &&
-              <p className="error">{t('Ensure at least one condition is enabled and all required fields are filled in.')}</p>
+              <p className="error">{t('Ensure at least one action is enabled and all required fields are filled in.')}</p>
             }
 
             <RuleNodeList nodes={this.props.actions}
@@ -160,6 +166,30 @@ const RuleEditor = React.createClass({
               className="rule-action-list"
               onChange={this.onActionsChange} />
 
+            <hr />
+
+            <div className="node-frequency-selector">
+              <h6>
+                {tct('Perform these actions at most once every [frequency]', {
+                  frequency: (
+                    <SelectInput ref="frequency"
+                          className={(this.hasError('frequency') ? ' error' : '')}
+                          value={frequency}
+                          style={{width:150}}
+                          required={true}>
+                      <option value="5">{t('5 minutes')}</option>
+                      <option value="10">{t('10 minutes')}</option>
+                      <option value="30">{t('30 minutes')}</option>
+                      <option value="60">{t('60 minutes')}</option>
+                      <option value="180">{t('3 hours')}</option>
+                      <option value="720">{t('12 hours')}</option>
+                      <option value="1440">{t('24 hours')}</option>
+                    </SelectInput>
+                  )
+                })}
+              </h6>
+            </div>
+
             <div className="actions">
               <button className="btn btn-primary btn-lg"
                       disabled={loading}>{t('Save Rule')}</button>
diff --git a/src/sentry/testutils/cases.py b/src/sentry/testutils/cases.py
index b77455f2c3..719d13bdcc 100644
--- a/src/sentry/testutils/cases.py
+++ b/src/sentry/testutils/cases.py
@@ -282,8 +282,6 @@ class RuleTestCase(TestCase):
         kwargs.setdefault('is_new', True)
         kwargs.setdefault('is_regression', True)
         kwargs.setdefault('is_sample', True)
-        kwargs.setdefault('rule_is_active', False)
-        kwargs.setdefault('rule_last_active', None)
         return EventState(**kwargs)
 
     def assertPasses(self, rule, event=None, **kwargs):
diff --git a/tests/sentry/api/endpoints/test_project_rules.py b/tests/sentry/api/endpoints/test_project_rules.py
index 29a99cb59b..e912757b45 100644
--- a/tests/sentry/api/endpoints/test_project_rules.py
+++ b/tests/sentry/api/endpoints/test_project_rules.py
@@ -50,6 +50,7 @@ class CreateProjectRuleTest(APITestCase):
             'actionMatch': 'any',
             'actions': actions,
             'conditions': conditions,
+            'frequency': 30,
         }, format='json')
 
         assert response.status_code == 200, response.content
@@ -60,6 +61,7 @@ class CreateProjectRuleTest(APITestCase):
         assert rule.data['action_match'] == 'any'
         assert rule.data['actions'] == actions
         assert rule.data['conditions'] == conditions
+        assert rule.data['frequency'] == 30
 
     def test_missing_name(self):
         self.login_as(user=self.user)
diff --git a/tests/sentry/rules/conditions/test_event_frequency.py b/tests/sentry/rules/conditions/test_event_frequency.py
index 2b85c24bcc..b6211fc02b 100644
--- a/tests/sentry/rules/conditions/test_event_frequency.py
+++ b/tests/sentry/rules/conditions/test_event_frequency.py
@@ -99,26 +99,6 @@ class FrequencyConditionMixin(object):
 
         self.assertPasses(rule, event)
 
-    @mock.patch('django.utils.timezone.now')
-    def test_doesnt_send_consecutive(self, now):
-        now.return_value = datetime(2016, 8, 1, 0, 0, 0, 0, tzinfo=pytz.utc)
-
-        event = self.get_event()
-        value = 10
-        rule = self.get_rule({
-            'interval': Interval.ONE_HOUR,
-            'value': six.text_type(value),
-        })
-
-        self.assertDoesNotPass(rule, event)
-
-        rule.clear_cache(event)
-        self.increment(event, value + 1)
-
-        self.assertPasses(rule, event)
-
-        self.assertDoesNotPass(rule, event, rule_last_active=now())
-
     @mock.patch('django.utils.timezone.now')
     def test_more_than_zero(self, now):
         now.return_value = datetime(2016, 8, 1, 0, 0, 0, 0, tzinfo=pytz.utc)
diff --git a/tests/sentry/rules/test_processor.py b/tests/sentry/rules/test_processor.py
index e365714221..7abba69c31 100644
--- a/tests/sentry/rules/test_processor.py
+++ b/tests/sentry/rules/test_processor.py
@@ -38,6 +38,10 @@ class RuleProcessorTest(TestCase):
         assert futures[0].rule == rule
         assert futures[0].kwargs == {}
 
+        # should not apply twice due to 30m default frequency
+        results = list(rp.apply())
+        assert len(results) == 0
+
 
 class EventCompatibilityProxyTest(TestCase):
     def test_simple(self):

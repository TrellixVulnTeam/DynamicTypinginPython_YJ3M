commit 05b04cdc5729d3e40bb454080726d6ab590f37df
Author: David Cramer <dcramer@gmail.com>
Date:   Mon Aug 1 20:19:52 2016 -0700

    Vendor django-social-auth
    
    This removes the external dependency on social auth which ensures a couple things:
    
    - We can fix issues as they come up
    - We can support Python 3 if need be
    
    It also:
    
    - Removes OpenID support
    - Removes unused backends

diff --git a/setup.py b/setup.py
index efcf796313..341828f50b 100755
--- a/setup.py
+++ b/setup.py
@@ -111,6 +111,7 @@ install_requires = [
     'kombu==3.0.35',
     'lxml>=3.4.1',
     'mock>=0.8.0,<1.1',
+    'oauth2>=1.5.167',
     'petname>=1.7,<1.8',
     'Pillow>=3.2.0,<3.3.0',
     'progressbar>=2.2,<2.4',
diff --git a/src/sentry/conf/server.py b/src/sentry/conf/server.py
index f8470a1b66..b8f798a594 100644
--- a/src/sentry/conf/server.py
+++ b/src/sentry/conf/server.py
@@ -296,13 +296,9 @@ else:
     LOGIN_URL = reverse_lazy('sentry-login')
 
 AUTHENTICATION_BACKENDS = (
-    'social_auth.backends.twitter.TwitterBackend',
-    'social_auth.backends.facebook.FacebookBackend',
-    # TODO: migrate to GoogleOAuth2Backend
-    'social_auth.backends.google.GoogleBackend',
-    'social_auth.backends.contrib.github.GithubBackend',
-    'social_auth.backends.contrib.bitbucket.BitbucketBackend',
-    'social_auth.backends.contrib.trello.TrelloBackend',
+    'social_auth.backends.github.GithubBackend',
+    'social_auth.backends.bitbucket.BitbucketBackend',
+    'social_auth.backends.trello.TrelloBackend',
     'sentry.utils.auth.EmailAuthBackend',
 )
 
@@ -312,13 +308,6 @@ SESSION_ENGINE = "django.contrib.sessions.backends.signed_cookies"
 SESSION_COOKIE_NAME = "sentrysid"
 SESSION_SERIALIZER = "django.contrib.sessions.serializers.PickleSerializer"
 
-TWITTER_CONSUMER_KEY = ''
-TWITTER_CONSUMER_SECRET = ''
-
-FACEBOOK_APP_ID = ''
-FACEBOOK_API_SECRET = ''
-FACEBOOK_EXTENDED_PERMISSIONS = ['email']
-
 GOOGLE_OAUTH2_CLIENT_ID = ''
 GOOGLE_OAUTH2_CLIENT_SECRET = ''
 
@@ -351,6 +340,12 @@ AUTH_PROVIDERS = {
     'bitbucket': ('BITBUCKET_CONSUMER_KEY', 'BITBUCKET_CONSUMER_SECRET'),
 }
 
+AUTH_PROVIDER_LABELS = {
+    'github': 'GitHub',
+    'trello': 'Trello',
+    'bitbucket': 'Bitbucket'
+}
+
 import random
 
 SOCIAL_AUTH_DEFAULT_USERNAME = lambda: random.choice(['Darth Vader', 'Obi-Wan Kenobi', 'R2-D2', 'C-3PO', 'Yoda'])
diff --git a/src/sentry/social_auth/urls.py b/src/sentry/social_auth/urls.py
index 0d53437fb2..c80143a433 100644
--- a/src/sentry/social_auth/urls.py
+++ b/src/sentry/social_auth/urls.py
@@ -1,3 +1,4 @@
+# TODO(dcramer): move our changes into social_auth
 from __future__ import absolute_import, print_function
 
 from django.conf.urls import patterns, url
@@ -8,16 +9,8 @@ from sentry.social_auth.views import auth, disconnect
 
 urlpatterns = patterns('',
     # authentication
-    url(r'^login/(?P<backend>[^/]+)/$', auth,
-        name='socialauth_begin'),
-    url(r'^complete/(?P<backend>[^/]+)/$', complete,
-        name='socialauth_complete'),
-
-    # XXX: Deprecated, this URLs are deprecated, instead use the login and
-    #      complete ones directly, they will differentiate the user intention
-    #      by checking it's authenticated status association.
     url(r'^associate/(?P<backend>[^/]+)/$', auth,
-        name='socialauth_associate_begin'),
+        name='socialauth_associate'),
     url(r'^associate/complete/(?P<backend>[^/]+)/$', complete,
         name='socialauth_associate_complete'),
 
diff --git a/src/sentry/social_auth/views.py b/src/sentry/social_auth/views.py
index 81b973e617..6082f691b8 100644
--- a/src/sentry/social_auth/views.py
+++ b/src/sentry/social_auth/views.py
@@ -35,7 +35,7 @@ def disconnect(request, backend, association_id=None):
     return HttpResponseRedirect(redirect)
 
 
-@dsa_view(setting('SOCIAL_AUTH_COMPLETE_URL_NAME', 'socialauth_complete'))
+@dsa_view(setting('SOCIAL_AUTH_COMPLETE_URL_NAME', 'socialauth_associate_complete'))
 def auth(request, backend):
     """Start authentication process"""
     return auth_process(request, backend)
diff --git a/src/sentry/templates/sentry/account/identities.html b/src/sentry/templates/sentry/account/identities.html
index c0ff7b2184..d5bc32a776 100644
--- a/src/sentry/templates/sentry/account/identities.html
+++ b/src/sentry/templates/sentry/account/identities.html
@@ -2,6 +2,7 @@
 
 {% load crispy_forms_tags %}
 {% load i18n %}
+{% load sentry_auth %}
 {% load sentry_helpers %}
 
 {% block title %}{% trans "Identities" %} | {{ block.super }}{% endblock %}
@@ -23,7 +24,7 @@
             <tbody>
                 {% for identity in identity_list %}
                     <tr>
-                        <td>{{ identity.provider|title }}</td>
+                        <td>{{ identity.provider|auth_provider_label }}</td>
                         <td style="text-align: center;">
                             <form method="post" action="{% url 'socialauth_disconnect_individual' identity.provider identity.id %}?next={% filter urlencode %}{% absolute_uri request.path %}{% endfilter %}">
                             {% csrf_token %}
@@ -40,8 +41,12 @@
             <legend>Connect a New Account</legend>
         </fieldset>
         <ul class="auth-options">
-            {% for engine in AUTH_PROVIDERS %}
-                <li><a href="{% url 'socialauth_associate_begin' engine %}?next={% filter urlencode %}{% absolute_uri request.path %}{% endfilter %}" class="btn btn-default auth-btn auth-{{ engine }}"><span class="auth-icon"></span>{{ engine|title }}</a></li>
+            {% for provider in AUTH_PROVIDERS %}
+                <li>
+                    <a href="{% url 'socialauth_associate' provider %}?next={% filter urlencode %}{% absolute_uri request.path %}{% endfilter %}" class="auth-{{ provider }}">
+                        {% blocktrans with service=provider|auth_provider_label %}Connect {{ service }}{% endblocktrans %}
+                    </a>
+                </li>
             {% endfor %}
         </ul>
     {% endif %}
diff --git a/src/sentry/templates/sentry/login.html b/src/sentry/templates/sentry/login.html
index fa1f1dc583..ec9cd4d765 100644
--- a/src/sentry/templates/sentry/login.html
+++ b/src/sentry/templates/sentry/login.html
@@ -2,6 +2,7 @@
 
 {% load crispy_forms_tags %}
 {% load i18n %}
+{% load sentry_auth %}
 
 {% block title %}{% trans "Login" %} | {{ block.super }}{% endblock %}
 
diff --git a/src/sentry/templatetags/sentry_auth.py b/src/sentry/templatetags/sentry_auth.py
new file mode 100644
index 0000000000..fa4a26299c
--- /dev/null
+++ b/src/sentry/templatetags/sentry_auth.py
@@ -0,0 +1,11 @@
+from __future__ import absolute_import, print_function
+
+from django.conf import settings
+from django import template
+
+register = template.Library()
+
+
+@register.filter
+def auth_provider_label(provider):
+    return settings.AUTH_PROVIDER_LABELS[provider]
diff --git a/src/sentry/utils/runner.py b/src/sentry/utils/runner.py
index 5e4d2a1d86..7a1a5e6e54 100644
--- a/src/sentry/utils/runner.py
+++ b/src/sentry/utils/runner.py
@@ -12,5 +12,6 @@ from __future__ import absolute_import, print_function
 from sentry.runner import configure, main  # NOQA
 
 import warnings
+
 warnings.warn("'sentry.utils.runner' has moved to 'sentry.runner'",
               DeprecationWarning)
diff --git a/src/social_auth/COPYRIGHT.django-twitter-oauth b/src/social_auth/COPYRIGHT.django-twitter-oauth
deleted file mode 100644
index 005d385470..0000000000
--- a/src/social_auth/COPYRIGHT.django-twitter-oauth
+++ /dev/null
@@ -1,2 +0,0 @@
-Original Copyright goes to Henrik Lied (henriklied)
-Code borrowed from https://github.com/henriklied/django-twitter-oauth
diff --git a/src/social_auth/LICENSE b/src/social_auth/LICENSE
new file mode 100644
index 0000000000..ba7d4e7eb1
--- /dev/null
+++ b/src/social_auth/LICENSE
@@ -0,0 +1,27 @@
+Copyright (c) 2010-2012, Mat√≠as Aguirre
+All rights reserved.
+ 
+Redistribution and use in source and binary forms, with or without modification,
+are permitted provided that the following conditions are met:
+ 
+    1. Redistributions of source code must retain the above copyright notice,
+       this list of conditions and the following disclaimer.
+    
+    2. Redistributions in binary form must reproduce the above copyright
+       notice, this list of conditions and the following disclaimer in the
+       documentation and/or other materials provided with the distribution.
+ 
+    3. Neither the name of this project nor the names of its contributors may be
+       used to endorse or promote products derived from this software without
+       specific prior written permission.
+ 
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/src/social_auth/__init__.py b/src/social_auth/__init__.py
index 745f572d61..b6c3a33444 100644
--- a/src/social_auth/__init__.py
+++ b/src/social_auth/__init__.py
@@ -1,6 +1,5 @@
-"""
-Django-social-auth application, allows OpenId or OAuth user
-registration/authentication just adding a few configurations.
-"""
+from __future__ import absolute_import
+
 version = (0, 7, 28)
+
 __version__ = '.'.join(map(str, version))
diff --git a/src/social_auth/admin.py b/src/social_auth/admin.py
index ece3046160..98f6feb6a8 100644
--- a/src/social_auth/admin.py
+++ b/src/social_auth/admin.py
@@ -1,6 +1,8 @@
-"""Admin settings"""
+from __future__ import absolute_import
+
 from django.contrib import admin
-from social_auth.models import UserSocialAuth, Nonce, Association
+
+from social_auth.models import UserSocialAuth
 
 _User = UserSocialAuth.user_model()
 
@@ -26,18 +28,4 @@ class UserSocialAuthOption(admin.ModelAdmin):
     list_select_related = True
 
 
-class NonceOption(admin.ModelAdmin):
-    """Nonce options"""
-    list_display = ('id', 'server_url', 'timestamp', 'salt')
-    search_fields = ('server_url',)
-
-
-class AssociationOption(admin.ModelAdmin):
-    """Association options"""
-    list_display = ('id', 'server_url', 'assoc_type')
-    list_filter = ('assoc_type',)
-    search_fields = ('server_url',)
-
 admin.site.register(UserSocialAuth, UserSocialAuthOption)
-admin.site.register(Nonce, NonceOption)
-admin.site.register(Association, AssociationOption)
diff --git a/src/social_auth/backends/__init__.py b/src/social_auth/backends/__init__.py
index 60e3bfb54e..925744fd0d 100644
--- a/src/social_auth/backends/__init__.py
+++ b/src/social_auth/backends/__init__.py
@@ -9,13 +9,11 @@ Also the modules *must* define a BACKENDS dictionary with the backend name
 (which is used for URLs matching) and Auth class, otherwise it won't be
 enabled.
 """
+from __future__ import absolute_import
+
 from urllib2 import Request, HTTPError
 from urllib import urlencode
 
-from openid.consumer.consumer import Consumer, SUCCESS, CANCEL, FAILURE
-from openid.consumer.discover import DiscoveryFailure
-from openid.extensions import sreg, ax, pape
-
 from oauth2 import Consumer as OAuthConsumer, Token, Request as OAuthRequest
 
 from sentry.utils import json
@@ -28,42 +26,17 @@ from social_auth.models import UserSocialAuth
 from social_auth.utils import (
     setting, model_to_ctype, ctype_to_model, clean_partial_pipeline,
     url_add_parameters, dsa_urlopen)
-from social_auth.store import DjangoOpenIDStore
 from social_auth.exceptions import (
-    StopPipeline, AuthException, AuthFailed, AuthCanceled, AuthUnknownError,
+    StopPipeline, AuthFailed, AuthCanceled, AuthUnknownError,
     AuthTokenError, AuthMissingParameter, AuthStateMissing, AuthStateForbidden,
     NotAllowedToDisconnect, BackendError)
 from social_auth.backends.utils import build_consumer_oauth_request
 
-
-# OpenID configuration
-OLD_AX_ATTRS = [
-    ('http://schema.openid.net/contact/email', 'old_email'),
-    ('http://schema.openid.net/namePerson', 'old_fullname'),
-    ('http://schema.openid.net/namePerson/friendly', 'old_nickname')
-]
-AX_SCHEMA_ATTRS = [
-    # Request both the full name and first/last components since some
-    # providers offer one but not the other.
-    ('http://axschema.org/contact/email', 'email'),
-    ('http://axschema.org/namePerson', 'fullname'),
-    ('http://axschema.org/namePerson/first', 'first_name'),
-    ('http://axschema.org/namePerson/last', 'last_name'),
-    ('http://axschema.org/namePerson/friendly', 'nickname'),
-]
-SREG_ATTR = [
-    ('email', 'email'),
-    ('fullname', 'fullname'),
-    ('nickname', 'nickname')
-]
-OPENID_ID_FIELD = 'openid_identifier'
-SESSION_NAME = 'openid'
-
 PIPELINE = setting('SOCIAL_AUTH_PIPELINE', (
     'social_auth.backends.pipeline.social.social_auth_user',
     # Removed by default since it can be a dangerouse behavior that
     # could lead to accounts take over.
-    #'social_auth.backends.pipeline.associate.associate_by_email',
+    # 'social_auth.backends.pipeline.associate.associate_by_email',
     'social_auth.backends.pipeline.user.get_username',
     'social_auth.backends.pipeline.user.create_user',
     'social_auth.backends.pipeline.social.associate_user',
@@ -244,91 +217,6 @@ class OAuthBackend(SocialAuthBackend):
         return data
 
 
-class OpenIDBackend(SocialAuthBackend):
-    """Generic OpenID authentication backend"""
-    name = 'openid'
-
-    def get_user_id(self, details, response):
-        """Return user unique id provided by service"""
-        return response.identity_url
-
-    def values_from_response(self, response, sreg_names=None, ax_names=None):
-        """Return values from SimpleRegistration response or
-        AttributeExchange response if present.
-
-        @sreg_names and @ax_names must be a list of name and aliases
-        for such name. The alias will be used as mapping key.
-        """
-        values = {}
-
-        # Use Simple Registration attributes if provided
-        if sreg_names:
-            resp = sreg.SRegResponse.fromSuccessResponse(response)
-            if resp:
-                values.update((alias, resp.get(name) or '')
-                              for name, alias in sreg_names)
-
-        # Use Attribute Exchange attributes if provided
-        if ax_names:
-            resp = ax.FetchResponse.fromSuccessResponse(response)
-            if resp:
-                for src, alias in ax_names:
-                    name = alias.replace('old_', '')
-                    values[name] = resp.getSingle(src, '') or values.get(name)
-        return values
-
-    def get_user_details(self, response):
-        """Return user details from an OpenID request"""
-        values = {'username': '', 'email': '', 'fullname': '',
-                  'first_name': '', 'last_name': ''}
-        # update values using SimpleRegistration or AttributeExchange
-        # values
-        values.update(self.values_from_response(response,
-                                                SREG_ATTR,
-                                                OLD_AX_ATTRS +
-                                                AX_SCHEMA_ATTRS))
-
-        fullname = values.get('fullname') or ''
-        first_name = values.get('first_name') or ''
-        last_name = values.get('last_name') or ''
-
-        if not fullname and first_name and last_name:
-            fullname = first_name + ' ' + last_name
-        elif fullname:
-            try:  # Try to split name for django user storage
-                first_name, last_name = fullname.rsplit(' ', 1)
-            except ValueError:
-                last_name = fullname
-
-        values.update({
-            'fullname': fullname,
-            'first_name': first_name,
-            'last_name': last_name,
-            'username': (
-                values.get('username') or
-                (first_name.title() + last_name.title())
-            )
-        })
-        return values
-
-    def extra_data(self, user, uid, response, details):
-        """Return defined extra data names to store in extra_data field.
-        Settings will be inspected to get more values names that should be
-        stored on extra_data field. Setting name is created from current
-        backend name (all uppercase) plus _SREG_EXTRA_DATA and
-        _AX_EXTRA_DATA because values can be returned by SimpleRegistration
-        or AttributeExchange schemas.
-
-        Both list must be a value name and an alias mapping similar to
-        SREG_ATTR, OLD_AX_ATTRS or AX_SCHEMA_ATTRS
-        """
-        name = self.name.replace('-', '_').upper()
-        sreg_names = setting(name + '_SREG_EXTRA_DATA')
-        ax_names = setting(name + '_AX_EXTRA_DATA')
-        data = self.values_from_response(response, sreg_names, ax_names)
-        return data
-
-
 class BaseAuth(object):
     """Base authentication class, new authenticators should subclass
     and implement needed methods.
@@ -454,131 +342,6 @@ class BaseAuth(object):
         return uri
 
 
-class OpenIdAuth(BaseAuth):
-    """OpenId process handling"""
-    AUTH_BACKEND = OpenIDBackend
-
-    def auth_url(self):
-        """Return auth URL returned by service"""
-        openid_request = self.setup_request(self.auth_extra_arguments())
-        # Construct completion URL, including page we should redirect to
-        return_to = self.build_absolute_uri(self.redirect)
-        return openid_request.redirectURL(self.trust_root(), return_to)
-
-    def auth_html(self):
-        """Return auth HTML returned by service"""
-        openid_request = self.setup_request(self.auth_extra_arguments())
-        return_to = self.build_absolute_uri(self.redirect)
-        form_tag = {'id': 'openid_message'}
-        return openid_request.htmlMarkup(self.trust_root(), return_to,
-                                         form_tag_attrs=form_tag)
-
-    def trust_root(self):
-        """Return trust-root option"""
-        return setting('OPENID_TRUST_ROOT') or self.build_absolute_uri('/')
-
-    def continue_pipeline(self, *args, **kwargs):
-        """Continue previous halted pipeline"""
-        response = self.consumer().complete(dict(self.data.items()),
-                                            self.build_absolute_uri())
-        kwargs.update({
-            'auth': self,
-            'response': response,
-            self.AUTH_BACKEND.name: True
-        })
-        return authenticate(*args, **kwargs)
-
-    def auth_complete(self, *args, **kwargs):
-        """Complete auth process"""
-        response = self.consumer().complete(dict(self.data.items()),
-                                            self.build_absolute_uri())
-        if not response:
-            raise AuthException(self, 'OpenID relying party endpoint')
-        elif response.status == SUCCESS:
-            kwargs.update({
-                'auth': self,
-                'response': response,
-                self.AUTH_BACKEND.name: True
-            })
-            return authenticate(*args, **kwargs)
-        elif response.status == FAILURE:
-            raise AuthFailed(self, response.message)
-        elif response.status == CANCEL:
-            raise AuthCanceled(self)
-        else:
-            raise AuthUnknownError(self, response.status)
-
-    def setup_request(self, extra_params=None):
-        """Setup request"""
-        openid_request = self.openid_request(extra_params)
-        # Request some user details. Use attribute exchange if provider
-        # advertises support.
-        if openid_request.endpoint.supportsType(ax.AXMessage.ns_uri):
-            fetch_request = ax.FetchRequest()
-            # Mark all attributes as required, Google ignores optional ones
-            for attr, alias in (AX_SCHEMA_ATTRS + OLD_AX_ATTRS):
-                fetch_request.add(ax.AttrInfo(attr, alias=alias,
-                                              required=True))
-        else:
-            fetch_request = sreg.SRegRequest(optional=dict(SREG_ATTR).keys())
-        openid_request.addExtension(fetch_request)
-
-        # Add PAPE Extension for if configured
-        preferred_policies = setting(
-            'SOCIAL_AUTH_OPENID_PAPE_PREFERRED_AUTH_POLICIES')
-        preferred_level_types = setting(
-            'SOCIAL_AUTH_OPENID_PAPE_PREFERRED_AUTH_LEVEL_TYPES')
-        max_age = setting('SOCIAL_AUTH_OPENID_PAPE_MAX_AUTH_AGE')
-        if max_age is not None:
-            try:
-                max_age = int(max_age)
-            except (ValueError, TypeError):
-                max_age = None
-
-        if (max_age is not None or preferred_policies is not None
-           or preferred_level_types is not None):
-            pape_request = pape.Request(
-                preferred_auth_policies=preferred_policies,
-                max_auth_age=max_age,
-                preferred_auth_level_types=preferred_level_types
-            )
-            openid_request.addExtension(pape_request)
-
-        return openid_request
-
-    def consumer(self):
-        """Create an OpenID Consumer object for the given Django request."""
-        return Consumer(self.request.session.setdefault(SESSION_NAME, {}),
-                        DjangoOpenIDStore())
-
-    @property
-    def uses_redirect(self):
-        """Return true if openid request will be handled with redirect or
-        HTML content will be returned.
-        """
-        return self.openid_request(
-            self.auth_extra_arguments()).shouldSendRedirect()
-
-    def openid_request(self, extra_params=None):
-        """Return openid request"""
-        if not hasattr(self, '_openid_request'):
-            try:
-                self._openid_request = self.consumer().begin(
-                    url_add_parameters(self.openid_url(), extra_params)
-                )
-            except DiscoveryFailure, err:
-                raise AuthException(self, 'OpenID discovery error: %s' % err)
-        return self._openid_request
-
-    def openid_url(self):
-        """Return service provider URL.
-        This base class is generic accepting a POST parameter that specifies
-        provider URL."""
-        if OPENID_ID_FIELD not in self.data:
-            raise AuthMissingParameter(self, OPENID_ID_FIELD)
-        return self.data[OPENID_ID_FIELD]
-
-
 class BaseOAuth(BaseAuth):
     """OAuth base class"""
     SETTINGS_KEY_NAME = ''
@@ -991,8 +754,3 @@ def get_backend(name, *args, **kwargs):
             return BACKENDSCACHE[name](*args, **kwargs)
         except KeyError:
             return None
-
-
-BACKENDS = {
-    'openid': OpenIdAuth
-}
diff --git a/src/social_auth/backends/amazon.py b/src/social_auth/backends/amazon.py
deleted file mode 100644
index 1f3f5343ba..0000000000
--- a/src/social_auth/backends/amazon.py
+++ /dev/null
@@ -1,94 +0,0 @@
-import base64
-from urllib2 import Request, HTTPError
-from urllib import urlencode
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.utils import dsa_urlopen
-from social_auth.exceptions import AuthTokenError
-
-
-class AmazonBackend(OAuthBackend):
-    """Amazon OAuth2 authentication backend"""
-    name = 'amazon'
-    # Default extra data to store
-    EXTRA_DATA = [
-        ('user_id', 'user_id'),
-        ('postal_code', 'postal_code')
-    ]
-    ID_KEY = 'user_id'
-
-    def get_user_details(self, response):
-        """Return user details from amazon account"""
-        name = response.get('name') or ''
-        first_name = ''
-        last_name = ''
-        if name and ' ' in name:
-            first_name, last_name = response.get('name').split(' ', 1)
-        else:
-            first_name = name
-        return {'username': name,
-                'email': response.get('email'),
-                'fullname': name,
-                'first_name': first_name,
-                'last_name': last_name}
-
-
-class AmazonAuth(BaseOAuth2):
-    """Amazon OAuth2 support"""
-    REDIRECT_STATE = False
-    AUTH_BACKEND = AmazonBackend
-    AUTHORIZATION_URL = 'http://www.amazon.com/ap/oa'
-    ACCESS_TOKEN_URL = 'https://api.amazon.com/auth/o2/token'
-    SETTINGS_KEY_NAME = 'AMAZON_APP_ID'
-    SETTINGS_SECRET_NAME = 'AMAZON_API_SECRET'
-    SCOPE_VAR_NAME = 'AMAZON_EXTENDED_PERMISSIONS'
-    DEFAULT_SCOPE = ['profile']
-
-    @classmethod
-    def refresh_token(cls, token, redirect_uri):
-        data = cls.refresh_token_params(token)
-        data['redirect_uri'] = redirect_uri
-        request = Request(cls.ACCESS_TOKEN_URL,
-                          data=urlencode(data),
-                          headers=cls.auth_headers())
-        return cls.process_refresh_token_response(dsa_urlopen(request).read())
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Grab user profile information from amazon."""
-        url = 'https://www.amazon.com/ap/user/profile?access_token=%s' % \
-                    access_token
-        try:
-            response = simplejson.load(dsa_urlopen(Request(url)))
-        except ValueError:
-            return None
-        except HTTPError:
-            raise AuthTokenError(self)
-        else:
-            if 'Profile' in response:
-                response = {
-                    'user_id': response['Profile']['CustomerId'],
-                    'name': response['Profile']['Name'],
-                    'email': response['Profile']['PrimaryEmail']
-                }
-            return response
-
-    @classmethod
-    def auth_headers(cls):
-        return {
-            'Authorization': 'Basic %s' % base64.urlsafe_b64encode(
-                '%s:%s' % cls.get_key_and_secret()
-            )
-        }
-
-
-BACKENDS = {
-    'amazon': AmazonAuth
-}
diff --git a/src/social_auth/backends/aol.py b/src/social_auth/backends/aol.py
deleted file mode 100644
index 117e85a255..0000000000
--- a/src/social_auth/backends/aol.py
+++ /dev/null
@@ -1,28 +0,0 @@
-"""
-AOL OpenID support
-
-No extra configurations are needed to make this work.
-"""
-from social_auth.backends import OpenIdAuth, OpenIDBackend
-
-
-AOL_OPENID_URL = 'http://openid.aol.com'
-
-# Backends
-class AolBackend(OpenIDBackend):
-    """Aol OpenID authentication backend"""
-    name = 'aol'
-
-# Auth classes
-class AolAuth(OpenIdAuth):
-    """Aol OpenID authentication"""
-    AUTH_BACKEND = AolBackend
-
-    def openid_url(self):
-        """Return AOL OpenID service url"""
-        return AOL_OPENID_URL
-
-# Backend definition
-BACKENDS = {
-    'aol': AolAuth,
-}
diff --git a/src/social_auth/backends/contrib/bitbucket.py b/src/social_auth/backends/bitbucket.py
similarity index 94%
rename from src/social_auth/backends/contrib/bitbucket.py
rename to src/social_auth/backends/bitbucket.py
index 2afaef6fea..4cb4e5150c 100644
--- a/src/social_auth/backends/contrib/bitbucket.py
+++ b/src/social_auth/backends/bitbucket.py
@@ -10,6 +10,8 @@ By default username, email, token expiration time, first name and last name are
 stored in extra_data field, check OAuthBackend class for details on how to
 extend it.
 """
+from __future__ import absolute_import
+
 try:
     import json as simplejson
 except ImportError:
@@ -22,11 +24,9 @@ from social_auth.utils import dsa_urlopen
 
 # Bitbucket configuration
 BITBUCKET_SERVER = 'bitbucket.org/api/1.0'
-BITBUCKET_REQUEST_TOKEN_URL = 'https://%s/oauth/request_token' % \
-                                    BITBUCKET_SERVER
+BITBUCKET_REQUEST_TOKEN_URL = 'https://%s/oauth/request_token' % BITBUCKET_SERVER
 BITBUCKET_ACCESS_TOKEN_URL = 'https://%s/oauth/access_token' % BITBUCKET_SERVER
-BITBUCKET_AUTHORIZATION_URL = 'https://%s/oauth/authenticate' % \
-                                    BITBUCKET_SERVER
+BITBUCKET_AUTHORIZATION_URL = 'https://%s/oauth/authenticate' % BITBUCKET_SERVER
 BITBUCKET_EMAIL_DATA_URL = 'https://%s/emails/' % BITBUCKET_SERVER
 BITBUCKET_USER_DATA_URL = 'https://%s/users/' % BITBUCKET_SERVER
 
@@ -66,8 +66,10 @@ class BitbucketBackend(OAuthBackend):
         """
         token = super(BitbucketBackend, cls).tokens(instance)
         if token and 'access_token' in token:
-            token = dict(tok.split('=')
-                            for tok in token['access_token'].split('&'))
+            token = dict(
+                tok.split('=')
+                for tok in token['access_token'].split('&')
+            )
         return token
 
 
diff --git a/src/social_auth/backends/browserid.py b/src/social_auth/backends/browserid.py
deleted file mode 100644
index 17ebd33bae..0000000000
--- a/src/social_auth/backends/browserid.py
+++ /dev/null
@@ -1,92 +0,0 @@
-"""
-BrowserID support
-"""
-from urllib import urlencode
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from django.contrib.auth import authenticate
-
-from social_auth.backends import SocialAuthBackend, BaseAuth
-from social_auth.utils import log, dsa_urlopen
-from social_auth.exceptions import AuthFailed, AuthMissingParameter
-
-
-# BrowserID verification server
-BROWSER_ID_SERVER = 'https://verifier.login.persona.org/verify'
-
-
-class BrowserIDBackend(SocialAuthBackend):
-    """BrowserID authentication backend"""
-    name = 'browserid'
-
-    def get_user_id(self, details, response):
-        """Use BrowserID email as ID"""
-        return details['email']
-
-    def get_user_details(self, response):
-        """Return user details, BrowserID only provides Email."""
-        # {'status': 'okay',
-        #  'audience': 'localhost:8000',
-        #  'expires': 1328983575529,
-        #  'email': 'name@server.com',
-        #  'issuer': 'login.persona.org'}
-        email = response['email']
-        return {'username': email.split('@', 1)[0],
-                'email': email,
-                'fullname': '',
-                'first_name': '',
-                'last_name': ''}
-
-    def extra_data(self, user, uid, response, details):
-        """Return users extra data"""
-        return {
-            'audience': response['audience'],
-            'issuer': response['issuer']
-        }
-
-
-# Auth classes
-class BrowserIDAuth(BaseAuth):
-    """BrowserID authentication"""
-    AUTH_BACKEND = BrowserIDBackend
-
-    def auth_complete(self, *args, **kwargs):
-        """Completes loging process, must return user instance"""
-        if not 'assertion' in self.data:
-            raise AuthMissingParameter(self, 'assertion')
-
-        data = urlencode({
-            'assertion': self.data['assertion'],
-            'audience': self.request.get_host()
-        })
-
-        try:
-            response = simplejson.load(dsa_urlopen(BROWSER_ID_SERVER,
-                                                   data=data))
-        except ValueError:
-            log('error', 'Could not load user data from BrowserID.',
-                exc_info=True)
-        else:
-            if response.get('status') == 'failure':
-                log('debug', 'Authentication failed.')
-                raise AuthFailed(self)
-
-            kwargs.update({
-                'auth': self,
-                'response': response,
-                self.AUTH_BACKEND.name: True
-            })
-            return authenticate(*args, **kwargs)
-
-
-# Backend definition
-BACKENDS = {
-    'browserid': BrowserIDAuth
-}
diff --git a/src/social_auth/backends/contrib/__init__.py b/src/social_auth/backends/contrib/__init__.py
deleted file mode 100644
index 914e3c187e..0000000000
--- a/src/social_auth/backends/contrib/__init__.py
+++ /dev/null
@@ -1 +0,0 @@
-"""Contrib auth modules"""
diff --git a/src/social_auth/backends/contrib/angel.py b/src/social_auth/backends/contrib/angel.py
deleted file mode 100644
index 18e129198f..0000000000
--- a/src/social_auth/backends/contrib/angel.py
+++ /dev/null
@@ -1,76 +0,0 @@
-"""
-settings.py should include the following:
-
-    ANGEL_CLIENT_ID = '...'
-    ANGEL_CLIENT_SECRET = '...'
-
-Optional scope to include 'email' and/or 'messages' separated by space:
-
-    ANGEL_AUTH_EXTRA_ARGUMENTS = {'scope': 'email messages'}
-
-More information on scope can be found at https://angel.co/api/oauth/faq
-"""
-from urllib import urlencode
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.utils import dsa_urlopen
-
-
-ANGEL_SERVER = 'angel.co'
-ANGEL_AUTHORIZATION_URL = 'https://angel.co/api/oauth/authorize/'
-ANGEL_ACCESS_TOKEN_URL = 'https://angel.co/api/oauth/token/'
-ANGEL_CHECK_AUTH = 'https://api.angel.co/1/me/'
-
-
-class AngelBackend(OAuthBackend):
-    name = 'angel'
-
-    def get_user_id(self, details, response):
-        return response['id']
-
-    def get_user_details(self, response):
-        """Return user details from Angel account"""
-        username = response['angellist_url'].split('/')[-1]
-        first_name = response['name'].split(' ')[0]
-        last_name = response['name'].split(' ')[-1]
-        email = response['email']
-        return {
-            'username': username,
-            'first_name': first_name,
-            'last_name': last_name,
-            'email': email,
-        }
-
-
-class AngelAuth(BaseOAuth2):
-    """Angel OAuth mechanism"""
-    AUTHORIZATION_URL = ANGEL_AUTHORIZATION_URL
-    ACCESS_TOKEN_URL = ANGEL_ACCESS_TOKEN_URL
-    AUTH_BACKEND = AngelBackend
-    SETTINGS_KEY_NAME = 'ANGEL_CLIENT_ID'
-    SETTINGS_SECRET_NAME = 'ANGEL_CLIENT_SECRET'
-    REDIRECT_STATE = False
-    STATE_PARAMETER = False
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Loads user data from service"""
-        params = {'access_token': access_token}
-        url = ANGEL_CHECK_AUTH + '?' + urlencode(params)
-        try:
-            return simplejson.load(dsa_urlopen(url))
-        except ValueError:
-            return None
-
-
-# Backend definition
-BACKENDS = {
-    'angel': AngelAuth,
-}
diff --git a/src/social_auth/backends/contrib/appsfuel.py b/src/social_auth/backends/contrib/appsfuel.py
deleted file mode 100644
index 66a328d181..0000000000
--- a/src/social_auth/backends/contrib/appsfuel.py
+++ /dev/null
@@ -1,66 +0,0 @@
-"""
-This module is originally written: django-social-auth-appsfuel==1.0.0
-You could refer to https://github.com/AppsFuel/django-social-auth-appsfuel for issues
-
-settings.py should include the following:
-
-    APPSFUEL_CLIENT_ID = '...'
-    APPSFUEL_CLIENT_SECRET = '...'
-
-"""
-import json
-from urllib import urlencode
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.utils import dsa_urlopen
-
-
-class AppsfuelBackend(OAuthBackend):
-    name = 'appsfuel'
-
-    def get_user_id(self, details, response):
-        return response['user_id']
-
-    def get_user_details(self, response):
-        """Return user details from Appsfuel account"""
-        fullname = response.get('display_name', '')
-        email = response.get('email', '')
-        username = email.split('@')[0] if email else ''
-        return {
-            'username': username,
-            'first_name': fullname,
-            'email': email
-        }
-
-
-class AppsfuelAuth(BaseOAuth2):
-    """Appsfuel OAuth mechanism"""
-    AUTH_BACKEND = AppsfuelBackend
-    AUTHORIZATION_URL = 'http://app.appsfuel.com/content/permission'
-    ACCESS_TOKEN_URL = 'https://api.appsfuel.com/v1/live/oauth/token'
-    USER_URL = 'https://api.appsfuel.com/v1/live/user'
-    SETTINGS_KEY_NAME = 'APPSFUEL_CLIENT_ID'
-    SETTINGS_SECRET_NAME = 'APPSFUEL_CLIENT_SECRET'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Loads user data from service"""
-        params = {'access_token': access_token}
-        url = self.USER_URL + '?' + urlencode(params)
-        return json.load(dsa_urlopen(url))
-
-
-class AppsfuelSandboxBackend(AppsfuelBackend):
-    name = 'appsfuel-sandbox'
-
-
-class AppsfuelSandboxAuth(AppsfuelAuth):
-    AUTH_BACKEND = AppsfuelSandboxBackend
-    AUTHORIZATION_URL = 'https://api.appsfuel.com/v1/sandbox/choose'
-    ACCESS_TOKEN_URL = 'https://api.appsfuel.com/v1/sandbox/oauth/token'
-    USER_URL = 'https://api.appsfuel.com/v1/sandbox/user'
-
-
-# Backend definitions
-BACKENDS = {
-    'appsfuel': AppsfuelAuth,
-    'appsfuel-sandbox': AppsfuelSandboxAuth,
-}
diff --git a/src/social_auth/backends/contrib/behance.py b/src/social_auth/backends/contrib/behance.py
deleted file mode 100644
index 1af91c5886..0000000000
--- a/src/social_auth/backends/contrib/behance.py
+++ /dev/null
@@ -1,68 +0,0 @@
-"""
-Behance OAuth2 support.
-
-This contribution adds support for the Behance OAuth service. The settings
-BEHANCE_CLIENT_ID and BEHANCE_CLIENT_SECRET must be defined with the values
-given by Behance application registration process.
-
-Extended permissions are supported by defining BEHANCE_EXTENDED_PERMISSIONS
-setting, it must be a list of values to request.
-
-By default username and access_token are stored in extra_data field.
-"""
-from social_auth.backends import BaseOAuth2, OAuthBackend
-
-
-# Behance configuration
-BEHANCE_AUTHORIZATION_URL = 'https://www.behance.net/v2/oauth/authenticate'
-BEHANCE_ACCESS_TOKEN_URL = 'https://www.behance.net/v2/oauth/token'
-
-
-class BehanceBackend(OAuthBackend):
-    """Behance OAuth authentication backend"""
-    name = 'behance'
-    # Default extra data to store (in addition to access_token)
-    EXTRA_DATA = [
-        ('username', 'username'),
-    ]
-
-    def get_user_id(self, details, response):
-        return response['user']['id']
-
-    def get_user_details(self, response):
-        """Return user details from Behance account"""
-        user = response['user']
-        return {
-            'username': user['username'],
-            'last_name': user['last_name'],
-            'first_name': user['first_name'],
-            'fullname': user['display_name'],
-            'email': '',
-        }
-
-    def extra_data(self, user, uid, response, details):
-        # Pull up the embedded user attributes so they can be found as extra
-        # data. See the example token response for possible attributes:
-        # http://www.behance.net/dev/authentication#step-by-step
-        all_data = dict((name, value) for name, value in response.iteritems())
-        all_data.update(response['user'])
-        return super(BehanceBackend, self).extra_data(user, uid, all_data,
-                details)
-
-
-class BehanceAuth(BaseOAuth2):
-    """Behance OAuth2 mechanism"""
-    AUTHORIZATION_URL = BEHANCE_AUTHORIZATION_URL
-    ACCESS_TOKEN_URL = BEHANCE_ACCESS_TOKEN_URL
-    AUTH_BACKEND = BehanceBackend
-    SETTINGS_KEY_NAME = 'BEHANCE_CLIENT_ID'
-    SETTINGS_SECRET_NAME = 'BEHANCE_CLIENT_SECRET'
-    SCOPE_SEPARATOR = '|'
-    ### Look at http://www.behance.net/dev/authentication#scopes
-    SCOPE_VAR_NAME = 'BEHANCE_EXTENDED_PERMISSIONS'
-
-
-# Backend definition
-BACKENDS = {
-    'behance': BehanceAuth
-}
diff --git a/src/social_auth/backends/contrib/belgiumeid.py b/src/social_auth/backends/contrib/belgiumeid.py
deleted file mode 100644
index 9d9a8ffa9b..0000000000
--- a/src/social_auth/backends/contrib/belgiumeid.py
+++ /dev/null
@@ -1,22 +0,0 @@
-from social_auth.backends import OpenIDBackend, OpenIdAuth
-
-E_ID_OPENID_URL = 'https://www.e-contract.be/eid-idp/endpoints/openid/auth'
-
-
-class EIDBackend(OpenIDBackend):
-    """e-ID OpenID authentication backend"""
-    name = 'eID'
-
-
-class EIDAuth(OpenIdAuth):
-    """Belgium e-ID OpenID authentication"""
-    AUTH_BACKEND = EIDBackend
-
-    def openid_url(self):
-        """Return Belgium e-ID OpenID service url"""
-        return E_ID_OPENID_URL
-
-# Backend definition
-BACKENDS = {
-    'eID': EIDAuth,
-}
diff --git a/src/social_auth/backends/contrib/dailymotion.py b/src/social_auth/backends/contrib/dailymotion.py
deleted file mode 100644
index 811d682b2c..0000000000
--- a/src/social_auth/backends/contrib/dailymotion.py
+++ /dev/null
@@ -1,87 +0,0 @@
-"""
-Dailymotion OAuth2 support.
-
-This adds support for Dailymotion OAuth service. An application must
-be registered first on dailymotion and the settings DAILYMOTION_CONSUMER_KEY
-and DAILYMOTION_CONSUMER_SECRET must be defined with the corresponding
-values.
-
-User screen name is used to generate username.
-
-By default account id is stored in extra_data field, check OAuthBackend
-class for details on how to extend it.
-"""
-from urllib2 import HTTPError
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.utils import dsa_urlopen
-from social_auth.backends import BaseOAuth2
-from social_auth.backends import SocialAuthBackend
-from social_auth.exceptions import AuthCanceled
-
-
-# Dailymotion configuration
-DAILYMOTION_SERVER = 'api.dailymotion.com'
-DAILYMOTION_REQUEST_TOKEN_URL = 'https://%s/oauth/token' % DAILYMOTION_SERVER
-DAILYMOTION_ACCESS_TOKEN_URL = 'https://%s/oauth/token' % DAILYMOTION_SERVER
-# Note: oauth/authorize forces the user to authorize every time.
-#       oauth/authenticate uses their previous selection, barring revocation.
-DAILYMOTION_AUTHORIZATION_URL = 'https://%s/oauth/authorize' % \
-                                    DAILYMOTION_SERVER
-DAILYMOTION_CHECK_AUTH = 'https://%s/me/?access_token=' % DAILYMOTION_SERVER
-
-
-class DailymotionBackend(SocialAuthBackend):
-    """Dailymotion OAuth authentication backend"""
-    name = 'dailymotion'
-    EXTRA_DATA = [('id', 'id')]
-
-    def get_user_id(self, details, response):
-        """Use dailymotion username as unique id"""
-        return details['username']
-
-    def get_user_details(self, response):
-        return {'username': response['screenname']}
-
-
-class DailymotionAuth(BaseOAuth2):
-    """Dailymotion OAuth2 authentication mechanism"""
-
-    AUTHORIZATION_URL = DAILYMOTION_AUTHORIZATION_URL
-    REQUEST_TOKEN_URL = DAILYMOTION_REQUEST_TOKEN_URL
-    ACCESS_TOKEN_URL = DAILYMOTION_ACCESS_TOKEN_URL
-    AUTH_BACKEND = DailymotionBackend
-    SETTINGS_KEY_NAME = 'DAILYMOTION_OAUTH2_KEY'
-    SETTINGS_SECRET_NAME = 'DAILYMOTION_OAUTH2_SECRET'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Return user data provided"""
-        try:
-            data = dsa_urlopen(DAILYMOTION_CHECK_AUTH + access_token).read()
-            return simplejson.loads(data)
-        except (ValueError, HTTPError):
-            return None
-
-    def auth_complete(self, *args, **kwargs):
-        """Completes login process, must return user instance"""
-        if 'denied' in self.data:
-            raise AuthCanceled(self)
-        else:
-            return super(DailymotionAuth, self).auth_complete(*args, **kwargs)
-
-    def oauth_request(self, token, url, extra_params=None):
-        extra_params = extra_params or {}
-        return extra_params
-
-
-# Backend definition
-BACKENDS = {
-    'dailymotion': DailymotionAuth,
-}
diff --git a/src/social_auth/backends/contrib/disqus.py b/src/social_auth/backends/contrib/disqus.py
deleted file mode 100644
index f36febc34b..0000000000
--- a/src/social_auth/backends/contrib/disqus.py
+++ /dev/null
@@ -1,80 +0,0 @@
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.utils import dsa_urlopen, backend_setting
-from urllib import urlencode
-
-
-DISQUS_SERVER = 'disqus.com'
-DISQUS_AUTHORIZATION_URL = 'https://disqus.com/api/oauth/2.0/authorize/'
-DISQUS_ACCESS_TOKEN_URL = 'https://disqus.com/api/oauth/2.0/access_token/'
-DISQUS_CHECK_AUTH = 'https://disqus.com/api/3.0/users/details.json'
-
-
-class DisqusBackend(OAuthBackend):
-    name = 'disqus'
-
-    EXTRA_DATA = [
-        ('avatar', 'avatar'),
-        ('connections', 'connections'),
-        ('user_id', 'user_id'),
-        ('email', 'email'),
-        ('email_hash', 'emailHash'),
-        ('expires', 'expires'),
-        ('location', 'location'),
-        ('meta', 'response'),
-        ('name', 'name'),
-        ('username', 'username'),
-    ]
-
-    def get_user_id(self, details, response):
-        return response['response']['id']
-
-    def get_user_details(self, response):
-        """Return user details from Disqus account"""
-        rr = response.get('response', {})
-
-        return {
-            'username': rr.get('username', ''),
-            'user_id': response.get('user_id', ''),
-            'email': rr.get('email', ''),
-            'name': rr.get('name', ''),
-        }
-
-    def extra_data(self, user, uid, response, details):
-        meta_response = dict(response, **response.get('response', {}))
-        return super(DisqusBackend, self).extra_data(user, uid, meta_response,
-                                                     details)
-
-
-class DisqusAuth(BaseOAuth2):
-    """Disqus OAuth mechanism"""
-    AUTHORIZATION_URL = DISQUS_AUTHORIZATION_URL
-    ACCESS_TOKEN_URL = DISQUS_ACCESS_TOKEN_URL
-    AUTH_BACKEND = DisqusBackend
-    SETTINGS_KEY_NAME = 'DISQUS_CLIENT_ID'
-    SETTINGS_SECRET_NAME = 'DISQUS_CLIENT_SECRET'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Loads user data from service"""
-        params = {
-            'access_token': access_token,
-            'api_secret': backend_setting(self, self.SETTINGS_SECRET_NAME),
-        }
-        url = DISQUS_CHECK_AUTH + '?' + urlencode(params)
-        try:
-            return simplejson.load(dsa_urlopen(url))
-        except ValueError:
-            return None
-
-
-# Backend definition
-BACKENDS = {
-    'disqus': DisqusAuth,
-}
diff --git a/src/social_auth/backends/contrib/douban.py b/src/social_auth/backends/contrib/douban.py
deleted file mode 100644
index c8ef333926..0000000000
--- a/src/social_auth/backends/contrib/douban.py
+++ /dev/null
@@ -1,128 +0,0 @@
-"""
-Douban OAuth support.
-
-This adds support for Douban OAuth service. An application must
-be registered first on douban.com and the settings DOUBAN_CONSUMER_KEY
-and DOUBAN_CONSUMER_SECRET must be defined with they corresponding
-values.
-
-By default account id is stored in extra_data field, check OAuthBackend
-class for details on how to extend it.
-"""
-from urllib2 import Request
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.utils import dsa_urlopen
-from social_auth.backends import ConsumerBasedOAuth, OAuthBackend, BaseOAuth2
-from social_auth.exceptions import AuthCanceled
-
-
-DOUBAN_SERVER = 'www.douban.com'
-DOUBAN_REQUEST_TOKEN_URL = 'http://%s/service/auth/request_token' % \
-                                DOUBAN_SERVER
-DOUBAN_ACCESS_TOKEN_URL = 'http://%s/service/auth/access_token' % \
-                                DOUBAN_SERVER
-
-DOUBAN_AUTHORIZATION_URL = 'http://%s/service/auth/authorize' % \
-                                DOUBAN_SERVER
-
-
-class DoubanBackend(OAuthBackend):
-    """Douban OAuth authentication backend"""
-    name = 'douban'
-    EXTRA_DATA = [('id', 'id')]
-
-    def get_user_id(self, details, response):
-        return response['db:uid']['$t']
-
-    def get_user_details(self, response):
-        """Return user details from Douban"""
-        return {'username': response["db:uid"]["$t"],
-                'email': ''}
-
-
-class DoubanAuth(ConsumerBasedOAuth):
-    """Douban OAuth authentication mechanism"""
-    AUTHORIZATION_URL = DOUBAN_AUTHORIZATION_URL
-    REQUEST_TOKEN_URL = DOUBAN_REQUEST_TOKEN_URL
-    ACCESS_TOKEN_URL = DOUBAN_ACCESS_TOKEN_URL
-    AUTH_BACKEND = DoubanBackend
-    SETTINGS_KEY_NAME = 'DOUBAN_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'DOUBAN_CONSUMER_SECRET'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Return user data provided"""
-        url = 'http://api.douban.com/people/%40me?&alt=json'
-        request = self.oauth_request(access_token, url)
-        json = self.fetch_response(request)
-
-        try:
-            return simplejson.loads(json)
-        except ValueError:
-            return None
-
-    def auth_complete(self, *args, **kwargs):
-        """Completes login process, must return user instance"""
-        if 'denied' in self.data:
-            raise AuthCanceled(self)
-        else:
-            return super(DoubanAuth, self).auth_complete(*args, **kwargs)
-
-
-class DoubanBackend2(OAuthBackend):
-    """Douban OAuth authentication backend"""
-    name = 'douban2'
-    EXTRA_DATA = [('id', 'id'),
-            ('uid', 'username'),
-            ('refresh_token', 'refresh_token'),
-            ]
-
-    def get_user_id(self, details, response):
-        return response['id']
-
-    def get_user_details(self, response):
-        """Return user details from Douban"""
-        return {'username': response.get('uid', ''),
-                'fullname': response.get('name', ''),
-                'email': ''}
-
-
-class DoubanAuth2(BaseOAuth2):
-    """Douban OAuth authentication mechanism"""
-    AUTHORIZATION_URL = 'https://%s/service/auth2/auth' % DOUBAN_SERVER
-    ACCESS_TOKEN_URL = 'https://%s/service/auth2/token' % DOUBAN_SERVER
-    AUTH_BACKEND = DoubanBackend2
-    SETTINGS_KEY_NAME = 'DOUBAN2_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'DOUBAN2_CONSUMER_SECRET'
-    REDIRECT_STATE = False
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Return user data provided"""
-        url = 'https://api.douban.com/v2/user/~me'
-        headers = {'Authorization': 'Bearer %s' % access_token}
-        request = Request(url, headers=headers)
-        try:
-            return simplejson.loads(dsa_urlopen(request).read())
-        except (ValueError, KeyError, IOError):
-            return None
-
-    def auth_complete(self, *args, **kwargs):
-        """Completes login process, must return user instance"""
-        if 'denied' in self.data:
-            raise AuthCanceled(self)
-        else:
-            return super(DoubanAuth2, self).auth_complete(*args, **kwargs)
-
-
-# Backend definition
-BACKENDS = {
-    'douban': DoubanAuth,
-    'douban2': DoubanAuth2,  # OAuth2.0
-}
diff --git a/src/social_auth/backends/contrib/dropbox.py b/src/social_auth/backends/contrib/dropbox.py
deleted file mode 100644
index dd2ce798ac..0000000000
--- a/src/social_auth/backends/contrib/dropbox.py
+++ /dev/null
@@ -1,80 +0,0 @@
-"""
-Dropbox OAuth support.
-
-This contribution adds support for Dropbox OAuth service. The settings
-DROPBOX_APP_ID and DROPBOX_API_SECRET must be defined with the values
-given by Dropbox application registration process.
-
-By default account id and token expiration time are stored in extra_data
-field, check OAuthBackend class for details on how to extend it.
-"""
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.utils import setting
-from social_auth.backends import ConsumerBasedOAuth, OAuthBackend
-
-
-# Dropbox configuration
-DROPBOX_SERVER = 'dropbox.com'
-DROPBOX_API = 'api.%s' % DROPBOX_SERVER
-DROPBOX_REQUEST_TOKEN_URL = 'https://%s/1/oauth/request_token' % DROPBOX_API
-DROPBOX_AUTHORIZATION_URL = 'https://www.%s/1/oauth/authorize' % DROPBOX_SERVER
-DROPBOX_ACCESS_TOKEN_URL = 'https://%s/1/oauth/access_token' % DROPBOX_API
-
-
-class DropboxBackend(OAuthBackend):
-    """Dropbox OAuth authentication backend"""
-    name = 'dropbox'
-    # Default extra data to store
-    EXTRA_DATA = [
-        ('id', 'id'),
-        ('expires', 'expires')
-    ]
-
-    def get_user_details(self, response):
-        """Return user details from Dropbox account"""
-        return {'username': str(response.get('uid')),
-                'email': response.get('email'),
-                'first_name': response.get('display_name')}
-
-    def get_user_id(self, details, response):
-        """OAuth providers return an unique user id in response"""
-        # Dropbox uses a uid parameter instead of id like most others...
-        return response['uid']
-
-
-class DropboxAuth(ConsumerBasedOAuth):
-    """Dropbox OAuth authentication mechanism"""
-    AUTHORIZATION_URL = DROPBOX_AUTHORIZATION_URL
-    REQUEST_TOKEN_URL = DROPBOX_REQUEST_TOKEN_URL
-    ACCESS_TOKEN_URL = DROPBOX_ACCESS_TOKEN_URL
-    AUTH_BACKEND = DropboxBackend
-    SETTINGS_KEY_NAME = 'DROPBOX_APP_ID'
-    SETTINGS_SECRET_NAME = 'DROPBOX_API_SECRET'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Loads user data from service"""
-        url = 'https://' + DROPBOX_API + '/1/account/info'
-        request = self.oauth_request(access_token, url)
-        response = self.fetch_response(request)
-        try:
-            return simplejson.loads(response)
-        except ValueError:
-            return None
-
-    @classmethod
-    def enabled(cls):
-        """Return backend enabled status by checking basic settings"""
-        return setting('DROPBOX_APP_ID') and setting('DROPBOX_API_SECRET')
-
-
-# Backend definition
-BACKENDS = {
-    'dropbox': DropboxAuth,
-}
diff --git a/src/social_auth/backends/contrib/evernote.py b/src/social_auth/backends/contrib/evernote.py
deleted file mode 100644
index 05a1ff314e..0000000000
--- a/src/social_auth/backends/contrib/evernote.py
+++ /dev/null
@@ -1,119 +0,0 @@
-"""
-EverNote OAuth support
-
-No extra configurations are needed to make this work.
-"""
-from urllib2 import HTTPError
-try:
-    from urlparse import parse_qs
-    parse_qs  # placate pyflakes
-except ImportError:
-    # fall back for Python 2.5
-    from cgi import parse_qs
-
-from oauth2 import Token
-from social_auth.utils import setting
-from social_auth.backends import ConsumerBasedOAuth, OAuthBackend
-from social_auth.exceptions import AuthCanceled
-
-
-if setting('EVERNOTE_DEBUG', False):
-    EVERNOTE_SERVER = 'sandbox.evernote.com'
-else:
-    EVERNOTE_SERVER = 'www.evernote.com'
-
-EVERNOTE_REQUEST_TOKEN_URL = 'https://%s/oauth' % EVERNOTE_SERVER
-EVERNOTE_ACCESS_TOKEN_URL = 'https://%s/oauth' % EVERNOTE_SERVER
-EVERNOTE_AUTHORIZATION_URL = 'https://%s/OAuth.action' % EVERNOTE_SERVER
-
-
-class EvernoteBackend(OAuthBackend):
-    """
-    Evernote OAuth authentication backend.
-
-    Possible Values:
-       {'edam_expires': ['1367525289541'],
-        'edam_noteStoreUrl': [
-            'https://sandbox.evernote.com/shard/s1/notestore'
-        ],
-        'edam_shard': ['s1'],
-        'edam_userId': ['123841'],
-        'edam_webApiUrlPrefix': ['https://sandbox.evernote.com/shard/s1/'],
-        'oauth_token': [
-            'S=s1:U=1e3c1:E=13e66dbee45:C=1370f2ac245:P=185:A=my_user:' \
-            'H=411443c5e8b20f8718ed382a19d4ae38'
-        ]}
-    """
-    name = 'evernote'
-
-    EXTRA_DATA = [
-        ('access_token', 'access_token'),
-        ('oauth_token', 'oauth_token'),
-        ('edam_noteStoreUrl', 'store_url'),
-        ('edam_expires', 'expires')
-    ]
-
-    @classmethod
-    def extra_data(cls, user, uid, response, details=None):
-        data = super(EvernoteBackend, cls).extra_data(user, uid, response, details)
-        # Evernote returns expiration timestamp in miliseconds, so it needs to
-        # be normalized.
-        if 'expires' in data:
-            data['expires'] = unicode(int(data['expires']) / 1000)
-        return data
-
-    def get_user_details(self, response):
-        """Return user details from Evernote account"""
-        return {
-            'username': response['edam_userId'],
-            'email': '',
-        }
-
-    def get_user_id(self, details, response):
-        return response['edam_userId']
-
-
-class EvernoteAuth(ConsumerBasedOAuth):
-    """Evernote OAuth authentication mechanism"""
-    AUTHORIZATION_URL = EVERNOTE_AUTHORIZATION_URL
-    REQUEST_TOKEN_URL = EVERNOTE_REQUEST_TOKEN_URL
-    ACCESS_TOKEN_URL = EVERNOTE_ACCESS_TOKEN_URL
-    AUTH_BACKEND = EvernoteBackend
-    SETTINGS_KEY_NAME = 'EVERNOTE_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'EVERNOTE_CONSUMER_SECRET'
-
-    def access_token(self, token):
-        """Return request for access token value"""
-        request = self.oauth_request(token, self.ACCESS_TOKEN_URL)
-
-        try:
-            response = self.fetch_response(request)
-        except HTTPError, e:
-            # Evernote returns a 401 error when AuthCanceled
-            if e.code == 401:
-                raise AuthCanceled(self)
-            else:
-                raise
-
-        params = parse_qs(response)
-
-        # evernote sents a empty secret token, this way it doesn't fires up the
-        # exception
-        response = response.replace('oauth_token_secret=',
-                                    'oauth_token_secret=None')
-        token = Token.from_string(response)
-
-        token.user_info = params
-        return token
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Return user data provided"""
-        # drop lists
-        return dict([(key, val[0]) for key, val in
-            access_token.user_info.items()])
-
-
-# Backend definition
-BACKENDS = {
-    'evernote': EvernoteAuth,
-}
diff --git a/src/social_auth/backends/contrib/exacttarget.py b/src/social_auth/backends/contrib/exacttarget.py
deleted file mode 100644
index 51a8b1ca47..0000000000
--- a/src/social_auth/backends/contrib/exacttarget.py
+++ /dev/null
@@ -1,124 +0,0 @@
-"""
-ExactTarget OAuth support.
-Support Authentication from IMH using JWT token and pre-shared key.
-Requires package pyjwt
-"""
-import imp
-from datetime import timedelta, datetime
-from django.contrib.auth import authenticate
-
-from social_auth.utils import setting
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.exceptions import AuthFailed, AuthCanceled
-
-
-class ExactTargetBackend(OAuthBackend):
-    """ExactTarget HubExchange authentication backend"""
-    name = 'exacttarget'
-    # Default extra data to store
-    EXTRA_DATA = []
-
-    def get_user_details(self, response):
-        """Use the email address of the user, suffixed by _et"""
-        if response.get("token"):
-            token = response['token']
-            user = token.get('request', {}).get('user')
-            if user:
-                if 'email' in user:
-                    user['username'] = "%s_et" % user['email']
-                return user
-
-    def extra_data(self, user, uid, response, details):
-        """
-        Load extra details from the JWT token
-        """
-        data = {
-            'email': details.get('email'),
-            'id': details.get('id'),
-            # OAuth token, for use with legacy SOAP API calls:
-            #   http://bit.ly/13pRHfo
-            'internalOauthToken': details.get('internalOauthToken'),
-            # Token for use with the Application ClientID for the FUEL API
-            'oauthToken': details.get('oauthToken'),
-            # If the token has expired, use the FUEL API to get a new token see
-            # http://bit.ly/10v1K5l and http://bit.ly/11IbI6F - set legacy=1
-            'refreshToken': details.get('refreshToken'),
-        }
-
-        # The expiresIn value determines how long the tokens are valid for.
-        # Take a bit off, then convert to an int timestamp
-        expiresSeconds = details.get('expiresIn', 0) - 30
-        expires = datetime.utcnow() + timedelta(seconds=expiresSeconds)
-        data['expires'] = (expires - datetime(1970, 1, 1)).total_seconds()
-
-        if response.get("token"):
-            token = response['token']
-            org = token.get('request', {}).get('organization')
-            if org:
-                data['stack'] = org.get('stackKey')
-                data['enterpriseId'] = org.get('enterpriseId')
-        return data
-
-    def get_user_id(self, details, response):
-        """Create a user ID from the ET user ID"""
-        return "exacttarget_%s" % details.get('id')
-
-    def uses_redirect(self):
-        return False
-
-
-class ExactTargetAuth(BaseOAuth2):
-    """ExactTarget authentication mechanism"""
-    AUTH_BACKEND = ExactTargetBackend
-    SETTINGS_KEY_NAME = 'EXACTTARGET_UNUSED'
-    # Set this to your application signature (from code.exacttarget.com)
-    SETTINGS_SECRET_NAME = 'EXACTTARGET_APP_SIGNATURE'
-
-    def __init__(self, request, redirect):
-        super(ExactTargetAuth, self).__init__(request, redirect)
-        fp, pathname, description = imp.find_module('jwt')
-        self.jwt = imp.load_module('jwt', fp, pathname, description)
-
-    def auth_url(self):
-        return None
-
-    def auth_complete(self, *args, **kwargs):
-        """Completes login process, must return user instance"""
-
-        if self.data.get('error'):
-            error = self.data.get('error_description') or self.data['error']
-            raise AuthFailed(self, error)
-
-        token = kwargs.get('request').POST.get('jwt', {})
-
-        if not token:
-            raise AuthFailed(self, 'Authentication Failed')
-        return self.do_auth(token, *args, **kwargs)
-
-    def do_auth(self, jwt_token, *args, **kwargs):
-        dummy, client_secret = self.get_key_and_secret()
-
-        # Decode the jwt token, using the Application Signature from settings
-        try:
-            decoded = self.jwt.decode(jwt_token, client_secret)
-        except self.jwt.DecodeError:
-            raise AuthCanceled(self)  # Wrong signature, fail authentication
-
-        kwargs.update({
-            'auth': self,
-            'response': {
-            'token': decoded,
-            },
-            self.AUTH_BACKEND.name: True
-        })
-        return authenticate(*args, **kwargs)
-
-    @classmethod
-    def enabled(cls):
-        """Return backend enabled status by checking basic settings"""
-        return setting('EXACTTARGET_APP_SIGNATURE')
-
-# Backend definition
-BACKENDS = {
-    'exacttarget': ExactTargetAuth,
-}
diff --git a/src/social_auth/backends/contrib/fedora.py b/src/social_auth/backends/contrib/fedora.py
deleted file mode 100644
index 3c948b8d1b..0000000000
--- a/src/social_auth/backends/contrib/fedora.py
+++ /dev/null
@@ -1,29 +0,0 @@
-"""
-Fedora OpenID support
-
-No extra configurations are needed to make this work.
-"""
-from social_auth.backends import OpenIDBackend, OpenIdAuth
-
-
-FEDORA_OPENID_URL = 'https://id.fedoraproject.org'
-
-
-class FedoraBackend(OpenIDBackend):
-    """Fedora OpenID authentication backend"""
-    name = 'fedora'
-
-
-class FedoraAuth(OpenIdAuth):
-    """Fedora OpenID authentication"""
-    AUTH_BACKEND = FedoraBackend
-
-    def openid_url(self):
-        """Return Fedora OpenID service url"""
-        return FEDORA_OPENID_URL
-
-
-# Backend definition
-BACKENDS = {
-    'fedora': FedoraAuth,
-}
diff --git a/src/social_auth/backends/contrib/fitbit.py b/src/social_auth/backends/contrib/fitbit.py
deleted file mode 100644
index 8aec5143a1..0000000000
--- a/src/social_auth/backends/contrib/fitbit.py
+++ /dev/null
@@ -1,89 +0,0 @@
-"""
-Fitbit OAuth support.
-
-This contribution adds support for Fitbit OAuth service. The settings
-FITBIT_CONSUMER_KEY and FITBIT_CONSUMER_SECRET must be defined with the values
-given by Fitbit application registration process.
-
-By default account id, username and token expiration time are stored in
-extra_data field, check OAuthBackend class for details on how to extend it.
-"""
-try:
-    from urlparse import parse_qs
-    parse_qs  # placate pyflakes
-except ImportError:
-    # fall back for Python 2.5
-    from cgi import parse_qs
-
-from oauth2 import Token
-
-from social_auth.backends import ConsumerBasedOAuth, OAuthBackend
-
-
-# Fitbit configuration
-FITBIT_SERVER = 'https://api.fitbit.com'
-FITBIT_REQUEST_TOKEN_URL = '%s/oauth/request_token' % FITBIT_SERVER
-FITBIT_AUTHORIZATION_URL = '%s/oauth/authorize' % FITBIT_SERVER
-FITBIT_ACCESS_TOKEN_URL = '%s/oauth/access_token' % FITBIT_SERVER
-FITBIT_USERINFO = 'http://api.fitbit.com/1/user/-/profile.json'
-
-
-class FitbitBackend(OAuthBackend):
-    """Fitbit OAuth authentication backend"""
-    name = 'fitbit'
-    # Default extra data to store
-    EXTRA_DATA = [('id', 'id'),
-                  ('username', 'username'),
-                  ('expires', 'expires')]
-
-    def get_user_id(self, details, response):
-        """
-        Fitbit doesn't provide user data, it must be requested to its API:
-            https://wiki.fitbit.com/display/API/API-Get-User-Info
-        """
-        return response['id']
-
-    def get_user_details(self, response):
-        """Return user details from Fitbit account"""
-        return {'username': response.get('id'),
-                'email': '',
-                'first_name': response.get('fullname')}
-
-
-class FitbitAuth(ConsumerBasedOAuth):
-    """Fitbit OAuth authentication mechanism"""
-    AUTHORIZATION_URL = FITBIT_AUTHORIZATION_URL
-    REQUEST_TOKEN_URL = FITBIT_REQUEST_TOKEN_URL
-    ACCESS_TOKEN_URL = FITBIT_ACCESS_TOKEN_URL
-    AUTH_BACKEND = FitbitBackend
-    SETTINGS_KEY_NAME = 'FITBIT_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'FITBIT_CONSUMER_SECRET'
-
-    def access_token(self, token):
-        """Return request for access token value"""
-        # Fitbit is a bit different - it passes user information along with
-        # the access token, so temporarily store it to vie the user_data
-        # method easy access later in the flow!
-        request = self.oauth_request(token, self.ACCESS_TOKEN_URL)
-        response = self.fetch_response(request)
-        token = Token.from_string(response)
-        params = parse_qs(response)
-
-        token.encoded_user_id = params.get('encoded_user_id', [None])[0]
-        token.fullname = params.get('fullname', [None])[0]
-        token.username = params.get('username', [None])[0]
-        return token
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Loads user data from service"""
-        return {
-            'id': access_token.encoded_user_id,
-            'username': access_token.username,
-            'fullname': access_token.fullname,
-        }
-
-
-# Backend definition
-BACKENDS = {
-    'fitbit': FitbitAuth,
-}
diff --git a/src/social_auth/backends/contrib/flickr.py b/src/social_auth/backends/contrib/flickr.py
deleted file mode 100644
index 39dbb79848..0000000000
--- a/src/social_auth/backends/contrib/flickr.py
+++ /dev/null
@@ -1,92 +0,0 @@
-"""
-Flickr OAuth support.
-
-This contribution adds support for Flickr OAuth service. The settings
-FLICKR_APP_ID and FLICKR_API_SECRET must be defined with the values
-given by Flickr application registration process.
-
-By default account id, username and token expiration time are stored in
-extra_data field, check OAuthBackend class for details on how to extend it.
-"""
-try:
-    from urlparse import parse_qs
-    parse_qs  # placate pyflakes
-except ImportError:
-    # fall back for Python 2.5
-    from cgi import parse_qs
-
-from oauth2 import Token
-
-from social_auth.backends import ConsumerBasedOAuth, OAuthBackend
-
-
-# Flickr configuration
-FLICKR_SERVER = 'http://www.flickr.com/services'
-FLICKR_REQUEST_TOKEN_URL = '%s/oauth/request_token' % FLICKR_SERVER
-FLICKR_AUTHORIZATION_URL = '%s/oauth/authorize' % FLICKR_SERVER
-FLICKR_ACCESS_TOKEN_URL = '%s/oauth/access_token' % FLICKR_SERVER
-
-
-class FlickrBackend(OAuthBackend):
-    """Flickr OAuth authentication backend"""
-    name = 'flickr'
-    # Default extra data to store
-    EXTRA_DATA = [
-        ('id', 'id'),
-        ('username', 'username'),
-        ('expires', 'expires')
-    ]
-
-    def get_user_details(self, response):
-        """Return user details from Flickr account"""
-        return {'username': response.get('id'),
-                'email': '',
-                'first_name': response.get('fullname')}
-
-
-class FlickrAuth(ConsumerBasedOAuth):
-    """Flickr OAuth authentication mechanism"""
-    AUTHORIZATION_URL = FLICKR_AUTHORIZATION_URL
-    REQUEST_TOKEN_URL = FLICKR_REQUEST_TOKEN_URL
-    ACCESS_TOKEN_URL = FLICKR_ACCESS_TOKEN_URL
-    AUTH_BACKEND = FlickrBackend
-    SETTINGS_KEY_NAME = 'FLICKR_APP_ID'
-    SETTINGS_SECRET_NAME = 'FLICKR_API_SECRET'
-
-    def access_token(self, token):
-        """Return request for access token value"""
-        # Flickr is a bit different - it passes user information along with
-        # the access token, so temporarily store it to view the user_data
-        # method easy access later in the flow!
-        request = self.oauth_request(token, self.ACCESS_TOKEN_URL)
-        response = self.fetch_response(request)
-        token = Token.from_string(response)
-        params = parse_qs(response)
-
-        token.user_nsid = params['user_nsid'][0] if 'user_nsid' in params \
-                                                 else None
-        token.fullname = params['fullname'][0] if 'fullname' in params \
-                                               else None
-        token.username = params['username'][0] if 'username' in params \
-                                               else None
-        return token
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Loads user data from service"""
-        return {
-            'id': access_token.user_nsid,
-            'username': access_token.username,
-            'fullname': access_token.fullname,
-        }
-
-    def auth_extra_arguments(self):
-        params = super(FlickrAuth, self).auth_extra_arguments() or {}
-        if not 'perms' in params:
-            params['perms'] = 'read'
-        return params
-
-
-# Backend definition
-BACKENDS = {
-    'flickr': FlickrAuth,
-}
diff --git a/src/social_auth/backends/contrib/foursquare.py b/src/social_auth/backends/contrib/foursquare.py
deleted file mode 100644
index 919c37fa2c..0000000000
--- a/src/social_auth/backends/contrib/foursquare.py
+++ /dev/null
@@ -1,59 +0,0 @@
-from urllib import urlencode
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.utils import dsa_urlopen
-
-
-FOURSQUARE_SERVER = 'foursquare.com'
-FOURSQUARE_AUTHORIZATION_URL = 'https://foursquare.com/oauth2/authenticate'
-FOURSQUARE_ACCESS_TOKEN_URL = 'https://foursquare.com/oauth2/access_token'
-FOURSQUARE_CHECK_AUTH = 'https://api.foursquare.com/v2/users/self'
-
-
-class FoursquareBackend(OAuthBackend):
-    name = 'foursquare'
-
-    def get_user_id(self, details, response):
-        return response['response']['user']['id']
-
-    def get_user_details(self, response):
-        """Return user details from Foursquare account"""
-        firstName = response['response']['user']['firstName']
-        lastName = response['response']['user'].get('lastName', '')
-        email = response['response']['user']['contact']['email']
-        return {'username': firstName + ' ' + lastName,
-                'first_name': firstName,
-                'last_name': lastName,
-                'email': email}
-
-
-class FoursquareAuth(BaseOAuth2):
-    """Foursquare OAuth mechanism"""
-    AUTHORIZATION_URL = FOURSQUARE_AUTHORIZATION_URL
-    ACCESS_TOKEN_URL = FOURSQUARE_ACCESS_TOKEN_URL
-    AUTH_BACKEND = FoursquareBackend
-    SETTINGS_KEY_NAME = 'FOURSQUARE_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'FOURSQUARE_CONSUMER_SECRET'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Loads user data from service"""
-        params = {'oauth_token': access_token}
-        url = FOURSQUARE_CHECK_AUTH + '?' + urlencode(params)
-        try:
-            return simplejson.load(dsa_urlopen(url))
-        except ValueError:
-            return None
-
-
-# Backend definition
-BACKENDS = {
-    'foursquare': FoursquareAuth,
-}
diff --git a/src/social_auth/backends/contrib/gae.py b/src/social_auth/backends/contrib/gae.py
deleted file mode 100644
index 2b0a6d047f..0000000000
--- a/src/social_auth/backends/contrib/gae.py
+++ /dev/null
@@ -1,67 +0,0 @@
-"""
-Google App Engine support using User API
-
-This backend is for use of django-social-auth on top
-of Google's App Engine PaaS.
-
-This backend directly uses Google's User API that
-is available on the App Engine platform.
-"""
-from __future__ import absolute_import
-
-from google.appengine.api import users
-
-from django.contrib.auth import authenticate
-from django.core.urlresolvers import reverse
-
-from social_auth.backends import SocialAuthBackend, BaseAuth
-from social_auth.exceptions import AuthException
-
-
-class GAEBackend(SocialAuthBackend):
-    """GoogleAppengine authentication backend"""
-    name = 'google-appengine'
-
-    def get_user_id(self, details, response):
-        """Return current user id."""
-        user = users.get_current_user()
-        if user:
-            return user.user_id()
-
-    def get_user_details(self, response):
-        """Return user basic information (id and email only)."""
-        user = users.get_current_user()
-        return {'username': user.user_id(),
-                'email': user.email(),
-                'fullname': '',
-                'first_name': '',
-                'last_name': ''}
-
-
-# Auth classes
-class GAEAuth(BaseAuth):
-    """GoogleAppengine authentication"""
-    AUTH_BACKEND = GAEBackend
-
-    def auth_url(self):
-        """Build and return complete URL."""
-        return users.create_login_url(reverse('socialauth_complete',
-                                              args=(self.AUTH_BACKEND.name,)))
-
-    def auth_complete(self, *args, **kwargs):
-        """Completes login process, must return user instance."""
-        if not users.get_current_user():
-            raise AuthException('Authentication error')
-
-        # Setting these two are necessary for BaseAuth.authenticate to work
-        kwargs.update({
-            'response': '',
-            self.AUTH_BACKEND.name: True
-        })
-        return authenticate(*args, **kwargs)
-
-
-# Backend definition
-BACKENDS = {
-    'google-appengine': GAEAuth,
-}
diff --git a/src/social_auth/backends/contrib/instagram.py b/src/social_auth/backends/contrib/instagram.py
deleted file mode 100644
index c7977c9a5c..0000000000
--- a/src/social_auth/backends/contrib/instagram.py
+++ /dev/null
@@ -1,72 +0,0 @@
-from urllib import urlencode
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.utils import dsa_urlopen
-
-
-INSTAGRAM_SERVER = 'instagram.com'
-INSTAGRAM_AUTHORIZATION_URL = 'https://instagram.com/oauth/authorize'
-INSTAGRAM_ACCESS_TOKEN_URL = 'https://instagram.com/oauth/access_token'
-INSTAGRAM_CHECK_AUTH = 'https://api.instagram.com/v1/users/self'
-
-
-class InstagramBackend(OAuthBackend):
-    name = 'instagram'
-
-    @classmethod
-    def extra_data(cls, user, uid, response, details=None):
-        """Return access_token and extra defined names to store in
-        extra_data field"""
-        data = super(InstagramBackend, cls).extra_data(user, uid, response,
-                                                       details)
-        try:
-            data['username'] = response['user']['username']
-        except KeyError:
-            pass
-        return data
-
-    def get_user_id(self, details, response):
-        return response['user']['id']
-
-    def get_user_details(self, response):
-        """Return user details from Instagram account"""
-        username = response['user']['username']
-        fullname = response['user'].get('full_name', '')
-        email = response['user'].get('email', '')
-        return {
-            'username': username,
-            'first_name': fullname,
-            'email': email
-        }
-
-
-class InstagramAuth(BaseOAuth2):
-    """Instagram OAuth mechanism"""
-    AUTHORIZATION_URL = INSTAGRAM_AUTHORIZATION_URL
-    ACCESS_TOKEN_URL = INSTAGRAM_ACCESS_TOKEN_URL
-    AUTH_BACKEND = InstagramBackend
-    SETTINGS_KEY_NAME = 'INSTAGRAM_CLIENT_ID'
-    SETTINGS_SECRET_NAME = 'INSTAGRAM_CLIENT_SECRET'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Loads user data from service"""
-        params = {'access_token': access_token}
-        url = INSTAGRAM_CHECK_AUTH + '?' + urlencode(params)
-        try:
-            return simplejson.load(dsa_urlopen(url))
-        except ValueError:
-            return None
-
-
-# Backend definition
-BACKENDS = {
-    'instagram': InstagramAuth,
-}
diff --git a/src/social_auth/backends/contrib/jawbone.py b/src/social_auth/backends/contrib/jawbone.py
deleted file mode 100644
index 90f263fe64..0000000000
--- a/src/social_auth/backends/contrib/jawbone.py
+++ /dev/null
@@ -1,82 +0,0 @@
-from urllib2 import Request, urlopen
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.exceptions import AuthCanceled, AuthUnknownError
-
-
-# Jawbone configuration
-JAWBONE_SERVER = 'https://jawbone.com/'
-JAWBONE_AUTHORIZATION_URL = '%s/auth/oauth2/auth' % JAWBONE_SERVER
-JAWBONE_ACCESS_TOKEN_URL = '%s/auth/oauth2/token' % JAWBONE_SERVER
-JAWBONE_CHECK_AUTH = '%s/nudge/api/users/@me' % JAWBONE_SERVER
-
-
-class JawboneBackend(OAuthBackend):
-    name = 'jawbone'
-
-    def get_user_id(self, details, response):
-        return response['data']['xid']
-
-    def get_user_details(self, response):
-        """Return user details from Jawbone account"""
-        firstName = response['data'].get('first', '')
-        lastName = response['data'].get('last', '')
-        dob = response['data'].get('dob', '')
-        gender = response['data'].get('gender', '')
-        height = response['data'].get('height', '')
-        weight = response['data'].get('weight', '')
-
-        return {'username': firstName + ' ' + lastName,
-                'first_name': firstName,
-                'last_name': lastName,
-                'dob': dob,
-                'gender': gender,
-                'height': height,
-                'weight': weight}
-
-
-class JawboneAuth(BaseOAuth2):
-    """Jawbone OAuth mechanism"""
-    AUTHORIZATION_URL = JAWBONE_AUTHORIZATION_URL
-    ACCESS_TOKEN_URL = JAWBONE_ACCESS_TOKEN_URL
-    SERVER_URL = JAWBONE_SERVER
-    AUTH_BACKEND = JawboneBackend
-    SETTINGS_KEY_NAME = 'JAWBONE_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'JAWBONE_CONSUMER_SECRET'
-    SCOPE_SEPARATOR = ' '
-    # Look at http://developer.github.com/v3/oauth/
-    SCOPE_VAR_NAME = 'JAWBONE_EXTENDED_PERMISSIONS'
-    REDIRECT_STATE = False
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Loads user data from service"""
-        url = JAWBONE_CHECK_AUTH
-        headers = {'Authorization': 'Bearer ' + access_token}
-        request = Request(url, headers=headers)
-        try:
-            return simplejson.load(urlopen(request))
-        except ValueError:
-            return None
-
-    def process_error(self, data):
-        error = self.request.GET.get('error', '')
-        if error:
-            if error == 'access_denied':
-                raise AuthCanceled(self)
-            else:
-                raise AuthUnknownError(self, 'Jawbone error was %s' % error)
-        return super(JawboneAuth, self).process_error(data)
-
-
-# Backend definition
-BACKENDS = {
-    'jawbone': JawboneAuth,
-}
diff --git a/src/social_auth/backends/contrib/linkedin.py b/src/social_auth/backends/contrib/linkedin.py
deleted file mode 100644
index 420bc25258..0000000000
--- a/src/social_auth/backends/contrib/linkedin.py
+++ /dev/null
@@ -1,200 +0,0 @@
-from django.utils.translation import get_language
-"""
-Linkedin OAuth support
-
-No extra configurations are needed to make this work.
-"""
-from xml.etree import ElementTree
-from xml.parsers.expat import ExpatError
-
-from urllib import urlencode
-from urllib2 import Request
-from oauth2 import Token
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.utils import setting, dsa_urlopen
-from social_auth.backends import ConsumerBasedOAuth, OAuthBackend, BaseOAuth2
-from social_auth.exceptions import AuthCanceled, AuthUnknownError
-
-
-LINKEDIN_SERVER = 'linkedin.com'
-LINKEDIN_REQUEST_TOKEN_URL = 'https://api.%s/uas/oauth/requestToken' % \
-                                    LINKEDIN_SERVER
-LINKEDIN_ACCESS_TOKEN_URL = 'https://api.%s/uas/oauth/accessToken' % \
-                                    LINKEDIN_SERVER
-LINKEDIN_AUTHORIZATION_URL = 'https://www.%s/uas/oauth/authenticate' % \
-                                    LINKEDIN_SERVER
-LINKEDIN_CHECK_AUTH = 'https://api.%s/v1/people/~' % LINKEDIN_SERVER
-# Check doc at http://developer.linkedin.com/docs/DOC-1014 about how to use
-# fields selectors to retrieve extra user data
-LINKEDIN_FIELD_SELECTORS = ['id', 'first-name', 'last-name']
-
-
-def add_language_header(request):
-    language = setting('LINKEDIN_FORCE_PROFILE_LANGUAGE', False)
-    if language is True:
-        request.add_header('Accept-Language', get_language())
-    elif language:
-        request.add_header('Accept-Language', language)
-
-
-class LinkedinBackend(OAuthBackend):
-    """Linkedin OAuth authentication backend"""
-    name = 'linkedin'
-    EXTRA_DATA = [('id', 'id'),
-                  ('first-name', 'first_name'),
-                  ('last-name', 'last_name')]
-
-    def get_user_details(self, response):
-        """Return user details from Linkedin account"""
-        first_name, last_name = response['first-name'], response['last-name']
-        email = response.get('email-address', '')
-        return {'username': first_name + last_name,
-                'fullname': first_name + ' ' + last_name,
-                'first_name': first_name,
-                'last_name': last_name,
-                'email': email}
-
-    @classmethod
-    def tokens(cls, instance):
-        """ Return list of OAuth v1 tokens from Linkedin  """
-        token = super(LinkedinBackend, cls).tokens(instance)
-        if token and 'access_token' in token:
-            token = dict(tok.split('=')
-                            for tok in token['access_token'].split('&'))
-        return token
-
-
-class LinkedinOAuth2Backend(OAuthBackend):
-    """Linkedin OAuth2 authentication backend"""
-    name = 'linkedin-oauth2'
-
-    EXTRA_DATA = [('id', 'id'),
-                  ('firstName', 'first_name'),
-                  ('lastName', 'last_name')]
-
-    def get_user_details(self, response):
-        first_name, last_name = response['firstName'], response['lastName']
-        return {'username': first_name + last_name,
-                'fullname': first_name + ' ' + last_name,
-                'first_name': first_name,
-                'last_name': last_name,
-                'email': response.get('emailAddress', '')}
-
-
-class LinkedinAuth(ConsumerBasedOAuth):
-    """Linkedin OAuth authentication mechanism"""
-    AUTHORIZATION_URL = LINKEDIN_AUTHORIZATION_URL
-    REQUEST_TOKEN_URL = LINKEDIN_REQUEST_TOKEN_URL
-    ACCESS_TOKEN_URL = LINKEDIN_ACCESS_TOKEN_URL
-    AUTH_BACKEND = LinkedinBackend
-    SETTINGS_KEY_NAME = 'LINKEDIN_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'LINKEDIN_CONSUMER_SECRET'
-    SCOPE_VAR_NAME = 'LINKEDIN_SCOPE'
-    SCOPE_SEPARATOR = '+'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Return user data provided"""
-        fields_selectors = LINKEDIN_FIELD_SELECTORS + \
-                           setting('LINKEDIN_EXTRA_FIELD_SELECTORS', [])
-        # use set() over fields_selectors since LinkedIn fails when values are
-        # duplicated
-        url = LINKEDIN_CHECK_AUTH + ':(%s)' % ','.join(set(fields_selectors))
-        request = self.oauth_request(access_token, url)
-        add_language_header(request)
-        raw_xml = self.fetch_response(request)
-        try:
-            return to_dict(ElementTree.fromstring(raw_xml))
-        except (ExpatError, KeyError, IndexError):
-            return None
-
-    def auth_complete(self, *args, **kwargs):
-        """Complete auth process. Check LinkedIn error response."""
-        oauth_problem = self.request.GET.get('oauth_problem')
-        if oauth_problem:
-            if oauth_problem == 'user_refused':
-                raise AuthCanceled(self, '')
-            else:
-                raise AuthUnknownError(self, 'LinkedIn error was %s' %
-                                                    oauth_problem)
-        return super(LinkedinAuth, self).auth_complete(*args, **kwargs)
-
-    def get_scope(self):
-        """Return list with needed access scope"""
-        scope = []
-        if self.SCOPE_VAR_NAME:
-            scope = setting(self.SCOPE_VAR_NAME, [])
-        else:
-            scope = []
-        return scope
-
-    def unauthorized_token(self):
-        """Makes first request to oauth. Returns an unauthorized Token."""
-        request_token_url = self.REQUEST_TOKEN_URL
-        scope = self.get_scope()
-        if scope:
-            qs = 'scope=' + self.SCOPE_SEPARATOR.join(scope)
-            request_token_url = request_token_url + '?' + qs
-
-        request = self.oauth_request(
-            token=None,
-            url=request_token_url,
-            extra_params=self.request_token_extra_arguments()
-        )
-        response = self.fetch_response(request)
-        return Token.from_string(response)
-
-
-class LinkedinOAuth2(BaseOAuth2):
-    AUTH_BACKEND = LinkedinOAuth2Backend
-    AUTHORIZATION_URL = 'https://www.linkedin.com/uas/oauth2/authorization'
-    ACCESS_TOKEN_URL = 'https://www.linkedin.com/uas/oauth2/accessToken'
-    SETTINGS_KEY_NAME = 'LINKEDIN_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'LINKEDIN_CONSUMER_SECRET'
-    SCOPE_VAR_NAME = 'LINKEDIN_SCOPE'
-    REDIRECT_STATE = False
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Return user data provided"""
-        fields_selectors = LINKEDIN_FIELD_SELECTORS + \
-                           setting('LINKEDIN_EXTRA_FIELD_SELECTORS', [])
-        url = LINKEDIN_CHECK_AUTH + ':(%s)' % ','.join(set(fields_selectors))
-        data = {'oauth2_access_token': access_token, 'format': 'json'}
-        request = Request(url + '?' + urlencode(data))
-        add_language_header(request)
-        try:
-            return simplejson.loads(dsa_urlopen(request).read())
-        except (ExpatError, KeyError, IndexError):
-            return None
-
-
-def to_dict(xml):
-    """Convert XML structure to dict recursively, repeated keys entries
-    are returned as in list containers."""
-    children = xml.getchildren()
-    if not children:
-        return xml.text
-    else:
-        out = {}
-        for node in xml.getchildren():
-            if node.tag in out:
-                if not isinstance(out[node.tag], list):
-                    out[node.tag] = [out[node.tag]]
-                out[node.tag].append(to_dict(node))
-            else:
-                out[node.tag] = to_dict(node)
-        return out
-
-
-# Backend definition
-BACKENDS = {
-    'linkedin': LinkedinAuth,
-    'linkedin-oauth2': LinkedinOAuth2,
-}
diff --git a/src/social_auth/backends/contrib/live.py b/src/social_auth/backends/contrib/live.py
deleted file mode 100644
index 56781fecf6..0000000000
--- a/src/social_auth/backends/contrib/live.py
+++ /dev/null
@@ -1,94 +0,0 @@
-"""
-MSN Live Connect oAuth 2.0
-
-Settings:
-LIVE_CLIENT_ID
-LIVE_CLIENT_SECRET
-LIVE_EXTENDED_PERMISSIONS (defaults are: wl.basic, wl.emails)
-
-References:
-* oAuth  http://msdn.microsoft.com/en-us/library/live/hh243649.aspx
-* Scopes http://msdn.microsoft.com/en-us/library/live/hh243646.aspx
-* REST   http://msdn.microsoft.com/en-us/library/live/hh243648.aspx
-
-Throws:
-AuthUnknownError - if user data retrieval fails
-"""
-from urllib import urlencode
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.utils import dsa_urlopen
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.exceptions import AuthUnknownError
-
-
-# Live Connect configuration
-LIVE_AUTHORIZATION_URL = 'https://login.live.com/oauth20_authorize.srf'
-LIVE_ACCESS_TOKEN_URL = 'https://login.live.com/oauth20_token.srf'
-LIVE_USER_DATA_URL = 'https://apis.live.net/v5.0/me'
-LIVE_SERVER = 'live.com'
-LIVE_DEFAULT_PERMISSIONS = ['wl.basic', 'wl.emails']
-
-
-class LiveBackend(OAuthBackend):
-    name = 'live'
-
-    EXTRA_DATA = [
-        ('id', 'id'),
-        ('access_token', 'access_token'),
-        ('reset_token', 'reset_token'),
-        ('expires', 'expires'),
-        ('email', 'email'),
-        ('first_name', 'first_name'),
-        ('last_name', 'last_name'),
-    ]
-
-    def get_user_id(self, details, response):
-        return response['id']
-
-    def get_user_details(self, response):
-        """Return user details from Live Connect account"""
-        try:
-            email = response['emails']['account']
-        except KeyError:
-            email = ''
-
-        return {'username': response.get('name'),
-                'email': email,
-                'first_name': response.get('first_name'),
-                'last_name': response.get('last_name')}
-
-
-class LiveAuth(BaseOAuth2):
-    AUTHORIZATION_URL = LIVE_AUTHORIZATION_URL
-    ACCESS_TOKEN_URL = LIVE_ACCESS_TOKEN_URL
-    AUTH_BACKEND = LiveBackend
-    SETTINGS_KEY_NAME = 'LIVE_CLIENT_ID'
-    SETTINGS_SECRET_NAME = 'LIVE_CLIENT_SECRET'
-    SCOPE_SEPARATOR = ','
-    SCOPE_VAR_NAME = 'LIVE_EXTENDED_PERMISSIONS'
-    DEFAULT_SCOPE = LIVE_DEFAULT_PERMISSIONS
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Loads user data from service"""
-        url = LIVE_USER_DATA_URL + '?' + urlencode({
-            'access_token': access_token
-        })
-        try:
-            return simplejson.load(dsa_urlopen(url))
-        except (ValueError, IOError):
-            raise AuthUnknownError('Error during profile retrieval, '
-                                   'please, try again later')
-
-
-# Backend definition
-BACKENDS = {
-    'live': LiveAuth,
-}
diff --git a/src/social_auth/backends/contrib/livejournal.py b/src/social_auth/backends/contrib/livejournal.py
deleted file mode 100644
index c1bbf2932a..0000000000
--- a/src/social_auth/backends/contrib/livejournal.py
+++ /dev/null
@@ -1,49 +0,0 @@
-"""
-LiveJournal OpenID support.
-
-This contribution adds support for LiveJournal OpenID service in the form
-username.livejournal.com. Username is retrieved from the identity url.
-"""
-import urlparse
-
-from social_auth.backends import OpenIDBackend, OpenIdAuth
-from social_auth.exceptions import AuthMissingParameter
-
-
-# LiveJournal conf
-LIVEJOURNAL_URL = 'http://%s.livejournal.com'
-LIVEJOURNAL_USER_FIELD = 'openid_lj_user'
-
-
-class LiveJournalBackend(OpenIDBackend):
-    """LiveJournal OpenID authentication backend"""
-    name = 'livejournal'
-
-    def get_user_details(self, response):
-        """Generate username from identity url"""
-        values = super(LiveJournalBackend, self).get_user_details(response)
-        values['username'] = values.get('username') or \
-                             urlparse.urlsplit(response.identity_url)\
-                                   .netloc.split('.', 1)[0]
-        return values
-
-
-class LiveJournalAuth(OpenIdAuth):
-    """LiveJournal OpenID authentication"""
-    AUTH_BACKEND = LiveJournalBackend
-
-    def uses_redirect(self):
-        """LiveJournal uses redirect"""
-        return True
-
-    def openid_url(self):
-        """Returns LiveJournal authentication URL"""
-        if not self.data.get(LIVEJOURNAL_USER_FIELD):
-            raise AuthMissingParameter(self, LIVEJOURNAL_USER_FIELD)
-        return LIVEJOURNAL_URL % self.data[LIVEJOURNAL_USER_FIELD]
-
-
-# Backend definition
-BACKENDS = {
-    'livejournal': LiveJournalAuth,
-}
diff --git a/src/social_auth/backends/contrib/mailru.py b/src/social_auth/backends/contrib/mailru.py
deleted file mode 100644
index 55b1f8930a..0000000000
--- a/src/social_auth/backends/contrib/mailru.py
+++ /dev/null
@@ -1,110 +0,0 @@
-"""
-Mail.ru OAuth2 support
-
-Take a look to http://api.mail.ru/docs/guides/oauth/
-
-You need to register OAuth site here:
-http://api.mail.ru/sites/my/add
-
-Then update your settings values using registration information
-
-"""
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from django.conf import settings
-
-from urllib import urlencode, unquote
-from urllib2 import Request, HTTPError
-from hashlib import md5
-
-from social_auth.backends import OAuthBackend, BaseOAuth2
-from social_auth.exceptions import AuthCanceled
-from social_auth.utils import setting, log, dsa_urlopen
-
-MAILRU_API_URL = 'http://www.appsmail.ru/platform/api'
-MAILRU_OAUTH2_SCOPE = ['']
-
-
-class MailruBackend(OAuthBackend):
-    """Mail.ru authentication backend"""
-    name = 'mailru-oauth2'
-    EXTRA_DATA = [('refresh_token', 'refresh_token'),
-                  ('expires_in', 'expires')]
-
-    def get_user_id(self, details, response):
-        """Return user unique id provided by Mail.ru"""
-        return response['uid']
-
-    def get_user_details(self, response):
-        """Return user details from Mail.ru request"""
-        values = {
-            'username': unquote(response['nick']),
-            'email': unquote(response['email']),
-            'first_name': unquote(response['first_name']),
-            'last_name': unquote(response['last_name'])
-        }
-
-        if values['first_name'] and values['last_name']:
-            values['fullname'] = '%s %s' % (values['first_name'],
-                                            values['last_name'])
-        return values
-
-
-class MailruOAuth2(BaseOAuth2):
-    """Mail.ru OAuth2 support"""
-    AUTH_BACKEND = MailruBackend
-    AUTHORIZATION_URL = 'https://connect.mail.ru/oauth/authorize'
-    ACCESS_TOKEN_URL = 'https://connect.mail.ru/oauth/token'
-    SETTINGS_KEY_NAME = 'MAILRU_OAUTH2_CLIENT_KEY'
-    SETTINGS_SECRET_NAME = 'MAILRU_OAUTH2_CLIENT_SECRET'
-
-    def get_scope(self):
-        return setting('MAILRU_OAUTH2_EXTRA_SCOPE', [])
-
-    def auth_complete(self, *args, **kwargs):
-        try:
-            return super(MailruOAuth2, self).auth_complete(*args, **kwargs)
-        except HTTPError:  # Mail.ru returns HTTPError 400 if cancelled
-            raise AuthCanceled(self)
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Return user data from Mail.ru REST API"""
-        data = {'method': 'users.getInfo', 'session_key': access_token}
-        return mailru_api(data)[0]
-
-
-def mailru_sig(data):
-    """ Calculates signature of request data """
-    param_list = sorted(list(item + '=' + data[item] for item in data))
-    return md5(''.join(param_list) +
-               settings.MAILRU_OAUTH2_CLIENT_SECRET).hexdigest()
-
-
-def mailru_api(data):
-    """ Calls Mail.ru REST API method
-        http://api.mail.ru/docs/guides/restapi/
-    """
-    data.update({'app_id': settings.MAILRU_OAUTH2_CLIENT_KEY, 'secure': '1'})
-    data['sig'] = mailru_sig(data)
-
-    params = urlencode(data)
-    request = Request(MAILRU_API_URL, params)
-    try:
-        return simplejson.loads(dsa_urlopen(request).read())
-    except (TypeError, KeyError, IOError, ValueError, IndexError):
-        log('error', 'Could not load data from Mail.ru.',
-            exc_info=True, extra=dict(data=params))
-        return None
-
-
-# Backend definition
-BACKENDS = {
-    'mailru-oauth2': MailruOAuth2
-}
diff --git a/src/social_auth/backends/contrib/mendeley.py b/src/social_auth/backends/contrib/mendeley.py
deleted file mode 100644
index f0b94267e3..0000000000
--- a/src/social_auth/backends/contrib/mendeley.py
+++ /dev/null
@@ -1,68 +0,0 @@
-"""
-Mendeley OAuth support
-
-No extra configurations are needed to make this work.
-"""
-from social_auth.backends import ConsumerBasedOAuth, OAuthBackend
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-MENDELEY_SERVER = 'mendeley.com'
-MENDELEY_REQUEST_TOKEN_URL = 'http://api.%s/oauth/request_token/' % \
-                                    MENDELEY_SERVER
-MENDELEY_ACCESS_TOKEN_URL = 'http://api.%s/oauth/access_token/' % \
-                                    MENDELEY_SERVER
-MENDELEY_AUTHORIZATION_URL = 'http://api.%s/oauth/authorize/' % \
-                                    MENDELEY_SERVER
-MENDELEY_CHECK_AUTH = 'http://api.%s/oapi/profiles/info/' % MENDELEY_SERVER
-
-MENDELEY_FIELD_SELECTORS = ['profile_id', 'name', 'bio']
-
-
-class MendeleyBackend(OAuthBackend):
-    name = 'mendeley'
-    EXTRA_DATA = [('profile_id', 'profile_id'),
-                  ('name', 'name'),
-                  ('bio', 'bio')]
-
-    def get_user_id(self, details, response):
-        return response['main']['profile_id']
-
-    def get_user_details(self, response):
-        """Return user details from Mendeley account"""
-        profile_id = response['main']['profile_id']
-        name = response['main']['name']
-        bio = response['main']['bio']
-        return {'profile_id': profile_id,
-                'name': name,
-                'bio': bio}
-
-
-class MendeleyAuth(ConsumerBasedOAuth):
-    """Mendeley OAuth authentication mechanism"""
-    AUTHORIZATION_URL = MENDELEY_AUTHORIZATION_URL
-    REQUEST_TOKEN_URL = MENDELEY_REQUEST_TOKEN_URL
-    ACCESS_TOKEN_URL = MENDELEY_ACCESS_TOKEN_URL
-    AUTH_BACKEND = MendeleyBackend
-    SETTINGS_KEY_NAME = 'MENDELEY_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'MENDELEY_CONSUMER_SECRET'
-    SCOPE_VAR_NAME = 'MENDELEY_SCOPE'
-    SCOPE_SEPARATOR = '+'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Return user data provided"""
-        url = MENDELEY_CHECK_AUTH + 'me/'
-        request = self.oauth_request(access_token, url)
-        data = simplejson.loads(self.fetch_response(request))
-        data.update(data['main'])
-        return data
-
-BACKENDS = {
-    'mendeley': MendeleyAuth,
-}
diff --git a/src/social_auth/backends/contrib/mixcloud.py b/src/social_auth/backends/contrib/mixcloud.py
deleted file mode 100644
index d1673d8a3c..0000000000
--- a/src/social_auth/backends/contrib/mixcloud.py
+++ /dev/null
@@ -1,58 +0,0 @@
-"""
-Mixcloud OAuth2 support
-"""
-from urllib import urlencode
-from urllib2 import Request
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.utils import dsa_urlopen
-
-
-MIXCLOUD_PROFILE_URL = 'https://api.mixcloud.com/me/'
-
-
-class MixcloudBackend(OAuthBackend):
-    name = 'mixcloud'
-
-    def get_user_id(self, details, response):
-        return response['username']
-
-    def get_user_details(self, response):
-        return {'username': response['username'],
-                'email': None,
-                'fullname': response['name'],
-                'first_name': None,
-                'last_name': None}
-
-
-class MixcloudOAuth2(BaseOAuth2):
-    AUTH_BACKEND = MixcloudBackend
-    AUTHORIZATION_URL = 'https://www.mixcloud.com/oauth/authorize'
-    ACCESS_TOKEN_URL = 'https://www.mixcloud.com/oauth/access_token'
-    SETTINGS_KEY_NAME = 'MIXCLOUD_CLIENT_ID'
-    SETTINGS_SECRET_NAME = 'MIXCLOUD_CLIENT_SECRET'
-
-    def user_data(self, access_token, *args, **kwargs):
-        return mixcloud_profile(access_token)
-
-
-def mixcloud_profile(access_token):
-    data = {'access_token': access_token, 'alt': 'json'}
-    request = Request(MIXCLOUD_PROFILE_URL + '?' + urlencode(data))
-    try:
-        return simplejson.loads(dsa_urlopen(request).read())
-    except (ValueError, KeyError, IOError):
-        return None
-
-
-BACKENDS = {
-    'mixcloud': MixcloudOAuth2,
-}
diff --git a/src/social_auth/backends/contrib/odnoklassniki.py b/src/social_auth/backends/contrib/odnoklassniki.py
deleted file mode 100644
index f2347e4b6a..0000000000
--- a/src/social_auth/backends/contrib/odnoklassniki.py
+++ /dev/null
@@ -1,277 +0,0 @@
-"""
-Odnoklassniki.ru OAuth2 and IFRAME application support
-If you are using OAuth2 authentication,
-    * Take a look to:
-        http://dev.odnoklassniki.ru/wiki/display/ok/The+OAuth+2.0+Protocol
-    * You need to register OAuth application here:
-        http://dev.odnoklassniki.ru/wiki/pages/viewpage.action?pageId=13992188
-elif you're building iframe application,
-    * Take a look to:
-        http://dev.odnoklassniki.ru/wiki/display/ok/
-                Odnoklassniki.ru+Third+Party+Platform
-    * You need to register your iframe application here:
-        http://dev.odnoklassniki.ru/wiki/pages/viewpage.action?pageId=5668937
-    * You need to sign a public offer and do some bureaucracy if you want to be
-      listed in application registry
-Then setup your application according manual and use information from
-registration mail to set settings values.
-"""
-from urllib import urlencode, unquote
-from urllib2 import Request
-from hashlib import md5
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from django import forms
-from django.contrib.auth import authenticate
-
-from social_auth.backends import OAuthBackend, BaseOAuth2, BaseAuth, \
-                                 SocialAuthBackend
-from social_auth.exceptions import AuthFailed
-from social_auth.utils import log, dsa_urlopen, backend_setting
-
-
-ODNOKLASSNIKI_API_SERVER = 'http://api.odnoklassniki.ru/'
-
-
-class OdnoklassnikiBackend(OAuthBackend):
-    '''Odnoklassniki authentication backend'''
-    name = 'odnoklassniki'
-    EXTRA_DATA = [('refresh_token', 'refresh_token'),
-                  ('expires_in', 'expires')]
-
-    def get_user_id(self, details, response):
-        '''Return user unique id provided by Odnoklassniki'''
-        return response['uid']
-
-    def get_user_details(self, response):
-        '''Return user details from Odnoklassniki request'''
-        return {
-            'username': response['uid'],
-            'email': '',
-            'fullname': unquote(response['name']),
-            'first_name': unquote(response['first_name']),
-            'last_name': unquote(response['last_name'])
-        }
-
-
-class OdnoklassnikiMixin(object):
-    def get_settings(self):
-        client_key = backend_setting(self, self.SETTINGS_KEY_NAME)
-        client_secret = backend_setting(self, self.SETTINGS_SECRET_NAME)
-        public_key = backend_setting(self, self.SETTINGS_PUBLIC_NAME)
-        return client_key, client_secret, public_key
-
-
-class OdnoklassnikiOAuth2(BaseOAuth2, OdnoklassnikiMixin):
-    '''Odnoklassniki OAuth2 support'''
-    AUTH_BACKEND = OdnoklassnikiBackend
-    AUTHORIZATION_URL = 'http://www.odnoklassniki.ru/oauth/authorize'
-    ACCESS_TOKEN_URL = 'http://api.odnoklassniki.ru/oauth/token.do'
-    SETTINGS_KEY_NAME = 'ODNOKLASSNIKI_OAUTH2_CLIENT_KEY'
-    SETTINGS_SECRET_NAME = 'ODNOKLASSNIKI_OAUTH2_CLIENT_SECRET'
-    SETTINGS_PUBLIC_NAME = 'ODNOKLASSNIKI_OAUTH2_APP_KEY'
-
-    def get_scope(self):
-        return backend_setting(self, 'ODNOKLASSNIKI_OAUTH2_EXTRA_SCOPE', [])
-
-    def user_data(self, access_token, *args, **kwargs):
-        '''Return user data from Odnoklassniki REST API'''
-        data = {'access_token': access_token, 'method': 'users.getCurrentUser'}
-        client_key, client_secret, public_key = self.get_settings()
-        return odnoklassniki_api(data, ODNOKLASSNIKI_API_SERVER, public_key,
-                                 client_secret, 'oauth')
-
-
-def odnoklassniki_oauth_sig(data, client_secret):
-    '''Calculates signature of request data access_token value must be included
-    Algorithm is described at
-        http://dev.odnoklassniki.ru/wiki/pages/viewpage.action?pageId=12878032,
-    search for "little bit different way"
-    '''
-    suffix = md5('{0:s}{1:s}'.format(data['access_token'],
-                                     client_secret)).hexdigest()
-    check_list = sorted(['{0:s}={1:s}'.format(key, value)
-                            for key, value in data.items()
-                                if key != 'access_token'])
-    return md5(''.join(check_list) + suffix).hexdigest()
-
-
-def odnoklassniki_iframe_sig(data, client_secret_or_session_secret):
-    '''Calculates signature as described at:
-        http://dev.odnoklassniki.ru/wiki/display/ok/
-            Authentication+and+Authorization
-    If API method requires session context, request is signed with session
-    secret key. Otherwise it is signed with application secret key
-    '''
-    param_list = sorted(['{0:s}={1:s}'.format(key, value)
-                            for key, value in data.items()])
-    return md5(''.join(param_list) +
-               client_secret_or_session_secret).hexdigest()
-
-
-def odnoklassniki_api(data, api_url, public_key, client_secret,
-                      request_type='oauth'):
-    ''' Calls Odnoklassniki REST API method
-        http://dev.odnoklassniki.ru/wiki/display/ok/Odnoklassniki+Rest+API
-    '''
-    data.update({
-        'application_key': public_key,
-        'format': 'JSON'
-    })
-    if request_type == 'oauth':
-        data['sig'] = odnoklassniki_oauth_sig(data, client_secret)
-    elif request_type == 'iframe_session':
-        data['sig'] = odnoklassniki_iframe_sig(data,
-                                               data['session_secret_key'])
-    elif request_type == 'iframe_nosession':
-        data['sig'] = odnoklassniki_iframe_sig(data, client_secret)
-    else:
-        msg = 'Unknown request type {0}. How should it be signed?'
-        raise AuthFailed(msg.format(request_type))
-    params = urlencode(data)
-    request = Request('{0}fb.do?{1}'.format(api_url, params))
-    try:
-        return simplejson.loads(dsa_urlopen(request).read())
-    except (TypeError, KeyError, IOError, ValueError, IndexError):
-        log('error', 'Could not load data from Odnoklassniki.',
-            exc_info=True, extra=dict(data=params))
-        return None
-
-
-class OdnoklassnikiIframeForm(forms.Form):
-    logged_user_id = forms.IntegerField()
-    api_server = forms.CharField()
-    application_key = forms.CharField()
-    session_key = forms.CharField()
-    session_secret_key = forms.CharField()
-    authorized = forms.IntegerField()
-    apiconnection = forms.CharField()
-    refplace = forms.CharField(required=False)
-    referer = forms.CharField(required=False)
-    auth_sig = forms.CharField()
-    sig = forms.CharField()
-    custom_args = forms.CharField(required=False)
-
-    def __init__(self, auth, *args, **kwargs):
-        self.auth = auth
-        super(OdnoklassnikiIframeForm, self).__init__(*args, **kwargs)
-
-    def get_auth_sig(self):
-        secret_key = backend_setting(self.auth, 'ODNOKLASSNIKI_APP_SECRET')
-        hash_source = '{0:d}{1:s}{2:s}'.format(
-                self.cleaned_data['logged_user_id'],
-                self.cleaned_data['session_key'],
-                secret_key
-        )
-        return md5(hash_source).hexdigest()
-
-    def clean_auth_sig(self):
-        correct_key = self.get_auth_sig()
-        key = self.cleaned_data['auth_sig'].lower()
-        if correct_key != key:
-            raise forms.ValidationError('Wrong authorization key')
-        return self.cleaned_data['auth_sig']
-
-    def get_response(self):
-        fields = ('logged_user_id',
-                  'api_server',
-                  'application_key',
-                  'session_key',
-                  'session_secret_key',
-                  'authorized',
-                  'apiconnection',
-                  )
-        response = {}
-        for fieldname in self.fields.keys():
-            if fieldname in fields:
-                response[fieldname] = self.cleaned_data[fieldname]
-        return response
-
-
-class OdnoklassnikiAppBackend(SocialAuthBackend):
-    '''Odnoklassniki iframe app authentication backend'''
-    name = 'odnoklassnikiapp'
-
-    def get_user_id(self, details, response):
-        '''Return unique user id provided by Odnoklassniki'''
-        return response['uid']
-
-    def extra_data(self, user, uid, response, details):
-        return dict([(key, value) for key, value in response.items()
-                            if key in response['extra_data_list']])
-
-    def get_user_details(self, response):
-        return {'username': response['uid'],
-                'email': '',
-                'fullname': unquote(response['name']),
-                'first_name': unquote(response['first_name']),
-                'last_name': unquote(response['last_name'])}
-
-
-class OdnoklassnikiApp(BaseAuth, OdnoklassnikiMixin):
-    '''Odnoklassniki iframe app authentication class'''
-    SETTINGS_KEY_NAME = 'ODNOKLASSNIKI_APP_KEY'
-    SETTINGS_SECRET_NAME = 'ODNOKLASSNIKI_APP_SECRET'
-    SETTINGS_PUBLIC_NAME = 'ODNOKLASSNIKI_APP_PUBLIC_KEY'
-    AUTH_BACKEND = OdnoklassnikiAppBackend
-
-    def auth_complete(self, request, user, *args, **kwargs):
-        form = OdnoklassnikiIframeForm(auth=self, data=request.GET)
-        if not form.is_valid():
-            raise AuthFailed('Cannot authorize: malformed parameters')
-        else:
-            response = form.get_response()
-            extra_user_data = backend_setting(
-                self, 'ODNOKLASSNIKI_APP_EXTRA_USER_DATA_LIST', ())
-            base_fields = ('uid', 'first_name', 'last_name', 'name')
-            fields = base_fields + extra_user_data
-            data = {
-                'method': 'users.getInfo',
-                'uids': '{0}'.format(response['logged_user_id']),
-                'fields': ','.join(fields),
-            }
-            client_key, client_secret, public_key = self.get_settings()
-            details = odnoklassniki_api(data, response['api_server'],
-                                        public_key, client_secret,
-                                        'iframe_nosession')
-            if len(details) == 1 and 'uid' in details[0]:
-                details = details[0]
-                auth_data_fields = backend_setting(
-                    self,
-                    'ODNOKLASSNIKI_APP_EXTRA_AUTH_DATA_LIST',
-                    ('api_server', 'apiconnection', 'session_key',
-                     'session_secret_key', 'authorized')
-                )
-
-                for field in auth_data_fields:
-                    details[field] = response[field]
-                details['extra_data_list'] = fields + auth_data_fields
-                kwargs.update({
-                    'auth': self,
-                    'response': details,
-                    self.AUTH_BACKEND.name: True
-                })
-            else:
-                raise AuthFailed('Cannot get user details: API error')
-        return authenticate(*args, **kwargs)
-
-    @property
-    def uses_redirect(self):
-        '''
-        Odnoklassniki API for iframe application does not require redirects
-        '''
-        return False
-
-
-# Backend definition
-BACKENDS = {
-    'odnoklassniki': OdnoklassnikiOAuth2,
-    'odnoklassnikiapp': OdnoklassnikiApp
-}
diff --git a/src/social_auth/backends/contrib/orkut.py b/src/social_auth/backends/contrib/orkut.py
deleted file mode 100644
index dca9014e5a..0000000000
--- a/src/social_auth/backends/contrib/orkut.py
+++ /dev/null
@@ -1,87 +0,0 @@
-"""
-Orkut OAuth support.
-
-This contribution adds support for Orkut OAuth service. The scope is
-limited to http://orkut.gmodules.com/social/ by default, but can be
-extended with ORKUT_EXTRA_SCOPE on project settings. Also name, display
-name and emails are the default requested user data, but extra values
-can be specified by defining ORKUT_EXTRA_DATA setting.
-
-OAuth settings ORKUT_CONSUMER_KEY and ORKUT_CONSUMER_SECRET are needed
-to enable this service support.
-"""
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.utils import setting, dsa_urlopen
-from social_auth.backends import OAuthBackend
-from social_auth.backends.google import BaseGoogleOAuth
-
-
-# Orkut configuration
-# default scope, specify extra scope in settings as in:
-# ORKUT_EXTRA_SCOPE = ['...']
-ORKUT_SCOPE = ['http://orkut.gmodules.com/social/']
-ORKUT_REST_ENDPOINT = 'http://www.orkut.com/social/rpc'
-ORKUT_DEFAULT_DATA = 'name,displayName,emails'
-
-
-class OrkutBackend(OAuthBackend):
-    """Orkut OAuth authentication backend"""
-    name = 'orkut'
-
-    def get_user_details(self, response):
-        """Return user details from Orkut account"""
-        try:
-            emails = response['emails'][0]['value']
-        except (KeyError, IndexError):
-            emails = ''
-
-        return {'username': response['displayName'],
-                'email': emails,
-                'fullname': response['displayName'],
-                'first_name': response['name']['givenName'],
-                'last_name': response['name']['familyName']}
-
-
-class OrkutAuth(BaseGoogleOAuth):
-    """Orkut OAuth authentication mechanism"""
-    AUTH_BACKEND = OrkutBackend
-    SETTINGS_KEY_NAME = 'ORKUT_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'ORKUT_CONSUMER_SECRET'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Loads user data from Orkut service"""
-        fields = ORKUT_DEFAULT_DATA
-        if setting('ORKUT_EXTRA_DATA'):
-            fields += ',' + setting('ORKUT_EXTRA_DATA')
-        scope = ORKUT_SCOPE + setting('ORKUT_EXTRA_SCOPE', [])
-        params = {'method': 'people.get',
-                  'id': 'myself',
-                  'userId': '@me',
-                  'groupId': '@self',
-                  'fields': fields,
-                  'scope': ' '.join(scope)}
-        request = self.oauth_request(access_token, ORKUT_REST_ENDPOINT, params)
-        response = dsa_urlopen(request.to_url()).read()
-        try:
-            return simplejson.loads(response)['data']
-        except (ValueError, KeyError):
-            return None
-
-    def oauth_request(self, token, url, extra_params=None):
-        extra_params = extra_params or {}
-        scope = ORKUT_SCOPE + setting('ORKUT_EXTRA_SCOPE', [])
-        extra_params['scope'] = ' '.join(scope)
-        return super(OrkutAuth, self).oauth_request(token, url, extra_params)
-
-
-# Backend definition
-BACKENDS = {
-    'orkut': OrkutAuth,
-}
diff --git a/src/social_auth/backends/contrib/rdio.py b/src/social_auth/backends/contrib/rdio.py
deleted file mode 100644
index 071fe8021a..0000000000
--- a/src/social_auth/backends/contrib/rdio.py
+++ /dev/null
@@ -1,127 +0,0 @@
-import urllib
-
-from oauth2 import Request as OAuthRequest, SignatureMethod_HMAC_SHA1
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import ConsumerBasedOAuth, OAuthBackend, BaseOAuth2
-from social_auth.utils import dsa_urlopen
-
-
-class RdioBaseBackend(OAuthBackend):
-    def get_user_id(self, details, response):
-        return response['key']
-
-    def get_user_details(self, response):
-        return {
-            'username': response['username'],
-            'first_name': response['firstName'],
-            'last_name': response['lastName'],
-            'fullname': response['displayName'],
-        }
-
-
-class RdioOAuth1Backend(RdioBaseBackend):
-    """Rdio OAuth authentication backend"""
-    name = 'rdio-oauth1'
-    EXTRA_DATA = [
-        ('key', 'rdio_id'),
-        ('icon', 'rdio_icon_url'),
-        ('url', 'rdio_profile_url'),
-        ('username', 'rdio_username'),
-        ('streamRegion', 'rdio_stream_region'),
-    ]
-
-    @classmethod
-    def tokens(cls, instance):
-        token = super(RdioOAuth1Backend, cls).tokens(instance)
-        if token and 'access_token' in token:
-            token = dict(tok.split('=')
-                            for tok in token['access_token'].split('&'))
-        return token
-
-
-class RdioOAuth2Backend(RdioBaseBackend):
-    name = 'rdio-oauth2'
-    EXTRA_DATA = [
-        ('key', 'rdio_id'),
-        ('icon', 'rdio_icon_url'),
-        ('url', 'rdio_profile_url'),
-        ('username', 'rdio_username'),
-        ('streamRegion', 'rdio_stream_region'),
-        ('refresh_token', 'refresh_token', True),
-        ('token_type', 'token_type', True),
-    ]
-
-
-class RdioOAuth1(ConsumerBasedOAuth):
-    AUTH_BACKEND = RdioOAuth1Backend
-    REQUEST_TOKEN_URL = 'http://api.rdio.com/oauth/request_token'
-    AUTHORIZATION_URL = 'https://www.rdio.com/oauth/authorize'
-    ACCESS_TOKEN_URL = 'http://api.rdio.com/oauth/access_token'
-    RDIO_API_BASE = 'http://api.rdio.com/1/'
-    SETTINGS_KEY_NAME = 'RDIO_OAUTH1_KEY'
-    SETTINGS_SECRET_NAME = 'RDIO_OAUTH1_SECRET'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Return user data provided"""
-        params = {
-            'method': 'currentUser',
-            'extras': 'username,displayName,streamRegion',
-        }
-        request = self.oauth_post_request(access_token, self.RDIO_API_BASE,
-            params=params)
-        response = dsa_urlopen(request.url, request.to_postdata())
-        json = '\n'.join(response.readlines())
-        try:
-            return simplejson.loads(json)['result']
-        except ValueError:
-            return None
-
-    def oauth_post_request(self, token, url, params):
-        """Generate OAuth request, setups callback url"""
-        if 'oauth_verifier' in self.data:
-            params['oauth_verifier'] = self.data['oauth_verifier']
-        request = OAuthRequest.from_consumer_and_token(self.consumer,
-                                                       token=token,
-                                                       http_url=url,
-                                                       parameters=params,
-                                                       http_method='POST')
-        request.sign_request(SignatureMethod_HMAC_SHA1(), self.consumer, token)
-        return request
-
-
-class RdioOAuth2(BaseOAuth2):
-    AUTH_BACKEND = RdioOAuth2Backend
-    AUTHORIZATION_URL = 'https://www.rdio.com/oauth2/authorize'
-    ACCESS_TOKEN_URL = 'https://www.rdio.com/oauth2/token'
-    RDIO_API_BASE = 'https://www.rdio.com/api/1/'
-    SETTINGS_KEY_NAME = 'RDIO_OAUTH2_KEY'
-    SETTINGS_SECRET_NAME = 'RDIO_OAUTH2_SECRET'
-    SCOPE_VAR_NAME = 'RDIO2_PERMISSIONS'
-    EXTRA_PARAMS_VAR_NAME = 'RDIO2_EXTRA_PARAMS'
-
-    def user_data(self, access_token, *args, **kwargs):
-        params = {
-            'method': 'currentUser',
-            'extras': 'username,displayName,streamRegion',
-            'access_token': access_token,
-        }
-        response = dsa_urlopen(self.RDIO_API_BASE, urllib.urlencode(params))
-        try:
-            return simplejson.load(response)['result']
-        except ValueError:
-            return None
-
-
-# Backend definition
-BACKENDS = {
-    'rdio-oauth1': RdioOAuth1,
-    'rdio-oauth2': RdioOAuth2
-}
diff --git a/src/social_auth/backends/contrib/readability.py b/src/social_auth/backends/contrib/readability.py
deleted file mode 100644
index 523b72af00..0000000000
--- a/src/social_auth/backends/contrib/readability.py
+++ /dev/null
@@ -1,106 +0,0 @@
-"""
-Readability OAuth support.
-
-This contribution adds support for Readability OAuth service. The settings
-READABILITY_CONSUMER_KEY and READABILITY_CONSUMER_SECRET must be defined with
-the values given by Readability in the Connections page of your account
-settings."""
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import ConsumerBasedOAuth, OAuthBackend
-from social_auth.exceptions import AuthCanceled
-from social_auth.utils import setting
-
-# Readability configuration
-READABILITY_SERVER = 'www.readability.com'
-READABILITY_API = 'https://%s/api/rest/v1' % READABILITY_SERVER
-READABILITY_AUTHORIZATION_URL = '%s/oauth/authorize/' % READABILITY_API
-READABILITY_ACCESS_TOKEN_URL = '%s/oauth/access_token/' % READABILITY_API
-READABILITY_REQUEST_TOKEN_URL = '%s/oauth/request_token/' % READABILITY_API
-READABILITY_USER_DATA_URL = '%s/users/_current' % READABILITY_API
-
-
-class ReadabilityBackend(OAuthBackend):
-    """Readability OAuth authentication backend"""
-    name = 'readability'
-
-    EXTRA_DATA = [('date_joined', 'date_joined'),
-                  ('kindle_email_address', 'kindle_email_address'),
-                  ('avatar_url', 'avatar_url'),
-                  ('email_into_address', 'email_into_address')]
-
-    def get_user_details(self, response):
-        username = response['username']
-        first_name, last_name = response['first_name'], response['last_name']
-        return {'username': username,
-                'first_name': first_name,
-                'last_name': last_name}
-
-    def get_user_id(self, details, response):
-        """Returns a unique username to use"""
-        return response['username']
-
-    @classmethod
-    def tokens(cls, instance):
-        """Return the tokens needed to authenticate the access to any API the
-        service might provide. Readability uses a pair of OAuthToken consisting
-        of an oauth_token and oauth_token_secret.
-
-        instance must be a UserSocialAuth instance.
-        """
-        token = super(ReadabilityBackend, cls).tokens(instance)
-        if token and 'access_token' in token:
-            # Split the OAuth query string and only return the values needed
-            token = dict(
-                filter(
-                    lambda x: x[0] in ['oauth_token', 'oauth_token_secret'],
-                    map(
-                        lambda x: x.split('='),
-                        token['access_token'].split('&'))))
-
-        return token
-
-
-class ReadabilityAuth(ConsumerBasedOAuth):
-    """Readability OAuth authentication mechanism"""
-    AUTHORIZATION_URL = READABILITY_AUTHORIZATION_URL
-    REQUEST_TOKEN_URL = READABILITY_REQUEST_TOKEN_URL
-    ACCESS_TOKEN_URL = READABILITY_ACCESS_TOKEN_URL
-    SERVER_URL = READABILITY_SERVER
-    AUTH_BACKEND = ReadabilityBackend
-    SETTINGS_KEY_NAME = 'READABILITY_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'READABILITY_CONSUMER_SECRET'
-
-    def user_data(self, access_token, *args, **kwargs):
-        url = READABILITY_USER_DATA_URL
-        request = self.oauth_request(access_token, url)
-        json = self.fetch_response(request)
-        try:
-            return simplejson.loads(json)
-        except ValueError:
-            return None
-
-    def auth_complete(self, *args, **kwargs):
-        """Completes login process, must return user instance"""
-        if 'error' in self.data:
-            raise AuthCanceled(self)
-        else:
-            return super(ReadabilityAuth, self).auth_complete(*args, **kwargs)
-
-    @classmethod
-    def enabled(cls):
-        """Return backend enabled status by checking basic settings"""
-
-        return setting('READABILITY_CONSUMER_KEY') \
-            and setting('READABILITY_CONSUMER_SECRET')
-
-BACKENDS = {
-    'readability': ReadabilityAuth,
-}
diff --git a/src/social_auth/backends/contrib/shopify.py b/src/social_auth/backends/contrib/shopify.py
deleted file mode 100644
index 4545665659..0000000000
--- a/src/social_auth/backends/contrib/shopify.py
+++ /dev/null
@@ -1,124 +0,0 @@
-"""
-Shopify OAuth support.
-
-You must:
-
-- Register an App in the shopify partner control panel
-- Add the API Key and shared secret in your django settings
-- Set the Application URL in shopify app settings
-- Install the shopify package
-
-"""
-import imp
-from urllib2 import HTTPError
-
-from django.contrib.auth import authenticate
-
-from social_auth.utils import setting
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.exceptions import AuthFailed, AuthCanceled
-
-
-class ShopifyBackend(OAuthBackend):
-    """Shopify OAuth2 authentication backend"""
-    name = 'shopify'
-    # Default extra data to store
-    EXTRA_DATA = [
-        ('shop', 'shop'),
-        ('website', 'website'),
-        ('expires', 'expires')
-    ]
-
-    def get_user_details(self, response):
-        """Use the shopify store name as the username"""
-        return {
-            'username': unicode(response.get('shop', '')
-                                      .replace('.myshopify.com', ''))
-        }
-
-    def get_user_id(self, details, response):
-        """OAuth providers return an unique user id in response"""
-        # For shopify, we'll use the shop ID
-        return response['shop']
-
-
-class ShopifyAuth(BaseOAuth2):
-    """Shopify OAuth authentication mechanism"""
-    AUTH_BACKEND = ShopifyBackend
-    SETTINGS_KEY_NAME = 'SHOPIFY_APP_API_KEY'
-    SETTINGS_SECRET_NAME = 'SHOPIFY_SHARED_SECRET'
-    # Look at http://api.shopify.com/authentication.html#scopes
-    SCOPE_VAR_NAME = 'SHOPIFY_SCOPE'
-
-    def __init__(self, request, redirect):
-        super(ShopifyAuth, self).__init__(request, redirect)
-        fp, pathname, description = imp.find_module('shopify')
-        self.shopifyAPI = imp.load_module('shopify', fp, pathname, description)
-
-    def auth_url(self):
-        self.shopifyAPI.Session.setup(api_key=setting('SHOPIFY_APP_API_KEY'),
-                                      secret=setting('SHOPIFY_SHARED_SECRET'))
-        scope = self.get_scope()
-        state = self.state_token()
-        self.request.session[self.AUTH_BACKEND.name + '_state'] = state
-
-        redirect_uri = self.get_redirect_uri(state)
-        permission_url = self.shopifyAPI.Session.create_permission_url(
-            self.request.GET.get('shop').strip(),
-            scope=scope, redirect_uri=redirect_uri
-        )
-        return permission_url
-
-    def auth_complete(self, *args, **kwargs):
-        """Completes login process, must return user instance"""
-        access_token = None
-        if self.data.get('error'):
-            error = self.data.get('error_description') or self.data['error']
-            raise AuthFailed(self, error)
-
-        client_id, client_secret = self.get_key_and_secret()
-        try:
-            shop_url = self.request.GET.get('shop')
-            self.shopifyAPI.Session.setup(
-                api_key=setting('SHOPIFY_APP_API_KEY'),
-                secret=setting('SHOPIFY_SHARED_SECRET')
-            )
-            shopify_session = self.shopifyAPI.Session(shop_url,
-                                                      self.request.REQUEST)
-            access_token = shopify_session.token
-        except self.shopifyAPI.ValidationException, e:
-            raise AuthCanceled(self)
-        except HTTPError, e:
-            if e.code == 400:
-                raise AuthCanceled(self)
-            else:
-                raise
-
-        if not access_token:
-            raise AuthFailed(self, 'Authentication Failed')
-        return self.do_auth(access_token, shop_url, shopify_session.url,
-                            *args, **kwargs)
-
-    def do_auth(self, access_token, shop_url, website, *args, **kwargs):
-        kwargs.update({
-            'auth': self,
-            'response': {
-                'shop': shop_url,
-                'website': 'http://%s' % website,
-                'access_token': access_token
-            },
-            self.AUTH_BACKEND.name: True
-        })
-        return authenticate(*args, **kwargs)
-
-    @classmethod
-    def enabled(cls):
-        """Return backend enabled status by checking basic settings"""
-        return setting('SHOPIFY_APP_API_KEY') and \
-               setting('SHOPIFY_SHARED_SECRET')
-
-
-# Backend definition
-BACKENDS = {
-    'shopify': ShopifyAuth,
-}
diff --git a/src/social_auth/backends/contrib/skyrock.py b/src/social_auth/backends/contrib/skyrock.py
deleted file mode 100644
index fa3d50d805..0000000000
--- a/src/social_auth/backends/contrib/skyrock.py
+++ /dev/null
@@ -1,80 +0,0 @@
-"""
-Skyrock OAuth support.
-
-This adds support for Skyrock OAuth service. An application must
-be registered first on skyrock and the settings SKYROCK_CONSUMER_KEY
-and SKYROCK_CONSUMER_SECRET must be defined with they corresponding
-values.
-
-By default account id is stored in extra_data field, check OAuthBackend
-class for details on how to extend it.
-"""
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.exceptions import AuthCanceled
-from social_auth.backends import ConsumerBasedOAuth, OAuthBackend
-
-
-# Skyrock configuration
-SKYROCK_SERVER = 'api.skyrock.com'
-SKYROCK_REQUEST_TOKEN_URL = 'https://%s/v2/oauth/initiate' % SKYROCK_SERVER
-SKYROCK_ACCESS_TOKEN_URL = 'https://%s/v2/oauth/token' % SKYROCK_SERVER
-# Note: oauth/authorize forces the user to authorize every time.
-#       oauth/authenticate uses their previous selection, barring revocation.
-SKYROCK_AUTHORIZATION_URL = 'http://%s/v2/oauth/authenticate' % SKYROCK_SERVER
-SKYROCK_CHECK_AUTH = 'https://%s/v2/user/get.json' % SKYROCK_SERVER
-
-
-class SkyrockBackend(OAuthBackend):
-    """Skyrock OAuth authentication backend"""
-    name = 'skyrock'
-    EXTRA_DATA = [('id', 'id')]
-
-    def get_user_id(self, details, response):
-        return response['id_user']
-
-    def get_user_details(self, response):
-        """Return user details from Skyrock account"""
-        return {'username': response['username'],
-                'email': response['email'],
-                'fullname': response['firstname'] + ' ' + response['name'],
-                'first_name': response['firstname'],
-                'last_name': response['name']}
-
-
-class SkyrockAuth(ConsumerBasedOAuth):
-    """Skyrock OAuth authentication mechanism"""
-    AUTHORIZATION_URL = SKYROCK_AUTHORIZATION_URL
-    REQUEST_TOKEN_URL = SKYROCK_REQUEST_TOKEN_URL
-    ACCESS_TOKEN_URL = SKYROCK_ACCESS_TOKEN_URL
-    AUTH_BACKEND = SkyrockBackend
-    SETTINGS_KEY_NAME = 'SKYROCK_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'SKYROCK_CONSUMER_SECRET'
-
-    def user_data(self, access_token):
-        """Return user data provided"""
-        request = self.oauth_request(access_token, SKYROCK_CHECK_AUTH)
-        json = self.fetch_response(request)
-        try:
-            return simplejson.loads(json)
-        except ValueError:
-            return None
-
-    def auth_complete(self, *args, **kwargs):
-        """Completes loging process, must return user instance"""
-        if 'denied' in self.data:
-            raise AuthCanceled(self)
-        else:
-            return super(SkyrockAuth, self).auth_complete(*args, **kwargs)
-
-
-# Backend definition
-BACKENDS = {
-    'skyrock': SkyrockAuth,
-}
diff --git a/src/social_auth/backends/contrib/soundcloud.py b/src/social_auth/backends/contrib/soundcloud.py
deleted file mode 100644
index 9c8ebd3ef2..0000000000
--- a/src/social_auth/backends/contrib/soundcloud.py
+++ /dev/null
@@ -1,116 +0,0 @@
-"""
-SoundCloud OAuth2 support.
-
-This contribution adds support for SoundCloud OAuth2 service.
-
-The settings SOUNDCLOUD_CLIENT_ID & SOUNDCLOUD_CLIENT_SECRET must be defined
-with the values given by SoundCloud application registration process.
-
-http://developers.soundcloud.com/
-http://developers.soundcloud.com/docs
-
-By default account id and token expiration time are stored in extra_data
-field, check OAuthBackend class for details on how to extend it.
-"""
-from urllib import urlencode
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.utils import dsa_urlopen
-from social_auth.backends import BaseOAuth2, OAuthBackend
-
-
-# SoundCloud configuration
-SOUNDCLOUD_AUTHORIZATION_URL = 'https://soundcloud.com/connect'
-SOUNDCLOUD_ACCESS_TOKEN_URL = 'https://api.soundcloud.com/oauth2/token'
-SOUNDCLOUD_USER_DATA_URL = 'https://api.soundcloud.com/me.json'
-SOUNDCLOUD_SERVER = 'soundcloud.com'
-EXTRA_DATA = [
-    ('refresh_token', 'refresh_token'),
-    ('expires_in', 'expires')
-]
-
-
-class SoundcloudBackend(OAuthBackend):
-    """Soundcloud OAuth authentication backend"""
-    name = 'soundcloud'
-    # Default extra data to store
-    EXTRA_DATA = [
-        ('id', 'id'),
-        ('expires', 'expires')
-    ]
-
-    def get_user_details(self, response):
-        """Return user details from Soundcloud account"""
-        fullname = response.get('full_name')
-        full_name = fullname.split(' ')
-        first_name = full_name[0]
-        if len(full_name) > 1:
-            last_name = full_name[-1]
-        else:
-            last_name = ''
-
-        return {'username': response.get('username'),
-                'email': response.get('email') or '',
-                'fullname': fullname,
-                'first_name': first_name,
-                'last_name': last_name}
-
-
-class SoundcloudAuth(BaseOAuth2):
-    """Soundcloud OAuth2 mechanism"""
-    AUTHORIZATION_URL = SOUNDCLOUD_AUTHORIZATION_URL
-    ACCESS_TOKEN_URL = SOUNDCLOUD_ACCESS_TOKEN_URL
-    AUTH_BACKEND = SoundcloudBackend
-    SETTINGS_KEY_NAME = 'SOUNDCLOUD_CLIENT_ID'
-    SETTINGS_SECRET_NAME = 'SOUNDCLOUD_CLIENT_SECRET'
-    SCOPE_SEPARATOR = ','
-    REDIRECT_STATE = False
-    #SCOPE_VAR_NAME = 'SOUNDCLOUD_EXTENDED_PERMISSIONS'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Loads user data from service"""
-        url = SOUNDCLOUD_USER_DATA_URL + '?' + urlencode({
-            'oauth_token': access_token
-        })
-        try:
-            value = simplejson.load(dsa_urlopen(url))
-            return value
-        except ValueError:
-            return None
-
-    def auth_url(self):
-        """Return redirect url"""
-        if self.STATE_PARAMETER or self.REDIRECT_STATE:
-            # Store state in session for further request validation. The state
-            # value is passed as state parameter (as specified in OAuth2 spec),
-            # but also added to redirect_uri, that way we can still verify the
-            # request if the provider doesn't implement the state parameter.
-            # Reuse token if any.
-            name = self.AUTH_BACKEND.name + '_state'
-            state = self.request.session.get(name) or self.state_token()
-            self.request.session[self.AUTH_BACKEND.name + '_state'] = state
-        else:
-            state = None
-
-        params = self.auth_params(state)
-        params.update(self.get_scope_argument())
-        params.update(self.auth_extra_arguments())
-
-        if self.request.META.get('QUERY_STRING'):
-            query_string = '&' + self.request.META['QUERY_STRING']
-        else:
-            query_string = ''
-        return self.AUTHORIZATION_URL + '?' + urlencode(params) + query_string
-
-
-# Backend definition
-BACKENDS = {
-    'soundcloud': SoundcloudAuth
-}
diff --git a/src/social_auth/backends/contrib/stackoverflow.py b/src/social_auth/backends/contrib/stackoverflow.py
deleted file mode 100644
index 29a4bd7725..0000000000
--- a/src/social_auth/backends/contrib/stackoverflow.py
+++ /dev/null
@@ -1,117 +0,0 @@
-"""
-Stackoverflow OAuth support.
-
-This contribution adds support for Stackoverflow OAuth service. The settings
-STACKOVERFLOW_CLIENT_ID, STACKOVERFLOW_CLIENT_SECRET and
-STACKOVERFLOW_CLIENT_SECRET must be defined with the values given by
-Stackoverflow application registration process.
-
-Extended permissions are supported by defining
-STACKOVERFLOW_EXTENDED_PERMISSIONS setting, it must be a list of values
-to request.
-
-By default account id and token expiration time are stored in extra_data
-field, check OAuthBackend class for details on how to extend it.
-"""
-from urllib import urlencode
-from urllib2 import Request, HTTPError
-from urlparse import parse_qsl
-from gzip import GzipFile
-from StringIO import StringIO
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from django.conf import settings
-
-from social_auth.utils import dsa_urlopen
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.exceptions import AuthUnknownError, AuthCanceled
-
-
-# Stackoverflow configuration
-STACKOVERFLOW_AUTHORIZATION_URL = 'https://stackexchange.com/oauth'
-STACKOVERFLOW_ACCESS_TOKEN_URL = 'https://stackexchange.com/oauth/access_token'
-STACKOVERFLOW_USER_DATA_URL = 'https://api.stackexchange.com/2.1/me'
-
-STACKOVERFLOW_SERVER = 'stackexchange.com'
-
-
-class StackoverflowBackend(OAuthBackend):
-    """Stackoverflow OAuth authentication backend"""
-    name = 'stackoverflow'
-    ID_KEY = 'user_id'
-    # Default extra data to store
-    EXTRA_DATA = [
-        ('id', 'id'),
-        ('expires', 'expires')
-    ]
-
-    def get_user_details(self, response):
-        """Return user details from Stackoverflow account"""
-        return {'username': response.get('link').split('/')[-1],
-                'full_name': response.get('display_name')}
-
-
-class StackoverflowAuth(BaseOAuth2):
-    """Stackoverflow OAuth2 mechanism"""
-    AUTHORIZATION_URL = STACKOVERFLOW_AUTHORIZATION_URL
-    ACCESS_TOKEN_URL = STACKOVERFLOW_ACCESS_TOKEN_URL
-    AUTH_BACKEND = StackoverflowBackend
-    SETTINGS_KEY_NAME = 'STACKOVERFLOW_CLIENT_ID'
-    SETTINGS_SECRET_NAME = 'STACKOVERFLOW_CLIENT_SECRET'
-    SCOPE_SEPARATOR = ','
-    # See: https://api.stackexchange.com/docs/authentication#scope
-    SCOPE_VAR_NAME = 'STACKOVERFLOW_EXTENDED_PERMISSIONS'
-
-    def auth_complete(self, *args, **kwargs):
-        """Completes loging process, must return user instance"""
-        self.process_error(self.data)
-        params = self.auth_complete_params(self.validate_state())
-        request = Request(self.ACCESS_TOKEN_URL, data=urlencode(params),
-                          headers=self.auth_headers())
-
-        try:
-            response = dict(parse_qsl(dsa_urlopen(request).read()))
-        except HTTPError, e:
-            if e.code == 400:
-                raise AuthCanceled(self)
-            else:
-                raise
-        except (ValueError, KeyError):
-            raise AuthUnknownError(self)
-
-        self.process_error(response)
-        return self.do_auth(response['access_token'], response=response,
-                            *args, **kwargs)
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Loads user data from service"""
-        url = STACKOVERFLOW_USER_DATA_URL + '?' + urlencode({
-            'site': 'stackoverflow',
-            'access_token': access_token,
-            'key': getattr(settings, 'STACKOVERFLOW_KEY')})
-
-        opener = dsa_urlopen(url)
-        if opener.headers.get('content-encoding') == 'gzip':
-            ''' stackoverflow doesn't respect no gzip header '''
-            gzip = GzipFile(fileobj=StringIO(opener.read()), mode='r')
-            response = gzip.read()
-        else:
-            response = opener.read()
-
-        try:
-            data = simplejson.loads(response)
-            return data.get('items')[0]
-        except (ValueError, TypeError):
-            return None
-
-# Backend definition
-BACKENDS = {
-    'stackoverflow': StackoverflowAuth,
-}
diff --git a/src/social_auth/backends/contrib/stocktwits.py b/src/social_auth/backends/contrib/stocktwits.py
deleted file mode 100644
index 454a3ca59a..0000000000
--- a/src/social_auth/backends/contrib/stocktwits.py
+++ /dev/null
@@ -1,67 +0,0 @@
-from urllib import urlencode
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.utils import dsa_urlopen
-
-STOCKTWITS_SERVER = 'api.stocktwits.com'
-STOCKTWITS_AUTHORIZATION_URL = 'https://%s/api/2/oauth/authorize' % \
-                                            STOCKTWITS_SERVER
-STOCKTWITS_ACCESS_TOKEN_URL = 'https://%s/api/2/oauth/token' % \
-                                            STOCKTWITS_SERVER
-STOCKTWITS_CHECK_AUTH = 'https://%s/api/2/account/verify.json' % \
-                                            STOCKTWITS_SERVER
-
-
-class StocktwitsBackend(OAuthBackend):
-    name = 'stocktwits'
-
-    def get_user_id(self, details, response):
-        return response['user']['id']
-
-    def get_user_details(self, response):
-        """Return user details from Stocktwits account"""
-        try:
-            first_name, last_name = response['user']['name'].split(' ', 1)
-        except:
-            first_name = response['user']['name']
-            last_name = ''
-        return {'username': response['user']['username'],
-                'email': '',  # not supplied
-                'fullname': response['user']['name'],
-                'first_name': first_name,
-                'last_name': last_name}
-
-
-class StocktwitsAuth(BaseOAuth2):
-    """Stocktwits OAuth mechanism"""
-    AUTHORIZATION_URL = STOCKTWITS_AUTHORIZATION_URL
-    ACCESS_TOKEN_URL = STOCKTWITS_ACCESS_TOKEN_URL
-    SERVER_URL = STOCKTWITS_SERVER
-    AUTH_BACKEND = StocktwitsBackend
-    SETTINGS_KEY_NAME = 'STOCKTWITS_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'STOCKTWITS_CONSUMER_SECRET'
-    SCOPE_SEPARATOR = ','
-    DEFAULT_SCOPE = ['read', 'publish_messages', 'publish_watch_lists',
-                     'follow_users', 'follow_stocks']
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Loads user data from service"""
-        params = {'access_token': access_token}
-        url = STOCKTWITS_CHECK_AUTH + '?' + urlencode(params)
-        try:
-            return simplejson.load(dsa_urlopen(url))
-        except ValueError:
-            return None
-
-
-# Backend definition
-BACKENDS = {
-    'stocktwits': StocktwitsAuth,
-}
diff --git a/src/social_auth/backends/contrib/tripit.py b/src/social_auth/backends/contrib/tripit.py
deleted file mode 100644
index 48cb79abee..0000000000
--- a/src/social_auth/backends/contrib/tripit.py
+++ /dev/null
@@ -1,70 +0,0 @@
-"""
-TripIt OAuth support.
-
-This adds support for TripIt OAuth service. An application must
-be registered first on TripIt and the settings TRIPIT_API_KEY
-and TRIPIT_API_SECRET must be defined with the corresponding
-values.
-
-User screen name is used to generate username.
-"""
-from xml.dom import minidom
-
-from social_auth.backends import ConsumerBasedOAuth, OAuthBackend
-
-
-TRIPIT_CHECK_AUTH = 'https://api.tripit.com/v1/get/profile'
-
-
-class TripItBackend(OAuthBackend):
-    """TripIt OAuth authentication backend"""
-    name = 'tripit'
-    EXTRA_DATA = [('screen_name', 'screen_name')]
-
-    def get_user_details(self, response):
-        """Return user details from TripIt account"""
-        try:
-            first_name, last_name = response['name'].split(' ', 1)
-        except ValueError:
-            first_name = response['name']
-            last_name = ''
-        return {'username': response['screen_name'],
-                'email': response['email'],
-                'fullname': response['name'],
-                'first_name': first_name,
-                'last_name': last_name}
-
-
-class TripItAuth(ConsumerBasedOAuth):
-    """TripIt OAuth authentication mechanism"""
-    AUTHORIZATION_URL = 'https://www.tripit.com/oauth/authorize'
-    REQUEST_TOKEN_URL = 'https://api.tripit.com/oauth/request_token'
-    ACCESS_TOKEN_URL = 'https://api.tripit.com/oauth/access_token'
-    AUTH_BACKEND = TripItBackend
-    SETTINGS_KEY_NAME = 'TRIPIT_API_KEY'
-    SETTINGS_SECRET_NAME = 'TRIPIT_API_SECRET'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Return user data provided"""
-        request = self.oauth_request(access_token, TRIPIT_CHECK_AUTH)
-        content = self.fetch_response(request)
-        try:
-            dom = minidom.parseString(content)
-        except ValueError:
-            return None
-
-        return {
-            'id': dom.getElementsByTagName('Profile')[0].getAttribute('ref'),
-            'name': dom.getElementsByTagName(
-                'public_display_name')[0].childNodes[0].data,
-            'screen_name': dom.getElementsByTagName(
-                'screen_name')[0].childNodes[0].data,
-            'email': dom.getElementsByTagName('is_primary')[0]
-                            .parentNode.getElementsByTagName('address')[0]
-                                .childNodes[0].data,
-        }
-
-# Backend definition
-BACKENDS = {
-    'tripit': TripItAuth,
-}
diff --git a/src/social_auth/backends/contrib/tumblr.py b/src/social_auth/backends/contrib/tumblr.py
deleted file mode 100644
index f9b615b755..0000000000
--- a/src/social_auth/backends/contrib/tumblr.py
+++ /dev/null
@@ -1,121 +0,0 @@
-"""
-Tumblr OAuth 1.0a support.
-
-Take a look to http://www.tumblr.com/docs/en/api/v2
-
-You need to register OAuth site here:
-http://www.tumblr.com/oauth/apps
-
-Then update your settings values using registration information
-
-ref:
-https://github.com/gkmngrgn/django-tumblr-auth
-"""
-from urllib import urlopen
-
-from oauth2 import Request as OAuthRequest, Token as OAuthToken, \
-                   SignatureMethod_HMAC_SHA1
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import ConsumerBasedOAuth
-from social_auth.backends import OAuthBackend
-
-
-TUMBLR_SERVER = 'www.tumblr.com'
-TUMBLR_AUTHORIZATION_URL = 'http://%s/oauth/authorize' % TUMBLR_SERVER
-TUMBLR_REQUEST_TOKEN_URL = 'http://%s/oauth/request_token' % TUMBLR_SERVER
-TUMBLR_ACCESS_TOKEN_URL = 'http://%s/oauth/access_token' % TUMBLR_SERVER
-TUMBLR_CHECK_AUTH = 'http://api.tumblr.com/v2/user/info'
-
-
-class TumblrBackend(OAuthBackend):
-    name = 'tumblr'
-
-    def get_user_id(self, details, response):
-        return details['username']
-
-    def get_user_details(self, response):
-        # http://www.tumblr.com/docs/en/api/v2#user-methods
-        user_info = response['response']['user']
-        data = {'username': user_info['name']}
-        blogs = user_info['blogs']
-        for blog in blogs:
-            if blog['primary']:
-                data['fullname'] = blog['title']
-                break
-        return data
-
-    @classmethod
-    def tokens(cls, instance):
-        """
-        Return the tokens needed to authenticate the access to any API the
-        service might provide. Tumblr uses a pair of OAuthToken consisting
-        on a oauth_token and oauth_token_secret.
-
-        instance must be a UserSocialAuth instance.
-        """
-        token = super(TumblrBackend, cls).tokens(instance)
-        if token and 'access_token' in token:
-            token = dict(tok.split('=')
-                            for tok in token['access_token'].split('&'))
-        return token
-
-
-class TumblrAuth(ConsumerBasedOAuth):
-    AUTH_BACKEND = TumblrBackend
-    AUTHORIZATION_URL = TUMBLR_AUTHORIZATION_URL
-    REQUEST_TOKEN_URL = TUMBLR_REQUEST_TOKEN_URL
-    ACCESS_TOKEN_URL = TUMBLR_ACCESS_TOKEN_URL
-    SERVER_URL = TUMBLR_SERVER
-    SETTINGS_KEY_NAME = 'TUMBLR_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'TUMBLR_CONSUMER_SECRET'
-
-    def user_data(self, access_token):
-        request = self.oauth_request(access_token, TUMBLR_CHECK_AUTH)
-        json = self.fetch_response(request)
-
-        try:
-            return simplejson.loads(json)
-        except ValueError:
-            return None
-
-    def unauthorized_token(self):
-        request = self.oauth_request(token=None, url=self.REQUEST_TOKEN_URL)
-        response = self.fetch_response(request)
-
-        return OAuthToken.from_string(response)
-
-    def oauth_request(self, token, url, extra_params=None):
-        params = {
-            'oauth_callback': self.redirect_uri,
-        }
-
-        if extra_params:
-            params.update(extra_params)
-
-        if 'oauth_verifier' in self.data:
-            params['oauth_verifier'] = self.data['oauth_verifier']
-
-        request = OAuthRequest.from_consumer_and_token(self.consumer,
-                                                       token=token,
-                                                       http_url=url,
-                                                       parameters=params)
-        request.sign_request(SignatureMethod_HMAC_SHA1(), self.consumer, token)
-        return request
-
-    def fetch_response(self, request):
-        """Executes request and fetchs service response"""
-        response = urlopen(request.to_url())
-        return response.read()
-
-
-BACKENDS = {
-    'tumblr': TumblrAuth
-}
diff --git a/src/social_auth/backends/contrib/twilio.py b/src/social_auth/backends/contrib/twilio.py
deleted file mode 100644
index 68a67fc767..0000000000
--- a/src/social_auth/backends/contrib/twilio.py
+++ /dev/null
@@ -1,77 +0,0 @@
-"""
-Twilio support
-"""
-from urllib import urlencode
-from re import sub
-
-from django.contrib.auth import authenticate
-from django.conf import settings
-
-from social_auth.backends import SocialAuthBackend, BaseAuth
-
-
-TWILIO_SERVER = 'https://www.twilio.com'
-TWILIO_AUTHORIZATION_URL = 'https://www.twilio.com/authorize/'
-
-
-class TwilioBackend(SocialAuthBackend):
-    name = 'twilio'
-
-    def get_user_id(self, details, response):
-        return response['AccountSid']
-
-    def get_user_details(self, response):
-        """Return twilio details, Twilio only provides AccountSID as
-        parameters."""
-        # /complete/twilio/?AccountSid=ACc65ea16c9ebd4d4684edf814995b27e
-        account_sid = response['AccountSid']
-        return {'username': account_sid,
-                'email': '',
-                'fullname': '',
-                'first_name': '',
-                'last_name': ''}
-
-
-# Auth classes
-class TwilioAuth(BaseAuth):
-    """Twilio authentication"""
-    AUTH_BACKEND = TwilioBackend
-    SETTINGS_KEY_NAME = 'TWILIO_CONNECT_KEY'
-    SETTINGS_SECRET_NAME = 'TWILIO_AUTH_TOKEN'
-
-    def auth_url(self):
-        """Return authorization redirect url."""
-        key = self.connect_api_key()
-        callback = self.request.build_absolute_uri(self.redirect)
-        callback = sub(r'^https', u'http', callback)
-        query = urlencode({'cb': callback})
-        return '%s%s?%s' % (TWILIO_AUTHORIZATION_URL, key, query)
-
-    def auth_complete(self, *args, **kwargs):
-        """Completes loging process, must return user instance"""
-        account_sid = self.data.get('AccountSid')
-
-        if not account_sid:
-            raise ValueError('No AccountSid returned')
-
-        kwargs.update({'response': self.data, self.AUTH_BACKEND.name: True})
-        return authenticate(*args, **kwargs)
-
-    @classmethod
-    def enabled(cls):
-        """Enable only if settings are defined."""
-        return cls.connect_api_key and cls.secret_key
-
-    @classmethod
-    def connect_api_key(cls):
-        return getattr(settings, cls.SETTINGS_KEY_NAME, '')
-
-    @classmethod
-    def secret_key(cls):
-        return getattr(settings, cls.SETTINGS_SECRET_NAME, '')
-
-
-# Backend definition
-BACKENDS = {
-    'twilio': TwilioAuth
-}
diff --git a/src/social_auth/backends/contrib/vk.py b/src/social_auth/backends/contrib/vk.py
deleted file mode 100644
index 7db3c2ab75..0000000000
--- a/src/social_auth/backends/contrib/vk.py
+++ /dev/null
@@ -1,310 +0,0 @@
-# -*- coding: utf-8 -*-
-"""
-vk.com OpenAPI and OAuth 2.0 support.
-
-This contribution adds support for VK.com OpenAPI, OAuth 2.0 and IFrame apps.
-Username is retrieved from the identity returned by server.
-"""
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from django.contrib.auth import authenticate
-
-from urllib import urlencode
-from hashlib import md5
-from time import time
-
-from social_auth.backends import SocialAuthBackend, OAuthBackend, BaseAuth, \
-                                 BaseOAuth2
-from social_auth.exceptions import AuthTokenRevoked, AuthException, \
-                                   AuthCanceled, AuthFailed
-from social_auth.utils import setting, log, dsa_urlopen
-
-
-# vk configuration
-VK_AUTHORIZATION_URL = 'http://oauth.vk.com/authorize'
-VK_ACCESS_TOKEN_URL = 'https://oauth.vk.com/access_token'
-VK_SERVER = 'vk.com'
-VK_DEFAULT_DATA = ['first_name', 'last_name', 'screen_name',
-                   'nickname', 'photo']
-
-VK_API_URL = 'https://api.vk.com/method/'
-VK_SERVER_API_URL = 'http://api.vk.com/api.php'
-VK_API_VERSION = '3.0'
-
-LOCAL_HTML = setting('VK_LOCAL_HTML', setting('VKONTAKTE_LOCAL_HTML',
-                                              'vkontakte.html'))
-
-USE_APP_AUTH = setting('VKAPP_APP_ID', False)
-
-
-class VKOpenAPIBackend(SocialAuthBackend):
-    """VK OpenAPI authentication backend"""
-    name = 'vk-openapi'
-
-    def get_user_id(self, details, response):
-        """Return user unique id provided by VK"""
-        return response['id']
-
-    def get_user_details(self, response):
-        """Return user details from VK request"""
-        nickname = response.get('nickname') or response['id']
-        if isinstance(nickname, (list, tuple, )):
-            nickname = nickname[0]
-        return {
-            'username': nickname,
-            'email': '',
-            'fullname': '',
-            'first_name': response.get('first_name')[0]
-                                if 'first_name' in response else '',
-            'last_name': response.get('last_name')[0]
-                                if 'last_name' in response else ''
-        }
-
-
-class VKOpenAPIAuth(BaseAuth):
-    """VKontakte OpenAPI authorization mechanism"""
-    AUTH_BACKEND = VKOpenAPIBackend
-    APP_ID = setting('VKONTAKTE_APP_ID')
-
-    def user_data(self, access_token, *args, **kwargs):
-        return dict(self.request.GET)
-
-    def auth_html(self):
-        """Returns local VK authentication page, not necessary for
-        VK to authenticate.
-        """
-        from django.template import RequestContext, loader
-
-        dict = {'VK_APP_ID': self.APP_ID,
-                'VK_COMPLETE_URL': self.redirect}
-
-        vk_template = loader.get_template(LOCAL_HTML)
-        context = RequestContext(self.request, dict)
-
-        return vk_template.render(context)
-
-    def auth_complete(self, *args, **kwargs):
-        """Performs check of authentication in VK, returns User if
-        succeeded"""
-        app_cookie = 'vk_app_' + self.APP_ID
-
-        if not 'id' in self.request.GET or \
-           not app_cookie in self.request.COOKIES:
-            raise AuthCanceled(self)
-
-        cookie_dict = dict(item.split('=') for item in
-                                self.request.COOKIES[app_cookie].split('&'))
-        check_str = ''.join(item + '=' + cookie_dict[item]
-                                for item in ['expire', 'mid', 'secret', 'sid'])
-
-        hash = md5(check_str + setting('VK_API_SECRET')).hexdigest()
-
-        if hash != cookie_dict['sig'] or int(cookie_dict['expire']) < time():
-            raise AuthFailed('VK authentication failed: invalid hash')
-        else:
-            kwargs.update({
-                'auth': self,
-                'response': self.user_data(cookie_dict['mid']),
-                self.AUTH_BACKEND.name: True
-            })
-            return authenticate(*args, **kwargs)
-
-    @property
-    def uses_redirect(self):
-        """VK does not require visiting server url in order
-        to do authentication, so auth_xxx methods are not needed to be called.
-        Their current implementation is just an example"""
-        return False
-
-
-class VKOAuth2Backend(OAuthBackend):
-    """VKOAuth2 authentication backend"""
-    name = 'vk-oauth'
-
-    EXTRA_DATA = [
-        ('id', 'id'),
-        ('expires', 'expires')
-    ]
-
-    def get_user_id(self, details, response):
-        """OAuth providers return an unique user id in response"""
-        return response['user_id']
-
-    def get_user_details(self, response):
-        """Return user details from VK account"""
-        return {
-            'username': response.get('screen_name'),
-            'email': '',
-            'first_name': response.get('first_name'),
-            'last_name': response.get('last_name')
-        }
-
-
-class VKApplicationBackend(VKOAuth2Backend):
-    name = 'vk-app'
-
-
-class VKOAuth2(BaseOAuth2):
-    """VK OAuth mechanism"""
-    AUTHORIZATION_URL = VK_AUTHORIZATION_URL
-    ACCESS_TOKEN_URL = VK_ACCESS_TOKEN_URL
-    AUTH_BACKEND = VKOAuth2Backend
-    SETTINGS_KEY_NAME = 'VK_APP_ID'
-    SETTINGS_SECRET_NAME = 'VK_API_SECRET'
-    # Look at:
-    # http://vk.com/developers.php?oid=-17680044&p=Application_Access_Rights
-    SCOPE_VAR_NAME = 'VK_EXTRA_SCOPE'
-
-    def get_scope(self):
-        return setting(VKOAuth2.SCOPE_VAR_NAME) or \
-               setting('VK_OAUTH2_EXTRA_SCOPE')
-
-    def user_data(self, access_token, response, *args, **kwargs):
-        """Loads user data from service"""
-        fields = ','.join(VK_DEFAULT_DATA + setting('VK_EXTRA_DATA', []))
-        params = {'access_token': access_token,
-                  'fields': fields,
-                  'uids': response.get('user_id')}
-
-        data = vk_api('users.get', params)
-
-        if data.get('error'):
-            error = data['error']
-            msg = error.get('error_msg', 'Unknown error')
-            if error.get('error_code') == 5:
-                raise AuthTokenRevoked(self, msg)
-            else:
-                raise AuthException(self, msg)
-
-        if data:
-            data = data.get('response')[0]
-            data['user_photo'] = data.get('photo')  # Backward compatibility
-
-        return data
-
-
-class VKAppAuth(VKOAuth2):
-    """VKontakte Application Authentication support"""
-    AUTH_BACKEND = VKApplicationBackend
-    SETTINGS_KEY_NAME = 'VKAPP_APP_ID'
-    SETTINGS_SECRET_NAME = 'VKAPP_API_SECRET'
-
-    def auth_complete(self, *args, **kwargs):
-        stop, app_auth = self.application_auth(*args, **kwargs)
-
-        if app_auth:
-            return app_auth
-
-        if stop:
-            return None
-
-        return super(VKAppAuth, self).auth_complete(*args, **kwargs)
-
-    def user_profile(self, user_id, access_token=None):
-        data = {'uids': user_id, 'fields': 'photo'}
-
-        if access_token:
-            data['access_token'] = access_token
-
-        profiles = vk_api('getProfiles', data, is_app=True).get('response',
-                                                                None)
-        return profiles[0] if profiles else None
-
-    def is_app_user(self, user_id, access_token=None):
-        """Returns app usage flag from VK API"""
-
-        data = {'uid': user_id}
-
-        if access_token:
-            data['access_token'] = access_token
-
-        return vk_api('isAppUser', data, is_app=True).get('response', 0)
-
-    def application_auth(self, *args, **kwargs):
-        required_params = ('is_app_user', 'viewer_id', 'access_token',
-                           'api_id')
-
-        for param in required_params:
-            if not param in self.request.REQUEST:
-                return (False, None)
-
-        auth_key = self.request.REQUEST.get('auth_key')
-
-        # Verify signature, if present
-        if auth_key:
-            check_key = md5('_'.join([
-                setting(self.SETTINGS_KEY_NAME),
-                self.request.REQUEST.get('viewer_id'),
-                setting(self.SETTINGS_SECRET_NAME)
-            ])).hexdigest()
-
-            if check_key != auth_key:
-                raise ValueError('VK authentication failed: invalid '
-                                 'auth key')
-
-        user_check = setting('VKAPP_USER_MODE', 0)
-        user_id = self.request.REQUEST.get('viewer_id')
-
-        if user_check:
-            is_user = self.request.REQUEST.get('is_app_user') \
-                        if user_check == 1 else self.is_app_user(user_id)
-
-            if not int(is_user):
-                return (True, None)
-
-        data = self.user_profile(user_id)
-        data['user_id'] = user_id
-
-        return (True, authenticate(*args, **{'auth': self,
-            'request': self.request,
-            'response': data, self.AUTH_BACKEND.name: True
-        }))
-
-
-def vk_api(method, data, is_app=False):
-    """Calls VK OpenAPI method
-        https://vk.com/apiclub,
-        https://vk.com/pages.php?o=-1&p=%C2%FB%EF%EE%EB%ED%E5%ED%E8%E5%20%E7'
-                                        %E0%EF%F0%EE%F1%EE%E2%20%EA%20API
-    """
-
-    # We need to perform server-side call if no access_token
-    if not 'access_token' in data:
-        if not 'v' in data:
-            data['v'] = VK_API_VERSION
-
-        if not 'api_id' in data:
-            data['api_id'] = setting('VKAPP_APP_ID' if is_app else 'VK_APP_ID')
-
-        data['method'] = method
-        data['format'] = 'json'
-
-        url = VK_SERVER_API_URL
-        secret = setting('VKAPP_API_SECRET' if is_app else 'VK_API_SECRET')
-
-        param_list = sorted(list(item + '=' + data[item] for item in data))
-        data['sig'] = md5(''.join(param_list) + secret).hexdigest()
-    else:
-        url = VK_API_URL + method
-
-    params = urlencode(data)
-    url += '?' + params
-    try:
-        return simplejson.load(dsa_urlopen(url))
-    except (TypeError, KeyError, IOError, ValueError, IndexError):
-        log('error', 'Could not load data from vk.com',
-            exc_info=True, extra=dict(data=data))
-        return None
-
-
-# Backend definition
-BACKENDS = {
-    'vk-openapi': VKOpenAPIAuth,
-    'vk-oauth': VKOAuth2 if not USE_APP_AUTH else VKAppAuth,
-}
diff --git a/src/social_auth/backends/contrib/vkontakte.py b/src/social_auth/backends/contrib/vkontakte.py
deleted file mode 100644
index c6abe026e9..0000000000
--- a/src/social_auth/backends/contrib/vkontakte.py
+++ /dev/null
@@ -1,4 +0,0 @@
-import warnings
-
-warnings.warn('Vkontakte backend was renamed to vk backend, settings were renamed too. Please adjust your settings', DeprecationWarning)
-from .vk import *
diff --git a/src/social_auth/backends/contrib/weibo.py b/src/social_auth/backends/contrib/weibo.py
deleted file mode 100644
index 408bcdeaf4..0000000000
--- a/src/social_auth/backends/contrib/weibo.py
+++ /dev/null
@@ -1,80 +0,0 @@
-#coding:utf8
-#author:hepochen@gmail.com  https://github.com/hepochen
-"""
-Weibo OAuth2 support.
-
-This script adds support for Weibo OAuth service. An application must
-be registered first on http://open.weibo.com.
-
-WEIBO_CLIENT_KEY and WEIBO_CLIENT_SECRET must be defined in the settings.py
-correctly.
-
-By default account id,profile_image_url,gender are stored in extra_data field,
-check OAuthBackend class for details on how to extend it.
-"""
-from urllib import urlencode
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import OAuthBackend, BaseOAuth2
-from social_auth.utils import dsa_urlopen
-
-
-WEIBO_SERVER = 'api.weibo.com'
-WEIBO_REQUEST_TOKEN_URL = 'https://%s/oauth2/request_token' % WEIBO_SERVER
-WEIBO_ACCESS_TOKEN_URL = 'https://%s/oauth2/access_token' % WEIBO_SERVER
-WEIBO_AUTHORIZATION_URL = 'https://%s/oauth2/authorize' % WEIBO_SERVER
-
-
-class WeiboBackend(OAuthBackend):
-    """Weibo (of sina) OAuth authentication backend"""
-    name = 'weibo'
-    # Default extra data to store
-    EXTRA_DATA = [
-        ('id', 'id'),
-        ('name', 'username'),
-        ('profile_image_url', 'profile_image_url'),
-        ('gender', 'gender')
-    ]
-
-    def get_user_id(self, details, response):
-        return response['uid']
-
-    def get_user_details(self, response):
-        """Return user details from Weibo. API URL is:
-        https://api.weibo.com/2/users/show.json/?uid=<UID>&access_token=<TOKEN>
-        """
-        return {'username': response.get("name", ""),
-                'first_name': response.get('screen_name', '')}
-
-
-class WeiboAuth(BaseOAuth2):
-    """Weibo OAuth authentication mechanism"""
-    AUTHORIZATION_URL = WEIBO_AUTHORIZATION_URL
-    REQUEST_TOKEN_URL = WEIBO_REQUEST_TOKEN_URL
-    ACCESS_TOKEN_URL = WEIBO_ACCESS_TOKEN_URL
-    AUTH_BACKEND = WeiboBackend
-    SETTINGS_KEY_NAME = 'WEIBO_CLIENT_KEY'
-    SETTINGS_SECRET_NAME = 'WEIBO_CLIENT_SECRET'
-    REDIRECT_STATE = False
-
-    def user_data(self, access_token, *args, **kwargs):
-        uid = kwargs.get('response', {}).get('uid')
-        data = {'access_token': access_token, 'uid': uid}
-        url = 'https://api.weibo.com/2/users/show.json?' + urlencode(data)
-        try:
-            return simplejson.loads(dsa_urlopen(url).read())
-        except (ValueError, KeyError, IOError):
-            return None
-
-
-# Backend definition
-BACKENDS = {
-    'weibo': WeiboAuth
-}
diff --git a/src/social_auth/backends/contrib/xing.py b/src/social_auth/backends/contrib/xing.py
deleted file mode 100644
index 1b125deba1..0000000000
--- a/src/social_auth/backends/contrib/xing.py
+++ /dev/null
@@ -1,111 +0,0 @@
-"""
-XING OAuth support
-
-No extra configurations are needed to make this work.
-"""
-import oauth2 as oauth
-from oauth2 import Token
-
-from urllib import urlencode
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import ConsumerBasedOAuth, OAuthBackend
-from social_auth.exceptions import AuthCanceled, AuthUnknownError
-
-
-XING_SERVER = 'xing.com'
-XING_REQUEST_TOKEN_URL = 'https://api.%s/v1/request_token' % \
-                                    XING_SERVER
-XING_ACCESS_TOKEN_URL = 'https://api.%s/v1/access_token' % \
-                                    XING_SERVER
-XING_AUTHORIZATION_URL = 'https://www.%s/v1/authorize' % \
-                                    XING_SERVER
-XING_CHECK_AUTH = 'https://api.%s/v1/users/me.json' % XING_SERVER
-
-
-class XingBackend(OAuthBackend):
-    """Xing OAuth authentication backend"""
-    name = 'xing'
-    EXTRA_DATA = [
-        ('id', 'id'),
-        ('user_id', 'user_id')
-    ]
-
-    def get_user_details(self, response):
-        """Return user details from Xing account"""
-        first_name, last_name = response['first_name'], response['last_name']
-        email = response.get('email', '')
-        return {'username': first_name + last_name,
-                'fullname': first_name + ' ' + last_name,
-                'first_name': first_name,
-                'last_name': last_name,
-                'email': email}
-
-
-class XingAuth(ConsumerBasedOAuth):
-    """Xing OAuth authentication mechanism"""
-    AUTH_BACKEND = XingBackend
-    AUTHORIZATION_URL = XING_AUTHORIZATION_URL
-    REQUEST_TOKEN_URL = XING_REQUEST_TOKEN_URL
-    ACCESS_TOKEN_URL = XING_ACCESS_TOKEN_URL
-    SETTINGS_KEY_NAME = 'XING_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'XING_CONSUMER_SECRET'
-    SCOPE_SEPARATOR = '+'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Return user data provided"""
-        key, secret = self.get_key_and_secret()
-        consumer = oauth.Consumer(key=key, secret=secret)
-        client = oauth.Client(consumer, access_token)
-        resp, content = client.request(XING_CHECK_AUTH, 'GET')
-        profile = simplejson.loads(content)['users'][0]
-
-        try:
-            return {
-                'user_id': profile['id'],
-                'id': profile['id'],
-                'first_name': profile['first_name'],
-                'last_name': profile['last_name'],
-                'email': profile['active_email']
-            }
-        except (KeyError, IndexError):
-            pass
-
-    def auth_complete(self, *args, **kwargs):
-        """Complete auth process. Check Xing error response."""
-        oauth_problem = self.request.GET.get('oauth_problem')
-        if oauth_problem:
-            if oauth_problem == 'user_refused':
-                raise AuthCanceled(self, '')
-            else:
-                raise AuthUnknownError(self, 'Xing error was %s' %
-                                                    oauth_problem)
-        return super(XingAuth, self).auth_complete(*args, **kwargs)
-
-    def unauthorized_token(self):
-        """Makes first request to oauth. Returns an unauthorized Token."""
-        request_token_url = self.REQUEST_TOKEN_URL
-        scope = self.get_scope_argument()
-        if scope:
-            request_token_url = request_token_url + '?' + urlencode(scope)
-
-        request = self.oauth_request(
-            token=None,
-            url=request_token_url,
-            extra_params=self.request_token_extra_arguments()
-        )
-        response = self.fetch_response(request)
-        return Token.from_string(response)
-
-
-# Backend definition
-BACKENDS = {
-    'xing': XingAuth,
-}
diff --git a/src/social_auth/backends/contrib/yahoo.py b/src/social_auth/backends/contrib/yahoo.py
deleted file mode 100644
index 7cf1bd7831..0000000000
--- a/src/social_auth/backends/contrib/yahoo.py
+++ /dev/null
@@ -1,110 +0,0 @@
-"""
-OAuth 1.0 Yahoo backend
-
-Options:
-YAHOO_CONSUMER_KEY
-YAHOO_CONSUMER_SECRET
-
-References:
-* http://developer.yahoo.com/oauth/guide/oauth-auth-flow.html
-* http://developer.yahoo.com/social/rest_api_guide/
-*           introspective-guid-resource.html
-* http://developer.yahoo.com/social/rest_api_guide/
-*           extended-profile-resource.html
-
-Scopes:
-To make this extension works correctly you have to have at least
-Yahoo Profile scope with Read permission
-
-Throws:
-AuthUnknownError - if user data retrieval fails (guid or profile)
-"""
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import ConsumerBasedOAuth, OAuthBackend
-from social_auth.exceptions import AuthUnknownError
-
-
-# Google OAuth base configuration
-YAHOO_OAUTH_SERVER = 'api.login.yahoo.com'
-REQUEST_TOKEN_URL = 'https://api.login.yahoo.com/oauth/v2/get_request_token'
-AUTHORIZATION_URL = 'https://api.login.yahoo.com/oauth/v2/request_auth'
-ACCESS_TOKEN_URL = 'https://api.login.yahoo.com/oauth/v2/get_token'
-
-
-class YahooOAuthBackend(OAuthBackend):
-    """Yahoo OAuth authentication backend"""
-    name = 'yahoo-oauth'
-
-    EXTRA_DATA = [
-        ('guid', 'id'),
-        ('access_token', 'access_token'),
-        ('expires', 'expires')
-    ]
-
-    def get_user_id(self, details, response):
-        return response['guid']
-
-    def get_user_details(self, response):
-        """Return user details from Yahoo Profile"""
-        fname = response.get('givenName')
-        lname = response.get('familyName')
-        if 'emails' in response:
-            email = response.get('emails')[0]['handle']
-        else:
-            email = ''
-        return {'username': response.get('nickname'),
-                'email': email,
-                'fullname': '%s %s' % (fname, lname),
-                'first_name': fname,
-                'last_name': lname}
-
-
-class YahooOAuth(ConsumerBasedOAuth):
-    AUTHORIZATION_URL = AUTHORIZATION_URL
-    REQUEST_TOKEN_URL = REQUEST_TOKEN_URL
-    ACCESS_TOKEN_URL = ACCESS_TOKEN_URL
-    AUTH_BACKEND = YahooOAuthBackend
-    SETTINGS_KEY_NAME = 'YAHOO_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'YAHOO_CONSUMER_SECRET'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Loads user data from service"""
-        guid = self._get_guid(access_token)
-        url = 'http://social.yahooapis.com/v1/user/%s/profile?format=json' \
-                    % guid
-        request = self.oauth_request(access_token, url)
-        response = self.fetch_response(request)
-        try:
-            return simplejson.loads(response)['profile']
-        except ValueError:
-            raise AuthUnknownError('Error during profile retrieval, '
-                                   'please, try again later')
-
-    def _get_guid(self, access_token):
-        """
-            Beause you have to provide GUID for every API request
-            it's also returned during one of OAuth calls
-        """
-        url = 'http://social.yahooapis.com/v1/me/guid?format=json'
-        request = self.oauth_request(access_token, url)
-        response = self.fetch_response(request)
-        try:
-            json = simplejson.loads(response)
-            return json['guid']['value']
-        except ValueError:
-            raise AuthUnknownError('Error during user id retrieval, '
-                                   'please, try again later')
-
-
-# Backend definition
-BACKENDS = {
-    'yahoo-oauth': YahooOAuth
-}
diff --git a/src/social_auth/backends/contrib/yammer.py b/src/social_auth/backends/contrib/yammer.py
deleted file mode 100644
index 2c87df42ca..0000000000
--- a/src/social_auth/backends/contrib/yammer.py
+++ /dev/null
@@ -1,106 +0,0 @@
-"""
-Yammer OAuth2 support
-"""
-import logging
-from urllib import urlencode
-from urlparse import parse_qs
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from django.utils.datastructures import MergeDict
-
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.exceptions import AuthCanceled
-from social_auth.utils import dsa_urlopen, setting
-
-
-YAMMER_SERVER = 'yammer.com'
-YAMMER_STAGING_SERVER = 'staging.yammer.com'
-YAMMER_OAUTH_URL = 'https://www.%s/oauth2/' % YAMMER_SERVER
-YAMMER_AUTH_URL = 'https://www.%s/dialog/oauth' % YAMMER_SERVER
-YAMMER_API_URL = 'https://www.%s/api/v1/' % YAMMER_SERVER
-
-
-class YammerBackend(OAuthBackend):
-    name = 'yammer'
-    EXTRA_DATA = [
-        ('id', 'id'),
-        ('expires', 'expires'),
-        ('mugshot_url', 'mugshot_url')
-    ]
-
-    def get_user_id(self, details, response):
-        return response['user']['id']
-
-    def get_user_details(self, response):
-        username = response['user']['name']
-        first_name = response['user']['first_name']
-        last_name = response['user']['last_name']
-        full_name = response['user']['full_name']
-        email = response['user']['contact']['email_addresses'][0]['address']
-        mugshot_url = response['user']['mugshot_url']
-        return {
-            'username': username,
-            'email': email,
-            'fullname': full_name,
-            'first_name': first_name,
-            'last_name': last_name,
-            'picture_url': mugshot_url
-        }
-
-
-class YammerOAuth2(BaseOAuth2):
-    AUTH_BACKEND = YammerBackend
-    AUTHORIZATION_URL = YAMMER_AUTH_URL
-    ACCESS_TOKEN_URL = '%s%s' % (YAMMER_OAUTH_URL, 'access_token')
-    REQUEST_TOKEN_URL = '%s%s' % (YAMMER_OAUTH_URL, 'request_token')
-    SETTINGS_KEY_NAME = 'YAMMER_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'YAMMER_CONSUMER_SECRET'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Load user data from yammer"""
-        params = {
-            'client_id': setting(self.SETTINGS_KEY_NAME, ''),
-            'client_secret': setting(self.SETTINGS_SECRET_NAME, ''),
-            'code': access_token
-        }
-
-        url = '%s?%s' % (self.ACCESS_TOKEN_URL, urlencode(params))
-
-        try:
-            return simplejson.load(dsa_urlopen(url))
-        except Exception, e:
-            logging.exception(e)
-        return None
-
-    def auth_complete(self, *args, **kwargs):
-        """Yammer API is a little strange"""
-        if 'error' in self.data:
-            logging.error("%s: %s:\n%s" % (
-                self.data('error'), self.data('error_reason'),
-                self.data('error_description')
-            ))
-            raise AuthCanceled(self)
-
-        # now we need to clean up the data params
-        data = dict(self.data.copy())
-        redirect_state = data.get('redirect_state')
-        if redirect_state and '?' in redirect_state:
-            redirect_state, extra = redirect_state.split('?', 1)
-            extra = parse_qs(extra)
-            data['redirect_state'] = redirect_state
-            if 'code' in extra:
-                data['code'] = extra['code'][0]
-        self.data = MergeDict(data)
-        return super(YammerOAuth2, self).auth_complete(*args, **kwargs)
-
-
-BACKENDS = {
-    'yammer': YammerOAuth2
-}
diff --git a/src/social_auth/backends/contrib/yammer_staging.py b/src/social_auth/backends/contrib/yammer_staging.py
deleted file mode 100644
index 144b9e4eb9..0000000000
--- a/src/social_auth/backends/contrib/yammer_staging.py
+++ /dev/null
@@ -1,27 +0,0 @@
-"""
-Yammer Staging OAuth2 support
-"""
-from social_auth.backends.contrib.yammer import YammerBackend, YammerOAuth2
-
-
-YAMMER_STAGING_SERVER = 'staging.yammer.com'
-YAMMER_STAGING_OAUTH_URL = 'https://www.%s/oauth2/' % YAMMER_STAGING_SERVER
-YAMMER_STAGING_AUTH_URL = 'https://www.%s/dialog/oauth' % YAMMER_STAGING_SERVER
-
-
-class YammerStagingBackend(YammerBackend):
-    name = 'yammer_staging'
-
-
-class YammerStagingOAuth2(YammerOAuth2):
-    AUTH_BACKEND = YammerStagingBackend
-    AUTHORIZATION_URL = YAMMER_STAGING_AUTH_URL
-    ACCESS_TOKEN_URL = '%s%s' % (YAMMER_STAGING_OAUTH_URL, 'access_token')
-    REQUEST_TOKEN_URL = '%s%s' % (YAMMER_STAGING_OAUTH_URL, 'request_token')
-    SETTINGS_KEY_NAME = 'YAMMER_STAGING_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'YAMMER_STAGING_CONSUMER_SECRET'
-
-
-BACKENDS = {
-    'yammer_staging': YammerStagingOAuth2
-}
diff --git a/src/social_auth/backends/contrib/yandex.py b/src/social_auth/backends/contrib/yandex.py
deleted file mode 100644
index 46f9f003a2..0000000000
--- a/src/social_auth/backends/contrib/yandex.py
+++ /dev/null
@@ -1,165 +0,0 @@
-"""
-Yandex OpenID and OAuth2 support.
-
-This contribution adds support for Yandex.ru OpenID service in the form
-openid.yandex.ru/user. Username is retrieved from the identity url.
-
-If username is not specified, OpenID 2.0 url used for authentication.
-"""
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from urllib import urlencode
-from urlparse import urlparse, urlsplit
-
-from social_auth.backends import OpenIDBackend, OpenIdAuth, OAuthBackend, \
-                                 BaseOAuth2
-
-from social_auth.utils import setting, log, dsa_urlopen
-
-# Yandex configuration
-YANDEX_AUTHORIZATION_URL = 'https://oauth.yandex.ru/authorize'
-YANDEX_ACCESS_TOKEN_URL = 'https://oauth.yandex.ru/token'
-YANDEX_SERVER = 'oauth.yandex.ru'
-
-YANDEX_OPENID_URL = 'http://openid.yandex.ru'
-
-
-def get_username_from_url(links):
-    try:
-        host = urlparse(links.get('www')).hostname
-        return host.split('.')[0]
-    except (IndexError, AttributeError):
-        return None
-
-
-class YandexBackend(OpenIDBackend):
-    """Yandex OpenID authentication backend"""
-    name = 'yandex'
-
-    def get_user_id(self, details, response):
-        return details['email'] or response.identity_url
-
-    def get_user_details(self, response):
-        """Generate username from identity url"""
-        values = super(YandexBackend, self).get_user_details(response)
-        values['username'] = values.get('username') or \
-                             urlsplit(response.identity_url).path.strip('/')
-
-        values['email'] = values.get('email', '')
-
-        return values
-
-
-class YandexAuth(OpenIdAuth):
-    """Yandex OpenID authentication"""
-    AUTH_BACKEND = YandexBackend
-
-    def openid_url(self):
-        """Returns Yandex authentication URL"""
-        return YANDEX_OPENID_URL
-
-
-class YaruBackend(OAuthBackend):
-    """Yandex OAuth authentication backend"""
-    name = 'yaru'
-    EXTRA_DATA = [
-        ('id', 'id'),
-        ('expires', 'expires')
-    ]
-
-    def get_user_details(self, response):
-        """Return user details from Yandex account"""
-        name = response['name']
-        last_name = ''
-
-        if ' ' in name:
-            names = name.split(' ')
-            last_name = names[0]
-            first_name = names[1]
-        else:
-            first_name = name
-
-        return {
-            'username': get_username_from_url(response.get('links')),
-            'email': response.get('email', ''),
-            'first_name': first_name,
-            'last_name': last_name,
-        }
-
-
-class YaruAuth(BaseOAuth2):
-    """Yandex Ya.ru OAuth mechanism"""
-    AUTHORIZATION_URL = YANDEX_AUTHORIZATION_URL
-    ACCESS_TOKEN_URL = YANDEX_ACCESS_TOKEN_URL
-    AUTH_BACKEND = YaruBackend
-    REDIRECT_STATE = False
-    SETTINGS_KEY_NAME = 'YANDEX_APP_ID'
-    SETTINGS_SECRET_NAME = 'YANDEX_API_SECRET'
-
-    def get_api_url(self):
-        return 'https://api-yaru.yandex.ru/me/'
-
-    def user_data(self, access_token, response, *args, **kwargs):
-        """Loads user data from service"""
-        params = {'oauth_token': access_token,
-                  'format': 'json',
-                  'text': 1,
-                  }
-
-        url = self.get_api_url() + '?' + urlencode(params)
-        try:
-            return simplejson.load(dsa_urlopen(url))
-        except (ValueError, IndexError):
-            log('error', 'Could not load data from Yandex.',
-                exc_info=True, extra=dict(data=params))
-            return None
-
-
-class YandexOAuth2Backend(YaruBackend):
-    """Legacy Yandex OAuth2 authentication backend"""
-    name = 'yandex-oauth2'
-
-
-class YandexOAuth2(YaruAuth):
-    """Yandex Ya.ru/Moi Krug OAuth mechanism"""
-    AUTH_BACKEND = YandexOAuth2Backend
-
-    def get_api_url(self):
-        return setting('YANDEX_OAUTH2_API_URL')
-
-    def user_data(self, access_token, response, *args, **kwargs):
-        reply = super(YandexOAuth2, self).user_data(access_token,
-                                                    response, args, kwargs)
-
-        if reply:
-            if isinstance(reply, list) and len(reply) >= 1:
-                reply = reply[0]
-
-            if 'links' in reply:
-                userpic = reply['links'].get('avatar')
-            elif 'avatar' in reply:
-                userpic = reply['avatar'].get('Portrait')
-            else:
-                userpic = ''
-
-            reply.update({
-                'id': reply['id'].split("/")[-1],
-                'access_token': access_token,
-                'userpic': userpic
-            })
-
-        return reply
-
-
-# Backend definition
-BACKENDS = {
-    'yandex': YandexAuth,
-    'yaru': YaruAuth,
-    'yandex-oauth2': YandexOAuth2
-}
diff --git a/src/social_auth/backends/facebook.py b/src/social_auth/backends/facebook.py
deleted file mode 100644
index 3f1d791a23..0000000000
--- a/src/social_auth/backends/facebook.py
+++ /dev/null
@@ -1,318 +0,0 @@
-"""
-Facebook OAuth support.
-
-This contribution adds support for Facebook OAuth service. The settings
-FACEBOOK_APP_ID and FACEBOOK_API_SECRET must be defined with the values
-given by Facebook application registration process.
-
-Extended permissions are supported by defining FACEBOOK_EXTENDED_PERMISSIONS
-setting, it must be a list of values to request.
-
-By default account id and token expiration time are stored in extra_data
-field, check OAuthBackend class for details on how to extend it.
-"""
-import cgi
-import base64
-import hmac
-import hashlib
-import time
-from urllib import urlencode
-from urllib2 import HTTPError
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from django.contrib.auth import authenticate
-from django.http import HttpResponse
-from django.template import TemplateDoesNotExist, RequestContext, loader
-
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.utils import sanitize_log_data, backend_setting, setting,\
-    log, dsa_urlopen
-from social_auth.exceptions import AuthException, AuthCanceled, AuthFailed,\
-    AuthTokenError, AuthUnknownError
-
-
-# Facebook configuration
-FACEBOOK_ME = 'https://graph.facebook.com/me?'
-ACCESS_TOKEN = 'https://graph.facebook.com/oauth/access_token?'
-USE_APP_AUTH = setting('FACEBOOK_APP_AUTH', False)
-LOCAL_HTML = setting('FACEBOOK_LOCAL_HTML', 'facebook.html')
-APP_NAMESPACE = setting('FACEBOOK_APP_NAMESPACE', None)
-REDIRECT_HTML = """
-<script type="text/javascript">
-    var domain = 'https://apps.facebook.com/',
-        redirectURI = domain + '{{ FACEBOOK_APP_NAMESPACE }}' + '/';
-    window.top.location = 'https://www.facebook.com/dialog/oauth/' +
-    '?client_id={{ FACEBOOK_APP_ID }}' +
-    '&redirect_uri=' + encodeURIComponent(redirectURI) +
-    '&scope={{ FACEBOOK_EXTENDED_PERMISSIONS }}';
-</script>
-"""
-
-
-class FacebookBackend(OAuthBackend):
-    """Facebook OAuth2 authentication backend"""
-    name = 'facebook'
-    # Default extra data to store
-    EXTRA_DATA = [
-        ('id', 'id'),
-        ('expires', 'expires')
-    ]
-
-    def get_user_details(self, response):
-        """Return user details from Facebook account"""
-        return {'username': response.get('username', response.get('name')),
-                'email': response.get('email', ''),
-                'fullname': response.get('name', ''),
-                'first_name': response.get('first_name', ''),
-                'last_name': response.get('last_name', '')}
-
-
-class FacebookAuth(BaseOAuth2):
-    """Facebook OAuth2 support"""
-    AUTH_BACKEND = FacebookBackend
-    RESPONSE_TYPE = None
-    SCOPE_SEPARATOR = ','
-    AUTHORIZATION_URL = 'https://www.facebook.com/dialog/oauth'
-    REVOKE_TOKEN_URL = 'https://graph.facebook.com/{uid}/permissions'
-    REVOKE_TOKEN_METHOD = 'DELETE'
-    ACCESS_TOKEN_URL = ACCESS_TOKEN
-    SETTINGS_KEY_NAME = 'FACEBOOK_APP_ID'
-    SETTINGS_SECRET_NAME = 'FACEBOOK_API_SECRET'
-    SCOPE_VAR_NAME = 'FACEBOOK_EXTENDED_PERMISSIONS'
-    EXTRA_PARAMS_VAR_NAME = 'FACEBOOK_PROFILE_EXTRA_PARAMS'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """
-        Grab user profile information from facebook.
-
-        returns: dict or None
-        """
-
-        data = None
-        params = backend_setting(self, self.EXTRA_PARAMS_VAR_NAME, {})
-        params['access_token'] = access_token
-        url = FACEBOOK_ME + urlencode(params)
-
-        try:
-            response = dsa_urlopen(url)
-            data = simplejson.load(response)
-        except ValueError:
-            extra = {'access_token': sanitize_log_data(access_token)}
-            log('error', 'Could not load user data from Facebook.',
-                exc_info=True, extra=extra)
-        except HTTPError:
-            extra = {'access_token': sanitize_log_data(access_token)}
-            log('error', 'Error validating access token.',
-                exc_info=True, extra=extra)
-            raise AuthTokenError(self)
-        else:
-            log('debug', 'Found user data for token %s',
-                sanitize_log_data(access_token), extra={'data': data})
-        return data
-
-    def auth_complete(self, *args, **kwargs):
-        """Completes loging process, must return user instance"""
-        access_token = None
-        expires = None
-
-        if 'code' in self.data:
-            state = self.validate_state()
-            url = ACCESS_TOKEN + urlencode({
-                'client_id': backend_setting(self, self.SETTINGS_KEY_NAME),
-                'redirect_uri': self.get_redirect_uri(state),
-                'client_secret': backend_setting(
-                    self,
-                    self.SETTINGS_SECRET_NAME
-                ),
-                'code': self.data['code']
-            })
-            try:
-                payload = dsa_urlopen(url)
-            except HTTPError:
-                raise AuthFailed(self, 'There was an error authenticating '
-                                       'the app')
-
-            response = payload.read()
-            parsed_response = cgi.parse_qs(response)
-
-            access_token = parsed_response['access_token'][0]
-            if 'expires' in parsed_response:
-                expires = parsed_response['expires'][0]
-
-        if 'signed_request' in self.data:
-            response = load_signed_request(
-                self.data.get('signed_request'),
-                backend_setting(self, self.SETTINGS_SECRET_NAME)
-            )
-
-            if response is not None:
-                access_token = response.get('access_token') or\
-                               response.get('oauth_token') or\
-                               self.data.get('access_token')
-
-                if 'expires' in response:
-                    expires = response['expires']
-
-        if access_token:
-            return self.do_auth(access_token, expires=expires, *args, **kwargs)
-        else:
-            if self.data.get('error') == 'access_denied':
-                raise AuthCanceled(self)
-            else:
-                raise AuthException(self)
-
-    @classmethod
-    def process_refresh_token_response(cls, response):
-        return dict((key, val[0])
-                        for key, val in cgi.parse_qs(response).iteritems())
-
-    @classmethod
-    def refresh_token_params(cls, token):
-        client_id, client_secret = cls.get_key_and_secret()
-        return {
-            'fb_exchange_token': token,
-            'grant_type': 'fb_exchange_token',
-            'client_id': client_id,
-            'client_secret': client_secret
-        }
-
-    def do_auth(self, access_token, expires=None, *args, **kwargs):
-        data = self.user_data(access_token)
-
-        if not isinstance(data, dict):
-            # From time to time Facebook responds back a JSON with just
-            # False as value, the reason is still unknown, but since the
-            # data is needed (it contains the user ID used to identify the
-            # account on further logins), this app cannot allow it to
-            # continue with the auth process.
-            raise AuthUnknownError(self, 'An error ocurred while '
-                                         'retrieving users Facebook '
-                                         'data')
-
-        data['access_token'] = access_token
-        if expires:  # expires is None on offline access
-            data['expires'] = expires
-
-        kwargs.update({'auth': self,
-                       'response': data,
-                       self.AUTH_BACKEND.name: True})
-        return authenticate(*args, **kwargs)
-
-    @classmethod
-    def enabled(cls):
-        """Return backend enabled status by checking basic settings"""
-        return backend_setting(cls, cls.SETTINGS_KEY_NAME) and\
-               backend_setting(cls, cls.SETTINGS_SECRET_NAME)
-
-    @classmethod
-    def revoke_token_params(cls, token, uid):
-        return {'access_token': token}
-
-    @classmethod
-    def process_revoke_token_response(cls, response):
-        return response.code == 200 and response.read() == 'true'
-
-
-def base64_url_decode(data):
-    data = data.encode(u'ascii')
-    data += '=' * (4 - (len(data) % 4))
-    return base64.urlsafe_b64decode(data)
-
-
-def base64_url_encode(data):
-    return base64.urlsafe_b64encode(data).rstrip('=')
-
-
-def load_signed_request(signed_request, api_secret=None):
-    try:
-        sig, payload = signed_request.split(u'.', 1)
-        sig = base64_url_decode(sig)
-        data = simplejson.loads(base64_url_decode(payload))
-
-        expected_sig = hmac.new(api_secret or setting('FACEBOOK_API_SECRET'),
-            msg=payload,
-            digestmod=hashlib.sha256).digest()
-
-        # allow the signed_request to function for upto 1 day
-        if sig == expected_sig and \
-           data[u'issued_at'] > (time.time() - 86400):
-            return data
-    except ValueError:
-        pass  # ignore if can't split on dot
-
-
-class FacebookAppAuth(FacebookAuth):
-    """Facebook Application Authentication support"""
-    uses_redirect = False
-
-    def auth_complete(self, *args, **kwargs):
-        if not self.application_auth() and 'error' not in self.data:
-            return HttpResponse(self.auth_html())
-
-        access_token = None
-        expires = None
-
-        if 'signed_request' in self.data:
-            response = load_signed_request(
-                self.data.get('signed_request'),
-                backend_setting(self, self.SETTINGS_SECRET_NAME)
-            )
-
-            if response is not None:
-                access_token = response.get('access_token') or\
-                               response.get('oauth_token') or\
-                               self.data.get('access_token')
-
-                if 'expires' in response:
-                    expires = response['expires']
-
-        if access_token:
-            return self.do_auth(access_token, expires=expires, *args, **kwargs)
-        else:
-            if self.data.get('error') == 'access_denied':
-                raise AuthCanceled(self)
-            else:
-                raise AuthException(self)
-
-    def application_auth(self):
-        required_params = ('user_id', 'oauth_token')
-        data = load_signed_request(
-            self.data.get('signed_request'),
-            backend_setting(self, self.SETTINGS_SECRET_NAME)
-        )
-        for param in required_params:
-            if not param in data:
-                return False
-        return True
-
-    def auth_html(self):
-        app_id = backend_setting(self, self.SETTINGS_KEY_NAME)
-        ctx = {
-            'FACEBOOK_APP_ID': app_id,
-            'FACEBOOK_EXTENDED_PERMISSIONS': ','.join(
-                backend_setting(self, self.SCOPE_VAR_NAME)
-            ),
-            'FACEBOOK_COMPLETE_URI': self.redirect_uri,
-            'FACEBOOK_APP_NAMESPACE': APP_NAMESPACE or app_id
-        }
-
-        try:
-            fb_template = loader.get_template(LOCAL_HTML)
-        except TemplateDoesNotExist:
-            fb_template = loader.get_template_from_string(REDIRECT_HTML)
-        context = RequestContext(self.request, ctx)
-
-        return fb_template.render(context)
-
-
-# Backend definition
-BACKENDS = {
-    'facebook': FacebookAppAuth if USE_APP_AUTH else FacebookAuth,
-}
diff --git a/src/social_auth/backends/contrib/github.py b/src/social_auth/backends/github.py
similarity index 97%
rename from src/social_auth/backends/contrib/github.py
rename to src/social_auth/backends/github.py
index 2dfe0d19b2..ba4f916833 100644
--- a/src/social_auth/backends/contrib/github.py
+++ b/src/social_auth/backends/github.py
@@ -14,6 +14,8 @@ setting, it must be a list of values to request.
 By default account id and token expiration time are stored in extra_data
 field, check OAuthBackend class for details on how to extend it.
 """
+from __future__ import absolute_import
+
 from urllib import urlencode
 from urllib2 import HTTPError
 
@@ -39,7 +41,7 @@ GITHUB_USER_DATA_URL = 'https://api.github.com/user'
 
 # GitHub organization configuration
 GITHUB_ORGANIZATION_MEMBER_OF_URL = \
-        'https://api.github.com/orgs/{org}/members/{username}'
+    'https://api.github.com/orgs/{org}/members/{username}'
 
 GITHUB_SERVER = 'github.com'
 
diff --git a/src/social_auth/backends/google.py b/src/social_auth/backends/google.py
deleted file mode 100644
index d03484b8f0..0000000000
--- a/src/social_auth/backends/google.py
+++ /dev/null
@@ -1,275 +0,0 @@
-"""
-Google OpenID and OAuth support
-
-OAuth works straightforward using anonymous configurations, username
-is generated by requesting email to the not documented, googleapis.com
-service. Registered applications can define settings GOOGLE_CONSUMER_KEY
-and GOOGLE_CONSUMER_SECRET and they will be used in the auth process.
-Setting GOOGLE_OAUTH_EXTRA_SCOPE can be used to access different user
-related data, like calendar, contacts, docs, etc.
-
-OAuth2 works similar to OAuth but application must be defined on Google
-APIs console https://code.google.com/apis/console/ Identity option.
-
-OpenID also works straightforward, it doesn't need further configurations.
-"""
-from urllib import urlencode
-from urllib2 import Request
-
-from oauth2 import Request as OAuthRequest
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.utils import setting, dsa_urlopen
-from social_auth.backends import OpenIdAuth, ConsumerBasedOAuth, BaseOAuth2, \
-                                 OAuthBackend, OpenIDBackend
-from social_auth.exceptions import AuthFailed
-
-
-# Google OAuth base configuration
-GOOGLE_OAUTH_SERVER = 'www.google.com'
-AUTHORIZATION_URL = 'https://www.google.com/accounts/OAuthAuthorizeToken'
-REQUEST_TOKEN_URL = 'https://www.google.com/accounts/OAuthGetRequestToken'
-ACCESS_TOKEN_URL = 'https://www.google.com/accounts/OAuthGetAccessToken'
-
-# Google OAuth2 base configuration
-GOOGLE_OAUTH2_SERVER = 'accounts.google.com'
-GOOGLE_OATUH2_AUTHORIZATION_URL = 'https://accounts.google.com/o/oauth2/auth'
-
-# scope for user email, specify extra scopes in settings, for example:
-# GOOGLE_OAUTH_EXTRA_SCOPE = ['https://www.google.com/m8/feeds/']
-GOOGLE_OAUTH_SCOPE = ['https://www.googleapis.com/auth/userinfo#email']
-GOOGLE_OAUTH2_SCOPE = ['https://www.googleapis.com/auth/userinfo.email',
-                       'https://www.googleapis.com/auth/userinfo.profile']
-GOOGLEAPIS_EMAIL = 'https://www.googleapis.com/userinfo/email'
-GOOGLEAPIS_PROFILE = 'https://www.googleapis.com/oauth2/v1/userinfo'
-GOOGLE_OPENID_URL = 'https://www.google.com/accounts/o8/id'
-
-
-# Backends
-class GoogleOAuthBackend(OAuthBackend):
-    """Google OAuth authentication backend"""
-    name = 'google-oauth'
-
-    def get_user_id(self, details, response):
-        """Use google email as unique id"""
-        validate_whitelists(self, details['email'])
-        return details['email']
-
-    def get_user_details(self, response):
-        """Return user details from Orkut account"""
-        email = response.get('email', '')
-        return {'username': email.split('@', 1)[0],
-                'email': email,
-                'fullname': '',
-                'first_name': '',
-                'last_name': ''}
-
-
-class GoogleOAuth2Backend(GoogleOAuthBackend):
-    """Google OAuth2 authentication backend"""
-    name = 'google-oauth2'
-    EXTRA_DATA = [
-        ('refresh_token', 'refresh_token', True),
-        ('expires_in', 'expires'),
-        ('token_type', 'token_type', True)
-    ]
-
-    def get_user_id(self, details, response):
-        """Use google email or id as unique id"""
-        user_id = super(GoogleOAuth2Backend, self).get_user_id(details,
-                                                               response)
-        if setting('GOOGLE_OAUTH2_USE_UNIQUE_USER_ID', False):
-            return response['id']
-        return user_id
-
-    def get_user_details(self, response):
-        email = response.get('email', '')
-        return {'username': email.split('@', 1)[0],
-                'email': email,
-                'fullname': response.get('name', ''),
-                'first_name': response.get('given_name', ''),
-                'last_name': response.get('family_name', '')}
-
-
-class GoogleBackend(OpenIDBackend):
-    """Google OpenID authentication backend"""
-    name = 'google'
-
-    def get_user_id(self, details, response):
-        """
-        Return user unique id provided by service. For google user email
-        is unique enought to flag a single user. Email comes from schema:
-        http://axschema.org/contact/email
-        """
-        validate_whitelists(self, details['email'])
-
-        return details['email']
-
-
-# Auth classes
-class GoogleAuth(OpenIdAuth):
-    """Google OpenID authentication"""
-    AUTH_BACKEND = GoogleBackend
-
-    def openid_url(self):
-        """Return Google OpenID service url"""
-        return GOOGLE_OPENID_URL
-
-
-class BaseGoogleOAuth(ConsumerBasedOAuth):
-    """Base class for Google OAuth mechanism"""
-    AUTHORIZATION_URL = AUTHORIZATION_URL
-    REQUEST_TOKEN_URL = REQUEST_TOKEN_URL
-    ACCESS_TOKEN_URL = ACCESS_TOKEN_URL
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Loads user data from G service"""
-        raise NotImplementedError('Implement in subclass')
-
-
-class GoogleOAuth(BaseGoogleOAuth):
-    """Google OAuth authorization mechanism"""
-    AUTH_BACKEND = GoogleOAuthBackend
-    SETTINGS_KEY_NAME = 'GOOGLE_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'GOOGLE_CONSUMER_SECRET'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Return user data from Google API"""
-        request = self.oauth_request(access_token, GOOGLEAPIS_EMAIL,
-                                     {'alt': 'json'})
-        url, params = request.to_url().split('?', 1)
-        return googleapis_email(url, params)
-
-    def oauth_authorization_request(self, token):
-        """Generate OAuth request to authorize token."""
-        return OAuthRequest.from_consumer_and_token(self.consumer,
-                    token=token,
-                    http_url=self.AUTHORIZATION_URL)
-
-    def oauth_request(self, token, url, extra_params=None):
-        extra_params = extra_params or {}
-        scope = GOOGLE_OAUTH_SCOPE + setting('GOOGLE_OAUTH_EXTRA_SCOPE', [])
-        extra_params.update({
-            'scope': ' '.join(scope),
-        })
-        if not self.registered():
-            xoauth_displayname = setting('GOOGLE_DISPLAY_NAME', 'Social Auth')
-            extra_params['xoauth_displayname'] = xoauth_displayname
-        return super(GoogleOAuth, self).oauth_request(token, url, extra_params)
-
-    @classmethod
-    def get_key_and_secret(cls):
-        """Return Google OAuth Consumer Key and Consumer Secret pair, uses
-        anonymous by default, beware that this marks the application as not
-        registered and a security badge is displayed on authorization page.
-        http://code.google.com/apis/accounts/docs/OAuth_ref.html#SigningOAuth
-        """
-        try:
-            return super(GoogleOAuth, cls).get_key_and_secret()
-        except AttributeError:
-            return 'anonymous', 'anonymous'
-
-    @classmethod
-    def enabled(cls):
-        """Google OAuth is always enabled because of anonymous access"""
-        return True
-
-    def registered(self):
-        """Check if Google OAuth Consumer Key and Consumer Secret are set"""
-        return self.get_key_and_secret() != ('anonymous', 'anonymous')
-
-
-# TODO: Remove this setting name check, keep for backward compatibility
-_OAUTH2_KEY_NAME = setting('GOOGLE_OAUTH2_CLIENT_ID') and \
-                   'GOOGLE_OAUTH2_CLIENT_ID' or \
-                   'GOOGLE_OAUTH2_CLIENT_KEY'
-
-
-class GoogleOAuth2(BaseOAuth2):
-    """Google OAuth2 support"""
-    AUTH_BACKEND = GoogleOAuth2Backend
-    AUTHORIZATION_URL = 'https://accounts.google.com/o/oauth2/auth'
-    ACCESS_TOKEN_URL = 'https://accounts.google.com/o/oauth2/token'
-    REVOKE_TOKEN_URL = 'https://accounts.google.com/o/oauth2/revoke'
-    REVOKE_TOKEN_METHOD = 'GET'
-    SETTINGS_KEY_NAME = _OAUTH2_KEY_NAME
-    SETTINGS_SECRET_NAME = 'GOOGLE_OAUTH2_CLIENT_SECRET'
-    SCOPE_VAR_NAME = 'GOOGLE_OAUTH_EXTRA_SCOPE'
-    DEFAULT_SCOPE = GOOGLE_OAUTH2_SCOPE
-    REDIRECT_STATE = False
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Return user data from Google API"""
-        return googleapis_profile(GOOGLEAPIS_PROFILE, access_token)
-
-    @classmethod
-    def revoke_token_params(cls, token, uid):
-        return {'token': token}
-
-    @classmethod
-    def revoke_token_headers(cls, token, uid):
-        return {'Content-type': 'application/json'}
-
-
-def googleapis_email(url, params):
-    """Loads user data from googleapis service, only email so far as it's
-    described in http://sites.google.com/site/oauthgoog/Home/emaildisplayscope
-
-    Parameters must be passed in queryset and Authorization header as described
-    on Google OAuth documentation at:
-    http://groups.google.com/group/oauth/browse_thread/thread/d15add9beb418ebc
-    and: http://code.google.com/apis/accounts/docs/OAuth2.html#CallingAnAPI
-    """
-    request = Request(url + '?' + params, headers={'Authorization': params})
-    try:
-        return simplejson.loads(dsa_urlopen(request).read())['data']
-    except (ValueError, KeyError, IOError):
-        return None
-
-
-def googleapis_profile(url, access_token):
-    """
-    Loads user data from googleapis service, such as name, given_name,
-    family_name, etc. as it's described in:
-    https://developers.google.com/accounts/docs/OAuth2Login
-    """
-    data = {'access_token': access_token, 'alt': 'json'}
-    request = Request(url + '?' + urlencode(data))
-    try:
-        return simplejson.loads(dsa_urlopen(request).read())
-    except (ValueError, KeyError, IOError):
-        return None
-
-
-def validate_whitelists(backend, email):
-    """
-    Validates allowed domains and emails against the following settings:
-        GOOGLE_WHITE_LISTED_DOMAINS
-        GOOGLE_WHITE_LISTED_EMAILS
-
-    All domains and emails are allowed if setting is an empty list.
-    """
-    emails = setting('GOOGLE_WHITE_LISTED_EMAILS', [])
-    domains = setting('GOOGLE_WHITE_LISTED_DOMAINS', [])
-    if not emails and not domains:
-        return True
-    if email in set(emails):
-        return True # you're good
-    if email.split('@', 1)[1] in set(domains):
-        return True
-    raise AuthFailed(backend, 'User not allowed')
-
-
-# Backend definition
-BACKENDS = {
-    'google': GoogleAuth,
-    'google-oauth': GoogleOAuth,
-    'google-oauth2': GoogleOAuth2,
-}
diff --git a/src/social_auth/backends/pipeline/__init__.py b/src/social_auth/backends/pipeline/__init__.py
index 8f39bdb893..0927a60cf6 100644
--- a/src/social_auth/backends/pipeline/__init__.py
+++ b/src/social_auth/backends/pipeline/__init__.py
@@ -5,3 +5,4 @@ to next pipeline item. Pipelines must take **kwargs parameters to avoid
 failure. At some point a pipeline entry must create a UserSocialAuth instance
 and load it to the output if the user logged in correctly.
 """
+from __future__ import absolute_import
diff --git a/src/social_auth/backends/pipeline/associate.py b/src/social_auth/backends/pipeline/associate.py
index fead77dc58..363a0446be 100644
--- a/src/social_auth/backends/pipeline/associate.py
+++ b/src/social_auth/backends/pipeline/associate.py
@@ -1,3 +1,5 @@
+from __future__ import absolute_import
+
 from django.core.exceptions import MultipleObjectsReturned, ObjectDoesNotExist
 
 from social_auth.models import UserSocialAuth
diff --git a/src/social_auth/backends/pipeline/misc.py b/src/social_auth/backends/pipeline/misc.py
index 91ccdb246a..f463212ab1 100644
--- a/src/social_auth/backends/pipeline/misc.py
+++ b/src/social_auth/backends/pipeline/misc.py
@@ -1,3 +1,5 @@
+from __future__ import absolute_import
+
 from social_auth.backends import PIPELINE
 from social_auth.utils import setting
 
diff --git a/src/social_auth/backends/pipeline/sauth.py b/src/social_auth/backends/pipeline/sauth.py
index 49ab7f9838..840bf69adb 100644
--- a/src/social_auth/backends/pipeline/sauth.py
+++ b/src/social_auth/backends/pipeline/sauth.py
@@ -1,3 +1,5 @@
-from social.pipeline.social_auth import social_user as social_auth_user, \
-                                        associate_user, load_extra_data
-social_auth_user, associate_user, load_extra_data  # placate pyflakes
+from __future__ import absolute_import
+
+from social.pipeline.social_auth import (  # NOQA
+    social_user as social_auth_user, associate_user, load_extra_data
+)
diff --git a/src/social_auth/backends/pipeline/social.py b/src/social_auth/backends/pipeline/social.py
index 3d414c5a16..eee81cf7bc 100644
--- a/src/social_auth/backends/pipeline/social.py
+++ b/src/social_auth/backends/pipeline/social.py
@@ -1,3 +1,5 @@
+from __future__ import absolute_import
+
 from django.db import IntegrityError
 from django.utils.translation import ugettext
 
@@ -54,7 +56,7 @@ def load_extra_data(backend, details, response, uid, user, social_user=None,
                    UserSocialAuth.get_social_auth(backend.name, uid))
     if social_user:
         extra_data = backend.extra_data(user, uid, response, details)
-        if kwargs.get('original_email') and not 'email' in extra_data:
+        if kwargs.get('original_email') and 'email' not in extra_data:
             extra_data['email'] = kwargs.get('original_email')
         if extra_data and social_user.extra_data != extra_data:
             if social_user.extra_data:
diff --git a/src/social_auth/backends/pipeline/user.py b/src/social_auth/backends/pipeline/user.py
index 9a721b53ea..7f03dd0860 100644
--- a/src/social_auth/backends/pipeline/user.py
+++ b/src/social_auth/backends/pipeline/user.py
@@ -1,3 +1,5 @@
+from __future__ import absolute_import
+
 from uuid import uuid4
 
 from social_auth.utils import setting, module_member
@@ -69,29 +71,12 @@ def create_user(backend, details, response, uid, username, user=None, *args,
 
 
 def _ignore_field(name, is_new=False):
-    return name in ('username', 'id', 'pk') or \
-           (not is_new and
-                name in setting('SOCIAL_AUTH_PROTECTED_USER_FIELDS', []))
-
+    if name in ('username', 'id', 'pk'):
+        return True
 
-def mongoengine_orm_maxlength_truncate(backend, details, user=None,
-                                       is_new=False, *args, **kwargs):
-    """Truncate any value in details that corresponds with a field in the user
-    model. Add this entry to the pipeline before update_user_details"""
-    if user is None:
-        return
-    out = {}
-    names = list(user._fields.keys())
-    for name, value in details.iteritems():
-        if name in names and not _ignore_field(name, is_new):
-            max_length = user._fields[name].max_length
-            try:
-                if max_length and len(value) > max_length:
-                    value = value[:max_length]
-            except TypeError:
-                pass
-        out[name] = value
-    return {'details': out}
+    if not is_new and name in setting('SOCIAL_AUTH_PROTECTED_USER_FIELDS', []):
+        return True
+    return False
 
 
 def django_orm_maxlength_truncate(backend, details, user=None, is_new=False,
diff --git a/src/social_auth/backends/reddit.py b/src/social_auth/backends/reddit.py
deleted file mode 100644
index 8d02b88f92..0000000000
--- a/src/social_auth/backends/reddit.py
+++ /dev/null
@@ -1,82 +0,0 @@
-import base64
-from urllib2 import Request, HTTPError
-from urllib import urlencode
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.utils import dsa_urlopen
-from social_auth.exceptions import AuthTokenError
-
-
-class RedditBackend(OAuthBackend):
-    """Reddit OAuth2 authentication backend"""
-    name = 'reddit'
-    # Default extra data to store
-    EXTRA_DATA = [
-        ('id', 'id'),
-        ('link_karma', 'link_karma'),
-        ('comment_karma', 'comment_karma'),
-        ('refresh_token', 'refresh_token'),
-        ('expires_in', 'expires')
-    ]
-
-    def get_user_details(self, response):
-        """Return user details from reddit account"""
-        return {'username': response.get('name'),
-                'email': '', 'fullname': '',
-                'first_name': '', 'last_name': ''}
-
-
-class RedditAuth(BaseOAuth2):
-    """Reddit OAuth2 support"""
-    REDIRECT_STATE = False
-    AUTH_BACKEND = RedditBackend
-    SCOPE_SEPARATOR = ','
-    AUTHORIZATION_URL = 'https://ssl.reddit.com/api/v1/authorize'
-    ACCESS_TOKEN_URL = 'https://ssl.reddit.com/api/v1/access_token'
-    SETTINGS_KEY_NAME = 'REDDIT_APP_ID'
-    SETTINGS_SECRET_NAME = 'REDDIT_API_SECRET'
-    SCOPE_VAR_NAME = 'REDDIT_EXTENDED_PERMISSIONS'
-    DEFAULT_SCOPE = ['identity']
-
-    @classmethod
-    def refresh_token(cls, token, redirect_uri):
-        data = cls.refresh_token_params(token)
-        data['redirect_uri'] = redirect_uri
-        request = Request(cls.ACCESS_TOKEN_URL,
-                          data=urlencode(data),
-                          headers=cls.auth_headers())
-        return cls.process_refresh_token_response(dsa_urlopen(request).read())
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Grab user profile information from reddit."""
-        try:
-            request = Request(
-                'https://oauth.reddit.com/api/v1/me.json',
-                headers={'Authorization': 'bearer %s' % access_token}
-            )
-            return simplejson.load(dsa_urlopen(request))
-        except ValueError:
-            return None
-        except HTTPError:
-            raise AuthTokenError(self)
-
-    @classmethod
-    def auth_headers(cls):
-        return {
-            'Authorization': 'Basic %s' % base64.urlsafe_b64encode(
-                '%s:%s' % cls.get_key_and_secret()
-            )
-        }
-
-
-BACKENDS = {
-    'reddit': RedditAuth
-}
diff --git a/src/social_auth/backends/steam.py b/src/social_auth/backends/steam.py
deleted file mode 100644
index 11384db7a0..0000000000
--- a/src/social_auth/backends/steam.py
+++ /dev/null
@@ -1,78 +0,0 @@
-"""Steam OpenId support"""
-import re
-import urllib
-import urllib2
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import OpenIdAuth, OpenIDBackend
-from social_auth.exceptions import AuthFailed
-from social_auth.utils import setting
-
-
-STEAM_ID = re.compile('steamcommunity.com/openid/id/(.*?)$')
-USER_INFO = 'http://api.steampowered.com/ISteamUser/GetPlayerSummaries/v0002/?'
-
-
-class SteamBackend(OpenIDBackend):
-    """Steam OpenId authentication backend"""
-    name = 'steam'
-
-    def get_user_id(self, details, response):
-        """Return user unique id provided by service"""
-        return self._user_id(response)
-
-    def get_user_details(self, response):
-        user_id = self._user_id(response)
-        url = USER_INFO + urllib.urlencode({'key': setting('STEAM_API_KEY'),
-                                            'steamids': user_id})
-        details = {}
-        try:
-            player = simplejson.load(urllib2.urlopen(url))
-        except (ValueError, IOError):
-            pass
-        else:
-            if len(player['response']['players']) > 0:
-                player = player['response']['players'][0]
-                details = {'username': player.get('personaname'),
-                           'email': '',
-                           'fullname': '',
-                           'first_name': '',
-                           'last_name': '',
-                           'player': player}
-        return details
-
-    def extra_data(self, user, uid, response, details):
-        return details['player']
-
-    def _user_id(self, response):
-        match = STEAM_ID.search(response.identity_url)
-        if match is None:
-            raise AuthFailed(self, 'Missing Steam Id')
-        return match.group(1)
-
-
-class SteamAuth(OpenIdAuth):
-    """Steam OpenId authentication"""
-    AUTH_BACKEND = SteamBackend
-
-    def openid_url(self):
-        """Return Steam OpenId service url"""
-        return 'http://steamcommunity.com/openid'
-
-    @classmethod
-    def enabled(cls):
-        """Steam OpenId is enabled when STEAM_API_KEY is defined"""
-        return setting('STEAM_API_KEY') is not None
-
-
-# Backend definition
-BACKENDS = {
-    'steam': SteamAuth
-}
diff --git a/src/social_auth/backends/stripe.py b/src/social_auth/backends/stripe.py
deleted file mode 100644
index b56f5808ef..0000000000
--- a/src/social_auth/backends/stripe.py
+++ /dev/null
@@ -1,87 +0,0 @@
-"""
-Stripe OAuth2 support.
-
-This backend adds support for Stripe OAuth2 service. The settings
-STRIPE_APP_ID and STRIPE_API_SECRET must be defined with the values
-given by Stripe application registration process.
-"""
-from social_auth.backends import BaseOAuth2, OAuthBackend
-from social_auth.exceptions import AuthFailed, AuthCanceled
-
-
-class StripeBackend(OAuthBackend):
-    """Stripe OAuth2 authentication backend"""
-    name = 'stripe'
-    ID_KEY = 'stripe_user_id'
-    EXTRA_DATA = [
-        ('stripe_publishable_key', 'stripe_publishable_key'),
-        ('access_token', 'access_token'),
-        ('livemode', 'livemode'),
-        ('token_type', 'token_type'),
-        ('refresh_token', 'refresh_token'),
-        ('stripe_user_id', 'stripe_user_id'),
-    ]
-
-    def get_user_details(self, response):
-        """Return user details from Stripe account"""
-        return {'username': response.get('stripe_user_id'),
-                'email': ''}
-
-
-class StripeAuth(BaseOAuth2):
-    """Facebook OAuth2 support"""
-    AUTH_BACKEND = StripeBackend
-    AUTHORIZATION_URL = 'https://connect.stripe.com/oauth/authorize'
-    ACCESS_TOKEN_URL = 'https://connect.stripe.com/oauth/token'
-    SCOPE_VAR_NAME = 'STRIPE_SCOPE'
-    SETTINGS_KEY_NAME = 'STRIPE_APP_ID'
-    SETTINGS_SECRET_NAME = 'STRIPE_APP_SECRET'
-    REDIRECT_STATE = False
-
-    def process_error(self, data):
-        if self.data.get('error'):
-            error = self.data.get('error_description') or self.data['error']
-            if self.data['error'] == 'access_denied':
-                raise AuthCanceled(self, error)
-            else:
-                raise AuthFailed(self, error)
-
-    def auth_params(self, state=None):
-        client_id, client_secret = self.get_key_and_secret()
-        params = {
-            'response_type': self.RESPONSE_TYPE,
-            'client_id': client_id,
-        }
-        if state:
-            params['state'] = state
-        return params
-
-    def auth_complete_params(self, state=None):
-        client_id, client_secret = self.get_key_and_secret()
-        return {
-            'grant_type': 'authorization_code',
-            'client_id': client_id,
-            'scope': self.SCOPE_SEPARATOR.join(self.get_scope()),
-            'code': self.data['code']
-       }
-
-    @classmethod
-    def auth_headers(cls):
-        client_id, client_secret = cls.get_key_and_secret()
-        return {
-            'Accept': 'application/json',
-            'Authorization': 'Bearer %s' % client_secret
-        }
-
-    @classmethod
-    def refresh_token_params(cls, refresh_token):
-        return {
-            'refresh_token': refresh_token,
-            'grant_type': 'refresh_token'
-        }
-
-
-# Backend definition
-BACKENDS = {
-    'stripe': StripeAuth
-}
diff --git a/src/social_auth/backends/contrib/trello.py b/src/social_auth/backends/trello.py
similarity index 93%
rename from src/social_auth/backends/contrib/trello.py
rename to src/social_auth/backends/trello.py
index 72c51fa2e9..6208f0fc63 100644
--- a/src/social_auth/backends/contrib/trello.py
+++ b/src/social_auth/backends/trello.py
@@ -4,7 +4,7 @@ TRELLO_CONSUMER_KEY & TRELLO_CONSUMER_SECRET
 at https://trello.com/1/appKey/generate
 and put into settings.py
 
-Also you can put something like 
+Also you can put something like
 TRELLO_AUTH_EXTRA_ARGUMENTS = {
     'name': '7WebPages Time Tracker',
     'expiration': 'never'
@@ -12,6 +12,7 @@ TRELLO_AUTH_EXTRA_ARGUMENTS = {
 
 into settings.py
 """
+from __future__ import absolute_import
 
 try:
     import json as simplejson
@@ -72,8 +73,10 @@ class TrelloBackend(OAuthBackend):
         """
         token = super(TrelloBackend, cls).tokens(instance)
         if token and 'access_token' in token:
-            token = dict(tok.split('=')
-                            for tok in token['access_token'].split('&'))
+            token = dict(
+                tok.split('=')
+                for tok in token['access_token'].split('&')
+            )
         return token
 
 
diff --git a/src/social_auth/backends/twitter.py b/src/social_auth/backends/twitter.py
deleted file mode 100644
index d533b303d9..0000000000
--- a/src/social_auth/backends/twitter.py
+++ /dev/null
@@ -1,99 +0,0 @@
-"""
-Twitter OAuth support.
-
-This adds support for Twitter OAuth service. An application must
-be registered first on twitter and the settings TWITTER_CONSUMER_KEY
-and TWITTER_CONSUMER_SECRET must be defined with the corresponding
-values.
-
-User screen name is used to generate username.
-
-By default account id is stored in extra_data field, check OAuthBackend
-class for details on how to extend it.
-"""
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from social_auth.backends import ConsumerBasedOAuth, OAuthBackend
-from social_auth.exceptions import AuthCanceled
-
-
-# Twitter configuration
-TWITTER_SERVER = 'api.twitter.com'
-TWITTER_REQUEST_TOKEN_URL = 'https://%s/oauth/request_token' % TWITTER_SERVER
-TWITTER_ACCESS_TOKEN_URL = 'https://%s/oauth/access_token' % TWITTER_SERVER
-# Note: oauth/authorize forces the user to authorize every time.
-#       oauth/authenticate uses their previous selection, barring revocation.
-TWITTER_AUTHORIZATION_URL = 'https://%s/oauth/authenticate' % TWITTER_SERVER
-TWITTER_CHECK_AUTH = 'https://%s/1.1/account/verify_credentials.json' % \
-                                    TWITTER_SERVER
-
-
-class TwitterBackend(OAuthBackend):
-    """Twitter OAuth authentication backend"""
-    name = 'twitter'
-    EXTRA_DATA = [('id', 'id')]
-
-    def get_user_details(self, response):
-        """Return user details from Twitter account"""
-        try:
-            first_name, last_name = response['name'].split(' ', 1)
-        except:
-            first_name = response['name']
-            last_name = ''
-        return {'username': response['screen_name'],
-                'email': '',  # not supplied
-                'fullname': response['name'],
-                'first_name': first_name,
-                'last_name': last_name}
-
-    @classmethod
-    def tokens(cls, instance):
-        """Return the tokens needed to authenticate the access to any API the
-        service might provide. Twitter uses a pair of OAuthToken consisting of
-        an oauth_token and oauth_token_secret.
-
-        instance must be a UserSocialAuth instance.
-        """
-        token = super(TwitterBackend, cls).tokens(instance)
-        if token and 'access_token' in token:
-            token = dict(tok.split('=')
-                            for tok in token['access_token'].split('&'))
-        return token
-
-
-class TwitterAuth(ConsumerBasedOAuth):
-    """Twitter OAuth authentication mechanism"""
-    AUTHORIZATION_URL = TWITTER_AUTHORIZATION_URL
-    REQUEST_TOKEN_URL = TWITTER_REQUEST_TOKEN_URL
-    ACCESS_TOKEN_URL = TWITTER_ACCESS_TOKEN_URL
-    AUTH_BACKEND = TwitterBackend
-    SETTINGS_KEY_NAME = 'TWITTER_CONSUMER_KEY'
-    SETTINGS_SECRET_NAME = 'TWITTER_CONSUMER_SECRET'
-
-    def user_data(self, access_token, *args, **kwargs):
-        """Return user data provided"""
-        request = self.oauth_request(access_token, TWITTER_CHECK_AUTH)
-        json = self.fetch_response(request)
-        try:
-            return simplejson.loads(json)
-        except ValueError:
-            return None
-
-    def auth_complete(self, *args, **kwargs):
-        """Completes login process, must return user instance"""
-        if 'denied' in self.data:
-            raise AuthCanceled(self)
-        else:
-            return super(TwitterAuth, self).auth_complete(*args, **kwargs)
-
-
-# Backend definition
-BACKENDS = {
-    'twitter': TwitterAuth,
-}
diff --git a/src/social_auth/backends/utils.py b/src/social_auth/backends/utils.py
index 9b26a1ef85..c140810a93 100644
--- a/src/social_auth/backends/utils.py
+++ b/src/social_auth/backends/utils.py
@@ -1,5 +1,9 @@
-from oauth2 import Consumer as OAuthConsumer, Token, Request as OAuthRequest, \
-                   SignatureMethod_HMAC_SHA1, HTTP_METHOD
+from __future__ import absolute_import
+
+from oauth2 import (
+    Consumer as OAuthConsumer, Token, Request as OAuthRequest,
+    SignatureMethod_HMAC_SHA1, HTTP_METHOD
+)
 
 try:
     import json as simplejson
diff --git a/src/social_auth/backends/yahoo.py b/src/social_auth/backends/yahoo.py
deleted file mode 100644
index 65ff401a41..0000000000
--- a/src/social_auth/backends/yahoo.py
+++ /dev/null
@@ -1,29 +0,0 @@
-"""
-Yahoo OpenID support
-
-No extra configurations are needed to make this work.
-"""
-from social_auth.backends import OpenIDBackend, OpenIdAuth
-
-
-YAHOO_OPENID_URL = 'http://me.yahoo.com'
-
-
-class YahooBackend(OpenIDBackend):
-    """Yahoo OpenID authentication backend"""
-    name = 'yahoo'
-
-
-class YahooAuth(OpenIdAuth):
-    """Yahoo OpenID authentication"""
-    AUTH_BACKEND = YahooBackend
-
-    def openid_url(self):
-        """Return Yahoo OpenID service url"""
-        return YAHOO_OPENID_URL
-
-
-# Backend definition
-BACKENDS = {
-    'yahoo': YahooAuth,
-}
diff --git a/src/social_auth/context_processors.py b/src/social_auth/context_processors.py
index cbb2d9d662..d46fe2de0b 100644
--- a/src/social_auth/context_processors.py
+++ b/src/social_auth/context_processors.py
@@ -1,3 +1,5 @@
+from __future__ import absolute_import
+
 from django.contrib.auth import REDIRECT_FIELD_NAME
 
 from social_auth.models import UserSocialAuth
@@ -20,7 +22,7 @@ def social_auth_backends(request):
 def social_auth_by_type_backends(request):
     """Load Social Auth current user data to context.
     Will add a output from backends_data to context under social_auth key where
-    each entry will be grouped by backend type (openid, oauth, oauth2).
+    each entry will be grouped by backend type (oauth, oauth2).
     """
     def context_value():
         data = backends_data(request.user)
diff --git a/src/social_auth/decorators.py b/src/social_auth/decorators.py
index 686a801bba..e1bce4e57a 100644
--- a/src/social_auth/decorators.py
+++ b/src/social_auth/decorators.py
@@ -1,3 +1,5 @@
+from __future__ import absolute_import
+
 from functools import wraps
 
 from django.core.urlresolvers import reverse
diff --git a/src/social_auth/exceptions.py b/src/social_auth/exceptions.py
index 5f7c8c55e8..897b4fff96 100644
--- a/src/social_auth/exceptions.py
+++ b/src/social_auth/exceptions.py
@@ -1,3 +1,5 @@
+from __future__ import absolute_import
+
 from django.utils.translation import ugettext
 
 
@@ -5,17 +7,19 @@ class SocialAuthBaseException(ValueError):
     """Base class for pipeline exceptions."""
     pass
 
+
 class BackendError(SocialAuthBaseException):
     def __unicode__(self):
         return ugettext(u'Backend error: %s' % self.message)
 
+
 class WrongBackend(BackendError):
     def __init__(self, backend_name):
         self.backend_name = backend_name
 
     def __unicode__(self):
         return ugettext(u'Incorrect authentication service "%s"') % \
-                self.backend_name
+            self.backend_name
 
 
 class NotAllowedToDisconnect(SocialAuthBaseException):
@@ -45,7 +49,7 @@ class AuthFailed(AuthException):
             return ugettext(u'Authentication process was cancelled')
         else:
             return ugettext(u'Authentication failed: %s') % \
-                        super(AuthFailed, self).__unicode__()
+                super(AuthFailed, self).__unicode__()
 
 
 class AuthCanceled(AuthException):
diff --git a/src/social_auth/fields.py b/src/social_auth/fields.py
index 607ffdb727..83d430eef2 100644
--- a/src/social_auth/fields.py
+++ b/src/social_auth/fields.py
@@ -1,14 +1,9 @@
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
+from __future__ import absolute_import
 
 from django.core.exceptions import ValidationError
 from django.db import models
 from django.utils.encoding import smart_unicode
+from django.utils import simplejson
 
 
 class JSONField(models.TextField):
diff --git a/src/social_auth/management/__init__.py b/src/social_auth/management/__init__.py
index e69de29bb2..c3961685ab 100644
--- a/src/social_auth/management/__init__.py
+++ b/src/social_auth/management/__init__.py
@@ -0,0 +1 @@
+from __future__ import absolute_import
diff --git a/src/social_auth/management/commands/__init__.py b/src/social_auth/management/commands/__init__.py
index e69de29bb2..c3961685ab 100644
--- a/src/social_auth/management/commands/__init__.py
+++ b/src/social_auth/management/commands/__init__.py
@@ -0,0 +1 @@
+from __future__ import absolute_import
diff --git a/src/social_auth/management/commands/clean_associations.py b/src/social_auth/management/commands/clean_associations.py
deleted file mode 100644
index bc0ab338e7..0000000000
--- a/src/social_auth/management/commands/clean_associations.py
+++ /dev/null
@@ -1,32 +0,0 @@
-import time
-import base64
-
-from openid.server.server import Signatory
-from openid.association import Association as OIDAssociation
-
-from django.core.management.base import BaseCommand
-
-
-class Command(BaseCommand):
-    help = 'Clear expired Associations instances from db'
-
-    def handle(self, *args, **options):
-        from social_auth.models import Association
-        print 'Clearing expired Association instances'
-        timestamp = time.time() + Signatory.SECRET_LIFETIME
-        associations = Association.objects.filter(issued__lt=timestamp)
-        remove = []
-
-        for assoc in associations:
-            oid = OIDAssociation(assoc.handle,
-                                 base64.decodestring(assoc.secret),
-                                 assoc.issued,
-                                 assoc.lifetime,
-                                 assoc.assoc_type)
-            if oid.getExpiresIn() == 0:
-                remove.append(assoc.pk)
-        if remove:
-            print 'Cleaning %s Associations' % len(remove)
-            Association.filter(pk__in=remove).delete()
-        else:
-            print 'No Associations to remove'
diff --git a/src/social_auth/management/commands/clean_nonces.py b/src/social_auth/management/commands/clean_nonces.py
deleted file mode 100644
index 751d825b8c..0000000000
--- a/src/social_auth/management/commands/clean_nonces.py
+++ /dev/null
@@ -1,20 +0,0 @@
-import time
-
-from openid.store.nonce import SKEW
-
-from django.core.management.base import BaseCommand
-
-
-class Command(BaseCommand):
-    help = 'Clear expired Nonce instances from db'
-
-    def handle(self, *args, **options):
-        from social_auth.models import Nonce
-        print 'Clearing expired Nonce instances'
-        qs = Nonce.objects.filter(timestamp__lt=(time.time() + SKEW))
-        count = qs.count()
-        if count > 0:
-            print 'Cleaning %s Nonces' % qs.count()
-            qs.delete()
-        else:
-            print 'No Nonces to remove'
diff --git a/src/social_auth/middleware.py b/src/social_auth/middleware.py
index 6ad33e70a4..67052db9ab 100644
--- a/src/social_auth/middleware.py
+++ b/src/social_auth/middleware.py
@@ -1,4 +1,6 @@
 # -*- coding: utf-8 -*-
+from __future__ import absolute_import
+
 from django.conf import settings
 from django.contrib.messages.api import error, MessageFailure
 from django.shortcuts import redirect
@@ -40,21 +42,23 @@ class SocialAuthExceptionMiddleware(object):
 
     def get_backend(self, request, exception):
         if not hasattr(self, 'backend'):
-            self.backend = getattr(request, 'backend', None) or \
-                           getattr(exception, 'backend', None)
+            self.backend = (
+                getattr(request, 'backend', None)
+                or getattr(exception, 'backend', None)
+            )
         return self.backend
 
     def raise_exception(self, request, exception):
         backend = self.backend
-        return backend and \
-               backend_setting(backend, 'SOCIAL_AUTH_RAISE_EXCEPTIONS')
+        return backend and backend_setting(backend, 'SOCIAL_AUTH_RAISE_EXCEPTIONS')
 
     def get_message(self, request, exception):
         return unicode(exception)
 
     def get_redirect_uri(self, request, exception):
         if self.backend is not None:
-            return backend_setting(self.backend,
-                                   'SOCIAL_AUTH_BACKEND_ERROR_URL') or \
-                                   settings.LOGIN_ERROR_URL
+            return (
+                backend_setting(self.backend, 'SOCIAL_AUTH_BACKEND_ERROR_URL')
+                or settings.LOGIN_ERROR_URL
+            )
         return settings.LOGIN_ERROR_URL
diff --git a/src/social_auth/models.py b/src/social_auth/models.py
index 63ea81b103..6c42c4eb22 100644
--- a/src/social_auth/models.py
+++ b/src/social_auth/models.py
@@ -1,4 +1,5 @@
-import base64
+from __future__ import absolute_import
+
 import time
 import re
 
@@ -6,7 +7,6 @@ from datetime import datetime, timedelta
 from django.conf import settings
 from django.db import models
 from django.db.models.loading import get_model
-from openid.association import Association as OIDAssociation
 
 from .fields import JSONField
 from .utils import setting
@@ -157,9 +157,7 @@ class UserSocialAuth(models.Model):
         TODO: consider how to ensure case-insensitive email matching
         """
         kwargs = cls.username_field(kwargs)
-        # Use count() > 0 since mongoengine doesn't support .exists(),
-        # Check issue #728
-        return cls.user_model().objects.filter(*args, **kwargs).count() > 0
+        return cls.user_model().objects.filter(*args, **kwargs).exists()
 
     @classmethod
     def create_user(cls, *args, **kwargs):
@@ -196,59 +194,6 @@ class UserSocialAuth(models.Model):
             uid = str(uid)
         return cls.objects.create(user=user, uid=uid, provider=provider)
 
-    @classmethod
-    def store_association(cls, server_url, association):
-        from social_auth.models import Association
-        args = {'server_url': server_url, 'handle': association.handle}
-        try:
-            assoc = Association.objects.get(**args)
-        except Association.DoesNotExist:
-            assoc = Association(**args)
-        assoc.secret = base64.encodestring(association.secret)
-        assoc.issued = association.issued
-        assoc.lifetime = association.lifetime
-        assoc.assoc_type = association.assoc_type
-        assoc.save()
-
-    @classmethod
-    def remove_association(cls, server_url, handle):
-        from social_auth.models import Association
-        assocs = list(Association.objects.filter(
-            server_url=server_url, handle=handle))
-        assocs_exist = len(assocs) > 0
-        for assoc in assocs:
-            assoc.delete()
-        return assocs_exist
-
-    @classmethod
-    def get_oid_associations(cls, server_url, handle=None):
-        from social_auth.models import Association
-        args = {'server_url': server_url}
-        if handle is not None:
-            args['handle'] = handle
-
-        return sorted([
-            (assoc.id, OIDAssociation(
-                assoc.handle,
-                base64.decodestring(assoc.secret),
-                assoc.issued,
-                assoc.lifetime,
-                assoc.assoc_type))
-            for assoc in Association.objects.filter(**args)
-        ], key=lambda x: x[1].issued, reverse=True)
-
-    @classmethod
-    def delete_associations(cls, ids_to_delete):
-        from social_auth.models import Association
-        Association.objects.filter(pk__in=ids_to_delete).delete()
-
-    @classmethod
-    def use_nonce(cls, server_url, timestamp, salt):
-        from social_auth.models import Nonce
-        return Nonce.objects.get_or_create(server_url=server_url,
-                                           timestamp=timestamp,
-                                           salt=salt)[1]
-
     @classmethod
     def get_social_auth(cls, provider, uid):
         try:
@@ -274,36 +219,3 @@ class UserSocialAuth(models.Model):
     @classmethod
     def user_model(cls):
         return get_model(*AUTH_USER_MODEL.split('.'))
-
-
-class Nonce(models.Model):
-    """One use numbers"""
-    server_url = models.CharField(max_length=NONCE_SERVER_URL_LENGTH)
-    timestamp = models.IntegerField(db_index=True)
-    salt = models.CharField(max_length=40)
-
-    class Meta:
-        app_label = 'social_auth'
-        unique_together = ('server_url', 'timestamp', 'salt')
-
-    def __unicode__(self):
-        """Unicode representation"""
-        return self.server_url
-
-
-class Association(models.Model):
-    """OpenId account association"""
-    server_url = models.CharField(max_length=ASSOCIATION_SERVER_URL_LENGTH)
-    handle = models.CharField(max_length=ASSOCIATION_HANDLE_LENGTH)
-    secret = models.CharField(max_length=255)  # Stored base64 encoded
-    issued = models.IntegerField(db_index=True)
-    lifetime = models.IntegerField()
-    assoc_type = models.CharField(max_length=64)
-
-    class Meta:
-        app_label = 'social_auth'
-        unique_together = ('server_url', 'handle')
-
-    def __unicode__(self):
-        """Unicode representation"""
-        return '%s %s' % (self.handle, self.issued)
diff --git a/src/social_auth/signals.py b/src/social_auth/signals.py
deleted file mode 100644
index fea9b82008..0000000000
--- a/src/social_auth/signals.py
+++ /dev/null
@@ -1,9 +0,0 @@
-from django.dispatch import Signal
-
-
-# This module is deprecated, this signals aren't used by the code anymore
-# and it's functionality should be replaced by pipeline methods.
-
-
-pre_update = Signal(providing_args=['user', 'response', 'details'])
-socialauth_registered = Signal(providing_args=['user', 'response', 'details'])
diff --git a/src/social_auth/migrations/0001_initial.py b/src/social_auth/south_migrations/0001_initial.py
similarity index 100%
rename from src/social_auth/migrations/0001_initial.py
rename to src/social_auth/south_migrations/0001_initial.py
diff --git a/src/social_auth/migrations/0002_auto__add_unique_nonce_timestamp_salt_server_url__add_unique_associati.py b/src/social_auth/south_migrations/0002_auto__add_unique_nonce_timestamp_salt_server_url__add_unique_associati.py
similarity index 100%
rename from src/social_auth/migrations/0002_auto__add_unique_nonce_timestamp_salt_server_url__add_unique_associati.py
rename to src/social_auth/south_migrations/0002_auto__add_unique_nonce_timestamp_salt_server_url__add_unique_associati.py
diff --git a/src/social_auth/migrations/__init__.py b/src/social_auth/south_migrations/__init__.py
similarity index 100%
rename from src/social_auth/migrations/__init__.py
rename to src/social_auth/south_migrations/__init__.py
diff --git a/src/social_auth/store.py b/src/social_auth/store.py
deleted file mode 100644
index a872e14dbb..0000000000
--- a/src/social_auth/store.py
+++ /dev/null
@@ -1,44 +0,0 @@
-"""OpenId storage that saves to django models"""
-import time
-
-from openid.store.interface import OpenIDStore
-from openid.store.nonce import SKEW
-
-from social_auth.models import UserSocialAuth
-
-
-class DjangoOpenIDStore(OpenIDStore):
-    """Storage class"""
-    def __init__(self):
-        """Init method"""
-        super(DjangoOpenIDStore, self).__init__()
-        self.max_nonce_age = 6 * 60 * 60  # Six hours
-
-    def storeAssociation(self, server_url, association):
-        """Store new assocition if doesn't exist"""
-        UserSocialAuth.store_association(server_url, association)
-
-    def removeAssociation(self, server_url, handle):
-        return UserSocialAuth.remove_association(server_url, handle)
-
-    def getAssociation(self, server_url, handle=None):
-        """Return stored assocition"""
-        oid_associations = UserSocialAuth.get_oid_associations(server_url,
-                                                               handle)
-        associations = [association
-                        for assoc_id, association in oid_associations
-                        if association.getExpiresIn() > 0]
-        expired = [assoc_id for assoc_id, association in oid_associations
-                   if association.getExpiresIn() == 0]
-
-        if expired:  # clear expired associations
-            UserSocialAuth.delete_associations(expired)
-
-        if associations:  # return most recet association
-            return associations[0]
-
-    def useNonce(self, server_url, timestamp, salt):
-        """Generate one use number and return *if* it was created"""
-        if abs(timestamp - time.time()) > SKEW:
-            return False
-        return UserSocialAuth.use_nonce(server_url, timestamp, salt)
diff --git a/src/social_auth/strategy.py b/src/social_auth/strategy.py
index 3fba44e65f..421d3a4557 100644
--- a/src/social_auth/strategy.py
+++ b/src/social_auth/strategy.py
@@ -1,45 +1,12 @@
+from __future__ import absolute_import
+
 from social.strategies.django_strategy import DjangoStrategy
 
 
 class DSAStrategy(DjangoStrategy):
     settings_map = {
-        'AMAZON_SECRET': 'AMAZON_API_SECRET',
-        'AMAZON_KEY': 'AMAZON_APP_ID',
-        'AMAZON_SCOPE': 'AMAZON_EXTENDED_PERMISSIONS',
-        'ANGEL_KEY': 'ANGEL_CLIENT_ID',
-        'ANGEL_SECRET': 'ANGEL_CLIENT_SECRET',
-        'APPSFUEL_KEY': 'APPSFUEL_CLIENT_ID',
-        'APPSFUEL_SECRET': 'APPSFUEL_CLIENT_SECRET',
-        'BEHANCE_KEY': 'BEHANCE_CLIENT_ID',
-        'BEHANCE_SECRET': 'BEHANCE_CLIENT_SECRET',
-        'BEHANCE_SCOPE': 'BEHANCE_EXTENDED_PERMISSIONS',
         'BITBUCKET_KEY': 'BITBUCKET_CONSUMER_KEY',
         'BITBUCKET_SECRET': 'BITBUCKET_CONSUMER_SECRET',
-        'DAILYMOTION_KEY': 'DAILYMOTION_OAUTH2_KEY',
-        'DAILYMOTION_SECRET': 'DAILYMOTION_OAUTH2_SECRET',
-        'DISQUS_KEY': 'DISQUS_CLIENT_ID',
-        'DISQUS_SECRET': 'DISQUS_CLIENT_SECRET',
-        'DOUBAN_OAUTH2_KEY': 'DOUBAN2_CONSUMER_KEY',
-        'DOUBAN_OAUTH2_SECRET': 'DOUBAN2_CONSUMER_SECRET',
-        'DOUBAN_KEY': 'DOUBAN_CONSUMER_KEY',
-        'DOUBAN_KEY': 'DOUBAN_CONSUMER_SECRET',
-        'DROPBOX_KEY': 'DROPBOX_API_SECRET',
-        'DROPBOX_SECRET': 'DROPBOX_APP_ID',
-        'EVERNOTE_KEY': 'EVERNOTE_CONSUMER_KEY',
-        'EVERNOTE_SECRET': 'EVERNOTE_CONSUMER_SECRET',
-        'EXACTTARGET_SECRET': 'EXACTTARGET_APP_SIGNATURE',
-        'EXACTTARGET_KEY': 'EXACTTARGET_UNUSED',
-        'FACEBOOK_KEY': 'FACEBOOK_APP_ID',
-        'FACEBOOK_SECRET': 'FACEBOOK_API_SECRET',
-        'FACEBOOK_SCOPE': 'FACEBOOK_EXTENDED_PERMISSIONS',
-        'FACEBOOK_APP_KEY': 'FACEBOOK_APP_ID',
-        'FACEBOOK_APP_LOCAL_HTML': 'FACEBOOK_LOCAL_HTML',
-        'FITBIT_KEY': 'FITBIT_CONSUMER_KEY',
-        'FITBIT_SECRET': 'FITBIT_CONSUMER_SECRET',
-        'FLICKR_SECRET': 'FLICKR_API_SECRET',
-        'FLICKR_KEY': 'FLICKR_APP_ID',
-        'FOURSQUARE_KEY': 'FOURSQUARE_CONSUMER_KEY',
-        'FOURSQUARE_SECRET': 'FOURSQUARE_CONSUMER_SECRET',
         'GITHUB_SECRET': 'GITHUB_API_SECRET',
         'GITHUB_KEY': 'GITHUB_APP_ID',
         'GITHUB_SCOPE': 'GITHUB_EXTENDED_PERMISSIONS',
@@ -49,83 +16,8 @@ class DSAStrategy(DjangoStrategy):
         'GOOGLE_OAUTH2_KEY': 'GOOGLE_OAUTH2_CLIENT_KEY',
         'GOOGLE_OAUTH2_SECRET': 'GOOGLE_OAUTH2_CLIENT_SECRET',
         'GOOGLE_OAUTH2_SCOPE': 'GOOGLE_OAUTH_EXTRA_SCOPE',
-        'INSTAGRAM_KEY': 'INSTAGRAM_CLIENT_ID',
-        'INSTAGRAM_SECRET': 'INSTAGRAM_CLIENT_SECRET',
-        'JAWBONE_KEY': 'JAWBONE_CONSUMER_KEY',
-        'JAWBONE_SECRET': 'JAWBONE_CONSUMER_SECRET',
-        'JAWBONE_SCOPE': 'JAWBONE_EXTENDED_PERMISSIONS',
-        'LINKEDIN_KEY': 'LINKEDIN_CONSUMER_KEY',
-        'LINKEDIN_SECRET': 'LINKEDIN_CONSUMER_SECRET',
-        'LINKEDIN_FIELDS_SELECTORS': 'LINKEDIN_EXTRA_FIELD_SELECTORS',
-        'LINKEDIN_OAUTH2_KEY': 'LINKEDIN_CONSUMER_KEY',
-        'LINKEDIN_OAUTH2_SECRET': 'LINKEDIN_CONSUMER_SECRET',
-        'LINKEDIN_OAUTH2_FIELDS_SELECTORS': 'LINKEDIN_EXTRA_FIELD_SELECTORS',
-        'LINKEDIN_OAUTH2_SCOPE': 'LINKEDIN_SCOPE',
-        'LIVE_KEY': 'LIVE_CLIENT_ID',
-        'LIVE_SECRET': 'LIVE_CLIENT_SECRET',
-        'LIVE_SCOPE': 'LIVE_EXTENDED_PERMISSIONS',
-        'MAILRU_OAUTH2_KEY': 'MAILRU_OAUTH2_CLIENT_KEY',
-        'MAILRU_OAUTH2_SECRET': 'MAILRU_OAUTH2_CLIENT_SECRET',
-        'MAILRU_OAUTH2_SCOPE': 'MAILRU_OAUTH2_EXTRA_SCOPE',
-        'MENDELEY_KEY': 'MENDELEY_CONSUMER_KEY',
-        'MENDELEY_SECRET': 'MENDELEY_CONSUMER_SECRET',
-        'MIXCLOUD_KEY': 'MIXCLOUD_CLIENT_ID',
-        'MIXCLOUD_SECRET': 'MIXCLOUD_CLIENT_SECRET',
-        'ODNOKLASSNIKI_OAUTH2_KEY': 'ODNOKLASSNIKI_OAUTH2_CLIENT_KEY',
-        'ODNOKLASSNIKI_OAUTH2_SECRET': 'ODNOKLASSNIKI_OAUTH2_CLIENT_SECRET',
-        'ODNOKLASSNIKI_OAUTH2_SCOPE': 'ODNOKLASSNIKI_OAUTH2_EXTRA_SCOPE',
-        'ORKUT_KEY': 'ORKUT_CONSUMER_KEY',
-        'ORKUT_SECRET': 'ORKUT_CONSUMER_SECRET',
-        'RDIO_OAUTH2_SCOPE': 'RDIO2_PERMISSIONS',
-        'READABILITY_KEY': 'READABILITY_CONSUMER_KEY',
-        'READABILITY_SECRET': 'READABILITY_CONSUMER_SECRET',
-        'REDDIT_SECRET': 'REDDIT_API_SECRET',
-        'REDDIT_KEY': 'REDDIT_APP_ID',
-        'REDDIT_SCOPE': 'REDDIT_EXTENDED_PERMISSIONS',
-        'SHOPIFY_KEY': 'SHOPIFY_APP_API_KEY',
-        'SHOPIFY_SECRET': 'SHOPIFY_SHARED_SECRET',
-        'SKYROCK_KEY': 'SKYROCK_CONSUMER_KEY',
-        'SKYROCK_SECRET': 'SKYROCK_CONSUMER_SECRET',
-        'SOUNDCLOUD_KEY': 'SOUNDCLOUD_CLIENT_ID',
-        'SOUNDCLOUD_SECRET': 'SOUNDCLOUD_CLIENT_SECRET',
-        'SOUNDCLOUD_SCOPE': 'SOUNDCLOUD_EXTENDED_PERMISSIONS',
-        'STACKOVERFLOW_KEY': 'STACKOVERFLOW_CLIENT_ID',
-        'STACKOVERFLOW_SECRET': 'STACKOVERFLOW_CLIENT_SECRET',
-        'STACKOVERFLOW_SCOPE': 'STACKOVERFLOW_EXTENDED_PERMISSIONS',
-        'STOCKTWITS_KEY': 'STOCKTWITS_CONSUMER_KEY',
-        'STOCKTWITS_SECRET': 'STOCKTWITS_CONSUMER_SECRET',
-        'STRIPE_KEY': 'STRIPE_APP_ID',
-        'STRIPE_SECRET': 'STRIPE_APP_SECRET',
         'TRELLO_KEY': 'TRELLO_CONSUMER_KEY',
         'TRELLO_SECRET': 'TRELLO_CONSUMER_SECRET',
-        'TRIPIT_KEY': 'TRIPIT_API_KEY',
-        'TRIPIT_SECRET': 'TRIPIT_API_SECRET',
-        'TUMBLR_KEY': 'TUMBLR_CONSUMER_KEY',
-        'TUMBLR_SECRET': 'TUMBLR_CONSUMER_SECRET',
-        'TWILIO_SECRET': 'TWILIO_AUTH_TOKEN',
-        'TWILIO_KEY': 'TWILIO_CONNECT_KEY',
-        'TWITTER_KEY': 'TWITTER_CONSUMER_KEY',
-        'TWITTER_SECRET': 'TWITTER_CONSUMER_SECRET',
-        'VK_APP_SECRET': 'VKAPP_API_SECRET',
-        'VK_APP_KEY': 'VKAPP_APP_ID',
-        'VK_APP_USERMODE': 'VKAPP_USER_MODE',
-        'VK_OAUTH2_EXTRA_DATA': 'VK_EXTRA_DATA',
-        'VK_OAUTH2_SCOPE': 'VK_EXTRA_SCOPE',
-        'VK_OAUTH2_SECRET': 'VK_API_SECRET',
-        'VK_OPENAPI_LOCAL_HTML': 'VK_LOCAL_HTML',
-        'VK_OPENAPI_APP_ID': 'VK_APP_ID',
-        'WEIBO_KEY': 'WEIBO_CLIENT_KEY',
-        'WEIBO_SECRET': 'WEIBO_CLIENT_SECRET',
-        'XING_KEY': 'XING_CONSUMER_KEY',
-        'XING_SECRET': 'XING_CONSUMER_SECRET',
-        'YAHOO_KEY': 'YAHOO_CONSUMER_KEY',
-        'YAHOO_SECRET': 'YAHOO_CONSUMER_SECRET',
-        'YAMMER_KEY': 'YAMMER_CONSUMER_KEY',
-        'YAMMER_SECRET': 'YAMMER_CONSUMER_SECRET',
-        'YAMMER_STAGING_KEY': 'YAMMER_STAGING_CONSUMER_KEY',
-        'YAMMER_STAGING_SECRET': 'YAMMER_STAGING_CONSUMER_SECRET',
-        'YANDEX_SECRET': 'YANDEX_API_SECRET',
-        'YANDEX_KEY': 'YANDEX_APP_ID',
         'ON_HTTPS': 'SOCIAL_AUTH_REDIRECT_IS_HTTPS',
     }
 
diff --git a/src/social_auth/tests/__init__.py b/src/social_auth/tests/__init__.py
deleted file mode 100644
index 969a45ce76..0000000000
--- a/src/social_auth/tests/__init__.py
+++ /dev/null
@@ -1,14 +0,0 @@
-from social_auth.utils import setting
-
-
-if setting('SOCIAL_AUTH_TEST_TWITTER', True):
-    from social_auth.tests.twitter import *
-
-if setting('SOCIAL_AUTH_TEST_FACEBOOK', True):
-    from social_auth.tests.facebook import *
-
-if setting('SOCIAL_AUTH_TEST_GOOGLE', True):
-    from social_auth.tests.google import *
-
-if setting('SOCIAL_AUTH_TEST_ODNOKLASSNIKI', True):
-    from social_auth.tests.odnoklassniki import *
\ No newline at end of file
diff --git a/src/social_auth/tests/base.py b/src/social_auth/tests/base.py
deleted file mode 100644
index f5bed808a3..0000000000
--- a/src/social_auth/tests/base.py
+++ /dev/null
@@ -1,175 +0,0 @@
-import re
-import urllib2
-import cookielib
-import urllib
-import urlparse
-import unittest
-from sgmllib import SGMLParser
-from django.conf import settings
-
-from django.test.client import Client
-from django.core.urlresolvers import reverse
-
-
-USER_AGENT = 'Mozilla/5.0'
-REFRESH_RE = re.compile(r'\d;\s*url=')
-
-
-class SocialAuthTestsCase(unittest.TestCase):
-    """Base class for social auth tests"""
-    SERVER_NAME = None
-    SERVER_PORT = None
-
-    def __init__(self, *args, **kwargs):
-        client_kwargs = {}
-        if self.SERVER_NAME:
-            client_kwargs['SERVER_NAME'] = self.SERVER_NAME
-        if self.SERVER_PORT:
-            client_kwargs['SERVER_PORT'] = self.SERVER_PORT
-        self.jar = None
-        self.client = Client(**client_kwargs)
-        super(SocialAuthTestsCase, self).__init__(*args, **kwargs)
-
-    def setUp(self):
-        from social_auth import backends
-        self.old_PIPELINE = backends.PIPELINE
-        backends.PIPELINE = (
-                'social_auth.backends.pipeline.social.social_auth_user',
-                'social_auth.backends.pipeline.associate.associate_by_email',
-                'social_auth.backends.pipeline.user.get_username',
-                'social_auth.backends.pipeline.user.create_user',
-                'social_auth.backends.pipeline.social.associate_user',
-                'social_auth.backends.pipeline.social.load_extra_data',
-                'social_auth.backends.pipeline.user.update_user_details',
-                )
-        super(SocialAuthTestsCase, self).setUp()
-
-    def tearDown(self):
-        from social_auth import backends
-        backends.PIPELINE = self.old_PIPELINE
-        super(SocialAuthTestsCase, self).tearDown()
-
-    def test_backend_cache(self):
-        """Ensure that the backend for the testcase gets cached."""
-        try:
-            self.name
-        except AttributeError:
-            pass
-        else:
-            if self.name not in settings.SOCIAL_AUTH_ENABLED_BACKENDS:
-                # this backend is not enabled (for example, google-openid/google-oauth2)
-                return
-            from social_auth import backends
-            backends.BACKENDS = {}
-            self.client.get(self.reverse('socialauth_begin', self.name))
-            self.assertTrue(self.name in backends.BACKENDSCACHE)
-
-    def get_content(self, url, data=None, use_cookies=False):
-        """Return content for given url, if data is not None, then a POST
-        request will be issued, otherwise GET will be used"""
-        data = data and urllib.urlencode(data, doseq=True) or data
-        request = urllib2.Request(url)
-        agent = urllib2.build_opener()
-
-        if use_cookies:
-            agent.add_handler(urllib2.HTTPCookieProcessor(self.get_jar()))
-        request.add_header('User-Agent', USER_AGENT)
-        return ''.join(agent.open(request, data=data).readlines())
-
-    def get_redirect(self, url, data=None, use_cookies=False):
-        """Return content for given url, if data is not None, then a POST
-        request will be issued, otherwise GET will be used"""
-        data = data and urllib.urlencode(data, doseq=True) or data
-        request = urllib2.Request(url)
-        agent = urllib2.build_opener(RedirectHandler())
-
-        if use_cookies:
-            agent.add_handler(urllib2.HTTPCookieProcessor(self.get_jar()))
-        request.add_header('User-Agent', USER_AGENT)
-        return agent.open(request, data=data)
-
-    def get_jar(self):
-        if not self.jar:
-            self.jar = cookielib.CookieJar()
-        return self.jar
-
-    def reverse(self, name, backend):
-        """Reverses backend URL by name"""
-        return reverse(name, args=(backend,))
-
-    def make_relative(self, value):
-        """Converst URL to relative, useful for server responses"""
-        parsed = urlparse.urlparse(value)
-        return urlparse.urlunparse(('', '', parsed.path, parsed.params,
-                                    parsed.query, parsed.fragment))
-
-
-class CustomParser(SGMLParser):
-    """Custom SGMLParser that closes the parser once it's fed"""
-    def feed(self, data):
-        SGMLParser.feed(self, data)
-        self.close()
-
-
-class FormParser(CustomParser):
-    """Form parser, load form data and action for given form"""
-    def __init__(self, *args, **kwargs):
-        CustomParser.__init__(self, *args, **kwargs)
-        self.inside_form = False
-        self.action = None
-        self.values = {}
-
-    def start_form(self, attributes):
-        """Start form parsing detecting if form is the one requested"""
-        attrs = dict(attributes)
-        if self.in_form(attrs):
-            # flag that we are inside the form and save action
-            self.inside_form = True
-            self.action = attrs.get('action')
-
-    def in_form(self, attrs):
-        """Override below"""
-        return True
-
-    def end_form(self):
-        """End form parsing, unset inside_form flag"""
-        self.inside_form = False
-
-    def start_input(self, attributes):
-        """Parse input fields, we only keep data for fields of type text,
-        hidden or password and that has a valid name."""
-        attrs = dict(attributes)
-        if self.inside_form:
-            type, name, value = attrs.get('type'), attrs.get('name'), \
-                                attrs.get('value')
-            if name and type in ('text', 'hidden', 'password'):
-                self.values[name] = value
-
-
-class FormParserByID(FormParser):
-    """Form parser, load form data and action for given form identified
-    by its id"""
-    def __init__(self, form_id, *args, **kwargs):
-        FormParser.__init__(self, *args, **kwargs)
-        self.form_id = form_id
-
-    def in_form(self, attrs):
-        return attrs.get('id') == self.form_id
-
-
-class RefreshParser(CustomParser):
-    """Refresh parser, will check refresh by meta tag and store refresh URL"""
-    def __init__(self, *args, **kwargs):
-        CustomParser.__init__(self, *args, **kwargs)
-        self.value = None
-
-    def start_meta(self, attributes):
-        """Start meta parsing checking by http-equiv attribute"""
-        attrs = dict(attributes)
-        if attrs.get('http-equiv') == 'refresh':
-            self.value = REFRESH_RE.sub('', attrs.get('content')).strip("'")
-
-
-class RedirectHandler(urllib2.HTTPRedirectHandler):
-    def http_error_302(self, req, fp, code, msg, headers):
-        return fp
diff --git a/src/social_auth/tests/client.py b/src/social_auth/tests/client.py
deleted file mode 100644
index dad02048de..0000000000
--- a/src/social_auth/tests/client.py
+++ /dev/null
@@ -1,169 +0,0 @@
-import urllib
-
-try:
-    import json as simplejson
-except ImportError:
-    try:
-        import simplejson
-    except ImportError:
-        from django.utils import simplejson
-
-from django.conf import settings
-from django.contrib.auth.models import AnonymousUser
-from django.test.client import Client, RequestFactory
-from django.utils.importlib import import_module
-from mock import patch
-from social_auth.views import complete
-
-class DumbResponse(object):
-    """
-    Response from a call to, urllib2.urlopen()
-    """
-
-    def __init__(self, data_str, url=None):
-        self.data_str = data_str
-        self.url = url
-
-    def read(self):
-        return self.data_str
-
-
-class NoBackendError(Exception):
-    """
-    Used when a client attempts to login with a invalid backend.
-    """
-    pass
-
-
-class SocialClient(Client):
-    """
-    Test client to login/register a user
-    Does so by mocking api posts/responses.
-
-    Only supports facebook.
-    """
-
-    @patch('social_auth.backends.facebook.FacebookAuth.enabled')
-    @patch('social_auth.utils.urlopen')
-    def login(self, user, mock_urlopen, mock_facebook_enabled, backend='facebook'):
-        """
-        Login or Register a facebook user.
-
-        If the user has never logged in then they get registered and logged in.
-        If the user has already registered, then they are logged in.
-
-        user: dict
-        backend: 'facebook'
-
-        example user:
-        {
-            'first_name': 'Django',
-            'last_name': 'Reinhardt',
-            'verified': True,
-            'name': 'Django Reinhardt',
-            'locale': 'en_US',
-            'hometown': {
-                'id': '12345678',
-                'name': 'Any Town, Any State'
-            },
-            'expires': '4812',
-            'updated_time': '2012-01-29T19:27:32+0000',
-            'access_token': 'dummyToken',
-            'link': 'http://www.facebook.com/profile.php?id=1234',
-            'location': {
-                'id': '108659242498155',
-                'name': 'Chicago, Illinois'
-            },
-            'gender': 'male',
-            'timezone': -6,
-            'id': '1234',
-            'email': 'user@domain.com'
-        }
-        """
-
-        token = 'dummyToken'
-        backends = {
-            'facebook': (
-                urllib.urlencode({
-                    'access_token': token,
-                    'expires': 3600,
-                }),
-                simplejson.dumps(user),
-            ),
-
-            'google': (
-                simplejson.dumps({
-                    "access_token": token,
-                    "token_type": "Bearer",
-                    "expires_in": 3600,
-                }),
-                simplejson.dumps(user),
-            ),
-
-            'linkedin': (
-                urllib.urlencode({
-                    'oauth_token': token,
-                    'oauth_token_secret': token,
-                    'oauth_callback_confirmed': 'true',
-                    'xoauth_request_auth_url': (
-                        'https://api.linkedin.com/uas/oauth/authorize'),
-                    'oauth_expires_in': 3600,
-                }),
-                urllib.urlencode({
-                    'oauth_token': token,
-                    'oauth_token_secret': token,
-                    'oauth_expires_in': 3600,
-                    'oauth_authorization_expires_in': 3600,
-                }),
-                (('<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n'
-                  '<person>\n'
-                  '  <id>{id}</id>\n'
-                  '  <email-address>{email}</email-address>\n'
-                  '  <first-name>{first_name}</first-name>\n'
-                  '  <last-name>{last_name}</last-name>\n'
-                  '</person>\n').format(**user)),
-            ),
-        }
-
-        if backend not in backends:
-            raise NoBackendError("%s is not supported" % backend)
-
-        """
-        mock out urlopen
-        """
-        mock_urlopen.side_effect = [
-            DumbResponse(r) for r in backends[backend]
-        ]
-        # make it work when no FACEBOOK_APP_ID declared
-        mock_facebook_enabled.return_value = True
-        factory = RequestFactory()
-        request = factory.post('', {'code': 'dummy',
-            'redirect_state': 'dummy'})
-
-        engine = import_module(settings.SESSION_ENGINE)
-        if self.session:
-            request.session = self.session
-        else:
-            request.session = engine.SessionStore()
-
-        request.user = AnonymousUser()
-        request.session['facebook_state'] = 'dummy'
-
-        # make it happen.
-        redirect = complete(request, backend)
-
-        request.session.save()
-
-        # Set the cookie for this session.
-        session_cookie = settings.SESSION_COOKIE_NAME
-        self.cookies[session_cookie] = request.session.session_key
-        cookie_data = {
-            'max-age': None,
-            'path': '/',
-            'domain': settings.SESSION_COOKIE_DOMAIN,
-            'secure': settings.SESSION_COOKIE_SECURE or None,
-            'expires': None,
-        }
-        self.cookies[session_cookie].update(cookie_data)
-
-        return True
diff --git a/src/social_auth/tests/facebook.py b/src/social_auth/tests/facebook.py
deleted file mode 100644
index cf76adc7ed..0000000000
--- a/src/social_auth/tests/facebook.py
+++ /dev/null
@@ -1,88 +0,0 @@
-import re
-
-from unittest import skip
-
-from social_auth.utils import setting
-from social_auth.tests.base import SocialAuthTestsCase, FormParserByID
-from django.contrib.sites.models import Site
-
-
-class FacebookTestCase(SocialAuthTestsCase):
-    SERVER_NAME = 'myapp.com'
-    SERVER_PORT = '8000'
-
-    def __init__(self, methodName='runTest'):
-        super(FacebookTestCase, self).__init__(methodName)
-
-    name = 'facebook'
-
-    def setUp(self, *args, **kwargs):
-        self.SERVER_NAME = Site.objects.get_current()
-        super(FacebookTestCase, self).setUp(*args, **kwargs)
-        self.user = setting('TEST_FACEBOOK_USER')
-        self.passwd = setting('TEST_FACEBOOK_PASSWORD')
-        # check that user and password are setup properly
-        # Ugh, these fail too.
-        #self.assertTrue(self.user)
-        #self.assertTrue(self.passwd)
-
-
-REDIRECT_RE = re.compile('window.location.replace\("(.*)"\);')
-
-class FacebookTestLogin(FacebookTestCase):
-    @skip("FacebookTestCase.setUp() is broken")
-    def test_login_succeful(self):
-        """
-
-        """
-        response = self.client.get('http://%s%s' % (self.SERVER_NAME, self.reverse('socialauth_begin', 'facebook')))
-        # social_auth must redirect to service page
-        self.assertEqual(response.status_code, 302)
-
-        # Open first redirect page, it contains user login form because
-        # we don't have cookie to send to twitter
-        parser = FormParserByID('login_form')
-        content = self.get_content(response['Location'], use_cookies=True)
-        parser.feed(content)
-        auth = {'email': self.user,
-                'pass': self.passwd}
-
-        # Check that action and values were loaded properly
-        self.assertTrue(parser.action)
-        self.assertTrue(parser.values)
-
-        # Post login form, will return authorization or redirect page
-        parser.values.update(auth)
-        redirect = self.get_redirect(parser.action, parser.values,
-                                   use_cookies=True)
-        # If page contains a form#login_form, then we are in the app
-        # authorization page because the app is not authorized yet,
-        # otherwise the app already gained permission and twitter sends
-        # a page that redirects to redirect_url
-        if 'login_form' in content:
-            # authorization form post, returns redirect_page
-            parser = FormParserByID('login_form')
-            parser.feed(content)
-            self.assertTrue(parser.action)
-            self.assertTrue(parser.values)
-            parser.values.update(auth)
-            redirect = self.get_redirect(parser.action, parser.values,
-                                             use_cookies=True)
-            redirect_page = redirect.read()
-        else:
-            redirect = self.get_redirect(redirect.headers['Location'],
-                use_cookies=True)
-            redirect_page = redirect.read()
-
-        if 'uiserver_form' in redirect_page:
-            # authorization form post, returns redirect_page
-            parser = FormParserByID('uiserver_form')
-            parser.feed(redirect_page)
-            self.assertTrue(parser.action)
-            self.assertTrue(parser.values)
-            parser.values.update(auth)
-            redirect = self.get_redirect(parser.action, parser.values,
-                use_cookies=True)
-
-
-        self.assertTrue(setting('LOGIN_REDIRECT_URL') in self.make_relative(redirect.headers['Location']))
diff --git a/src/social_auth/tests/google.py b/src/social_auth/tests/google.py
deleted file mode 100644
index 91258f1890..0000000000
--- a/src/social_auth/tests/google.py
+++ /dev/null
@@ -1,82 +0,0 @@
-import re
-
-from unittest import expectedFailure, skip
-
-from social_auth.utils import setting
-from social_auth.tests.base import SocialAuthTestsCase, FormParserByID, \
-                                   FormParser, RefreshParser
-from django.conf import settings
-
-class GoogleTestCase(SocialAuthTestsCase):
-
-    name = 'google'
-
-    def setUp(self, *args, **kwargs):
-        super(GoogleTestCase, self).setUp(*args, **kwargs)
-        self.user = setting('TEST_GOOGLE_USER')
-        self.passwd = setting('TEST_GOOGLE_PASSWORD')
-        # check that user and password are setup properly
-        # These fail.
-        #self.assertTrue(self.user)
-        #self.assertTrue(self.passwd)
-
-
-REDIRECT_RE = re.compile('window.location.replace\("(.*)"\);')
-
-
-class GoogleOpenIdTestLogin(GoogleTestCase):
-    SERVER_NAME = 'myapp.com'
-    SERVER_PORT = '8000'
-
-    @skip("GoogleTestCase.setUp() is broken")
-    def test_login_succeful(self):
-        if self.name not in settings.SOCIAL_AUTH_ENABLED_BACKENDS:
-            self.skipTest('Google OpenID is not enabled')
-        response = self.client.get(self.reverse('socialauth_begin', 'google'))
-
-        parser = FormParserByID('openid_message')
-        parser.feed(response.content)
-        # Check that action and values were loaded properly
-        self.assertTrue(parser.action)
-        self.assertTrue(parser.values)
-        content = self.get_content(parser.action, parser.values,
-                                   use_cookies=True)
-
-        parser = FormParserByID('gaia_loginform')
-        parser.feed(content)
-        auth = {'Email': self.user, 'Passwd': self.passwd}
-        parser.values.update(auth)
-        # Check that action and values were loaded properly
-        self.assertTrue(parser.action)
-        self.assertTrue(parser.values)
-
-        content = self.get_content(parser.action, parser.values,
-                                   use_cookies=True)
-        parser = RefreshParser()
-        parser.feed(content)
-
-        # approved?
-        result = self.get_redirect(parser.value, use_cookies=True)
-        if result.headers.get('Location', ''):  # approved?
-            # damn, google has a hell of redirects :-(
-            result = self.get_redirect(result.headers['Location'],
-                                       use_cookies=True)
-            result = self.get_redirect(result.headers['Location'],
-                                       use_cookies=True)
-            result = self.get_redirect(result.headers['Location'],
-                                       use_cookies=True)
-
-        # app was not approved
-        if self.SERVER_NAME not in result.headers.get('Location', ''):
-            content = self.get_content(parser.value, use_cookies=True)
-            parser = FormParser()
-            parser.feed(content)
-            parser.values['submit_true'] = 'yes'
-            parser.values['remember_choices'] = 'yes'
-            result = self.get_redirect(parser.action, parser.values,
-                                       use_cookies=True)
-
-        response = self.client.get(self.make_relative(
-                                            result.headers['Location']))
-        self.assertTrue(setting('LOGIN_REDIRECT_URL') in \
-                            self.make_relative(response['Location']))
diff --git a/src/social_auth/tests/odnoklassniki.py b/src/social_auth/tests/odnoklassniki.py
deleted file mode 100644
index 82d2abde8a..0000000000
--- a/src/social_auth/tests/odnoklassniki.py
+++ /dev/null
@@ -1,154 +0,0 @@
-# -*- coding:utf-8 -*-
-from __future__ import unicode_literals
-from unittest import skipUnless
-from django.conf import settings
-from django.core.urlresolvers import reverse
-from django.test.testcases import LiveServerTestCase, SimpleTestCase
-from django.test.utils import override_settings
-from selenium.webdriver.firefox.webdriver import WebDriver
-from selenium.webdriver.support.ui import WebDriverWait
-from social_auth.backends.contrib.odnoklassniki import odnoklassniki_oauth_sig
-from social_auth.models import UserSocialAuth
-import time
-        
-class SignatureTest(SimpleTestCase):
-    def test_oauth_signature(self):
-        data = {'access_token': 'cq240efje3pd0gdXUmrvvMaHyb-74XQi8',
-                'application_key': 'CBAJLNABABABABABA',
-                'method': 'users.getCurrentUser',
-                'format': 'JSON'}
-        secret = '31D6095131175A7C9656EC2C'
-        signature = '755fe7af274abbe545916039eb428c98'
-        self.assertEqual(odnoklassniki_oauth_sig(data, secret), signature)
-
-class OdnoklassnikiLiveTest(LiveServerTestCase):
-    @classmethod
-    def setUpClass(cls):
-        cls.selenium = WebDriver()
-        super(OdnoklassnikiLiveTest, cls).setUpClass()
-
-    @classmethod
-    def tearDownClass(cls):
-        super(OdnoklassnikiLiveTest, cls).tearDownClass()
-        cls.selenium.quit()
-        
-    def get_odnoklassniki_name(self):
-        raise NotImplementedError('This method is part of interface, but should be implemented in subclass')
-
-class BaseOdnoklassnikiAppTest(OdnoklassnikiLiveTest):
-    @skipUnless(hasattr(settings, 'ODNOKLASSNIKI_APP_ID'), 
-                "You need to have ODNOKLASSNIKI_APP_ID in settings to test iframe app")
-    @skipUnless(hasattr(settings, 'ODNOKLASSNIKI_SANDBOX_DEV_USERNAME'),
-                "You need to have ODNOKLASSNIKI_SANDBOX_DEV_USERNAME in settings to test iframe app")
-    @skipUnless(hasattr(settings, 'ODNOKLASSNIKI_SANDBOX_DEV_PASSWORD'),
-                "You need to have ODNOKLASSNIKI_SANDBOX_DEV_PASSWORD in settings to test iframe app")
-    def setUp(self):
-        self.app_id = settings.ODNOKLASSNIKI_APP_ID
-        self.dev_username = settings.ODNOKLASSNIKI_SANDBOX_DEV_USERNAME
-        self.dev_password = settings.ODNOKLASSNIKI_SANDBOX_DEV_PASSWORD
-        self.get_odnoklassniki_name()
-        
-    def sandbox_login(self):
-        WebDriverWait(self.selenium, 3).until(lambda ff: ff.find_element_by_name('j_username'))
-        dev_username_input = self.selenium.find_element_by_name('j_username')
-        dev_username_input.send_keys(self.dev_username)
-        dev_password_input = self.selenium.find_element_by_name('j_password')
-        dev_password_input.send_keys(self.dev_password)
-        self.selenium.find_element_by_name('actionId').click()
-        
-    def sandbox_logout(self):
-        self.selenium.get('http://api-sandbox.odnoklassniki.ru:8088/sandbox/logout.do')
-        WebDriverWait(self.selenium, 3).until(lambda ff: ff.find_element_by_name('j_username'))
-        
-    def get_odnoklassniki_name(self):
-        self.selenium.get('http://api-sandbox.odnoklassniki.ru:8088/sandbox/protected/main.do')
-        self.sandbox_login()
-        WebDriverWait(self.selenium, 3).until(lambda ff: ff.find_element_by_tag_name('fieldset'))
-        self.odnoklassniki_name = self.selenium.find_element_by_xpath('//*[@id="command"]/fieldset/table/tbody/tr[2]/td[2]').text
-        self.sandbox_logout()
-        
-    def login_into_sandbox(self):
-        self.selenium.get('http://api-sandbox.odnoklassniki.ru:8088/sandbox/protected/application/launch.do?appId={0:s}&userId=0'.format(self.app_id))
-        self.sandbox_login()
-        WebDriverWait(self.selenium, 3).until(lambda ff: ff.find_element_by_tag_name('iframe'))
-        time.sleep(1)
-        
-class OdnoklassnikiAppTest(BaseOdnoklassnikiAppTest):
-    def test_auth(self):
-        self.login_into_sandbox()
-        self.assertEquals(UserSocialAuth.objects.count(), 1)
-        social_auth = UserSocialAuth.objects.get()
-        user = social_auth.user
-        full_name = '{0} {1}'.format(user.first_name, user.last_name) 
-        self.assertEquals(full_name, self.odnoklassniki_name)
-        self.assertTrue('apiconnection' in social_auth.extra_data)
-        self.assertTrue('api_server' in social_auth.extra_data)
-        
-class OdnoklassnikiAppTestExtraData(BaseOdnoklassnikiAppTest):
-    @override_settings(ODNOKLASSNIKI_APP_EXTRA_USER_DATA_LIST = ('gender', 'birthday', 'age'))        
-    def test_extra_data(self):
-        self.login_into_sandbox()
-        self.assertEquals(UserSocialAuth.objects.count(), 1)
-        social_user = UserSocialAuth.objects.get()
-        user = social_user.user
-        full_name = '{0} {1}'.format(user.first_name, user.last_name) 
-        self.assertEquals(full_name, self.odnoklassniki_name)
-        self.assertTrue(all([field in social_user.extra_data for field in ('gender', 'birthday', 'age')]))
-
-class OdnoklassnikiOAuthTest(OdnoklassnikiLiveTest):
-    @skipUnless(hasattr(settings, "ODNOKLASSNIKI_OAUTH2_CLIENT_KEY"),
-                "You need to have ODNOKLASSNIKI_OAUTH2_CLIENT_KEY in settings to test odnoklassniki OAuth")
-    @skipUnless(hasattr(settings, "ODNOKLASSNIKI_TEST_USERNAME"),
-                "You need to have ODNOKLASSNIKI_TEST_USERNAME in settings to test odnoklassniki OAuth")
-    @skipUnless(hasattr(settings, "ODNOKLASSNIKI_TEST_PASSWORD"),
-                "You need to have ODNOKLASSNIKI_TEST_PASSWORD in settings to test odnoklassniki OAuth")
-    def setUp(self):
-        self.username = settings.ODNOKLASSNIKI_TEST_USERNAME
-        self.password = settings.ODNOKLASSNIKI_TEST_PASSWORD
-        self.get_odnoklassniki_name()
-    
-    def get_odnoklassniki_name(self):
-        #Load login page
-        self.selenium.get('http://www.odnoklassniki.ru/')
-        WebDriverWait(self.selenium, 3).until(lambda ff: ff.find_element_by_id('field_email'))
-        email_input = self.selenium.find_element_by_id('field_email')
-        email_input.send_keys(self.username)
-        pw_input = self.selenium.find_element_by_id('field_password')
-        pw_input.send_keys(self.password)
-        self.selenium.find_element_by_id('hook_FormButton_button_go').click()
-        #Submit form, wait for successful login
-        name_css_sel = '#hook_Block_MiddleColumnTopCardUser .mctc_name>a.mctc_nameLink'
-        WebDriverWait(self.selenium, 2).until(lambda ff: ff.find_element_by_css_selector(name_css_sel))
-        self.odnoklassniki_name = self.selenium.find_element_by_css_selector(name_css_sel).text
-        #Remember the name of logged user
-        link = [el for el in self.selenium.find_elements_by_css_selector('.portal-headline__login__link') if el.text == '–≤—ã—Ö–æ–¥']
-        self.assertTrue(len(link) == 1)
-        link[0].click()
-        #Click on logout link to show logout popup
-        WebDriverWait(self.selenium, 2).until(lambda ff: ff.find_element_by_id('hook_Form_PopLayerLogoffUserForm') and ff.find_element_by_id('hook_Form_PopLayerLogoffUserForm').is_displayed())
-        self.selenium.find_element_by_css_selector('#hook_FormButton_button_logoff').click()
-        #Click logout popup and wait for the login form be shown
-        WebDriverWait(self.selenium, 2).until(lambda ff: ff.find_element_by_id('field_email'))
-        
-    def login_into_odnoklassniki(self):
-        url = reverse('socialauth_begin', args=('odnoklassniki',))
-        self.selenium.get('{0:s}{1:s}'.format(self.live_server_url, url))
-        WebDriverWait(self.selenium, 2).until(lambda ff: ff.find_element_by_id('field_email'))
-        email_input = self.selenium.find_element_by_id('field_email')
-        pw_input = self.selenium.find_element_by_id('field_password')
-        email_input.send_keys(self.username)
-        pw_input.send_keys(self.password)
-        self.selenium.find_element_by_name('button_continue').click()
-        WebDriverWait(self.selenium, 2).until(lambda ff: ff.find_element_by_name('button_accept_request'))
-        self.selenium.find_element_by_name('button_accept_request').click()
-        self.selenium.implicitly_wait(2)
-        time.sleep(1)#We need this for the server to close database connection
-        #If this line is removed, following line will fail
-
-    def test_auth(self):
-        self.login_into_odnoklassniki()
-        self.assertEquals(UserSocialAuth.objects.count(), 1)
-        user = UserSocialAuth.objects.get().user
-        full_name = '{0} {1}'.format(user.first_name, user.last_name) 
-        self.assertEquals(full_name, self.odnoklassniki_name)
-
diff --git a/src/social_auth/tests/twitter.py b/src/social_auth/tests/twitter.py
deleted file mode 100644
index 1176901af1..0000000000
--- a/src/social_auth/tests/twitter.py
+++ /dev/null
@@ -1,79 +0,0 @@
-from unittest import expectedFailure, skip
-
-from social_auth.utils import setting
-from social_auth.tests.base import SocialAuthTestsCase, FormParserByID, \
-                                   RefreshParser
-from django.test.utils import override_settings
-
-
-class TwitterTestCase(SocialAuthTestsCase):
-
-    name = 'twitter'
-
-    def setUp(self, *args, **kwargs):
-        super(TwitterTestCase, self).setUp(*args, **kwargs)
-        self.user = setting('TEST_TWITTER_USER')
-        self.passwd = setting('TEST_TWITTER_PASSWORD')
-        # check that user and password are setup properly
-        # These fail spectacularly, and it's annoying to
-        # have asserts in setUp() anyway, especially in
-        # classes that are inherited.
-        #self.assertTrue(self.user)
-        #self.assertTrue(self.passwd)
-
-
-class TwitterTestLogin(TwitterTestCase):
-    @skip("TwitterTestCase.setUp() is broken")
-    @override_settings(SOCIAL_AUTH_PIPELINE = (
-        'social_auth.backends.pipeline.social.social_auth_user',
-        'social_auth.backends.pipeline.associate.associate_by_email',
-        'social_auth.backends.pipeline.user.get_username',
-        'social_auth.backends.pipeline.misc.save_status_to_session',
-        'social_auth.backends.pipeline.social.associate_user',
-        'social_auth.backends.pipeline.social.load_extra_data',
-        'social_auth.backends.pipeline.user.update_user_details',
-        ))
-    def test_login_successful(self):
-        response = self.client.get(self.reverse('socialauth_begin', 'twitter'))
-        # social_auth must redirect to service page
-        self.assertEqual(response.status_code, 302)
-
-        # Open first redirect page, it contains user login form because
-        # we don't have cookie to send to twitter
-        login_content = self.get_content(response['Location'])
-        parser = FormParserByID('oauth_form')
-        parser.feed(login_content)
-        auth = {'session[username_or_email]': self.user,
-                'session[password]': self.passwd}
-
-        # Check that action and values were loaded properly
-        self.assertTrue(parser.action)
-        self.assertTrue(parser.values)
-
-        # Post login form, will return authorization or redirect page
-        parser.values.update(auth)
-        content = self.get_content(parser.action, data=parser.values)
-
-        # If page contains a form#login_form, then we are in the app
-        # authorization page because the app is not authorized yet,
-        # otherwise the app already gained permission and twitter sends
-        # a page that redirects to redirect_url
-        if 'login_form' in content:
-            # authorization form post, returns redirect_page
-            parser = FormParserByID('login_form').feed(content)
-            self.assertTrue(parser.action)
-            self.assertTrue(parser.values)
-            parser.values.update(auth)
-            redirect_page = self.get_content(parser.action, data=parser.values)
-        else:
-            redirect_page = content
-
-        parser = RefreshParser()
-        parser.feed(redirect_page)
-        self.assertTrue(parser.value)
-
-        response = self.client.get(self.make_relative(parser.value))
-        self.assertEqual(response.status_code, 302)
-        location = self.make_relative(response['Location'])
-        login_redirect = setting('LOGIN_REDIRECT_URL')
-        self.assertTrue(location == login_redirect)
diff --git a/src/social_auth/urls.py b/src/social_auth/urls.py
index dabaae072c..67653b9a2f 100644
--- a/src/social_auth/urls.py
+++ b/src/social_auth/urls.py
@@ -1,25 +1,18 @@
-"""URLs module"""
-try: 
-    from django.conf.urls import patterns, url 
-except ImportError: 
+from __future__ import absolute_import
+
+try:
+    from django.conf.urls import patterns, url
+except ImportError:
     # for Django version less then 1.4
     from django.conf.urls.defaults import patterns, url
-    
+
 from social_auth.views import auth, complete, disconnect
 
 
 urlpatterns = patterns('',
     # authentication
-    url(r'^login/(?P<backend>[^/]+)/$', auth,
-        name='socialauth_begin'),
-    url(r'^complete/(?P<backend>[^/]+)/$', complete,
-        name='socialauth_complete'),
-
-    # XXX: Deprecated, this URLs are deprecated, instead use the login and
-    #      complete ones directly, they will differentiate the user intention
-    #      by checking it's authenticated status association.
     url(r'^associate/(?P<backend>[^/]+)/$', auth,
-        name='socialauth_associate_begin'),
+        name='socialauth_associate'),
     url(r'^associate/complete/(?P<backend>[^/]+)/$', complete,
         name='socialauth_associate_complete'),
 
diff --git a/src/social_auth/utils.py b/src/social_auth/utils.py
index 07e551d714..85b459882a 100644
--- a/src/social_auth/utils.py
+++ b/src/social_auth/utils.py
@@ -1,18 +1,18 @@
+from __future__ import absolute_import
+
 import random
 import urlparse
 import urllib
 import logging
-from urllib2 import urlopen
-from cgi import parse_qsl
 
+from cgi import parse_qsl
 from collections import defaultdict
-
 from django.conf import settings
 from django.db.models import Model
 from django.contrib.contenttypes.models import ContentType
-from django.utils.functional import SimpleLazyObject
+from django.utils.functional import empty, SimpleLazyObject
 from django.utils.importlib import import_module
-
+from urllib2 import urlopen
 
 try:
     random = random.SystemRandom()
@@ -21,9 +21,6 @@ except NotImplementedError:
     using_sysrandom = False
 
 
-from django.utils.functional import empty
-
-
 LEAVE_CHARS = getattr(settings, 'SOCIAL_AUTH_LOG_SANITIZE_LEAVE_CHARS', 4)
 
 
@@ -87,16 +84,14 @@ def group_backend_by_type(items, key=lambda x: x):
 
     # Beware of cyclical imports!
     from social_auth.backends import \
-        get_backends, OpenIdAuth, BaseOAuth, BaseOAuth2
+        get_backends, BaseOAuth, BaseOAuth2
 
     result = defaultdict(list)
     backends = get_backends()
 
     for item in items:
         backend = backends[key(item)]
-        if issubclass(backend, OpenIdAuth):
-            result['openid'].append(item)
-        elif issubclass(backend, BaseOAuth2):
+        if issubclass(backend, BaseOAuth2):
             result['oauth2'].append(item)
         elif issubclass(backend, BaseOAuth):
             result['oauth'].append(item)
diff --git a/src/social_auth/views.py b/src/social_auth/views.py
index 2a9986e91f..b1518b90b9 100644
--- a/src/social_auth/views.py
+++ b/src/social_auth/views.py
@@ -5,13 +5,14 @@ Notes:
       on third party providers that (if using POST) won't be sending csrf
       token back.
 """
-from urllib2 import quote
+from __future__ import absolute_import
 
 from django.http import HttpResponseRedirect, HttpResponse
 from django.contrib.auth import login, REDIRECT_FIELD_NAME
 from django.contrib.auth.decorators import login_required
 from django.contrib import messages
 from django.views.decorators.csrf import csrf_exempt
+from urllib2 import quote
 
 from social_auth.utils import (
     sanitize_redirect, setting, backend_setting, clean_partial_pipeline)
@@ -24,7 +25,7 @@ LOGIN_ERROR_URL = setting('LOGIN_ERROR_URL', setting('LOGIN_URL'))
 PIPELINE_KEY = setting('SOCIAL_AUTH_PARTIAL_PIPELINE_KEY', 'partial_pipeline')
 
 
-@dsa_view(setting('SOCIAL_AUTH_COMPLETE_URL_NAME', 'socialauth_complete'))
+@dsa_view(setting('SOCIAL_AUTH_COMPLETE_URL_NAME', 'socialauth_associate_complete'))
 def auth(request, backend):
     """Start authentication process"""
     return auth_process(request, backend)
